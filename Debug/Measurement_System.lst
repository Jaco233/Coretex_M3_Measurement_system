
Measurement_System:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .init         00000470  00000000  60000000  00008000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         00023e30  00000470  60000470  00008470  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .ARM.exidx    00000008  20000000  600242a0  00030000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .data         000005e4  20000008  600242a8  00030008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          0000c6d4  200005ec  6002488c  000305ec  2**2
                  ALLOC
  5 .comment      00000637  00000000  00000000  000305ec  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 000013a0  00000000  00000000  00030c23  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 00002e4e  00000000  00000000  00031fc3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   0001bd6a  00000000  00000000  00034e11  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 0000390c  00000000  00000000  00050b7b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   0000d7cf  00000000  00000000  00054487  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00004c1c  00000000  00000000  00061c58  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00008606  00000000  00000000  00066874  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00006c5a  00000000  00000000  0006ee7a  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_macinfo 000ef06f  00000000  00000000  00075ad4  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .ARM.attributes 00000025  00000000  00000000  00164b43  2**0
                  CONTENTS, READONLY
 16 .debug_ranges 000012f0  00000000  00000000  00164b68  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .init:

00000000 <__vector_table_vma_base_address>:
   0:	20010000 	.word	0x20010000
   4:	00000299 	.word	0x00000299
   8:	00000309 	.word	0x00000309
   c:	0000030b 	.word	0x0000030b
  10:	0000030d 	.word	0x0000030d
  14:	0000030f 	.word	0x0000030f
  18:	00000311 	.word	0x00000311
	...
  2c:	000140c1 	.word	0x000140c1
  30:	00000315 	.word	0x00000315
  34:	00000000 	.word	0x00000000
  38:	00014351 	.word	0x00014351
  3c:	000143a1 	.word	0x000143a1
  40:	0000031b 	.word	0x0000031b
  44:	00009e91 	.word	0x00009e91
  48:	0000031f 	.word	0x0000031f
  4c:	00000321 	.word	0x00000321
  50:	00000323 	.word	0x00000323
  54:	0000565d 	.word	0x0000565d
  58:	00000327 	.word	0x00000327
  5c:	00000329 	.word	0x00000329
  60:	0000032b 	.word	0x0000032b
  64:	0000032d 	.word	0x0000032d
  68:	0000275d 	.word	0x0000275d
  6c:	00002789 	.word	0x00002789
  70:	00000333 	.word	0x00000333
  74:	00000335 	.word	0x00000335
  78:	00003fbd 	.word	0x00003fbd
  7c:	00000339 	.word	0x00000339
  80:	0000033b 	.word	0x0000033b
  84:	00003fe9 	.word	0x00003fe9
  88:	0000033f 	.word	0x0000033f
  8c:	00000341 	.word	0x00000341
  90:	00000343 	.word	0x00000343
  94:	00000345 	.word	0x00000345
  98:	00000347 	.word	0x00000347
  9c:	00000349 	.word	0x00000349
  a0:	0000034b 	.word	0x0000034b
	...
  bc:	0000034d 	.word	0x0000034d
  c0:	0000034f 	.word	0x0000034f
  c4:	00000351 	.word	0x00000351
  c8:	00000353 	.word	0x00000353
  cc:	00000355 	.word	0x00000355
  d0:	00000357 	.word	0x00000357
  d4:	00000359 	.word	0x00000359
  d8:	0000035b 	.word	0x0000035b
  dc:	0000035d 	.word	0x0000035d
  e0:	00000a51 	.word	0x00000a51
  e4:	00000361 	.word	0x00000361
  e8:	00000363 	.word	0x00000363
  ec:	00000365 	.word	0x00000365
  f0:	00000367 	.word	0x00000367
  f4:	00000369 	.word	0x00000369
  f8:	0000036b 	.word	0x0000036b
  fc:	0000036d 	.word	0x0000036d
 100:	0000036f 	.word	0x0000036f
 104:	00000371 	.word	0x00000371
 108:	00000373 	.word	0x00000373
 10c:	00000375 	.word	0x00000375
 110:	00000377 	.word	0x00000377
 114:	00000379 	.word	0x00000379
 118:	0000037b 	.word	0x0000037b
 11c:	0000037d 	.word	0x0000037d
 120:	0000037f 	.word	0x0000037f
 124:	00000381 	.word	0x00000381
 128:	00000383 	.word	0x00000383
 12c:	00000385 	.word	0x00000385
 130:	00000387 	.word	0x00000387
 134:	00000389 	.word	0x00000389
 138:	0000038b 	.word	0x0000038b
 13c:	0000038d 	.word	0x0000038d
 140:	0000038f 	.word	0x0000038f
 144:	00000391 	.word	0x00000391
 148:	00000393 	.word	0x00000393
 14c:	00000395 	.word	0x00000395
 150:	00000397 	.word	0x00000397
 154:	00000399 	.word	0x00000399
 158:	0000039b 	.word	0x0000039b
 15c:	0000039d 	.word	0x0000039d
 160:	0000039f 	.word	0x0000039f
 164:	000003a1 	.word	0x000003a1
 168:	000003a3 	.word	0x000003a3
 16c:	000003a5 	.word	0x000003a5
 170:	000003a7 	.word	0x000003a7
 174:	000003a9 	.word	0x000003a9
 178:	000003ab 	.word	0x000003ab
 17c:	000003ad 	.word	0x000003ad
 180:	000003af 	.word	0x000003af
 184:	000003b1 	.word	0x000003b1
 188:	000003b3 	.word	0x000003b3
 18c:	000003b5 	.word	0x000003b5
 190:	000003b7 	.word	0x000003b7
 194:	000003b9 	.word	0x000003b9
 198:	000003bb 	.word	0x000003bb
 19c:	000003bd 	.word	0x000003bd
 1a0:	000003bf 	.word	0x000003bf
 1a4:	000003c1 	.word	0x000003c1
 1a8:	000003c3 	.word	0x000003c3
 1ac:	000003c5 	.word	0x000003c5
 1b0:	000003c7 	.word	0x000003c7
 1b4:	000003c9 	.word	0x000003c9
 1b8:	000003cb 	.word	0x000003cb
 1bc:	000003cd 	.word	0x000003cd
 1c0:	000003cf 	.word	0x000003cf
 1c4:	000003d1 	.word	0x000003d1
 1c8:	000003d3 	.word	0x000003d3
 1cc:	000003d5 	.word	0x000003d5
 1d0:	000003d7 	.word	0x000003d7
 1d4:	000003d9 	.word	0x000003d9
 1d8:	000003db 	.word	0x000003db
 1dc:	000003dd 	.word	0x000003dd
 1e0:	000003df 	.word	0x000003df
 1e4:	000003e1 	.word	0x000003e1
 1e8:	000003e3 	.word	0x000003e3
 1ec:	000003e5 	.word	0x000003e5
 1f0:	000003e7 	.word	0x000003e7
 1f4:	000003e9 	.word	0x000003e9
 1f8:	000003eb 	.word	0x000003eb
 1fc:	000003ed 	.word	0x000003ed
 200:	000003ef 	.word	0x000003ef
 204:	000003f1 	.word	0x000003f1
 208:	000003f3 	.word	0x000003f3
 20c:	000003f5 	.word	0x000003f5
 210:	000003f7 	.word	0x000003f7
 214:	000003f9 	.word	0x000003f9
 218:	00007e5d 	.word	0x00007e5d
 21c:	00007e85 	.word	0x00007e85
 220:	00007ead 	.word	0x00007ead
 224:	00007ed5 	.word	0x00007ed5
 228:	00007efd 	.word	0x00007efd
 22c:	00007f25 	.word	0x00007f25
 230:	00007f4d 	.word	0x00007f4d
 234:	00007f75 	.word	0x00007f75
 238:	00007f9d 	.word	0x00007f9d
 23c:	00007fc5 	.word	0x00007fc5
 240:	00007fed 	.word	0x00007fed
 244:	00008015 	.word	0x00008015
 248:	0000803d 	.word	0x0000803d
 24c:	00008065 	.word	0x00008065
 250:	0000808d 	.word	0x0000808d
 254:	000080b5 	.word	0x000080b5
 258:	000080dd 	.word	0x000080dd
 25c:	00008105 	.word	0x00008105
 260:	0000812d 	.word	0x0000812d
 264:	00008155 	.word	0x00008155
 268:	0000817d 	.word	0x0000817d
 26c:	000081a5 	.word	0x000081a5
 270:	000081cd 	.word	0x000081cd
 274:	000081f5 	.word	0x000081f5
 278:	0000821d 	.word	0x0000821d
 27c:	00008245 	.word	0x00008245
 280:	0000826d 	.word	0x0000826d
 284:	00008295 	.word	0x00008295
 288:	000082bd 	.word	0x000082bd
 28c:	000082e5 	.word	0x000082e5
 290:	0000830d 	.word	0x0000830d
 294:	00008335 	.word	0x00008335

00000298 <Reset_Handler>:
 298:	4868      	ldr	r0, [pc, #416]	; (43c <ACE_ADC2_FifoEmpty_IRQHandler+0x44>)
 29a:	4780      	blx	r0
 29c:	4868      	ldr	r0, [pc, #416]	; (440 <ACE_ADC2_FifoEmpty_IRQHandler+0x48>)
 29e:	2800      	cmp	r0, #0
 2a0:	d10b      	bne.n	2ba <copy_data>
 2a2:	4868      	ldr	r0, [pc, #416]	; (444 <ACE_ADC2_FifoEmpty_IRQHandler+0x4c>)
 2a4:	4968      	ldr	r1, [pc, #416]	; (448 <ACE_ADC2_FifoEmpty_IRQHandler+0x50>)
 2a6:	4a69      	ldr	r2, [pc, #420]	; (44c <ACE_ADC2_FifoEmpty_IRQHandler+0x54>)
 2a8:	4288      	cmp	r0, r1
 2aa:	d006      	beq.n	2ba <copy_data>

000002ac <copy_code_loop>:
 2ac:	4291      	cmp	r1, r2
 2ae:	bf1c      	itt	ne
 2b0:	f850 3b04 	ldrne.w	r3, [r0], #4
 2b4:	f841 3b04 	strne.w	r3, [r1], #4
 2b8:	d1f8      	bne.n	2ac <copy_code_loop>

000002ba <copy_data>:
 2ba:	4865      	ldr	r0, [pc, #404]	; (450 <ACE_ADC2_FifoEmpty_IRQHandler+0x58>)
 2bc:	4965      	ldr	r1, [pc, #404]	; (454 <ACE_ADC2_FifoEmpty_IRQHandler+0x5c>)
 2be:	4a66      	ldr	r2, [pc, #408]	; (458 <ACE_ADC2_FifoEmpty_IRQHandler+0x60>)
 2c0:	4288      	cmp	r0, r1
 2c2:	d006      	beq.n	2d2 <clear_bss>

000002c4 <copy_data_loop>:
 2c4:	4291      	cmp	r1, r2
 2c6:	bf1c      	itt	ne
 2c8:	f850 3b04 	ldrne.w	r3, [r0], #4
 2cc:	f841 3b04 	strne.w	r3, [r1], #4
 2d0:	d1f8      	bne.n	2c4 <copy_data_loop>

000002d2 <clear_bss>:
 2d2:	4862      	ldr	r0, [pc, #392]	; (45c <ACE_ADC2_FifoEmpty_IRQHandler+0x64>)
 2d4:	4962      	ldr	r1, [pc, #392]	; (460 <ACE_ADC2_FifoEmpty_IRQHandler+0x68>)
 2d6:	4a63      	ldr	r2, [pc, #396]	; (464 <ACE_ADC2_FifoEmpty_IRQHandler+0x6c>)

000002d8 <clear_bss_loop>:
 2d8:	4291      	cmp	r1, r2
 2da:	bf18      	it	ne
 2dc:	f841 0b04 	strne.w	r0, [r1], #4
 2e0:	d1fa      	bne.n	2d8 <clear_bss_loop>
	...

000002f0 <call_glob_ctor>:
 2f0:	f8df 0174 	ldr.w	r0, [pc, #372]	; 468 <ACE_ADC2_FifoEmpty_IRQHandler+0x70>
 2f4:	f20f 0e03 	addw	lr, pc, #3
 2f8:	4700      	bx	r0

000002fa <branch_to_main>:
 2fa:	f04f 0000 	mov.w	r0, #0
 2fe:	f04f 0100 	mov.w	r1, #0
 302:	f8df f168 	ldr.w	pc, [pc, #360]	; 46c <ACE_ADC2_FifoEmpty_IRQHandler+0x74>

00000306 <ExitLoop>:
 306:	e7fe      	b.n	306 <ExitLoop>

00000308 <NMI_Handler>:
 308:	e7fe      	b.n	308 <NMI_Handler>

0000030a <HardFault_Handler>:
 30a:	e7fe      	b.n	30a <HardFault_Handler>

0000030c <MemManage_Handler>:
 30c:	e7fe      	b.n	30c <MemManage_Handler>

0000030e <BusFault_Handler>:
 30e:	e7fe      	b.n	30e <BusFault_Handler>

00000310 <UsageFault_Handler>:
 310:	e7fe      	b.n	310 <UsageFault_Handler>
 312:	e7fe      	b.n	312 <UsageFault_Handler+0x2>

00000314 <DebugMon_Handler>:
 314:	e7fe      	b.n	314 <DebugMon_Handler>
 316:	e7fe      	b.n	316 <DebugMon_Handler+0x2>
 318:	e7fe      	b.n	318 <DebugMon_Handler+0x4>

0000031a <WdogWakeup_IRQHandler>:
 31a:	e7fe      	b.n	31a <WdogWakeup_IRQHandler>
 31c:	e7fe      	b.n	31c <WdogWakeup_IRQHandler+0x2>

0000031e <BrownOut_3_3V_IRQHandler>:
 31e:	e7fe      	b.n	31e <BrownOut_3_3V_IRQHandler>

00000320 <RTC_Match_IRQHandler>:
 320:	e7fe      	b.n	320 <RTC_Match_IRQHandler>

00000322 <RTCIF_Pub_IRQHandler>:
 322:	e7fe      	b.n	322 <RTCIF_Pub_IRQHandler>
 324:	e7fe      	b.n	324 <RTCIF_Pub_IRQHandler+0x2>

00000326 <IAP_IRQHandler>:
 326:	e7fe      	b.n	326 <IAP_IRQHandler>

00000328 <ENVM0_IRQHandler>:
 328:	e7fe      	b.n	328 <ENVM0_IRQHandler>

0000032a <ENVM1_IRQHandler>:
 32a:	e7fe      	b.n	32a <ENVM1_IRQHandler>

0000032c <DMA_IRQHandler>:
 32c:	e7fe      	b.n	32c <DMA_IRQHandler>
 32e:	e7fe      	b.n	32e <DMA_IRQHandler+0x2>
 330:	e7fe      	b.n	330 <DMA_IRQHandler+0x4>

00000332 <SPI0_IRQHandler>:
 332:	e7fe      	b.n	332 <SPI0_IRQHandler>

00000334 <SPI1_IRQHandler>:
 334:	e7fe      	b.n	334 <SPI1_IRQHandler>
 336:	e7fe      	b.n	336 <SPI1_IRQHandler+0x2>

00000338 <I2C0_SMBAlert_IRQHandler>:
 338:	e7fe      	b.n	338 <I2C0_SMBAlert_IRQHandler>

0000033a <I2C0_SMBus_IRQHandler>:
 33a:	e7fe      	b.n	33a <I2C0_SMBus_IRQHandler>
 33c:	e7fe      	b.n	33c <I2C0_SMBus_IRQHandler+0x2>

0000033e <I2C1_SMBAlert_IRQHandler>:
 33e:	e7fe      	b.n	33e <I2C1_SMBAlert_IRQHandler>

00000340 <I2C1_SMBus_IRQHandler>:
 340:	e7fe      	b.n	340 <I2C1_SMBus_IRQHandler>

00000342 <Timer1_IRQHandler>:
 342:	e7fe      	b.n	342 <Timer1_IRQHandler>

00000344 <Timer2_IRQHandler>:
 344:	e7fe      	b.n	344 <Timer2_IRQHandler>

00000346 <PLL_Lock_IRQHandler>:
 346:	e7fe      	b.n	346 <PLL_Lock_IRQHandler>

00000348 <PLL_LockLost_IRQHandler>:
 348:	e7fe      	b.n	348 <PLL_LockLost_IRQHandler>

0000034a <CommError_IRQHandler>:
 34a:	e7fe      	b.n	34a <CommError_IRQHandler>

0000034c <Fabric_IRQHandler>:
 34c:	e7fe      	b.n	34c <Fabric_IRQHandler>

0000034e <GPIO0_IRQHandler>:
 34e:	e7fe      	b.n	34e <GPIO0_IRQHandler>

00000350 <GPIO1_IRQHandler>:
 350:	e7fe      	b.n	350 <GPIO1_IRQHandler>

00000352 <GPIO2_IRQHandler>:
 352:	e7fe      	b.n	352 <GPIO2_IRQHandler>

00000354 <GPIO3_IRQHandler>:
 354:	e7fe      	b.n	354 <GPIO3_IRQHandler>

00000356 <GPIO4_IRQHandler>:
 356:	e7fe      	b.n	356 <GPIO4_IRQHandler>

00000358 <GPIO5_IRQHandler>:
 358:	e7fe      	b.n	358 <GPIO5_IRQHandler>

0000035a <GPIO6_IRQHandler>:
 35a:	e7fe      	b.n	35a <GPIO6_IRQHandler>

0000035c <GPIO7_IRQHandler>:
 35c:	e7fe      	b.n	35c <GPIO7_IRQHandler>
 35e:	e7fe      	b.n	35e <GPIO7_IRQHandler+0x2>

00000360 <GPIO9_IRQHandler>:
 360:	e7fe      	b.n	360 <GPIO9_IRQHandler>

00000362 <GPIO10_IRQHandler>:
 362:	e7fe      	b.n	362 <GPIO10_IRQHandler>

00000364 <GPIO11_IRQHandler>:
 364:	e7fe      	b.n	364 <GPIO11_IRQHandler>

00000366 <GPIO12_IRQHandler>:
 366:	e7fe      	b.n	366 <GPIO12_IRQHandler>

00000368 <GPIO13_IRQHandler>:
 368:	e7fe      	b.n	368 <GPIO13_IRQHandler>

0000036a <GPIO14_IRQHandler>:
 36a:	e7fe      	b.n	36a <GPIO14_IRQHandler>

0000036c <GPIO15_IRQHandler>:
 36c:	e7fe      	b.n	36c <GPIO15_IRQHandler>

0000036e <GPIO16_IRQHandler>:
 36e:	e7fe      	b.n	36e <GPIO16_IRQHandler>

00000370 <GPIO17_IRQHandler>:
 370:	e7fe      	b.n	370 <GPIO17_IRQHandler>

00000372 <GPIO18_IRQHandler>:
 372:	e7fe      	b.n	372 <GPIO18_IRQHandler>

00000374 <GPIO19_IRQHandler>:
 374:	e7fe      	b.n	374 <GPIO19_IRQHandler>

00000376 <GPIO20_IRQHandler>:
 376:	e7fe      	b.n	376 <GPIO20_IRQHandler>

00000378 <GPIO21_IRQHandler>:
 378:	e7fe      	b.n	378 <GPIO21_IRQHandler>

0000037a <GPIO22_IRQHandler>:
 37a:	e7fe      	b.n	37a <GPIO22_IRQHandler>

0000037c <GPIO23_IRQHandler>:
 37c:	e7fe      	b.n	37c <GPIO23_IRQHandler>

0000037e <GPIO24_IRQHandler>:
 37e:	e7fe      	b.n	37e <GPIO24_IRQHandler>

00000380 <GPIO25_IRQHandler>:
 380:	e7fe      	b.n	380 <GPIO25_IRQHandler>

00000382 <GPIO26_IRQHandler>:
 382:	e7fe      	b.n	382 <GPIO26_IRQHandler>

00000384 <GPIO27_IRQHandler>:
 384:	e7fe      	b.n	384 <GPIO27_IRQHandler>

00000386 <GPIO28_IRQHandler>:
 386:	e7fe      	b.n	386 <GPIO28_IRQHandler>

00000388 <GPIO29_IRQHandler>:
 388:	e7fe      	b.n	388 <GPIO29_IRQHandler>

0000038a <GPIO30_IRQHandler>:
 38a:	e7fe      	b.n	38a <GPIO30_IRQHandler>

0000038c <GPIO31_IRQHandler>:
 38c:	e7fe      	b.n	38c <GPIO31_IRQHandler>

0000038e <ACE_PC0_Flag0_IRQHandler>:
 38e:	e7fe      	b.n	38e <ACE_PC0_Flag0_IRQHandler>

00000390 <ACE_PC0_Flag1_IRQHandler>:
 390:	e7fe      	b.n	390 <ACE_PC0_Flag1_IRQHandler>

00000392 <ACE_PC0_Flag2_IRQHandler>:
 392:	e7fe      	b.n	392 <ACE_PC0_Flag2_IRQHandler>

00000394 <ACE_PC0_Flag3_IRQHandler>:
 394:	e7fe      	b.n	394 <ACE_PC0_Flag3_IRQHandler>

00000396 <ACE_PC1_Flag0_IRQHandler>:
 396:	e7fe      	b.n	396 <ACE_PC1_Flag0_IRQHandler>

00000398 <ACE_PC1_Flag1_IRQHandler>:
 398:	e7fe      	b.n	398 <ACE_PC1_Flag1_IRQHandler>

0000039a <ACE_PC1_Flag2_IRQHandler>:
 39a:	e7fe      	b.n	39a <ACE_PC1_Flag2_IRQHandler>

0000039c <ACE_PC1_Flag3_IRQHandler>:
 39c:	e7fe      	b.n	39c <ACE_PC1_Flag3_IRQHandler>

0000039e <ACE_PC2_Flag0_IRQHandler>:
 39e:	e7fe      	b.n	39e <ACE_PC2_Flag0_IRQHandler>

000003a0 <ACE_PC2_Flag1_IRQHandler>:
 3a0:	e7fe      	b.n	3a0 <ACE_PC2_Flag1_IRQHandler>

000003a2 <ACE_PC2_Flag2_IRQHandler>:
 3a2:	e7fe      	b.n	3a2 <ACE_PC2_Flag2_IRQHandler>

000003a4 <ACE_PC2_Flag3_IRQHandler>:
 3a4:	e7fe      	b.n	3a4 <ACE_PC2_Flag3_IRQHandler>

000003a6 <ACE_ADC0_DataValid_IRQHandler>:
 3a6:	e7fe      	b.n	3a6 <ACE_ADC0_DataValid_IRQHandler>

000003a8 <ACE_ADC1_DataValid_IRQHandler>:
 3a8:	e7fe      	b.n	3a8 <ACE_ADC1_DataValid_IRQHandler>

000003aa <ACE_ADC2_DataValid_IRQHandler>:
 3aa:	e7fe      	b.n	3aa <ACE_ADC2_DataValid_IRQHandler>

000003ac <ACE_ADC0_CalDone_IRQHandler>:
 3ac:	e7fe      	b.n	3ac <ACE_ADC0_CalDone_IRQHandler>

000003ae <ACE_ADC1_CalDone_IRQHandler>:
 3ae:	e7fe      	b.n	3ae <ACE_ADC1_CalDone_IRQHandler>

000003b0 <ACE_ADC2_CalDone_IRQHandler>:
 3b0:	e7fe      	b.n	3b0 <ACE_ADC2_CalDone_IRQHandler>

000003b2 <ACE_ADC0_CalStart_IRQHandler>:
 3b2:	e7fe      	b.n	3b2 <ACE_ADC0_CalStart_IRQHandler>

000003b4 <ACE_ADC1_CalStart_IRQHandler>:
 3b4:	e7fe      	b.n	3b4 <ACE_ADC1_CalStart_IRQHandler>

000003b6 <ACE_ADC2_CalStart_IRQHandler>:
 3b6:	e7fe      	b.n	3b6 <ACE_ADC2_CalStart_IRQHandler>

000003b8 <ACE_Comp0_Fall_IRQHandler>:
 3b8:	e7fe      	b.n	3b8 <ACE_Comp0_Fall_IRQHandler>

000003ba <ACE_Comp1_Fall_IRQHandler>:
 3ba:	e7fe      	b.n	3ba <ACE_Comp1_Fall_IRQHandler>

000003bc <ACE_Comp2_Fall_IRQHandler>:
 3bc:	e7fe      	b.n	3bc <ACE_Comp2_Fall_IRQHandler>

000003be <ACE_Comp3_Fall_IRQHandler>:
 3be:	e7fe      	b.n	3be <ACE_Comp3_Fall_IRQHandler>

000003c0 <ACE_Comp4_Fall_IRQHandler>:
 3c0:	e7fe      	b.n	3c0 <ACE_Comp4_Fall_IRQHandler>

000003c2 <ACE_Comp5_Fall_IRQHandler>:
 3c2:	e7fe      	b.n	3c2 <ACE_Comp5_Fall_IRQHandler>

000003c4 <ACE_Comp6_Fall_IRQHandler>:
 3c4:	e7fe      	b.n	3c4 <ACE_Comp6_Fall_IRQHandler>

000003c6 <ACE_Comp7_Fall_IRQHandler>:
 3c6:	e7fe      	b.n	3c6 <ACE_Comp7_Fall_IRQHandler>

000003c8 <ACE_Comp8_Fall_IRQHandler>:
 3c8:	e7fe      	b.n	3c8 <ACE_Comp8_Fall_IRQHandler>

000003ca <ACE_Comp9_Fall_IRQHandler>:
 3ca:	e7fe      	b.n	3ca <ACE_Comp9_Fall_IRQHandler>

000003cc <ACE_Comp10_Fall_IRQHandler>:
 3cc:	e7fe      	b.n	3cc <ACE_Comp10_Fall_IRQHandler>

000003ce <ACE_Comp11_Fall_IRQHandler>:
 3ce:	e7fe      	b.n	3ce <ACE_Comp11_Fall_IRQHandler>

000003d0 <ACE_Comp0_Rise_IRQHandler>:
 3d0:	e7fe      	b.n	3d0 <ACE_Comp0_Rise_IRQHandler>

000003d2 <ACE_Comp1_Rise_IRQHandler>:
 3d2:	e7fe      	b.n	3d2 <ACE_Comp1_Rise_IRQHandler>

000003d4 <ACE_Comp2_Rise_IRQHandler>:
 3d4:	e7fe      	b.n	3d4 <ACE_Comp2_Rise_IRQHandler>

000003d6 <ACE_Comp3_Rise_IRQHandler>:
 3d6:	e7fe      	b.n	3d6 <ACE_Comp3_Rise_IRQHandler>

000003d8 <ACE_Comp4_Rise_IRQHandler>:
 3d8:	e7fe      	b.n	3d8 <ACE_Comp4_Rise_IRQHandler>

000003da <ACE_Comp5_Rise_IRQHandler>:
 3da:	e7fe      	b.n	3da <ACE_Comp5_Rise_IRQHandler>

000003dc <ACE_Comp6_Rise_IRQHandler>:
 3dc:	e7fe      	b.n	3dc <ACE_Comp6_Rise_IRQHandler>

000003de <ACE_Comp7_Rise_IRQHandler>:
 3de:	e7fe      	b.n	3de <ACE_Comp7_Rise_IRQHandler>

000003e0 <ACE_Comp8_Rise_IRQHandler>:
 3e0:	e7fe      	b.n	3e0 <ACE_Comp8_Rise_IRQHandler>

000003e2 <ACE_Comp9_Rise_IRQHandler>:
 3e2:	e7fe      	b.n	3e2 <ACE_Comp9_Rise_IRQHandler>

000003e4 <ACE_Comp10_Rise_IRQHandler>:
 3e4:	e7fe      	b.n	3e4 <ACE_Comp10_Rise_IRQHandler>

000003e6 <ACE_Comp11_Rise_IRQHandler>:
 3e6:	e7fe      	b.n	3e6 <ACE_Comp11_Rise_IRQHandler>

000003e8 <ACE_ADC0_FifoFull_IRQHandler>:
 3e8:	e7fe      	b.n	3e8 <ACE_ADC0_FifoFull_IRQHandler>

000003ea <ACE_ADC0_FifoAFull_IRQHandler>:
 3ea:	e7fe      	b.n	3ea <ACE_ADC0_FifoAFull_IRQHandler>

000003ec <ACE_ADC0_FifoEmpty_IRQHandler>:
 3ec:	e7fe      	b.n	3ec <ACE_ADC0_FifoEmpty_IRQHandler>

000003ee <ACE_ADC1_FifoFull_IRQHandler>:
 3ee:	e7fe      	b.n	3ee <ACE_ADC1_FifoFull_IRQHandler>

000003f0 <ACE_ADC1_FifoAFull_IRQHandler>:
 3f0:	e7fe      	b.n	3f0 <ACE_ADC1_FifoAFull_IRQHandler>

000003f2 <ACE_ADC1_FifoEmpty_IRQHandler>:
 3f2:	e7fe      	b.n	3f2 <ACE_ADC1_FifoEmpty_IRQHandler>

000003f4 <ACE_ADC2_FifoFull_IRQHandler>:
 3f4:	e7fe      	b.n	3f4 <ACE_ADC2_FifoFull_IRQHandler>

000003f6 <ACE_ADC2_FifoAFull_IRQHandler>:
 3f6:	e7fe      	b.n	3f6 <ACE_ADC2_FifoAFull_IRQHandler>

000003f8 <ACE_ADC2_FifoEmpty_IRQHandler>:
 3f8:	e7fe      	b.n	3f8 <ACE_ADC2_FifoEmpty_IRQHandler>
 3fa:	e7fe      	b.n	3fa <ACE_ADC2_FifoEmpty_IRQHandler+0x2>
 3fc:	e7fe      	b.n	3fc <ACE_ADC2_FifoEmpty_IRQHandler+0x4>
 3fe:	e7fe      	b.n	3fe <ACE_ADC2_FifoEmpty_IRQHandler+0x6>
 400:	e7fe      	b.n	400 <ACE_ADC2_FifoEmpty_IRQHandler+0x8>
 402:	e7fe      	b.n	402 <ACE_ADC2_FifoEmpty_IRQHandler+0xa>
 404:	e7fe      	b.n	404 <ACE_ADC2_FifoEmpty_IRQHandler+0xc>
 406:	e7fe      	b.n	406 <ACE_ADC2_FifoEmpty_IRQHandler+0xe>
 408:	e7fe      	b.n	408 <ACE_ADC2_FifoEmpty_IRQHandler+0x10>
 40a:	e7fe      	b.n	40a <ACE_ADC2_FifoEmpty_IRQHandler+0x12>
 40c:	e7fe      	b.n	40c <ACE_ADC2_FifoEmpty_IRQHandler+0x14>
 40e:	e7fe      	b.n	40e <ACE_ADC2_FifoEmpty_IRQHandler+0x16>
 410:	e7fe      	b.n	410 <ACE_ADC2_FifoEmpty_IRQHandler+0x18>
 412:	e7fe      	b.n	412 <ACE_ADC2_FifoEmpty_IRQHandler+0x1a>
 414:	e7fe      	b.n	414 <ACE_ADC2_FifoEmpty_IRQHandler+0x1c>
 416:	e7fe      	b.n	416 <ACE_ADC2_FifoEmpty_IRQHandler+0x1e>
 418:	e7fe      	b.n	418 <ACE_ADC2_FifoEmpty_IRQHandler+0x20>
 41a:	e7fe      	b.n	41a <ACE_ADC2_FifoEmpty_IRQHandler+0x22>
 41c:	e7fe      	b.n	41c <ACE_ADC2_FifoEmpty_IRQHandler+0x24>
 41e:	e7fe      	b.n	41e <ACE_ADC2_FifoEmpty_IRQHandler+0x26>
 420:	e7fe      	b.n	420 <ACE_ADC2_FifoEmpty_IRQHandler+0x28>
 422:	e7fe      	b.n	422 <ACE_ADC2_FifoEmpty_IRQHandler+0x2a>
 424:	e7fe      	b.n	424 <ACE_ADC2_FifoEmpty_IRQHandler+0x2c>
 426:	e7fe      	b.n	426 <ACE_ADC2_FifoEmpty_IRQHandler+0x2e>
 428:	e7fe      	b.n	428 <ACE_ADC2_FifoEmpty_IRQHandler+0x30>
 42a:	e7fe      	b.n	42a <ACE_ADC2_FifoEmpty_IRQHandler+0x32>
 42c:	e7fe      	b.n	42c <ACE_ADC2_FifoEmpty_IRQHandler+0x34>
 42e:	e7fe      	b.n	42e <ACE_ADC2_FifoEmpty_IRQHandler+0x36>
 430:	e7fe      	b.n	430 <ACE_ADC2_FifoEmpty_IRQHandler+0x38>
 432:	e7fe      	b.n	432 <ACE_ADC2_FifoEmpty_IRQHandler+0x3a>
 434:	e7fe      	b.n	434 <ACE_ADC2_FifoEmpty_IRQHandler+0x3c>
 436:	e7fe      	b.n	436 <ACE_ADC2_FifoEmpty_IRQHandler+0x3e>
 438:	e7fe      	b.n	438 <ACE_ADC2_FifoEmpty_IRQHandler+0x40>
 43a:	0000      	.short	0x0000
 43c:	0000a1cd 	.word	0x0000a1cd
 440:	00000001 	.word	0x00000001
 444:	60000470 	.word	0x60000470
 448:	00000470 	.word	0x00000470
 44c:	20000008 	.word	0x20000008
 450:	600242a8 	.word	0x600242a8
 454:	20000008 	.word	0x20000008
 458:	200005ec 	.word	0x200005ec
 45c:	00000000 	.word	0x00000000
 460:	200005ec 	.word	0x200005ec
 464:	2000ccc0 	.word	0x2000ccc0
 468:	00014d55 	.word	0x00014d55
 46c:	00000909 	.word	0x00000909

Disassembly of section .text:

00000470 <__do_global_dtors_aux>:
     470:	f240 53ec 	movw	r3, #1516	; 0x5ec
     474:	f2c2 0300 	movt	r3, #8192	; 0x2000
     478:	781a      	ldrb	r2, [r3, #0]
     47a:	b90a      	cbnz	r2, 480 <__do_global_dtors_aux+0x10>
     47c:	2001      	movs	r0, #1
     47e:	7018      	strb	r0, [r3, #0]
     480:	4770      	bx	lr
     482:	bf00      	nop

00000484 <frame_dummy>:
     484:	f240 0008 	movw	r0, #8
     488:	f2c2 0000 	movt	r0, #8192	; 0x2000
     48c:	b508      	push	{r3, lr}
     48e:	6803      	ldr	r3, [r0, #0]
     490:	b12b      	cbz	r3, 49e <frame_dummy+0x1a>
     492:	f240 0300 	movw	r3, #0
     496:	f2c0 0300 	movt	r3, #0
     49a:	b103      	cbz	r3, 49e <frame_dummy+0x1a>
     49c:	4798      	blx	r3
     49e:	bd08      	pop	{r3, pc}

000004a0 <MSS_GPIO_set_outputs>:
static __INLINE void
MSS_GPIO_set_outputs
(
   uint32_t value
)
{
     4a0:	b480      	push	{r7}
     4a2:	b083      	sub	sp, #12
     4a4:	af00      	add	r7, sp, #0
     4a6:	6078      	str	r0, [r7, #4]
    GPIO->GPIO_OUT = value;
     4a8:	f243 0300 	movw	r3, #12288	; 0x3000
     4ac:	f2c4 0301 	movt	r3, #16385	; 0x4001
     4b0:	687a      	ldr	r2, [r7, #4]
     4b2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
}
     4b6:	f107 070c 	add.w	r7, r7, #12
     4ba:	46bd      	mov	sp, r7
     4bc:	bc80      	pop	{r7}
     4be:	4770      	bx	lr

000004c0 <vParTestInitialise>:
static volatile unsigned long ulGPIOState = 0UL;

/*-----------------------------------------------------------*/

void vParTestInitialise( void )
{
     4c0:	b580      	push	{r7, lr}
     4c2:	b082      	sub	sp, #8
     4c4:	af00      	add	r7, sp, #0
long x;

	/* Initialise the GPIO */
	MSS_GPIO_init();
     4c6:	f003 fddf 	bl	4088 <MSS_GPIO_init>

	/* Set up GPIO for the LEDs. */
	for( x = 0; x < partstMAX_LEDS; x++ )
     4ca:	f04f 0300 	mov.w	r3, #0
     4ce:	607b      	str	r3, [r7, #4]
     4d0:	e00a      	b.n	4e8 <vParTestInitialise+0x28>
	{
		MSS_GPIO_config( ( mss_gpio_id_t ) x , MSS_GPIO_OUTPUT_MODE );
     4d2:	687b      	ldr	r3, [r7, #4]
     4d4:	b2db      	uxtb	r3, r3
     4d6:	4618      	mov	r0, r3
     4d8:	f04f 0105 	mov.w	r1, #5
     4dc:	f003 fe0a 	bl	40f4 <MSS_GPIO_config>

	/* Initialise the GPIO */
	MSS_GPIO_init();

	/* Set up GPIO for the LEDs. */
	for( x = 0; x < partstMAX_LEDS; x++ )
     4e0:	687b      	ldr	r3, [r7, #4]
     4e2:	f103 0301 	add.w	r3, r3, #1
     4e6:	607b      	str	r3, [r7, #4]
     4e8:	687b      	ldr	r3, [r7, #4]
     4ea:	2b07      	cmp	r3, #7
     4ec:	ddf1      	ble.n	4d2 <vParTestInitialise+0x12>
	{
		MSS_GPIO_config( ( mss_gpio_id_t ) x , MSS_GPIO_OUTPUT_MODE );
	}

	/* All LEDs start off. */
	ulGPIOState = 0xffffffffUL;
     4ee:	f240 53f0 	movw	r3, #1520	; 0x5f0
     4f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
     4f6:	f04f 32ff 	mov.w	r2, #4294967295
     4fa:	601a      	str	r2, [r3, #0]
	MSS_GPIO_set_outputs( ulGPIOState );
     4fc:	f240 53f0 	movw	r3, #1520	; 0x5f0
     500:	f2c2 0300 	movt	r3, #8192	; 0x2000
     504:	681b      	ldr	r3, [r3, #0]
     506:	4618      	mov	r0, r3
     508:	f7ff ffca 	bl	4a0 <MSS_GPIO_set_outputs>
}
     50c:	f107 0708 	add.w	r7, r7, #8
     510:	46bd      	mov	sp, r7
     512:	bd80      	pop	{r7, pc}

00000514 <vParTestSetLED>:
/*-----------------------------------------------------------*/

void vParTestSetLED( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
{
     514:	b580      	push	{r7, lr}
     516:	b082      	sub	sp, #8
     518:	af00      	add	r7, sp, #0
     51a:	6078      	str	r0, [r7, #4]
     51c:	6039      	str	r1, [r7, #0]
	if( uxLED < partstMAX_LEDS )
     51e:	687b      	ldr	r3, [r7, #4]
     520:	2b07      	cmp	r3, #7
     522:	d833      	bhi.n	58c <vParTestSetLED+0x78>
	{
		/* A critical section is used as the LEDs are also accessed from an
		interrupt. */
		taskENTER_CRITICAL();
     524:	f013 fea8 	bl	14278 <vPortEnterCritical>
		{
			if( xValue == pdTRUE )
     528:	683b      	ldr	r3, [r7, #0]
     52a:	2b01      	cmp	r3, #1
     52c:	d113      	bne.n	556 <vParTestSetLED+0x42>
			{
				ulGPIOState &= ~( 1UL << uxLED );
     52e:	687b      	ldr	r3, [r7, #4]
     530:	f04f 0201 	mov.w	r2, #1
     534:	fa02 f303 	lsl.w	r3, r2, r3
     538:	ea6f 0203 	mvn.w	r2, r3
     53c:	f240 53f0 	movw	r3, #1520	; 0x5f0
     540:	f2c2 0300 	movt	r3, #8192	; 0x2000
     544:	681b      	ldr	r3, [r3, #0]
     546:	ea02 0203 	and.w	r2, r2, r3
     54a:	f240 53f0 	movw	r3, #1520	; 0x5f0
     54e:	f2c2 0300 	movt	r3, #8192	; 0x2000
     552:	601a      	str	r2, [r3, #0]
     554:	e010      	b.n	578 <vParTestSetLED+0x64>
			}
			else
			{
				ulGPIOState |= ( 1UL << uxLED );
     556:	687b      	ldr	r3, [r7, #4]
     558:	f04f 0201 	mov.w	r2, #1
     55c:	fa02 f203 	lsl.w	r2, r2, r3
     560:	f240 53f0 	movw	r3, #1520	; 0x5f0
     564:	f2c2 0300 	movt	r3, #8192	; 0x2000
     568:	681b      	ldr	r3, [r3, #0]
     56a:	ea42 0203 	orr.w	r2, r2, r3
     56e:	f240 53f0 	movw	r3, #1520	; 0x5f0
     572:	f2c2 0300 	movt	r3, #8192	; 0x2000
     576:	601a      	str	r2, [r3, #0]
			}
			
			MSS_GPIO_set_outputs( ulGPIOState );
     578:	f240 53f0 	movw	r3, #1520	; 0x5f0
     57c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     580:	681b      	ldr	r3, [r3, #0]
     582:	4618      	mov	r0, r3
     584:	f7ff ff8c 	bl	4a0 <MSS_GPIO_set_outputs>
		}
		taskEXIT_CRITICAL();
     588:	f013 feae 	bl	142e8 <vPortExitCritical>
	}
}
     58c:	f107 0708 	add.w	r7, r7, #8
     590:	46bd      	mov	sp, r7
     592:	bd80      	pop	{r7, pc}

00000594 <vParTestSetLEDFromISR>:
/*-----------------------------------------------------------*/

void vParTestSetLEDFromISR( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
{
     594:	b580      	push	{r7, lr}
     596:	b086      	sub	sp, #24
     598:	af00      	add	r7, sp, #0
     59a:	6078      	str	r0, [r7, #4]
     59c:	6039      	str	r1, [r7, #0]

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
     59e:	f3ef 8211 	mrs	r2, BASEPRI
     5a2:	f04f 0328 	mov.w	r3, #40	; 0x28
     5a6:	f383 8811 	msr	BASEPRI, r3
     5aa:	f3bf 8f6f 	isb	sy
     5ae:	f3bf 8f4f 	dsb	sy
     5b2:	613a      	str	r2, [r7, #16]
     5b4:	60fb      	str	r3, [r7, #12]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
     5b6:	693b      	ldr	r3, [r7, #16]
unsigned portBASE_TYPE uxInterruptFlags;

	uxInterruptFlags = portSET_INTERRUPT_MASK_FROM_ISR();
     5b8:	60bb      	str	r3, [r7, #8]
	{
		if( uxLED < partstMAX_LEDS )
     5ba:	687b      	ldr	r3, [r7, #4]
     5bc:	2b07      	cmp	r3, #7
     5be:	d82f      	bhi.n	620 <vParTestSetLEDFromISR+0x8c>
		{
			if( xValue == pdTRUE )
     5c0:	683b      	ldr	r3, [r7, #0]
     5c2:	2b01      	cmp	r3, #1
     5c4:	d113      	bne.n	5ee <vParTestSetLEDFromISR+0x5a>
			{
				ulGPIOState &= ~( 1UL << uxLED );
     5c6:	687b      	ldr	r3, [r7, #4]
     5c8:	f04f 0201 	mov.w	r2, #1
     5cc:	fa02 f303 	lsl.w	r3, r2, r3
     5d0:	ea6f 0203 	mvn.w	r2, r3
     5d4:	f240 53f0 	movw	r3, #1520	; 0x5f0
     5d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
     5dc:	681b      	ldr	r3, [r3, #0]
     5de:	ea02 0203 	and.w	r2, r2, r3
     5e2:	f240 53f0 	movw	r3, #1520	; 0x5f0
     5e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
     5ea:	601a      	str	r2, [r3, #0]
     5ec:	e010      	b.n	610 <vParTestSetLEDFromISR+0x7c>
			}
			else
			{
				ulGPIOState |= ( 1UL << uxLED );
     5ee:	687b      	ldr	r3, [r7, #4]
     5f0:	f04f 0201 	mov.w	r2, #1
     5f4:	fa02 f203 	lsl.w	r2, r2, r3
     5f8:	f240 53f0 	movw	r3, #1520	; 0x5f0
     5fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
     600:	681b      	ldr	r3, [r3, #0]
     602:	ea42 0203 	orr.w	r2, r2, r3
     606:	f240 53f0 	movw	r3, #1520	; 0x5f0
     60a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     60e:	601a      	str	r2, [r3, #0]
			}

			MSS_GPIO_set_outputs( ulGPIOState );
     610:	f240 53f0 	movw	r3, #1520	; 0x5f0
     614:	f2c2 0300 	movt	r3, #8192	; 0x2000
     618:	681b      	ldr	r3, [r3, #0]
     61a:	4618      	mov	r0, r3
     61c:	f7ff ff40 	bl	4a0 <MSS_GPIO_set_outputs>
     620:	68bb      	ldr	r3, [r7, #8]
     622:	617b      	str	r3, [r7, #20]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
     624:	697b      	ldr	r3, [r7, #20]
     626:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxInterruptFlags );
}
     62a:	f107 0718 	add.w	r7, r7, #24
     62e:	46bd      	mov	sp, r7
     630:	bd80      	pop	{r7, pc}
     632:	bf00      	nop

00000634 <vParTestToggleLED>:
/*-----------------------------------------------------------*/

void vParTestToggleLED( unsigned portBASE_TYPE uxLED )
{
     634:	b580      	push	{r7, lr}
     636:	b082      	sub	sp, #8
     638:	af00      	add	r7, sp, #0
     63a:	6078      	str	r0, [r7, #4]
	if( uxLED < partstMAX_LEDS )
     63c:	687b      	ldr	r3, [r7, #4]
     63e:	2b07      	cmp	r3, #7
     640:	d83d      	bhi.n	6be <vParTestToggleLED+0x8a>
	{
		/* A critical section is used as the LEDs are also accessed from an
		interrupt. */
		taskENTER_CRITICAL();
     642:	f013 fe19 	bl	14278 <vPortEnterCritical>
		{
			if( ( ulGPIOState & ( 1UL << uxLED ) ) != 0UL )
     646:	f240 53f0 	movw	r3, #1520	; 0x5f0
     64a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     64e:	681a      	ldr	r2, [r3, #0]
     650:	687b      	ldr	r3, [r7, #4]
     652:	fa22 f303 	lsr.w	r3, r2, r3
     656:	f003 0301 	and.w	r3, r3, #1
     65a:	b2db      	uxtb	r3, r3
     65c:	2b00      	cmp	r3, #0
     65e:	d013      	beq.n	688 <vParTestToggleLED+0x54>
			{
				ulGPIOState &= ~( 1UL << uxLED );
     660:	687b      	ldr	r3, [r7, #4]
     662:	f04f 0201 	mov.w	r2, #1
     666:	fa02 f303 	lsl.w	r3, r2, r3
     66a:	ea6f 0203 	mvn.w	r2, r3
     66e:	f240 53f0 	movw	r3, #1520	; 0x5f0
     672:	f2c2 0300 	movt	r3, #8192	; 0x2000
     676:	681b      	ldr	r3, [r3, #0]
     678:	ea02 0203 	and.w	r2, r2, r3
     67c:	f240 53f0 	movw	r3, #1520	; 0x5f0
     680:	f2c2 0300 	movt	r3, #8192	; 0x2000
     684:	601a      	str	r2, [r3, #0]
     686:	e010      	b.n	6aa <vParTestToggleLED+0x76>
			}
			else
			{
				ulGPIOState |= ( 1UL << uxLED );
     688:	687b      	ldr	r3, [r7, #4]
     68a:	f04f 0201 	mov.w	r2, #1
     68e:	fa02 f203 	lsl.w	r2, r2, r3
     692:	f240 53f0 	movw	r3, #1520	; 0x5f0
     696:	f2c2 0300 	movt	r3, #8192	; 0x2000
     69a:	681b      	ldr	r3, [r3, #0]
     69c:	ea42 0203 	orr.w	r2, r2, r3
     6a0:	f240 53f0 	movw	r3, #1520	; 0x5f0
     6a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     6a8:	601a      	str	r2, [r3, #0]
			}
			
			MSS_GPIO_set_outputs( ulGPIOState );
     6aa:	f240 53f0 	movw	r3, #1520	; 0x5f0
     6ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
     6b2:	681b      	ldr	r3, [r3, #0]
     6b4:	4618      	mov	r0, r3
     6b6:	f7ff fef3 	bl	4a0 <MSS_GPIO_set_outputs>
		}
		taskEXIT_CRITICAL();
     6ba:	f013 fe15 	bl	142e8 <vPortExitCritical>
	}
}
     6be:	f107 0708 	add.w	r7, r7, #8
     6c2:	46bd      	mov	sp, r7
     6c4:	bd80      	pop	{r7, pc}
     6c6:	bf00      	nop

000006c8 <lParTestGetLEDState>:
/*-----------------------------------------------------------*/

long lParTestGetLEDState( unsigned long ulLED )
{
     6c8:	b580      	push	{r7, lr}
     6ca:	b084      	sub	sp, #16
     6cc:	af00      	add	r7, sp, #0
     6ce:	6078      	str	r0, [r7, #4]
long lReturn = pdFALSE;
     6d0:	f04f 0300 	mov.w	r3, #0
     6d4:	60fb      	str	r3, [r7, #12]

	if( ulLED < partstMAX_LEDS )
     6d6:	687b      	ldr	r3, [r7, #4]
     6d8:	2b07      	cmp	r3, #7
     6da:	d812      	bhi.n	702 <lParTestGetLEDState+0x3a>
	{
		taskENTER_CRITICAL();
     6dc:	f013 fdcc 	bl	14278 <vPortEnterCritical>
		{
			if( ( ulGPIOState & ( 1UL << ulLED ) ) == 0UL )
     6e0:	f240 53f0 	movw	r3, #1520	; 0x5f0
     6e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     6e8:	681a      	ldr	r2, [r3, #0]
     6ea:	687b      	ldr	r3, [r7, #4]
     6ec:	fa22 f303 	lsr.w	r3, r2, r3
     6f0:	f003 0301 	and.w	r3, r3, #1
     6f4:	2b00      	cmp	r3, #0
     6f6:	d102      	bne.n	6fe <lParTestGetLEDState+0x36>
			{
				lReturn = pdTRUE;
     6f8:	f04f 0301 	mov.w	r3, #1
     6fc:	60fb      	str	r3, [r7, #12]
			}
		}
		taskEXIT_CRITICAL();
     6fe:	f013 fdf3 	bl	142e8 <vPortExitCritical>
	}

	return lReturn;
     702:	68fb      	ldr	r3, [r7, #12]
}
     704:	4618      	mov	r0, r3
     706:	f107 0710 	add.w	r7, r7, #16
     70a:	46bd      	mov	sp, r7
     70c:	bd80      	pop	{r7, pc}
     70e:	bf00      	nop

00000710 <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
     710:	b480      	push	{r7}
     712:	b083      	sub	sp, #12
     714:	af00      	add	r7, sp, #0
     716:	4603      	mov	r3, r0
     718:	80fb      	strh	r3, [r7, #6]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
     71a:	f24e 1300 	movw	r3, #57600	; 0xe100
     71e:	f2ce 0300 	movt	r3, #57344	; 0xe000
     722:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
     726:	ea4f 1252 	mov.w	r2, r2, lsr #5
     72a:	88f9      	ldrh	r1, [r7, #6]
     72c:	f001 011f 	and.w	r1, r1, #31
     730:	f04f 0001 	mov.w	r0, #1
     734:	fa00 f101 	lsl.w	r1, r0, r1
     738:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
     73c:	f107 070c 	add.w	r7, r7, #12
     740:	46bd      	mov	sp, r7
     742:	bc80      	pop	{r7}
     744:	4770      	bx	lr
     746:	bf00      	nop

00000748 <NVIC_DisableIRQ>:
 * 
 * Disable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
     748:	b480      	push	{r7}
     74a:	b083      	sub	sp, #12
     74c:	af00      	add	r7, sp, #0
     74e:	4603      	mov	r3, r0
     750:	80fb      	strh	r3, [r7, #6]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
     752:	f24e 1300 	movw	r3, #57600	; 0xe100
     756:	f2ce 0300 	movt	r3, #57344	; 0xe000
     75a:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
     75e:	ea4f 1252 	mov.w	r2, r2, lsr #5
     762:	88f9      	ldrh	r1, [r7, #6]
     764:	f001 011f 	and.w	r1, r1, #31
     768:	f04f 0001 	mov.w	r0, #1
     76c:	fa00 f101 	lsl.w	r1, r0, r1
     770:	f102 0220 	add.w	r2, r2, #32
     774:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
     778:	f107 070c 	add.w	r7, r7, #12
     77c:	46bd      	mov	sp, r7
     77e:	bc80      	pop	{r7}
     780:	4770      	bx	lr
     782:	bf00      	nop

00000784 <NVIC_ClearPendingIRQ>:
 *
 * Clear the pending bit for the specified interrupt. 
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
     784:	b480      	push	{r7}
     786:	b083      	sub	sp, #12
     788:	af00      	add	r7, sp, #0
     78a:	4603      	mov	r3, r0
     78c:	80fb      	strh	r3, [r7, #6]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
     78e:	f24e 1300 	movw	r3, #57600	; 0xe100
     792:	f2ce 0300 	movt	r3, #57344	; 0xe000
     796:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
     79a:	ea4f 1252 	mov.w	r2, r2, lsr #5
     79e:	88f9      	ldrh	r1, [r7, #6]
     7a0:	f001 011f 	and.w	r1, r1, #31
     7a4:	f04f 0001 	mov.w	r0, #1
     7a8:	fa00 f101 	lsl.w	r1, r0, r1
     7ac:	f102 0260 	add.w	r2, r2, #96	; 0x60
     7b0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
     7b4:	f107 070c 	add.w	r7, r7, #12
     7b8:	46bd      	mov	sp, r7
     7ba:	bc80      	pop	{r7}
     7bc:	4770      	bx	lr
     7be:	bf00      	nop

000007c0 <NVIC_SetPriority>:
 * interrupt, or negative to specify an internal (core) interrupt.
 *
 * Note: The priority cannot be set for every core interrupt.
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
     7c0:	b480      	push	{r7}
     7c2:	b083      	sub	sp, #12
     7c4:	af00      	add	r7, sp, #0
     7c6:	4603      	mov	r3, r0
     7c8:	6039      	str	r1, [r7, #0]
     7ca:	80fb      	strh	r3, [r7, #6]
  if(IRQn < 0) {
     7cc:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
     7d0:	2b00      	cmp	r3, #0
     7d2:	da10      	bge.n	7f6 <NVIC_SetPriority+0x36>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M3 System Interrupts */
     7d4:	f64e 5300 	movw	r3, #60672	; 0xed00
     7d8:	f2ce 0300 	movt	r3, #57344	; 0xe000
     7dc:	88fa      	ldrh	r2, [r7, #6]
     7de:	f002 020f 	and.w	r2, r2, #15
     7e2:	f1a2 0104 	sub.w	r1, r2, #4
     7e6:	683a      	ldr	r2, [r7, #0]
     7e8:	b2d2      	uxtb	r2, r2
     7ea:	ea4f 02c2 	mov.w	r2, r2, lsl #3
     7ee:	b2d2      	uxtb	r2, r2
     7f0:	440b      	add	r3, r1
     7f2:	761a      	strb	r2, [r3, #24]
     7f4:	e00d      	b.n	812 <NVIC_SetPriority+0x52>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
     7f6:	f24e 1300 	movw	r3, #57600	; 0xe100
     7fa:	f2ce 0300 	movt	r3, #57344	; 0xe000
     7fe:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
     802:	683a      	ldr	r2, [r7, #0]
     804:	b2d2      	uxtb	r2, r2
     806:	ea4f 02c2 	mov.w	r2, r2, lsl #3
     80a:	b2d2      	uxtb	r2, r2
     80c:	440b      	add	r3, r1
     80e:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
     812:	f107 070c 	add.w	r7, r7, #12
     816:	46bd      	mov	sp, r7
     818:	bc80      	pop	{r7}
     81a:	4770      	bx	lr

0000081c <MSS_TIM64_init>:
    one-shot mode. Allowed values for this parameter are:
        - MSS_TIMER_PERIODIC_MODE
        - MSS_TIMER_ONE_SHOT_MODE 
 */
static __INLINE void MSS_TIM64_init( mss_timer_mode_t mode )
{
     81c:	b580      	push	{r7, lr}
     81e:	b082      	sub	sp, #8
     820:	af00      	add	r7, sp, #0
     822:	4603      	mov	r3, r0
     824:	71fb      	strb	r3, [r7, #7]
    NVIC_DisableIRQ( Timer1_IRQn );         /* disable timer 1 interrupt within NVIC */
     826:	f04f 0014 	mov.w	r0, #20
     82a:	f7ff ff8d 	bl	748 <NVIC_DisableIRQ>
    NVIC_DisableIRQ( Timer2_IRQn );         /* disable timer 2 interrupt within NVIC */
     82e:	f04f 0015 	mov.w	r0, #21
     832:	f7ff ff89 	bl	748 <NVIC_DisableIRQ>
    
    SYSREG->SOFT_RST_CR &= ~SYSREG_TIMER_SOFTRESET_MASK; /* Take timer block out of reset */
     836:	f242 0300 	movw	r3, #8192	; 0x2000
     83a:	f2ce 0304 	movt	r3, #57348	; 0xe004
     83e:	f242 0200 	movw	r2, #8192	; 0x2000
     842:	f2ce 0204 	movt	r2, #57348	; 0xe004
     846:	6b12      	ldr	r2, [r2, #48]	; 0x30
     848:	f022 0240 	bic.w	r2, r2, #64	; 0x40
     84c:	631a      	str	r2, [r3, #48]	; 0x30
    
    TIMER->TIM64_MODE = 1U;                     /* switch to 64 bits mode */
     84e:	f245 0300 	movw	r3, #20480	; 0x5000
     852:	f2c4 0300 	movt	r3, #16384	; 0x4000
     856:	f04f 0201 	mov.w	r2, #1
     85a:	655a      	str	r2, [r3, #84]	; 0x54
    
    TIMER_BITBAND->TIM64ENABLE = 0U;            /* disable timer */
     85c:	f240 0300 	movw	r3, #0
     860:	f2c4 230a 	movt	r3, #16906	; 0x420a
     864:	f04f 0200 	mov.w	r2, #0
     868:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
    TIMER_BITBAND->TIM64INTEN = 0U;             /* disable interrupt */
     86c:	f240 0300 	movw	r3, #0
     870:	f2c4 230a 	movt	r3, #16906	; 0x420a
     874:	f04f 0200 	mov.w	r2, #0
     878:	f8c3 2908 	str.w	r2, [r3, #2312]	; 0x908
    TIMER_BITBAND->TIM64MODE = (uint32_t)mode;  /* set mode (continuous/one-shot) */
     87c:	f240 0300 	movw	r3, #0
     880:	f2c4 230a 	movt	r3, #16906	; 0x420a
     884:	79fa      	ldrb	r2, [r7, #7]
     886:	f8c3 2904 	str.w	r2, [r3, #2308]	; 0x904
    
    TIMER->TIM1_RIS = 1U;                   /* clear timer 1 interrupt */
     88a:	f245 0300 	movw	r3, #20480	; 0x5000
     88e:	f2c4 0300 	movt	r3, #16384	; 0x4000
     892:	f04f 0201 	mov.w	r2, #1
     896:	611a      	str	r2, [r3, #16]
    TIMER->TIM2_RIS = 1U;                   /* clear timer 2 interrupt */
     898:	f245 0300 	movw	r3, #20480	; 0x5000
     89c:	f2c4 0300 	movt	r3, #16384	; 0x4000
     8a0:	f04f 0201 	mov.w	r2, #1
     8a4:	629a      	str	r2, [r3, #40]	; 0x28
    NVIC_ClearPendingIRQ( Timer1_IRQn );    /* clear timer 1 interrupt within NVIC */
     8a6:	f04f 0014 	mov.w	r0, #20
     8aa:	f7ff ff6b 	bl	784 <NVIC_ClearPendingIRQ>
    NVIC_ClearPendingIRQ( Timer2_IRQn );    /* clear timer 2 interrupt within NVIC */
     8ae:	f04f 0015 	mov.w	r0, #21
     8b2:	f7ff ff67 	bl	784 <NVIC_ClearPendingIRQ>
}
     8b6:	f107 0708 	add.w	r7, r7, #8
     8ba:	46bd      	mov	sp, r7
     8bc:	bd80      	pop	{r7, pc}
     8be:	bf00      	nop

000008c0 <MSS_TIM64_start>:
  The MSS_TIM64_start() function enables the 64-bit timer and starts its
  down-counter decrementing from the load_value specified in previous calls to
  the MSS_TIM64_load_immediate() or MSS_TIM64_load_background() functions.
 */
static __INLINE void MSS_TIM64_start( void )
{
     8c0:	b480      	push	{r7}
     8c2:	af00      	add	r7, sp, #0
    TIMER_BITBAND->TIM64ENABLE = 1U;    /* enable timer */
     8c4:	f240 0300 	movw	r3, #0
     8c8:	f2c4 230a 	movt	r3, #16906	; 0x420a
     8cc:	f04f 0201 	mov.w	r2, #1
     8d0:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
}
     8d4:	46bd      	mov	sp, r7
     8d6:	bc80      	pop	{r7}
     8d8:	4770      	bx	lr
     8da:	bf00      	nop

000008dc <MSS_TIM64_load_immediate>:
static __INLINE void MSS_TIM64_load_immediate
(
    uint32_t load_value_u,
    uint32_t load_value_l
)
{
     8dc:	b480      	push	{r7}
     8de:	b083      	sub	sp, #12
     8e0:	af00      	add	r7, sp, #0
     8e2:	6078      	str	r0, [r7, #4]
     8e4:	6039      	str	r1, [r7, #0]
    TIMER->TIM64_LOADVAL_U = load_value_u;
     8e6:	f245 0300 	movw	r3, #20480	; 0x5000
     8ea:	f2c4 0300 	movt	r3, #16384	; 0x4000
     8ee:	687a      	ldr	r2, [r7, #4]
     8f0:	639a      	str	r2, [r3, #56]	; 0x38
    TIMER->TIM64_LOADVAL_L = load_value_l;
     8f2:	f245 0300 	movw	r3, #20480	; 0x5000
     8f6:	f2c4 0300 	movt	r3, #16384	; 0x4000
     8fa:	683a      	ldr	r2, [r7, #0]
     8fc:	63da      	str	r2, [r3, #60]	; 0x3c
}
     8fe:	f107 070c 	add.w	r7, r7, #12
     902:	46bd      	mov	sp, r7
     904:	bc80      	pop	{r7}
     906:	4770      	bx	lr

00000908 <main>:
|   (O)            (+)              (O)   |\n\r \
\_______________________________________/"


int main(void)
{
     908:	b580      	push	{r7, lr}
     90a:	b082      	sub	sp, #8
     90c:	af02      	add	r7, sp, #8
	/* Configure the NVIC, LED outputs and button inputs. */
	prvSetupHardware();
     90e:	f000 f90d 	bl	b2c <prvSetupHardware>

	/* Create the queue. */
	xQueue = xQueueCreate( mainQUEUE_LENGTH, sizeof( unsigned long ) );
     912:	f04f 0001 	mov.w	r0, #1
     916:	f04f 0104 	mov.w	r1, #4
     91a:	f04f 0200 	mov.w	r2, #0
     91e:	f00e fd0f 	bl	f340 <xQueueGenericCreate>
     922:	4602      	mov	r2, r0
     924:	f240 53f4 	movw	r3, #1524	; 0x5f4
     928:	f2c2 0300 	movt	r3, #8192	; 0x2000
     92c:	601a      	str	r2, [r3, #0]

	if( xQueue != NULL )
     92e:	f240 53f4 	movw	r3, #1524	; 0x5f4
     932:	f2c2 0300 	movt	r3, #8192	; 0x2000
     936:	681b      	ldr	r3, [r3, #0]
     938:	2b00      	cmp	r3, #0
     93a:	d068      	beq.n	a0e <main+0x106>
	{

		xTaskCreate( prvQueueReceiveTask, "Rx", configMINIMAL_STACK_SIZE, NULL, mainQUEUE_RECEIVE_TASK_PRIORITY, NULL );
     93c:	f04f 0302 	mov.w	r3, #2
     940:	9300      	str	r3, [sp, #0]
     942:	f04f 0300 	mov.w	r3, #0
     946:	9301      	str	r3, [sp, #4]
     948:	f640 20f5 	movw	r0, #2805	; 0xaf5
     94c:	f2c0 0000 	movt	r0, #0
     950:	f64a 31d4 	movw	r1, #43988	; 0xabd4
     954:	f2c0 0101 	movt	r1, #1
     958:	f04f 025a 	mov.w	r2, #90	; 0x5a
     95c:	f04f 0300 	mov.w	r3, #0
     960:	f00f fec6 	bl	106f0 <xTaskCreate>
		xTaskCreate( prvQueueSendTask, "TX", configMINIMAL_STACK_SIZE, NULL, mainQUEUE_SEND_TASK_PRIORITY, NULL );
     964:	f04f 0301 	mov.w	r3, #1
     968:	9300      	str	r3, [sp, #0]
     96a:	f04f 0300 	mov.w	r3, #0
     96e:	9301      	str	r3, [sp, #4]
     970:	f640 2089 	movw	r0, #2697	; 0xa89
     974:	f2c0 0000 	movt	r0, #0
     978:	f64a 31d8 	movw	r1, #43992	; 0xabd8
     97c:	f2c0 0101 	movt	r1, #1
     980:	f04f 025a 	mov.w	r2, #90	; 0x5a
     984:	f04f 0300 	mov.w	r3, #0
     988:	f00f feb2 	bl	106f0 <xTaskCreate>
		//printf( "\n\r********* Welcome to the Measurement System  *********\n\r" );


		/* Create the software timer that performs the 'check' functionality,
		as described at the top of this file. */
		xCheckTimer = xTimerCreate( "CheckTimer",					/* A text name, purely to help debugging. */
     98c:	f640 2311 	movw	r3, #2577	; 0xa11
     990:	f2c0 0300 	movt	r3, #0
     994:	9300      	str	r3, [sp, #0]
     996:	f64a 30dc 	movw	r0, #43996	; 0xabdc
     99a:	f2c0 0001 	movt	r0, #1
     99e:	f640 31b8 	movw	r1, #3000	; 0xbb8
     9a2:	f04f 0201 	mov.w	r2, #1
     9a6:	f04f 0300 	mov.w	r3, #0
     9aa:	f012 fd91 	bl	134d0 <xTimerCreate>
     9ae:	4602      	mov	r2, r0
     9b0:	f240 53f8 	movw	r3, #1528	; 0x5f8
     9b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     9b8:	601a      	str	r2, [r3, #0]
									( void * ) 0,					/* The ID is not used, so can be set to anything. */
									prvCheckTimerCallback			/* The callback function that inspects the status of all the other tasks. */
								  );

		/* Create the web server task. */
		xTaskCreate( vuIP_Task, "uIP", mainuIP_STACK_SIZE, NULL, mainuIP_TASK_PRIORITY, NULL );
     9ba:	f04f 0302 	mov.w	r3, #2
     9be:	9300      	str	r3, [sp, #0]
     9c0:	f04f 0300 	mov.w	r3, #0
     9c4:	9301      	str	r3, [sp, #4]
     9c6:	f640 50c5 	movw	r0, #3525	; 0xdc5
     9ca:	f2c0 0000 	movt	r0, #0
     9ce:	f64a 31e8 	movw	r1, #44008	; 0xabe8
     9d2:	f2c0 0101 	movt	r1, #1
     9d6:	f44f 7287 	mov.w	r2, #270	; 0x10e
     9da:	f04f 0300 	mov.w	r3, #0
     9de:	f00f fe87 	bl	106f0 <xTaskCreate>

		xTaskCreate( uart_task, "uart_task" ,configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+1, NULL);
     9e2:	f04f 0301 	mov.w	r3, #1
     9e6:	9300      	str	r3, [sp, #0]
     9e8:	f04f 0300 	mov.w	r3, #0
     9ec:	9301      	str	r3, [sp, #4]
     9ee:	f640 4029 	movw	r0, #3113	; 0xc29
     9f2:	f2c0 0000 	movt	r0, #0
     9f6:	f64a 31ec 	movw	r1, #44012	; 0xabec
     9fa:	f2c0 0101 	movt	r1, #1
     9fe:	f04f 025a 	mov.w	r2, #90	; 0x5a
     a02:	f04f 0300 	mov.w	r3, #0
     a06:	f00f fe73 	bl	106f0 <xTaskCreate>


		/* Start the tasks and timer running. */
		vTaskStartScheduler();
     a0a:	f010 fce1 	bl	113d0 <vTaskStartScheduler>
	/* If all is well, the scheduler will now be running, and the following line
	will never be reached.  If the following line does execute, then there was
	insufficient FreeRTOS heap memory available for the idle and/or timer tasks
	to be created.  See the memory management section on the FreeRTOS web site
	for more details. */
	for( ;; );
     a0e:	e7fe      	b.n	a0e <main+0x106>

00000a10 <prvCheckTimerCallback>:




static void prvCheckTimerCallback( TimerHandle_t xTimer )
{
     a10:	b580      	push	{r7, lr}
     a12:	b084      	sub	sp, #16
     a14:	af02      	add	r7, sp, #8
     a16:	6078      	str	r0, [r7, #4]

	/* Have any errors been latch in pcStatusMessage?  If so, shorten the
	period of the check timer to mainERROR_CHECK_TIMER_PERIOD_MS milliseconds.
	This will result in an increase in the rate at which mainCHECK_LED
	toggles. */
	if( pcStatusMessage != NULL )
     a18:	f240 53fc 	movw	r3, #1532	; 0x5fc
     a1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a20:	681b      	ldr	r3, [r3, #0]
     a22:	2b00      	cmp	r3, #0
     a24:	d010      	beq.n	a48 <prvCheckTimerCallback+0x38>
	{
		/* This call to xTimerChangePeriod() uses a zero block time.  Functions
		called from inside of a timer callback function must *never* attempt
		to block. */
		xTimerChangePeriod( xCheckTimer, ( mainERROR_CHECK_TIMER_PERIOD_MS ), mainDONT_BLOCK );
     a26:	f240 53f8 	movw	r3, #1528	; 0x5f8
     a2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a2e:	681b      	ldr	r3, [r3, #0]
     a30:	f04f 0200 	mov.w	r2, #0
     a34:	9200      	str	r2, [sp, #0]
     a36:	4618      	mov	r0, r3
     a38:	f04f 0104 	mov.w	r1, #4
     a3c:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
     a40:	f04f 0300 	mov.w	r3, #0
     a44:	f012 fd96 	bl	13574 <xTimerGenericCommand>
	}
}
     a48:	f107 0708 	add.w	r7, r7, #8
     a4c:	46bd      	mov	sp, r7
     a4e:	bd80      	pop	{r7, pc}

00000a50 <GPIO8_IRQHandler>:

/*-----------------------------------------------------------*/

/* The ISR executed when the user button is pushed. */
void GPIO8_IRQHandler( void )
{
     a50:	b580      	push	{r7, lr}
     a52:	b082      	sub	sp, #8
     a54:	af00      	add	r7, sp, #0
portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     a56:	f04f 0300 	mov.w	r3, #0
     a5a:	607b      	str	r3, [r7, #4]

//DO SOMETHING IF INTERUPTED BY BUTTON ON GPIO8 (SW1)


	/* Clear the interrupt before leaving. */
    MSS_GPIO_clear_irq( MSS_GPIO_8 );
     a5c:	f04f 0008 	mov.w	r0, #8
     a60:	f003 fc74 	bl	434c <MSS_GPIO_clear_irq>
	/* If calling xTimerResetFromISR() caused a task (in this case the timer
	service/daemon task) to unblock, and the unblocked task has a priority
	higher than or equal to the task that was interrupted, then
	xHigherPriorityTaskWoken will now be set to pdTRUE, and calling
	portEND_SWITCHING_ISR() will ensure the unblocked task runs next. */
	portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );
     a64:	687b      	ldr	r3, [r7, #4]
     a66:	2b00      	cmp	r3, #0
     a68:	d00a      	beq.n	a80 <GPIO8_IRQHandler+0x30>
     a6a:	f64e 5304 	movw	r3, #60676	; 0xed04
     a6e:	f2ce 0300 	movt	r3, #57344	; 0xe000
     a72:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
     a76:	601a      	str	r2, [r3, #0]
     a78:	f3bf 8f4f 	dsb	sy
     a7c:	f3bf 8f6f 	isb	sy
}
     a80:	f107 0708 	add.w	r7, r7, #8
     a84:	46bd      	mov	sp, r7
     a86:	bd80      	pop	{r7, pc}

00000a88 <prvQueueSendTask>:
/*-----------------------------------------------------------*/

static void prvQueueSendTask( void *pvParameters )
{
     a88:	b590      	push	{r4, r7, lr}
     a8a:	b087      	sub	sp, #28
     a8c:	af02      	add	r7, sp, #8
     a8e:	6078      	str	r0, [r7, #4]
TickType_t xNextWakeTime;
const unsigned long ulValueToSend = 100UL;
     a90:	f04f 0364 	mov.w	r3, #100	; 0x64
     a94:	60bb      	str	r3, [r7, #8]
	/* The timer command queue will have been filled when the timer test tasks
	were created in main() (this is part of the test they perform).  Therefore,
	while the check timer can be created in main(), it cannot be started from
	main().  Once the scheduler has started, the timer service task will drain
	the command queue, and now the check timer can be started successfully. */
	xTimerStart( xCheckTimer, portMAX_DELAY );
     a96:	f240 53f8 	movw	r3, #1528	; 0x5f8
     a9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a9e:	681c      	ldr	r4, [r3, #0]
     aa0:	f010 fdec 	bl	1167c <xTaskGetTickCount>
     aa4:	4603      	mov	r3, r0
     aa6:	f04f 32ff 	mov.w	r2, #4294967295
     aaa:	9200      	str	r2, [sp, #0]
     aac:	4620      	mov	r0, r4
     aae:	f04f 0101 	mov.w	r1, #1
     ab2:	461a      	mov	r2, r3
     ab4:	f04f 0300 	mov.w	r3, #0
     ab8:	f012 fd5c 	bl	13574 <xTimerGenericCommand>

	/* Initialise xNextWakeTime - this only needs to be done once. */
	xNextWakeTime = xTaskGetTickCount();
     abc:	f010 fdde 	bl	1167c <xTaskGetTickCount>
     ac0:	4603      	mov	r3, r0
     ac2:	60fb      	str	r3, [r7, #12]
	{
		/* Place this task in the blocked state until it is time to run again.
		The block time is specified in ticks, the constant used converts ticks
		to ms.  While in the Blocked state this task will not consume any CPU
		time. */
		vTaskDelayUntil( &xNextWakeTime, mainQUEUE_SEND_FREQUENCY_MS );
     ac4:	f107 030c 	add.w	r3, r7, #12
     ac8:	4618      	mov	r0, r3
     aca:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
     ace:	f010 f851 	bl	10b74 <vTaskDelayUntil>

		/* Send to the queue - causing the queue receive task to unblock and
		toggle an LED.  0 is used as the block time so the sending operation
		will not block - it shouldn't need to block as the queue should always
		be empty at this point in the code. */
		xQueueSend( xQueue, &ulValueToSend, mainDONT_BLOCK );
     ad2:	f240 53f4 	movw	r3, #1524	; 0x5f4
     ad6:	f2c2 0300 	movt	r3, #8192	; 0x2000
     ada:	681a      	ldr	r2, [r3, #0]
     adc:	f107 0308 	add.w	r3, r7, #8
     ae0:	4610      	mov	r0, r2
     ae2:	4619      	mov	r1, r3
     ae4:	f04f 0200 	mov.w	r2, #0
     ae8:	f04f 0300 	mov.w	r3, #0
     aec:	f00e fd3c 	bl	f568 <xQueueGenericSend>
	}
     af0:	e7e8      	b.n	ac4 <prvQueueSendTask+0x3c>
     af2:	bf00      	nop

00000af4 <prvQueueReceiveTask>:
}
/*-----------------------------------------------------------*/

static void prvQueueReceiveTask( void *pvParameters )
{
     af4:	b580      	push	{r7, lr}
     af6:	b084      	sub	sp, #16
     af8:	af00      	add	r7, sp, #0
     afa:	6078      	str	r0, [r7, #4]
     afc:	e000      	b.n	b00 <prvQueueReceiveTask+0xc>
		is it the expected value?  If it is, toggle the LED. */
		if( ulReceivedValue == 100UL )
		{
			vParTestToggleLED( mainTASK_CONTROLLED_LED );
		}
	}
     afe:	bf00      	nop
	for( ;; )
	{
		/* Wait until something arrives in the queue - this task will block
		indefinitely provided INCLUDE_vTaskSuspend is set to 1 in
		FreeRTOSConfig.h. */
		xQueueReceive( xQueue, &ulReceivedValue, portMAX_DELAY );
     b00:	f240 53f4 	movw	r3, #1524	; 0x5f4
     b04:	f2c2 0300 	movt	r3, #8192	; 0x2000
     b08:	681a      	ldr	r2, [r3, #0]
     b0a:	f107 030c 	add.w	r3, r7, #12
     b0e:	4610      	mov	r0, r2
     b10:	4619      	mov	r1, r3
     b12:	f04f 32ff 	mov.w	r2, #4294967295
     b16:	f00e ff77 	bl	fa08 <xQueueReceive>

		/*  To get here something must have been received from the queue, but
		is it the expected value?  If it is, toggle the LED. */
		if( ulReceivedValue == 100UL )
     b1a:	68fb      	ldr	r3, [r7, #12]
     b1c:	2b64      	cmp	r3, #100	; 0x64
     b1e:	d1ee      	bne.n	afe <prvQueueReceiveTask+0xa>
		{
			vParTestToggleLED( mainTASK_CONTROLLED_LED );
     b20:	f04f 0005 	mov.w	r0, #5
     b24:	f7ff fd86 	bl	634 <vParTestToggleLED>
		}
	}
     b28:	e7ea      	b.n	b00 <prvQueueReceiveTask+0xc>
     b2a:	bf00      	nop

00000b2c <prvSetupHardware>:
}
/*-----------------------------------------------------------*/


static void prvSetupHardware( void )
{
     b2c:	b580      	push	{r7, lr}
     b2e:	af00      	add	r7, sp, #0
	SystemCoreClockUpdate();
     b30:	f009 fb52 	bl	a1d8 <SystemCoreClockUpdate>


	/* Configure the GPIO for the LEDs. */
	vParTestInitialise();
     b34:	f7ff fcc4 	bl	4c0 <vParTestInitialise>

    MSS_UART_init
     b38:	f64a 10e4 	movw	r0, #43492	; 0xa9e4
     b3c:	f2c2 0000 	movt	r0, #8192	; 0x2000
     b40:	f44f 4161 	mov.w	r1, #57600	; 0xe100
     b44:	f04f 0203 	mov.w	r2, #3
     b48:	f001 f8fe 	bl	1d48 <MSS_UART_init>
        MSS_UART_57600_BAUD,
        MSS_UART_DATA_8_BITS | MSS_UART_NO_PARITY | MSS_UART_ONE_STOP_BIT
    );

	/* ACE Initialization */
	ACE_init();
     b4c:	f008 fb4c 	bl	91e8 <ACE_init>

	/* Setup the GPIO and the NVIC for the switch used in this simple demo. */
	NVIC_SetPriority( GPIO8_IRQn, configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY );
     b50:	f04f 0028 	mov.w	r0, #40	; 0x28
     b54:	f04f 0105 	mov.w	r1, #5
     b58:	f7ff fe32 	bl	7c0 <NVIC_SetPriority>
    NVIC_EnableIRQ( GPIO8_IRQn );
     b5c:	f04f 0028 	mov.w	r0, #40	; 0x28
     b60:	f7ff fdd6 	bl	710 <NVIC_EnableIRQ>
    MSS_GPIO_config( MSS_GPIO_8, MSS_GPIO_INPUT_MODE | MSS_GPIO_IRQ_EDGE_NEGATIVE );
     b64:	f04f 0008 	mov.w	r0, #8
     b68:	f04f 0162 	mov.w	r1, #98	; 0x62
     b6c:	f003 fac2 	bl	40f4 <MSS_GPIO_config>
    MSS_GPIO_enable_irq( MSS_GPIO_8 );
     b70:	f04f 0008 	mov.w	r0, #8
     b74:	f003 fb90 	bl	4298 <MSS_GPIO_enable_irq>
}
     b78:	bd80      	pop	{r7, pc}
     b7a:	bf00      	nop

00000b7c <vApplicationMallocFailedHook>:
/*-----------------------------------------------------------*/

void vApplicationMallocFailedHook( void )
{
     b7c:	b480      	push	{r7}
     b7e:	af00      	add	r7, sp, #0
	/* Called if a call to pvPortMalloc() fails because there is insufficient
	free memory available in the FreeRTOS heap.  pvPortMalloc() is called
	internally by FreeRTOS API functions that create tasks, queues, software
	timers, and semaphores.  The size of the FreeRTOS heap is set by the
	configTOTAL_HEAP_SIZE configuration constant in FreeRTOSConfig.h. */
	for( ;; );
     b80:	e7fe      	b.n	b80 <vApplicationMallocFailedHook+0x4>
     b82:	bf00      	nop

00000b84 <vApplicationStackOverflowHook>:
}
/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName )
{
     b84:	b480      	push	{r7}
     b86:	b085      	sub	sp, #20
     b88:	af00      	add	r7, sp, #0
     b8a:	6078      	str	r0, [r7, #4]
     b8c:	6039      	str	r1, [r7, #0]

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
     b8e:	f04f 0328 	mov.w	r3, #40	; 0x28
     b92:	f383 8811 	msr	BASEPRI, r3
     b96:	f3bf 8f6f 	isb	sy
     b9a:	f3bf 8f4f 	dsb	sy
     b9e:	60fb      	str	r3, [r7, #12]

	/* Run time stack overflow checking is performed if
	configconfigCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected. */
	taskDISABLE_INTERRUPTS();
	for( ;; );
     ba0:	e7fe      	b.n	ba0 <vApplicationStackOverflowHook+0x1c>
     ba2:	bf00      	nop

00000ba4 <vApplicationIdleHook>:
}
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
     ba4:	b580      	push	{r7, lr}
     ba6:	b082      	sub	sp, #8
     ba8:	af00      	add	r7, sp, #0
volatile size_t xFreeStackSpace;

	/* This function is called on each cycle of the idle task.  In this case it
	does nothing useful, other than report the amount of FreeRTOS heap that
	remains unallocated. */
	xFreeStackSpace = xPortGetFreeHeapSize();
     baa:	f013 f9e3 	bl	13f74 <xPortGetFreeHeapSize>
     bae:	4603      	mov	r3, r0
     bb0:	607b      	str	r3, [r7, #4]

	if( xFreeStackSpace > 100 )
     bb2:	687b      	ldr	r3, [r7, #4]
		/* By now, the kernel has allocated everything it is going to, so
		if there is a lot of heap remaining unallocated then
		the value of configTOTAL_HEAP_SIZE in FreeRTOSConfig.h can be
		reduced accordingly. */
	}
}
     bb4:	f107 0708 	add.w	r7, r7, #8
     bb8:	46bd      	mov	sp, r7
     bba:	bd80      	pop	{r7, pc}

00000bbc <pcGetTaskStatusMessage>:
/*-----------------------------------------------------------*/

char *pcGetTaskStatusMessage( void )
{
     bbc:	b480      	push	{r7}
     bbe:	af00      	add	r7, sp, #0
	/* Not bothered about a critical section here although technically because
	of the task priorities the pointer could change it will be atomic if not
	near atomic and its not critical. */
	if( pcStatusMessage == NULL )
     bc0:	f240 53fc 	movw	r3, #1532	; 0x5fc
     bc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     bc8:	681b      	ldr	r3, [r3, #0]
     bca:	2b00      	cmp	r3, #0
     bcc:	d104      	bne.n	bd8 <pcGetTaskStatusMessage+0x1c>
	{
		return "All tasks running without error";
     bce:	f64a 33f8 	movw	r3, #44024	; 0xabf8
     bd2:	f2c0 0301 	movt	r3, #1
     bd6:	e004      	b.n	be2 <pcGetTaskStatusMessage+0x26>
	}
	else
	{
		return ( char * ) pcStatusMessage;
     bd8:	f240 53fc 	movw	r3, #1532	; 0x5fc
     bdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
     be0:	681b      	ldr	r3, [r3, #0]
	}
}
     be2:	4618      	mov	r0, r3
     be4:	46bd      	mov	sp, r7
     be6:	bc80      	pop	{r7}
     be8:	4770      	bx	lr
     bea:	bf00      	nop

00000bec <vMainConfigureTimerForRunTimeStats>:
/*-----------------------------------------------------------*/

void vMainConfigureTimerForRunTimeStats( void )
{
     bec:	b580      	push	{r7, lr}
     bee:	b082      	sub	sp, #8
     bf0:	af00      	add	r7, sp, #0
const unsigned long ulMax32BitValue = 0xffffffffUL;
     bf2:	f04f 33ff 	mov.w	r3, #4294967295
     bf6:	607b      	str	r3, [r7, #4]

	MSS_TIM64_init( MSS_TIMER_PERIODIC_MODE );
     bf8:	f04f 0000 	mov.w	r0, #0
     bfc:	f7ff fe0e 	bl	81c <MSS_TIM64_init>
	MSS_TIM64_load_immediate( ulMax32BitValue, ulMax32BitValue );
     c00:	6878      	ldr	r0, [r7, #4]
     c02:	6879      	ldr	r1, [r7, #4]
     c04:	f7ff fe6a 	bl	8dc <MSS_TIM64_load_immediate>
	MSS_TIM64_start();
     c08:	f7ff fe5a 	bl	8c0 <MSS_TIM64_start>
}
     c0c:	f107 0708 	add.w	r7, r7, #8
     c10:	46bd      	mov	sp, r7
     c12:	bd80      	pop	{r7, pc}

00000c14 <ulGetRunTimeCounterValue>:
/*-----------------------------------------------------------*/

unsigned long ulGetRunTimeCounterValue( void )
{
     c14:	b480      	push	{r7}
     c16:	af00      	add	r7, sp, #0
	return 0UL;
     c18:	f04f 0300 	mov.w	r3, #0
}
     c1c:	4618      	mov	r0, r3
     c1e:	46bd      	mov	sp, r7
     c20:	bc80      	pop	{r7}
     c22:	4770      	bx	lr
     c24:	0000      	lsls	r0, r0, #0
	...

00000c28 <uart_task>:


void uart_task(void *para)
{
     c28:	b580      	push	{r7, lr}
     c2a:	b088      	sub	sp, #32
     c2c:	af00      	add	r7, sp, #0
     c2e:	6078      	str	r0, [r7, #4]
	uart_string_print((uint8_t *) "\n********* Welcome to the Measurement System  *********\n\r");
     c30:	f64a 4018 	movw	r0, #44056	; 0xac18
     c34:	f2c0 0001 	movt	r0, #1
     c38:	f009 fd4a 	bl	a6d0 <uart_string_print>

	for( ;; )
		{
			uart_string_print((uint8_t *)"\n\r");
     c3c:	f64a 4054 	movw	r0, #44116	; 0xac54
     c40:	f2c0 0001 	movt	r0, #1
     c44:	f009 fd44 	bl	a6d0 <uart_string_print>
			uart_string_print((uint8_t *) "********* SmartFusion Play Menu **************\n\r" );
     c48:	f64a 4058 	movw	r0, #44120	; 0xac58
     c4c:	f2c0 0001 	movt	r0, #1
     c50:	f009 fd3e 	bl	a6d0 <uart_string_print>
			uart_string_print((uint8_t *) "********* 0.  Multimeter *********************\n\r" );
     c54:	f64a 408c 	movw	r0, #44172	; 0xac8c
     c58:	f2c0 0001 	movt	r0, #1
     c5c:	f009 fd38 	bl	a6d0 <uart_string_print>
			uart_string_print((uint8_t *) "\n");
     c60:	f64a 40c0 	movw	r0, #44224	; 0xacc0
     c64:	f2c0 0001 	movt	r0, #1
     c68:	f009 fd32 	bl	a6d0 <uart_string_print>

	        do
	        {
	            rx_size = MSS_UART_get_rx(&g_mss_uart0, &key, 1);
     c6c:	f64a 10e4 	movw	r0, #43492	; 0xa9e4
     c70:	f2c2 0000 	movt	r0, #8192	; 0x2000
     c74:	f240 6100 	movw	r1, #1536	; 0x600
     c78:	f2c2 0100 	movt	r1, #8192	; 0x2000
     c7c:	f04f 0201 	mov.w	r2, #1
     c80:	f001 fade 	bl	2240 <MSS_UART_get_rx>
     c84:	4603      	mov	r3, r0
     c86:	b2da      	uxtb	r2, r3
     c88:	f240 6301 	movw	r3, #1537	; 0x601
     c8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     c90:	701a      	strb	r2, [r3, #0]
	        }while(rx_size == 0);
     c92:	f240 6301 	movw	r3, #1537	; 0x601
     c96:	f2c2 0300 	movt	r3, #8192	; 0x2000
     c9a:	781b      	ldrb	r3, [r3, #0]
     c9c:	2b00      	cmp	r3, #0
     c9e:	d0e5      	beq.n	c6c <uart_task+0x44>

	        rx_size = 0;
     ca0:	f240 6301 	movw	r3, #1537	; 0x601
     ca4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     ca8:	f04f 0200 	mov.w	r2, #0
     cac:	701a      	strb	r2, [r3, #0]
	        inMultimeter = 0;
     cae:	f64a 13b1 	movw	r3, #43441	; 0xa9b1
     cb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
     cb6:	f04f 0200 	mov.w	r2, #0
     cba:	701a      	strb	r2, [r3, #0]
	        switch(key)
     cbc:	f240 6300 	movw	r3, #1536	; 0x600
     cc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
     cc4:	781b      	ldrb	r3, [r3, #0]
     cc6:	2b30      	cmp	r3, #48	; 0x30
     cc8:	d116      	bne.n	cf8 <uart_task+0xd0>
	            case MULTIMETER:
	            {
	                //inWebTask = 0;
	                //inLedTask = 0;

	                std_menu = 0;
     cca:	f64a 13b0 	movw	r3, #43440	; 0xa9b0
     cce:	f2c2 0300 	movt	r3, #8192	; 0x2000
     cd2:	f04f 0200 	mov.w	r2, #0
     cd6:	701a      	strb	r2, [r3, #0]
	                char voltage_str[20];
//	                char voltage_val_str[5];
//	                strcpy(voltage_str, "Voltage: ");
//	                fprintf(voltage_val_str, "%5.2f", 42.6);
//	                strcat(voltage_str,voltage_val_str);
	                gcvt(55.3, 6, voltage_str);
     cd8:	f107 030c 	add.w	r3, r7, #12
     cdc:	a10e      	add	r1, pc, #56	; (adr r1, d18 <uart_task+0xf0>)
     cde:	e9d1 0100 	ldrd	r0, r1, [r1]
     ce2:	f04f 0206 	mov.w	r2, #6
     ce6:	f013 ffcd 	bl	14c84 <gcvt>
	                //strcat(voltage_str, " mV");

	                uart_string_print((uint8_t *)voltage_str);
     cea:	f107 030c 	add.w	r3, r7, #12
     cee:	4618      	mov	r0, r3
     cf0:	f009 fcee 	bl	a6d0 <uart_string_print>

	                break;
     cf4:	bf00      	nop
	            	uart_string_print((uint8_t *)"**** Please Enter Your Choice      ****** \n\r");
	                break;
	            }

	        }
		}
     cf6:	e7a1      	b.n	c3c <uart_task+0x14>
	                break;
	            }

	            default:  /* If selected key is out of range */
	            {
	            	uart_string_print((uint8_t *)"Invalid Key \n\r");
     cf8:	f64a 40c4 	movw	r0, #44228	; 0xacc4
     cfc:	f2c0 0001 	movt	r0, #1
     d00:	f009 fce6 	bl	a6d0 <uart_string_print>
	            	uart_string_print((uint8_t *)"**** Please Enter Your Choice      ****** \n\r");
     d04:	f64a 40d4 	movw	r0, #44244	; 0xacd4
     d08:	f2c0 0001 	movt	r0, #1
     d0c:	f009 fce0 	bl	a6d0 <uart_string_print>
	                break;
	            }

	        }
		}
     d10:	e794      	b.n	c3c <uart_task+0x14>
     d12:	bf00      	nop
     d14:	f3af 8000 	nop.w
     d18:	66666666 	.word	0x66666666
     d1c:	404ba666 	.word	0x404ba666

00000d20 <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
     d20:	b480      	push	{r7}
     d22:	b083      	sub	sp, #12
     d24:	af00      	add	r7, sp, #0
     d26:	4603      	mov	r3, r0
     d28:	80fb      	strh	r3, [r7, #6]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
     d2a:	f24e 1300 	movw	r3, #57600	; 0xe100
     d2e:	f2ce 0300 	movt	r3, #57344	; 0xe000
     d32:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
     d36:	ea4f 1252 	mov.w	r2, r2, lsr #5
     d3a:	88f9      	ldrh	r1, [r7, #6]
     d3c:	f001 011f 	and.w	r1, r1, #31
     d40:	f04f 0001 	mov.w	r0, #1
     d44:	fa00 f101 	lsl.w	r1, r0, r1
     d48:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
     d4c:	f107 070c 	add.w	r7, r7, #12
     d50:	46bd      	mov	sp, r7
     d52:	bc80      	pop	{r7}
     d54:	4770      	bx	lr
     d56:	bf00      	nop

00000d58 <NVIC_SetPriority>:
 * interrupt, or negative to specify an internal (core) interrupt.
 *
 * Note: The priority cannot be set for every core interrupt.
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
     d58:	b480      	push	{r7}
     d5a:	b083      	sub	sp, #12
     d5c:	af00      	add	r7, sp, #0
     d5e:	4603      	mov	r3, r0
     d60:	6039      	str	r1, [r7, #0]
     d62:	80fb      	strh	r3, [r7, #6]
  if(IRQn < 0) {
     d64:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
     d68:	2b00      	cmp	r3, #0
     d6a:	da10      	bge.n	d8e <NVIC_SetPriority+0x36>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M3 System Interrupts */
     d6c:	f64e 5300 	movw	r3, #60672	; 0xed00
     d70:	f2ce 0300 	movt	r3, #57344	; 0xe000
     d74:	88fa      	ldrh	r2, [r7, #6]
     d76:	f002 020f 	and.w	r2, r2, #15
     d7a:	f1a2 0104 	sub.w	r1, r2, #4
     d7e:	683a      	ldr	r2, [r7, #0]
     d80:	b2d2      	uxtb	r2, r2
     d82:	ea4f 02c2 	mov.w	r2, r2, lsl #3
     d86:	b2d2      	uxtb	r2, r2
     d88:	440b      	add	r3, r1
     d8a:	761a      	strb	r2, [r3, #24]
     d8c:	e00d      	b.n	daa <NVIC_SetPriority+0x52>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
     d8e:	f24e 1300 	movw	r3, #57600	; 0xe100
     d92:	f2ce 0300 	movt	r3, #57344	; 0xe000
     d96:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
     d9a:	683a      	ldr	r2, [r7, #0]
     d9c:	b2d2      	uxtb	r2, r2
     d9e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
     da2:	b2d2      	uxtb	r2, r2
     da4:	440b      	add	r3, r1
     da6:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
     daa:	f107 070c 	add.w	r7, r7, #12
     dae:	46bd      	mov	sp, r7
     db0:	bc80      	pop	{r7}
     db2:	4770      	bx	lr

00000db4 <clock_time>:
QueueHandle_t xEMACEventQueue = NULL;

/*-----------------------------------------------------------*/

clock_time_t clock_time( void )
{
     db4:	b580      	push	{r7, lr}
     db6:	af00      	add	r7, sp, #0
	return xTaskGetTickCount();
     db8:	f010 fc60 	bl	1167c <xTaskGetTickCount>
     dbc:	4603      	mov	r3, r0
}
     dbe:	4618      	mov	r0, r3
     dc0:	bd80      	pop	{r7, pc}
     dc2:	bf00      	nop

00000dc4 <vuIP_Task>:
/*-----------------------------------------------------------*/

void vuIP_Task( void *pvParameters )
{
     dc4:	b590      	push	{r4, r7, lr}
     dc6:	b087      	sub	sp, #28
     dc8:	af00      	add	r7, sp, #0
     dca:	6078      	str	r0, [r7, #4]
portBASE_TYPE i;
unsigned long ulNewEvent = 0UL, ulUIP_Events = 0UL;
     dcc:	f04f 0300 	mov.w	r3, #0
     dd0:	60bb      	str	r3, [r7, #8]
     dd2:	f04f 0300 	mov.w	r3, #0
     dd6:	613b      	str	r3, [r7, #16]

	/* Just to prevent compiler warnings about the unused parameter. */
	( void ) pvParameters;

	/* Initialise the uIP stack, configuring for web server usage. */
	prvInitialise_uIP();
     dd8:	f000 f8fe 	bl	fd8 <prvInitialise_uIP>

	/* Initialise the MAC and PHY. */
	prvInitEmac();
     ddc:	f000 fa06 	bl	11ec <prvInitEmac>
     de0:	e000      	b.n	de4 <vuIP_Task+0x20>
		if( ulUIP_Events == pdFALSE )
		{
			xQueueReceive( xEMACEventQueue, &ulNewEvent, portMAX_DELAY );
			ulUIP_Events |= ulNewEvent;
		}
	}
     de2:	bf00      	nop
	prvInitEmac();

	for( ;; )
	{
		/* Is there received data ready to be processed? */
		lPacketLength = MSS_MAC_rx_packet();
     de4:	f004 f96a 	bl	50bc <MSS_MAC_rx_packet>
     de8:	4603      	mov	r3, r0
     dea:	617b      	str	r3, [r7, #20]

		/* Statements to be executed if data has been received on the Ethernet. */
		if( ( lPacketLength > 0 ) && ( uip_buf != NULL ) )
     dec:	697b      	ldr	r3, [r7, #20]
     dee:	2b00      	cmp	r3, #0
     df0:	dd4f      	ble.n	e92 <vuIP_Task+0xce>
     df2:	f240 63a4 	movw	r3, #1700	; 0x6a4
     df6:	f2c2 0300 	movt	r3, #8192	; 0x2000
     dfa:	681b      	ldr	r3, [r3, #0]
     dfc:	2b00      	cmp	r3, #0
     dfe:	d048      	beq.n	e92 <vuIP_Task+0xce>
		{
			uip_len = ( u16_t ) lPacketLength;
     e00:	697b      	ldr	r3, [r7, #20]
     e02:	b29a      	uxth	r2, r3
     e04:	f64a 4328 	movw	r3, #44072	; 0xac28
     e08:	f2c2 0300 	movt	r3, #8192	; 0x2000
     e0c:	801a      	strh	r2, [r3, #0]

			/* Standard uIP loop taken from the uIP manual. */
			if( xHeader->type == htons( UIP_ETHTYPE_IP ) )
     e0e:	f240 63a4 	movw	r3, #1700	; 0x6a4
     e12:	f2c2 0300 	movt	r3, #8192	; 0x2000
     e16:	681b      	ldr	r3, [r3, #0]
     e18:	7b1a      	ldrb	r2, [r3, #12]
     e1a:	7b5b      	ldrb	r3, [r3, #13]
     e1c:	ea4f 2303 	mov.w	r3, r3, lsl #8
     e20:	ea43 0302 	orr.w	r3, r3, r2
     e24:	b29c      	uxth	r4, r3
     e26:	f44f 6000 	mov.w	r0, #2048	; 0x800
     e2a:	f00c fc95 	bl	d758 <htons>
     e2e:	4603      	mov	r3, r0
     e30:	429c      	cmp	r4, r3
     e32:	d10f      	bne.n	e54 <vuIP_Task+0x90>
			{
				uip_arp_ipin();
				uip_input();
     e34:	f04f 0001 	mov.w	r0, #1
     e38:	f00a fbb6 	bl	b5a8 <uip_process>

				/* If the above function invocation resulted in data that
				should be sent out on the network, the global variable
				uip_len is set to a value > 0. */
				if( uip_len > 0 )
     e3c:	f64a 4328 	movw	r3, #44072	; 0xac28
     e40:	f2c2 0300 	movt	r3, #8192	; 0x2000
     e44:	881b      	ldrh	r3, [r3, #0]
     e46:	2b00      	cmp	r3, #0
     e48:	d028      	beq.n	e9c <vuIP_Task+0xd8>
				{
					uip_arp_out();
     e4a:	f00d f87b 	bl	df44 <uip_arp_out>
					vEMACWrite();
     e4e:	f000 f9eb 	bl	1228 <vEMACWrite>
	{
		/* Is there received data ready to be processed? */
		lPacketLength = MSS_MAC_rx_packet();

		/* Statements to be executed if data has been received on the Ethernet. */
		if( ( lPacketLength > 0 ) && ( uip_buf != NULL ) )
     e52:	e028      	b.n	ea6 <vuIP_Task+0xe2>
				{
					uip_arp_out();
					vEMACWrite();
				}
			}
			else if( xHeader->type == htons( UIP_ETHTYPE_ARP ) )
     e54:	f240 63a4 	movw	r3, #1700	; 0x6a4
     e58:	f2c2 0300 	movt	r3, #8192	; 0x2000
     e5c:	681b      	ldr	r3, [r3, #0]
     e5e:	7b1a      	ldrb	r2, [r3, #12]
     e60:	7b5b      	ldrb	r3, [r3, #13]
     e62:	ea4f 2303 	mov.w	r3, r3, lsl #8
     e66:	ea43 0302 	orr.w	r3, r3, r2
     e6a:	b29c      	uxth	r4, r3
     e6c:	f640 0006 	movw	r0, #2054	; 0x806
     e70:	f00c fc72 	bl	d758 <htons>
     e74:	4603      	mov	r3, r0
     e76:	429c      	cmp	r4, r3
     e78:	d112      	bne.n	ea0 <vuIP_Task+0xdc>
			{
				uip_arp_arpin();
     e7a:	f00c fedf 	bl	dc3c <uip_arp_arpin>

				/* If the above function invocation resulted in data that
				should be sent out on the network, the global variable
				uip_len is set to a value > 0. */
				if( uip_len > 0 )
     e7e:	f64a 4328 	movw	r3, #44072	; 0xac28
     e82:	f2c2 0300 	movt	r3, #8192	; 0x2000
     e86:	881b      	ldrh	r3, [r3, #0]
     e88:	2b00      	cmp	r3, #0
     e8a:	d00b      	beq.n	ea4 <vuIP_Task+0xe0>
				{
					vEMACWrite();
     e8c:	f000 f9cc 	bl	1228 <vEMACWrite>
	{
		/* Is there received data ready to be processed? */
		lPacketLength = MSS_MAC_rx_packet();

		/* Statements to be executed if data has been received on the Ethernet. */
		if( ( lPacketLength > 0 ) && ( uip_buf != NULL ) )
     e90:	e009      	b.n	ea6 <vuIP_Task+0xe2>
			}
		}
		else
		{
			/* Clear the RX event latched in ulUIP_Events - if one was latched. */
			ulUIP_Events &= ~uipETHERNET_RX_EVENT;
     e92:	693b      	ldr	r3, [r7, #16]
     e94:	f023 0301 	bic.w	r3, r3, #1
     e98:	613b      	str	r3, [r7, #16]
     e9a:	e004      	b.n	ea6 <vuIP_Task+0xe2>
	{
		/* Is there received data ready to be processed? */
		lPacketLength = MSS_MAC_rx_packet();

		/* Statements to be executed if data has been received on the Ethernet. */
		if( ( lPacketLength > 0 ) && ( uip_buf != NULL ) )
     e9c:	bf00      	nop
     e9e:	e002      	b.n	ea6 <vuIP_Task+0xe2>
     ea0:	bf00      	nop
     ea2:	e000      	b.n	ea6 <vuIP_Task+0xe2>
     ea4:	bf00      	nop
			/* Clear the RX event latched in ulUIP_Events - if one was latched. */
			ulUIP_Events &= ~uipETHERNET_RX_EVENT;
		}

		/* Statements to be executed if the TCP/IP period timer has expired. */
		if( ( ulUIP_Events & uipPERIODIC_TIMER_EVENT ) != 0UL )
     ea6:	693b      	ldr	r3, [r7, #16]
     ea8:	f003 0308 	and.w	r3, r3, #8
     eac:	2b00      	cmp	r3, #0
     eae:	d033      	beq.n	f18 <vuIP_Task+0x154>
		{
			ulUIP_Events &= ~uipPERIODIC_TIMER_EVENT;
     eb0:	693b      	ldr	r3, [r7, #16]
     eb2:	f023 0308 	bic.w	r3, r3, #8
     eb6:	613b      	str	r3, [r7, #16]

			if( uip_buf != NULL )
     eb8:	f240 63a4 	movw	r3, #1700	; 0x6a4
     ebc:	f2c2 0300 	movt	r3, #8192	; 0x2000
     ec0:	681b      	ldr	r3, [r3, #0]
     ec2:	2b00      	cmp	r3, #0
     ec4:	d028      	beq.n	f18 <vuIP_Task+0x154>
			{
				for( i = 0; i < UIP_CONNS; i++ )
     ec6:	f04f 0300 	mov.w	r3, #0
     eca:	60fb      	str	r3, [r7, #12]
     ecc:	e021      	b.n	f12 <vuIP_Task+0x14e>
				{
					uip_periodic( i );
     ece:	68fb      	ldr	r3, [r7, #12]
     ed0:	f04f 02cc 	mov.w	r2, #204	; 0xcc
     ed4:	fb02 f203 	mul.w	r2, r2, r3
     ed8:	f64a 4340 	movw	r3, #44096	; 0xac40
     edc:	f2c2 0300 	movt	r3, #8192	; 0x2000
     ee0:	441a      	add	r2, r3
     ee2:	f64a 433c 	movw	r3, #44092	; 0xac3c
     ee6:	f2c2 0300 	movt	r3, #8192	; 0x2000
     eea:	601a      	str	r2, [r3, #0]
     eec:	f04f 0002 	mov.w	r0, #2
     ef0:	f00a fb5a 	bl	b5a8 <uip_process>

					/* If the above function invocation resulted in data that
					should be sent out on the network, the global variable
					uip_len is set to a value > 0. */
					if( uip_len > 0 )
     ef4:	f64a 4328 	movw	r3, #44072	; 0xac28
     ef8:	f2c2 0300 	movt	r3, #8192	; 0x2000
     efc:	881b      	ldrh	r3, [r3, #0]
     efe:	2b00      	cmp	r3, #0
     f00:	d003      	beq.n	f0a <vuIP_Task+0x146>
					{
						uip_arp_out();
     f02:	f00d f81f 	bl	df44 <uip_arp_out>
						vEMACWrite();
     f06:	f000 f98f 	bl	1228 <vEMACWrite>
		{
			ulUIP_Events &= ~uipPERIODIC_TIMER_EVENT;

			if( uip_buf != NULL )
			{
				for( i = 0; i < UIP_CONNS; i++ )
     f0a:	68fb      	ldr	r3, [r7, #12]
     f0c:	f103 0301 	add.w	r3, r3, #1
     f10:	60fb      	str	r3, [r7, #12]
     f12:	68fb      	ldr	r3, [r7, #12]
     f14:	2b27      	cmp	r3, #39	; 0x27
     f16:	ddda      	ble.n	ece <vuIP_Task+0x10a>
				}
			}
		}

		/* Statements to be executed if the ARP timer has expired. */
		if( ( ulUIP_Events & uipARP_TIMER_EVENT ) != 0 )
     f18:	693b      	ldr	r3, [r7, #16]
     f1a:	f003 0304 	and.w	r3, r3, #4
     f1e:	2b00      	cmp	r3, #0
     f20:	d005      	beq.n	f2e <vuIP_Task+0x16a>
		{
			ulUIP_Events &= ~uipARP_TIMER_EVENT;
     f22:	693b      	ldr	r3, [r7, #16]
     f24:	f023 0304 	bic.w	r3, r3, #4
     f28:	613b      	str	r3, [r7, #16]
			uip_arp_timer();
     f2a:	f00c fcd5 	bl	d8d8 <uip_arp_timer>
		}

		/* If all latched events have been cleared - block until another event
		occurs. */
		if( ulUIP_Events == pdFALSE )
     f2e:	693b      	ldr	r3, [r7, #16]
     f30:	2b00      	cmp	r3, #0
     f32:	f47f af56 	bne.w	de2 <vuIP_Task+0x1e>
		{
			xQueueReceive( xEMACEventQueue, &ulNewEvent, portMAX_DELAY );
     f36:	f240 6308 	movw	r3, #1544	; 0x608
     f3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     f3e:	681a      	ldr	r2, [r3, #0]
     f40:	f107 0308 	add.w	r3, r7, #8
     f44:	4610      	mov	r0, r2
     f46:	4619      	mov	r1, r3
     f48:	f04f 32ff 	mov.w	r2, #4294967295
     f4c:	f00e fd5c 	bl	fa08 <xQueueReceive>
			ulUIP_Events |= ulNewEvent;
     f50:	68bb      	ldr	r3, [r7, #8]
     f52:	693a      	ldr	r2, [r7, #16]
     f54:	ea42 0303 	orr.w	r3, r2, r3
     f58:	613b      	str	r3, [r7, #16]
		}
	}
     f5a:	e743      	b.n	de4 <vuIP_Task+0x20>

00000f5c <prvSetMACAddress>:
}
/*-----------------------------------------------------------*/

static void prvSetMACAddress( void )
{
     f5c:	b480      	push	{r7}
     f5e:	b083      	sub	sp, #12
     f60:	af00      	add	r7, sp, #0
struct uip_eth_addr xAddr;

	/* Configure the MAC address in the uIP stack. */
	xAddr.addr[ 0 ] = configMAC_ADDR0;
     f62:	f04f 0300 	mov.w	r3, #0
     f66:	703b      	strb	r3, [r7, #0]
	xAddr.addr[ 1 ] = configMAC_ADDR1;
     f68:	f04f 0312 	mov.w	r3, #18
     f6c:	707b      	strb	r3, [r7, #1]
	xAddr.addr[ 2 ] = configMAC_ADDR2;
     f6e:	f04f 0313 	mov.w	r3, #19
     f72:	70bb      	strb	r3, [r7, #2]
	xAddr.addr[ 3 ] = configMAC_ADDR3;
     f74:	f04f 0310 	mov.w	r3, #16
     f78:	70fb      	strb	r3, [r7, #3]
	xAddr.addr[ 4 ] = configMAC_ADDR4;
     f7a:	f04f 0315 	mov.w	r3, #21
     f7e:	713b      	strb	r3, [r7, #4]
	xAddr.addr[ 5 ] = configMAC_ADDR5;
     f80:	f04f 0311 	mov.w	r3, #17
     f84:	717b      	strb	r3, [r7, #5]
	uip_setethaddr( xAddr );
     f86:	783a      	ldrb	r2, [r7, #0]
     f88:	f642 737c 	movw	r3, #12156	; 0x2f7c
     f8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     f90:	701a      	strb	r2, [r3, #0]
     f92:	787a      	ldrb	r2, [r7, #1]
     f94:	f642 737c 	movw	r3, #12156	; 0x2f7c
     f98:	f2c2 0300 	movt	r3, #8192	; 0x2000
     f9c:	705a      	strb	r2, [r3, #1]
     f9e:	78ba      	ldrb	r2, [r7, #2]
     fa0:	f642 737c 	movw	r3, #12156	; 0x2f7c
     fa4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     fa8:	709a      	strb	r2, [r3, #2]
     faa:	78fa      	ldrb	r2, [r7, #3]
     fac:	f642 737c 	movw	r3, #12156	; 0x2f7c
     fb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
     fb4:	70da      	strb	r2, [r3, #3]
     fb6:	793a      	ldrb	r2, [r7, #4]
     fb8:	f642 737c 	movw	r3, #12156	; 0x2f7c
     fbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
     fc0:	711a      	strb	r2, [r3, #4]
     fc2:	797a      	ldrb	r2, [r7, #5]
     fc4:	f642 737c 	movw	r3, #12156	; 0x2f7c
     fc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
     fcc:	715a      	strb	r2, [r3, #5]
}
     fce:	f107 070c 	add.w	r7, r7, #12
     fd2:	46bd      	mov	sp, r7
     fd4:	bc80      	pop	{r7}
     fd6:	4770      	bx	lr

00000fd8 <prvInitialise_uIP>:
/*-----------------------------------------------------------*/

static void prvInitialise_uIP( void )
{
     fd8:	b580      	push	{r7, lr}
     fda:	b088      	sub	sp, #32
     fdc:	af02      	add	r7, sp, #8
uip_ipaddr_t xIPAddr;
TimerHandle_t xARPTimer, xPeriodicTimer;

	uip_init();
     fde:	f00a f8c5 	bl	b16c <uip_init>
	uip_ipaddr( &xIPAddr, configIP_ADDR0, configIP_ADDR1, configIP_ADDR2, configIP_ADDR3 );
     fe2:	f06f 033f 	mvn.w	r3, #63	; 0x3f
     fe6:	713b      	strb	r3, [r7, #4]
     fe8:	f06f 0357 	mvn.w	r3, #87	; 0x57
     fec:	717b      	strb	r3, [r7, #5]
     fee:	f04f 0300 	mov.w	r3, #0
     ff2:	71bb      	strb	r3, [r7, #6]
     ff4:	f06f 0337 	mvn.w	r3, #55	; 0x37
     ff8:	71fb      	strb	r3, [r7, #7]
	uip_sethostaddr( &xIPAddr );
     ffa:	793a      	ldrb	r2, [r7, #4]
     ffc:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    1000:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1004:	701a      	strb	r2, [r3, #0]
    1006:	797a      	ldrb	r2, [r7, #5]
    1008:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    100c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1010:	705a      	strb	r2, [r3, #1]
    1012:	79ba      	ldrb	r2, [r7, #6]
    1014:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    1018:	f2c2 0300 	movt	r3, #8192	; 0x2000
    101c:	709a      	strb	r2, [r3, #2]
    101e:	79fa      	ldrb	r2, [r7, #7]
    1020:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    1024:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1028:	70da      	strb	r2, [r3, #3]
	uip_ipaddr( &xIPAddr, configNET_MASK0, configNET_MASK1, configNET_MASK2, configNET_MASK3 );
    102a:	f04f 33ff 	mov.w	r3, #4294967295
    102e:	713b      	strb	r3, [r7, #4]
    1030:	f04f 33ff 	mov.w	r3, #4294967295
    1034:	717b      	strb	r3, [r7, #5]
    1036:	f04f 33ff 	mov.w	r3, #4294967295
    103a:	71bb      	strb	r3, [r7, #6]
    103c:	f04f 0300 	mov.w	r3, #0
    1040:	71fb      	strb	r3, [r7, #7]
	uip_setnetmask( &xIPAddr );
    1042:	793a      	ldrb	r2, [r7, #4]
    1044:	f64c 43ac 	movw	r3, #52396	; 0xccac
    1048:	f2c2 0300 	movt	r3, #8192	; 0x2000
    104c:	701a      	strb	r2, [r3, #0]
    104e:	797a      	ldrb	r2, [r7, #5]
    1050:	f64c 43ac 	movw	r3, #52396	; 0xccac
    1054:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1058:	705a      	strb	r2, [r3, #1]
    105a:	79ba      	ldrb	r2, [r7, #6]
    105c:	f64c 43ac 	movw	r3, #52396	; 0xccac
    1060:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1064:	709a      	strb	r2, [r3, #2]
    1066:	79fa      	ldrb	r2, [r7, #7]
    1068:	f64c 43ac 	movw	r3, #52396	; 0xccac
    106c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1070:	70da      	strb	r2, [r3, #3]
	prvSetMACAddress();
    1072:	f7ff ff73 	bl	f5c <prvSetMACAddress>
	httpd_init();
    1076:	f00e f829 	bl	f0cc <httpd_init>

	/* Create the queue used to sent TCP/IP events to the uIP stack. */
	xEMACEventQueue = xQueueCreate( uipEVENT_QUEUE_LENGTH, sizeof( unsigned long ) );
    107a:	f04f 000a 	mov.w	r0, #10
    107e:	f04f 0104 	mov.w	r1, #4
    1082:	f04f 0200 	mov.w	r2, #0
    1086:	f00e f95b 	bl	f340 <xQueueGenericCreate>
    108a:	4602      	mov	r2, r0
    108c:	f240 6308 	movw	r3, #1544	; 0x608
    1090:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1094:	601a      	str	r2, [r3, #0]

	/* Create and start the uIP timers. */
	xARPTimer = xTimerCreate( 	"ARPTimer", /* Just a name that is helpful for debugging, not used by the kernel. */
    1096:	f241 237d 	movw	r3, #4733	; 0x127d
    109a:	f2c0 0300 	movt	r3, #0
    109e:	9300      	str	r3, [sp, #0]
    10a0:	f64a 5004 	movw	r0, #44292	; 0xad04
    10a4:	f2c0 0001 	movt	r0, #1
    10a8:	f242 7110 	movw	r1, #10000	; 0x2710
    10ac:	f04f 0201 	mov.w	r2, #1
    10b0:	f04f 0300 	mov.w	r3, #0
    10b4:	f012 fa0c 	bl	134d0 <xTimerCreate>
    10b8:	4603      	mov	r3, r0
    10ba:	60bb      	str	r3, [r7, #8]
								pdTRUE, /* Autor-reload. */
								( void * ) uipARP_TIMER,
								prvUIPTimerCallback
							);

	xPeriodicTimer = xTimerCreate( 	"PeriodicTimer",
    10bc:	f241 237d 	movw	r3, #4733	; 0x127d
    10c0:	f2c0 0300 	movt	r3, #0
    10c4:	9300      	str	r3, [sp, #0]
    10c6:	f64a 5010 	movw	r0, #44304	; 0xad10
    10ca:	f2c0 0001 	movt	r0, #1
    10ce:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
    10d2:	f04f 0201 	mov.w	r2, #1
    10d6:	f04f 0301 	mov.w	r3, #1
    10da:	f012 f9f9 	bl	134d0 <xTimerCreate>
    10de:	4603      	mov	r3, r0
    10e0:	60fb      	str	r3, [r7, #12]
									( void * ) uipPERIODIC_TIMER,
									prvUIPTimerCallback
								);

	/* Sanity check that the timers were indeed created. */
	configASSERT( xARPTimer );
    10e2:	68bb      	ldr	r3, [r7, #8]
    10e4:	2b00      	cmp	r3, #0
    10e6:	d109      	bne.n	10fc <PROCESS_STACK_SIZE+0xfc>
    10e8:	f04f 0328 	mov.w	r3, #40	; 0x28
    10ec:	f383 8811 	msr	BASEPRI, r3
    10f0:	f3bf 8f6f 	isb	sy
    10f4:	f3bf 8f4f 	dsb	sy
    10f8:	613b      	str	r3, [r7, #16]
    10fa:	e7fe      	b.n	10fa <PROCESS_STACK_SIZE+0xfa>
	configASSERT( xPeriodicTimer );
    10fc:	68fb      	ldr	r3, [r7, #12]
    10fe:	2b00      	cmp	r3, #0
    1100:	d109      	bne.n	1116 <PROCESS_STACK_SIZE+0x116>
    1102:	f04f 0328 	mov.w	r3, #40	; 0x28
    1106:	f383 8811 	msr	BASEPRI, r3
    110a:	f3bf 8f6f 	isb	sy
    110e:	f3bf 8f4f 	dsb	sy
    1112:	617b      	str	r3, [r7, #20]
    1114:	e7fe      	b.n	1114 <PROCESS_STACK_SIZE+0x114>

	/* These commands will block indefinitely until they succeed, so there is
	no point in checking their return values. */
	xTimerStart( xARPTimer, portMAX_DELAY );
    1116:	f010 fab1 	bl	1167c <xTaskGetTickCount>
    111a:	4603      	mov	r3, r0
    111c:	f04f 32ff 	mov.w	r2, #4294967295
    1120:	9200      	str	r2, [sp, #0]
    1122:	68b8      	ldr	r0, [r7, #8]
    1124:	f04f 0101 	mov.w	r1, #1
    1128:	461a      	mov	r2, r3
    112a:	f04f 0300 	mov.w	r3, #0
    112e:	f012 fa21 	bl	13574 <xTimerGenericCommand>
	xTimerStart( xPeriodicTimer, portMAX_DELAY );
    1132:	f010 faa3 	bl	1167c <xTaskGetTickCount>
    1136:	4603      	mov	r3, r0
    1138:	f04f 32ff 	mov.w	r2, #4294967295
    113c:	9200      	str	r2, [sp, #0]
    113e:	68f8      	ldr	r0, [r7, #12]
    1140:	f04f 0101 	mov.w	r1, #1
    1144:	461a      	mov	r2, r3
    1146:	f04f 0300 	mov.w	r3, #0
    114a:	f012 fa13 	bl	13574 <xTimerGenericCommand>
}
    114e:	f107 0718 	add.w	r7, r7, #24
    1152:	46bd      	mov	sp, r7
    1154:	bd80      	pop	{r7, pc}
    1156:	bf00      	nop

00001158 <prvEMACEventListener>:
/*-----------------------------------------------------------*/

static void prvEMACEventListener( unsigned long ulISREvents )
{
    1158:	b580      	push	{r7, lr}
    115a:	b086      	sub	sp, #24
    115c:	af00      	add	r7, sp, #0
    115e:	6078      	str	r0, [r7, #4]
long lHigherPriorityTaskWoken = pdFALSE;
    1160:	f04f 0300 	mov.w	r3, #0
    1164:	613b      	str	r3, [r7, #16]
const unsigned long ulRxEvent = uipETHERNET_RX_EVENT;
    1166:	f04f 0301 	mov.w	r3, #1
    116a:	60fb      	str	r3, [r7, #12]

	/* Sanity check that the event queue was indeed created. */
	configASSERT( xEMACEventQueue );
    116c:	f240 6308 	movw	r3, #1544	; 0x608
    1170:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1174:	681b      	ldr	r3, [r3, #0]
    1176:	2b00      	cmp	r3, #0
    1178:	d109      	bne.n	118e <prvEMACEventListener+0x36>
    117a:	f04f 0328 	mov.w	r3, #40	; 0x28
    117e:	f383 8811 	msr	BASEPRI, r3
    1182:	f3bf 8f6f 	isb	sy
    1186:	f3bf 8f4f 	dsb	sy
    118a:	617b      	str	r3, [r7, #20]
    118c:	e7fe      	b.n	118c <prvEMACEventListener+0x34>

	if( ( ulISREvents & MSS_MAC_EVENT_PACKET_SEND ) != 0UL )
    118e:	687b      	ldr	r3, [r7, #4]
    1190:	f003 0301 	and.w	r3, r3, #1
    1194:	b2db      	uxtb	r3, r3
    1196:	2b00      	cmp	r3, #0
    1198:	d001      	beq.n	119e <prvEMACEventListener+0x46>
	{
		/* An Ethernet Tx event has occurred. */
		MSS_MAC_FreeTxBuffers();
    119a:	f005 fc51 	bl	6a40 <MSS_MAC_FreeTxBuffers>
	}

	if( ( ulISREvents & MSS_MAC_EVENT_PACKET_RECEIVED ) != 0UL )
    119e:	687b      	ldr	r3, [r7, #4]
    11a0:	f003 0302 	and.w	r3, r3, #2
    11a4:	2b00      	cmp	r3, #0
    11a6:	d00f      	beq.n	11c8 <prvEMACEventListener+0x70>
	{
		/* An Ethernet Rx event has occurred. */
		xQueueSendFromISR( xEMACEventQueue, &ulRxEvent, &lHigherPriorityTaskWoken );
    11a8:	f240 6308 	movw	r3, #1544	; 0x608
    11ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    11b0:	6819      	ldr	r1, [r3, #0]
    11b2:	f107 020c 	add.w	r2, r7, #12
    11b6:	f107 0310 	add.w	r3, r7, #16
    11ba:	4608      	mov	r0, r1
    11bc:	4611      	mov	r1, r2
    11be:	461a      	mov	r2, r3
    11c0:	f04f 0300 	mov.w	r3, #0
    11c4:	f00e fae8 	bl	f798 <xQueueGenericSendFromISR>
	}

	portEND_SWITCHING_ISR( lHigherPriorityTaskWoken );
    11c8:	693b      	ldr	r3, [r7, #16]
    11ca:	2b00      	cmp	r3, #0
    11cc:	d00a      	beq.n	11e4 <prvEMACEventListener+0x8c>
    11ce:	f64e 5304 	movw	r3, #60676	; 0xed04
    11d2:	f2ce 0300 	movt	r3, #57344	; 0xe000
    11d6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    11da:	601a      	str	r2, [r3, #0]
    11dc:	f3bf 8f4f 	dsb	sy
    11e0:	f3bf 8f6f 	isb	sy
}
    11e4:	f107 0718 	add.w	r7, r7, #24
    11e8:	46bd      	mov	sp, r7
    11ea:	bd80      	pop	{r7, pc}

000011ec <prvInitEmac>:
/*-----------------------------------------------------------*/

static void prvInitEmac( void )
{
    11ec:	b580      	push	{r7, lr}
    11ee:	b082      	sub	sp, #8
    11f0:	af00      	add	r7, sp, #0
const unsigned char ucPHYAddress = 1;
    11f2:	f04f 0301 	mov.w	r3, #1
    11f6:	71fb      	strb	r3, [r7, #7]

	/* Initialise the MAC and PHY hardware. */
	MSS_MAC_init( ucPHYAddress );
    11f8:	79fb      	ldrb	r3, [r7, #7]
    11fa:	4618      	mov	r0, r3
    11fc:	f003 f910 	bl	4420 <MSS_MAC_init>

	/* Register the event listener.  The Ethernet interrupt handler will call
	this listener whenever an Rx or a Tx interrupt occurs. */
	MSS_MAC_set_callback( ( MSS_MAC_callback_t ) prvEMACEventListener );
    1200:	f241 1059 	movw	r0, #4441	; 0x1159
    1204:	f2c0 0000 	movt	r0, #0
    1208:	f004 fac6 	bl	5798 <MSS_MAC_set_callback>

    /* Setup the EMAC and the NVIC for MAC interrupts. */
    NVIC_SetPriority( EthernetMAC_IRQn, configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY );
    120c:	f04f 0005 	mov.w	r0, #5
    1210:	f04f 0105 	mov.w	r1, #5
    1214:	f7ff fda0 	bl	d58 <NVIC_SetPriority>
    NVIC_EnableIRQ( EthernetMAC_IRQn );
    1218:	f04f 0005 	mov.w	r0, #5
    121c:	f7ff fd80 	bl	d20 <NVIC_EnableIRQ>
}
    1220:	f107 0708 	add.w	r7, r7, #8
    1224:	46bd      	mov	sp, r7
    1226:	bd80      	pop	{r7, pc}

00001228 <vEMACWrite>:
/*-----------------------------------------------------------*/

void vEMACWrite( void )
{
    1228:	b580      	push	{r7, lr}
    122a:	b084      	sub	sp, #16
    122c:	af00      	add	r7, sp, #0
const long lMaxAttempts = 10;
    122e:	f04f 030a 	mov.w	r3, #10
    1232:	607b      	str	r3, [r7, #4]
long lAttempt;
const TickType_t xShortDelay = ( 5 / portTICK_PERIOD_MS );
    1234:	f04f 0305 	mov.w	r3, #5
    1238:	60fb      	str	r3, [r7, #12]

	/* Try to send data to the Ethernet.  Keep trying for a while if data cannot
	be sent immediately.  Note that this will actually cause the data to be sent
	twice to get around delayed ACK problems when communicating with non real-
	time TCP/IP stacks (such as a Windows machine). */
	for( lAttempt = 0; lAttempt < lMaxAttempts; lAttempt++ )
    123a:	f04f 0300 	mov.w	r3, #0
    123e:	60bb      	str	r3, [r7, #8]
    1240:	e011      	b.n	1266 <vEMACWrite+0x3e>
	{
		if( MSS_MAC_tx_packet( uip_len ) != 0 )
    1242:	f64a 4328 	movw	r3, #44072	; 0xac28
    1246:	f2c2 0300 	movt	r3, #8192	; 0x2000
    124a:	881b      	ldrh	r3, [r3, #0]
    124c:	4618      	mov	r0, r3
    124e:	f003 fc59 	bl	4b04 <MSS_MAC_tx_packet>
    1252:	4603      	mov	r3, r0
    1254:	2b00      	cmp	r3, #0
    1256:	d10b      	bne.n	1270 <vEMACWrite+0x48>
		{
			break;
		}
		else
		{
			vTaskDelay( xShortDelay );
    1258:	68f8      	ldr	r0, [r7, #12]
    125a:	f00f fd13 	bl	10c84 <vTaskDelay>

	/* Try to send data to the Ethernet.  Keep trying for a while if data cannot
	be sent immediately.  Note that this will actually cause the data to be sent
	twice to get around delayed ACK problems when communicating with non real-
	time TCP/IP stacks (such as a Windows machine). */
	for( lAttempt = 0; lAttempt < lMaxAttempts; lAttempt++ )
    125e:	68bb      	ldr	r3, [r7, #8]
    1260:	f103 0301 	add.w	r3, r3, #1
    1264:	60bb      	str	r3, [r7, #8]
    1266:	68ba      	ldr	r2, [r7, #8]
    1268:	687b      	ldr	r3, [r7, #4]
    126a:	429a      	cmp	r2, r3
    126c:	dbe9      	blt.n	1242 <vEMACWrite+0x1a>
    126e:	e000      	b.n	1272 <vEMACWrite+0x4a>
	{
		if( MSS_MAC_tx_packet( uip_len ) != 0 )
		{
			break;
    1270:	bf00      	nop
		else
		{
			vTaskDelay( xShortDelay );
		}
	}
}
    1272:	f107 0710 	add.w	r7, r7, #16
    1276:	46bd      	mov	sp, r7
    1278:	bd80      	pop	{r7, pc}
    127a:	bf00      	nop

0000127c <prvUIPTimerCallback>:
/*-----------------------------------------------------------*/

static void prvUIPTimerCallback( TimerHandle_t xTimer )
{
    127c:	b580      	push	{r7, lr}
    127e:	b082      	sub	sp, #8
    1280:	af00      	add	r7, sp, #0
    1282:	6078      	str	r0, [r7, #4]
static const unsigned long ulPeriodicTimerExpired = uipPERIODIC_TIMER_EVENT;

	/* This is a time callback, so calls to xQueueSend() must not attempt to
	block.  As this callback is assigned to both the ARP and Periodic timers, the
	first thing to do is ascertain which timer it was that actually expired. */
	switch( ( int ) pvTimerGetTimerID( xTimer ) )
    1284:	6878      	ldr	r0, [r7, #4]
    1286:	f012 fd21 	bl	13ccc <pvTimerGetTimerID>
    128a:	4603      	mov	r3, r0
    128c:	2b00      	cmp	r3, #0
    128e:	d002      	beq.n	1296 <prvUIPTimerCallback+0x1a>
    1290:	2b01      	cmp	r3, #1
    1292:	d011      	beq.n	12b8 <prvUIPTimerCallback+0x3c>
    1294:	e020      	b.n	12d8 <prvUIPTimerCallback+0x5c>
	{
		case uipARP_TIMER		:	xQueueSend( xEMACEventQueue, &ulARPTimerExpired, uipDONT_BLOCK );
    1296:	f240 6308 	movw	r3, #1544	; 0x608
    129a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    129e:	681b      	ldr	r3, [r3, #0]
    12a0:	4618      	mov	r0, r3
    12a2:	f64a 5134 	movw	r1, #44340	; 0xad34
    12a6:	f2c0 0101 	movt	r1, #1
    12aa:	f04f 0200 	mov.w	r2, #0
    12ae:	f04f 0300 	mov.w	r3, #0
    12b2:	f00e f959 	bl	f568 <xQueueGenericSend>
									break;
    12b6:	e00f      	b.n	12d8 <prvUIPTimerCallback+0x5c>

		case uipPERIODIC_TIMER	:	xQueueSend( xEMACEventQueue, &ulPeriodicTimerExpired, uipDONT_BLOCK );
    12b8:	f240 6308 	movw	r3, #1544	; 0x608
    12bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    12c0:	681b      	ldr	r3, [r3, #0]
    12c2:	4618      	mov	r0, r3
    12c4:	f64a 5138 	movw	r1, #44344	; 0xad38
    12c8:	f2c0 0101 	movt	r1, #1
    12cc:	f04f 0200 	mov.w	r2, #0
    12d0:	f04f 0300 	mov.w	r3, #0
    12d4:	f00e f948 	bl	f568 <xQueueGenericSend>
									break;

		default					:  	/* Should not get here. */
									break;
	}
}
    12d8:	f107 0708 	add.w	r7, r7, #8
    12dc:	46bd      	mov	sp, r7
    12de:	bd80      	pop	{r7, pc}

000012e0 <vApplicationProcessFormInput>:
/*-----------------------------------------------------------*/

void vApplicationProcessFormInput( char *pcInputString )
{
    12e0:	b580      	push	{r7, lr}
    12e2:	b084      	sub	sp, #16
    12e4:	af00      	add	r7, sp, #0
    12e6:	6078      	str	r0, [r7, #4]
char *c;

	/* Only interested in processing form input if this is the IO page. */
	c = strstr( pcInputString, "io.shtml" );
    12e8:	6878      	ldr	r0, [r7, #4]
    12ea:	f64a 5120 	movw	r1, #44320	; 0xad20
    12ee:	f2c0 0101 	movt	r1, #1
    12f2:	f014 fa87 	bl	15804 <strstr>
    12f6:	4603      	mov	r3, r0
    12f8:	60fb      	str	r3, [r7, #12]

	if( c )
    12fa:	68fb      	ldr	r3, [r7, #12]
    12fc:	2b00      	cmp	r3, #0
    12fe:	d039      	beq.n	1374 <vApplicationProcessFormInput+0x94>
	{
		/* Is there a command in the string? */
		c = strstr( pcInputString, "?" );
    1300:	6878      	ldr	r0, [r7, #4]
    1302:	f04f 013f 	mov.w	r1, #63	; 0x3f
    1306:	f013 ff5b 	bl	151c0 <strchr>
    130a:	4603      	mov	r3, r0
    130c:	60fb      	str	r3, [r7, #12]
	    if( c )
    130e:	68fb      	ldr	r3, [r7, #12]
    1310:	2b00      	cmp	r3, #0
    1312:	d023      	beq.n	135c <vApplicationProcessFormInput+0x7c>
	    {
			/* Turn the LED's on or off in accordance with the check box status. */
			if( strstr( c, "LED0=1" ) != NULL )
    1314:	68f8      	ldr	r0, [r7, #12]
    1316:	f64a 512c 	movw	r1, #44332	; 0xad2c
    131a:	f2c0 0101 	movt	r1, #1
    131e:	f014 fa71 	bl	15804 <strstr>
    1322:	4603      	mov	r3, r0
    1324:	2b00      	cmp	r3, #0
    1326:	d00c      	beq.n	1342 <vApplicationProcessFormInput+0x62>
			{
				/* Turn the LEDs on. */
				vParTestSetLED( 3, 1 );
    1328:	f04f 0003 	mov.w	r0, #3
    132c:	f04f 0101 	mov.w	r1, #1
    1330:	f7ff f8f0 	bl	514 <vParTestSetLED>
				vParTestSetLED( 4, 1 );
    1334:	f04f 0004 	mov.w	r0, #4
    1338:	f04f 0101 	mov.w	r1, #1
    133c:	f7ff f8ea 	bl	514 <vParTestSetLED>
			}
			else
			{
				/* Turn the LEDs off. */
				vParTestSetLED( 3, 0 );
				vParTestSetLED( 4, 0 );
    1340:	e018      	b.n	1374 <vApplicationProcessFormInput+0x94>
				vParTestSetLED( 4, 1 );
			}
			else
			{
				/* Turn the LEDs off. */
				vParTestSetLED( 3, 0 );
    1342:	f04f 0003 	mov.w	r0, #3
    1346:	f04f 0100 	mov.w	r1, #0
    134a:	f7ff f8e3 	bl	514 <vParTestSetLED>
				vParTestSetLED( 4, 0 );
    134e:	f04f 0004 	mov.w	r0, #4
    1352:	f04f 0100 	mov.w	r1, #0
    1356:	f7ff f8dd 	bl	514 <vParTestSetLED>
    135a:	e00b      	b.n	1374 <vApplicationProcessFormInput+0x94>
			}
	    }
		else
		{
			/* Commands to turn LEDs off are not always explicit. */
			vParTestSetLED( 3, 0 );
    135c:	f04f 0003 	mov.w	r0, #3
    1360:	f04f 0100 	mov.w	r1, #0
    1364:	f7ff f8d6 	bl	514 <vParTestSetLED>
			vParTestSetLED( 4, 0 );
    1368:	f04f 0004 	mov.w	r0, #4
    136c:	f04f 0100 	mov.w	r1, #0
    1370:	f7ff f8d0 	bl	514 <vParTestSetLED>
		}
	}
}
    1374:	f107 0710 	add.w	r7, r7, #16
    1378:	46bd      	mov	sp, r7
    137a:	bd80      	pop	{r7, pc}

0000137c <nullfunction>:

static const struct httpd_cgi_call	*calls[] = { &file, &tcp, &net, &rtos, &run, &io, &output , NULL };

/*---------------------------------------------------------------------------*/
static PT_THREAD( nullfunction ( struct httpd_state *s, char *ptr ) )
{
    137c:	b480      	push	{r7}
    137e:	b085      	sub	sp, #20
    1380:	af00      	add	r7, sp, #0
    1382:	6078      	str	r0, [r7, #4]
    1384:	6039      	str	r1, [r7, #0]
	PSOCK_BEGIN( &s->sout );
    1386:	f04f 0301 	mov.w	r3, #1
    138a:	73fb      	strb	r3, [r7, #15]
	( void ) ptr;
	( void ) PT_YIELD_FLAG;
	PSOCK_END( &s->sout );
    138c:	f04f 0300 	mov.w	r3, #0
    1390:	73fb      	strb	r3, [r7, #15]
    1392:	687b      	ldr	r3, [r7, #4]
    1394:	f04f 0200 	mov.w	r2, #0
    1398:	851a      	strh	r2, [r3, #40]	; 0x28
    139a:	f04f 0302 	mov.w	r3, #2
}
    139e:	4618      	mov	r0, r3
    13a0:	f107 0714 	add.w	r7, r7, #20
    13a4:	46bd      	mov	sp, r7
    13a6:	bc80      	pop	{r7}
    13a8:	4770      	bx	lr
    13aa:	bf00      	nop

000013ac <httpd_cgi>:

/*---------------------------------------------------------------------------*/
httpd_cgifunction httpd_cgi( char *name )
{
    13ac:	b590      	push	{r4, r7, lr}
    13ae:	b085      	sub	sp, #20
    13b0:	af00      	add	r7, sp, #0
    13b2:	6078      	str	r0, [r7, #4]
	const struct httpd_cgi_call **f;

	/* Find the matching name in the table, return the function. */
	for( f = calls; *f != NULL; ++f )
    13b4:	f240 0310 	movw	r3, #16
    13b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    13bc:	60fb      	str	r3, [r7, #12]
    13be:	e019      	b.n	13f4 <httpd_cgi+0x48>
	{
		if( strncmp((*f)->name, name, strlen((*f)->name)) == 0 )
    13c0:	68fb      	ldr	r3, [r7, #12]
    13c2:	681b      	ldr	r3, [r3, #0]
    13c4:	681c      	ldr	r4, [r3, #0]
    13c6:	68fb      	ldr	r3, [r7, #12]
    13c8:	681b      	ldr	r3, [r3, #0]
    13ca:	681b      	ldr	r3, [r3, #0]
    13cc:	4618      	mov	r0, r3
    13ce:	f013 ffb5 	bl	1533c <strlen>
    13d2:	4603      	mov	r3, r0
    13d4:	4620      	mov	r0, r4
    13d6:	6879      	ldr	r1, [r7, #4]
    13d8:	461a      	mov	r2, r3
    13da:	f013 ffdf 	bl	1539c <strncmp>
    13de:	4603      	mov	r3, r0
    13e0:	2b00      	cmp	r3, #0
    13e2:	d103      	bne.n	13ec <httpd_cgi+0x40>
		{
			return( *f )->function;
    13e4:	68fb      	ldr	r3, [r7, #12]
    13e6:	681b      	ldr	r3, [r3, #0]
    13e8:	685b      	ldr	r3, [r3, #4]
    13ea:	e00b      	b.n	1404 <httpd_cgi+0x58>
httpd_cgifunction httpd_cgi( char *name )
{
	const struct httpd_cgi_call **f;

	/* Find the matching name in the table, return the function. */
	for( f = calls; *f != NULL; ++f )
    13ec:	68fb      	ldr	r3, [r7, #12]
    13ee:	f103 0304 	add.w	r3, r3, #4
    13f2:	60fb      	str	r3, [r7, #12]
    13f4:	68fb      	ldr	r3, [r7, #12]
    13f6:	681b      	ldr	r3, [r3, #0]
    13f8:	2b00      	cmp	r3, #0
    13fa:	d1e1      	bne.n	13c0 <httpd_cgi+0x14>
		{
			return( *f )->function;
		}
	}

	return nullfunction;
    13fc:	f241 337d 	movw	r3, #4989	; 0x137d
    1400:	f2c0 0300 	movt	r3, #0
}
    1404:	4618      	mov	r0, r3
    1406:	f107 0714 	add.w	r7, r7, #20
    140a:	46bd      	mov	sp, r7
    140c:	bd90      	pop	{r4, r7, pc}
    140e:	bf00      	nop

00001410 <generate_file_stats>:

/*---------------------------------------------------------------------------*/
static unsigned short generate_file_stats( void *arg )
{
    1410:	b590      	push	{r4, r7, lr}
    1412:	b085      	sub	sp, #20
    1414:	af00      	add	r7, sp, #0
    1416:	6078      	str	r0, [r7, #4]
	char	*f = ( char * ) arg;
    1418:	687b      	ldr	r3, [r7, #4]
    141a:	60fb      	str	r3, [r7, #12]
	return sprintf( ( char * ) uip_appdata, "%5u", httpd_fs_count(f) );
    141c:	f64a 4338 	movw	r3, #44088	; 0xac38
    1420:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1424:	681b      	ldr	r3, [r3, #0]
    1426:	461c      	mov	r4, r3
    1428:	68f8      	ldr	r0, [r7, #12]
    142a:	f00d f865 	bl	e4f8 <httpd_fs_count>
    142e:	4603      	mov	r3, r0
    1430:	4620      	mov	r0, r4
    1432:	f64a 5190 	movw	r1, #44432	; 0xad90
    1436:	f2c0 0101 	movt	r1, #1
    143a:	461a      	mov	r2, r3
    143c:	f013 fe52 	bl	150e4 <sprintf>
    1440:	4603      	mov	r3, r0
    1442:	b29b      	uxth	r3, r3
}
    1444:	4618      	mov	r0, r3
    1446:	f107 0714 	add.w	r7, r7, #20
    144a:	46bd      	mov	sp, r7
    144c:	bd90      	pop	{r4, r7, pc}
    144e:	bf00      	nop

00001450 <file_stats>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( file_stats ( struct httpd_state *s, char *ptr ) )
{
    1450:	b590      	push	{r4, r7, lr}
    1452:	b085      	sub	sp, #20
    1454:	af00      	add	r7, sp, #0
    1456:	6078      	str	r0, [r7, #4]
    1458:	6039      	str	r1, [r7, #0]
	PSOCK_BEGIN( &s->sout );
    145a:	f04f 0301 	mov.w	r3, #1
    145e:	73fb      	strb	r3, [r7, #15]
    1460:	687b      	ldr	r3, [r7, #4]
    1462:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    1464:	2b00      	cmp	r3, #0
    1466:	d002      	beq.n	146e <file_stats+0x1e>
    1468:	2b72      	cmp	r3, #114	; 0x72
    146a:	d004      	beq.n	1476 <file_stats+0x26>
    146c:	e01c      	b.n	14a8 <file_stats+0x58>

	( void ) PT_YIELD_FLAG;

	PSOCK_GENERATOR_SEND( &s->sout, generate_file_stats, strchr(ptr, ' ') + 1 );
    146e:	687b      	ldr	r3, [r7, #4]
    1470:	f04f 0272 	mov.w	r2, #114	; 0x72
    1474:	851a      	strh	r2, [r3, #40]	; 0x28
    1476:	687b      	ldr	r3, [r7, #4]
    1478:	f103 0428 	add.w	r4, r3, #40	; 0x28
    147c:	6838      	ldr	r0, [r7, #0]
    147e:	f04f 0120 	mov.w	r1, #32
    1482:	f013 fe9d 	bl	151c0 <strchr>
    1486:	4603      	mov	r3, r0
    1488:	f103 0301 	add.w	r3, r3, #1
    148c:	4620      	mov	r0, r4
    148e:	f241 4111 	movw	r1, #5137	; 0x1411
    1492:	f2c0 0100 	movt	r1, #0
    1496:	461a      	mov	r2, r3
    1498:	f009 fae4 	bl	aa64 <psock_generator_send>
    149c:	4603      	mov	r3, r0
    149e:	2b00      	cmp	r3, #0
    14a0:	d102      	bne.n	14a8 <file_stats+0x58>
    14a2:	f04f 0300 	mov.w	r3, #0
    14a6:	e008      	b.n	14ba <file_stats+0x6a>

	PSOCK_END( &s->sout );
    14a8:	f04f 0300 	mov.w	r3, #0
    14ac:	73fb      	strb	r3, [r7, #15]
    14ae:	687b      	ldr	r3, [r7, #4]
    14b0:	f04f 0200 	mov.w	r2, #0
    14b4:	851a      	strh	r2, [r3, #40]	; 0x28
    14b6:	f04f 0302 	mov.w	r3, #2
}
    14ba:	4618      	mov	r0, r3
    14bc:	f107 0714 	add.w	r7, r7, #20
    14c0:	46bd      	mov	sp, r7
    14c2:	bd90      	pop	{r4, r7, pc}

000014c4 <generate_tcp_stats>:
static const char	last_ack[] = /*  "LAST-ACK"*/ { 0x4c, 0x41, 0x53, 0x54, 0x2d, 0x41, 0x43, 0x4b, 0 };

static const char	*states[] = { closed, syn_rcvd, syn_sent, established, fin_wait_1, fin_wait_2, closing, time_wait, last_ack };

static unsigned short generate_tcp_stats( void *arg )
{
    14c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    14c8:	b08e      	sub	sp, #56	; 0x38
    14ca:	af0a      	add	r7, sp, #40	; 0x28
    14cc:	6078      	str	r0, [r7, #4]
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;
    14ce:	687b      	ldr	r3, [r7, #4]
    14d0:	60fb      	str	r3, [r7, #12]

	conn = &uip_conns[s->count];
    14d2:	68fb      	ldr	r3, [r7, #12]
    14d4:	f8b3 30ac 	ldrh.w	r3, [r3, #172]	; 0xac
    14d8:	f04f 02cc 	mov.w	r2, #204	; 0xcc
    14dc:	fb02 f203 	mul.w	r2, r2, r3
    14e0:	f64a 4340 	movw	r3, #44096	; 0xac40
    14e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    14e8:	4413      	add	r3, r2
    14ea:	60bb      	str	r3, [r7, #8]
	return sprintf( ( char * ) uip_appdata,
    14ec:	f64a 4338 	movw	r3, #44088	; 0xac38
    14f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    14f4:	681b      	ldr	r3, [r3, #0]
    14f6:	461e      	mov	r6, r3
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
    14f8:	68bb      	ldr	r3, [r7, #8]
    14fa:	889b      	ldrh	r3, [r3, #4]
    14fc:	4618      	mov	r0, r3
    14fe:	f00c f92b 	bl	d758 <htons>
    1502:	4603      	mov	r3, r0
{
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;

	conn = &uip_conns[s->count];
	return sprintf( ( char * ) uip_appdata,
    1504:	461d      	mov	r5, r3
    1506:	68bb      	ldr	r3, [r7, #8]
    1508:	881b      	ldrh	r3, [r3, #0]
    150a:	4618      	mov	r0, r3
    150c:	f00c f924 	bl	d758 <htons>
    1510:	4603      	mov	r3, r0
    1512:	ea4f 2313 	mov.w	r3, r3, lsr #8
    1516:	b29b      	uxth	r3, r3
    1518:	461c      	mov	r4, r3
    151a:	68bb      	ldr	r3, [r7, #8]
    151c:	881b      	ldrh	r3, [r3, #0]
    151e:	4618      	mov	r0, r3
    1520:	f00c f91a 	bl	d758 <htons>
    1524:	4603      	mov	r3, r0
    1526:	f003 09ff 	and.w	r9, r3, #255	; 0xff
    152a:	68bb      	ldr	r3, [r7, #8]
    152c:	885b      	ldrh	r3, [r3, #2]
    152e:	4618      	mov	r0, r3
    1530:	f00c f912 	bl	d758 <htons>
    1534:	4603      	mov	r3, r0
    1536:	ea4f 2313 	mov.w	r3, r3, lsr #8
    153a:	b29b      	uxth	r3, r3
    153c:	469a      	mov	sl, r3
    153e:	68bb      	ldr	r3, [r7, #8]
    1540:	885b      	ldrh	r3, [r3, #2]
    1542:	4618      	mov	r0, r3
    1544:	f00c f908 	bl	d758 <htons>
    1548:	4603      	mov	r3, r0
    154a:	f003 08ff 	and.w	r8, r3, #255	; 0xff
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
					 htons(conn->ripaddr.u16[0]) >> 8, htons(conn->ripaddr.u16[0]) & 0xff, htons(conn->ripaddr.u16[1]) >> 8,
					 htons(conn->ripaddr.u16[1]) & 0xff, htons(conn->rport), states[conn->tcpstateflags & UIP_TS_MASK], conn->nrtx, conn->timer,
    154e:	68bb      	ldr	r3, [r7, #8]
    1550:	88db      	ldrh	r3, [r3, #6]
    1552:	4618      	mov	r0, r3
    1554:	f00c f900 	bl	d758 <htons>
    1558:	4603      	mov	r3, r0
{
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;

	conn = &uip_conns[s->count];
	return sprintf( ( char * ) uip_appdata,
    155a:	469e      	mov	lr, r3
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
					 htons(conn->ripaddr.u16[0]) >> 8, htons(conn->ripaddr.u16[0]) & 0xff, htons(conn->ripaddr.u16[1]) >> 8,
					 htons(conn->ripaddr.u16[1]) & 0xff, htons(conn->rport), states[conn->tcpstateflags & UIP_TS_MASK], conn->nrtx, conn->timer,
    155c:	68bb      	ldr	r3, [r7, #8]
    155e:	7e5b      	ldrb	r3, [r3, #25]
    1560:	f003 020f 	and.w	r2, r3, #15
{
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;

	conn = &uip_conns[s->count];
	return sprintf( ( char * ) uip_appdata,
    1564:	f240 0330 	movw	r3, #48	; 0x30
    1568:	f2c2 0300 	movt	r3, #8192	; 0x2000
    156c:	f853 c022 	ldr.w	ip, [r3, r2, lsl #2]
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
					 htons(conn->ripaddr.u16[0]) >> 8, htons(conn->ripaddr.u16[0]) & 0xff, htons(conn->ripaddr.u16[1]) >> 8,
					 htons(conn->ripaddr.u16[1]) & 0xff, htons(conn->rport), states[conn->tcpstateflags & UIP_TS_MASK], conn->nrtx, conn->timer,
    1570:	68bb      	ldr	r3, [r7, #8]
    1572:	7edb      	ldrb	r3, [r3, #27]
{
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;

	conn = &uip_conns[s->count];
	return sprintf( ( char * ) uip_appdata,
    1574:	4618      	mov	r0, r3
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
					 htons(conn->ripaddr.u16[0]) >> 8, htons(conn->ripaddr.u16[0]) & 0xff, htons(conn->ripaddr.u16[1]) >> 8,
					 htons(conn->ripaddr.u16[1]) & 0xff, htons(conn->rport), states[conn->tcpstateflags & UIP_TS_MASK], conn->nrtx, conn->timer,
    1576:	68bb      	ldr	r3, [r7, #8]
    1578:	7e9b      	ldrb	r3, [r3, #26]
{
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;

	conn = &uip_conns[s->count];
	return sprintf( ( char * ) uip_appdata,
    157a:	4619      	mov	r1, r3
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
					 htons(conn->ripaddr.u16[0]) >> 8, htons(conn->ripaddr.u16[0]) & 0xff, htons(conn->ripaddr.u16[1]) >> 8,
					 htons(conn->ripaddr.u16[1]) & 0xff, htons(conn->rport), states[conn->tcpstateflags & UIP_TS_MASK], conn->nrtx, conn->timer,
					 (uip_outstanding(conn)) ? '*' : ' ', (uip_stopped(conn)) ? '!' : ' ' );
    157c:	68bb      	ldr	r3, [r7, #8]
    157e:	8a1b      	ldrh	r3, [r3, #16]
{
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;

	conn = &uip_conns[s->count];
	return sprintf( ( char * ) uip_appdata,
    1580:	2b00      	cmp	r3, #0
    1582:	d002      	beq.n	158a <generate_tcp_stats+0xc6>
    1584:	f04f 022a 	mov.w	r2, #42	; 0x2a
    1588:	e001      	b.n	158e <generate_tcp_stats+0xca>
    158a:	f04f 0220 	mov.w	r2, #32
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
					 htons(conn->ripaddr.u16[0]) >> 8, htons(conn->ripaddr.u16[0]) & 0xff, htons(conn->ripaddr.u16[1]) >> 8,
					 htons(conn->ripaddr.u16[1]) & 0xff, htons(conn->rport), states[conn->tcpstateflags & UIP_TS_MASK], conn->nrtx, conn->timer,
					 (uip_outstanding(conn)) ? '*' : ' ', (uip_stopped(conn)) ? '!' : ' ' );
    158e:	68bb      	ldr	r3, [r7, #8]
    1590:	7e5b      	ldrb	r3, [r3, #25]
    1592:	f003 0310 	and.w	r3, r3, #16
{
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;

	conn = &uip_conns[s->count];
	return sprintf( ( char * ) uip_appdata,
    1596:	2b00      	cmp	r3, #0
    1598:	d002      	beq.n	15a0 <generate_tcp_stats+0xdc>
    159a:	f04f 0321 	mov.w	r3, #33	; 0x21
    159e:	e001      	b.n	15a4 <generate_tcp_stats+0xe0>
    15a0:	f04f 0320 	mov.w	r3, #32
    15a4:	f8cd 9000 	str.w	r9, [sp]
    15a8:	f8cd a004 	str.w	sl, [sp, #4]
    15ac:	f8cd 8008 	str.w	r8, [sp, #8]
    15b0:	f8cd e00c 	str.w	lr, [sp, #12]
    15b4:	f8cd c010 	str.w	ip, [sp, #16]
    15b8:	9005      	str	r0, [sp, #20]
    15ba:	9106      	str	r1, [sp, #24]
    15bc:	9207      	str	r2, [sp, #28]
    15be:	9308      	str	r3, [sp, #32]
    15c0:	4630      	mov	r0, r6
    15c2:	f64a 5194 	movw	r1, #44436	; 0xad94
    15c6:	f2c0 0101 	movt	r1, #1
    15ca:	462a      	mov	r2, r5
    15cc:	4623      	mov	r3, r4
    15ce:	f013 fd89 	bl	150e4 <sprintf>
    15d2:	4603      	mov	r3, r0
    15d4:	b29b      	uxth	r3, r3
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
					 htons(conn->ripaddr.u16[0]) >> 8, htons(conn->ripaddr.u16[0]) & 0xff, htons(conn->ripaddr.u16[1]) >> 8,
					 htons(conn->ripaddr.u16[1]) & 0xff, htons(conn->rport), states[conn->tcpstateflags & UIP_TS_MASK], conn->nrtx, conn->timer,
					 (uip_outstanding(conn)) ? '*' : ' ', (uip_stopped(conn)) ? '!' : ' ' );
}
    15d6:	4618      	mov	r0, r3
    15d8:	f107 0710 	add.w	r7, r7, #16
    15dc:	46bd      	mov	sp, r7
    15de:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    15e2:	bf00      	nop

000015e4 <tcp_stats>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( tcp_stats ( struct httpd_state *s, char *ptr ) )
{
    15e4:	b580      	push	{r7, lr}
    15e6:	b084      	sub	sp, #16
    15e8:	af00      	add	r7, sp, #0
    15ea:	6078      	str	r0, [r7, #4]
    15ec:	6039      	str	r1, [r7, #0]
	PSOCK_BEGIN( &s->sout );
    15ee:	f04f 0301 	mov.w	r3, #1
    15f2:	73fb      	strb	r3, [r7, #15]
    15f4:	687b      	ldr	r3, [r7, #4]
    15f6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    15f8:	2b00      	cmp	r3, #0
    15fa:	d002      	beq.n	1602 <tcp_stats+0x1e>
    15fc:	2b9b      	cmp	r3, #155	; 0x9b
    15fe:	d01e      	beq.n	163e <tcp_stats+0x5a>
    1600:	e03c      	b.n	167c <tcp_stats+0x98>
	( void ) ptr;
	( void ) PT_YIELD_FLAG;
	for( s->count = 0; s->count < UIP_CONNS; ++s->count )
    1602:	687b      	ldr	r3, [r7, #4]
    1604:	f04f 0200 	mov.w	r2, #0
    1608:	f8a3 20ac 	strh.w	r2, [r3, #172]	; 0xac
    160c:	e031      	b.n	1672 <tcp_stats+0x8e>
	{
		if( (uip_conns[s->count].tcpstateflags & UIP_TS_MASK) != UIP_CLOSED )
    160e:	687b      	ldr	r3, [r7, #4]
    1610:	f8b3 30ac 	ldrh.w	r3, [r3, #172]	; 0xac
    1614:	461a      	mov	r2, r3
    1616:	f64a 4340 	movw	r3, #44096	; 0xac40
    161a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    161e:	f04f 01cc 	mov.w	r1, #204	; 0xcc
    1622:	fb01 f202 	mul.w	r2, r1, r2
    1626:	4413      	add	r3, r2
    1628:	f103 0318 	add.w	r3, r3, #24
    162c:	785b      	ldrb	r3, [r3, #1]
    162e:	f003 030f 	and.w	r3, r3, #15
    1632:	2b00      	cmp	r3, #0
    1634:	d014      	beq.n	1660 <tcp_stats+0x7c>
		{
			PSOCK_GENERATOR_SEND( &s->sout, generate_tcp_stats, s );
    1636:	687b      	ldr	r3, [r7, #4]
    1638:	f04f 029b 	mov.w	r2, #155	; 0x9b
    163c:	851a      	strh	r2, [r3, #40]	; 0x28
    163e:	687b      	ldr	r3, [r7, #4]
    1640:	f103 0328 	add.w	r3, r3, #40	; 0x28
    1644:	4618      	mov	r0, r3
    1646:	f241 41c5 	movw	r1, #5317	; 0x14c5
    164a:	f2c0 0100 	movt	r1, #0
    164e:	687a      	ldr	r2, [r7, #4]
    1650:	f009 fa08 	bl	aa64 <psock_generator_send>
    1654:	4603      	mov	r3, r0
    1656:	2b00      	cmp	r3, #0
    1658:	d102      	bne.n	1660 <tcp_stats+0x7c>
    165a:	f04f 0300 	mov.w	r3, #0
    165e:	e016      	b.n	168e <tcp_stats+0xaa>
static PT_THREAD( tcp_stats ( struct httpd_state *s, char *ptr ) )
{
	PSOCK_BEGIN( &s->sout );
	( void ) ptr;
	( void ) PT_YIELD_FLAG;
	for( s->count = 0; s->count < UIP_CONNS; ++s->count )
    1660:	687b      	ldr	r3, [r7, #4]
    1662:	f8b3 30ac 	ldrh.w	r3, [r3, #172]	; 0xac
    1666:	f103 0301 	add.w	r3, r3, #1
    166a:	b29a      	uxth	r2, r3
    166c:	687b      	ldr	r3, [r7, #4]
    166e:	f8a3 20ac 	strh.w	r2, [r3, #172]	; 0xac
    1672:	687b      	ldr	r3, [r7, #4]
    1674:	f8b3 30ac 	ldrh.w	r3, [r3, #172]	; 0xac
    1678:	2b27      	cmp	r3, #39	; 0x27
    167a:	d9c8      	bls.n	160e <tcp_stats+0x2a>
		{
			PSOCK_GENERATOR_SEND( &s->sout, generate_tcp_stats, s );
		}
	}

	PSOCK_END( &s->sout );
    167c:	f04f 0300 	mov.w	r3, #0
    1680:	73fb      	strb	r3, [r7, #15]
    1682:	687b      	ldr	r3, [r7, #4]
    1684:	f04f 0200 	mov.w	r2, #0
    1688:	851a      	strh	r2, [r3, #40]	; 0x28
    168a:	f04f 0302 	mov.w	r3, #2
}
    168e:	4618      	mov	r0, r3
    1690:	f107 0710 	add.w	r7, r7, #16
    1694:	46bd      	mov	sp, r7
    1696:	bd80      	pop	{r7, pc}

00001698 <generate_net_stats>:

/*---------------------------------------------------------------------------*/
static unsigned short generate_net_stats( void *arg )
{
    1698:	b580      	push	{r7, lr}
    169a:	b084      	sub	sp, #16
    169c:	af00      	add	r7, sp, #0
    169e:	6078      	str	r0, [r7, #4]
	struct httpd_state	*s = ( struct httpd_state * ) arg;
    16a0:	687b      	ldr	r3, [r7, #4]
    16a2:	60fb      	str	r3, [r7, #12]
	return sprintf( ( char * ) uip_appdata, "%5u\n", (( uip_stats_t * ) &uip_stat)[s->count] );
    16a4:	f64a 4338 	movw	r3, #44088	; 0xac38
    16a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    16ac:	681b      	ldr	r3, [r3, #0]
    16ae:	461a      	mov	r2, r3
    16b0:	68fb      	ldr	r3, [r7, #12]
    16b2:	f8b3 30ac 	ldrh.w	r3, [r3, #172]	; 0xac
    16b6:	ea4f 0143 	mov.w	r1, r3, lsl #1
    16ba:	f64c 4374 	movw	r3, #52340	; 0xcc74
    16be:	f2c2 0300 	movt	r3, #8192	; 0x2000
    16c2:	440b      	add	r3, r1
    16c4:	881b      	ldrh	r3, [r3, #0]
    16c6:	4610      	mov	r0, r2
    16c8:	f64a 51f4 	movw	r1, #44532	; 0xadf4
    16cc:	f2c0 0101 	movt	r1, #1
    16d0:	461a      	mov	r2, r3
    16d2:	f013 fd07 	bl	150e4 <sprintf>
    16d6:	4603      	mov	r3, r0
    16d8:	b29b      	uxth	r3, r3
}
    16da:	4618      	mov	r0, r3
    16dc:	f107 0710 	add.w	r7, r7, #16
    16e0:	46bd      	mov	sp, r7
    16e2:	bd80      	pop	{r7, pc}

000016e4 <net_stats>:

static PT_THREAD( net_stats ( struct httpd_state *s, char *ptr ) )
{
    16e4:	b580      	push	{r7, lr}
    16e6:	b084      	sub	sp, #16
    16e8:	af00      	add	r7, sp, #0
    16ea:	6078      	str	r0, [r7, #4]
    16ec:	6039      	str	r1, [r7, #0]
	PSOCK_BEGIN( &s->sout );
    16ee:	f04f 0301 	mov.w	r3, #1
    16f2:	73fb      	strb	r3, [r7, #15]
    16f4:	687b      	ldr	r3, [r7, #4]
    16f6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    16f8:	2b00      	cmp	r3, #0
    16fa:	d002      	beq.n	1702 <net_stats+0x1e>
    16fc:	2bb1      	cmp	r3, #177	; 0xb1
    16fe:	d00a      	beq.n	1716 <net_stats+0x32>
    1700:	e028      	b.n	1754 <net_stats+0x70>
	( void ) ptr;
	( void ) PT_YIELD_FLAG;
#if UIP_STATISTICS
	for( s->count = 0; s->count < sizeof(uip_stat) / sizeof(uip_stats_t); ++s->count )
    1702:	687b      	ldr	r3, [r7, #4]
    1704:	f04f 0200 	mov.w	r2, #0
    1708:	f8a3 20ac 	strh.w	r2, [r3, #172]	; 0xac
    170c:	e01d      	b.n	174a <net_stats+0x66>
	{
		PSOCK_GENERATOR_SEND( &s->sout, generate_net_stats, s );
    170e:	687b      	ldr	r3, [r7, #4]
    1710:	f04f 02b1 	mov.w	r2, #177	; 0xb1
    1714:	851a      	strh	r2, [r3, #40]	; 0x28
    1716:	687b      	ldr	r3, [r7, #4]
    1718:	f103 0328 	add.w	r3, r3, #40	; 0x28
    171c:	4618      	mov	r0, r3
    171e:	f241 6199 	movw	r1, #5785	; 0x1699
    1722:	f2c0 0100 	movt	r1, #0
    1726:	687a      	ldr	r2, [r7, #4]
    1728:	f009 f99c 	bl	aa64 <psock_generator_send>
    172c:	4603      	mov	r3, r0
    172e:	2b00      	cmp	r3, #0
    1730:	d102      	bne.n	1738 <net_stats+0x54>
    1732:	f04f 0300 	mov.w	r3, #0
    1736:	e016      	b.n	1766 <net_stats+0x82>
{
	PSOCK_BEGIN( &s->sout );
	( void ) ptr;
	( void ) PT_YIELD_FLAG;
#if UIP_STATISTICS
	for( s->count = 0; s->count < sizeof(uip_stat) / sizeof(uip_stats_t); ++s->count )
    1738:	687b      	ldr	r3, [r7, #4]
    173a:	f8b3 30ac 	ldrh.w	r3, [r3, #172]	; 0xac
    173e:	f103 0301 	add.w	r3, r3, #1
    1742:	b29a      	uxth	r2, r3
    1744:	687b      	ldr	r3, [r7, #4]
    1746:	f8a3 20ac 	strh.w	r2, [r3, #172]	; 0xac
    174a:	687b      	ldr	r3, [r7, #4]
    174c:	f8b3 30ac 	ldrh.w	r3, [r3, #172]	; 0xac
    1750:	2b1b      	cmp	r3, #27
    1752:	d9dc      	bls.n	170e <net_stats+0x2a>
		PSOCK_GENERATOR_SEND( &s->sout, generate_net_stats, s );
	}

#endif /* UIP_STATISTICS */

	PSOCK_END( &s->sout );
    1754:	f04f 0300 	mov.w	r3, #0
    1758:	73fb      	strb	r3, [r7, #15]
    175a:	687b      	ldr	r3, [r7, #4]
    175c:	f04f 0200 	mov.w	r2, #0
    1760:	851a      	strh	r2, [r3, #40]	; 0x28
    1762:	f04f 0302 	mov.w	r3, #2
}
    1766:	4618      	mov	r0, r3
    1768:	f107 0710 	add.w	r7, r7, #16
    176c:	46bd      	mov	sp, r7
    176e:	bd80      	pop	{r7, pc}

00001770 <generate_rtos_stats>:
extern void vTaskList( char *pcWriteBuffer );
extern char *pcGetTaskStatusMessage( void );
static char cCountBuf[128];
long		lRefreshCount = 0;
static unsigned short generate_rtos_stats( void *arg )
{
    1770:	b590      	push	{r4, r7, lr}
    1772:	b083      	sub	sp, #12
    1774:	af00      	add	r7, sp, #0
    1776:	6078      	str	r0, [r7, #4]
	( void ) arg;
	lRefreshCount++;
    1778:	f240 638c 	movw	r3, #1676	; 0x68c
    177c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1780:	681b      	ldr	r3, [r3, #0]
    1782:	f103 0201 	add.w	r2, r3, #1
    1786:	f240 638c 	movw	r3, #1676	; 0x68c
    178a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    178e:	601a      	str	r2, [r3, #0]
	sprintf( cCountBuf, "<p><br>Refresh count = %d<p><br>%s", ( int ) lRefreshCount, pcGetTaskStatusMessage() );
    1790:	f240 638c 	movw	r3, #1676	; 0x68c
    1794:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1798:	681c      	ldr	r4, [r3, #0]
    179a:	f7ff fa0f 	bl	bbc <pcGetTaskStatusMessage>
    179e:	4603      	mov	r3, r0
    17a0:	f240 600c 	movw	r0, #1548	; 0x60c
    17a4:	f2c2 0000 	movt	r0, #8192	; 0x2000
    17a8:	f64a 51fc 	movw	r1, #44540	; 0xadfc
    17ac:	f2c0 0101 	movt	r1, #1
    17b0:	4622      	mov	r2, r4
    17b2:	f013 fc97 	bl	150e4 <sprintf>
	vTaskList( ( char * ) uip_appdata );
    17b6:	f64a 4338 	movw	r3, #44088	; 0xac38
    17ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    17be:	681b      	ldr	r3, [r3, #0]
    17c0:	4618      	mov	r0, r3
    17c2:	f011 f8d9 	bl	12978 <vTaskList>
	strcat( uip_appdata, cCountBuf );
    17c6:	f64a 4338 	movw	r3, #44088	; 0xac38
    17ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    17ce:	681b      	ldr	r3, [r3, #0]
    17d0:	4618      	mov	r0, r3
    17d2:	f240 610c 	movw	r1, #1548	; 0x60c
    17d6:	f2c2 0100 	movt	r1, #8192	; 0x2000
    17da:	f013 fccd 	bl	15178 <strcat>

	return strlen( uip_appdata );
    17de:	f64a 4338 	movw	r3, #44088	; 0xac38
    17e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    17e6:	681b      	ldr	r3, [r3, #0]
    17e8:	4618      	mov	r0, r3
    17ea:	f013 fda7 	bl	1533c <strlen>
    17ee:	4603      	mov	r3, r0
    17f0:	b29b      	uxth	r3, r3
}
    17f2:	4618      	mov	r0, r3
    17f4:	f107 070c 	add.w	r7, r7, #12
    17f8:	46bd      	mov	sp, r7
    17fa:	bd90      	pop	{r4, r7, pc}

000017fc <rtos_stats>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( rtos_stats ( struct httpd_state *s, char *ptr ) )
{
    17fc:	b580      	push	{r7, lr}
    17fe:	b084      	sub	sp, #16
    1800:	af00      	add	r7, sp, #0
    1802:	6078      	str	r0, [r7, #4]
    1804:	6039      	str	r1, [r7, #0]
	PSOCK_BEGIN( &s->sout );
    1806:	f04f 0301 	mov.w	r3, #1
    180a:	73fb      	strb	r3, [r7, #15]
    180c:	687b      	ldr	r3, [r7, #4]
    180e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    1810:	2b00      	cmp	r3, #0
    1812:	d002      	beq.n	181a <rtos_stats+0x1e>
    1814:	2bcf      	cmp	r3, #207	; 0xcf
    1816:	d004      	beq.n	1822 <rtos_stats+0x26>
    1818:	e015      	b.n	1846 <rtos_stats+0x4a>
	( void ) ptr;
	( void ) PT_YIELD_FLAG;
	PSOCK_GENERATOR_SEND( &s->sout, generate_rtos_stats, NULL );
    181a:	687b      	ldr	r3, [r7, #4]
    181c:	f04f 02cf 	mov.w	r2, #207	; 0xcf
    1820:	851a      	strh	r2, [r3, #40]	; 0x28
    1822:	687b      	ldr	r3, [r7, #4]
    1824:	f103 0328 	add.w	r3, r3, #40	; 0x28
    1828:	4618      	mov	r0, r3
    182a:	f241 7171 	movw	r1, #6001	; 0x1771
    182e:	f2c0 0100 	movt	r1, #0
    1832:	f04f 0200 	mov.w	r2, #0
    1836:	f009 f915 	bl	aa64 <psock_generator_send>
    183a:	4603      	mov	r3, r0
    183c:	2b00      	cmp	r3, #0
    183e:	d102      	bne.n	1846 <rtos_stats+0x4a>
    1840:	f04f 0300 	mov.w	r3, #0
    1844:	e008      	b.n	1858 <rtos_stats+0x5c>
	PSOCK_END( &s->sout );
    1846:	f04f 0300 	mov.w	r3, #0
    184a:	73fb      	strb	r3, [r7, #15]
    184c:	687b      	ldr	r3, [r7, #4]
    184e:	f04f 0200 	mov.w	r2, #0
    1852:	851a      	strh	r2, [r3, #40]	; 0x28
    1854:	f04f 0302 	mov.w	r3, #2
}
    1858:	4618      	mov	r0, r3
    185a:	f107 0710 	add.w	r7, r7, #16
    185e:	46bd      	mov	sp, r7
    1860:	bd80      	pop	{r7, pc}
    1862:	bf00      	nop

00001864 <generate_io_state>:
/*---------------------------------------------------------------------------*/
char			*pcStatus;
unsigned long	ulString;

static unsigned short generate_io_state( void *arg )
{
    1864:	b580      	push	{r7, lr}
    1866:	b084      	sub	sp, #16
    1868:	af00      	add	r7, sp, #0
    186a:	6078      	str	r0, [r7, #4]
	extern long lParTestGetLEDState( unsigned long ulLED );
	unsigned short usRawVoltage;
	const ace_channel_handle_t xVoltageChannel = ( ace_channel_handle_t ) 0;
    186c:	f04f 0300 	mov.w	r3, #0
    1870:	73fb      	strb	r3, [r7, #15]

	( void ) arg;

	/* Are the dynamically setable LEDs currently on or off? */
	if( lParTestGetLEDState( 3 ) )
    1872:	f04f 0003 	mov.w	r0, #3
    1876:	f7fe ff27 	bl	6c8 <lParTestGetLEDState>
    187a:	4603      	mov	r3, r0
    187c:	2b00      	cmp	r3, #0
    187e:	d009      	beq.n	1894 <generate_io_state+0x30>
	{
		pcStatus = "checked";
    1880:	f64a 13b8 	movw	r3, #43448	; 0xa9b8
    1884:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1888:	f64a 6220 	movw	r2, #44576	; 0xae20
    188c:	f2c0 0201 	movt	r2, #1
    1890:	601a      	str	r2, [r3, #0]
    1892:	e008      	b.n	18a6 <generate_io_state+0x42>
	}
	else
	{
		pcStatus = "";
    1894:	f64a 13b8 	movw	r3, #43448	; 0xa9b8
    1898:	f2c2 0300 	movt	r3, #8192	; 0x2000
    189c:	f64a 6228 	movw	r2, #44584	; 0xae28
    18a0:	f2c0 0201 	movt	r2, #1
    18a4:	601a      	str	r2, [r3, #0]
	}

	usRawVoltage = ( unsigned short ) ACE_get_ppe_sample( xVoltageChannel );
    18a6:	7bfb      	ldrb	r3, [r7, #15]
    18a8:	4618      	mov	r0, r3
    18aa:	f008 fac7 	bl	9e3c <ACE_get_ppe_sample>
    18ae:	4603      	mov	r3, r0
    18b0:	81bb      	strh	r3, [r7, #12]
	sprintf( uip_appdata, "<input type=\"checkbox\" name=\"LED0\" value=\"1\" %s>LED<p><p><p>Raw voltage input is %d", pcStatus, usRawVoltage );
    18b2:	f64a 4338 	movw	r3, #44088	; 0xac38
    18b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    18ba:	681b      	ldr	r3, [r3, #0]
    18bc:	4619      	mov	r1, r3
    18be:	f64a 13b8 	movw	r3, #43448	; 0xa9b8
    18c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    18c6:	681a      	ldr	r2, [r3, #0]
    18c8:	89bb      	ldrh	r3, [r7, #12]
    18ca:	4608      	mov	r0, r1
    18cc:	f64a 612c 	movw	r1, #44588	; 0xae2c
    18d0:	f2c0 0101 	movt	r1, #1
    18d4:	f013 fc06 	bl	150e4 <sprintf>

	return strlen( uip_appdata );
    18d8:	f64a 4338 	movw	r3, #44088	; 0xac38
    18dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    18e0:	681b      	ldr	r3, [r3, #0]
    18e2:	4618      	mov	r0, r3
    18e4:	f013 fd2a 	bl	1533c <strlen>
    18e8:	4603      	mov	r3, r0
    18ea:	b29b      	uxth	r3, r3
}
    18ec:	4618      	mov	r0, r3
    18ee:	f107 0710 	add.w	r7, r7, #16
    18f2:	46bd      	mov	sp, r7
    18f4:	bd80      	pop	{r7, pc}
    18f6:	bf00      	nop

000018f8 <generate_runtime_stats>:

/*---------------------------------------------------------------------------*/
extern void vTaskGetRunTimeStats( char *pcWriteBuffer );
extern unsigned short usMaxJitter;
static unsigned short generate_runtime_stats( void *arg )
{
    18f8:	b580      	push	{r7, lr}
    18fa:	b082      	sub	sp, #8
    18fc:	af00      	add	r7, sp, #0
    18fe:	6078      	str	r0, [r7, #4]
	( void ) arg;
	lRefreshCount++;
    1900:	f240 638c 	movw	r3, #1676	; 0x68c
    1904:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1908:	681b      	ldr	r3, [r3, #0]
    190a:	f103 0201 	add.w	r2, r3, #1
    190e:	f240 638c 	movw	r3, #1676	; 0x68c
    1912:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1916:	601a      	str	r2, [r3, #0]
	sprintf( cCountBuf, "<p><br>Refresh count = %d", ( int ) lRefreshCount );
    1918:	f240 638c 	movw	r3, #1676	; 0x68c
    191c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1920:	681b      	ldr	r3, [r3, #0]
    1922:	f240 600c 	movw	r0, #1548	; 0x60c
    1926:	f2c2 0000 	movt	r0, #8192	; 0x2000
    192a:	f64a 6180 	movw	r1, #44672	; 0xae80
    192e:	f2c0 0101 	movt	r1, #1
    1932:	461a      	mov	r2, r3
    1934:	f013 fbd6 	bl	150e4 <sprintf>

	vTaskGetRunTimeStats( ( char * ) uip_appdata );
    1938:	f64a 4338 	movw	r3, #44088	; 0xac38
    193c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1940:	681b      	ldr	r3, [r3, #0]
    1942:	4618      	mov	r0, r3
    1944:	f011 f8d0 	bl	12ae8 <vTaskGetRunTimeStats>
	strcat( uip_appdata, cCountBuf );
    1948:	f64a 4338 	movw	r3, #44088	; 0xac38
    194c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1950:	681b      	ldr	r3, [r3, #0]
    1952:	4618      	mov	r0, r3
    1954:	f240 610c 	movw	r1, #1548	; 0x60c
    1958:	f2c2 0100 	movt	r1, #8192	; 0x2000
    195c:	f013 fc0c 	bl	15178 <strcat>

	return strlen( uip_appdata );
    1960:	f64a 4338 	movw	r3, #44088	; 0xac38
    1964:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1968:	681b      	ldr	r3, [r3, #0]
    196a:	4618      	mov	r0, r3
    196c:	f013 fce6 	bl	1533c <strlen>
    1970:	4603      	mov	r3, r0
    1972:	b29b      	uxth	r3, r3
}
    1974:	4618      	mov	r0, r3
    1976:	f107 0708 	add.w	r7, r7, #8
    197a:	46bd      	mov	sp, r7
    197c:	bd80      	pop	{r7, pc}
    197e:	bf00      	nop

00001980 <run_time>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( run_time ( struct httpd_state *s, char *ptr ) )
{
    1980:	b580      	push	{r7, lr}
    1982:	b084      	sub	sp, #16
    1984:	af00      	add	r7, sp, #0
    1986:	6078      	str	r0, [r7, #4]
    1988:	6039      	str	r1, [r7, #0]
	PSOCK_BEGIN( &s->sout );
    198a:	f04f 0301 	mov.w	r3, #1
    198e:	73fb      	strb	r3, [r7, #15]
    1990:	687b      	ldr	r3, [r7, #4]
    1992:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    1994:	2b00      	cmp	r3, #0
    1996:	d003      	beq.n	19a0 <run_time+0x20>
    1998:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
    199c:	d004      	beq.n	19a8 <run_time+0x28>
    199e:	e015      	b.n	19cc <run_time+0x4c>
	( void ) ptr;
	( void ) PT_YIELD_FLAG;
	PSOCK_GENERATOR_SEND( &s->sout, generate_runtime_stats, NULL );
    19a0:	687b      	ldr	r3, [r7, #4]
    19a2:	f44f 7282 	mov.w	r2, #260	; 0x104
    19a6:	851a      	strh	r2, [r3, #40]	; 0x28
    19a8:	687b      	ldr	r3, [r7, #4]
    19aa:	f103 0328 	add.w	r3, r3, #40	; 0x28
    19ae:	4618      	mov	r0, r3
    19b0:	f641 01f9 	movw	r1, #6393	; 0x18f9
    19b4:	f2c0 0100 	movt	r1, #0
    19b8:	f04f 0200 	mov.w	r2, #0
    19bc:	f009 f852 	bl	aa64 <psock_generator_send>
    19c0:	4603      	mov	r3, r0
    19c2:	2b00      	cmp	r3, #0
    19c4:	d102      	bne.n	19cc <run_time+0x4c>
    19c6:	f04f 0300 	mov.w	r3, #0
    19ca:	e008      	b.n	19de <run_time+0x5e>
	PSOCK_END( &s->sout );
    19cc:	f04f 0300 	mov.w	r3, #0
    19d0:	73fb      	strb	r3, [r7, #15]
    19d2:	687b      	ldr	r3, [r7, #4]
    19d4:	f04f 0200 	mov.w	r2, #0
    19d8:	851a      	strh	r2, [r3, #40]	; 0x28
    19da:	f04f 0302 	mov.w	r3, #2
}
    19de:	4618      	mov	r0, r3
    19e0:	f107 0710 	add.w	r7, r7, #16
    19e4:	46bd      	mov	sp, r7
    19e6:	bd80      	pop	{r7, pc}

000019e8 <led_io>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( led_io ( struct httpd_state *s, char *ptr ) )
{
    19e8:	b580      	push	{r7, lr}
    19ea:	b084      	sub	sp, #16
    19ec:	af00      	add	r7, sp, #0
    19ee:	6078      	str	r0, [r7, #4]
    19f0:	6039      	str	r1, [r7, #0]
	PSOCK_BEGIN( &s->sout );
    19f2:	f04f 0301 	mov.w	r3, #1
    19f6:	73fb      	strb	r3, [r7, #15]
    19f8:	687b      	ldr	r3, [r7, #4]
    19fa:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    19fc:	2b00      	cmp	r3, #0
    19fe:	d003      	beq.n	1a08 <led_io+0x20>
    1a00:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
    1a04:	d004      	beq.n	1a10 <led_io+0x28>
    1a06:	e015      	b.n	1a34 <led_io+0x4c>
	( void ) ptr;
	( void ) PT_YIELD_FLAG;
	PSOCK_GENERATOR_SEND( &s->sout, generate_io_state, NULL );
    1a08:	687b      	ldr	r3, [r7, #4]
    1a0a:	f44f 7287 	mov.w	r2, #270	; 0x10e
    1a0e:	851a      	strh	r2, [r3, #40]	; 0x28
    1a10:	687b      	ldr	r3, [r7, #4]
    1a12:	f103 0328 	add.w	r3, r3, #40	; 0x28
    1a16:	4618      	mov	r0, r3
    1a18:	f641 0165 	movw	r1, #6245	; 0x1865
    1a1c:	f2c0 0100 	movt	r1, #0
    1a20:	f04f 0200 	mov.w	r2, #0
    1a24:	f009 f81e 	bl	aa64 <psock_generator_send>
    1a28:	4603      	mov	r3, r0
    1a2a:	2b00      	cmp	r3, #0
    1a2c:	d102      	bne.n	1a34 <led_io+0x4c>
    1a2e:	f04f 0300 	mov.w	r3, #0
    1a32:	e008      	b.n	1a46 <led_io+0x5e>
	PSOCK_END( &s->sout );
    1a34:	f04f 0300 	mov.w	r3, #0
    1a38:	73fb      	strb	r3, [r7, #15]
    1a3a:	687b      	ldr	r3, [r7, #4]
    1a3c:	f04f 0200 	mov.w	r2, #0
    1a40:	851a      	strh	r2, [r3, #40]	; 0x28
    1a42:	f04f 0302 	mov.w	r3, #2
}
    1a46:	4618      	mov	r0, r3
    1a48:	f107 0710 	add.w	r7, r7, #16
    1a4c:	46bd      	mov	sp, r7
    1a4e:	bd80      	pop	{r7, pc}

00001a50 <delaySecs>:
//	return strlen( uip_appdata );
////#endif
//}

void delaySecs(int number_of_seconds)
{
    1a50:	b580      	push	{r7, lr}
    1a52:	b084      	sub	sp, #16
    1a54:	af00      	add	r7, sp, #0
    1a56:	6078      	str	r0, [r7, #4]
    // Converting time into milli_seconds
    int milli_seconds = 1000 * number_of_seconds;
    1a58:	687b      	ldr	r3, [r7, #4]
    1a5a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    1a5e:	fb02 f303 	mul.w	r3, r2, r3
    1a62:	60bb      	str	r3, [r7, #8]

    // Stroing start time
    clock_t start_time = clock();
    1a64:	f013 f8f8 	bl	14c58 <clock>
    1a68:	4603      	mov	r3, r0
    1a6a:	60fb      	str	r3, [r7, #12]

    // looping till required time is not acheived
    while (clock() < start_time + milli_seconds)
    1a6c:	f013 f8f4 	bl	14c58 <clock>
    1a70:	4602      	mov	r2, r0
    1a72:	68b9      	ldr	r1, [r7, #8]
    1a74:	68fb      	ldr	r3, [r7, #12]
    1a76:	440b      	add	r3, r1
    1a78:	429a      	cmp	r2, r3
    1a7a:	d3f7      	bcc.n	1a6c <delaySecs+0x1c>
        ;
}
    1a7c:	f107 0710 	add.w	r7, r7, #16
    1a80:	46bd      	mov	sp, r7
    1a82:	bd80      	pop	{r7, pc}
    1a84:	0000      	lsls	r0, r0, #0
	...

00001a88 <pot_voltage>:

static PT_THREAD( pot_voltage ( struct httpd_state *s, char *ptr ) )
{
    1a88:	b590      	push	{r4, r7, lr}
    1a8a:	b087      	sub	sp, #28
    1a8c:	af02      	add	r7, sp, #8
    1a8e:	6078      	str	r0, [r7, #4]
    1a90:	6039      	str	r1, [r7, #0]

	unsigned short usRawVoltage;
	const ace_channel_handle_t xVoltageChannel = ( ace_channel_handle_t ) 0;
    1a92:	f04f 0300 	mov.w	r3, #0
    1a96:	73bb      	strb	r3, [r7, #14]

		usRawVoltage = ( unsigned short ) ACE_get_ppe_sample( xVoltageChannel );
    1a98:	7bbb      	ldrb	r3, [r7, #14]
    1a9a:	4618      	mov	r0, r3
    1a9c:	f008 f9ce 	bl	9e3c <ACE_get_ppe_sample>
    1aa0:	4603      	mov	r3, r0
    1aa2:	81bb      	strh	r3, [r7, #12]




	//for( ;; ){
		PSOCK_BEGIN( &s->sout );
    1aa4:	f04f 0301 	mov.w	r3, #1
    1aa8:	73fb      	strb	r3, [r7, #15]
    1aaa:	687b      	ldr	r3, [r7, #4]
    1aac:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    1aae:	2b00      	cmp	r3, #0
    1ab0:	d004      	beq.n	1abc <pot_voltage+0x34>
    1ab2:	f240 1257 	movw	r2, #343	; 0x157
    1ab6:	4293      	cmp	r3, r2
    1ab8:	d021      	beq.n	1afe <pot_voltage+0x76>
    1aba:	e038      	b.n	1b2e <pot_voltage+0xa6>
			//( void ) ptr;
			//( void ) PT_YIELD_FLAG;
		snprintf( buf, sizeof(buf), "%.2f", usRawVoltage/10000.0 );
    1abc:	89bb      	ldrh	r3, [r7, #12]
    1abe:	4618      	mov	r0, r3
    1ac0:	f012 fe52 	bl	14768 <__aeabi_i2d>
    1ac4:	4602      	mov	r2, r0
    1ac6:	460b      	mov	r3, r1
    1ac8:	4610      	mov	r0, r2
    1aca:	4619      	mov	r1, r3
    1acc:	a320      	add	r3, pc, #128	; (adr r3, 1b50 <pot_voltage+0xc8>)
    1ace:	e9d3 2300 	ldrd	r2, r3, [r3]
    1ad2:	f012 ffd9 	bl	14a88 <__aeabi_ddiv>
    1ad6:	4602      	mov	r2, r0
    1ad8:	460b      	mov	r3, r1
    1ada:	e9cd 2300 	strd	r2, r3, [sp]
    1ade:	f240 6090 	movw	r0, #1680	; 0x690
    1ae2:	f2c2 0000 	movt	r0, #8192	; 0x2000
    1ae6:	f04f 010a 	mov.w	r1, #10
    1aea:	f64a 629c 	movw	r2, #44700	; 0xae9c
    1aee:	f2c0 0201 	movt	r2, #1
    1af2:	f013 fa89 	bl	15008 <snprintf>
		PSOCK_SEND_STR( &s->sout, buf);
    1af6:	687b      	ldr	r3, [r7, #4]
    1af8:	f240 1257 	movw	r2, #343	; 0x157
    1afc:	851a      	strh	r2, [r3, #40]	; 0x28
    1afe:	687b      	ldr	r3, [r7, #4]
    1b00:	f103 0428 	add.w	r4, r3, #40	; 0x28
    1b04:	f240 6090 	movw	r0, #1680	; 0x690
    1b08:	f2c2 0000 	movt	r0, #8192	; 0x2000
    1b0c:	f013 fc16 	bl	1533c <strlen>
    1b10:	4603      	mov	r3, r0
    1b12:	4620      	mov	r0, r4
    1b14:	f240 6190 	movw	r1, #1680	; 0x690
    1b18:	f2c2 0100 	movt	r1, #8192	; 0x2000
    1b1c:	461a      	mov	r2, r3
    1b1e:	f008 ff57 	bl	a9d0 <psock_send>
    1b22:	4603      	mov	r3, r0
    1b24:	2b00      	cmp	r3, #0
    1b26:	d102      	bne.n	1b2e <pot_voltage+0xa6>
    1b28:	f04f 0300 	mov.w	r3, #0
    1b2c:	e008      	b.n	1b40 <pot_voltage+0xb8>
		PSOCK_END( &s->sout );
    1b2e:	f04f 0300 	mov.w	r3, #0
    1b32:	73fb      	strb	r3, [r7, #15]
    1b34:	687b      	ldr	r3, [r7, #4]
    1b36:	f04f 0200 	mov.w	r2, #0
    1b3a:	851a      	strh	r2, [r3, #40]	; 0x28
    1b3c:	f04f 0302 	mov.w	r3, #2
		//delaySecs(1);
	//}


}
    1b40:	4618      	mov	r0, r3
    1b42:	f107 0714 	add.w	r7, r7, #20
    1b46:	46bd      	mov	sp, r7
    1b48:	bd90      	pop	{r4, r7, pc}
    1b4a:	bf00      	nop
    1b4c:	f3af 8000 	nop.w
    1b50:	00000000 	.word	0x00000000
    1b54:	40c38800 	.word	0x40c38800

00001b58 <NVIC_init>:

/***************************************************************************//**
 * 
 */
void NVIC_init( void )
{
    1b58:	b480      	push	{r7}
    1b5a:	af00      	add	r7, sp, #0
     * Please use SmartFusion CMSIS-PAL provided NVIC control functions.
     * The use of the Actel HAL NVIC control functions is obsolete on SmartFusion
     * devices.
     * Simply remove the call to NVIC_init() from your application code.
     */
    ASSERT(0);
    1b5c:	be00      	bkpt	0x0000
}
    1b5e:	46bd      	mov	sp, r7
    1b60:	bc80      	pop	{r7}
    1b62:	4770      	bx	lr

00001b64 <NVIC_set_handler>:
void NVIC_set_handler
(
    uint32_t interrupt_number,
    interrupt_handler_t handler
)
{
    1b64:	b480      	push	{r7}
    1b66:	b083      	sub	sp, #12
    1b68:	af00      	add	r7, sp, #0
    1b6a:	6078      	str	r0, [r7, #4]
    1b6c:	6039      	str	r1, [r7, #0]
     * devices.
     * Please provide a function using the folowing prototype to handle interrupts
     * from peripherals implemeted in the SmartFusion FPGA fabric:
     *      void Fabric_IRQHandler( void )
     */
    ASSERT(0);
    1b6e:	be00      	bkpt	0x0000
}
    1b70:	f107 070c 	add.w	r7, r7, #12
    1b74:	46bd      	mov	sp, r7
    1b76:	bc80      	pop	{r7}
    1b78:	4770      	bx	lr
    1b7a:	bf00      	nop

00001b7c <NVIC_set_priority>:
void NVIC_set_priority
(
    uint32_t interrupt_number,
    uint8_t priority_level
)
{
    1b7c:	b480      	push	{r7}
    1b7e:	b083      	sub	sp, #12
    1b80:	af00      	add	r7, sp, #0
    1b82:	6078      	str	r0, [r7, #4]
    1b84:	460b      	mov	r3, r1
    1b86:	70fb      	strb	r3, [r7, #3]
     * Please replace calls to NVIC_set_priority() with a call to the CMSIS-PAL
     * void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority) function where
     * IRQn is set to Fabric_IRQn in order to set the priority of interrupts
     * generated from peripheral implemented in the SmartFusion FPGA fabric.
     */
    ASSERT(0);
    1b88:	be00      	bkpt	0x0000
}
    1b8a:	f107 070c 	add.w	r7, r7, #12
    1b8e:	46bd      	mov	sp, r7
    1b90:	bc80      	pop	{r7}
    1b92:	4770      	bx	lr

00001b94 <NVIC_enable_interrupt>:

/***************************************************************************//**
 * 
 */
void NVIC_enable_interrupt( uint32_t interrupt_number )
{
    1b94:	b480      	push	{r7}
    1b96:	b083      	sub	sp, #12
    1b98:	af00      	add	r7, sp, #0
    1b9a:	6078      	str	r0, [r7, #4]
     * Please replace calls to NVIC_enable_interrupt() with a call to the CMSIS-PAL
     * void NVIC_EnableIRQ(IRQn_Type IRQn) function where IRQn is set to
     * Fabric_IRQn in order to enable interrupts from peripheral implemented in
     * the SmartFusion FPGA fabric.
     */
    ASSERT(0);
    1b9c:	be00      	bkpt	0x0000
}
    1b9e:	f107 070c 	add.w	r7, r7, #12
    1ba2:	46bd      	mov	sp, r7
    1ba4:	bc80      	pop	{r7}
    1ba6:	4770      	bx	lr

00001ba8 <NVIC_disable_interrupt>:

/***************************************************************************//**
 * 
 */
void NVIC_disable_interrupt( uint32_t interrupt_number )
{
    1ba8:	b480      	push	{r7}
    1baa:	b083      	sub	sp, #12
    1bac:	af00      	add	r7, sp, #0
    1bae:	6078      	str	r0, [r7, #4]
     * Please replace calls to NVIC_disable_interrupt() with a call to the CMSIS-PAL
     * void NVIC_DisableIRQ(IRQn_Type IRQn) function where IRQn is set to
     * Fabric_IRQn in order to disable interrupts from peripheral implemented in
     * the SmartFusion FPGA fabric.
     */
    ASSERT(0);
    1bb0:	be00      	bkpt	0x0000
}
    1bb2:	f107 070c 	add.w	r7, r7, #12
    1bb6:	46bd      	mov	sp, r7
    1bb8:	bc80      	pop	{r7}
    1bba:	4770      	bx	lr

00001bbc <NVIC_clear_interrupt>:

/***************************************************************************//**
 * 
 */
void NVIC_clear_interrupt( uint32_t interrupt_number )
{
    1bbc:	b480      	push	{r7}
    1bbe:	b083      	sub	sp, #12
    1bc0:	af00      	add	r7, sp, #0
    1bc2:	6078      	str	r0, [r7, #4]
     * Please replace calls to NVIC_clear_interrupt() with a call to the CMSIS-PAL
     * void NVIC_ClearPendingIRQ(IRQn_Type IRQn) function where IRQn is set to
     * Fabric_IRQn in order to clear interrupts from peripheral implemented in
     * the SmartFusion FPGA fabric.
     */
    ASSERT(0);
    1bc4:	be00      	bkpt	0x0000
}
    1bc6:	f107 070c 	add.w	r7, r7, #12
    1bca:	46bd      	mov	sp, r7
    1bcc:	bc80      	pop	{r7}
    1bce:	4770      	bx	lr

00001bd0 <HAL_disable_interrupts>:
    1bd0:	f3ef 8010 	mrs	r0, PRIMASK
    1bd4:	b672      	cpsid	i
    1bd6:	4770      	bx	lr

00001bd8 <HAL_restore_interrupts>:
    1bd8:	f380 8810 	msr	PRIMASK, r0
    1bdc:	4770      	bx	lr
	...

00001be0 <HAL_assert_fail>:
void HAL_assert_fail
(
    const uint8_t * file_name,
    uint32_t line_no
)
{
    1be0:	b480      	push	{r7}
    1be2:	b087      	sub	sp, #28
    1be4:	af00      	add	r7, sp, #0
    1be6:	6078      	str	r0, [r7, #4]
    1be8:	6039      	str	r1, [r7, #0]
    while(1)
    {
        volatile const uint8_t * assert_file = file_name;
    1bea:	687b      	ldr	r3, [r7, #4]
    1bec:	617b      	str	r3, [r7, #20]
        volatile uint32_t assert_line = line_no;
    1bee:	683b      	ldr	r3, [r7, #0]
    1bf0:	613b      	str	r3, [r7, #16]
        volatile char dummy;
		volatile uint32_t i_dummy;
		
		/* following lines to avoid compiler warnings: */
        dummy = *assert_file;
    1bf2:	697b      	ldr	r3, [r7, #20]
    1bf4:	781b      	ldrb	r3, [r3, #0]
    1bf6:	b2db      	uxtb	r3, r3
    1bf8:	73fb      	strb	r3, [r7, #15]
		i_dummy = assert_line;
    1bfa:	693b      	ldr	r3, [r7, #16]
    1bfc:	60bb      	str	r3, [r7, #8]
		i_dummy++;
    1bfe:	68bb      	ldr	r3, [r7, #8]
    1c00:	f103 0301 	add.w	r3, r3, #1
    1c04:	60bb      	str	r3, [r7, #8]
    }
    1c06:	e7f0      	b.n	1bea <HAL_assert_fail+0xa>

00001c08 <HW_set_32bit_reg>:
    1c08:	6001      	str	r1, [r0, #0]
    1c0a:	4770      	bx	lr

00001c0c <HW_get_32bit_reg>:
    1c0c:	6800      	ldr	r0, [r0, #0]
    1c0e:	4770      	bx	lr

00001c10 <HW_set_32bit_reg_field>:
    1c10:	b50e      	push	{r1, r2, r3, lr}
    1c12:	fa03 f301 	lsl.w	r3, r3, r1
    1c16:	ea03 0302 	and.w	r3, r3, r2
    1c1a:	6801      	ldr	r1, [r0, #0]
    1c1c:	ea6f 0202 	mvn.w	r2, r2
    1c20:	ea01 0102 	and.w	r1, r1, r2
    1c24:	ea41 0103 	orr.w	r1, r1, r3
    1c28:	6001      	str	r1, [r0, #0]
    1c2a:	bd0e      	pop	{r1, r2, r3, pc}

00001c2c <HW_get_32bit_reg_field>:
    1c2c:	6800      	ldr	r0, [r0, #0]
    1c2e:	ea00 0002 	and.w	r0, r0, r2
    1c32:	fa20 f001 	lsr.w	r0, r0, r1
    1c36:	4770      	bx	lr

00001c38 <HW_set_16bit_reg>:
    1c38:	8001      	strh	r1, [r0, #0]
    1c3a:	4770      	bx	lr

00001c3c <HW_get_16bit_reg>:
    1c3c:	8800      	ldrh	r0, [r0, #0]
    1c3e:	4770      	bx	lr

00001c40 <HW_set_16bit_reg_field>:
    1c40:	b50e      	push	{r1, r2, r3, lr}
    1c42:	fa03 f301 	lsl.w	r3, r3, r1
    1c46:	ea03 0302 	and.w	r3, r3, r2
    1c4a:	8801      	ldrh	r1, [r0, #0]
    1c4c:	ea6f 0202 	mvn.w	r2, r2
    1c50:	ea01 0102 	and.w	r1, r1, r2
    1c54:	ea41 0103 	orr.w	r1, r1, r3
    1c58:	8001      	strh	r1, [r0, #0]
    1c5a:	bd0e      	pop	{r1, r2, r3, pc}

00001c5c <HW_get_16bit_reg_field>:
    1c5c:	8800      	ldrh	r0, [r0, #0]
    1c5e:	ea00 0002 	and.w	r0, r0, r2
    1c62:	fa20 f001 	lsr.w	r0, r0, r1
    1c66:	4770      	bx	lr

00001c68 <HW_set_8bit_reg>:
    1c68:	7001      	strb	r1, [r0, #0]
    1c6a:	4770      	bx	lr

00001c6c <HW_get_8bit_reg>:
    1c6c:	7800      	ldrb	r0, [r0, #0]
    1c6e:	4770      	bx	lr

00001c70 <HW_set_8bit_reg_field>:
    1c70:	b50e      	push	{r1, r2, r3, lr}
    1c72:	fa03 f301 	lsl.w	r3, r3, r1
    1c76:	ea03 0302 	and.w	r3, r3, r2
    1c7a:	7801      	ldrb	r1, [r0, #0]
    1c7c:	ea6f 0202 	mvn.w	r2, r2
    1c80:	ea01 0102 	and.w	r1, r1, r2
    1c84:	ea41 0103 	orr.w	r1, r1, r3
    1c88:	7001      	strb	r1, [r0, #0]
    1c8a:	bd0e      	pop	{r1, r2, r3, pc}

00001c8c <HW_get_8bit_reg_field>:
    1c8c:	7800      	ldrb	r0, [r0, #0]
    1c8e:	ea00 0002 	and.w	r0, r0, r2
    1c92:	fa20 f001 	lsr.w	r0, r0, r1
    1c96:	4770      	bx	lr

00001c98 <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
    1c98:	b480      	push	{r7}
    1c9a:	b083      	sub	sp, #12
    1c9c:	af00      	add	r7, sp, #0
    1c9e:	4603      	mov	r3, r0
    1ca0:	80fb      	strh	r3, [r7, #6]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    1ca2:	f24e 1300 	movw	r3, #57600	; 0xe100
    1ca6:	f2ce 0300 	movt	r3, #57344	; 0xe000
    1caa:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    1cae:	ea4f 1252 	mov.w	r2, r2, lsr #5
    1cb2:	88f9      	ldrh	r1, [r7, #6]
    1cb4:	f001 011f 	and.w	r1, r1, #31
    1cb8:	f04f 0001 	mov.w	r0, #1
    1cbc:	fa00 f101 	lsl.w	r1, r0, r1
    1cc0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    1cc4:	f107 070c 	add.w	r7, r7, #12
    1cc8:	46bd      	mov	sp, r7
    1cca:	bc80      	pop	{r7}
    1ccc:	4770      	bx	lr
    1cce:	bf00      	nop

00001cd0 <NVIC_DisableIRQ>:
 * 
 * Disable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
    1cd0:	b480      	push	{r7}
    1cd2:	b083      	sub	sp, #12
    1cd4:	af00      	add	r7, sp, #0
    1cd6:	4603      	mov	r3, r0
    1cd8:	80fb      	strh	r3, [r7, #6]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
    1cda:	f24e 1300 	movw	r3, #57600	; 0xe100
    1cde:	f2ce 0300 	movt	r3, #57344	; 0xe000
    1ce2:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    1ce6:	ea4f 1252 	mov.w	r2, r2, lsr #5
    1cea:	88f9      	ldrh	r1, [r7, #6]
    1cec:	f001 011f 	and.w	r1, r1, #31
    1cf0:	f04f 0001 	mov.w	r0, #1
    1cf4:	fa00 f101 	lsl.w	r1, r0, r1
    1cf8:	f102 0220 	add.w	r2, r2, #32
    1cfc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    1d00:	f107 070c 	add.w	r7, r7, #12
    1d04:	46bd      	mov	sp, r7
    1d06:	bc80      	pop	{r7}
    1d08:	4770      	bx	lr
    1d0a:	bf00      	nop

00001d0c <NVIC_ClearPendingIRQ>:
 *
 * Clear the pending bit for the specified interrupt. 
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
    1d0c:	b480      	push	{r7}
    1d0e:	b083      	sub	sp, #12
    1d10:	af00      	add	r7, sp, #0
    1d12:	4603      	mov	r3, r0
    1d14:	80fb      	strh	r3, [r7, #6]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    1d16:	f24e 1300 	movw	r3, #57600	; 0xe100
    1d1a:	f2ce 0300 	movt	r3, #57344	; 0xe000
    1d1e:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    1d22:	ea4f 1252 	mov.w	r2, r2, lsr #5
    1d26:	88f9      	ldrh	r1, [r7, #6]
    1d28:	f001 011f 	and.w	r1, r1, #31
    1d2c:	f04f 0001 	mov.w	r0, #1
    1d30:	fa00 f101 	lsl.w	r1, r0, r1
    1d34:	f102 0260 	add.w	r2, r2, #96	; 0x60
    1d38:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    1d3c:	f107 070c 	add.w	r7, r7, #12
    1d40:	46bd      	mov	sp, r7
    1d42:	bc80      	pop	{r7}
    1d44:	4770      	bx	lr
    1d46:	bf00      	nop

00001d48 <MSS_UART_init>:
(
    mss_uart_instance_t* this_uart,
    uint32_t baud_rate,
    uint8_t line_config
)
{
    1d48:	b580      	push	{r7, lr}
    1d4a:	b088      	sub	sp, #32
    1d4c:	af00      	add	r7, sp, #0
    1d4e:	60f8      	str	r0, [r7, #12]
    1d50:	60b9      	str	r1, [r7, #8]
    1d52:	4613      	mov	r3, r2
    1d54:	71fb      	strb	r3, [r7, #7]
    uint16_t baud_value = 1U;
    1d56:	f04f 0301 	mov.w	r3, #1
    1d5a:	82fb      	strh	r3, [r7, #22]
    uint32_t pclk_freq = 0U;
    1d5c:	f04f 0300 	mov.w	r3, #0
    1d60:	61bb      	str	r3, [r7, #24]
    uint32_t baud_value_l;

    /* The driver expects g_mss_uart0 and g_mss_uart1 to be the only
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    1d62:	68fa      	ldr	r2, [r7, #12]
    1d64:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    1d68:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1d6c:	429a      	cmp	r2, r3
    1d6e:	d007      	beq.n	1d80 <MSS_UART_init+0x38>
    1d70:	68fa      	ldr	r2, [r7, #12]
    1d72:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    1d76:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1d7a:	429a      	cmp	r2, r3
    1d7c:	d000      	beq.n	1d80 <MSS_UART_init+0x38>
    1d7e:	be00      	bkpt	0x0000

    /* baud_rate should be greater than 0 */
    ASSERT( 0U < baud_rate );
    1d80:	68bb      	ldr	r3, [r7, #8]
    1d82:	2b00      	cmp	r3, #0
    1d84:	d100      	bne.n	1d88 <MSS_UART_init+0x40>
    1d86:	be00      	bkpt	0x0000

    /* Force the value of the CMSIS global variables holding the various system
     * clock frequencies to be updated. */
    SystemCoreClockUpdate();
    1d88:	f008 fa26 	bl	a1d8 <SystemCoreClockUpdate>

    if ( this_uart == &g_mss_uart0 )
    1d8c:	68fa      	ldr	r2, [r7, #12]
    1d8e:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    1d92:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1d96:	429a      	cmp	r2, r3
    1d98:	d12e      	bne.n	1df8 <MSS_UART_init+0xb0>
    {
        this_uart->hw_reg = UART0;
    1d9a:	68fb      	ldr	r3, [r7, #12]
    1d9c:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    1da0:	601a      	str	r2, [r3, #0]
        this_uart->hw_reg_bit = UART0_BITBAND;
    1da2:	68fb      	ldr	r3, [r7, #12]
    1da4:	f04f 4284 	mov.w	r2, #1107296256	; 0x42000000
    1da8:	605a      	str	r2, [r3, #4]
        this_uart->irqn = UART0_IRQn;
    1daa:	68fb      	ldr	r3, [r7, #12]
    1dac:	f04f 020a 	mov.w	r2, #10
    1db0:	811a      	strh	r2, [r3, #8]

        pclk_freq = g_FrequencyPCLK0;
    1db2:	f240 03bc 	movw	r3, #188	; 0xbc
    1db6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1dba:	681b      	ldr	r3, [r3, #0]
    1dbc:	61bb      	str	r3, [r7, #24]

        /* reset UART0 */
        SYSREG->SOFT_RST_CR |= SYSREG_UART0_SOFTRESET_MASK;
    1dbe:	f242 0300 	movw	r3, #8192	; 0x2000
    1dc2:	f2ce 0304 	movt	r3, #57348	; 0xe004
    1dc6:	f242 0200 	movw	r2, #8192	; 0x2000
    1dca:	f2ce 0204 	movt	r2, #57348	; 0xe004
    1dce:	6b12      	ldr	r2, [r2, #48]	; 0x30
    1dd0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    1dd4:	631a      	str	r2, [r3, #48]	; 0x30
        /* Clear any previously pended UART0 interrupt */
        NVIC_ClearPendingIRQ( UART0_IRQn );
    1dd6:	f04f 000a 	mov.w	r0, #10
    1dda:	f7ff ff97 	bl	1d0c <NVIC_ClearPendingIRQ>
        /* Take UART0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_UART0_SOFTRESET_MASK;
    1dde:	f242 0300 	movw	r3, #8192	; 0x2000
    1de2:	f2ce 0304 	movt	r3, #57348	; 0xe004
    1de6:	f242 0200 	movw	r2, #8192	; 0x2000
    1dea:	f2ce 0204 	movt	r2, #57348	; 0xe004
    1dee:	6b12      	ldr	r2, [r2, #48]	; 0x30
    1df0:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    1df4:	631a      	str	r2, [r3, #48]	; 0x30
    1df6:	e031      	b.n	1e5c <MSS_UART_init+0x114>
    }
    else
    {
        this_uart->hw_reg = UART1;
    1df8:	68fa      	ldr	r2, [r7, #12]
    1dfa:	f240 0300 	movw	r3, #0
    1dfe:	f2c4 0301 	movt	r3, #16385	; 0x4001
    1e02:	6013      	str	r3, [r2, #0]
        this_uart->hw_reg_bit = UART1_BITBAND;
    1e04:	68fa      	ldr	r2, [r7, #12]
    1e06:	f240 0300 	movw	r3, #0
    1e0a:	f2c4 2320 	movt	r3, #16928	; 0x4220
    1e0e:	6053      	str	r3, [r2, #4]
        this_uart->irqn = UART1_IRQn;
    1e10:	68fb      	ldr	r3, [r7, #12]
    1e12:	f04f 020b 	mov.w	r2, #11
    1e16:	811a      	strh	r2, [r3, #8]

        pclk_freq = g_FrequencyPCLK1;
    1e18:	f240 03c0 	movw	r3, #192	; 0xc0
    1e1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1e20:	681b      	ldr	r3, [r3, #0]
    1e22:	61bb      	str	r3, [r7, #24]

        /* Reset UART1 */
        SYSREG->SOFT_RST_CR |= SYSREG_UART1_SOFTRESET_MASK;
    1e24:	f242 0300 	movw	r3, #8192	; 0x2000
    1e28:	f2ce 0304 	movt	r3, #57348	; 0xe004
    1e2c:	f242 0200 	movw	r2, #8192	; 0x2000
    1e30:	f2ce 0204 	movt	r2, #57348	; 0xe004
    1e34:	6b12      	ldr	r2, [r2, #48]	; 0x30
    1e36:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    1e3a:	631a      	str	r2, [r3, #48]	; 0x30
        /* Clear any previously pended UART1 interrupt */
        NVIC_ClearPendingIRQ( UART1_IRQn );
    1e3c:	f04f 000b 	mov.w	r0, #11
    1e40:	f7ff ff64 	bl	1d0c <NVIC_ClearPendingIRQ>
        /* Take UART1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_UART1_SOFTRESET_MASK;
    1e44:	f242 0300 	movw	r3, #8192	; 0x2000
    1e48:	f2ce 0304 	movt	r3, #57348	; 0xe004
    1e4c:	f242 0200 	movw	r2, #8192	; 0x2000
    1e50:	f2ce 0204 	movt	r2, #57348	; 0xe004
    1e54:	6b12      	ldr	r2, [r2, #48]	; 0x30
    1e56:	f422 7280 	bic.w	r2, r2, #256	; 0x100
    1e5a:	631a      	str	r2, [r3, #48]	; 0x30
    }

    /* disable interrupts */
    this_uart->hw_reg->IER = 0U;
    1e5c:	68fb      	ldr	r3, [r7, #12]
    1e5e:	681b      	ldr	r3, [r3, #0]
    1e60:	f04f 0200 	mov.w	r2, #0
    1e64:	711a      	strb	r2, [r3, #4]
     * The baud value is computed using the following equation:
     *      baud_value_l = PCLK_Frequency / (baud_rate * 16)
     * The baud value is rounded up or down depending on what would be the remainder
     * of the divide by 16 operation.
     */
    if( 0U < baud_rate )
    1e66:	68bb      	ldr	r3, [r7, #8]
    1e68:	2b00      	cmp	r3, #0
    1e6a:	d021      	beq.n	1eb0 <MSS_UART_init+0x168>
    {
        baud_value_l = (uint32_t)(pclk_freq / baud_rate);
    1e6c:	69ba      	ldr	r2, [r7, #24]
    1e6e:	68bb      	ldr	r3, [r7, #8]
    1e70:	fbb2 f3f3 	udiv	r3, r2, r3
    1e74:	61fb      	str	r3, [r7, #28]
        if( baud_value_l & 0x00000008U )
    1e76:	69fb      	ldr	r3, [r7, #28]
    1e78:	f003 0308 	and.w	r3, r3, #8
    1e7c:	2b00      	cmp	r3, #0
    1e7e:	d006      	beq.n	1e8e <MSS_UART_init+0x146>
        {
            /* remainder above 0.5 */
            baud_value_l = (baud_value_l >> 4U) + 1U;        
    1e80:	69fb      	ldr	r3, [r7, #28]
    1e82:	ea4f 1313 	mov.w	r3, r3, lsr #4
    1e86:	f103 0301 	add.w	r3, r3, #1
    1e8a:	61fb      	str	r3, [r7, #28]
    1e8c:	e003      	b.n	1e96 <MSS_UART_init+0x14e>
        }
        else
        {
            /* remainder below 0.5 */
            baud_value_l = (baud_value_l >> 4U);
    1e8e:	69fb      	ldr	r3, [r7, #28]
    1e90:	ea4f 1313 	mov.w	r3, r3, lsr #4
    1e94:	61fb      	str	r3, [r7, #28]
        }
    
        /* Check if the baud rate is supported by the PCLK */
        ASSERT( baud_value_l <= UINT16_MAX);
    1e96:	69fa      	ldr	r2, [r7, #28]
    1e98:	f64f 73ff 	movw	r3, #65535	; 0xffff
    1e9c:	429a      	cmp	r2, r3
    1e9e:	d900      	bls.n	1ea2 <MSS_UART_init+0x15a>
    1ea0:	be00      	bkpt	0x0000
        if( baud_value_l <= (uint32_t)UINT16_MAX)
    1ea2:	69fa      	ldr	r2, [r7, #28]
    1ea4:	f64f 73ff 	movw	r3, #65535	; 0xffff
    1ea8:	429a      	cmp	r2, r3
    1eaa:	d801      	bhi.n	1eb0 <MSS_UART_init+0x168>
        {
            baud_value = (uint16_t)baud_value_l;
    1eac:	69fb      	ldr	r3, [r7, #28]
    1eae:	82fb      	strh	r3, [r7, #22]
        }
    }
    
    /* set divisor latch */
    this_uart->hw_reg_bit->LCR_DLAB = (uint32_t)1;
    1eb0:	68fb      	ldr	r3, [r7, #12]
    1eb2:	685b      	ldr	r3, [r3, #4]
    1eb4:	f04f 0201 	mov.w	r2, #1
    1eb8:	f8c3 219c 	str.w	r2, [r3, #412]	; 0x19c

    /* msb of baud value */
    this_uart->hw_reg->DMR = (uint8_t)(baud_value >> 8);
    1ebc:	68fb      	ldr	r3, [r7, #12]
    1ebe:	681b      	ldr	r3, [r3, #0]
    1ec0:	8afa      	ldrh	r2, [r7, #22]
    1ec2:	ea4f 2212 	mov.w	r2, r2, lsr #8
    1ec6:	b292      	uxth	r2, r2
    1ec8:	b2d2      	uxtb	r2, r2
    1eca:	711a      	strb	r2, [r3, #4]
    /* lsb of baud value */
    this_uart->hw_reg->DLR = (uint8_t)baud_value;
    1ecc:	68fb      	ldr	r3, [r7, #12]
    1ece:	681b      	ldr	r3, [r3, #0]
    1ed0:	8afa      	ldrh	r2, [r7, #22]
    1ed2:	b2d2      	uxtb	r2, r2
    1ed4:	701a      	strb	r2, [r3, #0]

    /* reset divisor latch */
    this_uart->hw_reg_bit->LCR_DLAB = (uint32_t)0;
    1ed6:	68fb      	ldr	r3, [r7, #12]
    1ed8:	685b      	ldr	r3, [r3, #4]
    1eda:	f04f 0200 	mov.w	r2, #0
    1ede:	f8c3 219c 	str.w	r2, [r3, #412]	; 0x19c

    /* set the line control register (bit length, stop bits, parity) */
    this_uart->hw_reg->LCR = line_config;
    1ee2:	68fb      	ldr	r3, [r7, #12]
    1ee4:	681b      	ldr	r3, [r3, #0]
    1ee6:	79fa      	ldrb	r2, [r7, #7]
    1ee8:	731a      	strb	r2, [r3, #12]

    /* FIFO configuration */
    /* RX FIFO length = 1 byte, clear receiver FIFO, 
       clear transmitter FIFO, enable RXRDYN and TXRDYN pins. */
    this_uart->hw_reg->FCR = (uint8_t)MSS_UART_FIFO_SINGLE_BYTE | 
    1eea:	68fb      	ldr	r3, [r7, #12]
    1eec:	681b      	ldr	r3, [r3, #0]
    1eee:	f04f 020e 	mov.w	r2, #14
    1ef2:	721a      	strb	r2, [r3, #8]
                              FCR_CLEAR_RX_FIFO_MASK | FCR_CLEAR_TX_FIFO_MASK | 
                              FCR_ENABLE_TXRDY_RXRDY_MASK;
    /* disable loopback */
    this_uart->hw_reg_bit->MCR_LOOP = (uint32_t)0;
    1ef4:	68fb      	ldr	r3, [r7, #12]
    1ef6:	685b      	ldr	r3, [r3, #4]
    1ef8:	f04f 0200 	mov.w	r2, #0
    1efc:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210

    /* Instance setup */
    this_uart->tx_buff_size = TX_COMPLETE;
    1f00:	68fb      	ldr	r3, [r7, #12]
    1f02:	f04f 0200 	mov.w	r2, #0
    1f06:	611a      	str	r2, [r3, #16]
    this_uart->tx_buffer = (const uint8_t *)0;
    1f08:	68fb      	ldr	r3, [r7, #12]
    1f0a:	f04f 0200 	mov.w	r2, #0
    1f0e:	60da      	str	r2, [r3, #12]
    this_uart->tx_idx = 0U;
    1f10:	68fb      	ldr	r3, [r7, #12]
    1f12:	f04f 0200 	mov.w	r2, #0
    1f16:	615a      	str	r2, [r3, #20]

    /* Default handlers for MSS UART interrupts */
    this_uart->rx_handler       = NULL_HANDLER;
    1f18:	68fb      	ldr	r3, [r7, #12]
    1f1a:	f04f 0200 	mov.w	r2, #0
    1f1e:	61da      	str	r2, [r3, #28]
    this_uart->tx_handler       = default_tx_handler;
    1f20:	68fa      	ldr	r2, [r7, #12]
    1f22:	f242 533d 	movw	r3, #9533	; 0x253d
    1f26:	f2c0 0300 	movt	r3, #0
    1f2a:	6213      	str	r3, [r2, #32]
    this_uart->linests_handler  = NULL_HANDLER;
    1f2c:	68fb      	ldr	r3, [r7, #12]
    1f2e:	f04f 0200 	mov.w	r2, #0
    1f32:	619a      	str	r2, [r3, #24]
    this_uart->modemsts_handler = NULL_HANDLER;
    1f34:	68fb      	ldr	r3, [r7, #12]
    1f36:	f04f 0200 	mov.w	r2, #0
    1f3a:	625a      	str	r2, [r3, #36]	; 0x24

    /* Initialize the sticky status */
    this_uart->status = 0U;
    1f3c:	68fb      	ldr	r3, [r7, #12]
    1f3e:	f04f 0200 	mov.w	r2, #0
    1f42:	729a      	strb	r2, [r3, #10]
}
    1f44:	f107 0720 	add.w	r7, r7, #32
    1f48:	46bd      	mov	sp, r7
    1f4a:	bd80      	pop	{r7, pc}

00001f4c <MSS_UART_polled_tx>:
(
    mss_uart_instance_t * this_uart,
    const uint8_t * pbuff,
    uint32_t tx_size
)
{
    1f4c:	b480      	push	{r7}
    1f4e:	b089      	sub	sp, #36	; 0x24
    1f50:	af00      	add	r7, sp, #0
    1f52:	60f8      	str	r0, [r7, #12]
    1f54:	60b9      	str	r1, [r7, #8]
    1f56:	607a      	str	r2, [r7, #4]
    uint32_t char_idx = 0U;
    1f58:	f04f 0300 	mov.w	r3, #0
    1f5c:	613b      	str	r3, [r7, #16]
    uint32_t size_sent;
    uint8_t status;

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    1f5e:	68fa      	ldr	r2, [r7, #12]
    1f60:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    1f64:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1f68:	429a      	cmp	r2, r3
    1f6a:	d007      	beq.n	1f7c <MSS_UART_polled_tx+0x30>
    1f6c:	68fa      	ldr	r2, [r7, #12]
    1f6e:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    1f72:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1f76:	429a      	cmp	r2, r3
    1f78:	d000      	beq.n	1f7c <MSS_UART_polled_tx+0x30>
    1f7a:	be00      	bkpt	0x0000
    ASSERT( pbuff != ( (uint8_t *)0 ) );
    1f7c:	68bb      	ldr	r3, [r7, #8]
    1f7e:	2b00      	cmp	r3, #0
    1f80:	d100      	bne.n	1f84 <MSS_UART_polled_tx+0x38>
    1f82:	be00      	bkpt	0x0000
    ASSERT( tx_size > 0U );
    1f84:	687b      	ldr	r3, [r7, #4]
    1f86:	2b00      	cmp	r3, #0
    1f88:	d100      	bne.n	1f8c <MSS_UART_polled_tx+0x40>
    1f8a:	be00      	bkpt	0x0000

    if( ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) ) &&
    1f8c:	68fa      	ldr	r2, [r7, #12]
    1f8e:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    1f92:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1f96:	429a      	cmp	r2, r3
    1f98:	d006      	beq.n	1fa8 <MSS_UART_polled_tx+0x5c>
    1f9a:	68fa      	ldr	r2, [r7, #12]
    1f9c:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    1fa0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1fa4:	429a      	cmp	r2, r3
    1fa6:	d13d      	bne.n	2024 <MAIN_STACK_SIZE+0x24>
    1fa8:	68bb      	ldr	r3, [r7, #8]
    1faa:	2b00      	cmp	r3, #0
    1fac:	d03a      	beq.n	2024 <MAIN_STACK_SIZE+0x24>
    1fae:	687b      	ldr	r3, [r7, #4]
    1fb0:	2b00      	cmp	r3, #0
    1fb2:	d037      	beq.n	2024 <MAIN_STACK_SIZE+0x24>
         /* Remain in this loop until the entire input buffer
          * has been transferred to the UART.
          */
        do {
            /* Read the Line Status Register and update the sticky record */
            status = this_uart->hw_reg->LSR;
    1fb4:	68fb      	ldr	r3, [r7, #12]
    1fb6:	681b      	ldr	r3, [r3, #0]
    1fb8:	7d1b      	ldrb	r3, [r3, #20]
    1fba:	76fb      	strb	r3, [r7, #27]
            this_uart->status |= status;
    1fbc:	68fb      	ldr	r3, [r7, #12]
    1fbe:	7a9a      	ldrb	r2, [r3, #10]
    1fc0:	7efb      	ldrb	r3, [r7, #27]
    1fc2:	ea42 0303 	orr.w	r3, r2, r3
    1fc6:	b2da      	uxtb	r2, r3
    1fc8:	68fb      	ldr	r3, [r7, #12]
    1fca:	729a      	strb	r2, [r3, #10]

            /* Check if TX FIFO is empty. */
            if( status & MSS_UART_THRE )
    1fcc:	7efb      	ldrb	r3, [r7, #27]
    1fce:	f003 0320 	and.w	r3, r3, #32
    1fd2:	2b00      	cmp	r3, #0
    1fd4:	d023      	beq.n	201e <MAIN_STACK_SIZE+0x1e>
            {
                uint32_t fill_size = TX_FIFO_SIZE;
    1fd6:	f04f 0310 	mov.w	r3, #16
    1fda:	61fb      	str	r3, [r7, #28]

                /* Calculate the number of bytes to transmit. */
                if ( tx_size < TX_FIFO_SIZE )
    1fdc:	687b      	ldr	r3, [r7, #4]
    1fde:	2b0f      	cmp	r3, #15
    1fe0:	d801      	bhi.n	1fe6 <MSS_UART_polled_tx+0x9a>
                {
                    fill_size = tx_size;
    1fe2:	687b      	ldr	r3, [r7, #4]
    1fe4:	61fb      	str	r3, [r7, #28]
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for ( size_sent = 0U; size_sent < fill_size; ++size_sent )
    1fe6:	f04f 0300 	mov.w	r3, #0
    1fea:	617b      	str	r3, [r7, #20]
    1fec:	e00e      	b.n	200c <MAIN_STACK_SIZE+0xc>
                {
                    /* Send next character in the buffer. */
                    this_uart->hw_reg->THR = pbuff[char_idx++];
    1fee:	68fb      	ldr	r3, [r7, #12]
    1ff0:	681b      	ldr	r3, [r3, #0]
    1ff2:	68b9      	ldr	r1, [r7, #8]
    1ff4:	693a      	ldr	r2, [r7, #16]
    1ff6:	440a      	add	r2, r1
    1ff8:	7812      	ldrb	r2, [r2, #0]
    1ffa:	701a      	strb	r2, [r3, #0]
    1ffc:	693b      	ldr	r3, [r7, #16]
    1ffe:	f103 0301 	add.w	r3, r3, #1
    2002:	613b      	str	r3, [r7, #16]
                {
                    fill_size = tx_size;
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for ( size_sent = 0U; size_sent < fill_size; ++size_sent )
    2004:	697b      	ldr	r3, [r7, #20]
    2006:	f103 0301 	add.w	r3, r3, #1
    200a:	617b      	str	r3, [r7, #20]
    200c:	697a      	ldr	r2, [r7, #20]
    200e:	69fb      	ldr	r3, [r7, #28]
    2010:	429a      	cmp	r2, r3
    2012:	d3ec      	bcc.n	1fee <MSS_UART_polled_tx+0xa2>
                    /* Send next character in the buffer. */
                    this_uart->hw_reg->THR = pbuff[char_idx++];
                }

                /* Calculate the number of untransmitted bytes remaining. */
                tx_size -= size_sent;
    2014:	687a      	ldr	r2, [r7, #4]
    2016:	697b      	ldr	r3, [r7, #20]
    2018:	ebc3 0302 	rsb	r3, r3, r2
    201c:	607b      	str	r3, [r7, #4]
            }
        }while( tx_size );
    201e:	687b      	ldr	r3, [r7, #4]
    2020:	2b00      	cmp	r3, #0
    2022:	d1c7      	bne.n	1fb4 <MSS_UART_polled_tx+0x68>
    }
}
    2024:	f107 0724 	add.w	r7, r7, #36	; 0x24
    2028:	46bd      	mov	sp, r7
    202a:	bc80      	pop	{r7}
    202c:	4770      	bx	lr
    202e:	bf00      	nop

00002030 <MSS_UART_polled_tx_string>:
MSS_UART_polled_tx_string
(
    mss_uart_instance_t * this_uart,
    const uint8_t * p_sz_string
)
{
    2030:	b480      	push	{r7}
    2032:	b087      	sub	sp, #28
    2034:	af00      	add	r7, sp, #0
    2036:	6078      	str	r0, [r7, #4]
    2038:	6039      	str	r1, [r7, #0]
    uint32_t char_idx = 0U;
    203a:	f04f 0300 	mov.w	r3, #0
    203e:	60bb      	str	r3, [r7, #8]
    uint32_t fill_size;
    uint_fast8_t data_byte;
    uint8_t status;

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    2040:	687a      	ldr	r2, [r7, #4]
    2042:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    2046:	f2c2 0300 	movt	r3, #8192	; 0x2000
    204a:	429a      	cmp	r2, r3
    204c:	d007      	beq.n	205e <MSS_UART_polled_tx_string+0x2e>
    204e:	687a      	ldr	r2, [r7, #4]
    2050:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    2054:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2058:	429a      	cmp	r2, r3
    205a:	d000      	beq.n	205e <MSS_UART_polled_tx_string+0x2e>
    205c:	be00      	bkpt	0x0000
    ASSERT( p_sz_string != ( (uint8_t *)0 ) );
    205e:	683b      	ldr	r3, [r7, #0]
    2060:	2b00      	cmp	r3, #0
    2062:	d100      	bne.n	2066 <MSS_UART_polled_tx_string+0x36>
    2064:	be00      	bkpt	0x0000

    if( ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) ) &&
    2066:	687a      	ldr	r2, [r7, #4]
    2068:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    206c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2070:	429a      	cmp	r2, r3
    2072:	d006      	beq.n	2082 <MSS_UART_polled_tx_string+0x52>
    2074:	687a      	ldr	r2, [r7, #4]
    2076:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    207a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    207e:	429a      	cmp	r2, r3
    2080:	d138      	bne.n	20f4 <MSS_UART_polled_tx_string+0xc4>
    2082:	683b      	ldr	r3, [r7, #0]
    2084:	2b00      	cmp	r3, #0
    2086:	d035      	beq.n	20f4 <MSS_UART_polled_tx_string+0xc4>
          ( p_sz_string != ( (uint8_t *)0 ) ) )
    {
        /* Get the first data byte from the input buffer */
        data_byte = (uint_fast8_t)p_sz_string[char_idx];
    2088:	683a      	ldr	r2, [r7, #0]
    208a:	68bb      	ldr	r3, [r7, #8]
    208c:	4413      	add	r3, r2
    208e:	781b      	ldrb	r3, [r3, #0]
    2090:	613b      	str	r3, [r7, #16]

        /* First check for the NULL terminator byte.
         * Then remain in this loop until the entire string in the input buffer
         * has been transferred to the UART.
         */
        while ( 0U != data_byte )
    2092:	e02c      	b.n	20ee <MSS_UART_polled_tx_string+0xbe>
        {
            /* Wait until TX FIFO is empty. */
            do {
                status = this_uart->hw_reg->LSR;
    2094:	687b      	ldr	r3, [r7, #4]
    2096:	681b      	ldr	r3, [r3, #0]
    2098:	7d1b      	ldrb	r3, [r3, #20]
    209a:	75fb      	strb	r3, [r7, #23]
                this_uart->status |= status;
    209c:	687b      	ldr	r3, [r7, #4]
    209e:	7a9a      	ldrb	r2, [r3, #10]
    20a0:	7dfb      	ldrb	r3, [r7, #23]
    20a2:	ea42 0303 	orr.w	r3, r2, r3
    20a6:	b2da      	uxtb	r2, r3
    20a8:	687b      	ldr	r3, [r7, #4]
    20aa:	729a      	strb	r2, [r3, #10]
            } while ( !( status & MSS_UART_THRE ) );
    20ac:	7dfb      	ldrb	r3, [r7, #23]
    20ae:	f003 0320 	and.w	r3, r3, #32
    20b2:	2b00      	cmp	r3, #0
    20b4:	d0ee      	beq.n	2094 <MSS_UART_polled_tx_string+0x64>

            /* Send bytes from the input buffer until the TX FIFO is full
             * or we reach the NULL terminator byte.
             */
            fill_size = 0U;
    20b6:	f04f 0300 	mov.w	r3, #0
    20ba:	60fb      	str	r3, [r7, #12]
            while ( (0U != data_byte) && (fill_size < TX_FIFO_SIZE) )
    20bc:	e011      	b.n	20e2 <MSS_UART_polled_tx_string+0xb2>
            {
                /* Send the data byte */
                this_uart->hw_reg->THR = data_byte;
    20be:	687b      	ldr	r3, [r7, #4]
    20c0:	681b      	ldr	r3, [r3, #0]
    20c2:	693a      	ldr	r2, [r7, #16]
    20c4:	b2d2      	uxtb	r2, r2
    20c6:	701a      	strb	r2, [r3, #0]
                ++fill_size;
    20c8:	68fb      	ldr	r3, [r7, #12]
    20ca:	f103 0301 	add.w	r3, r3, #1
    20ce:	60fb      	str	r3, [r7, #12]
                char_idx++;
    20d0:	68bb      	ldr	r3, [r7, #8]
    20d2:	f103 0301 	add.w	r3, r3, #1
    20d6:	60bb      	str	r3, [r7, #8]
                /* Get the next data byte from the input buffer */
                data_byte = (uint_fast8_t)p_sz_string[char_idx];
    20d8:	683a      	ldr	r2, [r7, #0]
    20da:	68bb      	ldr	r3, [r7, #8]
    20dc:	4413      	add	r3, r2
    20de:	781b      	ldrb	r3, [r3, #0]
    20e0:	613b      	str	r3, [r7, #16]

            /* Send bytes from the input buffer until the TX FIFO is full
             * or we reach the NULL terminator byte.
             */
            fill_size = 0U;
            while ( (0U != data_byte) && (fill_size < TX_FIFO_SIZE) )
    20e2:	693b      	ldr	r3, [r7, #16]
    20e4:	2b00      	cmp	r3, #0
    20e6:	d002      	beq.n	20ee <MSS_UART_polled_tx_string+0xbe>
    20e8:	68fb      	ldr	r3, [r7, #12]
    20ea:	2b0f      	cmp	r3, #15
    20ec:	d9e7      	bls.n	20be <MSS_UART_polled_tx_string+0x8e>

        /* First check for the NULL terminator byte.
         * Then remain in this loop until the entire string in the input buffer
         * has been transferred to the UART.
         */
        while ( 0U != data_byte )
    20ee:	693b      	ldr	r3, [r7, #16]
    20f0:	2b00      	cmp	r3, #0
    20f2:	d1cf      	bne.n	2094 <MSS_UART_polled_tx_string+0x64>
                /* Get the next data byte from the input buffer */
                data_byte = (uint_fast8_t)p_sz_string[char_idx];
            }
        }
    }
}
    20f4:	f107 071c 	add.w	r7, r7, #28
    20f8:	46bd      	mov	sp, r7
    20fa:	bc80      	pop	{r7}
    20fc:	4770      	bx	lr
    20fe:	bf00      	nop

00002100 <MSS_UART_irq_tx>:
(
    mss_uart_instance_t * this_uart,
    const uint8_t * pbuff,
    uint32_t tx_size
)
{
    2100:	b580      	push	{r7, lr}
    2102:	b084      	sub	sp, #16
    2104:	af00      	add	r7, sp, #0
    2106:	60f8      	str	r0, [r7, #12]
    2108:	60b9      	str	r1, [r7, #8]
    210a:	607a      	str	r2, [r7, #4]
    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    210c:	68fa      	ldr	r2, [r7, #12]
    210e:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    2112:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2116:	429a      	cmp	r2, r3
    2118:	d007      	beq.n	212a <MSS_UART_irq_tx+0x2a>
    211a:	68fa      	ldr	r2, [r7, #12]
    211c:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    2120:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2124:	429a      	cmp	r2, r3
    2126:	d000      	beq.n	212a <MSS_UART_irq_tx+0x2a>
    2128:	be00      	bkpt	0x0000
    ASSERT( pbuff != ((uint8_t *)0) );
    212a:	68bb      	ldr	r3, [r7, #8]
    212c:	2b00      	cmp	r3, #0
    212e:	d100      	bne.n	2132 <MSS_UART_irq_tx+0x32>
    2130:	be00      	bkpt	0x0000
    ASSERT( tx_size > 0U );
    2132:	687b      	ldr	r3, [r7, #4]
    2134:	2b00      	cmp	r3, #0
    2136:	d100      	bne.n	213a <MSS_UART_irq_tx+0x3a>
    2138:	be00      	bkpt	0x0000

    if ( ( tx_size > 0U ) && ( pbuff != ((uint8_t *)0) ) &&
    213a:	687b      	ldr	r3, [r7, #4]
    213c:	2b00      	cmp	r3, #0
    213e:	d032      	beq.n	21a6 <MSS_UART_irq_tx+0xa6>
    2140:	68bb      	ldr	r3, [r7, #8]
    2142:	2b00      	cmp	r3, #0
    2144:	d02f      	beq.n	21a6 <MSS_UART_irq_tx+0xa6>
       ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) ) )
    2146:	68fa      	ldr	r2, [r7, #12]
    2148:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    214c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2150:	429a      	cmp	r2, r3
    2152:	d006      	beq.n	2162 <MSS_UART_irq_tx+0x62>
    2154:	68fa      	ldr	r2, [r7, #12]
    2156:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    215a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    215e:	429a      	cmp	r2, r3
    2160:	d121      	bne.n	21a6 <MSS_UART_irq_tx+0xa6>
    {
        /*Initialise the transmit info for the UART instance with the arguments.*/
        this_uart->tx_buffer = pbuff;
    2162:	68fb      	ldr	r3, [r7, #12]
    2164:	68ba      	ldr	r2, [r7, #8]
    2166:	60da      	str	r2, [r3, #12]
        this_uart->tx_buff_size = tx_size;
    2168:	68fb      	ldr	r3, [r7, #12]
    216a:	687a      	ldr	r2, [r7, #4]
    216c:	611a      	str	r2, [r3, #16]
        this_uart->tx_idx = (uint16_t)0;
    216e:	68fb      	ldr	r3, [r7, #12]
    2170:	f04f 0200 	mov.w	r2, #0
    2174:	615a      	str	r2, [r3, #20]

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ( this_uart->irqn );
    2176:	68fb      	ldr	r3, [r7, #12]
    2178:	891b      	ldrh	r3, [r3, #8]
    217a:	b21b      	sxth	r3, r3
    217c:	4618      	mov	r0, r3
    217e:	f7ff fdc5 	bl	1d0c <NVIC_ClearPendingIRQ>

        /* assign default handler for data transfer */
        this_uart->tx_handler = default_tx_handler;
    2182:	68fa      	ldr	r2, [r7, #12]
    2184:	f242 533d 	movw	r3, #9533	; 0x253d
    2188:	f2c0 0300 	movt	r3, #0
    218c:	6213      	str	r3, [r2, #32]

        /* enables TX interrupt */
        this_uart->hw_reg_bit->IER_ETBEI = (uint32_t)1;
    218e:	68fb      	ldr	r3, [r7, #12]
    2190:	685b      	ldr	r3, [r3, #4]
    2192:	f04f 0201 	mov.w	r2, #1
    2196:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

        /* Enable UART instance interrupt in Cortex-M3 NVIC. */
        NVIC_EnableIRQ( this_uart->irqn );
    219a:	68fb      	ldr	r3, [r7, #12]
    219c:	891b      	ldrh	r3, [r3, #8]
    219e:	b21b      	sxth	r3, r3
    21a0:	4618      	mov	r0, r3
    21a2:	f7ff fd79 	bl	1c98 <NVIC_EnableIRQ>
    }
}
    21a6:	f107 0710 	add.w	r7, r7, #16
    21aa:	46bd      	mov	sp, r7
    21ac:	bd80      	pop	{r7, pc}
    21ae:	bf00      	nop

000021b0 <MSS_UART_tx_complete>:
int8_t
MSS_UART_tx_complete
(
    mss_uart_instance_t * this_uart
)
{
    21b0:	b480      	push	{r7}
    21b2:	b085      	sub	sp, #20
    21b4:	af00      	add	r7, sp, #0
    21b6:	6078      	str	r0, [r7, #4]
    int8_t ret_value = 0;
    21b8:	f04f 0300 	mov.w	r3, #0
    21bc:	73bb      	strb	r3, [r7, #14]
    uint8_t status = 0U;
    21be:	f04f 0300 	mov.w	r3, #0
    21c2:	73fb      	strb	r3, [r7, #15]

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    21c4:	687a      	ldr	r2, [r7, #4]
    21c6:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    21ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    21ce:	429a      	cmp	r2, r3
    21d0:	d007      	beq.n	21e2 <MSS_UART_tx_complete+0x32>
    21d2:	687a      	ldr	r2, [r7, #4]
    21d4:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    21d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    21dc:	429a      	cmp	r2, r3
    21de:	d000      	beq.n	21e2 <MSS_UART_tx_complete+0x32>
    21e0:	be00      	bkpt	0x0000

    if ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) )
    21e2:	687a      	ldr	r2, [r7, #4]
    21e4:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    21e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    21ec:	429a      	cmp	r2, r3
    21ee:	d006      	beq.n	21fe <MSS_UART_tx_complete+0x4e>
    21f0:	687a      	ldr	r2, [r7, #4]
    21f2:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    21f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    21fa:	429a      	cmp	r2, r3
    21fc:	d117      	bne.n	222e <MSS_UART_tx_complete+0x7e>
    {
        /* Read the Line Status Register and update the sticky record. */
        status = this_uart->hw_reg->LSR;
    21fe:	687b      	ldr	r3, [r7, #4]
    2200:	681b      	ldr	r3, [r3, #0]
    2202:	7d1b      	ldrb	r3, [r3, #20]
    2204:	73fb      	strb	r3, [r7, #15]
        this_uart->status |= status;
    2206:	687b      	ldr	r3, [r7, #4]
    2208:	7a9a      	ldrb	r2, [r3, #10]
    220a:	7bfb      	ldrb	r3, [r7, #15]
    220c:	ea42 0303 	orr.w	r3, r2, r3
    2210:	b2da      	uxtb	r2, r3
    2212:	687b      	ldr	r3, [r7, #4]
    2214:	729a      	strb	r2, [r3, #10]

        if ( ( TX_COMPLETE == this_uart->tx_buff_size ) &&
    2216:	687b      	ldr	r3, [r7, #4]
    2218:	691b      	ldr	r3, [r3, #16]
    221a:	2b00      	cmp	r3, #0
    221c:	d107      	bne.n	222e <MSS_UART_tx_complete+0x7e>
             ( status & MSS_UART_TEMT ) )
    221e:	7bfb      	ldrb	r3, [r7, #15]
    2220:	f003 0340 	and.w	r3, r3, #64	; 0x40
    {
        /* Read the Line Status Register and update the sticky record. */
        status = this_uart->hw_reg->LSR;
        this_uart->status |= status;

        if ( ( TX_COMPLETE == this_uart->tx_buff_size ) &&
    2224:	2b00      	cmp	r3, #0
    2226:	d002      	beq.n	222e <MSS_UART_tx_complete+0x7e>
             ( status & MSS_UART_TEMT ) )
        {
            ret_value = (int8_t)1;
    2228:	f04f 0301 	mov.w	r3, #1
    222c:	73bb      	strb	r3, [r7, #14]
        }
    }
    return ret_value;
    222e:	7bbb      	ldrb	r3, [r7, #14]
    2230:	b25b      	sxtb	r3, r3
}
    2232:	4618      	mov	r0, r3
    2234:	f107 0714 	add.w	r7, r7, #20
    2238:	46bd      	mov	sp, r7
    223a:	bc80      	pop	{r7}
    223c:	4770      	bx	lr
    223e:	bf00      	nop

00002240 <MSS_UART_get_rx>:
(
    mss_uart_instance_t * this_uart,
    uint8_t * rx_buff,
    size_t buff_size
)
{
    2240:	b480      	push	{r7}
    2242:	b087      	sub	sp, #28
    2244:	af00      	add	r7, sp, #0
    2246:	60f8      	str	r0, [r7, #12]
    2248:	60b9      	str	r1, [r7, #8]
    224a:	607a      	str	r2, [r7, #4]
    size_t rx_size = 0U;
    224c:	f04f 0300 	mov.w	r3, #0
    2250:	613b      	str	r3, [r7, #16]
    uint8_t status = 0U;
    2252:	f04f 0300 	mov.w	r3, #0
    2256:	75fb      	strb	r3, [r7, #23]

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    2258:	68fa      	ldr	r2, [r7, #12]
    225a:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    225e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2262:	429a      	cmp	r2, r3
    2264:	d007      	beq.n	2276 <MSS_UART_get_rx+0x36>
    2266:	68fa      	ldr	r2, [r7, #12]
    2268:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    226c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2270:	429a      	cmp	r2, r3
    2272:	d000      	beq.n	2276 <MSS_UART_get_rx+0x36>
    2274:	be00      	bkpt	0x0000
    ASSERT( rx_buff != ((uint8_t *)0) );
    2276:	68bb      	ldr	r3, [r7, #8]
    2278:	2b00      	cmp	r3, #0
    227a:	d100      	bne.n	227e <MSS_UART_get_rx+0x3e>
    227c:	be00      	bkpt	0x0000
    ASSERT( buff_size > 0U );
    227e:	687b      	ldr	r3, [r7, #4]
    2280:	2b00      	cmp	r3, #0
    2282:	d100      	bne.n	2286 <MSS_UART_get_rx+0x46>
    2284:	be00      	bkpt	0x0000

    if( ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) ) &&
    2286:	68fa      	ldr	r2, [r7, #12]
    2288:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    228c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2290:	429a      	cmp	r2, r3
    2292:	d006      	beq.n	22a2 <MSS_UART_get_rx+0x62>
    2294:	68fa      	ldr	r2, [r7, #12]
    2296:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    229a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    229e:	429a      	cmp	r2, r3
    22a0:	d134      	bne.n	230c <MSS_UART_get_rx+0xcc>
    22a2:	68bb      	ldr	r3, [r7, #8]
    22a4:	2b00      	cmp	r3, #0
    22a6:	d031      	beq.n	230c <MSS_UART_get_rx+0xcc>
    22a8:	687b      	ldr	r3, [r7, #4]
    22aa:	2b00      	cmp	r3, #0
    22ac:	d02e      	beq.n	230c <MSS_UART_get_rx+0xcc>
          ( rx_buff != ((uint8_t *)0) ) && ( buff_size > 0U ) )
    {
        status = this_uart->hw_reg->LSR;
    22ae:	68fb      	ldr	r3, [r7, #12]
    22b0:	681b      	ldr	r3, [r3, #0]
    22b2:	7d1b      	ldrb	r3, [r3, #20]
    22b4:	75fb      	strb	r3, [r7, #23]
        this_uart->status |= status;
    22b6:	68fb      	ldr	r3, [r7, #12]
    22b8:	7a9a      	ldrb	r2, [r3, #10]
    22ba:	7dfb      	ldrb	r3, [r7, #23]
    22bc:	ea42 0303 	orr.w	r3, r2, r3
    22c0:	b2da      	uxtb	r2, r3
    22c2:	68fb      	ldr	r3, [r7, #12]
    22c4:	729a      	strb	r2, [r3, #10]

        while (( (status & MSS_UART_DATA_READY) != 0U) &&
    22c6:	e017      	b.n	22f8 <MSS_UART_get_rx+0xb8>
               ( rx_size < buff_size ) )
        {
            rx_buff[rx_size] = this_uart->hw_reg->RBR;
    22c8:	68ba      	ldr	r2, [r7, #8]
    22ca:	693b      	ldr	r3, [r7, #16]
    22cc:	4413      	add	r3, r2
    22ce:	68fa      	ldr	r2, [r7, #12]
    22d0:	6812      	ldr	r2, [r2, #0]
    22d2:	7812      	ldrb	r2, [r2, #0]
    22d4:	b2d2      	uxtb	r2, r2
    22d6:	701a      	strb	r2, [r3, #0]
            ++rx_size;
    22d8:	693b      	ldr	r3, [r7, #16]
    22da:	f103 0301 	add.w	r3, r3, #1
    22de:	613b      	str	r3, [r7, #16]
            status = this_uart->hw_reg->LSR;
    22e0:	68fb      	ldr	r3, [r7, #12]
    22e2:	681b      	ldr	r3, [r3, #0]
    22e4:	7d1b      	ldrb	r3, [r3, #20]
    22e6:	75fb      	strb	r3, [r7, #23]
            this_uart->status |= status;
    22e8:	68fb      	ldr	r3, [r7, #12]
    22ea:	7a9a      	ldrb	r2, [r3, #10]
    22ec:	7dfb      	ldrb	r3, [r7, #23]
    22ee:	ea42 0303 	orr.w	r3, r2, r3
    22f2:	b2da      	uxtb	r2, r3
    22f4:	68fb      	ldr	r3, [r7, #12]
    22f6:	729a      	strb	r2, [r3, #10]
          ( rx_buff != ((uint8_t *)0) ) && ( buff_size > 0U ) )
    {
        status = this_uart->hw_reg->LSR;
        this_uart->status |= status;

        while (( (status & MSS_UART_DATA_READY) != 0U) &&
    22f8:	7dfb      	ldrb	r3, [r7, #23]
    22fa:	f003 0301 	and.w	r3, r3, #1
    22fe:	b2db      	uxtb	r3, r3
    2300:	2b00      	cmp	r3, #0
    2302:	d003      	beq.n	230c <MSS_UART_get_rx+0xcc>
    2304:	693a      	ldr	r2, [r7, #16]
    2306:	687b      	ldr	r3, [r7, #4]
    2308:	429a      	cmp	r2, r3
    230a:	d3dd      	bcc.n	22c8 <MSS_UART_get_rx+0x88>
            ++rx_size;
            status = this_uart->hw_reg->LSR;
            this_uart->status |= status;
        }
    }
    return rx_size;
    230c:	693b      	ldr	r3, [r7, #16]
}
    230e:	4618      	mov	r0, r3
    2310:	f107 071c 	add.w	r7, r7, #28
    2314:	46bd      	mov	sp, r7
    2316:	bc80      	pop	{r7}
    2318:	4770      	bx	lr
    231a:	bf00      	nop

0000231c <MSS_UART_enable_irq>:
MSS_UART_enable_irq
(
    mss_uart_instance_t * this_uart,
    uint8_t irq_mask
)
{
    231c:	b580      	push	{r7, lr}
    231e:	b082      	sub	sp, #8
    2320:	af00      	add	r7, sp, #0
    2322:	6078      	str	r0, [r7, #4]
    2324:	460b      	mov	r3, r1
    2326:	70fb      	strb	r3, [r7, #3]
    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    2328:	687a      	ldr	r2, [r7, #4]
    232a:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    232e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2332:	429a      	cmp	r2, r3
    2334:	d007      	beq.n	2346 <MSS_UART_enable_irq+0x2a>
    2336:	687a      	ldr	r2, [r7, #4]
    2338:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    233c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2340:	429a      	cmp	r2, r3
    2342:	d000      	beq.n	2346 <MSS_UART_enable_irq+0x2a>
    2344:	be00      	bkpt	0x0000

    if( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) )
    2346:	687a      	ldr	r2, [r7, #4]
    2348:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    234c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2350:	429a      	cmp	r2, r3
    2352:	d006      	beq.n	2362 <MSS_UART_enable_irq+0x46>
    2354:	687a      	ldr	r2, [r7, #4]
    2356:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    235a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    235e:	429a      	cmp	r2, r3
    2360:	d116      	bne.n	2390 <MSS_UART_enable_irq+0x74>
    {
        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ( this_uart->irqn );
    2362:	687b      	ldr	r3, [r7, #4]
    2364:	891b      	ldrh	r3, [r3, #8]
    2366:	b21b      	sxth	r3, r3
    2368:	4618      	mov	r0, r3
    236a:	f7ff fccf 	bl	1d0c <NVIC_ClearPendingIRQ>
         * bit 0 - Receive Data Available Interrupt
         * bit 1 - Transmitter Holding  Register Empty Interrupt
         * bit 2 - Receiver Line Status Interrupt
         * bit 3 - Modem Status Interrupt
         */
        this_uart->hw_reg->IER |= irq_mask;
    236e:	687b      	ldr	r3, [r7, #4]
    2370:	681b      	ldr	r3, [r3, #0]
    2372:	687a      	ldr	r2, [r7, #4]
    2374:	6812      	ldr	r2, [r2, #0]
    2376:	7912      	ldrb	r2, [r2, #4]
    2378:	b2d1      	uxtb	r1, r2
    237a:	78fa      	ldrb	r2, [r7, #3]
    237c:	ea41 0202 	orr.w	r2, r1, r2
    2380:	b2d2      	uxtb	r2, r2
    2382:	711a      	strb	r2, [r3, #4]

        /* Enable UART instance interrupt in Cortex-M3 NVIC. */
        NVIC_EnableIRQ( this_uart->irqn );
    2384:	687b      	ldr	r3, [r7, #4]
    2386:	891b      	ldrh	r3, [r3, #8]
    2388:	b21b      	sxth	r3, r3
    238a:	4618      	mov	r0, r3
    238c:	f7ff fc84 	bl	1c98 <NVIC_EnableIRQ>
    }
}
    2390:	f107 0708 	add.w	r7, r7, #8
    2394:	46bd      	mov	sp, r7
    2396:	bd80      	pop	{r7, pc}

00002398 <MSS_UART_disable_irq>:
MSS_UART_disable_irq
(
    mss_uart_instance_t * this_uart,
    uint8_t irq_mask
)
{
    2398:	b580      	push	{r7, lr}
    239a:	b082      	sub	sp, #8
    239c:	af00      	add	r7, sp, #0
    239e:	6078      	str	r0, [r7, #4]
    23a0:	460b      	mov	r3, r1
    23a2:	70fb      	strb	r3, [r7, #3]
    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    23a4:	687a      	ldr	r2, [r7, #4]
    23a6:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    23aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    23ae:	429a      	cmp	r2, r3
    23b0:	d007      	beq.n	23c2 <MSS_UART_disable_irq+0x2a>
    23b2:	687a      	ldr	r2, [r7, #4]
    23b4:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    23b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    23bc:	429a      	cmp	r2, r3
    23be:	d000      	beq.n	23c2 <MSS_UART_disable_irq+0x2a>
    23c0:	be00      	bkpt	0x0000

    if( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) )
    23c2:	687a      	ldr	r2, [r7, #4]
    23c4:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    23c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    23cc:	429a      	cmp	r2, r3
    23ce:	d006      	beq.n	23de <MSS_UART_disable_irq+0x46>
    23d0:	687a      	ldr	r2, [r7, #4]
    23d2:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    23d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    23da:	429a      	cmp	r2, r3
    23dc:	d11c      	bne.n	2418 <MSS_UART_disable_irq+0x80>
         * bit 0 - Receive Data Available Interrupt
         * bit 1 - Transmitter Holding  Register Empty Interrupt
         * bit 2 - Receiver Line Status Interrupt
         * bit 3 - Modem Status Interrupt
         */
        this_uart->hw_reg->IER &= ( (uint8_t)~irq_mask );
    23de:	687b      	ldr	r3, [r7, #4]
    23e0:	681b      	ldr	r3, [r3, #0]
    23e2:	687a      	ldr	r2, [r7, #4]
    23e4:	6812      	ldr	r2, [r2, #0]
    23e6:	7912      	ldrb	r2, [r2, #4]
    23e8:	b2d1      	uxtb	r1, r2
    23ea:	78fa      	ldrb	r2, [r7, #3]
    23ec:	ea6f 0202 	mvn.w	r2, r2
    23f0:	b2d2      	uxtb	r2, r2
    23f2:	ea01 0202 	and.w	r2, r1, r2
    23f6:	b2d2      	uxtb	r2, r2
    23f8:	711a      	strb	r2, [r3, #4]

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ( this_uart->irqn );
    23fa:	687b      	ldr	r3, [r7, #4]
    23fc:	891b      	ldrh	r3, [r3, #8]
    23fe:	b21b      	sxth	r3, r3
    2400:	4618      	mov	r0, r3
    2402:	f7ff fc83 	bl	1d0c <NVIC_ClearPendingIRQ>

        if( irq_mask == IIRF_MASK )
    2406:	78fb      	ldrb	r3, [r7, #3]
    2408:	2b0f      	cmp	r3, #15
    240a:	d105      	bne.n	2418 <MSS_UART_disable_irq+0x80>
        {
            /* Disable UART instance interrupt in Cortex-M3 NVIC. */
            NVIC_DisableIRQ( this_uart->irqn );
    240c:	687b      	ldr	r3, [r7, #4]
    240e:	891b      	ldrh	r3, [r3, #8]
    2410:	b21b      	sxth	r3, r3
    2412:	4618      	mov	r0, r3
    2414:	f7ff fc5c 	bl	1cd0 <NVIC_DisableIRQ>

        }
    }
}
    2418:	f107 0708 	add.w	r7, r7, #8
    241c:	46bd      	mov	sp, r7
    241e:	bd80      	pop	{r7, pc}

00002420 <MSS_UART_isr>:
static void
MSS_UART_isr
(
    mss_uart_instance_t * this_uart
)
{
    2420:	b580      	push	{r7, lr}
    2422:	b084      	sub	sp, #16
    2424:	af00      	add	r7, sp, #0
    2426:	6078      	str	r0, [r7, #4]
    uint8_t iirf;

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    2428:	687a      	ldr	r2, [r7, #4]
    242a:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    242e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2432:	429a      	cmp	r2, r3
    2434:	d007      	beq.n	2446 <MSS_UART_isr+0x26>
    2436:	687a      	ldr	r2, [r7, #4]
    2438:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    243c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2440:	429a      	cmp	r2, r3
    2442:	d000      	beq.n	2446 <MSS_UART_isr+0x26>
    2444:	be00      	bkpt	0x0000

    if ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) )
    2446:	687a      	ldr	r2, [r7, #4]
    2448:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    244c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2450:	429a      	cmp	r2, r3
    2452:	d006      	beq.n	2462 <MSS_UART_isr+0x42>
    2454:	687a      	ldr	r2, [r7, #4]
    2456:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    245a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    245e:	429a      	cmp	r2, r3
    2460:	d167      	bne.n	2532 <MSS_UART_isr+0x112>
    {
        iirf = this_uart->hw_reg->IIR & IIRF_MASK;
    2462:	687b      	ldr	r3, [r7, #4]
    2464:	681b      	ldr	r3, [r3, #0]
    2466:	7a1b      	ldrb	r3, [r3, #8]
    2468:	b2db      	uxtb	r3, r3
    246a:	f003 030f 	and.w	r3, r3, #15
    246e:	73fb      	strb	r3, [r7, #15]

        switch ( iirf )
    2470:	7bfb      	ldrb	r3, [r7, #15]
    2472:	2b0c      	cmp	r3, #12
    2474:	d854      	bhi.n	2520 <MSS_UART_isr+0x100>
    2476:	a201      	add	r2, pc, #4	; (adr r2, 247c <MSS_UART_isr+0x5c>)
    2478:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    247c:	000024b1 	.word	0x000024b1
    2480:	00002521 	.word	0x00002521
    2484:	000024cd 	.word	0x000024cd
    2488:	00002521 	.word	0x00002521
    248c:	000024e9 	.word	0x000024e9
    2490:	00002521 	.word	0x00002521
    2494:	00002505 	.word	0x00002505
    2498:	00002521 	.word	0x00002521
    249c:	00002521 	.word	0x00002521
    24a0:	00002521 	.word	0x00002521
    24a4:	00002521 	.word	0x00002521
    24a8:	00002521 	.word	0x00002521
    24ac:	000024e9 	.word	0x000024e9
        {
            case IIRF_MODEM_STATUS:  /* Modem status interrupt */
            {
                ASSERT( NULL_HANDLER != this_uart->modemsts_handler );
    24b0:	687b      	ldr	r3, [r7, #4]
    24b2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    24b4:	2b00      	cmp	r3, #0
    24b6:	d100      	bne.n	24ba <MSS_UART_isr+0x9a>
    24b8:	be00      	bkpt	0x0000
                if( NULL_HANDLER != this_uart->modemsts_handler )
    24ba:	687b      	ldr	r3, [r7, #4]
    24bc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    24be:	2b00      	cmp	r3, #0
    24c0:	d030      	beq.n	2524 <MSS_UART_isr+0x104>
                {
                   (*(this_uart->modemsts_handler))( this_uart );
    24c2:	687b      	ldr	r3, [r7, #4]
    24c4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    24c6:	6878      	ldr	r0, [r7, #4]
    24c8:	4798      	blx	r3
                }
            }
            break;
    24ca:	e032      	b.n	2532 <MSS_UART_isr+0x112>

            case IIRF_THRE: /* Transmitter Holding Register Empty */
            {
                ASSERT( NULL_HANDLER != this_uart->tx_handler );
    24cc:	687b      	ldr	r3, [r7, #4]
    24ce:	6a1b      	ldr	r3, [r3, #32]
    24d0:	2b00      	cmp	r3, #0
    24d2:	d100      	bne.n	24d6 <MSS_UART_isr+0xb6>
    24d4:	be00      	bkpt	0x0000
                if ( NULL_HANDLER != this_uart->tx_handler )
    24d6:	687b      	ldr	r3, [r7, #4]
    24d8:	6a1b      	ldr	r3, [r3, #32]
    24da:	2b00      	cmp	r3, #0
    24dc:	d024      	beq.n	2528 <MSS_UART_isr+0x108>
                {
                    (*(this_uart->tx_handler))( this_uart );
    24de:	687b      	ldr	r3, [r7, #4]
    24e0:	6a1b      	ldr	r3, [r3, #32]
    24e2:	6878      	ldr	r0, [r7, #4]
    24e4:	4798      	blx	r3
                }
            }
            break;
    24e6:	e024      	b.n	2532 <MSS_UART_isr+0x112>

            case IIRF_RX_DATA:      /* Received Data Available */
            case IIRF_DATA_TIMEOUT: /* Received Data Timed-out */
            {
                ASSERT( NULL_HANDLER != this_uart->rx_handler );
    24e8:	687b      	ldr	r3, [r7, #4]
    24ea:	69db      	ldr	r3, [r3, #28]
    24ec:	2b00      	cmp	r3, #0
    24ee:	d100      	bne.n	24f2 <MSS_UART_isr+0xd2>
    24f0:	be00      	bkpt	0x0000
                if ( NULL_HANDLER != this_uart->rx_handler )
    24f2:	687b      	ldr	r3, [r7, #4]
    24f4:	69db      	ldr	r3, [r3, #28]
    24f6:	2b00      	cmp	r3, #0
    24f8:	d018      	beq.n	252c <MSS_UART_isr+0x10c>
                {
                    (*(this_uart->rx_handler))( this_uart );
    24fa:	687b      	ldr	r3, [r7, #4]
    24fc:	69db      	ldr	r3, [r3, #28]
    24fe:	6878      	ldr	r0, [r7, #4]
    2500:	4798      	blx	r3
                }
            }
            break;
    2502:	e016      	b.n	2532 <MSS_UART_isr+0x112>

            case IIRF_RX_LINE_STATUS:  /* Line Status Interrupt */
            {
                ASSERT( NULL_HANDLER != this_uart->linests_handler );
    2504:	687b      	ldr	r3, [r7, #4]
    2506:	699b      	ldr	r3, [r3, #24]
    2508:	2b00      	cmp	r3, #0
    250a:	d100      	bne.n	250e <MSS_UART_isr+0xee>
    250c:	be00      	bkpt	0x0000
                if ( NULL_HANDLER != this_uart->linests_handler )
    250e:	687b      	ldr	r3, [r7, #4]
    2510:	699b      	ldr	r3, [r3, #24]
    2512:	2b00      	cmp	r3, #0
    2514:	d00c      	beq.n	2530 <MSS_UART_isr+0x110>
                {
                   (*(this_uart->linests_handler))( this_uart );
    2516:	687b      	ldr	r3, [r7, #4]
    2518:	699b      	ldr	r3, [r3, #24]
    251a:	6878      	ldr	r0, [r7, #4]
    251c:	4798      	blx	r3
                }
            }
            break;
    251e:	e008      	b.n	2532 <MSS_UART_isr+0x112>

            default:
            {
                ASSERT( INVALID_INTERRUPT );
    2520:	be00      	bkpt	0x0000
    2522:	e006      	b.n	2532 <MSS_UART_isr+0x112>
                if( NULL_HANDLER != this_uart->modemsts_handler )
                {
                   (*(this_uart->modemsts_handler))( this_uart );
                }
            }
            break;
    2524:	bf00      	nop
    2526:	e004      	b.n	2532 <MSS_UART_isr+0x112>
                if ( NULL_HANDLER != this_uart->tx_handler )
                {
                    (*(this_uart->tx_handler))( this_uart );
                }
            }
            break;
    2528:	bf00      	nop
    252a:	e002      	b.n	2532 <MSS_UART_isr+0x112>
                if ( NULL_HANDLER != this_uart->rx_handler )
                {
                    (*(this_uart->rx_handler))( this_uart );
                }
            }
            break;
    252c:	bf00      	nop
    252e:	e000      	b.n	2532 <MSS_UART_isr+0x112>
                if ( NULL_HANDLER != this_uart->linests_handler )
                {
                   (*(this_uart->linests_handler))( this_uart );
                }
            }
            break;
    2530:	bf00      	nop
                ASSERT( INVALID_INTERRUPT );
            }
            break;
        }
    }
}
    2532:	f107 0710 	add.w	r7, r7, #16
    2536:	46bd      	mov	sp, r7
    2538:	bd80      	pop	{r7, pc}
    253a:	bf00      	nop

0000253c <default_tx_handler>:
static void
default_tx_handler
(
    mss_uart_instance_t * this_uart
)
{
    253c:	b480      	push	{r7}
    253e:	b087      	sub	sp, #28
    2540:	af00      	add	r7, sp, #0
    2542:	6078      	str	r0, [r7, #4]
    uint8_t status;

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    2544:	687a      	ldr	r2, [r7, #4]
    2546:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    254a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    254e:	429a      	cmp	r2, r3
    2550:	d007      	beq.n	2562 <default_tx_handler+0x26>
    2552:	687a      	ldr	r2, [r7, #4]
    2554:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    2558:	f2c2 0300 	movt	r3, #8192	; 0x2000
    255c:	429a      	cmp	r2, r3
    255e:	d000      	beq.n	2562 <default_tx_handler+0x26>
    2560:	be00      	bkpt	0x0000
    ASSERT( ( (uint8_t *)0 ) != this_uart->tx_buffer );
    2562:	687b      	ldr	r3, [r7, #4]
    2564:	68db      	ldr	r3, [r3, #12]
    2566:	2b00      	cmp	r3, #0
    2568:	d100      	bne.n	256c <default_tx_handler+0x30>
    256a:	be00      	bkpt	0x0000
    ASSERT( 0U < this_uart->tx_buff_size );
    256c:	687b      	ldr	r3, [r7, #4]
    256e:	691b      	ldr	r3, [r3, #16]
    2570:	2b00      	cmp	r3, #0
    2572:	d100      	bne.n	2576 <default_tx_handler+0x3a>
    2574:	be00      	bkpt	0x0000

    if( ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) ) &&
    2576:	687a      	ldr	r2, [r7, #4]
    2578:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    257c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2580:	429a      	cmp	r2, r3
    2582:	d006      	beq.n	2592 <default_tx_handler+0x56>
    2584:	687a      	ldr	r2, [r7, #4]
    2586:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    258a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    258e:	429a      	cmp	r2, r3
    2590:	d152      	bne.n	2638 <default_tx_handler+0xfc>
        ( ( (uint8_t *)0 ) != this_uart->tx_buffer ) &&
    2592:	687b      	ldr	r3, [r7, #4]
    2594:	68db      	ldr	r3, [r3, #12]

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    ASSERT( ( (uint8_t *)0 ) != this_uart->tx_buffer );
    ASSERT( 0U < this_uart->tx_buff_size );

    if( ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) ) &&
    2596:	2b00      	cmp	r3, #0
    2598:	d04e      	beq.n	2638 <default_tx_handler+0xfc>
        ( ( (uint8_t *)0 ) != this_uart->tx_buffer ) &&
        ( 0U < this_uart->tx_buff_size ) )
    259a:	687b      	ldr	r3, [r7, #4]
    259c:	691b      	ldr	r3, [r3, #16]

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    ASSERT( ( (uint8_t *)0 ) != this_uart->tx_buffer );
    ASSERT( 0U < this_uart->tx_buff_size );

    if( ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) ) &&
    259e:	2b00      	cmp	r3, #0
    25a0:	d04a      	beq.n	2638 <default_tx_handler+0xfc>
        ( ( (uint8_t *)0 ) != this_uart->tx_buffer ) &&
        ( 0U < this_uart->tx_buff_size ) )
    {
        /* Read the Line Status Register and update the sticky record. */
        status = this_uart->hw_reg->LSR;
    25a2:	687b      	ldr	r3, [r7, #4]
    25a4:	681b      	ldr	r3, [r3, #0]
    25a6:	7d1b      	ldrb	r3, [r3, #20]
    25a8:	72fb      	strb	r3, [r7, #11]
        this_uart->status |= status;
    25aa:	687b      	ldr	r3, [r7, #4]
    25ac:	7a9a      	ldrb	r2, [r3, #10]
    25ae:	7afb      	ldrb	r3, [r7, #11]
    25b0:	ea42 0303 	orr.w	r3, r2, r3
    25b4:	b2da      	uxtb	r2, r3
    25b6:	687b      	ldr	r3, [r7, #4]
    25b8:	729a      	strb	r2, [r3, #10]

        /*
         * This function should only be called as a result of a THRE interrupt.
         * Verify that this is true before proceeding to transmit data.
         */
        if ( status & MSS_UART_THRE )
    25ba:	7afb      	ldrb	r3, [r7, #11]
    25bc:	f003 0320 	and.w	r3, r3, #32
    25c0:	2b00      	cmp	r3, #0
    25c2:	d029      	beq.n	2618 <default_tx_handler+0xdc>
        {
            uint32_t i;
            uint32_t fill_size = TX_FIFO_SIZE;
    25c4:	f04f 0310 	mov.w	r3, #16
    25c8:	613b      	str	r3, [r7, #16]
            uint32_t tx_remain = this_uart->tx_buff_size - this_uart->tx_idx;
    25ca:	687b      	ldr	r3, [r7, #4]
    25cc:	691a      	ldr	r2, [r3, #16]
    25ce:	687b      	ldr	r3, [r7, #4]
    25d0:	695b      	ldr	r3, [r3, #20]
    25d2:	ebc3 0302 	rsb	r3, r3, r2
    25d6:	617b      	str	r3, [r7, #20]

            /* Calculate the number of bytes to transmit. */
            if ( tx_remain < TX_FIFO_SIZE )
    25d8:	697b      	ldr	r3, [r7, #20]
    25da:	2b0f      	cmp	r3, #15
    25dc:	d801      	bhi.n	25e2 <default_tx_handler+0xa6>
            {
                fill_size = tx_remain;
    25de:	697b      	ldr	r3, [r7, #20]
    25e0:	613b      	str	r3, [r7, #16]
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for ( i = 0U; i < fill_size; ++i )
    25e2:	f04f 0300 	mov.w	r3, #0
    25e6:	60fb      	str	r3, [r7, #12]
    25e8:	e012      	b.n	2610 <default_tx_handler+0xd4>
            {
                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = this_uart->tx_buffer[this_uart->tx_idx];
    25ea:	687b      	ldr	r3, [r7, #4]
    25ec:	681b      	ldr	r3, [r3, #0]
    25ee:	687a      	ldr	r2, [r7, #4]
    25f0:	68d1      	ldr	r1, [r2, #12]
    25f2:	687a      	ldr	r2, [r7, #4]
    25f4:	6952      	ldr	r2, [r2, #20]
    25f6:	440a      	add	r2, r1
    25f8:	7812      	ldrb	r2, [r2, #0]
    25fa:	701a      	strb	r2, [r3, #0]
                ++this_uart->tx_idx;
    25fc:	687b      	ldr	r3, [r7, #4]
    25fe:	695b      	ldr	r3, [r3, #20]
    2600:	f103 0201 	add.w	r2, r3, #1
    2604:	687b      	ldr	r3, [r7, #4]
    2606:	615a      	str	r2, [r3, #20]
            {
                fill_size = tx_remain;
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for ( i = 0U; i < fill_size; ++i )
    2608:	68fb      	ldr	r3, [r7, #12]
    260a:	f103 0301 	add.w	r3, r3, #1
    260e:	60fb      	str	r3, [r7, #12]
    2610:	68fa      	ldr	r2, [r7, #12]
    2612:	693b      	ldr	r3, [r7, #16]
    2614:	429a      	cmp	r2, r3
    2616:	d3e8      	bcc.n	25ea <default_tx_handler+0xae>
                ++this_uart->tx_idx;
            }
        }

        /* Flag Tx as complete if all data has been pushed into the Tx FIFO. */
        if ( this_uart->tx_idx == this_uart->tx_buff_size )
    2618:	687b      	ldr	r3, [r7, #4]
    261a:	695a      	ldr	r2, [r3, #20]
    261c:	687b      	ldr	r3, [r7, #4]
    261e:	691b      	ldr	r3, [r3, #16]
    2620:	429a      	cmp	r2, r3
    2622:	d109      	bne.n	2638 <default_tx_handler+0xfc>
        {
            this_uart->tx_buff_size = TX_COMPLETE;
    2624:	687b      	ldr	r3, [r7, #4]
    2626:	f04f 0200 	mov.w	r2, #0
    262a:	611a      	str	r2, [r3, #16]
            /* disables TX interrupt */
            this_uart->hw_reg_bit->IER_ETBEI = 0U;
    262c:	687b      	ldr	r3, [r7, #4]
    262e:	685b      	ldr	r3, [r3, #4]
    2630:	f04f 0200 	mov.w	r2, #0
    2634:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
        }
    }
}
    2638:	f107 071c 	add.w	r7, r7, #28
    263c:	46bd      	mov	sp, r7
    263e:	bc80      	pop	{r7}
    2640:	4770      	bx	lr
    2642:	bf00      	nop

00002644 <MSS_UART_set_rx_handler>:
(
    mss_uart_instance_t *       this_uart,
    mss_uart_irq_handler_t      handler,
    mss_uart_rx_trig_level_t    trigger_level
)
{
    2644:	b580      	push	{r7, lr}
    2646:	b084      	sub	sp, #16
    2648:	af00      	add	r7, sp, #0
    264a:	60f8      	str	r0, [r7, #12]
    264c:	60b9      	str	r1, [r7, #8]
    264e:	4613      	mov	r3, r2
    2650:	71fb      	strb	r3, [r7, #7]
    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    2652:	68fa      	ldr	r2, [r7, #12]
    2654:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    2658:	f2c2 0300 	movt	r3, #8192	; 0x2000
    265c:	429a      	cmp	r2, r3
    265e:	d007      	beq.n	2670 <MSS_UART_set_rx_handler+0x2c>
    2660:	68fa      	ldr	r2, [r7, #12]
    2662:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    2666:	f2c2 0300 	movt	r3, #8192	; 0x2000
    266a:	429a      	cmp	r2, r3
    266c:	d000      	beq.n	2670 <MSS_UART_set_rx_handler+0x2c>
    266e:	be00      	bkpt	0x0000
    ASSERT( handler != INVALID_IRQ_HANDLER );
    2670:	68bb      	ldr	r3, [r7, #8]
    2672:	2b00      	cmp	r3, #0
    2674:	d100      	bne.n	2678 <MSS_UART_set_rx_handler+0x34>
    2676:	be00      	bkpt	0x0000
    ASSERT( trigger_level < MSS_UART_FIFO_INVALID_TRIG_LEVEL );
    2678:	79fb      	ldrb	r3, [r7, #7]
    267a:	2bc0      	cmp	r3, #192	; 0xc0
    267c:	d900      	bls.n	2680 <MSS_UART_set_rx_handler+0x3c>
    267e:	be00      	bkpt	0x0000

    if( ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) ) &&
    2680:	68fa      	ldr	r2, [r7, #12]
    2682:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    2686:	f2c2 0300 	movt	r3, #8192	; 0x2000
    268a:	429a      	cmp	r2, r3
    268c:	d006      	beq.n	269c <MSS_UART_set_rx_handler+0x58>
    268e:	68fa      	ldr	r2, [r7, #12]
    2690:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    2694:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2698:	429a      	cmp	r2, r3
    269a:	d123      	bne.n	26e4 <MSS_UART_set_rx_handler+0xa0>
    269c:	68bb      	ldr	r3, [r7, #8]
    269e:	2b00      	cmp	r3, #0
    26a0:	d020      	beq.n	26e4 <MSS_UART_set_rx_handler+0xa0>
    26a2:	79fb      	ldrb	r3, [r7, #7]
    26a4:	2bc0      	cmp	r3, #192	; 0xc0
    26a6:	d81d      	bhi.n	26e4 <MSS_UART_set_rx_handler+0xa0>
        ( handler != INVALID_IRQ_HANDLER) &&
        ( trigger_level < MSS_UART_FIFO_INVALID_TRIG_LEVEL) )
    {
        this_uart->rx_handler = handler;
    26a8:	68fb      	ldr	r3, [r7, #12]
    26aa:	68ba      	ldr	r2, [r7, #8]
    26ac:	61da      	str	r2, [r3, #28]

        /* Set the receive interrupt trigger level. */
        /* Clear RX FIFO; Enable TXRDY and RXRDY for PDMA */
        this_uart->hw_reg->FCR = (uint8_t)(FCR_TRIG_LEVEL_MASK & (uint8_t)trigger_level) |
    26ae:	68fb      	ldr	r3, [r7, #12]
    26b0:	681a      	ldr	r2, [r3, #0]
    26b2:	79fb      	ldrb	r3, [r7, #7]
    26b4:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    26b8:	f043 030a 	orr.w	r3, r3, #10
    26bc:	b2db      	uxtb	r3, r3
    26be:	7213      	strb	r3, [r2, #8]
                              FCR_CLEAR_RX_FIFO_MASK | FCR_ENABLE_TXRDY_RXRDY_MASK;

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ( this_uart->irqn );
    26c0:	68fb      	ldr	r3, [r7, #12]
    26c2:	891b      	ldrh	r3, [r3, #8]
    26c4:	b21b      	sxth	r3, r3
    26c6:	4618      	mov	r0, r3
    26c8:	f7ff fb20 	bl	1d0c <NVIC_ClearPendingIRQ>

        /* Enable receive interrupt. */
        this_uart->hw_reg_bit->IER_ERBFI = 1U;
    26cc:	68fb      	ldr	r3, [r7, #12]
    26ce:	685b      	ldr	r3, [r3, #4]
    26d0:	f04f 0201 	mov.w	r2, #1
    26d4:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

        /* Enable UART instance interrupt in Cortex-M3 NVIC. */
        NVIC_EnableIRQ( this_uart->irqn );
    26d8:	68fb      	ldr	r3, [r7, #12]
    26da:	891b      	ldrh	r3, [r3, #8]
    26dc:	b21b      	sxth	r3, r3
    26de:	4618      	mov	r0, r3
    26e0:	f7ff fada 	bl	1c98 <NVIC_EnableIRQ>
    }
}
    26e4:	f107 0710 	add.w	r7, r7, #16
    26e8:	46bd      	mov	sp, r7
    26ea:	bd80      	pop	{r7, pc}

000026ec <MSS_UART_set_loopback>:
MSS_UART_set_loopback
(
    mss_uart_instance_t *   this_uart,
    mss_uart_loopback_t     loopback
)
{
    26ec:	b480      	push	{r7}
    26ee:	b083      	sub	sp, #12
    26f0:	af00      	add	r7, sp, #0
    26f2:	6078      	str	r0, [r7, #4]
    26f4:	460b      	mov	r3, r1
    26f6:	70fb      	strb	r3, [r7, #3]
    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    26f8:	687a      	ldr	r2, [r7, #4]
    26fa:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    26fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2702:	429a      	cmp	r2, r3
    2704:	d007      	beq.n	2716 <MSS_UART_set_loopback+0x2a>
    2706:	687a      	ldr	r2, [r7, #4]
    2708:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    270c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2710:	429a      	cmp	r2, r3
    2712:	d000      	beq.n	2716 <MSS_UART_set_loopback+0x2a>
    2714:	be00      	bkpt	0x0000

    if( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) )
    2716:	687a      	ldr	r2, [r7, #4]
    2718:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    271c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2720:	429a      	cmp	r2, r3
    2722:	d006      	beq.n	2732 <MSS_UART_set_loopback+0x46>
    2724:	687a      	ldr	r2, [r7, #4]
    2726:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    272a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    272e:	429a      	cmp	r2, r3
    2730:	d10f      	bne.n	2752 <MSS_UART_set_loopback+0x66>
    {
        if ( loopback == MSS_UART_LOOPBACK_OFF )
    2732:	78fb      	ldrb	r3, [r7, #3]
    2734:	2b00      	cmp	r3, #0
    2736:	d106      	bne.n	2746 <MSS_UART_set_loopback+0x5a>
        {
            this_uart->hw_reg_bit->MCR_LOOP = 0U;
    2738:	687b      	ldr	r3, [r7, #4]
    273a:	685b      	ldr	r3, [r3, #4]
    273c:	f04f 0200 	mov.w	r2, #0
    2740:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
    2744:	e005      	b.n	2752 <MSS_UART_set_loopback+0x66>
        }
        else
        {
            this_uart->hw_reg_bit->MCR_LOOP = 1U;
    2746:	687b      	ldr	r3, [r7, #4]
    2748:	685b      	ldr	r3, [r3, #4]
    274a:	f04f 0201 	mov.w	r2, #1
    274e:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
        }
    }
}
    2752:	f107 070c 	add.w	r7, r7, #12
    2756:	46bd      	mov	sp, r7
    2758:	bc80      	pop	{r7}
    275a:	4770      	bx	lr

0000275c <UART0_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void UART0_IRQHandler( void )
#else
void UART0_IRQHandler( void )
#endif
{
    275c:	4668      	mov	r0, sp
    275e:	f020 0107 	bic.w	r1, r0, #7
    2762:	468d      	mov	sp, r1
    2764:	b589      	push	{r0, r3, r7, lr}
    2766:	af00      	add	r7, sp, #0
    MSS_UART_isr( &g_mss_uart0 );
    2768:	f64a 10e4 	movw	r0, #43492	; 0xa9e4
    276c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    2770:	f7ff fe56 	bl	2420 <MSS_UART_isr>
    NVIC_ClearPendingIRQ( UART0_IRQn );
    2774:	f04f 000a 	mov.w	r0, #10
    2778:	f7ff fac8 	bl	1d0c <NVIC_ClearPendingIRQ>
}
    277c:	46bd      	mov	sp, r7
    277e:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    2782:	4685      	mov	sp, r0
    2784:	4770      	bx	lr
    2786:	bf00      	nop

00002788 <UART1_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void UART1_IRQHandler( void )
#else
void UART1_IRQHandler( void )
#endif
{
    2788:	4668      	mov	r0, sp
    278a:	f020 0107 	bic.w	r1, r0, #7
    278e:	468d      	mov	sp, r1
    2790:	b589      	push	{r0, r3, r7, lr}
    2792:	af00      	add	r7, sp, #0
    MSS_UART_isr( &g_mss_uart1 );
    2794:	f64a 10bc 	movw	r0, #43452	; 0xa9bc
    2798:	f2c2 0000 	movt	r0, #8192	; 0x2000
    279c:	f7ff fe40 	bl	2420 <MSS_UART_isr>
    NVIC_ClearPendingIRQ( UART1_IRQn );
    27a0:	f04f 000b 	mov.w	r0, #11
    27a4:	f7ff fab2 	bl	1d0c <NVIC_ClearPendingIRQ>
}
    27a8:	46bd      	mov	sp, r7
    27aa:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    27ae:	4685      	mov	sp, r0
    27b0:	4770      	bx	lr
    27b2:	bf00      	nop

000027b4 <MSS_UART_set_rxstatus_handler>:
MSS_UART_set_rxstatus_handler
(
    mss_uart_instance_t * this_uart,
    mss_uart_irq_handler_t handler
)
{
    27b4:	b580      	push	{r7, lr}
    27b6:	b082      	sub	sp, #8
    27b8:	af00      	add	r7, sp, #0
    27ba:	6078      	str	r0, [r7, #4]
    27bc:	6039      	str	r1, [r7, #0]
    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    27be:	687a      	ldr	r2, [r7, #4]
    27c0:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    27c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    27c8:	429a      	cmp	r2, r3
    27ca:	d007      	beq.n	27dc <MSS_UART_set_rxstatus_handler+0x28>
    27cc:	687a      	ldr	r2, [r7, #4]
    27ce:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    27d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    27d6:	429a      	cmp	r2, r3
    27d8:	d000      	beq.n	27dc <MSS_UART_set_rxstatus_handler+0x28>
    27da:	be00      	bkpt	0x0000
    ASSERT( handler != INVALID_IRQ_HANDLER);
    27dc:	683b      	ldr	r3, [r7, #0]
    27de:	2b00      	cmp	r3, #0
    27e0:	d100      	bne.n	27e4 <MSS_UART_set_rxstatus_handler+0x30>
    27e2:	be00      	bkpt	0x0000

    if( ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) ) &&
    27e4:	687a      	ldr	r2, [r7, #4]
    27e6:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    27ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    27ee:	429a      	cmp	r2, r3
    27f0:	d006      	beq.n	2800 <MSS_UART_set_rxstatus_handler+0x4c>
    27f2:	687a      	ldr	r2, [r7, #4]
    27f4:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    27f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    27fc:	429a      	cmp	r2, r3
    27fe:	d117      	bne.n	2830 <MSS_UART_set_rxstatus_handler+0x7c>
    2800:	683b      	ldr	r3, [r7, #0]
    2802:	2b00      	cmp	r3, #0
    2804:	d014      	beq.n	2830 <MSS_UART_set_rxstatus_handler+0x7c>
        ( handler != INVALID_IRQ_HANDLER) )
    {
        this_uart->linests_handler = handler;
    2806:	687b      	ldr	r3, [r7, #4]
    2808:	683a      	ldr	r2, [r7, #0]
    280a:	619a      	str	r2, [r3, #24]

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ( this_uart->irqn );
    280c:	687b      	ldr	r3, [r7, #4]
    280e:	891b      	ldrh	r3, [r3, #8]
    2810:	b21b      	sxth	r3, r3
    2812:	4618      	mov	r0, r3
    2814:	f7ff fa7a 	bl	1d0c <NVIC_ClearPendingIRQ>

        /* Enable receiver line status interrupt. */
        this_uart->hw_reg_bit->IER_ELSI = 1U;
    2818:	687b      	ldr	r3, [r7, #4]
    281a:	685b      	ldr	r3, [r3, #4]
    281c:	f04f 0201 	mov.w	r2, #1
    2820:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

        /* Enable UART instance interrupt in Cortex-M3 NVIC. */
        NVIC_EnableIRQ( this_uart->irqn );
    2824:	687b      	ldr	r3, [r7, #4]
    2826:	891b      	ldrh	r3, [r3, #8]
    2828:	b21b      	sxth	r3, r3
    282a:	4618      	mov	r0, r3
    282c:	f7ff fa34 	bl	1c98 <NVIC_EnableIRQ>
    }
}
    2830:	f107 0708 	add.w	r7, r7, #8
    2834:	46bd      	mov	sp, r7
    2836:	bd80      	pop	{r7, pc}

00002838 <MSS_UART_set_tx_handler>:
MSS_UART_set_tx_handler
(
    mss_uart_instance_t * this_uart,
    mss_uart_irq_handler_t handler
)
{
    2838:	b580      	push	{r7, lr}
    283a:	b082      	sub	sp, #8
    283c:	af00      	add	r7, sp, #0
    283e:	6078      	str	r0, [r7, #4]
    2840:	6039      	str	r1, [r7, #0]
    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    2842:	687a      	ldr	r2, [r7, #4]
    2844:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    2848:	f2c2 0300 	movt	r3, #8192	; 0x2000
    284c:	429a      	cmp	r2, r3
    284e:	d007      	beq.n	2860 <MSS_UART_set_tx_handler+0x28>
    2850:	687a      	ldr	r2, [r7, #4]
    2852:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    2856:	f2c2 0300 	movt	r3, #8192	; 0x2000
    285a:	429a      	cmp	r2, r3
    285c:	d000      	beq.n	2860 <MSS_UART_set_tx_handler+0x28>
    285e:	be00      	bkpt	0x0000
    ASSERT( handler != INVALID_IRQ_HANDLER);
    2860:	683b      	ldr	r3, [r7, #0]
    2862:	2b00      	cmp	r3, #0
    2864:	d100      	bne.n	2868 <MSS_UART_set_tx_handler+0x30>
    2866:	be00      	bkpt	0x0000

    if( ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) ) &&
    2868:	687a      	ldr	r2, [r7, #4]
    286a:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    286e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2872:	429a      	cmp	r2, r3
    2874:	d006      	beq.n	2884 <MSS_UART_set_tx_handler+0x4c>
    2876:	687a      	ldr	r2, [r7, #4]
    2878:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    287c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2880:	429a      	cmp	r2, r3
    2882:	d11f      	bne.n	28c4 <MSS_UART_set_tx_handler+0x8c>
    2884:	683b      	ldr	r3, [r7, #0]
    2886:	2b00      	cmp	r3, #0
    2888:	d01c      	beq.n	28c4 <MSS_UART_set_tx_handler+0x8c>
        ( handler != INVALID_IRQ_HANDLER) )
    {
        this_uart->tx_handler = handler;
    288a:	687b      	ldr	r3, [r7, #4]
    288c:	683a      	ldr	r2, [r7, #0]
    288e:	621a      	str	r2, [r3, #32]

        /* Make TX buffer info invalid */
        this_uart->tx_buffer = (const uint8_t *)0;
    2890:	687b      	ldr	r3, [r7, #4]
    2892:	f04f 0200 	mov.w	r2, #0
    2896:	60da      	str	r2, [r3, #12]
        this_uart->tx_buff_size = 0U;
    2898:	687b      	ldr	r3, [r7, #4]
    289a:	f04f 0200 	mov.w	r2, #0
    289e:	611a      	str	r2, [r3, #16]

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ( this_uart->irqn );
    28a0:	687b      	ldr	r3, [r7, #4]
    28a2:	891b      	ldrh	r3, [r3, #8]
    28a4:	b21b      	sxth	r3, r3
    28a6:	4618      	mov	r0, r3
    28a8:	f7ff fa30 	bl	1d0c <NVIC_ClearPendingIRQ>

        /* Enable transmitter holding register Empty interrupt. */
        this_uart->hw_reg_bit->IER_ETBEI = 1U;
    28ac:	687b      	ldr	r3, [r7, #4]
    28ae:	685b      	ldr	r3, [r3, #4]
    28b0:	f04f 0201 	mov.w	r2, #1
    28b4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

        /* Enable UART instance interrupt in Cortex-M3 NVIC. */
        NVIC_EnableIRQ( this_uart->irqn );
    28b8:	687b      	ldr	r3, [r7, #4]
    28ba:	891b      	ldrh	r3, [r3, #8]
    28bc:	b21b      	sxth	r3, r3
    28be:	4618      	mov	r0, r3
    28c0:	f7ff f9ea 	bl	1c98 <NVIC_EnableIRQ>
    }
}
    28c4:	f107 0708 	add.w	r7, r7, #8
    28c8:	46bd      	mov	sp, r7
    28ca:	bd80      	pop	{r7, pc}

000028cc <MSS_UART_set_modemstatus_handler>:
MSS_UART_set_modemstatus_handler
(
    mss_uart_instance_t * this_uart,
    mss_uart_irq_handler_t handler
)
{
    28cc:	b580      	push	{r7, lr}
    28ce:	b082      	sub	sp, #8
    28d0:	af00      	add	r7, sp, #0
    28d2:	6078      	str	r0, [r7, #4]
    28d4:	6039      	str	r1, [r7, #0]
    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    28d6:	687a      	ldr	r2, [r7, #4]
    28d8:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    28dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    28e0:	429a      	cmp	r2, r3
    28e2:	d007      	beq.n	28f4 <MSS_UART_set_modemstatus_handler+0x28>
    28e4:	687a      	ldr	r2, [r7, #4]
    28e6:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    28ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    28ee:	429a      	cmp	r2, r3
    28f0:	d000      	beq.n	28f4 <MSS_UART_set_modemstatus_handler+0x28>
    28f2:	be00      	bkpt	0x0000
    ASSERT( handler != INVALID_IRQ_HANDLER );
    28f4:	683b      	ldr	r3, [r7, #0]
    28f6:	2b00      	cmp	r3, #0
    28f8:	d100      	bne.n	28fc <MSS_UART_set_modemstatus_handler+0x30>
    28fa:	be00      	bkpt	0x0000

    if( ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) ) &&
    28fc:	687a      	ldr	r2, [r7, #4]
    28fe:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    2902:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2906:	429a      	cmp	r2, r3
    2908:	d006      	beq.n	2918 <MSS_UART_set_modemstatus_handler+0x4c>
    290a:	687a      	ldr	r2, [r7, #4]
    290c:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    2910:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2914:	429a      	cmp	r2, r3
    2916:	d117      	bne.n	2948 <MSS_UART_set_modemstatus_handler+0x7c>
    2918:	683b      	ldr	r3, [r7, #0]
    291a:	2b00      	cmp	r3, #0
    291c:	d014      	beq.n	2948 <MSS_UART_set_modemstatus_handler+0x7c>
        ( handler != INVALID_IRQ_HANDLER) )
    {
        this_uart->modemsts_handler = handler;
    291e:	687b      	ldr	r3, [r7, #4]
    2920:	683a      	ldr	r2, [r7, #0]
    2922:	625a      	str	r2, [r3, #36]	; 0x24

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ( this_uart->irqn );
    2924:	687b      	ldr	r3, [r7, #4]
    2926:	891b      	ldrh	r3, [r3, #8]
    2928:	b21b      	sxth	r3, r3
    292a:	4618      	mov	r0, r3
    292c:	f7ff f9ee 	bl	1d0c <NVIC_ClearPendingIRQ>

        /* Enable modem status interrupt. */
        this_uart->hw_reg_bit->IER_EDSSI = 1U;
    2930:	687b      	ldr	r3, [r7, #4]
    2932:	685b      	ldr	r3, [r3, #4]
    2934:	f04f 0201 	mov.w	r2, #1
    2938:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

        /* Enable UART instance interrupt in Cortex-M3 NVIC. */
        NVIC_EnableIRQ( this_uart->irqn );
    293c:	687b      	ldr	r3, [r7, #4]
    293e:	891b      	ldrh	r3, [r3, #8]
    2940:	b21b      	sxth	r3, r3
    2942:	4618      	mov	r0, r3
    2944:	f7ff f9a8 	bl	1c98 <NVIC_EnableIRQ>
    }
}
    2948:	f107 0708 	add.w	r7, r7, #8
    294c:	46bd      	mov	sp, r7
    294e:	bd80      	pop	{r7, pc}

00002950 <MSS_UART_fill_tx_fifo>:
(
    mss_uart_instance_t * this_uart,
    const uint8_t * tx_buffer,
    size_t tx_size
)
{
    2950:	b480      	push	{r7}
    2952:	b089      	sub	sp, #36	; 0x24
    2954:	af00      	add	r7, sp, #0
    2956:	60f8      	str	r0, [r7, #12]
    2958:	60b9      	str	r1, [r7, #8]
    295a:	607a      	str	r2, [r7, #4]
    uint8_t status = 0U;
    295c:	f04f 0300 	mov.w	r3, #0
    2960:	75fb      	strb	r3, [r7, #23]
    size_t size_sent = 0U;
    2962:	f04f 0300 	mov.w	r3, #0
    2966:	61bb      	str	r3, [r7, #24]

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    2968:	68fa      	ldr	r2, [r7, #12]
    296a:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    296e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2972:	429a      	cmp	r2, r3
    2974:	d007      	beq.n	2986 <MSS_UART_fill_tx_fifo+0x36>
    2976:	68fa      	ldr	r2, [r7, #12]
    2978:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    297c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2980:	429a      	cmp	r2, r3
    2982:	d000      	beq.n	2986 <MSS_UART_fill_tx_fifo+0x36>
    2984:	be00      	bkpt	0x0000
    ASSERT( tx_buffer != ( (uint8_t *)0 ) );
    2986:	68bb      	ldr	r3, [r7, #8]
    2988:	2b00      	cmp	r3, #0
    298a:	d100      	bne.n	298e <MSS_UART_fill_tx_fifo+0x3e>
    298c:	be00      	bkpt	0x0000
    ASSERT( tx_size > 0 );
    298e:	687b      	ldr	r3, [r7, #4]
    2990:	2b00      	cmp	r3, #0
    2992:	d100      	bne.n	2996 <MSS_UART_fill_tx_fifo+0x46>
    2994:	be00      	bkpt	0x0000

    /* Fill the UART's Tx FIFO until the FIFO is full or the complete input
     * buffer has been written. */
    if( ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1 ) ) &&
    2996:	68fa      	ldr	r2, [r7, #12]
    2998:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    299c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    29a0:	429a      	cmp	r2, r3
    29a2:	d006      	beq.n	29b2 <MSS_UART_fill_tx_fifo+0x62>
    29a4:	68fa      	ldr	r2, [r7, #12]
    29a6:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    29aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    29ae:	429a      	cmp	r2, r3
    29b0:	d131      	bne.n	2a16 <MSS_UART_fill_tx_fifo+0xc6>
    29b2:	68bb      	ldr	r3, [r7, #8]
    29b4:	2b00      	cmp	r3, #0
    29b6:	d02e      	beq.n	2a16 <MSS_UART_fill_tx_fifo+0xc6>
    29b8:	687b      	ldr	r3, [r7, #4]
    29ba:	2b00      	cmp	r3, #0
    29bc:	d02b      	beq.n	2a16 <MSS_UART_fill_tx_fifo+0xc6>
        (tx_buffer != ( (uint8_t *)0 ))   &&
        (tx_size > 0u) )
    {
        status = this_uart->hw_reg->LSR;
    29be:	68fb      	ldr	r3, [r7, #12]
    29c0:	681b      	ldr	r3, [r3, #0]
    29c2:	7d1b      	ldrb	r3, [r3, #20]
    29c4:	75fb      	strb	r3, [r7, #23]
        this_uart->status |= status;
    29c6:	68fb      	ldr	r3, [r7, #12]
    29c8:	7a9a      	ldrb	r2, [r3, #10]
    29ca:	7dfb      	ldrb	r3, [r7, #23]
    29cc:	ea42 0303 	orr.w	r3, r2, r3
    29d0:	b2da      	uxtb	r2, r3
    29d2:	68fb      	ldr	r3, [r7, #12]
    29d4:	729a      	strb	r2, [r3, #10]

        if( status & MSS_UART_THRE )
    29d6:	7dfb      	ldrb	r3, [r7, #23]
    29d8:	f003 0320 	and.w	r3, r3, #32
    29dc:	2b00      	cmp	r3, #0
    29de:	d01a      	beq.n	2a16 <MSS_UART_fill_tx_fifo+0xc6>
        {
            uint32_t fill_size = TX_FIFO_SIZE;
    29e0:	f04f 0310 	mov.w	r3, #16
    29e4:	61fb      	str	r3, [r7, #28]

            if ( tx_size < TX_FIFO_SIZE )
    29e6:	687b      	ldr	r3, [r7, #4]
    29e8:	2b0f      	cmp	r3, #15
    29ea:	d801      	bhi.n	29f0 <MSS_UART_fill_tx_fifo+0xa0>
            {
                fill_size = tx_size;
    29ec:	687b      	ldr	r3, [r7, #4]
    29ee:	61fb      	str	r3, [r7, #28]
            }
            /* Fill up FIFO */
            for ( size_sent = 0U; size_sent < fill_size; ++size_sent )
    29f0:	f04f 0300 	mov.w	r3, #0
    29f4:	61bb      	str	r3, [r7, #24]
    29f6:	e00a      	b.n	2a0e <MSS_UART_fill_tx_fifo+0xbe>
            {

                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = tx_buffer[size_sent];
    29f8:	68fb      	ldr	r3, [r7, #12]
    29fa:	681b      	ldr	r3, [r3, #0]
    29fc:	68b9      	ldr	r1, [r7, #8]
    29fe:	69ba      	ldr	r2, [r7, #24]
    2a00:	440a      	add	r2, r1
    2a02:	7812      	ldrb	r2, [r2, #0]
    2a04:	701a      	strb	r2, [r3, #0]
            if ( tx_size < TX_FIFO_SIZE )
            {
                fill_size = tx_size;
            }
            /* Fill up FIFO */
            for ( size_sent = 0U; size_sent < fill_size; ++size_sent )
    2a06:	69bb      	ldr	r3, [r7, #24]
    2a08:	f103 0301 	add.w	r3, r3, #1
    2a0c:	61bb      	str	r3, [r7, #24]
    2a0e:	69ba      	ldr	r2, [r7, #24]
    2a10:	69fb      	ldr	r3, [r7, #28]
    2a12:	429a      	cmp	r2, r3
    2a14:	d3f0      	bcc.n	29f8 <MSS_UART_fill_tx_fifo+0xa8>
                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = tx_buffer[size_sent];
            }
        }
    }
    return size_sent;
    2a16:	69bb      	ldr	r3, [r7, #24]
}
    2a18:	4618      	mov	r0, r3
    2a1a:	f107 0724 	add.w	r7, r7, #36	; 0x24
    2a1e:	46bd      	mov	sp, r7
    2a20:	bc80      	pop	{r7}
    2a22:	4770      	bx	lr

00002a24 <MSS_UART_get_rx_status>:
uint8_t
MSS_UART_get_rx_status
(
    mss_uart_instance_t * this_uart
)
{
    2a24:	b480      	push	{r7}
    2a26:	b085      	sub	sp, #20
    2a28:	af00      	add	r7, sp, #0
    2a2a:	6078      	str	r0, [r7, #4]
    uint8_t status = MSS_UART_INVALID_PARAM;
    2a2c:	f04f 33ff 	mov.w	r3, #4294967295
    2a30:	73fb      	strb	r3, [r7, #15]

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    2a32:	687a      	ldr	r2, [r7, #4]
    2a34:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    2a38:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a3c:	429a      	cmp	r2, r3
    2a3e:	d007      	beq.n	2a50 <MSS_UART_get_rx_status+0x2c>
    2a40:	687a      	ldr	r2, [r7, #4]
    2a42:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    2a46:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a4a:	429a      	cmp	r2, r3
    2a4c:	d000      	beq.n	2a50 <MSS_UART_get_rx_status+0x2c>
    2a4e:	be00      	bkpt	0x0000

    if( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) )
    2a50:	687a      	ldr	r2, [r7, #4]
    2a52:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    2a56:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a5a:	429a      	cmp	r2, r3
    2a5c:	d006      	beq.n	2a6c <MSS_UART_get_rx_status+0x48>
    2a5e:	687a      	ldr	r2, [r7, #4]
    2a60:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    2a64:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a68:	429a      	cmp	r2, r3
    2a6a:	d113      	bne.n	2a94 <MSS_UART_get_rx_status+0x70>
         * Bit 2 - Parity error status
         * Bit 3 - Frame error status
         * Bit 4 - Break interrupt indicator
         * Bit 7 - FIFO data error status
         */
        this_uart->status |= (this_uart->hw_reg->LSR);
    2a6c:	687b      	ldr	r3, [r7, #4]
    2a6e:	7a9a      	ldrb	r2, [r3, #10]
    2a70:	687b      	ldr	r3, [r7, #4]
    2a72:	681b      	ldr	r3, [r3, #0]
    2a74:	7d1b      	ldrb	r3, [r3, #20]
    2a76:	b2db      	uxtb	r3, r3
    2a78:	ea42 0303 	orr.w	r3, r2, r3
    2a7c:	b2da      	uxtb	r2, r3
    2a7e:	687b      	ldr	r3, [r7, #4]
    2a80:	729a      	strb	r2, [r3, #10]
        status = (this_uart->status & STATUS_ERROR_MASK );
    2a82:	687b      	ldr	r3, [r7, #4]
    2a84:	7a9b      	ldrb	r3, [r3, #10]
    2a86:	f023 0361 	bic.w	r3, r3, #97	; 0x61
    2a8a:	73fb      	strb	r3, [r7, #15]
        /* Clear the sticky status after reading */
        this_uart->status = 0U;
    2a8c:	687b      	ldr	r3, [r7, #4]
    2a8e:	f04f 0200 	mov.w	r2, #0
    2a92:	729a      	strb	r2, [r3, #10]
    }
    return status;
    2a94:	7bfb      	ldrb	r3, [r7, #15]
}
    2a96:	4618      	mov	r0, r3
    2a98:	f107 0714 	add.w	r7, r7, #20
    2a9c:	46bd      	mov	sp, r7
    2a9e:	bc80      	pop	{r7}
    2aa0:	4770      	bx	lr
    2aa2:	bf00      	nop

00002aa4 <MSS_UART_get_modem_status>:
uint8_t
MSS_UART_get_modem_status
(
    mss_uart_instance_t * this_uart
)
{
    2aa4:	b480      	push	{r7}
    2aa6:	b085      	sub	sp, #20
    2aa8:	af00      	add	r7, sp, #0
    2aaa:	6078      	str	r0, [r7, #4]
    uint8_t status = MSS_UART_INVALID_PARAM;
    2aac:	f04f 33ff 	mov.w	r3, #4294967295
    2ab0:	73fb      	strb	r3, [r7, #15]

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    2ab2:	687a      	ldr	r2, [r7, #4]
    2ab4:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    2ab8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2abc:	429a      	cmp	r2, r3
    2abe:	d007      	beq.n	2ad0 <MSS_UART_get_modem_status+0x2c>
    2ac0:	687a      	ldr	r2, [r7, #4]
    2ac2:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    2ac6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2aca:	429a      	cmp	r2, r3
    2acc:	d000      	beq.n	2ad0 <MSS_UART_get_modem_status+0x2c>
    2ace:	be00      	bkpt	0x0000

    if( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) )
    2ad0:	687a      	ldr	r2, [r7, #4]
    2ad2:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    2ad6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2ada:	429a      	cmp	r2, r3
    2adc:	d006      	beq.n	2aec <MSS_UART_get_modem_status+0x48>
    2ade:	687a      	ldr	r2, [r7, #4]
    2ae0:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    2ae4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2ae8:	429a      	cmp	r2, r3
    2aea:	d103      	bne.n	2af4 <MSS_UART_get_modem_status+0x50>
         * Bit 4 - Clear To Send
         * Bit 5 - Data Set Ready
         * Bit 6 - Ring Indicator
         * Bit 7 - Data Carrier Detect
         */
        status = this_uart->hw_reg->MSR;
    2aec:	687b      	ldr	r3, [r7, #4]
    2aee:	681b      	ldr	r3, [r3, #0]
    2af0:	7e1b      	ldrb	r3, [r3, #24]
    2af2:	73fb      	strb	r3, [r7, #15]
    }
    return status;
    2af4:	7bfb      	ldrb	r3, [r7, #15]
}
    2af6:	4618      	mov	r0, r3
    2af8:	f107 0714 	add.w	r7, r7, #20
    2afc:	46bd      	mov	sp, r7
    2afe:	bc80      	pop	{r7}
    2b00:	4770      	bx	lr
    2b02:	bf00      	nop

00002b04 <MSS_UART_get_tx_status>:
uint8_t
MSS_UART_get_tx_status
(
    mss_uart_instance_t * this_uart
)
{
    2b04:	b480      	push	{r7}
    2b06:	b085      	sub	sp, #20
    2b08:	af00      	add	r7, sp, #0
    2b0a:	6078      	str	r0, [r7, #4]
    uint8_t status = MSS_UART_TX_BUSY;
    2b0c:	f04f 0300 	mov.w	r3, #0
    2b10:	73fb      	strb	r3, [r7, #15]

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    2b12:	687a      	ldr	r2, [r7, #4]
    2b14:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    2b18:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2b1c:	429a      	cmp	r2, r3
    2b1e:	d007      	beq.n	2b30 <MSS_UART_get_tx_status+0x2c>
    2b20:	687a      	ldr	r2, [r7, #4]
    2b22:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    2b26:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2b2a:	429a      	cmp	r2, r3
    2b2c:	d000      	beq.n	2b30 <MSS_UART_get_tx_status+0x2c>
    2b2e:	be00      	bkpt	0x0000

    if( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) )
    2b30:	687a      	ldr	r2, [r7, #4]
    2b32:	f64a 13e4 	movw	r3, #43492	; 0xa9e4
    2b36:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2b3a:	429a      	cmp	r2, r3
    2b3c:	d006      	beq.n	2b4c <MSS_UART_get_tx_status+0x48>
    2b3e:	687a      	ldr	r2, [r7, #4]
    2b40:	f64a 13bc 	movw	r3, #43452	; 0xa9bc
    2b44:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2b48:	429a      	cmp	r2, r3
    2b4a:	d10f      	bne.n	2b6c <MSS_UART_get_tx_status+0x68>
    {
        /* Read the Line Status Register and update the sticky record. */
        status = this_uart->hw_reg->LSR;
    2b4c:	687b      	ldr	r3, [r7, #4]
    2b4e:	681b      	ldr	r3, [r3, #0]
    2b50:	7d1b      	ldrb	r3, [r3, #20]
    2b52:	73fb      	strb	r3, [r7, #15]
        this_uart->status |= status;
    2b54:	687b      	ldr	r3, [r7, #4]
    2b56:	7a9a      	ldrb	r2, [r3, #10]
    2b58:	7bfb      	ldrb	r3, [r7, #15]
    2b5a:	ea42 0303 	orr.w	r3, r2, r3
    2b5e:	b2da      	uxtb	r2, r3
    2b60:	687b      	ldr	r3, [r7, #4]
    2b62:	729a      	strb	r2, [r3, #10]
        /*
         * Extract the transmit status bits from the UART's Line Status Register.
         * Bit 5 - Transmitter Holding Register/FIFO Empty (THRE) status. (If = 1, TX FIFO is empty)
         * Bit 6 - Transmitter Empty (TEMT) status. (If = 1, both TX FIFO and shift register are empty)
         */
        status &= ( MSS_UART_THRE | MSS_UART_TEMT );
    2b64:	7bfb      	ldrb	r3, [r7, #15]
    2b66:	f003 0360 	and.w	r3, r3, #96	; 0x60
    2b6a:	73fb      	strb	r3, [r7, #15]
    }
    return status;
    2b6c:	7bfb      	ldrb	r3, [r7, #15]
}
    2b6e:	4618      	mov	r0, r3
    2b70:	f107 0714 	add.w	r7, r7, #20
    2b74:	46bd      	mov	sp, r7
    2b76:	bc80      	pop	{r7}
    2b78:	4770      	bx	lr
    2b7a:	bf00      	nop

00002b7c <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
    2b7c:	b480      	push	{r7}
    2b7e:	b083      	sub	sp, #12
    2b80:	af00      	add	r7, sp, #0
    2b82:	4603      	mov	r3, r0
    2b84:	80fb      	strh	r3, [r7, #6]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    2b86:	f24e 1300 	movw	r3, #57600	; 0xe100
    2b8a:	f2ce 0300 	movt	r3, #57344	; 0xe000
    2b8e:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    2b92:	ea4f 1252 	mov.w	r2, r2, lsr #5
    2b96:	88f9      	ldrh	r1, [r7, #6]
    2b98:	f001 011f 	and.w	r1, r1, #31
    2b9c:	f04f 0001 	mov.w	r0, #1
    2ba0:	fa00 f101 	lsl.w	r1, r0, r1
    2ba4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    2ba8:	f107 070c 	add.w	r7, r7, #12
    2bac:	46bd      	mov	sp, r7
    2bae:	bc80      	pop	{r7}
    2bb0:	4770      	bx	lr
    2bb2:	bf00      	nop

00002bb4 <NVIC_DisableIRQ>:
 * 
 * Disable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
    2bb4:	b480      	push	{r7}
    2bb6:	b083      	sub	sp, #12
    2bb8:	af00      	add	r7, sp, #0
    2bba:	4603      	mov	r3, r0
    2bbc:	80fb      	strh	r3, [r7, #6]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
    2bbe:	f24e 1300 	movw	r3, #57600	; 0xe100
    2bc2:	f2ce 0300 	movt	r3, #57344	; 0xe000
    2bc6:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    2bca:	ea4f 1252 	mov.w	r2, r2, lsr #5
    2bce:	88f9      	ldrh	r1, [r7, #6]
    2bd0:	f001 011f 	and.w	r1, r1, #31
    2bd4:	f04f 0001 	mov.w	r0, #1
    2bd8:	fa00 f101 	lsl.w	r1, r0, r1
    2bdc:	f102 0220 	add.w	r2, r2, #32
    2be0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    2be4:	f107 070c 	add.w	r7, r7, #12
    2be8:	46bd      	mov	sp, r7
    2bea:	bc80      	pop	{r7}
    2bec:	4770      	bx	lr
    2bee:	bf00      	nop

00002bf0 <NVIC_ClearPendingIRQ>:
 *
 * Clear the pending bit for the specified interrupt. 
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
    2bf0:	b480      	push	{r7}
    2bf2:	b083      	sub	sp, #12
    2bf4:	af00      	add	r7, sp, #0
    2bf6:	4603      	mov	r3, r0
    2bf8:	80fb      	strh	r3, [r7, #6]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    2bfa:	f24e 1300 	movw	r3, #57600	; 0xe100
    2bfe:	f2ce 0300 	movt	r3, #57344	; 0xe000
    2c02:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    2c06:	ea4f 1252 	mov.w	r2, r2, lsr #5
    2c0a:	88f9      	ldrh	r1, [r7, #6]
    2c0c:	f001 011f 	and.w	r1, r1, #31
    2c10:	f04f 0001 	mov.w	r0, #1
    2c14:	fa00 f101 	lsl.w	r1, r0, r1
    2c18:	f102 0260 	add.w	r2, r2, #96	; 0x60
    2c1c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    2c20:	f107 070c 	add.w	r7, r7, #12
    2c24:	46bd      	mov	sp, r7
    2c26:	bc80      	pop	{r7}
    2c28:	4770      	bx	lr
    2c2a:	bf00      	nop

00002c2c <MSS_I2C_init>:
(
    mss_i2c_instance_t * this_i2c,
    uint8_t ser_address,
    mss_i2c_clock_divider_t ser_clock_speed
)
{
    2c2c:	b580      	push	{r7, lr}
    2c2e:	b084      	sub	sp, #16
    2c30:	af00      	add	r7, sp, #0
    2c32:	6078      	str	r0, [r7, #4]
    2c34:	4613      	mov	r3, r2
    2c36:	460a      	mov	r2, r1
    2c38:	70fa      	strb	r2, [r7, #3]
    2c3a:	70bb      	strb	r3, [r7, #2]
    uint32_t primask;
    uint_fast16_t clock_speed = (uint_fast16_t)ser_clock_speed;
    2c3c:	78bb      	ldrb	r3, [r7, #2]
    2c3e:	60fb      	str	r3, [r7, #12]
    
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    2c40:	687a      	ldr	r2, [r7, #4]
    2c42:	f64a 230c 	movw	r3, #43532	; 0xaa0c
    2c46:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2c4a:	429a      	cmp	r2, r3
    2c4c:	d007      	beq.n	2c5e <MSS_I2C_init+0x32>
    2c4e:	687a      	ldr	r2, [r7, #4]
    2c50:	f64a 2380 	movw	r3, #43648	; 0xaa80
    2c54:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2c58:	429a      	cmp	r2, r3
    2c5a:	d000      	beq.n	2c5e <MSS_I2C_init+0x32>
    2c5c:	be00      	bkpt	0x0000
     * Initialize all items of the this_i2c data structure to zero. This
     * initializes all state variables to their init value. It relies on
     * the fact that NO_TRANSACTION, I2C_SUCCESS and I2C_RELEASE_BUS all
     * have an actual value of zero.
     */
    primask = disable_interrupts();
    2c5e:	f001 f98f 	bl	3f80 <disable_interrupts>
    2c62:	4603      	mov	r3, r0
    2c64:	60bb      	str	r3, [r7, #8]
    memset(this_i2c, 0, sizeof(mss_i2c_instance_t));
    2c66:	6878      	ldr	r0, [r7, #4]
    2c68:	f04f 0100 	mov.w	r1, #0
    2c6c:	f04f 0274 	mov.w	r2, #116	; 0x74
    2c70:	f012 f960 	bl	14f34 <memset>
    
    if ( this_i2c == &g_mss_i2c0 )
    2c74:	687a      	ldr	r2, [r7, #4]
    2c76:	f64a 230c 	movw	r3, #43532	; 0xaa0c
    2c7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2c7e:	429a      	cmp	r2, r3
    2c80:	d12c      	bne.n	2cdc <MSS_I2C_init+0xb0>
    {
        this_i2c->irqn = I2C0_IRQn;
    2c82:	687b      	ldr	r3, [r7, #4]
    2c84:	f04f 020e 	mov.w	r2, #14
    2c88:	825a      	strh	r2, [r3, #18]
        this_i2c->hw_reg = I2C0;
    2c8a:	687a      	ldr	r2, [r7, #4]
    2c8c:	f242 0300 	movw	r3, #8192	; 0x2000
    2c90:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2c94:	6153      	str	r3, [r2, #20]
        this_i2c->hw_reg_bit = I2C0_BITBAND;
    2c96:	687a      	ldr	r2, [r7, #4]
    2c98:	f240 0300 	movw	r3, #0
    2c9c:	f2c4 2304 	movt	r3, #16900	; 0x4204
    2ca0:	6193      	str	r3, [r2, #24]
        
        /* reset I2C0 */
        SYSREG->SOFT_RST_CR |= SYSREG_I2C0_SOFTRESET_MASK;
    2ca2:	f242 0300 	movw	r3, #8192	; 0x2000
    2ca6:	f2ce 0304 	movt	r3, #57348	; 0xe004
    2caa:	f242 0200 	movw	r2, #8192	; 0x2000
    2cae:	f2ce 0204 	movt	r2, #57348	; 0xe004
    2cb2:	6b12      	ldr	r2, [r2, #48]	; 0x30
    2cb4:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
    2cb8:	631a      	str	r2, [r3, #48]	; 0x30
        /* Clear any previously pended I2C0 interrupt */
        NVIC_ClearPendingIRQ( I2C0_IRQn );
    2cba:	f04f 000e 	mov.w	r0, #14
    2cbe:	f7ff ff97 	bl	2bf0 <NVIC_ClearPendingIRQ>
        /* Take I2C0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_I2C0_SOFTRESET_MASK;
    2cc2:	f242 0300 	movw	r3, #8192	; 0x2000
    2cc6:	f2ce 0304 	movt	r3, #57348	; 0xe004
    2cca:	f242 0200 	movw	r2, #8192	; 0x2000
    2cce:	f2ce 0204 	movt	r2, #57348	; 0xe004
    2cd2:	6b12      	ldr	r2, [r2, #48]	; 0x30
    2cd4:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
    2cd8:	631a      	str	r2, [r3, #48]	; 0x30
    2cda:	e02b      	b.n	2d34 <MSS_I2C_init+0x108>
    }
    else
    {
        this_i2c->irqn = I2C1_IRQn;
    2cdc:	687b      	ldr	r3, [r7, #4]
    2cde:	f04f 0211 	mov.w	r2, #17
    2ce2:	825a      	strh	r2, [r3, #18]
        this_i2c->hw_reg = I2C1;
    2ce4:	687a      	ldr	r2, [r7, #4]
    2ce6:	f242 0300 	movw	r3, #8192	; 0x2000
    2cea:	f2c4 0301 	movt	r3, #16385	; 0x4001
    2cee:	6153      	str	r3, [r2, #20]
        this_i2c->hw_reg_bit = I2C1_BITBAND;
    2cf0:	687a      	ldr	r2, [r7, #4]
    2cf2:	f240 0300 	movw	r3, #0
    2cf6:	f2c4 2324 	movt	r3, #16932	; 0x4224
    2cfa:	6193      	str	r3, [r2, #24]
        
        /* reset I2C1 */
        SYSREG->SOFT_RST_CR |= SYSREG_I2C1_SOFTRESET_MASK;
    2cfc:	f242 0300 	movw	r3, #8192	; 0x2000
    2d00:	f2ce 0304 	movt	r3, #57348	; 0xe004
    2d04:	f242 0200 	movw	r2, #8192	; 0x2000
    2d08:	f2ce 0204 	movt	r2, #57348	; 0xe004
    2d0c:	6b12      	ldr	r2, [r2, #48]	; 0x30
    2d0e:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
    2d12:	631a      	str	r2, [r3, #48]	; 0x30
        /* Clear any previously pended I2C1 interrupt */
        NVIC_ClearPendingIRQ( I2C1_IRQn );
    2d14:	f04f 0011 	mov.w	r0, #17
    2d18:	f7ff ff6a 	bl	2bf0 <NVIC_ClearPendingIRQ>
        /* Take I2C1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_I2C1_SOFTRESET_MASK;
    2d1c:	f242 0300 	movw	r3, #8192	; 0x2000
    2d20:	f2ce 0304 	movt	r3, #57348	; 0xe004
    2d24:	f242 0200 	movw	r2, #8192	; 0x2000
    2d28:	f2ce 0204 	movt	r2, #57348	; 0xe004
    2d2c:	6b12      	ldr	r2, [r2, #48]	; 0x30
    2d2e:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
    2d32:	631a      	str	r2, [r3, #48]	; 0x30
    }
    
    /* Use same base address for SMBus bitband access */
    this_i2c->hw_smb_reg_bit = (I2C_SMBus_BitBand_TypeDef *)this_i2c->hw_reg_bit;
    2d34:	687b      	ldr	r3, [r7, #4]
    2d36:	699b      	ldr	r3, [r3, #24]
    2d38:	461a      	mov	r2, r3
    2d3a:	687b      	ldr	r3, [r7, #4]
    2d3c:	61da      	str	r2, [r3, #28]

    /* Update Serial address of the device */
    this_i2c->ser_address = (uint_fast8_t)ser_address << 1u;
    2d3e:	78fb      	ldrb	r3, [r7, #3]
    2d40:	ea4f 0243 	mov.w	r2, r3, lsl #1
    2d44:	687b      	ldr	r3, [r7, #4]
    2d46:	601a      	str	r2, [r3, #0]

    this_i2c->hw_reg_bit->CTRL_CR2 = (uint32_t)((clock_speed >> 2u) & 0x01u);
    2d48:	687b      	ldr	r3, [r7, #4]
    2d4a:	699b      	ldr	r3, [r3, #24]
    2d4c:	68fa      	ldr	r2, [r7, #12]
    2d4e:	ea4f 0292 	mov.w	r2, r2, lsr #2
    2d52:	f002 0201 	and.w	r2, r2, #1
    2d56:	61da      	str	r2, [r3, #28]
    this_i2c->hw_reg_bit->CTRL_CR1 = (uint32_t)((clock_speed >> 1u) & 0x01u);
    2d58:	687b      	ldr	r3, [r7, #4]
    2d5a:	699b      	ldr	r3, [r3, #24]
    2d5c:	68fa      	ldr	r2, [r7, #12]
    2d5e:	ea4f 0252 	mov.w	r2, r2, lsr #1
    2d62:	f002 0201 	and.w	r2, r2, #1
    2d66:	605a      	str	r2, [r3, #4]
    this_i2c->hw_reg_bit->CTRL_CR0 = (uint32_t)(clock_speed & 0x01u);
    2d68:	687b      	ldr	r3, [r7, #4]
    2d6a:	699b      	ldr	r3, [r3, #24]
    2d6c:	68fa      	ldr	r2, [r7, #12]
    2d6e:	f002 0201 	and.w	r2, r2, #1
    2d72:	601a      	str	r2, [r3, #0]
    this_i2c->hw_reg->ADDR = (uint8_t)this_i2c->ser_address;
    2d74:	687b      	ldr	r3, [r7, #4]
    2d76:	695b      	ldr	r3, [r3, #20]
    2d78:	687a      	ldr	r2, [r7, #4]
    2d7a:	6812      	ldr	r2, [r2, #0]
    2d7c:	b2d2      	uxtb	r2, r2
    2d7e:	731a      	strb	r2, [r3, #12]
    this_i2c->hw_reg_bit->CTRL_ENS1 = 0x01u; /* set enable bit */
    2d80:	687b      	ldr	r3, [r7, #4]
    2d82:	699b      	ldr	r3, [r3, #24]
    2d84:	f04f 0201 	mov.w	r2, #1
    2d88:	619a      	str	r2, [r3, #24]
    restore_interrupts( primask );
    2d8a:	68b8      	ldr	r0, [r7, #8]
    2d8c:	f001 f90a 	bl	3fa4 <restore_interrupts>
}
    2d90:	f107 0710 	add.w	r7, r7, #16
    2d94:	46bd      	mov	sp, r7
    2d96:	bd80      	pop	{r7, pc}

00002d98 <MSS_I2C_write>:
    uint8_t serial_addr,
    const uint8_t * write_buffer,
    uint16_t write_size,
    uint8_t options
)
{
    2d98:	b580      	push	{r7, lr}
    2d9a:	b086      	sub	sp, #24
    2d9c:	af00      	add	r7, sp, #0
    2d9e:	60f8      	str	r0, [r7, #12]
    2da0:	607a      	str	r2, [r7, #4]
    2da2:	460a      	mov	r2, r1
    2da4:	72fa      	strb	r2, [r7, #11]
    2da6:	807b      	strh	r3, [r7, #2]
    uint32_t primask;
    volatile uint8_t stat_ctrl;

    ASSERT((this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1));
    2da8:	68fa      	ldr	r2, [r7, #12]
    2daa:	f64a 230c 	movw	r3, #43532	; 0xaa0c
    2dae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2db2:	429a      	cmp	r2, r3
    2db4:	d007      	beq.n	2dc6 <MSS_I2C_write+0x2e>
    2db6:	68fa      	ldr	r2, [r7, #12]
    2db8:	f64a 2380 	movw	r3, #43648	; 0xaa80
    2dbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2dc0:	429a      	cmp	r2, r3
    2dc2:	d000      	beq.n	2dc6 <MSS_I2C_write+0x2e>
    2dc4:	be00      	bkpt	0x0000

    primask = disable_interrupts();
    2dc6:	f001 f8db 	bl	3f80 <disable_interrupts>
    2dca:	4603      	mov	r3, r0
    2dcc:	617b      	str	r3, [r7, #20]

    /* Update the transaction only when there is no transaction going on I2C */
    if( this_i2c->transaction == NO_TRANSACTION)
    2dce:	68fb      	ldr	r3, [r7, #12]
    2dd0:	7a1b      	ldrb	r3, [r3, #8]
    2dd2:	2b00      	cmp	r3, #0
    2dd4:	d103      	bne.n	2dde <MSS_I2C_write+0x46>
    {
      this_i2c->transaction = MASTER_WRITE_TRANSACTION;
    2dd6:	68fb      	ldr	r3, [r7, #12]
    2dd8:	f04f 0201 	mov.w	r2, #1
    2ddc:	721a      	strb	r2, [r3, #8]
    }

    /* Update the Pending transaction information so that transaction can restarted */
    this_i2c->pending_transaction = MASTER_WRITE_TRANSACTION ;
    2dde:	68fb      	ldr	r3, [r7, #12]
    2de0:	f04f 0201 	mov.w	r2, #1
    2de4:	f883 2072 	strb.w	r2, [r3, #114]	; 0x72

    /* Update target address */
    this_i2c->target_addr = (uint_fast8_t)serial_addr << 1u;
    2de8:	7afb      	ldrb	r3, [r7, #11]
    2dea:	ea4f 0243 	mov.w	r2, r3, lsl #1
    2dee:	68fb      	ldr	r3, [r7, #12]
    2df0:	605a      	str	r2, [r3, #4]

    this_i2c->dir = WRITE_DIR;
    2df2:	68fb      	ldr	r3, [r7, #12]
    2df4:	f04f 0200 	mov.w	r2, #0
    2df8:	62da      	str	r2, [r3, #44]	; 0x2c

    this_i2c->master_tx_buffer = write_buffer;
    2dfa:	68fb      	ldr	r3, [r7, #12]
    2dfc:	687a      	ldr	r2, [r7, #4]
    2dfe:	621a      	str	r2, [r3, #32]
    this_i2c->master_tx_size = write_size;
    2e00:	887a      	ldrh	r2, [r7, #2]
    2e02:	68fb      	ldr	r3, [r7, #12]
    2e04:	625a      	str	r2, [r3, #36]	; 0x24
    this_i2c->master_tx_idx = 0u;
    2e06:	68fb      	ldr	r3, [r7, #12]
    2e08:	f04f 0200 	mov.w	r2, #0
    2e0c:	629a      	str	r2, [r3, #40]	; 0x28

    /* Set I2C status in progress */
    this_i2c->master_status = MSS_I2C_IN_PROGRESS;
    2e0e:	68fb      	ldr	r3, [r7, #12]
    2e10:	f04f 0201 	mov.w	r2, #1
    2e14:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    this_i2c->options = options;
    2e18:	68fb      	ldr	r3, [r7, #12]
    2e1a:	f897 2020 	ldrb.w	r2, [r7, #32]
    2e1e:	741a      	strb	r2, [r3, #16]

    if(MSS_I2C_IN_PROGRESS == this_i2c->slave_status)
    2e20:	68fb      	ldr	r3, [r7, #12]
    2e22:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    2e26:	b2db      	uxtb	r3, r3
    2e28:	2b01      	cmp	r3, #1
    2e2a:	d105      	bne.n	2e38 <MSS_I2C_write+0xa0>
    {
        this_i2c->is_transaction_pending = 1u;
    2e2c:	68fb      	ldr	r3, [r7, #12]
    2e2e:	f04f 0201 	mov.w	r2, #1
    2e32:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
    2e36:	e004      	b.n	2e42 <MSS_I2C_write+0xaa>
    }
    else
    {
        this_i2c->hw_reg_bit->CTRL_STA = 0x01u;
    2e38:	68fb      	ldr	r3, [r7, #12]
    2e3a:	699b      	ldr	r3, [r3, #24]
    2e3c:	f04f 0201 	mov.w	r2, #1
    2e40:	615a      	str	r2, [r3, #20]
    /*
     * Clear interrupts if required (depends on repeated starts).
     * Since the Bus is on hold, only then prior status needs to
     * be cleared.
     */
    if ( MSS_I2C_HOLD_BUS == this_i2c->bus_status )
    2e42:	68fb      	ldr	r3, [r7, #12]
    2e44:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
    2e48:	2b01      	cmp	r3, #1
    2e4a:	d111      	bne.n	2e70 <MSS_I2C_write+0xd8>
    {
        this_i2c->hw_reg_bit->CTRL_SI = 0u;
    2e4c:	68fb      	ldr	r3, [r7, #12]
    2e4e:	699b      	ldr	r3, [r3, #24]
    2e50:	f04f 0200 	mov.w	r2, #0
    2e54:	60da      	str	r2, [r3, #12]
        stat_ctrl = this_i2c->hw_reg->STATUS;
    2e56:	68fb      	ldr	r3, [r7, #12]
    2e58:	695b      	ldr	r3, [r3, #20]
    2e5a:	791b      	ldrb	r3, [r3, #4]
    2e5c:	74fb      	strb	r3, [r7, #19]
        stat_ctrl = stat_ctrl;  /* Avoids Lint warning */
    2e5e:	7cfb      	ldrb	r3, [r7, #19]
    2e60:	b2db      	uxtb	r3, r3
    2e62:	74fb      	strb	r3, [r7, #19]
        NVIC_ClearPendingIRQ( this_i2c->irqn );
    2e64:	68fb      	ldr	r3, [r7, #12]
    2e66:	8a5b      	ldrh	r3, [r3, #18]
    2e68:	b21b      	sxth	r3, r3
    2e6a:	4618      	mov	r0, r3
    2e6c:	f7ff fec0 	bl	2bf0 <NVIC_ClearPendingIRQ>
    }

    /* Enable the interrupt. ( Re-enable) */
    NVIC_EnableIRQ( this_i2c->irqn );
    2e70:	68fb      	ldr	r3, [r7, #12]
    2e72:	8a5b      	ldrh	r3, [r3, #18]
    2e74:	b21b      	sxth	r3, r3
    2e76:	4618      	mov	r0, r3
    2e78:	f7ff fe80 	bl	2b7c <NVIC_EnableIRQ>

    restore_interrupts( primask );
    2e7c:	6978      	ldr	r0, [r7, #20]
    2e7e:	f001 f891 	bl	3fa4 <restore_interrupts>
}
    2e82:	f107 0718 	add.w	r7, r7, #24
    2e86:	46bd      	mov	sp, r7
    2e88:	bd80      	pop	{r7, pc}
    2e8a:	bf00      	nop

00002e8c <MSS_I2C_read>:
    uint8_t serial_addr,
    uint8_t * read_buffer,
    uint16_t read_size,
    uint8_t options
)
{
    2e8c:	b580      	push	{r7, lr}
    2e8e:	b086      	sub	sp, #24
    2e90:	af00      	add	r7, sp, #0
    2e92:	60f8      	str	r0, [r7, #12]
    2e94:	607a      	str	r2, [r7, #4]
    2e96:	460a      	mov	r2, r1
    2e98:	72fa      	strb	r2, [r7, #11]
    2e9a:	807b      	strh	r3, [r7, #2]
    uint32_t primask;
    volatile uint8_t stat_ctrl;

    ASSERT((this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1));
    2e9c:	68fa      	ldr	r2, [r7, #12]
    2e9e:	f64a 230c 	movw	r3, #43532	; 0xaa0c
    2ea2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2ea6:	429a      	cmp	r2, r3
    2ea8:	d007      	beq.n	2eba <MSS_I2C_read+0x2e>
    2eaa:	68fa      	ldr	r2, [r7, #12]
    2eac:	f64a 2380 	movw	r3, #43648	; 0xaa80
    2eb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2eb4:	429a      	cmp	r2, r3
    2eb6:	d000      	beq.n	2eba <MSS_I2C_read+0x2e>
    2eb8:	be00      	bkpt	0x0000

    primask = disable_interrupts();
    2eba:	f001 f861 	bl	3f80 <disable_interrupts>
    2ebe:	4603      	mov	r3, r0
    2ec0:	617b      	str	r3, [r7, #20]
    
    /* Update the transaction only when there is no transaction going on I2C */
    if( this_i2c->transaction == NO_TRANSACTION)
    2ec2:	68fb      	ldr	r3, [r7, #12]
    2ec4:	7a1b      	ldrb	r3, [r3, #8]
    2ec6:	2b00      	cmp	r3, #0
    2ec8:	d103      	bne.n	2ed2 <MSS_I2C_read+0x46>
    {
      this_i2c->transaction = MASTER_READ_TRANSACTION;
    2eca:	68fb      	ldr	r3, [r7, #12]
    2ecc:	f04f 0202 	mov.w	r2, #2
    2ed0:	721a      	strb	r2, [r3, #8]
    }

    /* Update the Pending transaction information so that transaction can restarted */
    this_i2c->pending_transaction = MASTER_READ_TRANSACTION ;
    2ed2:	68fb      	ldr	r3, [r7, #12]
    2ed4:	f04f 0202 	mov.w	r2, #2
    2ed8:	f883 2072 	strb.w	r2, [r3, #114]	; 0x72

    /* Update target address */
    this_i2c->target_addr = (uint_fast8_t)serial_addr << 1u;
    2edc:	7afb      	ldrb	r3, [r7, #11]
    2ede:	ea4f 0243 	mov.w	r2, r3, lsl #1
    2ee2:	68fb      	ldr	r3, [r7, #12]
    2ee4:	605a      	str	r2, [r3, #4]

    this_i2c->dir = READ_DIR;
    2ee6:	68fb      	ldr	r3, [r7, #12]
    2ee8:	f04f 0201 	mov.w	r2, #1
    2eec:	62da      	str	r2, [r3, #44]	; 0x2c

    this_i2c->master_rx_buffer = read_buffer;
    2eee:	68fb      	ldr	r3, [r7, #12]
    2ef0:	687a      	ldr	r2, [r7, #4]
    2ef2:	631a      	str	r2, [r3, #48]	; 0x30
    this_i2c->master_rx_size = read_size;
    2ef4:	887a      	ldrh	r2, [r7, #2]
    2ef6:	68fb      	ldr	r3, [r7, #12]
    2ef8:	635a      	str	r2, [r3, #52]	; 0x34
    this_i2c->master_rx_idx = 0u;
    2efa:	68fb      	ldr	r3, [r7, #12]
    2efc:	f04f 0200 	mov.w	r2, #0
    2f00:	639a      	str	r2, [r3, #56]	; 0x38
    
    /* Set I2C status in progress */
    this_i2c->master_status = MSS_I2C_IN_PROGRESS;
    2f02:	68fb      	ldr	r3, [r7, #12]
    2f04:	f04f 0201 	mov.w	r2, #1
    2f08:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    this_i2c->options = options;
    2f0c:	68fb      	ldr	r3, [r7, #12]
    2f0e:	f897 2020 	ldrb.w	r2, [r7, #32]
    2f12:	741a      	strb	r2, [r3, #16]

    if(MSS_I2C_IN_PROGRESS == this_i2c->slave_status)
    2f14:	68fb      	ldr	r3, [r7, #12]
    2f16:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    2f1a:	b2db      	uxtb	r3, r3
    2f1c:	2b01      	cmp	r3, #1
    2f1e:	d105      	bne.n	2f2c <MSS_I2C_read+0xa0>
    {
        this_i2c->is_transaction_pending = 1u;
    2f20:	68fb      	ldr	r3, [r7, #12]
    2f22:	f04f 0201 	mov.w	r2, #1
    2f26:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
    2f2a:	e004      	b.n	2f36 <MSS_I2C_read+0xaa>
    }
    else
    {
        this_i2c->hw_reg_bit->CTRL_STA = 0x01u;
    2f2c:	68fb      	ldr	r3, [r7, #12]
    2f2e:	699b      	ldr	r3, [r3, #24]
    2f30:	f04f 0201 	mov.w	r2, #1
    2f34:	615a      	str	r2, [r3, #20]
    /*
     * Clear interrupts if required (depends on repeated starts).
     * Since the Bus is on hold, only then prior status needs to
     * be cleared.
     */
    if ( MSS_I2C_HOLD_BUS == this_i2c->bus_status )
    2f36:	68fb      	ldr	r3, [r7, #12]
    2f38:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
    2f3c:	2b01      	cmp	r3, #1
    2f3e:	d111      	bne.n	2f64 <MSS_I2C_read+0xd8>
    {
        this_i2c->hw_reg_bit->CTRL_SI = 0u;
    2f40:	68fb      	ldr	r3, [r7, #12]
    2f42:	699b      	ldr	r3, [r3, #24]
    2f44:	f04f 0200 	mov.w	r2, #0
    2f48:	60da      	str	r2, [r3, #12]
        stat_ctrl = this_i2c->hw_reg->STATUS;
    2f4a:	68fb      	ldr	r3, [r7, #12]
    2f4c:	695b      	ldr	r3, [r3, #20]
    2f4e:	791b      	ldrb	r3, [r3, #4]
    2f50:	74fb      	strb	r3, [r7, #19]
        stat_ctrl = stat_ctrl;  /* Avoids Lint warning */
    2f52:	7cfb      	ldrb	r3, [r7, #19]
    2f54:	b2db      	uxtb	r3, r3
    2f56:	74fb      	strb	r3, [r7, #19]
        NVIC_ClearPendingIRQ( this_i2c->irqn );
    2f58:	68fb      	ldr	r3, [r7, #12]
    2f5a:	8a5b      	ldrh	r3, [r3, #18]
    2f5c:	b21b      	sxth	r3, r3
    2f5e:	4618      	mov	r0, r3
    2f60:	f7ff fe46 	bl	2bf0 <NVIC_ClearPendingIRQ>
    }
    
    /* Enable the interrupt. ( Re-enable) */
    NVIC_EnableIRQ( this_i2c->irqn );
    2f64:	68fb      	ldr	r3, [r7, #12]
    2f66:	8a5b      	ldrh	r3, [r3, #18]
    2f68:	b21b      	sxth	r3, r3
    2f6a:	4618      	mov	r0, r3
    2f6c:	f7ff fe06 	bl	2b7c <NVIC_EnableIRQ>
    restore_interrupts( primask );
    2f70:	6978      	ldr	r0, [r7, #20]
    2f72:	f001 f817 	bl	3fa4 <restore_interrupts>
}
    2f76:	f107 0718 	add.w	r7, r7, #24
    2f7a:	46bd      	mov	sp, r7
    2f7c:	bd80      	pop	{r7, pc}
    2f7e:	bf00      	nop

00002f80 <MSS_I2C_write_read>:
    uint16_t offset_size,
    uint8_t * read_buffer,
    uint16_t read_size,
    uint8_t options
)
{
    2f80:	b580      	push	{r7, lr}
    2f82:	b086      	sub	sp, #24
    2f84:	af00      	add	r7, sp, #0
    2f86:	60f8      	str	r0, [r7, #12]
    2f88:	607a      	str	r2, [r7, #4]
    2f8a:	460a      	mov	r2, r1
    2f8c:	72fa      	strb	r2, [r7, #11]
    2f8e:	807b      	strh	r3, [r7, #2]
    ASSERT((this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1));
    2f90:	68fa      	ldr	r2, [r7, #12]
    2f92:	f64a 230c 	movw	r3, #43532	; 0xaa0c
    2f96:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2f9a:	429a      	cmp	r2, r3
    2f9c:	d007      	beq.n	2fae <MSS_I2C_write_read+0x2e>
    2f9e:	68fa      	ldr	r2, [r7, #12]
    2fa0:	f64a 2380 	movw	r3, #43648	; 0xaa80
    2fa4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2fa8:	429a      	cmp	r2, r3
    2faa:	d000      	beq.n	2fae <MSS_I2C_write_read+0x2e>
    2fac:	be00      	bkpt	0x0000
    ASSERT(offset_size > 0u);
    2fae:	887b      	ldrh	r3, [r7, #2]
    2fb0:	2b00      	cmp	r3, #0
    2fb2:	d100      	bne.n	2fb6 <MSS_I2C_write_read+0x36>
    2fb4:	be00      	bkpt	0x0000
    ASSERT(addr_offset != (const uint8_t *)0);
    2fb6:	687b      	ldr	r3, [r7, #4]
    2fb8:	2b00      	cmp	r3, #0
    2fba:	d100      	bne.n	2fbe <MSS_I2C_write_read+0x3e>
    2fbc:	be00      	bkpt	0x0000
    ASSERT(read_size > 0u);
    2fbe:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
    2fc0:	2b00      	cmp	r3, #0
    2fc2:	d100      	bne.n	2fc6 <MSS_I2C_write_read+0x46>
    2fc4:	be00      	bkpt	0x0000
    ASSERT(read_buffer != (uint8_t *)0);
    2fc6:	6a3b      	ldr	r3, [r7, #32]
    2fc8:	2b00      	cmp	r3, #0
    2fca:	d100      	bne.n	2fce <MSS_I2C_write_read+0x4e>
    2fcc:	be00      	bkpt	0x0000

    if((read_size > 0u) && (offset_size > 0u))
    2fce:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
    2fd0:	2b00      	cmp	r3, #0
    2fd2:	d06a      	beq.n	30aa <MSS_I2C_write_read+0x12a>
    2fd4:	887b      	ldrh	r3, [r7, #2]
    2fd6:	2b00      	cmp	r3, #0
    2fd8:	d067      	beq.n	30aa <MSS_I2C_write_read+0x12a>
    {
        uint32_t primask;
        volatile uint8_t stat_ctrl;

        primask = disable_interrupts();
    2fda:	f000 ffd1 	bl	3f80 <disable_interrupts>
    2fde:	4603      	mov	r3, r0
    2fe0:	617b      	str	r3, [r7, #20]

        /* Update the transaction only when there is no transaction going on I2C */
        if( this_i2c->transaction == NO_TRANSACTION)
    2fe2:	68fb      	ldr	r3, [r7, #12]
    2fe4:	7a1b      	ldrb	r3, [r3, #8]
    2fe6:	2b00      	cmp	r3, #0
    2fe8:	d103      	bne.n	2ff2 <MSS_I2C_write_read+0x72>
        {
            this_i2c->transaction = MASTER_RANDOM_READ_TRANSACTION;
    2fea:	68fb      	ldr	r3, [r7, #12]
    2fec:	f04f 0203 	mov.w	r2, #3
    2ff0:	721a      	strb	r2, [r3, #8]
        }

        /* Update the Pending transaction information so that transaction can restarted */
        this_i2c->pending_transaction = MASTER_RANDOM_READ_TRANSACTION ;
    2ff2:	68fb      	ldr	r3, [r7, #12]
    2ff4:	f04f 0203 	mov.w	r2, #3
    2ff8:	f883 2072 	strb.w	r2, [r3, #114]	; 0x72

        /* Update target address */
        this_i2c->target_addr = (uint_fast8_t)serial_addr << 1u;
    2ffc:	7afb      	ldrb	r3, [r7, #11]
    2ffe:	ea4f 0243 	mov.w	r2, r3, lsl #1
    3002:	68fb      	ldr	r3, [r7, #12]
    3004:	605a      	str	r2, [r3, #4]

        this_i2c->dir = WRITE_DIR;
    3006:	68fb      	ldr	r3, [r7, #12]
    3008:	f04f 0200 	mov.w	r2, #0
    300c:	62da      	str	r2, [r3, #44]	; 0x2c
        this_i2c->master_tx_buffer = addr_offset;
    300e:	68fb      	ldr	r3, [r7, #12]
    3010:	687a      	ldr	r2, [r7, #4]
    3012:	621a      	str	r2, [r3, #32]
        this_i2c->master_tx_size = offset_size;
    3014:	887a      	ldrh	r2, [r7, #2]
    3016:	68fb      	ldr	r3, [r7, #12]
    3018:	625a      	str	r2, [r3, #36]	; 0x24
        this_i2c->master_tx_idx = 0u;
    301a:	68fb      	ldr	r3, [r7, #12]
    301c:	f04f 0200 	mov.w	r2, #0
    3020:	629a      	str	r2, [r3, #40]	; 0x28

        this_i2c->master_rx_buffer = read_buffer;
    3022:	68fb      	ldr	r3, [r7, #12]
    3024:	6a3a      	ldr	r2, [r7, #32]
    3026:	631a      	str	r2, [r3, #48]	; 0x30
        this_i2c->master_rx_size = read_size;
    3028:	8cba      	ldrh	r2, [r7, #36]	; 0x24
    302a:	68fb      	ldr	r3, [r7, #12]
    302c:	635a      	str	r2, [r3, #52]	; 0x34
        this_i2c->master_rx_idx = 0u;
    302e:	68fb      	ldr	r3, [r7, #12]
    3030:	f04f 0200 	mov.w	r2, #0
    3034:	639a      	str	r2, [r3, #56]	; 0x38

        /* Set I2C status in progress */
        this_i2c->master_status = MSS_I2C_IN_PROGRESS;
    3036:	68fb      	ldr	r3, [r7, #12]
    3038:	f04f 0201 	mov.w	r2, #1
    303c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
        this_i2c->options = options;
    3040:	68fb      	ldr	r3, [r7, #12]
    3042:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
    3046:	741a      	strb	r2, [r3, #16]

        if(MSS_I2C_IN_PROGRESS == this_i2c->slave_status)
    3048:	68fb      	ldr	r3, [r7, #12]
    304a:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    304e:	b2db      	uxtb	r3, r3
    3050:	2b01      	cmp	r3, #1
    3052:	d105      	bne.n	3060 <MSS_I2C_write_read+0xe0>
        {
            this_i2c->is_transaction_pending = 1u;
    3054:	68fb      	ldr	r3, [r7, #12]
    3056:	f04f 0201 	mov.w	r2, #1
    305a:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
    305e:	e004      	b.n	306a <MSS_I2C_write_read+0xea>
        }
        else
        {
            this_i2c->hw_reg_bit->CTRL_STA = 0x01u;
    3060:	68fb      	ldr	r3, [r7, #12]
    3062:	699b      	ldr	r3, [r3, #24]
    3064:	f04f 0201 	mov.w	r2, #1
    3068:	615a      	str	r2, [r3, #20]
        /*
         * Clear interrupts if required (depends on repeated starts).
         * Since the Bus is on hold, only then prior status needs to
         * be cleared.
         */
        if ( MSS_I2C_HOLD_BUS == this_i2c->bus_status )
    306a:	68fb      	ldr	r3, [r7, #12]
    306c:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
    3070:	2b01      	cmp	r3, #1
    3072:	d111      	bne.n	3098 <MSS_I2C_write_read+0x118>
        {
            this_i2c->hw_reg_bit->CTRL_SI = 0u;
    3074:	68fb      	ldr	r3, [r7, #12]
    3076:	699b      	ldr	r3, [r3, #24]
    3078:	f04f 0200 	mov.w	r2, #0
    307c:	60da      	str	r2, [r3, #12]
            stat_ctrl = this_i2c->hw_reg->STATUS;
    307e:	68fb      	ldr	r3, [r7, #12]
    3080:	695b      	ldr	r3, [r3, #20]
    3082:	791b      	ldrb	r3, [r3, #4]
    3084:	74fb      	strb	r3, [r7, #19]
            stat_ctrl = stat_ctrl;  /* Avoids Lint warning */
    3086:	7cfb      	ldrb	r3, [r7, #19]
    3088:	b2db      	uxtb	r3, r3
    308a:	74fb      	strb	r3, [r7, #19]
            NVIC_ClearPendingIRQ( this_i2c->irqn );
    308c:	68fb      	ldr	r3, [r7, #12]
    308e:	8a5b      	ldrh	r3, [r3, #18]
    3090:	b21b      	sxth	r3, r3
    3092:	4618      	mov	r0, r3
    3094:	f7ff fdac 	bl	2bf0 <NVIC_ClearPendingIRQ>
        }

        /* Enable the interrupt. ( Re-enable) */
        NVIC_EnableIRQ( this_i2c->irqn );
    3098:	68fb      	ldr	r3, [r7, #12]
    309a:	8a5b      	ldrh	r3, [r3, #18]
    309c:	b21b      	sxth	r3, r3
    309e:	4618      	mov	r0, r3
    30a0:	f7ff fd6c 	bl	2b7c <NVIC_EnableIRQ>

        restore_interrupts( primask );
    30a4:	6978      	ldr	r0, [r7, #20]
    30a6:	f000 ff7d 	bl	3fa4 <restore_interrupts>
    }
}
    30aa:	f107 0718 	add.w	r7, r7, #24
    30ae:	46bd      	mov	sp, r7
    30b0:	bd80      	pop	{r7, pc}
    30b2:	bf00      	nop

000030b4 <MSS_I2C_get_status>:
 */
mss_i2c_status_t MSS_I2C_get_status
(
    mss_i2c_instance_t * this_i2c
)
{
    30b4:	b480      	push	{r7}
    30b6:	b085      	sub	sp, #20
    30b8:	af00      	add	r7, sp, #0
    30ba:	6078      	str	r0, [r7, #4]
    mss_i2c_status_t i2c_status ;

    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    30bc:	687a      	ldr	r2, [r7, #4]
    30be:	f64a 230c 	movw	r3, #43532	; 0xaa0c
    30c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    30c6:	429a      	cmp	r2, r3
    30c8:	d007      	beq.n	30da <MSS_I2C_get_status+0x26>
    30ca:	687a      	ldr	r2, [r7, #4]
    30cc:	f64a 2380 	movw	r3, #43648	; 0xaa80
    30d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    30d4:	429a      	cmp	r2, r3
    30d6:	d000      	beq.n	30da <MSS_I2C_get_status+0x26>
    30d8:	be00      	bkpt	0x0000

    i2c_status = this_i2c->master_status ;
    30da:	687b      	ldr	r3, [r7, #4]
    30dc:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    30e0:	73fb      	strb	r3, [r7, #15]
    return i2c_status;
    30e2:	7bfb      	ldrb	r3, [r7, #15]
}
    30e4:	4618      	mov	r0, r3
    30e6:	f107 0714 	add.w	r7, r7, #20
    30ea:	46bd      	mov	sp, r7
    30ec:	bc80      	pop	{r7}
    30ee:	4770      	bx	lr

000030f0 <MSS_I2C_wait_complete>:
mss_i2c_status_t MSS_I2C_wait_complete
(
    mss_i2c_instance_t * this_i2c,
    uint32_t timeout_ms
)
{
    30f0:	b480      	push	{r7}
    30f2:	b085      	sub	sp, #20
    30f4:	af00      	add	r7, sp, #0
    30f6:	6078      	str	r0, [r7, #4]
    30f8:	6039      	str	r1, [r7, #0]
	mss_i2c_status_t i2c_status;
    
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    30fa:	687a      	ldr	r2, [r7, #4]
    30fc:	f64a 230c 	movw	r3, #43532	; 0xaa0c
    3100:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3104:	429a      	cmp	r2, r3
    3106:	d007      	beq.n	3118 <MSS_I2C_wait_complete+0x28>
    3108:	687a      	ldr	r2, [r7, #4]
    310a:	f64a 2380 	movw	r3, #43648	; 0xaa80
    310e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3112:	429a      	cmp	r2, r3
    3114:	d000      	beq.n	3118 <MSS_I2C_wait_complete+0x28>
    3116:	be00      	bkpt	0x0000
    
    this_i2c->master_timeout_ms = timeout_ms;
    3118:	687b      	ldr	r3, [r7, #4]
    311a:	683a      	ldr	r2, [r7, #0]
    311c:	641a      	str	r2, [r3, #64]	; 0x40

    /* Run the loop until state returns I2C_FAILED  or I2C_SUCESS*/
    do {
        i2c_status = this_i2c->master_status;
    311e:	687b      	ldr	r3, [r7, #4]
    3120:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    3124:	73fb      	strb	r3, [r7, #15]
    } while(MSS_I2C_IN_PROGRESS == i2c_status);
    3126:	7bfb      	ldrb	r3, [r7, #15]
    3128:	2b01      	cmp	r3, #1
    312a:	d0f8      	beq.n	311e <MSS_I2C_wait_complete+0x2e>

    return i2c_status;
    312c:	7bfb      	ldrb	r3, [r7, #15]
}
    312e:	4618      	mov	r0, r3
    3130:	f107 0714 	add.w	r7, r7, #20
    3134:	46bd      	mov	sp, r7
    3136:	bc80      	pop	{r7}
    3138:	4770      	bx	lr
    313a:	bf00      	nop

0000313c <MSS_I2C_system_tick>:
void MSS_I2C_system_tick
(
    mss_i2c_instance_t * this_i2c,
    uint32_t ms_since_last_tick
)
{
    313c:	b480      	push	{r7}
    313e:	b083      	sub	sp, #12
    3140:	af00      	add	r7, sp, #0
    3142:	6078      	str	r0, [r7, #4]
    3144:	6039      	str	r1, [r7, #0]
    if(this_i2c->master_timeout_ms != MSS_I2C_NO_TIMEOUT)
    3146:	687b      	ldr	r3, [r7, #4]
    3148:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    314a:	2b00      	cmp	r3, #0
    314c:	d01e      	beq.n	318c <MSS_I2C_system_tick+0x50>
    {
        if(this_i2c->master_timeout_ms > ms_since_last_tick)
    314e:	687b      	ldr	r3, [r7, #4]
    3150:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    3152:	683b      	ldr	r3, [r7, #0]
    3154:	429a      	cmp	r2, r3
    3156:	d907      	bls.n	3168 <MSS_I2C_system_tick+0x2c>
        {
            this_i2c->master_timeout_ms -= ms_since_last_tick;
    3158:	687b      	ldr	r3, [r7, #4]
    315a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    315c:	683b      	ldr	r3, [r7, #0]
    315e:	ebc3 0202 	rsb	r2, r3, r2
    3162:	687b      	ldr	r3, [r7, #4]
    3164:	641a      	str	r2, [r3, #64]	; 0x40
    3166:	e011      	b.n	318c <MSS_I2C_system_tick+0x50>
        else
        {
            /*
             * Mark current transaction as having timed out.
             */
            this_i2c->master_status = MSS_I2C_TIMED_OUT;
    3168:	687b      	ldr	r3, [r7, #4]
    316a:	f04f 0203 	mov.w	r2, #3
    316e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            this_i2c->transaction = NO_TRANSACTION;
    3172:	687b      	ldr	r3, [r7, #4]
    3174:	f04f 0200 	mov.w	r2, #0
    3178:	721a      	strb	r2, [r3, #8]
            this_i2c->is_transaction_pending = 0;
    317a:	687b      	ldr	r3, [r7, #4]
    317c:	f04f 0200 	mov.w	r2, #0
    3180:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
            
            /*
             * Make sure we do not incorrectly signal a timeout for subsequent
             * transactions.
             */
            this_i2c->master_timeout_ms = MSS_I2C_NO_TIMEOUT;
    3184:	687b      	ldr	r3, [r7, #4]
    3186:	f04f 0200 	mov.w	r2, #0
    318a:	641a      	str	r2, [r3, #64]	; 0x40
        }
    }
}
    318c:	f107 070c 	add.w	r7, r7, #12
    3190:	46bd      	mov	sp, r7
    3192:	bc80      	pop	{r7}
    3194:	4770      	bx	lr
    3196:	bf00      	nop

00003198 <MSS_I2C_set_slave_tx_buffer>:
(
    mss_i2c_instance_t * this_i2c,
    const uint8_t * tx_buffer,
    uint16_t tx_size
)
{
    3198:	b580      	push	{r7, lr}
    319a:	b086      	sub	sp, #24
    319c:	af00      	add	r7, sp, #0
    319e:	60f8      	str	r0, [r7, #12]
    31a0:	60b9      	str	r1, [r7, #8]
    31a2:	4613      	mov	r3, r2
    31a4:	80fb      	strh	r3, [r7, #6]
    uint32_t primask;
    
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    31a6:	68fa      	ldr	r2, [r7, #12]
    31a8:	f64a 230c 	movw	r3, #43532	; 0xaa0c
    31ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    31b0:	429a      	cmp	r2, r3
    31b2:	d007      	beq.n	31c4 <MSS_I2C_set_slave_tx_buffer+0x2c>
    31b4:	68fa      	ldr	r2, [r7, #12]
    31b6:	f64a 2380 	movw	r3, #43648	; 0xaa80
    31ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    31be:	429a      	cmp	r2, r3
    31c0:	d000      	beq.n	31c4 <MSS_I2C_set_slave_tx_buffer+0x2c>
    31c2:	be00      	bkpt	0x0000

    primask = disable_interrupts();
    31c4:	f000 fedc 	bl	3f80 <disable_interrupts>
    31c8:	4603      	mov	r3, r0
    31ca:	617b      	str	r3, [r7, #20]
    
    this_i2c->slave_tx_buffer = tx_buffer;
    31cc:	68fb      	ldr	r3, [r7, #12]
    31ce:	68ba      	ldr	r2, [r7, #8]
    31d0:	645a      	str	r2, [r3, #68]	; 0x44
    this_i2c->slave_tx_size = tx_size;
    31d2:	88fa      	ldrh	r2, [r7, #6]
    31d4:	68fb      	ldr	r3, [r7, #12]
    31d6:	649a      	str	r2, [r3, #72]	; 0x48
    this_i2c->slave_tx_idx = 0u;
    31d8:	68fb      	ldr	r3, [r7, #12]
    31da:	f04f 0200 	mov.w	r2, #0
    31de:	64da      	str	r2, [r3, #76]	; 0x4c
    
    restore_interrupts( primask );
    31e0:	6978      	ldr	r0, [r7, #20]
    31e2:	f000 fedf 	bl	3fa4 <restore_interrupts>
}
    31e6:	f107 0718 	add.w	r7, r7, #24
    31ea:	46bd      	mov	sp, r7
    31ec:	bd80      	pop	{r7, pc}
    31ee:	bf00      	nop

000031f0 <MSS_I2C_set_slave_rx_buffer>:
(
    mss_i2c_instance_t * this_i2c,
    uint8_t * rx_buffer,
    uint16_t rx_size
)
{
    31f0:	b580      	push	{r7, lr}
    31f2:	b086      	sub	sp, #24
    31f4:	af00      	add	r7, sp, #0
    31f6:	60f8      	str	r0, [r7, #12]
    31f8:	60b9      	str	r1, [r7, #8]
    31fa:	4613      	mov	r3, r2
    31fc:	80fb      	strh	r3, [r7, #6]
    uint32_t primask;

    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    31fe:	68fa      	ldr	r2, [r7, #12]
    3200:	f64a 230c 	movw	r3, #43532	; 0xaa0c
    3204:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3208:	429a      	cmp	r2, r3
    320a:	d007      	beq.n	321c <MSS_I2C_set_slave_rx_buffer+0x2c>
    320c:	68fa      	ldr	r2, [r7, #12]
    320e:	f64a 2380 	movw	r3, #43648	; 0xaa80
    3212:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3216:	429a      	cmp	r2, r3
    3218:	d000      	beq.n	321c <MSS_I2C_set_slave_rx_buffer+0x2c>
    321a:	be00      	bkpt	0x0000

    primask = disable_interrupts();
    321c:	f000 feb0 	bl	3f80 <disable_interrupts>
    3220:	4603      	mov	r3, r0
    3222:	617b      	str	r3, [r7, #20]
    
    this_i2c->slave_rx_buffer = rx_buffer;
    3224:	68fb      	ldr	r3, [r7, #12]
    3226:	68ba      	ldr	r2, [r7, #8]
    3228:	651a      	str	r2, [r3, #80]	; 0x50
    this_i2c->slave_rx_size = rx_size;
    322a:	88fa      	ldrh	r2, [r7, #6]
    322c:	68fb      	ldr	r3, [r7, #12]
    322e:	655a      	str	r2, [r3, #84]	; 0x54
    this_i2c->slave_rx_idx = 0u;
    3230:	68fb      	ldr	r3, [r7, #12]
    3232:	f04f 0200 	mov.w	r2, #0
    3236:	659a      	str	r2, [r3, #88]	; 0x58

    restore_interrupts( primask );
    3238:	6978      	ldr	r0, [r7, #20]
    323a:	f000 feb3 	bl	3fa4 <restore_interrupts>
}
    323e:	f107 0718 	add.w	r7, r7, #24
    3242:	46bd      	mov	sp, r7
    3244:	bd80      	pop	{r7, pc}
    3246:	bf00      	nop

00003248 <MSS_I2C_set_slave_mem_offset_length>:
void MSS_I2C_set_slave_mem_offset_length
(
    mss_i2c_instance_t * this_i2c,
    uint8_t offset_length
)
{
    3248:	b480      	push	{r7}
    324a:	b083      	sub	sp, #12
    324c:	af00      	add	r7, sp, #0
    324e:	6078      	str	r0, [r7, #4]
    3250:	460b      	mov	r3, r1
    3252:	70fb      	strb	r3, [r7, #3]
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    3254:	687a      	ldr	r2, [r7, #4]
    3256:	f64a 230c 	movw	r3, #43532	; 0xaa0c
    325a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    325e:	429a      	cmp	r2, r3
    3260:	d007      	beq.n	3272 <MSS_I2C_set_slave_mem_offset_length+0x2a>
    3262:	687a      	ldr	r2, [r7, #4]
    3264:	f64a 2380 	movw	r3, #43648	; 0xaa80
    3268:	f2c2 0300 	movt	r3, #8192	; 0x2000
    326c:	429a      	cmp	r2, r3
    326e:	d000      	beq.n	3272 <MSS_I2C_set_slave_mem_offset_length+0x2a>
    3270:	be00      	bkpt	0x0000
    ASSERT(offset_length <= MAX_OFFSET_LENGTH);
    3272:	78fb      	ldrb	r3, [r7, #3]
    3274:	2b02      	cmp	r3, #2
    3276:	d900      	bls.n	327a <MSS_I2C_set_slave_mem_offset_length+0x32>
    3278:	be00      	bkpt	0x0000
    
    if(offset_length > MAX_OFFSET_LENGTH)
    327a:	78fb      	ldrb	r3, [r7, #3]
    327c:	2b02      	cmp	r3, #2
    327e:	d904      	bls.n	328a <MSS_I2C_set_slave_mem_offset_length+0x42>
    {
        this_i2c->slave_mem_offset_length = MAX_OFFSET_LENGTH;
    3280:	687b      	ldr	r3, [r7, #4]
    3282:	f04f 0202 	mov.w	r2, #2
    3286:	661a      	str	r2, [r3, #96]	; 0x60
    3288:	e002      	b.n	3290 <MSS_I2C_set_slave_mem_offset_length+0x48>
    }
    else
    {
        this_i2c->slave_mem_offset_length = offset_length;
    328a:	78fa      	ldrb	r2, [r7, #3]
    328c:	687b      	ldr	r3, [r7, #4]
    328e:	661a      	str	r2, [r3, #96]	; 0x60
    }
}
    3290:	f107 070c 	add.w	r7, r7, #12
    3294:	46bd      	mov	sp, r7
    3296:	bc80      	pop	{r7}
    3298:	4770      	bx	lr
    329a:	bf00      	nop

0000329c <MSS_I2C_register_write_handler>:
void MSS_I2C_register_write_handler
(
    mss_i2c_instance_t * this_i2c,
    mss_i2c_slave_wr_handler_t handler
)
{
    329c:	b480      	push	{r7}
    329e:	b083      	sub	sp, #12
    32a0:	af00      	add	r7, sp, #0
    32a2:	6078      	str	r0, [r7, #4]
    32a4:	6039      	str	r1, [r7, #0]
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    32a6:	687a      	ldr	r2, [r7, #4]
    32a8:	f64a 230c 	movw	r3, #43532	; 0xaa0c
    32ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    32b0:	429a      	cmp	r2, r3
    32b2:	d007      	beq.n	32c4 <MSS_I2C_register_write_handler+0x28>
    32b4:	687a      	ldr	r2, [r7, #4]
    32b6:	f64a 2380 	movw	r3, #43648	; 0xaa80
    32ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    32be:	429a      	cmp	r2, r3
    32c0:	d000      	beq.n	32c4 <MSS_I2C_register_write_handler+0x28>
    32c2:	be00      	bkpt	0x0000

    this_i2c->slave_write_handler = handler;
    32c4:	687b      	ldr	r3, [r7, #4]
    32c6:	683a      	ldr	r2, [r7, #0]
    32c8:	665a      	str	r2, [r3, #100]	; 0x64
}
    32ca:	f107 070c 	add.w	r7, r7, #12
    32ce:	46bd      	mov	sp, r7
    32d0:	bc80      	pop	{r7}
    32d2:	4770      	bx	lr

000032d4 <MSS_I2C_enable_slave>:
 */
void MSS_I2C_enable_slave
(
    mss_i2c_instance_t * this_i2c
)
{
    32d4:	b580      	push	{r7, lr}
    32d6:	b084      	sub	sp, #16
    32d8:	af00      	add	r7, sp, #0
    32da:	6078      	str	r0, [r7, #4]
    uint32_t primask;

    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    32dc:	687a      	ldr	r2, [r7, #4]
    32de:	f64a 230c 	movw	r3, #43532	; 0xaa0c
    32e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    32e6:	429a      	cmp	r2, r3
    32e8:	d007      	beq.n	32fa <MSS_I2C_enable_slave+0x26>
    32ea:	687a      	ldr	r2, [r7, #4]
    32ec:	f64a 2380 	movw	r3, #43648	; 0xaa80
    32f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    32f4:	429a      	cmp	r2, r3
    32f6:	d000      	beq.n	32fa <MSS_I2C_enable_slave+0x26>
    32f8:	be00      	bkpt	0x0000

    primask = disable_interrupts();
    32fa:	f000 fe41 	bl	3f80 <disable_interrupts>
    32fe:	4603      	mov	r3, r0
    3300:	60fb      	str	r3, [r7, #12]

    /* Set the assert acknowledge bit. */
    this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
    3302:	687b      	ldr	r3, [r7, #4]
    3304:	699b      	ldr	r3, [r3, #24]
    3306:	f04f 0201 	mov.w	r2, #1
    330a:	609a      	str	r2, [r3, #8]
    
    /* Enable slave */
    this_i2c->is_slave_enabled = 1u;
    330c:	687b      	ldr	r3, [r7, #4]
    330e:	f04f 0201 	mov.w	r2, #1
    3312:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68

    restore_interrupts( primask );
    3316:	68f8      	ldr	r0, [r7, #12]
    3318:	f000 fe44 	bl	3fa4 <restore_interrupts>

    /* Enable Interrupt */
    NVIC_EnableIRQ( this_i2c->irqn );
    331c:	687b      	ldr	r3, [r7, #4]
    331e:	8a5b      	ldrh	r3, [r3, #18]
    3320:	b21b      	sxth	r3, r3
    3322:	4618      	mov	r0, r3
    3324:	f7ff fc2a 	bl	2b7c <NVIC_EnableIRQ>
}
    3328:	f107 0710 	add.w	r7, r7, #16
    332c:	46bd      	mov	sp, r7
    332e:	bd80      	pop	{r7, pc}

00003330 <MSS_I2C_disable_slave>:
 */
void MSS_I2C_disable_slave
(
    mss_i2c_instance_t * this_i2c
)
{
    3330:	b580      	push	{r7, lr}
    3332:	b084      	sub	sp, #16
    3334:	af00      	add	r7, sp, #0
    3336:	6078      	str	r0, [r7, #4]
    uint32_t primask;

    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    3338:	687a      	ldr	r2, [r7, #4]
    333a:	f64a 230c 	movw	r3, #43532	; 0xaa0c
    333e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3342:	429a      	cmp	r2, r3
    3344:	d007      	beq.n	3356 <MSS_I2C_disable_slave+0x26>
    3346:	687a      	ldr	r2, [r7, #4]
    3348:	f64a 2380 	movw	r3, #43648	; 0xaa80
    334c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3350:	429a      	cmp	r2, r3
    3352:	d000      	beq.n	3356 <MSS_I2C_disable_slave+0x26>
    3354:	be00      	bkpt	0x0000

    primask = disable_interrupts();
    3356:	f000 fe13 	bl	3f80 <disable_interrupts>
    335a:	4603      	mov	r3, r0
    335c:	60fb      	str	r3, [r7, #12]

    /* Reset the assert acknowledge bit. */
    this_i2c->hw_reg_bit->CTRL_AA = 0x00u;
    335e:	687b      	ldr	r3, [r7, #4]
    3360:	699b      	ldr	r3, [r3, #24]
    3362:	f04f 0200 	mov.w	r2, #0
    3366:	609a      	str	r2, [r3, #8]

    /* Disable slave */
    this_i2c->is_slave_enabled = 0u;
    3368:	687b      	ldr	r3, [r7, #4]
    336a:	f04f 0200 	mov.w	r2, #0
    336e:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68

    restore_interrupts( primask );
    3372:	68f8      	ldr	r0, [r7, #12]
    3374:	f000 fe16 	bl	3fa4 <restore_interrupts>
}
    3378:	f107 0710 	add.w	r7, r7, #16
    337c:	46bd      	mov	sp, r7
    337e:	bd80      	pop	{r7, pc}

00003380 <enable_slave_if_required>:
 */
static void enable_slave_if_required
(
    mss_i2c_instance_t * this_i2c
)
{
    3380:	b480      	push	{r7}
    3382:	b083      	sub	sp, #12
    3384:	af00      	add	r7, sp, #0
    3386:	6078      	str	r0, [r7, #4]
    if( this_i2c->is_slave_enabled )
    3388:	687b      	ldr	r3, [r7, #4]
    338a:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
    338e:	2b00      	cmp	r3, #0
    3390:	d004      	beq.n	339c <enable_slave_if_required+0x1c>
    {
        this_i2c->hw_reg_bit->CTRL_AA = 1u;
    3392:	687b      	ldr	r3, [r7, #4]
    3394:	699b      	ldr	r3, [r3, #24]
    3396:	f04f 0201 	mov.w	r2, #1
    339a:	609a      	str	r2, [r3, #8]
    }
}
    339c:	f107 070c 	add.w	r7, r7, #12
    33a0:	46bd      	mov	sp, r7
    33a2:	bc80      	pop	{r7}
    33a4:	4770      	bx	lr
    33a6:	bf00      	nop

000033a8 <mss_i2c_isr>:
 */
static void mss_i2c_isr
(
    mss_i2c_instance_t * this_i2c
)
{
    33a8:	b580      	push	{r7, lr}
    33aa:	b084      	sub	sp, #16
    33ac:	af00      	add	r7, sp, #0
    33ae:	6078      	str	r0, [r7, #4]
    volatile uint8_t status;
    uint8_t data;
    uint8_t hold_bus;
    uint8_t clear_irq = 1u;
    33b0:	f04f 0301 	mov.w	r3, #1
    33b4:	73bb      	strb	r3, [r7, #14]
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    33b6:	687a      	ldr	r2, [r7, #4]
    33b8:	f64a 230c 	movw	r3, #43532	; 0xaa0c
    33bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    33c0:	429a      	cmp	r2, r3
    33c2:	d007      	beq.n	33d4 <mss_i2c_isr+0x2c>
    33c4:	687a      	ldr	r2, [r7, #4]
    33c6:	f64a 2380 	movw	r3, #43648	; 0xaa80
    33ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    33ce:	429a      	cmp	r2, r3
    33d0:	d000      	beq.n	33d4 <mss_i2c_isr+0x2c>
    33d2:	be00      	bkpt	0x0000

    status = this_i2c->hw_reg->STATUS;
    33d4:	687b      	ldr	r3, [r7, #4]
    33d6:	695b      	ldr	r3, [r3, #20]
    33d8:	791b      	ldrb	r3, [r3, #4]
    33da:	72fb      	strb	r3, [r7, #11]

    switch( status )
    33dc:	7afb      	ldrb	r3, [r7, #11]
    33de:	b2db      	uxtb	r3, r3
    33e0:	f1a3 0308 	sub.w	r3, r3, #8
    33e4:	2bd0      	cmp	r3, #208	; 0xd0
    33e6:	f200 841c 	bhi.w	3c22 <mss_i2c_isr+0x87a>
    33ea:	a201      	add	r2, pc, #4	; (adr r2, 33f0 <mss_i2c_isr+0x48>)
    33ec:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    33f0:	00003735 	.word	0x00003735
    33f4:	00003c23 	.word	0x00003c23
    33f8:	00003c23 	.word	0x00003c23
    33fc:	00003c23 	.word	0x00003c23
    3400:	00003c23 	.word	0x00003c23
    3404:	00003c23 	.word	0x00003c23
    3408:	00003c23 	.word	0x00003c23
    340c:	00003c23 	.word	0x00003c23
    3410:	00003735 	.word	0x00003735
    3414:	00003c23 	.word	0x00003c23
    3418:	00003c23 	.word	0x00003c23
    341c:	00003c23 	.word	0x00003c23
    3420:	00003c23 	.word	0x00003c23
    3424:	00003c23 	.word	0x00003c23
    3428:	00003c23 	.word	0x00003c23
    342c:	00003c23 	.word	0x00003c23
    3430:	000037d9 	.word	0x000037d9
    3434:	00003c23 	.word	0x00003c23
    3438:	00003c23 	.word	0x00003c23
    343c:	00003c23 	.word	0x00003c23
    3440:	00003c23 	.word	0x00003c23
    3444:	00003c23 	.word	0x00003c23
    3448:	00003c23 	.word	0x00003c23
    344c:	00003c23 	.word	0x00003c23
    3450:	000037b5 	.word	0x000037b5
    3454:	00003c23 	.word	0x00003c23
    3458:	00003c23 	.word	0x00003c23
    345c:	00003c23 	.word	0x00003c23
    3460:	00003c23 	.word	0x00003c23
    3464:	00003c23 	.word	0x00003c23
    3468:	00003c23 	.word	0x00003c23
    346c:	00003c23 	.word	0x00003c23
    3470:	000037d9 	.word	0x000037d9
    3474:	00003c23 	.word	0x00003c23
    3478:	00003c23 	.word	0x00003c23
    347c:	00003c23 	.word	0x00003c23
    3480:	00003c23 	.word	0x00003c23
    3484:	00003c23 	.word	0x00003c23
    3488:	00003c23 	.word	0x00003c23
    348c:	00003c23 	.word	0x00003c23
    3490:	0000386d 	.word	0x0000386d
    3494:	00003c23 	.word	0x00003c23
    3498:	00003c23 	.word	0x00003c23
    349c:	00003c23 	.word	0x00003c23
    34a0:	00003c23 	.word	0x00003c23
    34a4:	00003c23 	.word	0x00003c23
    34a8:	00003c23 	.word	0x00003c23
    34ac:	00003c23 	.word	0x00003c23
    34b0:	000037a9 	.word	0x000037a9
    34b4:	00003c23 	.word	0x00003c23
    34b8:	00003c23 	.word	0x00003c23
    34bc:	00003c23 	.word	0x00003c23
    34c0:	00003c23 	.word	0x00003c23
    34c4:	00003c23 	.word	0x00003c23
    34c8:	00003c23 	.word	0x00003c23
    34cc:	00003c23 	.word	0x00003c23
    34d0:	00003891 	.word	0x00003891
    34d4:	00003c23 	.word	0x00003c23
    34d8:	00003c23 	.word	0x00003c23
    34dc:	00003c23 	.word	0x00003c23
    34e0:	00003c23 	.word	0x00003c23
    34e4:	00003c23 	.word	0x00003c23
    34e8:	00003c23 	.word	0x00003c23
    34ec:	00003c23 	.word	0x00003c23
    34f0:	000038e1 	.word	0x000038e1
    34f4:	00003c23 	.word	0x00003c23
    34f8:	00003c23 	.word	0x00003c23
    34fc:	00003c23 	.word	0x00003c23
    3500:	00003c23 	.word	0x00003c23
    3504:	00003c23 	.word	0x00003c23
    3508:	00003c23 	.word	0x00003c23
    350c:	00003c23 	.word	0x00003c23
    3510:	00003905 	.word	0x00003905
    3514:	00003c23 	.word	0x00003c23
    3518:	00003c23 	.word	0x00003c23
    351c:	00003c23 	.word	0x00003c23
    3520:	00003c23 	.word	0x00003c23
    3524:	00003c23 	.word	0x00003c23
    3528:	00003c23 	.word	0x00003c23
    352c:	00003c23 	.word	0x00003c23
    3530:	0000393f 	.word	0x0000393f
    3534:	00003c23 	.word	0x00003c23
    3538:	00003c23 	.word	0x00003c23
    353c:	00003c23 	.word	0x00003c23
    3540:	00003c23 	.word	0x00003c23
    3544:	00003c23 	.word	0x00003c23
    3548:	00003c23 	.word	0x00003c23
    354c:	00003c23 	.word	0x00003c23
    3550:	000039e1 	.word	0x000039e1
    3554:	00003c23 	.word	0x00003c23
    3558:	00003c23 	.word	0x00003c23
    355c:	00003c23 	.word	0x00003c23
    3560:	00003c23 	.word	0x00003c23
    3564:	00003c23 	.word	0x00003c23
    3568:	00003c23 	.word	0x00003c23
    356c:	00003c23 	.word	0x00003c23
    3570:	000039d7 	.word	0x000039d7
    3574:	00003c23 	.word	0x00003c23
    3578:	00003c23 	.word	0x00003c23
    357c:	00003c23 	.word	0x00003c23
    3580:	00003c23 	.word	0x00003c23
    3584:	00003c23 	.word	0x00003c23
    3588:	00003c23 	.word	0x00003c23
    358c:	00003c23 	.word	0x00003c23
    3590:	000039e1 	.word	0x000039e1
    3594:	00003c23 	.word	0x00003c23
    3598:	00003c23 	.word	0x00003c23
    359c:	00003c23 	.word	0x00003c23
    35a0:	00003c23 	.word	0x00003c23
    35a4:	00003c23 	.word	0x00003c23
    35a8:	00003c23 	.word	0x00003c23
    35ac:	00003c23 	.word	0x00003c23
    35b0:	000039d7 	.word	0x000039d7
    35b4:	00003c23 	.word	0x00003c23
    35b8:	00003c23 	.word	0x00003c23
    35bc:	00003c23 	.word	0x00003c23
    35c0:	00003c23 	.word	0x00003c23
    35c4:	00003c23 	.word	0x00003c23
    35c8:	00003c23 	.word	0x00003c23
    35cc:	00003c23 	.word	0x00003c23
    35d0:	00003a23 	.word	0x00003a23
    35d4:	00003c23 	.word	0x00003c23
    35d8:	00003c23 	.word	0x00003c23
    35dc:	00003c23 	.word	0x00003c23
    35e0:	00003c23 	.word	0x00003c23
    35e4:	00003c23 	.word	0x00003c23
    35e8:	00003c23 	.word	0x00003c23
    35ec:	00003c23 	.word	0x00003c23
    35f0:	000039a3 	.word	0x000039a3
    35f4:	00003c23 	.word	0x00003c23
    35f8:	00003c23 	.word	0x00003c23
    35fc:	00003c23 	.word	0x00003c23
    3600:	00003c23 	.word	0x00003c23
    3604:	00003c23 	.word	0x00003c23
    3608:	00003c23 	.word	0x00003c23
    360c:	00003c23 	.word	0x00003c23
    3610:	00003a23 	.word	0x00003a23
    3614:	00003c23 	.word	0x00003c23
    3618:	00003c23 	.word	0x00003c23
    361c:	00003c23 	.word	0x00003c23
    3620:	00003c23 	.word	0x00003c23
    3624:	00003c23 	.word	0x00003c23
    3628:	00003c23 	.word	0x00003c23
    362c:	00003c23 	.word	0x00003c23
    3630:	000039a3 	.word	0x000039a3
    3634:	00003c23 	.word	0x00003c23
    3638:	00003c23 	.word	0x00003c23
    363c:	00003c23 	.word	0x00003c23
    3640:	00003c23 	.word	0x00003c23
    3644:	00003c23 	.word	0x00003c23
    3648:	00003c23 	.word	0x00003c23
    364c:	00003c23 	.word	0x00003c23
    3650:	00003a7f 	.word	0x00003a7f
    3654:	00003c23 	.word	0x00003c23
    3658:	00003c23 	.word	0x00003c23
    365c:	00003c23 	.word	0x00003c23
    3660:	00003c23 	.word	0x00003c23
    3664:	00003c23 	.word	0x00003c23
    3668:	00003c23 	.word	0x00003c23
    366c:	00003c23 	.word	0x00003c23
    3670:	00003b57 	.word	0x00003b57
    3674:	00003c23 	.word	0x00003c23
    3678:	00003c23 	.word	0x00003c23
    367c:	00003c23 	.word	0x00003c23
    3680:	00003c23 	.word	0x00003c23
    3684:	00003c23 	.word	0x00003c23
    3688:	00003c23 	.word	0x00003c23
    368c:	00003c23 	.word	0x00003c23
    3690:	00003b57 	.word	0x00003b57
    3694:	00003c23 	.word	0x00003c23
    3698:	00003c23 	.word	0x00003c23
    369c:	00003c23 	.word	0x00003c23
    36a0:	00003c23 	.word	0x00003c23
    36a4:	00003c23 	.word	0x00003c23
    36a8:	00003c23 	.word	0x00003c23
    36ac:	00003c23 	.word	0x00003c23
    36b0:	00003b57 	.word	0x00003b57
    36b4:	00003c23 	.word	0x00003c23
    36b8:	00003c23 	.word	0x00003c23
    36bc:	00003c23 	.word	0x00003c23
    36c0:	00003c23 	.word	0x00003c23
    36c4:	00003c23 	.word	0x00003c23
    36c8:	00003c23 	.word	0x00003c23
    36cc:	00003c23 	.word	0x00003c23
    36d0:	00003be9 	.word	0x00003be9
    36d4:	00003c23 	.word	0x00003c23
    36d8:	00003c23 	.word	0x00003c23
    36dc:	00003c23 	.word	0x00003c23
    36e0:	00003c23 	.word	0x00003c23
    36e4:	00003c23 	.word	0x00003c23
    36e8:	00003c23 	.word	0x00003c23
    36ec:	00003c23 	.word	0x00003c23
    36f0:	00003be9 	.word	0x00003be9
    36f4:	00003c23 	.word	0x00003c23
    36f8:	00003c23 	.word	0x00003c23
    36fc:	00003c23 	.word	0x00003c23
    3700:	00003c23 	.word	0x00003c23
    3704:	00003c23 	.word	0x00003c23
    3708:	00003c23 	.word	0x00003c23
    370c:	00003c23 	.word	0x00003c23
    3710:	00003c23 	.word	0x00003c23
    3714:	00003c23 	.word	0x00003c23
    3718:	00003c23 	.word	0x00003c23
    371c:	00003c23 	.word	0x00003c23
    3720:	00003c23 	.word	0x00003c23
    3724:	00003c23 	.word	0x00003c23
    3728:	00003c23 	.word	0x00003c23
    372c:	00003c23 	.word	0x00003c23
    3730:	00003b29 	.word	0x00003b29
    {
        /************** MASTER TRANSMITTER / RECEIVER *******************/
      
        case ST_START: /* start has been xmt'd */
        case ST_RESTART: /* repeated start has been xmt'd */
            this_i2c->hw_reg_bit->CTRL_STA = 0u;
    3734:	687b      	ldr	r3, [r7, #4]
    3736:	699b      	ldr	r3, [r3, #24]
    3738:	f04f 0200 	mov.w	r2, #0
    373c:	615a      	str	r2, [r3, #20]
            this_i2c->hw_reg->DATA = (uint8_t)this_i2c->target_addr;
    373e:	687b      	ldr	r3, [r7, #4]
    3740:	695b      	ldr	r3, [r3, #20]
    3742:	687a      	ldr	r2, [r7, #4]
    3744:	6852      	ldr	r2, [r2, #4]
    3746:	b2d2      	uxtb	r2, r2
    3748:	721a      	strb	r2, [r3, #8]
            this_i2c->hw_reg_bit->DATA_DIR = this_i2c->dir;
    374a:	687b      	ldr	r3, [r7, #4]
    374c:	699b      	ldr	r3, [r3, #24]
    374e:	687a      	ldr	r2, [r7, #4]
    3750:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    3752:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
            if ( this_i2c->dir == WRITE_DIR )
    3756:	687b      	ldr	r3, [r7, #4]
    3758:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    375a:	2b00      	cmp	r3, #0
    375c:	d104      	bne.n	3768 <mss_i2c_isr+0x3c0>
            {
                this_i2c->master_tx_idx = 0u;
    375e:	687b      	ldr	r3, [r7, #4]
    3760:	f04f 0200 	mov.w	r2, #0
    3764:	629a      	str	r2, [r3, #40]	; 0x28
    3766:	e007      	b.n	3778 <mss_i2c_isr+0x3d0>
            }
            else if ( this_i2c->dir == READ_DIR)
    3768:	687b      	ldr	r3, [r7, #4]
    376a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    376c:	2b01      	cmp	r3, #1
    376e:	d103      	bne.n	3778 <mss_i2c_isr+0x3d0>
            {
                this_i2c->master_rx_idx = 0u;
    3770:	687b      	ldr	r3, [r7, #4]
    3772:	f04f 0200 	mov.w	r2, #0
    3776:	639a      	str	r2, [r3, #56]	; 0x38
            /*
             * Clear the pending transaction. This condition will be true if the slave 
             * has acquired the bus to carry out pending master transaction which 
             * it had received during its slave transmission or reception mode. 
             */
            if(this_i2c->is_transaction_pending)
    3778:	687b      	ldr	r3, [r7, #4]
    377a:	f893 3071 	ldrb.w	r3, [r3, #113]	; 0x71
    377e:	2b00      	cmp	r3, #0
    3780:	d004      	beq.n	378c <mss_i2c_isr+0x3e4>
            {
                this_i2c->is_transaction_pending = 0u;
    3782:	687b      	ldr	r3, [r7, #4]
    3784:	f04f 0200 	mov.w	r2, #0
    3788:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71

            /*
             * Make sure to update proper transaction after master START
             * or RESTART
             */
            if(this_i2c->transaction != this_i2c->pending_transaction)
    378c:	687b      	ldr	r3, [r7, #4]
    378e:	7a1a      	ldrb	r2, [r3, #8]
    3790:	687b      	ldr	r3, [r7, #4]
    3792:	f893 3072 	ldrb.w	r3, [r3, #114]	; 0x72
    3796:	429a      	cmp	r2, r3
    3798:	f000 8267 	beq.w	3c6a <mss_i2c_isr+0x8c2>
            {
                this_i2c->transaction = this_i2c->pending_transaction;
    379c:	687b      	ldr	r3, [r7, #4]
    379e:	f893 2072 	ldrb.w	r2, [r3, #114]	; 0x72
    37a2:	687b      	ldr	r3, [r7, #4]
    37a4:	721a      	strb	r2, [r3, #8]
            }
            break;
    37a6:	e269      	b.n	3c7c <mss_i2c_isr+0x8d4>
            
        case ST_LOST_ARB:
            /* Set start bit.  Let's keep trying!  Don't give up! */
            this_i2c->hw_reg_bit->CTRL_STA = 0x01u;
    37a8:	687b      	ldr	r3, [r7, #4]
    37aa:	699b      	ldr	r3, [r3, #24]
    37ac:	f04f 0201 	mov.w	r2, #1
    37b0:	615a      	str	r2, [r3, #20]
            break;
    37b2:	e263      	b.n	3c7c <mss_i2c_isr+0x8d4>
            
        /******************* MASTER TRANSMITTER *************************/
        case ST_SLAW_NACK:
            /* SLA+W has been transmitted; not ACK has been received - let's stop. */
            this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
    37b4:	687b      	ldr	r3, [r7, #4]
    37b6:	699b      	ldr	r3, [r3, #24]
    37b8:	f04f 0201 	mov.w	r2, #1
    37bc:	611a      	str	r2, [r3, #16]
            this_i2c->master_status = MSS_I2C_FAILED;
    37be:	687b      	ldr	r3, [r7, #4]
    37c0:	f04f 0202 	mov.w	r2, #2
    37c4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            this_i2c->transaction = NO_TRANSACTION;
    37c8:	687b      	ldr	r3, [r7, #4]
    37ca:	f04f 0200 	mov.w	r2, #0
    37ce:	721a      	strb	r2, [r3, #8]
            enable_slave_if_required(this_i2c);
    37d0:	6878      	ldr	r0, [r7, #4]
    37d2:	f7ff fdd5 	bl	3380 <enable_slave_if_required>
            break;
    37d6:	e251      	b.n	3c7c <mss_i2c_isr+0x8d4>
            
        case ST_SLAW_ACK:
        case ST_TX_DATA_ACK:
            /* data byte has been xmt'd with ACK, time to send stop bit or repeated start. */
            if (this_i2c->master_tx_idx < this_i2c->master_tx_size)
    37d8:	687b      	ldr	r3, [r7, #4]
    37da:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    37dc:	687b      	ldr	r3, [r7, #4]
    37de:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    37e0:	429a      	cmp	r2, r3
    37e2:	d20d      	bcs.n	3800 <mss_i2c_isr+0x458>
            {    
                this_i2c->hw_reg->DATA = this_i2c->master_tx_buffer[this_i2c->master_tx_idx++];
    37e4:	687b      	ldr	r3, [r7, #4]
    37e6:	695a      	ldr	r2, [r3, #20]
    37e8:	687b      	ldr	r3, [r7, #4]
    37ea:	6a19      	ldr	r1, [r3, #32]
    37ec:	687b      	ldr	r3, [r7, #4]
    37ee:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    37f0:	4419      	add	r1, r3
    37f2:	7809      	ldrb	r1, [r1, #0]
    37f4:	7211      	strb	r1, [r2, #8]
    37f6:	f103 0201 	add.w	r2, r3, #1
    37fa:	687b      	ldr	r3, [r7, #4]
    37fc:	629a      	str	r2, [r3, #40]	; 0x28
                    NVIC_DisableIRQ( this_i2c->irqn );
                    clear_irq = 0u;
                }
                this_i2c->master_status = MSS_I2C_SUCCESS;
            }
            break;
    37fe:	e23d      	b.n	3c7c <mss_i2c_isr+0x8d4>
            /* data byte has been xmt'd with ACK, time to send stop bit or repeated start. */
            if (this_i2c->master_tx_idx < this_i2c->master_tx_size)
            {    
                this_i2c->hw_reg->DATA = this_i2c->master_tx_buffer[this_i2c->master_tx_idx++];
            }
            else if ( this_i2c->transaction == MASTER_RANDOM_READ_TRANSACTION )
    3800:	687b      	ldr	r3, [r7, #4]
    3802:	7a1b      	ldrb	r3, [r3, #8]
    3804:	2b03      	cmp	r3, #3
    3806:	d109      	bne.n	381c <mss_i2c_isr+0x474>
            {
                /* We are finished sending the address offset part of a random read transaction.
                 * It is is time to send a restart in order to change direction. */
                 this_i2c->dir = READ_DIR;
    3808:	687b      	ldr	r3, [r7, #4]
    380a:	f04f 0201 	mov.w	r2, #1
    380e:	62da      	str	r2, [r3, #44]	; 0x2c
                 this_i2c->hw_reg_bit->CTRL_STA = 0x01u;
    3810:	687b      	ldr	r3, [r7, #4]
    3812:	699b      	ldr	r3, [r3, #24]
    3814:	f04f 0201 	mov.w	r2, #1
    3818:	615a      	str	r2, [r3, #20]
                    NVIC_DisableIRQ( this_i2c->irqn );
                    clear_irq = 0u;
                }
                this_i2c->master_status = MSS_I2C_SUCCESS;
            }
            break;
    381a:	e22f      	b.n	3c7c <mss_i2c_isr+0x8d4>
            {
                /*
                 * Set the transaction back to NO_TRANSACTION to allow user to do further
                 * transaction
                 */
                this_i2c->transaction = NO_TRANSACTION;
    381c:	687b      	ldr	r3, [r7, #4]
    381e:	f04f 0200 	mov.w	r2, #0
    3822:	721a      	strb	r2, [r3, #8]
                hold_bus = this_i2c->options & MSS_I2C_HOLD_BUS;
    3824:	687b      	ldr	r3, [r7, #4]
    3826:	7c1b      	ldrb	r3, [r3, #16]
    3828:	f003 0301 	and.w	r3, r3, #1
    382c:	737b      	strb	r3, [r7, #13]

                /* Store the information of current I2C bus status in the bus_status*/
                this_i2c->bus_status  = hold_bus;
    382e:	687b      	ldr	r3, [r7, #4]
    3830:	7b7a      	ldrb	r2, [r7, #13]
    3832:	f883 2070 	strb.w	r2, [r3, #112]	; 0x70
                if ( hold_bus == 0u )
    3836:	7b7b      	ldrb	r3, [r7, #13]
    3838:	2b00      	cmp	r3, #0
    383a:	d108      	bne.n	384e <mss_i2c_isr+0x4a6>
                { 
                    this_i2c->hw_reg_bit->CTRL_STO = 0x01u; /*xmt stop condition */
    383c:	687b      	ldr	r3, [r7, #4]
    383e:	699b      	ldr	r3, [r3, #24]
    3840:	f04f 0201 	mov.w	r2, #1
    3844:	611a      	str	r2, [r3, #16]
                    enable_slave_if_required(this_i2c);
    3846:	6878      	ldr	r0, [r7, #4]
    3848:	f7ff fd9a 	bl	3380 <enable_slave_if_required>
    384c:	e008      	b.n	3860 <mss_i2c_isr+0x4b8>
                }
                else
                {
                    NVIC_DisableIRQ( this_i2c->irqn );
    384e:	687b      	ldr	r3, [r7, #4]
    3850:	8a5b      	ldrh	r3, [r3, #18]
    3852:	b21b      	sxth	r3, r3
    3854:	4618      	mov	r0, r3
    3856:	f7ff f9ad 	bl	2bb4 <NVIC_DisableIRQ>
                    clear_irq = 0u;
    385a:	f04f 0300 	mov.w	r3, #0
    385e:	73bb      	strb	r3, [r7, #14]
                }
                this_i2c->master_status = MSS_I2C_SUCCESS;
    3860:	687b      	ldr	r3, [r7, #4]
    3862:	f04f 0200 	mov.w	r2, #0
    3866:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            }
            break;
    386a:	e207      	b.n	3c7c <mss_i2c_isr+0x8d4>
            /* data byte SENT, ACK to be received
             * In fact, this means we've received a NACK (This may not be 
             * obvious, but if we've rec'd an ACK then we would be in state 
             * 0x28!) hence, let's send a stop bit
             */
            this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
    386c:	687b      	ldr	r3, [r7, #4]
    386e:	699b      	ldr	r3, [r3, #24]
    3870:	f04f 0201 	mov.w	r2, #1
    3874:	611a      	str	r2, [r3, #16]
            this_i2c->master_status = MSS_I2C_FAILED;
    3876:	687b      	ldr	r3, [r7, #4]
    3878:	f04f 0202 	mov.w	r2, #2
    387c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
    3880:	687b      	ldr	r3, [r7, #4]
    3882:	f04f 0200 	mov.w	r2, #0
    3886:	721a      	strb	r2, [r3, #8]
            enable_slave_if_required(this_i2c);
    3888:	6878      	ldr	r0, [r7, #4]
    388a:	f7ff fd79 	bl	3380 <enable_slave_if_required>

            break;
    388e:	e1f5      	b.n	3c7c <mss_i2c_isr+0x8d4>
      /* STATUS codes 08H, 10H, 38H are all covered in MTX mode */
        case ST_SLAR_ACK: /* SLA+R tx'ed. */
            /* Let's make sure we ACK the first data byte received (set AA bit in CTRL) unless
             * the next byte is the last byte of the read transaction.
             */
            if(this_i2c->master_rx_size > 1u)
    3890:	687b      	ldr	r3, [r7, #4]
    3892:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    3894:	2b01      	cmp	r3, #1
    3896:	d905      	bls.n	38a4 <mss_i2c_isr+0x4fc>
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
    3898:	687b      	ldr	r3, [r7, #4]
    389a:	699b      	ldr	r3, [r3, #24]
    389c:	f04f 0201 	mov.w	r2, #1
    38a0:	609a      	str	r2, [r3, #8]
                this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
                this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
                this_i2c->master_status = MSS_I2C_SUCCESS;
                this_i2c->transaction = NO_TRANSACTION;
            }
            break;
    38a2:	e1eb      	b.n	3c7c <mss_i2c_isr+0x8d4>
             */
            if(this_i2c->master_rx_size > 1u)
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
            }
            else if(1u == this_i2c->master_rx_size)
    38a4:	687b      	ldr	r3, [r7, #4]
    38a6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    38a8:	2b01      	cmp	r3, #1
    38aa:	d105      	bne.n	38b8 <mss_i2c_isr+0x510>
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
    38ac:	687b      	ldr	r3, [r7, #4]
    38ae:	699b      	ldr	r3, [r3, #24]
    38b0:	f04f 0200 	mov.w	r2, #0
    38b4:	609a      	str	r2, [r3, #8]
                this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
                this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
                this_i2c->master_status = MSS_I2C_SUCCESS;
                this_i2c->transaction = NO_TRANSACTION;
            }
            break;
    38b6:	e1e1      	b.n	3c7c <mss_i2c_isr+0x8d4>
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
            }
            else /* this_i2c->master_rx_size == 0u */
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
    38b8:	687b      	ldr	r3, [r7, #4]
    38ba:	699b      	ldr	r3, [r3, #24]
    38bc:	f04f 0201 	mov.w	r2, #1
    38c0:	609a      	str	r2, [r3, #8]
                this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
    38c2:	687b      	ldr	r3, [r7, #4]
    38c4:	699b      	ldr	r3, [r3, #24]
    38c6:	f04f 0201 	mov.w	r2, #1
    38ca:	611a      	str	r2, [r3, #16]
                this_i2c->master_status = MSS_I2C_SUCCESS;
    38cc:	687b      	ldr	r3, [r7, #4]
    38ce:	f04f 0200 	mov.w	r2, #0
    38d2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
                this_i2c->transaction = NO_TRANSACTION;
    38d6:	687b      	ldr	r3, [r7, #4]
    38d8:	f04f 0200 	mov.w	r2, #0
    38dc:	721a      	strb	r2, [r3, #8]
            }
            break;
    38de:	e1cd      	b.n	3c7c <mss_i2c_isr+0x8d4>
            
        case ST_SLAR_NACK: /* SLA+R tx'ed; let's release the bus (send a stop condition) */
            this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
    38e0:	687b      	ldr	r3, [r7, #4]
    38e2:	699b      	ldr	r3, [r3, #24]
    38e4:	f04f 0201 	mov.w	r2, #1
    38e8:	611a      	str	r2, [r3, #16]
            this_i2c->master_status = MSS_I2C_FAILED;
    38ea:	687b      	ldr	r3, [r7, #4]
    38ec:	f04f 0202 	mov.w	r2, #2
    38f0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
    38f4:	687b      	ldr	r3, [r7, #4]
    38f6:	f04f 0200 	mov.w	r2, #0
    38fa:	721a      	strb	r2, [r3, #8]
            enable_slave_if_required(this_i2c);
    38fc:	6878      	ldr	r0, [r7, #4]
    38fe:	f7ff fd3f 	bl	3380 <enable_slave_if_required>
            break;
    3902:	e1bb      	b.n	3c7c <mss_i2c_isr+0x8d4>
          
        case ST_RX_DATA_ACK: /* Data byte received, ACK returned */
            /* First, get the data */
            this_i2c->master_rx_buffer[this_i2c->master_rx_idx++] = this_i2c->hw_reg->DATA;
    3904:	687b      	ldr	r3, [r7, #4]
    3906:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    3908:	687b      	ldr	r3, [r7, #4]
    390a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    390c:	441a      	add	r2, r3
    390e:	6879      	ldr	r1, [r7, #4]
    3910:	6949      	ldr	r1, [r1, #20]
    3912:	7a09      	ldrb	r1, [r1, #8]
    3914:	b2c9      	uxtb	r1, r1
    3916:	7011      	strb	r1, [r2, #0]
    3918:	f103 0201 	add.w	r2, r3, #1
    391c:	687b      	ldr	r3, [r7, #4]
    391e:	639a      	str	r2, [r3, #56]	; 0x38

            if( this_i2c->master_rx_idx >= (this_i2c->master_rx_size - 1u))
    3920:	687b      	ldr	r3, [r7, #4]
    3922:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    3924:	687b      	ldr	r3, [r7, #4]
    3926:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    3928:	f103 33ff 	add.w	r3, r3, #4294967295
    392c:	429a      	cmp	r2, r3
    392e:	f0c0 819e 	bcc.w	3c6e <mss_i2c_isr+0x8c6>
            {
                /* If we're at the second last byte, let's set AA to 0 so
                 * we return a NACK at the last byte. */
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
    3932:	687b      	ldr	r3, [r7, #4]
    3934:	699b      	ldr	r3, [r3, #24]
    3936:	f04f 0200 	mov.w	r2, #0
    393a:	609a      	str	r2, [r3, #8]
            }
            break;
    393c:	e19e      	b.n	3c7c <mss_i2c_isr+0x8d4>
            
        case ST_RX_DATA_NACK: /* Data byte received, NACK returned */
            /* Get the data, then send a stop condition */
            this_i2c->master_rx_buffer[this_i2c->master_rx_idx] = this_i2c->hw_reg->DATA;
    393e:	687b      	ldr	r3, [r7, #4]
    3940:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    3942:	687b      	ldr	r3, [r7, #4]
    3944:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    3946:	4413      	add	r3, r2
    3948:	687a      	ldr	r2, [r7, #4]
    394a:	6952      	ldr	r2, [r2, #20]
    394c:	7a12      	ldrb	r2, [r2, #8]
    394e:	b2d2      	uxtb	r2, r2
    3950:	701a      	strb	r2, [r3, #0]
          
            hold_bus = this_i2c->options &  MSS_I2C_HOLD_BUS; 
    3952:	687b      	ldr	r3, [r7, #4]
    3954:	7c1b      	ldrb	r3, [r3, #16]
    3956:	f003 0301 	and.w	r3, r3, #1
    395a:	737b      	strb	r3, [r7, #13]

            /* Store the information of current I2C bus status in the bus_status*/
            this_i2c->bus_status  = hold_bus;
    395c:	687b      	ldr	r3, [r7, #4]
    395e:	7b7a      	ldrb	r2, [r7, #13]
    3960:	f883 2070 	strb.w	r2, [r3, #112]	; 0x70
            if ( hold_bus == 0u )
    3964:	7b7b      	ldrb	r3, [r7, #13]
    3966:	2b00      	cmp	r3, #0
    3968:	d108      	bne.n	397c <mss_i2c_isr+0x5d4>
            { 
                this_i2c->hw_reg_bit->CTRL_STO = 0x01u;  /*xmt stop condition */
    396a:	687b      	ldr	r3, [r7, #4]
    396c:	699b      	ldr	r3, [r3, #24]
    396e:	f04f 0201 	mov.w	r2, #1
    3972:	611a      	str	r2, [r3, #16]

                /* Bus is released, now we can start listening to bus, if it is slave */
                   enable_slave_if_required(this_i2c);
    3974:	6878      	ldr	r0, [r7, #4]
    3976:	f7ff fd03 	bl	3380 <enable_slave_if_required>
    397a:	e008      	b.n	398e <mss_i2c_isr+0x5e6>
            }
            else
            {
                NVIC_DisableIRQ( this_i2c->irqn );
    397c:	687b      	ldr	r3, [r7, #4]
    397e:	8a5b      	ldrh	r3, [r3, #18]
    3980:	b21b      	sxth	r3, r3
    3982:	4618      	mov	r0, r3
    3984:	f7ff f916 	bl	2bb4 <NVIC_DisableIRQ>
                clear_irq = 0u;
    3988:	f04f 0300 	mov.w	r3, #0
    398c:	73bb      	strb	r3, [r7, #14]

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
    398e:	687b      	ldr	r3, [r7, #4]
    3990:	f04f 0200 	mov.w	r2, #0
    3994:	721a      	strb	r2, [r3, #8]
            this_i2c->master_status = MSS_I2C_SUCCESS;
    3996:	687b      	ldr	r3, [r7, #4]
    3998:	f04f 0200 	mov.w	r2, #0
    399c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            break;
    39a0:	e16c      	b.n	3c7c <mss_i2c_isr+0x8d4>
        
        /******************** SLAVE RECEIVER **************************/
        case ST_GCA_NACK: /* NACK after, GCA addressing */
        case ST_SLA_NACK: /* Re-enable AA (assert ack) bit for future transmissions */
            this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
    39a2:	687b      	ldr	r3, [r7, #4]
    39a4:	699b      	ldr	r3, [r3, #24]
    39a6:	f04f 0201 	mov.w	r2, #1
    39aa:	609a      	str	r2, [r3, #8]
            
            this_i2c->transaction = NO_TRANSACTION;
    39ac:	687b      	ldr	r3, [r7, #4]
    39ae:	f04f 0200 	mov.w	r2, #0
    39b2:	721a      	strb	r2, [r3, #8]
            this_i2c->slave_status = MSS_I2C_SUCCESS;
    39b4:	687b      	ldr	r3, [r7, #4]
    39b6:	f04f 0200 	mov.w	r2, #0
    39ba:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
            
            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
    39be:	687b      	ldr	r3, [r7, #4]
    39c0:	f893 3071 	ldrb.w	r3, [r3, #113]	; 0x71
    39c4:	2b00      	cmp	r3, #0
    39c6:	f000 8154 	beq.w	3c72 <mss_i2c_isr+0x8ca>
            {
                this_i2c->hw_reg_bit->CTRL_STA = 1u ;
    39ca:	687b      	ldr	r3, [r7, #4]
    39cc:	699b      	ldr	r3, [r3, #24]
    39ce:	f04f 0201 	mov.w	r2, #1
    39d2:	615a      	str	r2, [r3, #20]
            }
            break;
    39d4:	e152      	b.n	3c7c <mss_i2c_isr+0x8d4>
        case ST_SLV_LA: /* Arbitr. lost (SLA rec'd) */
            /*
             *  We lost arbitration and either the GCE or our address was the
             *  one received so pend the master operation we were starting.
             */
            this_i2c->is_transaction_pending = 1u;
    39d6:	687b      	ldr	r3, [r7, #4]
    39d8:	f04f 0201 	mov.w	r2, #1
    39dc:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
            /* Fall through to normal ST processing as we are now in slave mode */

        case ST_GCA: /* General call address received, ACK returned */
        case ST_SLAVE_SLAW: /* SLA+W received, ACK returned */

            this_i2c->transaction = WRITE_SLAVE_TRANSACTION;
    39e0:	687b      	ldr	r3, [r7, #4]
    39e2:	f04f 0204 	mov.w	r2, #4
    39e6:	721a      	strb	r2, [r3, #8]
            this_i2c->slave_rx_idx = 0u;
    39e8:	687b      	ldr	r3, [r7, #4]
    39ea:	f04f 0200 	mov.w	r2, #0
    39ee:	659a      	str	r2, [r3, #88]	; 0x58
            this_i2c->random_read_addr = 0u;
    39f0:	687b      	ldr	r3, [r7, #4]
    39f2:	f04f 0200 	mov.w	r2, #0
    39f6:	60da      	str	r2, [r3, #12]

             /* If Start Bit is set, clear it, but store that information since it is because of
              * pending transaction
              */
            if(this_i2c->hw_reg_bit->CTRL_STA)
    39f8:	687b      	ldr	r3, [r7, #4]
    39fa:	699b      	ldr	r3, [r3, #24]
    39fc:	695b      	ldr	r3, [r3, #20]
    39fe:	2b00      	cmp	r3, #0
    3a00:	d009      	beq.n	3a16 <mss_i2c_isr+0x66e>
            {
                this_i2c->hw_reg_bit->CTRL_STA = 0u ;
    3a02:	687b      	ldr	r3, [r7, #4]
    3a04:	699b      	ldr	r3, [r3, #24]
    3a06:	f04f 0200 	mov.w	r2, #0
    3a0a:	615a      	str	r2, [r3, #20]
                this_i2c->is_transaction_pending = 1u;
    3a0c:	687b      	ldr	r3, [r7, #4]
    3a0e:	f04f 0201 	mov.w	r2, #1
    3a12:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
            }
            this_i2c->slave_status = MSS_I2C_IN_PROGRESS;
    3a16:	687b      	ldr	r3, [r7, #4]
    3a18:	f04f 0201 	mov.w	r2, #1
    3a1c:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
#ifdef MSS_I2C_INCLUDE_SLA_IN_RX_PAYLOAD
            /* Fall through to put address as first byte in payload buffer */
#else
            /* Only break from this case if the slave address must NOT be included at the
             * beginning of the received write data. */
            break;
    3a20:	e12c      	b.n	3c7c <mss_i2c_isr+0x8d4>
#endif            
        case ST_GCA_ACK: /* DATA received; ACK sent after GCA */
        case ST_RDATA: /* DATA received; must clear DATA register */
            if((this_i2c->slave_rx_buffer != (uint8_t *)0)
    3a22:	687b      	ldr	r3, [r7, #4]
    3a24:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    3a26:	2b00      	cmp	r3, #0
    3a28:	d01c      	beq.n	3a64 <mss_i2c_isr+0x6bc>
               && (this_i2c->slave_rx_idx < this_i2c->slave_rx_size))
    3a2a:	687b      	ldr	r3, [r7, #4]
    3a2c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    3a2e:	687b      	ldr	r3, [r7, #4]
    3a30:	6d5b      	ldr	r3, [r3, #84]	; 0x54
             * beginning of the received write data. */
            break;
#endif            
        case ST_GCA_ACK: /* DATA received; ACK sent after GCA */
        case ST_RDATA: /* DATA received; must clear DATA register */
            if((this_i2c->slave_rx_buffer != (uint8_t *)0)
    3a32:	429a      	cmp	r2, r3
    3a34:	d216      	bcs.n	3a64 <mss_i2c_isr+0x6bc>
               && (this_i2c->slave_rx_idx < this_i2c->slave_rx_size))
            {
                data = this_i2c->hw_reg->DATA;
    3a36:	687b      	ldr	r3, [r7, #4]
    3a38:	695b      	ldr	r3, [r3, #20]
    3a3a:	7a1b      	ldrb	r3, [r3, #8]
    3a3c:	733b      	strb	r3, [r7, #12]
                this_i2c->slave_rx_buffer[this_i2c->slave_rx_idx++] = data;
    3a3e:	687b      	ldr	r3, [r7, #4]
    3a40:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    3a42:	687b      	ldr	r3, [r7, #4]
    3a44:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    3a46:	441a      	add	r2, r3
    3a48:	7b39      	ldrb	r1, [r7, #12]
    3a4a:	7011      	strb	r1, [r2, #0]
    3a4c:	f103 0201 	add.w	r2, r3, #1
    3a50:	687b      	ldr	r3, [r7, #4]
    3a52:	659a      	str	r2, [r3, #88]	; 0x58
                {
                    /* Ignore the slave address byte in the random read address
                       computation in the case where INCLUDE_SLA_IN_RX_PAYLOAD
                       is defined. */
#endif
                    this_i2c->random_read_addr = (this_i2c->random_read_addr << 8) + data;
    3a54:	687b      	ldr	r3, [r7, #4]
    3a56:	68db      	ldr	r3, [r3, #12]
    3a58:	ea4f 2203 	mov.w	r2, r3, lsl #8
    3a5c:	7b3b      	ldrb	r3, [r7, #12]
    3a5e:	441a      	add	r2, r3
    3a60:	687b      	ldr	r3, [r7, #4]
    3a62:	60da      	str	r2, [r3, #12]
#ifdef MSS_I2C_INCLUDE_SLA_IN_RX_PAYLOAD
                }
#endif
            }
            
            if (this_i2c->slave_rx_idx >= this_i2c->slave_rx_size)
    3a64:	687b      	ldr	r3, [r7, #4]
    3a66:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    3a68:	687b      	ldr	r3, [r7, #4]
    3a6a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    3a6c:	429a      	cmp	r2, r3
    3a6e:	f0c0 8102 	bcc.w	3c76 <mss_i2c_isr+0x8ce>
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0u;   /* send a NACK when done (next reception) */
    3a72:	687b      	ldr	r3, [r7, #4]
    3a74:	699b      	ldr	r3, [r3, #24]
    3a76:	f04f 0200 	mov.w	r2, #0
    3a7a:	609a      	str	r2, [r3, #8]
            }
            break;
    3a7c:	e0fe      	b.n	3c7c <mss_i2c_isr+0x8d4>
            /* STOP or repeated START occurred. */
            /* We cannot be sure if the transaction has actually completed as
             * this hardware state reports that either a STOP or repeated START
             * condition has occurred. We assume that this is a repeated START
             * if the transaction was a write from the master to this point.*/
            if ( this_i2c->transaction == WRITE_SLAVE_TRANSACTION )
    3a7e:	687b      	ldr	r3, [r7, #4]
    3a80:	7a1b      	ldrb	r3, [r3, #8]
    3a82:	2b04      	cmp	r3, #4
    3a84:	d135      	bne.n	3af2 <mss_i2c_isr+0x74a>
            {
                if ( this_i2c->slave_rx_idx == this_i2c->slave_mem_offset_length )
    3a86:	687b      	ldr	r3, [r7, #4]
    3a88:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    3a8a:	687b      	ldr	r3, [r7, #4]
    3a8c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    3a8e:	429a      	cmp	r2, r3
    3a90:	d103      	bne.n	3a9a <mss_i2c_isr+0x6f2>
                {
                    this_i2c->slave_tx_idx = this_i2c->random_read_addr;
    3a92:	687b      	ldr	r3, [r7, #4]
    3a94:	68da      	ldr	r2, [r3, #12]
    3a96:	687b      	ldr	r3, [r7, #4]
    3a98:	64da      	str	r2, [r3, #76]	; 0x4c
                }
                {
                    /* Call the slave's write transaction handler if it exists. */
                    if ( this_i2c->slave_write_handler != 0u )
    3a9a:	687b      	ldr	r3, [r7, #4]
    3a9c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    3a9e:	2b00      	cmp	r3, #0
    3aa0:	d021      	beq.n	3ae6 <mss_i2c_isr+0x73e>
                    {
                        mss_i2c_slave_handler_ret_t h_ret;
                        h_ret = this_i2c->slave_write_handler( this_i2c, this_i2c->slave_rx_buffer, (uint16_t)this_i2c->slave_rx_idx );
    3aa2:	687b      	ldr	r3, [r7, #4]
    3aa4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    3aa6:	687a      	ldr	r2, [r7, #4]
    3aa8:	6d11      	ldr	r1, [r2, #80]	; 0x50
    3aaa:	687a      	ldr	r2, [r7, #4]
    3aac:	6d92      	ldr	r2, [r2, #88]	; 0x58
    3aae:	b292      	uxth	r2, r2
    3ab0:	6878      	ldr	r0, [r7, #4]
    3ab2:	4798      	blx	r3
    3ab4:	4603      	mov	r3, r0
    3ab6:	73fb      	strb	r3, [r7, #15]
                        if ( MSS_I2C_REENABLE_SLAVE_RX == h_ret )
    3ab8:	7bfb      	ldrb	r3, [r7, #15]
    3aba:	2b00      	cmp	r3, #0
    3abc:	d108      	bne.n	3ad0 <mss_i2c_isr+0x728>
                        {
                            /* There is a small risk that the write handler could
                             * call MSS_I2C_disable_slave() but return
                             * MSS_I2C_REENABLE_SLAVE_RX in error so we only
                             * enable ACKs if still in slave mode. */
                             enable_slave_if_required(this_i2c);
    3abe:	6878      	ldr	r0, [r7, #4]
    3ac0:	f7ff fc5e 	bl	3380 <enable_slave_if_required>
                             this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
    3ac4:	687b      	ldr	r3, [r7, #4]
    3ac6:	699b      	ldr	r3, [r3, #24]
    3ac8:	f04f 0201 	mov.w	r2, #1
    3acc:	609a      	str	r2, [r3, #8]
                        }
                    }
                    else
                    {
                        /* Re-enable address acknowledge in case we were ready to nack the next received byte. */
                        this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
    3ace:	e017      	b.n	3b00 <mss_i2c_isr+0x758>
                             enable_slave_if_required(this_i2c);
                             this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
                        }
                        else
                        {
                            this_i2c->hw_reg_bit->CTRL_AA = 0u;
    3ad0:	687b      	ldr	r3, [r7, #4]
    3ad2:	699b      	ldr	r3, [r3, #24]
    3ad4:	f04f 0200 	mov.w	r2, #0
    3ad8:	609a      	str	r2, [r3, #8]
                            /* Clear slave mode flag as well otherwise in mixed
                             * master/slave applications, the AA bit will get set by
                             * subsequent master operations. */
                            this_i2c->is_slave_enabled = 0u;
    3ada:	687b      	ldr	r3, [r7, #4]
    3adc:	f04f 0200 	mov.w	r2, #0
    3ae0:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
                        }
                    }
                    else
                    {
                        /* Re-enable address acknowledge in case we were ready to nack the next received byte. */
                        this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
    3ae4:	e00c      	b.n	3b00 <mss_i2c_isr+0x758>
    3ae6:	687b      	ldr	r3, [r7, #4]
    3ae8:	699b      	ldr	r3, [r3, #24]
    3aea:	f04f 0201 	mov.w	r2, #1
    3aee:	609a      	str	r2, [r3, #8]
    3af0:	e006      	b.n	3b00 <mss_i2c_isr+0x758>
            {
                /*
                 * Reset slave_tx_idx so that a subsequent read will result in the slave's
                 * transmit buffer being sent from the first byte.
                 */
                this_i2c->slave_tx_idx = 0u;
    3af2:	687b      	ldr	r3, [r7, #4]
    3af4:	f04f 0200 	mov.w	r2, #0
    3af8:	64da      	str	r2, [r3, #76]	; 0x4c
                /*
                 * See if we need to re-enable acknowledgement as some error conditions, such
                 * as a master prematurely ending a transfer, can see us get here with AA set
                 * to 0 which will disable slave operation if we are not careful.
                 */
                enable_slave_if_required(this_i2c);
    3afa:	6878      	ldr	r0, [r7, #4]
    3afc:	f7ff fc40 	bl	3380 <enable_slave_if_required>
            }

            /* Mark any previous master write transaction as complete. */
            this_i2c->slave_status = MSS_I2C_SUCCESS;
    3b00:	687b      	ldr	r3, [r7, #4]
    3b02:	f04f 0200 	mov.w	r2, #0
    3b06:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
    3b0a:	687b      	ldr	r3, [r7, #4]
    3b0c:	f893 3071 	ldrb.w	r3, [r3, #113]	; 0x71
    3b10:	2b00      	cmp	r3, #0
    3b12:	d004      	beq.n	3b1e <mss_i2c_isr+0x776>
            {
                this_i2c->hw_reg_bit->CTRL_STA = 1u ;
    3b14:	687b      	ldr	r3, [r7, #4]
    3b16:	699b      	ldr	r3, [r3, #24]
    3b18:	f04f 0201 	mov.w	r2, #1
    3b1c:	615a      	str	r2, [r3, #20]

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
    3b1e:	687b      	ldr	r3, [r7, #4]
    3b20:	f04f 0200 	mov.w	r2, #0
    3b24:	721a      	strb	r2, [r3, #8]
            break;
    3b26:	e0a9      	b.n	3c7c <mss_i2c_isr+0x8d4>
        case ST_SLV_RST: /* SMBUS ONLY: timeout state. must clear interrupt */
            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction.
             */
            this_i2c->transaction = NO_TRANSACTION;
    3b28:	687b      	ldr	r3, [r7, #4]
    3b2a:	f04f 0200 	mov.w	r2, #0
    3b2e:	721a      	strb	r2, [r3, #8]
            /*
             * Reset slave_tx_idx so that a subsequent read will result in the slave's
             * transmit buffer being sent from the first byte.
             */
            this_i2c->slave_tx_idx = 0u;
    3b30:	687b      	ldr	r3, [r7, #4]
    3b32:	f04f 0200 	mov.w	r2, #0
    3b36:	64da      	str	r2, [r3, #76]	; 0x4c
            /*
             * Clear status to I2C_FAILED only if there was an operation in progress.
             */
            if(MSS_I2C_IN_PROGRESS == this_i2c->slave_status)
    3b38:	687b      	ldr	r3, [r7, #4]
    3b3a:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    3b3e:	b2db      	uxtb	r3, r3
    3b40:	2b01      	cmp	r3, #1
    3b42:	d104      	bne.n	3b4e <mss_i2c_isr+0x7a6>
            {
                this_i2c->slave_status = MSS_I2C_FAILED;
    3b44:	687b      	ldr	r3, [r7, #4]
    3b46:	f04f 0202 	mov.w	r2, #2
    3b4a:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
            }

            enable_slave_if_required(this_i2c); /* Make sure AA is set correctly */
    3b4e:	6878      	ldr	r0, [r7, #4]
    3b50:	f7ff fc16 	bl	3380 <enable_slave_if_required>

            break;
    3b54:	e092      	b.n	3c7c <mss_i2c_isr+0x8d4>
            
        /****************** SLAVE TRANSMITTER **************************/
        case ST_SLAVE_SLAR_ACK: /* SLA+R received, ACK returned */
        case ST_SLARW_LA:   /* Arbitration lost, SLA+R received, ACK returned */
        case ST_RACK: /* Data tx'ed, ACK received */
            if ( status == ST_SLAVE_SLAR_ACK )
    3b56:	7afb      	ldrb	r3, [r7, #11]
    3b58:	b2db      	uxtb	r3, r3
    3b5a:	2ba8      	cmp	r3, #168	; 0xa8
    3b5c:	d11b      	bne.n	3b96 <mss_i2c_isr+0x7ee>
            {
                this_i2c->transaction = READ_SLAVE_TRANSACTION;
    3b5e:	687b      	ldr	r3, [r7, #4]
    3b60:	f04f 0205 	mov.w	r2, #5
    3b64:	721a      	strb	r2, [r3, #8]
                this_i2c->random_read_addr = 0u;
    3b66:	687b      	ldr	r3, [r7, #4]
    3b68:	f04f 0200 	mov.w	r2, #0
    3b6c:	60da      	str	r2, [r3, #12]

                this_i2c->slave_status = MSS_I2C_IN_PROGRESS;
    3b6e:	687b      	ldr	r3, [r7, #4]
    3b70:	f04f 0201 	mov.w	r2, #1
    3b74:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

                /* If Start Bit is set, clear it, but store that information since it is because of
                 * pending transaction
                 */
                if(this_i2c->hw_reg_bit->CTRL_STA)
    3b78:	687b      	ldr	r3, [r7, #4]
    3b7a:	699b      	ldr	r3, [r3, #24]
    3b7c:	695b      	ldr	r3, [r3, #20]
    3b7e:	2b00      	cmp	r3, #0
    3b80:	d009      	beq.n	3b96 <mss_i2c_isr+0x7ee>
                {
                    this_i2c->hw_reg_bit->CTRL_STA = 0u ;
    3b82:	687b      	ldr	r3, [r7, #4]
    3b84:	699b      	ldr	r3, [r3, #24]
    3b86:	f04f 0200 	mov.w	r2, #0
    3b8a:	615a      	str	r2, [r3, #20]
                    this_i2c->is_transaction_pending = 1u;
    3b8c:	687b      	ldr	r3, [r7, #4]
    3b8e:	f04f 0201 	mov.w	r2, #1
    3b92:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
                }
            }
            if (this_i2c->slave_tx_idx >= this_i2c->slave_tx_size)
    3b96:	687b      	ldr	r3, [r7, #4]
    3b98:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    3b9a:	687b      	ldr	r3, [r7, #4]
    3b9c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    3b9e:	429a      	cmp	r2, r3
    3ba0:	d305      	bcc.n	3bae <mss_i2c_isr+0x806>
            {
                /* Ensure 0xFF is returned to the master when the slave specifies
                 * an empty transmit buffer. */
                this_i2c->hw_reg->DATA = 0xFFu;
    3ba2:	687b      	ldr	r3, [r7, #4]
    3ba4:	695b      	ldr	r3, [r3, #20]
    3ba6:	f04f 32ff 	mov.w	r2, #4294967295
    3baa:	721a      	strb	r2, [r3, #8]
    3bac:	e00c      	b.n	3bc8 <mss_i2c_isr+0x820>
            }
            else
            {
                /* Load the data the data byte to be sent to the master. */
                this_i2c->hw_reg->DATA = this_i2c->slave_tx_buffer[this_i2c->slave_tx_idx++];
    3bae:	687b      	ldr	r3, [r7, #4]
    3bb0:	695a      	ldr	r2, [r3, #20]
    3bb2:	687b      	ldr	r3, [r7, #4]
    3bb4:	6c59      	ldr	r1, [r3, #68]	; 0x44
    3bb6:	687b      	ldr	r3, [r7, #4]
    3bb8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    3bba:	4419      	add	r1, r3
    3bbc:	7809      	ldrb	r1, [r1, #0]
    3bbe:	7211      	strb	r1, [r2, #8]
    3bc0:	f103 0201 	add.w	r2, r3, #1
    3bc4:	687b      	ldr	r3, [r7, #4]
    3bc6:	64da      	str	r2, [r3, #76]	; 0x4c
            }
            /* Determine if this is the last data byte to send to the master. */
            if (this_i2c->slave_tx_idx >= this_i2c->slave_tx_size) /* last byte? */
    3bc8:	687b      	ldr	r3, [r7, #4]
    3bca:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    3bcc:	687b      	ldr	r3, [r7, #4]
    3bce:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    3bd0:	429a      	cmp	r2, r3
    3bd2:	d352      	bcc.n	3c7a <mss_i2c_isr+0x8d2>
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
    3bd4:	687b      	ldr	r3, [r7, #4]
    3bd6:	699b      	ldr	r3, [r3, #24]
    3bd8:	f04f 0200 	mov.w	r2, #0
    3bdc:	609a      	str	r2, [r3, #8]
                /* Next read transaction will result in slave's transmit buffer
                 * being sent from the first byte. */
                this_i2c->slave_tx_idx = 0u;
    3bde:	687b      	ldr	r3, [r7, #4]
    3be0:	f04f 0200 	mov.w	r2, #0
    3be4:	64da      	str	r2, [r3, #76]	; 0x4c
            }
            break;
    3be6:	e049      	b.n	3c7c <mss_i2c_isr+0x8d4>
        case ST_SLAVE_RNACK:    /* Data byte has been transmitted; not-ACK has been received. */
        case ST_FINAL: /* Last Data byte tx'ed, ACK received */
            /* We assume that the transaction will be stopped by the master.
             * Reset slave_tx_idx so that a subsequent read will result in the slave's
             * transmit buffer being sent from the first byte. */
            this_i2c->slave_tx_idx = 0u;
    3be8:	687b      	ldr	r3, [r7, #4]
    3bea:	f04f 0200 	mov.w	r2, #0
    3bee:	64da      	str	r2, [r3, #76]	; 0x4c
            this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
    3bf0:	687b      	ldr	r3, [r7, #4]
    3bf2:	699b      	ldr	r3, [r3, #24]
    3bf4:	f04f 0201 	mov.w	r2, #1
    3bf8:	609a      	str	r2, [r3, #8]

            /*  Mark previous state as complete */
            this_i2c->slave_status = MSS_I2C_SUCCESS;
    3bfa:	687b      	ldr	r3, [r7, #4]
    3bfc:	f04f 0200 	mov.w	r2, #0
    3c00:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
    3c04:	687b      	ldr	r3, [r7, #4]
    3c06:	f893 3071 	ldrb.w	r3, [r3, #113]	; 0x71
    3c0a:	2b00      	cmp	r3, #0
    3c0c:	d004      	beq.n	3c18 <mss_i2c_isr+0x870>
            {
                this_i2c->hw_reg_bit->CTRL_STA = 1u ;
    3c0e:	687b      	ldr	r3, [r7, #4]
    3c10:	699b      	ldr	r3, [r3, #24]
    3c12:	f04f 0201 	mov.w	r2, #1
    3c16:	615a      	str	r2, [r3, #20]

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
    3c18:	687b      	ldr	r3, [r7, #4]
    3c1a:	f04f 0200 	mov.w	r2, #0
    3c1e:	721a      	strb	r2, [r3, #8]
            break;
    3c20:	e02c      	b.n	3c7c <mss_i2c_isr+0x8d4>
        case ST_RESET_ACTIVATED:
        case ST_BUS_ERROR: /* Bus error during MST or selected slave modes */
        default:
            /* Some undefined state has encountered. Clear Start bit to make
             * sure, next good transaction happen */
            this_i2c->hw_reg_bit->CTRL_STA = 0x00u;
    3c22:	687b      	ldr	r3, [r7, #4]
    3c24:	699b      	ldr	r3, [r3, #24]
    3c26:	f04f 0200 	mov.w	r2, #0
    3c2a:	615a      	str	r2, [r3, #20]
            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
    3c2c:	687b      	ldr	r3, [r7, #4]
    3c2e:	f04f 0200 	mov.w	r2, #0
    3c32:	721a      	strb	r2, [r3, #8]
            /*
             * Reset slave_tx_idx so that a subsequent read will result in the slave's
             * transmit buffer being sent from the first byte.
             */
            this_i2c->slave_tx_idx = 0u;
    3c34:	687b      	ldr	r3, [r7, #4]
    3c36:	f04f 0200 	mov.w	r2, #0
    3c3a:	64da      	str	r2, [r3, #76]	; 0x4c
            /*
             * Clear statuses to I2C_FAILED only if there was an operation in progress.
             */
            if(MSS_I2C_IN_PROGRESS == this_i2c->master_status)
    3c3c:	687b      	ldr	r3, [r7, #4]
    3c3e:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    3c42:	b2db      	uxtb	r3, r3
    3c44:	2b01      	cmp	r3, #1
    3c46:	d104      	bne.n	3c52 <mss_i2c_isr+0x8aa>
            {
                this_i2c->master_status = MSS_I2C_FAILED;
    3c48:	687b      	ldr	r3, [r7, #4]
    3c4a:	f04f 0202 	mov.w	r2, #2
    3c4e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            }

            if(MSS_I2C_IN_PROGRESS == this_i2c->slave_status)
    3c52:	687b      	ldr	r3, [r7, #4]
    3c54:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    3c58:	b2db      	uxtb	r3, r3
    3c5a:	2b01      	cmp	r3, #1
    3c5c:	d10e      	bne.n	3c7c <mss_i2c_isr+0x8d4>
            {
                this_i2c->slave_status = MSS_I2C_FAILED;
    3c5e:	687b      	ldr	r3, [r7, #4]
    3c60:	f04f 0202 	mov.w	r2, #2
    3c64:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
    3c68:	e008      	b.n	3c7c <mss_i2c_isr+0x8d4>
             */
            if(this_i2c->transaction != this_i2c->pending_transaction)
            {
                this_i2c->transaction = this_i2c->pending_transaction;
            }
            break;
    3c6a:	bf00      	nop
    3c6c:	e006      	b.n	3c7c <mss_i2c_isr+0x8d4>
            {
                /* If we're at the second last byte, let's set AA to 0 so
                 * we return a NACK at the last byte. */
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
            }
            break;
    3c6e:	bf00      	nop
    3c70:	e004      	b.n	3c7c <mss_i2c_isr+0x8d4>
            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
            {
                this_i2c->hw_reg_bit->CTRL_STA = 1u ;
            }
            break;
    3c72:	bf00      	nop
    3c74:	e002      	b.n	3c7c <mss_i2c_isr+0x8d4>
            
            if (this_i2c->slave_rx_idx >= this_i2c->slave_rx_size)
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0u;   /* send a NACK when done (next reception) */
            }
            break;
    3c76:	bf00      	nop
    3c78:	e000      	b.n	3c7c <mss_i2c_isr+0x8d4>
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
                /* Next read transaction will result in slave's transmit buffer
                 * being sent from the first byte. */
                this_i2c->slave_tx_idx = 0u;
            }
            break;
    3c7a:	bf00      	nop


            break;
    }
    
    if ( clear_irq )
    3c7c:	7bbb      	ldrb	r3, [r7, #14]
    3c7e:	2b00      	cmp	r3, #0
    3c80:	d004      	beq.n	3c8c <mss_i2c_isr+0x8e4>
    {
        /* clear interrupt. */
        this_i2c->hw_reg_bit->CTRL_SI = 0u;
    3c82:	687b      	ldr	r3, [r7, #4]
    3c84:	699b      	ldr	r3, [r3, #24]
    3c86:	f04f 0200 	mov.w	r2, #0
    3c8a:	60da      	str	r2, [r3, #12]
    }
    
    /* Read the status register to ensure the last I2C registers write took place
     * in a system built around a bus making use of posted writes. */
    status = this_i2c->hw_reg->STATUS;
    3c8c:	687b      	ldr	r3, [r7, #4]
    3c8e:	695b      	ldr	r3, [r3, #20]
    3c90:	791b      	ldrb	r3, [r3, #4]
    3c92:	72fb      	strb	r3, [r7, #11]
}
    3c94:	f107 0710 	add.w	r7, r7, #16
    3c98:	46bd      	mov	sp, r7
    3c9a:	bd80      	pop	{r7, pc}

00003c9c <MSS_I2C_smbus_init>:
void MSS_I2C_smbus_init
(
    mss_i2c_instance_t * this_i2c,
    uint8_t frequency
)
{
    3c9c:	b480      	push	{r7}
    3c9e:	b083      	sub	sp, #12
    3ca0:	af00      	add	r7, sp, #0
    3ca2:	6078      	str	r0, [r7, #4]
    3ca4:	460b      	mov	r3, r1
    3ca6:	70fb      	strb	r3, [r7, #3]
    /* Set the frequency before enabling time out logic */
    this_i2c->hw_reg->FREQ = frequency;
    3ca8:	687b      	ldr	r3, [r7, #4]
    3caa:	695b      	ldr	r3, [r3, #20]
    3cac:	78fa      	ldrb	r2, [r7, #3]
    3cae:	751a      	strb	r2, [r3, #20]

    /* Enable SMBUS */
    this_i2c->hw_reg->SMBUS = MSS_INIT_AND_ENABLE_SMBUS;
    3cb0:	687b      	ldr	r3, [r7, #4]
    3cb2:	695b      	ldr	r3, [r3, #20]
    3cb4:	f04f 0254 	mov.w	r2, #84	; 0x54
    3cb8:	741a      	strb	r2, [r3, #16]
}
    3cba:	f107 070c 	add.w	r7, r7, #12
    3cbe:	46bd      	mov	sp, r7
    3cc0:	bc80      	pop	{r7}
    3cc2:	4770      	bx	lr

00003cc4 <MSS_I2C_enable_smbus_irq>:
void MSS_I2C_enable_smbus_irq
(
    mss_i2c_instance_t * this_i2c,
    uint8_t  irq_type
)
{
    3cc4:	b580      	push	{r7, lr}
    3cc6:	b082      	sub	sp, #8
    3cc8:	af00      	add	r7, sp, #0
    3cca:	6078      	str	r0, [r7, #4]
    3ccc:	460b      	mov	r3, r1
    3cce:	70fb      	strb	r3, [r7, #3]
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    3cd0:	687a      	ldr	r2, [r7, #4]
    3cd2:	f64a 230c 	movw	r3, #43532	; 0xaa0c
    3cd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3cda:	429a      	cmp	r2, r3
    3cdc:	d007      	beq.n	3cee <MSS_I2C_enable_smbus_irq+0x2a>
    3cde:	687a      	ldr	r2, [r7, #4]
    3ce0:	f64a 2380 	movw	r3, #43648	; 0xaa80
    3ce4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3ce8:	429a      	cmp	r2, r3
    3cea:	d000      	beq.n	3cee <MSS_I2C_enable_smbus_irq+0x2a>
    3cec:	be00      	bkpt	0x0000

	/* Enable any interrupts selected by the user */
    if ( this_i2c == &g_mss_i2c0 )
    3cee:	687a      	ldr	r2, [r7, #4]
    3cf0:	f64a 230c 	movw	r3, #43532	; 0xaa0c
    3cf4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3cf8:	429a      	cmp	r2, r3
    3cfa:	d127      	bne.n	3d4c <MSS_I2C_enable_smbus_irq+0x88>
    {
        if ( irq_type & MSS_I2C_SMBALERT_IRQ )
    3cfc:	78fb      	ldrb	r3, [r7, #3]
    3cfe:	f003 0301 	and.w	r3, r3, #1
    3d02:	b2db      	uxtb	r3, r3
    3d04:	2b00      	cmp	r3, #0
    3d06:	d00d      	beq.n	3d24 <MSS_I2C_enable_smbus_irq+0x60>
        {
            /* Clear interrupt at the NVIC and enable in MSS I2C */
        	NVIC_ClearPendingIRQ( I2C0_SMBAlert_IRQn );
    3d08:	f04f 000f 	mov.w	r0, #15
    3d0c:	f7fe ff70 	bl	2bf0 <NVIC_ClearPendingIRQ>
            this_i2c->hw_smb_reg_bit->SMB_SMBALERT_IE = 0x01u;
    3d10:	687b      	ldr	r3, [r7, #4]
    3d12:	69db      	ldr	r3, [r3, #28]
    3d14:	f04f 0201 	mov.w	r2, #1
    3d18:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
            /* Enable the interrupt at the NVIC */
            NVIC_EnableIRQ( I2C0_SMBAlert_IRQn );
    3d1c:	f04f 000f 	mov.w	r0, #15
    3d20:	f7fe ff2c 	bl	2b7c <NVIC_EnableIRQ>
        }
        if (irq_type & MSS_I2C_SMBSUS_IRQ )
    3d24:	78fb      	ldrb	r3, [r7, #3]
    3d26:	f003 0302 	and.w	r3, r3, #2
    3d2a:	2b00      	cmp	r3, #0
    3d2c:	d036      	beq.n	3d9c <MSS_I2C_enable_smbus_irq+0xd8>
        {
            /* Clear interrupt at the NVIC and enable in MSS I2C */
            NVIC_ClearPendingIRQ( I2C0_SMBus_IRQn );
    3d2e:	f04f 0010 	mov.w	r0, #16
    3d32:	f7fe ff5d 	bl	2bf0 <NVIC_ClearPendingIRQ>
            this_i2c->hw_smb_reg_bit->SMB_SMBSUS_IE = 0x01u;
    3d36:	687b      	ldr	r3, [r7, #4]
    3d38:	69db      	ldr	r3, [r3, #28]
    3d3a:	f04f 0201 	mov.w	r2, #1
    3d3e:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
            /* Enable the interrupt at the NVIC */
            NVIC_EnableIRQ( I2C0_SMBus_IRQn );
    3d42:	f04f 0010 	mov.w	r0, #16
    3d46:	f7fe ff19 	bl	2b7c <NVIC_EnableIRQ>
    3d4a:	e028      	b.n	3d9e <MSS_I2C_enable_smbus_irq+0xda>
        }
    }
    else
    {
        if ( irq_type & MSS_I2C_SMBALERT_IRQ )
    3d4c:	78fb      	ldrb	r3, [r7, #3]
    3d4e:	f003 0301 	and.w	r3, r3, #1
    3d52:	b2db      	uxtb	r3, r3
    3d54:	2b00      	cmp	r3, #0
    3d56:	d00d      	beq.n	3d74 <MSS_I2C_enable_smbus_irq+0xb0>
        {
            /* Clear interrupt at the NVIC and enable in MSS I2C */
            NVIC_ClearPendingIRQ( I2C1_SMBAlert_IRQn );
    3d58:	f04f 0012 	mov.w	r0, #18
    3d5c:	f7fe ff48 	bl	2bf0 <NVIC_ClearPendingIRQ>
            this_i2c->hw_smb_reg_bit->SMB_SMBALERT_IE = 0x01u;
    3d60:	687b      	ldr	r3, [r7, #4]
    3d62:	69db      	ldr	r3, [r3, #28]
    3d64:	f04f 0201 	mov.w	r2, #1
    3d68:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
            /* Enable the interrupt at the NVIC */
            NVIC_EnableIRQ( I2C1_SMBAlert_IRQn );
    3d6c:	f04f 0012 	mov.w	r0, #18
    3d70:	f7fe ff04 	bl	2b7c <NVIC_EnableIRQ>
        }
        if (irq_type & MSS_I2C_SMBSUS_IRQ )
    3d74:	78fb      	ldrb	r3, [r7, #3]
    3d76:	f003 0302 	and.w	r3, r3, #2
    3d7a:	2b00      	cmp	r3, #0
    3d7c:	d00f      	beq.n	3d9e <MSS_I2C_enable_smbus_irq+0xda>
        {
            /* Clear interrupt at the NVIC and enable in MSS I2C */
            NVIC_ClearPendingIRQ( I2C1_SMBus_IRQn );
    3d7e:	f04f 0013 	mov.w	r0, #19
    3d82:	f7fe ff35 	bl	2bf0 <NVIC_ClearPendingIRQ>
            this_i2c->hw_smb_reg_bit->SMB_SMBSUS_IE = 0x01u;
    3d86:	687b      	ldr	r3, [r7, #4]
    3d88:	69db      	ldr	r3, [r3, #28]
    3d8a:	f04f 0201 	mov.w	r2, #1
    3d8e:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
            /* Enable the interrupt at the NVIC */
            NVIC_EnableIRQ( I2C1_SMBus_IRQn );
    3d92:	f04f 0013 	mov.w	r0, #19
    3d96:	f7fe fef1 	bl	2b7c <NVIC_EnableIRQ>
    3d9a:	e000      	b.n	3d9e <MSS_I2C_enable_smbus_irq+0xda>
        {
            /* Clear interrupt at the NVIC and enable in MSS I2C */
            NVIC_ClearPendingIRQ( I2C0_SMBus_IRQn );
            this_i2c->hw_smb_reg_bit->SMB_SMBSUS_IE = 0x01u;
            /* Enable the interrupt at the NVIC */
            NVIC_EnableIRQ( I2C0_SMBus_IRQn );
    3d9c:	bf00      	nop
            this_i2c->hw_smb_reg_bit->SMB_SMBSUS_IE = 0x01u;
            /* Enable the interrupt at the NVIC */
            NVIC_EnableIRQ( I2C1_SMBus_IRQn );
        }
    }
}
    3d9e:	f107 0708 	add.w	r7, r7, #8
    3da2:	46bd      	mov	sp, r7
    3da4:	bd80      	pop	{r7, pc}
    3da6:	bf00      	nop

00003da8 <MSS_I2C_disable_smbus_irq>:
void MSS_I2C_disable_smbus_irq
(
    mss_i2c_instance_t * this_i2c,
    uint8_t  irq_type
)
{
    3da8:	b580      	push	{r7, lr}
    3daa:	b082      	sub	sp, #8
    3dac:	af00      	add	r7, sp, #0
    3dae:	6078      	str	r0, [r7, #4]
    3db0:	460b      	mov	r3, r1
    3db2:	70fb      	strb	r3, [r7, #3]
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    3db4:	687a      	ldr	r2, [r7, #4]
    3db6:	f64a 230c 	movw	r3, #43532	; 0xaa0c
    3dba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3dbe:	429a      	cmp	r2, r3
    3dc0:	d007      	beq.n	3dd2 <MSS_I2C_disable_smbus_irq+0x2a>
    3dc2:	687a      	ldr	r2, [r7, #4]
    3dc4:	f64a 2380 	movw	r3, #43648	; 0xaa80
    3dc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3dcc:	429a      	cmp	r2, r3
    3dce:	d000      	beq.n	3dd2 <MSS_I2C_disable_smbus_irq+0x2a>
    3dd0:	be00      	bkpt	0x0000

	/* Disable any interrupts selected by the user */
    if ( this_i2c == &g_mss_i2c0 )
    3dd2:	687a      	ldr	r2, [r7, #4]
    3dd4:	f64a 230c 	movw	r3, #43532	; 0xaa0c
    3dd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3ddc:	429a      	cmp	r2, r3
    3dde:	d11f      	bne.n	3e20 <MSS_I2C_disable_smbus_irq+0x78>
    {
        if ( irq_type & MSS_I2C_SMBALERT_IRQ )
    3de0:	78fb      	ldrb	r3, [r7, #3]
    3de2:	f003 0301 	and.w	r3, r3, #1
    3de6:	b2db      	uxtb	r3, r3
    3de8:	2b00      	cmp	r3, #0
    3dea:	d009      	beq.n	3e00 <MSS_I2C_disable_smbus_irq+0x58>
        {
            /* Disable interrupt at the NVIC and the MSS I2C */
            this_i2c->hw_smb_reg_bit->SMB_SMBALERT_IE = 0x00u;
    3dec:	687b      	ldr	r3, [r7, #4]
    3dee:	69db      	ldr	r3, [r3, #28]
    3df0:	f04f 0200 	mov.w	r2, #0
    3df4:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
            NVIC_DisableIRQ( I2C0_SMBAlert_IRQn );
    3df8:	f04f 000f 	mov.w	r0, #15
    3dfc:	f7fe feda 	bl	2bb4 <NVIC_DisableIRQ>
        }
        if (irq_type & MSS_I2C_SMBSUS_IRQ )
    3e00:	78fb      	ldrb	r3, [r7, #3]
    3e02:	f003 0302 	and.w	r3, r3, #2
    3e06:	2b00      	cmp	r3, #0
    3e08:	d02a      	beq.n	3e60 <MSS_I2C_disable_smbus_irq+0xb8>
        {
            /* Disable interrupt at the NVIC and the MSS I2C */
            this_i2c->hw_smb_reg_bit->SMB_SMBSUS_IE = 0x00u;
    3e0a:	687b      	ldr	r3, [r7, #4]
    3e0c:	69db      	ldr	r3, [r3, #28]
    3e0e:	f04f 0200 	mov.w	r2, #0
    3e12:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
            NVIC_DisableIRQ( I2C0_SMBus_IRQn );
    3e16:	f04f 0010 	mov.w	r0, #16
    3e1a:	f7fe fecb 	bl	2bb4 <NVIC_DisableIRQ>
    3e1e:	e020      	b.n	3e62 <MSS_I2C_disable_smbus_irq+0xba>
        }
    }
    else
    {
        if ( irq_type & MSS_I2C_SMBALERT_IRQ )
    3e20:	78fb      	ldrb	r3, [r7, #3]
    3e22:	f003 0301 	and.w	r3, r3, #1
    3e26:	b2db      	uxtb	r3, r3
    3e28:	2b00      	cmp	r3, #0
    3e2a:	d009      	beq.n	3e40 <MSS_I2C_disable_smbus_irq+0x98>
        {
            /* Disable interrupt at the NVIC and the MSS I2C */
            this_i2c->hw_smb_reg_bit->SMB_SMBALERT_IE = 0x00u;
    3e2c:	687b      	ldr	r3, [r7, #4]
    3e2e:	69db      	ldr	r3, [r3, #28]
    3e30:	f04f 0200 	mov.w	r2, #0
    3e34:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
            NVIC_DisableIRQ( I2C1_SMBAlert_IRQn );
    3e38:	f04f 0012 	mov.w	r0, #18
    3e3c:	f7fe feba 	bl	2bb4 <NVIC_DisableIRQ>
        }
        if (irq_type & MSS_I2C_SMBSUS_IRQ )
    3e40:	78fb      	ldrb	r3, [r7, #3]
    3e42:	f003 0302 	and.w	r3, r3, #2
    3e46:	2b00      	cmp	r3, #0
    3e48:	d00b      	beq.n	3e62 <MSS_I2C_disable_smbus_irq+0xba>
        {
            /* Disable interrupt at the NVIC and the MSS I2C */
            this_i2c->hw_smb_reg_bit->SMB_SMBSUS_IE = 0x00u;
    3e4a:	687b      	ldr	r3, [r7, #4]
    3e4c:	69db      	ldr	r3, [r3, #28]
    3e4e:	f04f 0200 	mov.w	r2, #0
    3e52:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
            NVIC_DisableIRQ( I2C1_SMBus_IRQn );
    3e56:	f04f 0013 	mov.w	r0, #19
    3e5a:	f7fe feab 	bl	2bb4 <NVIC_DisableIRQ>
    3e5e:	e000      	b.n	3e62 <MSS_I2C_disable_smbus_irq+0xba>
        }
        if (irq_type & MSS_I2C_SMBSUS_IRQ )
        {
            /* Disable interrupt at the NVIC and the MSS I2C */
            this_i2c->hw_smb_reg_bit->SMB_SMBSUS_IE = 0x00u;
            NVIC_DisableIRQ( I2C0_SMBus_IRQn );
    3e60:	bf00      	nop
            /* Disable interrupt at the NVIC and the MSS I2C */
            this_i2c->hw_smb_reg_bit->SMB_SMBSUS_IE = 0x00u;
            NVIC_DisableIRQ( I2C1_SMBus_IRQn );
        }
    }
}
    3e62:	f107 0708 	add.w	r7, r7, #8
    3e66:	46bd      	mov	sp, r7
    3e68:	bd80      	pop	{r7, pc}
    3e6a:	bf00      	nop

00003e6c <MSS_I2C_suspend_smbus_slave>:
 */
void MSS_I2C_suspend_smbus_slave
(
    mss_i2c_instance_t * this_i2c
)
{
    3e6c:	b480      	push	{r7}
    3e6e:	b083      	sub	sp, #12
    3e70:	af00      	add	r7, sp, #0
    3e72:	6078      	str	r0, [r7, #4]
    /* Active low output so 0 asserts condition */
    this_i2c->hw_smb_reg_bit->SMB_SMBSUS_NO = 0x00u;
    3e74:	687b      	ldr	r3, [r7, #4]
    3e76:	69db      	ldr	r3, [r3, #28]
    3e78:	f04f 0200 	mov.w	r2, #0
    3e7c:	f8c3 2218 	str.w	r2, [r3, #536]	; 0x218
}
    3e80:	f107 070c 	add.w	r7, r7, #12
    3e84:	46bd      	mov	sp, r7
    3e86:	bc80      	pop	{r7}
    3e88:	4770      	bx	lr
    3e8a:	bf00      	nop

00003e8c <MSS_I2C_resume_smbus_slave>:
 */
void MSS_I2C_resume_smbus_slave
(
    mss_i2c_instance_t * this_i2c
)
{
    3e8c:	b480      	push	{r7}
    3e8e:	b083      	sub	sp, #12
    3e90:	af00      	add	r7, sp, #0
    3e92:	6078      	str	r0, [r7, #4]
    /* Active low output so 1 clears condition */
    this_i2c->hw_smb_reg_bit->SMB_SMBSUS_NO = 0x01u;
    3e94:	687b      	ldr	r3, [r7, #4]
    3e96:	69db      	ldr	r3, [r3, #28]
    3e98:	f04f 0201 	mov.w	r2, #1
    3e9c:	f8c3 2218 	str.w	r2, [r3, #536]	; 0x218
}
    3ea0:	f107 070c 	add.w	r7, r7, #12
    3ea4:	46bd      	mov	sp, r7
    3ea6:	bc80      	pop	{r7}
    3ea8:	4770      	bx	lr
    3eaa:	bf00      	nop

00003eac <MSS_I2C_reset_smbus>:
 */
void MSS_I2C_reset_smbus
(
    mss_i2c_instance_t * this_i2c
)
{
    3eac:	b480      	push	{r7}
    3eae:	b083      	sub	sp, #12
    3eb0:	af00      	add	r7, sp, #0
    3eb2:	6078      	str	r0, [r7, #4]
    this_i2c->hw_smb_reg_bit->SMB_SMBus_Reset = 0x01u;
    3eb4:	687b      	ldr	r3, [r7, #4]
    3eb6:	69db      	ldr	r3, [r3, #28]
    3eb8:	f04f 0201 	mov.w	r2, #1
    3ebc:	f8c3 221c 	str.w	r2, [r3, #540]	; 0x21c
}
    3ec0:	f107 070c 	add.w	r7, r7, #12
    3ec4:	46bd      	mov	sp, r7
    3ec6:	bc80      	pop	{r7}
    3ec8:	4770      	bx	lr
    3eca:	bf00      	nop

00003ecc <MSS_I2C_set_smbus_alert>:
 */
void MSS_I2C_set_smbus_alert
(
    mss_i2c_instance_t * this_i2c
)
{
    3ecc:	b480      	push	{r7}
    3ece:	b083      	sub	sp, #12
    3ed0:	af00      	add	r7, sp, #0
    3ed2:	6078      	str	r0, [r7, #4]
    /* Active low output so 0 asserts condition */
    this_i2c->hw_smb_reg_bit->SMB_SMBALERT_NO = 0x00u;
    3ed4:	687b      	ldr	r3, [r7, #4]
    3ed6:	69db      	ldr	r3, [r3, #28]
    3ed8:	f04f 0200 	mov.w	r2, #0
    3edc:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
}
    3ee0:	f107 070c 	add.w	r7, r7, #12
    3ee4:	46bd      	mov	sp, r7
    3ee6:	bc80      	pop	{r7}
    3ee8:	4770      	bx	lr
    3eea:	bf00      	nop

00003eec <MSS_I2C_clear_smbus_alert>:
 */
void MSS_I2C_clear_smbus_alert
(
    mss_i2c_instance_t * this_i2c
)
{
    3eec:	b480      	push	{r7}
    3eee:	b083      	sub	sp, #12
    3ef0:	af00      	add	r7, sp, #0
    3ef2:	6078      	str	r0, [r7, #4]
    /* Active low output so 1 clears condition */
    this_i2c->hw_smb_reg_bit->SMB_SMBALERT_NO = 0x01u;
    3ef4:	687b      	ldr	r3, [r7, #4]
    3ef6:	69db      	ldr	r3, [r3, #28]
    3ef8:	f04f 0201 	mov.w	r2, #1
    3efc:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
}
    3f00:	f107 070c 	add.w	r7, r7, #12
    3f04:	46bd      	mov	sp, r7
    3f06:	bc80      	pop	{r7}
    3f08:	4770      	bx	lr
    3f0a:	bf00      	nop

00003f0c <MSS_I2C_set_gca>:

void MSS_I2C_set_gca
(
    mss_i2c_instance_t * this_i2c
)
{
    3f0c:	b480      	push	{r7}
    3f0e:	b083      	sub	sp, #12
    3f10:	af00      	add	r7, sp, #0
    3f12:	6078      	str	r0, [r7, #4]
    /* accept GC addressing. */
    this_i2c->hw_reg_bit->ADDR_GC = 0x01u;
    3f14:	687b      	ldr	r3, [r7, #4]
    3f16:	699b      	ldr	r3, [r3, #24]
    3f18:	f04f 0201 	mov.w	r2, #1
    3f1c:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
    3f20:	f107 070c 	add.w	r7, r7, #12
    3f24:	46bd      	mov	sp, r7
    3f26:	bc80      	pop	{r7}
    3f28:	4770      	bx	lr
    3f2a:	bf00      	nop

00003f2c <MSS_I2C_clear_gca>:
 */
void MSS_I2C_clear_gca
(
    mss_i2c_instance_t * this_i2c
)
{
    3f2c:	b480      	push	{r7}
    3f2e:	b083      	sub	sp, #12
    3f30:	af00      	add	r7, sp, #0
    3f32:	6078      	str	r0, [r7, #4]
    /* Disable GC addressing. */
    this_i2c->hw_reg_bit->ADDR_GC = 0u;
    3f34:	687b      	ldr	r3, [r7, #4]
    3f36:	699b      	ldr	r3, [r3, #24]
    3f38:	f04f 0200 	mov.w	r2, #0
    3f3c:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
    3f40:	f107 070c 	add.w	r7, r7, #12
    3f44:	46bd      	mov	sp, r7
    3f46:	bc80      	pop	{r7}
    3f48:	4770      	bx	lr
    3f4a:	bf00      	nop

00003f4c <MSS_I2C_set_user_data>:
void MSS_I2C_set_user_data
(
    mss_i2c_instance_t * this_i2c,
    void * p_user_data
)
{
    3f4c:	b480      	push	{r7}
    3f4e:	b083      	sub	sp, #12
    3f50:	af00      	add	r7, sp, #0
    3f52:	6078      	str	r0, [r7, #4]
    3f54:	6039      	str	r1, [r7, #0]
    this_i2c->p_user_data = p_user_data ;
    3f56:	687b      	ldr	r3, [r7, #4]
    3f58:	683a      	ldr	r2, [r7, #0]
    3f5a:	66da      	str	r2, [r3, #108]	; 0x6c
}
    3f5c:	f107 070c 	add.w	r7, r7, #12
    3f60:	46bd      	mov	sp, r7
    3f62:	bc80      	pop	{r7}
    3f64:	4770      	bx	lr
    3f66:	bf00      	nop

00003f68 <MSS_I2C_get_user_data>:
 */
void * MSS_I2C_get_user_data
(
    mss_i2c_instance_t * this_i2c
)
{
    3f68:	b480      	push	{r7}
    3f6a:	b083      	sub	sp, #12
    3f6c:	af00      	add	r7, sp, #0
    3f6e:	6078      	str	r0, [r7, #4]
    return( this_i2c->p_user_data);
    3f70:	687b      	ldr	r3, [r7, #4]
    3f72:	6edb      	ldr	r3, [r3, #108]	; 0x6c
}
    3f74:	4618      	mov	r0, r3
    3f76:	f107 070c 	add.w	r7, r7, #12
    3f7a:	46bd      	mov	sp, r7
    3f7c:	bc80      	pop	{r7}
    3f7e:	4770      	bx	lr

00003f80 <disable_interrupts>:
/*------------------------------------------------------------------------------
 *
 */
static uint32_t disable_interrupts( void )
{
    3f80:	b580      	push	{r7, lr}
    3f82:	b082      	sub	sp, #8
    3f84:	af00      	add	r7, sp, #0
    uint32_t primask;
    primask = __get_PRIMASK();
    3f86:	f006 f80f 	bl	9fa8 <__get_PRIMASK>
    3f8a:	4603      	mov	r3, r0
    3f8c:	607b      	str	r3, [r7, #4]
    __set_PRIMASK(1u);
    3f8e:	f04f 0001 	mov.w	r0, #1
    3f92:	f006 f819 	bl	9fc8 <__set_PRIMASK>
    return primask;
    3f96:	687b      	ldr	r3, [r7, #4]
}
    3f98:	4618      	mov	r0, r3
    3f9a:	f107 0708 	add.w	r7, r7, #8
    3f9e:	46bd      	mov	sp, r7
    3fa0:	bd80      	pop	{r7, pc}
    3fa2:	bf00      	nop

00003fa4 <restore_interrupts>:

/*------------------------------------------------------------------------------
 *
 */
static void restore_interrupts( uint32_t primask )
{
    3fa4:	b580      	push	{r7, lr}
    3fa6:	b082      	sub	sp, #8
    3fa8:	af00      	add	r7, sp, #0
    3faa:	6078      	str	r0, [r7, #4]
    __set_PRIMASK( primask );
    3fac:	6878      	ldr	r0, [r7, #4]
    3fae:	f006 f80b 	bl	9fc8 <__set_PRIMASK>
}
    3fb2:	f107 0708 	add.w	r7, r7, #8
    3fb6:	46bd      	mov	sp, r7
    3fb8:	bd80      	pop	{r7, pc}
    3fba:	bf00      	nop

00003fbc <I2C0_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void I2C0_IRQHandler( void )
#else
void I2C0_IRQHandler( void )
#endif
{
    3fbc:	4668      	mov	r0, sp
    3fbe:	f020 0107 	bic.w	r1, r0, #7
    3fc2:	468d      	mov	sp, r1
    3fc4:	b589      	push	{r0, r3, r7, lr}
    3fc6:	af00      	add	r7, sp, #0
    mss_i2c_isr( &g_mss_i2c0 );
    3fc8:	f64a 200c 	movw	r0, #43532	; 0xaa0c
    3fcc:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3fd0:	f7ff f9ea 	bl	33a8 <mss_i2c_isr>
    NVIC_ClearPendingIRQ( I2C0_IRQn );
    3fd4:	f04f 000e 	mov.w	r0, #14
    3fd8:	f7fe fe0a 	bl	2bf0 <NVIC_ClearPendingIRQ>
}
    3fdc:	46bd      	mov	sp, r7
    3fde:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    3fe2:	4685      	mov	sp, r0
    3fe4:	4770      	bx	lr
    3fe6:	bf00      	nop

00003fe8 <I2C1_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void I2C1_IRQHandler( void )
#else
void I2C1_IRQHandler( void )
#endif
{
    3fe8:	4668      	mov	r0, sp
    3fea:	f020 0107 	bic.w	r1, r0, #7
    3fee:	468d      	mov	sp, r1
    3ff0:	b589      	push	{r0, r3, r7, lr}
    3ff2:	af00      	add	r7, sp, #0
    mss_i2c_isr( &g_mss_i2c1 );
    3ff4:	f64a 2080 	movw	r0, #43648	; 0xaa80
    3ff8:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3ffc:	f7ff f9d4 	bl	33a8 <mss_i2c_isr>
    NVIC_ClearPendingIRQ( I2C1_IRQn );
    4000:	f04f 0011 	mov.w	r0, #17
    4004:	f7fe fdf4 	bl	2bf0 <NVIC_ClearPendingIRQ>
}
    4008:	46bd      	mov	sp, r7
    400a:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    400e:	4685      	mov	sp, r0
    4010:	4770      	bx	lr
    4012:	bf00      	nop

00004014 <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
    4014:	b480      	push	{r7}
    4016:	b083      	sub	sp, #12
    4018:	af00      	add	r7, sp, #0
    401a:	4603      	mov	r3, r0
    401c:	80fb      	strh	r3, [r7, #6]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    401e:	f24e 1300 	movw	r3, #57600	; 0xe100
    4022:	f2ce 0300 	movt	r3, #57344	; 0xe000
    4026:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    402a:	ea4f 1252 	mov.w	r2, r2, lsr #5
    402e:	88f9      	ldrh	r1, [r7, #6]
    4030:	f001 011f 	and.w	r1, r1, #31
    4034:	f04f 0001 	mov.w	r0, #1
    4038:	fa00 f101 	lsl.w	r1, r0, r1
    403c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    4040:	f107 070c 	add.w	r7, r7, #12
    4044:	46bd      	mov	sp, r7
    4046:	bc80      	pop	{r7}
    4048:	4770      	bx	lr
    404a:	bf00      	nop

0000404c <NVIC_ClearPendingIRQ>:
 *
 * Clear the pending bit for the specified interrupt. 
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
    404c:	b480      	push	{r7}
    404e:	b083      	sub	sp, #12
    4050:	af00      	add	r7, sp, #0
    4052:	4603      	mov	r3, r0
    4054:	80fb      	strh	r3, [r7, #6]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    4056:	f24e 1300 	movw	r3, #57600	; 0xe100
    405a:	f2ce 0300 	movt	r3, #57344	; 0xe000
    405e:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    4062:	ea4f 1252 	mov.w	r2, r2, lsr #5
    4066:	88f9      	ldrh	r1, [r7, #6]
    4068:	f001 011f 	and.w	r1, r1, #31
    406c:	f04f 0001 	mov.w	r0, #1
    4070:	fa00 f101 	lsl.w	r1, r0, r1
    4074:	f102 0260 	add.w	r2, r2, #96	; 0x60
    4078:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    407c:	f107 070c 	add.w	r7, r7, #12
    4080:	46bd      	mov	sp, r7
    4082:	bc80      	pop	{r7}
    4084:	4770      	bx	lr
    4086:	bf00      	nop

00004088 <MSS_GPIO_init>:
/*-------------------------------------------------------------------------*//**
 * MSS_GPIO_init
 * See "mss_gpio.h" for details of how to use this function.
 */
void MSS_GPIO_init( void )
{
    4088:	b580      	push	{r7, lr}
    408a:	b082      	sub	sp, #8
    408c:	af00      	add	r7, sp, #0
    uint32_t i;
    
    /* reset MSS GPIO hardware */
    SYSREG->SOFT_RST_CR |= SYSREG_GPIO_SOFTRESET_MASK;
    408e:	f242 0300 	movw	r3, #8192	; 0x2000
    4092:	f2ce 0304 	movt	r3, #57348	; 0xe004
    4096:	f242 0200 	movw	r2, #8192	; 0x2000
    409a:	f2ce 0204 	movt	r2, #57348	; 0xe004
    409e:	6b12      	ldr	r2, [r2, #48]	; 0x30
    40a0:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    40a4:	631a      	str	r2, [r3, #48]	; 0x30
    /* Clear any previously pended MSS GPIO interrupt */
    for ( i = 0U; i < NB_OF_GPIO; ++i )
    40a6:	f04f 0300 	mov.w	r3, #0
    40aa:	607b      	str	r3, [r7, #4]
    40ac:	e00e      	b.n	40cc <MSS_GPIO_init+0x44>
    {
        NVIC_ClearPendingIRQ( g_gpio_irqn_lut[i] );
    40ae:	687a      	ldr	r2, [r7, #4]
    40b0:	f24b 0374 	movw	r3, #45172	; 0xb074
    40b4:	f2c0 0301 	movt	r3, #1
    40b8:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    40bc:	b21b      	sxth	r3, r3
    40be:	4618      	mov	r0, r3
    40c0:	f7ff ffc4 	bl	404c <NVIC_ClearPendingIRQ>
    uint32_t i;
    
    /* reset MSS GPIO hardware */
    SYSREG->SOFT_RST_CR |= SYSREG_GPIO_SOFTRESET_MASK;
    /* Clear any previously pended MSS GPIO interrupt */
    for ( i = 0U; i < NB_OF_GPIO; ++i )
    40c4:	687b      	ldr	r3, [r7, #4]
    40c6:	f103 0301 	add.w	r3, r3, #1
    40ca:	607b      	str	r3, [r7, #4]
    40cc:	687b      	ldr	r3, [r7, #4]
    40ce:	2b1f      	cmp	r3, #31
    40d0:	d9ed      	bls.n	40ae <MSS_GPIO_init+0x26>
    {
        NVIC_ClearPendingIRQ( g_gpio_irqn_lut[i] );
    }
    /* Take MSS GPIO hardware out of reset. */
    SYSREG->SOFT_RST_CR &= ~SYSREG_GPIO_SOFTRESET_MASK;
    40d2:	f242 0300 	movw	r3, #8192	; 0x2000
    40d6:	f2ce 0304 	movt	r3, #57348	; 0xe004
    40da:	f242 0200 	movw	r2, #8192	; 0x2000
    40de:	f2ce 0204 	movt	r2, #57348	; 0xe004
    40e2:	6b12      	ldr	r2, [r2, #48]	; 0x30
    40e4:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
    40e8:	631a      	str	r2, [r3, #48]	; 0x30
}
    40ea:	f107 0708 	add.w	r7, r7, #8
    40ee:	46bd      	mov	sp, r7
    40f0:	bd80      	pop	{r7, pc}
    40f2:	bf00      	nop

000040f4 <MSS_GPIO_config>:
void MSS_GPIO_config
(
    mss_gpio_id_t port_id,
    uint32_t config
)
{
    40f4:	b480      	push	{r7}
    40f6:	b085      	sub	sp, #20
    40f8:	af00      	add	r7, sp, #0
    40fa:	4603      	mov	r3, r0
    40fc:	6039      	str	r1, [r7, #0]
    40fe:	71fb      	strb	r3, [r7, #7]
    uint32_t gpio_idx = (uint32_t)port_id;
    4100:	79fb      	ldrb	r3, [r7, #7]
    4102:	60fb      	str	r3, [r7, #12]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
    4104:	68fb      	ldr	r3, [r7, #12]
    4106:	2b1f      	cmp	r3, #31
    4108:	d900      	bls.n	410c <MSS_GPIO_config+0x18>
    410a:	be00      	bkpt	0x0000

    if ( gpio_idx < NB_OF_GPIO )
    410c:	68fb      	ldr	r3, [r7, #12]
    410e:	2b1f      	cmp	r3, #31
    4110:	d808      	bhi.n	4124 <MSS_GPIO_config+0x30>
    {
        *(g_config_reg_lut[gpio_idx]) = config;
    4112:	68fa      	ldr	r2, [r7, #12]
    4114:	f64a 73f4 	movw	r3, #45044	; 0xaff4
    4118:	f2c0 0301 	movt	r3, #1
    411c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    4120:	683a      	ldr	r2, [r7, #0]
    4122:	601a      	str	r2, [r3, #0]
    }
}
    4124:	f107 0714 	add.w	r7, r7, #20
    4128:	46bd      	mov	sp, r7
    412a:	bc80      	pop	{r7}
    412c:	4770      	bx	lr
    412e:	bf00      	nop

00004130 <MSS_GPIO_set_output>:
void MSS_GPIO_set_output
(
    mss_gpio_id_t       port_id,
    uint8_t             value
)
{
    4130:	b480      	push	{r7}
    4132:	b085      	sub	sp, #20
    4134:	af00      	add	r7, sp, #0
    4136:	4602      	mov	r2, r0
    4138:	460b      	mov	r3, r1
    413a:	71fa      	strb	r2, [r7, #7]
    413c:	71bb      	strb	r3, [r7, #6]
    uint32_t gpio_idx = (uint32_t)port_id;
    413e:	79fb      	ldrb	r3, [r7, #7]
    4140:	60fb      	str	r3, [r7, #12]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
    4142:	68fb      	ldr	r3, [r7, #12]
    4144:	2b1f      	cmp	r3, #31
    4146:	d900      	bls.n	414a <MSS_GPIO_set_output+0x1a>
    4148:	be00      	bkpt	0x0000
    
    if ( gpio_idx < NB_OF_GPIO )
    414a:	68fb      	ldr	r3, [r7, #12]
    414c:	2b1f      	cmp	r3, #31
    414e:	d809      	bhi.n	4164 <MSS_GPIO_set_output+0x34>
    {
        GPIO_BITBAND->GPIO_OUT[gpio_idx] = (uint32_t)value;
    4150:	f240 0300 	movw	r3, #0
    4154:	f2c4 2326 	movt	r3, #16934	; 0x4226
    4158:	68fa      	ldr	r2, [r7, #12]
    415a:	79b9      	ldrb	r1, [r7, #6]
    415c:	f502 6288 	add.w	r2, r2, #1088	; 0x440
    4160:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }
}
    4164:	f107 0714 	add.w	r7, r7, #20
    4168:	46bd      	mov	sp, r7
    416a:	bc80      	pop	{r7}
    416c:	4770      	bx	lr
    416e:	bf00      	nop

00004170 <MSS_GPIO_drive_inout>:
void MSS_GPIO_drive_inout
(
    mss_gpio_id_t port_id,
    mss_gpio_inout_state_t inout_state
)
{
    4170:	b480      	push	{r7}
    4172:	b087      	sub	sp, #28
    4174:	af00      	add	r7, sp, #0
    4176:	4602      	mov	r2, r0
    4178:	460b      	mov	r3, r1
    417a:	71fa      	strb	r2, [r7, #7]
    417c:	71bb      	strb	r3, [r7, #6]
    uint32_t outputs_state;
    uint32_t config;
    uint32_t gpio_idx = (uint32_t)port_id;
    417e:	79fb      	ldrb	r3, [r7, #7]
    4180:	617b      	str	r3, [r7, #20]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
    4182:	697b      	ldr	r3, [r7, #20]
    4184:	2b1f      	cmp	r3, #31
    4186:	d900      	bls.n	418a <MSS_GPIO_drive_inout+0x1a>
    4188:	be00      	bkpt	0x0000
    
    if ( gpio_idx < NB_OF_GPIO )
    418a:	697b      	ldr	r3, [r7, #20]
    418c:	2b1f      	cmp	r3, #31
    418e:	d87d      	bhi.n	428c <MSS_GPIO_drive_inout+0x11c>
    {
        switch( inout_state )
    4190:	79bb      	ldrb	r3, [r7, #6]
    4192:	2b01      	cmp	r3, #1
    4194:	d004      	beq.n	41a0 <MSS_GPIO_drive_inout+0x30>
    4196:	2b02      	cmp	r3, #2
    4198:	d060      	beq.n	425c <MSS_GPIO_drive_inout+0xec>
    419a:	2b00      	cmp	r3, #0
    419c:	d02e      	beq.n	41fc <MSS_GPIO_drive_inout+0x8c>
    419e:	e074      	b.n	428a <MSS_GPIO_drive_inout+0x11a>
        {
        case MSS_GPIO_DRIVE_HIGH:
            /* Set output high */
            outputs_state = GPIO->GPIO_OUT;
    41a0:	f243 0300 	movw	r3, #12288	; 0x3000
    41a4:	f2c4 0301 	movt	r3, #16385	; 0x4001
    41a8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    41ac:	60fb      	str	r3, [r7, #12]
            outputs_state |= (uint32_t)1 << gpio_idx;
    41ae:	697b      	ldr	r3, [r7, #20]
    41b0:	f04f 0201 	mov.w	r2, #1
    41b4:	fa02 f303 	lsl.w	r3, r2, r3
    41b8:	68fa      	ldr	r2, [r7, #12]
    41ba:	ea42 0303 	orr.w	r3, r2, r3
    41be:	60fb      	str	r3, [r7, #12]
            GPIO->GPIO_OUT = outputs_state;
    41c0:	f243 0300 	movw	r3, #12288	; 0x3000
    41c4:	f2c4 0301 	movt	r3, #16385	; 0x4001
    41c8:	68fa      	ldr	r2, [r7, #12]
    41ca:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
            /* Enable output buffer */
            config = *(g_config_reg_lut[gpio_idx]);
    41ce:	697a      	ldr	r2, [r7, #20]
    41d0:	f64a 73f4 	movw	r3, #45044	; 0xaff4
    41d4:	f2c0 0301 	movt	r3, #1
    41d8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    41dc:	681b      	ldr	r3, [r3, #0]
    41de:	613b      	str	r3, [r7, #16]
            config |= OUTPUT_BUFFER_ENABLE_MASK;
    41e0:	693b      	ldr	r3, [r7, #16]
    41e2:	f043 0304 	orr.w	r3, r3, #4
    41e6:	613b      	str	r3, [r7, #16]
            *(g_config_reg_lut[gpio_idx]) = config;
    41e8:	697a      	ldr	r2, [r7, #20]
    41ea:	f64a 73f4 	movw	r3, #45044	; 0xaff4
    41ee:	f2c0 0301 	movt	r3, #1
    41f2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    41f6:	693a      	ldr	r2, [r7, #16]
    41f8:	601a      	str	r2, [r3, #0]
            break;
    41fa:	e047      	b.n	428c <MSS_GPIO_drive_inout+0x11c>
            
        case MSS_GPIO_DRIVE_LOW:
            /* Set output low */
            outputs_state = GPIO->GPIO_OUT;
    41fc:	f243 0300 	movw	r3, #12288	; 0x3000
    4200:	f2c4 0301 	movt	r3, #16385	; 0x4001
    4204:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    4208:	60fb      	str	r3, [r7, #12]
            outputs_state &= ~((uint32_t)((uint32_t)1 << gpio_idx));
    420a:	697b      	ldr	r3, [r7, #20]
    420c:	f04f 0201 	mov.w	r2, #1
    4210:	fa02 f303 	lsl.w	r3, r2, r3
    4214:	ea6f 0303 	mvn.w	r3, r3
    4218:	68fa      	ldr	r2, [r7, #12]
    421a:	ea02 0303 	and.w	r3, r2, r3
    421e:	60fb      	str	r3, [r7, #12]
            GPIO->GPIO_OUT = outputs_state;
    4220:	f243 0300 	movw	r3, #12288	; 0x3000
    4224:	f2c4 0301 	movt	r3, #16385	; 0x4001
    4228:	68fa      	ldr	r2, [r7, #12]
    422a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
            /* Enable output buffer */
            config = *(g_config_reg_lut[gpio_idx]);
    422e:	697a      	ldr	r2, [r7, #20]
    4230:	f64a 73f4 	movw	r3, #45044	; 0xaff4
    4234:	f2c0 0301 	movt	r3, #1
    4238:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    423c:	681b      	ldr	r3, [r3, #0]
    423e:	613b      	str	r3, [r7, #16]
            config |= OUTPUT_BUFFER_ENABLE_MASK;
    4240:	693b      	ldr	r3, [r7, #16]
    4242:	f043 0304 	orr.w	r3, r3, #4
    4246:	613b      	str	r3, [r7, #16]
            *(g_config_reg_lut[gpio_idx]) = config;
    4248:	697a      	ldr	r2, [r7, #20]
    424a:	f64a 73f4 	movw	r3, #45044	; 0xaff4
    424e:	f2c0 0301 	movt	r3, #1
    4252:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    4256:	693a      	ldr	r2, [r7, #16]
    4258:	601a      	str	r2, [r3, #0]
            break;
    425a:	e017      	b.n	428c <MSS_GPIO_drive_inout+0x11c>
            
        case MSS_GPIO_HIGH_Z:
            /* Disable output buffer */
            config = *(g_config_reg_lut[gpio_idx]);
    425c:	697a      	ldr	r2, [r7, #20]
    425e:	f64a 73f4 	movw	r3, #45044	; 0xaff4
    4262:	f2c0 0301 	movt	r3, #1
    4266:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    426a:	681b      	ldr	r3, [r3, #0]
    426c:	613b      	str	r3, [r7, #16]
            config &= ~OUTPUT_BUFFER_ENABLE_MASK;
    426e:	693b      	ldr	r3, [r7, #16]
    4270:	f023 0304 	bic.w	r3, r3, #4
    4274:	613b      	str	r3, [r7, #16]
            *(g_config_reg_lut[gpio_idx]) = config;
    4276:	697a      	ldr	r2, [r7, #20]
    4278:	f64a 73f4 	movw	r3, #45044	; 0xaff4
    427c:	f2c0 0301 	movt	r3, #1
    4280:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    4284:	693a      	ldr	r2, [r7, #16]
    4286:	601a      	str	r2, [r3, #0]
            break;
    4288:	e000      	b.n	428c <MSS_GPIO_drive_inout+0x11c>
            
        default:
            ASSERT(0);
    428a:	be00      	bkpt	0x0000
            break;
        }
    }
}
    428c:	f107 071c 	add.w	r7, r7, #28
    4290:	46bd      	mov	sp, r7
    4292:	bc80      	pop	{r7}
    4294:	4770      	bx	lr
    4296:	bf00      	nop

00004298 <MSS_GPIO_enable_irq>:
 */
void MSS_GPIO_enable_irq
(
    mss_gpio_id_t port_id
)
{
    4298:	b580      	push	{r7, lr}
    429a:	b084      	sub	sp, #16
    429c:	af00      	add	r7, sp, #0
    429e:	4603      	mov	r3, r0
    42a0:	71fb      	strb	r3, [r7, #7]
    uint32_t cfg_value;
    uint32_t gpio_idx = (uint32_t)port_id;
    42a2:	79fb      	ldrb	r3, [r7, #7]
    42a4:	60fb      	str	r3, [r7, #12]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
    42a6:	68fb      	ldr	r3, [r7, #12]
    42a8:	2b1f      	cmp	r3, #31
    42aa:	d900      	bls.n	42ae <MSS_GPIO_enable_irq+0x16>
    42ac:	be00      	bkpt	0x0000
    
    if ( gpio_idx < NB_OF_GPIO )
    42ae:	68fb      	ldr	r3, [r7, #12]
    42b0:	2b1f      	cmp	r3, #31
    42b2:	d81e      	bhi.n	42f2 <MSS_GPIO_enable_irq+0x5a>
    {
        cfg_value = *(g_config_reg_lut[gpio_idx]);
    42b4:	68fa      	ldr	r2, [r7, #12]
    42b6:	f64a 73f4 	movw	r3, #45044	; 0xaff4
    42ba:	f2c0 0301 	movt	r3, #1
    42be:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    42c2:	681b      	ldr	r3, [r3, #0]
    42c4:	60bb      	str	r3, [r7, #8]
        *(g_config_reg_lut[gpio_idx]) = (cfg_value | GPIO_INT_ENABLE_MASK);
    42c6:	68fa      	ldr	r2, [r7, #12]
    42c8:	f64a 73f4 	movw	r3, #45044	; 0xaff4
    42cc:	f2c0 0301 	movt	r3, #1
    42d0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    42d4:	68ba      	ldr	r2, [r7, #8]
    42d6:	f042 0208 	orr.w	r2, r2, #8
    42da:	601a      	str	r2, [r3, #0]
        NVIC_EnableIRQ( g_gpio_irqn_lut[gpio_idx] );
    42dc:	68fa      	ldr	r2, [r7, #12]
    42de:	f24b 0374 	movw	r3, #45172	; 0xb074
    42e2:	f2c0 0301 	movt	r3, #1
    42e6:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    42ea:	b21b      	sxth	r3, r3
    42ec:	4618      	mov	r0, r3
    42ee:	f7ff fe91 	bl	4014 <NVIC_EnableIRQ>
    }
}
    42f2:	f107 0710 	add.w	r7, r7, #16
    42f6:	46bd      	mov	sp, r7
    42f8:	bd80      	pop	{r7, pc}
    42fa:	bf00      	nop

000042fc <MSS_GPIO_disable_irq>:
 */
void MSS_GPIO_disable_irq
(
    mss_gpio_id_t port_id
)
{
    42fc:	b480      	push	{r7}
    42fe:	b085      	sub	sp, #20
    4300:	af00      	add	r7, sp, #0
    4302:	4603      	mov	r3, r0
    4304:	71fb      	strb	r3, [r7, #7]
    uint32_t cfg_value;
    uint32_t gpio_idx = (uint32_t)port_id;
    4306:	79fb      	ldrb	r3, [r7, #7]
    4308:	60fb      	str	r3, [r7, #12]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
    430a:	68fb      	ldr	r3, [r7, #12]
    430c:	2b1f      	cmp	r3, #31
    430e:	d900      	bls.n	4312 <MSS_GPIO_disable_irq+0x16>
    4310:	be00      	bkpt	0x0000

    if ( gpio_idx < NB_OF_GPIO )
    4312:	68fb      	ldr	r3, [r7, #12]
    4314:	2b1f      	cmp	r3, #31
    4316:	d813      	bhi.n	4340 <MSS_GPIO_disable_irq+0x44>
    {
        cfg_value = *(g_config_reg_lut[gpio_idx]);
    4318:	68fa      	ldr	r2, [r7, #12]
    431a:	f64a 73f4 	movw	r3, #45044	; 0xaff4
    431e:	f2c0 0301 	movt	r3, #1
    4322:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    4326:	681b      	ldr	r3, [r3, #0]
    4328:	60bb      	str	r3, [r7, #8]
        *(g_config_reg_lut[gpio_idx]) = (cfg_value & ~GPIO_INT_ENABLE_MASK);
    432a:	68fa      	ldr	r2, [r7, #12]
    432c:	f64a 73f4 	movw	r3, #45044	; 0xaff4
    4330:	f2c0 0301 	movt	r3, #1
    4334:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    4338:	68ba      	ldr	r2, [r7, #8]
    433a:	f022 0208 	bic.w	r2, r2, #8
    433e:	601a      	str	r2, [r3, #0]
    }
}
    4340:	f107 0714 	add.w	r7, r7, #20
    4344:	46bd      	mov	sp, r7
    4346:	bc80      	pop	{r7}
    4348:	4770      	bx	lr
    434a:	bf00      	nop

0000434c <MSS_GPIO_clear_irq>:
 */
void MSS_GPIO_clear_irq
(
    mss_gpio_id_t port_id
)
{
    434c:	b580      	push	{r7, lr}
    434e:	b084      	sub	sp, #16
    4350:	af00      	add	r7, sp, #0
    4352:	4603      	mov	r3, r0
    4354:	71fb      	strb	r3, [r7, #7]
    uint32_t gpio_idx = (uint32_t)port_id;
    4356:	79fb      	ldrb	r3, [r7, #7]
    4358:	60fb      	str	r3, [r7, #12]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
    435a:	68fb      	ldr	r3, [r7, #12]
    435c:	2b1f      	cmp	r3, #31
    435e:	d900      	bls.n	4362 <MSS_GPIO_clear_irq+0x16>
    4360:	be00      	bkpt	0x0000
    
    if ( gpio_idx < NB_OF_GPIO )
    4362:	68fb      	ldr	r3, [r7, #12]
    4364:	2b1f      	cmp	r3, #31
    4366:	d815      	bhi.n	4394 <MSS_GPIO_clear_irq+0x48>
    {
        GPIO->GPIO_IRQ = ((uint32_t)1) << gpio_idx;
    4368:	f243 0300 	movw	r3, #12288	; 0x3000
    436c:	f2c4 0301 	movt	r3, #16385	; 0x4001
    4370:	68fa      	ldr	r2, [r7, #12]
    4372:	f04f 0101 	mov.w	r1, #1
    4376:	fa01 f202 	lsl.w	r2, r1, r2
    437a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
        NVIC_ClearPendingIRQ( g_gpio_irqn_lut[gpio_idx] );
    437e:	68fa      	ldr	r2, [r7, #12]
    4380:	f24b 0374 	movw	r3, #45172	; 0xb074
    4384:	f2c0 0301 	movt	r3, #1
    4388:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    438c:	b21b      	sxth	r3, r3
    438e:	4618      	mov	r0, r3
    4390:	f7ff fe5c 	bl	404c <NVIC_ClearPendingIRQ>
    }
}
    4394:	f107 0710 	add.w	r7, r7, #16
    4398:	46bd      	mov	sp, r7
    439a:	bd80      	pop	{r7, pc}

0000439c <mss_mac_crc32>:
(
    uint32_t value,
    const uint8_t *data,
    uint32_t data_length
)
{
    439c:	b480      	push	{r7}
    439e:	b087      	sub	sp, #28
    43a0:	af00      	add	r7, sp, #0
    43a2:	60f8      	str	r0, [r7, #12]
    43a4:	60b9      	str	r1, [r7, #8]
    43a6:	607a      	str	r2, [r7, #4]
  uint32_t a;
  
  for(a=0; a<data_length; a++) {
    43a8:	f04f 0300 	mov.w	r3, #0
    43ac:	617b      	str	r3, [r7, #20]
    43ae:	e019      	b.n	43e4 <mss_mac_crc32+0x48>
	value = crc32_table[(value ^ data[a]) & 0xff] ^ (value >> 8);
    43b0:	68ba      	ldr	r2, [r7, #8]
    43b2:	697b      	ldr	r3, [r7, #20]
    43b4:	4413      	add	r3, r2
    43b6:	781b      	ldrb	r3, [r3, #0]
    43b8:	461a      	mov	r2, r3
    43ba:	68fb      	ldr	r3, [r7, #12]
    43bc:	ea82 0303 	eor.w	r3, r2, r3
    43c0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    43c4:	f24b 03b4 	movw	r3, #45236	; 0xb0b4
    43c8:	f2c0 0301 	movt	r3, #1
    43cc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    43d0:	68fb      	ldr	r3, [r7, #12]
    43d2:	ea4f 2313 	mov.w	r3, r3, lsr #8
    43d6:	ea82 0303 	eor.w	r3, r2, r3
    43da:	60fb      	str	r3, [r7, #12]
    uint32_t data_length
)
{
  uint32_t a;
  
  for(a=0; a<data_length; a++) {
    43dc:	697b      	ldr	r3, [r7, #20]
    43de:	f103 0301 	add.w	r3, r3, #1
    43e2:	617b      	str	r3, [r7, #20]
    43e4:	697a      	ldr	r2, [r7, #20]
    43e6:	687b      	ldr	r3, [r7, #4]
    43e8:	429a      	cmp	r2, r3
    43ea:	d3e1      	bcc.n	43b0 <mss_mac_crc32+0x14>
	value = crc32_table[(value ^ data[a]) & 0xff] ^ (value >> 8);
  }
  
  return value;
    43ec:	68fb      	ldr	r3, [r7, #12]
}
    43ee:	4618      	mov	r0, r3
    43f0:	f107 071c 	add.w	r7, r7, #28
    43f4:	46bd      	mov	sp, r7
    43f6:	bc80      	pop	{r7}
    43f8:	4770      	bx	lr
    43fa:	bf00      	nop

000043fc <mss_ethernet_crc>:
mss_ethernet_crc
(
    const uint8_t *data,
    uint32_t data_length
)
{
    43fc:	b580      	push	{r7, lr}
    43fe:	b082      	sub	sp, #8
    4400:	af00      	add	r7, sp, #0
    4402:	6078      	str	r0, [r7, #4]
    4404:	6039      	str	r1, [r7, #0]
	return mss_mac_crc32( 0xffffffffUL, data, data_length );
    4406:	f04f 30ff 	mov.w	r0, #4294967295
    440a:	6879      	ldr	r1, [r7, #4]
    440c:	683a      	ldr	r2, [r7, #0]
    440e:	f7ff ffc5 	bl	439c <mss_mac_crc32>
    4412:	4603      	mov	r3, r0
}
    4414:	4618      	mov	r0, r3
    4416:	f107 0708 	add.w	r7, r7, #8
    441a:	46bd      	mov	sp, r7
    441c:	bd80      	pop	{r7, pc}
    441e:	bf00      	nop

00004420 <MSS_MAC_init>:
void
MSS_MAC_init
(
	uint8_t phy_address
)
{
    4420:	b580      	push	{r7, lr}
    4422:	b08a      	sub	sp, #40	; 0x28
    4424:	af00      	add	r7, sp, #0
    4426:	4603      	mov	r3, r0
    4428:	71fb      	strb	r3, [r7, #7]
    const uint8_t mac_address[6] = { DEFAULT_MAC_ADDRESS };
    442a:	f24b 6204 	movw	r2, #46596	; 0xb604
    442e:	f2c0 0201 	movt	r2, #1
    4432:	f107 030c 	add.w	r3, r7, #12
    4436:	e892 0003 	ldmia.w	r2, {r0, r1}
    443a:	6018      	str	r0, [r3, #0]
    443c:	f103 0304 	add.w	r3, r3, #4
    4440:	8019      	strh	r1, [r3, #0]
    int32_t a;

	/* To start with all buffers are free. */
	for( a = 0; a < macNUM_BUFFERS; a++ )
    4442:	f04f 0300 	mov.w	r3, #0
    4446:	617b      	str	r3, [r7, #20]
    4448:	e00b      	b.n	4462 <MSS_MAC_init+0x42>
	{
		ucMACBufferInUse[ a ] = pdFALSE;
    444a:	697a      	ldr	r2, [r7, #20]
    444c:	f642 7358 	movw	r3, #12120	; 0x2f58
    4450:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4454:	f04f 0100 	mov.w	r1, #0
    4458:	5499      	strb	r1, [r3, r2]
{
    const uint8_t mac_address[6] = { DEFAULT_MAC_ADDRESS };
    int32_t a;

	/* To start with all buffers are free. */
	for( a = 0; a < macNUM_BUFFERS; a++ )
    445a:	697b      	ldr	r3, [r7, #20]
    445c:	f103 0301 	add.w	r3, r3, #1
    4460:	617b      	str	r3, [r7, #20]
    4462:	697b      	ldr	r3, [r7, #20]
    4464:	2b06      	cmp	r3, #6
    4466:	ddf0      	ble.n	444a <MSS_MAC_init+0x2a>
	{
		ucMACBufferInUse[ a ] = pdFALSE;
	}
	
    /* Try to reset chip */
    MAC_BITBAND->CSR0_SWR = 1u;
    4468:	f240 0300 	movw	r3, #0
    446c:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4470:	f04f 0201 	mov.w	r2, #1
    4474:	601a      	str	r2, [r3, #0]

    do
    {
    	vTaskDelay( 10 );
    4476:	f04f 000a 	mov.w	r0, #10
    447a:	f00c fc03 	bl	10c84 <vTaskDelay>
    } while ( 1u == MAC_BITBAND->CSR0_SWR );
    447e:	f240 0300 	movw	r3, #0
    4482:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4486:	681b      	ldr	r3, [r3, #0]
    4488:	2b01      	cmp	r3, #1
    448a:	d0f4      	beq.n	4476 <MSS_MAC_init+0x56>

    /* Check reset values of some registers to constrol
     * base address validity */
    configASSERT( MAC->CSR0 == 0xFE000000uL );
    448c:	f243 0300 	movw	r3, #12288	; 0x3000
    4490:	f2c4 0300 	movt	r3, #16384	; 0x4000
    4494:	681b      	ldr	r3, [r3, #0]
    4496:	f1b3 4f7e 	cmp.w	r3, #4261412864	; 0xfe000000
    449a:	d009      	beq.n	44b0 <MSS_MAC_init+0x90>
    449c:	f04f 0328 	mov.w	r3, #40	; 0x28
    44a0:	f383 8811 	msr	BASEPRI, r3
    44a4:	f3bf 8f6f 	isb	sy
    44a8:	f3bf 8f4f 	dsb	sy
    44ac:	61bb      	str	r3, [r7, #24]
    44ae:	e7fe      	b.n	44ae <MSS_MAC_init+0x8e>
    configASSERT( MAC->CSR5 == 0xF0000000uL );
    44b0:	f243 0300 	movw	r3, #12288	; 0x3000
    44b4:	f2c4 0300 	movt	r3, #16384	; 0x4000
    44b8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    44ba:	f1b3 4f70 	cmp.w	r3, #4026531840	; 0xf0000000
    44be:	d009      	beq.n	44d4 <MSS_MAC_init+0xb4>
    44c0:	f04f 0328 	mov.w	r3, #40	; 0x28
    44c4:	f383 8811 	msr	BASEPRI, r3
    44c8:	f3bf 8f6f 	isb	sy
    44cc:	f3bf 8f4f 	dsb	sy
    44d0:	61fb      	str	r3, [r7, #28]
    44d2:	e7fe      	b.n	44d2 <MSS_MAC_init+0xb2>
    configASSERT( MAC->CSR6 == 0x32000040uL );
    44d4:	f243 0300 	movw	r3, #12288	; 0x3000
    44d8:	f2c4 0300 	movt	r3, #16384	; 0x4000
    44dc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    44de:	f240 0340 	movw	r3, #64	; 0x40
    44e2:	f2c3 2300 	movt	r3, #12800	; 0x3200
    44e6:	429a      	cmp	r2, r3
    44e8:	d009      	beq.n	44fe <MSS_MAC_init+0xde>
    44ea:	f04f 0328 	mov.w	r3, #40	; 0x28
    44ee:	f383 8811 	msr	BASEPRI, r3
    44f2:	f3bf 8f6f 	isb	sy
    44f6:	f3bf 8f4f 	dsb	sy
    44fa:	623b      	str	r3, [r7, #32]
    44fc:	e7fe      	b.n	44fc <MSS_MAC_init+0xdc>

    /* Instance setup */
    MAC_memset_All( &g_mss_mac, 0u );
    44fe:	f64a 20f4 	movw	r0, #43764	; 0xaaf4
    4502:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4506:	f04f 0100 	mov.w	r1, #0
    450a:	f002 f857 	bl	65bc <MAC_memset_All>

    g_mss_mac.base_address = MAC_BASE;
    450e:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4512:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4516:	f243 0200 	movw	r2, #12288	; 0x3000
    451a:	f2c4 0200 	movt	r2, #16384	; 0x4000
    451e:	601a      	str	r2, [r3, #0]
    g_mss_mac.phy_address = phy_address;
    4520:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4524:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4528:	79fa      	ldrb	r2, [r7, #7]
    452a:	f883 20e8 	strb.w	r2, [r3, #232]	; 0xe8

    for( a=0; a<RX_RING_SIZE; a++ )
    452e:	f04f 0300 	mov.w	r3, #0
    4532:	617b      	str	r3, [r7, #20]
    4534:	e03b      	b.n	45ae <MSS_MAC_init+0x18e>
    {
        /* Give the ownership to the MAC */
        g_mss_mac.rx_descriptors[a].descriptor_0 = RDES0_OWN;
    4536:	697a      	ldr	r2, [r7, #20]
    4538:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    453c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4540:	ea4f 1202 	mov.w	r2, r2, lsl #4
    4544:	4413      	add	r3, r2
    4546:	f103 0398 	add.w	r3, r3, #152	; 0x98
    454a:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    454e:	601a      	str	r2, [r3, #0]
        g_mss_mac.rx_descriptors[a].descriptor_1 = (MSS_RX_BUFF_SIZE << RDES1_RBS1_OFFSET);
    4550:	697a      	ldr	r2, [r7, #20]
    4552:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4556:	f2c2 0300 	movt	r3, #8192	; 0x2000
    455a:	ea4f 1202 	mov.w	r2, r2, lsl #4
    455e:	4413      	add	r3, r2
    4560:	f103 039c 	add.w	r3, r3, #156	; 0x9c
    4564:	f44f 62be 	mov.w	r2, #1520	; 0x5f0
    4568:	601a      	str	r2, [r3, #0]
		
		/* Allocate a buffer to the descriptor, then mark the buffer as in use
		(not free). */
        g_mss_mac.rx_descriptors[a].buffer_1 = ( unsigned long ) &( xMACBuffers.ucBuffer[ a ][ 0 ] );
    456a:	6979      	ldr	r1, [r7, #20]
    456c:	f240 63a8 	movw	r3, #1704	; 0x6a8
    4570:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4574:	697a      	ldr	r2, [r7, #20]
    4576:	f44f 60ba 	mov.w	r0, #1488	; 0x5d0
    457a:	fb00 f202 	mul.w	r2, r0, r2
    457e:	4413      	add	r3, r2
    4580:	461a      	mov	r2, r3
    4582:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4586:	f2c2 0300 	movt	r3, #8192	; 0x2000
    458a:	f101 010a 	add.w	r1, r1, #10
    458e:	ea4f 1101 	mov.w	r1, r1, lsl #4
    4592:	440b      	add	r3, r1
    4594:	601a      	str	r2, [r3, #0]
		ucMACBufferInUse[ a ] = pdTRUE;
    4596:	697a      	ldr	r2, [r7, #20]
    4598:	f642 7358 	movw	r3, #12120	; 0x2f58
    459c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    45a0:	f04f 0101 	mov.w	r1, #1
    45a4:	5499      	strb	r1, [r3, r2]
    MAC_memset_All( &g_mss_mac, 0u );

    g_mss_mac.base_address = MAC_BASE;
    g_mss_mac.phy_address = phy_address;

    for( a=0; a<RX_RING_SIZE; a++ )
    45a6:	697b      	ldr	r3, [r7, #20]
    45a8:	f103 0301 	add.w	r3, r3, #1
    45ac:	617b      	str	r3, [r7, #20]
    45ae:	697b      	ldr	r3, [r7, #20]
    45b0:	2b04      	cmp	r3, #4
    45b2:	ddc0      	ble.n	4536 <MSS_MAC_init+0x116>
		/* Allocate a buffer to the descriptor, then mark the buffer as in use
		(not free). */
        g_mss_mac.rx_descriptors[a].buffer_1 = ( unsigned long ) &( xMACBuffers.ucBuffer[ a ][ 0 ] );
		ucMACBufferInUse[ a ] = pdTRUE;
    }
    g_mss_mac.rx_descriptors[RX_RING_SIZE-1].descriptor_1 |= RDES1_RER;
    45b4:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    45b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    45bc:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
    45c0:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
    45c4:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    45c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    45cc:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc

    for( a = 0; a < TX_RING_SIZE; a++ )
    45d0:	f04f 0300 	mov.w	r3, #0
    45d4:	617b      	str	r3, [r7, #20]
    45d6:	e010      	b.n	45fa <MSS_MAC_init+0x1da>
    {
		/* Buffers only get allocated to the Tx buffers when something is
		actually tranmitted. */
        g_mss_mac.tx_descriptors[a].buffer_1 = ( unsigned long ) NULL;
    45d8:	697a      	ldr	r2, [r7, #20]
    45da:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    45de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    45e2:	ea4f 1202 	mov.w	r2, r2, lsl #4
    45e6:	4413      	add	r3, r2
    45e8:	f103 037c 	add.w	r3, r3, #124	; 0x7c
    45ec:	f04f 0200 	mov.w	r2, #0
    45f0:	601a      	str	r2, [r3, #0]
        g_mss_mac.rx_descriptors[a].buffer_1 = ( unsigned long ) &( xMACBuffers.ucBuffer[ a ][ 0 ] );
		ucMACBufferInUse[ a ] = pdTRUE;
    }
    g_mss_mac.rx_descriptors[RX_RING_SIZE-1].descriptor_1 |= RDES1_RER;

    for( a = 0; a < TX_RING_SIZE; a++ )
    45f2:	697b      	ldr	r3, [r7, #20]
    45f4:	f103 0301 	add.w	r3, r3, #1
    45f8:	617b      	str	r3, [r7, #20]
    45fa:	697b      	ldr	r3, [r7, #20]
    45fc:	2b01      	cmp	r3, #1
    45fe:	ddeb      	ble.n	45d8 <MSS_MAC_init+0x1b8>
    {
		/* Buffers only get allocated to the Tx buffers when something is
		actually tranmitted. */
        g_mss_mac.tx_descriptors[a].buffer_1 = ( unsigned long ) NULL;
    }
    g_mss_mac.tx_descriptors[TX_RING_SIZE - 1].descriptor_1 |= TDES1_TER;
    4600:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4604:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4608:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    460c:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
    4610:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4614:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4618:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

    /* Configurable settings */
    MAC_BITBAND->CSR0_DBO = DESCRIPTOR_BYTE_ORDERING_MODE;
    461c:	f240 0300 	movw	r3, #0
    4620:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4624:	f04f 0200 	mov.w	r2, #0
    4628:	651a      	str	r2, [r3, #80]	; 0x50
    MAC->CSR0 = (MAC->CSR0 & ~CSR0_PBL_MASK) | ((uint32_t)PROGRAMMABLE_BURST_LENGTH << CSR0_PBL_SHIFT);
    462a:	f243 0300 	movw	r3, #12288	; 0x3000
    462e:	f2c4 0300 	movt	r3, #16384	; 0x4000
    4632:	f243 0200 	movw	r2, #12288	; 0x3000
    4636:	f2c4 0200 	movt	r2, #16384	; 0x4000
    463a:	6812      	ldr	r2, [r2, #0]
    463c:	f422 527c 	bic.w	r2, r2, #16128	; 0x3f00
    4640:	601a      	str	r2, [r3, #0]
    MAC_BITBAND->CSR0_BLE = BUFFER_BYTE_ORDERING_MODE;
    4642:	f240 0300 	movw	r3, #0
    4646:	f2c4 2306 	movt	r3, #16902	; 0x4206
    464a:	f04f 0200 	mov.w	r2, #0
    464e:	61da      	str	r2, [r3, #28]
    MAC_BITBAND->CSR0_BAR = (uint32_t)BUS_ARBITRATION_SCHEME;
    4650:	f240 0300 	movw	r3, #0
    4654:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4658:	f04f 0200 	mov.w	r2, #0
    465c:	605a      	str	r2, [r3, #4]

    /* Fixed settings */
    /* No space between descriptors */
    MAC->CSR0 = MAC->CSR0 &~ CSR0_DSL_MASK;
    465e:	f243 0300 	movw	r3, #12288	; 0x3000
    4662:	f2c4 0300 	movt	r3, #16384	; 0x4000
    4666:	f243 0200 	movw	r2, #12288	; 0x3000
    466a:	f2c4 0200 	movt	r2, #16384	; 0x4000
    466e:	6812      	ldr	r2, [r2, #0]
    4670:	f022 027c 	bic.w	r2, r2, #124	; 0x7c
    4674:	601a      	str	r2, [r3, #0]
    /* General-purpose timer works in continuous mode */
    MAC_BITBAND->CSR11_CON = 1u;
    4676:	f240 0300 	movw	r3, #0
    467a:	f2c4 2306 	movt	r3, #16902	; 0x4206
    467e:	f04f 0201 	mov.w	r2, #1
    4682:	f8c3 2b40 	str.w	r2, [r3, #2880]	; 0xb40
    /* Start general-purpose */
    MAC->CSR11 =  (MAC->CSR11 & ~CSR11_TIM_MASK) | (0x0000FFFFuL << CSR11_TIM_SHIFT);
    4686:	f243 0300 	movw	r3, #12288	; 0x3000
    468a:	f2c4 0300 	movt	r3, #16384	; 0x4000
    468e:	f243 0200 	movw	r2, #12288	; 0x3000
    4692:	f2c4 0200 	movt	r2, #16384	; 0x4000
    4696:	6d92      	ldr	r2, [r2, #88]	; 0x58
    4698:	ea6f 4212 	mvn.w	r2, r2, lsr #16
    469c:	ea6f 4202 	mvn.w	r2, r2, lsl #16
    46a0:	659a      	str	r2, [r3, #88]	; 0x58

	/* Ensure promiscous mode is off (it should be by default anyway). */
	MAC_BITBAND->CSR6_PR = 0;
    46a2:	f240 0300 	movw	r3, #0
    46a6:	f2c4 2306 	movt	r3, #16902	; 0x4206
    46aa:	f04f 0200 	mov.w	r2, #0
    46ae:	f8c3 2618 	str.w	r2, [r3, #1560]	; 0x618
	
	/* Perfect filter. */
	MAC_BITBAND->CSR6_HP = 1;
    46b2:	f240 0300 	movw	r3, #0
    46b6:	f2c4 2306 	movt	r3, #16902	; 0x4206
    46ba:	f04f 0201 	mov.w	r2, #1
    46be:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
	
	/* Pass multcast. */
	MAC_BITBAND->CSR6_PM = 1;
    46c2:	f240 0300 	movw	r3, #0
    46c6:	f2c4 2306 	movt	r3, #16902	; 0x4206
    46ca:	f04f 0201 	mov.w	r2, #1
    46ce:	f8c3 261c 	str.w	r2, [r3, #1564]	; 0x61c
	
    /* Set descriptors */
    MAC->CSR3 = (uint32_t)&(g_mss_mac.rx_descriptors[0].descriptor_0);
    46d2:	f243 0300 	movw	r3, #12288	; 0x3000
    46d6:	f2c4 0300 	movt	r3, #16384	; 0x4000
    46da:	4a24      	ldr	r2, [pc, #144]	; (476c <MSS_MAC_init+0x34c>)
    46dc:	619a      	str	r2, [r3, #24]
    MAC->CSR4 = (uint32_t)&(g_mss_mac.tx_descriptors[0].descriptor_0);
    46de:	f243 0300 	movw	r3, #12288	; 0x3000
    46e2:	f2c4 0300 	movt	r3, #16384	; 0x4000
    46e6:	4a22      	ldr	r2, [pc, #136]	; (4770 <MSS_MAC_init+0x350>)
    46e8:	621a      	str	r2, [r3, #32]

	/* enable normal interrupts */
    MAC_BITBAND->CSR7_NIE = 1u;
    46ea:	f240 0300 	movw	r3, #0
    46ee:	f2c4 2306 	movt	r3, #16902	; 0x4206
    46f2:	f04f 0201 	mov.w	r2, #1
    46f6:	f8c3 2740 	str.w	r2, [r3, #1856]	; 0x740

    /* Set default MAC address and reset mac filters */
   	MAC_memcpy( g_mss_mac.mac_address, mac_address, 6u );
    46fa:	f107 030c 	add.w	r3, r7, #12
    46fe:	481d      	ldr	r0, [pc, #116]	; (4774 <MSS_MAC_init+0x354>)
    4700:	4619      	mov	r1, r3
    4702:	f04f 0206 	mov.w	r2, #6
    4706:	f002 f97d 	bl	6a04 <MAC_memcpy>
 	MSS_MAC_set_mac_address((uint8_t *)mac_address);
    470a:	f107 030c 	add.w	r3, r7, #12
    470e:	4618      	mov	r0, r3
    4710:	f000 fe66 	bl	53e0 <MSS_MAC_set_mac_address>
	
    /* Detect PHY */
    if( g_mss_mac.phy_address > MSS_PHY_ADDRESS_MAX )
    4714:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4718:	f2c2 0300 	movt	r3, #8192	; 0x2000
    471c:	f893 30e8 	ldrb.w	r3, [r3, #232]	; 0xe8
    4720:	2b1f      	cmp	r3, #31
    4722:	d913      	bls.n	474c <MSS_MAC_init+0x32c>
    {
    	PHY_probe();
    4724:	f002 fbd2 	bl	6ecc <PHY_probe>
    	configASSERT( g_mss_mac.phy_address <= MSS_PHY_ADDRESS_MAX );
    4728:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    472c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4730:	f893 30e8 	ldrb.w	r3, [r3, #232]	; 0xe8
    4734:	2b1f      	cmp	r3, #31
    4736:	d909      	bls.n	474c <MSS_MAC_init+0x32c>
    4738:	f04f 0328 	mov.w	r3, #40	; 0x28
    473c:	f383 8811 	msr	BASEPRI, r3
    4740:	f3bf 8f6f 	isb	sy
    4744:	f3bf 8f4f 	dsb	sy
    4748:	627b      	str	r3, [r7, #36]	; 0x24
    474a:	e7fe      	b.n	474a <MSS_MAC_init+0x32a>
    }

    /* Reset PHY */
    PHY_reset();
    474c:	f002 fc00 	bl	6f50 <PHY_reset>

	/* Configure chip according to PHY status */
    MSS_MAC_auto_setup_link();
    4750:	f000 fdde 	bl	5310 <MSS_MAC_auto_setup_link>
	
	/* Ensure uip_buf starts by pointing somewhere. */
	uip_buf = MAC_obtain_buffer();	
    4754:	f002 f9b8 	bl	6ac8 <MAC_obtain_buffer>
    4758:	4602      	mov	r2, r0
    475a:	f240 63a4 	movw	r3, #1700	; 0x6a4
    475e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4762:	601a      	str	r2, [r3, #0]
}
    4764:	f107 0728 	add.w	r7, r7, #40	; 0x28
    4768:	46bd      	mov	sp, r7
    476a:	bd80      	pop	{r7, pc}
    476c:	2000ab8c 	.word	0x2000ab8c
    4770:	2000ab68 	.word	0x2000ab68
    4774:	2000aafa 	.word	0x2000aafa

00004778 <MSS_MAC_configure>:
void
MSS_MAC_configure
(
    uint32_t configuration
)
{
    4778:	b580      	push	{r7, lr}
    477a:	b086      	sub	sp, #24
    477c:	af00      	add	r7, sp, #0
    477e:	6078      	str	r0, [r7, #4]
    int32_t ret;

    ret = MAC_stop_transmission();
    4780:	f001 fd90 	bl	62a4 <MAC_stop_transmission>
    4784:	4603      	mov	r3, r0
    4786:	60fb      	str	r3, [r7, #12]
    configASSERT( ret == MAC_OK );
    4788:	68fb      	ldr	r3, [r7, #12]
    478a:	2b00      	cmp	r3, #0
    478c:	d009      	beq.n	47a2 <MSS_MAC_configure+0x2a>
    478e:	f04f 0328 	mov.w	r3, #40	; 0x28
    4792:	f383 8811 	msr	BASEPRI, r3
    4796:	f3bf 8f6f 	isb	sy
    479a:	f3bf 8f4f 	dsb	sy
    479e:	613b      	str	r3, [r7, #16]
    47a0:	e7fe      	b.n	47a0 <MSS_MAC_configure+0x28>

    ret = MAC_stop_receiving();
    47a2:	f001 fdbd 	bl	6320 <MAC_stop_receiving>
    47a6:	4603      	mov	r3, r0
    47a8:	60fb      	str	r3, [r7, #12]
    configASSERT( ret == MAC_OK );
    47aa:	68fb      	ldr	r3, [r7, #12]
    47ac:	2b00      	cmp	r3, #0
    47ae:	d009      	beq.n	47c4 <MSS_MAC_configure+0x4c>
    47b0:	f04f 0328 	mov.w	r3, #40	; 0x28
    47b4:	f383 8811 	msr	BASEPRI, r3
    47b8:	f3bf 8f6f 	isb	sy
    47bc:	f3bf 8f4f 	dsb	sy
    47c0:	617b      	str	r3, [r7, #20]
    47c2:	e7fe      	b.n	47c2 <MSS_MAC_configure+0x4a>

    MAC_BITBAND->CSR6_RA = (uint32_t)(((configuration & MSS_MAC_CFG_RECEIVE_ALL) != 0u) ? 1u : 0u );
    47c4:	f240 0300 	movw	r3, #0
    47c8:	f2c4 2306 	movt	r3, #16902	; 0x4206
    47cc:	687a      	ldr	r2, [r7, #4]
    47ce:	f002 0201 	and.w	r2, r2, #1
    47d2:	b2d2      	uxtb	r2, r2
    47d4:	2a00      	cmp	r2, #0
    47d6:	d002      	beq.n	47de <MSS_MAC_configure+0x66>
    47d8:	f04f 0201 	mov.w	r2, #1
    47dc:	e001      	b.n	47e2 <MSS_MAC_configure+0x6a>
    47de:	f04f 0200 	mov.w	r2, #0
    47e2:	f8c3 2678 	str.w	r2, [r3, #1656]	; 0x678
    MAC_BITBAND->CSR6_TTM = (((configuration & MSS_MAC_CFG_TRANSMIT_THRESHOLD_MODE) != 0u) ? 1u : 0u );
    47e6:	f240 0300 	movw	r3, #0
    47ea:	f2c4 2306 	movt	r3, #16902	; 0x4206
    47ee:	687a      	ldr	r2, [r7, #4]
    47f0:	f002 0202 	and.w	r2, r2, #2
    47f4:	2a00      	cmp	r2, #0
    47f6:	d002      	beq.n	47fe <MSS_MAC_configure+0x86>
    47f8:	f04f 0201 	mov.w	r2, #1
    47fc:	e001      	b.n	4802 <MSS_MAC_configure+0x8a>
    47fe:	f04f 0200 	mov.w	r2, #0
    4802:	f8c3 2658 	str.w	r2, [r3, #1624]	; 0x658
    MAC_BITBAND->CSR6_SF = (uint32_t)(((configuration & MSS_MAC_CFG_STORE_AND_FORWARD) != 0u) ? 1u : 0u );
    4806:	f240 0300 	movw	r3, #0
    480a:	f2c4 2306 	movt	r3, #16902	; 0x4206
    480e:	687a      	ldr	r2, [r7, #4]
    4810:	f002 0204 	and.w	r2, r2, #4
    4814:	2a00      	cmp	r2, #0
    4816:	d002      	beq.n	481e <MSS_MAC_configure+0xa6>
    4818:	f04f 0201 	mov.w	r2, #1
    481c:	e001      	b.n	4822 <MSS_MAC_configure+0xaa>
    481e:	f04f 0200 	mov.w	r2, #0
    4822:	f8c3 2654 	str.w	r2, [r3, #1620]	; 0x654

    switch( configuration & MSS_MAC_CFG_THRESHOLD_CONTROL_11 ) {
    4826:	687b      	ldr	r3, [r7, #4]
    4828:	f003 0318 	and.w	r3, r3, #24
    482c:	2b18      	cmp	r3, #24
    482e:	d86c      	bhi.n	490a <MSS_MAC_configure+0x192>
    4830:	a201      	add	r2, pc, #4	; (adr r2, 4838 <MSS_MAC_configure+0xc0>)
    4832:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    4836:	bf00      	nop
    4838:	0000489d 	.word	0x0000489d
    483c:	0000490b 	.word	0x0000490b
    4840:	0000490b 	.word	0x0000490b
    4844:	0000490b 	.word	0x0000490b
    4848:	0000490b 	.word	0x0000490b
    484c:	0000490b 	.word	0x0000490b
    4850:	0000490b 	.word	0x0000490b
    4854:	0000490b 	.word	0x0000490b
    4858:	000048b7 	.word	0x000048b7
    485c:	0000490b 	.word	0x0000490b
    4860:	0000490b 	.word	0x0000490b
    4864:	0000490b 	.word	0x0000490b
    4868:	0000490b 	.word	0x0000490b
    486c:	0000490b 	.word	0x0000490b
    4870:	0000490b 	.word	0x0000490b
    4874:	0000490b 	.word	0x0000490b
    4878:	000048d5 	.word	0x000048d5
    487c:	0000490b 	.word	0x0000490b
    4880:	0000490b 	.word	0x0000490b
    4884:	0000490b 	.word	0x0000490b
    4888:	0000490b 	.word	0x0000490b
    488c:	0000490b 	.word	0x0000490b
    4890:	0000490b 	.word	0x0000490b
    4894:	0000490b 	.word	0x0000490b
    4898:	000048f3 	.word	0x000048f3
    case MSS_MAC_CFG_THRESHOLD_CONTROL_00:
        MAC->CSR6 = MAC->CSR6 & ~CSR6_TR_MASK;
    489c:	f243 0300 	movw	r3, #12288	; 0x3000
    48a0:	f2c4 0300 	movt	r3, #16384	; 0x4000
    48a4:	f243 0200 	movw	r2, #12288	; 0x3000
    48a8:	f2c4 0200 	movt	r2, #16384	; 0x4000
    48ac:	6b12      	ldr	r2, [r2, #48]	; 0x30
    48ae:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
    48b2:	631a      	str	r2, [r3, #48]	; 0x30
        break;
    48b4:	e029      	b.n	490a <MSS_MAC_configure+0x192>
    case MSS_MAC_CFG_THRESHOLD_CONTROL_01:
        MAC->CSR6 = (MAC->CSR6 & ~CSR6_TR_MASK) | ((uint32_t)1 << CSR6_TR_SHIFT );
    48b6:	f243 0300 	movw	r3, #12288	; 0x3000
    48ba:	f2c4 0300 	movt	r3, #16384	; 0x4000
    48be:	f243 0200 	movw	r2, #12288	; 0x3000
    48c2:	f2c4 0200 	movt	r2, #16384	; 0x4000
    48c6:	6b12      	ldr	r2, [r2, #48]	; 0x30
    48c8:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
    48cc:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    48d0:	631a      	str	r2, [r3, #48]	; 0x30
        break;
    48d2:	e01a      	b.n	490a <MSS_MAC_configure+0x192>
    case MSS_MAC_CFG_THRESHOLD_CONTROL_10:
        MAC->CSR6 = (MAC->CSR6 & ~CSR6_TR_MASK) | ((uint32_t)2 << CSR6_TR_SHIFT );
    48d4:	f243 0300 	movw	r3, #12288	; 0x3000
    48d8:	f2c4 0300 	movt	r3, #16384	; 0x4000
    48dc:	f243 0200 	movw	r2, #12288	; 0x3000
    48e0:	f2c4 0200 	movt	r2, #16384	; 0x4000
    48e4:	6b12      	ldr	r2, [r2, #48]	; 0x30
    48e6:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
    48ea:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    48ee:	631a      	str	r2, [r3, #48]	; 0x30
        break;
    48f0:	e00b      	b.n	490a <MSS_MAC_configure+0x192>
    case MSS_MAC_CFG_THRESHOLD_CONTROL_11:
        MAC->CSR6 = (MAC->CSR6 & ~CSR6_TR_MASK) | ((uint32_t)3 << CSR6_TR_SHIFT );
    48f2:	f243 0300 	movw	r3, #12288	; 0x3000
    48f6:	f2c4 0300 	movt	r3, #16384	; 0x4000
    48fa:	f243 0200 	movw	r2, #12288	; 0x3000
    48fe:	f2c4 0200 	movt	r2, #16384	; 0x4000
    4902:	6b12      	ldr	r2, [r2, #48]	; 0x30
    4904:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
    4908:	631a      	str	r2, [r3, #48]	; 0x30
        break;
    default:
        break;
    }
    MAC_BITBAND->CSR6_FD = (uint32_t)(((configuration & MSS_MAC_CFG_FULL_DUPLEX_MODE) != 0u) ? 1u : 0u );
    490a:	f240 0300 	movw	r3, #0
    490e:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4912:	687a      	ldr	r2, [r7, #4]
    4914:	f002 0220 	and.w	r2, r2, #32
    4918:	2a00      	cmp	r2, #0
    491a:	d002      	beq.n	4922 <MSS_MAC_configure+0x1aa>
    491c:	f04f 0201 	mov.w	r2, #1
    4920:	e001      	b.n	4926 <MSS_MAC_configure+0x1ae>
    4922:	f04f 0200 	mov.w	r2, #0
    4926:	f8c3 2624 	str.w	r2, [r3, #1572]	; 0x624
    MAC_BITBAND->CSR6_PM = (uint32_t)(((configuration & MSS_MAC_CFG_PASS_ALL_MULTICAST) != 0u) ? 1u : 0u );
    492a:	f240 0300 	movw	r3, #0
    492e:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4932:	687a      	ldr	r2, [r7, #4]
    4934:	f002 0240 	and.w	r2, r2, #64	; 0x40
    4938:	2a00      	cmp	r2, #0
    493a:	d002      	beq.n	4942 <MSS_MAC_configure+0x1ca>
    493c:	f04f 0201 	mov.w	r2, #1
    4940:	e001      	b.n	4946 <MSS_MAC_configure+0x1ce>
    4942:	f04f 0200 	mov.w	r2, #0
    4946:	f8c3 261c 	str.w	r2, [r3, #1564]	; 0x61c
    MAC_BITBAND->CSR6_PR = (uint32_t)(((configuration & MSS_MAC_CFG_PROMISCUOUS_MODE) != 0u) ? 1u : 0u );
    494a:	f240 0300 	movw	r3, #0
    494e:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4952:	687a      	ldr	r2, [r7, #4]
    4954:	f002 0280 	and.w	r2, r2, #128	; 0x80
    4958:	2a00      	cmp	r2, #0
    495a:	d002      	beq.n	4962 <MSS_MAC_configure+0x1ea>
    495c:	f04f 0201 	mov.w	r2, #1
    4960:	e001      	b.n	4966 <MSS_MAC_configure+0x1ee>
    4962:	f04f 0200 	mov.w	r2, #0
    4966:	f8c3 2618 	str.w	r2, [r3, #1560]	; 0x618
    MAC_BITBAND->CSR6_PB = (uint32_t)(((configuration & MSS_MAC_CFG_PASS_BAD_FRAMES) != 0u) ? 1u : 0u );
    496a:	f240 0300 	movw	r3, #0
    496e:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4972:	687a      	ldr	r2, [r7, #4]
    4974:	f402 7200 	and.w	r2, r2, #512	; 0x200
    4978:	2a00      	cmp	r2, #0
    497a:	d002      	beq.n	4982 <MSS_MAC_configure+0x20a>
    497c:	f04f 0201 	mov.w	r2, #1
    4980:	e001      	b.n	4986 <MSS_MAC_configure+0x20e>
    4982:	f04f 0200 	mov.w	r2, #0
    4986:	f8c3 260c 	str.w	r2, [r3, #1548]	; 0x60c
    PHY_set_link_type( (uint8_t)
    498a:	687b      	ldr	r3, [r7, #4]
    498c:	b2db      	uxtb	r3, r3
    498e:	f003 0302 	and.w	r3, r3, #2
        ((((configuration & MSS_MAC_CFG_TRANSMIT_THRESHOLD_MODE) != 0u) ? MSS_MAC_LINK_STATUS_100MB : 0u ) |
        (((configuration & MSS_MAC_CFG_FULL_DUPLEX_MODE) != 0u) ? MSS_MAC_LINK_STATUS_FDX : 0u )) );
    4992:	687a      	ldr	r2, [r7, #4]
    4994:	f002 0220 	and.w	r2, r2, #32
    }
    MAC_BITBAND->CSR6_FD = (uint32_t)(((configuration & MSS_MAC_CFG_FULL_DUPLEX_MODE) != 0u) ? 1u : 0u );
    MAC_BITBAND->CSR6_PM = (uint32_t)(((configuration & MSS_MAC_CFG_PASS_ALL_MULTICAST) != 0u) ? 1u : 0u );
    MAC_BITBAND->CSR6_PR = (uint32_t)(((configuration & MSS_MAC_CFG_PROMISCUOUS_MODE) != 0u) ? 1u : 0u );
    MAC_BITBAND->CSR6_PB = (uint32_t)(((configuration & MSS_MAC_CFG_PASS_BAD_FRAMES) != 0u) ? 1u : 0u );
    PHY_set_link_type( (uint8_t)
    4998:	2a00      	cmp	r2, #0
    499a:	d002      	beq.n	49a2 <MSS_MAC_configure+0x22a>
    499c:	f04f 0204 	mov.w	r2, #4
    49a0:	e001      	b.n	49a6 <MSS_MAC_configure+0x22e>
    49a2:	f04f 0200 	mov.w	r2, #0
    49a6:	ea43 0302 	orr.w	r3, r3, r2
    49aa:	b2db      	uxtb	r3, r3
    49ac:	4618      	mov	r0, r3
    49ae:	f002 fb43 	bl	7038 <PHY_set_link_type>
        ((((configuration & MSS_MAC_CFG_TRANSMIT_THRESHOLD_MODE) != 0u) ? MSS_MAC_LINK_STATUS_100MB : 0u ) |
        (((configuration & MSS_MAC_CFG_FULL_DUPLEX_MODE) != 0u) ? MSS_MAC_LINK_STATUS_FDX : 0u )) );

    MSS_MAC_auto_setup_link();
    49b2:	f000 fcad 	bl	5310 <MSS_MAC_auto_setup_link>
}
    49b6:	f107 0718 	add.w	r7, r7, #24
    49ba:	46bd      	mov	sp, r7
    49bc:	bd80      	pop	{r7, pc}
    49be:	bf00      	nop

000049c0 <MSS_MAC_get_configuration>:
 *    - #MSS_MAC_CFG_HASH_PERFECT_RECEIVE_FILTERING_MODE
 * @see   MAC_configure()
 */
int32_t
MSS_MAC_get_configuration( void )
{
    49c0:	b480      	push	{r7}
    49c2:	b083      	sub	sp, #12
    49c4:	af00      	add	r7, sp, #0
    uint32_t configuration;

    configuration = 0u;
    49c6:	f04f 0300 	mov.w	r3, #0
    49ca:	607b      	str	r3, [r7, #4]
    if( MAC_BITBAND->CSR6_RA != 0u ) {
    49cc:	f240 0300 	movw	r3, #0
    49d0:	f2c4 2306 	movt	r3, #16902	; 0x4206
    49d4:	f8d3 3678 	ldr.w	r3, [r3, #1656]	; 0x678
    49d8:	2b00      	cmp	r3, #0
    49da:	d003      	beq.n	49e4 <MSS_MAC_get_configuration+0x24>
        configuration |= MSS_MAC_CFG_RECEIVE_ALL;
    49dc:	687b      	ldr	r3, [r7, #4]
    49de:	f043 0301 	orr.w	r3, r3, #1
    49e2:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_TTM != 0u ) {
    49e4:	f240 0300 	movw	r3, #0
    49e8:	f2c4 2306 	movt	r3, #16902	; 0x4206
    49ec:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
    49f0:	2b00      	cmp	r3, #0
    49f2:	d003      	beq.n	49fc <MSS_MAC_get_configuration+0x3c>
        configuration |= MSS_MAC_CFG_TRANSMIT_THRESHOLD_MODE;
    49f4:	687b      	ldr	r3, [r7, #4]
    49f6:	f043 0302 	orr.w	r3, r3, #2
    49fa:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_SF != 0u ) {
    49fc:	f240 0300 	movw	r3, #0
    4a00:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4a04:	f8d3 3654 	ldr.w	r3, [r3, #1620]	; 0x654
    4a08:	2b00      	cmp	r3, #0
    4a0a:	d003      	beq.n	4a14 <MSS_MAC_get_configuration+0x54>
        configuration |= MSS_MAC_CFG_STORE_AND_FORWARD;
    4a0c:	687b      	ldr	r3, [r7, #4]
    4a0e:	f043 0304 	orr.w	r3, r3, #4
    4a12:	607b      	str	r3, [r7, #4]
    }

    switch( (MAC->CSR6 & CSR6_TR_MASK) >> CSR6_TR_SHIFT ) {
    4a14:	f243 0300 	movw	r3, #12288	; 0x3000
    4a18:	f2c4 0300 	movt	r3, #16384	; 0x4000
    4a1c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    4a1e:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
    4a22:	ea4f 3393 	mov.w	r3, r3, lsr #14
    4a26:	2b02      	cmp	r3, #2
    4a28:	d008      	beq.n	4a3c <MSS_MAC_get_configuration+0x7c>
    4a2a:	2b03      	cmp	r3, #3
    4a2c:	d00b      	beq.n	4a46 <MSS_MAC_get_configuration+0x86>
    4a2e:	2b01      	cmp	r3, #1
    4a30:	d10d      	bne.n	4a4e <MSS_MAC_get_configuration+0x8e>
    case 1: configuration |= MSS_MAC_CFG_THRESHOLD_CONTROL_01; break;
    4a32:	687b      	ldr	r3, [r7, #4]
    4a34:	f043 0308 	orr.w	r3, r3, #8
    4a38:	607b      	str	r3, [r7, #4]
    4a3a:	e008      	b.n	4a4e <MSS_MAC_get_configuration+0x8e>
    case 2: configuration |= MSS_MAC_CFG_THRESHOLD_CONTROL_10; break;
    4a3c:	687b      	ldr	r3, [r7, #4]
    4a3e:	f043 0310 	orr.w	r3, r3, #16
    4a42:	607b      	str	r3, [r7, #4]
    4a44:	e003      	b.n	4a4e <MSS_MAC_get_configuration+0x8e>
    case 3: configuration |= MSS_MAC_CFG_THRESHOLD_CONTROL_11; break;
    4a46:	687b      	ldr	r3, [r7, #4]
    4a48:	f043 0318 	orr.w	r3, r3, #24
    4a4c:	607b      	str	r3, [r7, #4]
    default: break;
    }
    if( MAC_BITBAND->CSR6_FD != 0u ) {
    4a4e:	f240 0300 	movw	r3, #0
    4a52:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4a56:	f8d3 3624 	ldr.w	r3, [r3, #1572]	; 0x624
    4a5a:	2b00      	cmp	r3, #0
    4a5c:	d003      	beq.n	4a66 <MSS_MAC_get_configuration+0xa6>
        configuration |= MSS_MAC_CFG_FULL_DUPLEX_MODE;
    4a5e:	687b      	ldr	r3, [r7, #4]
    4a60:	f043 0320 	orr.w	r3, r3, #32
    4a64:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_PM != 0u ) {
    4a66:	f240 0300 	movw	r3, #0
    4a6a:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4a6e:	f8d3 361c 	ldr.w	r3, [r3, #1564]	; 0x61c
    4a72:	2b00      	cmp	r3, #0
    4a74:	d003      	beq.n	4a7e <MSS_MAC_get_configuration+0xbe>
        configuration |= MSS_MAC_CFG_PASS_ALL_MULTICAST;
    4a76:	687b      	ldr	r3, [r7, #4]
    4a78:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    4a7c:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_PR != 0u ) {
    4a7e:	f240 0300 	movw	r3, #0
    4a82:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4a86:	f8d3 3618 	ldr.w	r3, [r3, #1560]	; 0x618
    4a8a:	2b00      	cmp	r3, #0
    4a8c:	d003      	beq.n	4a96 <MSS_MAC_get_configuration+0xd6>
        configuration |= MSS_MAC_CFG_PROMISCUOUS_MODE;
    4a8e:	687b      	ldr	r3, [r7, #4]
    4a90:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    4a94:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_IF != 0u ) {
    4a96:	f240 0300 	movw	r3, #0
    4a9a:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4a9e:	f8d3 3610 	ldr.w	r3, [r3, #1552]	; 0x610
    4aa2:	2b00      	cmp	r3, #0
    4aa4:	d003      	beq.n	4aae <MSS_MAC_get_configuration+0xee>
        configuration |= MSS_MAC_CFG_INVERSE_FILTERING;
    4aa6:	687b      	ldr	r3, [r7, #4]
    4aa8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    4aac:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_PB != 0u ) {
    4aae:	f240 0300 	movw	r3, #0
    4ab2:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4ab6:	f8d3 360c 	ldr.w	r3, [r3, #1548]	; 0x60c
    4aba:	2b00      	cmp	r3, #0
    4abc:	d003      	beq.n	4ac6 <MSS_MAC_get_configuration+0x106>
        configuration |= MSS_MAC_CFG_PASS_BAD_FRAMES;
    4abe:	687b      	ldr	r3, [r7, #4]
    4ac0:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    4ac4:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_HO != 0u ) {
    4ac6:	f240 0300 	movw	r3, #0
    4aca:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4ace:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    4ad2:	2b00      	cmp	r3, #0
    4ad4:	d003      	beq.n	4ade <MSS_MAC_get_configuration+0x11e>
        configuration |= MSS_MAC_CFG_HASH_ONLY_FILTERING_MODE;
    4ad6:	687b      	ldr	r3, [r7, #4]
    4ad8:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    4adc:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_HP != 0u ) {
    4ade:	f240 0300 	movw	r3, #0
    4ae2:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4ae6:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4aea:	2b00      	cmp	r3, #0
    4aec:	d003      	beq.n	4af6 <MSS_MAC_get_configuration+0x136>
        configuration |= MSS_MAC_CFG_HASH_PERFECT_RECEIVE_FILTERING_MODE;
    4aee:	687b      	ldr	r3, [r7, #4]
    4af0:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
    4af4:	607b      	str	r3, [r7, #4]
    }

    return (int32_t)configuration;
    4af6:	687b      	ldr	r3, [r7, #4]
}
    4af8:	4618      	mov	r0, r3
    4afa:	f107 070c 	add.w	r7, r7, #12
    4afe:	46bd      	mov	sp, r7
    4b00:	bc80      	pop	{r7}
    4b02:	4770      	bx	lr

00004b04 <MSS_MAC_tx_packet>:
int32_t
MSS_MAC_tx_packet
(
    unsigned short usLength
)
{
    4b04:	b580      	push	{r7, lr}
    4b06:	b08a      	sub	sp, #40	; 0x28
    4b08:	af00      	add	r7, sp, #0
    4b0a:	4603      	mov	r3, r0
    4b0c:	80fb      	strh	r3, [r7, #6]
	uint32_t desc;
	unsigned long ulDescriptor;
    int32_t error = MAC_OK;
    4b0e:	f04f 0300 	mov.w	r3, #0
    4b12:	617b      	str	r3, [r7, #20]

    configASSERT( uip_buf != NULL_buffer );
    4b14:	f240 63a4 	movw	r3, #1700	; 0x6a4
    4b18:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4b1c:	681a      	ldr	r2, [r3, #0]
    4b1e:	f240 639c 	movw	r3, #1692	; 0x69c
    4b22:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4b26:	681b      	ldr	r3, [r3, #0]
    4b28:	429a      	cmp	r2, r3
    4b2a:	d109      	bne.n	4b40 <MSS_MAC_tx_packet+0x3c>
    4b2c:	f04f 0328 	mov.w	r3, #40	; 0x28
    4b30:	f383 8811 	msr	BASEPRI, r3
    4b34:	f3bf 8f6f 	isb	sy
    4b38:	f3bf 8f4f 	dsb	sy
    4b3c:	61bb      	str	r3, [r7, #24]
    4b3e:	e7fe      	b.n	4b3e <MSS_MAC_tx_packet+0x3a>

	configASSERT( usLength >= 12 );
    4b40:	88fb      	ldrh	r3, [r7, #6]
    4b42:	2b0b      	cmp	r3, #11
    4b44:	d809      	bhi.n	4b5a <MSS_MAC_tx_packet+0x56>
    4b46:	f04f 0328 	mov.w	r3, #40	; 0x28
    4b4a:	f383 8811 	msr	BASEPRI, r3
    4b4e:	f3bf 8f6f 	isb	sy
    4b52:	f3bf 8f4f 	dsb	sy
    4b56:	61fb      	str	r3, [r7, #28]
    4b58:	e7fe      	b.n	4b58 <MSS_MAC_tx_packet+0x54>

    if( (g_mss_mac.flags & FLAG_EXCEED_LIMIT) == 0u )
    4b5a:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4b5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4b62:	791b      	ldrb	r3, [r3, #4]
    4b64:	f003 0308 	and.w	r3, r3, #8
    4b68:	2b00      	cmp	r3, #0
    4b6a:	d10e      	bne.n	4b8a <MSS_MAC_tx_packet+0x86>
    {
		configASSERT( usLength <= MSS_MAX_PACKET_SIZE );
    4b6c:	88fa      	ldrh	r2, [r7, #6]
    4b6e:	f240 53ea 	movw	r3, #1514	; 0x5ea
    4b72:	429a      	cmp	r2, r3
    4b74:	d909      	bls.n	4b8a <MSS_MAC_tx_packet+0x86>
    4b76:	f04f 0328 	mov.w	r3, #40	; 0x28
    4b7a:	f383 8811 	msr	BASEPRI, r3
    4b7e:	f3bf 8f6f 	isb	sy
    4b82:	f3bf 8f4f 	dsb	sy
    4b86:	623b      	str	r3, [r7, #32]
    4b88:	e7fe      	b.n	4b88 <MSS_MAC_tx_packet+0x84>
	}

	taskENTER_CRITICAL();
    4b8a:	f00f fb75 	bl	14278 <vPortEnterCritical>
	{
		/* Check both Tx descriptors are free, meaning the double send has completed. */
		if( ( ( (g_mss_mac.tx_descriptors[ 0 ].descriptor_0) & TDES0_OWN) == TDES0_OWN ) || ( ( (g_mss_mac.tx_descriptors[ 1 ].descriptor_0) & TDES0_OWN) == TDES0_OWN ) )
    4b8e:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4b92:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4b96:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    4b98:	2b00      	cmp	r3, #0
    4b9a:	db07      	blt.n	4bac <MSS_MAC_tx_packet+0xa8>
    4b9c:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4ba0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4ba4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
    4ba8:	2b00      	cmp	r3, #0
    4baa:	da02      	bge.n	4bb2 <MSS_MAC_tx_packet+0xae>
		{
			error = MAC_BUFFER_IS_FULL;
    4bac:	f06f 0303 	mvn.w	r3, #3
    4bb0:	617b      	str	r3, [r7, #20]
		}
	}
	taskEXIT_CRITICAL();
    4bb2:	f00f fb99 	bl	142e8 <vPortExitCritical>

	configASSERT( ( g_mss_mac.tx_desc_index == 0 ) );
    4bb6:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4bba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4bbe:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    4bc0:	2b00      	cmp	r3, #0
    4bc2:	d009      	beq.n	4bd8 <MSS_MAC_tx_packet+0xd4>
    4bc4:	f04f 0328 	mov.w	r3, #40	; 0x28
    4bc8:	f383 8811 	msr	BASEPRI, r3
    4bcc:	f3bf 8f6f 	isb	sy
    4bd0:	f3bf 8f4f 	dsb	sy
    4bd4:	627b      	str	r3, [r7, #36]	; 0x24
    4bd6:	e7fe      	b.n	4bd6 <MSS_MAC_tx_packet+0xd2>
	
	if( error == MAC_OK )
    4bd8:	697b      	ldr	r3, [r7, #20]
    4bda:	2b00      	cmp	r3, #0
    4bdc:	f040 820d 	bne.w	4ffa <MSS_MAC_tx_packet+0x4f6>
	{
		/* Ensure nothing is going to get sent until both descriptors are ready.
		This is done to	prevent a Tx end occurring prior to the second descriptor
		being ready. */
		MAC_BITBAND->CSR6_ST = 0u;
    4be0:	f240 0300 	movw	r3, #0
    4be4:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4be8:	f04f 0200 	mov.w	r2, #0
    4bec:	f8c3 2634 	str.w	r2, [r3, #1588]	; 0x634

		/* Assumed TX_RING_SIZE == 2.  A #error directive checks this is the
		case. */
		taskENTER_CRITICAL();
    4bf0:	f00f fb42 	bl	14278 <vPortEnterCritical>
		{
			for( ulDescriptor = 0; ulDescriptor < TX_RING_SIZE; ulDescriptor++ )
    4bf4:	f04f 0300 	mov.w	r3, #0
    4bf8:	613b      	str	r3, [r7, #16]
    4bfa:	e1f8      	b.n	4fee <MSS_MAC_tx_packet+0x4ea>
			{
				g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_1 = 0u;
    4bfc:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4c00:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4c04:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    4c06:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4c0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4c0e:	f102 0207 	add.w	r2, r2, #7
    4c12:	ea4f 1202 	mov.w	r2, r2, lsl #4
    4c16:	4413      	add	r3, r2
    4c18:	f103 0308 	add.w	r3, r3, #8
    4c1c:	f04f 0200 	mov.w	r2, #0
    4c20:	601a      	str	r2, [r3, #0]
	
				if( (g_mss_mac.flags & FLAG_CRC_DISABLE) != 0u ) {
    4c22:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4c26:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4c2a:	791b      	ldrb	r3, [r3, #4]
    4c2c:	f003 0304 	and.w	r3, r3, #4
    4c30:	2b00      	cmp	r3, #0
    4c32:	d023      	beq.n	4c7c <MSS_MAC_tx_packet+0x178>
					g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_1 |= TDES1_AC;
    4c34:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4c38:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4c3c:	6f19      	ldr	r1, [r3, #112]	; 0x70
    4c3e:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4c42:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4c46:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    4c48:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4c4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4c50:	f102 0207 	add.w	r2, r2, #7
    4c54:	ea4f 1202 	mov.w	r2, r2, lsl #4
    4c58:	4413      	add	r3, r2
    4c5a:	f103 0308 	add.w	r3, r3, #8
    4c5e:	681b      	ldr	r3, [r3, #0]
    4c60:	f043 6280 	orr.w	r2, r3, #67108864	; 0x4000000
    4c64:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4c68:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4c6c:	f101 0107 	add.w	r1, r1, #7
    4c70:	ea4f 1101 	mov.w	r1, r1, lsl #4
    4c74:	440b      	add	r3, r1
    4c76:	f103 0308 	add.w	r3, r3, #8
    4c7a:	601a      	str	r2, [r3, #0]
				}
	
				/* Every buffer can hold a full frame so they are always first and last
				   descriptor */
				g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_1 |= TDES1_LS | TDES1_FS;
    4c7c:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4c80:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4c84:	6f19      	ldr	r1, [r3, #112]	; 0x70
    4c86:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4c8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4c8e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    4c90:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4c94:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4c98:	f102 0207 	add.w	r2, r2, #7
    4c9c:	ea4f 1202 	mov.w	r2, r2, lsl #4
    4ca0:	4413      	add	r3, r2
    4ca2:	f103 0308 	add.w	r3, r3, #8
    4ca6:	681b      	ldr	r3, [r3, #0]
    4ca8:	f043 42c0 	orr.w	r2, r3, #1610612736	; 0x60000000
    4cac:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4cb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4cb4:	f101 0107 	add.w	r1, r1, #7
    4cb8:	ea4f 1101 	mov.w	r1, r1, lsl #4
    4cbc:	440b      	add	r3, r1
    4cbe:	f103 0308 	add.w	r3, r3, #8
    4cc2:	601a      	str	r2, [r3, #0]
	
				/* set data size */
				g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_1 |= usLength;
    4cc4:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4cc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4ccc:	6f19      	ldr	r1, [r3, #112]	; 0x70
    4cce:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4cd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4cd6:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    4cd8:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4cdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4ce0:	f102 0207 	add.w	r2, r2, #7
    4ce4:	ea4f 1202 	mov.w	r2, r2, lsl #4
    4ce8:	4413      	add	r3, r2
    4cea:	f103 0308 	add.w	r3, r3, #8
    4cee:	681a      	ldr	r2, [r3, #0]
    4cf0:	88fb      	ldrh	r3, [r7, #6]
    4cf2:	ea42 0203 	orr.w	r2, r2, r3
    4cf6:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4cfa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4cfe:	f101 0107 	add.w	r1, r1, #7
    4d02:	ea4f 1101 	mov.w	r1, r1, lsl #4
    4d06:	440b      	add	r3, r1
    4d08:	f103 0308 	add.w	r3, r3, #8
    4d0c:	601a      	str	r2, [r3, #0]
	
				/* reset end of ring */
				g_mss_mac.tx_descriptors[TX_RING_SIZE-1].descriptor_1 |= TDES1_TER;
    4d0e:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4d12:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4d16:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    4d1a:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
    4d1e:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4d22:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4d26:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	
				if( usLength > MSS_TX_BUFF_SIZE ) /* FLAG_EXCEED_LIMIT */
    4d2a:	88fa      	ldrh	r2, [r7, #6]
    4d2c:	f240 53ec 	movw	r3, #1516	; 0x5ec
    4d30:	429a      	cmp	r2, r3
    4d32:	d902      	bls.n	4d3a <MSS_MAC_tx_packet+0x236>
				{
					usLength = (uint16_t)MSS_TX_BUFF_SIZE;
    4d34:	f240 53ec 	movw	r3, #1516	; 0x5ec
    4d38:	80fb      	strh	r3, [r7, #6]
				}
	
				/* The data buffer is assigned to the Tx descriptor. */
				g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].buffer_1 = ( unsigned long ) uip_buf;
    4d3a:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4d3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4d42:	6f19      	ldr	r1, [r3, #112]	; 0x70
    4d44:	f240 63a4 	movw	r3, #1700	; 0x6a4
    4d48:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4d4c:	681b      	ldr	r3, [r3, #0]
    4d4e:	461a      	mov	r2, r3
    4d50:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4d54:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4d58:	ea4f 1101 	mov.w	r1, r1, lsl #4
    4d5c:	440b      	add	r3, r1
    4d5e:	f103 037c 	add.w	r3, r3, #124	; 0x7c
    4d62:	601a      	str	r2, [r3, #0]
	
				/* update counters */
				desc = g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_0;
    4d64:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4d68:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4d6c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    4d6e:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4d72:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4d76:	f102 0207 	add.w	r2, r2, #7
    4d7a:	ea4f 1202 	mov.w	r2, r2, lsl #4
    4d7e:	4413      	add	r3, r2
    4d80:	f103 0304 	add.w	r3, r3, #4
    4d84:	681b      	ldr	r3, [r3, #0]
    4d86:	60fb      	str	r3, [r7, #12]
				if( (desc & TDES0_LO) != 0u ) {
    4d88:	68fb      	ldr	r3, [r7, #12]
    4d8a:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    4d8e:	2b00      	cmp	r3, #0
    4d90:	d027      	beq.n	4de2 <MSS_MAC_tx_packet+0x2de>
					g_mss_mac.statistics.tx_loss_of_carrier++;
    4d92:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4d96:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4d9a:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    4d9e:	ea4f 2212 	mov.w	r2, r2, lsr #8
    4da2:	f893 311c 	ldrb.w	r3, [r3, #284]	; 0x11c
    4da6:	ea4f 6303 	mov.w	r3, r3, lsl #24
    4daa:	ea43 0302 	orr.w	r3, r3, r2
    4dae:	f103 0201 	add.w	r2, r3, #1
    4db2:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4db6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4dba:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    4dbe:	ea4f 2101 	mov.w	r1, r1, lsl #8
    4dc2:	f8d3 0118 	ldr.w	r0, [r3, #280]	; 0x118
    4dc6:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    4dca:	ea40 0101 	orr.w	r1, r0, r1
    4dce:	f8c3 1118 	str.w	r1, [r3, #280]	; 0x118
    4dd2:	ea4f 6212 	mov.w	r2, r2, lsr #24
    4dd6:	f04f 0100 	mov.w	r1, #0
    4dda:	ea41 0202 	orr.w	r2, r1, r2
    4dde:	f883 211c 	strb.w	r2, [r3, #284]	; 0x11c
				}
				if( (desc & TDES0_NC) != 0u ) {
    4de2:	68fb      	ldr	r3, [r7, #12]
    4de4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    4de8:	2b00      	cmp	r3, #0
    4dea:	d027      	beq.n	4e3c <MSS_MAC_tx_packet+0x338>
					g_mss_mac.statistics.tx_no_carrier++;
    4dec:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4df0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4df4:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
    4df8:	ea4f 2212 	mov.w	r2, r2, lsr #8
    4dfc:	f893 3120 	ldrb.w	r3, [r3, #288]	; 0x120
    4e00:	ea4f 6303 	mov.w	r3, r3, lsl #24
    4e04:	ea43 0302 	orr.w	r3, r3, r2
    4e08:	f103 0201 	add.w	r2, r3, #1
    4e0c:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4e10:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4e14:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    4e18:	ea4f 2101 	mov.w	r1, r1, lsl #8
    4e1c:	f8d3 011c 	ldr.w	r0, [r3, #284]	; 0x11c
    4e20:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    4e24:	ea40 0101 	orr.w	r1, r0, r1
    4e28:	f8c3 111c 	str.w	r1, [r3, #284]	; 0x11c
    4e2c:	ea4f 6212 	mov.w	r2, r2, lsr #24
    4e30:	f04f 0100 	mov.w	r1, #0
    4e34:	ea41 0202 	orr.w	r2, r1, r2
    4e38:	f883 2120 	strb.w	r2, [r3, #288]	; 0x120
				}
				if( (desc & TDES0_LC) != 0u ) {
    4e3c:	68fb      	ldr	r3, [r7, #12]
    4e3e:	f403 7300 	and.w	r3, r3, #512	; 0x200
    4e42:	2b00      	cmp	r3, #0
    4e44:	d027      	beq.n	4e96 <MSS_MAC_tx_packet+0x392>
					g_mss_mac.statistics.tx_late_collision++;
    4e46:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4e4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4e4e:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    4e52:	ea4f 2212 	mov.w	r2, r2, lsr #8
    4e56:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
    4e5a:	ea4f 6303 	mov.w	r3, r3, lsl #24
    4e5e:	ea43 0302 	orr.w	r3, r3, r2
    4e62:	f103 0201 	add.w	r2, r3, #1
    4e66:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4e6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4e6e:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    4e72:	ea4f 2101 	mov.w	r1, r1, lsl #8
    4e76:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
    4e7a:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    4e7e:	ea40 0101 	orr.w	r1, r0, r1
    4e82:	f8c3 1120 	str.w	r1, [r3, #288]	; 0x120
    4e86:	ea4f 6212 	mov.w	r2, r2, lsr #24
    4e8a:	f04f 0100 	mov.w	r1, #0
    4e8e:	ea41 0202 	orr.w	r2, r1, r2
    4e92:	f883 2124 	strb.w	r2, [r3, #292]	; 0x124
				}
				if( (desc & TDES0_EC) != 0u ) {
    4e96:	68fb      	ldr	r3, [r7, #12]
    4e98:	f403 7380 	and.w	r3, r3, #256	; 0x100
    4e9c:	2b00      	cmp	r3, #0
    4e9e:	d027      	beq.n	4ef0 <MSS_MAC_tx_packet+0x3ec>
					g_mss_mac.statistics.tx_excessive_collision++;
    4ea0:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4ea4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4ea8:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    4eac:	ea4f 2212 	mov.w	r2, r2, lsr #8
    4eb0:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
    4eb4:	ea4f 6303 	mov.w	r3, r3, lsl #24
    4eb8:	ea43 0302 	orr.w	r3, r3, r2
    4ebc:	f103 0201 	add.w	r2, r3, #1
    4ec0:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4ec4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4ec8:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    4ecc:	ea4f 2101 	mov.w	r1, r1, lsl #8
    4ed0:	f8d3 0124 	ldr.w	r0, [r3, #292]	; 0x124
    4ed4:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    4ed8:	ea40 0101 	orr.w	r1, r0, r1
    4edc:	f8c3 1124 	str.w	r1, [r3, #292]	; 0x124
    4ee0:	ea4f 6212 	mov.w	r2, r2, lsr #24
    4ee4:	f04f 0100 	mov.w	r1, #0
    4ee8:	ea41 0202 	orr.w	r2, r1, r2
    4eec:	f883 2128 	strb.w	r2, [r3, #296]	; 0x128
				}
				if( (desc & TDES0_UF) != 0u ) {
    4ef0:	68fb      	ldr	r3, [r7, #12]
    4ef2:	f003 0302 	and.w	r3, r3, #2
    4ef6:	2b00      	cmp	r3, #0
    4ef8:	d027      	beq.n	4f4a <MSS_MAC_tx_packet+0x446>
					g_mss_mac.statistics.tx_underflow_error++;
    4efa:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4efe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4f02:	f8d3 212c 	ldr.w	r2, [r3, #300]	; 0x12c
    4f06:	ea4f 2212 	mov.w	r2, r2, lsr #8
    4f0a:	f893 3130 	ldrb.w	r3, [r3, #304]	; 0x130
    4f0e:	ea4f 6303 	mov.w	r3, r3, lsl #24
    4f12:	ea43 0302 	orr.w	r3, r3, r2
    4f16:	f103 0201 	add.w	r2, r3, #1
    4f1a:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4f1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4f22:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    4f26:	ea4f 2101 	mov.w	r1, r1, lsl #8
    4f2a:	f8d3 012c 	ldr.w	r0, [r3, #300]	; 0x12c
    4f2e:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    4f32:	ea40 0101 	orr.w	r1, r0, r1
    4f36:	f8c3 112c 	str.w	r1, [r3, #300]	; 0x12c
    4f3a:	ea4f 6212 	mov.w	r2, r2, lsr #24
    4f3e:	f04f 0100 	mov.w	r1, #0
    4f42:	ea41 0202 	orr.w	r2, r1, r2
    4f46:	f883 2130 	strb.w	r2, [r3, #304]	; 0x130
				}
				g_mss_mac.statistics.tx_collision_count +=
    4f4a:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4f4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4f52:	f8d3 2128 	ldr.w	r2, [r3, #296]	; 0x128
    4f56:	ea4f 2212 	mov.w	r2, r2, lsr #8
    4f5a:	f893 312c 	ldrb.w	r3, [r3, #300]	; 0x12c
    4f5e:	ea4f 6303 	mov.w	r3, r3, lsl #24
    4f62:	ea43 0302 	orr.w	r3, r3, r2
    4f66:	461a      	mov	r2, r3
					(desc >> TDES0_CC_OFFSET) & TDES0_CC_MASK;
    4f68:	68fb      	ldr	r3, [r7, #12]
    4f6a:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    4f6e:	f003 030f 	and.w	r3, r3, #15
					g_mss_mac.statistics.tx_excessive_collision++;
				}
				if( (desc & TDES0_UF) != 0u ) {
					g_mss_mac.statistics.tx_underflow_error++;
				}
				g_mss_mac.statistics.tx_collision_count +=
    4f72:	441a      	add	r2, r3
    4f74:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4f78:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4f7c:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    4f80:	ea4f 2101 	mov.w	r1, r1, lsl #8
    4f84:	f8d3 0128 	ldr.w	r0, [r3, #296]	; 0x128
    4f88:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    4f8c:	ea40 0101 	orr.w	r1, r0, r1
    4f90:	f8c3 1128 	str.w	r1, [r3, #296]	; 0x128
    4f94:	ea4f 6212 	mov.w	r2, r2, lsr #24
    4f98:	f04f 0100 	mov.w	r1, #0
    4f9c:	ea41 0202 	orr.w	r2, r1, r2
    4fa0:	f883 212c 	strb.w	r2, [r3, #300]	; 0x12c
					(desc >> TDES0_CC_OFFSET) & TDES0_CC_MASK;
	
				/* Give ownership of descriptor to the MAC */
				g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_0 = TDES0_OWN;
    4fa4:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4fa8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4fac:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    4fae:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4fb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4fb6:	f102 0207 	add.w	r2, r2, #7
    4fba:	ea4f 1202 	mov.w	r2, r2, lsl #4
    4fbe:	4413      	add	r3, r2
    4fc0:	f103 0304 	add.w	r3, r3, #4
    4fc4:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    4fc8:	601a      	str	r2, [r3, #0]
				
				g_mss_mac.tx_desc_index = (g_mss_mac.tx_desc_index + 1u) % (uint32_t)TX_RING_SIZE;
    4fca:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4fce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4fd2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    4fd4:	f103 0301 	add.w	r3, r3, #1
    4fd8:	f003 0201 	and.w	r2, r3, #1
    4fdc:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    4fe0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4fe4:	671a      	str	r2, [r3, #112]	; 0x70

		/* Assumed TX_RING_SIZE == 2.  A #error directive checks this is the
		case. */
		taskENTER_CRITICAL();
		{
			for( ulDescriptor = 0; ulDescriptor < TX_RING_SIZE; ulDescriptor++ )
    4fe6:	693b      	ldr	r3, [r7, #16]
    4fe8:	f103 0301 	add.w	r3, r3, #1
    4fec:	613b      	str	r3, [r7, #16]
    4fee:	693b      	ldr	r3, [r7, #16]
    4ff0:	2b01      	cmp	r3, #1
    4ff2:	f67f ae03 	bls.w	4bfc <MSS_MAC_tx_packet+0xf8>
				g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_0 = TDES0_OWN;
				
				g_mss_mac.tx_desc_index = (g_mss_mac.tx_desc_index + 1u) % (uint32_t)TX_RING_SIZE;
			}		
		}
		taskEXIT_CRITICAL();
    4ff6:	f00f f977 	bl	142e8 <vPortExitCritical>
    }
	
    if (error == MAC_OK)
    4ffa:	697b      	ldr	r3, [r7, #20]
    4ffc:	2b00      	cmp	r3, #0
    4ffe:	d119      	bne.n	5034 <MSS_MAC_tx_packet+0x530>
    {
        error = (int32_t)usLength;
    5000:	88fb      	ldrh	r3, [r7, #6]
    5002:	617b      	str	r3, [r7, #20]
		
		/* Start sending now both descriptors are set up.  This is done to
		prevent a Tx end occurring prior to the second descriptor being
		ready. */
		MAC_BITBAND->CSR6_ST = 1u;
    5004:	f240 0300 	movw	r3, #0
    5008:	f2c4 2306 	movt	r3, #16902	; 0x4206
    500c:	f04f 0201 	mov.w	r2, #1
    5010:	f8c3 2634 	str.w	r2, [r3, #1588]	; 0x634
		MAC->CSR1 = 1u;
    5014:	f243 0300 	movw	r3, #12288	; 0x3000
    5018:	f2c4 0300 	movt	r3, #16384	; 0x4000
    501c:	f04f 0201 	mov.w	r2, #1
    5020:	609a      	str	r2, [r3, #8]
		
		/* The buffer pointed to by uip_buf is now assigned to a Tx descriptor.
		Find anothere free buffer for uip_buf. */
		uip_buf = MAC_obtain_buffer();
    5022:	f001 fd51 	bl	6ac8 <MAC_obtain_buffer>
    5026:	4602      	mov	r2, r0
    5028:	f240 63a4 	movw	r3, #1700	; 0x6a4
    502c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5030:	601a      	str	r2, [r3, #0]
    5032:	e002      	b.n	503a <MSS_MAC_tx_packet+0x536>
    }
    else
    {
        error = 0;
    5034:	f04f 0300 	mov.w	r3, #0
    5038:	617b      	str	r3, [r7, #20]
    }
    return ( error );
    503a:	697b      	ldr	r3, [r7, #20]
}
    503c:	4618      	mov	r0, r3
    503e:	f107 0728 	add.w	r7, r7, #40	; 0x28
    5042:	46bd      	mov	sp, r7
    5044:	bd80      	pop	{r7, pc}
    5046:	bf00      	nop

00005048 <MSS_MAC_rx_pckt_size>:
int32_t
MSS_MAC_rx_pckt_size
(
    void
)
{
    5048:	b580      	push	{r7, lr}
    504a:	b082      	sub	sp, #8
    504c:	af00      	add	r7, sp, #0
    int32_t retval;
    MAC_dismiss_bad_frames();
    504e:	f001 f9a5 	bl	639c <MAC_dismiss_bad_frames>

    if( (g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &	RDES0_OWN) != 0u )
    5052:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5056:	f2c2 0300 	movt	r3, #8192	; 0x2000
    505a:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    505e:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5062:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5066:	ea4f 1202 	mov.w	r2, r2, lsl #4
    506a:	4413      	add	r3, r2
    506c:	f103 0398 	add.w	r3, r3, #152	; 0x98
    5070:	681b      	ldr	r3, [r3, #0]
    5072:	2b00      	cmp	r3, #0
    5074:	da03      	bge.n	507e <MSS_MAC_rx_pckt_size+0x36>
    {
    	/* Current descriptor is empty */
    	retval = 0;
    5076:	f04f 0300 	mov.w	r3, #0
    507a:	603b      	str	r3, [r7, #0]
    507c:	e018      	b.n	50b0 <MSS_MAC_rx_pckt_size+0x68>
    }
    else
    {
        uint32_t frame_length;
        frame_length = ( g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 >> RDES0_FL_OFFSET ) & RDES0_FL_MASK;
    507e:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5082:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5086:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    508a:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    508e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5092:	ea4f 1202 	mov.w	r2, r2, lsl #4
    5096:	4413      	add	r3, r2
    5098:	f103 0398 	add.w	r3, r3, #152	; 0x98
    509c:	681b      	ldr	r3, [r3, #0]
    509e:	ea4f 4313 	mov.w	r3, r3, lsr #16
    50a2:	ea4f 4383 	mov.w	r3, r3, lsl #18
    50a6:	ea4f 4393 	mov.w	r3, r3, lsr #18
    50aa:	607b      	str	r3, [r7, #4]
        retval = (int32_t)( frame_length );
    50ac:	687b      	ldr	r3, [r7, #4]
    50ae:	603b      	str	r3, [r7, #0]
    }
    return retval;
    50b0:	683b      	ldr	r3, [r7, #0]
}
    50b2:	4618      	mov	r0, r3
    50b4:	f107 0708 	add.w	r7, r7, #8
    50b8:	46bd      	mov	sp, r7
    50ba:	bd80      	pop	{r7, pc}

000050bc <MSS_MAC_rx_packet>:
int32_t
MSS_MAC_rx_packet
(
	void
)
{
    50bc:	b590      	push	{r4, r7, lr}
    50be:	b083      	sub	sp, #12
    50c0:	af00      	add	r7, sp, #0
	uint16_t frame_length=0u;
    50c2:	f04f 0300 	mov.w	r3, #0
    50c6:	80fb      	strh	r3, [r7, #6]

    MAC_dismiss_bad_frames();
    50c8:	f001 f968 	bl	639c <MAC_dismiss_bad_frames>

    if( (g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 & RDES0_OWN) == 0u )
    50cc:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    50d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    50d4:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    50d8:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    50dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    50e0:	ea4f 1202 	mov.w	r2, r2, lsl #4
    50e4:	4413      	add	r3, r2
    50e6:	f103 0398 	add.w	r3, r3, #152	; 0x98
    50ea:	681b      	ldr	r3, [r3, #0]
    50ec:	2b00      	cmp	r3, #0
    50ee:	db56      	blt.n	519e <MSS_MAC_rx_packet+0xe2>
    {
        frame_length = ( (
    	    g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 >>
    50f0:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    50f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    50f8:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    50fc:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5100:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5104:	ea4f 1202 	mov.w	r2, r2, lsl #4
    5108:	4413      	add	r3, r2
    510a:	f103 0398 	add.w	r3, r3, #152	; 0x98
    510e:	681b      	ldr	r3, [r3, #0]
    5110:	ea4f 4313 	mov.w	r3, r3, lsr #16

    MAC_dismiss_bad_frames();

    if( (g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 & RDES0_OWN) == 0u )
    {
        frame_length = ( (
    5114:	b29b      	uxth	r3, r3
    5116:	ea4f 4383 	mov.w	r3, r3, lsl #18
    511a:	ea4f 4393 	mov.w	r3, r3, lsr #18
    511e:	80fb      	strh	r3, [r7, #6]
    	    g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 >>
    	    RDES0_FL_OFFSET ) & RDES0_FL_MASK );

        /* strip crc */
        frame_length -= 4u;
    5120:	88fb      	ldrh	r3, [r7, #6]
    5122:	f1a3 0304 	sub.w	r3, r3, #4
    5126:	80fb      	strh	r3, [r7, #6]

        if( frame_length > macBUFFER_SIZE ) {
    5128:	88fb      	ldrh	r3, [r7, #6]
    512a:	f5b3 6fba 	cmp.w	r3, #1488	; 0x5d0
    512e:	d902      	bls.n	5136 <MSS_MAC_rx_packet+0x7a>
        	return MAC_NOT_ENOUGH_SPACE;
    5130:	f06f 0304 	mvn.w	r3, #4
    5134:	e034      	b.n	51a0 <MSS_MAC_rx_packet+0xe4>
        }

		/* uip_buf is about to point to the buffer that contains the received
		data, mark the buffer that uip_buf is currently pointing to as free
		again. */
		MAC_release_buffer( uip_buf );
    5136:	f240 63a4 	movw	r3, #1700	; 0x6a4
    513a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    513e:	681b      	ldr	r3, [r3, #0]
    5140:	4618      	mov	r0, r3
    5142:	f001 fd7d 	bl	6c40 <MAC_release_buffer>
        uip_buf = ( unsigned char * ) g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].buffer_1;
    5146:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    514a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    514e:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    5152:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5156:	f2c2 0300 	movt	r3, #8192	; 0x2000
    515a:	f102 020a 	add.w	r2, r2, #10
    515e:	ea4f 1202 	mov.w	r2, r2, lsl #4
    5162:	4413      	add	r3, r2
    5164:	681b      	ldr	r3, [r3, #0]
    5166:	461a      	mov	r2, r3
    5168:	f240 63a4 	movw	r3, #1700	; 0x6a4
    516c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5170:	601a      	str	r2, [r3, #0]
		
		/* The buffer the Rx descriptor was pointing to is now in use by the
		uIP stack - allocate a new buffer to the Rx descriptor. */
		g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].buffer_1 = ( unsigned long ) MAC_obtain_buffer();
    5172:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5176:	f2c2 0300 	movt	r3, #8192	; 0x2000
    517a:	f8d3 4094 	ldr.w	r4, [r3, #148]	; 0x94
    517e:	f001 fca3 	bl	6ac8 <MAC_obtain_buffer>
    5182:	4603      	mov	r3, r0
    5184:	461a      	mov	r2, r3
    5186:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    518a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    518e:	f104 010a 	add.w	r1, r4, #10
    5192:	ea4f 1101 	mov.w	r1, r1, lsl #4
    5196:	440b      	add	r3, r1
    5198:	601a      	str	r2, [r3, #0]

        MSS_MAC_prepare_rx_descriptor();
    519a:	f000 fcb9 	bl	5b10 <MSS_MAC_prepare_rx_descriptor>
    }
    return ((int32_t)frame_length);
    519e:	88fb      	ldrh	r3, [r7, #6]
}
    51a0:	4618      	mov	r0, r3
    51a2:	f107 070c 	add.w	r7, r7, #12
    51a6:	46bd      	mov	sp, r7
    51a8:	bd90      	pop	{r4, r7, pc}
    51aa:	bf00      	nop

000051ac <MSS_MAC_rx_packet_ptrset>:
MSS_MAC_rx_packet_ptrset
(
    uint8_t **pacData,
    uint32_t time_out
)
{
    51ac:	b580      	push	{r7, lr}
    51ae:	b084      	sub	sp, #16
    51b0:	af00      	add	r7, sp, #0
    51b2:	6078      	str	r0, [r7, #4]
    51b4:	6039      	str	r1, [r7, #0]
	uint16_t frame_length = 0u;
    51b6:	f04f 0300 	mov.w	r3, #0
    51ba:	813b      	strh	r3, [r7, #8]
    int8_t exit = 0;
    51bc:	f04f 0300 	mov.w	r3, #0
    51c0:	72fb      	strb	r3, [r7, #11]

    configASSERT(  (time_out == MSS_MAC_BLOCKING) ||
    51c2:	683b      	ldr	r3, [r7, #0]
    51c4:	f1b3 3fff 	cmp.w	r3, #4294967295
    51c8:	d009      	beq.n	51de <MSS_MAC_rx_packet_ptrset+0x32>
    51ca:	683b      	ldr	r3, [r7, #0]
    51cc:	2b00      	cmp	r3, #0
    51ce:	d006      	beq.n	51de <MSS_MAC_rx_packet_ptrset+0x32>
    51d0:	683b      	ldr	r3, [r7, #0]
    51d2:	2b00      	cmp	r3, #0
    51d4:	d006      	beq.n	51e4 <MSS_MAC_rx_packet_ptrset+0x38>
    51d6:	683b      	ldr	r3, [r7, #0]
    51d8:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
    51dc:	d802      	bhi.n	51e4 <MSS_MAC_rx_packet_ptrset+0x38>
    51de:	f04f 0301 	mov.w	r3, #1
    51e2:	e001      	b.n	51e8 <MSS_MAC_rx_packet_ptrset+0x3c>
    51e4:	f04f 0300 	mov.w	r3, #0
    51e8:	2b00      	cmp	r3, #0
    51ea:	d109      	bne.n	5200 <MSS_MAC_rx_packet_ptrset+0x54>
    51ec:	f04f 0328 	mov.w	r3, #40	; 0x28
    51f0:	f383 8811 	msr	BASEPRI, r3
    51f4:	f3bf 8f6f 	isb	sy
    51f8:	f3bf 8f4f 	dsb	sy
    51fc:	60fb      	str	r3, [r7, #12]
    51fe:	e7fe      	b.n	51fe <MSS_MAC_rx_packet_ptrset+0x52>
    			(time_out == MSS_MAC_NONBLOCKING) ||
    			((time_out >= 1) && (time_out <= 0x01000000UL)) );

    MAC_dismiss_bad_frames();
    5200:	f001 f8cc 	bl	639c <MAC_dismiss_bad_frames>

    /* wait for a packet */
	if( time_out != MSS_MAC_BLOCKING ) {
    5204:	683b      	ldr	r3, [r7, #0]
    5206:	f1b3 3fff 	cmp.w	r3, #4294967295
    520a:	d018      	beq.n	523e <MSS_MAC_rx_packet_ptrset+0x92>
		if( time_out == MSS_MAC_NONBLOCKING ) {
    520c:	683b      	ldr	r3, [r7, #0]
    520e:	2b00      	cmp	r3, #0
    5210:	d104      	bne.n	521c <MSS_MAC_rx_packet_ptrset+0x70>
    		MAC_set_time_out( 0u );
    5212:	f04f 0000 	mov.w	r0, #0
    5216:	f001 f913 	bl	6440 <MAC_set_time_out>
		} else {
    		MAC_set_time_out( time_out );
		}
	}

    while( ((g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    521a:	e011      	b.n	5240 <MSS_MAC_rx_packet_ptrset+0x94>
    /* wait for a packet */
	if( time_out != MSS_MAC_BLOCKING ) {
		if( time_out == MSS_MAC_NONBLOCKING ) {
    		MAC_set_time_out( 0u );
		} else {
    		MAC_set_time_out( time_out );
    521c:	6838      	ldr	r0, [r7, #0]
    521e:	f001 f90f 	bl	6440 <MAC_set_time_out>
		}
	}

    while( ((g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    5222:	e00d      	b.n	5240 <MSS_MAC_rx_packet_ptrset+0x94>
    	RDES0_OWN) != 0u) && (exit == 0) )
    {
    	if( time_out != MSS_MAC_BLOCKING )
    5224:	683b      	ldr	r3, [r7, #0]
    5226:	f1b3 3fff 	cmp.w	r3, #4294967295
    522a:	d009      	beq.n	5240 <MSS_MAC_rx_packet_ptrset+0x94>
    	{
    		if( MAC_get_time_out() == 0u ) {
    522c:	f001 f930 	bl	6490 <MAC_get_time_out>
    5230:	4603      	mov	r3, r0
    5232:	2b00      	cmp	r3, #0
    5234:	d104      	bne.n	5240 <MSS_MAC_rx_packet_ptrset+0x94>
    			exit = 1;
    5236:	f04f 0301 	mov.w	r3, #1
    523a:	72fb      	strb	r3, [r7, #11]
    523c:	e000      	b.n	5240 <MSS_MAC_rx_packet_ptrset+0x94>
		} else {
    		MAC_set_time_out( time_out );
		}
	}

    while( ((g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    523e:	bf00      	nop
    5240:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5244:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5248:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    524c:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5250:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5254:	ea4f 1202 	mov.w	r2, r2, lsl #4
    5258:	4413      	add	r3, r2
    525a:	f103 0398 	add.w	r3, r3, #152	; 0x98
    525e:	681b      	ldr	r3, [r3, #0]
    5260:	2b00      	cmp	r3, #0
    5262:	da03      	bge.n	526c <MSS_MAC_rx_packet_ptrset+0xc0>
    5264:	f997 300b 	ldrsb.w	r3, [r7, #11]
    5268:	2b00      	cmp	r3, #0
    526a:	d0db      	beq.n	5224 <MSS_MAC_rx_packet_ptrset+0x78>
    			exit = 1;
    		}
    	}
    }

    if(exit == 0)
    526c:	f997 300b 	ldrsb.w	r3, [r7, #11]
    5270:	2b00      	cmp	r3, #0
    5272:	d12e      	bne.n	52d2 <MSS_MAC_rx_packet_ptrset+0x126>
    {
        frame_length = ( (
    	    g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 >>
    5274:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5278:	f2c2 0300 	movt	r3, #8192	; 0x2000
    527c:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    5280:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5284:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5288:	ea4f 1202 	mov.w	r2, r2, lsl #4
    528c:	4413      	add	r3, r2
    528e:	f103 0398 	add.w	r3, r3, #152	; 0x98
    5292:	681b      	ldr	r3, [r3, #0]
    5294:	ea4f 4313 	mov.w	r3, r3, lsr #16
    	}
    }

    if(exit == 0)
    {
        frame_length = ( (
    5298:	b29b      	uxth	r3, r3
    529a:	ea4f 4383 	mov.w	r3, r3, lsl #18
    529e:	ea4f 4393 	mov.w	r3, r3, lsr #18
    52a2:	813b      	strh	r3, [r7, #8]
    	    g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 >>
    	    RDES0_FL_OFFSET ) & RDES0_FL_MASK );

        /* strip crc */
        frame_length -= 4u;
    52a4:	893b      	ldrh	r3, [r7, #8]
    52a6:	f1a3 0304 	sub.w	r3, r3, #4
    52aa:	813b      	strh	r3, [r7, #8]
       /* Here we are setting the buffer 'pacData' address to the address
          RX descriptor address. After this is called, the following function
          must be called 'MAC_prepare_rx_descriptor'
          to prepare the current rx descriptor for receiving the next packet.
       */
    	*pacData = (uint8_t *)g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].buffer_1 ;
    52ac:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    52b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    52b4:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    52b8:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    52bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    52c0:	f102 020a 	add.w	r2, r2, #10
    52c4:	ea4f 1202 	mov.w	r2, r2, lsl #4
    52c8:	4413      	add	r3, r2
    52ca:	681b      	ldr	r3, [r3, #0]
    52cc:	461a      	mov	r2, r3
    52ce:	687b      	ldr	r3, [r7, #4]
    52d0:	601a      	str	r2, [r3, #0]

    }
    return ((int32_t)frame_length);
    52d2:	893b      	ldrh	r3, [r7, #8]
}
    52d4:	4618      	mov	r0, r3
    52d6:	f107 0710 	add.w	r7, r7, #16
    52da:	46bd      	mov	sp, r7
    52dc:	bd80      	pop	{r7, pc}
    52de:	bf00      	nop

000052e0 <MSS_MAC_link_status>:
int32_t
MSS_MAC_link_status
(
    void
)
{
    52e0:	b580      	push	{r7, lr}
    52e2:	b082      	sub	sp, #8
    52e4:	af00      	add	r7, sp, #0
	uint32_t link;

    link = PHY_link_status();
    52e6:	f001 fe6b 	bl	6fc0 <PHY_link_status>
    52ea:	4603      	mov	r3, r0
    52ec:	607b      	str	r3, [r7, #4]
    if( link == MSS_MAC_LINK_STATUS_LINK ) {
    52ee:	687b      	ldr	r3, [r7, #4]
    52f0:	2b01      	cmp	r3, #1
    52f2:	d106      	bne.n	5302 <MSS_MAC_link_status+0x22>
    	link |= PHY_link_type();
    52f4:	f001 fe7c 	bl	6ff0 <PHY_link_type>
    52f8:	4603      	mov	r3, r0
    52fa:	687a      	ldr	r2, [r7, #4]
    52fc:	ea42 0303 	orr.w	r3, r2, r3
    5300:	607b      	str	r3, [r7, #4]
    }

    return ((int32_t)link);
    5302:	687b      	ldr	r3, [r7, #4]
}
    5304:	4618      	mov	r0, r3
    5306:	f107 0708 	add.w	r7, r7, #8
    530a:	46bd      	mov	sp, r7
    530c:	bd80      	pop	{r7, pc}
    530e:	bf00      	nop

00005310 <MSS_MAC_auto_setup_link>:
int32_t
MSS_MAC_auto_setup_link
(
    void
)
{
    5310:	b580      	push	{r7, lr}
    5312:	b084      	sub	sp, #16
    5314:	af00      	add	r7, sp, #0
	int32_t link;

    PHY_auto_negotiate();
    5316:	f001 fe2b 	bl	6f70 <PHY_auto_negotiate>

    link = MSS_MAC_link_status();
    531a:	f7ff ffe1 	bl	52e0 <MSS_MAC_link_status>
    531e:	4603      	mov	r3, r0
    5320:	603b      	str	r3, [r7, #0]

    if( (link & MSS_MAC_LINK_STATUS_LINK) != 0u ) {
    5322:	683b      	ldr	r3, [r7, #0]
    5324:	f003 0301 	and.w	r3, r3, #1
    5328:	b2db      	uxtb	r3, r3
    532a:	2b00      	cmp	r3, #0
    532c:	d051      	beq.n	53d2 <MSS_MAC_auto_setup_link+0xc2>
    	int32_t ret;
	    ret = MAC_stop_transmission();
    532e:	f000 ffb9 	bl	62a4 <MAC_stop_transmission>
    5332:	4603      	mov	r3, r0
    5334:	607b      	str	r3, [r7, #4]
	    MAC_CHECK( ret == MAC_OK, ret );
    5336:	687b      	ldr	r3, [r7, #4]
    5338:	2b00      	cmp	r3, #0
    533a:	d013      	beq.n	5364 <MSS_MAC_auto_setup_link+0x54>
    533c:	687b      	ldr	r3, [r7, #4]
    533e:	b2da      	uxtb	r2, r3
    5340:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5344:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5348:	715a      	strb	r2, [r3, #5]
    534a:	687b      	ldr	r3, [r7, #4]
    534c:	2b00      	cmp	r3, #0
    534e:	d009      	beq.n	5364 <MSS_MAC_auto_setup_link+0x54>
    5350:	f04f 0328 	mov.w	r3, #40	; 0x28
    5354:	f383 8811 	msr	BASEPRI, r3
    5358:	f3bf 8f6f 	isb	sy
    535c:	f3bf 8f4f 	dsb	sy
    5360:	60bb      	str	r3, [r7, #8]
    5362:	e7fe      	b.n	5362 <MSS_MAC_auto_setup_link+0x52>

	    ret = MAC_stop_receiving();
    5364:	f000 ffdc 	bl	6320 <MAC_stop_receiving>
    5368:	4603      	mov	r3, r0
    536a:	607b      	str	r3, [r7, #4]
	    MAC_CHECK( ret == MAC_OK, ret );
    536c:	687b      	ldr	r3, [r7, #4]
    536e:	2b00      	cmp	r3, #0
    5370:	d013      	beq.n	539a <MSS_MAC_auto_setup_link+0x8a>
    5372:	687b      	ldr	r3, [r7, #4]
    5374:	b2da      	uxtb	r2, r3
    5376:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    537a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    537e:	715a      	strb	r2, [r3, #5]
    5380:	687b      	ldr	r3, [r7, #4]
    5382:	2b00      	cmp	r3, #0
    5384:	d009      	beq.n	539a <MSS_MAC_auto_setup_link+0x8a>
    5386:	f04f 0328 	mov.w	r3, #40	; 0x28
    538a:	f383 8811 	msr	BASEPRI, r3
    538e:	f3bf 8f6f 	isb	sy
    5392:	f3bf 8f4f 	dsb	sy
    5396:	60fb      	str	r3, [r7, #12]
    5398:	e7fe      	b.n	5398 <MSS_MAC_auto_setup_link+0x88>
        MAC_BITBAND->CSR6_TTM = (uint32_t)((((uint32_t)link & MSS_MAC_LINK_STATUS_100MB) != 0u) ? 1u : 0u );
    539a:	f240 0300 	movw	r3, #0
    539e:	f2c4 2306 	movt	r3, #16902	; 0x4206
    53a2:	683a      	ldr	r2, [r7, #0]
    53a4:	f002 0202 	and.w	r2, r2, #2
    53a8:	2a00      	cmp	r2, #0
    53aa:	d002      	beq.n	53b2 <MSS_MAC_auto_setup_link+0xa2>
    53ac:	f04f 0201 	mov.w	r2, #1
    53b0:	e001      	b.n	53b6 <MSS_MAC_auto_setup_link+0xa6>
    53b2:	f04f 0200 	mov.w	r2, #0
    53b6:	f8c3 2658 	str.w	r2, [r3, #1624]	; 0x658
        MAC_BITBAND->CSR6_FD = (uint32_t)((((uint32_t)link & MSS_MAC_LINK_STATUS_FDX) != 0u) ? 1u : 1u );
    53ba:	f240 0300 	movw	r3, #0
    53be:	f2c4 2306 	movt	r3, #16902	; 0x4206
    53c2:	f04f 0201 	mov.w	r2, #1
    53c6:	f8c3 2624 	str.w	r2, [r3, #1572]	; 0x624
	    MAC_start_transmission();
    53ca:	f000 ff9b 	bl	6304 <MAC_start_transmission>
	    MAC_start_receiving();
    53ce:	f000 ffd7 	bl	6380 <MAC_start_receiving>
    }

    return link;
    53d2:	683b      	ldr	r3, [r7, #0]
}
    53d4:	4618      	mov	r0, r3
    53d6:	f107 0710 	add.w	r7, r7, #16
    53da:	46bd      	mov	sp, r7
    53dc:	bd80      	pop	{r7, pc}
    53de:	bf00      	nop

000053e0 <MSS_MAC_set_mac_address>:
void
MSS_MAC_set_mac_address
(
    const uint8_t *new_address
)
{
    53e0:	b580      	push	{r7, lr}
    53e2:	b084      	sub	sp, #16
    53e4:	af00      	add	r7, sp, #0
    53e6:	6078      	str	r0, [r7, #4]
    /* Check if the new address is unicast */
    configASSERT( (new_address[0]&1) == 0 );
    53e8:	687b      	ldr	r3, [r7, #4]
    53ea:	781b      	ldrb	r3, [r3, #0]
    53ec:	f003 0301 	and.w	r3, r3, #1
    53f0:	2b00      	cmp	r3, #0
    53f2:	d009      	beq.n	5408 <MSS_MAC_set_mac_address+0x28>
    53f4:	f04f 0328 	mov.w	r3, #40	; 0x28
    53f8:	f383 8811 	msr	BASEPRI, r3
    53fc:	f3bf 8f6f 	isb	sy
    5400:	f3bf 8f4f 	dsb	sy
    5404:	60fb      	str	r3, [r7, #12]
    5406:	e7fe      	b.n	5406 <MSS_MAC_set_mac_address+0x26>

   	MAC_memcpy( g_mss_mac.mac_address, new_address, 6u );
    5408:	481c      	ldr	r0, [pc, #112]	; (547c <MSS_MAC_set_mac_address+0x9c>)
    540a:	6879      	ldr	r1, [r7, #4]
    540c:	f04f 0206 	mov.w	r2, #6
    5410:	f001 faf8 	bl	6a04 <MAC_memcpy>

   	if((g_mss_mac.flags & FLAG_PERFECT_FILTERING) != 0u ) {
    5414:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5418:	f2c2 0300 	movt	r3, #8192	; 0x2000
    541c:	791b      	ldrb	r3, [r3, #4]
    541e:	f003 0302 	and.w	r3, r3, #2
    5422:	2b00      	cmp	r3, #0
    5424:	d023      	beq.n	546e <MSS_MAC_set_mac_address+0x8e>
		int32_t a;
	   	/* set unused filters to the new mac address */
		for( a=14*6; a>=0; a-=6 ) {
    5426:	f04f 0354 	mov.w	r3, #84	; 0x54
    542a:	60bb      	str	r3, [r7, #8]
    542c:	e01c      	b.n	5468 <MSS_MAC_set_mac_address+0x88>
			if( (g_mss_mac.mac_filter_data[a] & 1u) != 0u ) {
    542e:	68ba      	ldr	r2, [r7, #8]
    5430:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5434:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5438:	4413      	add	r3, r2
    543a:	7b1b      	ldrb	r3, [r3, #12]
    543c:	f003 0301 	and.w	r3, r3, #1
    5440:	b2db      	uxtb	r3, r3
    5442:	2b00      	cmp	r3, #0
    5444:	d003      	beq.n	544e <MSS_MAC_set_mac_address+0x6e>
				/* Filters with multicast addresses are used */
				a = -1;
    5446:	f04f 33ff 	mov.w	r3, #4294967295
    544a:	60bb      	str	r3, [r7, #8]
    544c:	e008      	b.n	5460 <MSS_MAC_set_mac_address+0x80>
			} else {
				MAC_memcpy( &(g_mss_mac.mac_filter_data[a]),
    544e:	68ba      	ldr	r2, [r7, #8]
    5450:	4b0b      	ldr	r3, [pc, #44]	; (5480 <MSS_MAC_set_mac_address+0xa0>)
    5452:	4413      	add	r3, r2
    5454:	4618      	mov	r0, r3
    5456:	4909      	ldr	r1, [pc, #36]	; (547c <MSS_MAC_set_mac_address+0x9c>)
    5458:	f04f 0206 	mov.w	r2, #6
    545c:	f001 fad2 	bl	6a04 <MAC_memcpy>
   	MAC_memcpy( g_mss_mac.mac_address, new_address, 6u );

   	if((g_mss_mac.flags & FLAG_PERFECT_FILTERING) != 0u ) {
		int32_t a;
	   	/* set unused filters to the new mac address */
		for( a=14*6; a>=0; a-=6 ) {
    5460:	68bb      	ldr	r3, [r7, #8]
    5462:	f1a3 0306 	sub.w	r3, r3, #6
    5466:	60bb      	str	r3, [r7, #8]
    5468:	68bb      	ldr	r3, [r7, #8]
    546a:	2b00      	cmp	r3, #0
    546c:	dadf      	bge.n	542e <MSS_MAC_set_mac_address+0x4e>
					g_mss_mac.mac_address, 6u );
			}
		}
   	}

   	MAC_send_setup_frame();
    546e:	f000 fd63 	bl	5f38 <MAC_send_setup_frame>
}
    5472:	f107 0710 	add.w	r7, r7, #16
    5476:	46bd      	mov	sp, r7
    5478:	bd80      	pop	{r7, pc}
    547a:	bf00      	nop
    547c:	2000aafa 	.word	0x2000aafa
    5480:	2000ab00 	.word	0x2000ab00

00005484 <MSS_MAC_get_mac_address>:
void
MSS_MAC_get_mac_address
(
    uint8_t *address
)
{
    5484:	b580      	push	{r7, lr}
    5486:	b082      	sub	sp, #8
    5488:	af00      	add	r7, sp, #0
    548a:	6078      	str	r0, [r7, #4]
   	MAC_memcpy( address, g_mss_mac.mac_address, 6u );
    548c:	6878      	ldr	r0, [r7, #4]
    548e:	4904      	ldr	r1, [pc, #16]	; (54a0 <MSS_MAC_get_mac_address+0x1c>)
    5490:	f04f 0206 	mov.w	r2, #6
    5494:	f001 fab6 	bl	6a04 <MAC_memcpy>
}
    5498:	f107 0708 	add.w	r7, r7, #8
    549c:	46bd      	mov	sp, r7
    549e:	bd80      	pop	{r7, pc}
    54a0:	2000aafa 	.word	0x2000aafa

000054a4 <MSS_MAC_set_mac_filters>:
MSS_MAC_set_mac_filters
(
	uint16_t filter_count,
	const uint8_t *filters
)
{
    54a4:	b580      	push	{r7, lr}
    54a6:	b08a      	sub	sp, #40	; 0x28
    54a8:	af00      	add	r7, sp, #0
    54aa:	4603      	mov	r3, r0
    54ac:	6039      	str	r1, [r7, #0]
    54ae:	80fb      	strh	r3, [r7, #6]
    configASSERT( (filter_count==0) || (filters != NULL_buffer) );
    54b0:	88fb      	ldrh	r3, [r7, #6]
    54b2:	2b00      	cmp	r3, #0
    54b4:	d007      	beq.n	54c6 <MSS_MAC_set_mac_filters+0x22>
    54b6:	f240 639c 	movw	r3, #1692	; 0x69c
    54ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    54be:	681b      	ldr	r3, [r3, #0]
    54c0:	683a      	ldr	r2, [r7, #0]
    54c2:	429a      	cmp	r2, r3
    54c4:	d002      	beq.n	54cc <MSS_MAC_set_mac_filters+0x28>
    54c6:	f04f 0301 	mov.w	r3, #1
    54ca:	e001      	b.n	54d0 <MSS_MAC_set_mac_filters+0x2c>
    54cc:	f04f 0300 	mov.w	r3, #0
    54d0:	2b00      	cmp	r3, #0
    54d2:	d109      	bne.n	54e8 <MSS_MAC_set_mac_filters+0x44>
    54d4:	f04f 0328 	mov.w	r3, #40	; 0x28
    54d8:	f383 8811 	msr	BASEPRI, r3
    54dc:	f3bf 8f6f 	isb	sy
    54e0:	f3bf 8f4f 	dsb	sy
    54e4:	623b      	str	r3, [r7, #32]
    54e6:	e7fe      	b.n	54e6 <MSS_MAC_set_mac_filters+0x42>
    /* Check if the mac addresses is multicast */
    {
    	int32_t a;
    	for( a = 0u; a < filter_count; a++ ) {
    54e8:	f04f 0300 	mov.w	r3, #0
    54ec:	60fb      	str	r3, [r7, #12]
    54ee:	e01c      	b.n	552a <MSS_MAC_set_mac_filters+0x86>
    		configASSERT( (filters[a*6]&1) == 1 );
    54f0:	68fa      	ldr	r2, [r7, #12]
    54f2:	4613      	mov	r3, r2
    54f4:	ea4f 0343 	mov.w	r3, r3, lsl #1
    54f8:	4413      	add	r3, r2
    54fa:	ea4f 0343 	mov.w	r3, r3, lsl #1
    54fe:	461a      	mov	r2, r3
    5500:	683b      	ldr	r3, [r7, #0]
    5502:	4413      	add	r3, r2
    5504:	781b      	ldrb	r3, [r3, #0]
    5506:	f003 0301 	and.w	r3, r3, #1
    550a:	2b00      	cmp	r3, #0
    550c:	d109      	bne.n	5522 <MSS_MAC_set_mac_filters+0x7e>
    550e:	f04f 0328 	mov.w	r3, #40	; 0x28
    5512:	f383 8811 	msr	BASEPRI, r3
    5516:	f3bf 8f6f 	isb	sy
    551a:	f3bf 8f4f 	dsb	sy
    551e:	627b      	str	r3, [r7, #36]	; 0x24
    5520:	e7fe      	b.n	5520 <MSS_MAC_set_mac_filters+0x7c>
{
    configASSERT( (filter_count==0) || (filters != NULL_buffer) );
    /* Check if the mac addresses is multicast */
    {
    	int32_t a;
    	for( a = 0u; a < filter_count; a++ ) {
    5522:	68fb      	ldr	r3, [r7, #12]
    5524:	f103 0301 	add.w	r3, r3, #1
    5528:	60fb      	str	r3, [r7, #12]
    552a:	88fa      	ldrh	r2, [r7, #6]
    552c:	68fb      	ldr	r3, [r7, #12]
    552e:	429a      	cmp	r2, r3
    5530:	dcde      	bgt.n	54f0 <MSS_MAC_set_mac_filters+0x4c>
    		configASSERT( (filters[a*6]&1) == 1 );
    	}
    }

    if( filter_count <= 15 ){
    5532:	88fb      	ldrh	r3, [r7, #6]
    5534:	2b0f      	cmp	r3, #15
    5536:	d833      	bhi.n	55a0 <MSS_MAC_set_mac_filters+0xfc>
    	int32_t a;
    	g_mss_mac.flags |= FLAG_PERFECT_FILTERING;
    5538:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    553c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5540:	791b      	ldrb	r3, [r3, #4]
    5542:	f043 0302 	orr.w	r3, r3, #2
    5546:	b2da      	uxtb	r2, r3
    5548:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    554c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5550:	711a      	strb	r2, [r3, #4]

    	/* copy new filters */
    	MAC_memcpy( g_mss_mac.mac_filter_data, filters, (uint32_t)(filter_count*6));
    5552:	88fa      	ldrh	r2, [r7, #6]
    5554:	4613      	mov	r3, r2
    5556:	ea4f 0343 	mov.w	r3, r3, lsl #1
    555a:	4413      	add	r3, r2
    555c:	ea4f 0343 	mov.w	r3, r3, lsl #1
    5560:	483c      	ldr	r0, [pc, #240]	; (5654 <MSS_MAC_set_mac_filters+0x1b0>)
    5562:	6839      	ldr	r1, [r7, #0]
    5564:	461a      	mov	r2, r3
    5566:	f001 fa4d 	bl	6a04 <MAC_memcpy>

    	/* set unused filters to our mac address */
    	for( a=filter_count; a<15; a++ ) {
    556a:	88fb      	ldrh	r3, [r7, #6]
    556c:	613b      	str	r3, [r7, #16]
    556e:	e013      	b.n	5598 <MSS_MAC_set_mac_filters+0xf4>
   			MAC_memcpy( &(g_mss_mac.mac_filter_data[a*6]),
    5570:	693a      	ldr	r2, [r7, #16]
    5572:	4613      	mov	r3, r2
    5574:	ea4f 0343 	mov.w	r3, r3, lsl #1
    5578:	4413      	add	r3, r2
    557a:	ea4f 0343 	mov.w	r3, r3, lsl #1
    557e:	461a      	mov	r2, r3
    5580:	4b34      	ldr	r3, [pc, #208]	; (5654 <MSS_MAC_set_mac_filters+0x1b0>)
    5582:	4413      	add	r3, r2
    5584:	4618      	mov	r0, r3
    5586:	4934      	ldr	r1, [pc, #208]	; (5658 <MSS_MAC_set_mac_filters+0x1b4>)
    5588:	f04f 0206 	mov.w	r2, #6
    558c:	f001 fa3a 	bl	6a04 <MAC_memcpy>

    	/* copy new filters */
    	MAC_memcpy( g_mss_mac.mac_filter_data, filters, (uint32_t)(filter_count*6));

    	/* set unused filters to our mac address */
    	for( a=filter_count; a<15; a++ ) {
    5590:	693b      	ldr	r3, [r7, #16]
    5592:	f103 0301 	add.w	r3, r3, #1
    5596:	613b      	str	r3, [r7, #16]
    5598:	693b      	ldr	r3, [r7, #16]
    559a:	2b0e      	cmp	r3, #14
    559c:	dde8      	ble.n	5570 <MSS_MAC_set_mac_filters+0xcc>
    559e:	e052      	b.n	5646 <MSS_MAC_set_mac_filters+0x1a2>
    	}
    } else {
    	int32_t a,b;
    	uint32_t hash;

    	g_mss_mac.flags &= ~FLAG_PERFECT_FILTERING;
    55a0:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    55a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    55a8:	791b      	ldrb	r3, [r3, #4]
    55aa:	461a      	mov	r2, r3
    55ac:	f002 02fd 	and.w	r2, r2, #253	; 0xfd
    55b0:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    55b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    55b8:	711a      	strb	r2, [r3, #4]

    	/* reset hash table */
    	MAC_memset( g_mss_mac.mac_filter_data, 0u, 64u );
    55ba:	4826      	ldr	r0, [pc, #152]	; (5654 <MSS_MAC_set_mac_filters+0x1b0>)
    55bc:	f04f 0100 	mov.w	r1, #0
    55c0:	f04f 0240 	mov.w	r2, #64	; 0x40
    55c4:	f000 ffde 	bl	6584 <MAC_memset>

    	for( a=0, b=0; a<filter_count; a++, b+=6 ) {
    55c8:	f04f 0300 	mov.w	r3, #0
    55cc:	617b      	str	r3, [r7, #20]
    55ce:	f04f 0300 	mov.w	r3, #0
    55d2:	61bb      	str	r3, [r7, #24]
    55d4:	e033      	b.n	563e <MSS_MAC_set_mac_filters+0x19a>
    		hash = mss_ethernet_crc( &(filters[b]), 6 ) & 0x1FF;
    55d6:	69ba      	ldr	r2, [r7, #24]
    55d8:	683b      	ldr	r3, [r7, #0]
    55da:	4413      	add	r3, r2
    55dc:	4618      	mov	r0, r3
    55de:	f04f 0106 	mov.w	r1, #6
    55e2:	f7fe ff0b 	bl	43fc <mss_ethernet_crc>
    55e6:	4603      	mov	r3, r0
    55e8:	ea4f 53c3 	mov.w	r3, r3, lsl #23
    55ec:	ea4f 53d3 	mov.w	r3, r3, lsr #23
    55f0:	61fb      	str	r3, [r7, #28]
    		g_mss_mac.mac_filter_data[ hash / 8 ] |= 1 << (hash & 0x7);
    55f2:	69fb      	ldr	r3, [r7, #28]
    55f4:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    55f8:	4619      	mov	r1, r3
    55fa:	461a      	mov	r2, r3
    55fc:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5600:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5604:	4413      	add	r3, r2
    5606:	7b1b      	ldrb	r3, [r3, #12]
    5608:	461a      	mov	r2, r3
    560a:	69fb      	ldr	r3, [r7, #28]
    560c:	f003 0307 	and.w	r3, r3, #7
    5610:	f04f 0001 	mov.w	r0, #1
    5614:	fa00 f303 	lsl.w	r3, r0, r3
    5618:	b2db      	uxtb	r3, r3
    561a:	ea42 0303 	orr.w	r3, r2, r3
    561e:	b2db      	uxtb	r3, r3
    5620:	b2da      	uxtb	r2, r3
    5622:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5626:	f2c2 0300 	movt	r3, #8192	; 0x2000
    562a:	440b      	add	r3, r1
    562c:	731a      	strb	r2, [r3, #12]
    	g_mss_mac.flags &= ~FLAG_PERFECT_FILTERING;

    	/* reset hash table */
    	MAC_memset( g_mss_mac.mac_filter_data, 0u, 64u );

    	for( a=0, b=0; a<filter_count; a++, b+=6 ) {
    562e:	697b      	ldr	r3, [r7, #20]
    5630:	f103 0301 	add.w	r3, r3, #1
    5634:	617b      	str	r3, [r7, #20]
    5636:	69bb      	ldr	r3, [r7, #24]
    5638:	f103 0306 	add.w	r3, r3, #6
    563c:	61bb      	str	r3, [r7, #24]
    563e:	88fa      	ldrh	r2, [r7, #6]
    5640:	697b      	ldr	r3, [r7, #20]
    5642:	429a      	cmp	r2, r3
    5644:	dcc7      	bgt.n	55d6 <MSS_MAC_set_mac_filters+0x132>
    		hash = mss_ethernet_crc( &(filters[b]), 6 ) & 0x1FF;
    		g_mss_mac.mac_filter_data[ hash / 8 ] |= 1 << (hash & 0x7);
    	}
    }

    MAC_send_setup_frame();
    5646:	f000 fc77 	bl	5f38 <MAC_send_setup_frame>
}
    564a:	f107 0728 	add.w	r7, r7, #40	; 0x28
    564e:	46bd      	mov	sp, r7
    5650:	bd80      	pop	{r7, pc}
    5652:	bf00      	nop
    5654:	2000ab00 	.word	0x2000ab00
    5658:	2000aafa 	.word	0x2000aafa

0000565c <EthernetMAC_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void EthernetMAC_IRQHandler( void )
#else
void EthernetMAC_IRQHandler( void )
#endif
{
    565c:	4668      	mov	r0, sp
    565e:	f020 0107 	bic.w	r1, r0, #7
    5662:	468d      	mov	sp, r1
    5664:	b581      	push	{r0, r7, lr}
    5666:	b083      	sub	sp, #12
    5668:	af00      	add	r7, sp, #0
    uint32_t events;
    uint32_t intr_status;

    events = 0u;
    566a:	f04f 0300 	mov.w	r3, #0
    566e:	603b      	str	r3, [r7, #0]
    intr_status = MAC->CSR5;
    5670:	f243 0300 	movw	r3, #12288	; 0x3000
    5674:	f2c4 0300 	movt	r3, #16384	; 0x4000
    5678:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    567a:	607b      	str	r3, [r7, #4]

    if( (intr_status & CSR5_NIS_MASK) != 0u ) {
    567c:	687b      	ldr	r3, [r7, #4]
    567e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
    5682:	2b00      	cmp	r3, #0
    5684:	d062      	beq.n	574c <EthernetMAC_IRQHandler+0xf0>
    	if( (intr_status & CSR5_TI_MASK) != 0u ) { /* Transmit */
    5686:	687b      	ldr	r3, [r7, #4]
    5688:	f003 0301 	and.w	r3, r3, #1
    568c:	b2db      	uxtb	r3, r3
    568e:	2b00      	cmp	r3, #0
    5690:	d02b      	beq.n	56ea <EthernetMAC_IRQHandler+0x8e>
    		g_mss_mac.statistics.tx_interrupts++;
    5692:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5696:	f2c2 0300 	movt	r3, #8192	; 0x2000
    569a:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
    569e:	ea4f 2212 	mov.w	r2, r2, lsr #8
    56a2:	f893 3118 	ldrb.w	r3, [r3, #280]	; 0x118
    56a6:	ea4f 6303 	mov.w	r3, r3, lsl #24
    56aa:	ea43 0302 	orr.w	r3, r3, r2
    56ae:	f103 0201 	add.w	r2, r3, #1
    56b2:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    56b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    56ba:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    56be:	ea4f 2101 	mov.w	r1, r1, lsl #8
    56c2:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
    56c6:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    56ca:	ea40 0101 	orr.w	r1, r0, r1
    56ce:	f8c3 1114 	str.w	r1, [r3, #276]	; 0x114
    56d2:	ea4f 6212 	mov.w	r2, r2, lsr #24
    56d6:	f04f 0100 	mov.w	r1, #0
    56da:	ea41 0202 	orr.w	r2, r1, r2
    56de:	f883 2118 	strb.w	r2, [r3, #280]	; 0x118
    		events |= MSS_MAC_EVENT_PACKET_SEND;
    56e2:	683b      	ldr	r3, [r7, #0]
    56e4:	f043 0301 	orr.w	r3, r3, #1
    56e8:	603b      	str	r3, [r7, #0]
    	}

    	if( (intr_status & CSR5_RI_MASK) != 0u ) { /* Receive */
    56ea:	687b      	ldr	r3, [r7, #4]
    56ec:	f003 0340 	and.w	r3, r3, #64	; 0x40
    56f0:	2b00      	cmp	r3, #0
    56f2:	d02b      	beq.n	574c <EthernetMAC_IRQHandler+0xf0>
    		g_mss_mac.statistics.rx_interrupts++;
    56f4:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    56f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    56fc:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
    5700:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5704:	f893 30ec 	ldrb.w	r3, [r3, #236]	; 0xec
    5708:	ea4f 6303 	mov.w	r3, r3, lsl #24
    570c:	ea43 0302 	orr.w	r3, r3, r2
    5710:	f103 0201 	add.w	r2, r3, #1
    5714:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5718:	f2c2 0300 	movt	r3, #8192	; 0x2000
    571c:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    5720:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5724:	f8d3 00e8 	ldr.w	r0, [r3, #232]	; 0xe8
    5728:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    572c:	ea40 0101 	orr.w	r1, r0, r1
    5730:	f8c3 10e8 	str.w	r1, [r3, #232]	; 0xe8
    5734:	ea4f 6212 	mov.w	r2, r2, lsr #24
    5738:	f04f 0100 	mov.w	r1, #0
    573c:	ea41 0202 	orr.w	r2, r1, r2
    5740:	f883 20ec 	strb.w	r2, [r3, #236]	; 0xec
    		events |= MSS_MAC_EVENT_PACKET_RECEIVED;
    5744:	683b      	ldr	r3, [r7, #0]
    5746:	f043 0302 	orr.w	r3, r3, #2
    574a:	603b      	str	r3, [r7, #0]
    	}
    }

    /* Clear interrupts */
    MAC->CSR5 = CSR5_INT_BITS;
    574c:	f243 0300 	movw	r3, #12288	; 0x3000
    5750:	f2c4 0300 	movt	r3, #16384	; 0x4000
    5754:	f64c 52e7 	movw	r2, #52711	; 0xcde7
    5758:	f2c0 0201 	movt	r2, #1
    575c:	629a      	str	r2, [r3, #40]	; 0x28

    if( (events != 0u) && (g_mss_mac.listener != NULL_callback) ) {
    575e:	683b      	ldr	r3, [r7, #0]
    5760:	2b00      	cmp	r3, #0
    5762:	d012      	beq.n	578a <EthernetMAC_IRQHandler+0x12e>
    5764:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5768:	f2c2 0300 	movt	r3, #8192	; 0x2000
    576c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    576e:	f240 63a0 	movw	r3, #1696	; 0x6a0
    5772:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5776:	681b      	ldr	r3, [r3, #0]
    5778:	429a      	cmp	r2, r3
    577a:	d006      	beq.n	578a <EthernetMAC_IRQHandler+0x12e>
        g_mss_mac.listener( events );
    577c:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5780:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5784:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    5786:	6838      	ldr	r0, [r7, #0]
    5788:	4798      	blx	r3
    }
}
    578a:	f107 070c 	add.w	r7, r7, #12
    578e:	46bd      	mov	sp, r7
    5790:	e8bd 4081 	ldmia.w	sp!, {r0, r7, lr}
    5794:	4685      	mov	sp, r0
    5796:	4770      	bx	lr

00005798 <MSS_MAC_set_callback>:
void
MSS_MAC_set_callback
(
    MSS_MAC_callback_t listener
)
{
    5798:	b480      	push	{r7}
    579a:	b083      	sub	sp, #12
    579c:	af00      	add	r7, sp, #0
    579e:	6078      	str	r0, [r7, #4]
	/* disable tx and rx interrupts */
    MAC_BITBAND->CSR7_RIE = 0u;
    57a0:	f240 0300 	movw	r3, #0
    57a4:	f2c4 2306 	movt	r3, #16902	; 0x4206
    57a8:	f04f 0200 	mov.w	r2, #0
    57ac:	f8c3 2718 	str.w	r2, [r3, #1816]	; 0x718
    MAC_BITBAND->CSR7_TIE = 0u;
    57b0:	f240 0300 	movw	r3, #0
    57b4:	f2c4 2306 	movt	r3, #16902	; 0x4206
    57b8:	f04f 0200 	mov.w	r2, #0
    57bc:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700

    g_mss_mac.listener = listener;
    57c0:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    57c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    57c8:	687a      	ldr	r2, [r7, #4]
    57ca:	66da      	str	r2, [r3, #108]	; 0x6c

	if( listener != NULL_callback ) {
    57cc:	f240 63a0 	movw	r3, #1696	; 0x6a0
    57d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    57d4:	681b      	ldr	r3, [r3, #0]
    57d6:	687a      	ldr	r2, [r7, #4]
    57d8:	429a      	cmp	r2, r3
    57da:	d00f      	beq.n	57fc <MSS_MAC_set_callback+0x64>
		/* enable tx and rx interrupts */
        MAC_BITBAND->CSR7_RIE = 1u;
    57dc:	f240 0300 	movw	r3, #0
    57e0:	f2c4 2306 	movt	r3, #16902	; 0x4206
    57e4:	f04f 0201 	mov.w	r2, #1
    57e8:	f8c3 2718 	str.w	r2, [r3, #1816]	; 0x718
        MAC_BITBAND->CSR7_TIE = 1u;
    57ec:	f240 0300 	movw	r3, #0
    57f0:	f2c4 2306 	movt	r3, #16902	; 0x4206
    57f4:	f04f 0201 	mov.w	r2, #1
    57f8:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700
	}
}
    57fc:	f107 070c 	add.w	r7, r7, #12
    5800:	46bd      	mov	sp, r7
    5802:	bc80      	pop	{r7}
    5804:	4770      	bx	lr
    5806:	bf00      	nop

00005808 <MSS_MAC_last_error>:
const int8_t*
MSS_MAC_last_error
(
    void
)
{
    5808:	b480      	push	{r7}
    580a:	b083      	sub	sp, #12
    580c:	af00      	add	r7, sp, #0
	int8_t error_msg_nb;
    const int8_t* returnvalue;

	error_msg_nb = -(g_mss_mac.last_error);
    580e:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5812:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5816:	795b      	ldrb	r3, [r3, #5]
    5818:	f1c3 0300 	rsb	r3, r3, #0
    581c:	70fb      	strb	r3, [r7, #3]
	if( error_msg_nb >= ERROR_MESSAGE_COUNT ) {
    581e:	f997 3003 	ldrsb.w	r3, [r7, #3]
    5822:	2b07      	cmp	r3, #7
    5824:	dd05      	ble.n	5832 <MSS_MAC_last_error+0x2a>
		returnvalue = unknown_error;
    5826:	f24b 43b4 	movw	r3, #46260	; 0xb4b4
    582a:	f2c0 0301 	movt	r3, #1
    582e:	607b      	str	r3, [r7, #4]
    5830:	e00d      	b.n	584e <MSS_MAC_last_error+0x46>
	} else {
		returnvalue = ErrorMessages[error_msg_nb];
    5832:	f24b 42c4 	movw	r2, #46276	; 0xb4c4
    5836:	f2c0 0201 	movt	r2, #1
    583a:	f997 1003 	ldrsb.w	r1, [r7, #3]
    583e:	460b      	mov	r3, r1
    5840:	ea4f 0383 	mov.w	r3, r3, lsl #2
    5844:	440b      	add	r3, r1
    5846:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    584a:	4413      	add	r3, r2
    584c:	607b      	str	r3, [r7, #4]
	}
	return returnvalue;
    584e:	687b      	ldr	r3, [r7, #4]
}
    5850:	4618      	mov	r0, r3
    5852:	f107 070c 	add.w	r7, r7, #12
    5856:	46bd      	mov	sp, r7
    5858:	bc80      	pop	{r7}
    585a:	4770      	bx	lr

0000585c <MSS_MAC_get_statistics>:
uint32_t
MSS_MAC_get_statistics
(
    mss_mac_statistics_id_t stat_id
)
{
    585c:	b480      	push	{r7}
    585e:	b085      	sub	sp, #20
    5860:	af00      	add	r7, sp, #0
    5862:	4603      	mov	r3, r0
    5864:	71fb      	strb	r3, [r7, #7]
    uint32_t returnval = 0u;
    5866:	f04f 0300 	mov.w	r3, #0
    586a:	60fb      	str	r3, [r7, #12]

	switch( stat_id ) {
    586c:	79fb      	ldrb	r3, [r7, #7]
    586e:	2b11      	cmp	r3, #17
    5870:	f200 8147 	bhi.w	5b02 <MSS_MAC_get_statistics+0x2a6>
    5874:	a201      	add	r2, pc, #4	; (adr r2, 587c <MSS_MAC_get_statistics+0x20>)
    5876:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    587a:	bf00      	nop
    587c:	000058c5 	.word	0x000058c5
    5880:	000058e5 	.word	0x000058e5
    5884:	00005905 	.word	0x00005905
    5888:	00005925 	.word	0x00005925
    588c:	00005945 	.word	0x00005945
    5890:	00005965 	.word	0x00005965
    5894:	00005985 	.word	0x00005985
    5898:	000059a5 	.word	0x000059a5
    589c:	000059c5 	.word	0x000059c5
    58a0:	000059e5 	.word	0x000059e5
    58a4:	00005a05 	.word	0x00005a05
    58a8:	00005a25 	.word	0x00005a25
    58ac:	00005a45 	.word	0x00005a45
    58b0:	00005a65 	.word	0x00005a65
    58b4:	00005a85 	.word	0x00005a85
    58b8:	00005aa5 	.word	0x00005aa5
    58bc:	00005ac5 	.word	0x00005ac5
    58c0:	00005ae5 	.word	0x00005ae5
	case MSS_MAC_RX_INTERRUPTS:
		returnval = g_mss_mac.statistics.rx_interrupts;
    58c4:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    58c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    58cc:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
    58d0:	ea4f 2212 	mov.w	r2, r2, lsr #8
    58d4:	f893 30ec 	ldrb.w	r3, [r3, #236]	; 0xec
    58d8:	ea4f 6303 	mov.w	r3, r3, lsl #24
    58dc:	ea43 0302 	orr.w	r3, r3, r2
    58e0:	60fb      	str	r3, [r7, #12]
        break;
    58e2:	e10e      	b.n	5b02 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_FILTERING_FAIL:
		returnval = g_mss_mac.statistics.rx_filtering_fail;
    58e4:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    58e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    58ec:	f8d3 20ec 	ldr.w	r2, [r3, #236]	; 0xec
    58f0:	ea4f 2212 	mov.w	r2, r2, lsr #8
    58f4:	f893 30f0 	ldrb.w	r3, [r3, #240]	; 0xf0
    58f8:	ea4f 6303 	mov.w	r3, r3, lsl #24
    58fc:	ea43 0302 	orr.w	r3, r3, r2
    5900:	60fb      	str	r3, [r7, #12]
        break;
    5902:	e0fe      	b.n	5b02 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_DESCRIPTOR_ERROR:
		returnval = g_mss_mac.statistics.rx_descriptor_error;
    5904:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5908:	f2c2 0300 	movt	r3, #8192	; 0x2000
    590c:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
    5910:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5914:	f893 30f4 	ldrb.w	r3, [r3, #244]	; 0xf4
    5918:	ea4f 6303 	mov.w	r3, r3, lsl #24
    591c:	ea43 0302 	orr.w	r3, r3, r2
    5920:	60fb      	str	r3, [r7, #12]
        break;
    5922:	e0ee      	b.n	5b02 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_RUNT_FRAME:
		returnval = g_mss_mac.statistics.rx_runt_frame;
    5924:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5928:	f2c2 0300 	movt	r3, #8192	; 0x2000
    592c:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
    5930:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5934:	f893 30f8 	ldrb.w	r3, [r3, #248]	; 0xf8
    5938:	ea4f 6303 	mov.w	r3, r3, lsl #24
    593c:	ea43 0302 	orr.w	r3, r3, r2
    5940:	60fb      	str	r3, [r7, #12]
        break;
    5942:	e0de      	b.n	5b02 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_NOT_FIRST:
		returnval = g_mss_mac.statistics.rx_not_first;
    5944:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5948:	f2c2 0300 	movt	r3, #8192	; 0x2000
    594c:	f8d3 20f8 	ldr.w	r2, [r3, #248]	; 0xf8
    5950:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5954:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
    5958:	ea4f 6303 	mov.w	r3, r3, lsl #24
    595c:	ea43 0302 	orr.w	r3, r3, r2
    5960:	60fb      	str	r3, [r7, #12]
        break;
    5962:	e0ce      	b.n	5b02 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_NOT_LAST:
		returnval = g_mss_mac.statistics.rx_not_last;
    5964:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5968:	f2c2 0300 	movt	r3, #8192	; 0x2000
    596c:	f8d3 20fc 	ldr.w	r2, [r3, #252]	; 0xfc
    5970:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5974:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
    5978:	ea4f 6303 	mov.w	r3, r3, lsl #24
    597c:	ea43 0302 	orr.w	r3, r3, r2
    5980:	60fb      	str	r3, [r7, #12]
        break;
    5982:	e0be      	b.n	5b02 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_FRAME_TOO_LONG:
		returnval = g_mss_mac.statistics.rx_frame_too_long;
    5984:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5988:	f2c2 0300 	movt	r3, #8192	; 0x2000
    598c:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    5990:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5994:	f893 3104 	ldrb.w	r3, [r3, #260]	; 0x104
    5998:	ea4f 6303 	mov.w	r3, r3, lsl #24
    599c:	ea43 0302 	orr.w	r3, r3, r2
    59a0:	60fb      	str	r3, [r7, #12]
        break;
    59a2:	e0ae      	b.n	5b02 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_COLLISION_SEEN:
		returnval = g_mss_mac.statistics.rx_collision_seen;
    59a4:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    59a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    59ac:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    59b0:	ea4f 2212 	mov.w	r2, r2, lsr #8
    59b4:	f893 3108 	ldrb.w	r3, [r3, #264]	; 0x108
    59b8:	ea4f 6303 	mov.w	r3, r3, lsl #24
    59bc:	ea43 0302 	orr.w	r3, r3, r2
    59c0:	60fb      	str	r3, [r7, #12]
        break;
    59c2:	e09e      	b.n	5b02 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_CRC_ERROR:
		returnval = g_mss_mac.statistics.rx_crc_error;
    59c4:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    59c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    59cc:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
    59d0:	ea4f 2212 	mov.w	r2, r2, lsr #8
    59d4:	f893 310c 	ldrb.w	r3, [r3, #268]	; 0x10c
    59d8:	ea4f 6303 	mov.w	r3, r3, lsl #24
    59dc:	ea43 0302 	orr.w	r3, r3, r2
    59e0:	60fb      	str	r3, [r7, #12]
        break;
    59e2:	e08e      	b.n	5b02 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_FIFO_OVERFLOW:
		returnval = g_mss_mac.statistics.rx_fifo_overflow;
    59e4:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    59e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    59ec:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    59f0:	ea4f 2212 	mov.w	r2, r2, lsr #8
    59f4:	f893 3110 	ldrb.w	r3, [r3, #272]	; 0x110
    59f8:	ea4f 6303 	mov.w	r3, r3, lsl #24
    59fc:	ea43 0302 	orr.w	r3, r3, r2
    5a00:	60fb      	str	r3, [r7, #12]
        break;
    5a02:	e07e      	b.n	5b02 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_MISSED_FRAME:
		returnval = g_mss_mac.statistics.rx_missed_frame;
    5a04:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5a08:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5a0c:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    5a10:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5a14:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
    5a18:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5a1c:	ea43 0302 	orr.w	r3, r3, r2
    5a20:	60fb      	str	r3, [r7, #12]
        break;
    5a22:	e06e      	b.n	5b02 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_TX_INTERRUPTS:
		returnval = g_mss_mac.statistics.tx_interrupts;
    5a24:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5a28:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5a2c:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
    5a30:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5a34:	f893 3118 	ldrb.w	r3, [r3, #280]	; 0x118
    5a38:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5a3c:	ea43 0302 	orr.w	r3, r3, r2
    5a40:	60fb      	str	r3, [r7, #12]
        break;
    5a42:	e05e      	b.n	5b02 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_TX_LOSS_OF_CARRIER:
		returnval = g_mss_mac.statistics.tx_loss_of_carrier;
    5a44:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5a48:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5a4c:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    5a50:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5a54:	f893 311c 	ldrb.w	r3, [r3, #284]	; 0x11c
    5a58:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5a5c:	ea43 0302 	orr.w	r3, r3, r2
    5a60:	60fb      	str	r3, [r7, #12]
        break;
    5a62:	e04e      	b.n	5b02 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_TX_NO_CARRIER:
		returnval = g_mss_mac.statistics.tx_no_carrier;
    5a64:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5a68:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5a6c:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
    5a70:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5a74:	f893 3120 	ldrb.w	r3, [r3, #288]	; 0x120
    5a78:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5a7c:	ea43 0302 	orr.w	r3, r3, r2
    5a80:	60fb      	str	r3, [r7, #12]
        break;
    5a82:	e03e      	b.n	5b02 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_TX_LATE_COLLISION:
		returnval = g_mss_mac.statistics.tx_late_collision;
    5a84:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5a88:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5a8c:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    5a90:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5a94:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
    5a98:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5a9c:	ea43 0302 	orr.w	r3, r3, r2
    5aa0:	60fb      	str	r3, [r7, #12]
        break;
    5aa2:	e02e      	b.n	5b02 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_TX_EXCESSIVE_COLLISION:
		returnval = g_mss_mac.statistics.tx_excessive_collision;
    5aa4:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5aa8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5aac:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    5ab0:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5ab4:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
    5ab8:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5abc:	ea43 0302 	orr.w	r3, r3, r2
    5ac0:	60fb      	str	r3, [r7, #12]
        break;
    5ac2:	e01e      	b.n	5b02 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_TX_COLLISION_COUNT:
		returnval = g_mss_mac.statistics.tx_collision_count;
    5ac4:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5ac8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5acc:	f8d3 2128 	ldr.w	r2, [r3, #296]	; 0x128
    5ad0:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5ad4:	f893 312c 	ldrb.w	r3, [r3, #300]	; 0x12c
    5ad8:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5adc:	ea43 0302 	orr.w	r3, r3, r2
    5ae0:	60fb      	str	r3, [r7, #12]
        break;
    5ae2:	e00e      	b.n	5b02 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_TX_UNDERFLOW_ERROR:
		returnval = g_mss_mac.statistics.tx_underflow_error;
    5ae4:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5ae8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5aec:	f8d3 212c 	ldr.w	r2, [r3, #300]	; 0x12c
    5af0:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5af4:	f893 3130 	ldrb.w	r3, [r3, #304]	; 0x130
    5af8:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5afc:	ea43 0302 	orr.w	r3, r3, r2
    5b00:	60fb      	str	r3, [r7, #12]
        break;
    default:
        break;
	}

	return returnval;
    5b02:	68fb      	ldr	r3, [r7, #12]
}
    5b04:	4618      	mov	r0, r3
    5b06:	f107 0714 	add.w	r7, r7, #20
    5b0a:	46bd      	mov	sp, r7
    5b0c:	bc80      	pop	{r7}
    5b0e:	4770      	bx	lr

00005b10 <MSS_MAC_prepare_rx_descriptor>:
void
MSS_MAC_prepare_rx_descriptor
(
    void
)
{
    5b10:	b580      	push	{r7, lr}
    5b12:	b082      	sub	sp, #8
    5b14:	af00      	add	r7, sp, #0
	uint32_t desc;

	/* update counters */
	desc = g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0;
    5b16:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5b1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5b1e:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    5b22:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5b26:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5b2a:	ea4f 1202 	mov.w	r2, r2, lsl #4
    5b2e:	4413      	add	r3, r2
    5b30:	f103 0398 	add.w	r3, r3, #152	; 0x98
    5b34:	681b      	ldr	r3, [r3, #0]
    5b36:	607b      	str	r3, [r7, #4]
	if( (desc & RDES0_FF) != 0u ) {
    5b38:	687b      	ldr	r3, [r7, #4]
    5b3a:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
    5b3e:	2b00      	cmp	r3, #0
    5b40:	d027      	beq.n	5b92 <MSS_MAC_prepare_rx_descriptor+0x82>
		g_mss_mac.statistics.rx_filtering_fail++;
    5b42:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5b46:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5b4a:	f8d3 20ec 	ldr.w	r2, [r3, #236]	; 0xec
    5b4e:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5b52:	f893 30f0 	ldrb.w	r3, [r3, #240]	; 0xf0
    5b56:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5b5a:	ea43 0302 	orr.w	r3, r3, r2
    5b5e:	f103 0201 	add.w	r2, r3, #1
    5b62:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5b66:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5b6a:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    5b6e:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5b72:	f8d3 00ec 	ldr.w	r0, [r3, #236]	; 0xec
    5b76:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    5b7a:	ea40 0101 	orr.w	r1, r0, r1
    5b7e:	f8c3 10ec 	str.w	r1, [r3, #236]	; 0xec
    5b82:	ea4f 6212 	mov.w	r2, r2, lsr #24
    5b86:	f04f 0100 	mov.w	r1, #0
    5b8a:	ea41 0202 	orr.w	r2, r1, r2
    5b8e:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
	}
	if( (desc & RDES0_DE) != 0u ) {
    5b92:	687b      	ldr	r3, [r7, #4]
    5b94:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    5b98:	2b00      	cmp	r3, #0
    5b9a:	d027      	beq.n	5bec <MSS_MAC_prepare_rx_descriptor+0xdc>
		g_mss_mac.statistics.rx_descriptor_error++;
    5b9c:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5ba0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5ba4:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
    5ba8:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5bac:	f893 30f4 	ldrb.w	r3, [r3, #244]	; 0xf4
    5bb0:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5bb4:	ea43 0302 	orr.w	r3, r3, r2
    5bb8:	f103 0201 	add.w	r2, r3, #1
    5bbc:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5bc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5bc4:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    5bc8:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5bcc:	f8d3 00f0 	ldr.w	r0, [r3, #240]	; 0xf0
    5bd0:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    5bd4:	ea40 0101 	orr.w	r1, r0, r1
    5bd8:	f8c3 10f0 	str.w	r1, [r3, #240]	; 0xf0
    5bdc:	ea4f 6212 	mov.w	r2, r2, lsr #24
    5be0:	f04f 0100 	mov.w	r1, #0
    5be4:	ea41 0202 	orr.w	r2, r1, r2
    5be8:	f883 20f4 	strb.w	r2, [r3, #244]	; 0xf4
	}
	if( (desc & RDES0_RF) != 0u ) {
    5bec:	687b      	ldr	r3, [r7, #4]
    5bee:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    5bf2:	2b00      	cmp	r3, #0
    5bf4:	d027      	beq.n	5c46 <MSS_MAC_prepare_rx_descriptor+0x136>
		g_mss_mac.statistics.rx_runt_frame++;
    5bf6:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5bfa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5bfe:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
    5c02:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5c06:	f893 30f8 	ldrb.w	r3, [r3, #248]	; 0xf8
    5c0a:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5c0e:	ea43 0302 	orr.w	r3, r3, r2
    5c12:	f103 0201 	add.w	r2, r3, #1
    5c16:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5c1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5c1e:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    5c22:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5c26:	f8d3 00f4 	ldr.w	r0, [r3, #244]	; 0xf4
    5c2a:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    5c2e:	ea40 0101 	orr.w	r1, r0, r1
    5c32:	f8c3 10f4 	str.w	r1, [r3, #244]	; 0xf4
    5c36:	ea4f 6212 	mov.w	r2, r2, lsr #24
    5c3a:	f04f 0100 	mov.w	r1, #0
    5c3e:	ea41 0202 	orr.w	r2, r1, r2
    5c42:	f883 20f8 	strb.w	r2, [r3, #248]	; 0xf8
	}
	if( (desc & RDES0_FS) == 0u ) {
    5c46:	687b      	ldr	r3, [r7, #4]
    5c48:	f403 7300 	and.w	r3, r3, #512	; 0x200
    5c4c:	2b00      	cmp	r3, #0
    5c4e:	d127      	bne.n	5ca0 <MSS_MAC_prepare_rx_descriptor+0x190>
		g_mss_mac.statistics.rx_not_first++;
    5c50:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5c54:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5c58:	f8d3 20f8 	ldr.w	r2, [r3, #248]	; 0xf8
    5c5c:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5c60:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
    5c64:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5c68:	ea43 0302 	orr.w	r3, r3, r2
    5c6c:	f103 0201 	add.w	r2, r3, #1
    5c70:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5c74:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5c78:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    5c7c:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5c80:	f8d3 00f8 	ldr.w	r0, [r3, #248]	; 0xf8
    5c84:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    5c88:	ea40 0101 	orr.w	r1, r0, r1
    5c8c:	f8c3 10f8 	str.w	r1, [r3, #248]	; 0xf8
    5c90:	ea4f 6212 	mov.w	r2, r2, lsr #24
    5c94:	f04f 0100 	mov.w	r1, #0
    5c98:	ea41 0202 	orr.w	r2, r1, r2
    5c9c:	f883 20fc 	strb.w	r2, [r3, #252]	; 0xfc
	}
	if( (desc & RDES0_LS) == 0u ) {
    5ca0:	687b      	ldr	r3, [r7, #4]
    5ca2:	f403 7380 	and.w	r3, r3, #256	; 0x100
    5ca6:	2b00      	cmp	r3, #0
    5ca8:	d127      	bne.n	5cfa <MSS_MAC_prepare_rx_descriptor+0x1ea>
		g_mss_mac.statistics.rx_not_last++;
    5caa:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5cae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5cb2:	f8d3 20fc 	ldr.w	r2, [r3, #252]	; 0xfc
    5cb6:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5cba:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
    5cbe:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5cc2:	ea43 0302 	orr.w	r3, r3, r2
    5cc6:	f103 0201 	add.w	r2, r3, #1
    5cca:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5cce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5cd2:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    5cd6:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5cda:	f8d3 00fc 	ldr.w	r0, [r3, #252]	; 0xfc
    5cde:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    5ce2:	ea40 0101 	orr.w	r1, r0, r1
    5ce6:	f8c3 10fc 	str.w	r1, [r3, #252]	; 0xfc
    5cea:	ea4f 6212 	mov.w	r2, r2, lsr #24
    5cee:	f04f 0100 	mov.w	r1, #0
    5cf2:	ea41 0202 	orr.w	r2, r1, r2
    5cf6:	f883 2100 	strb.w	r2, [r3, #256]	; 0x100
	}
	if( (desc & RDES0_TL) != 0u ) {
    5cfa:	687b      	ldr	r3, [r7, #4]
    5cfc:	f003 0380 	and.w	r3, r3, #128	; 0x80
    5d00:	2b00      	cmp	r3, #0
    5d02:	d027      	beq.n	5d54 <MSS_MAC_prepare_rx_descriptor+0x244>
		g_mss_mac.statistics.rx_frame_too_long++;
    5d04:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5d08:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5d0c:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    5d10:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5d14:	f893 3104 	ldrb.w	r3, [r3, #260]	; 0x104
    5d18:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5d1c:	ea43 0302 	orr.w	r3, r3, r2
    5d20:	f103 0201 	add.w	r2, r3, #1
    5d24:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5d28:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5d2c:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    5d30:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5d34:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
    5d38:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    5d3c:	ea40 0101 	orr.w	r1, r0, r1
    5d40:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
    5d44:	ea4f 6212 	mov.w	r2, r2, lsr #24
    5d48:	f04f 0100 	mov.w	r1, #0
    5d4c:	ea41 0202 	orr.w	r2, r1, r2
    5d50:	f883 2104 	strb.w	r2, [r3, #260]	; 0x104
	}
	if( (desc & RDES0_CS) != 0u ) {
    5d54:	687b      	ldr	r3, [r7, #4]
    5d56:	f003 0340 	and.w	r3, r3, #64	; 0x40
    5d5a:	2b00      	cmp	r3, #0
    5d5c:	d027      	beq.n	5dae <MSS_MAC_prepare_rx_descriptor+0x29e>
		g_mss_mac.statistics.rx_collision_seen++;
    5d5e:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5d62:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5d66:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    5d6a:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5d6e:	f893 3108 	ldrb.w	r3, [r3, #264]	; 0x108
    5d72:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5d76:	ea43 0302 	orr.w	r3, r3, r2
    5d7a:	f103 0201 	add.w	r2, r3, #1
    5d7e:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5d82:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5d86:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    5d8a:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5d8e:	f8d3 0104 	ldr.w	r0, [r3, #260]	; 0x104
    5d92:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    5d96:	ea40 0101 	orr.w	r1, r0, r1
    5d9a:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
    5d9e:	ea4f 6212 	mov.w	r2, r2, lsr #24
    5da2:	f04f 0100 	mov.w	r1, #0
    5da6:	ea41 0202 	orr.w	r2, r1, r2
    5daa:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
	}
	if( (desc & RDES0_CE) != 0u ) {
    5dae:	687b      	ldr	r3, [r7, #4]
    5db0:	f003 0302 	and.w	r3, r3, #2
    5db4:	2b00      	cmp	r3, #0
    5db6:	d027      	beq.n	5e08 <MSS_MAC_prepare_rx_descriptor+0x2f8>
		g_mss_mac.statistics.rx_crc_error++;
    5db8:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5dbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5dc0:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
    5dc4:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5dc8:	f893 310c 	ldrb.w	r3, [r3, #268]	; 0x10c
    5dcc:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5dd0:	ea43 0302 	orr.w	r3, r3, r2
    5dd4:	f103 0201 	add.w	r2, r3, #1
    5dd8:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5ddc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5de0:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    5de4:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5de8:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
    5dec:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    5df0:	ea40 0101 	orr.w	r1, r0, r1
    5df4:	f8c3 1108 	str.w	r1, [r3, #264]	; 0x108
    5df8:	ea4f 6212 	mov.w	r2, r2, lsr #24
    5dfc:	f04f 0100 	mov.w	r1, #0
    5e00:	ea41 0202 	orr.w	r2, r1, r2
    5e04:	f883 210c 	strb.w	r2, [r3, #268]	; 0x10c
	}

	desc = MAC->CSR8;
    5e08:	f243 0300 	movw	r3, #12288	; 0x3000
    5e0c:	f2c4 0300 	movt	r3, #16384	; 0x4000
    5e10:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    5e12:	607b      	str	r3, [r7, #4]
	g_mss_mac.statistics.rx_fifo_overflow +=
    5e14:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5e18:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5e1c:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    5e20:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5e24:	f893 3110 	ldrb.w	r3, [r3, #272]	; 0x110
    5e28:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5e2c:	ea43 0302 	orr.w	r3, r3, r2
    5e30:	461a      	mov	r2, r3
		(desc & (CSR8_OCO_MASK|CSR8_FOC_MASK)) >> CSR8_FOC_SHIFT;
    5e32:	6879      	ldr	r1, [r7, #4]
    5e34:	f240 0300 	movw	r3, #0
    5e38:	f6c1 73fe 	movt	r3, #8190	; 0x1ffe
    5e3c:	ea01 0303 	and.w	r3, r1, r3
    5e40:	ea4f 4353 	mov.w	r3, r3, lsr #17
	if( (desc & RDES0_CE) != 0u ) {
		g_mss_mac.statistics.rx_crc_error++;
	}

	desc = MAC->CSR8;
	g_mss_mac.statistics.rx_fifo_overflow +=
    5e44:	441a      	add	r2, r3
    5e46:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5e4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5e4e:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    5e52:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5e56:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
    5e5a:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    5e5e:	ea40 0101 	orr.w	r1, r0, r1
    5e62:	f8c3 110c 	str.w	r1, [r3, #268]	; 0x10c
    5e66:	ea4f 6212 	mov.w	r2, r2, lsr #24
    5e6a:	f04f 0100 	mov.w	r1, #0
    5e6e:	ea41 0202 	orr.w	r2, r1, r2
    5e72:	f883 2110 	strb.w	r2, [r3, #272]	; 0x110
		(desc & (CSR8_OCO_MASK|CSR8_FOC_MASK)) >> CSR8_FOC_SHIFT;
	g_mss_mac.statistics.rx_missed_frame +=
    5e76:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5e7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5e7e:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    5e82:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5e86:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
    5e8a:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5e8e:	ea43 0302 	orr.w	r3, r3, r2
    5e92:	461a      	mov	r2, r3
		(desc & (CSR8_MFO_MASK|CSR8_MFC_MASK));
    5e94:	687b      	ldr	r3, [r7, #4]
    5e96:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    5e9a:	f423 037e 	bic.w	r3, r3, #16646144	; 0xfe0000
	}

	desc = MAC->CSR8;
	g_mss_mac.statistics.rx_fifo_overflow +=
		(desc & (CSR8_OCO_MASK|CSR8_FOC_MASK)) >> CSR8_FOC_SHIFT;
	g_mss_mac.statistics.rx_missed_frame +=
    5e9e:	441a      	add	r2, r3
    5ea0:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5ea4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5ea8:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    5eac:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5eb0:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
    5eb4:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    5eb8:	ea40 0101 	orr.w	r1, r0, r1
    5ebc:	f8c3 1110 	str.w	r1, [r3, #272]	; 0x110
    5ec0:	ea4f 6212 	mov.w	r2, r2, lsr #24
    5ec4:	f04f 0100 	mov.w	r1, #0
    5ec8:	ea41 0202 	orr.w	r2, r1, r2
    5ecc:	f883 2114 	strb.w	r2, [r3, #276]	; 0x114
		(desc & (CSR8_MFO_MASK|CSR8_MFC_MASK));

	/* Give ownership of descriptor to the MAC */
	g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 = RDES0_OWN;
    5ed0:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5ed4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5ed8:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    5edc:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5ee0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5ee4:	ea4f 1202 	mov.w	r2, r2, lsl #4
    5ee8:	4413      	add	r3, r2
    5eea:	f103 0398 	add.w	r3, r3, #152	; 0x98
    5eee:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    5ef2:	601a      	str	r2, [r3, #0]
	g_mss_mac.rx_desc_index = (g_mss_mac.rx_desc_index + 1u) % RX_RING_SIZE;
    5ef4:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5ef8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5efc:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    5f00:	f103 0101 	add.w	r1, r3, #1
    5f04:	f64c 43cd 	movw	r3, #52429	; 0xcccd
    5f08:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
    5f0c:	fba3 2301 	umull	r2, r3, r3, r1
    5f10:	ea4f 0293 	mov.w	r2, r3, lsr #2
    5f14:	4613      	mov	r3, r2
    5f16:	ea4f 0383 	mov.w	r3, r3, lsl #2
    5f1a:	4413      	add	r3, r2
    5f1c:	ebc3 0201 	rsb	r2, r3, r1
    5f20:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5f24:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5f28:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

	/* Start receive */
    MAC_start_receiving();
    5f2c:	f000 fa28 	bl	6380 <MAC_start_receiving>
}
    5f30:	f107 0708 	add.w	r7, r7, #8
    5f34:	46bd      	mov	sp, r7
    5f36:	bd80      	pop	{r7, pc}

00005f38 <MAC_send_setup_frame>:
static int32_t
MAC_send_setup_frame
(
    void
)
{
    5f38:	b580      	push	{r7, lr}
    5f3a:	b0be      	sub	sp, #248	; 0xf8
    5f3c:	af00      	add	r7, sp, #0
	uint8_t *data;
	int32_t a,b,c,d;
	int32_t ret;

    /* prepare descriptor */
	descriptor.descriptor_0 = TDES0_OWN;
    5f3e:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    5f42:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
	descriptor.descriptor_1 = TDES1_SET | TDES1_TER |
    5f46:	f240 03c0 	movw	r3, #192	; 0xc0
    5f4a:	f6c0 2300 	movt	r3, #2560	; 0xa00
    5f4e:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
		(sizeof(frame_data) << TDES1_TBS1_OFFSET);

	if( (g_mss_mac.flags & FLAG_PERFECT_FILTERING) == 0u ) {
    5f52:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5f56:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5f5a:	791b      	ldrb	r3, [r3, #4]
    5f5c:	f003 0302 	and.w	r3, r3, #2
    5f60:	2b00      	cmp	r3, #0
    5f62:	d105      	bne.n	5f70 <MAC_send_setup_frame+0x38>
		descriptor.descriptor_1 |= TDES1_FT0;
    5f64:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
    5f68:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
    5f6c:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	}

	descriptor.buffer_1 = (uint32_t)frame_data;
    5f70:	f107 0304 	add.w	r3, r7, #4
    5f74:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
	descriptor.buffer_2 = 0u;
    5f78:	f04f 0300 	mov.w	r3, #0
    5f7c:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0

    /* prepare frame */
    if( (g_mss_mac.flags & FLAG_PERFECT_FILTERING) != 0u ) {
    5f80:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    5f84:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5f88:	791b      	ldrb	r3, [r3, #4]
    5f8a:	f003 0302 	and.w	r3, r3, #2
    5f8e:	2b00      	cmp	r3, #0
    5f90:	d00c      	beq.n	5fac <MAC_send_setup_frame+0x74>
    	b = 0;
    5f92:	f04f 0300 	mov.w	r3, #0
    5f96:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    	d = 12;
    5f9a:	f04f 030c 	mov.w	r3, #12
    5f9e:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    	c = 90;
    5fa2:	f04f 035a 	mov.w	r3, #90	; 0x5a
    5fa6:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    5faa:	e00b      	b.n	5fc4 <MAC_send_setup_frame+0x8c>
    } else {
    	b = 156;
    5fac:	f04f 039c 	mov.w	r3, #156	; 0x9c
    5fb0:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    	d = 0;
    5fb4:	f04f 0300 	mov.w	r3, #0
    5fb8:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    	c = 64;
    5fbc:	f04f 0340 	mov.w	r3, #64	; 0x40
    5fc0:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    }

   	data = g_mss_mac.mac_address;
    5fc4:	4bb4      	ldr	r3, [pc, #720]	; (6298 <MAC_send_setup_frame+0x360>)
    5fc6:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
   	frame_data[b] = data[0];
    5fca:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
    5fce:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    5fd2:	7812      	ldrb	r2, [r2, #0]
    5fd4:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    5fd8:	440b      	add	r3, r1
    5fda:	f803 2cf4 	strb.w	r2, [r3, #-244]
   	frame_data[b+1] = data[1];
    5fde:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
    5fe2:	f103 0301 	add.w	r3, r3, #1
    5fe6:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    5fea:	f102 0201 	add.w	r2, r2, #1
    5fee:	7812      	ldrb	r2, [r2, #0]
    5ff0:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    5ff4:	440b      	add	r3, r1
    5ff6:	f803 2cf4 	strb.w	r2, [r3, #-244]
   	frame_data[b+4] = data[2];
    5ffa:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
    5ffe:	f103 0304 	add.w	r3, r3, #4
    6002:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    6006:	f102 0202 	add.w	r2, r2, #2
    600a:	7812      	ldrb	r2, [r2, #0]
    600c:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    6010:	440b      	add	r3, r1
    6012:	f803 2cf4 	strb.w	r2, [r3, #-244]
   	frame_data[b+5] = data[3];
    6016:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
    601a:	f103 0305 	add.w	r3, r3, #5
    601e:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    6022:	f102 0203 	add.w	r2, r2, #3
    6026:	7812      	ldrb	r2, [r2, #0]
    6028:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    602c:	440b      	add	r3, r1
    602e:	f803 2cf4 	strb.w	r2, [r3, #-244]
   	frame_data[b+8] = data[4];
    6032:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
    6036:	f103 0308 	add.w	r3, r3, #8
    603a:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    603e:	f102 0204 	add.w	r2, r2, #4
    6042:	7812      	ldrb	r2, [r2, #0]
    6044:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    6048:	440b      	add	r3, r1
    604a:	f803 2cf4 	strb.w	r2, [r3, #-244]
   	frame_data[b+9] = data[5];
    604e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
    6052:	f103 0309 	add.w	r3, r3, #9
    6056:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    605a:	f102 0205 	add.w	r2, r2, #5
    605e:	7812      	ldrb	r2, [r2, #0]
    6060:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    6064:	440b      	add	r3, r1
    6066:	f803 2cf4 	strb.w	r2, [r3, #-244]

   	data = g_mss_mac.mac_filter_data;
    606a:	4b8c      	ldr	r3, [pc, #560]	; (629c <MAC_send_setup_frame+0x364>)
    606c:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
    for( a = 0; a < c; ) {
    6070:	f04f 0300 	mov.w	r3, #0
    6074:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    6078:	e081      	b.n	617e <MAC_send_setup_frame+0x246>
		frame_data[d] = data[a++];
    607a:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    607e:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
    6082:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    6086:	440a      	add	r2, r1
    6088:	7812      	ldrb	r2, [r2, #0]
    608a:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    608e:	440b      	add	r3, r1
    6090:	f803 2cf4 	strb.w	r2, [r3, #-244]
    6094:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    6098:	f103 0301 	add.w	r3, r3, #1
    609c:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
	   	frame_data[d+1] = data[a++];
    60a0:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    60a4:	f103 0301 	add.w	r3, r3, #1
    60a8:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
    60ac:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    60b0:	440a      	add	r2, r1
    60b2:	7812      	ldrb	r2, [r2, #0]
    60b4:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    60b8:	440b      	add	r3, r1
    60ba:	f803 2cf4 	strb.w	r2, [r3, #-244]
    60be:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    60c2:	f103 0301 	add.w	r3, r3, #1
    60c6:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
	   	frame_data[d+4] = data[a++];
    60ca:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    60ce:	f103 0304 	add.w	r3, r3, #4
    60d2:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
    60d6:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    60da:	440a      	add	r2, r1
    60dc:	7812      	ldrb	r2, [r2, #0]
    60de:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    60e2:	440b      	add	r3, r1
    60e4:	f803 2cf4 	strb.w	r2, [r3, #-244]
    60e8:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    60ec:	f103 0301 	add.w	r3, r3, #1
    60f0:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
	   	frame_data[d+5] = data[a++];
    60f4:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    60f8:	f103 0305 	add.w	r3, r3, #5
    60fc:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
    6100:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    6104:	440a      	add	r2, r1
    6106:	7812      	ldrb	r2, [r2, #0]
    6108:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    610c:	440b      	add	r3, r1
    610e:	f803 2cf4 	strb.w	r2, [r3, #-244]
    6112:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    6116:	f103 0301 	add.w	r3, r3, #1
    611a:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
	   	frame_data[d+8] = data[a++];
    611e:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    6122:	f103 0308 	add.w	r3, r3, #8
    6126:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
    612a:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    612e:	440a      	add	r2, r1
    6130:	7812      	ldrb	r2, [r2, #0]
    6132:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    6136:	440b      	add	r3, r1
    6138:	f803 2cf4 	strb.w	r2, [r3, #-244]
    613c:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    6140:	f103 0301 	add.w	r3, r3, #1
    6144:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
	   	frame_data[d+9] = data[a++];
    6148:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    614c:	f103 0309 	add.w	r3, r3, #9
    6150:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
    6154:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    6158:	440a      	add	r2, r1
    615a:	7812      	ldrb	r2, [r2, #0]
    615c:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    6160:	440b      	add	r3, r1
    6162:	f803 2cf4 	strb.w	r2, [r3, #-244]
    6166:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    616a:	f103 0301 	add.w	r3, r3, #1
    616e:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
	   	d += 12;
    6172:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    6176:	f103 030c 	add.w	r3, r3, #12
    617a:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
   	frame_data[b+5] = data[3];
   	frame_data[b+8] = data[4];
   	frame_data[b+9] = data[5];

   	data = g_mss_mac.mac_filter_data;
    for( a = 0; a < c; ) {
    617e:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
    6182:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
    6186:	429a      	cmp	r2, r3
    6188:	f6ff af77 	blt.w	607a <MAC_send_setup_frame+0x142>
	   	frame_data[d+9] = data[a++];
	   	d += 12;
	}

	/* Stop transmission */
    ret = MAC_stop_transmission();
    618c:	f000 f88a 	bl	62a4 <MAC_stop_transmission>
    6190:	4603      	mov	r3, r0
    6192:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    configASSERT( ret == MAC_OK );
    6196:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
    619a:	2b00      	cmp	r3, #0
    619c:	d00a      	beq.n	61b4 <MAC_send_setup_frame+0x27c>
    619e:	f04f 0328 	mov.w	r3, #40	; 0x28
    61a2:	f383 8811 	msr	BASEPRI, r3
    61a6:	f3bf 8f6f 	isb	sy
    61aa:	f3bf 8f4f 	dsb	sy
    61ae:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
    61b2:	e7fe      	b.n	61b2 <MAC_send_setup_frame+0x27a>

    ret = MAC_stop_receiving();
    61b4:	f000 f8b4 	bl	6320 <MAC_stop_receiving>
    61b8:	4603      	mov	r3, r0
    61ba:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    configASSERT( ret == MAC_OK );
    61be:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
    61c2:	2b00      	cmp	r3, #0
    61c4:	d00a      	beq.n	61dc <MAC_send_setup_frame+0x2a4>
    61c6:	f04f 0328 	mov.w	r3, #40	; 0x28
    61ca:	f383 8811 	msr	BASEPRI, r3
    61ce:	f3bf 8f6f 	isb	sy
    61d2:	f3bf 8f4f 	dsb	sy
    61d6:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
    61da:	e7fe      	b.n	61da <MAC_send_setup_frame+0x2a2>

    /* Set descriptor */
    MAC->CSR4 = (uint32_t)&descriptor;
    61dc:	f243 0300 	movw	r3, #12288	; 0x3000
    61e0:	f2c4 0300 	movt	r3, #16384	; 0x4000
    61e4:	f107 02c4 	add.w	r2, r7, #196	; 0xc4
    61e8:	621a      	str	r2, [r3, #32]

	/* Start transmission */
    MAC_start_transmission();
    61ea:	f000 f88b 	bl	6304 <MAC_start_transmission>

    /* Wait until transmission over */
    ret = MAC_OK;
    61ee:	f04f 0300 	mov.w	r3, #0
    61f2:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    MAC_set_time_out( (uint32_t)SETUP_FRAME_TIME_OUT );
    61f6:	f242 7010 	movw	r0, #10000	; 0x2710
    61fa:	f000 f921 	bl	6440 <MAC_set_time_out>

    while( (((MAC->CSR5 & CSR5_TS_MASK) >> CSR5_TS_SHIFT) !=
    61fe:	e00f      	b.n	6220 <MAC_send_setup_frame+0x2e8>
    	CSR5_TS_SUSPENDED) && (MAC_OK == ret) )
    {
    	/* transmit poll demand */
    	MAC->CSR1 = 1u;
    6200:	f243 0300 	movw	r3, #12288	; 0x3000
    6204:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6208:	f04f 0201 	mov.w	r2, #1
    620c:	609a      	str	r2, [r3, #8]
    	if( MAC_get_time_out() == 0u ) {
    620e:	f000 f93f 	bl	6490 <MAC_get_time_out>
    6212:	4603      	mov	r3, r0
    6214:	2b00      	cmp	r3, #0
    6216:	d103      	bne.n	6220 <MAC_send_setup_frame+0x2e8>
    		ret = MAC_TIME_OUT;
    6218:	f06f 0305 	mvn.w	r3, #5
    621c:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8

    /* Wait until transmission over */
    ret = MAC_OK;
    MAC_set_time_out( (uint32_t)SETUP_FRAME_TIME_OUT );

    while( (((MAC->CSR5 & CSR5_TS_MASK) >> CSR5_TS_SHIFT) !=
    6220:	f243 0300 	movw	r3, #12288	; 0x3000
    6224:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6228:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    622a:	f403 03e0 	and.w	r3, r3, #7340032	; 0x700000
    622e:	ea4f 5313 	mov.w	r3, r3, lsr #20
    6232:	2b06      	cmp	r3, #6
    6234:	d003      	beq.n	623e <MAC_send_setup_frame+0x306>
    6236:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
    623a:	2b00      	cmp	r3, #0
    623c:	d0e0      	beq.n	6200 <MAC_send_setup_frame+0x2c8>
    	if( MAC_get_time_out() == 0u ) {
    		ret = MAC_TIME_OUT;
    	}
    }

	MAC_CHECK( MAC_stop_transmission() == MAC_OK, MAC_FAIL );
    623e:	f000 f831 	bl	62a4 <MAC_stop_transmission>
    6242:	4603      	mov	r3, r0
    6244:	2b00      	cmp	r3, #0
    6246:	d016      	beq.n	6276 <MAC_send_setup_frame+0x33e>
    6248:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    624c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6250:	f04f 32ff 	mov.w	r2, #4294967295
    6254:	715a      	strb	r2, [r3, #5]
    6256:	f000 f825 	bl	62a4 <MAC_stop_transmission>
    625a:	4603      	mov	r3, r0
    625c:	2b00      	cmp	r3, #0
    625e:	d00a      	beq.n	6276 <MAC_send_setup_frame+0x33e>
    6260:	f04f 0328 	mov.w	r3, #40	; 0x28
    6264:	f383 8811 	msr	BASEPRI, r3
    6268:	f3bf 8f6f 	isb	sy
    626c:	f3bf 8f4f 	dsb	sy
    6270:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
    6274:	e7fe      	b.n	6274 <MAC_send_setup_frame+0x33c>

    /* Set tx descriptor */
    MAC->CSR4 = (uint32_t)g_mss_mac.tx_descriptors;
    6276:	f243 0300 	movw	r3, #12288	; 0x3000
    627a:	f2c4 0300 	movt	r3, #16384	; 0x4000
    627e:	4a08      	ldr	r2, [pc, #32]	; (62a0 <MAC_send_setup_frame+0x368>)
    6280:	621a      	str	r2, [r3, #32]

    /* Start receiving and transmission */
    MAC_start_receiving();
    6282:	f000 f87d 	bl	6380 <MAC_start_receiving>
    MAC_start_transmission();
    6286:	f000 f83d 	bl	6304 <MAC_start_transmission>

    return ret;
    628a:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
}
    628e:	4618      	mov	r0, r3
    6290:	f107 07f8 	add.w	r7, r7, #248	; 0xf8
    6294:	46bd      	mov	sp, r7
    6296:	bd80      	pop	{r7, pc}
    6298:	2000aafa 	.word	0x2000aafa
    629c:	2000ab00 	.word	0x2000ab00
    62a0:	2000ab68 	.word	0x2000ab68

000062a4 <MAC_stop_transmission>:
static int32_t
MAC_stop_transmission
(
    void
)
{
    62a4:	b580      	push	{r7, lr}
    62a6:	b082      	sub	sp, #8
    62a8:	af00      	add	r7, sp, #0
    int32_t retval = MAC_OK;
    62aa:	f04f 0300 	mov.w	r3, #0
    62ae:	607b      	str	r3, [r7, #4]
    MAC_set_time_out( (uint16_t)STATE_CHANGE_TIME_OUT );
    62b0:	f242 7010 	movw	r0, #10000	; 0x2710
    62b4:	f000 f8c4 	bl	6440 <MAC_set_time_out>

	while( (((MAC->CSR5 & CSR5_TS_MASK) >> CSR5_TS_SHIFT) !=
    62b8:	e00f      	b.n	62da <MAC_stop_transmission+0x36>
		CSR5_TS_STOPPED) && (retval == MAC_OK) )
	{
    	MAC_BITBAND->CSR6_ST = 0u;
    62ba:	f240 0300 	movw	r3, #0
    62be:	f2c4 2306 	movt	r3, #16902	; 0x4206
    62c2:	f04f 0200 	mov.w	r2, #0
    62c6:	f8c3 2634 	str.w	r2, [r3, #1588]	; 0x634
    	if( MAC_get_time_out() == 0u ) {
    62ca:	f000 f8e1 	bl	6490 <MAC_get_time_out>
    62ce:	4603      	mov	r3, r0
    62d0:	2b00      	cmp	r3, #0
    62d2:	d102      	bne.n	62da <MAC_stop_transmission+0x36>
    		retval = MAC_TIME_OUT;
    62d4:	f06f 0305 	mvn.w	r3, #5
    62d8:	607b      	str	r3, [r7, #4]
)
{
    int32_t retval = MAC_OK;
    MAC_set_time_out( (uint16_t)STATE_CHANGE_TIME_OUT );

	while( (((MAC->CSR5 & CSR5_TS_MASK) >> CSR5_TS_SHIFT) !=
    62da:	f243 0300 	movw	r3, #12288	; 0x3000
    62de:	f2c4 0300 	movt	r3, #16384	; 0x4000
    62e2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    62e4:	f403 03e0 	and.w	r3, r3, #7340032	; 0x700000
    62e8:	ea4f 5313 	mov.w	r3, r3, lsr #20
    62ec:	2b00      	cmp	r3, #0
    62ee:	d002      	beq.n	62f6 <MAC_stop_transmission+0x52>
    62f0:	687b      	ldr	r3, [r7, #4]
    62f2:	2b00      	cmp	r3, #0
    62f4:	d0e1      	beq.n	62ba <MAC_stop_transmission+0x16>
    	MAC_BITBAND->CSR6_ST = 0u;
    	if( MAC_get_time_out() == 0u ) {
    		retval = MAC_TIME_OUT;
    	}
	}
	return retval;
    62f6:	687b      	ldr	r3, [r7, #4]
}
    62f8:	4618      	mov	r0, r3
    62fa:	f107 0708 	add.w	r7, r7, #8
    62fe:	46bd      	mov	sp, r7
    6300:	bd80      	pop	{r7, pc}
    6302:	bf00      	nop

00006304 <MAC_start_transmission>:
static void
MAC_start_transmission
(
    void
)
{
    6304:	b480      	push	{r7}
    6306:	af00      	add	r7, sp, #0
    MAC_BITBAND->CSR6_ST = 1u;
    6308:	f240 0300 	movw	r3, #0
    630c:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6310:	f04f 0201 	mov.w	r2, #1
    6314:	f8c3 2634 	str.w	r2, [r3, #1588]	; 0x634
}
    6318:	46bd      	mov	sp, r7
    631a:	bc80      	pop	{r7}
    631c:	4770      	bx	lr
    631e:	bf00      	nop

00006320 <MAC_stop_receiving>:
static int32_t
MAC_stop_receiving
(
    void
)
{
    6320:	b580      	push	{r7, lr}
    6322:	b082      	sub	sp, #8
    6324:	af00      	add	r7, sp, #0
    int32_t retval = MAC_OK;
    6326:	f04f 0300 	mov.w	r3, #0
    632a:	607b      	str	r3, [r7, #4]
    MAC_set_time_out( (uint16_t)STATE_CHANGE_TIME_OUT );
    632c:	f242 7010 	movw	r0, #10000	; 0x2710
    6330:	f000 f886 	bl	6440 <MAC_set_time_out>

	while( (((MAC->CSR5 & CSR5_RS_MASK) >> CSR5_RS_SHIFT) != CSR5_RS_STOPPED)
    6334:	e00f      	b.n	6356 <MAC_stop_receiving+0x36>
            && (retval == MAC_OK) )
	{
    	MAC_BITBAND->CSR6_SR = 0u;
    6336:	f240 0300 	movw	r3, #0
    633a:	f2c4 2306 	movt	r3, #16902	; 0x4206
    633e:	f04f 0200 	mov.w	r2, #0
    6342:	f8c3 2604 	str.w	r2, [r3, #1540]	; 0x604
    	if( MAC_get_time_out() == 0u ) {
    6346:	f000 f8a3 	bl	6490 <MAC_get_time_out>
    634a:	4603      	mov	r3, r0
    634c:	2b00      	cmp	r3, #0
    634e:	d102      	bne.n	6356 <MAC_stop_receiving+0x36>
    		retval = MAC_TIME_OUT;
    6350:	f06f 0305 	mvn.w	r3, #5
    6354:	607b      	str	r3, [r7, #4]
)
{
    int32_t retval = MAC_OK;
    MAC_set_time_out( (uint16_t)STATE_CHANGE_TIME_OUT );

	while( (((MAC->CSR5 & CSR5_RS_MASK) >> CSR5_RS_SHIFT) != CSR5_RS_STOPPED)
    6356:	f243 0300 	movw	r3, #12288	; 0x3000
    635a:	f2c4 0300 	movt	r3, #16384	; 0x4000
    635e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6360:	f403 23c0 	and.w	r3, r3, #393216	; 0x60000
    6364:	ea4f 4353 	mov.w	r3, r3, lsr #17
    6368:	2b00      	cmp	r3, #0
    636a:	d002      	beq.n	6372 <MAC_stop_receiving+0x52>
    636c:	687b      	ldr	r3, [r7, #4]
    636e:	2b00      	cmp	r3, #0
    6370:	d0e1      	beq.n	6336 <MAC_stop_receiving+0x16>
    	if( MAC_get_time_out() == 0u ) {
    		retval = MAC_TIME_OUT;
    	}
	}

	return retval;
    6372:	687b      	ldr	r3, [r7, #4]
}
    6374:	4618      	mov	r0, r3
    6376:	f107 0708 	add.w	r7, r7, #8
    637a:	46bd      	mov	sp, r7
    637c:	bd80      	pop	{r7, pc}
    637e:	bf00      	nop

00006380 <MAC_start_receiving>:
static void
MAC_start_receiving
(
    void
)
{
    6380:	b480      	push	{r7}
    6382:	af00      	add	r7, sp, #0
    MAC_BITBAND->CSR6_SR = 1u;
    6384:	f240 0300 	movw	r3, #0
    6388:	f2c4 2306 	movt	r3, #16902	; 0x4206
    638c:	f04f 0201 	mov.w	r2, #1
    6390:	f8c3 2604 	str.w	r2, [r3, #1540]	; 0x604
}
    6394:	46bd      	mov	sp, r7
    6396:	bc80      	pop	{r7}
    6398:	4770      	bx	lr
    639a:	bf00      	nop

0000639c <MAC_dismiss_bad_frames>:
static int32_t
MAC_dismiss_bad_frames
(
    void
)
{
    639c:	b580      	push	{r7, lr}
    639e:	b082      	sub	sp, #8
    63a0:	af00      	add	r7, sp, #0
	int32_t dc = 0;
    63a2:	f04f 0300 	mov.w	r3, #0
    63a6:	603b      	str	r3, [r7, #0]
	int8_t cont = 1;
    63a8:	f04f 0301 	mov.w	r3, #1
    63ac:	71fb      	strb	r3, [r7, #7]

	if( MAC_BITBAND->CSR6_PB != 0u ) {
    63ae:	f240 0300 	movw	r3, #0
    63b2:	f2c4 2306 	movt	r3, #16902	; 0x4206
    63b6:	f8d3 360c 	ldr.w	r3, [r3, #1548]	; 0x60c
    63ba:	2b00      	cmp	r3, #0
    63bc:	d023      	beq.n	6406 <MAC_dismiss_bad_frames+0x6a>
		/* User wants bad frames too, don't dismiss anything */
		cont = 0;
    63be:	f04f 0300 	mov.w	r3, #0
    63c2:	71fb      	strb	r3, [r7, #7]
	}

	while( ( (g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    63c4:	e020      	b.n	6408 <MAC_dismiss_bad_frames+0x6c>
            RDES0_OWN) == 0u) && (cont == 1) ) /* Host owns this descriptor */
    {
    	/* check error summary */
    	if( (g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    63c6:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    63ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    63ce:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    63d2:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    63d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    63da:	ea4f 1202 	mov.w	r2, r2, lsl #4
    63de:	4413      	add	r3, r2
    63e0:	f103 0398 	add.w	r3, r3, #152	; 0x98
    63e4:	681b      	ldr	r3, [r3, #0]
    63e6:	f403 4303 	and.w	r3, r3, #33536	; 0x8300
    63ea:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    63ee:	d006      	beq.n	63fe <MAC_dismiss_bad_frames+0x62>
    		(RDES0_ES | RDES0_LS | RDES0_FS)) != (RDES0_LS | RDES0_FS) )
    	{
    		MSS_MAC_prepare_rx_descriptor();
    63f0:	f7ff fb8e 	bl	5b10 <MSS_MAC_prepare_rx_descriptor>
    		dc++;
    63f4:	683b      	ldr	r3, [r7, #0]
    63f6:	f103 0301 	add.w	r3, r3, #1
    63fa:	603b      	str	r3, [r7, #0]
    63fc:	e004      	b.n	6408 <MAC_dismiss_bad_frames+0x6c>
    	}
        else
        {
    		cont = 0;
    63fe:	f04f 0300 	mov.w	r3, #0
    6402:	71fb      	strb	r3, [r7, #7]
    6404:	e000      	b.n	6408 <MAC_dismiss_bad_frames+0x6c>
	if( MAC_BITBAND->CSR6_PB != 0u ) {
		/* User wants bad frames too, don't dismiss anything */
		cont = 0;
	}

	while( ( (g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    6406:	bf00      	nop
    6408:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    640c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6410:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    6414:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    6418:	f2c2 0300 	movt	r3, #8192	; 0x2000
    641c:	ea4f 1202 	mov.w	r2, r2, lsl #4
    6420:	4413      	add	r3, r2
    6422:	f103 0398 	add.w	r3, r3, #152	; 0x98
    6426:	681b      	ldr	r3, [r3, #0]
    6428:	2b00      	cmp	r3, #0
    642a:	db03      	blt.n	6434 <MAC_dismiss_bad_frames+0x98>
    642c:	f997 3007 	ldrsb.w	r3, [r7, #7]
    6430:	2b01      	cmp	r3, #1
    6432:	d0c8      	beq.n	63c6 <MAC_dismiss_bad_frames+0x2a>
        {
    		cont = 0;
    	}
    }

	return dc;
    6434:	683b      	ldr	r3, [r7, #0]
}
    6436:	4618      	mov	r0, r3
    6438:	f107 0708 	add.w	r7, r7, #8
    643c:	46bd      	mov	sp, r7
    643e:	bd80      	pop	{r7, pc}

00006440 <MAC_set_time_out>:
static void
MAC_set_time_out
(
    uint32_t time_out
)
{
    6440:	b480      	push	{r7}
    6442:	b083      	sub	sp, #12
    6444:	af00      	add	r7, sp, #0
    6446:	6078      	str	r0, [r7, #4]
	g_mss_mac.time_out_value = (time_out * 122u) / 10u;
    6448:	687b      	ldr	r3, [r7, #4]
    644a:	f04f 027a 	mov.w	r2, #122	; 0x7a
    644e:	fb02 f203 	mul.w	r2, r2, r3
    6452:	f64c 43cd 	movw	r3, #52429	; 0xcccd
    6456:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
    645a:	fba3 1302 	umull	r1, r3, r3, r2
    645e:	ea4f 02d3 	mov.w	r2, r3, lsr #3
    6462:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    6466:	f2c2 0300 	movt	r3, #8192	; 0x2000
    646a:	669a      	str	r2, [r3, #104]	; 0x68

	g_mss_mac.last_timer_value = (uint16_t)( MAC->CSR11 & CSR11_TIM_MASK );
    646c:	f243 0300 	movw	r3, #12288	; 0x3000
    6470:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6474:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    6476:	b29a      	uxth	r2, r3
    6478:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    647c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6480:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
}
    6484:	f107 070c 	add.w	r7, r7, #12
    6488:	46bd      	mov	sp, r7
    648a:	bc80      	pop	{r7}
    648c:	4770      	bx	lr
    648e:	bf00      	nop

00006490 <MAC_get_time_out>:
static uint32_t
MAC_get_time_out
(
    void
)
{
    6490:	b480      	push	{r7}
    6492:	b083      	sub	sp, #12
    6494:	af00      	add	r7, sp, #0
	uint32_t timer;
	uint32_t time = 0u;
    6496:	f04f 0300 	mov.w	r3, #0
    649a:	607b      	str	r3, [r7, #4]

	timer = ( MAC->CSR11 & CSR11_TIM_MASK );
    649c:	f243 0300 	movw	r3, #12288	; 0x3000
    64a0:	f2c4 0300 	movt	r3, #16384	; 0x4000
    64a4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    64a6:	ea4f 4303 	mov.w	r3, r3, lsl #16
    64aa:	ea4f 4313 	mov.w	r3, r3, lsr #16
    64ae:	603b      	str	r3, [r7, #0]

	if( timer > g_mss_mac.last_timer_value ) {
    64b0:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    64b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    64b8:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
    64bc:	461a      	mov	r2, r3
    64be:	683b      	ldr	r3, [r7, #0]
    64c0:	429a      	cmp	r2, r3
    64c2:	d202      	bcs.n	64ca <MAC_get_time_out+0x3a>
		time = 0x0000ffffUL;
    64c4:	f64f 73ff 	movw	r3, #65535	; 0xffff
    64c8:	607b      	str	r3, [r7, #4]
	}
	time += g_mss_mac.last_timer_value - timer;
    64ca:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    64ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    64d2:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
    64d6:	461a      	mov	r2, r3
    64d8:	683b      	ldr	r3, [r7, #0]
    64da:	ebc3 0302 	rsb	r3, r3, r2
    64de:	687a      	ldr	r2, [r7, #4]
    64e0:	4413      	add	r3, r2
    64e2:	607b      	str	r3, [r7, #4]

	if( MAC_BITBAND->CSR6_TTM == 0u ) {
    64e4:	f240 0300 	movw	r3, #0
    64e8:	f2c4 2306 	movt	r3, #16902	; 0x4206
    64ec:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
    64f0:	2b00      	cmp	r3, #0
    64f2:	d107      	bne.n	6504 <MAC_get_time_out+0x74>
		time *= 10u;
    64f4:	687a      	ldr	r2, [r7, #4]
    64f6:	4613      	mov	r3, r2
    64f8:	ea4f 0383 	mov.w	r3, r3, lsl #2
    64fc:	4413      	add	r3, r2
    64fe:	ea4f 0343 	mov.w	r3, r3, lsl #1
    6502:	607b      	str	r3, [r7, #4]
	}
	if( g_mss_mac.time_out_value <= time ){
    6504:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    6508:	f2c2 0300 	movt	r3, #8192	; 0x2000
    650c:	6e9a      	ldr	r2, [r3, #104]	; 0x68
    650e:	687b      	ldr	r3, [r7, #4]
    6510:	429a      	cmp	r2, r3
    6512:	d807      	bhi.n	6524 <MAC_get_time_out+0x94>
		g_mss_mac.time_out_value = 0u;
    6514:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    6518:	f2c2 0300 	movt	r3, #8192	; 0x2000
    651c:	f04f 0200 	mov.w	r2, #0
    6520:	669a      	str	r2, [r3, #104]	; 0x68
    6522:	e00c      	b.n	653e <MAC_get_time_out+0xae>
	} else {
		g_mss_mac.time_out_value -= time;
    6524:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    6528:	f2c2 0300 	movt	r3, #8192	; 0x2000
    652c:	6e9a      	ldr	r2, [r3, #104]	; 0x68
    652e:	687b      	ldr	r3, [r7, #4]
    6530:	ebc3 0202 	rsb	r2, r3, r2
    6534:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    6538:	f2c2 0300 	movt	r3, #8192	; 0x2000
    653c:	669a      	str	r2, [r3, #104]	; 0x68
	}

	g_mss_mac.last_timer_value = (uint16_t)timer;
    653e:	683b      	ldr	r3, [r7, #0]
    6540:	b29a      	uxth	r2, r3
    6542:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    6546:	f2c2 0300 	movt	r3, #8192	; 0x2000
    654a:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66

	return ((g_mss_mac.time_out_value * 10u) / 122u);
    654e:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    6552:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6556:	6e9a      	ldr	r2, [r3, #104]	; 0x68
    6558:	4613      	mov	r3, r2
    655a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    655e:	4413      	add	r3, r2
    6560:	ea4f 0343 	mov.w	r3, r3, lsl #1
    6564:	461a      	mov	r2, r3
    6566:	f24c 533f 	movw	r3, #50495	; 0xc53f
    656a:	f2c4 3325 	movt	r3, #17189	; 0x4325
    656e:	fba3 1302 	umull	r1, r3, r3, r2
    6572:	ea4f 1353 	mov.w	r3, r3, lsr #5
}
    6576:	4618      	mov	r0, r3
    6578:	f107 070c 	add.w	r7, r7, #12
    657c:	46bd      	mov	sp, r7
    657e:	bc80      	pop	{r7}
    6580:	4770      	bx	lr
    6582:	bf00      	nop

00006584 <MAC_memset>:
/***************************************************************************//**
 * Fills the first n bytes of the memory area pointed to by s with the constant
 * byte c.
 */
static void MAC_memset(uint8_t *s, uint8_t c, uint32_t n)
{
    6584:	b480      	push	{r7}
    6586:	b087      	sub	sp, #28
    6588:	af00      	add	r7, sp, #0
    658a:	60f8      	str	r0, [r7, #12]
    658c:	460b      	mov	r3, r1
    658e:	607a      	str	r2, [r7, #4]
    6590:	72fb      	strb	r3, [r7, #11]
    uint8_t *sb = s;
    6592:	68fb      	ldr	r3, [r7, #12]
    6594:	617b      	str	r3, [r7, #20]

    while( n > 0u ) {
    6596:	e008      	b.n	65aa <MAC_memset+0x26>
    	n--;
    6598:	687b      	ldr	r3, [r7, #4]
    659a:	f103 33ff 	add.w	r3, r3, #4294967295
    659e:	607b      	str	r3, [r7, #4]
        sb[n] = c;
    65a0:	697a      	ldr	r2, [r7, #20]
    65a2:	687b      	ldr	r3, [r7, #4]
    65a4:	4413      	add	r3, r2
    65a6:	7afa      	ldrb	r2, [r7, #11]
    65a8:	701a      	strb	r2, [r3, #0]
 */
static void MAC_memset(uint8_t *s, uint8_t c, uint32_t n)
{
    uint8_t *sb = s;

    while( n > 0u ) {
    65aa:	687b      	ldr	r3, [r7, #4]
    65ac:	2b00      	cmp	r3, #0
    65ae:	d1f3      	bne.n	6598 <MAC_memset+0x14>
    	n--;
        sb[n] = c;
    }
}
    65b0:	f107 071c 	add.w	r7, r7, #28
    65b4:	46bd      	mov	sp, r7
    65b6:	bc80      	pop	{r7}
    65b8:	4770      	bx	lr
    65ba:	bf00      	nop

000065bc <MAC_memset_All>:
 * Fills all fields of MAC_instance_t with c.
 *
 * @return          a pointer to the given MAC_instance_t s.
 */
static void MAC_memset_All(MAC_instance_t *s, uint32_t c)
{
    65bc:	b580      	push	{r7, lr}
    65be:	b084      	sub	sp, #16
    65c0:	af00      	add	r7, sp, #0
    65c2:	6078      	str	r0, [r7, #4]
    65c4:	6039      	str	r1, [r7, #0]
    int32_t count;
    s->base_address = (addr_t)c;
    65c6:	687b      	ldr	r3, [r7, #4]
    65c8:	683a      	ldr	r2, [r7, #0]
    65ca:	601a      	str	r2, [r3, #0]
    s->flags = (uint8_t)c;
    65cc:	683b      	ldr	r3, [r7, #0]
    65ce:	b2da      	uxtb	r2, r3
    65d0:	687b      	ldr	r3, [r7, #4]
    65d2:	711a      	strb	r2, [r3, #4]
    s->last_error = (int8_t)c;
    65d4:	683b      	ldr	r3, [r7, #0]
    65d6:	b2da      	uxtb	r2, r3
    65d8:	687b      	ldr	r3, [r7, #4]
    65da:	715a      	strb	r2, [r3, #5]
    s->last_timer_value = (uint16_t)c;
    65dc:	683b      	ldr	r3, [r7, #0]
    65de:	b29a      	uxth	r2, r3
    65e0:	687b      	ldr	r3, [r7, #4]
    65e2:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
    s->listener = NULL_callback;
    65e6:	f240 63a0 	movw	r3, #1696	; 0x6a0
    65ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    65ee:	681a      	ldr	r2, [r3, #0]
    65f0:	687b      	ldr	r3, [r7, #4]
    65f2:	66da      	str	r2, [r3, #108]	; 0x6c
   	MAC_memset( s->mac_address, (uint8_t)c, 6u );
    65f4:	687b      	ldr	r3, [r7, #4]
    65f6:	f103 0206 	add.w	r2, r3, #6
    65fa:	683b      	ldr	r3, [r7, #0]
    65fc:	b2db      	uxtb	r3, r3
    65fe:	4610      	mov	r0, r2
    6600:	4619      	mov	r1, r3
    6602:	f04f 0206 	mov.w	r2, #6
    6606:	f7ff ffbd 	bl	6584 <MAC_memset>
   	MAC_memset( s->mac_filter_data, (uint8_t)c, 90u );
    660a:	687b      	ldr	r3, [r7, #4]
    660c:	f103 020c 	add.w	r2, r3, #12
    6610:	683b      	ldr	r3, [r7, #0]
    6612:	b2db      	uxtb	r3, r3
    6614:	4610      	mov	r0, r2
    6616:	4619      	mov	r1, r3
    6618:	f04f 025a 	mov.w	r2, #90	; 0x5a
    661c:	f7ff ffb2 	bl	6584 <MAC_memset>
    s->phy_address = (uint8_t)c;
    6620:	683b      	ldr	r3, [r7, #0]
    6622:	b2da      	uxtb	r2, r3
    6624:	687b      	ldr	r3, [r7, #4]
    6626:	f883 20e8 	strb.w	r2, [r3, #232]	; 0xe8
    s->rx_desc_index =c;
    662a:	687b      	ldr	r3, [r7, #4]
    662c:	683a      	ldr	r2, [r7, #0]
    662e:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    for(count = 0; count<RX_RING_SIZE ;count++)
    6632:	f04f 0300 	mov.w	r3, #0
    6636:	60fb      	str	r3, [r7, #12]
    6638:	e029      	b.n	668e <MAC_memset_All+0xd2>
    {
        s->rx_descriptors[count].buffer_1 = c;
    663a:	68fa      	ldr	r2, [r7, #12]
    663c:	687b      	ldr	r3, [r7, #4]
    663e:	f102 020a 	add.w	r2, r2, #10
    6642:	ea4f 1202 	mov.w	r2, r2, lsl #4
    6646:	4413      	add	r3, r2
    6648:	683a      	ldr	r2, [r7, #0]
    664a:	601a      	str	r2, [r3, #0]
        s->rx_descriptors[count].buffer_2 = c;
    664c:	68fa      	ldr	r2, [r7, #12]
    664e:	687b      	ldr	r3, [r7, #4]
    6650:	f102 020a 	add.w	r2, r2, #10
    6654:	ea4f 1202 	mov.w	r2, r2, lsl #4
    6658:	4413      	add	r3, r2
    665a:	f103 0304 	add.w	r3, r3, #4
    665e:	683a      	ldr	r2, [r7, #0]
    6660:	601a      	str	r2, [r3, #0]
        s->rx_descriptors[count].descriptor_0 = c;
    6662:	68fa      	ldr	r2, [r7, #12]
    6664:	687b      	ldr	r3, [r7, #4]
    6666:	ea4f 1202 	mov.w	r2, r2, lsl #4
    666a:	4413      	add	r3, r2
    666c:	f103 0398 	add.w	r3, r3, #152	; 0x98
    6670:	683a      	ldr	r2, [r7, #0]
    6672:	601a      	str	r2, [r3, #0]
        s->rx_descriptors[count].descriptor_1 = c;
    6674:	68fa      	ldr	r2, [r7, #12]
    6676:	687b      	ldr	r3, [r7, #4]
    6678:	ea4f 1202 	mov.w	r2, r2, lsl #4
    667c:	4413      	add	r3, r2
    667e:	f103 039c 	add.w	r3, r3, #156	; 0x9c
    6682:	683a      	ldr	r2, [r7, #0]
    6684:	601a      	str	r2, [r3, #0]
    s->listener = NULL_callback;
   	MAC_memset( s->mac_address, (uint8_t)c, 6u );
   	MAC_memset( s->mac_filter_data, (uint8_t)c, 90u );
    s->phy_address = (uint8_t)c;
    s->rx_desc_index =c;
    for(count = 0; count<RX_RING_SIZE ;count++)
    6686:	68fb      	ldr	r3, [r7, #12]
    6688:	f103 0301 	add.w	r3, r3, #1
    668c:	60fb      	str	r3, [r7, #12]
    668e:	68fb      	ldr	r3, [r7, #12]
    6690:	2b04      	cmp	r3, #4
    6692:	ddd2      	ble.n	663a <MAC_memset_All+0x7e>
        s->rx_descriptors[count].buffer_1 = c;
        s->rx_descriptors[count].buffer_2 = c;
        s->rx_descriptors[count].descriptor_0 = c;
        s->rx_descriptors[count].descriptor_1 = c;
    }
    s->statistics.rx_collision_seen =c;
    6694:	687b      	ldr	r3, [r7, #4]
    6696:	683a      	ldr	r2, [r7, #0]
    6698:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    669c:	ea4f 2202 	mov.w	r2, r2, lsl #8
    66a0:	f8d3 1104 	ldr.w	r1, [r3, #260]	; 0x104
    66a4:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    66a8:	ea41 0202 	orr.w	r2, r1, r2
    66ac:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    66b0:	78fa      	ldrb	r2, [r7, #3]
    66b2:	f04f 0100 	mov.w	r1, #0
    66b6:	ea41 0202 	orr.w	r2, r1, r2
    66ba:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
    s->statistics.rx_crc_error = c;
    66be:	687b      	ldr	r3, [r7, #4]
    66c0:	683a      	ldr	r2, [r7, #0]
    66c2:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    66c6:	ea4f 2202 	mov.w	r2, r2, lsl #8
    66ca:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
    66ce:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    66d2:	ea41 0202 	orr.w	r2, r1, r2
    66d6:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
    66da:	78fa      	ldrb	r2, [r7, #3]
    66dc:	f04f 0100 	mov.w	r1, #0
    66e0:	ea41 0202 	orr.w	r2, r1, r2
    66e4:	f883 210c 	strb.w	r2, [r3, #268]	; 0x10c
    s->statistics.rx_descriptor_error = c;
    66e8:	687b      	ldr	r3, [r7, #4]
    66ea:	683a      	ldr	r2, [r7, #0]
    66ec:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    66f0:	ea4f 2202 	mov.w	r2, r2, lsl #8
    66f4:	f8d3 10f0 	ldr.w	r1, [r3, #240]	; 0xf0
    66f8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    66fc:	ea41 0202 	orr.w	r2, r1, r2
    6700:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
    6704:	78fa      	ldrb	r2, [r7, #3]
    6706:	f04f 0100 	mov.w	r1, #0
    670a:	ea41 0202 	orr.w	r2, r1, r2
    670e:	f883 20f4 	strb.w	r2, [r3, #244]	; 0xf4
    s->statistics.rx_fifo_overflow = c;
    6712:	687b      	ldr	r3, [r7, #4]
    6714:	683a      	ldr	r2, [r7, #0]
    6716:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    671a:	ea4f 2202 	mov.w	r2, r2, lsl #8
    671e:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
    6722:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6726:	ea41 0202 	orr.w	r2, r1, r2
    672a:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    672e:	78fa      	ldrb	r2, [r7, #3]
    6730:	f04f 0100 	mov.w	r1, #0
    6734:	ea41 0202 	orr.w	r2, r1, r2
    6738:	f883 2110 	strb.w	r2, [r3, #272]	; 0x110
    s->statistics.rx_filtering_fail = c;
    673c:	687b      	ldr	r3, [r7, #4]
    673e:	683a      	ldr	r2, [r7, #0]
    6740:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    6744:	ea4f 2202 	mov.w	r2, r2, lsl #8
    6748:	f8d3 10ec 	ldr.w	r1, [r3, #236]	; 0xec
    674c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6750:	ea41 0202 	orr.w	r2, r1, r2
    6754:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
    6758:	78fa      	ldrb	r2, [r7, #3]
    675a:	f04f 0100 	mov.w	r1, #0
    675e:	ea41 0202 	orr.w	r2, r1, r2
    6762:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
    s->statistics.rx_frame_too_long = c;
    6766:	687b      	ldr	r3, [r7, #4]
    6768:	683a      	ldr	r2, [r7, #0]
    676a:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    676e:	ea4f 2202 	mov.w	r2, r2, lsl #8
    6772:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
    6776:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    677a:	ea41 0202 	orr.w	r2, r1, r2
    677e:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    6782:	78fa      	ldrb	r2, [r7, #3]
    6784:	f04f 0100 	mov.w	r1, #0
    6788:	ea41 0202 	orr.w	r2, r1, r2
    678c:	f883 2104 	strb.w	r2, [r3, #260]	; 0x104
    s->statistics.rx_interrupts = c;
    6790:	687b      	ldr	r3, [r7, #4]
    6792:	683a      	ldr	r2, [r7, #0]
    6794:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    6798:	ea4f 2202 	mov.w	r2, r2, lsl #8
    679c:	f8d3 10e8 	ldr.w	r1, [r3, #232]	; 0xe8
    67a0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    67a4:	ea41 0202 	orr.w	r2, r1, r2
    67a8:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
    67ac:	78fa      	ldrb	r2, [r7, #3]
    67ae:	f04f 0100 	mov.w	r1, #0
    67b2:	ea41 0202 	orr.w	r2, r1, r2
    67b6:	f883 20ec 	strb.w	r2, [r3, #236]	; 0xec
    s->statistics.rx_missed_frame = c;
    67ba:	687b      	ldr	r3, [r7, #4]
    67bc:	683a      	ldr	r2, [r7, #0]
    67be:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    67c2:	ea4f 2202 	mov.w	r2, r2, lsl #8
    67c6:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
    67ca:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    67ce:	ea41 0202 	orr.w	r2, r1, r2
    67d2:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
    67d6:	78fa      	ldrb	r2, [r7, #3]
    67d8:	f04f 0100 	mov.w	r1, #0
    67dc:	ea41 0202 	orr.w	r2, r1, r2
    67e0:	f883 2114 	strb.w	r2, [r3, #276]	; 0x114
    s->statistics.rx_not_first = c;
    67e4:	687b      	ldr	r3, [r7, #4]
    67e6:	683a      	ldr	r2, [r7, #0]
    67e8:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    67ec:	ea4f 2202 	mov.w	r2, r2, lsl #8
    67f0:	f8d3 10f8 	ldr.w	r1, [r3, #248]	; 0xf8
    67f4:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    67f8:	ea41 0202 	orr.w	r2, r1, r2
    67fc:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
    6800:	78fa      	ldrb	r2, [r7, #3]
    6802:	f04f 0100 	mov.w	r1, #0
    6806:	ea41 0202 	orr.w	r2, r1, r2
    680a:	f883 20fc 	strb.w	r2, [r3, #252]	; 0xfc
    s->statistics.rx_not_last = c;
    680e:	687b      	ldr	r3, [r7, #4]
    6810:	683a      	ldr	r2, [r7, #0]
    6812:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    6816:	ea4f 2202 	mov.w	r2, r2, lsl #8
    681a:	f8d3 10fc 	ldr.w	r1, [r3, #252]	; 0xfc
    681e:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6822:	ea41 0202 	orr.w	r2, r1, r2
    6826:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
    682a:	78fa      	ldrb	r2, [r7, #3]
    682c:	f04f 0100 	mov.w	r1, #0
    6830:	ea41 0202 	orr.w	r2, r1, r2
    6834:	f883 2100 	strb.w	r2, [r3, #256]	; 0x100
    s->statistics.rx_runt_frame = c;
    6838:	687b      	ldr	r3, [r7, #4]
    683a:	683a      	ldr	r2, [r7, #0]
    683c:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    6840:	ea4f 2202 	mov.w	r2, r2, lsl #8
    6844:	f8d3 10f4 	ldr.w	r1, [r3, #244]	; 0xf4
    6848:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    684c:	ea41 0202 	orr.w	r2, r1, r2
    6850:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
    6854:	78fa      	ldrb	r2, [r7, #3]
    6856:	f04f 0100 	mov.w	r1, #0
    685a:	ea41 0202 	orr.w	r2, r1, r2
    685e:	f883 20f8 	strb.w	r2, [r3, #248]	; 0xf8
    s->statistics.tx_collision_count = c;
    6862:	687b      	ldr	r3, [r7, #4]
    6864:	683a      	ldr	r2, [r7, #0]
    6866:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    686a:	ea4f 2202 	mov.w	r2, r2, lsl #8
    686e:	f8d3 1128 	ldr.w	r1, [r3, #296]	; 0x128
    6872:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6876:	ea41 0202 	orr.w	r2, r1, r2
    687a:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
    687e:	78fa      	ldrb	r2, [r7, #3]
    6880:	f04f 0100 	mov.w	r1, #0
    6884:	ea41 0202 	orr.w	r2, r1, r2
    6888:	f883 212c 	strb.w	r2, [r3, #300]	; 0x12c
    s->statistics.tx_excessive_collision = c;
    688c:	687b      	ldr	r3, [r7, #4]
    688e:	683a      	ldr	r2, [r7, #0]
    6890:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    6894:	ea4f 2202 	mov.w	r2, r2, lsl #8
    6898:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
    689c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    68a0:	ea41 0202 	orr.w	r2, r1, r2
    68a4:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
    68a8:	78fa      	ldrb	r2, [r7, #3]
    68aa:	f04f 0100 	mov.w	r1, #0
    68ae:	ea41 0202 	orr.w	r2, r1, r2
    68b2:	f883 2128 	strb.w	r2, [r3, #296]	; 0x128
    s->statistics.tx_interrupts = c;
    68b6:	687b      	ldr	r3, [r7, #4]
    68b8:	683a      	ldr	r2, [r7, #0]
    68ba:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    68be:	ea4f 2202 	mov.w	r2, r2, lsl #8
    68c2:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
    68c6:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    68ca:	ea41 0202 	orr.w	r2, r1, r2
    68ce:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    68d2:	78fa      	ldrb	r2, [r7, #3]
    68d4:	f04f 0100 	mov.w	r1, #0
    68d8:	ea41 0202 	orr.w	r2, r1, r2
    68dc:	f883 2118 	strb.w	r2, [r3, #280]	; 0x118
    s->statistics.tx_late_collision = c;
    68e0:	687b      	ldr	r3, [r7, #4]
    68e2:	683a      	ldr	r2, [r7, #0]
    68e4:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    68e8:	ea4f 2202 	mov.w	r2, r2, lsl #8
    68ec:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
    68f0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    68f4:	ea41 0202 	orr.w	r2, r1, r2
    68f8:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
    68fc:	78fa      	ldrb	r2, [r7, #3]
    68fe:	f04f 0100 	mov.w	r1, #0
    6902:	ea41 0202 	orr.w	r2, r1, r2
    6906:	f883 2124 	strb.w	r2, [r3, #292]	; 0x124
    s->statistics.tx_loss_of_carrier = c;
    690a:	687b      	ldr	r3, [r7, #4]
    690c:	683a      	ldr	r2, [r7, #0]
    690e:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    6912:	ea4f 2202 	mov.w	r2, r2, lsl #8
    6916:	f8d3 1118 	ldr.w	r1, [r3, #280]	; 0x118
    691a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    691e:	ea41 0202 	orr.w	r2, r1, r2
    6922:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
    6926:	78fa      	ldrb	r2, [r7, #3]
    6928:	f04f 0100 	mov.w	r1, #0
    692c:	ea41 0202 	orr.w	r2, r1, r2
    6930:	f883 211c 	strb.w	r2, [r3, #284]	; 0x11c
    s->statistics.tx_no_carrier = c;
    6934:	687b      	ldr	r3, [r7, #4]
    6936:	683a      	ldr	r2, [r7, #0]
    6938:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    693c:	ea4f 2202 	mov.w	r2, r2, lsl #8
    6940:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
    6944:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6948:	ea41 0202 	orr.w	r2, r1, r2
    694c:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
    6950:	78fa      	ldrb	r2, [r7, #3]
    6952:	f04f 0100 	mov.w	r1, #0
    6956:	ea41 0202 	orr.w	r2, r1, r2
    695a:	f883 2120 	strb.w	r2, [r3, #288]	; 0x120
    s->statistics.tx_underflow_error = c;
    695e:	687b      	ldr	r3, [r7, #4]
    6960:	683a      	ldr	r2, [r7, #0]
    6962:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    6966:	ea4f 2202 	mov.w	r2, r2, lsl #8
    696a:	f8d3 112c 	ldr.w	r1, [r3, #300]	; 0x12c
    696e:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6972:	ea41 0202 	orr.w	r2, r1, r2
    6976:	f8c3 212c 	str.w	r2, [r3, #300]	; 0x12c
    697a:	78fa      	ldrb	r2, [r7, #3]
    697c:	f04f 0100 	mov.w	r1, #0
    6980:	ea41 0202 	orr.w	r2, r1, r2
    6984:	f883 2130 	strb.w	r2, [r3, #304]	; 0x130
    s->time_out_value = c;
    6988:	687b      	ldr	r3, [r7, #4]
    698a:	683a      	ldr	r2, [r7, #0]
    698c:	669a      	str	r2, [r3, #104]	; 0x68
    s->tx_desc_index = c;
    698e:	687b      	ldr	r3, [r7, #4]
    6990:	683a      	ldr	r2, [r7, #0]
    6992:	671a      	str	r2, [r3, #112]	; 0x70
    for(count = 0; count < TX_RING_SIZE ;count++)
    6994:	f04f 0300 	mov.w	r3, #0
    6998:	60fb      	str	r3, [r7, #12]
    699a:	e02b      	b.n	69f4 <MAC_memset_All+0x438>
    {
        s->tx_descriptors[count].buffer_1 = c;
    699c:	68fa      	ldr	r2, [r7, #12]
    699e:	687b      	ldr	r3, [r7, #4]
    69a0:	ea4f 1202 	mov.w	r2, r2, lsl #4
    69a4:	4413      	add	r3, r2
    69a6:	f103 037c 	add.w	r3, r3, #124	; 0x7c
    69aa:	683a      	ldr	r2, [r7, #0]
    69ac:	601a      	str	r2, [r3, #0]
        s->tx_descriptors[count].buffer_2 = c;
    69ae:	68fa      	ldr	r2, [r7, #12]
    69b0:	687b      	ldr	r3, [r7, #4]
    69b2:	ea4f 1202 	mov.w	r2, r2, lsl #4
    69b6:	4413      	add	r3, r2
    69b8:	f103 0380 	add.w	r3, r3, #128	; 0x80
    69bc:	683a      	ldr	r2, [r7, #0]
    69be:	601a      	str	r2, [r3, #0]
        s->tx_descriptors[count].descriptor_0 = c;
    69c0:	68fa      	ldr	r2, [r7, #12]
    69c2:	687b      	ldr	r3, [r7, #4]
    69c4:	f102 0207 	add.w	r2, r2, #7
    69c8:	ea4f 1202 	mov.w	r2, r2, lsl #4
    69cc:	4413      	add	r3, r2
    69ce:	f103 0304 	add.w	r3, r3, #4
    69d2:	683a      	ldr	r2, [r7, #0]
    69d4:	601a      	str	r2, [r3, #0]
        s->tx_descriptors[count].descriptor_1 = c;
    69d6:	68fa      	ldr	r2, [r7, #12]
    69d8:	687b      	ldr	r3, [r7, #4]
    69da:	f102 0207 	add.w	r2, r2, #7
    69de:	ea4f 1202 	mov.w	r2, r2, lsl #4
    69e2:	4413      	add	r3, r2
    69e4:	f103 0308 	add.w	r3, r3, #8
    69e8:	683a      	ldr	r2, [r7, #0]
    69ea:	601a      	str	r2, [r3, #0]
    s->statistics.tx_loss_of_carrier = c;
    s->statistics.tx_no_carrier = c;
    s->statistics.tx_underflow_error = c;
    s->time_out_value = c;
    s->tx_desc_index = c;
    for(count = 0; count < TX_RING_SIZE ;count++)
    69ec:	68fb      	ldr	r3, [r7, #12]
    69ee:	f103 0301 	add.w	r3, r3, #1
    69f2:	60fb      	str	r3, [r7, #12]
    69f4:	68fb      	ldr	r3, [r7, #12]
    69f6:	2b01      	cmp	r3, #1
    69f8:	ddd0      	ble.n	699c <MAC_memset_All+0x3e0>
        s->tx_descriptors[count].buffer_1 = c;
        s->tx_descriptors[count].buffer_2 = c;
        s->tx_descriptors[count].descriptor_0 = c;
        s->tx_descriptors[count].descriptor_1 = c;
    }
}
    69fa:	f107 0710 	add.w	r7, r7, #16
    69fe:	46bd      	mov	sp, r7
    6a00:	bd80      	pop	{r7, pc}
    6a02:	bf00      	nop

00006a04 <MAC_memcpy>:
 * The memory areas should not overlap.
 *
 * @return          a pointer to the memory area dest.
 */
static void MAC_memcpy(uint8_t *dest, const uint8_t *src, uint32_t n)
{
    6a04:	b480      	push	{r7}
    6a06:	b087      	sub	sp, #28
    6a08:	af00      	add	r7, sp, #0
    6a0a:	60f8      	str	r0, [r7, #12]
    6a0c:	60b9      	str	r1, [r7, #8]
    6a0e:	607a      	str	r2, [r7, #4]
    uint8_t *d = dest;
    6a10:	68fb      	ldr	r3, [r7, #12]
    6a12:	617b      	str	r3, [r7, #20]

    while( n > 0u ) {
    6a14:	e00b      	b.n	6a2e <MAC_memcpy+0x2a>
    	n--;
    6a16:	687b      	ldr	r3, [r7, #4]
    6a18:	f103 33ff 	add.w	r3, r3, #4294967295
    6a1c:	607b      	str	r3, [r7, #4]
        d[n] = src[n];
    6a1e:	697a      	ldr	r2, [r7, #20]
    6a20:	687b      	ldr	r3, [r7, #4]
    6a22:	4413      	add	r3, r2
    6a24:	68b9      	ldr	r1, [r7, #8]
    6a26:	687a      	ldr	r2, [r7, #4]
    6a28:	440a      	add	r2, r1
    6a2a:	7812      	ldrb	r2, [r2, #0]
    6a2c:	701a      	strb	r2, [r3, #0]
 */
static void MAC_memcpy(uint8_t *dest, const uint8_t *src, uint32_t n)
{
    uint8_t *d = dest;

    while( n > 0u ) {
    6a2e:	687b      	ldr	r3, [r7, #4]
    6a30:	2b00      	cmp	r3, #0
    6a32:	d1f0      	bne.n	6a16 <MAC_memcpy+0x12>
    	n--;
        d[n] = src[n];
    }
}
    6a34:	f107 071c 	add.w	r7, r7, #28
    6a38:	46bd      	mov	sp, r7
    6a3a:	bc80      	pop	{r7}
    6a3c:	4770      	bx	lr
    6a3e:	bf00      	nop

00006a40 <MSS_MAC_FreeTxBuffers>:
 * Tx has completed, mark the buffers that were assigned to the Tx descriptors
 * as free again.
 *
 */
void MSS_MAC_FreeTxBuffers( void )
{
    6a40:	b580      	push	{r7, lr}
    6a42:	b082      	sub	sp, #8
    6a44:	af00      	add	r7, sp, #0
	/* Check the buffers have not already been freed in the first of the
	two Tx interrupts - which could potentially happen if the second Tx completed
	during the interrupt for the first Tx. */
	if( g_mss_mac.tx_descriptors[ 0 ].buffer_1 != ( uint32_t ) NULL )
    6a46:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    6a4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6a4e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
    6a50:	2b00      	cmp	r3, #0
    6a52:	d034      	beq.n	6abe <MSS_MAC_FreeTxBuffers+0x7e>
	{
		if( ( ( (g_mss_mac.tx_descriptors[ 0 ].descriptor_0) & TDES0_OWN) == 0 ) && ( ( (g_mss_mac.tx_descriptors[ 1 ].descriptor_0) & TDES0_OWN) == 0 ) )
    6a54:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    6a58:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6a5c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    6a5e:	2b00      	cmp	r3, #0
    6a60:	db2d      	blt.n	6abe <MSS_MAC_FreeTxBuffers+0x7e>
    6a62:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    6a66:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6a6a:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
    6a6e:	2b00      	cmp	r3, #0
    6a70:	db25      	blt.n	6abe <MSS_MAC_FreeTxBuffers+0x7e>
		{
			configASSERT( g_mss_mac.tx_descriptors[ 0 ].buffer_1 == g_mss_mac.tx_descriptors[ 1 ].buffer_1 );
    6a72:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    6a76:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6a7a:	6fda      	ldr	r2, [r3, #124]	; 0x7c
    6a7c:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    6a80:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6a84:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
    6a88:	429a      	cmp	r2, r3
    6a8a:	d009      	beq.n	6aa0 <MSS_MAC_FreeTxBuffers+0x60>
    6a8c:	f04f 0328 	mov.w	r3, #40	; 0x28
    6a90:	f383 8811 	msr	BASEPRI, r3
    6a94:	f3bf 8f6f 	isb	sy
    6a98:	f3bf 8f4f 	dsb	sy
    6a9c:	607b      	str	r3, [r7, #4]
    6a9e:	e7fe      	b.n	6a9e <MSS_MAC_FreeTxBuffers+0x5e>
			MAC_release_buffer( ( unsigned char * ) g_mss_mac.tx_descriptors[ 0 ].buffer_1 );
    6aa0:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    6aa4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6aa8:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
    6aaa:	4618      	mov	r0, r3
    6aac:	f000 f8c8 	bl	6c40 <MAC_release_buffer>
			
			/* Just to mark the fact that the buffer has already been released. */
			g_mss_mac.tx_descriptors[ 0 ].buffer_1 = ( uint32_t ) NULL;
    6ab0:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    6ab4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6ab8:	f04f 0200 	mov.w	r2, #0
    6abc:	67da      	str	r2, [r3, #124]	; 0x7c
		}
	}
}
    6abe:	f107 0708 	add.w	r7, r7, #8
    6ac2:	46bd      	mov	sp, r7
    6ac4:	bd80      	pop	{r7, pc}
    6ac6:	bf00      	nop

00006ac8 <MAC_obtain_buffer>:
 * as in use, then return its address.
 *
 * @return          a pointer to a free buffer.
 */
unsigned char *MAC_obtain_buffer( void )
{
    6ac8:	b480      	push	{r7}
    6aca:	b089      	sub	sp, #36	; 0x24
    6acc:	af00      	add	r7, sp, #0
long lIndex, lAttempt = 0, lDescriptor, lBufferIsInUse;
    6ace:	f04f 0300 	mov.w	r3, #0
    6ad2:	60bb      	str	r3, [r7, #8]
unsigned char *pcReturn = NULL;
    6ad4:	f04f 0300 	mov.w	r3, #0
    6ad8:	617b      	str	r3, [r7, #20]
unsigned char *pcBufferAddress;

	/* Find and return the address of a buffer that is not being used.  Mark
	the buffer as now in use. */
	while( ( lAttempt <= 1 ) && ( pcReturn == NULL ) )
    6ada:	e096      	b.n	6c0a <MAC_obtain_buffer+0x142>
	{
		for( lIndex = 0; lIndex < macNUM_BUFFERS; lIndex++ )
    6adc:	f04f 0300 	mov.w	r3, #0
    6ae0:	607b      	str	r3, [r7, #4]
    6ae2:	e01f      	b.n	6b24 <MAC_obtain_buffer+0x5c>
		{
			if( ucMACBufferInUse[ lIndex ] == pdFALSE )
    6ae4:	687a      	ldr	r2, [r7, #4]
    6ae6:	f642 7358 	movw	r3, #12120	; 0x2f58
    6aea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6aee:	5c9b      	ldrb	r3, [r3, r2]
    6af0:	2b00      	cmp	r3, #0
    6af2:	d113      	bne.n	6b1c <MAC_obtain_buffer+0x54>
			{
				pcReturn = &( xMACBuffers.ucBuffer[ lIndex ][ 0 ] );
    6af4:	f240 63a8 	movw	r3, #1704	; 0x6a8
    6af8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6afc:	687a      	ldr	r2, [r7, #4]
    6afe:	f44f 61ba 	mov.w	r1, #1488	; 0x5d0
    6b02:	fb01 f202 	mul.w	r2, r1, r2
    6b06:	4413      	add	r3, r2
    6b08:	617b      	str	r3, [r7, #20]
				ucMACBufferInUse[ lIndex ] = pdTRUE;
    6b0a:	687a      	ldr	r2, [r7, #4]
    6b0c:	f642 7358 	movw	r3, #12120	; 0x2f58
    6b10:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6b14:	f04f 0101 	mov.w	r1, #1
    6b18:	5499      	strb	r1, [r3, r2]
				break;
    6b1a:	e006      	b.n	6b2a <MAC_obtain_buffer+0x62>

	/* Find and return the address of a buffer that is not being used.  Mark
	the buffer as now in use. */
	while( ( lAttempt <= 1 ) && ( pcReturn == NULL ) )
	{
		for( lIndex = 0; lIndex < macNUM_BUFFERS; lIndex++ )
    6b1c:	687b      	ldr	r3, [r7, #4]
    6b1e:	f103 0301 	add.w	r3, r3, #1
    6b22:	607b      	str	r3, [r7, #4]
    6b24:	687b      	ldr	r3, [r7, #4]
    6b26:	2b06      	cmp	r3, #6
    6b28:	dddc      	ble.n	6ae4 <MAC_obtain_buffer+0x1c>
				ucMACBufferInUse[ lIndex ] = pdTRUE;
				break;
			}
		}
		
		if( pcReturn == NULL )
    6b2a:	697b      	ldr	r3, [r7, #20]
    6b2c:	2b00      	cmp	r3, #0
    6b2e:	d168      	bne.n	6c02 <MAC_obtain_buffer+0x13a>
		{
			/* Did not find a buffer.  That should not really happen, but could if
			an interrupt was missed.  See if any buffers are marked as in use, but
			are not actually in use. */
			for( lIndex = 0; lIndex < macNUM_BUFFERS; lIndex++ )
    6b30:	f04f 0300 	mov.w	r3, #0
    6b34:	607b      	str	r3, [r7, #4]
    6b36:	e061      	b.n	6bfc <MAC_obtain_buffer+0x134>
			{
				pcBufferAddress = &( xMACBuffers.ucBuffer[ lIndex ][ 0 ] );
    6b38:	f240 63a8 	movw	r3, #1704	; 0x6a8
    6b3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6b40:	687a      	ldr	r2, [r7, #4]
    6b42:	f44f 61ba 	mov.w	r1, #1488	; 0x5d0
    6b46:	fb01 f202 	mul.w	r2, r1, r2
    6b4a:	4413      	add	r3, r2
    6b4c:	61bb      	str	r3, [r7, #24]
				lBufferIsInUse = pdFALSE;
    6b4e:	f04f 0300 	mov.w	r3, #0
    6b52:	613b      	str	r3, [r7, #16]
				
				/* Is the buffer used by an Rx descriptor? */
				for( lDescriptor = 0; lDescriptor < RX_RING_SIZE; lDescriptor++ )
    6b54:	f04f 0300 	mov.w	r3, #0
    6b58:	60fb      	str	r3, [r7, #12]
    6b5a:	e015      	b.n	6b88 <MAC_obtain_buffer+0xc0>
				{
					if( g_mss_mac.rx_descriptors[ lDescriptor ].buffer_1 == ( uint32_t ) pcBufferAddress )
    6b5c:	68fa      	ldr	r2, [r7, #12]
    6b5e:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    6b62:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6b66:	f102 020a 	add.w	r2, r2, #10
    6b6a:	ea4f 1202 	mov.w	r2, r2, lsl #4
    6b6e:	4413      	add	r3, r2
    6b70:	681a      	ldr	r2, [r3, #0]
    6b72:	69bb      	ldr	r3, [r7, #24]
    6b74:	429a      	cmp	r2, r3
    6b76:	d103      	bne.n	6b80 <MAC_obtain_buffer+0xb8>
					{
						/* The buffer is in use by an Rx descriptor. */
						lBufferIsInUse = pdTRUE;
    6b78:	f04f 0301 	mov.w	r3, #1
    6b7c:	613b      	str	r3, [r7, #16]
						break;
    6b7e:	e006      	b.n	6b8e <MAC_obtain_buffer+0xc6>
			{
				pcBufferAddress = &( xMACBuffers.ucBuffer[ lIndex ][ 0 ] );
				lBufferIsInUse = pdFALSE;
				
				/* Is the buffer used by an Rx descriptor? */
				for( lDescriptor = 0; lDescriptor < RX_RING_SIZE; lDescriptor++ )
    6b80:	68fb      	ldr	r3, [r7, #12]
    6b82:	f103 0301 	add.w	r3, r3, #1
    6b86:	60fb      	str	r3, [r7, #12]
    6b88:	68fb      	ldr	r3, [r7, #12]
    6b8a:	2b04      	cmp	r3, #4
    6b8c:	dde6      	ble.n	6b5c <MAC_obtain_buffer+0x94>
						lBufferIsInUse = pdTRUE;
						break;
					}
				}
				
				if( lBufferIsInUse != pdTRUE )
    6b8e:	693b      	ldr	r3, [r7, #16]
    6b90:	2b01      	cmp	r3, #1
    6b92:	d01c      	beq.n	6bce <MAC_obtain_buffer+0x106>
				{
					/* Is the buffer used by an Tx descriptor? */
					for( lDescriptor = 0; lDescriptor < TX_RING_SIZE; lDescriptor++ )
    6b94:	f04f 0300 	mov.w	r3, #0
    6b98:	60fb      	str	r3, [r7, #12]
    6b9a:	e015      	b.n	6bc8 <MAC_obtain_buffer+0x100>
					{
						if( g_mss_mac.tx_descriptors[ lDescriptor ].buffer_1 == ( uint32_t ) pcBufferAddress )
    6b9c:	68fa      	ldr	r2, [r7, #12]
    6b9e:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    6ba2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6ba6:	ea4f 1202 	mov.w	r2, r2, lsl #4
    6baa:	4413      	add	r3, r2
    6bac:	f103 037c 	add.w	r3, r3, #124	; 0x7c
    6bb0:	681a      	ldr	r2, [r3, #0]
    6bb2:	69bb      	ldr	r3, [r7, #24]
    6bb4:	429a      	cmp	r2, r3
    6bb6:	d103      	bne.n	6bc0 <MAC_obtain_buffer+0xf8>
						{
							/* The buffer is in use by an Tx descriptor. */
							lBufferIsInUse = pdTRUE;
    6bb8:	f04f 0301 	mov.w	r3, #1
    6bbc:	613b      	str	r3, [r7, #16]
							break;
    6bbe:	e006      	b.n	6bce <MAC_obtain_buffer+0x106>
				}
				
				if( lBufferIsInUse != pdTRUE )
				{
					/* Is the buffer used by an Tx descriptor? */
					for( lDescriptor = 0; lDescriptor < TX_RING_SIZE; lDescriptor++ )
    6bc0:	68fb      	ldr	r3, [r7, #12]
    6bc2:	f103 0301 	add.w	r3, r3, #1
    6bc6:	60fb      	str	r3, [r7, #12]
    6bc8:	68fb      	ldr	r3, [r7, #12]
    6bca:	2b01      	cmp	r3, #1
    6bcc:	dde6      	ble.n	6b9c <MAC_obtain_buffer+0xd4>
				}
				
				/* If the buffer was not found to be in use by either a Tx or an
				Rx descriptor, but the buffer is marked as in use, then mark the
				buffer to be in it's correct state of "not in use". */
				if( ( lBufferIsInUse == pdFALSE ) && ( ucMACBufferInUse[ lIndex ] == pdTRUE ) )
    6bce:	693b      	ldr	r3, [r7, #16]
    6bd0:	2b00      	cmp	r3, #0
    6bd2:	d10f      	bne.n	6bf4 <MAC_obtain_buffer+0x12c>
    6bd4:	687a      	ldr	r2, [r7, #4]
    6bd6:	f642 7358 	movw	r3, #12120	; 0x2f58
    6bda:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6bde:	5c9b      	ldrb	r3, [r3, r2]
    6be0:	2b01      	cmp	r3, #1
    6be2:	d107      	bne.n	6bf4 <MAC_obtain_buffer+0x12c>
				{
					ucMACBufferInUse[ lIndex ] = pdFALSE;
    6be4:	687a      	ldr	r2, [r7, #4]
    6be6:	f642 7358 	movw	r3, #12120	; 0x2f58
    6bea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6bee:	f04f 0100 	mov.w	r1, #0
    6bf2:	5499      	strb	r1, [r3, r2]
		if( pcReturn == NULL )
		{
			/* Did not find a buffer.  That should not really happen, but could if
			an interrupt was missed.  See if any buffers are marked as in use, but
			are not actually in use. */
			for( lIndex = 0; lIndex < macNUM_BUFFERS; lIndex++ )
    6bf4:	687b      	ldr	r3, [r7, #4]
    6bf6:	f103 0301 	add.w	r3, r3, #1
    6bfa:	607b      	str	r3, [r7, #4]
    6bfc:	687b      	ldr	r3, [r7, #4]
    6bfe:	2b06      	cmp	r3, #6
    6c00:	dd9a      	ble.n	6b38 <MAC_obtain_buffer+0x70>
			}
		}
																	
		/* If any buffer states were changed it might be that a buffer can now
		be obtained.  Try again, but only one more time. */
		lAttempt++;
    6c02:	68bb      	ldr	r3, [r7, #8]
    6c04:	f103 0301 	add.w	r3, r3, #1
    6c08:	60bb      	str	r3, [r7, #8]
unsigned char *pcReturn = NULL;
unsigned char *pcBufferAddress;

	/* Find and return the address of a buffer that is not being used.  Mark
	the buffer as now in use. */
	while( ( lAttempt <= 1 ) && ( pcReturn == NULL ) )
    6c0a:	68bb      	ldr	r3, [r7, #8]
    6c0c:	2b01      	cmp	r3, #1
    6c0e:	dc03      	bgt.n	6c18 <MAC_obtain_buffer+0x150>
    6c10:	697b      	ldr	r3, [r7, #20]
    6c12:	2b00      	cmp	r3, #0
    6c14:	f43f af62 	beq.w	6adc <MAC_obtain_buffer+0x14>
		/* If any buffer states were changed it might be that a buffer can now
		be obtained.  Try again, but only one more time. */
		lAttempt++;
	}
	
	configASSERT( pcReturn );
    6c18:	697b      	ldr	r3, [r7, #20]
    6c1a:	2b00      	cmp	r3, #0
    6c1c:	d109      	bne.n	6c32 <MAC_obtain_buffer+0x16a>
    6c1e:	f04f 0328 	mov.w	r3, #40	; 0x28
    6c22:	f383 8811 	msr	BASEPRI, r3
    6c26:	f3bf 8f6f 	isb	sy
    6c2a:	f3bf 8f4f 	dsb	sy
    6c2e:	61fb      	str	r3, [r7, #28]
    6c30:	e7fe      	b.n	6c30 <MAC_obtain_buffer+0x168>
	return pcReturn;
    6c32:	697b      	ldr	r3, [r7, #20]
}
    6c34:	4618      	mov	r0, r3
    6c36:	f107 0724 	add.w	r7, r7, #36	; 0x24
    6c3a:	46bd      	mov	sp, r7
    6c3c:	bc80      	pop	{r7}
    6c3e:	4770      	bx	lr

00006c40 <MAC_release_buffer>:
/***************************************************************************//**
 * Return a buffer to the list of free buffers, it was in use, but is not now.
 *
 */
void MAC_release_buffer( unsigned char *pucBufferToRelease )
{
    6c40:	b480      	push	{r7}
    6c42:	b085      	sub	sp, #20
    6c44:	af00      	add	r7, sp, #0
    6c46:	6078      	str	r0, [r7, #4]
long lIndex;

	/* uip_buf is going to point to a different buffer - first ensure the buffer
	it is currently pointing to is marked as being free again. */
	for( lIndex = 0; lIndex < macNUM_BUFFERS; lIndex++ )
    6c48:	f04f 0300 	mov.w	r3, #0
    6c4c:	60bb      	str	r3, [r7, #8]
    6c4e:	e019      	b.n	6c84 <MAC_release_buffer+0x44>
	{
		if( pucBufferToRelease == &( xMACBuffers.ucBuffer[ lIndex ][ 0 ] ) )
    6c50:	f240 63a8 	movw	r3, #1704	; 0x6a8
    6c54:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6c58:	68ba      	ldr	r2, [r7, #8]
    6c5a:	f44f 61ba 	mov.w	r1, #1488	; 0x5d0
    6c5e:	fb01 f202 	mul.w	r2, r1, r2
    6c62:	441a      	add	r2, r3
    6c64:	687b      	ldr	r3, [r7, #4]
    6c66:	429a      	cmp	r2, r3
    6c68:	d108      	bne.n	6c7c <MAC_release_buffer+0x3c>
		{
			/* This is the buffer in use, mark it as being free. */
			ucMACBufferInUse[ lIndex ] = pdFALSE;
    6c6a:	68ba      	ldr	r2, [r7, #8]
    6c6c:	f642 7358 	movw	r3, #12120	; 0x2f58
    6c70:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6c74:	f04f 0100 	mov.w	r1, #0
    6c78:	5499      	strb	r1, [r3, r2]
			break;
    6c7a:	e006      	b.n	6c8a <MAC_release_buffer+0x4a>
{
long lIndex;

	/* uip_buf is going to point to a different buffer - first ensure the buffer
	it is currently pointing to is marked as being free again. */
	for( lIndex = 0; lIndex < macNUM_BUFFERS; lIndex++ )
    6c7c:	68bb      	ldr	r3, [r7, #8]
    6c7e:	f103 0301 	add.w	r3, r3, #1
    6c82:	60bb      	str	r3, [r7, #8]
    6c84:	68bb      	ldr	r3, [r7, #8]
    6c86:	2b06      	cmp	r3, #6
    6c88:	dde2      	ble.n	6c50 <MAC_release_buffer+0x10>
			ucMACBufferInUse[ lIndex ] = pdFALSE;
			break;
		}
	}
	
	configASSERT( lIndex < macNUM_BUFFERS );
    6c8a:	68bb      	ldr	r3, [r7, #8]
    6c8c:	2b06      	cmp	r3, #6
    6c8e:	dd09      	ble.n	6ca4 <MAC_release_buffer+0x64>
    6c90:	f04f 0328 	mov.w	r3, #40	; 0x28
    6c94:	f383 8811 	msr	BASEPRI, r3
    6c98:	f3bf 8f6f 	isb	sy
    6c9c:	f3bf 8f4f 	dsb	sy
    6ca0:	60fb      	str	r3, [r7, #12]
    6ca2:	e7fe      	b.n	6ca2 <MAC_release_buffer+0x62>
}
    6ca4:	f107 0714 	add.w	r7, r7, #20
    6ca8:	46bd      	mov	sp, r7
    6caa:	bc80      	pop	{r7}
    6cac:	4770      	bx	lr
    6cae:	bf00      	nop

00006cb0 <MDIO_management_clock>:
static void
MDIO_management_clock
(
    int32_t clock
)
{
    6cb0:	b480      	push	{r7}
    6cb2:	b085      	sub	sp, #20
    6cb4:	af00      	add	r7, sp, #0
    6cb6:	6078      	str	r0, [r7, #4]
	int32_t volatile a;
    
    MAC_BITBAND->CSR9_MDC = (uint32_t)clock;
    6cb8:	f240 0300 	movw	r3, #0
    6cbc:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6cc0:	687a      	ldr	r2, [r7, #4]
    6cc2:	f8c3 2940 	str.w	r2, [r3, #2368]	; 0x940
    
	/* delay for 1us */
	for( a = 0; a < ONEMICROSECOND; a++ ){}
    6cc6:	f04f 0300 	mov.w	r3, #0
    6cca:	60fb      	str	r3, [r7, #12]
    6ccc:	e003      	b.n	6cd6 <MDIO_management_clock+0x26>
    6cce:	68fb      	ldr	r3, [r7, #12]
    6cd0:	f103 0301 	add.w	r3, r3, #1
    6cd4:	60fb      	str	r3, [r7, #12]
    6cd6:	68fb      	ldr	r3, [r7, #12]
    6cd8:	2b13      	cmp	r3, #19
    6cda:	d9f8      	bls.n	6cce <MDIO_management_clock+0x1e>
}
    6cdc:	f107 0714 	add.w	r7, r7, #20
    6ce0:	46bd      	mov	sp, r7
    6ce2:	bc80      	pop	{r7}
    6ce4:	4770      	bx	lr
    6ce6:	bf00      	nop

00006ce8 <MDIO_send_cmd>:
MDIO_send_cmd
(
    uint8_t regad,
    mdio_cmd_t mdio_cmd
)
{
    6ce8:	b580      	push	{r7, lr}
    6cea:	b084      	sub	sp, #16
    6cec:	af00      	add	r7, sp, #0
    6cee:	4602      	mov	r2, r0
    6cf0:	460b      	mov	r3, r1
    6cf2:	71fa      	strb	r2, [r7, #7]
    6cf4:	71bb      	strb	r3, [r7, #6]
    int32_t i;
    uint16_t mask, data;

    /* enable MII output */
    MAC_BITBAND->CSR9_MDEN = 1;
    6cf6:	f240 0300 	movw	r3, #0
    6cfa:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6cfe:	f04f 0201 	mov.w	r2, #1
    6d02:	f8c3 2948 	str.w	r2, [r3, #2376]	; 0x948

    /* send 32 1's preamble */
    MAC_BITBAND->CSR9_MDO = 1;
    6d06:	f240 0300 	movw	r3, #0
    6d0a:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6d0e:	f04f 0201 	mov.w	r2, #1
    6d12:	f8c3 2944 	str.w	r2, [r3, #2372]	; 0x944
    for (i = 0; i < PREAMBLECOUNT; i++) {
    6d16:	f04f 0300 	mov.w	r3, #0
    6d1a:	60bb      	str	r3, [r7, #8]
    6d1c:	e00b      	b.n	6d36 <MDIO_send_cmd+0x4e>
    	MDIO_management_clock( 0 );
    6d1e:	f04f 0000 	mov.w	r0, #0
    6d22:	f7ff ffc5 	bl	6cb0 <MDIO_management_clock>
    	MDIO_management_clock( 1 );
    6d26:	f04f 0001 	mov.w	r0, #1
    6d2a:	f7ff ffc1 	bl	6cb0 <MDIO_management_clock>
    /* enable MII output */
    MAC_BITBAND->CSR9_MDEN = 1;

    /* send 32 1's preamble */
    MAC_BITBAND->CSR9_MDO = 1;
    for (i = 0; i < PREAMBLECOUNT; i++) {
    6d2e:	68bb      	ldr	r3, [r7, #8]
    6d30:	f103 0301 	add.w	r3, r3, #1
    6d34:	60bb      	str	r3, [r7, #8]
    6d36:	68bb      	ldr	r3, [r7, #8]
    6d38:	2b1f      	cmp	r3, #31
    6d3a:	d9f0      	bls.n	6d1e <MDIO_send_cmd+0x36>
    	MDIO_management_clock( 0 );
    	MDIO_management_clock( 1 );
    }

    /* calculate data bits */
    data = MDIO_START |
    6d3c:	79bb      	ldrb	r3, [r7, #6]
    6d3e:	2b00      	cmp	r3, #0
    6d40:	d102      	bne.n	6d48 <MDIO_send_cmd+0x60>
    6d42:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    6d46:	e001      	b.n	6d4c <MDIO_send_cmd+0x64>
    6d48:	f245 0202 	movw	r2, #20482	; 0x5002
    6d4c:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    6d50:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6d54:	f893 30e8 	ldrb.w	r3, [r3, #232]	; 0xe8
    6d58:	ea4f 13c3 	mov.w	r3, r3, lsl #7
    6d5c:	b29b      	uxth	r3, r3
    6d5e:	f403 6378 	and.w	r3, r3, #3968	; 0xf80
    6d62:	ea42 0303 	orr.w	r3, r2, r3
    6d66:	b29a      	uxth	r2, r3
    6d68:	79fb      	ldrb	r3, [r7, #7]
    6d6a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    6d6e:	b29b      	uxth	r3, r3
    6d70:	f003 037c 	and.w	r3, r3, #124	; 0x7c
    6d74:	ea42 0303 	orr.w	r3, r2, r3
    6d78:	81fb      	strh	r3, [r7, #14]
    	(( mdio_cmd == MDIO_CMD_READ ) ? MDIO_READ : MDIO_WRITE ) |
    	((g_mss_mac.phy_address << MDIO_ADDR_OFFSET) & MDIO_ADDR_MASK) |
    	((regad << MDIO_REG_ADDR_OFFSET) & MDIO_REG_ADDR_MASK);

    /* sent out */
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    6d7a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    6d7e:	81bb      	strh	r3, [r7, #12]
    6d80:	e02b      	b.n	6dda <MDIO_send_cmd+0xf2>
    {
        if ((mask == 0x2) && (mdio_cmd == MDIO_CMD_READ)) {
    6d82:	89bb      	ldrh	r3, [r7, #12]
    6d84:	2b02      	cmp	r3, #2
    6d86:	d10a      	bne.n	6d9e <MDIO_send_cmd+0xb6>
    6d88:	79bb      	ldrb	r3, [r7, #6]
    6d8a:	2b00      	cmp	r3, #0
    6d8c:	d107      	bne.n	6d9e <MDIO_send_cmd+0xb6>
    		/* enable MII input */
            MAC_BITBAND->CSR9_MDEN = 0;
    6d8e:	f240 0300 	movw	r3, #0
    6d92:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6d96:	f04f 0200 	mov.w	r2, #0
    6d9a:	f8c3 2948 	str.w	r2, [r3, #2376]	; 0x948
        }

    	MDIO_management_clock( 0 );
    6d9e:	f04f 0000 	mov.w	r0, #0
    6da2:	f7ff ff85 	bl	6cb0 <MDIO_management_clock>

        /* prepare MDO */
        MAC_BITBAND->CSR9_MDO = (uint32_t)((mask & data) != 0 ? 1UL : 0UL);
    6da6:	f240 0300 	movw	r3, #0
    6daa:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6dae:	89b9      	ldrh	r1, [r7, #12]
    6db0:	89fa      	ldrh	r2, [r7, #14]
    6db2:	ea01 0202 	and.w	r2, r1, r2
    6db6:	b292      	uxth	r2, r2
    6db8:	2a00      	cmp	r2, #0
    6dba:	d002      	beq.n	6dc2 <MDIO_send_cmd+0xda>
    6dbc:	f04f 0201 	mov.w	r2, #1
    6dc0:	e001      	b.n	6dc6 <MDIO_send_cmd+0xde>
    6dc2:	f04f 0200 	mov.w	r2, #0
    6dc6:	f8c3 2944 	str.w	r2, [r3, #2372]	; 0x944
        
    	MDIO_management_clock( 1 );
    6dca:	f04f 0001 	mov.w	r0, #1
    6dce:	f7ff ff6f 	bl	6cb0 <MDIO_management_clock>
    	(( mdio_cmd == MDIO_CMD_READ ) ? MDIO_READ : MDIO_WRITE ) |
    	((g_mss_mac.phy_address << MDIO_ADDR_OFFSET) & MDIO_ADDR_MASK) |
    	((regad << MDIO_REG_ADDR_OFFSET) & MDIO_REG_ADDR_MASK);

    /* sent out */
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    6dd2:	89bb      	ldrh	r3, [r7, #12]
    6dd4:	ea4f 0353 	mov.w	r3, r3, lsr #1
    6dd8:	81bb      	strh	r3, [r7, #12]
    6dda:	89bb      	ldrh	r3, [r7, #12]
    6ddc:	2b00      	cmp	r3, #0
    6dde:	d1d0      	bne.n	6d82 <MDIO_send_cmd+0x9a>
        /* prepare MDO */
        MAC_BITBAND->CSR9_MDO = (uint32_t)((mask & data) != 0 ? 1UL : 0UL);
        
    	MDIO_management_clock( 1 );
    }
}
    6de0:	f107 0710 	add.w	r7, r7, #16
    6de4:	46bd      	mov	sp, r7
    6de6:	bd80      	pop	{r7, pc}

00006de8 <MDIO_read>:
static uint16_t
MDIO_read
(
    uint8_t regad
)
{
    6de8:	b580      	push	{r7, lr}
    6dea:	b084      	sub	sp, #16
    6dec:	af00      	add	r7, sp, #0
    6dee:	4603      	mov	r3, r0
    6df0:	71fb      	strb	r3, [r7, #7]
    uint16_t mask;
    uint16_t data;

    MDIO_send_cmd( regad, MDIO_CMD_READ);
    6df2:	79fb      	ldrb	r3, [r7, #7]
    6df4:	4618      	mov	r0, r3
    6df6:	f04f 0100 	mov.w	r1, #0
    6dfa:	f7ff ff75 	bl	6ce8 <MDIO_send_cmd>

    /* read data */
    data = 0;
    6dfe:	f04f 0300 	mov.w	r3, #0
    6e02:	81fb      	strh	r3, [r7, #14]
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    6e04:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    6e08:	81bb      	strh	r3, [r7, #12]
    6e0a:	e018      	b.n	6e3e <MDIO_read+0x56>
    {
    	MDIO_management_clock( 0 );
    6e0c:	f04f 0000 	mov.w	r0, #0
    6e10:	f7ff ff4e 	bl	6cb0 <MDIO_management_clock>

        /* read MDI */
        if(MAC_BITBAND-> CSR9_MDI != 0){
    6e14:	f240 0300 	movw	r3, #0
    6e18:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6e1c:	f8d3 394c 	ldr.w	r3, [r3, #2380]	; 0x94c
    6e20:	2b00      	cmp	r3, #0
    6e22:	d004      	beq.n	6e2e <MDIO_read+0x46>
            data |= mask;
    6e24:	89fa      	ldrh	r2, [r7, #14]
    6e26:	89bb      	ldrh	r3, [r7, #12]
    6e28:	ea42 0303 	orr.w	r3, r2, r3
    6e2c:	81fb      	strh	r3, [r7, #14]
        }

    	MDIO_management_clock( 1 );
    6e2e:	f04f 0001 	mov.w	r0, #1
    6e32:	f7ff ff3d 	bl	6cb0 <MDIO_management_clock>

    MDIO_send_cmd( regad, MDIO_CMD_READ);

    /* read data */
    data = 0;
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    6e36:	89bb      	ldrh	r3, [r7, #12]
    6e38:	ea4f 0353 	mov.w	r3, r3, lsr #1
    6e3c:	81bb      	strh	r3, [r7, #12]
    6e3e:	89bb      	ldrh	r3, [r7, #12]
    6e40:	2b00      	cmp	r3, #0
    6e42:	d1e3      	bne.n	6e0c <MDIO_read+0x24>
        }

    	MDIO_management_clock( 1 );
    }

    MDIO_management_clock( 0 );
    6e44:	f04f 0000 	mov.w	r0, #0
    6e48:	f7ff ff32 	bl	6cb0 <MDIO_management_clock>

    return data;
    6e4c:	89fb      	ldrh	r3, [r7, #14]
}
    6e4e:	4618      	mov	r0, r3
    6e50:	f107 0710 	add.w	r7, r7, #16
    6e54:	46bd      	mov	sp, r7
    6e56:	bd80      	pop	{r7, pc}

00006e58 <MDIO_write>:
MDIO_write
(
    uint8_t regad,
    uint16_t data
)
{
    6e58:	b580      	push	{r7, lr}
    6e5a:	b084      	sub	sp, #16
    6e5c:	af00      	add	r7, sp, #0
    6e5e:	4602      	mov	r2, r0
    6e60:	460b      	mov	r3, r1
    6e62:	71fa      	strb	r2, [r7, #7]
    6e64:	80bb      	strh	r3, [r7, #4]
    uint16_t mask;

    MDIO_send_cmd(regad, MDIO_CMD_WRITE);
    6e66:	79fb      	ldrb	r3, [r7, #7]
    6e68:	4618      	mov	r0, r3
    6e6a:	f04f 0101 	mov.w	r1, #1
    6e6e:	f7ff ff3b 	bl	6ce8 <MDIO_send_cmd>

    /* write data */
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    6e72:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    6e76:	81fb      	strh	r3, [r7, #14]
    6e78:	e01d      	b.n	6eb6 <MDIO_write+0x5e>
    {
    	MDIO_management_clock( 0 );
    6e7a:	f04f 0000 	mov.w	r0, #0
    6e7e:	f7ff ff17 	bl	6cb0 <MDIO_management_clock>

        /* prepare MDO */
    	MAC_BITBAND->CSR9_MDO = (uint32_t)((mask & data) != 0 ? 1UL : 0UL);
    6e82:	f240 0300 	movw	r3, #0
    6e86:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6e8a:	89f9      	ldrh	r1, [r7, #14]
    6e8c:	88ba      	ldrh	r2, [r7, #4]
    6e8e:	ea01 0202 	and.w	r2, r1, r2
    6e92:	b292      	uxth	r2, r2
    6e94:	2a00      	cmp	r2, #0
    6e96:	d002      	beq.n	6e9e <MDIO_write+0x46>
    6e98:	f04f 0201 	mov.w	r2, #1
    6e9c:	e001      	b.n	6ea2 <MDIO_write+0x4a>
    6e9e:	f04f 0200 	mov.w	r2, #0
    6ea2:	f8c3 2944 	str.w	r2, [r3, #2372]	; 0x944

    	MDIO_management_clock( 1 );
    6ea6:	f04f 0001 	mov.w	r0, #1
    6eaa:	f7ff ff01 	bl	6cb0 <MDIO_management_clock>
    uint16_t mask;

    MDIO_send_cmd(regad, MDIO_CMD_WRITE);

    /* write data */
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    6eae:	89fb      	ldrh	r3, [r7, #14]
    6eb0:	ea4f 0353 	mov.w	r3, r3, lsr #1
    6eb4:	81fb      	strh	r3, [r7, #14]
    6eb6:	89fb      	ldrh	r3, [r7, #14]
    6eb8:	2b00      	cmp	r3, #0
    6eba:	d1de      	bne.n	6e7a <MDIO_write+0x22>
    	MAC_BITBAND->CSR9_MDO = (uint32_t)((mask & data) != 0 ? 1UL : 0UL);

    	MDIO_management_clock( 1 );
    }

    MDIO_management_clock( 0 );
    6ebc:	f04f 0000 	mov.w	r0, #0
    6ec0:	f7ff fef6 	bl	6cb0 <MDIO_management_clock>
}
    6ec4:	f107 0710 	add.w	r7, r7, #16
    6ec8:	46bd      	mov	sp, r7
    6eca:	bd80      	pop	{r7, pc}

00006ecc <PHY_probe>:
 * Probe used PHY.
 *
 * return	PHY address. If PHY don't fount, returns 255.
 */
uint8_t PHY_probe( void )
{
    6ecc:	b580      	push	{r7, lr}
    6ece:	b082      	sub	sp, #8
    6ed0:	af00      	add	r7, sp, #0
	uint8_t phy;
	uint8_t phy_found;
	uint16_t reg;

	phy_found = 0;
    6ed2:	f04f 0300 	mov.w	r3, #0
    6ed6:	717b      	strb	r3, [r7, #5]
	for (phy = MSS_PHY_ADDRESS_MIN; phy <= MSS_PHY_ADDRESS_MAX; phy++) {
    6ed8:	f04f 0300 	mov.w	r3, #0
    6edc:	713b      	strb	r3, [r7, #4]
    6ede:	e01e      	b.n	6f1e <PHY_probe+0x52>
		g_mss_mac.phy_address = phy;
    6ee0:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    6ee4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6ee8:	793a      	ldrb	r2, [r7, #4]
    6eea:	f883 20e8 	strb.w	r2, [r3, #232]	; 0xe8

        reg = MDIO_read( PHYREG_PHYID1R );
    6eee:	f04f 0002 	mov.w	r0, #2
    6ef2:	f7ff ff79 	bl	6de8 <MDIO_read>
    6ef6:	4603      	mov	r3, r0
    6ef8:	80fb      	strh	r3, [r7, #6]

        if ((reg != 0x0000ffffUL) && (reg != 0x00000000UL)) {
    6efa:	88fa      	ldrh	r2, [r7, #6]
    6efc:	f64f 73ff 	movw	r3, #65535	; 0xffff
    6f00:	429a      	cmp	r2, r3
    6f02:	d008      	beq.n	6f16 <PHY_probe+0x4a>
    6f04:	88fb      	ldrh	r3, [r7, #6]
    6f06:	2b00      	cmp	r3, #0
    6f08:	d005      	beq.n	6f16 <PHY_probe+0x4a>
        	phy_found = 1;
    6f0a:	f04f 0301 	mov.w	r3, #1
    6f0e:	717b      	strb	r3, [r7, #5]
        	phy = MSS_PHY_ADDRESS_MAX + 1;
    6f10:	f04f 0320 	mov.w	r3, #32
    6f14:	713b      	strb	r3, [r7, #4]
	uint8_t phy;
	uint8_t phy_found;
	uint16_t reg;

	phy_found = 0;
	for (phy = MSS_PHY_ADDRESS_MIN; phy <= MSS_PHY_ADDRESS_MAX; phy++) {
    6f16:	793b      	ldrb	r3, [r7, #4]
    6f18:	f103 0301 	add.w	r3, r3, #1
    6f1c:	713b      	strb	r3, [r7, #4]
    6f1e:	793b      	ldrb	r3, [r7, #4]
    6f20:	2b1f      	cmp	r3, #31
    6f22:	d9dd      	bls.n	6ee0 <PHY_probe+0x14>
        	phy_found = 1;
        	phy = MSS_PHY_ADDRESS_MAX + 1;
        }
    }

    if( phy_found == 0 ) {
    6f24:	797b      	ldrb	r3, [r7, #5]
    6f26:	2b00      	cmp	r3, #0
    6f28:	d107      	bne.n	6f3a <PHY_probe+0x6e>
    	g_mss_mac.phy_address = MSS_PHY_ADDRESS_AUTO_DETECT;
    6f2a:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    6f2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6f32:	f04f 32ff 	mov.w	r2, #4294967295
    6f36:	f883 20e8 	strb.w	r2, [r3, #232]	; 0xe8
    }
    return g_mss_mac.phy_address;
    6f3a:	f64a 23f4 	movw	r3, #43764	; 0xaaf4
    6f3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6f42:	f893 30e8 	ldrb.w	r3, [r3, #232]	; 0xe8
}
    6f46:	4618      	mov	r0, r3
    6f48:	f107 0708 	add.w	r7, r7, #8
    6f4c:	46bd      	mov	sp, r7
    6f4e:	bd80      	pop	{r7, pc}

00006f50 <PHY_reset>:

/***************************************************************************//**
 * Resets the PHY.
 */
void PHY_reset( void )
{
    6f50:	b580      	push	{r7, lr}
    6f52:	af00      	add	r7, sp, #0
	MDIO_write( PHYREG_MIIMCR, MIIMCR_RESET );
    6f54:	f04f 0000 	mov.w	r0, #0
    6f58:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    6f5c:	f7ff ff7c 	bl	6e58 <MDIO_write>
	MDIO_write( PHYREG_MIIMCR,
    6f60:	f04f 0000 	mov.w	r0, #0
    6f64:	f44f 5194 	mov.w	r1, #4736	; 0x1280
    6f68:	f7ff ff76 	bl	6e58 <MDIO_write>
		MIIMCR_ENABLE_AUTONEGOTIATION |
		MIIMCR_RESTART_AUTONEGOTIATION |
		MIIMCR_COLLISION_TEST );
}
    6f6c:	bd80      	pop	{r7, pc}
    6f6e:	bf00      	nop

00006f70 <PHY_auto_negotiate>:

/***************************************************************************//**
 * Restarts PHY auto-negotiation and wait until it's over.
 */
void PHY_auto_negotiate( void )
{
    6f70:	b580      	push	{r7, lr}
    6f72:	b082      	sub	sp, #8
    6f74:	af00      	add	r7, sp, #0
	uint16_t reg;

	reg = MDIO_read( PHYREG_MIIMCR );
    6f76:	f04f 0000 	mov.w	r0, #0
    6f7a:	f7ff ff35 	bl	6de8 <MDIO_read>
    6f7e:	4603      	mov	r3, r0
    6f80:	80fb      	strh	r3, [r7, #6]
	MDIO_write( PHYREG_MIIMCR,
    6f82:	88fb      	ldrh	r3, [r7, #6]
    6f84:	f443 5390 	orr.w	r3, r3, #4608	; 0x1200
    6f88:	b29b      	uxth	r3, r3
    6f8a:	f04f 0000 	mov.w	r0, #0
    6f8e:	4619      	mov	r1, r3
    6f90:	f7ff ff62 	bl	6e58 <MDIO_write>
		(uint16_t)( MIIMCR_ENABLE_AUTONEGOTIATION |
		MIIMCR_RESTART_AUTONEGOTIATION |
		reg) );

	for( ;; ) {
		reg = MDIO_read( PHYREG_MIIMSR );
    6f94:	f04f 0001 	mov.w	r0, #1
    6f98:	f7ff ff26 	bl	6de8 <MDIO_read>
    6f9c:	4603      	mov	r3, r0
    6f9e:	80fb      	strh	r3, [r7, #6]
		if( (reg & MIIMSR_ANC) != 0 ) {
    6fa0:	88fb      	ldrh	r3, [r7, #6]
    6fa2:	f003 0320 	and.w	r3, r3, #32
    6fa6:	2b00      	cmp	r3, #0
    6fa8:	d104      	bne.n	6fb4 <PHY_auto_negotiate+0x44>
			break;
		} else {
			vTaskDelay( 200 );
    6faa:	f04f 00c8 	mov.w	r0, #200	; 0xc8
    6fae:	f009 fe69 	bl	10c84 <vTaskDelay>
		}
	}
    6fb2:	e7ef      	b.n	6f94 <PHY_auto_negotiate+0x24>
}
    6fb4:	bf00      	nop
    6fb6:	f107 0708 	add.w	r7, r7, #8
    6fba:	46bd      	mov	sp, r7
    6fbc:	bd80      	pop	{r7, pc}
    6fbe:	bf00      	nop

00006fc0 <PHY_link_status>:
 * Returns link status.
 *
 * @return          #MAC_LINK_STATUS_LINK if link is up.
 */
uint8_t PHY_link_status( void )
{
    6fc0:	b580      	push	{r7, lr}
    6fc2:	b082      	sub	sp, #8
    6fc4:	af00      	add	r7, sp, #0
	uint8_t retval = 0;
    6fc6:	f04f 0300 	mov.w	r3, #0
    6fca:	71fb      	strb	r3, [r7, #7]
	if(( MDIO_read( PHYREG_MIIMSR ) & MIIMSR_LINK ) != 0 ){
    6fcc:	f04f 0001 	mov.w	r0, #1
    6fd0:	f7ff ff0a 	bl	6de8 <MDIO_read>
    6fd4:	4603      	mov	r3, r0
    6fd6:	f003 0304 	and.w	r3, r3, #4
    6fda:	2b00      	cmp	r3, #0
    6fdc:	d002      	beq.n	6fe4 <PHY_link_status+0x24>
		retval = MSS_MAC_LINK_STATUS_LINK;
    6fde:	f04f 0301 	mov.w	r3, #1
    6fe2:	71fb      	strb	r3, [r7, #7]
	}
	return retval;
    6fe4:	79fb      	ldrb	r3, [r7, #7]
}
    6fe6:	4618      	mov	r0, r3
    6fe8:	f107 0708 	add.w	r7, r7, #8
    6fec:	46bd      	mov	sp, r7
    6fee:	bd80      	pop	{r7, pc}

00006ff0 <PHY_link_type>:
 * @return          the logical OR of the following values:
 *      #MAC_LINK_STATUS_100MB   - Connection is 100Mb
 *      #MAC_LINK_STATUS_FDX     - Connection is full duplex
 */
uint8_t PHY_link_type( void )
{
    6ff0:	b580      	push	{r7, lr}
    6ff2:	b082      	sub	sp, #8
    6ff4:	af00      	add	r7, sp, #0
	uint16_t diagnostic;
	uint8_t type = 0;
    6ff6:	f04f 0300 	mov.w	r3, #0
    6ffa:	71fb      	strb	r3, [r7, #7]

	diagnostic = MDIO_read( PHYREG_DR );
    6ffc:	f04f 0012 	mov.w	r0, #18
    7000:	f7ff fef2 	bl	6de8 <MDIO_read>
    7004:	4603      	mov	r3, r0
    7006:	80bb      	strh	r3, [r7, #4]

    if( (diagnostic & DR_DPLX) != 0 ) {
    7008:	88bb      	ldrh	r3, [r7, #4]
    700a:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    700e:	2b00      	cmp	r3, #0
    7010:	d002      	beq.n	7018 <PHY_link_type+0x28>
    	type = MSS_MAC_LINK_STATUS_FDX;
    7012:	f04f 0304 	mov.w	r3, #4
    7016:	71fb      	strb	r3, [r7, #7]
    }

    if( (diagnostic & DR_DATA_RATE) != 0 ) {
    7018:	88bb      	ldrh	r3, [r7, #4]
    701a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    701e:	2b00      	cmp	r3, #0
    7020:	d003      	beq.n	702a <PHY_link_type+0x3a>
    	type |= MSS_MAC_LINK_STATUS_100MB;
    7022:	79fb      	ldrb	r3, [r7, #7]
    7024:	f043 0302 	orr.w	r3, r3, #2
    7028:	71fb      	strb	r3, [r7, #7]
    }

    return type;
    702a:	79fb      	ldrb	r3, [r7, #7]
}
    702c:	4618      	mov	r0, r3
    702e:	f107 0708 	add.w	r7, r7, #8
    7032:	46bd      	mov	sp, r7
    7034:	bd80      	pop	{r7, pc}
    7036:	bf00      	nop

00007038 <PHY_set_link_type>:
void
PHY_set_link_type
(
    uint8_t type
)
{
    7038:	b580      	push	{r7, lr}
    703a:	b084      	sub	sp, #16
    703c:	af00      	add	r7, sp, #0
    703e:	4603      	mov	r3, r0
    7040:	71fb      	strb	r3, [r7, #7]
	uint16_t reg;

	reg = MDIO_read( PHYREG_ANAR );
    7042:	f04f 0004 	mov.w	r0, #4
    7046:	f7ff fecf 	bl	6de8 <MDIO_read>
    704a:	4603      	mov	r3, r0
    704c:	81fb      	strh	r3, [r7, #14]
	reg |= ANAR_100FD | ANAR_100HD | ANAR_10FD | ANAR_10HD;
    704e:	89fb      	ldrh	r3, [r7, #14]
    7050:	f443 73f0 	orr.w	r3, r3, #480	; 0x1e0
    7054:	81fb      	strh	r3, [r7, #14]

	if( (type & MSS_MAC_LINK_STATUS_100MB) == 0 ) {
    7056:	79fb      	ldrb	r3, [r7, #7]
    7058:	f003 0302 	and.w	r3, r3, #2
    705c:	2b00      	cmp	r3, #0
    705e:	d103      	bne.n	7068 <PHY_set_link_type+0x30>
		reg &= ~(ANAR_100FD | ANAR_100HD);
    7060:	89fb      	ldrh	r3, [r7, #14]
    7062:	f423 73c0 	bic.w	r3, r3, #384	; 0x180
    7066:	81fb      	strh	r3, [r7, #14]
	}

	if( (type & MSS_MAC_LINK_STATUS_FDX) == 0 ) {
    7068:	79fb      	ldrb	r3, [r7, #7]
    706a:	f003 0304 	and.w	r3, r3, #4
    706e:	2b00      	cmp	r3, #0
    7070:	d103      	bne.n	707a <PHY_set_link_type+0x42>
		reg &= ~(ANAR_100FD | ANAR_10FD);
    7072:	89fb      	ldrh	r3, [r7, #14]
    7074:	f423 73a0 	bic.w	r3, r3, #320	; 0x140
    7078:	81fb      	strh	r3, [r7, #14]
	}

	MDIO_write( PHYREG_ANAR, reg );
    707a:	89fb      	ldrh	r3, [r7, #14]
    707c:	f04f 0004 	mov.w	r0, #4
    7080:	4619      	mov	r1, r3
    7082:	f7ff fee9 	bl	6e58 <MDIO_write>
}
    7086:	f107 0710 	add.w	r7, r7, #16
    708a:	46bd      	mov	sp, r7
    708c:	bd80      	pop	{r7, pc}
    708e:	bf00      	nop

00007090 <PHY_set_loopback>:
uint16_t
PHY_set_loopback
(
   uint8_t enable
)
{
    7090:	b580      	push	{r7, lr}
    7092:	b084      	sub	sp, #16
    7094:	af00      	add	r7, sp, #0
    7096:	4603      	mov	r3, r0
    7098:	71fb      	strb	r3, [r7, #7]

	uint16_t reg = 0;   
    709a:	f04f 0300 	mov.w	r3, #0
    709e:	81fb      	strh	r3, [r7, #14]
	

	reg = MDIO_read( PHYREG_MIIMCR );
    70a0:	f04f 0000 	mov.w	r0, #0
    70a4:	f7ff fea0 	bl	6de8 <MDIO_read>
    70a8:	4603      	mov	r3, r0
    70aa:	81fb      	strh	r3, [r7, #14]
	// If set to one we need to set the LOCAL Phy loopback
	if(enable == 1)
    70ac:	79fb      	ldrb	r3, [r7, #7]
    70ae:	2b01      	cmp	r3, #1
    70b0:	d104      	bne.n	70bc <PHY_set_loopback+0x2c>
		reg |= MIIMCR_LOOPBACK;
    70b2:	89fb      	ldrh	r3, [r7, #14]
    70b4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    70b8:	81fb      	strh	r3, [r7, #14]
    70ba:	e003      	b.n	70c4 <PHY_set_loopback+0x34>
	else // else we want to clear the bit..
		reg ^= MIIMCR_LOOPBACK;
    70bc:	89fb      	ldrh	r3, [r7, #14]
    70be:	f483 4380 	eor.w	r3, r3, #16384	; 0x4000
    70c2:	81fb      	strh	r3, [r7, #14]
	
	
	MDIO_write( PHYREG_MIIMCR,reg );
    70c4:	89fb      	ldrh	r3, [r7, #14]
    70c6:	f04f 0000 	mov.w	r0, #0
    70ca:	4619      	mov	r1, r3
    70cc:	f7ff fec4 	bl	6e58 <MDIO_write>
	reg = MDIO_read( PHYREG_MIIMCR );
    70d0:	f04f 0000 	mov.w	r0, #0
    70d4:	f7ff fe88 	bl	6de8 <MDIO_read>
    70d8:	4603      	mov	r3, r0
    70da:	81fb      	strh	r3, [r7, #14]
	
	return reg;
    70dc:	89fb      	ldrh	r3, [r7, #14]
	
}
    70de:	4618      	mov	r0, r3
    70e0:	f107 0710 	add.w	r7, r7, #16
    70e4:	46bd      	mov	sp, r7
    70e6:	bd80      	pop	{r7, pc}

000070e8 <ACE_get_channel_type>:
channel_type_t
ACE_get_channel_type
(
    ace_channel_handle_t    channel_handle
)
{
    70e8:	b480      	push	{r7}
    70ea:	b085      	sub	sp, #20
    70ec:	af00      	add	r7, sp, #0
    70ee:	4603      	mov	r3, r0
    70f0:	71fb      	strb	r3, [r7, #7]
    channel_type_t channel_type = VOLTAGE;
    70f2:	f04f 0300 	mov.w	r3, #0
    70f6:	73fb      	strb	r3, [r7, #15]
    
    ASSERT((int32_t)channel_handle < ACE_NB_OF_INPUT_CHANNELS);
    70f8:	79fb      	ldrb	r3, [r7, #7]
    70fa:	2b02      	cmp	r3, #2
    70fc:	d900      	bls.n	7100 <ACE_get_channel_type+0x18>
    70fe:	be00      	bkpt	0x0000
    
    if((int32_t)channel_handle < ACE_NB_OF_INPUT_CHANNELS)
    7100:	79fb      	ldrb	r3, [r7, #7]
    7102:	2b02      	cmp	r3, #2
    7104:	d807      	bhi.n	7116 <ACE_get_channel_type+0x2e>
    {
        channel_type = channel_type_lut_h[channel_handle];
    7106:	79fa      	ldrb	r2, [r7, #7]
    7108:	f642 736c 	movw	r3, #12140	; 0x2f6c
    710c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7110:	5c9b      	ldrb	r3, [r3, r2]
    7112:	73fb      	strb	r3, [r7, #15]
    7114:	e002      	b.n	711c <ACE_get_channel_type+0x34>
    }
    else
    {
        channel_type = VOLTAGE;
    7116:	f04f 0300 	mov.w	r3, #0
    711a:	73fb      	strb	r3, [r7, #15]
    }
    
    return channel_type;
    711c:	7bfb      	ldrb	r3, [r7, #15]
}
    711e:	4618      	mov	r0, r3
    7120:	f107 0714 	add.w	r7, r7, #20
    7124:	46bd      	mov	sp, r7
    7126:	bc80      	pop	{r7}
    7128:	4770      	bx	lr
    712a:	bf00      	nop

0000712c <ACE_convert_adc_input_to_mV>:
uint32_t ACE_convert_adc_input_to_mV
(
    ace_channel_handle_t    channel_handle,
    uint16_t                sample_value
)
{
    712c:	b480      	push	{r7}
    712e:	b085      	sub	sp, #20
    7130:	af00      	add	r7, sp, #0
    7132:	4602      	mov	r2, r0
    7134:	460b      	mov	r3, r1
    7136:	71fa      	strb	r2, [r7, #7]
    7138:	80bb      	strh	r3, [r7, #4]
    uint32_t voltage;
    adc_channel_id_t channel_id;
    uint8_t adc_id;
    
    channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    713a:	79fa      	ldrb	r2, [r7, #7]
    713c:	f240 035c 	movw	r3, #92	; 0x5c
    7140:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7144:	ea4f 1202 	mov.w	r2, r2, lsl #4
    7148:	4413      	add	r3, r2
    714a:	791b      	ldrb	r3, [r3, #4]
    714c:	73bb      	strb	r3, [r7, #14]
    adc_id = (uint8_t)channel_id >> 4u;
    714e:	7bbb      	ldrb	r3, [r7, #14]
    7150:	ea4f 1313 	mov.w	r3, r3, lsr #4
    7154:	73fb      	strb	r3, [r7, #15]
    voltage = ( g_ace_adc_config[adc_id].va_ref * (uint32_t)sample_value ) / g_ace_adc_config[adc_id].adc_resolution;
    7156:	7bfb      	ldrb	r3, [r7, #15]
    7158:	f240 0254 	movw	r2, #84	; 0x54
    715c:	f2c2 0200 	movt	r2, #8192	; 0x2000
    7160:	ea4f 0383 	mov.w	r3, r3, lsl #2
    7164:	4413      	add	r3, r2
    7166:	885b      	ldrh	r3, [r3, #2]
    7168:	88ba      	ldrh	r2, [r7, #4]
    716a:	fb02 f203 	mul.w	r2, r2, r3
    716e:	7bf9      	ldrb	r1, [r7, #15]
    7170:	f240 0354 	movw	r3, #84	; 0x54
    7174:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7178:	f833 3021 	ldrh.w	r3, [r3, r1, lsl #2]
    717c:	fbb2 f3f3 	udiv	r3, r2, r3
    7180:	60bb      	str	r3, [r7, #8]
    
    return voltage;
    7182:	68bb      	ldr	r3, [r7, #8]
}
    7184:	4618      	mov	r0, r3
    7186:	f107 0714 	add.w	r7, r7, #20
    718a:	46bd      	mov	sp, r7
    718c:	bc80      	pop	{r7}
    718e:	4770      	bx	lr

00007190 <ace_init_convert>:

/*-------------------------------------------------------------------------*//**
 *
 */
void ace_init_convert(void)
{
    7190:	b480      	push	{r7}
    7192:	b087      	sub	sp, #28
    7194:	af00      	add	r7, sp, #0
    uint8_t abps_idx;
    int32_t channel;
    uint32_t saved_pc2_ctrl;
    
    /* Pause the SSE PC2 while accesses to ACB from APB3 are taking place. */
    saved_pc2_ctrl = ACE->PC2_CTRL;
    7196:	f240 0300 	movw	r3, #0
    719a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    719e:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
    71a2:	60fb      	str	r3, [r7, #12]
    ACE->PC2_CTRL = 0u;
    71a4:	f240 0300 	movw	r3, #0
    71a8:	f2c4 0302 	movt	r3, #16386	; 0x4002
    71ac:	f04f 0200 	mov.w	r2, #0
    71b0:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    
    /* Populate the g_gdec_lut look-up table. */
    for(abps_idx = 0u; abps_idx < MAX_NB_OF_APBS; ++abps_idx)
    71b4:	f04f 0300 	mov.w	r3, #0
    71b8:	71fb      	strb	r3, [r7, #7]
    71ba:	e039      	b.n	7230 <ace_init_convert+0xa0>
    {
        uint8_t quad_id;
        uint8_t acb_config_byte;
        uint8_t channel_is_abps2;
        
        quad_id = abps_idx / 2u;
    71bc:	79fb      	ldrb	r3, [r7, #7]
    71be:	ea4f 0353 	mov.w	r3, r3, lsr #1
    71c2:	747b      	strb	r3, [r7, #17]
        acb_config_byte = ACE->ACB_DATA[quad_id].b8;
    71c4:	f240 0200 	movw	r2, #0
    71c8:	f2c4 0202 	movt	r2, #16386	; 0x4002
    71cc:	7c79      	ldrb	r1, [r7, #17]
    71ce:	460b      	mov	r3, r1
    71d0:	ea4f 0343 	mov.w	r3, r3, lsl #1
    71d4:	440b      	add	r3, r1
    71d6:	ea4f 1303 	mov.w	r3, r3, lsl #4
    71da:	4413      	add	r3, r2
    71dc:	f503 7308 	add.w	r3, r3, #544	; 0x220
    71e0:	791b      	ldrb	r3, [r3, #4]
    71e2:	74bb      	strb	r3, [r7, #18]
        channel_is_abps2 = abps_idx & 0x01u;
    71e4:	79fb      	ldrb	r3, [r7, #7]
    71e6:	f003 0301 	and.w	r3, r3, #1
    71ea:	74fb      	strb	r3, [r7, #19]
        if(channel_is_abps2)
    71ec:	7cfb      	ldrb	r3, [r7, #19]
    71ee:	2b00      	cmp	r3, #0
    71f0:	d00d      	beq.n	720e <ace_init_convert+0x7e>
        {
            /* ABPS2 */
            g_gdec_lut[abps_idx] = (acb_config_byte >> 5u) & 0x03u;
    71f2:	79f9      	ldrb	r1, [r7, #7]
    71f4:	7cbb      	ldrb	r3, [r7, #18]
    71f6:	ea4f 1353 	mov.w	r3, r3, lsr #5
    71fa:	b2db      	uxtb	r3, r3
    71fc:	461a      	mov	r2, r3
    71fe:	f002 0203 	and.w	r2, r2, #3
    7202:	f642 7360 	movw	r3, #12128	; 0x2f60
    7206:	f2c2 0300 	movt	r3, #8192	; 0x2000
    720a:	545a      	strb	r2, [r3, r1]
    720c:	e00c      	b.n	7228 <ace_init_convert+0x98>
        }
        else
        {
            /* ABPS1 */
            g_gdec_lut[abps_idx] = (acb_config_byte >> 1u) & 0x03u;
    720e:	79f9      	ldrb	r1, [r7, #7]
    7210:	7cbb      	ldrb	r3, [r7, #18]
    7212:	ea4f 0353 	mov.w	r3, r3, lsr #1
    7216:	b2db      	uxtb	r3, r3
    7218:	461a      	mov	r2, r3
    721a:	f002 0203 	and.w	r2, r2, #3
    721e:	f642 7360 	movw	r3, #12128	; 0x2f60
    7222:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7226:	545a      	strb	r2, [r3, r1]
    /* Pause the SSE PC2 while accesses to ACB from APB3 are taking place. */
    saved_pc2_ctrl = ACE->PC2_CTRL;
    ACE->PC2_CTRL = 0u;
    
    /* Populate the g_gdec_lut look-up table. */
    for(abps_idx = 0u; abps_idx < MAX_NB_OF_APBS; ++abps_idx)
    7228:	79fb      	ldrb	r3, [r7, #7]
    722a:	f103 0301 	add.w	r3, r3, #1
    722e:	71fb      	strb	r3, [r7, #7]
    7230:	79fb      	ldrb	r3, [r7, #7]
    7232:	2b09      	cmp	r3, #9
    7234:	d9c2      	bls.n	71bc <ace_init_convert+0x2c>
            g_gdec_lut[abps_idx] = (acb_config_byte >> 1u) & 0x03u;
        }
    }
    
    /* Populate the channel_type_lut_h look-up table. */
    for(channel = 0; channel < ACE_NB_OF_INPUT_CHANNELS; ++channel)
    7236:	f04f 0300 	mov.w	r3, #0
    723a:	60bb      	str	r3, [r7, #8]
    723c:	e073      	b.n	7326 <ace_init_convert+0x196>
        uint8_t quad_id;
        uint8_t acb_config_byte;
        adc_channel_id_t channel_id;
        channel_type_t channel_type;
    
        channel_id = g_ace_channel_desc_table[channel].signal_id;
    723e:	68ba      	ldr	r2, [r7, #8]
    7240:	f240 035c 	movw	r3, #92	; 0x5c
    7244:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7248:	ea4f 1202 	mov.w	r2, r2, lsl #4
    724c:	4413      	add	r3, r2
    724e:	791b      	ldrb	r3, [r3, #4]
    7250:	75bb      	strb	r3, [r7, #22]
        quad_id = channel_quad_lut[channel_id];
    7252:	7dba      	ldrb	r2, [r7, #22]
    7254:	f24b 633c 	movw	r3, #46652	; 0xb63c
    7258:	f2c0 0301 	movt	r3, #1
    725c:	5c9b      	ldrb	r3, [r3, r2]
    725e:	753b      	strb	r3, [r7, #20]
        
        switch (channel_type_lut[channel_id])
    7260:	7dba      	ldrb	r2, [r7, #22]
    7262:	f24b 630c 	movw	r3, #46604	; 0xb60c
    7266:	f2c0 0301 	movt	r3, #1
    726a:	5c9b      	ldrb	r3, [r3, r2]
    726c:	2b01      	cmp	r3, #1
    726e:	d007      	beq.n	7280 <ace_init_convert+0xf0>
    7270:	2b02      	cmp	r3, #2
    7272:	d027      	beq.n	72c4 <ace_init_convert+0x134>
    7274:	2b00      	cmp	r3, #0
    7276:	d147      	bne.n	7308 <ace_init_convert+0x178>
        {
            case VOLTAGE_CHANNEL:
                channel_type = VOLTAGE;
    7278:	f04f 0300 	mov.w	r3, #0
    727c:	75fb      	strb	r3, [r7, #23]
                break;
    727e:	e047      	b.n	7310 <ace_init_convert+0x180>
                
            case CURRENT_CHANNEL:
                ASSERT( quad_id != INVALID_QUAD_ID );
    7280:	7d3b      	ldrb	r3, [r7, #20]
    7282:	2bff      	cmp	r3, #255	; 0xff
    7284:	d100      	bne.n	7288 <ace_init_convert+0xf8>
    7286:	be00      	bkpt	0x0000
                acb_config_byte = ACE->ACB_DATA[quad_id].b9;
    7288:	f240 0200 	movw	r2, #0
    728c:	f2c4 0202 	movt	r2, #16386	; 0x4002
    7290:	7d39      	ldrb	r1, [r7, #20]
    7292:	460b      	mov	r3, r1
    7294:	ea4f 0343 	mov.w	r3, r3, lsl #1
    7298:	440b      	add	r3, r1
    729a:	ea4f 1303 	mov.w	r3, r3, lsl #4
    729e:	4413      	add	r3, r2
    72a0:	f503 7308 	add.w	r3, r3, #544	; 0x220
    72a4:	7a1b      	ldrb	r3, [r3, #8]
    72a6:	757b      	strb	r3, [r7, #21]
                if ( acb_config_byte & 0x01u )
    72a8:	7d7b      	ldrb	r3, [r7, #21]
    72aa:	f003 0301 	and.w	r3, r3, #1
    72ae:	b2db      	uxtb	r3, r3
    72b0:	2b00      	cmp	r3, #0
    72b2:	d003      	beq.n	72bc <ace_init_convert+0x12c>
                {
                    channel_type = VOLTAGE;
    72b4:	f04f 0300 	mov.w	r3, #0
    72b8:	75fb      	strb	r3, [r7, #23]
                }
                else
                {
                    channel_type = CURRENT;
                }
                break;
    72ba:	e029      	b.n	7310 <ace_init_convert+0x180>
                {
                    channel_type = VOLTAGE;
                }
                else
                {
                    channel_type = CURRENT;
    72bc:	f04f 0301 	mov.w	r3, #1
    72c0:	75fb      	strb	r3, [r7, #23]
                }
                break;
    72c2:	e025      	b.n	7310 <ace_init_convert+0x180>
            
            case TEMPERATURE_CHANNEL:
                ASSERT( quad_id != INVALID_QUAD_ID );
    72c4:	7d3b      	ldrb	r3, [r7, #20]
    72c6:	2bff      	cmp	r3, #255	; 0xff
    72c8:	d100      	bne.n	72cc <ace_init_convert+0x13c>
    72ca:	be00      	bkpt	0x0000
                acb_config_byte = ACE->ACB_DATA[quad_id].b10;
    72cc:	f240 0200 	movw	r2, #0
    72d0:	f2c4 0202 	movt	r2, #16386	; 0x4002
    72d4:	7d39      	ldrb	r1, [r7, #20]
    72d6:	460b      	mov	r3, r1
    72d8:	ea4f 0343 	mov.w	r3, r3, lsl #1
    72dc:	440b      	add	r3, r1
    72de:	ea4f 1303 	mov.w	r3, r3, lsl #4
    72e2:	4413      	add	r3, r2
    72e4:	f503 730a 	add.w	r3, r3, #552	; 0x228
    72e8:	791b      	ldrb	r3, [r3, #4]
    72ea:	757b      	strb	r3, [r7, #21]
                if ( acb_config_byte & 0x01u )
    72ec:	7d7b      	ldrb	r3, [r7, #21]
    72ee:	f003 0301 	and.w	r3, r3, #1
    72f2:	b2db      	uxtb	r3, r3
    72f4:	2b00      	cmp	r3, #0
    72f6:	d003      	beq.n	7300 <ace_init_convert+0x170>
                {
                    channel_type = VOLTAGE;
    72f8:	f04f 0300 	mov.w	r3, #0
    72fc:	75fb      	strb	r3, [r7, #23]
                }
                else
                {
                    channel_type = TEMPERATURE;
                }
                break;
    72fe:	e007      	b.n	7310 <ace_init_convert+0x180>
                {
                    channel_type = VOLTAGE;
                }
                else
                {
                    channel_type = TEMPERATURE;
    7300:	f04f 0302 	mov.w	r3, #2
    7304:	75fb      	strb	r3, [r7, #23]
                }
                break;
    7306:	e003      	b.n	7310 <ace_init_convert+0x180>
                
            default:
                ASSERT(0);
    7308:	be00      	bkpt	0x0000
                channel_type = VOLTAGE;
    730a:	f04f 0300 	mov.w	r3, #0
    730e:	75fb      	strb	r3, [r7, #23]
                break;
        }
        
        channel_type_lut_h[channel] = channel_type;
    7310:	68ba      	ldr	r2, [r7, #8]
    7312:	f642 736c 	movw	r3, #12140	; 0x2f6c
    7316:	f2c2 0300 	movt	r3, #8192	; 0x2000
    731a:	7df9      	ldrb	r1, [r7, #23]
    731c:	5499      	strb	r1, [r3, r2]
            g_gdec_lut[abps_idx] = (acb_config_byte >> 1u) & 0x03u;
        }
    }
    
    /* Populate the channel_type_lut_h look-up table. */
    for(channel = 0; channel < ACE_NB_OF_INPUT_CHANNELS; ++channel)
    731e:	68bb      	ldr	r3, [r7, #8]
    7320:	f103 0301 	add.w	r3, r3, #1
    7324:	60bb      	str	r3, [r7, #8]
    7326:	68bb      	ldr	r3, [r7, #8]
    7328:	2b02      	cmp	r3, #2
    732a:	dd88      	ble.n	723e <ace_init_convert+0xae>
        
        channel_type_lut_h[channel] = channel_type;
    }
    
    /* Restore SSE PC2 operations. */
    ACE->PC2_CTRL = saved_pc2_ctrl;
    732c:	f240 0300 	movw	r3, #0
    7330:	f2c4 0302 	movt	r3, #16386	; 0x4002
    7334:	68fa      	ldr	r2, [r7, #12]
    7336:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
}
    733a:	f107 071c 	add.w	r7, r7, #28
    733e:	46bd      	mov	sp, r7
    7340:	bc80      	pop	{r7}
    7342:	4770      	bx	lr

00007344 <ACE_convert_to_mV>:
int32_t ACE_convert_to_mV
(
    ace_channel_handle_t    channel_handle,
    uint16_t                sample_value
)
{
    7344:	b480      	push	{r7}
    7346:	b08d      	sub	sp, #52	; 0x34
    7348:	af00      	add	r7, sp, #0
    734a:	4602      	mov	r2, r0
    734c:	460b      	mov	r3, r1
    734e:	71fa      	strb	r2, [r7, #7]
    7350:	80bb      	strh	r3, [r7, #4]
    int32_t voltage;
    adc_channel_id_t channel_id;
    uint8_t adc_id;
    
    channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    7352:	79fa      	ldrb	r2, [r7, #7]
    7354:	f240 035c 	movw	r3, #92	; 0x5c
    7358:	f2c2 0300 	movt	r3, #8192	; 0x2000
    735c:	ea4f 1202 	mov.w	r2, r2, lsl #4
    7360:	4413      	add	r3, r2
    7362:	791b      	ldrb	r3, [r3, #4]
    7364:	74bb      	strb	r3, [r7, #18]
    adc_id = (uint8_t)channel_id >> 4u;
    7366:	7cbb      	ldrb	r3, [r7, #18]
    7368:	ea4f 1313 	mov.w	r3, r3, lsr #4
    736c:	74fb      	strb	r3, [r7, #19]
    
    if (NON_ABPS_CHANNEL == abps_channel_lut[channel_id])
    736e:	7cba      	ldrb	r2, [r7, #18]
    7370:	f24b 636c 	movw	r3, #46700	; 0xb66c
    7374:	f2c0 0301 	movt	r3, #1
    7378:	5c9b      	ldrb	r3, [r3, r2]
    737a:	2bff      	cmp	r3, #255	; 0xff
    737c:	d11c      	bne.n	73b8 <ACE_convert_to_mV+0x74>
    {
        uint32_t adc_voltage;
        
        adc_voltage = ( g_ace_adc_config[adc_id].va_ref * (uint32_t)sample_value ) / PPE_SAMPLES_RESOLUTION;
    737e:	7cfb      	ldrb	r3, [r7, #19]
    7380:	f240 0254 	movw	r2, #84	; 0x54
    7384:	f2c2 0200 	movt	r2, #8192	; 0x2000
    7388:	ea4f 0383 	mov.w	r3, r3, lsl #2
    738c:	4413      	add	r3, r2
    738e:	885b      	ldrh	r3, [r3, #2]
    7390:	88ba      	ldrh	r2, [r7, #4]
    7392:	fb02 f203 	mul.w	r2, r2, r3
    7396:	f240 1301 	movw	r3, #257	; 0x101
    739a:	f2c0 0310 	movt	r3, #16
    739e:	fba3 1302 	umull	r1, r3, r3, r2
    73a2:	ebc3 0202 	rsb	r2, r3, r2
    73a6:	ea4f 0252 	mov.w	r2, r2, lsr #1
    73aa:	4413      	add	r3, r2
    73ac:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    73b0:	617b      	str	r3, [r7, #20]
        voltage = (int32_t)adc_voltage;
    73b2:	697b      	ldr	r3, [r7, #20]
    73b4:	60fb      	str	r3, [r7, #12]
    73b6:	e03d      	b.n	7434 <ACE_convert_to_mV+0xf0>
        int32_t gain;
        int32_t va_ref;
        int32_t sample;
        int32_t ppe_resolution;
        
        apbs_idx = abps_idx_lut[channel_id];
    73b8:	7cba      	ldrb	r2, [r7, #18]
    73ba:	f24b 639c 	movw	r3, #46748	; 0xb69c
    73be:	f2c0 0301 	movt	r3, #1
    73c2:	5c9b      	ldrb	r3, [r3, r2]
    73c4:	76fb      	strb	r3, [r7, #27]
        gdec = g_gdec_lut[apbs_idx];
    73c6:	7efa      	ldrb	r2, [r7, #27]
    73c8:	f642 7360 	movw	r3, #12128	; 0x2f60
    73cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    73d0:	5c9b      	ldrb	r3, [r3, r2]
    73d2:	76bb      	strb	r3, [r7, #26]

        sample = (int32_t)sample_value;
    73d4:	88bb      	ldrh	r3, [r7, #4]
    73d6:	62bb      	str	r3, [r7, #40]	; 0x28
        ppe_resolution = (int32_t)PPE_SAMPLES_RESOLUTION;
    73d8:	f640 73ff 	movw	r3, #4095	; 0xfff
    73dc:	62fb      	str	r3, [r7, #44]	; 0x2c
        gain = (int32_t)apbs_gain_lut[gdec];
    73de:	7eba      	ldrb	r2, [r7, #26]
    73e0:	f24b 63cc 	movw	r3, #46796	; 0xb6cc
    73e4:	f2c0 0301 	movt	r3, #1
    73e8:	5c9b      	ldrb	r3, [r3, r2]
    73ea:	623b      	str	r3, [r7, #32]
        range = (int32_t)apbs_range[gdec];
    73ec:	7eba      	ldrb	r2, [r7, #26]
    73ee:	f24b 63d0 	movw	r3, #46800	; 0xb6d0
    73f2:	f2c0 0301 	movt	r3, #1
    73f6:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    73fa:	b21b      	sxth	r3, r3
    73fc:	61fb      	str	r3, [r7, #28]
        va_ref = (int32_t)g_ace_adc_config[adc_id].va_ref;
    73fe:	7cfb      	ldrb	r3, [r7, #19]
    7400:	f240 0254 	movw	r2, #84	; 0x54
    7404:	f2c2 0200 	movt	r2, #8192	; 0x2000
    7408:	ea4f 0383 	mov.w	r3, r3, lsl #2
    740c:	4413      	add	r3, r2
    740e:	885b      	ldrh	r3, [r3, #2]
    7410:	627b      	str	r3, [r7, #36]	; 0x24
        
        voltage = range - (((ppe_resolution - sample) * (va_ref * gain)) / ppe_resolution);
    7412:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    7414:	6abb      	ldr	r3, [r7, #40]	; 0x28
    7416:	ebc3 0302 	rsb	r3, r3, r2
    741a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    741c:	6a39      	ldr	r1, [r7, #32]
    741e:	fb01 f202 	mul.w	r2, r1, r2
    7422:	fb02 f203 	mul.w	r2, r2, r3
    7426:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    7428:	fb92 f3f3 	sdiv	r3, r2, r3
    742c:	69fa      	ldr	r2, [r7, #28]
    742e:	ebc3 0302 	rsb	r3, r3, r2
    7432:	60fb      	str	r3, [r7, #12]
    }
    return voltage;
    7434:	68fb      	ldr	r3, [r7, #12]
}
    7436:	4618      	mov	r0, r3
    7438:	f107 0734 	add.w	r7, r7, #52	; 0x34
    743c:	46bd      	mov	sp, r7
    743e:	bc80      	pop	{r7}
    7440:	4770      	bx	lr
    7442:	bf00      	nop

00007444 <ACE_convert_to_mA>:
uint32_t ACE_convert_to_mA
(
    ace_channel_handle_t    channel_handle,
    uint16_t                sample_value
)
{
    7444:	b580      	push	{r7, lr}
    7446:	b086      	sub	sp, #24
    7448:	af00      	add	r7, sp, #0
    744a:	4602      	mov	r2, r0
    744c:	460b      	mov	r3, r1
    744e:	71fa      	strb	r2, [r7, #7]
    7450:	80bb      	strh	r3, [r7, #4]
    uint32_t current = 0u;
    7452:	f04f 0300 	mov.w	r3, #0
    7456:	60bb      	str	r3, [r7, #8]
    
    ASSERT((int32_t)channel_handle < ACE_NB_OF_INPUT_CHANNELS);
    7458:	79fb      	ldrb	r3, [r7, #7]
    745a:	2b02      	cmp	r3, #2
    745c:	d900      	bls.n	7460 <ACE_convert_to_mA+0x1c>
    745e:	be00      	bkpt	0x0000
    
    if((int32_t)channel_handle < ACE_NB_OF_INPUT_CHANNELS)
    7460:	79fb      	ldrb	r3, [r7, #7]
    7462:	2b02      	cmp	r3, #2
    7464:	d842      	bhi.n	74ec <ACE_convert_to_mA+0xa8>
    {
        adc_channel_id_t channel_id;
        uint8_t current_monitor_idx;
        
        channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    7466:	79fa      	ldrb	r2, [r7, #7]
    7468:	f240 035c 	movw	r3, #92	; 0x5c
    746c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7470:	ea4f 1202 	mov.w	r2, r2, lsl #4
    7474:	4413      	add	r3, r2
    7476:	791b      	ldrb	r3, [r3, #4]
    7478:	73bb      	strb	r3, [r7, #14]
        ASSERT((int32_t)channel_id < sizeof(channel_type_lut));
    747a:	7bbb      	ldrb	r3, [r7, #14]
    747c:	2b2f      	cmp	r3, #47	; 0x2f
    747e:	d900      	bls.n	7482 <ACE_convert_to_mA+0x3e>
    7480:	be00      	bkpt	0x0000
        if(CURRENT_CHANNEL == channel_type_lut[channel_id])
    7482:	7bba      	ldrb	r2, [r7, #14]
    7484:	f24b 630c 	movw	r3, #46604	; 0xb60c
    7488:	f2c0 0301 	movt	r3, #1
    748c:	5c9b      	ldrb	r3, [r3, r2]
    748e:	2b01      	cmp	r3, #1
    7490:	d12c      	bne.n	74ec <ACE_convert_to_mA+0xa8>
             *       CM2     :       0x13     :   2
             *       CM3     :       0x17     :   3
             *       CM4     :       0x23     :   4
             */
            current_monitor_idx
                = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
    7492:	7bbb      	ldrb	r3, [r7, #14]
    7494:	f003 0304 	and.w	r3, r3, #4
    7498:	ea4f 0393 	mov.w	r3, r3, lsr #2
             *       CM1     :       0x07     :   1
             *       CM2     :       0x13     :   2
             *       CM3     :       0x17     :   3
             *       CM4     :       0x23     :   4
             */
            current_monitor_idx
    749c:	b2da      	uxtb	r2, r3
                = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
    749e:	7bbb      	ldrb	r3, [r7, #14]
    74a0:	f003 0330 	and.w	r3, r3, #48	; 0x30
    74a4:	ea4f 03d3 	mov.w	r3, r3, lsr #3
             *       CM1     :       0x07     :   1
             *       CM2     :       0x13     :   2
             *       CM3     :       0x17     :   3
             *       CM4     :       0x23     :   4
             */
            current_monitor_idx
    74a8:	b2db      	uxtb	r3, r3
    74aa:	4413      	add	r3, r2
    74ac:	73fb      	strb	r3, [r7, #15]
                = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
            
            if(current_monitor_idx < (uint8_t)ACE_NB_OF_CURRENT_MONITORS)
    74ae:	7bfb      	ldrb	r3, [r7, #15]
    74b0:	2b03      	cmp	r3, #3
    74b2:	d81b      	bhi.n	74ec <ACE_convert_to_mA+0xa8>
            {
                /* Retrieve the current sensing external resistor value from 
                 * the ACE configuration data generated by the ACE configurator. */
                resistor = g_ace_current_resistors[current_monitor_idx];
    74b4:	7bfa      	ldrb	r2, [r7, #15]
    74b6:	f64a 7340 	movw	r3, #44864	; 0xaf40
    74ba:	f2c0 0301 	movt	r3, #1
    74be:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    74c2:	613b      	str	r3, [r7, #16]
                
                /* Compute mA current value taking into account the amplication
                 * factor of 50 used within the current monitor hardware. */
                voltage = (uint32_t)ACE_convert_to_mV(channel_handle, sample_value);
    74c4:	79fa      	ldrb	r2, [r7, #7]
    74c6:	88bb      	ldrh	r3, [r7, #4]
    74c8:	4610      	mov	r0, r2
    74ca:	4619      	mov	r1, r3
    74cc:	f7ff ff3a 	bl	7344 <ACE_convert_to_mV>
    74d0:	4603      	mov	r3, r0
    74d2:	617b      	str	r3, [r7, #20]
                current = (voltage * 20u) / resistor;
    74d4:	697a      	ldr	r2, [r7, #20]
    74d6:	4613      	mov	r3, r2
    74d8:	ea4f 0383 	mov.w	r3, r3, lsl #2
    74dc:	4413      	add	r3, r2
    74de:	ea4f 0383 	mov.w	r3, r3, lsl #2
    74e2:	461a      	mov	r2, r3
    74e4:	693b      	ldr	r3, [r7, #16]
    74e6:	fbb2 f3f3 	udiv	r3, r2, r3
    74ea:	60bb      	str	r3, [r7, #8]
            }
        }
    }
    

    return current;
    74ec:	68bb      	ldr	r3, [r7, #8]
}
    74ee:	4618      	mov	r0, r3
    74f0:	f107 0718 	add.w	r7, r7, #24
    74f4:	46bd      	mov	sp, r7
    74f6:	bd80      	pop	{r7, pc}

000074f8 <ACE_convert_to_uA>:
uint32_t ACE_convert_to_uA
(
    ace_channel_handle_t    channel_handle,
    uint16_t                sample_value
)
{
    74f8:	b580      	push	{r7, lr}
    74fa:	b086      	sub	sp, #24
    74fc:	af00      	add	r7, sp, #0
    74fe:	4602      	mov	r2, r0
    7500:	460b      	mov	r3, r1
    7502:	71fa      	strb	r2, [r7, #7]
    7504:	80bb      	strh	r3, [r7, #4]
    uint32_t current = 0u;
    7506:	f04f 0300 	mov.w	r3, #0
    750a:	60bb      	str	r3, [r7, #8]
    
    ASSERT((int32_t)channel_handle < ACE_NB_OF_INPUT_CHANNELS);
    750c:	79fb      	ldrb	r3, [r7, #7]
    750e:	2b02      	cmp	r3, #2
    7510:	d900      	bls.n	7514 <ACE_convert_to_uA+0x1c>
    7512:	be00      	bkpt	0x0000
    
    if((int32_t)channel_handle < ACE_NB_OF_INPUT_CHANNELS)
    7514:	79fb      	ldrb	r3, [r7, #7]
    7516:	2b02      	cmp	r3, #2
    7518:	d83f      	bhi.n	759a <ACE_convert_to_uA+0xa2>
    {
        adc_channel_id_t channel_id;
        uint8_t current_monitor_idx;
        
        channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    751a:	79fa      	ldrb	r2, [r7, #7]
    751c:	f240 035c 	movw	r3, #92	; 0x5c
    7520:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7524:	ea4f 1202 	mov.w	r2, r2, lsl #4
    7528:	4413      	add	r3, r2
    752a:	791b      	ldrb	r3, [r3, #4]
    752c:	73bb      	strb	r3, [r7, #14]
        ASSERT((int32_t)channel_id < sizeof(channel_type_lut));
    752e:	7bbb      	ldrb	r3, [r7, #14]
    7530:	2b2f      	cmp	r3, #47	; 0x2f
    7532:	d900      	bls.n	7536 <ACE_convert_to_uA+0x3e>
    7534:	be00      	bkpt	0x0000
        if(CURRENT_CHANNEL == channel_type_lut[channel_id])
    7536:	7bba      	ldrb	r2, [r7, #14]
    7538:	f24b 630c 	movw	r3, #46604	; 0xb60c
    753c:	f2c0 0301 	movt	r3, #1
    7540:	5c9b      	ldrb	r3, [r3, r2]
    7542:	2b01      	cmp	r3, #1
    7544:	d129      	bne.n	759a <ACE_convert_to_uA+0xa2>
             *       CM2     :       0x13     :   2
             *       CM3     :       0x17     :   3
             *       CM4     :       0x23     :   4
             */
            current_monitor_idx
                = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
    7546:	7bbb      	ldrb	r3, [r7, #14]
    7548:	f003 0304 	and.w	r3, r3, #4
    754c:	ea4f 0393 	mov.w	r3, r3, lsr #2
             *       CM1     :       0x07     :   1
             *       CM2     :       0x13     :   2
             *       CM3     :       0x17     :   3
             *       CM4     :       0x23     :   4
             */
            current_monitor_idx
    7550:	b2da      	uxtb	r2, r3
                = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
    7552:	7bbb      	ldrb	r3, [r7, #14]
    7554:	f003 0330 	and.w	r3, r3, #48	; 0x30
    7558:	ea4f 03d3 	mov.w	r3, r3, lsr #3
             *       CM1     :       0x07     :   1
             *       CM2     :       0x13     :   2
             *       CM3     :       0x17     :   3
             *       CM4     :       0x23     :   4
             */
            current_monitor_idx
    755c:	b2db      	uxtb	r3, r3
    755e:	4413      	add	r3, r2
    7560:	73fb      	strb	r3, [r7, #15]
                = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
            
            if(current_monitor_idx < (uint8_t)ACE_NB_OF_CURRENT_MONITORS)
    7562:	7bfb      	ldrb	r3, [r7, #15]
    7564:	2b03      	cmp	r3, #3
    7566:	d818      	bhi.n	759a <ACE_convert_to_uA+0xa2>
            {
                /* Retrieve the current sensing external resistor value from 
                 * the ACE configuration data generated by the ACE configurator. */
                resistor = g_ace_current_resistors[current_monitor_idx];
    7568:	7bfa      	ldrb	r2, [r7, #15]
    756a:	f64a 7340 	movw	r3, #44864	; 0xaf40
    756e:	f2c0 0301 	movt	r3, #1
    7572:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    7576:	613b      	str	r3, [r7, #16]
                
                /* Compute mA current value taking into account the amplication
                 * factor of 50 used within the current monitor hardware. */
                voltage = (uint32_t)ACE_convert_to_mV(channel_handle, sample_value);
    7578:	79fa      	ldrb	r2, [r7, #7]
    757a:	88bb      	ldrh	r3, [r7, #4]
    757c:	4610      	mov	r0, r2
    757e:	4619      	mov	r1, r3
    7580:	f7ff fee0 	bl	7344 <ACE_convert_to_mV>
    7584:	4603      	mov	r3, r0
    7586:	617b      	str	r3, [r7, #20]
                current = (voltage * (1000000u / 50u) ) / resistor;
    7588:	697b      	ldr	r3, [r7, #20]
    758a:	f644 6220 	movw	r2, #20000	; 0x4e20
    758e:	fb02 f203 	mul.w	r2, r2, r3
    7592:	693b      	ldr	r3, [r7, #16]
    7594:	fbb2 f3f3 	udiv	r3, r2, r3
    7598:	60bb      	str	r3, [r7, #8]
            }
        }
    }
    
    return current;
    759a:	68bb      	ldr	r3, [r7, #8]
}
    759c:	4618      	mov	r0, r3
    759e:	f107 0718 	add.w	r7, r7, #24
    75a2:	46bd      	mov	sp, r7
    75a4:	bd80      	pop	{r7, pc}
    75a6:	bf00      	nop

000075a8 <ACE_convert_to_Kelvin>:
uint32_t ACE_convert_to_Kelvin
(
    ace_channel_handle_t    channel_handle,
    uint16_t                sample_value
)
{
    75a8:	b580      	push	{r7, lr}
    75aa:	b084      	sub	sp, #16
    75ac:	af00      	add	r7, sp, #0
    75ae:	4602      	mov	r2, r0
    75b0:	460b      	mov	r3, r1
    75b2:	71fa      	strb	r2, [r7, #7]
    75b4:	80bb      	strh	r3, [r7, #4]
    uint32_t temperature;
    uint32_t voltage;
    
    voltage = (uint32_t)ACE_convert_to_mV( channel_handle, sample_value );
    75b6:	79fa      	ldrb	r2, [r7, #7]
    75b8:	88bb      	ldrh	r3, [r7, #4]
    75ba:	4610      	mov	r0, r2
    75bc:	4619      	mov	r1, r3
    75be:	f7ff fec1 	bl	7344 <ACE_convert_to_mV>
    75c2:	4603      	mov	r3, r0
    75c4:	60fb      	str	r3, [r7, #12]
    
    /* Tk = (V * 10^3) / 2.5  */
    temperature = (voltage * 10u) / 25u;
    75c6:	68fa      	ldr	r2, [r7, #12]
    75c8:	4613      	mov	r3, r2
    75ca:	ea4f 0383 	mov.w	r3, r3, lsl #2
    75ce:	4413      	add	r3, r2
    75d0:	ea4f 0343 	mov.w	r3, r3, lsl #1
    75d4:	461a      	mov	r2, r3
    75d6:	f248 531f 	movw	r3, #34079	; 0x851f
    75da:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
    75de:	fba3 1302 	umull	r1, r3, r3, r2
    75e2:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    75e6:	60bb      	str	r3, [r7, #8]
    
    return temperature;
    75e8:	68bb      	ldr	r3, [r7, #8]
}
    75ea:	4618      	mov	r0, r3
    75ec:	f107 0710 	add.w	r7, r7, #16
    75f0:	46bd      	mov	sp, r7
    75f2:	bd80      	pop	{r7, pc}

000075f4 <ACE_convert_to_Celsius>:
int32_t ACE_convert_to_Celsius
(
    ace_channel_handle_t    channel_handle,
    uint16_t                sample_value
)
{
    75f4:	b580      	push	{r7, lr}
    75f6:	b084      	sub	sp, #16
    75f8:	af00      	add	r7, sp, #0
    75fa:	4602      	mov	r2, r0
    75fc:	460b      	mov	r3, r1
    75fe:	71fa      	strb	r2, [r7, #7]
    7600:	80bb      	strh	r3, [r7, #4]
    int32_t temperature;
    int32_t voltage;
    
    voltage = (int32_t)ACE_convert_to_mV( channel_handle, sample_value );
    7602:	79fa      	ldrb	r2, [r7, #7]
    7604:	88bb      	ldrh	r3, [r7, #4]
    7606:	4610      	mov	r0, r2
    7608:	4619      	mov	r1, r3
    760a:	f7ff fe9b 	bl	7344 <ACE_convert_to_mV>
    760e:	4603      	mov	r3, r0
    7610:	60fb      	str	r3, [r7, #12]
    
    /* Tk = (V * 10^3) / 2.5  */
    /* Tc = Tk - 273.15 */
    temperature = (voltage * 4) - 2731;
    7612:	68fb      	ldr	r3, [r7, #12]
    7614:	ea4f 0383 	mov.w	r3, r3, lsl #2
    7618:	f5a3 632a 	sub.w	r3, r3, #2720	; 0xaa0
    761c:	f1a3 030b 	sub.w	r3, r3, #11
    7620:	60bb      	str	r3, [r7, #8]
    
    return temperature;
    7622:	68bb      	ldr	r3, [r7, #8]
}
    7624:	4618      	mov	r0, r3
    7626:	f107 0710 	add.w	r7, r7, #16
    762a:	46bd      	mov	sp, r7
    762c:	bd80      	pop	{r7, pc}
    762e:	bf00      	nop

00007630 <ACE_convert_to_Fahrenheit>:
int32_t ACE_convert_to_Fahrenheit
(
    ace_channel_handle_t    channel_handle,
    uint16_t                sample_value
)
{
    7630:	b580      	push	{r7, lr}
    7632:	b084      	sub	sp, #16
    7634:	af00      	add	r7, sp, #0
    7636:	4602      	mov	r2, r0
    7638:	460b      	mov	r3, r1
    763a:	71fa      	strb	r2, [r7, #7]
    763c:	80bb      	strh	r3, [r7, #4]
    int32_t temperature;
    
    temperature = (int32_t)ACE_convert_to_Kelvin( channel_handle, sample_value );
    763e:	79fa      	ldrb	r2, [r7, #7]
    7640:	88bb      	ldrh	r3, [r7, #4]
    7642:	4610      	mov	r0, r2
    7644:	4619      	mov	r1, r3
    7646:	f7ff ffaf 	bl	75a8 <ACE_convert_to_Kelvin>
    764a:	4603      	mov	r3, r0
    764c:	60fb      	str	r3, [r7, #12]
    
    /* F = (K * 9/5) - 459.67 */
    temperature = ((temperature * 9) / 5) - 459;
    764e:	68fa      	ldr	r2, [r7, #12]
    7650:	4613      	mov	r3, r2
    7652:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    7656:	441a      	add	r2, r3
    7658:	f246 6367 	movw	r3, #26215	; 0x6667
    765c:	f2c6 6366 	movt	r3, #26214	; 0x6666
    7660:	fb83 1302 	smull	r1, r3, r3, r2
    7664:	ea4f 0163 	mov.w	r1, r3, asr #1
    7668:	ea4f 73e2 	mov.w	r3, r2, asr #31
    766c:	ebc3 0301 	rsb	r3, r3, r1
    7670:	f5a3 73e4 	sub.w	r3, r3, #456	; 0x1c8
    7674:	f1a3 0303 	sub.w	r3, r3, #3
    7678:	60fb      	str	r3, [r7, #12]
    
    return temperature;
    767a:	68fb      	ldr	r3, [r7, #12]
}
    767c:	4618      	mov	r0, r3
    767e:	f107 0710 	add.w	r7, r7, #16
    7682:	46bd      	mov	sp, r7
    7684:	bd80      	pop	{r7, pc}
    7686:	bf00      	nop

00007688 <ACE_get_channel_name>:
 */
const uint8_t * ACE_get_channel_name
(
    ace_channel_handle_t    channel_handle
)
{
    7688:	b480      	push	{r7}
    768a:	b085      	sub	sp, #20
    768c:	af00      	add	r7, sp, #0
    768e:	4603      	mov	r3, r0
    7690:	71fb      	strb	r3, [r7, #7]
    const uint8_t * p_channel_name = 0;
    7692:	f04f 0300 	mov.w	r3, #0
    7696:	60fb      	str	r3, [r7, #12]
    
    if ( channel_handle < NB_OF_ACE_CHANNEL_HANDLES)
    7698:	79fb      	ldrb	r3, [r7, #7]
    769a:	2b02      	cmp	r3, #2
    769c:	d809      	bhi.n	76b2 <ACE_get_channel_name+0x2a>
    {
        p_channel_name = g_ace_channel_desc_table[channel_handle].p_sz_channel_name;
    769e:	79fa      	ldrb	r2, [r7, #7]
    76a0:	f240 035c 	movw	r3, #92	; 0x5c
    76a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    76a8:	ea4f 1202 	mov.w	r2, r2, lsl #4
    76ac:	4413      	add	r3, r2
    76ae:	681b      	ldr	r3, [r3, #0]
    76b0:	60fb      	str	r3, [r7, #12]
    }
    
    return p_channel_name;
    76b2:	68fb      	ldr	r3, [r7, #12]
}
    76b4:	4618      	mov	r0, r3
    76b6:	f107 0714 	add.w	r7, r7, #20
    76ba:	46bd      	mov	sp, r7
    76bc:	bc80      	pop	{r7}
    76be:	4770      	bx	lr

000076c0 <ACE_convert_mV_to_adc_value>:
uint16_t ACE_convert_mV_to_adc_value
(
    ace_channel_handle_t    channel_handle,
    uint32_t                voltage
)
{
    76c0:	b480      	push	{r7}
    76c2:	b087      	sub	sp, #28
    76c4:	af00      	add	r7, sp, #0
    76c6:	4603      	mov	r3, r0
    76c8:	6039      	str	r1, [r7, #0]
    76ca:	71fb      	strb	r3, [r7, #7]
    uint16_t sample_value;
    adc_channel_id_t channel_id;
    uint8_t adc_id;
    
    channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    76cc:	79fa      	ldrb	r2, [r7, #7]
    76ce:	f240 035c 	movw	r3, #92	; 0x5c
    76d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    76d6:	ea4f 1202 	mov.w	r2, r2, lsl #4
    76da:	4413      	add	r3, r2
    76dc:	791b      	ldrb	r3, [r3, #4]
    76de:	73bb      	strb	r3, [r7, #14]
    adc_id = (uint8_t)channel_id >> 4u;
    76e0:	7bbb      	ldrb	r3, [r7, #14]
    76e2:	ea4f 1313 	mov.w	r3, r3, lsr #4
    76e6:	73fb      	strb	r3, [r7, #15]
    
    if (voltage > g_ace_adc_config[adc_id].va_ref)
    76e8:	7bfb      	ldrb	r3, [r7, #15]
    76ea:	f240 0254 	movw	r2, #84	; 0x54
    76ee:	f2c2 0200 	movt	r2, #8192	; 0x2000
    76f2:	ea4f 0383 	mov.w	r3, r3, lsl #2
    76f6:	4413      	add	r3, r2
    76f8:	885b      	ldrh	r3, [r3, #2]
    76fa:	461a      	mov	r2, r3
    76fc:	683b      	ldr	r3, [r7, #0]
    76fe:	429a      	cmp	r2, r3
    7700:	d20a      	bcs.n	7718 <ACE_convert_mV_to_adc_value+0x58>
    {
        sample_value = g_ace_adc_config[adc_id].adc_resolution - 1u;
    7702:	7bfa      	ldrb	r2, [r7, #15]
    7704:	f240 0354 	movw	r3, #84	; 0x54
    7708:	f2c2 0300 	movt	r3, #8192	; 0x2000
    770c:	f833 3022 	ldrh.w	r3, [r3, r2, lsl #2]
    7710:	f103 33ff 	add.w	r3, r3, #4294967295
    7714:	81bb      	strh	r3, [r7, #12]
    7716:	e01b      	b.n	7750 <ACE_convert_mV_to_adc_value+0x90>
    else
    {
        uint32_t va_ref;
        uint32_t adc_resolution;
        
        va_ref = g_ace_adc_config[adc_id].va_ref;
    7718:	7bfb      	ldrb	r3, [r7, #15]
    771a:	f240 0254 	movw	r2, #84	; 0x54
    771e:	f2c2 0200 	movt	r2, #8192	; 0x2000
    7722:	ea4f 0383 	mov.w	r3, r3, lsl #2
    7726:	4413      	add	r3, r2
    7728:	885b      	ldrh	r3, [r3, #2]
    772a:	613b      	str	r3, [r7, #16]
        adc_resolution = g_ace_adc_config[adc_id].adc_resolution;
    772c:	7bfa      	ldrb	r2, [r7, #15]
    772e:	f240 0354 	movw	r3, #84	; 0x54
    7732:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7736:	f833 3022 	ldrh.w	r3, [r3, r2, lsl #2]
    773a:	617b      	str	r3, [r7, #20]
        
        sample_value = (uint16_t)((voltage * (adc_resolution - 1u)) / va_ref);
    773c:	697b      	ldr	r3, [r7, #20]
    773e:	f103 33ff 	add.w	r3, r3, #4294967295
    7742:	683a      	ldr	r2, [r7, #0]
    7744:	fb02 f203 	mul.w	r2, r2, r3
    7748:	693b      	ldr	r3, [r7, #16]
    774a:	fbb2 f3f3 	udiv	r3, r2, r3
    774e:	81bb      	strh	r3, [r7, #12]
    }
    
    return sample_value;
    7750:	89bb      	ldrh	r3, [r7, #12]
}
    7752:	4618      	mov	r0, r3
    7754:	f107 071c 	add.w	r7, r7, #28
    7758:	46bd      	mov	sp, r7
    775a:	bc80      	pop	{r7}
    775c:	4770      	bx	lr
    775e:	bf00      	nop

00007760 <convert_mV_to_ppe_value>:
static uint16_t convert_mV_to_ppe_value
(
    ace_channel_handle_t    channel_handle,
    uint32_t                voltage
)
{
    7760:	b480      	push	{r7}
    7762:	b085      	sub	sp, #20
    7764:	af00      	add	r7, sp, #0
    7766:	4603      	mov	r3, r0
    7768:	6039      	str	r1, [r7, #0]
    776a:	71fb      	strb	r3, [r7, #7]
    uint16_t sample_value;
    adc_channel_id_t channel_id;
    uint8_t adc_id;
    
    channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    776c:	79fa      	ldrb	r2, [r7, #7]
    776e:	f240 035c 	movw	r3, #92	; 0x5c
    7772:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7776:	ea4f 1202 	mov.w	r2, r2, lsl #4
    777a:	4413      	add	r3, r2
    777c:	791b      	ldrb	r3, [r3, #4]
    777e:	73bb      	strb	r3, [r7, #14]
    adc_id = (uint8_t)channel_id >> 4u;
    7780:	7bbb      	ldrb	r3, [r7, #14]
    7782:	ea4f 1313 	mov.w	r3, r3, lsr #4
    7786:	73fb      	strb	r3, [r7, #15]
    
    if (voltage > g_ace_adc_config[adc_id].va_ref)
    7788:	7bfb      	ldrb	r3, [r7, #15]
    778a:	f240 0254 	movw	r2, #84	; 0x54
    778e:	f2c2 0200 	movt	r2, #8192	; 0x2000
    7792:	ea4f 0383 	mov.w	r3, r3, lsl #2
    7796:	4413      	add	r3, r2
    7798:	885b      	ldrh	r3, [r3, #2]
    779a:	461a      	mov	r2, r3
    779c:	683b      	ldr	r3, [r7, #0]
    779e:	429a      	cmp	r2, r3
    77a0:	d203      	bcs.n	77aa <convert_mV_to_ppe_value+0x4a>
    {
        sample_value = PPE_SAMPLES_RESOLUTION;
    77a2:	f640 73ff 	movw	r3, #4095	; 0xfff
    77a6:	81bb      	strh	r3, [r7, #12]
    77a8:	e011      	b.n	77ce <convert_mV_to_ppe_value+0x6e>
    }
    else
    {
        sample_value = (uint16_t)((voltage * PPE_SAMPLES_RESOLUTION) / g_ace_adc_config[adc_id].va_ref);
    77aa:	683a      	ldr	r2, [r7, #0]
    77ac:	4613      	mov	r3, r2
    77ae:	ea4f 3303 	mov.w	r3, r3, lsl #12
    77b2:	ebc2 0103 	rsb	r1, r2, r3
    77b6:	7bfb      	ldrb	r3, [r7, #15]
    77b8:	f240 0254 	movw	r2, #84	; 0x54
    77bc:	f2c2 0200 	movt	r2, #8192	; 0x2000
    77c0:	ea4f 0383 	mov.w	r3, r3, lsl #2
    77c4:	4413      	add	r3, r2
    77c6:	885b      	ldrh	r3, [r3, #2]
    77c8:	fbb1 f3f3 	udiv	r3, r1, r3
    77cc:	81bb      	strh	r3, [r7, #12]
    }
    
    return sample_value;
    77ce:	89bb      	ldrh	r3, [r7, #12]
}
    77d0:	4618      	mov	r0, r3
    77d2:	f107 0714 	add.w	r7, r7, #20
    77d6:	46bd      	mov	sp, r7
    77d8:	bc80      	pop	{r7}
    77da:	4770      	bx	lr

000077dc <ACE_convert_from_mV>:
uint16_t ACE_convert_from_mV
(
    ace_channel_handle_t    channel_handle,
    int32_t                 voltage
)
{
    77dc:	b480      	push	{r7}
    77de:	b08b      	sub	sp, #44	; 0x2c
    77e0:	af00      	add	r7, sp, #0
    77e2:	4603      	mov	r3, r0
    77e4:	6039      	str	r1, [r7, #0]
    77e6:	71fb      	strb	r3, [r7, #7]
    uint16_t sample_value;
    adc_channel_id_t channel_id;
    uint8_t adc_id;
    uint32_t adc_voltage;
    
    channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    77e8:	79fa      	ldrb	r2, [r7, #7]
    77ea:	f240 035c 	movw	r3, #92	; 0x5c
    77ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    77f2:	ea4f 1202 	mov.w	r2, r2, lsl #4
    77f6:	4413      	add	r3, r2
    77f8:	791b      	ldrb	r3, [r3, #4]
    77fa:	72bb      	strb	r3, [r7, #10]
    adc_id = (uint8_t)channel_id >> 4u;
    77fc:	7abb      	ldrb	r3, [r7, #10]
    77fe:	ea4f 1313 	mov.w	r3, r3, lsr #4
    7802:	72fb      	strb	r3, [r7, #11]
    
    if ( abps_channel_lut[channel_id] == NON_ABPS_CHANNEL )
    7804:	7aba      	ldrb	r2, [r7, #10]
    7806:	f24b 636c 	movw	r3, #46700	; 0xb66c
    780a:	f2c0 0301 	movt	r3, #1
    780e:	5c9b      	ldrb	r3, [r3, r2]
    7810:	2bff      	cmp	r3, #255	; 0xff
    7812:	d11b      	bne.n	784c <ACE_convert_from_mV+0x70>
    {
        if (voltage > 0)
    7814:	683b      	ldr	r3, [r7, #0]
    7816:	2b00      	cmp	r3, #0
    7818:	dd02      	ble.n	7820 <ACE_convert_from_mV+0x44>
        {
            adc_voltage = (uint32_t)voltage;
    781a:	683b      	ldr	r3, [r7, #0]
    781c:	60fb      	str	r3, [r7, #12]
    781e:	e002      	b.n	7826 <ACE_convert_from_mV+0x4a>
        }
        else
        {
            adc_voltage = 0u;
    7820:	f04f 0300 	mov.w	r3, #0
    7824:	60fb      	str	r3, [r7, #12]
        }
        sample_value = (uint16_t)((adc_voltage * PPE_SAMPLES_RESOLUTION) / g_ace_adc_config[adc_id].va_ref);
    7826:	68fa      	ldr	r2, [r7, #12]
    7828:	4613      	mov	r3, r2
    782a:	ea4f 3303 	mov.w	r3, r3, lsl #12
    782e:	ebc2 0103 	rsb	r1, r2, r3
    7832:	7afb      	ldrb	r3, [r7, #11]
    7834:	f240 0254 	movw	r2, #84	; 0x54
    7838:	f2c2 0200 	movt	r2, #8192	; 0x2000
    783c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    7840:	4413      	add	r3, r2
    7842:	885b      	ldrh	r3, [r3, #2]
    7844:	fbb1 f3f3 	udiv	r3, r1, r3
    7848:	813b      	strh	r3, [r7, #8]
    784a:	e03f      	b.n	78cc <ACE_convert_from_mV+0xf0>
        int32_t actual_afe_voltage;
        uint32_t gain;
        uint32_t va_ref;
        uint32_t ppe_resolution;
        
        apbs_idx = abps_idx_lut[channel_id];
    784c:	7aba      	ldrb	r2, [r7, #10]
    784e:	f24b 639c 	movw	r3, #46748	; 0xb69c
    7852:	f2c0 0301 	movt	r3, #1
    7856:	5c9b      	ldrb	r3, [r3, r2]
    7858:	74bb      	strb	r3, [r7, #18]
        gdec = g_gdec_lut[apbs_idx];
    785a:	7cba      	ldrb	r2, [r7, #18]
    785c:	f642 7360 	movw	r3, #12128	; 0x2f60
    7860:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7864:	5c9b      	ldrb	r3, [r3, r2]
    7866:	74fb      	strb	r3, [r7, #19]

        ppe_resolution = (uint32_t)PPE_SAMPLES_RESOLUTION;
    7868:	f640 73ff 	movw	r3, #4095	; 0xfff
    786c:	627b      	str	r3, [r7, #36]	; 0x24
        gain = (uint32_t)apbs_gain_lut[gdec];
    786e:	7cfa      	ldrb	r2, [r7, #19]
    7870:	f24b 63cc 	movw	r3, #46796	; 0xb6cc
    7874:	f2c0 0301 	movt	r3, #1
    7878:	5c9b      	ldrb	r3, [r3, r2]
    787a:	61fb      	str	r3, [r7, #28]
        range = (int32_t)apbs_range[gdec];
    787c:	7cfa      	ldrb	r2, [r7, #19]
    787e:	f24b 63d0 	movw	r3, #46800	; 0xb6d0
    7882:	f2c0 0301 	movt	r3, #1
    7886:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    788a:	b21b      	sxth	r3, r3
    788c:	617b      	str	r3, [r7, #20]
        va_ref = (uint32_t)g_ace_adc_config[adc_id].va_ref;
    788e:	7afb      	ldrb	r3, [r7, #11]
    7890:	f240 0254 	movw	r2, #84	; 0x54
    7894:	f2c2 0200 	movt	r2, #8192	; 0x2000
    7898:	ea4f 0383 	mov.w	r3, r3, lsl #2
    789c:	4413      	add	r3, r2
    789e:	885b      	ldrh	r3, [r3, #2]
    78a0:	623b      	str	r3, [r7, #32]
        
        actual_afe_voltage = range - voltage;
    78a2:	697a      	ldr	r2, [r7, #20]
    78a4:	683b      	ldr	r3, [r7, #0]
    78a6:	ebc3 0302 	rsb	r3, r3, r2
    78aa:	61bb      	str	r3, [r7, #24]
        sample_value = (uint16_t)(ppe_resolution - ((((ppe_resolution * (uint32_t)actual_afe_voltage) / gain) / va_ref)));
    78ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    78ae:	b29a      	uxth	r2, r3
    78b0:	69bb      	ldr	r3, [r7, #24]
    78b2:	6a79      	ldr	r1, [r7, #36]	; 0x24
    78b4:	fb01 f103 	mul.w	r1, r1, r3
    78b8:	69fb      	ldr	r3, [r7, #28]
    78ba:	fbb1 f1f3 	udiv	r1, r1, r3
    78be:	6a3b      	ldr	r3, [r7, #32]
    78c0:	fbb1 f3f3 	udiv	r3, r1, r3
    78c4:	b29b      	uxth	r3, r3
    78c6:	ebc3 0302 	rsb	r3, r3, r2
    78ca:	813b      	strh	r3, [r7, #8]
    }
        
    if (sample_value > MAX_PPE_SAMPLE_VALUE)
    78cc:	893a      	ldrh	r2, [r7, #8]
    78ce:	f640 73ff 	movw	r3, #4095	; 0xfff
    78d2:	429a      	cmp	r2, r3
    78d4:	d902      	bls.n	78dc <ACE_convert_from_mV+0x100>
    {
        sample_value = MAX_PPE_SAMPLE_VALUE;
    78d6:	f640 73ff 	movw	r3, #4095	; 0xfff
    78da:	813b      	strh	r3, [r7, #8]
    }
    
    return sample_value;
    78dc:	893b      	ldrh	r3, [r7, #8]
}
    78de:	4618      	mov	r0, r3
    78e0:	f107 072c 	add.w	r7, r7, #44	; 0x2c
    78e4:	46bd      	mov	sp, r7
    78e6:	bc80      	pop	{r7}
    78e8:	4770      	bx	lr
    78ea:	bf00      	nop

000078ec <ACE_convert_from_mA>:
uint16_t ACE_convert_from_mA
(
    ace_channel_handle_t    channel_handle,
    uint32_t                current
)
{
    78ec:	b580      	push	{r7, lr}
    78ee:	b086      	sub	sp, #24
    78f0:	af00      	add	r7, sp, #0
    78f2:	4603      	mov	r3, r0
    78f4:	6039      	str	r1, [r7, #0]
    78f6:	71fb      	strb	r3, [r7, #7]
    uint16_t sample_value = 0u;
    78f8:	f04f 0300 	mov.w	r3, #0
    78fc:	817b      	strh	r3, [r7, #10]
    uint32_t voltage;
    uint32_t resistor = 1u;
    78fe:	f04f 0301 	mov.w	r3, #1
    7902:	613b      	str	r3, [r7, #16]
    adc_channel_id_t channel_id;
    
    ASSERT((int32_t)channel_handle < ACE_NB_OF_INPUT_CHANNELS);
    7904:	79fb      	ldrb	r3, [r7, #7]
    7906:	2b02      	cmp	r3, #2
    7908:	d900      	bls.n	790c <ACE_convert_from_mA+0x20>
    790a:	be00      	bkpt	0x0000
    
    channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    790c:	79fa      	ldrb	r2, [r7, #7]
    790e:	f240 035c 	movw	r3, #92	; 0x5c
    7912:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7916:	ea4f 1202 	mov.w	r2, r2, lsl #4
    791a:	4413      	add	r3, r2
    791c:	791b      	ldrb	r3, [r3, #4]
    791e:	75bb      	strb	r3, [r7, #22]
    ASSERT((int32_t)channel_id < sizeof(channel_type_lut));
    7920:	7dbb      	ldrb	r3, [r7, #22]
    7922:	2b2f      	cmp	r3, #47	; 0x2f
    7924:	d900      	bls.n	7928 <ACE_convert_from_mA+0x3c>
    7926:	be00      	bkpt	0x0000
    
    if(CURRENT_CHANNEL == channel_type_lut[channel_id])
    7928:	7dba      	ldrb	r2, [r7, #22]
    792a:	f24b 630c 	movw	r3, #46604	; 0xb60c
    792e:	f2c0 0301 	movt	r3, #1
    7932:	5c9b      	ldrb	r3, [r3, r2]
    7934:	2b01      	cmp	r3, #1
    7936:	d134      	bne.n	79a2 <ACE_convert_from_mA+0xb6>
    {
        uint8_t current_monitor_idx;
        
        current_monitor_idx
            = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
    7938:	7dbb      	ldrb	r3, [r7, #22]
    793a:	f003 0304 	and.w	r3, r3, #4
    793e:	ea4f 0393 	mov.w	r3, r3, lsr #2
    
    if(CURRENT_CHANNEL == channel_type_lut[channel_id])
    {
        uint8_t current_monitor_idx;
        
        current_monitor_idx
    7942:	b2da      	uxtb	r2, r3
            = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
    7944:	7dbb      	ldrb	r3, [r7, #22]
    7946:	f003 0330 	and.w	r3, r3, #48	; 0x30
    794a:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    
    if(CURRENT_CHANNEL == channel_type_lut[channel_id])
    {
        uint8_t current_monitor_idx;
        
        current_monitor_idx
    794e:	b2db      	uxtb	r3, r3
    7950:	4413      	add	r3, r2
    7952:	75fb      	strb	r3, [r7, #23]
            = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
    
        if(current_monitor_idx < (uint8_t)ACE_NB_OF_CURRENT_MONITORS)
    7954:	7dfb      	ldrb	r3, [r7, #23]
    7956:	2b03      	cmp	r3, #3
    7958:	d823      	bhi.n	79a2 <ACE_convert_from_mA+0xb6>
        {
            resistor = g_ace_current_resistors[current_monitor_idx];
    795a:	7dfa      	ldrb	r2, [r7, #23]
    795c:	f64a 7340 	movw	r3, #44864	; 0xaf40
    7960:	f2c0 0301 	movt	r3, #1
    7964:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    7968:	613b      	str	r3, [r7, #16]
            /* 
             * Keep in mind the multiply by 50 gain within the current monitor.
             * Therefore the voltage seen on the ADC input is:
             *      V = (I * 50 * R) / 1000.
             */
            voltage = (current * resistor) / 20u;
    796a:	683b      	ldr	r3, [r7, #0]
    796c:	693a      	ldr	r2, [r7, #16]
    796e:	fb02 f203 	mul.w	r2, r2, r3
    7972:	f64c 43cd 	movw	r3, #52429	; 0xcccd
    7976:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
    797a:	fba3 1302 	umull	r1, r3, r3, r2
    797e:	ea4f 1313 	mov.w	r3, r3, lsr #4
    7982:	60fb      	str	r3, [r7, #12]
            sample_value = convert_mV_to_ppe_value( channel_handle, voltage );
    7984:	79fb      	ldrb	r3, [r7, #7]
    7986:	4618      	mov	r0, r3
    7988:	68f9      	ldr	r1, [r7, #12]
    798a:	f7ff fee9 	bl	7760 <convert_mV_to_ppe_value>
    798e:	4603      	mov	r3, r0
    7990:	817b      	strh	r3, [r7, #10]
            
            if (sample_value > MAX_PPE_SAMPLE_VALUE)
    7992:	897a      	ldrh	r2, [r7, #10]
    7994:	f640 73ff 	movw	r3, #4095	; 0xfff
    7998:	429a      	cmp	r2, r3
    799a:	d902      	bls.n	79a2 <ACE_convert_from_mA+0xb6>
            {
                sample_value = MAX_PPE_SAMPLE_VALUE;
    799c:	f640 73ff 	movw	r3, #4095	; 0xfff
    79a0:	817b      	strh	r3, [r7, #10]
            }
        }
    }
    return sample_value;
    79a2:	897b      	ldrh	r3, [r7, #10]
}
    79a4:	4618      	mov	r0, r3
    79a6:	f107 0718 	add.w	r7, r7, #24
    79aa:	46bd      	mov	sp, r7
    79ac:	bd80      	pop	{r7, pc}
    79ae:	bf00      	nop

000079b0 <ACE_convert_from_uA>:
uint16_t ACE_convert_from_uA
(
    ace_channel_handle_t    channel_handle,
    uint32_t                current
)
{
    79b0:	b580      	push	{r7, lr}
    79b2:	b086      	sub	sp, #24
    79b4:	af00      	add	r7, sp, #0
    79b6:	4603      	mov	r3, r0
    79b8:	6039      	str	r1, [r7, #0]
    79ba:	71fb      	strb	r3, [r7, #7]
    uint16_t sample_value = 0u;
    79bc:	f04f 0300 	mov.w	r3, #0
    79c0:	817b      	strh	r3, [r7, #10]
    uint32_t voltage;
    uint32_t resistor = 1u;
    79c2:	f04f 0301 	mov.w	r3, #1
    79c6:	613b      	str	r3, [r7, #16]
    adc_channel_id_t channel_id;
    
    ASSERT((int32_t)channel_handle < ACE_NB_OF_INPUT_CHANNELS);
    79c8:	79fb      	ldrb	r3, [r7, #7]
    79ca:	2b02      	cmp	r3, #2
    79cc:	d900      	bls.n	79d0 <ACE_convert_from_uA+0x20>
    79ce:	be00      	bkpt	0x0000
    
    channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    79d0:	79fa      	ldrb	r2, [r7, #7]
    79d2:	f240 035c 	movw	r3, #92	; 0x5c
    79d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    79da:	ea4f 1202 	mov.w	r2, r2, lsl #4
    79de:	4413      	add	r3, r2
    79e0:	791b      	ldrb	r3, [r3, #4]
    79e2:	75bb      	strb	r3, [r7, #22]
    ASSERT((int32_t)channel_id < sizeof(channel_type_lut));
    79e4:	7dbb      	ldrb	r3, [r7, #22]
    79e6:	2b2f      	cmp	r3, #47	; 0x2f
    79e8:	d900      	bls.n	79ec <ACE_convert_from_uA+0x3c>
    79ea:	be00      	bkpt	0x0000
    
    if(CURRENT_CHANNEL == channel_type_lut[channel_id])
    79ec:	7dba      	ldrb	r2, [r7, #22]
    79ee:	f24b 630c 	movw	r3, #46604	; 0xb60c
    79f2:	f2c0 0301 	movt	r3, #1
    79f6:	5c9b      	ldrb	r3, [r3, r2]
    79f8:	2b01      	cmp	r3, #1
    79fa:	d134      	bne.n	7a66 <ACE_convert_from_uA+0xb6>
    {
        uint8_t current_monitor_idx;
        
        current_monitor_idx
            = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
    79fc:	7dbb      	ldrb	r3, [r7, #22]
    79fe:	f003 0304 	and.w	r3, r3, #4
    7a02:	ea4f 0393 	mov.w	r3, r3, lsr #2
    
    if(CURRENT_CHANNEL == channel_type_lut[channel_id])
    {
        uint8_t current_monitor_idx;
        
        current_monitor_idx
    7a06:	b2da      	uxtb	r2, r3
            = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
    7a08:	7dbb      	ldrb	r3, [r7, #22]
    7a0a:	f003 0330 	and.w	r3, r3, #48	; 0x30
    7a0e:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    
    if(CURRENT_CHANNEL == channel_type_lut[channel_id])
    {
        uint8_t current_monitor_idx;
        
        current_monitor_idx
    7a12:	b2db      	uxtb	r3, r3
    7a14:	4413      	add	r3, r2
    7a16:	75fb      	strb	r3, [r7, #23]
            = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
    
        if(current_monitor_idx < (uint8_t)ACE_NB_OF_CURRENT_MONITORS)
    7a18:	7dfb      	ldrb	r3, [r7, #23]
    7a1a:	2b03      	cmp	r3, #3
    7a1c:	d823      	bhi.n	7a66 <ACE_convert_from_uA+0xb6>
        {
            resistor = g_ace_current_resistors[current_monitor_idx];
    7a1e:	7dfa      	ldrb	r2, [r7, #23]
    7a20:	f64a 7340 	movw	r3, #44864	; 0xaf40
    7a24:	f2c0 0301 	movt	r3, #1
    7a28:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    7a2c:	613b      	str	r3, [r7, #16]
            voltage = (current * resistor) / 20000u;
    7a2e:	683b      	ldr	r3, [r7, #0]
    7a30:	693a      	ldr	r2, [r7, #16]
    7a32:	fb02 f203 	mul.w	r2, r2, r3
    7a36:	f241 7359 	movw	r3, #5977	; 0x1759
    7a3a:	f2cd 13b7 	movt	r3, #53687	; 0xd1b7
    7a3e:	fba3 1302 	umull	r1, r3, r3, r2
    7a42:	ea4f 3393 	mov.w	r3, r3, lsr #14
    7a46:	60fb      	str	r3, [r7, #12]
            sample_value = convert_mV_to_ppe_value( channel_handle, voltage );
    7a48:	79fb      	ldrb	r3, [r7, #7]
    7a4a:	4618      	mov	r0, r3
    7a4c:	68f9      	ldr	r1, [r7, #12]
    7a4e:	f7ff fe87 	bl	7760 <convert_mV_to_ppe_value>
    7a52:	4603      	mov	r3, r0
    7a54:	817b      	strh	r3, [r7, #10]
            
            if (sample_value > MAX_PPE_SAMPLE_VALUE)
    7a56:	897a      	ldrh	r2, [r7, #10]
    7a58:	f640 73ff 	movw	r3, #4095	; 0xfff
    7a5c:	429a      	cmp	r2, r3
    7a5e:	d902      	bls.n	7a66 <ACE_convert_from_uA+0xb6>
            {
                sample_value = MAX_PPE_SAMPLE_VALUE;
    7a60:	f640 73ff 	movw	r3, #4095	; 0xfff
    7a64:	817b      	strh	r3, [r7, #10]
            }
        }
    }
    return sample_value;
    7a66:	897b      	ldrh	r3, [r7, #10]
}
    7a68:	4618      	mov	r0, r3
    7a6a:	f107 0718 	add.w	r7, r7, #24
    7a6e:	46bd      	mov	sp, r7
    7a70:	bd80      	pop	{r7, pc}
    7a72:	bf00      	nop

00007a74 <ACE_convert_from_Kelvin>:
uint16_t ACE_convert_from_Kelvin
(
    ace_channel_handle_t    channel_handle,
    uint32_t                temperature
)
{
    7a74:	b580      	push	{r7, lr}
    7a76:	b084      	sub	sp, #16
    7a78:	af00      	add	r7, sp, #0
    7a7a:	4603      	mov	r3, r0
    7a7c:	6039      	str	r1, [r7, #0]
    7a7e:	71fb      	strb	r3, [r7, #7]
    uint16_t sample_value;
    uint32_t voltage;
    
    voltage = (temperature * 25u) / 10u;
    7a80:	683a      	ldr	r2, [r7, #0]
    7a82:	4613      	mov	r3, r2
    7a84:	ea4f 0383 	mov.w	r3, r3, lsl #2
    7a88:	4413      	add	r3, r2
    7a8a:	ea4f 0283 	mov.w	r2, r3, lsl #2
    7a8e:	441a      	add	r2, r3
    7a90:	f64c 43cd 	movw	r3, #52429	; 0xcccd
    7a94:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
    7a98:	fba3 1302 	umull	r1, r3, r3, r2
    7a9c:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    7aa0:	60fb      	str	r3, [r7, #12]
    sample_value = convert_mV_to_ppe_value( channel_handle, voltage );
    7aa2:	79fb      	ldrb	r3, [r7, #7]
    7aa4:	4618      	mov	r0, r3
    7aa6:	68f9      	ldr	r1, [r7, #12]
    7aa8:	f7ff fe5a 	bl	7760 <convert_mV_to_ppe_value>
    7aac:	4603      	mov	r3, r0
    7aae:	817b      	strh	r3, [r7, #10]
    
    if (sample_value > MAX_PPE_SAMPLE_VALUE)
    7ab0:	897a      	ldrh	r2, [r7, #10]
    7ab2:	f640 73ff 	movw	r3, #4095	; 0xfff
    7ab6:	429a      	cmp	r2, r3
    7ab8:	d902      	bls.n	7ac0 <ACE_convert_from_Kelvin+0x4c>
    {
        sample_value = MAX_PPE_SAMPLE_VALUE;
    7aba:	f640 73ff 	movw	r3, #4095	; 0xfff
    7abe:	817b      	strh	r3, [r7, #10]
    }
    return sample_value;
    7ac0:	897b      	ldrh	r3, [r7, #10]
}
    7ac2:	4618      	mov	r0, r3
    7ac4:	f107 0710 	add.w	r7, r7, #16
    7ac8:	46bd      	mov	sp, r7
    7aca:	bd80      	pop	{r7, pc}

00007acc <ACE_convert_from_Celsius>:
uint16_t ACE_convert_from_Celsius
(
    ace_channel_handle_t    channel_handle,
    int32_t                 temperature
)
{
    7acc:	b580      	push	{r7, lr}
    7ace:	b084      	sub	sp, #16
    7ad0:	af00      	add	r7, sp, #0
    7ad2:	4603      	mov	r3, r0
    7ad4:	6039      	str	r1, [r7, #0]
    7ad6:	71fb      	strb	r3, [r7, #7]
    uint16_t sample_value;
    uint32_t voltage;
    
    temperature = temperature + 2731;
    7ad8:	683b      	ldr	r3, [r7, #0]
    7ada:	f503 632a 	add.w	r3, r3, #2720	; 0xaa0
    7ade:	f103 030b 	add.w	r3, r3, #11
    7ae2:	603b      	str	r3, [r7, #0]
    voltage = (uint32_t)temperature / 4u;
    7ae4:	683b      	ldr	r3, [r7, #0]
    7ae6:	ea4f 0393 	mov.w	r3, r3, lsr #2
    7aea:	60fb      	str	r3, [r7, #12]
    sample_value = convert_mV_to_ppe_value( channel_handle, voltage );
    7aec:	79fb      	ldrb	r3, [r7, #7]
    7aee:	4618      	mov	r0, r3
    7af0:	68f9      	ldr	r1, [r7, #12]
    7af2:	f7ff fe35 	bl	7760 <convert_mV_to_ppe_value>
    7af6:	4603      	mov	r3, r0
    7af8:	817b      	strh	r3, [r7, #10]
    
    if (sample_value > MAX_PPE_SAMPLE_VALUE)
    7afa:	897a      	ldrh	r2, [r7, #10]
    7afc:	f640 73ff 	movw	r3, #4095	; 0xfff
    7b00:	429a      	cmp	r2, r3
    7b02:	d902      	bls.n	7b0a <ACE_convert_from_Celsius+0x3e>
    {
        sample_value = MAX_PPE_SAMPLE_VALUE;
    7b04:	f640 73ff 	movw	r3, #4095	; 0xfff
    7b08:	817b      	strh	r3, [r7, #10]
    }
    return sample_value;
    7b0a:	897b      	ldrh	r3, [r7, #10]
}
    7b0c:	4618      	mov	r0, r3
    7b0e:	f107 0710 	add.w	r7, r7, #16
    7b12:	46bd      	mov	sp, r7
    7b14:	bd80      	pop	{r7, pc}
    7b16:	bf00      	nop

00007b18 <ACE_convert_from_Fahrenheit>:
uint16_t ACE_convert_from_Fahrenheit
(
    ace_channel_handle_t    channel_handle,
    int32_t                 temperature
)
{
    7b18:	b580      	push	{r7, lr}
    7b1a:	b084      	sub	sp, #16
    7b1c:	af00      	add	r7, sp, #0
    7b1e:	4603      	mov	r3, r0
    7b20:	6039      	str	r1, [r7, #0]
    7b22:	71fb      	strb	r3, [r7, #7]
    uint16_t sample_value;
    uint32_t kelvin;
    
    temperature = temperature + 459;
    7b24:	683b      	ldr	r3, [r7, #0]
    7b26:	f503 73e4 	add.w	r3, r3, #456	; 0x1c8
    7b2a:	f103 0303 	add.w	r3, r3, #3
    7b2e:	603b      	str	r3, [r7, #0]
    kelvin = (uint32_t)temperature;
    7b30:	683b      	ldr	r3, [r7, #0]
    7b32:	60fb      	str	r3, [r7, #12]
    kelvin = (kelvin * 5u) / 9u;
    7b34:	68fa      	ldr	r2, [r7, #12]
    7b36:	4613      	mov	r3, r2
    7b38:	ea4f 0383 	mov.w	r3, r3, lsl #2
    7b3c:	441a      	add	r2, r3
    7b3e:	f648 6339 	movw	r3, #36409	; 0x8e39
    7b42:	f6c3 03e3 	movt	r3, #14563	; 0x38e3
    7b46:	fba3 1302 	umull	r1, r3, r3, r2
    7b4a:	ea4f 0353 	mov.w	r3, r3, lsr #1
    7b4e:	60fb      	str	r3, [r7, #12]
    
    sample_value = ACE_convert_from_Kelvin( channel_handle, kelvin );
    7b50:	79fb      	ldrb	r3, [r7, #7]
    7b52:	4618      	mov	r0, r3
    7b54:	68f9      	ldr	r1, [r7, #12]
    7b56:	f7ff ff8d 	bl	7a74 <ACE_convert_from_Kelvin>
    7b5a:	4603      	mov	r3, r0
    7b5c:	817b      	strh	r3, [r7, #10]
    
    if (sample_value > MAX_PPE_SAMPLE_VALUE)
    7b5e:	897a      	ldrh	r2, [r7, #10]
    7b60:	f640 73ff 	movw	r3, #4095	; 0xfff
    7b64:	429a      	cmp	r2, r3
    7b66:	d902      	bls.n	7b6e <ACE_convert_from_Fahrenheit+0x56>
    {
        sample_value = MAX_PPE_SAMPLE_VALUE;
    7b68:	f640 73ff 	movw	r3, #4095	; 0xfff
    7b6c:	817b      	strh	r3, [r7, #10]
    }
    return sample_value;
    7b6e:	897b      	ldrh	r3, [r7, #10]
}
    7b70:	4618      	mov	r0, r3
    7b72:	f107 0710 	add.w	r7, r7, #16
    7b76:	46bd      	mov	sp, r7
    7b78:	bd80      	pop	{r7, pc}
    7b7a:	bf00      	nop

00007b7c <ACE_translate_pdma_value>:
uint16_t ACE_translate_pdma_value
(
    uint32_t            pdma_value,
    adc_channel_id_t *  channel_id
)
{
    7b7c:	b480      	push	{r7}
    7b7e:	b085      	sub	sp, #20
    7b80:	af00      	add	r7, sp, #0
    7b82:	6078      	str	r0, [r7, #4]
    7b84:	6039      	str	r1, [r7, #0]
    uint16_t ppe_value;
      
    ppe_value = (uint16_t)((pdma_value >> 8u) & 0xFFFFu);
    7b86:	687b      	ldr	r3, [r7, #4]
    7b88:	ea4f 2313 	mov.w	r3, r3, lsr #8
    7b8c:	81fb      	strh	r3, [r7, #14]
    if ( channel_id != 0 )
    7b8e:	683b      	ldr	r3, [r7, #0]
    7b90:	2b00      	cmp	r3, #0
    7b92:	d005      	beq.n	7ba0 <ACE_translate_pdma_value+0x24>
    {
        *channel_id = (adc_channel_id_t)((pdma_value >> 24u) & 0xFFu);
    7b94:	687b      	ldr	r3, [r7, #4]
    7b96:	ea4f 6313 	mov.w	r3, r3, lsr #24
    7b9a:	b2da      	uxtb	r2, r3
    7b9c:	683b      	ldr	r3, [r7, #0]
    7b9e:	701a      	strb	r2, [r3, #0]
    }
    
    return ppe_value;
    7ba0:	89fb      	ldrh	r3, [r7, #14]
}
    7ba2:	4618      	mov	r0, r3
    7ba4:	f107 0714 	add.w	r7, r7, #20
    7ba8:	46bd      	mov	sp, r7
    7baa:	bc80      	pop	{r7}
    7bac:	4770      	bx	lr
    7bae:	bf00      	nop

00007bb0 <NVIC_ClearPendingIRQ>:
 *
 * Clear the pending bit for the specified interrupt. 
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
    7bb0:	b480      	push	{r7}
    7bb2:	b083      	sub	sp, #12
    7bb4:	af00      	add	r7, sp, #0
    7bb6:	4603      	mov	r3, r0
    7bb8:	80fb      	strh	r3, [r7, #6]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    7bba:	f24e 1300 	movw	r3, #57600	; 0xe100
    7bbe:	f2ce 0300 	movt	r3, #57344	; 0xe000
    7bc2:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    7bc6:	ea4f 1252 	mov.w	r2, r2, lsr #5
    7bca:	88f9      	ldrh	r1, [r7, #6]
    7bcc:	f001 011f 	and.w	r1, r1, #31
    7bd0:	f04f 0001 	mov.w	r0, #1
    7bd4:	fa00 f101 	lsl.w	r1, r0, r1
    7bd8:	f102 0260 	add.w	r2, r2, #96	; 0x60
    7bdc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    7be0:	f107 070c 	add.w	r7, r7, #12
    7be4:	46bd      	mov	sp, r7
    7be6:	bc80      	pop	{r7}
    7be8:	4770      	bx	lr
    7bea:	bf00      	nop

00007bec <ace_init_flags>:
/*-------------------------------------------------------------------------*//**
  Intialise the ACE driver's internal data structures used by flag control
  functions.
 */
void ace_init_flags( void )
{
    7bec:	b480      	push	{r7}
    7bee:	af00      	add	r7, sp, #0
        }
        
        g_ppe_global_flags_isr = 0u;
    }
#endif
}
    7bf0:	46bd      	mov	sp, r7
    7bf2:	bc80      	pop	{r7}
    7bf4:	4770      	bx	lr
    7bf6:	bf00      	nop

00007bf8 <ACE_is_hysteresis_flag>:

/*-------------------------------------------------------------------------*//**
 *
 */
uint32_t ACE_is_hysteresis_flag( ace_flag_handle_t   flag_handle )
{
    7bf8:	b480      	push	{r7}
    7bfa:	b085      	sub	sp, #20
    7bfc:	af00      	add	r7, sp, #0
    7bfe:	4603      	mov	r3, r0
    7c00:	71fb      	strb	r3, [r7, #7]
    uint32_t hysteresis = 0u;
    7c02:	f04f 0300 	mov.w	r3, #0
    7c06:	60fb      	str	r3, [r7, #12]
    if ( g_ppe_flags_desc_table[flag_handle].flag_type >= DUAL_HYSTERESIS_OVER )
    {
        hysteresis = 1u;
    }
#endif
    return hysteresis;
    7c08:	68fb      	ldr	r3, [r7, #12]
}
    7c0a:	4618      	mov	r0, r3
    7c0c:	f107 0714 	add.w	r7, r7, #20
    7c10:	46bd      	mov	sp, r7
    7c12:	bc80      	pop	{r7}
    7c14:	4770      	bx	lr
    7c16:	bf00      	nop

00007c18 <ACE_is_under_flag>:
 */
uint32_t ACE_is_under_flag
(
    ace_flag_handle_t   flag_handle
)
{
    7c18:	b480      	push	{r7}
    7c1a:	b085      	sub	sp, #20
    7c1c:	af00      	add	r7, sp, #0
    7c1e:	4603      	mov	r3, r0
    7c20:	71fb      	strb	r3, [r7, #7]
    uint32_t is_under = 0;
    7c22:	f04f 0300 	mov.w	r3, #0
    7c26:	60fb      	str	r3, [r7, #12]
        {
            is_under = flag_type_lut[flag_type];
        }
    }
#endif
    return is_under;
    7c28:	68fb      	ldr	r3, [r7, #12]
}
    7c2a:	4618      	mov	r0, r3
    7c2c:	f107 0714 	add.w	r7, r7, #20
    7c30:	46bd      	mov	sp, r7
    7c32:	bc80      	pop	{r7}
    7c34:	4770      	bx	lr
    7c36:	bf00      	nop

00007c38 <ACE_set_flag_threshold>:
void ACE_set_flag_threshold
(
    ace_flag_handle_t   flag_handle,
    uint16_t            new_threshold
)
{
    7c38:	b480      	push	{r7}
    7c3a:	b083      	sub	sp, #12
    7c3c:	af00      	add	r7, sp, #0
    7c3e:	4602      	mov	r2, r0
    7c40:	460b      	mov	r3, r1
    7c42:	71fa      	strb	r2, [r7, #7]
    7c44:	80bb      	strh	r3, [r7, #4]
                ACE->PPE_RAM_DATA[ppe_offset + 1u] = (ACE->PPE_RAM_DATA[ppe_offset + 1u] & (uint32_t)~PPE_RAM_THRESHOLD_MASK) + low_threshold;
            }
        }
    }
#endif
}
    7c46:	f107 070c 	add.w	r7, r7, #12
    7c4a:	46bd      	mov	sp, r7
    7c4c:	bc80      	pop	{r7}
    7c4e:	4770      	bx	lr

00007c50 <ACE_set_flag_assertion>:
void ACE_set_flag_assertion
(
    ace_flag_handle_t   flag_handle,
    uint16_t            assertion_value
)
{
    7c50:	b480      	push	{r7}
    7c52:	b083      	sub	sp, #12
    7c54:	af00      	add	r7, sp, #0
    7c56:	4602      	mov	r2, r0
    7c58:	460b      	mov	r3, r1
    7c5a:	71fa      	strb	r2, [r7, #7]
    7c5c:	80bb      	strh	r3, [r7, #4]
            ppe_offset = g_ppe_flags_desc_table[flag_handle].threshold_ppe_offset;
        }
        ACE->PPE_RAM_DATA[ppe_offset] = (ACE->PPE_RAM_DATA[ppe_offset] & ~PPE_RAM_THRESHOLD_MASK) + assertion_value;
    }
#endif
}
    7c5e:	f107 070c 	add.w	r7, r7, #12
    7c62:	46bd      	mov	sp, r7
    7c64:	bc80      	pop	{r7}
    7c66:	4770      	bx	lr

00007c68 <ACE_set_flag_deassertion>:
void ACE_set_flag_deassertion
(
    ace_flag_handle_t   flag_handle,
    uint16_t            assertion_value
)
{
    7c68:	b480      	push	{r7}
    7c6a:	b083      	sub	sp, #12
    7c6c:	af00      	add	r7, sp, #0
    7c6e:	4602      	mov	r2, r0
    7c70:	460b      	mov	r3, r1
    7c72:	71fa      	strb	r2, [r7, #7]
    7c74:	80bb      	strh	r3, [r7, #4]
        }
        
        ACE->PPE_RAM_DATA[ppe_offset] = (ACE->PPE_RAM_DATA[ppe_offset] & ~PPE_RAM_THRESHOLD_MASK) + assertion_value;
    }
#endif
}
    7c76:	f107 070c 	add.w	r7, r7, #12
    7c7a:	46bd      	mov	sp, r7
    7c7c:	bc80      	pop	{r7}
    7c7e:	4770      	bx	lr

00007c80 <ACE_set_flag_hysteresis>:
ACE_set_flag_hysteresis
(
    ace_flag_handle_t   flag_handle,
    uint16_t            adc_hysteresis
)
{
    7c80:	b480      	push	{r7}
    7c82:	b083      	sub	sp, #12
    7c84:	af00      	add	r7, sp, #0
    7c86:	4602      	mov	r2, r0
    7c88:	460b      	mov	r3, r1
    7c8a:	71fa      	strb	r2, [r7, #7]
    7c8c:	80bb      	strh	r3, [r7, #4]
            ACE->PPE_RAM_DATA[ppe_offset] = (ACE->PPE_RAM_DATA[ppe_offset] & ~PPE_RAM_THRESHOLD_MASK) + high_threshold;
            ACE->PPE_RAM_DATA[ppe_offset + 1u] = (ACE->PPE_RAM_DATA[ppe_offset + 1u] & ~PPE_RAM_THRESHOLD_MASK) + low_threshold;
        }
    }
#endif
}
    7c8e:	f107 070c 	add.w	r7, r7, #12
    7c92:	46bd      	mov	sp, r7
    7c94:	bc80      	pop	{r7}
    7c96:	4770      	bx	lr

00007c98 <ACE_set_channel_hysteresis>:
ACE_set_channel_hysteresis
(
    ace_channel_handle_t    channel_handle,
    uint16_t                adc_hysteresis
)
{
    7c98:	b480      	push	{r7}
    7c9a:	b083      	sub	sp, #12
    7c9c:	af00      	add	r7, sp, #0
    7c9e:	4602      	mov	r2, r0
    7ca0:	460b      	mov	r3, r1
    7ca2:	71fa      	strb	r2, [r7, #7]
    7ca4:	80bb      	strh	r3, [r7, #4]
            flag_handle = (ace_flag_handle_t)g_ace_channel_desc_table[channel_handle].p_flags_array[i];
            ACE_set_flag_hysteresis( flag_handle, adc_hysteresis );
        }
    }
#endif
}
    7ca6:	f107 070c 	add.w	r7, r7, #12
    7caa:	46bd      	mov	sp, r7
    7cac:	bc80      	pop	{r7}
    7cae:	4770      	bx	lr

00007cb0 <ACE_get_flag_handle>:
ace_flag_handle_t
ACE_get_flag_handle
(
    const uint8_t * p_sz_full_flag_name
)
{
    7cb0:	b480      	push	{r7}
    7cb2:	b085      	sub	sp, #20
    7cb4:	af00      	add	r7, sp, #0
    7cb6:	6078      	str	r0, [r7, #4]
    ace_flag_handle_t flag_handle = INVALID_FLAG_HANDLE;
    7cb8:	f04f 0300 	mov.w	r3, #0
    7cbc:	73fb      	strb	r3, [r7, #15]
                break;
            }
        }
    }
#endif
    return flag_handle;
    7cbe:	7bfb      	ldrb	r3, [r7, #15]
}
    7cc0:	4618      	mov	r0, r3
    7cc2:	f107 0714 	add.w	r7, r7, #20
    7cc6:	46bd      	mov	sp, r7
    7cc8:	bc80      	pop	{r7}
    7cca:	4770      	bx	lr

00007ccc <ACE_get_flag_status>:
int32_t
ACE_get_flag_status
(
    ace_flag_handle_t   flag_handle
)
{
    7ccc:	b480      	push	{r7}
    7cce:	b085      	sub	sp, #20
    7cd0:	af00      	add	r7, sp, #0
    7cd2:	4603      	mov	r3, r0
    7cd4:	71fb      	strb	r3, [r7, #7]
    int32_t flag_state = UNKNOWN_FLAG;
    7cd6:	f04f 33ff 	mov.w	r3, #4294967295
    7cda:	60fb      	str	r3, [r7, #12]
            }
        }

    }
#endif
    return flag_state;
    7cdc:	68fb      	ldr	r3, [r7, #12]
}
    7cde:	4618      	mov	r0, r3
    7ce0:	f107 0714 	add.w	r7, r7, #20
    7ce4:	46bd      	mov	sp, r7
    7ce6:	bc80      	pop	{r7}
    7ce8:	4770      	bx	lr
    7cea:	bf00      	nop

00007cec <ACE_get_flag_name>:
const uint8_t *
ACE_get_flag_name
(
    ace_flag_handle_t flag_handle
)
{
    7cec:	b480      	push	{r7}
    7cee:	b085      	sub	sp, #20
    7cf0:	af00      	add	r7, sp, #0
    7cf2:	4603      	mov	r3, r0
    7cf4:	71fb      	strb	r3, [r7, #7]
    const uint8_t * psz_flag_name = 0;
    7cf6:	f04f 0300 	mov.w	r3, #0
    7cfa:	60fb      	str	r3, [r7, #12]
    if ( flag_handle < NB_OF_ACE_FLAG_HANDLES )
    {
        psz_flag_name = g_ppe_flags_desc_table[flag_handle].p_sz_flag_name;
    }
#endif
    return psz_flag_name;
    7cfc:	68fb      	ldr	r3, [r7, #12]
}
    7cfe:	4618      	mov	r0, r3
    7d00:	f107 0714 	add.w	r7, r7, #20
    7d04:	46bd      	mov	sp, r7
    7d06:	bc80      	pop	{r7}
    7d08:	4770      	bx	lr
    7d0a:	bf00      	nop

00007d0c <ACE_get_flag_channel>:
ace_channel_handle_t
ACE_get_flag_channel
(
    ace_flag_handle_t flag_handle
)
{
    7d0c:	b480      	push	{r7}
    7d0e:	b085      	sub	sp, #20
    7d10:	af00      	add	r7, sp, #0
    7d12:	4603      	mov	r3, r0
    7d14:	71fb      	strb	r3, [r7, #7]
    ace_channel_handle_t channel_handle = INVALID_CHANNEL_HANDLE;
    7d16:	f04f 0303 	mov.w	r3, #3
    7d1a:	73fb      	strb	r3, [r7, #15]
    if ( flag_handle < NB_OF_ACE_FLAG_HANDLES )
    {
        channel_handle = g_ppe_flags_desc_table[flag_handle].channel_handle;
    }
#endif
    return channel_handle;
    7d1c:	7bfb      	ldrb	r3, [r7, #15]
}
    7d1e:	4618      	mov	r0, r3
    7d20:	f107 0714 	add.w	r7, r7, #20
    7d24:	46bd      	mov	sp, r7
    7d26:	bc80      	pop	{r7}
    7d28:	4770      	bx	lr
    7d2a:	bf00      	nop

00007d2c <ACE_get_channel_flag_count>:
uint32_t
ACE_get_channel_flag_count
(
    ace_channel_handle_t    channel_handle
)
{
    7d2c:	b480      	push	{r7}
    7d2e:	b085      	sub	sp, #20
    7d30:	af00      	add	r7, sp, #0
    7d32:	4603      	mov	r3, r0
    7d34:	71fb      	strb	r3, [r7, #7]
    uint32_t flag_count = 0;
    7d36:	f04f 0300 	mov.w	r3, #0
    7d3a:	60fb      	str	r3, [r7, #12]
    if (channel_handle < ACE_NB_OF_INPUT_CHANNELS)
    {
        flag_count = g_ace_channel_desc_table[channel_handle].nb_of_flags;
    }
#endif
    return flag_count;
    7d3c:	68fb      	ldr	r3, [r7, #12]
}
    7d3e:	4618      	mov	r0, r3
    7d40:	f107 0714 	add.w	r7, r7, #20
    7d44:	46bd      	mov	sp, r7
    7d46:	bc80      	pop	{r7}
    7d48:	4770      	bx	lr
    7d4a:	bf00      	nop

00007d4c <ACE_get_channel_first_flag>:
ACE_get_channel_first_flag
(
    ace_channel_handle_t    channel_handle,
    uint16_t *              iterator
)
{
    7d4c:	b480      	push	{r7}
    7d4e:	b085      	sub	sp, #20
    7d50:	af00      	add	r7, sp, #0
    7d52:	4603      	mov	r3, r0
    7d54:	6039      	str	r1, [r7, #0]
    7d56:	71fb      	strb	r3, [r7, #7]
    ace_flag_handle_t flag_handle = INVALID_FLAG_HANDLE;
    7d58:	f04f 0300 	mov.w	r3, #0
    7d5c:	73fb      	strb	r3, [r7, #15]
        {
            flag_handle = (ace_flag_handle_t)g_ace_channel_desc_table[channel_handle].p_flags_array[*iterator];
        }
    }
#endif    
    return flag_handle;
    7d5e:	7bfb      	ldrb	r3, [r7, #15]
}
    7d60:	4618      	mov	r0, r3
    7d62:	f107 0714 	add.w	r7, r7, #20
    7d66:	46bd      	mov	sp, r7
    7d68:	bc80      	pop	{r7}
    7d6a:	4770      	bx	lr

00007d6c <ACE_get_channel_next_flag>:
ACE_get_channel_next_flag
(
    ace_channel_handle_t    channel_handle,
    uint16_t *              iterator
)
{
    7d6c:	b480      	push	{r7}
    7d6e:	b085      	sub	sp, #20
    7d70:	af00      	add	r7, sp, #0
    7d72:	4603      	mov	r3, r0
    7d74:	6039      	str	r1, [r7, #0]
    7d76:	71fb      	strb	r3, [r7, #7]
    ace_flag_handle_t flag_handle = INVALID_FLAG_HANDLE;
    7d78:	f04f 0300 	mov.w	r3, #0
    7d7c:	73fb      	strb	r3, [r7, #15]
        {
            flag_handle = (ace_flag_handle_t)g_ace_channel_desc_table[channel_handle].p_flags_array[*iterator];
        }
    }
#endif
    return flag_handle;
    7d7e:	7bfb      	ldrb	r3, [r7, #15]
}
    7d80:	4618      	mov	r0, r3
    7d82:	f107 0714 	add.w	r7, r7, #20
    7d86:	46bd      	mov	sp, r7
    7d88:	bc80      	pop	{r7}
    7d8a:	4770      	bx	lr

00007d8c <ACE_enable_channel_flags_irq>:
 */
void ACE_enable_channel_flags_irq
(
    ace_channel_handle_t channel_handle
)
{
    7d8c:	b480      	push	{r7}
    7d8e:	b083      	sub	sp, #12
    7d90:	af00      	add	r7, sp, #0
    7d92:	4603      	mov	r3, r0
    7d94:	71fb      	strb	r3, [r7, #7]
            flag_handle = (ace_flag_handle_t)g_ace_channel_desc_table[channel_handle].p_flags_array[flag_idx];
            ACE_enable_flag_irq( flag_handle );
        }
    }
#endif
}
    7d96:	f107 070c 	add.w	r7, r7, #12
    7d9a:	46bd      	mov	sp, r7
    7d9c:	bc80      	pop	{r7}
    7d9e:	4770      	bx	lr

00007da0 <ACE_disable_channel_flags_irq>:
 */
void ACE_disable_channel_flags_irq
(
    ace_channel_handle_t channel_handle
)
{
    7da0:	b480      	push	{r7}
    7da2:	b083      	sub	sp, #12
    7da4:	af00      	add	r7, sp, #0
    7da6:	4603      	mov	r3, r0
    7da8:	71fb      	strb	r3, [r7, #7]
            flag_handle = (ace_flag_handle_t)g_ace_channel_desc_table[channel_handle].p_flags_array[flag_idx];
            ACE_disable_flag_irq( flag_handle );
        }
    }
#endif
}
    7daa:	f107 070c 	add.w	r7, r7, #12
    7dae:	46bd      	mov	sp, r7
    7db0:	bc80      	pop	{r7}
    7db2:	4770      	bx	lr

00007db4 <ACE_clear_channel_flags_irq>:
 */
void ACE_clear_channel_flags_irq
(
    ace_channel_handle_t channel_handle
)
{
    7db4:	b480      	push	{r7}
    7db6:	b083      	sub	sp, #12
    7db8:	af00      	add	r7, sp, #0
    7dba:	4603      	mov	r3, r0
    7dbc:	71fb      	strb	r3, [r7, #7]
            flag_handle = (ace_flag_handle_t)g_ace_channel_desc_table[channel_handle].p_flags_array[flag_idx];
            ACE_clear_flag_irq( flag_handle );
        }
    }
#endif
}
    7dbe:	f107 070c 	add.w	r7, r7, #12
    7dc2:	46bd      	mov	sp, r7
    7dc4:	bc80      	pop	{r7}
    7dc6:	4770      	bx	lr

00007dc8 <ACE_enable_flag_irq>:
 */
void ACE_enable_flag_irq
(
    ace_flag_handle_t flag_handle
)
{
    7dc8:	b480      	push	{r7}
    7dca:	b083      	sub	sp, #12
    7dcc:	af00      	add	r7, sp, #0
    7dce:	4603      	mov	r3, r0
    7dd0:	71fb      	strb	r3, [r7, #7]
        }
        
        NVIC_EnableIRQ( threshold_irqn_lut[flag_bit_offset] );
    }
#endif
}
    7dd2:	f107 070c 	add.w	r7, r7, #12
    7dd6:	46bd      	mov	sp, r7
    7dd8:	bc80      	pop	{r7}
    7dda:	4770      	bx	lr

00007ddc <ACE_disable_flag_irq>:
 */
void ACE_disable_flag_irq
(
    ace_flag_handle_t flag_handle
)
{
    7ddc:	b480      	push	{r7}
    7dde:	b083      	sub	sp, #12
    7de0:	af00      	add	r7, sp, #0
    7de2:	4603      	mov	r3, r0
    7de4:	71fb      	strb	r3, [r7, #7]
            dummy_read = *(flags_irq_enable_regs_lut[ppe_flag_group]);
            ++dummy_read;
        }
    }
#endif
}
    7de6:	f107 070c 	add.w	r7, r7, #12
    7dea:	46bd      	mov	sp, r7
    7dec:	bc80      	pop	{r7}
    7dee:	4770      	bx	lr

00007df0 <ACE_clear_flag_irq>:
 */
void ACE_clear_flag_irq
(
    ace_flag_handle_t flag_handle
)
{
    7df0:	b480      	push	{r7}
    7df2:	b083      	sub	sp, #12
    7df4:	af00      	add	r7, sp, #0
    7df6:	4603      	mov	r3, r0
    7df8:	71fb      	strb	r3, [r7, #7]
            dummy_read = *(flags_irq_clear_regs_lut[ppe_flag_group]);
            ++dummy_read;
        }
    }
#endif
}
    7dfa:	f107 070c 	add.w	r7, r7, #12
    7dfe:	46bd      	mov	sp, r7
    7e00:	bc80      	pop	{r7}
    7e02:	4770      	bx	lr

00007e04 <ACE_register_flag_isr>:
void ACE_register_flag_isr
(
    ace_flag_handle_t   flag_handle,
    flag_isr_t          flag_isr
)
{
    7e04:	b480      	push	{r7}
    7e06:	b083      	sub	sp, #12
    7e08:	af00      	add	r7, sp, #0
    7e0a:	4603      	mov	r3, r0
    7e0c:	6039      	str	r1, [r7, #0]
    7e0e:	71fb      	strb	r3, [r7, #7]
        {
            g_ppe_flags_isr_lut[flag_id] = flag_isr;
        }
    }
#endif
}
    7e10:	f107 070c 	add.w	r7, r7, #12
    7e14:	46bd      	mov	sp, r7
    7e16:	bc80      	pop	{r7}
    7e18:	4770      	bx	lr
    7e1a:	bf00      	nop

00007e1c <ACE_register_channel_flags_isr>:
void ACE_register_channel_flags_isr
(
    ace_channel_handle_t    channel_handle,
    channel_flag_isr_t      channel_flag_isr
)
{
    7e1c:	b480      	push	{r7}
    7e1e:	b083      	sub	sp, #12
    7e20:	af00      	add	r7, sp, #0
    7e22:	4603      	mov	r3, r0
    7e24:	6039      	str	r1, [r7, #0]
    7e26:	71fb      	strb	r3, [r7, #7]
    if ( channel_handle < NB_OF_ACE_CHANNEL_HANDLES )
    {
        g_ppe_channel_flags_isr_lut[channel_handle] = channel_flag_isr;
    }
#endif
}
    7e28:	f107 070c 	add.w	r7, r7, #12
    7e2c:	46bd      	mov	sp, r7
    7e2e:	bc80      	pop	{r7}
    7e30:	4770      	bx	lr
    7e32:	bf00      	nop

00007e34 <ACE_register_global_flags_isr>:
 */
void ACE_register_global_flags_isr
(
    global_flag_isr_t  global_flag_isr
)
{
    7e34:	b480      	push	{r7}
    7e36:	b083      	sub	sp, #12
    7e38:	af00      	add	r7, sp, #0
    7e3a:	6078      	str	r0, [r7, #4]
#if (ACE_NB_OF_PPE_FLAGS > 0)
    g_ppe_global_flags_isr = global_flag_isr;
#endif
}
    7e3c:	f107 070c 	add.w	r7, r7, #12
    7e40:	46bd      	mov	sp, r7
    7e42:	bc80      	pop	{r7}
    7e44:	4770      	bx	lr
    7e46:	bf00      	nop

00007e48 <process_flag_irq>:
/*-------------------------------------------------------------------------*//**
 * Actual PPE flag interrupt service routines:
 */

static void process_flag_irq( uint8_t threshold_flag_id )
{
    7e48:	b480      	push	{r7}
    7e4a:	b083      	sub	sp, #12
    7e4c:	af00      	add	r7, sp, #0
    7e4e:	4603      	mov	r3, r0
    7e50:	71fb      	strb	r3, [r7, #7]
            dummy_read = *(flags_irq_clear_regs_lut[flag_group]);
            ++dummy_read;
        }
    }
#endif
}
    7e52:	f107 070c 	add.w	r7, r7, #12
    7e56:	46bd      	mov	sp, r7
    7e58:	bc80      	pop	{r7}
    7e5a:	4770      	bx	lr

00007e5c <ACE_PPE_Flag0_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag0_IRQHandler( void )
#else
void ACE_PPE_Flag0_IRQHandler( void )
#endif
{
    7e5c:	4668      	mov	r0, sp
    7e5e:	f020 0107 	bic.w	r1, r0, #7
    7e62:	468d      	mov	sp, r1
    7e64:	b589      	push	{r0, r3, r7, lr}
    7e66:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG0 );
    7e68:	f04f 0000 	mov.w	r0, #0
    7e6c:	f7ff ffec 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag0_IRQn );
    7e70:	f04f 0076 	mov.w	r0, #118	; 0x76
    7e74:	f7ff fe9c 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    7e78:	46bd      	mov	sp, r7
    7e7a:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    7e7e:	4685      	mov	sp, r0
    7e80:	4770      	bx	lr
    7e82:	bf00      	nop

00007e84 <ACE_PPE_Flag1_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag1_IRQHandler( void )
#else
void ACE_PPE_Flag1_IRQHandler( void )
#endif
{
    7e84:	4668      	mov	r0, sp
    7e86:	f020 0107 	bic.w	r1, r0, #7
    7e8a:	468d      	mov	sp, r1
    7e8c:	b589      	push	{r0, r3, r7, lr}
    7e8e:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG1 );
    7e90:	f04f 0001 	mov.w	r0, #1
    7e94:	f7ff ffd8 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag1_IRQn );
    7e98:	f04f 0077 	mov.w	r0, #119	; 0x77
    7e9c:	f7ff fe88 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    7ea0:	46bd      	mov	sp, r7
    7ea2:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    7ea6:	4685      	mov	sp, r0
    7ea8:	4770      	bx	lr
    7eaa:	bf00      	nop

00007eac <ACE_PPE_Flag2_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag2_IRQHandler( void )
#else
void ACE_PPE_Flag2_IRQHandler( void )
#endif
{
    7eac:	4668      	mov	r0, sp
    7eae:	f020 0107 	bic.w	r1, r0, #7
    7eb2:	468d      	mov	sp, r1
    7eb4:	b589      	push	{r0, r3, r7, lr}
    7eb6:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG2 );
    7eb8:	f04f 0002 	mov.w	r0, #2
    7ebc:	f7ff ffc4 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag2_IRQn );
    7ec0:	f04f 0078 	mov.w	r0, #120	; 0x78
    7ec4:	f7ff fe74 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    7ec8:	46bd      	mov	sp, r7
    7eca:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    7ece:	4685      	mov	sp, r0
    7ed0:	4770      	bx	lr
    7ed2:	bf00      	nop

00007ed4 <ACE_PPE_Flag3_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag3_IRQHandler( void )
#else
void ACE_PPE_Flag3_IRQHandler( void )
#endif
{
    7ed4:	4668      	mov	r0, sp
    7ed6:	f020 0107 	bic.w	r1, r0, #7
    7eda:	468d      	mov	sp, r1
    7edc:	b589      	push	{r0, r3, r7, lr}
    7ede:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG3 );
    7ee0:	f04f 0003 	mov.w	r0, #3
    7ee4:	f7ff ffb0 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag3_IRQn );
    7ee8:	f04f 0079 	mov.w	r0, #121	; 0x79
    7eec:	f7ff fe60 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    7ef0:	46bd      	mov	sp, r7
    7ef2:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    7ef6:	4685      	mov	sp, r0
    7ef8:	4770      	bx	lr
    7efa:	bf00      	nop

00007efc <ACE_PPE_Flag4_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag4_IRQHandler( void )
#else
void ACE_PPE_Flag4_IRQHandler( void )
#endif
{
    7efc:	4668      	mov	r0, sp
    7efe:	f020 0107 	bic.w	r1, r0, #7
    7f02:	468d      	mov	sp, r1
    7f04:	b589      	push	{r0, r3, r7, lr}
    7f06:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG4 );
    7f08:	f04f 0004 	mov.w	r0, #4
    7f0c:	f7ff ff9c 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag4_IRQn );
    7f10:	f04f 007a 	mov.w	r0, #122	; 0x7a
    7f14:	f7ff fe4c 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    7f18:	46bd      	mov	sp, r7
    7f1a:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    7f1e:	4685      	mov	sp, r0
    7f20:	4770      	bx	lr
    7f22:	bf00      	nop

00007f24 <ACE_PPE_Flag5_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag5_IRQHandler( void )
#else
void ACE_PPE_Flag5_IRQHandler( void )
#endif
{
    7f24:	4668      	mov	r0, sp
    7f26:	f020 0107 	bic.w	r1, r0, #7
    7f2a:	468d      	mov	sp, r1
    7f2c:	b589      	push	{r0, r3, r7, lr}
    7f2e:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG5 );
    7f30:	f04f 0005 	mov.w	r0, #5
    7f34:	f7ff ff88 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag5_IRQn );
    7f38:	f04f 007b 	mov.w	r0, #123	; 0x7b
    7f3c:	f7ff fe38 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    7f40:	46bd      	mov	sp, r7
    7f42:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    7f46:	4685      	mov	sp, r0
    7f48:	4770      	bx	lr
    7f4a:	bf00      	nop

00007f4c <ACE_PPE_Flag6_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag6_IRQHandler( void )
#else
void ACE_PPE_Flag6_IRQHandler( void )
#endif
{
    7f4c:	4668      	mov	r0, sp
    7f4e:	f020 0107 	bic.w	r1, r0, #7
    7f52:	468d      	mov	sp, r1
    7f54:	b589      	push	{r0, r3, r7, lr}
    7f56:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG6 );
    7f58:	f04f 0006 	mov.w	r0, #6
    7f5c:	f7ff ff74 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag6_IRQn );
    7f60:	f04f 007c 	mov.w	r0, #124	; 0x7c
    7f64:	f7ff fe24 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    7f68:	46bd      	mov	sp, r7
    7f6a:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    7f6e:	4685      	mov	sp, r0
    7f70:	4770      	bx	lr
    7f72:	bf00      	nop

00007f74 <ACE_PPE_Flag7_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag7_IRQHandler( void )
#else
void ACE_PPE_Flag7_IRQHandler( void )
#endif
{
    7f74:	4668      	mov	r0, sp
    7f76:	f020 0107 	bic.w	r1, r0, #7
    7f7a:	468d      	mov	sp, r1
    7f7c:	b589      	push	{r0, r3, r7, lr}
    7f7e:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG7 );
    7f80:	f04f 0007 	mov.w	r0, #7
    7f84:	f7ff ff60 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag7_IRQn );
    7f88:	f04f 007d 	mov.w	r0, #125	; 0x7d
    7f8c:	f7ff fe10 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    7f90:	46bd      	mov	sp, r7
    7f92:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    7f96:	4685      	mov	sp, r0
    7f98:	4770      	bx	lr
    7f9a:	bf00      	nop

00007f9c <ACE_PPE_Flag8_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag8_IRQHandler( void )
#else
void ACE_PPE_Flag8_IRQHandler( void )
#endif
{
    7f9c:	4668      	mov	r0, sp
    7f9e:	f020 0107 	bic.w	r1, r0, #7
    7fa2:	468d      	mov	sp, r1
    7fa4:	b589      	push	{r0, r3, r7, lr}
    7fa6:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG8 );
    7fa8:	f04f 0008 	mov.w	r0, #8
    7fac:	f7ff ff4c 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag8_IRQn );
    7fb0:	f04f 007e 	mov.w	r0, #126	; 0x7e
    7fb4:	f7ff fdfc 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    7fb8:	46bd      	mov	sp, r7
    7fba:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    7fbe:	4685      	mov	sp, r0
    7fc0:	4770      	bx	lr
    7fc2:	bf00      	nop

00007fc4 <ACE_PPE_Flag9_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag9_IRQHandler( void )
#else
void ACE_PPE_Flag9_IRQHandler( void )
#endif
{
    7fc4:	4668      	mov	r0, sp
    7fc6:	f020 0107 	bic.w	r1, r0, #7
    7fca:	468d      	mov	sp, r1
    7fcc:	b589      	push	{r0, r3, r7, lr}
    7fce:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG9 );
    7fd0:	f04f 0009 	mov.w	r0, #9
    7fd4:	f7ff ff38 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag9_IRQn );
    7fd8:	f04f 007f 	mov.w	r0, #127	; 0x7f
    7fdc:	f7ff fde8 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    7fe0:	46bd      	mov	sp, r7
    7fe2:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    7fe6:	4685      	mov	sp, r0
    7fe8:	4770      	bx	lr
    7fea:	bf00      	nop

00007fec <ACE_PPE_Flag10_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag10_IRQHandler( void )
#else
void ACE_PPE_Flag10_IRQHandler( void )
#endif
{
    7fec:	4668      	mov	r0, sp
    7fee:	f020 0107 	bic.w	r1, r0, #7
    7ff2:	468d      	mov	sp, r1
    7ff4:	b589      	push	{r0, r3, r7, lr}
    7ff6:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG10 );
    7ff8:	f04f 000a 	mov.w	r0, #10
    7ffc:	f7ff ff24 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag10_IRQn );
    8000:	f04f 0080 	mov.w	r0, #128	; 0x80
    8004:	f7ff fdd4 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    8008:	46bd      	mov	sp, r7
    800a:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    800e:	4685      	mov	sp, r0
    8010:	4770      	bx	lr
    8012:	bf00      	nop

00008014 <ACE_PPE_Flag11_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag11_IRQHandler( void )
#else
void ACE_PPE_Flag11_IRQHandler( void )
#endif
{
    8014:	4668      	mov	r0, sp
    8016:	f020 0107 	bic.w	r1, r0, #7
    801a:	468d      	mov	sp, r1
    801c:	b589      	push	{r0, r3, r7, lr}
    801e:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG11 );
    8020:	f04f 000b 	mov.w	r0, #11
    8024:	f7ff ff10 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag11_IRQn );
    8028:	f04f 0081 	mov.w	r0, #129	; 0x81
    802c:	f7ff fdc0 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    8030:	46bd      	mov	sp, r7
    8032:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    8036:	4685      	mov	sp, r0
    8038:	4770      	bx	lr
    803a:	bf00      	nop

0000803c <ACE_PPE_Flag12_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag12_IRQHandler( void )
#else
void ACE_PPE_Flag12_IRQHandler( void )
#endif
{
    803c:	4668      	mov	r0, sp
    803e:	f020 0107 	bic.w	r1, r0, #7
    8042:	468d      	mov	sp, r1
    8044:	b589      	push	{r0, r3, r7, lr}
    8046:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG12 );
    8048:	f04f 000c 	mov.w	r0, #12
    804c:	f7ff fefc 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag12_IRQn );
    8050:	f04f 0082 	mov.w	r0, #130	; 0x82
    8054:	f7ff fdac 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    8058:	46bd      	mov	sp, r7
    805a:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    805e:	4685      	mov	sp, r0
    8060:	4770      	bx	lr
    8062:	bf00      	nop

00008064 <ACE_PPE_Flag13_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag13_IRQHandler( void )
#else
void ACE_PPE_Flag13_IRQHandler( void )
#endif
{
    8064:	4668      	mov	r0, sp
    8066:	f020 0107 	bic.w	r1, r0, #7
    806a:	468d      	mov	sp, r1
    806c:	b589      	push	{r0, r3, r7, lr}
    806e:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG13 );
    8070:	f04f 000d 	mov.w	r0, #13
    8074:	f7ff fee8 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag13_IRQn );
    8078:	f04f 0083 	mov.w	r0, #131	; 0x83
    807c:	f7ff fd98 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    8080:	46bd      	mov	sp, r7
    8082:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    8086:	4685      	mov	sp, r0
    8088:	4770      	bx	lr
    808a:	bf00      	nop

0000808c <ACE_PPE_Flag14_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag14_IRQHandler( void )
#else
void ACE_PPE_Flag14_IRQHandler( void )
#endif
{
    808c:	4668      	mov	r0, sp
    808e:	f020 0107 	bic.w	r1, r0, #7
    8092:	468d      	mov	sp, r1
    8094:	b589      	push	{r0, r3, r7, lr}
    8096:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG14 );
    8098:	f04f 000e 	mov.w	r0, #14
    809c:	f7ff fed4 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag14_IRQn );
    80a0:	f04f 0084 	mov.w	r0, #132	; 0x84
    80a4:	f7ff fd84 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    80a8:	46bd      	mov	sp, r7
    80aa:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    80ae:	4685      	mov	sp, r0
    80b0:	4770      	bx	lr
    80b2:	bf00      	nop

000080b4 <ACE_PPE_Flag15_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag15_IRQHandler( void )
#else
void ACE_PPE_Flag15_IRQHandler( void )
#endif
{
    80b4:	4668      	mov	r0, sp
    80b6:	f020 0107 	bic.w	r1, r0, #7
    80ba:	468d      	mov	sp, r1
    80bc:	b589      	push	{r0, r3, r7, lr}
    80be:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG15 );
    80c0:	f04f 000f 	mov.w	r0, #15
    80c4:	f7ff fec0 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag15_IRQn );
    80c8:	f04f 0085 	mov.w	r0, #133	; 0x85
    80cc:	f7ff fd70 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    80d0:	46bd      	mov	sp, r7
    80d2:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    80d6:	4685      	mov	sp, r0
    80d8:	4770      	bx	lr
    80da:	bf00      	nop

000080dc <ACE_PPE_Flag16_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag16_IRQHandler( void )
#else
void ACE_PPE_Flag16_IRQHandler( void )
#endif
{
    80dc:	4668      	mov	r0, sp
    80de:	f020 0107 	bic.w	r1, r0, #7
    80e2:	468d      	mov	sp, r1
    80e4:	b589      	push	{r0, r3, r7, lr}
    80e6:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG16 );
    80e8:	f04f 0010 	mov.w	r0, #16
    80ec:	f7ff feac 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag16_IRQn );
    80f0:	f04f 0086 	mov.w	r0, #134	; 0x86
    80f4:	f7ff fd5c 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    80f8:	46bd      	mov	sp, r7
    80fa:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    80fe:	4685      	mov	sp, r0
    8100:	4770      	bx	lr
    8102:	bf00      	nop

00008104 <ACE_PPE_Flag17_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag17_IRQHandler( void )
#else
void ACE_PPE_Flag17_IRQHandler( void )
#endif
{
    8104:	4668      	mov	r0, sp
    8106:	f020 0107 	bic.w	r1, r0, #7
    810a:	468d      	mov	sp, r1
    810c:	b589      	push	{r0, r3, r7, lr}
    810e:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG17 );
    8110:	f04f 0011 	mov.w	r0, #17
    8114:	f7ff fe98 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag17_IRQn );
    8118:	f04f 0087 	mov.w	r0, #135	; 0x87
    811c:	f7ff fd48 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    8120:	46bd      	mov	sp, r7
    8122:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    8126:	4685      	mov	sp, r0
    8128:	4770      	bx	lr
    812a:	bf00      	nop

0000812c <ACE_PPE_Flag18_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag18_IRQHandler( void )
#else
void ACE_PPE_Flag18_IRQHandler( void )
#endif
{
    812c:	4668      	mov	r0, sp
    812e:	f020 0107 	bic.w	r1, r0, #7
    8132:	468d      	mov	sp, r1
    8134:	b589      	push	{r0, r3, r7, lr}
    8136:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG18 );
    8138:	f04f 0012 	mov.w	r0, #18
    813c:	f7ff fe84 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag18_IRQn );
    8140:	f04f 0088 	mov.w	r0, #136	; 0x88
    8144:	f7ff fd34 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    8148:	46bd      	mov	sp, r7
    814a:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    814e:	4685      	mov	sp, r0
    8150:	4770      	bx	lr
    8152:	bf00      	nop

00008154 <ACE_PPE_Flag19_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag19_IRQHandler( void )
#else
void ACE_PPE_Flag19_IRQHandler( void )
#endif
{
    8154:	4668      	mov	r0, sp
    8156:	f020 0107 	bic.w	r1, r0, #7
    815a:	468d      	mov	sp, r1
    815c:	b589      	push	{r0, r3, r7, lr}
    815e:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG19 );
    8160:	f04f 0013 	mov.w	r0, #19
    8164:	f7ff fe70 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag19_IRQn );
    8168:	f04f 0089 	mov.w	r0, #137	; 0x89
    816c:	f7ff fd20 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    8170:	46bd      	mov	sp, r7
    8172:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    8176:	4685      	mov	sp, r0
    8178:	4770      	bx	lr
    817a:	bf00      	nop

0000817c <ACE_PPE_Flag20_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag20_IRQHandler( void )
#else
void ACE_PPE_Flag20_IRQHandler( void )
#endif
{
    817c:	4668      	mov	r0, sp
    817e:	f020 0107 	bic.w	r1, r0, #7
    8182:	468d      	mov	sp, r1
    8184:	b589      	push	{r0, r3, r7, lr}
    8186:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG20 );
    8188:	f04f 0014 	mov.w	r0, #20
    818c:	f7ff fe5c 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag20_IRQn );
    8190:	f04f 008a 	mov.w	r0, #138	; 0x8a
    8194:	f7ff fd0c 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    8198:	46bd      	mov	sp, r7
    819a:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    819e:	4685      	mov	sp, r0
    81a0:	4770      	bx	lr
    81a2:	bf00      	nop

000081a4 <ACE_PPE_Flag21_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag21_IRQHandler( void )
#else
void ACE_PPE_Flag21_IRQHandler( void )
#endif
{
    81a4:	4668      	mov	r0, sp
    81a6:	f020 0107 	bic.w	r1, r0, #7
    81aa:	468d      	mov	sp, r1
    81ac:	b589      	push	{r0, r3, r7, lr}
    81ae:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG21 );
    81b0:	f04f 0015 	mov.w	r0, #21
    81b4:	f7ff fe48 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag21_IRQn );
    81b8:	f04f 008b 	mov.w	r0, #139	; 0x8b
    81bc:	f7ff fcf8 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    81c0:	46bd      	mov	sp, r7
    81c2:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    81c6:	4685      	mov	sp, r0
    81c8:	4770      	bx	lr
    81ca:	bf00      	nop

000081cc <ACE_PPE_Flag22_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag22_IRQHandler( void )
#else
void ACE_PPE_Flag22_IRQHandler( void )
#endif
{
    81cc:	4668      	mov	r0, sp
    81ce:	f020 0107 	bic.w	r1, r0, #7
    81d2:	468d      	mov	sp, r1
    81d4:	b589      	push	{r0, r3, r7, lr}
    81d6:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG22 );
    81d8:	f04f 0016 	mov.w	r0, #22
    81dc:	f7ff fe34 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag22_IRQn );
    81e0:	f04f 008c 	mov.w	r0, #140	; 0x8c
    81e4:	f7ff fce4 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    81e8:	46bd      	mov	sp, r7
    81ea:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    81ee:	4685      	mov	sp, r0
    81f0:	4770      	bx	lr
    81f2:	bf00      	nop

000081f4 <ACE_PPE_Flag23_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag23_IRQHandler( void )
#else
void ACE_PPE_Flag23_IRQHandler( void )
#endif
{
    81f4:	4668      	mov	r0, sp
    81f6:	f020 0107 	bic.w	r1, r0, #7
    81fa:	468d      	mov	sp, r1
    81fc:	b589      	push	{r0, r3, r7, lr}
    81fe:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG23 );
    8200:	f04f 0017 	mov.w	r0, #23
    8204:	f7ff fe20 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag23_IRQn );
    8208:	f04f 008d 	mov.w	r0, #141	; 0x8d
    820c:	f7ff fcd0 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    8210:	46bd      	mov	sp, r7
    8212:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    8216:	4685      	mov	sp, r0
    8218:	4770      	bx	lr
    821a:	bf00      	nop

0000821c <ACE_PPE_Flag24_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag24_IRQHandler( void )
#else
void ACE_PPE_Flag24_IRQHandler( void )
#endif
{
    821c:	4668      	mov	r0, sp
    821e:	f020 0107 	bic.w	r1, r0, #7
    8222:	468d      	mov	sp, r1
    8224:	b589      	push	{r0, r3, r7, lr}
    8226:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG24 );
    8228:	f04f 0018 	mov.w	r0, #24
    822c:	f7ff fe0c 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag24_IRQn );
    8230:	f04f 008e 	mov.w	r0, #142	; 0x8e
    8234:	f7ff fcbc 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    8238:	46bd      	mov	sp, r7
    823a:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    823e:	4685      	mov	sp, r0
    8240:	4770      	bx	lr
    8242:	bf00      	nop

00008244 <ACE_PPE_Flag25_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag25_IRQHandler( void )
#else
void ACE_PPE_Flag25_IRQHandler( void )
#endif
{
    8244:	4668      	mov	r0, sp
    8246:	f020 0107 	bic.w	r1, r0, #7
    824a:	468d      	mov	sp, r1
    824c:	b589      	push	{r0, r3, r7, lr}
    824e:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG25 );
    8250:	f04f 0019 	mov.w	r0, #25
    8254:	f7ff fdf8 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag25_IRQn );
    8258:	f04f 008f 	mov.w	r0, #143	; 0x8f
    825c:	f7ff fca8 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    8260:	46bd      	mov	sp, r7
    8262:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    8266:	4685      	mov	sp, r0
    8268:	4770      	bx	lr
    826a:	bf00      	nop

0000826c <ACE_PPE_Flag26_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag26_IRQHandler( void )
#else
void ACE_PPE_Flag26_IRQHandler( void )
#endif
{
    826c:	4668      	mov	r0, sp
    826e:	f020 0107 	bic.w	r1, r0, #7
    8272:	468d      	mov	sp, r1
    8274:	b589      	push	{r0, r3, r7, lr}
    8276:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG26 );
    8278:	f04f 001a 	mov.w	r0, #26
    827c:	f7ff fde4 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag26_IRQn );
    8280:	f04f 0090 	mov.w	r0, #144	; 0x90
    8284:	f7ff fc94 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    8288:	46bd      	mov	sp, r7
    828a:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    828e:	4685      	mov	sp, r0
    8290:	4770      	bx	lr
    8292:	bf00      	nop

00008294 <ACE_PPE_Flag27_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag27_IRQHandler( void )
#else
void ACE_PPE_Flag27_IRQHandler( void )
#endif
{
    8294:	4668      	mov	r0, sp
    8296:	f020 0107 	bic.w	r1, r0, #7
    829a:	468d      	mov	sp, r1
    829c:	b589      	push	{r0, r3, r7, lr}
    829e:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG27 );
    82a0:	f04f 001b 	mov.w	r0, #27
    82a4:	f7ff fdd0 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag27_IRQn );
    82a8:	f04f 0091 	mov.w	r0, #145	; 0x91
    82ac:	f7ff fc80 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    82b0:	46bd      	mov	sp, r7
    82b2:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    82b6:	4685      	mov	sp, r0
    82b8:	4770      	bx	lr
    82ba:	bf00      	nop

000082bc <ACE_PPE_Flag28_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag28_IRQHandler( void )
#else
void ACE_PPE_Flag28_IRQHandler( void )
#endif
{
    82bc:	4668      	mov	r0, sp
    82be:	f020 0107 	bic.w	r1, r0, #7
    82c2:	468d      	mov	sp, r1
    82c4:	b589      	push	{r0, r3, r7, lr}
    82c6:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG28 );
    82c8:	f04f 001c 	mov.w	r0, #28
    82cc:	f7ff fdbc 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag28_IRQn );
    82d0:	f04f 0092 	mov.w	r0, #146	; 0x92
    82d4:	f7ff fc6c 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    82d8:	46bd      	mov	sp, r7
    82da:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    82de:	4685      	mov	sp, r0
    82e0:	4770      	bx	lr
    82e2:	bf00      	nop

000082e4 <ACE_PPE_Flag29_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag29_IRQHandler( void )
#else
void ACE_PPE_Flag29_IRQHandler( void )
#endif
{
    82e4:	4668      	mov	r0, sp
    82e6:	f020 0107 	bic.w	r1, r0, #7
    82ea:	468d      	mov	sp, r1
    82ec:	b589      	push	{r0, r3, r7, lr}
    82ee:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG29 );
    82f0:	f04f 001d 	mov.w	r0, #29
    82f4:	f7ff fda8 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag29_IRQn );
    82f8:	f04f 0093 	mov.w	r0, #147	; 0x93
    82fc:	f7ff fc58 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    8300:	46bd      	mov	sp, r7
    8302:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    8306:	4685      	mov	sp, r0
    8308:	4770      	bx	lr
    830a:	bf00      	nop

0000830c <ACE_PPE_Flag30_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag30_IRQHandler( void )
#else
void ACE_PPE_Flag30_IRQHandler( void )
#endif
{
    830c:	4668      	mov	r0, sp
    830e:	f020 0107 	bic.w	r1, r0, #7
    8312:	468d      	mov	sp, r1
    8314:	b589      	push	{r0, r3, r7, lr}
    8316:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG30 );
    8318:	f04f 001e 	mov.w	r0, #30
    831c:	f7ff fd94 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag30_IRQn );
    8320:	f04f 0094 	mov.w	r0, #148	; 0x94
    8324:	f7ff fc44 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    8328:	46bd      	mov	sp, r7
    832a:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    832e:	4685      	mov	sp, r0
    8330:	4770      	bx	lr
    8332:	bf00      	nop

00008334 <ACE_PPE_Flag31_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag31_IRQHandler( void )
#else
void ACE_PPE_Flag31_IRQHandler( void )
#endif
{
    8334:	4668      	mov	r0, sp
    8336:	f020 0107 	bic.w	r1, r0, #7
    833a:	468d      	mov	sp, r1
    833c:	b589      	push	{r0, r3, r7, lr}
    833e:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG31 );
    8340:	f04f 001f 	mov.w	r0, #31
    8344:	f7ff fd80 	bl	7e48 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag31_IRQn );
    8348:	f04f 0095 	mov.w	r0, #149	; 0x95
    834c:	f7ff fc30 	bl	7bb0 <NVIC_ClearPendingIRQ>
}
    8350:	46bd      	mov	sp, r7
    8352:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    8356:	4685      	mov	sp, r0
    8358:	4770      	bx	lr
    835a:	bf00      	nop

0000835c <ACE_get_sse_seq_handle>:
sse_sequence_handle_t
ACE_get_sse_seq_handle
(
    const uint8_t * p_sz_sequence_name
)
{
    835c:	b580      	push	{r7, lr}
    835e:	b084      	sub	sp, #16
    8360:	af00      	add	r7, sp, #0
    8362:	6078      	str	r0, [r7, #4]
    uint16_t seq_idx;
    sse_sequence_handle_t handle = INVALID_SSE_SEQ_HANDLE;
    8364:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8368:	817b      	strh	r3, [r7, #10]
    
    for ( seq_idx = 0u;  seq_idx < (uint32_t)ACE_NB_OF_SSE_PROCEDURES; ++seq_idx )
    836a:	f04f 0300 	mov.w	r3, #0
    836e:	813b      	strh	r3, [r7, #8]
    8370:	e02d      	b.n	83ce <ACE_get_sse_seq_handle+0x72>
    {
        if ( g_sse_sequences_desc_table[seq_idx].p_sz_proc_name != 0 )
    8372:	8939      	ldrh	r1, [r7, #8]
    8374:	f240 028c 	movw	r2, #140	; 0x8c
    8378:	f2c2 0200 	movt	r2, #8192	; 0x2000
    837c:	460b      	mov	r3, r1
    837e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8382:	440b      	add	r3, r1
    8384:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8388:	4413      	add	r3, r2
    838a:	681b      	ldr	r3, [r3, #0]
    838c:	2b00      	cmp	r3, #0
    838e:	d01a      	beq.n	83c6 <ACE_get_sse_seq_handle+0x6a>
        {
            int32_t diff;
            diff = strncmp( (const char *)p_sz_sequence_name, (const char *)g_sse_sequences_desc_table[seq_idx].p_sz_proc_name, MAX_PROCEDURE_NAME_LENGTH );
    8390:	8939      	ldrh	r1, [r7, #8]
    8392:	f240 028c 	movw	r2, #140	; 0x8c
    8396:	f2c2 0200 	movt	r2, #8192	; 0x2000
    839a:	460b      	mov	r3, r1
    839c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    83a0:	440b      	add	r3, r1
    83a2:	ea4f 0383 	mov.w	r3, r3, lsl #2
    83a6:	4413      	add	r3, r2
    83a8:	681b      	ldr	r3, [r3, #0]
    83aa:	6878      	ldr	r0, [r7, #4]
    83ac:	4619      	mov	r1, r3
    83ae:	f04f 0209 	mov.w	r2, #9
    83b2:	f00c fff3 	bl	1539c <strncmp>
    83b6:	4603      	mov	r3, r0
    83b8:	60fb      	str	r3, [r7, #12]
            if ( 0 == diff )
    83ba:	68fb      	ldr	r3, [r7, #12]
    83bc:	2b00      	cmp	r3, #0
    83be:	d102      	bne.n	83c6 <ACE_get_sse_seq_handle+0x6a>
            {
                /* channel name found. */
                handle = seq_idx;
    83c0:	893b      	ldrh	r3, [r7, #8]
    83c2:	817b      	strh	r3, [r7, #10]
                break;
    83c4:	e006      	b.n	83d4 <ACE_get_sse_seq_handle+0x78>
)
{
    uint16_t seq_idx;
    sse_sequence_handle_t handle = INVALID_SSE_SEQ_HANDLE;
    
    for ( seq_idx = 0u;  seq_idx < (uint32_t)ACE_NB_OF_SSE_PROCEDURES; ++seq_idx )
    83c6:	893b      	ldrh	r3, [r7, #8]
    83c8:	f103 0301 	add.w	r3, r3, #1
    83cc:	813b      	strh	r3, [r7, #8]
    83ce:	893b      	ldrh	r3, [r7, #8]
    83d0:	2b01      	cmp	r3, #1
    83d2:	d9ce      	bls.n	8372 <ACE_get_sse_seq_handle+0x16>
                handle = seq_idx;
                break;
            }
        }
    }
    return handle;
    83d4:	897b      	ldrh	r3, [r7, #10]
}
    83d6:	4618      	mov	r0, r3
    83d8:	f107 0710 	add.w	r7, r7, #16
    83dc:	46bd      	mov	sp, r7
    83de:	bd80      	pop	{r7, pc}

000083e0 <ACE_load_sse>:
 */
void ACE_load_sse
(
    sse_sequence_handle_t  sequence
)
{
    83e0:	b480      	push	{r7}
    83e2:	b085      	sub	sp, #20
    83e4:	af00      	add	r7, sp, #0
    83e6:	4603      	mov	r3, r0
    83e8:	80fb      	strh	r3, [r7, #6]
    ASSERT( sequence < (sse_sequence_handle_t)ACE_NB_OF_SSE_PROCEDURES );
    83ea:	88fb      	ldrh	r3, [r7, #6]
    83ec:	2b01      	cmp	r3, #1
    83ee:	d900      	bls.n	83f2 <ACE_load_sse+0x12>
    83f0:	be00      	bkpt	0x0000
    
    if ( sequence < (sse_sequence_handle_t)ACE_NB_OF_SSE_PROCEDURES )
    83f2:	88fb      	ldrh	r3, [r7, #6]
    83f4:	2b01      	cmp	r3, #1
    83f6:	f200 8085 	bhi.w	8504 <ACE_load_sse+0x124>
    {
        uint16_t i;
        uint16_t offset;
        const uint16_t * p_ucode;
        
        ASSERT( g_sse_sequences_desc_table[sequence].sse_pc_id < NB_OF_ANALOG_BLOCKS );
    83fa:	88f9      	ldrh	r1, [r7, #6]
    83fc:	f240 028c 	movw	r2, #140	; 0x8c
    8400:	f2c2 0200 	movt	r2, #8192	; 0x2000
    8404:	460b      	mov	r3, r1
    8406:	ea4f 0383 	mov.w	r3, r3, lsl #2
    840a:	440b      	add	r3, r1
    840c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8410:	4413      	add	r3, r2
    8412:	f103 0310 	add.w	r3, r3, #16
    8416:	781b      	ldrb	r3, [r3, #0]
    8418:	2b02      	cmp	r3, #2
    841a:	d900      	bls.n	841e <ACE_load_sse+0x3e>
    841c:	be00      	bkpt	0x0000
        
        if ( g_sse_sequences_desc_table[sequence].sse_pc_id < NB_OF_ANALOG_BLOCKS )
    841e:	88f9      	ldrh	r1, [r7, #6]
    8420:	f240 028c 	movw	r2, #140	; 0x8c
    8424:	f2c2 0200 	movt	r2, #8192	; 0x2000
    8428:	460b      	mov	r3, r1
    842a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    842e:	440b      	add	r3, r1
    8430:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8434:	4413      	add	r3, r2
    8436:	f103 0310 	add.w	r3, r3, #16
    843a:	781b      	ldrb	r3, [r3, #0]
    843c:	2b02      	cmp	r3, #2
    843e:	d861      	bhi.n	8504 <ACE_load_sse+0x124>
        {
            /* Stop relevant program counter. */
            *sse_pc_ctrl_lut[g_sse_sequences_desc_table[sequence].sse_pc_id] = SSE_STOP;
    8440:	88f9      	ldrh	r1, [r7, #6]
    8442:	f240 028c 	movw	r2, #140	; 0x8c
    8446:	f2c2 0200 	movt	r2, #8192	; 0x2000
    844a:	460b      	mov	r3, r1
    844c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8450:	440b      	add	r3, r1
    8452:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8456:	4413      	add	r3, r2
    8458:	f103 0310 	add.w	r3, r3, #16
    845c:	781b      	ldrb	r3, [r3, #0]
    845e:	461a      	mov	r2, r3
    8460:	f24b 63d8 	movw	r3, #46808	; 0xb6d8
    8464:	f2c0 0301 	movt	r3, #1
    8468:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    846c:	f04f 0200 	mov.w	r2, #0
    8470:	601a      	str	r2, [r3, #0]
            
            /* Load microcode into SEE RAM.*/
            p_ucode = g_sse_sequences_desc_table[sequence].sse_ucode;
    8472:	88f9      	ldrh	r1, [r7, #6]
    8474:	f240 028c 	movw	r2, #140	; 0x8c
    8478:	f2c2 0200 	movt	r2, #8192	; 0x2000
    847c:	460b      	mov	r3, r1
    847e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8482:	440b      	add	r3, r1
    8484:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8488:	4413      	add	r3, r2
    848a:	f103 030c 	add.w	r3, r3, #12
    848e:	681b      	ldr	r3, [r3, #0]
    8490:	60fb      	str	r3, [r7, #12]
            offset = g_sse_sequences_desc_table[sequence].sse_load_offset;
    8492:	88f9      	ldrh	r1, [r7, #6]
    8494:	f240 028c 	movw	r2, #140	; 0x8c
    8498:	f2c2 0200 	movt	r2, #8192	; 0x2000
    849c:	460b      	mov	r3, r1
    849e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    84a2:	440b      	add	r3, r1
    84a4:	ea4f 0383 	mov.w	r3, r3, lsl #2
    84a8:	4413      	add	r3, r2
    84aa:	88db      	ldrh	r3, [r3, #6]
    84ac:	817b      	strh	r3, [r7, #10]
            
            for ( i = 0u; i < g_sse_sequences_desc_table[sequence].sse_ucode_length; ++i )
    84ae:	f04f 0300 	mov.w	r3, #0
    84b2:	813b      	strh	r3, [r7, #8]
    84b4:	e014      	b.n	84e0 <ACE_load_sse+0x100>
            {
                ACE->SSE_RAM_DATA[offset + i] = (uint32_t)*p_ucode;
    84b6:	f240 0300 	movw	r3, #0
    84ba:	f2c4 0302 	movt	r3, #16386	; 0x4002
    84be:	8979      	ldrh	r1, [r7, #10]
    84c0:	893a      	ldrh	r2, [r7, #8]
    84c2:	440a      	add	r2, r1
    84c4:	68f9      	ldr	r1, [r7, #12]
    84c6:	8809      	ldrh	r1, [r1, #0]
    84c8:	f502 7200 	add.w	r2, r2, #512	; 0x200
    84cc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
                ++p_ucode;
    84d0:	68fb      	ldr	r3, [r7, #12]
    84d2:	f103 0302 	add.w	r3, r3, #2
    84d6:	60fb      	str	r3, [r7, #12]
            
            /* Load microcode into SEE RAM.*/
            p_ucode = g_sse_sequences_desc_table[sequence].sse_ucode;
            offset = g_sse_sequences_desc_table[sequence].sse_load_offset;
            
            for ( i = 0u; i < g_sse_sequences_desc_table[sequence].sse_ucode_length; ++i )
    84d8:	893b      	ldrh	r3, [r7, #8]
    84da:	f103 0301 	add.w	r3, r3, #1
    84de:	813b      	strh	r3, [r7, #8]
    84e0:	88f9      	ldrh	r1, [r7, #6]
    84e2:	f240 028c 	movw	r2, #140	; 0x8c
    84e6:	f2c2 0200 	movt	r2, #8192	; 0x2000
    84ea:	460b      	mov	r3, r1
    84ec:	ea4f 0383 	mov.w	r3, r3, lsl #2
    84f0:	440b      	add	r3, r1
    84f2:	ea4f 0383 	mov.w	r3, r3, lsl #2
    84f6:	4413      	add	r3, r2
    84f8:	f103 0308 	add.w	r3, r3, #8
    84fc:	881b      	ldrh	r3, [r3, #0]
    84fe:	893a      	ldrh	r2, [r7, #8]
    8500:	429a      	cmp	r2, r3
    8502:	d3d8      	bcc.n	84b6 <ACE_load_sse+0xd6>
                ACE->SSE_RAM_DATA[offset + i] = (uint32_t)*p_ucode;
                ++p_ucode;
            }
        }
    }
}
    8504:	f107 0714 	add.w	r7, r7, #20
    8508:	46bd      	mov	sp, r7
    850a:	bc80      	pop	{r7}
    850c:	4770      	bx	lr
    850e:	bf00      	nop

00008510 <ACE_start_sse>:
 */
void ACE_start_sse
(
    sse_sequence_handle_t  sequence
)
{
    8510:	b480      	push	{r7}
    8512:	b085      	sub	sp, #20
    8514:	af00      	add	r7, sp, #0
    8516:	4603      	mov	r3, r0
    8518:	80fb      	strh	r3, [r7, #6]
    ASSERT( sequence < (sse_sequence_handle_t)ACE_NB_OF_SSE_PROCEDURES );
    851a:	88fb      	ldrh	r3, [r7, #6]
    851c:	2b01      	cmp	r3, #1
    851e:	d900      	bls.n	8522 <ACE_start_sse+0x12>
    8520:	be00      	bkpt	0x0000
    
    if ( sequence < (sse_sequence_handle_t)ACE_NB_OF_SSE_PROCEDURES )
    8522:	88fb      	ldrh	r3, [r7, #6]
    8524:	2b01      	cmp	r3, #1
    8526:	f200 808d 	bhi.w	8644 <ACE_start_sse+0x134>
    {
        uint16_t pc;
        
        ASSERT( g_sse_sequences_desc_table[sequence].sse_pc_id < NB_OF_ANALOG_BLOCKS );
    852a:	88f9      	ldrh	r1, [r7, #6]
    852c:	f240 028c 	movw	r2, #140	; 0x8c
    8530:	f2c2 0200 	movt	r2, #8192	; 0x2000
    8534:	460b      	mov	r3, r1
    8536:	ea4f 0383 	mov.w	r3, r3, lsl #2
    853a:	440b      	add	r3, r1
    853c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8540:	4413      	add	r3, r2
    8542:	f103 0310 	add.w	r3, r3, #16
    8546:	781b      	ldrb	r3, [r3, #0]
    8548:	2b02      	cmp	r3, #2
    854a:	d900      	bls.n	854e <ACE_start_sse+0x3e>
    854c:	be00      	bkpt	0x0000
        ASSERT( g_sse_sequences_desc_table[sequence].sse_load_offset < SEE_RAM_WORD_SIZE );
    854e:	88f9      	ldrh	r1, [r7, #6]
    8550:	f240 028c 	movw	r2, #140	; 0x8c
    8554:	f2c2 0200 	movt	r2, #8192	; 0x2000
    8558:	460b      	mov	r3, r1
    855a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    855e:	440b      	add	r3, r1
    8560:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8564:	4413      	add	r3, r2
    8566:	88da      	ldrh	r2, [r3, #6]
    8568:	f240 13ff 	movw	r3, #511	; 0x1ff
    856c:	429a      	cmp	r2, r3
    856e:	d900      	bls.n	8572 <ACE_start_sse+0x62>
    8570:	be00      	bkpt	0x0000
    
        pc = g_sse_sequences_desc_table[sequence].sse_load_offset;
    8572:	88f9      	ldrh	r1, [r7, #6]
    8574:	f240 028c 	movw	r2, #140	; 0x8c
    8578:	f2c2 0200 	movt	r2, #8192	; 0x2000
    857c:	460b      	mov	r3, r1
    857e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8582:	440b      	add	r3, r1
    8584:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8588:	4413      	add	r3, r2
    858a:	88db      	ldrh	r3, [r3, #6]
    858c:	81fb      	strh	r3, [r7, #14]
        
        if ( pc < 256u )
    858e:	89fb      	ldrh	r3, [r7, #14]
    8590:	2bff      	cmp	r3, #255	; 0xff
    8592:	d818      	bhi.n	85c6 <ACE_start_sse+0xb6>
        {
            *sse_pc_lo_lut[g_sse_sequences_desc_table[sequence].sse_pc_id] = pc;
    8594:	88f9      	ldrh	r1, [r7, #6]
    8596:	f240 028c 	movw	r2, #140	; 0x8c
    859a:	f2c2 0200 	movt	r2, #8192	; 0x2000
    859e:	460b      	mov	r3, r1
    85a0:	ea4f 0383 	mov.w	r3, r3, lsl #2
    85a4:	440b      	add	r3, r1
    85a6:	ea4f 0383 	mov.w	r3, r3, lsl #2
    85aa:	4413      	add	r3, r2
    85ac:	f103 0310 	add.w	r3, r3, #16
    85b0:	781b      	ldrb	r3, [r3, #0]
    85b2:	461a      	mov	r2, r3
    85b4:	f24b 63e4 	movw	r3, #46820	; 0xb6e4
    85b8:	f2c0 0301 	movt	r3, #1
    85bc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    85c0:	89fa      	ldrh	r2, [r7, #14]
    85c2:	601a      	str	r2, [r3, #0]
    85c4:	e019      	b.n	85fa <ACE_start_sse+0xea>
        }
        else
        {
            *sse_pc_hi_lut[g_sse_sequences_desc_table[sequence].sse_pc_id] = pc - 256;
    85c6:	88f9      	ldrh	r1, [r7, #6]
    85c8:	f240 028c 	movw	r2, #140	; 0x8c
    85cc:	f2c2 0200 	movt	r2, #8192	; 0x2000
    85d0:	460b      	mov	r3, r1
    85d2:	ea4f 0383 	mov.w	r3, r3, lsl #2
    85d6:	440b      	add	r3, r1
    85d8:	ea4f 0383 	mov.w	r3, r3, lsl #2
    85dc:	4413      	add	r3, r2
    85de:	f103 0310 	add.w	r3, r3, #16
    85e2:	781b      	ldrb	r3, [r3, #0]
    85e4:	461a      	mov	r2, r3
    85e6:	f24b 63f0 	movw	r3, #46832	; 0xb6f0
    85ea:	f2c0 0301 	movt	r3, #1
    85ee:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    85f2:	89fa      	ldrh	r2, [r7, #14]
    85f4:	f5a2 7280 	sub.w	r2, r2, #256	; 0x100
    85f8:	601a      	str	r2, [r3, #0]
        }
        
        *sse_pc_ctrl_lut[g_sse_sequences_desc_table[sequence].sse_pc_id] = SSE_START;
    85fa:	88f9      	ldrh	r1, [r7, #6]
    85fc:	f240 028c 	movw	r2, #140	; 0x8c
    8600:	f2c2 0200 	movt	r2, #8192	; 0x2000
    8604:	460b      	mov	r3, r1
    8606:	ea4f 0383 	mov.w	r3, r3, lsl #2
    860a:	440b      	add	r3, r1
    860c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8610:	4413      	add	r3, r2
    8612:	f103 0310 	add.w	r3, r3, #16
    8616:	781b      	ldrb	r3, [r3, #0]
    8618:	461a      	mov	r2, r3
    861a:	f24b 63d8 	movw	r3, #46808	; 0xb6d8
    861e:	f2c0 0301 	movt	r3, #1
    8622:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    8626:	f04f 0201 	mov.w	r2, #1
    862a:	601a      	str	r2, [r3, #0]
        
        /* Enable Sample Sequencing Engine in case it was not done as part of
         * system boot. */
        ACE->SSE_TS_CTRL |= TS_ENABLE_MASK;
    862c:	f240 0300 	movw	r3, #0
    8630:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8634:	f240 0200 	movw	r2, #0
    8638:	f2c4 0202 	movt	r2, #16386	; 0x4002
    863c:	6852      	ldr	r2, [r2, #4]
    863e:	f042 0201 	orr.w	r2, r2, #1
    8642:	605a      	str	r2, [r3, #4]
    }
}
    8644:	f107 0714 	add.w	r7, r7, #20
    8648:	46bd      	mov	sp, r7
    864a:	bc80      	pop	{r7}
    864c:	4770      	bx	lr
    864e:	bf00      	nop

00008650 <ACE_restart_sse>:
 */
void ACE_restart_sse
(
    sse_sequence_handle_t  sequence
)
{
    8650:	b480      	push	{r7}
    8652:	b085      	sub	sp, #20
    8654:	af00      	add	r7, sp, #0
    8656:	4603      	mov	r3, r0
    8658:	80fb      	strh	r3, [r7, #6]
    ASSERT( sequence < ACE_NB_OF_SSE_PROCEDURES );
    865a:	88fb      	ldrh	r3, [r7, #6]
    865c:	2b01      	cmp	r3, #1
    865e:	d900      	bls.n	8662 <ACE_restart_sse+0x12>
    8660:	be00      	bkpt	0x0000
    ASSERT( g_sse_sequences_desc_table[sequence].sse_pc_id < NB_OF_ANALOG_BLOCKS );
    8662:	88f9      	ldrh	r1, [r7, #6]
    8664:	f240 028c 	movw	r2, #140	; 0x8c
    8668:	f2c2 0200 	movt	r2, #8192	; 0x2000
    866c:	460b      	mov	r3, r1
    866e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8672:	440b      	add	r3, r1
    8674:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8678:	4413      	add	r3, r2
    867a:	f103 0310 	add.w	r3, r3, #16
    867e:	781b      	ldrb	r3, [r3, #0]
    8680:	2b02      	cmp	r3, #2
    8682:	d900      	bls.n	8686 <ACE_restart_sse+0x36>
    8684:	be00      	bkpt	0x0000
    ASSERT( g_sse_sequences_desc_table[sequence].sse_load_offset < SEE_RAM_WORD_SIZE );
    8686:	88f9      	ldrh	r1, [r7, #6]
    8688:	f240 028c 	movw	r2, #140	; 0x8c
    868c:	f2c2 0200 	movt	r2, #8192	; 0x2000
    8690:	460b      	mov	r3, r1
    8692:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8696:	440b      	add	r3, r1
    8698:	ea4f 0383 	mov.w	r3, r3, lsl #2
    869c:	4413      	add	r3, r2
    869e:	88da      	ldrh	r2, [r3, #6]
    86a0:	f240 13ff 	movw	r3, #511	; 0x1ff
    86a4:	429a      	cmp	r2, r3
    86a6:	d900      	bls.n	86aa <ACE_restart_sse+0x5a>
    86a8:	be00      	bkpt	0x0000
    
    if ( sequence < (sse_sequence_handle_t)ACE_NB_OF_SSE_PROCEDURES )
    86aa:	88fb      	ldrh	r3, [r7, #6]
    86ac:	2b01      	cmp	r3, #1
    86ae:	d85c      	bhi.n	876a <ACE_restart_sse+0x11a>
    {
        uint16_t pc;
        
        pc = g_sse_sequences_desc_table[sequence].sse_loop_pc;
    86b0:	88f9      	ldrh	r1, [r7, #6]
    86b2:	f240 028c 	movw	r2, #140	; 0x8c
    86b6:	f2c2 0200 	movt	r2, #8192	; 0x2000
    86ba:	460b      	mov	r3, r1
    86bc:	ea4f 0383 	mov.w	r3, r3, lsl #2
    86c0:	440b      	add	r3, r1
    86c2:	ea4f 0383 	mov.w	r3, r3, lsl #2
    86c6:	4413      	add	r3, r2
    86c8:	889b      	ldrh	r3, [r3, #4]
    86ca:	81fb      	strh	r3, [r7, #14]
        
        if ( pc < 256u )
    86cc:	89fb      	ldrh	r3, [r7, #14]
    86ce:	2bff      	cmp	r3, #255	; 0xff
    86d0:	d818      	bhi.n	8704 <ACE_restart_sse+0xb4>
        {
            *sse_pc_lo_lut[g_sse_sequences_desc_table[sequence].sse_pc_id] = pc;
    86d2:	88f9      	ldrh	r1, [r7, #6]
    86d4:	f240 028c 	movw	r2, #140	; 0x8c
    86d8:	f2c2 0200 	movt	r2, #8192	; 0x2000
    86dc:	460b      	mov	r3, r1
    86de:	ea4f 0383 	mov.w	r3, r3, lsl #2
    86e2:	440b      	add	r3, r1
    86e4:	ea4f 0383 	mov.w	r3, r3, lsl #2
    86e8:	4413      	add	r3, r2
    86ea:	f103 0310 	add.w	r3, r3, #16
    86ee:	781b      	ldrb	r3, [r3, #0]
    86f0:	461a      	mov	r2, r3
    86f2:	f24b 63e4 	movw	r3, #46820	; 0xb6e4
    86f6:	f2c0 0301 	movt	r3, #1
    86fa:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    86fe:	89fa      	ldrh	r2, [r7, #14]
    8700:	601a      	str	r2, [r3, #0]
    8702:	e019      	b.n	8738 <ACE_restart_sse+0xe8>
        }
        else
        {
            *sse_pc_hi_lut[g_sse_sequences_desc_table[sequence].sse_pc_id] = pc - 256;
    8704:	88f9      	ldrh	r1, [r7, #6]
    8706:	f240 028c 	movw	r2, #140	; 0x8c
    870a:	f2c2 0200 	movt	r2, #8192	; 0x2000
    870e:	460b      	mov	r3, r1
    8710:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8714:	440b      	add	r3, r1
    8716:	ea4f 0383 	mov.w	r3, r3, lsl #2
    871a:	4413      	add	r3, r2
    871c:	f103 0310 	add.w	r3, r3, #16
    8720:	781b      	ldrb	r3, [r3, #0]
    8722:	461a      	mov	r2, r3
    8724:	f24b 63f0 	movw	r3, #46832	; 0xb6f0
    8728:	f2c0 0301 	movt	r3, #1
    872c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    8730:	89fa      	ldrh	r2, [r7, #14]
    8732:	f5a2 7280 	sub.w	r2, r2, #256	; 0x100
    8736:	601a      	str	r2, [r3, #0]
        }
        
        *sse_pc_ctrl_lut[g_sse_sequences_desc_table[sequence].sse_pc_id] = SSE_START;
    8738:	88f9      	ldrh	r1, [r7, #6]
    873a:	f240 028c 	movw	r2, #140	; 0x8c
    873e:	f2c2 0200 	movt	r2, #8192	; 0x2000
    8742:	460b      	mov	r3, r1
    8744:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8748:	440b      	add	r3, r1
    874a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    874e:	4413      	add	r3, r2
    8750:	f103 0310 	add.w	r3, r3, #16
    8754:	781b      	ldrb	r3, [r3, #0]
    8756:	461a      	mov	r2, r3
    8758:	f24b 63d8 	movw	r3, #46808	; 0xb6d8
    875c:	f2c0 0301 	movt	r3, #1
    8760:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    8764:	f04f 0201 	mov.w	r2, #1
    8768:	601a      	str	r2, [r3, #0]
    }
}
    876a:	f107 0714 	add.w	r7, r7, #20
    876e:	46bd      	mov	sp, r7
    8770:	bc80      	pop	{r7}
    8772:	4770      	bx	lr

00008774 <ACE_stop_sse>:
 */
void ACE_stop_sse
(
    sse_sequence_handle_t  sequence
)
{
    8774:	b480      	push	{r7}
    8776:	b083      	sub	sp, #12
    8778:	af00      	add	r7, sp, #0
    877a:	4603      	mov	r3, r0
    877c:	80fb      	strh	r3, [r7, #6]
    ASSERT( sequence < ACE_NB_OF_SSE_PROCEDURES );
    877e:	88fb      	ldrh	r3, [r7, #6]
    8780:	2b01      	cmp	r3, #1
    8782:	d900      	bls.n	8786 <ACE_stop_sse+0x12>
    8784:	be00      	bkpt	0x0000
    
    if ( sequence < (sse_sequence_handle_t)ACE_NB_OF_SSE_PROCEDURES )
    8786:	88fb      	ldrh	r3, [r7, #6]
    8788:	2b01      	cmp	r3, #1
    878a:	d818      	bhi.n	87be <ACE_stop_sse+0x4a>
    {
        /* Stop relevant program counter. */
        *sse_pc_ctrl_lut[g_sse_sequences_desc_table[sequence].sse_pc_id] = SSE_STOP;
    878c:	88f9      	ldrh	r1, [r7, #6]
    878e:	f240 028c 	movw	r2, #140	; 0x8c
    8792:	f2c2 0200 	movt	r2, #8192	; 0x2000
    8796:	460b      	mov	r3, r1
    8798:	ea4f 0383 	mov.w	r3, r3, lsl #2
    879c:	440b      	add	r3, r1
    879e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    87a2:	4413      	add	r3, r2
    87a4:	f103 0310 	add.w	r3, r3, #16
    87a8:	781b      	ldrb	r3, [r3, #0]
    87aa:	461a      	mov	r2, r3
    87ac:	f24b 63d8 	movw	r3, #46808	; 0xb6d8
    87b0:	f2c0 0301 	movt	r3, #1
    87b4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    87b8:	f04f 0200 	mov.w	r2, #0
    87bc:	601a      	str	r2, [r3, #0]
    }
}
    87be:	f107 070c 	add.w	r7, r7, #12
    87c2:	46bd      	mov	sp, r7
    87c4:	bc80      	pop	{r7}
    87c6:	4770      	bx	lr

000087c8 <ACE_resume_sse>:
 */
void ACE_resume_sse
(
    sse_sequence_handle_t  sequence
)
{
    87c8:	b480      	push	{r7}
    87ca:	b083      	sub	sp, #12
    87cc:	af00      	add	r7, sp, #0
    87ce:	4603      	mov	r3, r0
    87d0:	80fb      	strh	r3, [r7, #6]
    ASSERT( sequence < ACE_NB_OF_SSE_PROCEDURES );
    87d2:	88fb      	ldrh	r3, [r7, #6]
    87d4:	2b01      	cmp	r3, #1
    87d6:	d900      	bls.n	87da <ACE_resume_sse+0x12>
    87d8:	be00      	bkpt	0x0000
    
    if ( sequence < (sse_sequence_handle_t)ACE_NB_OF_SSE_PROCEDURES )
    87da:	88fb      	ldrh	r3, [r7, #6]
    87dc:	2b01      	cmp	r3, #1
    87de:	d818      	bhi.n	8812 <ACE_resume_sse+0x4a>
    {
        *sse_pc_ctrl_lut[g_sse_sequences_desc_table[sequence].sse_pc_id] = SSE_START;
    87e0:	88f9      	ldrh	r1, [r7, #6]
    87e2:	f240 028c 	movw	r2, #140	; 0x8c
    87e6:	f2c2 0200 	movt	r2, #8192	; 0x2000
    87ea:	460b      	mov	r3, r1
    87ec:	ea4f 0383 	mov.w	r3, r3, lsl #2
    87f0:	440b      	add	r3, r1
    87f2:	ea4f 0383 	mov.w	r3, r3, lsl #2
    87f6:	4413      	add	r3, r2
    87f8:	f103 0310 	add.w	r3, r3, #16
    87fc:	781b      	ldrb	r3, [r3, #0]
    87fe:	461a      	mov	r2, r3
    8800:	f24b 63d8 	movw	r3, #46808	; 0xb6d8
    8804:	f2c0 0301 	movt	r3, #1
    8808:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    880c:	f04f 0201 	mov.w	r2, #1
    8810:	601a      	str	r2, [r3, #0]
    }
}
    8812:	f107 070c 	add.w	r7, r7, #12
    8816:	46bd      	mov	sp, r7
    8818:	bc80      	pop	{r7}
    881a:	4770      	bx	lr

0000881c <ACE_enable_sse_irq>:
 */
void ACE_enable_sse_irq
(
	sse_irq_id_t sse_irq_id
)
{
    881c:	b480      	push	{r7}
    881e:	b083      	sub	sp, #12
    8820:	af00      	add	r7, sp, #0
    8822:	4603      	mov	r3, r0
    8824:	71fb      	strb	r3, [r7, #7]
    ASSERT( sse_irq_id < NB_OF_SSE_FLAG_IRQS );
    8826:	79fb      	ldrb	r3, [r7, #7]
    8828:	2b14      	cmp	r3, #20
    882a:	d900      	bls.n	882e <ACE_enable_sse_irq+0x12>
    882c:	be00      	bkpt	0x0000
    
    ACE->SSE_IRQ_EN |= 1uL << (uint32_t)sse_irq_id;
    882e:	f240 0300 	movw	r3, #0
    8832:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8836:	f240 0200 	movw	r2, #0
    883a:	f2c4 0202 	movt	r2, #16386	; 0x4002
    883e:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    8842:	6811      	ldr	r1, [r2, #0]
    8844:	79fa      	ldrb	r2, [r7, #7]
    8846:	f04f 0001 	mov.w	r0, #1
    884a:	fa00 f202 	lsl.w	r2, r0, r2
    884e:	ea41 0202 	orr.w	r2, r1, r2
    8852:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    8856:	601a      	str	r2, [r3, #0]
}
    8858:	f107 070c 	add.w	r7, r7, #12
    885c:	46bd      	mov	sp, r7
    885e:	bc80      	pop	{r7}
    8860:	4770      	bx	lr
    8862:	bf00      	nop

00008864 <ACE_disable_sse_irq>:
 */
void ACE_disable_sse_irq
(
	sse_irq_id_t sse_irq_id
)
{
    8864:	b480      	push	{r7}
    8866:	b085      	sub	sp, #20
    8868:	af00      	add	r7, sp, #0
    886a:	4603      	mov	r3, r0
    886c:	71fb      	strb	r3, [r7, #7]
    volatile uint32_t dummy_read;
    
    ASSERT( sse_irq_id < NB_OF_SSE_FLAG_IRQS );
    886e:	79fb      	ldrb	r3, [r7, #7]
    8870:	2b14      	cmp	r3, #20
    8872:	d900      	bls.n	8876 <ACE_disable_sse_irq+0x12>
    8874:	be00      	bkpt	0x0000
    
    ACE->SSE_IRQ_EN &= (uint32_t)~(1uL << (uint32_t)sse_irq_id);
    8876:	f240 0300 	movw	r3, #0
    887a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    887e:	f240 0200 	movw	r2, #0
    8882:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8886:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    888a:	6811      	ldr	r1, [r2, #0]
    888c:	79fa      	ldrb	r2, [r7, #7]
    888e:	f04f 0001 	mov.w	r0, #1
    8892:	fa00 f202 	lsl.w	r2, r0, r2
    8896:	ea6f 0202 	mvn.w	r2, r2
    889a:	ea01 0202 	and.w	r2, r1, r2
    889e:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    88a2:	601a      	str	r2, [r3, #0]
    /*
     * Ensure that the posted write to the SSE_IRQ_EN register completed before
     * returning from this function. Not doing this may result in the interrupt
     * only being disabled some time after this function returns.
     */
    dummy_read = ACE->SSE_IRQ_EN;
    88a4:	f240 0300 	movw	r3, #0
    88a8:	f2c4 0302 	movt	r3, #16386	; 0x4002
    88ac:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    88b0:	681b      	ldr	r3, [r3, #0]
    88b2:	60fb      	str	r3, [r7, #12]
    ++dummy_read;
    88b4:	68fb      	ldr	r3, [r7, #12]
    88b6:	f103 0301 	add.w	r3, r3, #1
    88ba:	60fb      	str	r3, [r7, #12]
}
    88bc:	f107 0714 	add.w	r7, r7, #20
    88c0:	46bd      	mov	sp, r7
    88c2:	bc80      	pop	{r7}
    88c4:	4770      	bx	lr
    88c6:	bf00      	nop

000088c8 <ACE_clear_sse_irq>:
 */
void ACE_clear_sse_irq
(
	sse_irq_id_t sse_irq_id
)
{
    88c8:	b480      	push	{r7}
    88ca:	b085      	sub	sp, #20
    88cc:	af00      	add	r7, sp, #0
    88ce:	4603      	mov	r3, r0
    88d0:	71fb      	strb	r3, [r7, #7]
    volatile uint32_t dummy_read;
    
    ASSERT( sse_irq_id < NB_OF_SSE_FLAG_IRQS );
    88d2:	79fb      	ldrb	r3, [r7, #7]
    88d4:	2b14      	cmp	r3, #20
    88d6:	d900      	bls.n	88da <ACE_clear_sse_irq+0x12>
    88d8:	be00      	bkpt	0x0000
    
    ACE->SSE_IRQ_CLR |= 1uL << (uint32_t)sse_irq_id;
    88da:	f240 0300 	movw	r3, #0
    88de:	f2c4 0302 	movt	r3, #16386	; 0x4002
    88e2:	f240 0200 	movw	r2, #0
    88e6:	f2c4 0202 	movt	r2, #16386	; 0x4002
    88ea:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    88ee:	f102 0208 	add.w	r2, r2, #8
    88f2:	6811      	ldr	r1, [r2, #0]
    88f4:	79fa      	ldrb	r2, [r7, #7]
    88f6:	f04f 0001 	mov.w	r0, #1
    88fa:	fa00 f202 	lsl.w	r2, r0, r2
    88fe:	ea41 0202 	orr.w	r2, r1, r2
    8902:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    8906:	f103 0308 	add.w	r3, r3, #8
    890a:	601a      	str	r2, [r3, #0]
     * Ensure that the posted write to the SSE_IRQ_CLR register completed before
     * returning from this function. Not doing this may result in the interrupt
     * retriggering if the Cortex-M3 returns from interrupt before the posted
     * write completes.
     */
    dummy_read = ACE->SSE_IRQ_CLR;
    890c:	f240 0300 	movw	r3, #0
    8910:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8914:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    8918:	f103 0308 	add.w	r3, r3, #8
    891c:	681b      	ldr	r3, [r3, #0]
    891e:	60fb      	str	r3, [r7, #12]
    ++dummy_read;
    8920:	68fb      	ldr	r3, [r7, #12]
    8922:	f103 0301 	add.w	r3, r3, #1
    8926:	60fb      	str	r3, [r7, #12]
}
    8928:	f107 0714 	add.w	r7, r7, #20
    892c:	46bd      	mov	sp, r7
    892e:	bc80      	pop	{r7}
    8930:	4770      	bx	lr
    8932:	bf00      	nop

00008934 <ACE_clear_sample_pipeline>:

/*-------------------------------------------------------------------------*//**
 *
 */
void ACE_clear_sample_pipeline(void)
{
    8934:	b480      	push	{r7}
    8936:	b083      	sub	sp, #12
    8938:	af00      	add	r7, sp, #0
    uint32_t saved_sse_ctrl;
    uint32_t saved_ppe_ctrl;
    
    /* Pause the Sample Sequencing Engine. */
    saved_sse_ctrl = ACE->SSE_TS_CTRL;
    893a:	f240 0300 	movw	r3, #0
    893e:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8942:	685b      	ldr	r3, [r3, #4]
    8944:	603b      	str	r3, [r7, #0]
    ACE->SSE_TS_CTRL = ACE->SSE_TS_CTRL & ~((uint32_t)TS_ENABLE_MASK);
    8946:	f240 0300 	movw	r3, #0
    894a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    894e:	f240 0200 	movw	r2, #0
    8952:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8956:	6852      	ldr	r2, [r2, #4]
    8958:	f022 0201 	bic.w	r2, r2, #1
    895c:	605a      	str	r2, [r3, #4]
    
    /* Pause the Post Processing Engine. */
    saved_ppe_ctrl = ACE->PPE_CTRL;
    895e:	f240 0300 	movw	r3, #0
    8962:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8966:	f503 53a0 	add.w	r3, r3, #5120	; 0x1400
    896a:	f103 0304 	add.w	r3, r3, #4
    896e:	681b      	ldr	r3, [r3, #0]
    8970:	607b      	str	r3, [r7, #4]
    ACE->PPE_CTRL = ACE->PPE_CTRL & ~((uint32_t)PPE_ENABLE_MASK);
    8972:	f240 0300 	movw	r3, #0
    8976:	f2c4 0302 	movt	r3, #16386	; 0x4002
    897a:	f240 0200 	movw	r2, #0
    897e:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8982:	f502 52a0 	add.w	r2, r2, #5120	; 0x1400
    8986:	f102 0204 	add.w	r2, r2, #4
    898a:	6812      	ldr	r2, [r2, #0]
    898c:	f022 0201 	bic.w	r2, r2, #1
    8990:	f503 53a0 	add.w	r3, r3, #5120	; 0x1400
    8994:	f103 0304 	add.w	r3, r3, #4
    8998:	601a      	str	r2, [r3, #0]
    
    /* Reset the ADCs */
    ACE->ADC0_MISC_CTRL |= ADC_RESET_MASK;
    899a:	f240 0300 	movw	r3, #0
    899e:	f2c4 0302 	movt	r3, #16386	; 0x4002
    89a2:	f240 0200 	movw	r2, #0
    89a6:	f2c4 0202 	movt	r2, #16386	; 0x4002
    89aa:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
    89ac:	f042 0210 	orr.w	r2, r2, #16
    89b0:	65da      	str	r2, [r3, #92]	; 0x5c
    ACE->ADC1_MISC_CTRL |= ADC_RESET_MASK;
    89b2:	f240 0300 	movw	r3, #0
    89b6:	f2c4 0302 	movt	r3, #16386	; 0x4002
    89ba:	f240 0200 	movw	r2, #0
    89be:	f2c4 0202 	movt	r2, #16386	; 0x4002
    89c2:	f8d2 209c 	ldr.w	r2, [r2, #156]	; 0x9c
    89c6:	f042 0210 	orr.w	r2, r2, #16
    89ca:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
    ACE->ADC2_MISC_CTRL |= ADC_RESET_MASK;
    89ce:	f240 0300 	movw	r3, #0
    89d2:	f2c4 0302 	movt	r3, #16386	; 0x4002
    89d6:	f240 0200 	movw	r2, #0
    89da:	f2c4 0202 	movt	r2, #16386	; 0x4002
    89de:	f8d2 20dc 	ldr.w	r2, [r2, #220]	; 0xdc
    89e2:	f042 0210 	orr.w	r2, r2, #16
    89e6:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
    
    /* Clear ADC FIFOs */
    ACE->ADC0_FIFO_CTRL |= ADC_FIFO_CLR_MASK;
    89ea:	f240 0300 	movw	r3, #0
    89ee:	f2c4 0302 	movt	r3, #16386	; 0x4002
    89f2:	f240 0200 	movw	r2, #0
    89f6:	f2c4 0202 	movt	r2, #16386	; 0x4002
    89fa:	f502 52a4 	add.w	r2, r2, #5248	; 0x1480
    89fe:	f102 0210 	add.w	r2, r2, #16
    8a02:	6812      	ldr	r2, [r2, #0]
    8a04:	f042 0204 	orr.w	r2, r2, #4
    8a08:	f503 53a4 	add.w	r3, r3, #5248	; 0x1480
    8a0c:	f103 0310 	add.w	r3, r3, #16
    8a10:	601a      	str	r2, [r3, #0]
    ACE->ADC1_FIFO_CTRL |= ADC_FIFO_CLR_MASK;
    8a12:	f240 0300 	movw	r3, #0
    8a16:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8a1a:	f240 0200 	movw	r2, #0
    8a1e:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8a22:	f502 52a4 	add.w	r2, r2, #5248	; 0x1480
    8a26:	f102 021c 	add.w	r2, r2, #28
    8a2a:	6812      	ldr	r2, [r2, #0]
    8a2c:	f042 0204 	orr.w	r2, r2, #4
    8a30:	f503 53a4 	add.w	r3, r3, #5248	; 0x1480
    8a34:	f103 031c 	add.w	r3, r3, #28
    8a38:	601a      	str	r2, [r3, #0]
    ACE->ADC2_FIFO_CTRL |= ADC_FIFO_CLR_MASK;
    8a3a:	f240 0300 	movw	r3, #0
    8a3e:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8a42:	f240 0200 	movw	r2, #0
    8a46:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8a4a:	f502 52a4 	add.w	r2, r2, #5248	; 0x1480
    8a4e:	f102 0228 	add.w	r2, r2, #40	; 0x28
    8a52:	6812      	ldr	r2, [r2, #0]
    8a54:	f042 0204 	orr.w	r2, r2, #4
    8a58:	f503 53a4 	add.w	r3, r3, #5248	; 0x1480
    8a5c:	f103 0328 	add.w	r3, r3, #40	; 0x28
    8a60:	601a      	str	r2, [r3, #0]
    
    /* clear DMA FIFOs */
    ACE->PPE_PDMA_CTRL |= PDMA_DATAOUT_CLR_MASK;
    8a62:	f240 0300 	movw	r3, #0
    8a66:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8a6a:	f240 0200 	movw	r2, #0
    8a6e:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8a72:	f502 5298 	add.w	r2, r2, #4864	; 0x1300
    8a76:	6812      	ldr	r2, [r2, #0]
    8a78:	f042 0204 	orr.w	r2, r2, #4
    8a7c:	f503 5398 	add.w	r3, r3, #4864	; 0x1300
    8a80:	601a      	str	r2, [r3, #0]
    
    /* Unpause the Post Processing Engine. */
    ACE->PPE_CTRL = saved_ppe_ctrl;
    8a82:	f240 0300 	movw	r3, #0
    8a86:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8a8a:	f503 53a0 	add.w	r3, r3, #5120	; 0x1400
    8a8e:	f103 0304 	add.w	r3, r3, #4
    8a92:	687a      	ldr	r2, [r7, #4]
    8a94:	601a      	str	r2, [r3, #0]
    
    /* Unpause the Sample Sequencing Engine. */
    ACE->SSE_TS_CTRL = saved_sse_ctrl;
    8a96:	f240 0300 	movw	r3, #0
    8a9a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8a9e:	683a      	ldr	r2, [r7, #0]
    8aa0:	605a      	str	r2, [r3, #4]
}
    8aa2:	f107 070c 	add.w	r7, r7, #12
    8aa6:	46bd      	mov	sp, r7
    8aa8:	bc80      	pop	{r7}
    8aaa:	4770      	bx	lr

00008aac <ACE_get_default_m_factor>:
 */
int16_t ACE_get_default_m_factor
(
    ace_channel_handle_t channel_handle
)
{
    8aac:	b480      	push	{r7}
    8aae:	b083      	sub	sp, #12
    8ab0:	af00      	add	r7, sp, #0
    8ab2:	4603      	mov	r3, r0
    8ab4:	71fb      	strb	r3, [r7, #7]
    ASSERT( channel_handle < NB_OF_ACE_CHANNEL_HANDLES );
    8ab6:	79fb      	ldrb	r3, [r7, #7]
    8ab8:	2b02      	cmp	r3, #2
    8aba:	d900      	bls.n	8abe <ACE_get_default_m_factor+0x12>
    8abc:	be00      	bkpt	0x0000
    
    return g_ace_ppe_transforms_desc_table[channel_handle].m_ppe_offset;
    8abe:	79fa      	ldrb	r2, [r7, #7]
    8ac0:	f64a 7394 	movw	r3, #44948	; 0xaf94
    8ac4:	f2c0 0301 	movt	r3, #1
    8ac8:	f833 3032 	ldrh.w	r3, [r3, r2, lsl #3]
    8acc:	b21b      	sxth	r3, r3
}
    8ace:	4618      	mov	r0, r3
    8ad0:	f107 070c 	add.w	r7, r7, #12
    8ad4:	46bd      	mov	sp, r7
    8ad6:	bc80      	pop	{r7}
    8ad8:	4770      	bx	lr
    8ada:	bf00      	nop

00008adc <ACE_get_default_c_offset>:
 */
int16_t ACE_get_default_c_offset
(
    ace_channel_handle_t channel_handle
)
{
    8adc:	b480      	push	{r7}
    8ade:	b083      	sub	sp, #12
    8ae0:	af00      	add	r7, sp, #0
    8ae2:	4603      	mov	r3, r0
    8ae4:	71fb      	strb	r3, [r7, #7]
    ASSERT( channel_handle < NB_OF_ACE_CHANNEL_HANDLES );
    8ae6:	79fb      	ldrb	r3, [r7, #7]
    8ae8:	2b02      	cmp	r3, #2
    8aea:	d900      	bls.n	8aee <ACE_get_default_c_offset+0x12>
    8aec:	be00      	bkpt	0x0000
    
    return g_ace_ppe_transforms_desc_table[channel_handle].c_ppe_offset;
    8aee:	79fb      	ldrb	r3, [r7, #7]
    8af0:	f64a 7294 	movw	r2, #44948	; 0xaf94
    8af4:	f2c0 0201 	movt	r2, #1
    8af8:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    8afc:	4413      	add	r3, r2
    8afe:	885b      	ldrh	r3, [r3, #2]
    8b00:	b21b      	sxth	r3, r3
}
    8b02:	4618      	mov	r0, r3
    8b04:	f107 070c 	add.w	r7, r7, #12
    8b08:	46bd      	mov	sp, r7
    8b0a:	bc80      	pop	{r7}
    8b0c:	4770      	bx	lr
    8b0e:	bf00      	nop

00008b10 <ACE_set_linear_transform>:
(
    ace_channel_handle_t channel_handle,
	int16_t m2,
	int16_t c2
)
{
    8b10:	b5b0      	push	{r4, r5, r7, lr}
    8b12:	b092      	sub	sp, #72	; 0x48
    8b14:	af00      	add	r7, sp, #0
    8b16:	4613      	mov	r3, r2
    8b18:	4602      	mov	r2, r0
    8b1a:	71fa      	strb	r2, [r7, #7]
    8b1c:	460a      	mov	r2, r1
    8b1e:	80ba      	strh	r2, [r7, #4]
    8b20:	807b      	strh	r3, [r7, #2]
    int64_t c64_2;
    uint16_t m1;
    uint16_t c1;
    uint16_t mext;
    
    channel_calibration_t calibration = {0x4000u, 0x4000u, 0x0000u};
    8b22:	f24b 7250 	movw	r2, #46928	; 0xb750
    8b26:	f2c0 0201 	movt	r2, #1
    8b2a:	f107 030c 	add.w	r3, r7, #12
    8b2e:	e892 0003 	ldmia.w	r2, {r0, r1}
    8b32:	6018      	str	r0, [r3, #0]
    8b34:	f103 0304 	add.w	r3, r3, #4
    8b38:	8019      	strh	r1, [r3, #0]
    
    ASSERT( channel_handle < NB_OF_ACE_CHANNEL_HANDLES );
    8b3a:	79fb      	ldrb	r3, [r7, #7]
    8b3c:	2b02      	cmp	r3, #2
    8b3e:	d900      	bls.n	8b42 <ACE_set_linear_transform+0x32>
    8b40:	be00      	bkpt	0x0000
    
    if(channel_handle < NB_OF_ACE_CHANNEL_HANDLES)
    8b42:	79fb      	ldrb	r3, [r7, #7]
    8b44:	2b02      	cmp	r3, #2
    8b46:	f200 809d 	bhi.w	8c84 <ACE_set_linear_transform+0x174>
    {
        channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    8b4a:	79fa      	ldrb	r2, [r7, #7]
    8b4c:	f240 035c 	movw	r3, #92	; 0x5c
    8b50:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8b54:	ea4f 1202 	mov.w	r2, r2, lsl #4
    8b58:	4413      	add	r3, r2
    8b5a:	791b      	ldrb	r3, [r3, #4]
    8b5c:	74fb      	strb	r3, [r7, #19]
        
        get_calibration(channel_id, &calibration);
    8b5e:	7cfa      	ldrb	r2, [r7, #19]
    8b60:	f107 030c 	add.w	r3, r7, #12
    8b64:	4610      	mov	r0, r2
    8b66:	4619      	mov	r1, r3
    8b68:	f000 f928 	bl	8dbc <get_calibration>
        
        m1 = calibration.m1;
    8b6c:	89fb      	ldrh	r3, [r7, #14]
    8b6e:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
        c1 = calibration.c1;
    8b72:	8a3b      	ldrh	r3, [r7, #16]
    8b74:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
        
        mext = calibration.mext;
    8b78:	89bb      	ldrh	r3, [r7, #12]
    8b7a:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46

        /* 
         * m = m2 * m1 * mext
         */
        m32 = extend_sign(m2) * extend_sign(m1);
    8b7e:	88bb      	ldrh	r3, [r7, #4]
    8b80:	4618      	mov	r0, r3
    8b82:	f000 f883 	bl	8c8c <extend_sign>
    8b86:	4604      	mov	r4, r0
    8b88:	f8b7 3042 	ldrh.w	r3, [r7, #66]	; 0x42
    8b8c:	4618      	mov	r0, r3
    8b8e:	f000 f87d 	bl	8c8c <extend_sign>
    8b92:	4603      	mov	r3, r0
    8b94:	fb03 f304 	mul.w	r3, r3, r4
    8b98:	61fb      	str	r3, [r7, #28]
        m64 = (int64_t)m32 * extend_sign(mext);
    8b9a:	69fb      	ldr	r3, [r7, #28]
    8b9c:	461c      	mov	r4, r3
    8b9e:	ea4f 75e4 	mov.w	r5, r4, asr #31
    8ba2:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
    8ba6:	4618      	mov	r0, r3
    8ba8:	f000 f870 	bl	8c8c <extend_sign>
    8bac:	4603      	mov	r3, r0
    8bae:	461a      	mov	r2, r3
    8bb0:	ea4f 73e2 	mov.w	r3, r2, asr #31
    8bb4:	fb02 f105 	mul.w	r1, r2, r5
    8bb8:	fb04 f003 	mul.w	r0, r4, r3
    8bbc:	4401      	add	r1, r0
    8bbe:	fba4 2302 	umull	r2, r3, r4, r2
    8bc2:	4419      	add	r1, r3
    8bc4:	460b      	mov	r3, r1
    8bc6:	e9c7 2308 	strd	r2, r3, [r7, #32]
    8bca:	e9c7 2308 	strd	r2, r3, [r7, #32]
        
        /* Convert 48-bit result to 32-bit ACE format result. */
        m = adjust_to_16bit_ace_format(m64);
    8bce:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
    8bd2:	f000 f8b3 	bl	8d3c <adjust_to_16bit_ace_format>
    8bd6:	4603      	mov	r3, r0
    8bd8:	617b      	str	r3, [r7, #20]

        /*
         * c = (m2 * c1 * mext) + (c2 * mext)
         */
        c32 = extend_sign(m2) * extend_sign(c1);
    8bda:	88bb      	ldrh	r3, [r7, #4]
    8bdc:	4618      	mov	r0, r3
    8bde:	f000 f855 	bl	8c8c <extend_sign>
    8be2:	4604      	mov	r4, r0
    8be4:	f8b7 3044 	ldrh.w	r3, [r7, #68]	; 0x44
    8be8:	4618      	mov	r0, r3
    8bea:	f000 f84f 	bl	8c8c <extend_sign>
    8bee:	4603      	mov	r3, r0
    8bf0:	fb03 f304 	mul.w	r3, r3, r4
    8bf4:	62fb      	str	r3, [r7, #44]	; 0x2c
        c64_1 = (int64_t)c32 * extend_sign(mext);
    8bf6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8bf8:	461c      	mov	r4, r3
    8bfa:	ea4f 75e4 	mov.w	r5, r4, asr #31
    8bfe:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
    8c02:	4618      	mov	r0, r3
    8c04:	f000 f842 	bl	8c8c <extend_sign>
    8c08:	4603      	mov	r3, r0
    8c0a:	461a      	mov	r2, r3
    8c0c:	ea4f 73e2 	mov.w	r3, r2, asr #31
    8c10:	fb02 f105 	mul.w	r1, r2, r5
    8c14:	fb04 f003 	mul.w	r0, r4, r3
    8c18:	4401      	add	r1, r0
    8c1a:	fba4 2302 	umull	r2, r3, r4, r2
    8c1e:	4419      	add	r1, r3
    8c20:	460b      	mov	r3, r1
    8c22:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
    8c26:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30

        c64_2 = ((int64_t)(extend_sign(c2) * extend_sign(mext))) << 14;
    8c2a:	887b      	ldrh	r3, [r7, #2]
    8c2c:	4618      	mov	r0, r3
    8c2e:	f000 f82d 	bl	8c8c <extend_sign>
    8c32:	4604      	mov	r4, r0
    8c34:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
    8c38:	4618      	mov	r0, r3
    8c3a:	f000 f827 	bl	8c8c <extend_sign>
    8c3e:	4603      	mov	r3, r0
    8c40:	fb03 f304 	mul.w	r3, r3, r4
    8c44:	461a      	mov	r2, r3
    8c46:	ea4f 73e2 	mov.w	r3, r2, asr #31
    8c4a:	ea4f 4192 	mov.w	r1, r2, lsr #18
    8c4e:	ea4f 3083 	mov.w	r0, r3, lsl #14
    8c52:	ea40 0101 	orr.w	r1, r0, r1
    8c56:	63f9      	str	r1, [r7, #60]	; 0x3c
    8c58:	ea4f 3382 	mov.w	r3, r2, lsl #14
    8c5c:	63bb      	str	r3, [r7, #56]	; 0x38
        
        c = adjust_to_24bit_ace_format(c64_1 + c64_2);
    8c5e:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
    8c62:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
    8c66:	1812      	adds	r2, r2, r0
    8c68:	eb43 0301 	adc.w	r3, r3, r1
    8c6c:	4610      	mov	r0, r2
    8c6e:	4619      	mov	r1, r3
    8c70:	f000 f824 	bl	8cbc <adjust_to_24bit_ace_format>
    8c74:	4603      	mov	r3, r0
    8c76:	61bb      	str	r3, [r7, #24]
        
        write_transform_coefficients(channel_handle, m, c);
    8c78:	79fb      	ldrb	r3, [r7, #7]
    8c7a:	4618      	mov	r0, r3
    8c7c:	6979      	ldr	r1, [r7, #20]
    8c7e:	69ba      	ldr	r2, [r7, #24]
    8c80:	f000 fa5c 	bl	913c <write_transform_coefficients>
    }
}
    8c84:	f107 0748 	add.w	r7, r7, #72	; 0x48
    8c88:	46bd      	mov	sp, r7
    8c8a:	bdb0      	pop	{r4, r5, r7, pc}

00008c8c <extend_sign>:
 */
int32_t extend_sign
(
    uint16_t x
)
{
    8c8c:	b480      	push	{r7}
    8c8e:	b085      	sub	sp, #20
    8c90:	af00      	add	r7, sp, #0
    8c92:	4603      	mov	r3, r0
    8c94:	80fb      	strh	r3, [r7, #6]
    int32_t y;
    const uint32_t sign_bit_mask = 0x00008000u;
    8c96:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    8c9a:	60fb      	str	r3, [r7, #12]
    
    y = (x ^ sign_bit_mask) - sign_bit_mask;
    8c9c:	88fa      	ldrh	r2, [r7, #6]
    8c9e:	68fb      	ldr	r3, [r7, #12]
    8ca0:	ea82 0203 	eor.w	r2, r2, r3
    8ca4:	68fb      	ldr	r3, [r7, #12]
    8ca6:	ebc3 0302 	rsb	r3, r3, r2
    8caa:	60bb      	str	r3, [r7, #8]
    
    return y;
    8cac:	68bb      	ldr	r3, [r7, #8]
}
    8cae:	4618      	mov	r0, r3
    8cb0:	f107 0714 	add.w	r7, r7, #20
    8cb4:	46bd      	mov	sp, r7
    8cb6:	bc80      	pop	{r7}
    8cb8:	4770      	bx	lr
    8cba:	bf00      	nop

00008cbc <adjust_to_24bit_ace_format>:
 */
uint32_t adjust_to_24bit_ace_format
(
    int64_t signed48
)
{
    8cbc:	b4b0      	push	{r4, r5, r7}
    8cbe:	b089      	sub	sp, #36	; 0x24
    8cc0:	af00      	add	r7, sp, #0
    8cc2:	e9c7 0100 	strd	r0, r1, [r7]
    int32_t ace24_format;
    const int64_t MAX_POSITIVE = 0x00001FFFFFFFFFFFuLL; /* +7.9999 */
    8cc6:	f04f 30ff 	mov.w	r0, #4294967295
    8cca:	f641 71ff 	movw	r1, #8191	; 0x1fff
    8cce:	e9c7 0104 	strd	r0, r1, [r7, #16]
    const int64_t MIN_NEGATIVE = 0xFFFF200000000000uLL; /* -8 */
    8cd2:	f04f 0000 	mov.w	r0, #0
    8cd6:	f04f 4110 	mov.w	r1, #2415919104	; 0x90000000
    8cda:	ea4f 31e1 	mov.w	r1, r1, asr #15
    8cde:	e9c7 0106 	strd	r0, r1, [r7, #24]
    
    /* Check saturation. */
    if(signed48 > MAX_POSITIVE)
    8ce2:	e9d7 0100 	ldrd	r0, r1, [r7]
    8ce6:	e9d7 4504 	ldrd	r4, r5, [r7, #16]
    8cea:	4284      	cmp	r4, r0
    8cec:	eb75 0c01 	sbcs.w	ip, r5, r1
    8cf0:	da04      	bge.n	8cfc <adjust_to_24bit_ace_format+0x40>
    {
        signed48 = MAX_POSITIVE;
    8cf2:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
    8cf6:	e9c7 0100 	strd	r0, r1, [r7]
    8cfa:	e00b      	b.n	8d14 <adjust_to_24bit_ace_format+0x58>
    }
    else if(signed48 < MIN_NEGATIVE)
    8cfc:	e9d7 4500 	ldrd	r4, r5, [r7]
    8d00:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
    8d04:	4284      	cmp	r4, r0
    8d06:	eb75 0c01 	sbcs.w	ip, r5, r1
    8d0a:	da03      	bge.n	8d14 <adjust_to_24bit_ace_format+0x58>
    {
        signed48 = MIN_NEGATIVE;
    8d0c:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
    8d10:	e9c7 0100 	strd	r0, r1, [r7]
    }
    
    /* Adjust to 24-bit ACE format. */
    ace24_format = (uint32_t)(signed48 >> 14);
    8d14:	6879      	ldr	r1, [r7, #4]
    8d16:	ea4f 4181 	mov.w	r1, r1, lsl #18
    8d1a:	6838      	ldr	r0, [r7, #0]
    8d1c:	ea4f 3290 	mov.w	r2, r0, lsr #14
    8d20:	ea41 0202 	orr.w	r2, r1, r2
    8d24:	6879      	ldr	r1, [r7, #4]
    8d26:	ea4f 33a1 	mov.w	r3, r1, asr #14
    8d2a:	4613      	mov	r3, r2
    8d2c:	60fb      	str	r3, [r7, #12]
    
    return ace24_format;
    8d2e:	68fb      	ldr	r3, [r7, #12]
}
    8d30:	4618      	mov	r0, r3
    8d32:	f107 0724 	add.w	r7, r7, #36	; 0x24
    8d36:	46bd      	mov	sp, r7
    8d38:	bcb0      	pop	{r4, r5, r7}
    8d3a:	4770      	bx	lr

00008d3c <adjust_to_16bit_ace_format>:
 */
uint32_t adjust_to_16bit_ace_format
(
    int64_t signed48
)
{
    8d3c:	b4b0      	push	{r4, r5, r7}
    8d3e:	b089      	sub	sp, #36	; 0x24
    8d40:	af00      	add	r7, sp, #0
    8d42:	e9c7 0100 	strd	r0, r1, [r7]
    int32_t ace24_format;
    const int64_t MAX_POSITIVE = 0x00001FFFFFFFFFFFuLL; /* +7.9999 */
    8d46:	f04f 30ff 	mov.w	r0, #4294967295
    8d4a:	f641 71ff 	movw	r1, #8191	; 0x1fff
    8d4e:	e9c7 0104 	strd	r0, r1, [r7, #16]
    const int64_t MIN_NEGATIVE = 0xFFFF200000000000uLL; /* -8 */
    8d52:	f04f 0000 	mov.w	r0, #0
    8d56:	f04f 4110 	mov.w	r1, #2415919104	; 0x90000000
    8d5a:	ea4f 31e1 	mov.w	r1, r1, asr #15
    8d5e:	e9c7 0106 	strd	r0, r1, [r7, #24]
    
    /* Check saturation. */
    if(signed48 > MAX_POSITIVE)
    8d62:	e9d7 0100 	ldrd	r0, r1, [r7]
    8d66:	e9d7 4504 	ldrd	r4, r5, [r7, #16]
    8d6a:	4284      	cmp	r4, r0
    8d6c:	eb75 0c01 	sbcs.w	ip, r5, r1
    8d70:	da04      	bge.n	8d7c <adjust_to_16bit_ace_format+0x40>
    {
        signed48 = MAX_POSITIVE;
    8d72:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
    8d76:	e9c7 0100 	strd	r0, r1, [r7]
    8d7a:	e00b      	b.n	8d94 <adjust_to_16bit_ace_format+0x58>
    }
    else if(signed48 < MIN_NEGATIVE)
    8d7c:	e9d7 4500 	ldrd	r4, r5, [r7]
    8d80:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
    8d84:	4284      	cmp	r4, r0
    8d86:	eb75 0c01 	sbcs.w	ip, r5, r1
    8d8a:	da03      	bge.n	8d94 <adjust_to_16bit_ace_format+0x58>
    {
        signed48 = MIN_NEGATIVE;
    8d8c:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
    8d90:	e9c7 0100 	strd	r0, r1, [r7]
    }
    
    /* Adjust to 24-bit ACE format. */
    ace24_format = (uint32_t)(signed48 >> 20);
    8d94:	6879      	ldr	r1, [r7, #4]
    8d96:	ea4f 3101 	mov.w	r1, r1, lsl #12
    8d9a:	6838      	ldr	r0, [r7, #0]
    8d9c:	ea4f 5210 	mov.w	r2, r0, lsr #20
    8da0:	ea41 0202 	orr.w	r2, r1, r2
    8da4:	6879      	ldr	r1, [r7, #4]
    8da6:	ea4f 5321 	mov.w	r3, r1, asr #20
    8daa:	4613      	mov	r3, r2
    8dac:	60fb      	str	r3, [r7, #12]
    
    return ace24_format;
    8dae:	68fb      	ldr	r3, [r7, #12]
}
    8db0:	4618      	mov	r0, r3
    8db2:	f107 0724 	add.w	r7, r7, #36	; 0x24
    8db6:	46bd      	mov	sp, r7
    8db8:	bcb0      	pop	{r4, r5, r7}
    8dba:	4770      	bx	lr

00008dbc <get_calibration>:
void get_calibration
(
    adc_channel_id_t channel_id,
    channel_calibration_t * p_calibration
)
{
    8dbc:	b490      	push	{r4, r7}
    8dbe:	b0a4      	sub	sp, #144	; 0x90
    8dc0:	af00      	add	r7, sp, #0
    8dc2:	4603      	mov	r3, r0
    8dc4:	6039      	str	r1, [r7, #0]
    8dc6:	71fb      	strb	r3, [r7, #7]
    const uint32_t channel_mask = 0x0000000F;
    8dc8:	f04f 030f 	mov.w	r3, #15
    8dcc:	65bb      	str	r3, [r7, #88]	; 0x58
    const uint32_t CMB_MUX_SEL_MASK = 0x01;
    8dce:	f04f 0301 	mov.w	r3, #1
    8dd2:	65fb      	str	r3, [r7, #92]	; 0x5c
    const uint32_t TMB_MUX_SEL_MASK = 0x01;
    8dd4:	f04f 0301 	mov.w	r3, #1
    8dd8:	663b      	str	r3, [r7, #96]	; 0x60
        DIRECT_ADC_INPUT_CHAN,
        DIRECT_ADC_INPUT_CHAN,
        FLOATING_CHAN,
        FLOATING_CHAN,
        OBDOUT_CHAN
    };
    8dda:	f24b 7300 	movw	r3, #46848	; 0xb700
    8dde:	f2c0 0301 	movt	r3, #1
    8de2:	f107 0c48 	add.w	ip, r7, #72	; 0x48
    8de6:	cb0f      	ldmia	r3!, {r0, r1, r2, r3}
    8de8:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
    cal_channel_type_t channel_type;
    uint32_t channel_nb;
    uint32_t adc_nb;
    uint32_t range;
    uint32_t quad_id;
    mtd_calibration_mc_t const * p_mc_coeff = 0;
    8dec:	f04f 0300 	mov.w	r3, #0
    8df0:	67bb      	str	r3, [r7, #120]	; 0x78
    
    channel_nb = channel_id & channel_mask;
    8df2:	79fa      	ldrb	r2, [r7, #7]
    8df4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    8df6:	ea02 0303 	and.w	r3, r2, r3
    8dfa:	66bb      	str	r3, [r7, #104]	; 0x68
    channel_type = channel_type_lut[channel_nb];
    8dfc:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    8dfe:	f107 0290 	add.w	r2, r7, #144	; 0x90
    8e02:	4413      	add	r3, r2
    8e04:	f813 3c48 	ldrb.w	r3, [r3, #-72]
    8e08:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
    adc_nb = ((uint32_t)channel_id & 0x30u) >> 4u;
    8e0c:	79fb      	ldrb	r3, [r7, #7]
    8e0e:	f003 0330 	and.w	r3, r3, #48	; 0x30
    8e12:	ea4f 1313 	mov.w	r3, r3, lsr #4
    8e16:	66fb      	str	r3, [r7, #108]	; 0x6c
    
    quad_id = adc_nb * 2;
    8e18:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    8e1a:	ea4f 0343 	mov.w	r3, r3, lsl #1
    8e1e:	677b      	str	r3, [r7, #116]	; 0x74
    
    if ( (channel_nb > 4) && (channel_nb < 9) ) { ++quad_id; }
    8e20:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    8e22:	2b04      	cmp	r3, #4
    8e24:	d906      	bls.n	8e34 <get_calibration+0x78>
    8e26:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    8e28:	2b08      	cmp	r3, #8
    8e2a:	d803      	bhi.n	8e34 <get_calibration+0x78>
    8e2c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    8e2e:	f103 0301 	add.w	r3, r3, #1
    8e32:	677b      	str	r3, [r7, #116]	; 0x74
    
    switch ( channel_type )
    8e34:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
    8e38:	2b05      	cmp	r3, #5
    8e3a:	f200 8151 	bhi.w	90e0 <get_calibration+0x324>
    8e3e:	a201      	add	r2, pc, #4	; (adr r2, 8e44 <get_calibration+0x88>)
    8e40:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    8e44:	00008e5d 	.word	0x00008e5d
    8e48:	00008eab 	.word	0x00008eab
    8e4c:	00008f01 	.word	0x00008f01
    8e50:	00008f67 	.word	0x00008f67
    8e54:	00008fd9 	.word	0x00008fd9
    8e58:	00009041 	.word	0x00009041
    {
    case ABPS1_CHAN:
        range = (ACE->ACB_DATA[quad_id].b8 & ABPS1_CFG_BITS_MASK) >> ABPS1_CFG_BITS_SHIFT;
    8e5c:	f240 0200 	movw	r2, #0
    8e60:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8e64:	6f79      	ldr	r1, [r7, #116]	; 0x74
    8e66:	460b      	mov	r3, r1
    8e68:	ea4f 0343 	mov.w	r3, r3, lsl #1
    8e6c:	440b      	add	r3, r1
    8e6e:	ea4f 1303 	mov.w	r3, r3, lsl #4
    8e72:	4413      	add	r3, r2
    8e74:	f503 7308 	add.w	r3, r3, #544	; 0x220
    8e78:	791b      	ldrb	r3, [r3, #4]
    8e7a:	b2db      	uxtb	r3, r3
    8e7c:	f003 0306 	and.w	r3, r3, #6
    8e80:	ea4f 0353 	mov.w	r3, r3, lsr #1
    8e84:	673b      	str	r3, [r7, #112]	; 0x70
        p_mc_coeff = &p_mtd_data->abps_calibration[quad_id][0][range];
    8e86:	f24b 63fc 	movw	r3, #46844	; 0xb6fc
    8e8a:	f2c0 0301 	movt	r3, #1
    8e8e:	681b      	ldr	r3, [r3, #0]
    8e90:	f103 0390 	add.w	r3, r3, #144	; 0x90
    8e94:	461a      	mov	r2, r3
    8e96:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    8e98:	ea4f 01c3 	mov.w	r1, r3, lsl #3
    8e9c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
    8e9e:	440b      	add	r3, r1
    8ea0:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8ea4:	4413      	add	r3, r2
    8ea6:	67bb      	str	r3, [r7, #120]	; 0x78
        break;
    8ea8:	e122      	b.n	90f0 <get_calibration+0x334>
        
    case ABPS2_CHAN:
        range = (ACE->ACB_DATA[quad_id].b8 & ABPS2_CFG_BITS_MASK) >> ABPS2_CFG_BITS_SHIFT;
    8eaa:	f240 0200 	movw	r2, #0
    8eae:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8eb2:	6f79      	ldr	r1, [r7, #116]	; 0x74
    8eb4:	460b      	mov	r3, r1
    8eb6:	ea4f 0343 	mov.w	r3, r3, lsl #1
    8eba:	440b      	add	r3, r1
    8ebc:	ea4f 1303 	mov.w	r3, r3, lsl #4
    8ec0:	4413      	add	r3, r2
    8ec2:	f503 7308 	add.w	r3, r3, #544	; 0x220
    8ec6:	791b      	ldrb	r3, [r3, #4]
    8ec8:	b2db      	uxtb	r3, r3
    8eca:	f003 0360 	and.w	r3, r3, #96	; 0x60
    8ece:	ea4f 1353 	mov.w	r3, r3, lsr #5
    8ed2:	673b      	str	r3, [r7, #112]	; 0x70
        p_mc_coeff = &p_mtd_data->abps_calibration[quad_id][1][range];
    8ed4:	f24b 63fc 	movw	r3, #46844	; 0xb6fc
    8ed8:	f2c0 0301 	movt	r3, #1
    8edc:	681b      	ldr	r3, [r3, #0]
    8ede:	f103 0390 	add.w	r3, r3, #144	; 0x90
    8ee2:	461a      	mov	r2, r3
    8ee4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    8ee6:	ea4f 0343 	mov.w	r3, r3, lsl #1
    8eea:	f103 0301 	add.w	r3, r3, #1
    8eee:	ea4f 0183 	mov.w	r1, r3, lsl #2
    8ef2:	6f3b      	ldr	r3, [r7, #112]	; 0x70
    8ef4:	440b      	add	r3, r1
    8ef6:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8efa:	4413      	add	r3, r2
    8efc:	67bb      	str	r3, [r7, #120]	; 0x78
        break;
    8efe:	e0f7      	b.n	90f0 <get_calibration+0x334>
        
    case CMB_CHAN:
        {
            uint32_t cmb_mux_sel = (uint32_t)ACE->ACB_DATA[quad_id].b9 & CMB_MUX_SEL_MASK;
    8f00:	f240 0200 	movw	r2, #0
    8f04:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8f08:	6f79      	ldr	r1, [r7, #116]	; 0x74
    8f0a:	460b      	mov	r3, r1
    8f0c:	ea4f 0343 	mov.w	r3, r3, lsl #1
    8f10:	440b      	add	r3, r1
    8f12:	ea4f 1303 	mov.w	r3, r3, lsl #4
    8f16:	4413      	add	r3, r2
    8f18:	f503 7308 	add.w	r3, r3, #544	; 0x220
    8f1c:	7a1b      	ldrb	r3, [r3, #8]
    8f1e:	b2db      	uxtb	r3, r3
    8f20:	461a      	mov	r2, r3
    8f22:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    8f24:	ea02 0303 	and.w	r3, r2, r3
    8f28:	67fb      	str	r3, [r7, #124]	; 0x7c
            if ( cmb_mux_sel == 0 )
    8f2a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
    8f2c:	2b00      	cmp	r3, #0
    8f2e:	d10c      	bne.n	8f4a <get_calibration+0x18e>
            {   /* current monitor */
                p_mc_coeff = &p_mtd_data->cm_calibration[quad_id];
    8f30:	f24b 63fc 	movw	r3, #46844	; 0xb6fc
    8f34:	f2c0 0301 	movt	r3, #1
    8f38:	681b      	ldr	r3, [r3, #0]
    8f3a:	f503 72c0 	add.w	r2, r3, #384	; 0x180
    8f3e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    8f40:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8f44:	4413      	add	r3, r2
    8f46:	67bb      	str	r3, [r7, #120]	; 0x78
            else
            {   /* direct input */
                p_mc_coeff = &p_mtd_data->quads_direct_input_cal[quad_id][0];
            }
        }
        break;
    8f48:	e0d2      	b.n	90f0 <get_calibration+0x334>
            {   /* current monitor */
                p_mc_coeff = &p_mtd_data->cm_calibration[quad_id];
            }
            else
            {   /* direct input */
                p_mc_coeff = &p_mtd_data->quads_direct_input_cal[quad_id][0];
    8f4a:	f24b 63fc 	movw	r3, #46844	; 0xb6fc
    8f4e:	f2c0 0301 	movt	r3, #1
    8f52:	681b      	ldr	r3, [r3, #0]
    8f54:	f503 73d8 	add.w	r3, r3, #432	; 0x1b0
    8f58:	461a      	mov	r2, r3
    8f5a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    8f5c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    8f60:	4413      	add	r3, r2
    8f62:	67bb      	str	r3, [r7, #120]	; 0x78
            }
        }
        break;
    8f64:	e0c4      	b.n	90f0 <get_calibration+0x334>
        
    case TMB_CHAN:
        {
            uint32_t tmb_mux_sel = (uint32_t)ACE->ACB_DATA[quad_id].b10 & TMB_MUX_SEL_MASK;
    8f66:	f240 0200 	movw	r2, #0
    8f6a:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8f6e:	6f79      	ldr	r1, [r7, #116]	; 0x74
    8f70:	460b      	mov	r3, r1
    8f72:	ea4f 0343 	mov.w	r3, r3, lsl #1
    8f76:	440b      	add	r3, r1
    8f78:	ea4f 1303 	mov.w	r3, r3, lsl #4
    8f7c:	4413      	add	r3, r2
    8f7e:	f503 730a 	add.w	r3, r3, #552	; 0x228
    8f82:	791b      	ldrb	r3, [r3, #4]
    8f84:	b2db      	uxtb	r3, r3
    8f86:	461a      	mov	r2, r3
    8f88:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    8f8a:	ea02 0303 	and.w	r3, r2, r3
    8f8e:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
            if ( tmb_mux_sel == 0 )
    8f92:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
    8f96:	2b00      	cmp	r3, #0
    8f98:	d10c      	bne.n	8fb4 <get_calibration+0x1f8>
            {   /* temperature monitor */
                p_mc_coeff = &p_mtd_data->tm_calibration[quad_id];
    8f9a:	f24b 63fc 	movw	r3, #46844	; 0xb6fc
    8f9e:	f2c0 0301 	movt	r3, #1
    8fa2:	681b      	ldr	r3, [r3, #0]
    8fa4:	f503 72cc 	add.w	r2, r3, #408	; 0x198
    8fa8:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    8faa:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8fae:	4413      	add	r3, r2
    8fb0:	67bb      	str	r3, [r7, #120]	; 0x78
            else
            {   /* direct input */
                p_mc_coeff = &p_mtd_data->quads_direct_input_cal[quad_id][1];
            }
        }
        break;
    8fb2:	e09d      	b.n	90f0 <get_calibration+0x334>
            {   /* temperature monitor */
                p_mc_coeff = &p_mtd_data->tm_calibration[quad_id];
            }
            else
            {   /* direct input */
                p_mc_coeff = &p_mtd_data->quads_direct_input_cal[quad_id][1];
    8fb4:	f24b 63fc 	movw	r3, #46844	; 0xb6fc
    8fb8:	f2c0 0301 	movt	r3, #1
    8fbc:	681b      	ldr	r3, [r3, #0]
    8fbe:	f503 73d8 	add.w	r3, r3, #432	; 0x1b0
    8fc2:	461a      	mov	r2, r3
    8fc4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    8fc6:	ea4f 0343 	mov.w	r3, r3, lsl #1
    8fca:	f103 0301 	add.w	r3, r3, #1
    8fce:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8fd2:	4413      	add	r3, r2
    8fd4:	67bb      	str	r3, [r7, #120]	; 0x78
            }
        }
        break;
    8fd6:	e08b      	b.n	90f0 <get_calibration+0x334>
#ifdef SMARTFUSION_060_DEVICE
            const uint32_t channel_to_direct_in_lut[16]
                = { 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
#else
            const uint32_t channel_to_direct_in_lut[16]
                = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0 };
    8fd8:	f24b 7310 	movw	r3, #46864	; 0xb710
    8fdc:	f2c0 0301 	movt	r3, #1
    8fe0:	f107 0c08 	add.w	ip, r7, #8
    8fe4:	461c      	mov	r4, r3
    8fe6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    8fe8:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    8fec:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    8fee:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    8ff2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    8ff4:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    8ff8:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
    8ffc:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
#endif
            uint32_t direct_in_id;
            
            direct_in_id = channel_to_direct_in_lut[channel_id & channel_mask];
    9000:	79fa      	ldrb	r2, [r7, #7]
    9002:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    9004:	ea02 0303 	and.w	r3, r2, r3
    9008:	ea4f 0383 	mov.w	r3, r3, lsl #2
    900c:	f107 0290 	add.w	r2, r7, #144	; 0x90
    9010:	4413      	add	r3, r2
    9012:	f853 3c88 	ldr.w	r3, [r3, #-136]
    9016:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
            p_mc_coeff = &p_mtd_data->adc_direct_input_cal[adc_nb][direct_in_id];
    901a:	f24b 63fc 	movw	r3, #46844	; 0xb6fc
    901e:	f2c0 0301 	movt	r3, #1
    9022:	681b      	ldr	r3, [r3, #0]
    9024:	f503 73f0 	add.w	r3, r3, #480	; 0x1e0
    9028:	461a      	mov	r2, r3
    902a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    902c:	ea4f 0183 	mov.w	r1, r3, lsl #2
    9030:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
    9034:	440b      	add	r3, r1
    9036:	ea4f 0383 	mov.w	r3, r3, lsl #2
    903a:	4413      	add	r3, r2
    903c:	67bb      	str	r3, [r7, #120]	; 0x78
        }
        break;
    903e:	e057      	b.n	90f0 <get_calibration+0x334>
        
    case OBDOUT_CHAN:
        {
            uint32_t obd_mode = (uint32_t)ACE->ACB_DATA[quad_id].b6 & OBD_MODE_MASK;
    9040:	f240 0200 	movw	r2, #0
    9044:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9048:	6f79      	ldr	r1, [r7, #116]	; 0x74
    904a:	460b      	mov	r3, r1
    904c:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9050:	440b      	add	r3, r1
    9052:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9056:	4413      	add	r3, r2
    9058:	f503 7306 	add.w	r3, r3, #536	; 0x218
    905c:	791b      	ldrb	r3, [r3, #4]
    905e:	b2db      	uxtb	r3, r3
    9060:	f003 0301 	and.w	r3, r3, #1
    9064:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
            uint32_t chopping_option = (uint32_t)ACE->ACB_DATA[quad_id].b6 & OBD_CHOPPING_MASK;
    9068:	f240 0200 	movw	r2, #0
    906c:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9070:	6f79      	ldr	r1, [r7, #116]	; 0x74
    9072:	460b      	mov	r3, r1
    9074:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9078:	440b      	add	r3, r1
    907a:	ea4f 1303 	mov.w	r3, r3, lsl #4
    907e:	4413      	add	r3, r2
    9080:	f503 7306 	add.w	r3, r3, #536	; 0x218
    9084:	791b      	ldrb	r3, [r3, #4]
    9086:	b2db      	uxtb	r3, r3
    9088:	f003 0302 	and.w	r3, r3, #2
    908c:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
            if (obd_mode > 0)
    9090:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
    9094:	2b00      	cmp	r3, #0
    9096:	d003      	beq.n	90a0 <get_calibration+0x2e4>
            {
                obd_mode = 1;
    9098:	f04f 0301 	mov.w	r3, #1
    909c:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
            }
            if (chopping_option > 0)
    90a0:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
    90a4:	2b00      	cmp	r3, #0
    90a6:	d003      	beq.n	90b0 <get_calibration+0x2f4>
            {
                chopping_option = 1;
    90a8:	f04f 0301 	mov.w	r3, #1
    90ac:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
            }
            p_mc_coeff = &p_mtd_data->obd_calibration[adc_nb][obd_mode][chopping_option];
    90b0:	f24b 63fc 	movw	r3, #46844	; 0xb6fc
    90b4:	f2c0 0301 	movt	r3, #1
    90b8:	681b      	ldr	r3, [r3, #0]
    90ba:	f503 73a8 	add.w	r3, r3, #336	; 0x150
    90be:	461a      	mov	r2, r3
    90c0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    90c2:	ea4f 0143 	mov.w	r1, r3, lsl #1
    90c6:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
    90ca:	440b      	add	r3, r1
    90cc:	ea4f 0143 	mov.w	r1, r3, lsl #1
    90d0:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
    90d4:	440b      	add	r3, r1
    90d6:	ea4f 0383 	mov.w	r3, r3, lsl #2
    90da:	4413      	add	r3, r2
    90dc:	67bb      	str	r3, [r7, #120]	; 0x78
        }
        break;
    90de:	e007      	b.n	90f0 <get_calibration+0x334>
       
    case FLOATING_CHAN:
    default:
        /* Give neutral values is invalid channel. */
        p_calibration->m1 = NEUTRAL_M_FACTOR;
    90e0:	683b      	ldr	r3, [r7, #0]
    90e2:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    90e6:	805a      	strh	r2, [r3, #2]
        p_calibration->c1 = NEUTRAL_C_OFFSET;
    90e8:	683b      	ldr	r3, [r7, #0]
    90ea:	f04f 0200 	mov.w	r2, #0
    90ee:	809a      	strh	r2, [r3, #4]
        break;
    }
    
    if (p_mc_coeff != 0)
    90f0:	6fbb      	ldr	r3, [r7, #120]	; 0x78
    90f2:	2b00      	cmp	r3, #0
    90f4:	d007      	beq.n	9106 <get_calibration+0x34a>
    {
        p_calibration->m1 = p_mc_coeff->m;
    90f6:	6fbb      	ldr	r3, [r7, #120]	; 0x78
    90f8:	881a      	ldrh	r2, [r3, #0]
    90fa:	683b      	ldr	r3, [r7, #0]
    90fc:	805a      	strh	r2, [r3, #2]
        p_calibration->c1 = p_mc_coeff->c;
    90fe:	6fbb      	ldr	r3, [r7, #120]	; 0x78
    9100:	885a      	ldrh	r2, [r3, #2]
    9102:	683b      	ldr	r3, [r7, #0]
    9104:	809a      	strh	r2, [r3, #4]
    
    /*--------------------------------------------------------------------------
      Retrieve the value of the mext factor. This depends if external VAREF is
      used by the ADC sampling the analog input channel.
     */
    if (g_ace_external_varef_used[adc_nb])
    9106:	6efa      	ldr	r2, [r7, #108]	; 0x6c
    9108:	f64a 7350 	movw	r3, #44880	; 0xaf50
    910c:	f2c0 0301 	movt	r3, #1
    9110:	5c9b      	ldrb	r3, [r3, r2]
    9112:	2b00      	cmp	r3, #0
    9114:	d008      	beq.n	9128 <get_calibration+0x36c>
    {
        p_calibration->mext = p_mtd_data->global_settings.varef_m;
    9116:	f24b 63fc 	movw	r3, #46844	; 0xb6fc
    911a:	f2c0 0301 	movt	r3, #1
    911e:	681b      	ldr	r3, [r3, #0]
    9120:	8b9a      	ldrh	r2, [r3, #28]
    9122:	683b      	ldr	r3, [r7, #0]
    9124:	801a      	strh	r2, [r3, #0]
    9126:	e003      	b.n	9130 <get_calibration+0x374>
    }
    else
    {
        p_calibration->mext = NEUTRAL_M_FACTOR;
    9128:	683b      	ldr	r3, [r7, #0]
    912a:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    912e:	801a      	strh	r2, [r3, #0]
    }
}
    9130:	f107 0790 	add.w	r7, r7, #144	; 0x90
    9134:	46bd      	mov	sp, r7
    9136:	bc90      	pop	{r4, r7}
    9138:	4770      	bx	lr
    913a:	bf00      	nop

0000913c <write_transform_coefficients>:
(
    ace_channel_handle_t channel_handle,
	uint32_t m,
	uint32_t c
)
{
    913c:	b480      	push	{r7}
    913e:	b087      	sub	sp, #28
    9140:	af00      	add	r7, sp, #0
    9142:	4603      	mov	r3, r0
    9144:	60b9      	str	r1, [r7, #8]
    9146:	607a      	str	r2, [r7, #4]
    9148:	73fb      	strb	r3, [r7, #15]
    uint16_t m_ppe_offset;
    uint16_t c_ppe_offset;
    const uint32_t PPE_OPCODE_MASK = 0xFF000000u;
    914a:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
    914e:	617b      	str	r3, [r7, #20]
    
    m_ppe_offset = g_ace_ppe_transforms_desc_table[channel_handle].m_ppe_offset;
    9150:	7bfa      	ldrb	r2, [r7, #15]
    9152:	f64a 7394 	movw	r3, #44948	; 0xaf94
    9156:	f2c0 0301 	movt	r3, #1
    915a:	f833 3032 	ldrh.w	r3, [r3, r2, lsl #3]
    915e:	823b      	strh	r3, [r7, #16]
    c_ppe_offset = g_ace_ppe_transforms_desc_table[channel_handle].c_ppe_offset;
    9160:	7bfb      	ldrb	r3, [r7, #15]
    9162:	f64a 7294 	movw	r2, #44948	; 0xaf94
    9166:	f2c0 0201 	movt	r2, #1
    916a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    916e:	4413      	add	r3, r2
    9170:	885b      	ldrh	r3, [r3, #2]
    9172:	827b      	strh	r3, [r7, #18]
    
    ACE->PPE_RAM_DATA[m_ppe_offset]
    9174:	f240 0300 	movw	r3, #0
    9178:	f2c4 0302 	movt	r3, #16386	; 0x4002
    917c:	8a38      	ldrh	r0, [r7, #16]
        = (ACE->PPE_RAM_DATA[m_ppe_offset] & PPE_OPCODE_MASK) | (m >> 8u);
    917e:	f240 0200 	movw	r2, #0
    9182:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9186:	8a39      	ldrh	r1, [r7, #16]
    9188:	f501 61c0 	add.w	r1, r1, #1536	; 0x600
    918c:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
    9190:	697a      	ldr	r2, [r7, #20]
    9192:	ea01 0102 	and.w	r1, r1, r2
    9196:	68ba      	ldr	r2, [r7, #8]
    9198:	ea4f 2212 	mov.w	r2, r2, lsr #8
    919c:	ea41 0102 	orr.w	r1, r1, r2
    const uint32_t PPE_OPCODE_MASK = 0xFF000000u;
    
    m_ppe_offset = g_ace_ppe_transforms_desc_table[channel_handle].m_ppe_offset;
    c_ppe_offset = g_ace_ppe_transforms_desc_table[channel_handle].c_ppe_offset;
    
    ACE->PPE_RAM_DATA[m_ppe_offset]
    91a0:	f500 62c0 	add.w	r2, r0, #1536	; 0x600
    91a4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        = (ACE->PPE_RAM_DATA[m_ppe_offset] & PPE_OPCODE_MASK) | (m >> 8u);
        
    ACE->PPE_RAM_DATA[c_ppe_offset]
    91a8:	f240 0300 	movw	r3, #0
    91ac:	f2c4 0302 	movt	r3, #16386	; 0x4002
    91b0:	8a78      	ldrh	r0, [r7, #18]
        = (ACE->PPE_RAM_DATA[c_ppe_offset] & PPE_OPCODE_MASK) | (c >> 8u);
    91b2:	f240 0200 	movw	r2, #0
    91b6:	f2c4 0202 	movt	r2, #16386	; 0x4002
    91ba:	8a79      	ldrh	r1, [r7, #18]
    91bc:	f501 61c0 	add.w	r1, r1, #1536	; 0x600
    91c0:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
    91c4:	697a      	ldr	r2, [r7, #20]
    91c6:	ea01 0102 	and.w	r1, r1, r2
    91ca:	687a      	ldr	r2, [r7, #4]
    91cc:	ea4f 2212 	mov.w	r2, r2, lsr #8
    91d0:	ea41 0102 	orr.w	r1, r1, r2
    c_ppe_offset = g_ace_ppe_transforms_desc_table[channel_handle].c_ppe_offset;
    
    ACE->PPE_RAM_DATA[m_ppe_offset]
        = (ACE->PPE_RAM_DATA[m_ppe_offset] & PPE_OPCODE_MASK) | (m >> 8u);
        
    ACE->PPE_RAM_DATA[c_ppe_offset]
    91d4:	f500 62c0 	add.w	r2, r0, #1536	; 0x600
    91d8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        = (ACE->PPE_RAM_DATA[c_ppe_offset] & PPE_OPCODE_MASK) | (c >> 8u);
}
    91dc:	f107 071c 	add.w	r7, r7, #28
    91e0:	46bd      	mov	sp, r7
    91e2:	bc80      	pop	{r7}
    91e4:	4770      	bx	lr
    91e6:	bf00      	nop

000091e8 <ACE_init>:

/*-------------------------------------------------------------------------*//**
  See "mss_ace.h" for details of how to use this function.
 */
void ACE_init( void )
{
    91e8:	b580      	push	{r7, lr}
    91ea:	af00      	add	r7, sp, #0
    /* Initialize driver's internal data. */
    ace_init_flags();
    91ec:	f7fe fcfe 	bl	7bec <ace_init_flags>
    
    /* Initialize the data structures used by conversion functions. */
    ace_init_convert();
    91f0:	f7fd ffce 	bl	7190 <ace_init_convert>
}
    91f4:	bd80      	pop	{r7, pc}
    91f6:	bf00      	nop

000091f8 <ACE_start_adc>:
 */
void ACE_start_adc
(
	adc_channel_id_t channel_id
)
{
    91f8:	b480      	push	{r7}
    91fa:	b083      	sub	sp, #12
    91fc:	af00      	add	r7, sp, #0
    91fe:	4603      	mov	r3, r0
    9200:	71fb      	strb	r3, [r7, #7]
    ACE->ADC0_CONV_CTRL = (uint32_t)((uint32_t)channel_id | START_ADC_CONVERSION);
    9202:	f240 0300 	movw	r3, #0
    9206:	f2c4 0302 	movt	r3, #16386	; 0x4002
    920a:	79fa      	ldrb	r2, [r7, #7]
    920c:	ea6f 6242 	mvn.w	r2, r2, lsl #25
    9210:	ea6f 6252 	mvn.w	r2, r2, lsr #25
    9214:	b2d2      	uxtb	r2, r2
    9216:	651a      	str	r2, [r3, #80]	; 0x50
}
    9218:	f107 070c 	add.w	r7, r7, #12
    921c:	46bd      	mov	sp, r7
    921e:	bc80      	pop	{r7}
    9220:	4770      	bx	lr
    9222:	bf00      	nop

00009224 <ACE_get_adc_result>:

uint16_t ACE_get_adc_result
(
    uint8_t adc_id
)
{
    9224:	b480      	push	{r7}
    9226:	b085      	sub	sp, #20
    9228:	af00      	add	r7, sp, #0
    922a:	4603      	mov	r3, r0
    922c:	71fb      	strb	r3, [r7, #7]
    uint16_t result = 0u;
    922e:	f04f 0300 	mov.w	r3, #0
    9232:	817b      	strh	r3, [r7, #10]
    uint32_t data_valid;

    ASSERT( adc_id < NB_OF_ANALOG_MODULES );
    9234:	79fb      	ldrb	r3, [r7, #7]
    9236:	2b02      	cmp	r3, #2
    9238:	d900      	bls.n	923c <ACE_get_adc_result+0x18>
    923a:	be00      	bkpt	0x0000
    
    if ( adc_id < (uint8_t)NB_OF_ANALOG_MODULES )
    923c:	79fb      	ldrb	r3, [r7, #7]
    923e:	2b02      	cmp	r3, #2
    9240:	d81b      	bhi.n	927a <ACE_get_adc_result+0x56>
    {
        do {
            data_valid = (uint32_t)(*adc_status_reg_lut[adc_id] & ADC_DATAVALID_MASK);
    9242:	79fa      	ldrb	r2, [r7, #7]
    9244:	f24b 7358 	movw	r3, #46936	; 0xb758
    9248:	f2c0 0301 	movt	r3, #1
    924c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    9250:	681b      	ldr	r3, [r3, #0]
    9252:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    9256:	60fb      	str	r3, [r7, #12]
        } while ( !data_valid );
    9258:	68fb      	ldr	r3, [r7, #12]
    925a:	2b00      	cmp	r3, #0
    925c:	d0f1      	beq.n	9242 <ACE_get_adc_result+0x1e>
        
        result = (uint16_t)(*adc_status_reg_lut[adc_id] & ADC_RESULT_MASK);
    925e:	79fa      	ldrb	r2, [r7, #7]
    9260:	f24b 7358 	movw	r3, #46936	; 0xb758
    9264:	f2c0 0301 	movt	r3, #1
    9268:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    926c:	681b      	ldr	r3, [r3, #0]
    926e:	b29b      	uxth	r3, r3
    9270:	ea4f 5303 	mov.w	r3, r3, lsl #20
    9274:	ea4f 5313 	mov.w	r3, r3, lsr #20
    9278:	817b      	strh	r3, [r7, #10]
    }
    return result;
    927a:	897b      	ldrh	r3, [r7, #10]
}
    927c:	4618      	mov	r0, r3
    927e:	f107 0714 	add.w	r7, r7, #20
    9282:	46bd      	mov	sp, r7
    9284:	bc80      	pop	{r7}
    9286:	4770      	bx	lr

00009288 <ACE_configure_sdd>:
	sdd_id_t            sdd_id,
	sdd_resolution_t    resolution,
    uint8_t             mode,
    sdd_update_method_t sync_update
)
{
    9288:	b490      	push	{r4, r7}
    928a:	b086      	sub	sp, #24
    928c:	af00      	add	r7, sp, #0
    928e:	71f8      	strb	r0, [r7, #7]
    9290:	71b9      	strb	r1, [r7, #6]
    9292:	717a      	strb	r2, [r7, #5]
    9294:	713b      	strb	r3, [r7, #4]
    ASSERT( sdd_id < NB_OF_SDD );
    9296:	79fb      	ldrb	r3, [r7, #7]
    9298:	2b02      	cmp	r3, #2
    929a:	d900      	bls.n	929e <ACE_configure_sdd+0x16>
    929c:	be00      	bkpt	0x0000
    
    if ( sdd_id < NB_OF_SDD )
    929e:	79fb      	ldrb	r3, [r7, #7]
    92a0:	2b02      	cmp	r3, #2
    92a2:	f200 80bc 	bhi.w	941e <ACE_configure_sdd+0x196>
    {
#ifdef SMARTFUSION_060_DEVICE
        const uint8_t sdd_2_quad_lut[NB_OF_SDD] = {0u};
#else	
        const uint8_t sdd_2_quad_lut[NB_OF_SDD] = {0u, 2u, 4u};
    92a6:	f24b 72a4 	movw	r2, #47012	; 0xb7a4
    92aa:	f2c0 0201 	movt	r2, #1
    92ae:	f107 030c 	add.w	r3, r7, #12
    92b2:	6812      	ldr	r2, [r2, #0]
    92b4:	4611      	mov	r1, r2
    92b6:	8019      	strh	r1, [r3, #0]
    92b8:	f103 0302 	add.w	r3, r3, #2
    92bc:	ea4f 4212 	mov.w	r2, r2, lsr #16
    92c0:	701a      	strb	r2, [r3, #0]
#endif
        uint8_t quad_id;
        uint8_t obd_mode_idx = 1u;
    92c2:	f04f 0301 	mov.w	r3, #1
    92c6:	74bb      	strb	r3, [r7, #18]
        uint8_t chopping_mode_idx = 0u;
    92c8:	f04f 0300 	mov.w	r3, #0
    92cc:	74fb      	strb	r3, [r7, #19]
        uint32_t saved_pc2_ctrl;
        
        quad_id = sdd_2_quad_lut[sdd_id];
    92ce:	79fb      	ldrb	r3, [r7, #7]
    92d0:	f107 0218 	add.w	r2, r7, #24
    92d4:	4413      	add	r3, r2
    92d6:	f813 3c0c 	ldrb.w	r3, [r3, #-12]
    92da:	747b      	strb	r3, [r7, #17]
        
        /* Pause the SSE PC2 while accesses to ACB from APB3 are taking place. */
        saved_pc2_ctrl = ACE->PC2_CTRL;
    92dc:	f240 0300 	movw	r3, #0
    92e0:	f2c4 0302 	movt	r3, #16386	; 0x4002
    92e4:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
    92e8:	617b      	str	r3, [r7, #20]
        ACE->PC2_CTRL = 0u;
    92ea:	f240 0300 	movw	r3, #0
    92ee:	f2c4 0302 	movt	r3, #16386	; 0x4002
    92f2:	f04f 0200 	mov.w	r2, #0
    92f6:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
        
        /* Select between voltage/current and RTZ modes.*/
        ACE->ACB_DATA[quad_id].b6 = mode;
    92fa:	f240 0200 	movw	r2, #0
    92fe:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9302:	7c79      	ldrb	r1, [r7, #17]
    9304:	460b      	mov	r3, r1
    9306:	ea4f 0343 	mov.w	r3, r3, lsl #1
    930a:	440b      	add	r3, r1
    930c:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9310:	4413      	add	r3, r2
    9312:	f503 7306 	add.w	r3, r3, #536	; 0x218
    9316:	797a      	ldrb	r2, [r7, #5]
    9318:	711a      	strb	r2, [r3, #4]
        
        /* Load manufacturing generated trim value. */
        if ( (mode & OBD_MODE_MASK) > 0u )
    931a:	797b      	ldrb	r3, [r7, #5]
    931c:	f003 0301 	and.w	r3, r3, #1
    9320:	b2db      	uxtb	r3, r3
    9322:	2b00      	cmp	r3, #0
    9324:	d002      	beq.n	932c <ACE_configure_sdd+0xa4>
        {
            obd_mode_idx = 0u;
    9326:	f04f 0300 	mov.w	r3, #0
    932a:	74bb      	strb	r3, [r7, #18]
        }
        if ( (mode & OBD_CHOPPING_MASK) > 0u )
    932c:	797b      	ldrb	r3, [r7, #5]
    932e:	f003 0302 	and.w	r3, r3, #2
    9332:	2b00      	cmp	r3, #0
    9334:	d002      	beq.n	933c <ACE_configure_sdd+0xb4>
        {
            chopping_mode_idx = 1u;
    9336:	f04f 0301 	mov.w	r3, #1
    933a:	74fb      	strb	r3, [r7, #19]
        }
        ACE->ACB_DATA[quad_id].b4
    933c:	f240 0200 	movw	r2, #0
    9340:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9344:	7c79      	ldrb	r1, [r7, #17]
            = p_mtd_data->odb_trimming[sdd_id][obd_mode_idx][chopping_mode_idx];
    9346:	f24b 7394 	movw	r3, #46996	; 0xb794
    934a:	f2c0 0301 	movt	r3, #1
    934e:	681b      	ldr	r3, [r3, #0]
    9350:	79fc      	ldrb	r4, [r7, #7]
    9352:	f897 c012 	ldrb.w	ip, [r7, #18]
    9356:	7cf8      	ldrb	r0, [r7, #19]
    9358:	ea4f 0444 	mov.w	r4, r4, lsl #1
    935c:	44a4      	add	ip, r4
    935e:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
    9362:	4460      	add	r0, ip
    9364:	4403      	add	r3, r0
    9366:	f103 0380 	add.w	r3, r3, #128	; 0x80
    936a:	7918      	ldrb	r0, [r3, #4]
        }
        if ( (mode & OBD_CHOPPING_MASK) > 0u )
        {
            chopping_mode_idx = 1u;
        }
        ACE->ACB_DATA[quad_id].b4
    936c:	460b      	mov	r3, r1
    936e:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9372:	440b      	add	r3, r1
    9374:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9378:	4413      	add	r3, r2
    937a:	f503 7304 	add.w	r3, r3, #528	; 0x210
    937e:	4602      	mov	r2, r0
    9380:	711a      	strb	r2, [r3, #4]
            = p_mtd_data->odb_trimming[sdd_id][obd_mode_idx][chopping_mode_idx];
        
        /* Restore SSE PC2 operations since no ACB accesses should take place
         * beyond this point. */
        ACE->PC2_CTRL = saved_pc2_ctrl;
    9382:	f240 0300 	movw	r3, #0
    9386:	f2c4 0302 	movt	r3, #16386	; 0x4002
    938a:	697a      	ldr	r2, [r7, #20]
    938c:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    
        /* Set SDD resolution. */
        *dac_ctrl_reg_lut[sdd_id] = (uint32_t)resolution;
    9390:	79fa      	ldrb	r2, [r7, #7]
    9392:	f24b 7364 	movw	r3, #46948	; 0xb764
    9396:	f2c0 0301 	movt	r3, #1
    939a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    939e:	79ba      	ldrb	r2, [r7, #6]
    93a0:	601a      	str	r2, [r3, #0]
        
        /* Update SDD value through SSE_DACn_BYTES01. */
        *dac_ctrl_reg_lut[sdd_id] |= SDD_REG_SEL_MASK;
    93a2:	79fa      	ldrb	r2, [r7, #7]
    93a4:	f24b 7364 	movw	r3, #46948	; 0xb764
    93a8:	f2c0 0301 	movt	r3, #1
    93ac:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    93b0:	79f9      	ldrb	r1, [r7, #7]
    93b2:	f24b 7364 	movw	r3, #46948	; 0xb764
    93b6:	f2c0 0301 	movt	r3, #1
    93ba:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    93be:	681b      	ldr	r3, [r3, #0]
    93c0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    93c4:	6013      	str	r3, [r2, #0]
        
        /* Synchronous or individual SDD update. */
        if ( INDIVIDUAL_UPDATE == sync_update )
    93c6:	793b      	ldrb	r3, [r7, #4]
    93c8:	2b00      	cmp	r3, #0
    93ca:	d115      	bne.n	93f8 <ACE_configure_sdd+0x170>
        {
            ACE->DAC_SYNC_CTRL &= ~dac_enable_masks_lut[sdd_id];
    93cc:	f240 0300 	movw	r3, #0
    93d0:	f2c4 0302 	movt	r3, #16386	; 0x4002
    93d4:	f240 0200 	movw	r2, #0
    93d8:	f2c4 0202 	movt	r2, #16386	; 0x4002
    93dc:	6911      	ldr	r1, [r2, #16]
    93de:	79f8      	ldrb	r0, [r7, #7]
    93e0:	f24b 7270 	movw	r2, #46960	; 0xb770
    93e4:	f2c0 0201 	movt	r2, #1
    93e8:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
    93ec:	ea6f 0202 	mvn.w	r2, r2
    93f0:	ea01 0202 	and.w	r2, r1, r2
    93f4:	611a      	str	r2, [r3, #16]
    93f6:	e012      	b.n	941e <ACE_configure_sdd+0x196>
        }
        else
        {
            ACE->DAC_SYNC_CTRL |= dac_enable_masks_lut[sdd_id];
    93f8:	f240 0300 	movw	r3, #0
    93fc:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9400:	f240 0200 	movw	r2, #0
    9404:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9408:	6911      	ldr	r1, [r2, #16]
    940a:	79f8      	ldrb	r0, [r7, #7]
    940c:	f24b 7270 	movw	r2, #46960	; 0xb770
    9410:	f2c0 0201 	movt	r2, #1
    9414:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
    9418:	ea41 0202 	orr.w	r2, r1, r2
    941c:	611a      	str	r2, [r3, #16]
        }
    }
}
    941e:	f107 0718 	add.w	r7, r7, #24
    9422:	46bd      	mov	sp, r7
    9424:	bc90      	pop	{r4, r7}
    9426:	4770      	bx	lr

00009428 <ACE_enable_sdd>:
 */
void ACE_enable_sdd
(
	sdd_id_t    sdd_id
)
{
    9428:	b480      	push	{r7}
    942a:	b083      	sub	sp, #12
    942c:	af00      	add	r7, sp, #0
    942e:	4603      	mov	r3, r0
    9430:	71fb      	strb	r3, [r7, #7]
    ASSERT( sdd_id < NB_OF_SDD );
    9432:	79fb      	ldrb	r3, [r7, #7]
    9434:	2b02      	cmp	r3, #2
    9436:	d900      	bls.n	943a <ACE_enable_sdd+0x12>
    9438:	be00      	bkpt	0x0000
    
    if ( sdd_id < NB_OF_SDD )
    943a:	79fb      	ldrb	r3, [r7, #7]
    943c:	2b02      	cmp	r3, #2
    943e:	d811      	bhi.n	9464 <ACE_enable_sdd+0x3c>
    {
        *dac_ctrl_reg_lut[sdd_id] |= SDD_ENABLE_MASK;
    9440:	79fa      	ldrb	r2, [r7, #7]
    9442:	f24b 7364 	movw	r3, #46948	; 0xb764
    9446:	f2c0 0301 	movt	r3, #1
    944a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    944e:	79f9      	ldrb	r1, [r7, #7]
    9450:	f24b 7364 	movw	r3, #46948	; 0xb764
    9454:	f2c0 0301 	movt	r3, #1
    9458:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    945c:	681b      	ldr	r3, [r3, #0]
    945e:	f043 0320 	orr.w	r3, r3, #32
    9462:	6013      	str	r3, [r2, #0]
    }
}
    9464:	f107 070c 	add.w	r7, r7, #12
    9468:	46bd      	mov	sp, r7
    946a:	bc80      	pop	{r7}
    946c:	4770      	bx	lr
    946e:	bf00      	nop

00009470 <ACE_disable_sdd>:
 */
void ACE_disable_sdd
(
	sdd_id_t    sdd_id
)
{
    9470:	b480      	push	{r7}
    9472:	b083      	sub	sp, #12
    9474:	af00      	add	r7, sp, #0
    9476:	4603      	mov	r3, r0
    9478:	71fb      	strb	r3, [r7, #7]
    ASSERT( sdd_id < NB_OF_SDD );
    947a:	79fb      	ldrb	r3, [r7, #7]
    947c:	2b02      	cmp	r3, #2
    947e:	d900      	bls.n	9482 <ACE_disable_sdd+0x12>
    9480:	be00      	bkpt	0x0000
    
    if ( sdd_id < NB_OF_SDD )
    9482:	79fb      	ldrb	r3, [r7, #7]
    9484:	2b02      	cmp	r3, #2
    9486:	d811      	bhi.n	94ac <ACE_disable_sdd+0x3c>
    {
        *dac_ctrl_reg_lut[sdd_id] &= ~SDD_ENABLE_MASK;
    9488:	79fa      	ldrb	r2, [r7, #7]
    948a:	f24b 7364 	movw	r3, #46948	; 0xb764
    948e:	f2c0 0301 	movt	r3, #1
    9492:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    9496:	79f9      	ldrb	r1, [r7, #7]
    9498:	f24b 7364 	movw	r3, #46948	; 0xb764
    949c:	f2c0 0301 	movt	r3, #1
    94a0:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    94a4:	681b      	ldr	r3, [r3, #0]
    94a6:	f023 0320 	bic.w	r3, r3, #32
    94aa:	6013      	str	r3, [r2, #0]
    }
}
    94ac:	f107 070c 	add.w	r7, r7, #12
    94b0:	46bd      	mov	sp, r7
    94b2:	bc80      	pop	{r7}
    94b4:	4770      	bx	lr
    94b6:	bf00      	nop

000094b8 <ACE_set_sdd_value>:
void ACE_set_sdd_value
(
	sdd_id_t    sdd_id,
	uint32_t    sdd_value
)
{
    94b8:	b480      	push	{r7}
    94ba:	b083      	sub	sp, #12
    94bc:	af00      	add	r7, sp, #0
    94be:	4603      	mov	r3, r0
    94c0:	6039      	str	r1, [r7, #0]
    94c2:	71fb      	strb	r3, [r7, #7]
    ASSERT( sdd_id < NB_OF_SDD );
    94c4:	79fb      	ldrb	r3, [r7, #7]
    94c6:	2b02      	cmp	r3, #2
    94c8:	d900      	bls.n	94cc <ACE_set_sdd_value+0x14>
    94ca:	be00      	bkpt	0x0000
    
    if ( sdd_id < NB_OF_SDD )
    94cc:	79fb      	ldrb	r3, [r7, #7]
    94ce:	2b02      	cmp	r3, #2
    94d0:	d813      	bhi.n	94fa <ACE_set_sdd_value+0x42>
    {
        *dac_byte2_reg_lut[sdd_id] = sdd_value >> 16;
    94d2:	79fa      	ldrb	r2, [r7, #7]
    94d4:	f24b 7388 	movw	r3, #46984	; 0xb788
    94d8:	f2c0 0301 	movt	r3, #1
    94dc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    94e0:	683a      	ldr	r2, [r7, #0]
    94e2:	ea4f 4212 	mov.w	r2, r2, lsr #16
    94e6:	601a      	str	r2, [r3, #0]
        *dac_byte01_reg_lut[sdd_id] = sdd_value;
    94e8:	79fa      	ldrb	r2, [r7, #7]
    94ea:	f24b 737c 	movw	r3, #46972	; 0xb77c
    94ee:	f2c0 0301 	movt	r3, #1
    94f2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    94f6:	683a      	ldr	r2, [r7, #0]
    94f8:	601a      	str	r2, [r3, #0]
    }
}
    94fa:	f107 070c 	add.w	r7, r7, #12
    94fe:	46bd      	mov	sp, r7
    9500:	bc80      	pop	{r7}
    9502:	4770      	bx	lr

00009504 <ACE_set_sdd_value_sync>:
(
    uint32_t sdd0_value,
    uint32_t sdd1_value,
    uint32_t sdd2_value
)
{
    9504:	b480      	push	{r7}
    9506:	b087      	sub	sp, #28
    9508:	af00      	add	r7, sp, #0
    950a:	60f8      	str	r0, [r7, #12]
    950c:	60b9      	str	r1, [r7, #8]
    950e:	607a      	str	r2, [r7, #4]
    uint32_t dac_sync_ctrl;
    
    dac_sync_ctrl = ACE->DAC_SYNC_CTRL;
    9510:	f240 0300 	movw	r3, #0
    9514:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9518:	691b      	ldr	r3, [r3, #16]
    951a:	617b      	str	r3, [r7, #20]
    
    if ( SDD_NO_UPDATE != sdd0_value )
    951c:	68fb      	ldr	r3, [r7, #12]
    951e:	f1b3 3fff 	cmp.w	r3, #4294967295
    9522:	d012      	beq.n	954a <ACE_set_sdd_value_sync+0x46>
    {
        ACE->DAC0_BYTE2 = sdd0_value >> 16;
    9524:	f240 0300 	movw	r3, #0
    9528:	f2c4 0302 	movt	r3, #16386	; 0x4002
    952c:	68fa      	ldr	r2, [r7, #12]
    952e:	ea4f 4212 	mov.w	r2, r2, lsr #16
    9532:	66da      	str	r2, [r3, #108]	; 0x6c
        ACE->SSE_DAC0_BYTES01 = sdd0_value;
    9534:	f240 0300 	movw	r3, #0
    9538:	f2c4 0302 	movt	r3, #16386	; 0x4002
    953c:	68fa      	ldr	r2, [r7, #12]
    953e:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
        dac_sync_ctrl |= DAC0_SYNC_UPDATE;
    9542:	697b      	ldr	r3, [r7, #20]
    9544:	f043 0301 	orr.w	r3, r3, #1
    9548:	617b      	str	r3, [r7, #20]
    }

    if ( SDD_NO_UPDATE != sdd1_value )
    954a:	68bb      	ldr	r3, [r7, #8]
    954c:	f1b3 3fff 	cmp.w	r3, #4294967295
    9550:	d013      	beq.n	957a <ACE_set_sdd_value_sync+0x76>
    {
        ACE->DAC1_BYTE2 = sdd1_value >> 16;
    9552:	f240 0300 	movw	r3, #0
    9556:	f2c4 0302 	movt	r3, #16386	; 0x4002
    955a:	68ba      	ldr	r2, [r7, #8]
    955c:	ea4f 4212 	mov.w	r2, r2, lsr #16
    9560:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
        ACE->SSE_DAC1_BYTES01 = sdd1_value;
    9564:	f240 0300 	movw	r3, #0
    9568:	f2c4 0302 	movt	r3, #16386	; 0x4002
    956c:	68ba      	ldr	r2, [r7, #8]
    956e:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
        dac_sync_ctrl |= DAC1_SYNC_UPDATE;
    9572:	697b      	ldr	r3, [r7, #20]
    9574:	f043 0302 	orr.w	r3, r3, #2
    9578:	617b      	str	r3, [r7, #20]
    }

    if ( SDD_NO_UPDATE != sdd2_value )
    957a:	687b      	ldr	r3, [r7, #4]
    957c:	f1b3 3fff 	cmp.w	r3, #4294967295
    9580:	d01c      	beq.n	95bc <ACE_set_sdd_value_sync+0xb8>
    {
        ACE->DAC2_BYTE2 = sdd2_value >> 16;
    9582:	f240 0300 	movw	r3, #0
    9586:	f2c4 0302 	movt	r3, #16386	; 0x4002
    958a:	687a      	ldr	r2, [r7, #4]
    958c:	ea4f 4212 	mov.w	r2, r2, lsr #16
    9590:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
        ACE->DAC2_BYTE1 = sdd2_value >> 8;
    9594:	f240 0300 	movw	r3, #0
    9598:	f2c4 0302 	movt	r3, #16386	; 0x4002
    959c:	687a      	ldr	r2, [r7, #4]
    959e:	ea4f 2212 	mov.w	r2, r2, lsr #8
    95a2:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
        ACE->SSE_DAC2_BYTES01 = sdd2_value;
    95a6:	f240 0300 	movw	r3, #0
    95aa:	f2c4 0302 	movt	r3, #16386	; 0x4002
    95ae:	687a      	ldr	r2, [r7, #4]
    95b0:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
        dac_sync_ctrl |= DAC2_SYNC_UPDATE;
    95b4:	697b      	ldr	r3, [r7, #20]
    95b6:	f043 0304 	orr.w	r3, r3, #4
    95ba:	617b      	str	r3, [r7, #20]
    }
    
    ACE->DAC_SYNC_CTRL = dac_sync_ctrl;
    95bc:	f240 0300 	movw	r3, #0
    95c0:	f2c4 0302 	movt	r3, #16386	; 0x4002
    95c4:	697a      	ldr	r2, [r7, #20]
    95c6:	611a      	str	r2, [r3, #16]
}
    95c8:	f107 071c 	add.w	r7, r7, #28
    95cc:	46bd      	mov	sp, r7
    95ce:	bc80      	pop	{r7}
    95d0:	4770      	bx	lr
    95d2:	bf00      	nop

000095d4 <ACE_set_comp_reference>:
void ACE_set_comp_reference
(
    comparator_id_t     comp_id,
    comp_reference_t    reference
)
{
    95d4:	b480      	push	{r7}
    95d6:	b087      	sub	sp, #28
    95d8:	af00      	add	r7, sp, #0
    95da:	4602      	mov	r2, r0
    95dc:	460b      	mov	r3, r1
    95de:	71fa      	strb	r2, [r7, #7]
    95e0:	71bb      	strb	r3, [r7, #6]
    uint8_t scb_id;
    uint32_t odd;
    
    odd = (uint32_t)comp_id & 0x01u;
    95e2:	79fb      	ldrb	r3, [r7, #7]
    95e4:	f003 0301 	and.w	r3, r3, #1
    95e8:	613b      	str	r3, [r7, #16]
    
    ASSERT( comp_id < NB_OF_COMPARATORS );
    95ea:	79fb      	ldrb	r3, [r7, #7]
    95ec:	2b09      	cmp	r3, #9
    95ee:	d900      	bls.n	95f2 <ACE_set_comp_reference+0x1e>
    95f0:	be00      	bkpt	0x0000
    ASSERT( reference < NB_OF_COMP_REF );
    95f2:	79bb      	ldrb	r3, [r7, #6]
    95f4:	2b03      	cmp	r3, #3
    95f6:	d900      	bls.n	95fa <ACE_set_comp_reference+0x26>
    95f8:	be00      	bkpt	0x0000
    ASSERT( odd );    /* Only Temperature block comparators have configurable reference input. */
    95fa:	693b      	ldr	r3, [r7, #16]
    95fc:	2b00      	cmp	r3, #0
    95fe:	d100      	bne.n	9602 <ACE_set_comp_reference+0x2e>
    9600:	be00      	bkpt	0x0000
    
    if ( (comp_id < NB_OF_COMPARATORS) && (reference < NB_OF_COMP_REF) && (odd) )
    9602:	79fb      	ldrb	r3, [r7, #7]
    9604:	2b09      	cmp	r3, #9
    9606:	f200 80b9 	bhi.w	977c <ACE_set_comp_reference+0x1a8>
    960a:	79bb      	ldrb	r3, [r7, #6]
    960c:	2b03      	cmp	r3, #3
    960e:	f200 80b5 	bhi.w	977c <ACE_set_comp_reference+0x1a8>
    9612:	693b      	ldr	r3, [r7, #16]
    9614:	2b00      	cmp	r3, #0
    9616:	f000 80b1 	beq.w	977c <ACE_set_comp_reference+0x1a8>
    {
        uint32_t saved_pc2_ctrl;
        
        scb_id = comp_id_2_scb_lut[comp_id];
    961a:	79fa      	ldrb	r2, [r7, #7]
    961c:	f24b 7398 	movw	r3, #47000	; 0xb798
    9620:	f2c0 0301 	movt	r3, #1
    9624:	5c9b      	ldrb	r3, [r3, r2]
    9626:	73fb      	strb	r3, [r7, #15]
        
        /* Pause the SSE PC2 while accesses to ACB from APB3 are taking place. */
        saved_pc2_ctrl = ACE->PC2_CTRL;
    9628:	f240 0300 	movw	r3, #0
    962c:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9630:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
    9634:	617b      	str	r3, [r7, #20]
        ACE->PC2_CTRL = 0u;
    9636:	f240 0300 	movw	r3, #0
    963a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    963e:	f04f 0200 	mov.w	r2, #0
    9642:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    
        if ( ADC_IN_COMP_REF == reference )
    9646:	79bb      	ldrb	r3, [r7, #6]
    9648:	2b03      	cmp	r3, #3
    964a:	d146      	bne.n	96da <ACE_set_comp_reference+0x106>
        {
            ACE->ACB_DATA[scb_id].b10 &= (uint8_t)~B10_COMP_VREF_SW_MASK;
    964c:	f240 0100 	movw	r1, #0
    9650:	f2c4 0102 	movt	r1, #16386	; 0x4002
    9654:	7bf8      	ldrb	r0, [r7, #15]
    9656:	f240 0200 	movw	r2, #0
    965a:	f2c4 0202 	movt	r2, #16386	; 0x4002
    965e:	f897 c00f 	ldrb.w	ip, [r7, #15]
    9662:	4663      	mov	r3, ip
    9664:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9668:	4463      	add	r3, ip
    966a:	ea4f 1303 	mov.w	r3, r3, lsl #4
    966e:	4413      	add	r3, r2
    9670:	f503 730a 	add.w	r3, r3, #552	; 0x228
    9674:	791b      	ldrb	r3, [r3, #4]
    9676:	b2db      	uxtb	r3, r3
    9678:	461a      	mov	r2, r3
    967a:	f002 02df 	and.w	r2, r2, #223	; 0xdf
    967e:	4603      	mov	r3, r0
    9680:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9684:	4403      	add	r3, r0
    9686:	ea4f 1303 	mov.w	r3, r3, lsl #4
    968a:	440b      	add	r3, r1
    968c:	f503 730a 	add.w	r3, r3, #552	; 0x228
    9690:	711a      	strb	r2, [r3, #4]
            ACE->ACB_DATA[scb_id].b11 &= (uint8_t)~B11_DAC_MUXSEL_MASK;
    9692:	f240 0100 	movw	r1, #0
    9696:	f2c4 0102 	movt	r1, #16386	; 0x4002
    969a:	7bf8      	ldrb	r0, [r7, #15]
    969c:	f240 0200 	movw	r2, #0
    96a0:	f2c4 0202 	movt	r2, #16386	; 0x4002
    96a4:	f897 c00f 	ldrb.w	ip, [r7, #15]
    96a8:	4663      	mov	r3, ip
    96aa:	ea4f 0343 	mov.w	r3, r3, lsl #1
    96ae:	4463      	add	r3, ip
    96b0:	ea4f 1303 	mov.w	r3, r3, lsl #4
    96b4:	4413      	add	r3, r2
    96b6:	f503 730a 	add.w	r3, r3, #552	; 0x228
    96ba:	7a1b      	ldrb	r3, [r3, #8]
    96bc:	b2db      	uxtb	r3, r3
    96be:	461a      	mov	r2, r3
    96c0:	f002 02fc 	and.w	r2, r2, #252	; 0xfc
    96c4:	4603      	mov	r3, r0
    96c6:	ea4f 0343 	mov.w	r3, r3, lsl #1
    96ca:	4403      	add	r3, r0
    96cc:	ea4f 1303 	mov.w	r3, r3, lsl #4
    96d0:	440b      	add	r3, r1
    96d2:	f503 730a 	add.w	r3, r3, #552	; 0x228
    96d6:	721a      	strb	r2, [r3, #8]
    96d8:	e049      	b.n	976e <ACE_set_comp_reference+0x19a>
        }
        else
        {
            ACE->ACB_DATA[scb_id].b10 |= (uint8_t)B10_COMP_VREF_SW_MASK;
    96da:	f240 0200 	movw	r2, #0
    96de:	f2c4 0202 	movt	r2, #16386	; 0x4002
    96e2:	7bf8      	ldrb	r0, [r7, #15]
    96e4:	f240 0100 	movw	r1, #0
    96e8:	f2c4 0102 	movt	r1, #16386	; 0x4002
    96ec:	f897 c00f 	ldrb.w	ip, [r7, #15]
    96f0:	4663      	mov	r3, ip
    96f2:	ea4f 0343 	mov.w	r3, r3, lsl #1
    96f6:	4463      	add	r3, ip
    96f8:	ea4f 1303 	mov.w	r3, r3, lsl #4
    96fc:	440b      	add	r3, r1
    96fe:	f503 730a 	add.w	r3, r3, #552	; 0x228
    9702:	791b      	ldrb	r3, [r3, #4]
    9704:	b2db      	uxtb	r3, r3
    9706:	f043 0320 	orr.w	r3, r3, #32
    970a:	b2d9      	uxtb	r1, r3
    970c:	4603      	mov	r3, r0
    970e:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9712:	4403      	add	r3, r0
    9714:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9718:	4413      	add	r3, r2
    971a:	f503 730a 	add.w	r3, r3, #552	; 0x228
    971e:	460a      	mov	r2, r1
    9720:	711a      	strb	r2, [r3, #4]
            ACE->ACB_DATA[scb_id].b11 = (ACE->ACB_DATA[scb_id].b11 & (uint8_t)~B11_DAC_MUXSEL_MASK) + (uint8_t)reference;
    9722:	f240 0200 	movw	r2, #0
    9726:	f2c4 0202 	movt	r2, #16386	; 0x4002
    972a:	7bf8      	ldrb	r0, [r7, #15]
    972c:	f240 0100 	movw	r1, #0
    9730:	f2c4 0102 	movt	r1, #16386	; 0x4002
    9734:	f897 c00f 	ldrb.w	ip, [r7, #15]
    9738:	4663      	mov	r3, ip
    973a:	ea4f 0343 	mov.w	r3, r3, lsl #1
    973e:	4463      	add	r3, ip
    9740:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9744:	440b      	add	r3, r1
    9746:	f503 730a 	add.w	r3, r3, #552	; 0x228
    974a:	7a1b      	ldrb	r3, [r3, #8]
    974c:	b2db      	uxtb	r3, r3
    974e:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
    9752:	79b9      	ldrb	r1, [r7, #6]
    9754:	440b      	add	r3, r1
    9756:	b2d9      	uxtb	r1, r3
    9758:	4603      	mov	r3, r0
    975a:	ea4f 0343 	mov.w	r3, r3, lsl #1
    975e:	4403      	add	r3, r0
    9760:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9764:	4413      	add	r3, r2
    9766:	f503 730a 	add.w	r3, r3, #552	; 0x228
    976a:	460a      	mov	r2, r1
    976c:	721a      	strb	r2, [r3, #8]
        }
    
        /* Restore SSE PC2 operations since no ACB accesses should take place
         * beyond this point. */
        ACE->PC2_CTRL = saved_pc2_ctrl;
    976e:	f240 0300 	movw	r3, #0
    9772:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9776:	697a      	ldr	r2, [r7, #20]
    9778:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    }
}
    977c:	f107 071c 	add.w	r7, r7, #28
    9780:	46bd      	mov	sp, r7
    9782:	bc80      	pop	{r7}
    9784:	4770      	bx	lr
    9786:	bf00      	nop

00009788 <ACE_set_comp_hysteresis>:
void ACE_set_comp_hysteresis
(
	comparator_id_t     comp_id,
    comp_hysteresis_t   hysteresis
)
{
    9788:	b480      	push	{r7}
    978a:	b087      	sub	sp, #28
    978c:	af00      	add	r7, sp, #0
    978e:	4602      	mov	r2, r0
    9790:	460b      	mov	r3, r1
    9792:	71fa      	strb	r2, [r7, #7]
    9794:	71bb      	strb	r3, [r7, #6]
    uint8_t scb_id;
    
    ASSERT( comp_id < NB_OF_COMPARATORS );
    9796:	79fb      	ldrb	r3, [r7, #7]
    9798:	2b09      	cmp	r3, #9
    979a:	d900      	bls.n	979e <ACE_set_comp_hysteresis+0x16>
    979c:	be00      	bkpt	0x0000
    ASSERT( hysteresis < NB_OF_HYSTERESIS );
    979e:	79bb      	ldrb	r3, [r7, #6]
    97a0:	2b03      	cmp	r3, #3
    97a2:	d900      	bls.n	97a6 <ACE_set_comp_hysteresis+0x1e>
    97a4:	be00      	bkpt	0x0000
    
    if ( (comp_id < NB_OF_COMPARATORS) && (hysteresis < NB_OF_HYSTERESIS) )
    97a6:	79fb      	ldrb	r3, [r7, #7]
    97a8:	2b09      	cmp	r3, #9
    97aa:	d87b      	bhi.n	98a4 <ACE_set_comp_hysteresis+0x11c>
    97ac:	79bb      	ldrb	r3, [r7, #6]
    97ae:	2b03      	cmp	r3, #3
    97b0:	d878      	bhi.n	98a4 <ACE_set_comp_hysteresis+0x11c>
    {
        uint32_t odd;
        uint32_t saved_pc2_ctrl;
        
        scb_id = comp_id_2_scb_lut[comp_id];
    97b2:	79fa      	ldrb	r2, [r7, #7]
    97b4:	f24b 7398 	movw	r3, #47000	; 0xb798
    97b8:	f2c0 0301 	movt	r3, #1
    97bc:	5c9b      	ldrb	r3, [r3, r2]
    97be:	73fb      	strb	r3, [r7, #15]
        odd = (uint32_t)comp_id & 0x01u;
    97c0:	79fb      	ldrb	r3, [r7, #7]
    97c2:	f003 0301 	and.w	r3, r3, #1
    97c6:	613b      	str	r3, [r7, #16]
        
        /* Pause the SSE PC2 while accesses to ACB from APB3 are taking place. */
        saved_pc2_ctrl = ACE->PC2_CTRL;
    97c8:	f240 0300 	movw	r3, #0
    97cc:	f2c4 0302 	movt	r3, #16386	; 0x4002
    97d0:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
    97d4:	617b      	str	r3, [r7, #20]
        ACE->PC2_CTRL = 0u;
    97d6:	f240 0300 	movw	r3, #0
    97da:	f2c4 0302 	movt	r3, #16386	; 0x4002
    97de:	f04f 0200 	mov.w	r2, #0
    97e2:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    
        if ( odd )
    97e6:	693b      	ldr	r3, [r7, #16]
    97e8:	2b00      	cmp	r3, #0
    97ea:	d02a      	beq.n	9842 <ACE_set_comp_hysteresis+0xba>
        {
            /* Temperature monitor block comparator. */
            ACE->ACB_DATA[scb_id].b10 = (ACE->ACB_DATA[scb_id].b10 & ~HYSTERESIS_MASK) | (uint8_t)((uint8_t)hysteresis << HYSTERESIS_SHIFT);
    97ec:	f240 0200 	movw	r2, #0
    97f0:	f2c4 0202 	movt	r2, #16386	; 0x4002
    97f4:	7bf8      	ldrb	r0, [r7, #15]
    97f6:	f240 0100 	movw	r1, #0
    97fa:	f2c4 0102 	movt	r1, #16386	; 0x4002
    97fe:	f897 c00f 	ldrb.w	ip, [r7, #15]
    9802:	4663      	mov	r3, ip
    9804:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9808:	4463      	add	r3, ip
    980a:	ea4f 1303 	mov.w	r3, r3, lsl #4
    980e:	440b      	add	r3, r1
    9810:	f503 730a 	add.w	r3, r3, #552	; 0x228
    9814:	791b      	ldrb	r3, [r3, #4]
    9816:	b2db      	uxtb	r3, r3
    9818:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    981c:	79b9      	ldrb	r1, [r7, #6]
    981e:	ea4f 1181 	mov.w	r1, r1, lsl #6
    9822:	b2c9      	uxtb	r1, r1
    9824:	ea43 0301 	orr.w	r3, r3, r1
    9828:	b2d9      	uxtb	r1, r3
    982a:	4603      	mov	r3, r0
    982c:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9830:	4403      	add	r3, r0
    9832:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9836:	4413      	add	r3, r2
    9838:	f503 730a 	add.w	r3, r3, #552	; 0x228
    983c:	460a      	mov	r2, r1
    983e:	711a      	strb	r2, [r3, #4]
    9840:	e029      	b.n	9896 <ACE_set_comp_hysteresis+0x10e>
        }
        else
        {
            /* Current monitor block comparator. */
            ACE->ACB_DATA[scb_id].b9 = (ACE->ACB_DATA[scb_id].b9 & ~HYSTERESIS_MASK) | (uint8_t)((uint8_t)hysteresis << HYSTERESIS_SHIFT);
    9842:	f240 0200 	movw	r2, #0
    9846:	f2c4 0202 	movt	r2, #16386	; 0x4002
    984a:	7bf8      	ldrb	r0, [r7, #15]
    984c:	f240 0100 	movw	r1, #0
    9850:	f2c4 0102 	movt	r1, #16386	; 0x4002
    9854:	f897 c00f 	ldrb.w	ip, [r7, #15]
    9858:	4663      	mov	r3, ip
    985a:	ea4f 0343 	mov.w	r3, r3, lsl #1
    985e:	4463      	add	r3, ip
    9860:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9864:	440b      	add	r3, r1
    9866:	f503 7308 	add.w	r3, r3, #544	; 0x220
    986a:	7a1b      	ldrb	r3, [r3, #8]
    986c:	b2db      	uxtb	r3, r3
    986e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    9872:	79b9      	ldrb	r1, [r7, #6]
    9874:	ea4f 1181 	mov.w	r1, r1, lsl #6
    9878:	b2c9      	uxtb	r1, r1
    987a:	ea43 0301 	orr.w	r3, r3, r1
    987e:	b2d9      	uxtb	r1, r3
    9880:	4603      	mov	r3, r0
    9882:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9886:	4403      	add	r3, r0
    9888:	ea4f 1303 	mov.w	r3, r3, lsl #4
    988c:	4413      	add	r3, r2
    988e:	f503 7308 	add.w	r3, r3, #544	; 0x220
    9892:	460a      	mov	r2, r1
    9894:	721a      	strb	r2, [r3, #8]
        }
        
        /* Restore SSE PC2 operations since no ACB accesses should take place
         * beyond this point. */
        ACE->PC2_CTRL = saved_pc2_ctrl;
    9896:	f240 0300 	movw	r3, #0
    989a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    989e:	697a      	ldr	r2, [r7, #20]
    98a0:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    }
}
    98a4:	f107 071c 	add.w	r7, r7, #28
    98a8:	46bd      	mov	sp, r7
    98aa:	bc80      	pop	{r7}
    98ac:	4770      	bx	lr
    98ae:	bf00      	nop

000098b0 <ACE_enable_comp>:
 */
void ACE_enable_comp
(
	comparator_id_t comp_id
)
{
    98b0:	b480      	push	{r7}
    98b2:	b087      	sub	sp, #28
    98b4:	af00      	add	r7, sp, #0
    98b6:	4603      	mov	r3, r0
    98b8:	71fb      	strb	r3, [r7, #7]
    uint8_t scb_id;
    
    ASSERT( comp_id < NB_OF_COMPARATORS );
    98ba:	79fb      	ldrb	r3, [r7, #7]
    98bc:	2b09      	cmp	r3, #9
    98be:	d900      	bls.n	98c2 <ACE_enable_comp+0x12>
    98c0:	be00      	bkpt	0x0000
    
    if ( comp_id < NB_OF_COMPARATORS )
    98c2:	79fb      	ldrb	r3, [r7, #7]
    98c4:	2b09      	cmp	r3, #9
    98c6:	d86c      	bhi.n	99a2 <ACE_enable_comp+0xf2>
    {
        uint32_t odd;
        uint32_t saved_pc2_ctrl;
        
        scb_id = comp_id_2_scb_lut[comp_id];
    98c8:	79fa      	ldrb	r2, [r7, #7]
    98ca:	f24b 7398 	movw	r3, #47000	; 0xb798
    98ce:	f2c0 0301 	movt	r3, #1
    98d2:	5c9b      	ldrb	r3, [r3, r2]
    98d4:	73fb      	strb	r3, [r7, #15]
        odd = (uint32_t)comp_id & 0x01u;
    98d6:	79fb      	ldrb	r3, [r7, #7]
    98d8:	f003 0301 	and.w	r3, r3, #1
    98dc:	613b      	str	r3, [r7, #16]
        
        /* Pause the SSE PC2 while accesses to ACB from APB3 are taking place. */
        saved_pc2_ctrl = ACE->PC2_CTRL;
    98de:	f240 0300 	movw	r3, #0
    98e2:	f2c4 0302 	movt	r3, #16386	; 0x4002
    98e6:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
    98ea:	617b      	str	r3, [r7, #20]
        ACE->PC2_CTRL = 0u;
    98ec:	f240 0300 	movw	r3, #0
    98f0:	f2c4 0302 	movt	r3, #16386	; 0x4002
    98f4:	f04f 0200 	mov.w	r2, #0
    98f8:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
        
        if ( odd )
    98fc:	693b      	ldr	r3, [r7, #16]
    98fe:	2b00      	cmp	r3, #0
    9900:	d024      	beq.n	994c <ACE_enable_comp+0x9c>
        {
            /* Temperature monitor block comparator. */
            ACE->ACB_DATA[scb_id].b10 |= COMPARATOR_ENABLE_MASK;
    9902:	f240 0200 	movw	r2, #0
    9906:	f2c4 0202 	movt	r2, #16386	; 0x4002
    990a:	7bf8      	ldrb	r0, [r7, #15]
    990c:	f240 0100 	movw	r1, #0
    9910:	f2c4 0102 	movt	r1, #16386	; 0x4002
    9914:	f897 c00f 	ldrb.w	ip, [r7, #15]
    9918:	4663      	mov	r3, ip
    991a:	ea4f 0343 	mov.w	r3, r3, lsl #1
    991e:	4463      	add	r3, ip
    9920:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9924:	440b      	add	r3, r1
    9926:	f503 730a 	add.w	r3, r3, #552	; 0x228
    992a:	791b      	ldrb	r3, [r3, #4]
    992c:	b2db      	uxtb	r3, r3
    992e:	f043 0310 	orr.w	r3, r3, #16
    9932:	b2d9      	uxtb	r1, r3
    9934:	4603      	mov	r3, r0
    9936:	ea4f 0343 	mov.w	r3, r3, lsl #1
    993a:	4403      	add	r3, r0
    993c:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9940:	4413      	add	r3, r2
    9942:	f503 730a 	add.w	r3, r3, #552	; 0x228
    9946:	460a      	mov	r2, r1
    9948:	711a      	strb	r2, [r3, #4]
    994a:	e023      	b.n	9994 <ACE_enable_comp+0xe4>
        }
        else
        {
            /* Current monitor block comparator. */
            ACE->ACB_DATA[scb_id].b9 |= COMPARATOR_ENABLE_MASK;
    994c:	f240 0200 	movw	r2, #0
    9950:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9954:	7bf8      	ldrb	r0, [r7, #15]
    9956:	f240 0100 	movw	r1, #0
    995a:	f2c4 0102 	movt	r1, #16386	; 0x4002
    995e:	f897 c00f 	ldrb.w	ip, [r7, #15]
    9962:	4663      	mov	r3, ip
    9964:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9968:	4463      	add	r3, ip
    996a:	ea4f 1303 	mov.w	r3, r3, lsl #4
    996e:	440b      	add	r3, r1
    9970:	f503 7308 	add.w	r3, r3, #544	; 0x220
    9974:	7a1b      	ldrb	r3, [r3, #8]
    9976:	b2db      	uxtb	r3, r3
    9978:	f043 0310 	orr.w	r3, r3, #16
    997c:	b2d9      	uxtb	r1, r3
    997e:	4603      	mov	r3, r0
    9980:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9984:	4403      	add	r3, r0
    9986:	ea4f 1303 	mov.w	r3, r3, lsl #4
    998a:	4413      	add	r3, r2
    998c:	f503 7308 	add.w	r3, r3, #544	; 0x220
    9990:	460a      	mov	r2, r1
    9992:	721a      	strb	r2, [r3, #8]
        }
        
        /* Restore SSE PC2 operations since no ACB accesses should take place
         * beyond this point. */
        ACE->PC2_CTRL = saved_pc2_ctrl;
    9994:	f240 0300 	movw	r3, #0
    9998:	f2c4 0302 	movt	r3, #16386	; 0x4002
    999c:	697a      	ldr	r2, [r7, #20]
    999e:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    }
}
    99a2:	f107 071c 	add.w	r7, r7, #28
    99a6:	46bd      	mov	sp, r7
    99a8:	bc80      	pop	{r7}
    99aa:	4770      	bx	lr

000099ac <ACE_disable_comp>:
 */
void ACE_disable_comp
(
	comparator_id_t comp_id
)
{
    99ac:	b480      	push	{r7}
    99ae:	b087      	sub	sp, #28
    99b0:	af00      	add	r7, sp, #0
    99b2:	4603      	mov	r3, r0
    99b4:	71fb      	strb	r3, [r7, #7]
    uint8_t scb_id;
    
    ASSERT( comp_id < NB_OF_COMPARATORS );
    99b6:	79fb      	ldrb	r3, [r7, #7]
    99b8:	2b09      	cmp	r3, #9
    99ba:	d900      	bls.n	99be <ACE_disable_comp+0x12>
    99bc:	be00      	bkpt	0x0000
    
    if ( comp_id < NB_OF_COMPARATORS )
    99be:	79fb      	ldrb	r3, [r7, #7]
    99c0:	2b09      	cmp	r3, #9
    99c2:	d86a      	bhi.n	9a9a <ACE_disable_comp+0xee>
    {
        uint32_t odd;
        uint32_t saved_pc2_ctrl;
        
        scb_id = comp_id_2_scb_lut[comp_id];
    99c4:	79fa      	ldrb	r2, [r7, #7]
    99c6:	f24b 7398 	movw	r3, #47000	; 0xb798
    99ca:	f2c0 0301 	movt	r3, #1
    99ce:	5c9b      	ldrb	r3, [r3, r2]
    99d0:	73fb      	strb	r3, [r7, #15]
        odd = (uint32_t)comp_id & 0x01u;
    99d2:	79fb      	ldrb	r3, [r7, #7]
    99d4:	f003 0301 	and.w	r3, r3, #1
    99d8:	613b      	str	r3, [r7, #16]
        
        /* Pause the SSE PC2 while accesses to ACB from APB3 are taking place. */
        saved_pc2_ctrl = ACE->PC2_CTRL;
    99da:	f240 0300 	movw	r3, #0
    99de:	f2c4 0302 	movt	r3, #16386	; 0x4002
    99e2:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
    99e6:	617b      	str	r3, [r7, #20]
        ACE->PC2_CTRL = 0u;
    99e8:	f240 0300 	movw	r3, #0
    99ec:	f2c4 0302 	movt	r3, #16386	; 0x4002
    99f0:	f04f 0200 	mov.w	r2, #0
    99f4:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
        
        if ( odd )
    99f8:	693b      	ldr	r3, [r7, #16]
    99fa:	2b00      	cmp	r3, #0
    99fc:	d023      	beq.n	9a46 <ACE_disable_comp+0x9a>
        {
            /* Temperature monitor block comparator. */
            ACE->ACB_DATA[scb_id].b10 &= (uint8_t)~COMPARATOR_ENABLE_MASK;
    99fe:	f240 0100 	movw	r1, #0
    9a02:	f2c4 0102 	movt	r1, #16386	; 0x4002
    9a06:	7bf8      	ldrb	r0, [r7, #15]
    9a08:	f240 0200 	movw	r2, #0
    9a0c:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9a10:	f897 c00f 	ldrb.w	ip, [r7, #15]
    9a14:	4663      	mov	r3, ip
    9a16:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9a1a:	4463      	add	r3, ip
    9a1c:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9a20:	4413      	add	r3, r2
    9a22:	f503 730a 	add.w	r3, r3, #552	; 0x228
    9a26:	791b      	ldrb	r3, [r3, #4]
    9a28:	b2db      	uxtb	r3, r3
    9a2a:	461a      	mov	r2, r3
    9a2c:	f002 02ef 	and.w	r2, r2, #239	; 0xef
    9a30:	4603      	mov	r3, r0
    9a32:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9a36:	4403      	add	r3, r0
    9a38:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9a3c:	440b      	add	r3, r1
    9a3e:	f503 730a 	add.w	r3, r3, #552	; 0x228
    9a42:	711a      	strb	r2, [r3, #4]
    9a44:	e022      	b.n	9a8c <ACE_disable_comp+0xe0>
        }
        else
        {
            /* Current monitor block comparator. */
            ACE->ACB_DATA[scb_id].b9 &= (uint8_t)~COMPARATOR_ENABLE_MASK;
    9a46:	f240 0100 	movw	r1, #0
    9a4a:	f2c4 0102 	movt	r1, #16386	; 0x4002
    9a4e:	7bf8      	ldrb	r0, [r7, #15]
    9a50:	f240 0200 	movw	r2, #0
    9a54:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9a58:	f897 c00f 	ldrb.w	ip, [r7, #15]
    9a5c:	4663      	mov	r3, ip
    9a5e:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9a62:	4463      	add	r3, ip
    9a64:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9a68:	4413      	add	r3, r2
    9a6a:	f503 7308 	add.w	r3, r3, #544	; 0x220
    9a6e:	7a1b      	ldrb	r3, [r3, #8]
    9a70:	b2db      	uxtb	r3, r3
    9a72:	461a      	mov	r2, r3
    9a74:	f002 02ef 	and.w	r2, r2, #239	; 0xef
    9a78:	4603      	mov	r3, r0
    9a7a:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9a7e:	4403      	add	r3, r0
    9a80:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9a84:	440b      	add	r3, r1
    9a86:	f503 7308 	add.w	r3, r3, #544	; 0x220
    9a8a:	721a      	strb	r2, [r3, #8]
        }
        
        /* Restore SSE PC2 operations since no ACB accesses should take place
         * beyond this point. */
        ACE->PC2_CTRL = saved_pc2_ctrl;
    9a8c:	f240 0300 	movw	r3, #0
    9a90:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9a94:	697a      	ldr	r2, [r7, #20]
    9a96:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    }
}
    9a9a:	f107 071c 	add.w	r7, r7, #28
    9a9e:	46bd      	mov	sp, r7
    9aa0:	bc80      	pop	{r7}
    9aa2:	4770      	bx	lr

00009aa4 <ACE_enable_comp_rise_irq>:
 */
void ACE_enable_comp_rise_irq
(
	comparator_id_t comp_id
)
{
    9aa4:	b480      	push	{r7}
    9aa6:	b083      	sub	sp, #12
    9aa8:	af00      	add	r7, sp, #0
    9aaa:	4603      	mov	r3, r0
    9aac:	71fb      	strb	r3, [r7, #7]
    ASSERT( comp_id < NB_OF_COMPARATORS );
    9aae:	79fb      	ldrb	r3, [r7, #7]
    9ab0:	2b09      	cmp	r3, #9
    9ab2:	d900      	bls.n	9ab6 <ACE_enable_comp_rise_irq+0x12>
    9ab4:	be00      	bkpt	0x0000
    
    ACE->COMP_IRQ_EN |= (uint32_t)(FIRST_RISE_IRQ_MASK << (uint32_t)comp_id);
    9ab6:	f240 0300 	movw	r3, #0
    9aba:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9abe:	f240 0200 	movw	r2, #0
    9ac2:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9ac6:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    9aca:	f102 020c 	add.w	r2, r2, #12
    9ace:	6811      	ldr	r1, [r2, #0]
    9ad0:	79fa      	ldrb	r2, [r7, #7]
    9ad2:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    9ad6:	fa00 f202 	lsl.w	r2, r0, r2
    9ada:	ea41 0202 	orr.w	r2, r1, r2
    9ade:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    9ae2:	f103 030c 	add.w	r3, r3, #12
    9ae6:	601a      	str	r2, [r3, #0]
}
    9ae8:	f107 070c 	add.w	r7, r7, #12
    9aec:	46bd      	mov	sp, r7
    9aee:	bc80      	pop	{r7}
    9af0:	4770      	bx	lr
    9af2:	bf00      	nop

00009af4 <ACE_disable_comp_rise_irq>:
 */
void ACE_disable_comp_rise_irq
(
	comparator_id_t comp_id
)
{
    9af4:	b480      	push	{r7}
    9af6:	b085      	sub	sp, #20
    9af8:	af00      	add	r7, sp, #0
    9afa:	4603      	mov	r3, r0
    9afc:	71fb      	strb	r3, [r7, #7]
    volatile uint32_t dummy_read;
    
    ASSERT( comp_id < NB_OF_COMPARATORS );
    9afe:	79fb      	ldrb	r3, [r7, #7]
    9b00:	2b09      	cmp	r3, #9
    9b02:	d900      	bls.n	9b06 <ACE_disable_comp_rise_irq+0x12>
    9b04:	be00      	bkpt	0x0000
    
    ACE->COMP_IRQ_EN &= ~(FIRST_RISE_IRQ_MASK << (uint32_t)comp_id);
    9b06:	f240 0300 	movw	r3, #0
    9b0a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9b0e:	f240 0200 	movw	r2, #0
    9b12:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9b16:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    9b1a:	f102 020c 	add.w	r2, r2, #12
    9b1e:	6811      	ldr	r1, [r2, #0]
    9b20:	79fa      	ldrb	r2, [r7, #7]
    9b22:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    9b26:	fa00 f202 	lsl.w	r2, r0, r2
    9b2a:	ea6f 0202 	mvn.w	r2, r2
    9b2e:	ea01 0202 	and.w	r2, r1, r2
    9b32:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    9b36:	f103 030c 	add.w	r3, r3, #12
    9b3a:	601a      	str	r2, [r3, #0]
    /*
     * Ensure that the posted write to the COMP_IRQ_EN register completed before
     * returning from this function. Not doing this may result in the interrupt
     * only being disabled some time after this function returns.
     */
    dummy_read = ACE->COMP_IRQ_EN;
    9b3c:	f240 0300 	movw	r3, #0
    9b40:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9b44:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    9b48:	f103 030c 	add.w	r3, r3, #12
    9b4c:	681b      	ldr	r3, [r3, #0]
    9b4e:	60fb      	str	r3, [r7, #12]
    ++dummy_read;
    9b50:	68fb      	ldr	r3, [r7, #12]
    9b52:	f103 0301 	add.w	r3, r3, #1
    9b56:	60fb      	str	r3, [r7, #12]
}
    9b58:	f107 0714 	add.w	r7, r7, #20
    9b5c:	46bd      	mov	sp, r7
    9b5e:	bc80      	pop	{r7}
    9b60:	4770      	bx	lr
    9b62:	bf00      	nop

00009b64 <ACE_clear_comp_rise_irq>:
 */
void ACE_clear_comp_rise_irq
(
	comparator_id_t comp_id
)
{
    9b64:	b480      	push	{r7}
    9b66:	b085      	sub	sp, #20
    9b68:	af00      	add	r7, sp, #0
    9b6a:	4603      	mov	r3, r0
    9b6c:	71fb      	strb	r3, [r7, #7]
    volatile uint32_t dummy_read;
    
    ASSERT( comp_id < NB_OF_COMPARATORS );
    9b6e:	79fb      	ldrb	r3, [r7, #7]
    9b70:	2b09      	cmp	r3, #9
    9b72:	d900      	bls.n	9b76 <ACE_clear_comp_rise_irq+0x12>
    9b74:	be00      	bkpt	0x0000
    
    ACE->COMP_IRQ_CLR |= (FIRST_RISE_IRQ_MASK << (uint32_t)comp_id);
    9b76:	f240 0300 	movw	r3, #0
    9b7a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9b7e:	f240 0200 	movw	r2, #0
    9b82:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9b86:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    9b8a:	f102 0214 	add.w	r2, r2, #20
    9b8e:	6811      	ldr	r1, [r2, #0]
    9b90:	79fa      	ldrb	r2, [r7, #7]
    9b92:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    9b96:	fa00 f202 	lsl.w	r2, r0, r2
    9b9a:	ea41 0202 	orr.w	r2, r1, r2
    9b9e:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    9ba2:	f103 0314 	add.w	r3, r3, #20
    9ba6:	601a      	str	r2, [r3, #0]
     * Ensure that the posted write to the COMP_IRQ_CLR register completed before
     * returning from this function. Not doing this may result in the interrupt
     * retriggering if the Cortex-M3 returns from interrupt before the posted
     * write completes.
     */
    dummy_read = ACE->COMP_IRQ_CLR;
    9ba8:	f240 0300 	movw	r3, #0
    9bac:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9bb0:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    9bb4:	f103 0314 	add.w	r3, r3, #20
    9bb8:	681b      	ldr	r3, [r3, #0]
    9bba:	60fb      	str	r3, [r7, #12]
    ++dummy_read;
    9bbc:	68fb      	ldr	r3, [r7, #12]
    9bbe:	f103 0301 	add.w	r3, r3, #1
    9bc2:	60fb      	str	r3, [r7, #12]
}
    9bc4:	f107 0714 	add.w	r7, r7, #20
    9bc8:	46bd      	mov	sp, r7
    9bca:	bc80      	pop	{r7}
    9bcc:	4770      	bx	lr
    9bce:	bf00      	nop

00009bd0 <ACE_enable_comp_fall_irq>:
 */
void ACE_enable_comp_fall_irq
(
	comparator_id_t comp_id
)
{
    9bd0:	b480      	push	{r7}
    9bd2:	b083      	sub	sp, #12
    9bd4:	af00      	add	r7, sp, #0
    9bd6:	4603      	mov	r3, r0
    9bd8:	71fb      	strb	r3, [r7, #7]
    ASSERT( comp_id < NB_OF_COMPARATORS );
    9bda:	79fb      	ldrb	r3, [r7, #7]
    9bdc:	2b09      	cmp	r3, #9
    9bde:	d900      	bls.n	9be2 <ACE_enable_comp_fall_irq+0x12>
    9be0:	be00      	bkpt	0x0000
    
    ACE->COMP_IRQ_EN |= (uint32_t)(FIRST_FALL_IRQ_MASK << (uint32_t)comp_id);
    9be2:	f240 0300 	movw	r3, #0
    9be6:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9bea:	f240 0200 	movw	r2, #0
    9bee:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9bf2:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    9bf6:	f102 020c 	add.w	r2, r2, #12
    9bfa:	6811      	ldr	r1, [r2, #0]
    9bfc:	79fa      	ldrb	r2, [r7, #7]
    9bfe:	f04f 0001 	mov.w	r0, #1
    9c02:	fa00 f202 	lsl.w	r2, r0, r2
    9c06:	ea41 0202 	orr.w	r2, r1, r2
    9c0a:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    9c0e:	f103 030c 	add.w	r3, r3, #12
    9c12:	601a      	str	r2, [r3, #0]
}
    9c14:	f107 070c 	add.w	r7, r7, #12
    9c18:	46bd      	mov	sp, r7
    9c1a:	bc80      	pop	{r7}
    9c1c:	4770      	bx	lr
    9c1e:	bf00      	nop

00009c20 <ACE_disable_comp_fall_irq>:
 */
void ACE_disable_comp_fall_irq
(
	comparator_id_t comp_id
)
{
    9c20:	b480      	push	{r7}
    9c22:	b085      	sub	sp, #20
    9c24:	af00      	add	r7, sp, #0
    9c26:	4603      	mov	r3, r0
    9c28:	71fb      	strb	r3, [r7, #7]
    volatile uint32_t dummy_read;
    
    ASSERT( comp_id < NB_OF_COMPARATORS );
    9c2a:	79fb      	ldrb	r3, [r7, #7]
    9c2c:	2b09      	cmp	r3, #9
    9c2e:	d900      	bls.n	9c32 <ACE_disable_comp_fall_irq+0x12>
    9c30:	be00      	bkpt	0x0000
    
    ACE->COMP_IRQ_EN &= ~(FIRST_FALL_IRQ_MASK << (uint32_t)comp_id);
    9c32:	f240 0300 	movw	r3, #0
    9c36:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9c3a:	f240 0200 	movw	r2, #0
    9c3e:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9c42:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    9c46:	f102 020c 	add.w	r2, r2, #12
    9c4a:	6811      	ldr	r1, [r2, #0]
    9c4c:	79fa      	ldrb	r2, [r7, #7]
    9c4e:	f04f 0001 	mov.w	r0, #1
    9c52:	fa00 f202 	lsl.w	r2, r0, r2
    9c56:	ea6f 0202 	mvn.w	r2, r2
    9c5a:	ea01 0202 	and.w	r2, r1, r2
    9c5e:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    9c62:	f103 030c 	add.w	r3, r3, #12
    9c66:	601a      	str	r2, [r3, #0]
    /*
     * Ensure that the posted write to the COMP_IRQ_EN register completed before
     * returning from this function. Not doing this may result in the interrupt
     * only being disabled some time after this function returns.
     */
    dummy_read = ACE->COMP_IRQ_EN;
    9c68:	f240 0300 	movw	r3, #0
    9c6c:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9c70:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    9c74:	f103 030c 	add.w	r3, r3, #12
    9c78:	681b      	ldr	r3, [r3, #0]
    9c7a:	60fb      	str	r3, [r7, #12]
    ++dummy_read;
    9c7c:	68fb      	ldr	r3, [r7, #12]
    9c7e:	f103 0301 	add.w	r3, r3, #1
    9c82:	60fb      	str	r3, [r7, #12]
}
    9c84:	f107 0714 	add.w	r7, r7, #20
    9c88:	46bd      	mov	sp, r7
    9c8a:	bc80      	pop	{r7}
    9c8c:	4770      	bx	lr
    9c8e:	bf00      	nop

00009c90 <ACE_clear_comp_fall_irq>:
 */
void ACE_clear_comp_fall_irq
(
	comparator_id_t comp_id
)
{
    9c90:	b480      	push	{r7}
    9c92:	b085      	sub	sp, #20
    9c94:	af00      	add	r7, sp, #0
    9c96:	4603      	mov	r3, r0
    9c98:	71fb      	strb	r3, [r7, #7]
    volatile uint32_t dummy_read;
    
    ASSERT( comp_id < NB_OF_COMPARATORS );
    9c9a:	79fb      	ldrb	r3, [r7, #7]
    9c9c:	2b09      	cmp	r3, #9
    9c9e:	d900      	bls.n	9ca2 <ACE_clear_comp_fall_irq+0x12>
    9ca0:	be00      	bkpt	0x0000
    
    ACE->COMP_IRQ_CLR |= (FIRST_FALL_IRQ_MASK << (uint32_t)comp_id);
    9ca2:	f240 0300 	movw	r3, #0
    9ca6:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9caa:	f240 0200 	movw	r2, #0
    9cae:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9cb2:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    9cb6:	f102 0214 	add.w	r2, r2, #20
    9cba:	6811      	ldr	r1, [r2, #0]
    9cbc:	79fa      	ldrb	r2, [r7, #7]
    9cbe:	f04f 0001 	mov.w	r0, #1
    9cc2:	fa00 f202 	lsl.w	r2, r0, r2
    9cc6:	ea41 0202 	orr.w	r2, r1, r2
    9cca:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    9cce:	f103 0314 	add.w	r3, r3, #20
    9cd2:	601a      	str	r2, [r3, #0]
     * Ensure that the posted write to the COMP_IRQ_CLR register completed before
     * returning from this function. Not doing this may result in the interrupt
     * retriggering if the Cortex-M3 returns from interrupt before the posted
     * write completes.
     */
    dummy_read = ACE->COMP_IRQ_CLR;
    9cd4:	f240 0300 	movw	r3, #0
    9cd8:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9cdc:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    9ce0:	f103 0314 	add.w	r3, r3, #20
    9ce4:	681b      	ldr	r3, [r3, #0]
    9ce6:	60fb      	str	r3, [r7, #12]
    ++dummy_read;
    9ce8:	68fb      	ldr	r3, [r7, #12]
    9cea:	f103 0301 	add.w	r3, r3, #1
    9cee:	60fb      	str	r3, [r7, #12]
}
    9cf0:	f107 0714 	add.w	r7, r7, #20
    9cf4:	46bd      	mov	sp, r7
    9cf6:	bc80      	pop	{r7}
    9cf8:	4770      	bx	lr
    9cfa:	bf00      	nop

00009cfc <ACE_get_comp_status>:

/*-------------------------------------------------------------------------*//**
 * Returns the raw analog quad comparator status.
 */
uint32_t ACE_get_comp_status( void )
{
    9cfc:	b480      	push	{r7}
    9cfe:	af00      	add	r7, sp, #0
    return ACE->COMP_IRQ;
    9d00:	f240 0300 	movw	r3, #0
    9d04:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9d08:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    9d0c:	f103 0310 	add.w	r3, r3, #16
    9d10:	681b      	ldr	r3, [r3, #0]
}
    9d12:	4618      	mov	r0, r3
    9d14:	46bd      	mov	sp, r7
    9d16:	bc80      	pop	{r7}
    9d18:	4770      	bx	lr
    9d1a:	bf00      	nop

00009d1c <ACE_get_channel_count>:
uint32_t
ACE_get_channel_count
(
    void
)
{
    9d1c:	b480      	push	{r7}
    9d1e:	af00      	add	r7, sp, #0
    return (uint32_t)ACE_NB_OF_INPUT_CHANNELS;
    9d20:	f04f 0303 	mov.w	r3, #3
}
    9d24:	4618      	mov	r0, r3
    9d26:	46bd      	mov	sp, r7
    9d28:	bc80      	pop	{r7}
    9d2a:	4770      	bx	lr

00009d2c <ACE_get_first_channel>:
ace_channel_handle_t
ACE_get_first_channel
(
    void
)
{
    9d2c:	b480      	push	{r7}
    9d2e:	b083      	sub	sp, #12
    9d30:	af00      	add	r7, sp, #0
    ace_channel_handle_t channel_handle;
    
    channel_handle = (ace_channel_handle_t)0;
    9d32:	f04f 0300 	mov.w	r3, #0
    9d36:	71fb      	strb	r3, [r7, #7]
    
    return channel_handle;
    9d38:	79fb      	ldrb	r3, [r7, #7]
}
    9d3a:	4618      	mov	r0, r3
    9d3c:	f107 070c 	add.w	r7, r7, #12
    9d40:	46bd      	mov	sp, r7
    9d42:	bc80      	pop	{r7}
    9d44:	4770      	bx	lr
    9d46:	bf00      	nop

00009d48 <ACE_get_next_channel>:
ace_channel_handle_t
ACE_get_next_channel
(
    ace_channel_handle_t channel_handle
)
{
    9d48:	b480      	push	{r7}
    9d4a:	b083      	sub	sp, #12
    9d4c:	af00      	add	r7, sp, #0
    9d4e:	4603      	mov	r3, r0
    9d50:	71fb      	strb	r3, [r7, #7]
    ++channel_handle;
    9d52:	79fb      	ldrb	r3, [r7, #7]
    9d54:	f103 0301 	add.w	r3, r3, #1
    9d58:	71fb      	strb	r3, [r7, #7]
    
    if ( channel_handle >= NB_OF_ACE_CHANNEL_HANDLES )
    9d5a:	79fb      	ldrb	r3, [r7, #7]
    9d5c:	2b02      	cmp	r3, #2
    9d5e:	d902      	bls.n	9d66 <ACE_get_next_channel+0x1e>
    {
         channel_handle = (ace_channel_handle_t)0;
    9d60:	f04f 0300 	mov.w	r3, #0
    9d64:	71fb      	strb	r3, [r7, #7]
    }
    
    return channel_handle;
    9d66:	79fb      	ldrb	r3, [r7, #7]
}
    9d68:	4618      	mov	r0, r3
    9d6a:	f107 070c 	add.w	r7, r7, #12
    9d6e:	46bd      	mov	sp, r7
    9d70:	bc80      	pop	{r7}
    9d72:	4770      	bx	lr

00009d74 <ACE_get_channel_handle>:
ace_channel_handle_t
ACE_get_channel_handle
(
    const uint8_t * p_sz_channel_name
)
{
    9d74:	b580      	push	{r7, lr}
    9d76:	b084      	sub	sp, #16
    9d78:	af00      	add	r7, sp, #0
    9d7a:	6078      	str	r0, [r7, #4]
    uint16_t channel_idx;
    ace_channel_handle_t channel_handle = INVALID_CHANNEL_HANDLE;
    9d7c:	f04f 0303 	mov.w	r3, #3
    9d80:	72fb      	strb	r3, [r7, #11]
    
    for ( channel_idx = 0u;  channel_idx < (uint16_t)ACE_NB_OF_INPUT_CHANNELS; ++channel_idx )
    9d82:	f04f 0300 	mov.w	r3, #0
    9d86:	813b      	strh	r3, [r7, #8]
    9d88:	e025      	b.n	9dd6 <ACE_get_channel_handle+0x62>
    {
        if ( g_ace_channel_desc_table[channel_idx].p_sz_channel_name != 0 )
    9d8a:	893a      	ldrh	r2, [r7, #8]
    9d8c:	f240 035c 	movw	r3, #92	; 0x5c
    9d90:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9d94:	ea4f 1202 	mov.w	r2, r2, lsl #4
    9d98:	4413      	add	r3, r2
    9d9a:	681b      	ldr	r3, [r3, #0]
    9d9c:	2b00      	cmp	r3, #0
    9d9e:	d016      	beq.n	9dce <ACE_get_channel_handle+0x5a>
        {
            int32_t diff;
            diff = strncmp( (const char*)p_sz_channel_name, (const char*)g_ace_channel_desc_table[channel_idx].p_sz_channel_name, (size_t)MAX_CHANNEL_NAME_LENGTH );
    9da0:	893a      	ldrh	r2, [r7, #8]
    9da2:	f240 035c 	movw	r3, #92	; 0x5c
    9da6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9daa:	ea4f 1202 	mov.w	r2, r2, lsl #4
    9dae:	4413      	add	r3, r2
    9db0:	681b      	ldr	r3, [r3, #0]
    9db2:	6878      	ldr	r0, [r7, #4]
    9db4:	4619      	mov	r1, r3
    9db6:	f04f 0214 	mov.w	r2, #20
    9dba:	f00b faef 	bl	1539c <strncmp>
    9dbe:	4603      	mov	r3, r0
    9dc0:	60fb      	str	r3, [r7, #12]
            if ( 0 == diff )
    9dc2:	68fb      	ldr	r3, [r7, #12]
    9dc4:	2b00      	cmp	r3, #0
    9dc6:	d102      	bne.n	9dce <ACE_get_channel_handle+0x5a>
            {
                /* channel name found. */
                channel_handle = (ace_channel_handle_t)channel_idx;
    9dc8:	893b      	ldrh	r3, [r7, #8]
    9dca:	72fb      	strb	r3, [r7, #11]
                break;
    9dcc:	e006      	b.n	9ddc <ACE_get_channel_handle+0x68>
)
{
    uint16_t channel_idx;
    ace_channel_handle_t channel_handle = INVALID_CHANNEL_HANDLE;
    
    for ( channel_idx = 0u;  channel_idx < (uint16_t)ACE_NB_OF_INPUT_CHANNELS; ++channel_idx )
    9dce:	893b      	ldrh	r3, [r7, #8]
    9dd0:	f103 0301 	add.w	r3, r3, #1
    9dd4:	813b      	strh	r3, [r7, #8]
    9dd6:	893b      	ldrh	r3, [r7, #8]
    9dd8:	2b02      	cmp	r3, #2
    9dda:	d9d6      	bls.n	9d8a <ACE_get_channel_handle+0x16>
                channel_handle = (ace_channel_handle_t)channel_idx;
                break;
            }
        }
    }
    return channel_handle;
    9ddc:	7afb      	ldrb	r3, [r7, #11]
}
    9dde:	4618      	mov	r0, r3
    9de0:	f107 0710 	add.w	r7, r7, #16
    9de4:	46bd      	mov	sp, r7
    9de6:	bd80      	pop	{r7, pc}

00009de8 <ACE_get_input_channel_handle>:
ace_channel_handle_t
ACE_get_input_channel_handle
(
    adc_channel_id_t    channel_id
)
{
    9de8:	b480      	push	{r7}
    9dea:	b085      	sub	sp, #20
    9dec:	af00      	add	r7, sp, #0
    9dee:	4603      	mov	r3, r0
    9df0:	71fb      	strb	r3, [r7, #7]
    uint16_t channel_idx;
    ace_channel_handle_t channel_handle = INVALID_CHANNEL_HANDLE;
    9df2:	f04f 0303 	mov.w	r3, #3
    9df6:	73fb      	strb	r3, [r7, #15]
    
    for ( channel_idx = 0u;  channel_idx < (uint16_t)ACE_NB_OF_INPUT_CHANNELS; ++channel_idx )
    9df8:	f04f 0300 	mov.w	r3, #0
    9dfc:	81bb      	strh	r3, [r7, #12]
    9dfe:	e012      	b.n	9e26 <ACE_get_input_channel_handle+0x3e>
    {
        if ( g_ace_channel_desc_table[channel_idx].signal_id == channel_id )
    9e00:	89ba      	ldrh	r2, [r7, #12]
    9e02:	f240 035c 	movw	r3, #92	; 0x5c
    9e06:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9e0a:	ea4f 1202 	mov.w	r2, r2, lsl #4
    9e0e:	4413      	add	r3, r2
    9e10:	791b      	ldrb	r3, [r3, #4]
    9e12:	79fa      	ldrb	r2, [r7, #7]
    9e14:	429a      	cmp	r2, r3
    9e16:	d102      	bne.n	9e1e <ACE_get_input_channel_handle+0x36>
        {
            /* channel ID found. */
            channel_handle = (ace_channel_handle_t)channel_idx;
    9e18:	89bb      	ldrh	r3, [r7, #12]
    9e1a:	73fb      	strb	r3, [r7, #15]
            break;
    9e1c:	e006      	b.n	9e2c <ACE_get_input_channel_handle+0x44>
)
{
    uint16_t channel_idx;
    ace_channel_handle_t channel_handle = INVALID_CHANNEL_HANDLE;
    
    for ( channel_idx = 0u;  channel_idx < (uint16_t)ACE_NB_OF_INPUT_CHANNELS; ++channel_idx )
    9e1e:	89bb      	ldrh	r3, [r7, #12]
    9e20:	f103 0301 	add.w	r3, r3, #1
    9e24:	81bb      	strh	r3, [r7, #12]
    9e26:	89bb      	ldrh	r3, [r7, #12]
    9e28:	2b02      	cmp	r3, #2
    9e2a:	d9e9      	bls.n	9e00 <ACE_get_input_channel_handle+0x18>
            /* channel ID found. */
            channel_handle = (ace_channel_handle_t)channel_idx;
            break;
        }
    }
    return channel_handle;
    9e2c:	7bfb      	ldrb	r3, [r7, #15]
}
    9e2e:	4618      	mov	r0, r3
    9e30:	f107 0714 	add.w	r7, r7, #20
    9e34:	46bd      	mov	sp, r7
    9e36:	bc80      	pop	{r7}
    9e38:	4770      	bx	lr
    9e3a:	bf00      	nop

00009e3c <ACE_get_ppe_sample>:
uint16_t
ACE_get_ppe_sample
(
    ace_channel_handle_t channel_handle
)
{
    9e3c:	b480      	push	{r7}
    9e3e:	b085      	sub	sp, #20
    9e40:	af00      	add	r7, sp, #0
    9e42:	4603      	mov	r3, r0
    9e44:	71fb      	strb	r3, [r7, #7]
    uint16_t sample;
    uint16_t ppe_offset;
    
    ppe_offset = g_ace_channel_desc_table[channel_handle].signal_ppe_offset;
    9e46:	79fa      	ldrb	r2, [r7, #7]
    9e48:	f240 035c 	movw	r3, #92	; 0x5c
    9e4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9e50:	ea4f 1202 	mov.w	r2, r2, lsl #4
    9e54:	4413      	add	r3, r2
    9e56:	88db      	ldrh	r3, [r3, #6]
    9e58:	81fb      	strh	r3, [r7, #14]
    sample = (uint16_t)(ACE->PPE_RAM_DATA[ppe_offset] >> 16u);
    9e5a:	f240 0300 	movw	r3, #0
    9e5e:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9e62:	89fa      	ldrh	r2, [r7, #14]
    9e64:	f502 62c0 	add.w	r2, r2, #1536	; 0x600
    9e68:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    9e6c:	ea4f 4313 	mov.w	r3, r3, lsr #16
    9e70:	81bb      	strh	r3, [r7, #12]
    
    /* Check that the PPE processing did not result into a negative value.*/
    if((sample & 0x8000u) > 0u)
    9e72:	89bb      	ldrh	r3, [r7, #12]
    9e74:	b21b      	sxth	r3, r3
    9e76:	2b00      	cmp	r3, #0
    9e78:	da02      	bge.n	9e80 <ACE_get_ppe_sample+0x44>
    {
        /* Normalize negative value to zero. */
        sample = 0u;
    9e7a:	f04f 0300 	mov.w	r3, #0
    9e7e:	81bb      	strh	r3, [r7, #12]
    }
    
    return sample;
    9e80:	89bb      	ldrh	r3, [r7, #12]
}
    9e82:	4618      	mov	r0, r3
    9e84:	f107 0714 	add.w	r7, r7, #20
    9e88:	46bd      	mov	sp, r7
    9e8a:	bc80      	pop	{r7}
    9e8c:	4770      	bx	lr
    9e8e:	bf00      	nop

00009e90 <BrownOut_1_5V_IRQHandler>:
#elif defined( __ICCARM__ )
__irq void BrownOut_1_5V_IRQHandler( void )
#else
void BrownOut_1_5V_IRQHandler( void )
#endif
{
    9e90:	4668      	mov	r0, sp
    9e92:	f020 0107 	bic.w	r1, r0, #7
    9e96:	468d      	mov	sp, r1
    9e98:	b481      	push	{r0, r7}
    9e9a:	b082      	sub	sp, #8
    9e9c:	af00      	add	r7, sp, #0
     * Reduce frequency to 3MHz.
     * 	1) Select RC oscillator as CLKC clock source.
     *  2) Set divider to maximum allowed value (divide by 28).
     *  3) Set glitchless mux to use CLKC as MSS clock source.
     */
    SYSREG->MSS_CCC_MUX_CR = (SYSREG->MSS_CCC_MUX_CR & ~CLKC_SOURCE_MASK) | CLKC_SOURCE_VALUE;
    9e9e:	f242 0300 	movw	r3, #8192	; 0x2000
    9ea2:	f2ce 0304 	movt	r3, #57348	; 0xe004
    9ea6:	f242 0200 	movw	r2, #8192	; 0x2000
    9eaa:	f2ce 0204 	movt	r2, #57348	; 0xe004
    9eae:	6d12      	ldr	r2, [r2, #80]	; 0x50
    9eb0:	f442 22e0 	orr.w	r2, r2, #458752	; 0x70000
    9eb4:	651a      	str	r2, [r3, #80]	; 0x50
    SYSREG->MSS_CCC_DIV_CR = (SYSREG->MSS_CCC_DIV_CR & ~GLC_DIV_MASK) | GLC_DIV_VALUE;
    9eb6:	f242 0300 	movw	r3, #8192	; 0x2000
    9eba:	f2ce 0304 	movt	r3, #57348	; 0xe004
    9ebe:	f242 0200 	movw	r2, #8192	; 0x2000
    9ec2:	f2ce 0204 	movt	r2, #57348	; 0xe004
    9ec6:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
    9ec8:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
    9ecc:	f442 1270 	orr.w	r2, r2, #3932160	; 0x3c0000
    9ed0:	64da      	str	r2, [r3, #76]	; 0x4c
    SYSREG->MSS_CCC_MUX_CR = (SYSREG->MSS_CCC_MUX_CR & ~GLMUX_MASK) | GLMUX_VALUE;
    9ed2:	f242 0300 	movw	r3, #8192	; 0x2000
    9ed6:	f2ce 0304 	movt	r3, #57348	; 0xe004
    9eda:	f242 0200 	movw	r2, #8192	; 0x2000
    9ede:	f2ce 0204 	movt	r2, #57348	; 0xe004
    9ee2:	6d12      	ldr	r2, [r2, #80]	; 0x50
    9ee4:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
    9ee8:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
    9eec:	651a      	str	r2, [r3, #80]	; 0x50
	
    /*
     * Wait for supplies to become stable.
     */
    delay_count = STABLE_SUPPLY_DELAY;
    9eee:	f04f 0364 	mov.w	r3, #100	; 0x64
    9ef2:	603b      	str	r3, [r7, #0]
    do
    {
        brownout_status = SYSREG->DEVICE_SR & BROWNOUT_SYNCN_MASK;
    9ef4:	f242 0300 	movw	r3, #8192	; 0x2000
    9ef8:	f2ce 0304 	movt	r3, #57348	; 0xe004
    9efc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    9efe:	f003 0303 	and.w	r3, r3, #3
    9f02:	607b      	str	r3, [r7, #4]
        if ( NO_BROWNOUT == brownout_status )
    9f04:	687b      	ldr	r3, [r7, #4]
    9f06:	2b03      	cmp	r3, #3
    9f08:	d104      	bne.n	9f14 <BrownOut_1_5V_IRQHandler+0x84>
        {
            --delay_count;
    9f0a:	683b      	ldr	r3, [r7, #0]
    9f0c:	f103 33ff 	add.w	r3, r3, #4294967295
    9f10:	603b      	str	r3, [r7, #0]
    9f12:	e002      	b.n	9f1a <BrownOut_1_5V_IRQHandler+0x8a>
        }
        else
        {
            delay_count = STABLE_SUPPLY_DELAY;
    9f14:	f04f 0364 	mov.w	r3, #100	; 0x64
    9f18:	603b      	str	r3, [r7, #0]
        }
    } while ( delay_count != 0 );
    9f1a:	683b      	ldr	r3, [r7, #0]
    9f1c:	2b00      	cmp	r3, #0
    9f1e:	d1e9      	bne.n	9ef4 <BrownOut_1_5V_IRQHandler+0x64>
	
    /*
     * Issue system reset request.
     */
    SCB->AIRCR = SYS_RESET_REQUEST;
    9f20:	f64e 5300 	movw	r3, #60672	; 0xed00
    9f24:	f2ce 0300 	movt	r3, #57344	; 0xe000
    9f28:	f240 0204 	movw	r2, #4
    9f2c:	f2c0 52fa 	movt	r2, #1530	; 0x5fa
    9f30:	60da      	str	r2, [r3, #12]
}
    9f32:	f107 0708 	add.w	r7, r7, #8
    9f36:	46bd      	mov	sp, r7
    9f38:	bc81      	pop	{r0, r7}
    9f3a:	4685      	mov	sp, r0
    9f3c:	4770      	bx	lr
    9f3e:	bf00      	nop

00009f40 <__get_PSP>:
 * Return the actual process stack pointer
 */
uint32_t __get_PSP(void) __attribute__( ( naked ) );
uint32_t __get_PSP(void)
{
  uint32_t result=0;
    9f40:	f04f 0400 	mov.w	r4, #0

  __ASM volatile ("MRS %0, psp\n\t" 
    9f44:	f3ef 8409 	mrs	r4, PSP
    9f48:	4620      	mov	r0, r4
    9f4a:	4770      	bx	lr
                  "MOV r0, %0 \n\t"
                  "BX  lr     \n\t"  : "=r" (result) );
  return(result);
    9f4c:	4623      	mov	r3, r4
}
    9f4e:	4618      	mov	r0, r3

00009f50 <__set_PSP>:
 * Assign the value ProcessStackPointer to the MSP 
 * (process stack pointer) Cortex processor register
 */
void __set_PSP(uint32_t topOfProcStack) __attribute__( ( naked ) );
void __set_PSP(uint32_t topOfProcStack)
{
    9f50:	4603      	mov	r3, r0
  __ASM volatile ("MSR psp, %0\n\t"
    9f52:	f383 8809 	msr	PSP, r3
    9f56:	4770      	bx	lr

00009f58 <__get_MSP>:
 * Cortex processor register
 */
uint32_t __get_MSP(void) __attribute__( ( naked ) );
uint32_t __get_MSP(void)
{
  uint32_t result=0;
    9f58:	f04f 0400 	mov.w	r4, #0

  __ASM volatile ("MRS %0, msp\n\t" 
    9f5c:	f3ef 8408 	mrs	r4, MSP
    9f60:	4620      	mov	r0, r4
    9f62:	4770      	bx	lr
                  "MOV r0, %0 \n\t"
                  "BX  lr     \n\t"  : "=r" (result) );
  return(result);
    9f64:	4623      	mov	r3, r4
}
    9f66:	4618      	mov	r0, r3

00009f68 <__set_MSP>:
 * Assign the value mainStackPointer to the MSP 
 * (main stack pointer) Cortex processor register
 */
void __set_MSP(uint32_t topOfMainStack) __attribute__( ( naked ) );
void __set_MSP(uint32_t topOfMainStack)
{
    9f68:	4603      	mov	r3, r0
  __ASM volatile ("MSR msp, %0\n\t"
    9f6a:	f383 8808 	msr	MSP, r3
    9f6e:	4770      	bx	lr

00009f70 <__get_BASEPRI>:
 * @return BasePriority
 *
 * Return the content of the base priority register
 */
uint32_t __get_BASEPRI(void)
{
    9f70:	b480      	push	{r7}
    9f72:	b083      	sub	sp, #12
    9f74:	af00      	add	r7, sp, #0
  uint32_t result=0;
    9f76:	f04f 0300 	mov.w	r3, #0
    9f7a:	607b      	str	r3, [r7, #4]
  
  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
    9f7c:	f3ef 8312 	mrs	r3, BASEPRI_MASK
    9f80:	607b      	str	r3, [r7, #4]
  return(result);
    9f82:	687b      	ldr	r3, [r7, #4]
}
    9f84:	4618      	mov	r0, r3
    9f86:	f107 070c 	add.w	r7, r7, #12
    9f8a:	46bd      	mov	sp, r7
    9f8c:	bc80      	pop	{r7}
    9f8e:	4770      	bx	lr

00009f90 <__set_BASEPRI>:
 * @param  basePri  BasePriority
 *
 * Set the base priority register
 */
void __set_BASEPRI(uint32_t value)
{
    9f90:	b480      	push	{r7}
    9f92:	b083      	sub	sp, #12
    9f94:	af00      	add	r7, sp, #0
    9f96:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
    9f98:	687b      	ldr	r3, [r7, #4]
    9f9a:	f383 8811 	msr	BASEPRI, r3
}
    9f9e:	f107 070c 	add.w	r7, r7, #12
    9fa2:	46bd      	mov	sp, r7
    9fa4:	bc80      	pop	{r7}
    9fa6:	4770      	bx	lr

00009fa8 <__get_PRIMASK>:
 * @return PriMask
 *
 * Return state of the priority mask bit from the priority mask register
 */
uint32_t __get_PRIMASK(void)
{
    9fa8:	b480      	push	{r7}
    9faa:	b083      	sub	sp, #12
    9fac:	af00      	add	r7, sp, #0
  uint32_t result=0;
    9fae:	f04f 0300 	mov.w	r3, #0
    9fb2:	607b      	str	r3, [r7, #4]

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    9fb4:	f3ef 8310 	mrs	r3, PRIMASK
    9fb8:	607b      	str	r3, [r7, #4]
  return(result);
    9fba:	687b      	ldr	r3, [r7, #4]
}
    9fbc:	4618      	mov	r0, r3
    9fbe:	f107 070c 	add.w	r7, r7, #12
    9fc2:	46bd      	mov	sp, r7
    9fc4:	bc80      	pop	{r7}
    9fc6:	4770      	bx	lr

00009fc8 <__set_PRIMASK>:
 * @param  priMask  PriMask
 *
 * Set the priority mask bit in the priority mask register
 */
void __set_PRIMASK(uint32_t priMask)
{
    9fc8:	b480      	push	{r7}
    9fca:	b083      	sub	sp, #12
    9fcc:	af00      	add	r7, sp, #0
    9fce:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
    9fd0:	687b      	ldr	r3, [r7, #4]
    9fd2:	f383 8810 	msr	PRIMASK, r3
}
    9fd6:	f107 070c 	add.w	r7, r7, #12
    9fda:	46bd      	mov	sp, r7
    9fdc:	bc80      	pop	{r7}
    9fde:	4770      	bx	lr

00009fe0 <__get_FAULTMASK>:
 * @return FaultMask
 *
 * Return the content of the fault mask register
 */
uint32_t __get_FAULTMASK(void)
{
    9fe0:	b480      	push	{r7}
    9fe2:	b083      	sub	sp, #12
    9fe4:	af00      	add	r7, sp, #0
  uint32_t result=0;
    9fe6:	f04f 0300 	mov.w	r3, #0
    9fea:	607b      	str	r3, [r7, #4]
  
  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
    9fec:	f3ef 8313 	mrs	r3, FAULTMASK
    9ff0:	607b      	str	r3, [r7, #4]
  return(result);
    9ff2:	687b      	ldr	r3, [r7, #4]
}
    9ff4:	4618      	mov	r0, r3
    9ff6:	f107 070c 	add.w	r7, r7, #12
    9ffa:	46bd      	mov	sp, r7
    9ffc:	bc80      	pop	{r7}
    9ffe:	4770      	bx	lr

0000a000 <__set_FAULTMASK>:
 * @param  faultMask  faultMask value
 *
 * Set the fault mask register
 */
void __set_FAULTMASK(uint32_t faultMask)
{
    a000:	b480      	push	{r7}
    a002:	b083      	sub	sp, #12
    a004:	af00      	add	r7, sp, #0
    a006:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
    a008:	687b      	ldr	r3, [r7, #4]
    a00a:	f383 8813 	msr	FAULTMASK, r3
}
    a00e:	f107 070c 	add.w	r7, r7, #12
    a012:	46bd      	mov	sp, r7
    a014:	bc80      	pop	{r7}
    a016:	4770      	bx	lr

0000a018 <__get_CONTROL>:
*  @return Control value
 *
 * Return the content of the control register
 */
uint32_t __get_CONTROL(void)
{
    a018:	b480      	push	{r7}
    a01a:	b083      	sub	sp, #12
    a01c:	af00      	add	r7, sp, #0
  uint32_t result=0;
    a01e:	f04f 0300 	mov.w	r3, #0
    a022:	607b      	str	r3, [r7, #4]

  __ASM volatile ("MRS %0, control" : "=r" (result) );
    a024:	f3ef 8314 	mrs	r3, CONTROL
    a028:	607b      	str	r3, [r7, #4]
  return(result);
    a02a:	687b      	ldr	r3, [r7, #4]
}
    a02c:	4618      	mov	r0, r3
    a02e:	f107 070c 	add.w	r7, r7, #12
    a032:	46bd      	mov	sp, r7
    a034:	bc80      	pop	{r7}
    a036:	4770      	bx	lr

0000a038 <__set_CONTROL>:
 * @param  control  Control value
 *
 * Set the control register
 */
void __set_CONTROL(uint32_t control)
{
    a038:	b480      	push	{r7}
    a03a:	b083      	sub	sp, #12
    a03c:	af00      	add	r7, sp, #0
    a03e:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR control, %0" : : "r" (control) );
    a040:	687b      	ldr	r3, [r7, #4]
    a042:	f383 8814 	msr	CONTROL, r3
}
    a046:	f107 070c 	add.w	r7, r7, #12
    a04a:	46bd      	mov	sp, r7
    a04c:	bc80      	pop	{r7}
    a04e:	4770      	bx	lr

0000a050 <__REV>:
 * @return        reversed value
 *
 * Reverse byte order in integer value
 */
uint32_t __REV(uint32_t value)
{
    a050:	b480      	push	{r7}
    a052:	b085      	sub	sp, #20
    a054:	af00      	add	r7, sp, #0
    a056:	6078      	str	r0, [r7, #4]
  uint32_t result=0;
    a058:	f04f 0300 	mov.w	r3, #0
    a05c:	60fb      	str	r3, [r7, #12]
  
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
    a05e:	687b      	ldr	r3, [r7, #4]
    a060:	ba1b      	rev	r3, r3
    a062:	60fb      	str	r3, [r7, #12]
  return(result);
    a064:	68fb      	ldr	r3, [r7, #12]
}
    a066:	4618      	mov	r0, r3
    a068:	f107 0714 	add.w	r7, r7, #20
    a06c:	46bd      	mov	sp, r7
    a06e:	bc80      	pop	{r7}
    a070:	4770      	bx	lr
    a072:	bf00      	nop

0000a074 <__REV16>:
 * @return        reversed value
 *
 * Reverse byte order in unsigned short value
 */
uint32_t __REV16(uint16_t value)
{
    a074:	b480      	push	{r7}
    a076:	b085      	sub	sp, #20
    a078:	af00      	add	r7, sp, #0
    a07a:	4603      	mov	r3, r0
    a07c:	80fb      	strh	r3, [r7, #6]
  uint32_t result=0;
    a07e:	f04f 0300 	mov.w	r3, #0
    a082:	60fb      	str	r3, [r7, #12]
  
  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
    a084:	88fb      	ldrh	r3, [r7, #6]
    a086:	ba5b      	rev16	r3, r3
    a088:	60fb      	str	r3, [r7, #12]
  return(result);
    a08a:	68fb      	ldr	r3, [r7, #12]
}
    a08c:	4618      	mov	r0, r3
    a08e:	f107 0714 	add.w	r7, r7, #20
    a092:	46bd      	mov	sp, r7
    a094:	bc80      	pop	{r7}
    a096:	4770      	bx	lr

0000a098 <__REVSH>:
 * @return        reversed value
 *
 * Reverse byte order in signed short value with sign extension to integer
 */
int32_t __REVSH(int16_t value)
{
    a098:	b480      	push	{r7}
    a09a:	b085      	sub	sp, #20
    a09c:	af00      	add	r7, sp, #0
    a09e:	4603      	mov	r3, r0
    a0a0:	80fb      	strh	r3, [r7, #6]
  uint32_t result=0;
    a0a2:	f04f 0300 	mov.w	r3, #0
    a0a6:	60fb      	str	r3, [r7, #12]
  
  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
    a0a8:	88fb      	ldrh	r3, [r7, #6]
    a0aa:	badb      	revsh	r3, r3
    a0ac:	60fb      	str	r3, [r7, #12]
  return(result);
    a0ae:	68fb      	ldr	r3, [r7, #12]
}
    a0b0:	4618      	mov	r0, r3
    a0b2:	f107 0714 	add.w	r7, r7, #20
    a0b6:	46bd      	mov	sp, r7
    a0b8:	bc80      	pop	{r7}
    a0ba:	4770      	bx	lr

0000a0bc <__RBIT>:
 * @return        reversed value
 *
 * Reverse bit order of value
 */
uint32_t __RBIT(uint32_t value)
{
    a0bc:	b480      	push	{r7}
    a0be:	b085      	sub	sp, #20
    a0c0:	af00      	add	r7, sp, #0
    a0c2:	6078      	str	r0, [r7, #4]
  uint32_t result=0;
    a0c4:	f04f 0300 	mov.w	r3, #0
    a0c8:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
    a0ca:	687b      	ldr	r3, [r7, #4]
    a0cc:	fa93 f3a3 	rbit	r3, r3
    a0d0:	60fb      	str	r3, [r7, #12]
   return(result);
    a0d2:	68fb      	ldr	r3, [r7, #12]
}
    a0d4:	4618      	mov	r0, r3
    a0d6:	f107 0714 	add.w	r7, r7, #20
    a0da:	46bd      	mov	sp, r7
    a0dc:	bc80      	pop	{r7}
    a0de:	4770      	bx	lr

0000a0e0 <__LDREXB>:
 * @return        value of (*address)
 *
 * Exclusive LDR command for 8 bit value
 */
uint8_t __LDREXB(uint8_t *addr)
{
    a0e0:	b480      	push	{r7}
    a0e2:	b085      	sub	sp, #20
    a0e4:	af00      	add	r7, sp, #0
    a0e6:	6078      	str	r0, [r7, #4]
    uint8_t result=0;
    a0e8:	f04f 0300 	mov.w	r3, #0
    a0ec:	73fb      	strb	r3, [r7, #15]
  
   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
    a0ee:	687b      	ldr	r3, [r7, #4]
    a0f0:	e8d3 3f4f 	ldrexb	r3, [r3]
    a0f4:	73fb      	strb	r3, [r7, #15]
   return(result);
    a0f6:	7bfb      	ldrb	r3, [r7, #15]
}
    a0f8:	4618      	mov	r0, r3
    a0fa:	f107 0714 	add.w	r7, r7, #20
    a0fe:	46bd      	mov	sp, r7
    a100:	bc80      	pop	{r7}
    a102:	4770      	bx	lr

0000a104 <__LDREXH>:
 * @return        value of (*address)
 *
 * Exclusive LDR command for 16 bit values
 */
uint16_t __LDREXH(uint16_t *addr)
{
    a104:	b480      	push	{r7}
    a106:	b085      	sub	sp, #20
    a108:	af00      	add	r7, sp, #0
    a10a:	6078      	str	r0, [r7, #4]
    uint16_t result=0;
    a10c:	f04f 0300 	mov.w	r3, #0
    a110:	81fb      	strh	r3, [r7, #14]
  
   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
    a112:	687b      	ldr	r3, [r7, #4]
    a114:	e8d3 3f5f 	ldrexh	r3, [r3]
    a118:	81fb      	strh	r3, [r7, #14]
   return(result);
    a11a:	89fb      	ldrh	r3, [r7, #14]
}
    a11c:	4618      	mov	r0, r3
    a11e:	f107 0714 	add.w	r7, r7, #20
    a122:	46bd      	mov	sp, r7
    a124:	bc80      	pop	{r7}
    a126:	4770      	bx	lr

0000a128 <__LDREXW>:
 * @return        value of (*address)
 *
 * Exclusive LDR command for 32 bit values
 */
uint32_t __LDREXW(uint32_t *addr)
{
    a128:	b480      	push	{r7}
    a12a:	b085      	sub	sp, #20
    a12c:	af00      	add	r7, sp, #0
    a12e:	6078      	str	r0, [r7, #4]
    uint32_t result=0;
    a130:	f04f 0300 	mov.w	r3, #0
    a134:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    a136:	687b      	ldr	r3, [r7, #4]
    a138:	e853 3f00 	ldrex	r3, [r3]
    a13c:	60fb      	str	r3, [r7, #12]
   return(result);
    a13e:	68fb      	ldr	r3, [r7, #12]
}
    a140:	4618      	mov	r0, r3
    a142:	f107 0714 	add.w	r7, r7, #20
    a146:	46bd      	mov	sp, r7
    a148:	bc80      	pop	{r7}
    a14a:	4770      	bx	lr

0000a14c <__STREXB>:
 * @return        successful / failed
 *
 * Exclusive STR command for 8 bit values
 */
uint32_t __STREXB(uint8_t value, uint8_t *addr)
{
    a14c:	b480      	push	{r7}
    a14e:	b085      	sub	sp, #20
    a150:	af00      	add	r7, sp, #0
    a152:	4603      	mov	r3, r0
    a154:	6039      	str	r1, [r7, #0]
    a156:	71fb      	strb	r3, [r7, #7]
   uint32_t result=0;
    a158:	f04f 0300 	mov.w	r3, #0
    a15c:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("strexb %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    a15e:	683b      	ldr	r3, [r7, #0]
    a160:	79fa      	ldrb	r2, [r7, #7]
    a162:	e8c3 2f41 	strexb	r1, r2, [r3]
    a166:	460b      	mov	r3, r1
    a168:	60fb      	str	r3, [r7, #12]
   return(result);
    a16a:	68fb      	ldr	r3, [r7, #12]
}
    a16c:	4618      	mov	r0, r3
    a16e:	f107 0714 	add.w	r7, r7, #20
    a172:	46bd      	mov	sp, r7
    a174:	bc80      	pop	{r7}
    a176:	4770      	bx	lr

0000a178 <__STREXH>:
 * @return        successful / failed
 *
 * Exclusive STR command for 16 bit values
 */
uint32_t __STREXH(uint16_t value, uint16_t *addr)
{
    a178:	b480      	push	{r7}
    a17a:	b085      	sub	sp, #20
    a17c:	af00      	add	r7, sp, #0
    a17e:	4603      	mov	r3, r0
    a180:	6039      	str	r1, [r7, #0]
    a182:	80fb      	strh	r3, [r7, #6]
   uint32_t result=0;
    a184:	f04f 0300 	mov.w	r3, #0
    a188:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("strexh %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    a18a:	683b      	ldr	r3, [r7, #0]
    a18c:	88fa      	ldrh	r2, [r7, #6]
    a18e:	e8c3 2f51 	strexh	r1, r2, [r3]
    a192:	460b      	mov	r3, r1
    a194:	60fb      	str	r3, [r7, #12]
   return(result);
    a196:	68fb      	ldr	r3, [r7, #12]
}
    a198:	4618      	mov	r0, r3
    a19a:	f107 0714 	add.w	r7, r7, #20
    a19e:	46bd      	mov	sp, r7
    a1a0:	bc80      	pop	{r7}
    a1a2:	4770      	bx	lr

0000a1a4 <__STREXW>:
 * @return        successful / failed
 *
 * Exclusive STR command for 32 bit values
 */
uint32_t __STREXW(uint32_t value, uint32_t *addr)
{
    a1a4:	b480      	push	{r7}
    a1a6:	b085      	sub	sp, #20
    a1a8:	af00      	add	r7, sp, #0
    a1aa:	6078      	str	r0, [r7, #4]
    a1ac:	6039      	str	r1, [r7, #0]
   uint32_t result=0;
    a1ae:	f04f 0300 	mov.w	r3, #0
    a1b2:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("strex %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
    a1b4:	683b      	ldr	r3, [r7, #0]
    a1b6:	687a      	ldr	r2, [r7, #4]
    a1b8:	e843 2300 	strex	r3, r2, [r3]
    a1bc:	60fb      	str	r3, [r7, #12]
   return(result);
    a1be:	68fb      	ldr	r3, [r7, #12]
}
    a1c0:	4618      	mov	r0, r3
    a1c2:	f107 0714 	add.w	r7, r7, #20
    a1c6:	46bd      	mov	sp, r7
    a1c8:	bc80      	pop	{r7}
    a1ca:	4770      	bx	lr

0000a1cc <SystemInit>:

/***************************************************************************//**
 * See system_a2fxxxm3f.h for details.
 */
void SystemInit(void)
{
    a1cc:	b480      	push	{r7}
    a1ce:	af00      	add	r7, sp, #0
    /*
     * Do not make use of global variables or make any asumptions regarding
     * memory content if modifying this function. The memory content has not been
     * initialised by the time this function is called by the start-up code.
     */
}
    a1d0:	46bd      	mov	sp, r7
    a1d2:	bc80      	pop	{r7}
    a1d4:	4770      	bx	lr
    a1d6:	bf00      	nop

0000a1d8 <SystemCoreClockUpdate>:

/***************************************************************************//**
 *
 */
void SystemCoreClockUpdate (void)
{
    a1d8:	b580      	push	{r7, lr}
    a1da:	b08a      	sub	sp, #40	; 0x28
    a1dc:	af00      	add	r7, sp, #0
    uint32_t PclkDiv0;
    uint32_t PclkDiv1;
    uint32_t AceDiv;
    uint32_t FabDiv;

    const uint32_t pclk_div_lut[4] = { 1uL, 2uL, 4uL, 1uL };
    a1de:	f24b 73a8 	movw	r3, #47016	; 0xb7a8
    a1e2:	f2c0 0301 	movt	r3, #1
    a1e6:	46bc      	mov	ip, r7
    a1e8:	cb0f      	ldmia	r3!, {r0, r1, r2, r3}
    a1ea:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}

    /* Read PCLK dividers from system registers. Multiply the value read from
     * system register by two to get actual divider value. */
    PclkDiv0 = pclk_div_lut[((SYSREG->MSS_CLK_CR >> PCLK0_DIV_SHIFT) & PCLK_DIV_MASK)];
    a1ee:	f242 0300 	movw	r3, #8192	; 0x2000
    a1f2:	f2ce 0304 	movt	r3, #57348	; 0xe004
    a1f6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    a1f8:	ea4f 0393 	mov.w	r3, r3, lsr #2
    a1fc:	f003 0303 	and.w	r3, r3, #3
    a200:	ea4f 0383 	mov.w	r3, r3, lsl #2
    a204:	f107 0228 	add.w	r2, r7, #40	; 0x28
    a208:	4413      	add	r3, r2
    a20a:	f853 3c28 	ldr.w	r3, [r3, #-40]
    a20e:	613b      	str	r3, [r7, #16]
    PclkDiv1 = pclk_div_lut[((SYSREG->MSS_CLK_CR >> PCLK1_DIV_SHIFT) & PCLK_DIV_MASK)];
    a210:	f242 0300 	movw	r3, #8192	; 0x2000
    a214:	f2ce 0304 	movt	r3, #57348	; 0xe004
    a218:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    a21a:	ea4f 1313 	mov.w	r3, r3, lsr #4
    a21e:	f003 0303 	and.w	r3, r3, #3
    a222:	ea4f 0383 	mov.w	r3, r3, lsl #2
    a226:	f107 0228 	add.w	r2, r7, #40	; 0x28
    a22a:	4413      	add	r3, r2
    a22c:	f853 3c28 	ldr.w	r3, [r3, #-40]
    a230:	617b      	str	r3, [r7, #20]
    AceDiv = pclk_div_lut[((SYSREG->MSS_CLK_CR >> ACE_DIV_SHIFT) & PCLK_DIV_MASK)];
    a232:	f242 0300 	movw	r3, #8192	; 0x2000
    a236:	f2ce 0304 	movt	r3, #57348	; 0xe004
    a23a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    a23c:	ea4f 1393 	mov.w	r3, r3, lsr #6
    a240:	f003 0303 	and.w	r3, r3, #3
    a244:	ea4f 0383 	mov.w	r3, r3, lsl #2
    a248:	f107 0228 	add.w	r2, r7, #40	; 0x28
    a24c:	4413      	add	r3, r2
    a24e:	f853 3c28 	ldr.w	r3, [r3, #-40]
    a252:	61bb      	str	r3, [r7, #24]
    {
        /* Compute the FPGA fabric frequency divider. */
        uint32_t obdiv;
        uint32_t obdivhalf;
        
        obdiv = (SYSREG->MSS_CCC_DIV_CR >> OBDIV_SHIFT) & OBDIV_MASK;
    a254:	f242 0300 	movw	r3, #8192	; 0x2000
    a258:	f2ce 0304 	movt	r3, #57348	; 0xe004
    a25c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    a25e:	ea4f 2313 	mov.w	r3, r3, lsr #8
    a262:	f003 031f 	and.w	r3, r3, #31
    a266:	623b      	str	r3, [r7, #32]
        obdivhalf = (SYSREG->MSS_CCC_DIV_CR >> OBDIVHALF_SHIFT) & OBDIVHALF_MASK;
    a268:	f242 0300 	movw	r3, #8192	; 0x2000
    a26c:	f2ce 0304 	movt	r3, #57348	; 0xe004
    a270:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    a272:	ea4f 3353 	mov.w	r3, r3, lsr #13
    a276:	f003 0301 	and.w	r3, r3, #1
    a27a:	627b      	str	r3, [r7, #36]	; 0x24
        FabDiv = obdiv + 1uL;
    a27c:	6a3b      	ldr	r3, [r7, #32]
    a27e:	f103 0301 	add.w	r3, r3, #1
    a282:	61fb      	str	r3, [r7, #28]
        if ( obdivhalf != 0uL )
    a284:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    a286:	2b00      	cmp	r3, #0
    a288:	d003      	beq.n	a292 <SystemCoreClockUpdate+0xba>
        {
            FabDiv = FabDiv * 2uL;
    a28a:	69fb      	ldr	r3, [r7, #28]
    a28c:	ea4f 0343 	mov.w	r3, r3, lsl #1
    a290:	61fb      	str	r3, [r7, #28]
    }
    
    /* Retrieve FCLK from eNVM spare pages if Actel system boot programmed as part of the system. */
    
    /* Read system clock from eNVM spare pages. */
    SystemCoreClock = GetSystemClock();
    a292:	f000 f849 	bl	a328 <GetSystemClock>
    a296:	4602      	mov	r2, r0
    a298:	f240 03b8 	movw	r3, #184	; 0xb8
    a29c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a2a0:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK0 = SystemCoreClock / PclkDiv0;
    a2a2:	f240 03b8 	movw	r3, #184	; 0xb8
    a2a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a2aa:	681a      	ldr	r2, [r3, #0]
    a2ac:	693b      	ldr	r3, [r7, #16]
    a2ae:	fbb2 f2f3 	udiv	r2, r2, r3
    a2b2:	f240 03bc 	movw	r3, #188	; 0xbc
    a2b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a2ba:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK1 = SystemCoreClock / PclkDiv1;
    a2bc:	f240 03b8 	movw	r3, #184	; 0xb8
    a2c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a2c4:	681a      	ldr	r2, [r3, #0]
    a2c6:	697b      	ldr	r3, [r7, #20]
    a2c8:	fbb2 f2f3 	udiv	r2, r2, r3
    a2cc:	f240 03c0 	movw	r3, #192	; 0xc0
    a2d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a2d4:	601a      	str	r2, [r3, #0]
    g_FrequencyACE = SystemCoreClock / AceDiv;
    a2d6:	f240 03b8 	movw	r3, #184	; 0xb8
    a2da:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a2de:	681a      	ldr	r2, [r3, #0]
    a2e0:	69bb      	ldr	r3, [r7, #24]
    a2e2:	fbb2 f2f3 	udiv	r2, r2, r3
    a2e6:	f240 03c4 	movw	r3, #196	; 0xc4
    a2ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a2ee:	601a      	str	r2, [r3, #0]
    g_FrequencyFPGA = SystemCoreClock / FabDiv;
    a2f0:	f240 03b8 	movw	r3, #184	; 0xb8
    a2f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a2f8:	681a      	ldr	r2, [r3, #0]
    a2fa:	69fb      	ldr	r3, [r7, #28]
    a2fc:	fbb2 f2f3 	udiv	r2, r2, r3
    a300:	f240 03c8 	movw	r3, #200	; 0xc8
    a304:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a308:	601a      	str	r2, [r3, #0]
    
    /* Keep SystemFrequency as well as SystemCoreClock for legacy reasons. */
    SystemFrequency = SystemCoreClock;
    a30a:	f240 03b8 	movw	r3, #184	; 0xb8
    a30e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a312:	681a      	ldr	r2, [r3, #0]
    a314:	f240 03b4 	movw	r3, #180	; 0xb4
    a318:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a31c:	601a      	str	r2, [r3, #0]
}
    a31e:	f107 0728 	add.w	r7, r7, #40	; 0x28
    a322:	46bd      	mov	sp, r7
    a324:	bd80      	pop	{r7, pc}
    a326:	bf00      	nop

0000a328 <GetSystemClock>:
 * retrieved from eNVM spare pages.
 * The FCLK frequency value selected in the MSS Configurator software tool is
 * stored in eNVM spare pages as part of the Actel system boot configuration data.
 */
uint32_t GetSystemClock( void )
{
    a328:	b480      	push	{r7}
    a32a:	b08b      	sub	sp, #44	; 0x2c
    a32c:	af00      	add	r7, sp, #0
    uint32_t fclk = 0uL;
    a32e:	f04f 0300 	mov.w	r3, #0
    a332:	607b      	str	r3, [r7, #4]
    
    uint32_t * p_sysboot_key = SYSBOOT_KEY_ADDR;
    a334:	f640 031c 	movw	r3, #2076	; 0x81c
    a338:	f2c6 0308 	movt	r3, #24584	; 0x6008
    a33c:	60bb      	str	r3, [r7, #8]
    uint32_t * p_idcode = IDCODE_LOCATION;
    a33e:	f240 2330 	movw	r3, #560	; 0x230
    a342:	f2c6 0308 	movt	r3, #24584	; 0x6008
    a346:	60fb      	str	r3, [r7, #12]
    uint32_t idcode;
	
    idcode = *p_idcode & ~IDCODE_DEV_REV_MASK;
    a348:	68fb      	ldr	r3, [r7, #12]
    a34a:	681b      	ldr	r3, [r3, #0]
    a34c:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
    a350:	613b      	str	r3, [r7, #16]
	
    if ( A2F060IFX_ID == idcode )
    a352:	693a      	ldr	r2, [r7, #16]
    a354:	f241 13cf 	movw	r3, #4559	; 0x11cf
    a358:	f2c0 53a1 	movt	r3, #1441	; 0x5a1
    a35c:	429a      	cmp	r2, r3
    a35e:	d108      	bne.n	a372 <GetSystemClock+0x4a>
    {
        uint32_t *p_fclk = SYSBOOT_A2F060_FCLK_ADDR;
    a360:	f64e 732c 	movw	r3, #61228	; 0xef2c
    a364:	f2c6 0301 	movt	r3, #24577	; 0x6001
    a368:	617b      	str	r3, [r7, #20]
        fclk = *p_fclk;
    a36a:	697b      	ldr	r3, [r7, #20]
    a36c:	681b      	ldr	r3, [r3, #0]
    a36e:	607b      	str	r3, [r7, #4]
    a370:	e03d      	b.n	a3ee <GetSystemClock+0xc6>
    }
    else if ( SYSBOOT_KEY_VALUE == *p_sysboot_key )
    a372:	68bb      	ldr	r3, [r7, #8]
    a374:	681a      	ldr	r2, [r3, #0]
    a376:	f244 3341 	movw	r3, #17217	; 0x4341
    a37a:	f6c4 4354 	movt	r3, #19540	; 0x4c54
    a37e:	429a      	cmp	r2, r3
    a380:	d135      	bne.n	a3ee <GetSystemClock+0xc6>
    {
        /* Actel system boot programmed, check if it has the FCLK value stored. */
        uint32_t *p_sysboot_version = SYSBOOT_VERSION_ADDR;
    a382:	f640 0340 	movw	r3, #2112	; 0x840
    a386:	f2c6 0308 	movt	r3, #24584	; 0x6008
    a38a:	61bb      	str	r3, [r7, #24]
        uint32_t sysboot_version = *p_sysboot_version;
    a38c:	69bb      	ldr	r3, [r7, #24]
    a38e:	681b      	ldr	r3, [r3, #0]
    a390:	61fb      	str	r3, [r7, #28]
        
        sysboot_version &= SYSBOOT_VERSION_MASK;
    a392:	69fb      	ldr	r3, [r7, #28]
    a394:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    a398:	61fb      	str	r3, [r7, #28]
        
        if ( sysboot_version >= MIN_SYSBOOT_VERSION )
    a39a:	69fa      	ldr	r2, [r7, #28]
    a39c:	f240 3300 	movw	r3, #768	; 0x300
    a3a0:	f2c0 0301 	movt	r3, #1
    a3a4:	429a      	cmp	r2, r3
    a3a6:	d922      	bls.n	a3ee <GetSystemClock+0xc6>
        {
            /* Handle change of eNVM location of FCLK between 1.3.x and 2.x.x versions of the system boot. */
            if ( sysboot_version < SYSBOOT_VERSION_2_X )
    a3a8:	69fa      	ldr	r2, [r7, #28]
    a3aa:	f64f 73ff 	movw	r3, #65535	; 0xffff
    a3ae:	f2c0 0301 	movt	r3, #1
    a3b2:	429a      	cmp	r2, r3
    a3b4:	d808      	bhi.n	a3c8 <GetSystemClock+0xa0>
            {
                /* Read FCLK value from MSS configurator generated configuration
                 * data stored in eNVM spare pages as part of system boot version 1.3.x
                 * configuration tables. */
                uint32_t *p_fclk = SYSBOOT_1_3_FCLK_ADDR;
    a3b6:	f241 632c 	movw	r3, #5676	; 0x162c
    a3ba:	f2c6 0308 	movt	r3, #24584	; 0x6008
    a3be:	623b      	str	r3, [r7, #32]
                fclk = *p_fclk;
    a3c0:	6a3b      	ldr	r3, [r7, #32]
    a3c2:	681b      	ldr	r3, [r3, #0]
    a3c4:	607b      	str	r3, [r7, #4]
    a3c6:	e012      	b.n	a3ee <GetSystemClock+0xc6>
            }
            else if ( sysboot_version < MAX_SYSBOOT_VERSION )
    a3c8:	69fa      	ldr	r2, [r7, #28]
    a3ca:	f64f 73ff 	movw	r3, #65535	; 0xffff
    a3ce:	f2c0 0302 	movt	r3, #2
    a3d2:	429a      	cmp	r2, r3
    a3d4:	d808      	bhi.n	a3e8 <GetSystemClock+0xc0>
            {
                /* Read FCLK value from MSS configurator generated configuration
                 * data stored in eNVM spare pages as part of system boot version 2.x.x
                 * configuration tables. */
                uint32_t *p_fclk = SYSBOOT_2_x_FCLK_ADDR;
    a3d6:	f641 63ac 	movw	r3, #7852	; 0x1eac
    a3da:	f2c6 0308 	movt	r3, #24584	; 0x6008
    a3de:	627b      	str	r3, [r7, #36]	; 0x24
                fclk = *p_fclk;
    a3e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    a3e2:	681b      	ldr	r3, [r3, #0]
    a3e4:	607b      	str	r3, [r7, #4]
    a3e6:	e002      	b.n	a3ee <GetSystemClock+0xc6>
            }
            else
            {
                fclk = 0uL;
    a3e8:	f04f 0300 	mov.w	r3, #0
    a3ec:	607b      	str	r3, [r7, #4]
            }
        }
    }
    
    if ( 0uL == fclk )
    a3ee:	687b      	ldr	r3, [r7, #4]
    a3f0:	2b00      	cmp	r3, #0
    a3f2:	d105      	bne.n	a400 <GetSystemClock+0xd8>
        /* 
         * Could not retrieve FCLK from system boot configuration data. Fall back
         * to using SMARTFUSION_FCLK_FREQ which must then be defined as part of
         * project settings.
         */
        ASSERT( SMARTFUSION_FCLK_FREQ_DEFINED );
    a3f4:	be00      	bkpt	0x0000
        fclk = SMARTFUSION_FCLK_FREQ;
    a3f6:	f647 0340 	movw	r3, #30784	; 0x7840
    a3fa:	f2c0 137d 	movt	r3, #381	; 0x17d
    a3fe:	607b      	str	r3, [r7, #4]
    }
    
    return fclk;
    a400:	687b      	ldr	r3, [r7, #4]
}
    a402:	4618      	mov	r0, r3
    a404:	f107 072c 	add.w	r7, r7, #44	; 0x2c
    a408:	46bd      	mov	sp, r7
    a40a:	bc80      	pop	{r7}
    a40c:	4770      	bx	lr
    a40e:	bf00      	nop

0000a410 <_close>:

/*==============================================================================
 * Close a file.
 */
int _close(int file)
{
    a410:	b480      	push	{r7}
    a412:	b083      	sub	sp, #12
    a414:	af00      	add	r7, sp, #0
    a416:	6078      	str	r0, [r7, #4]
    return -1;
    a418:	f04f 33ff 	mov.w	r3, #4294967295
}
    a41c:	4618      	mov	r0, r3
    a41e:	f107 070c 	add.w	r7, r7, #12
    a422:	46bd      	mov	sp, r7
    a424:	bc80      	pop	{r7}
    a426:	4770      	bx	lr

0000a428 <_execve>:

/*==============================================================================
 * Transfer control to a new process.
 */
int _execve(char *name, char **argv, char **env)
{
    a428:	b580      	push	{r7, lr}
    a42a:	b084      	sub	sp, #16
    a42c:	af00      	add	r7, sp, #0
    a42e:	60f8      	str	r0, [r7, #12]
    a430:	60b9      	str	r1, [r7, #8]
    a432:	607a      	str	r2, [r7, #4]
    errno = ENOMEM;
    a434:	f00a fc88 	bl	14d48 <__errno>
    a438:	4603      	mov	r3, r0
    a43a:	f04f 020c 	mov.w	r2, #12
    a43e:	601a      	str	r2, [r3, #0]
    return -1;
    a440:	f04f 33ff 	mov.w	r3, #4294967295
}
    a444:	4618      	mov	r0, r3
    a446:	f107 0710 	add.w	r7, r7, #16
    a44a:	46bd      	mov	sp, r7
    a44c:	bd80      	pop	{r7, pc}
    a44e:	bf00      	nop

0000a450 <_exit>:
{
	/* Should we force a system reset? */
	while( 1 )
	{
		;
	}
    a450:	b480      	push	{r7}
    a452:	b083      	sub	sp, #12
    a454:	af00      	add	r7, sp, #0
    a456:	6078      	str	r0, [r7, #4]
    a458:	e7fe      	b.n	a458 <_exit+0x8>
    a45a:	bf00      	nop

0000a45c <_fork>:

/*==============================================================================
 * Create a new process.
 */
int _fork(void)
{
    a45c:	b580      	push	{r7, lr}
    a45e:	af00      	add	r7, sp, #0
    errno = EAGAIN;
    a460:	f00a fc72 	bl	14d48 <__errno>
    a464:	4603      	mov	r3, r0
    a466:	f04f 020b 	mov.w	r2, #11
    a46a:	601a      	str	r2, [r3, #0]
    return -1;
    a46c:	f04f 33ff 	mov.w	r3, #4294967295
}
    a470:	4618      	mov	r0, r3
    a472:	bd80      	pop	{r7, pc}

0000a474 <_fstat>:

/*==============================================================================
 * Status of an open file.
 */
int _fstat(int file, struct stat *st)
{
    a474:	b480      	push	{r7}
    a476:	b083      	sub	sp, #12
    a478:	af00      	add	r7, sp, #0
    a47a:	6078      	str	r0, [r7, #4]
    a47c:	6039      	str	r1, [r7, #0]
    st->st_mode = S_IFCHR;
    a47e:	683b      	ldr	r3, [r7, #0]
    a480:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    a484:	605a      	str	r2, [r3, #4]
    return 0;
    a486:	f04f 0300 	mov.w	r3, #0
}
    a48a:	4618      	mov	r0, r3
    a48c:	f107 070c 	add.w	r7, r7, #12
    a490:	46bd      	mov	sp, r7
    a492:	bc80      	pop	{r7}
    a494:	4770      	bx	lr
    a496:	bf00      	nop

0000a498 <_getpid>:

/*==============================================================================
 * Process-ID
 */
int _getpid(void)
{
    a498:	b480      	push	{r7}
    a49a:	af00      	add	r7, sp, #0
    return 1;
    a49c:	f04f 0301 	mov.w	r3, #1
}
    a4a0:	4618      	mov	r0, r3
    a4a2:	46bd      	mov	sp, r7
    a4a4:	bc80      	pop	{r7}
    a4a6:	4770      	bx	lr

0000a4a8 <_isatty>:

/*==============================================================================
 * Query whether output stream is a terminal.
 */
int _isatty(int file)
{
    a4a8:	b480      	push	{r7}
    a4aa:	b083      	sub	sp, #12
    a4ac:	af00      	add	r7, sp, #0
    a4ae:	6078      	str	r0, [r7, #4]
    return 1;
    a4b0:	f04f 0301 	mov.w	r3, #1
}
    a4b4:	4618      	mov	r0, r3
    a4b6:	f107 070c 	add.w	r7, r7, #12
    a4ba:	46bd      	mov	sp, r7
    a4bc:	bc80      	pop	{r7}
    a4be:	4770      	bx	lr

0000a4c0 <_kill>:

/*==============================================================================
 * Send a signal.
 */
int _kill(int pid, int sig)
{
    a4c0:	b580      	push	{r7, lr}
    a4c2:	b082      	sub	sp, #8
    a4c4:	af00      	add	r7, sp, #0
    a4c6:	6078      	str	r0, [r7, #4]
    a4c8:	6039      	str	r1, [r7, #0]
    errno = EINVAL;
    a4ca:	f00a fc3d 	bl	14d48 <__errno>
    a4ce:	4603      	mov	r3, r0
    a4d0:	f04f 0216 	mov.w	r2, #22
    a4d4:	601a      	str	r2, [r3, #0]
    return -1;
    a4d6:	f04f 33ff 	mov.w	r3, #4294967295
}
    a4da:	4618      	mov	r0, r3
    a4dc:	f107 0708 	add.w	r7, r7, #8
    a4e0:	46bd      	mov	sp, r7
    a4e2:	bd80      	pop	{r7, pc}

0000a4e4 <_link>:

/*==============================================================================
 * Establish a new name for an existing file.
 */
int _link(char *old, char *new)
{
    a4e4:	b580      	push	{r7, lr}
    a4e6:	b082      	sub	sp, #8
    a4e8:	af00      	add	r7, sp, #0
    a4ea:	6078      	str	r0, [r7, #4]
    a4ec:	6039      	str	r1, [r7, #0]
    errno = EMLINK;
    a4ee:	f00a fc2b 	bl	14d48 <__errno>
    a4f2:	4603      	mov	r3, r0
    a4f4:	f04f 021f 	mov.w	r2, #31
    a4f8:	601a      	str	r2, [r3, #0]
    return -1;
    a4fa:	f04f 33ff 	mov.w	r3, #4294967295
}
    a4fe:	4618      	mov	r0, r3
    a500:	f107 0708 	add.w	r7, r7, #8
    a504:	46bd      	mov	sp, r7
    a506:	bd80      	pop	{r7, pc}

0000a508 <_lseek>:

/*==============================================================================
 * Set position in a file.
 */
int _lseek(int file, int ptr, int dir)
{
    a508:	b480      	push	{r7}
    a50a:	b085      	sub	sp, #20
    a50c:	af00      	add	r7, sp, #0
    a50e:	60f8      	str	r0, [r7, #12]
    a510:	60b9      	str	r1, [r7, #8]
    a512:	607a      	str	r2, [r7, #4]
    return 0;
    a514:	f04f 0300 	mov.w	r3, #0
}
    a518:	4618      	mov	r0, r3
    a51a:	f107 0714 	add.w	r7, r7, #20
    a51e:	46bd      	mov	sp, r7
    a520:	bc80      	pop	{r7}
    a522:	4770      	bx	lr

0000a524 <_open>:

/*==============================================================================
 * Open a file.
 */
int _open(const char *name, int flags, int mode)
{
    a524:	b480      	push	{r7}
    a526:	b085      	sub	sp, #20
    a528:	af00      	add	r7, sp, #0
    a52a:	60f8      	str	r0, [r7, #12]
    a52c:	60b9      	str	r1, [r7, #8]
    a52e:	607a      	str	r2, [r7, #4]
    return -1;
    a530:	f04f 33ff 	mov.w	r3, #4294967295
}
    a534:	4618      	mov	r0, r3
    a536:	f107 0714 	add.w	r7, r7, #20
    a53a:	46bd      	mov	sp, r7
    a53c:	bc80      	pop	{r7}
    a53e:	4770      	bx	lr

0000a540 <_read>:

/*==============================================================================
 * Read from a file.
 */
int _read(int file, char *ptr, int len)
{
    a540:	b480      	push	{r7}
    a542:	b085      	sub	sp, #20
    a544:	af00      	add	r7, sp, #0
    a546:	60f8      	str	r0, [r7, #12]
    a548:	60b9      	str	r1, [r7, #8]
    a54a:	607a      	str	r2, [r7, #4]
    return 0;
    a54c:	f04f 0300 	mov.w	r3, #0
}
    a550:	4618      	mov	r0, r3
    a552:	f107 0714 	add.w	r7, r7, #20
    a556:	46bd      	mov	sp, r7
    a558:	bc80      	pop	{r7}
    a55a:	4770      	bx	lr

0000a55c <_write_r>:
 * all files, including stdoutso if you need to generate any output, for
 * example to a serial port for debugging, you should make your minimal write
 * capable of doing this.
 */
int _write_r( void * reent, int file, char * ptr, int len )
{
    a55c:	b580      	push	{r7, lr}
    a55e:	b084      	sub	sp, #16
    a560:	af00      	add	r7, sp, #0
    a562:	60f8      	str	r0, [r7, #12]
    a564:	60b9      	str	r1, [r7, #8]
    a566:	607a      	str	r2, [r7, #4]
    a568:	603b      	str	r3, [r7, #0]
#ifdef ACTEL_STDIO_THRU_UART
    /*--------------------------------------------------------------------------
     * Initialize the UART driver if it is the first time this function is
     * called.
     */
    if ( !g_stdio_uart_init_done )
    a56a:	f642 7370 	movw	r3, #12144	; 0x2f70
    a56e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a572:	681b      	ldr	r3, [r3, #0]
    a574:	2b00      	cmp	r3, #0
    a576:	d110      	bne.n	a59a <_write_r+0x3e>
    {
        MSS_UART_init( &g_mss_uart0, ACTEL_STDIO_BAUD_RATE, (MSS_UART_DATA_8_BITS | MSS_UART_NO_PARITY));
    a578:	f64a 10e4 	movw	r0, #43492	; 0xa9e4
    a57c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    a580:	f44f 4161 	mov.w	r1, #57600	; 0xe100
    a584:	f04f 0203 	mov.w	r2, #3
    a588:	f7f7 fbde 	bl	1d48 <MSS_UART_init>
        g_stdio_uart_init_done = 1;
    a58c:	f642 7370 	movw	r3, #12144	; 0x2f70
    a590:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a594:	f04f 0201 	mov.w	r2, #1
    a598:	601a      	str	r2, [r3, #0]
    }
    
    /*--------------------------------------------------------------------------
     * Output text to the UART.
     */
    MSS_UART_polled_tx( &g_mss_uart0, (uint8_t *)ptr, len );
    a59a:	683b      	ldr	r3, [r7, #0]
    a59c:	f64a 10e4 	movw	r0, #43492	; 0xa9e4
    a5a0:	f2c2 0000 	movt	r0, #8192	; 0x2000
    a5a4:	6879      	ldr	r1, [r7, #4]
    a5a6:	461a      	mov	r2, r3
    a5a8:	f7f7 fcd0 	bl	1f4c <MSS_UART_polled_tx>
    
    return len;
    a5ac:	683b      	ldr	r3, [r7, #0]
#else   /* ACTEL_STDIO_THRU_UART */
    return 0;
#endif  /* ACTEL_STDIO_THRU_UART */
}
    a5ae:	4618      	mov	r0, r3
    a5b0:	f107 0710 	add.w	r7, r7, #16
    a5b4:	46bd      	mov	sp, r7
    a5b6:	bd80      	pop	{r7, pc}

0000a5b8 <_sbrk>:
 * it is useful to have a working implementation. The following suffices for a
 * standalone system; it exploits the symbol _end automatically defined by the
 * GNU linker. 
 */
caddr_t _sbrk(int incr)
{
    a5b8:	b580      	push	{r7, lr}
    a5ba:	b084      	sub	sp, #16
    a5bc:	af00      	add	r7, sp, #0
    a5be:	6078      	str	r0, [r7, #4]
    extern char _end;		/* Defined by the linker */
    static char *heap_end;
    char *prev_heap_end;
    char * stack_ptr;
    
    if (heap_end == 0)
    a5c0:	f642 7378 	movw	r3, #12152	; 0x2f78
    a5c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a5c8:	681b      	ldr	r3, [r3, #0]
    a5ca:	2b00      	cmp	r3, #0
    a5cc:	d108      	bne.n	a5e0 <_sbrk+0x28>
    {
      heap_end = &_end;
    a5ce:	f642 7378 	movw	r3, #12152	; 0x2f78
    a5d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a5d6:	f64c 42c0 	movw	r2, #52416	; 0xccc0
    a5da:	f2c2 0200 	movt	r2, #8192	; 0x2000
    a5de:	601a      	str	r2, [r3, #0]
    }
    
    prev_heap_end = heap_end;
    a5e0:	f642 7378 	movw	r3, #12152	; 0x2f78
    a5e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a5e8:	681b      	ldr	r3, [r3, #0]
    a5ea:	60bb      	str	r3, [r7, #8]
    asm volatile ("MRS %0, msp" : "=r" (stack_ptr) );
    a5ec:	f3ef 8308 	mrs	r3, MSP
    a5f0:	60fb      	str	r3, [r7, #12]
    if (heap_end + incr > stack_ptr)
    a5f2:	f642 7378 	movw	r3, #12152	; 0x2f78
    a5f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a5fa:	681a      	ldr	r2, [r3, #0]
    a5fc:	687b      	ldr	r3, [r7, #4]
    a5fe:	441a      	add	r2, r3
    a600:	68fb      	ldr	r3, [r7, #12]
    a602:	429a      	cmp	r2, r3
    a604:	d90f      	bls.n	a626 <_sbrk+0x6e>
    {
      _write_r ((void *)0, 1, "Heap and stack collision\n", 25);
    a606:	f04f 0000 	mov.w	r0, #0
    a60a:	f04f 0101 	mov.w	r1, #1
    a60e:	f24b 72b8 	movw	r2, #47032	; 0xb7b8
    a612:	f2c0 0201 	movt	r2, #1
    a616:	f04f 0319 	mov.w	r3, #25
    a61a:	f7ff ff9f 	bl	a55c <_write_r>
      _exit (1);
    a61e:	f04f 0001 	mov.w	r0, #1
    a622:	f7ff ff15 	bl	a450 <_exit>
    }
  
    heap_end += incr;
    a626:	f642 7378 	movw	r3, #12152	; 0x2f78
    a62a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a62e:	681a      	ldr	r2, [r3, #0]
    a630:	687b      	ldr	r3, [r7, #4]
    a632:	441a      	add	r2, r3
    a634:	f642 7378 	movw	r3, #12152	; 0x2f78
    a638:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a63c:	601a      	str	r2, [r3, #0]
    return (caddr_t) prev_heap_end;
    a63e:	68bb      	ldr	r3, [r7, #8]
}
    a640:	4618      	mov	r0, r3
    a642:	f107 0710 	add.w	r7, r7, #16
    a646:	46bd      	mov	sp, r7
    a648:	bd80      	pop	{r7, pc}
    a64a:	bf00      	nop

0000a64c <_stat>:

/*==============================================================================
 * Status of a file (by name).
 */
int _stat(char *file, struct stat *st)
{
    a64c:	b480      	push	{r7}
    a64e:	b083      	sub	sp, #12
    a650:	af00      	add	r7, sp, #0
    a652:	6078      	str	r0, [r7, #4]
    a654:	6039      	str	r1, [r7, #0]
    st->st_mode = S_IFCHR;
    a656:	683b      	ldr	r3, [r7, #0]
    a658:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    a65c:	605a      	str	r2, [r3, #4]
    return 0;
    a65e:	f04f 0300 	mov.w	r3, #0
}
    a662:	4618      	mov	r0, r3
    a664:	f107 070c 	add.w	r7, r7, #12
    a668:	46bd      	mov	sp, r7
    a66a:	bc80      	pop	{r7}
    a66c:	4770      	bx	lr
    a66e:	bf00      	nop

0000a670 <_times>:

/*==============================================================================
 * Timing information for current process.
 */
int _times(struct tms *buf)
{
    a670:	b480      	push	{r7}
    a672:	b083      	sub	sp, #12
    a674:	af00      	add	r7, sp, #0
    a676:	6078      	str	r0, [r7, #4]
    return -1;
    a678:	f04f 33ff 	mov.w	r3, #4294967295
}
    a67c:	4618      	mov	r0, r3
    a67e:	f107 070c 	add.w	r7, r7, #12
    a682:	46bd      	mov	sp, r7
    a684:	bc80      	pop	{r7}
    a686:	4770      	bx	lr

0000a688 <_unlink>:

/*==============================================================================
 * Remove a file's directory entry.
 */
int _unlink(char *name)
{
    a688:	b580      	push	{r7, lr}
    a68a:	b082      	sub	sp, #8
    a68c:	af00      	add	r7, sp, #0
    a68e:	6078      	str	r0, [r7, #4]
    errno = ENOENT;
    a690:	f00a fb5a 	bl	14d48 <__errno>
    a694:	4603      	mov	r3, r0
    a696:	f04f 0202 	mov.w	r2, #2
    a69a:	601a      	str	r2, [r3, #0]
    return -1;
    a69c:	f04f 33ff 	mov.w	r3, #4294967295
}
    a6a0:	4618      	mov	r0, r3
    a6a2:	f107 0708 	add.w	r7, r7, #8
    a6a6:	46bd      	mov	sp, r7
    a6a8:	bd80      	pop	{r7, pc}
    a6aa:	bf00      	nop

0000a6ac <_wait>:

/*==============================================================================
 * Wait for a child process.
 */
int _wait(int *status)
{
    a6ac:	b580      	push	{r7, lr}
    a6ae:	b082      	sub	sp, #8
    a6b0:	af00      	add	r7, sp, #0
    a6b2:	6078      	str	r0, [r7, #4]
    errno = ECHILD;
    a6b4:	f00a fb48 	bl	14d48 <__errno>
    a6b8:	4603      	mov	r3, r0
    a6ba:	f04f 020a 	mov.w	r2, #10
    a6be:	601a      	str	r2, [r3, #0]
    return -1;
    a6c0:	f04f 33ff 	mov.w	r3, #4294967295
}
    a6c4:	4618      	mov	r0, r3
    a6c6:	f107 0708 	add.w	r7, r7, #8
    a6ca:	46bd      	mov	sp, r7
    a6cc:	bd80      	pop	{r7, pc}
    a6ce:	bf00      	nop

0000a6d0 <uart_string_print>:
//Only uart 0 will be used in this project

mss_uart_instance_t * const uart_instance = &g_mss_uart0;


void uart_string_print(uint8_t * uart_string){
    a6d0:	b580      	push	{r7, lr}
    a6d2:	b082      	sub	sp, #8
    a6d4:	af00      	add	r7, sp, #0
    a6d6:	6078      	str	r0, [r7, #4]
	MSS_UART_polled_tx_string(uart_instance, uart_string);
    a6d8:	f24b 73d4 	movw	r3, #47060	; 0xb7d4
    a6dc:	f2c0 0301 	movt	r3, #1
    a6e0:	681b      	ldr	r3, [r3, #0]
    a6e2:	4618      	mov	r0, r3
    a6e4:	6879      	ldr	r1, [r7, #4]
    a6e6:	f7f7 fca3 	bl	2030 <MSS_UART_polled_tx_string>
}
    a6ea:	f107 0708 	add.w	r7, r7, #8
    a6ee:	46bd      	mov	sp, r7
    a6f0:	bd80      	pop	{r7, pc}
    a6f2:	bf00      	nop

0000a6f4 <buf_setup>:

/*---------------------------------------------------------------------------*/
static void
buf_setup(struct psock_buf *buf,
	  u8_t *bufptr, u16_t bufsize)
{
    a6f4:	b480      	push	{r7}
    a6f6:	b085      	sub	sp, #20
    a6f8:	af00      	add	r7, sp, #0
    a6fa:	60f8      	str	r0, [r7, #12]
    a6fc:	60b9      	str	r1, [r7, #8]
    a6fe:	4613      	mov	r3, r2
    a700:	80fb      	strh	r3, [r7, #6]
  buf->ptr = bufptr;
    a702:	68fb      	ldr	r3, [r7, #12]
    a704:	68ba      	ldr	r2, [r7, #8]
    a706:	601a      	str	r2, [r3, #0]
  buf->left = bufsize;
    a708:	68fb      	ldr	r3, [r7, #12]
    a70a:	88fa      	ldrh	r2, [r7, #6]
    a70c:	809a      	strh	r2, [r3, #4]
}
    a70e:	f107 0714 	add.w	r7, r7, #20
    a712:	46bd      	mov	sp, r7
    a714:	bc80      	pop	{r7}
    a716:	4770      	bx	lr

0000a718 <buf_bufdata>:
/*---------------------------------------------------------------------------*/
static u8_t
buf_bufdata(struct psock_buf *buf, u16_t len,
	    u8_t **dataptr, u16_t *datalen)
{
    a718:	b580      	push	{r7, lr}
    a71a:	b084      	sub	sp, #16
    a71c:	af00      	add	r7, sp, #0
    a71e:	60f8      	str	r0, [r7, #12]
    a720:	607a      	str	r2, [r7, #4]
    a722:	603b      	str	r3, [r7, #0]
    a724:	460b      	mov	r3, r1
    a726:	817b      	strh	r3, [r7, #10]
  ( void ) len;
  if(*datalen < buf->left) {
    a728:	683b      	ldr	r3, [r7, #0]
    a72a:	881a      	ldrh	r2, [r3, #0]
    a72c:	68fb      	ldr	r3, [r7, #12]
    a72e:	889b      	ldrh	r3, [r3, #4]
    a730:	429a      	cmp	r2, r3
    a732:	d228      	bcs.n	a786 <buf_bufdata+0x6e>
    memcpy(buf->ptr, *dataptr, *datalen);
    a734:	68fb      	ldr	r3, [r7, #12]
    a736:	6819      	ldr	r1, [r3, #0]
    a738:	687b      	ldr	r3, [r7, #4]
    a73a:	681a      	ldr	r2, [r3, #0]
    a73c:	683b      	ldr	r3, [r7, #0]
    a73e:	881b      	ldrh	r3, [r3, #0]
    a740:	4608      	mov	r0, r1
    a742:	4611      	mov	r1, r2
    a744:	461a      	mov	r2, r3
    a746:	f00a fb2d 	bl	14da4 <memcpy>
    buf->ptr += *datalen;
    a74a:	68fb      	ldr	r3, [r7, #12]
    a74c:	681a      	ldr	r2, [r3, #0]
    a74e:	683b      	ldr	r3, [r7, #0]
    a750:	881b      	ldrh	r3, [r3, #0]
    a752:	441a      	add	r2, r3
    a754:	68fb      	ldr	r3, [r7, #12]
    a756:	601a      	str	r2, [r3, #0]
    buf->left -= *datalen;
    a758:	68fb      	ldr	r3, [r7, #12]
    a75a:	889a      	ldrh	r2, [r3, #4]
    a75c:	683b      	ldr	r3, [r7, #0]
    a75e:	881b      	ldrh	r3, [r3, #0]
    a760:	ebc3 0302 	rsb	r3, r3, r2
    a764:	b29a      	uxth	r2, r3
    a766:	68fb      	ldr	r3, [r7, #12]
    a768:	809a      	strh	r2, [r3, #4]
    *dataptr += *datalen;
    a76a:	687b      	ldr	r3, [r7, #4]
    a76c:	681a      	ldr	r2, [r3, #0]
    a76e:	683b      	ldr	r3, [r7, #0]
    a770:	881b      	ldrh	r3, [r3, #0]
    a772:	441a      	add	r2, r3
    a774:	687b      	ldr	r3, [r7, #4]
    a776:	601a      	str	r2, [r3, #0]
    *datalen = 0;
    a778:	683b      	ldr	r3, [r7, #0]
    a77a:	f04f 0200 	mov.w	r2, #0
    a77e:	801a      	strh	r2, [r3, #0]
    return BUF_NOT_FULL;
    a780:	f04f 0300 	mov.w	r3, #0
    a784:	e051      	b.n	a82a <buf_bufdata+0x112>
  } else if(*datalen == buf->left) {
    a786:	683b      	ldr	r3, [r7, #0]
    a788:	881a      	ldrh	r2, [r3, #0]
    a78a:	68fb      	ldr	r3, [r7, #12]
    a78c:	889b      	ldrh	r3, [r3, #4]
    a78e:	429a      	cmp	r2, r3
    a790:	d123      	bne.n	a7da <buf_bufdata+0xc2>
    memcpy(buf->ptr, *dataptr, *datalen);
    a792:	68fb      	ldr	r3, [r7, #12]
    a794:	6819      	ldr	r1, [r3, #0]
    a796:	687b      	ldr	r3, [r7, #4]
    a798:	681a      	ldr	r2, [r3, #0]
    a79a:	683b      	ldr	r3, [r7, #0]
    a79c:	881b      	ldrh	r3, [r3, #0]
    a79e:	4608      	mov	r0, r1
    a7a0:	4611      	mov	r1, r2
    a7a2:	461a      	mov	r2, r3
    a7a4:	f00a fafe 	bl	14da4 <memcpy>
    buf->ptr += *datalen;
    a7a8:	68fb      	ldr	r3, [r7, #12]
    a7aa:	681a      	ldr	r2, [r3, #0]
    a7ac:	683b      	ldr	r3, [r7, #0]
    a7ae:	881b      	ldrh	r3, [r3, #0]
    a7b0:	441a      	add	r2, r3
    a7b2:	68fb      	ldr	r3, [r7, #12]
    a7b4:	601a      	str	r2, [r3, #0]
    buf->left = 0;
    a7b6:	68fb      	ldr	r3, [r7, #12]
    a7b8:	f04f 0200 	mov.w	r2, #0
    a7bc:	809a      	strh	r2, [r3, #4]
    *dataptr += *datalen;
    a7be:	687b      	ldr	r3, [r7, #4]
    a7c0:	681a      	ldr	r2, [r3, #0]
    a7c2:	683b      	ldr	r3, [r7, #0]
    a7c4:	881b      	ldrh	r3, [r3, #0]
    a7c6:	441a      	add	r2, r3
    a7c8:	687b      	ldr	r3, [r7, #4]
    a7ca:	601a      	str	r2, [r3, #0]
    *datalen = 0;
    a7cc:	683b      	ldr	r3, [r7, #0]
    a7ce:	f04f 0200 	mov.w	r2, #0
    a7d2:	801a      	strh	r2, [r3, #0]
    return BUF_FULL;
    a7d4:	f04f 0301 	mov.w	r3, #1
    a7d8:	e027      	b.n	a82a <buf_bufdata+0x112>
  } else {
    memcpy(buf->ptr, *dataptr, buf->left);
    a7da:	68fb      	ldr	r3, [r7, #12]
    a7dc:	6819      	ldr	r1, [r3, #0]
    a7de:	687b      	ldr	r3, [r7, #4]
    a7e0:	681a      	ldr	r2, [r3, #0]
    a7e2:	68fb      	ldr	r3, [r7, #12]
    a7e4:	889b      	ldrh	r3, [r3, #4]
    a7e6:	4608      	mov	r0, r1
    a7e8:	4611      	mov	r1, r2
    a7ea:	461a      	mov	r2, r3
    a7ec:	f00a fada 	bl	14da4 <memcpy>
    buf->ptr += buf->left;
    a7f0:	68fb      	ldr	r3, [r7, #12]
    a7f2:	681a      	ldr	r2, [r3, #0]
    a7f4:	68fb      	ldr	r3, [r7, #12]
    a7f6:	889b      	ldrh	r3, [r3, #4]
    a7f8:	441a      	add	r2, r3
    a7fa:	68fb      	ldr	r3, [r7, #12]
    a7fc:	601a      	str	r2, [r3, #0]
    *datalen -= buf->left;
    a7fe:	683b      	ldr	r3, [r7, #0]
    a800:	881a      	ldrh	r2, [r3, #0]
    a802:	68fb      	ldr	r3, [r7, #12]
    a804:	889b      	ldrh	r3, [r3, #4]
    a806:	ebc3 0302 	rsb	r3, r3, r2
    a80a:	b29a      	uxth	r2, r3
    a80c:	683b      	ldr	r3, [r7, #0]
    a80e:	801a      	strh	r2, [r3, #0]
    *dataptr += buf->left;
    a810:	687b      	ldr	r3, [r7, #4]
    a812:	681a      	ldr	r2, [r3, #0]
    a814:	68fb      	ldr	r3, [r7, #12]
    a816:	889b      	ldrh	r3, [r3, #4]
    a818:	441a      	add	r2, r3
    a81a:	687b      	ldr	r3, [r7, #4]
    a81c:	601a      	str	r2, [r3, #0]
    buf->left = 0;
    a81e:	68fb      	ldr	r3, [r7, #12]
    a820:	f04f 0200 	mov.w	r2, #0
    a824:	809a      	strh	r2, [r3, #4]
    return BUF_FULL;
    a826:	f04f 0301 	mov.w	r3, #1
  }
}
    a82a:	4618      	mov	r0, r3
    a82c:	f107 0710 	add.w	r7, r7, #16
    a830:	46bd      	mov	sp, r7
    a832:	bd80      	pop	{r7, pc}

0000a834 <buf_bufto>:
/*---------------------------------------------------------------------------*/
static u8_t
buf_bufto(register struct psock_buf *buf, u8_t endmarker,
	  register u8_t **dataptr, register u16_t *datalen)
{
    a834:	b480      	push	{r7}
    a836:	b085      	sub	sp, #20
    a838:	af00      	add	r7, sp, #0
    a83a:	71f9      	strb	r1, [r7, #7]
  u8_t c;
  while(buf->left > 0 && *datalen > 0) {
    a83c:	e022      	b.n	a884 <buf_bufto+0x50>
    c = *buf->ptr = **dataptr;
    a83e:	6801      	ldr	r1, [r0, #0]
    a840:	f8d2 c000 	ldr.w	ip, [r2]
    a844:	f89c c000 	ldrb.w	ip, [ip]
    a848:	f881 c000 	strb.w	ip, [r1]
    a84c:	7809      	ldrb	r1, [r1, #0]
    a84e:	73f9      	strb	r1, [r7, #15]
    ++*dataptr;
    a850:	6811      	ldr	r1, [r2, #0]
    a852:	f101 0101 	add.w	r1, r1, #1
    a856:	6011      	str	r1, [r2, #0]
    ++buf->ptr;
    a858:	6801      	ldr	r1, [r0, #0]
    a85a:	f101 0101 	add.w	r1, r1, #1
    a85e:	6001      	str	r1, [r0, #0]
    --*datalen;
    a860:	8819      	ldrh	r1, [r3, #0]
    a862:	f101 31ff 	add.w	r1, r1, #4294967295
    a866:	b289      	uxth	r1, r1
    a868:	8019      	strh	r1, [r3, #0]
    --buf->left;
    a86a:	8881      	ldrh	r1, [r0, #4]
    a86c:	f101 31ff 	add.w	r1, r1, #4294967295
    a870:	b289      	uxth	r1, r1
    a872:	8081      	strh	r1, [r0, #4]

    if(c == endmarker) {
    a874:	f897 c00f 	ldrb.w	ip, [r7, #15]
    a878:	79f9      	ldrb	r1, [r7, #7]
    a87a:	458c      	cmp	ip, r1
    a87c:	d102      	bne.n	a884 <buf_bufto+0x50>
      return BUF_FOUND;
    a87e:	f04f 0302 	mov.w	r3, #2
    a882:	e024      	b.n	a8ce <buf_bufto+0x9a>
static u8_t
buf_bufto(register struct psock_buf *buf, u8_t endmarker,
	  register u8_t **dataptr, register u16_t *datalen)
{
  u8_t c;
  while(buf->left > 0 && *datalen > 0) {
    a884:	8881      	ldrh	r1, [r0, #4]
    a886:	2900      	cmp	r1, #0
    a888:	d002      	beq.n	a890 <buf_bufto+0x5c>
    a88a:	8819      	ldrh	r1, [r3, #0]
    a88c:	2900      	cmp	r1, #0
    a88e:	d1d6      	bne.n	a83e <buf_bufto+0xa>
    if(c == endmarker) {
      return BUF_FOUND;
    }
  }

  if(*datalen == 0) {
    a890:	8819      	ldrh	r1, [r3, #0]
    a892:	2900      	cmp	r1, #0
    a894:	d115      	bne.n	a8c2 <buf_bufto+0x8e>
    return BUF_NOT_FOUND;
    a896:	f04f 0300 	mov.w	r3, #0
    a89a:	e018      	b.n	a8ce <buf_bufto+0x9a>
  }

  while(*datalen > 0) {
    c = **dataptr;
    a89c:	6811      	ldr	r1, [r2, #0]
    a89e:	7809      	ldrb	r1, [r1, #0]
    a8a0:	73f9      	strb	r1, [r7, #15]
    --*datalen;
    a8a2:	8819      	ldrh	r1, [r3, #0]
    a8a4:	f101 31ff 	add.w	r1, r1, #4294967295
    a8a8:	b289      	uxth	r1, r1
    a8aa:	8019      	strh	r1, [r3, #0]
    ++*dataptr;
    a8ac:	6811      	ldr	r1, [r2, #0]
    a8ae:	f101 0101 	add.w	r1, r1, #1
    a8b2:	6011      	str	r1, [r2, #0]

    if(c == endmarker) {
    a8b4:	7bf8      	ldrb	r0, [r7, #15]
    a8b6:	79f9      	ldrb	r1, [r7, #7]
    a8b8:	4288      	cmp	r0, r1
    a8ba:	d103      	bne.n	a8c4 <buf_bufto+0x90>
      return BUF_FOUND | BUF_FULL;
    a8bc:	f04f 0303 	mov.w	r3, #3
    a8c0:	e005      	b.n	a8ce <buf_bufto+0x9a>

  if(*datalen == 0) {
    return BUF_NOT_FOUND;
  }

  while(*datalen > 0) {
    a8c2:	bf00      	nop
    a8c4:	8819      	ldrh	r1, [r3, #0]
    a8c6:	2900      	cmp	r1, #0
    a8c8:	d1e8      	bne.n	a89c <buf_bufto+0x68>
    if(c == endmarker) {
      return BUF_FOUND | BUF_FULL;
    }
  }

  return BUF_FULL;
    a8ca:	f04f 0301 	mov.w	r3, #1
}
    a8ce:	4618      	mov	r0, r3
    a8d0:	f107 0714 	add.w	r7, r7, #20
    a8d4:	46bd      	mov	sp, r7
    a8d6:	bc80      	pop	{r7}
    a8d8:	4770      	bx	lr
    a8da:	bf00      	nop

0000a8dc <send_data>:
/*---------------------------------------------------------------------------*/
static char
send_data(register struct psock *s)
{
    a8dc:	b598      	push	{r3, r4, r7, lr}
    a8de:	af00      	add	r7, sp, #0
    a8e0:	4604      	mov	r4, r0
  if(s->state != STATE_DATA_SENT || uip_rexmit()) {
    a8e2:	f894 3020 	ldrb.w	r3, [r4, #32]
    a8e6:	2b06      	cmp	r3, #6
    a8e8:	d108      	bne.n	a8fc <send_data+0x20>
    a8ea:	f64a 4334 	movw	r3, #44084	; 0xac34
    a8ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a8f2:	781b      	ldrb	r3, [r3, #0]
    a8f4:	f003 0304 	and.w	r3, r3, #4
    a8f8:	2b00      	cmp	r3, #0
    a8fa:	d021      	beq.n	a940 <send_data+0x64>
    if(s->sendlen > uip_mss()) {
    a8fc:	8a22      	ldrh	r2, [r4, #16]
    a8fe:	f64a 433c 	movw	r3, #44092	; 0xac3c
    a902:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a906:	681b      	ldr	r3, [r3, #0]
    a908:	8a5b      	ldrh	r3, [r3, #18]
    a90a:	429a      	cmp	r2, r3
    a90c:	d90b      	bls.n	a926 <send_data+0x4a>
      uip_send(s->sendptr, uip_mss());
    a90e:	6862      	ldr	r2, [r4, #4]
    a910:	f64a 433c 	movw	r3, #44092	; 0xac3c
    a914:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a918:	681b      	ldr	r3, [r3, #0]
    a91a:	8a5b      	ldrh	r3, [r3, #18]
    a91c:	4610      	mov	r0, r2
    a91e:	4619      	mov	r1, r3
    a920:	f002 ff60 	bl	d7e4 <uip_send>
    a924:	e005      	b.n	a932 <send_data+0x56>
    } else {
      uip_send(s->sendptr, s->sendlen);
    a926:	6862      	ldr	r2, [r4, #4]
    a928:	8a23      	ldrh	r3, [r4, #16]
    a92a:	4610      	mov	r0, r2
    a92c:	4619      	mov	r1, r3
    a92e:	f002 ff59 	bl	d7e4 <uip_send>
    }
    s->state = STATE_DATA_SENT;
    a932:	f04f 0306 	mov.w	r3, #6
    a936:	f884 3020 	strb.w	r3, [r4, #32]
    return 1;
    a93a:	f04f 0301 	mov.w	r3, #1
    a93e:	e001      	b.n	a944 <send_data+0x68>
  }
  return 0;
    a940:	f04f 0300 	mov.w	r3, #0
}
    a944:	4618      	mov	r0, r3
    a946:	bd98      	pop	{r3, r4, r7, pc}

0000a948 <data_acked>:
/*---------------------------------------------------------------------------*/
static char
data_acked(register struct psock *s)
{
    a948:	b480      	push	{r7}
    a94a:	af00      	add	r7, sp, #0
    a94c:	4603      	mov	r3, r0
  if(s->state == STATE_DATA_SENT && uip_acked()) {
    a94e:	f893 2020 	ldrb.w	r2, [r3, #32]
    a952:	2a06      	cmp	r2, #6
    a954:	d135      	bne.n	a9c2 <data_acked+0x7a>
    a956:	f64a 4234 	movw	r2, #44084	; 0xac34
    a95a:	f2c2 0200 	movt	r2, #8192	; 0x2000
    a95e:	7812      	ldrb	r2, [r2, #0]
    a960:	f002 0201 	and.w	r2, r2, #1
    a964:	b2d2      	uxtb	r2, r2
    a966:	2a00      	cmp	r2, #0
    a968:	d02b      	beq.n	a9c2 <data_acked+0x7a>
    if(s->sendlen > uip_mss()) {
    a96a:	8a19      	ldrh	r1, [r3, #16]
    a96c:	f64a 423c 	movw	r2, #44092	; 0xac3c
    a970:	f2c2 0200 	movt	r2, #8192	; 0x2000
    a974:	6812      	ldr	r2, [r2, #0]
    a976:	8a52      	ldrh	r2, [r2, #18]
    a978:	4291      	cmp	r1, r2
    a97a:	d914      	bls.n	a9a6 <data_acked+0x5e>
      s->sendlen -= uip_mss();
    a97c:	8a19      	ldrh	r1, [r3, #16]
    a97e:	f64a 423c 	movw	r2, #44092	; 0xac3c
    a982:	f2c2 0200 	movt	r2, #8192	; 0x2000
    a986:	6812      	ldr	r2, [r2, #0]
    a988:	8a52      	ldrh	r2, [r2, #18]
    a98a:	ebc2 0201 	rsb	r2, r2, r1
    a98e:	b292      	uxth	r2, r2
    a990:	821a      	strh	r2, [r3, #16]
      s->sendptr += uip_mss();
    a992:	6859      	ldr	r1, [r3, #4]
    a994:	f64a 423c 	movw	r2, #44092	; 0xac3c
    a998:	f2c2 0200 	movt	r2, #8192	; 0x2000
    a99c:	6812      	ldr	r2, [r2, #0]
    a99e:	8a52      	ldrh	r2, [r2, #18]
    a9a0:	440a      	add	r2, r1
    a9a2:	605a      	str	r2, [r3, #4]
    a9a4:	e006      	b.n	a9b4 <data_acked+0x6c>
    } else {
      s->sendptr += s->sendlen;
    a9a6:	6859      	ldr	r1, [r3, #4]
    a9a8:	8a1a      	ldrh	r2, [r3, #16]
    a9aa:	440a      	add	r2, r1
    a9ac:	605a      	str	r2, [r3, #4]
      s->sendlen = 0;
    a9ae:	f04f 0200 	mov.w	r2, #0
    a9b2:	821a      	strh	r2, [r3, #16]
    }
    s->state = STATE_ACKED;
    a9b4:	f04f 0201 	mov.w	r2, #1
    a9b8:	f883 2020 	strb.w	r2, [r3, #32]
    return 1;
    a9bc:	f04f 0301 	mov.w	r3, #1
    a9c0:	e001      	b.n	a9c6 <data_acked+0x7e>
  }
  return 0;
    a9c2:	f04f 0300 	mov.w	r3, #0
}
    a9c6:	4618      	mov	r0, r3
    a9c8:	46bd      	mov	sp, r7
    a9ca:	bc80      	pop	{r7}
    a9cc:	4770      	bx	lr
    a9ce:	bf00      	nop

0000a9d0 <psock_send>:
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_send(register struct psock *s, const char *buf,
		     unsigned int len))
{
    a9d0:	b5b0      	push	{r4, r5, r7, lr}
    a9d2:	b084      	sub	sp, #16
    a9d4:	af00      	add	r7, sp, #0
    a9d6:	4604      	mov	r4, r0
    a9d8:	6079      	str	r1, [r7, #4]
    a9da:	603a      	str	r2, [r7, #0]
  PT_BEGIN(&s->psockpt);
    a9dc:	f04f 0301 	mov.w	r3, #1
    a9e0:	73fb      	strb	r3, [r7, #15]
    a9e2:	8863      	ldrh	r3, [r4, #2]
    a9e4:	2b00      	cmp	r3, #0
    a9e6:	d002      	beq.n	a9ee <psock_send+0x1e>
    a9e8:	2bd0      	cmp	r3, #208	; 0xd0
    a9ea:	d016      	beq.n	aa1a <psock_send+0x4a>
    a9ec:	e02d      	b.n	aa4a <psock_send+0x7a>
  ( void ) PT_YIELD_FLAG;
  /* If there is no data to send, we exit immediately. */
  if(len == 0) {
    a9ee:	683b      	ldr	r3, [r7, #0]
    a9f0:	2b00      	cmp	r3, #0
    a9f2:	d105      	bne.n	aa00 <psock_send+0x30>
    PT_EXIT(&s->psockpt);
    a9f4:	f04f 0300 	mov.w	r3, #0
    a9f8:	8063      	strh	r3, [r4, #2]
    a9fa:	f04f 0301 	mov.w	r3, #1
    a9fe:	e02c      	b.n	aa5a <psock_send+0x8a>
  }

  /* Save the length of and a pointer to the data that is to be
     sent. */
  s->sendptr = (unsigned char*)buf;
    aa00:	687b      	ldr	r3, [r7, #4]
    aa02:	6063      	str	r3, [r4, #4]
  s->sendlen = (unsigned short)len;
    aa04:	683b      	ldr	r3, [r7, #0]
    aa06:	b29b      	uxth	r3, r3
    aa08:	8223      	strh	r3, [r4, #16]

  s->state = STATE_NONE;
    aa0a:	f04f 0300 	mov.w	r3, #0
    aa0e:	f884 3020 	strb.w	r3, [r4, #32]

  /* We loop here until all data is sent. The s->sendlen variable is
     updated by the data_sent() function. */
  while(s->sendlen > 0) {
    aa12:	e013      	b.n	aa3c <psock_send+0x6c>
     * send_data() must be called in succession to ensure that all
     * data is sent. Therefore the & operator is used instead of the
     * && operator, which would cause only the data_acked() function
     * to be called when it returns false.
     */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
    aa14:	f04f 03d0 	mov.w	r3, #208	; 0xd0
    aa18:	8063      	strh	r3, [r4, #2]
    aa1a:	4620      	mov	r0, r4
    aa1c:	f7ff ff94 	bl	a948 <data_acked>
    aa20:	4603      	mov	r3, r0
    aa22:	461d      	mov	r5, r3
    aa24:	4620      	mov	r0, r4
    aa26:	f7ff ff59 	bl	a8dc <send_data>
    aa2a:	4603      	mov	r3, r0
    aa2c:	ea05 0303 	and.w	r3, r5, r3
    aa30:	b2db      	uxtb	r3, r3
    aa32:	2b00      	cmp	r3, #0
    aa34:	d102      	bne.n	aa3c <psock_send+0x6c>
    aa36:	f04f 0300 	mov.w	r3, #0
    aa3a:	e00e      	b.n	aa5a <psock_send+0x8a>

  s->state = STATE_NONE;

  /* We loop here until all data is sent. The s->sendlen variable is
     updated by the data_sent() function. */
  while(s->sendlen > 0) {
    aa3c:	8a23      	ldrh	r3, [r4, #16]
    aa3e:	2b00      	cmp	r3, #0
    aa40:	d1e8      	bne.n	aa14 <psock_send+0x44>
     * to be called when it returns false.
     */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
  }

  s->state = STATE_NONE;
    aa42:	f04f 0300 	mov.w	r3, #0
    aa46:	f884 3020 	strb.w	r3, [r4, #32]

  PT_END(&s->psockpt);
    aa4a:	f04f 0300 	mov.w	r3, #0
    aa4e:	73fb      	strb	r3, [r7, #15]
    aa50:	f04f 0300 	mov.w	r3, #0
    aa54:	8063      	strh	r3, [r4, #2]
    aa56:	f04f 0302 	mov.w	r3, #2
}
    aa5a:	4618      	mov	r0, r3
    aa5c:	f107 0710 	add.w	r7, r7, #16
    aa60:	46bd      	mov	sp, r7
    aa62:	bdb0      	pop	{r4, r5, r7, pc}

0000aa64 <psock_generator_send>:
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_generator_send(register struct psock *s,
			       unsigned short (*generate)(void *), void *arg))
{
    aa64:	b5b0      	push	{r4, r5, r7, lr}
    aa66:	b084      	sub	sp, #16
    aa68:	af00      	add	r7, sp, #0
    aa6a:	4604      	mov	r4, r0
    aa6c:	6079      	str	r1, [r7, #4]
    aa6e:	603a      	str	r2, [r7, #0]
  PT_BEGIN(&s->psockpt);
    aa70:	f04f 0301 	mov.w	r3, #1
    aa74:	73fb      	strb	r3, [r7, #15]
    aa76:	8863      	ldrh	r3, [r4, #2]
    aa78:	2b00      	cmp	r3, #0
    aa7a:	d002      	beq.n	aa82 <psock_generator_send+0x1e>
    aa7c:	2bef      	cmp	r3, #239	; 0xef
    aa7e:	d027      	beq.n	aad0 <psock_generator_send+0x6c>
    aa80:	e03e      	b.n	ab00 <psock_generator_send+0x9c>
  ( void ) PT_YIELD_FLAG;
  /* Ensure that there is a generator function to call. */
  if(generate == NULL) {
    aa82:	687b      	ldr	r3, [r7, #4]
    aa84:	2b00      	cmp	r3, #0
    aa86:	d105      	bne.n	aa94 <psock_generator_send+0x30>
    PT_EXIT(&s->psockpt);
    aa88:	f04f 0300 	mov.w	r3, #0
    aa8c:	8063      	strh	r3, [r4, #2]
    aa8e:	f04f 0301 	mov.w	r3, #1
    aa92:	e03d      	b.n	ab10 <psock_generator_send+0xac>
  }

  /* Call the generator function to generate the data in the
     uip_appdata buffer. */
  s->sendlen = generate(arg);
    aa94:	687b      	ldr	r3, [r7, #4]
    aa96:	6838      	ldr	r0, [r7, #0]
    aa98:	4798      	blx	r3
    aa9a:	4603      	mov	r3, r0
    aa9c:	8223      	strh	r3, [r4, #16]
  s->sendptr = uip_appdata;
    aa9e:	f64a 4338 	movw	r3, #44088	; 0xac38
    aaa2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aaa6:	681b      	ldr	r3, [r3, #0]
    aaa8:	6063      	str	r3, [r4, #4]

  s->state = STATE_NONE;
    aaaa:	f04f 0300 	mov.w	r3, #0
    aaae:	f884 3020 	strb.w	r3, [r4, #32]
  do {
    /* Call the generator function again if we are called to perform a
       retransmission. */
    if(uip_rexmit()) {
    aab2:	f64a 4334 	movw	r3, #44084	; 0xac34
    aab6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aaba:	781b      	ldrb	r3, [r3, #0]
    aabc:	f003 0304 	and.w	r3, r3, #4
    aac0:	2b00      	cmp	r3, #0
    aac2:	d002      	beq.n	aaca <psock_generator_send+0x66>
      generate(arg);
    aac4:	687b      	ldr	r3, [r7, #4]
    aac6:	6838      	ldr	r0, [r7, #0]
    aac8:	4798      	blx	r3
    }
    /* Wait until all data is sent and acknowledged. */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
    aaca:	f04f 03ef 	mov.w	r3, #239	; 0xef
    aace:	8063      	strh	r3, [r4, #2]
    aad0:	4620      	mov	r0, r4
    aad2:	f7ff ff39 	bl	a948 <data_acked>
    aad6:	4603      	mov	r3, r0
    aad8:	461d      	mov	r5, r3
    aada:	4620      	mov	r0, r4
    aadc:	f7ff fefe 	bl	a8dc <send_data>
    aae0:	4603      	mov	r3, r0
    aae2:	ea05 0303 	and.w	r3, r5, r3
    aae6:	b2db      	uxtb	r3, r3
    aae8:	2b00      	cmp	r3, #0
    aaea:	d102      	bne.n	aaf2 <psock_generator_send+0x8e>
    aaec:	f04f 0300 	mov.w	r3, #0
    aaf0:	e00e      	b.n	ab10 <psock_generator_send+0xac>
  } while(s->sendlen > 0);
    aaf2:	8a23      	ldrh	r3, [r4, #16]
    aaf4:	2b00      	cmp	r3, #0
    aaf6:	d1dc      	bne.n	aab2 <psock_generator_send+0x4e>

  s->state = STATE_NONE;
    aaf8:	f04f 0300 	mov.w	r3, #0
    aafc:	f884 3020 	strb.w	r3, [r4, #32]

  PT_END(&s->psockpt);
    ab00:	f04f 0300 	mov.w	r3, #0
    ab04:	73fb      	strb	r3, [r7, #15]
    ab06:	f04f 0300 	mov.w	r3, #0
    ab0a:	8063      	strh	r3, [r4, #2]
    ab0c:	f04f 0302 	mov.w	r3, #2
}
    ab10:	4618      	mov	r0, r3
    ab12:	f107 0710 	add.w	r7, r7, #16
    ab16:	46bd      	mov	sp, r7
    ab18:	bdb0      	pop	{r4, r5, r7, pc}
    ab1a:	bf00      	nop

0000ab1c <psock_datalen>:
/*---------------------------------------------------------------------------*/
u16_t
psock_datalen(struct psock *psock)
{
    ab1c:	b480      	push	{r7}
    ab1e:	b083      	sub	sp, #12
    ab20:	af00      	add	r7, sp, #0
    ab22:	6078      	str	r0, [r7, #4]
  return psock->bufsize - psock->buf.left;
    ab24:	687b      	ldr	r3, [r7, #4]
    ab26:	69db      	ldr	r3, [r3, #28]
    ab28:	b29a      	uxth	r2, r3
    ab2a:	687b      	ldr	r3, [r7, #4]
    ab2c:	8b1b      	ldrh	r3, [r3, #24]
    ab2e:	ebc3 0302 	rsb	r3, r3, r2
    ab32:	b29b      	uxth	r3, r3
}
    ab34:	4618      	mov	r0, r3
    ab36:	f107 070c 	add.w	r7, r7, #12
    ab3a:	46bd      	mov	sp, r7
    ab3c:	bc80      	pop	{r7}
    ab3e:	4770      	bx	lr

0000ab40 <psock_newdata>:
/*---------------------------------------------------------------------------*/
char
psock_newdata(struct psock *s)
{
    ab40:	b480      	push	{r7}
    ab42:	b083      	sub	sp, #12
    ab44:	af00      	add	r7, sp, #0
    ab46:	6078      	str	r0, [r7, #4]
  if(s->readlen > 0) {
    ab48:	687b      	ldr	r3, [r7, #4]
    ab4a:	8a5b      	ldrh	r3, [r3, #18]
    ab4c:	2b00      	cmp	r3, #0
    ab4e:	d002      	beq.n	ab56 <psock_newdata+0x16>
    /* There is data in the uip_appdata buffer that has not yet been
       read with the PSOCK_READ functions. */
    return 1;
    ab50:	f04f 0301 	mov.w	r3, #1
    ab54:	e01a      	b.n	ab8c <psock_newdata+0x4c>
  } else if(s->state == STATE_READ) {
    ab56:	687b      	ldr	r3, [r7, #4]
    ab58:	f893 3020 	ldrb.w	r3, [r3, #32]
    ab5c:	2b02      	cmp	r3, #2
    ab5e:	d107      	bne.n	ab70 <psock_newdata+0x30>
    /* All data in uip_appdata buffer already consumed. */
    s->state = STATE_BLOCKED_NEWDATA;
    ab60:	687b      	ldr	r3, [r7, #4]
    ab62:	f04f 0203 	mov.w	r2, #3
    ab66:	f883 2020 	strb.w	r2, [r3, #32]
    return 0;
    ab6a:	f04f 0300 	mov.w	r3, #0
    ab6e:	e00d      	b.n	ab8c <psock_newdata+0x4c>
  } else if(uip_newdata()) {
    ab70:	f64a 4334 	movw	r3, #44084	; 0xac34
    ab74:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ab78:	781b      	ldrb	r3, [r3, #0]
    ab7a:	f003 0302 	and.w	r3, r3, #2
    ab7e:	2b00      	cmp	r3, #0
    ab80:	d002      	beq.n	ab88 <psock_newdata+0x48>
    /* There is new data that has not been consumed. */
    return 1;
    ab82:	f04f 0301 	mov.w	r3, #1
    ab86:	e001      	b.n	ab8c <psock_newdata+0x4c>
  } else {
    /* There is no new data. */
    return 0;
    ab88:	f04f 0300 	mov.w	r3, #0
  }
}
    ab8c:	4618      	mov	r0, r3
    ab8e:	f107 070c 	add.w	r7, r7, #12
    ab92:	46bd      	mov	sp, r7
    ab94:	bc80      	pop	{r7}
    ab96:	4770      	bx	lr

0000ab98 <psock_readto>:
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_readto(register struct psock *psock, unsigned char c))
{
    ab98:	b590      	push	{r4, r7, lr}
    ab9a:	b085      	sub	sp, #20
    ab9c:	af00      	add	r7, sp, #0
    ab9e:	4604      	mov	r4, r0
    aba0:	460b      	mov	r3, r1
    aba2:	71fb      	strb	r3, [r7, #7]
  PT_BEGIN(&psock->psockpt);
    aba4:	f04f 0301 	mov.w	r3, #1
    aba8:	73fb      	strb	r3, [r7, #15]
    abaa:	8863      	ldrh	r3, [r4, #2]
    abac:	2b00      	cmp	r3, #0
    abae:	d003      	beq.n	abb8 <psock_readto+0x20>
    abb0:	f5b3 7f8e 	cmp.w	r3, #284	; 0x11c
    abb4:	d010      	beq.n	abd8 <psock_readto+0x40>
    abb6:	e046      	b.n	ac46 <psock_readto+0xae>
  ( void ) PT_YIELD_FLAG;
  buf_setup(&psock->buf, (unsigned char*)psock->bufptr, psock->bufsize);
    abb8:	f104 0114 	add.w	r1, r4, #20
    abbc:	68e2      	ldr	r2, [r4, #12]
    abbe:	69e3      	ldr	r3, [r4, #28]
    abc0:	b29b      	uxth	r3, r3
    abc2:	4608      	mov	r0, r1
    abc4:	4611      	mov	r1, r2
    abc6:	461a      	mov	r2, r3
    abc8:	f7ff fd94 	bl	a6f4 <buf_setup>

  /* XXX: Should add buf_checkmarker() before do{} loop, if
     incoming data has been handled while waiting for a write. */

  do {
    if(psock->readlen == 0) {
    abcc:	8a63      	ldrh	r3, [r4, #18]
    abce:	2b00      	cmp	r3, #0
    abd0:	d11b      	bne.n	ac0a <psock_readto+0x72>
      PT_WAIT_UNTIL(&psock->psockpt, psock_newdata(psock));
    abd2:	f44f 738e 	mov.w	r3, #284	; 0x11c
    abd6:	8063      	strh	r3, [r4, #2]
    abd8:	4620      	mov	r0, r4
    abda:	f7ff ffb1 	bl	ab40 <psock_newdata>
    abde:	4603      	mov	r3, r0
    abe0:	2b00      	cmp	r3, #0
    abe2:	d102      	bne.n	abea <psock_readto+0x52>
    abe4:	f04f 0300 	mov.w	r3, #0
    abe8:	e035      	b.n	ac56 <psock_readto+0xbe>
      psock->state = STATE_READ;
    abea:	f04f 0302 	mov.w	r3, #2
    abee:	f884 3020 	strb.w	r3, [r4, #32]
      psock->readptr = (u8_t *)uip_appdata;
    abf2:	f64a 4338 	movw	r3, #44088	; 0xac38
    abf6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    abfa:	681b      	ldr	r3, [r3, #0]
    abfc:	60a3      	str	r3, [r4, #8]
      psock->readlen = uip_datalen();
    abfe:	f64a 4328 	movw	r3, #44072	; 0xac28
    ac02:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ac06:	881b      	ldrh	r3, [r3, #0]
    ac08:	8263      	strh	r3, [r4, #18]
    }
  } while((buf_bufto(&psock->buf, c,
    ac0a:	f104 0014 	add.w	r0, r4, #20
    ac0e:	f104 0208 	add.w	r2, r4, #8
    ac12:	f104 0312 	add.w	r3, r4, #18
    ac16:	79f9      	ldrb	r1, [r7, #7]
    ac18:	f7ff fe0c 	bl	a834 <buf_bufto>
    ac1c:	4603      	mov	r3, r0
    ac1e:	f003 0302 	and.w	r3, r3, #2
		     &psock->readptr,
		     &psock->readlen) & BUF_FOUND) == 0);
    ac22:	2b00      	cmp	r3, #0
    ac24:	d0d2      	beq.n	abcc <psock_readto+0x34>

  if(psock_datalen(psock) == 0) {
    ac26:	4620      	mov	r0, r4
    ac28:	f7ff ff78 	bl	ab1c <psock_datalen>
    ac2c:	4603      	mov	r3, r0
    ac2e:	2b00      	cmp	r3, #0
    ac30:	d109      	bne.n	ac46 <psock_readto+0xae>
    psock->state = STATE_NONE;
    ac32:	f04f 0300 	mov.w	r3, #0
    ac36:	f884 3020 	strb.w	r3, [r4, #32]
    PT_RESTART(&psock->psockpt);
    ac3a:	f04f 0300 	mov.w	r3, #0
    ac3e:	8063      	strh	r3, [r4, #2]
    ac40:	f04f 0300 	mov.w	r3, #0
    ac44:	e007      	b.n	ac56 <psock_readto+0xbe>
  }
  PT_END(&psock->psockpt);
    ac46:	f04f 0300 	mov.w	r3, #0
    ac4a:	73fb      	strb	r3, [r7, #15]
    ac4c:	f04f 0300 	mov.w	r3, #0
    ac50:	8063      	strh	r3, [r4, #2]
    ac52:	f04f 0302 	mov.w	r3, #2
}
    ac56:	4618      	mov	r0, r3
    ac58:	f107 0714 	add.w	r7, r7, #20
    ac5c:	46bd      	mov	sp, r7
    ac5e:	bd90      	pop	{r4, r7, pc}

0000ac60 <psock_readbuf>:
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_readbuf(register struct psock *psock))
{
    ac60:	b590      	push	{r4, r7, lr}
    ac62:	b083      	sub	sp, #12
    ac64:	af00      	add	r7, sp, #0
    ac66:	4604      	mov	r4, r0
  PT_BEGIN(&psock->psockpt);
    ac68:	f04f 0301 	mov.w	r3, #1
    ac6c:	71fb      	strb	r3, [r7, #7]
    ac6e:	8863      	ldrh	r3, [r4, #2]
    ac70:	2b00      	cmp	r3, #0
    ac72:	d004      	beq.n	ac7e <psock_readbuf+0x1e>
    ac74:	f240 1237 	movw	r2, #311	; 0x137
    ac78:	4293      	cmp	r3, r2
    ac7a:	d010      	beq.n	ac9e <psock_readbuf+0x3e>
    ac7c:	e045      	b.n	ad0a <psock_readbuf+0xaa>
  ( void ) PT_YIELD_FLAG;
  buf_setup(&psock->buf, (unsigned char * ) psock->bufptr, psock->bufsize);
    ac7e:	f104 0114 	add.w	r1, r4, #20
    ac82:	68e2      	ldr	r2, [r4, #12]
    ac84:	69e3      	ldr	r3, [r4, #28]
    ac86:	b29b      	uxth	r3, r3
    ac88:	4608      	mov	r0, r1
    ac8a:	4611      	mov	r1, r2
    ac8c:	461a      	mov	r2, r3
    ac8e:	f7ff fd31 	bl	a6f4 <buf_setup>

  /* XXX: Should add buf_checkmarker() before do{} loop, if
     incoming data has been handled while waiting for a write. */

  do {
    if(psock->readlen == 0) {
    ac92:	8a63      	ldrh	r3, [r4, #18]
    ac94:	2b00      	cmp	r3, #0
    ac96:	d11b      	bne.n	acd0 <psock_readbuf+0x70>
      PT_WAIT_UNTIL(&psock->psockpt, psock_newdata(psock));
    ac98:	f240 1337 	movw	r3, #311	; 0x137
    ac9c:	8063      	strh	r3, [r4, #2]
    ac9e:	4620      	mov	r0, r4
    aca0:	f7ff ff4e 	bl	ab40 <psock_newdata>
    aca4:	4603      	mov	r3, r0
    aca6:	2b00      	cmp	r3, #0
    aca8:	d102      	bne.n	acb0 <psock_readbuf+0x50>
    acaa:	f04f 0300 	mov.w	r3, #0
    acae:	e034      	b.n	ad1a <psock_readbuf+0xba>
      psock->state = STATE_READ;
    acb0:	f04f 0302 	mov.w	r3, #2
    acb4:	f884 3020 	strb.w	r3, [r4, #32]
      psock->readptr = (u8_t *)uip_appdata;
    acb8:	f64a 4338 	movw	r3, #44088	; 0xac38
    acbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    acc0:	681b      	ldr	r3, [r3, #0]
    acc2:	60a3      	str	r3, [r4, #8]
      psock->readlen = uip_datalen();
    acc4:	f64a 4328 	movw	r3, #44072	; 0xac28
    acc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    accc:	881b      	ldrh	r3, [r3, #0]
    acce:	8263      	strh	r3, [r4, #18]
    }
  } while(buf_bufdata(&psock->buf, psock->bufsize,
    acd0:	f104 0014 	add.w	r0, r4, #20
    acd4:	69e3      	ldr	r3, [r4, #28]
    acd6:	b299      	uxth	r1, r3
    acd8:	f104 0208 	add.w	r2, r4, #8
    acdc:	f104 0312 	add.w	r3, r4, #18
    ace0:	f7ff fd1a 	bl	a718 <buf_bufdata>
    ace4:	4603      	mov	r3, r0
			 &psock->readptr,
			 &psock->readlen) != BUF_FULL);
    ace6:	2b01      	cmp	r3, #1
    ace8:	d1d3      	bne.n	ac92 <psock_readbuf+0x32>

  if(psock_datalen(psock) == 0) {
    acea:	4620      	mov	r0, r4
    acec:	f7ff ff16 	bl	ab1c <psock_datalen>
    acf0:	4603      	mov	r3, r0
    acf2:	2b00      	cmp	r3, #0
    acf4:	d109      	bne.n	ad0a <psock_readbuf+0xaa>
    psock->state = STATE_NONE;
    acf6:	f04f 0300 	mov.w	r3, #0
    acfa:	f884 3020 	strb.w	r3, [r4, #32]
    PT_RESTART(&psock->psockpt);
    acfe:	f04f 0300 	mov.w	r3, #0
    ad02:	8063      	strh	r3, [r4, #2]
    ad04:	f04f 0300 	mov.w	r3, #0
    ad08:	e007      	b.n	ad1a <psock_readbuf+0xba>
  }
  PT_END(&psock->psockpt);
    ad0a:	f04f 0300 	mov.w	r3, #0
    ad0e:	71fb      	strb	r3, [r7, #7]
    ad10:	f04f 0300 	mov.w	r3, #0
    ad14:	8063      	strh	r3, [r4, #2]
    ad16:	f04f 0302 	mov.w	r3, #2
}
    ad1a:	4618      	mov	r0, r3
    ad1c:	f107 070c 	add.w	r7, r7, #12
    ad20:	46bd      	mov	sp, r7
    ad22:	bd90      	pop	{r4, r7, pc}

0000ad24 <psock_init>:
/*---------------------------------------------------------------------------*/
void
psock_init(register struct psock *psock, char *buffer, unsigned int buffersize)
{
    ad24:	b590      	push	{r4, r7, lr}
    ad26:	b083      	sub	sp, #12
    ad28:	af00      	add	r7, sp, #0
    ad2a:	4604      	mov	r4, r0
    ad2c:	6079      	str	r1, [r7, #4]
    ad2e:	603a      	str	r2, [r7, #0]
  psock->state = STATE_NONE;
    ad30:	f04f 0300 	mov.w	r3, #0
    ad34:	f884 3020 	strb.w	r3, [r4, #32]
  psock->readlen = 0;
    ad38:	f04f 0300 	mov.w	r3, #0
    ad3c:	8263      	strh	r3, [r4, #18]
  psock->bufptr = buffer;
    ad3e:	687b      	ldr	r3, [r7, #4]
    ad40:	60e3      	str	r3, [r4, #12]
  psock->bufsize = buffersize;
    ad42:	683b      	ldr	r3, [r7, #0]
    ad44:	61e3      	str	r3, [r4, #28]
  buf_setup(&psock->buf, (unsigned char*) buffer, buffersize);
    ad46:	f104 0214 	add.w	r2, r4, #20
    ad4a:	683b      	ldr	r3, [r7, #0]
    ad4c:	b29b      	uxth	r3, r3
    ad4e:	4610      	mov	r0, r2
    ad50:	6879      	ldr	r1, [r7, #4]
    ad52:	461a      	mov	r2, r3
    ad54:	f7ff fcce 	bl	a6f4 <buf_setup>
  PT_INIT(&psock->pt);
    ad58:	f04f 0300 	mov.w	r3, #0
    ad5c:	8023      	strh	r3, [r4, #0]
  PT_INIT(&psock->psockpt);
    ad5e:	f04f 0300 	mov.w	r3, #0
    ad62:	8063      	strh	r3, [r4, #2]
}
    ad64:	f107 070c 	add.w	r7, r7, #12
    ad68:	46bd      	mov	sp, r7
    ad6a:	bd90      	pop	{r4, r7, pc}

0000ad6c <timer_set>:
 * \param t A pointer to the timer
 * \param interval The interval before the timer expires.
 *
 */
void timer_set( struct timer *t, clock_time_t interval )
{
    ad6c:	b580      	push	{r7, lr}
    ad6e:	b082      	sub	sp, #8
    ad70:	af00      	add	r7, sp, #0
    ad72:	6078      	str	r0, [r7, #4]
    ad74:	6039      	str	r1, [r7, #0]
	t->interval = interval;
    ad76:	687b      	ldr	r3, [r7, #4]
    ad78:	683a      	ldr	r2, [r7, #0]
    ad7a:	605a      	str	r2, [r3, #4]
	t->start = clock_time();
    ad7c:	f7f6 f81a 	bl	db4 <clock_time>
    ad80:	4602      	mov	r2, r0
    ad82:	687b      	ldr	r3, [r7, #4]
    ad84:	601a      	str	r2, [r3, #0]
}
    ad86:	f107 0708 	add.w	r7, r7, #8
    ad8a:	46bd      	mov	sp, r7
    ad8c:	bd80      	pop	{r7, pc}
    ad8e:	bf00      	nop

0000ad90 <timer_reset>:
 * \param t A pointer to the timer.
 *
 * \sa timer_restart()
 */
void timer_reset( struct timer *t )
{
    ad90:	b480      	push	{r7}
    ad92:	b083      	sub	sp, #12
    ad94:	af00      	add	r7, sp, #0
    ad96:	6078      	str	r0, [r7, #4]
	t->start += t->interval;
    ad98:	687b      	ldr	r3, [r7, #4]
    ad9a:	681a      	ldr	r2, [r3, #0]
    ad9c:	687b      	ldr	r3, [r7, #4]
    ad9e:	685b      	ldr	r3, [r3, #4]
    ada0:	441a      	add	r2, r3
    ada2:	687b      	ldr	r3, [r7, #4]
    ada4:	601a      	str	r2, [r3, #0]
}
    ada6:	f107 070c 	add.w	r7, r7, #12
    adaa:	46bd      	mov	sp, r7
    adac:	bc80      	pop	{r7}
    adae:	4770      	bx	lr

0000adb0 <timer_restart>:
 * \param t A pointer to the timer.
 *
 * \sa timer_reset()
 */
void timer_restart( struct timer *t )
{
    adb0:	b580      	push	{r7, lr}
    adb2:	b082      	sub	sp, #8
    adb4:	af00      	add	r7, sp, #0
    adb6:	6078      	str	r0, [r7, #4]
	t->start = clock_time();
    adb8:	f7f5 fffc 	bl	db4 <clock_time>
    adbc:	4602      	mov	r2, r0
    adbe:	687b      	ldr	r3, [r7, #4]
    adc0:	601a      	str	r2, [r3, #0]
}
    adc2:	f107 0708 	add.w	r7, r7, #8
    adc6:	46bd      	mov	sp, r7
    adc8:	bd80      	pop	{r7, pc}
    adca:	bf00      	nop

0000adcc <timer_expired>:
 *
 * \return Non-zero if the timer has expired, zero otherwise.
 *
 */
int timer_expired( struct timer *t )
{
    adcc:	b580      	push	{r7, lr}
    adce:	b082      	sub	sp, #8
    add0:	af00      	add	r7, sp, #0
    add2:	6078      	str	r0, [r7, #4]
	return( clock_time_t ) ( clock_time() - t->start ) >= ( clock_time_t ) t->interval;
    add4:	f7f5 ffee 	bl	db4 <clock_time>
    add8:	4602      	mov	r2, r0
    adda:	687b      	ldr	r3, [r7, #4]
    addc:	681b      	ldr	r3, [r3, #0]
    adde:	ebc3 0202 	rsb	r2, r3, r2
    ade2:	687b      	ldr	r3, [r7, #4]
    ade4:	685b      	ldr	r3, [r3, #4]
    ade6:	429a      	cmp	r2, r3
    ade8:	bf34      	ite	cc
    adea:	2300      	movcc	r3, #0
    adec:	2301      	movcs	r3, #1
}
    adee:	4618      	mov	r0, r3
    adf0:	f107 0708 	add.w	r7, r7, #8
    adf4:	46bd      	mov	sp, r7
    adf6:	bd80      	pop	{r7, pc}

0000adf8 <timer_remaining>:
 *
 * \return The time until the timer expires
 *
 */
clock_time_t timer_remaining( struct timer *t )
{
    adf8:	b590      	push	{r4, r7, lr}
    adfa:	b083      	sub	sp, #12
    adfc:	af00      	add	r7, sp, #0
    adfe:	6078      	str	r0, [r7, #4]
	return t->start + t->interval - clock_time();
    ae00:	687b      	ldr	r3, [r7, #4]
    ae02:	681a      	ldr	r2, [r3, #0]
    ae04:	687b      	ldr	r3, [r7, #4]
    ae06:	685b      	ldr	r3, [r3, #4]
    ae08:	eb02 0403 	add.w	r4, r2, r3
    ae0c:	f7f5 ffd2 	bl	db4 <clock_time>
    ae10:	4603      	mov	r3, r0
    ae12:	ebc3 0304 	rsb	r3, r3, r4
}
    ae16:	4618      	mov	r0, r3
    ae18:	f107 070c 	add.w	r7, r7, #12
    ae1c:	46bd      	mov	sp, r7
    ae1e:	bd90      	pop	{r4, r7, pc}

0000ae20 <uip_setipid>:

/* Ths ipid variable is an increasing number that is used for the IP ID	field. */
static u16_t ipid;

void uip_setipid( u16_t id )
{
    ae20:	b480      	push	{r7}
    ae22:	b083      	sub	sp, #12
    ae24:	af00      	add	r7, sp, #0
    ae26:	4603      	mov	r3, r0
    ae28:	80fb      	strh	r3, [r7, #6]
	ipid = id;
    ae2a:	f642 7384 	movw	r3, #12164	; 0x2f84
    ae2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ae32:	88fa      	ldrh	r2, [r7, #6]
    ae34:	801a      	strh	r2, [r3, #0]
}
    ae36:	f107 070c 	add.w	r7, r7, #12
    ae3a:	46bd      	mov	sp, r7
    ae3c:	bc80      	pop	{r7}
    ae3e:	4770      	bx	lr

0000ae40 <uip_add32>:
	#define UIP_LOG( m )
#endif /* UIP_LOGGING == 1 */

#if !UIP_ARCH_ADD32
	void uip_add32( u8_t *op32, u16_t op16 )
	{
    ae40:	b480      	push	{r7}
    ae42:	b083      	sub	sp, #12
    ae44:	af00      	add	r7, sp, #0
    ae46:	6078      	str	r0, [r7, #4]
    ae48:	460b      	mov	r3, r1
    ae4a:	807b      	strh	r3, [r7, #2]
		uip_acc32[3] = op32[3] + ( op16 & 0xff );
    ae4c:	687b      	ldr	r3, [r7, #4]
    ae4e:	f103 0303 	add.w	r3, r3, #3
    ae52:	781a      	ldrb	r2, [r3, #0]
    ae54:	887b      	ldrh	r3, [r7, #2]
    ae56:	b2db      	uxtb	r3, r3
    ae58:	4413      	add	r3, r2
    ae5a:	b2da      	uxtb	r2, r3
    ae5c:	f64a 4330 	movw	r3, #44080	; 0xac30
    ae60:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ae64:	70da      	strb	r2, [r3, #3]
		uip_acc32[2] = op32[2] + ( op16 >> 8 );
    ae66:	687b      	ldr	r3, [r7, #4]
    ae68:	f103 0302 	add.w	r3, r3, #2
    ae6c:	781a      	ldrb	r2, [r3, #0]
    ae6e:	887b      	ldrh	r3, [r7, #2]
    ae70:	ea4f 2313 	mov.w	r3, r3, lsr #8
    ae74:	b29b      	uxth	r3, r3
    ae76:	b2db      	uxtb	r3, r3
    ae78:	4413      	add	r3, r2
    ae7a:	b2da      	uxtb	r2, r3
    ae7c:	f64a 4330 	movw	r3, #44080	; 0xac30
    ae80:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ae84:	709a      	strb	r2, [r3, #2]
		uip_acc32[1] = op32[1];
    ae86:	687b      	ldr	r3, [r7, #4]
    ae88:	f103 0301 	add.w	r3, r3, #1
    ae8c:	781a      	ldrb	r2, [r3, #0]
    ae8e:	f64a 4330 	movw	r3, #44080	; 0xac30
    ae92:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ae96:	705a      	strb	r2, [r3, #1]
		uip_acc32[0] = op32[0];
    ae98:	687b      	ldr	r3, [r7, #4]
    ae9a:	781a      	ldrb	r2, [r3, #0]
    ae9c:	f64a 4330 	movw	r3, #44080	; 0xac30
    aea0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aea4:	701a      	strb	r2, [r3, #0]

		if( uip_acc32[2] < (op16 >> 8) )
    aea6:	f64a 4330 	movw	r3, #44080	; 0xac30
    aeaa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aeae:	789b      	ldrb	r3, [r3, #2]
    aeb0:	461a      	mov	r2, r3
    aeb2:	887b      	ldrh	r3, [r7, #2]
    aeb4:	ea4f 2313 	mov.w	r3, r3, lsr #8
    aeb8:	b29b      	uxth	r3, r3
    aeba:	429a      	cmp	r2, r3
    aebc:	d220      	bcs.n	af00 <uip_add32+0xc0>
		{
			++uip_acc32[1];
    aebe:	f64a 4330 	movw	r3, #44080	; 0xac30
    aec2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aec6:	785b      	ldrb	r3, [r3, #1]
    aec8:	f103 0301 	add.w	r3, r3, #1
    aecc:	b2da      	uxtb	r2, r3
    aece:	f64a 4330 	movw	r3, #44080	; 0xac30
    aed2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aed6:	705a      	strb	r2, [r3, #1]
			if( uip_acc32[1] == 0 )
    aed8:	f64a 4330 	movw	r3, #44080	; 0xac30
    aedc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aee0:	785b      	ldrb	r3, [r3, #1]
    aee2:	2b00      	cmp	r3, #0
    aee4:	d10c      	bne.n	af00 <uip_add32+0xc0>
			{
				++uip_acc32[0];
    aee6:	f64a 4330 	movw	r3, #44080	; 0xac30
    aeea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aeee:	781b      	ldrb	r3, [r3, #0]
    aef0:	f103 0301 	add.w	r3, r3, #1
    aef4:	b2da      	uxtb	r2, r3
    aef6:	f64a 4330 	movw	r3, #44080	; 0xac30
    aefa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aefe:	701a      	strb	r2, [r3, #0]
			}
		}

		if( uip_acc32[3] < (op16 & 0xff) )
    af00:	f64a 4330 	movw	r3, #44080	; 0xac30
    af04:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af08:	78db      	ldrb	r3, [r3, #3]
    af0a:	461a      	mov	r2, r3
    af0c:	887b      	ldrh	r3, [r7, #2]
    af0e:	f003 03ff 	and.w	r3, r3, #255	; 0xff
    af12:	429a      	cmp	r2, r3
    af14:	da34      	bge.n	af80 <uip_add32+0x140>
		{
			++uip_acc32[2];
    af16:	f64a 4330 	movw	r3, #44080	; 0xac30
    af1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af1e:	789b      	ldrb	r3, [r3, #2]
    af20:	f103 0301 	add.w	r3, r3, #1
    af24:	b2da      	uxtb	r2, r3
    af26:	f64a 4330 	movw	r3, #44080	; 0xac30
    af2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af2e:	709a      	strb	r2, [r3, #2]
			if( uip_acc32[2] == 0 )
    af30:	f64a 4330 	movw	r3, #44080	; 0xac30
    af34:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af38:	789b      	ldrb	r3, [r3, #2]
    af3a:	2b00      	cmp	r3, #0
    af3c:	d120      	bne.n	af80 <uip_add32+0x140>
			{
				++uip_acc32[1];
    af3e:	f64a 4330 	movw	r3, #44080	; 0xac30
    af42:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af46:	785b      	ldrb	r3, [r3, #1]
    af48:	f103 0301 	add.w	r3, r3, #1
    af4c:	b2da      	uxtb	r2, r3
    af4e:	f64a 4330 	movw	r3, #44080	; 0xac30
    af52:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af56:	705a      	strb	r2, [r3, #1]
				if( uip_acc32[1] == 0 )
    af58:	f64a 4330 	movw	r3, #44080	; 0xac30
    af5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af60:	785b      	ldrb	r3, [r3, #1]
    af62:	2b00      	cmp	r3, #0
    af64:	d10c      	bne.n	af80 <uip_add32+0x140>
				{
					++uip_acc32[0];
    af66:	f64a 4330 	movw	r3, #44080	; 0xac30
    af6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af6e:	781b      	ldrb	r3, [r3, #0]
    af70:	f103 0301 	add.w	r3, r3, #1
    af74:	b2da      	uxtb	r2, r3
    af76:	f64a 4330 	movw	r3, #44080	; 0xac30
    af7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af7e:	701a      	strb	r2, [r3, #0]
				}
			}
		}
	}
    af80:	f107 070c 	add.w	r7, r7, #12
    af84:	46bd      	mov	sp, r7
    af86:	bc80      	pop	{r7}
    af88:	4770      	bx	lr
    af8a:	bf00      	nop

0000af8c <chksum>:
#endif /* UIP_ARCH_ADD32 */

#if !UIP_ARCH_CHKSUM

	static u16_t chksum( u16_t sum, const u8_t *data, u16_t len )
	{
    af8c:	b480      	push	{r7}
    af8e:	b089      	sub	sp, #36	; 0x24
    af90:	af00      	add	r7, sp, #0
    af92:	60b9      	str	r1, [r7, #8]
    af94:	4613      	mov	r3, r2
    af96:	4602      	mov	r2, r0
    af98:	81fa      	strh	r2, [r7, #14]
    af9a:	80fb      	strh	r3, [r7, #6]
		u16_t		t;
		const u8_t	*dataptr;
		const u8_t	*last_byte;

		dataptr = data;
    af9c:	68bb      	ldr	r3, [r7, #8]
    af9e:	61bb      	str	r3, [r7, #24]
		last_byte = data + len - 1;
    afa0:	88fb      	ldrh	r3, [r7, #6]
    afa2:	f103 33ff 	add.w	r3, r3, #4294967295
    afa6:	68ba      	ldr	r2, [r7, #8]
    afa8:	4413      	add	r3, r2
    afaa:	61fb      	str	r3, [r7, #28]

		while( dataptr < last_byte )
    afac:	e01a      	b.n	afe4 <chksum+0x58>
		{
			/* At least two more bytes */
			t = ( dataptr[ 0 ] << 8 ) + dataptr[ 1 ];
    afae:	69bb      	ldr	r3, [r7, #24]
    afb0:	781b      	ldrb	r3, [r3, #0]
    afb2:	ea4f 2303 	mov.w	r3, r3, lsl #8
    afb6:	b29a      	uxth	r2, r3
    afb8:	69bb      	ldr	r3, [r7, #24]
    afba:	f103 0301 	add.w	r3, r3, #1
    afbe:	781b      	ldrb	r3, [r3, #0]
    afc0:	4413      	add	r3, r2
    afc2:	82fb      	strh	r3, [r7, #22]
			sum += t;
    afc4:	89fa      	ldrh	r2, [r7, #14]
    afc6:	8afb      	ldrh	r3, [r7, #22]
    afc8:	4413      	add	r3, r2
    afca:	81fb      	strh	r3, [r7, #14]
			if( sum < t )
    afcc:	89fa      	ldrh	r2, [r7, #14]
    afce:	8afb      	ldrh	r3, [r7, #22]
    afd0:	429a      	cmp	r2, r3
    afd2:	d203      	bcs.n	afdc <chksum+0x50>
			{
				sum++;	/* carry */
    afd4:	89fb      	ldrh	r3, [r7, #14]
    afd6:	f103 0301 	add.w	r3, r3, #1
    afda:	81fb      	strh	r3, [r7, #14]
			}

			dataptr += 2;
    afdc:	69bb      	ldr	r3, [r7, #24]
    afde:	f103 0302 	add.w	r3, r3, #2
    afe2:	61bb      	str	r3, [r7, #24]
		const u8_t	*last_byte;

		dataptr = data;
		last_byte = data + len - 1;

		while( dataptr < last_byte )
    afe4:	69ba      	ldr	r2, [r7, #24]
    afe6:	69fb      	ldr	r3, [r7, #28]
    afe8:	429a      	cmp	r2, r3
    afea:	d3e0      	bcc.n	afae <chksum+0x22>
			}

			dataptr += 2;
		}

		if( dataptr == last_byte )
    afec:	69ba      	ldr	r2, [r7, #24]
    afee:	69fb      	ldr	r3, [r7, #28]
    aff0:	429a      	cmp	r2, r3
    aff2:	d110      	bne.n	b016 <chksum+0x8a>
		{
			t = ( dataptr[ 0 ] << 8 ) + 0;
    aff4:	69bb      	ldr	r3, [r7, #24]
    aff6:	781b      	ldrb	r3, [r3, #0]
    aff8:	ea4f 2303 	mov.w	r3, r3, lsl #8
    affc:	82fb      	strh	r3, [r7, #22]
			sum += t;
    affe:	89fa      	ldrh	r2, [r7, #14]
    b000:	8afb      	ldrh	r3, [r7, #22]
    b002:	4413      	add	r3, r2
    b004:	81fb      	strh	r3, [r7, #14]
			if( sum < t )
    b006:	89fa      	ldrh	r2, [r7, #14]
    b008:	8afb      	ldrh	r3, [r7, #22]
    b00a:	429a      	cmp	r2, r3
    b00c:	d203      	bcs.n	b016 <chksum+0x8a>
			{
				sum++;	/* carry */
    b00e:	89fb      	ldrh	r3, [r7, #14]
    b010:	f103 0301 	add.w	r3, r3, #1
    b014:	81fb      	strh	r3, [r7, #14]
			}
		}

		/* Return sum in host byte order. */
		return sum;
    b016:	89fb      	ldrh	r3, [r7, #14]
	}
    b018:	4618      	mov	r0, r3
    b01a:	f107 0724 	add.w	r7, r7, #36	; 0x24
    b01e:	46bd      	mov	sp, r7
    b020:	bc80      	pop	{r7}
    b022:	4770      	bx	lr

0000b024 <uip_chksum>:
	/*---------------------------------------------------------------------------*/

	u16_t uip_chksum( u16_t *data, u16_t len )
	{
    b024:	b580      	push	{r7, lr}
    b026:	b082      	sub	sp, #8
    b028:	af00      	add	r7, sp, #0
    b02a:	6078      	str	r0, [r7, #4]
    b02c:	460b      	mov	r3, r1
    b02e:	807b      	strh	r3, [r7, #2]
		return htons( chksum( 0, ( u8_t * ) data, len ) );
    b030:	687a      	ldr	r2, [r7, #4]
    b032:	887b      	ldrh	r3, [r7, #2]
    b034:	f04f 0000 	mov.w	r0, #0
    b038:	4611      	mov	r1, r2
    b03a:	461a      	mov	r2, r3
    b03c:	f7ff ffa6 	bl	af8c <chksum>
    b040:	4603      	mov	r3, r0
    b042:	4618      	mov	r0, r3
    b044:	f002 fb88 	bl	d758 <htons>
    b048:	4603      	mov	r3, r0
	}
    b04a:	4618      	mov	r0, r3
    b04c:	f107 0708 	add.w	r7, r7, #8
    b050:	46bd      	mov	sp, r7
    b052:	bd80      	pop	{r7, pc}

0000b054 <uip_ipchksum>:
	/*---------------------------------------------------------------------------*/

	#ifndef UIP_ARCH_IPCHKSUM
		u16_t uip_ipchksum( void )
		{
    b054:	b580      	push	{r7, lr}
    b056:	b082      	sub	sp, #8
    b058:	af00      	add	r7, sp, #0
			u16_t	sum;

			sum = chksum( 0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN );
    b05a:	f240 63a4 	movw	r3, #1700	; 0x6a4
    b05e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b062:	681b      	ldr	r3, [r3, #0]
    b064:	f103 030e 	add.w	r3, r3, #14
    b068:	f04f 0000 	mov.w	r0, #0
    b06c:	4619      	mov	r1, r3
    b06e:	f04f 0214 	mov.w	r2, #20
    b072:	f7ff ff8b 	bl	af8c <chksum>
    b076:	4603      	mov	r3, r0
    b078:	80fb      	strh	r3, [r7, #6]

			//DEBUG_PRINTF( "uip_ipchksum: sum 0x%04x\n", sum );
			return( sum == 0 ) ? 0xffff : htons( sum );
    b07a:	88fb      	ldrh	r3, [r7, #6]
    b07c:	2b00      	cmp	r3, #0
    b07e:	d005      	beq.n	b08c <uip_ipchksum+0x38>
    b080:	88fb      	ldrh	r3, [r7, #6]
    b082:	4618      	mov	r0, r3
    b084:	f002 fb68 	bl	d758 <htons>
    b088:	4603      	mov	r3, r0
    b08a:	e001      	b.n	b090 <uip_ipchksum+0x3c>
    b08c:	f64f 73ff 	movw	r3, #65535	; 0xffff
		}
    b090:	4618      	mov	r0, r3
    b092:	f107 0708 	add.w	r7, r7, #8
    b096:	46bd      	mov	sp, r7
    b098:	bd80      	pop	{r7, pc}
    b09a:	bf00      	nop

0000b09c <upper_layer_chksum>:
	#endif
	/*---------------------------------------------------------------------------*/

	static u16_t upper_layer_chksum( u8_t proto )
	{
    b09c:	b580      	push	{r7, lr}
    b09e:	b084      	sub	sp, #16
    b0a0:	af00      	add	r7, sp, #0
    b0a2:	4603      	mov	r3, r0
    b0a4:	71fb      	strb	r3, [r7, #7]
		u16_t	sum;

		#if UIP_CONF_IPV6
			upper_layer_len = ( ((u16_t) (BUF->len[ 0 ]) << 8) + BUF->len[ 1 ] );
		#else /* UIP_CONF_IPV6 */
			upper_layer_len = ( ((u16_t) (BUF->len[ 0 ]) << 8) + BUF->len[ 1 ] ) - UIP_IPH_LEN;
    b0a6:	f240 63a4 	movw	r3, #1700	; 0x6a4
    b0aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b0ae:	681b      	ldr	r3, [r3, #0]
    b0b0:	f103 030e 	add.w	r3, r3, #14
    b0b4:	789b      	ldrb	r3, [r3, #2]
    b0b6:	ea4f 2303 	mov.w	r3, r3, lsl #8
    b0ba:	b29a      	uxth	r2, r3
    b0bc:	f240 63a4 	movw	r3, #1700	; 0x6a4
    b0c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b0c4:	681b      	ldr	r3, [r3, #0]
    b0c6:	f103 030e 	add.w	r3, r3, #14
    b0ca:	78db      	ldrb	r3, [r3, #3]
    b0cc:	4413      	add	r3, r2
    b0ce:	b29b      	uxth	r3, r3
    b0d0:	f1a3 0314 	sub.w	r3, r3, #20
    b0d4:	81bb      	strh	r3, [r7, #12]
		#endif /* UIP_CONF_IPV6 */

		/* First sum pseudoheader. */

		/* IP protocol and length fields. This addition cannot carry. */
		sum = upper_layer_len + proto;
    b0d6:	79fa      	ldrb	r2, [r7, #7]
    b0d8:	89bb      	ldrh	r3, [r7, #12]
    b0da:	4413      	add	r3, r2
    b0dc:	81fb      	strh	r3, [r7, #14]

		/* Sum IP source and destination addresses. */
		sum = chksum( sum, ( u8_t * ) &BUF->srcipaddr, 2 * sizeof(uip_ipaddr_t) );
    b0de:	f240 63a4 	movw	r3, #1700	; 0x6a4
    b0e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b0e6:	681b      	ldr	r3, [r3, #0]
    b0e8:	f103 030e 	add.w	r3, r3, #14
    b0ec:	f103 030c 	add.w	r3, r3, #12
    b0f0:	89fa      	ldrh	r2, [r7, #14]
    b0f2:	4610      	mov	r0, r2
    b0f4:	4619      	mov	r1, r3
    b0f6:	f04f 0208 	mov.w	r2, #8
    b0fa:	f7ff ff47 	bl	af8c <chksum>
    b0fe:	4603      	mov	r3, r0
    b100:	81fb      	strh	r3, [r7, #14]

		/* Sum TCP header and data. */
		sum = chksum( sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN], upper_layer_len );
    b102:	f240 63a4 	movw	r3, #1700	; 0x6a4
    b106:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b10a:	681b      	ldr	r3, [r3, #0]
    b10c:	f103 0222 	add.w	r2, r3, #34	; 0x22
    b110:	89f9      	ldrh	r1, [r7, #14]
    b112:	89bb      	ldrh	r3, [r7, #12]
    b114:	4608      	mov	r0, r1
    b116:	4611      	mov	r1, r2
    b118:	461a      	mov	r2, r3
    b11a:	f7ff ff37 	bl	af8c <chksum>
    b11e:	4603      	mov	r3, r0
    b120:	81fb      	strh	r3, [r7, #14]

		return( sum == 0 ) ? 0xffff : htons( sum );
    b122:	89fb      	ldrh	r3, [r7, #14]
    b124:	2b00      	cmp	r3, #0
    b126:	d005      	beq.n	b134 <upper_layer_chksum+0x98>
    b128:	89fb      	ldrh	r3, [r7, #14]
    b12a:	4618      	mov	r0, r3
    b12c:	f002 fb14 	bl	d758 <htons>
    b130:	4603      	mov	r3, r0
    b132:	e001      	b.n	b138 <upper_layer_chksum+0x9c>
    b134:	f64f 73ff 	movw	r3, #65535	; 0xffff
	}
    b138:	4618      	mov	r0, r3
    b13a:	f107 0710 	add.w	r7, r7, #16
    b13e:	46bd      	mov	sp, r7
    b140:	bd80      	pop	{r7, pc}
    b142:	bf00      	nop

0000b144 <uip_tcpchksum>:
		}
	#endif /* UIP_CONF_IPV6 */
	/*---------------------------------------------------------------------------*/

	u16_t uip_tcpchksum( void )
	{
    b144:	b580      	push	{r7, lr}
    b146:	af00      	add	r7, sp, #0
		return upper_layer_chksum( UIP_PROTO_TCP );
    b148:	f04f 0006 	mov.w	r0, #6
    b14c:	f7ff ffa6 	bl	b09c <upper_layer_chksum>
    b150:	4603      	mov	r3, r0
	}
    b152:	4618      	mov	r0, r3
    b154:	bd80      	pop	{r7, pc}
    b156:	bf00      	nop

0000b158 <uip_udpchksum>:
	/*---------------------------------------------------------------------------*/

	#if UIP_UDP_CHECKSUMS
		u16_t uip_udpchksum( void )
		{
    b158:	b580      	push	{r7, lr}
    b15a:	af00      	add	r7, sp, #0
			return upper_layer_chksum( UIP_PROTO_UDP );
    b15c:	f04f 0011 	mov.w	r0, #17
    b160:	f7ff ff9c 	bl	b09c <upper_layer_chksum>
    b164:	4603      	mov	r3, r0
		}
    b166:	4618      	mov	r0, r3
    b168:	bd80      	pop	{r7, pc}
    b16a:	bf00      	nop

0000b16c <uip_init>:

#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/

void uip_init( void )
{
    b16c:	b480      	push	{r7}
    b16e:	af00      	add	r7, sp, #0
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    b170:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b174:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b178:	f04f 0200 	mov.w	r2, #0
    b17c:	701a      	strb	r2, [r3, #0]
    b17e:	e01a      	b.n	b1b6 <uip_init+0x4a>
	{
		uip_listenports[ c ] = 0;
    b180:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b184:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b188:	781b      	ldrb	r3, [r3, #0]
    b18a:	461a      	mov	r2, r3
    b18c:	f64c 4320 	movw	r3, #52256	; 0xcc20
    b190:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b194:	f04f 0100 	mov.w	r1, #0
    b198:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/

void uip_init( void )
{
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    b19c:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b1a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b1a4:	781b      	ldrb	r3, [r3, #0]
    b1a6:	f103 0301 	add.w	r3, r3, #1
    b1aa:	b2da      	uxtb	r2, r3
    b1ac:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b1b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b1b4:	701a      	strb	r2, [r3, #0]
    b1b6:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b1ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b1be:	781b      	ldrb	r3, [r3, #0]
    b1c0:	2b27      	cmp	r3, #39	; 0x27
    b1c2:	d9dd      	bls.n	b180 <uip_init+0x14>
	{
		uip_listenports[ c ] = 0;
	}

	for( c = 0; c < UIP_CONNS; ++c )
    b1c4:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b1c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b1cc:	f04f 0200 	mov.w	r2, #0
    b1d0:	701a      	strb	r2, [r3, #0]
    b1d2:	e020      	b.n	b216 <uip_init+0xaa>
	{
		uip_conns[ c ].tcpstateflags = UIP_CLOSED;
    b1d4:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b1d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b1dc:	781b      	ldrb	r3, [r3, #0]
    b1de:	461a      	mov	r2, r3
    b1e0:	f64a 4340 	movw	r3, #44096	; 0xac40
    b1e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b1e8:	f04f 01cc 	mov.w	r1, #204	; 0xcc
    b1ec:	fb01 f202 	mul.w	r2, r1, r2
    b1f0:	4413      	add	r3, r2
    b1f2:	f103 0318 	add.w	r3, r3, #24
    b1f6:	f04f 0200 	mov.w	r2, #0
    b1fa:	705a      	strb	r2, [r3, #1]
	for( c = 0; c < UIP_LISTENPORTS; ++c )
	{
		uip_listenports[ c ] = 0;
	}

	for( c = 0; c < UIP_CONNS; ++c )
    b1fc:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b200:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b204:	781b      	ldrb	r3, [r3, #0]
    b206:	f103 0301 	add.w	r3, r3, #1
    b20a:	b2da      	uxtb	r2, r3
    b20c:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b210:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b214:	701a      	strb	r2, [r3, #0]
    b216:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b21a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b21e:	781b      	ldrb	r3, [r3, #0]
    b220:	2b27      	cmp	r3, #39	; 0x27
    b222:	d9d7      	bls.n	b1d4 <uip_init+0x68>
	{
		uip_conns[ c ].tcpstateflags = UIP_CLOSED;
	}

	#if UIP_ACTIVE_OPEN
		lastport = 1024;
    b224:	f642 738c 	movw	r3, #12172	; 0x2f8c
    b228:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b22c:	f44f 6280 	mov.w	r2, #1024	; 0x400
    b230:	801a      	strh	r2, [r3, #0]

	/* IPv4 initialization. */
	#if UIP_FIXEDADDR == 0
		/*  uip_hostaddr[ 0 ] = uip_hostaddr[ 1 ] = 0;*/
	#endif /* UIP_FIXEDADDR */
}
    b232:	46bd      	mov	sp, r7
    b234:	bc80      	pop	{r7}
    b236:	4770      	bx	lr

0000b238 <uip_connect>:
/*---------------------------------------------------------------------------*/

#if UIP_ACTIVE_OPEN
	struct uip_conn *uip_connect( uip_ipaddr_t *ripaddr, u16_t rport )
	{
    b238:	b5b0      	push	{r4, r5, r7, lr}
    b23a:	b082      	sub	sp, #8
    b23c:	af00      	add	r7, sp, #0
    b23e:	6078      	str	r0, [r7, #4]
    b240:	460b      	mov	r3, r1
    b242:	807b      	strh	r3, [r7, #2]
    b244:	e000      	b.n	b248 <uip_connect+0x10>
		for( c = 0; c < UIP_CONNS; ++c )
		{
			conn = &uip_conns[ c ];
			if( conn->tcpstateflags != UIP_CLOSED && conn->lport == htons(lastport) )
			{
				goto again;
    b246:	bf00      	nop
	{
		register struct uip_conn	*conn, *cconn;

		/* Find an unused local port. */
	again:
		++lastport;
    b248:	f642 738c 	movw	r3, #12172	; 0x2f8c
    b24c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b250:	881b      	ldrh	r3, [r3, #0]
    b252:	f103 0301 	add.w	r3, r3, #1
    b256:	b29a      	uxth	r2, r3
    b258:	f642 738c 	movw	r3, #12172	; 0x2f8c
    b25c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b260:	801a      	strh	r2, [r3, #0]

		if( lastport >= 32000 )
    b262:	f642 738c 	movw	r3, #12172	; 0x2f8c
    b266:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b26a:	881a      	ldrh	r2, [r3, #0]
    b26c:	f647 43ff 	movw	r3, #31999	; 0x7cff
    b270:	429a      	cmp	r2, r3
    b272:	d906      	bls.n	b282 <uip_connect+0x4a>
		{
			lastport = 4096;
    b274:	f642 738c 	movw	r3, #12172	; 0x2f8c
    b278:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b27c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    b280:	801a      	strh	r2, [r3, #0]
		}

		/* Check if this port is already in use, and if so try to find
		 another one. */
		for( c = 0; c < UIP_CONNS; ++c )
    b282:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b286:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b28a:	f04f 0200 	mov.w	r2, #0
    b28e:	701a      	strb	r2, [r3, #0]
    b290:	e02a      	b.n	b2e8 <uip_connect+0xb0>
		{
			conn = &uip_conns[ c ];
    b292:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b296:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b29a:	781b      	ldrb	r3, [r3, #0]
    b29c:	f04f 02cc 	mov.w	r2, #204	; 0xcc
    b2a0:	fb02 f203 	mul.w	r2, r2, r3
    b2a4:	f64a 4340 	movw	r3, #44096	; 0xac40
    b2a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b2ac:	eb02 0403 	add.w	r4, r2, r3
			if( conn->tcpstateflags != UIP_CLOSED && conn->lport == htons(lastport) )
    b2b0:	7e63      	ldrb	r3, [r4, #25]
    b2b2:	2b00      	cmp	r3, #0
    b2b4:	d00b      	beq.n	b2ce <uip_connect+0x96>
    b2b6:	88a4      	ldrh	r4, [r4, #4]
    b2b8:	f642 738c 	movw	r3, #12172	; 0x2f8c
    b2bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b2c0:	881b      	ldrh	r3, [r3, #0]
    b2c2:	4618      	mov	r0, r3
    b2c4:	f002 fa48 	bl	d758 <htons>
    b2c8:	4603      	mov	r3, r0
    b2ca:	429c      	cmp	r4, r3
    b2cc:	d0bb      	beq.n	b246 <uip_connect+0xe>
			lastport = 4096;
		}

		/* Check if this port is already in use, and if so try to find
		 another one. */
		for( c = 0; c < UIP_CONNS; ++c )
    b2ce:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b2d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b2d6:	781b      	ldrb	r3, [r3, #0]
    b2d8:	f103 0301 	add.w	r3, r3, #1
    b2dc:	b2da      	uxtb	r2, r3
    b2de:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b2e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b2e6:	701a      	strb	r2, [r3, #0]
    b2e8:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b2ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b2f0:	781b      	ldrb	r3, [r3, #0]
    b2f2:	2b27      	cmp	r3, #39	; 0x27
    b2f4:	d9cd      	bls.n	b292 <uip_connect+0x5a>
			{
				goto again;
			}
		}

		conn = 0;
    b2f6:	f04f 0400 	mov.w	r4, #0
		for( c = 0; c < UIP_CONNS; ++c )
    b2fa:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b2fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b302:	f04f 0200 	mov.w	r2, #0
    b306:	701a      	strb	r2, [r3, #0]
    b308:	e02a      	b.n	b360 <uip_connect+0x128>
		{
			cconn = &uip_conns[ c ];
    b30a:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b30e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b312:	781b      	ldrb	r3, [r3, #0]
    b314:	f04f 02cc 	mov.w	r2, #204	; 0xcc
    b318:	fb02 f203 	mul.w	r2, r2, r3
    b31c:	f64a 4340 	movw	r3, #44096	; 0xac40
    b320:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b324:	eb02 0503 	add.w	r5, r2, r3
			if( cconn->tcpstateflags == UIP_CLOSED )
    b328:	7e6b      	ldrb	r3, [r5, #25]
    b32a:	2b00      	cmp	r3, #0
    b32c:	d101      	bne.n	b332 <uip_connect+0xfa>
			{
				conn = cconn;
    b32e:	462c      	mov	r4, r5
				break;
    b330:	e01d      	b.n	b36e <uip_connect+0x136>
			}

			if( cconn->tcpstateflags == UIP_TIME_WAIT )
    b332:	7e6b      	ldrb	r3, [r5, #25]
    b334:	2b07      	cmp	r3, #7
    b336:	d106      	bne.n	b346 <uip_connect+0x10e>
			{
				if( conn == 0 || cconn->timer > conn->timer )
    b338:	2c00      	cmp	r4, #0
    b33a:	d003      	beq.n	b344 <uip_connect+0x10c>
    b33c:	7eaa      	ldrb	r2, [r5, #26]
    b33e:	7ea3      	ldrb	r3, [r4, #26]
    b340:	429a      	cmp	r2, r3
    b342:	d900      	bls.n	b346 <uip_connect+0x10e>
				{
					conn = cconn;
    b344:	462c      	mov	r4, r5
				goto again;
			}
		}

		conn = 0;
		for( c = 0; c < UIP_CONNS; ++c )
    b346:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b34a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b34e:	781b      	ldrb	r3, [r3, #0]
    b350:	f103 0301 	add.w	r3, r3, #1
    b354:	b2da      	uxtb	r2, r3
    b356:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b35a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b35e:	701a      	strb	r2, [r3, #0]
    b360:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b364:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b368:	781b      	ldrb	r3, [r3, #0]
    b36a:	2b27      	cmp	r3, #39	; 0x27
    b36c:	d9cd      	bls.n	b30a <uip_connect+0xd2>
					conn = cconn;
				}
			}
		}

		if( conn == 0 )
    b36e:	2c00      	cmp	r4, #0
    b370:	d102      	bne.n	b378 <uip_connect+0x140>
		{
			return 0;
    b372:	f04f 0300 	mov.w	r3, #0
    b376:	e04a      	b.n	b40e <uip_connect+0x1d6>
		}

		conn->tcpstateflags = UIP_SYN_SENT;
    b378:	f04f 0302 	mov.w	r3, #2
    b37c:	7663      	strb	r3, [r4, #25]

		conn->snd_nxt[ 0 ] = iss[ 0 ];
    b37e:	f642 7388 	movw	r3, #12168	; 0x2f88
    b382:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b386:	781b      	ldrb	r3, [r3, #0]
    b388:	7323      	strb	r3, [r4, #12]
		conn->snd_nxt[ 1 ] = iss[ 1 ];
    b38a:	f642 7388 	movw	r3, #12168	; 0x2f88
    b38e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b392:	785b      	ldrb	r3, [r3, #1]
    b394:	7363      	strb	r3, [r4, #13]
		conn->snd_nxt[ 2 ] = iss[ 2 ];
    b396:	f642 7388 	movw	r3, #12168	; 0x2f88
    b39a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b39e:	789b      	ldrb	r3, [r3, #2]
    b3a0:	73a3      	strb	r3, [r4, #14]
		conn->snd_nxt[ 3 ] = iss[ 3 ];
    b3a2:	f642 7388 	movw	r3, #12168	; 0x2f88
    b3a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b3aa:	78db      	ldrb	r3, [r3, #3]
    b3ac:	73e3      	strb	r3, [r4, #15]

		conn->initialmss = conn->mss = UIP_TCP_MSS;
    b3ae:	f240 5392 	movw	r3, #1426	; 0x592
    b3b2:	8263      	strh	r3, [r4, #18]
    b3b4:	8a63      	ldrh	r3, [r4, #18]
    b3b6:	82a3      	strh	r3, [r4, #20]

		conn->len = 1;		/* TCP length of the SYN is one. */
    b3b8:	f04f 0301 	mov.w	r3, #1
    b3bc:	8223      	strh	r3, [r4, #16]
		conn->nrtx = 0;
    b3be:	f04f 0300 	mov.w	r3, #0
    b3c2:	76e3      	strb	r3, [r4, #27]
		conn->timer = 1;	/* Send the SYN next time around. */
    b3c4:	f04f 0301 	mov.w	r3, #1
    b3c8:	76a3      	strb	r3, [r4, #26]
		conn->rto = UIP_RTO;
    b3ca:	f04f 0303 	mov.w	r3, #3
    b3ce:	7623      	strb	r3, [r4, #24]
		conn->sa = 0;
    b3d0:	f04f 0300 	mov.w	r3, #0
    b3d4:	75a3      	strb	r3, [r4, #22]
		conn->sv = 16;		/* Initial value of the RTT variance. */
    b3d6:	f04f 0310 	mov.w	r3, #16
    b3da:	75e3      	strb	r3, [r4, #23]
		conn->lport = htons( lastport );
    b3dc:	f642 738c 	movw	r3, #12172	; 0x2f8c
    b3e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b3e4:	881b      	ldrh	r3, [r3, #0]
    b3e6:	4618      	mov	r0, r3
    b3e8:	f002 f9b6 	bl	d758 <htons>
    b3ec:	4603      	mov	r3, r0
    b3ee:	80a3      	strh	r3, [r4, #4]
		conn->rport = rport;
    b3f0:	887b      	ldrh	r3, [r7, #2]
    b3f2:	80e3      	strh	r3, [r4, #6]
		uip_ipaddr_copy( &conn->ripaddr, ripaddr );
    b3f4:	687b      	ldr	r3, [r7, #4]
    b3f6:	781b      	ldrb	r3, [r3, #0]
    b3f8:	7023      	strb	r3, [r4, #0]
    b3fa:	687b      	ldr	r3, [r7, #4]
    b3fc:	785b      	ldrb	r3, [r3, #1]
    b3fe:	7063      	strb	r3, [r4, #1]
    b400:	687b      	ldr	r3, [r7, #4]
    b402:	789b      	ldrb	r3, [r3, #2]
    b404:	70a3      	strb	r3, [r4, #2]
    b406:	687b      	ldr	r3, [r7, #4]
    b408:	78db      	ldrb	r3, [r3, #3]
    b40a:	70e3      	strb	r3, [r4, #3]

		return conn;
    b40c:	4623      	mov	r3, r4
	}
    b40e:	4618      	mov	r0, r3
    b410:	f107 0708 	add.w	r7, r7, #8
    b414:	46bd      	mov	sp, r7
    b416:	bdb0      	pop	{r4, r5, r7, pc}

0000b418 <uip_unlisten>:
	}
/*---------------------------------------------------------------------------*/
#endif /* UIP_UDP */

void uip_unlisten( u16_t port )
{
    b418:	b480      	push	{r7}
    b41a:	b083      	sub	sp, #12
    b41c:	af00      	add	r7, sp, #0
    b41e:	4603      	mov	r3, r0
    b420:	80fb      	strh	r3, [r7, #6]
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    b422:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b426:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b42a:	f04f 0200 	mov.w	r2, #0
    b42e:	701a      	strb	r2, [r3, #0]
    b430:	e02a      	b.n	b488 <uip_unlisten+0x70>
	{
		if( uip_listenports[ c ] == port )
    b432:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b436:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b43a:	781b      	ldrb	r3, [r3, #0]
    b43c:	461a      	mov	r2, r3
    b43e:	f64c 4320 	movw	r3, #52256	; 0xcc20
    b442:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b446:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    b44a:	88fa      	ldrh	r2, [r7, #6]
    b44c:	429a      	cmp	r2, r3
    b44e:	d10e      	bne.n	b46e <uip_unlisten+0x56>
		{
			uip_listenports[ c ] = 0;
    b450:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b454:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b458:	781b      	ldrb	r3, [r3, #0]
    b45a:	461a      	mov	r2, r3
    b45c:	f64c 4320 	movw	r3, #52256	; 0xcc20
    b460:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b464:	f04f 0100 	mov.w	r1, #0
    b468:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
			return;
    b46c:	e013      	b.n	b496 <uip_unlisten+0x7e>
/*---------------------------------------------------------------------------*/
#endif /* UIP_UDP */

void uip_unlisten( u16_t port )
{
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    b46e:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b472:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b476:	781b      	ldrb	r3, [r3, #0]
    b478:	f103 0301 	add.w	r3, r3, #1
    b47c:	b2da      	uxtb	r2, r3
    b47e:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b482:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b486:	701a      	strb	r2, [r3, #0]
    b488:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b48c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b490:	781b      	ldrb	r3, [r3, #0]
    b492:	2b27      	cmp	r3, #39	; 0x27
    b494:	d9cd      	bls.n	b432 <uip_unlisten+0x1a>
		{
			uip_listenports[ c ] = 0;
			return;
		}
	}
}
    b496:	f107 070c 	add.w	r7, r7, #12
    b49a:	46bd      	mov	sp, r7
    b49c:	bc80      	pop	{r7}
    b49e:	4770      	bx	lr

0000b4a0 <uip_listen>:
/*---------------------------------------------------------------------------*/

void uip_listen( u16_t port )
{
    b4a0:	b480      	push	{r7}
    b4a2:	b083      	sub	sp, #12
    b4a4:	af00      	add	r7, sp, #0
    b4a6:	4603      	mov	r3, r0
    b4a8:	80fb      	strh	r3, [r7, #6]
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    b4aa:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b4ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b4b2:	f04f 0200 	mov.w	r2, #0
    b4b6:	701a      	strb	r2, [r3, #0]
    b4b8:	e028      	b.n	b50c <uip_listen+0x6c>
	{
		if( uip_listenports[ c ] == 0 )
    b4ba:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b4be:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b4c2:	781b      	ldrb	r3, [r3, #0]
    b4c4:	461a      	mov	r2, r3
    b4c6:	f64c 4320 	movw	r3, #52256	; 0xcc20
    b4ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b4ce:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    b4d2:	2b00      	cmp	r3, #0
    b4d4:	d10d      	bne.n	b4f2 <uip_listen+0x52>
		{
			uip_listenports[ c ] = port;
    b4d6:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b4da:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b4de:	781b      	ldrb	r3, [r3, #0]
    b4e0:	461a      	mov	r2, r3
    b4e2:	f64c 4320 	movw	r3, #52256	; 0xcc20
    b4e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b4ea:	88f9      	ldrh	r1, [r7, #6]
    b4ec:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
			return;
    b4f0:	e013      	b.n	b51a <uip_listen+0x7a>
}
/*---------------------------------------------------------------------------*/

void uip_listen( u16_t port )
{
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    b4f2:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b4f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b4fa:	781b      	ldrb	r3, [r3, #0]
    b4fc:	f103 0301 	add.w	r3, r3, #1
    b500:	b2da      	uxtb	r2, r3
    b502:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b506:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b50a:	701a      	strb	r2, [r3, #0]
    b50c:	f642 738e 	movw	r3, #12174	; 0x2f8e
    b510:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b514:	781b      	ldrb	r3, [r3, #0]
    b516:	2b27      	cmp	r3, #39	; 0x27
    b518:	d9cf      	bls.n	b4ba <uip_listen+0x1a>
		{
			uip_listenports[ c ] = port;
			return;
		}
	}
}
    b51a:	f107 070c 	add.w	r7, r7, #12
    b51e:	46bd      	mov	sp, r7
    b520:	bc80      	pop	{r7}
    b522:	4770      	bx	lr

0000b524 <uip_add_rcv_nxt>:
/*---------------------------------------------------------------------------*/
#endif /* UIP_REASSEMBLY */


static void uip_add_rcv_nxt( u16_t n )
{
    b524:	b580      	push	{r7, lr}
    b526:	b082      	sub	sp, #8
    b528:	af00      	add	r7, sp, #0
    b52a:	4603      	mov	r3, r0
    b52c:	80fb      	strh	r3, [r7, #6]
	uip_add32( uip_conn->rcv_nxt, n );
    b52e:	f64a 433c 	movw	r3, #44092	; 0xac3c
    b532:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b536:	681b      	ldr	r3, [r3, #0]
    b538:	f103 0208 	add.w	r2, r3, #8
    b53c:	88fb      	ldrh	r3, [r7, #6]
    b53e:	4610      	mov	r0, r2
    b540:	4619      	mov	r1, r3
    b542:	f7ff fc7d 	bl	ae40 <uip_add32>
	uip_conn->rcv_nxt[ 0 ] = uip_acc32[ 0 ];
    b546:	f64a 433c 	movw	r3, #44092	; 0xac3c
    b54a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b54e:	681a      	ldr	r2, [r3, #0]
    b550:	f64a 4330 	movw	r3, #44080	; 0xac30
    b554:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b558:	781b      	ldrb	r3, [r3, #0]
    b55a:	7213      	strb	r3, [r2, #8]
	uip_conn->rcv_nxt[ 1 ] = uip_acc32[ 1 ];
    b55c:	f64a 433c 	movw	r3, #44092	; 0xac3c
    b560:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b564:	681a      	ldr	r2, [r3, #0]
    b566:	f64a 4330 	movw	r3, #44080	; 0xac30
    b56a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b56e:	785b      	ldrb	r3, [r3, #1]
    b570:	7253      	strb	r3, [r2, #9]
	uip_conn->rcv_nxt[ 2 ] = uip_acc32[ 2 ];
    b572:	f64a 433c 	movw	r3, #44092	; 0xac3c
    b576:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b57a:	681a      	ldr	r2, [r3, #0]
    b57c:	f64a 4330 	movw	r3, #44080	; 0xac30
    b580:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b584:	789b      	ldrb	r3, [r3, #2]
    b586:	7293      	strb	r3, [r2, #10]
	uip_conn->rcv_nxt[ 3 ] = uip_acc32[ 3 ];
    b588:	f64a 433c 	movw	r3, #44092	; 0xac3c
    b58c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b590:	681a      	ldr	r2, [r3, #0]
    b592:	f64a 4330 	movw	r3, #44080	; 0xac30
    b596:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b59a:	78db      	ldrb	r3, [r3, #3]
    b59c:	72d3      	strb	r3, [r2, #11]
}
    b59e:	f107 0708 	add.w	r7, r7, #8
    b5a2:	46bd      	mov	sp, r7
    b5a4:	bd80      	pop	{r7, pc}
    b5a6:	bf00      	nop

0000b5a8 <uip_process>:
/*---------------------------------------------------------------------------*/

void uip_process( u8_t flag )
{
    b5a8:	b590      	push	{r4, r7, lr}
    b5aa:	b085      	sub	sp, #20
    b5ac:	af00      	add	r7, sp, #0
    b5ae:	4603      	mov	r3, r0
    b5b0:	71fb      	strb	r3, [r7, #7]
	register struct uip_conn	*uip_connr = uip_conn;
    b5b2:	f64a 433c 	movw	r3, #44092	; 0xac3c
    b5b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b5ba:	681c      	ldr	r4, [r3, #0]
		{
			goto udp_send;
		}
	#endif /* UIP_UDP */

	uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
    b5bc:	f240 63a4 	movw	r3, #1700	; 0x6a4
    b5c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b5c4:	681b      	ldr	r3, [r3, #0]
    b5c6:	f103 0236 	add.w	r2, r3, #54	; 0x36
    b5ca:	f64a 4338 	movw	r3, #44088	; 0xac38
    b5ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b5d2:	601a      	str	r2, [r3, #0]
    b5d4:	f64a 4338 	movw	r3, #44088	; 0xac38
    b5d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b5dc:	681a      	ldr	r2, [r3, #0]
    b5de:	f64a 432c 	movw	r3, #44076	; 0xac2c
    b5e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b5e6:	601a      	str	r2, [r3, #0]

	/* Check if we were invoked because of a poll request for a
	 particular connection. */
	if( flag == UIP_POLL_REQUEST )
    b5e8:	79fb      	ldrb	r3, [r7, #7]
    b5ea:	2b03      	cmp	r3, #3
    b5ec:	d114      	bne.n	b618 <uip_process+0x70>
	{
		if( (uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED && !uip_outstanding(uip_connr) )
    b5ee:	7e63      	ldrb	r3, [r4, #25]
    b5f0:	f003 030f 	and.w	r3, r3, #15
    b5f4:	2b03      	cmp	r3, #3
    b5f6:	f042 807c 	bne.w	d6f2 <uip_process+0x214a>
    b5fa:	8a23      	ldrh	r3, [r4, #16]
    b5fc:	2b00      	cmp	r3, #0
    b5fe:	f042 807a 	bne.w	d6f6 <uip_process+0x214e>
		{
			uip_flags = UIP_POLL;
    b602:	f64a 4334 	movw	r3, #44084	; 0xac34
    b606:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b60a:	f04f 0208 	mov.w	r2, #8
    b60e:	701a      	strb	r2, [r3, #0]
			UIP_APPCALL();
    b610:	f003 fcd0 	bl	efb4 <httpd_appcall>
			goto appsend;
    b614:	f001 bcbc 	b.w	cf90 <uip_process+0x19e8>

		goto drop;

		/* Check if we were invoked because of the perodic timer fireing. */
	}
	else if( flag == UIP_TIMER )
    b618:	79fb      	ldrb	r3, [r7, #7]
    b61a:	2b02      	cmp	r3, #2
    b61c:	f040 8109 	bne.w	b832 <uip_process+0x28a>
				--uip_reasstmr;
			}
		#endif /* UIP_REASSEMBLY */

		/* Increase the initial sequence number. */
		if( ++iss[ 3 ] == 0 )
    b620:	f642 7388 	movw	r3, #12168	; 0x2f88
    b624:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b628:	78db      	ldrb	r3, [r3, #3]
    b62a:	f103 0301 	add.w	r3, r3, #1
    b62e:	b2da      	uxtb	r2, r3
    b630:	f642 7388 	movw	r3, #12168	; 0x2f88
    b634:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b638:	70da      	strb	r2, [r3, #3]
    b63a:	f642 7388 	movw	r3, #12168	; 0x2f88
    b63e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b642:	78db      	ldrb	r3, [r3, #3]
    b644:	2b00      	cmp	r3, #0
    b646:	d134      	bne.n	b6b2 <uip_process+0x10a>
		{
			if( ++iss[ 2 ] == 0 )
    b648:	f642 7388 	movw	r3, #12168	; 0x2f88
    b64c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b650:	789b      	ldrb	r3, [r3, #2]
    b652:	f103 0301 	add.w	r3, r3, #1
    b656:	b2da      	uxtb	r2, r3
    b658:	f642 7388 	movw	r3, #12168	; 0x2f88
    b65c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b660:	709a      	strb	r2, [r3, #2]
    b662:	f642 7388 	movw	r3, #12168	; 0x2f88
    b666:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b66a:	789b      	ldrb	r3, [r3, #2]
    b66c:	2b00      	cmp	r3, #0
    b66e:	d120      	bne.n	b6b2 <uip_process+0x10a>
			{
				if( ++iss[ 1 ] == 0 )
    b670:	f642 7388 	movw	r3, #12168	; 0x2f88
    b674:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b678:	785b      	ldrb	r3, [r3, #1]
    b67a:	f103 0301 	add.w	r3, r3, #1
    b67e:	b2da      	uxtb	r2, r3
    b680:	f642 7388 	movw	r3, #12168	; 0x2f88
    b684:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b688:	705a      	strb	r2, [r3, #1]
    b68a:	f642 7388 	movw	r3, #12168	; 0x2f88
    b68e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b692:	785b      	ldrb	r3, [r3, #1]
    b694:	2b00      	cmp	r3, #0
    b696:	d10c      	bne.n	b6b2 <uip_process+0x10a>
				{
					++iss[ 0 ];
    b698:	f642 7388 	movw	r3, #12168	; 0x2f88
    b69c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b6a0:	781b      	ldrb	r3, [r3, #0]
    b6a2:	f103 0301 	add.w	r3, r3, #1
    b6a6:	b2da      	uxtb	r2, r3
    b6a8:	f642 7388 	movw	r3, #12168	; 0x2f88
    b6ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b6b0:	701a      	strb	r2, [r3, #0]
				}
			}
		}

		/* Reset the length variables. */
		uip_len = 0;
    b6b2:	f64a 4328 	movw	r3, #44072	; 0xac28
    b6b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b6ba:	f04f 0200 	mov.w	r2, #0
    b6be:	801a      	strh	r2, [r3, #0]
		uip_slen = 0;
    b6c0:	f64c 43b4 	movw	r3, #52404	; 0xccb4
    b6c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b6c8:	f04f 0200 	mov.w	r2, #0
    b6cc:	801a      	strh	r2, [r3, #0]

		/* Check if the connection is in a state in which we simply wait
		for the connection to time out. If so, we increase the
		connection's timer and remove the connection if it times
		out. */
		if( uip_connr->tcpstateflags == UIP_TIME_WAIT || uip_connr->tcpstateflags == UIP_FIN_WAIT_2 )
    b6ce:	7e63      	ldrb	r3, [r4, #25]
    b6d0:	2b07      	cmp	r3, #7
    b6d2:	d002      	beq.n	b6da <uip_process+0x132>
    b6d4:	7e63      	ldrb	r3, [r4, #25]
    b6d6:	2b05      	cmp	r3, #5
    b6d8:	d10d      	bne.n	b6f6 <uip_process+0x14e>
		{
			++( uip_connr->timer );
    b6da:	7ea3      	ldrb	r3, [r4, #26]
    b6dc:	f103 0301 	add.w	r3, r3, #1
    b6e0:	b2db      	uxtb	r3, r3
    b6e2:	76a3      	strb	r3, [r4, #26]
			if( uip_connr->timer == UIP_TIME_WAIT_TIMEOUT )
    b6e4:	7ea3      	ldrb	r3, [r4, #26]
    b6e6:	2b78      	cmp	r3, #120	; 0x78
    b6e8:	d102      	bne.n	b6f0 <uip_process+0x148>
			{
				uip_connr->tcpstateflags = UIP_CLOSED;
    b6ea:	f04f 0300 	mov.w	r3, #0
    b6ee:	7663      	strb	r3, [r4, #25]

		/* Check if the connection is in a state in which we simply wait
		for the connection to time out. If so, we increase the
		connection's timer and remove the connection if it times
		out. */
		if( uip_connr->tcpstateflags == UIP_TIME_WAIT || uip_connr->tcpstateflags == UIP_FIN_WAIT_2 )
    b6f0:	bf00      	nop
				UIP_APPCALL();
				goto appsend;
			}
		}

		goto drop;
    b6f2:	f002 b81d 	b.w	d730 <uip_process+0x2188>
			if( uip_connr->timer == UIP_TIME_WAIT_TIMEOUT )
			{
				uip_connr->tcpstateflags = UIP_CLOSED;
			}
		}
		else if( uip_connr->tcpstateflags != UIP_CLOSED )
    b6f6:	7e63      	ldrb	r3, [r4, #25]
    b6f8:	2b00      	cmp	r3, #0
    b6fa:	f001 87fe 	beq.w	d6fa <uip_process+0x2152>
		{
			/* If the connection has outstanding data, we increase the
			connection's timer and see if it has reached the RTO value
			in which case we retransmit. */
			if( uip_outstanding(uip_connr) )
    b6fe:	8a23      	ldrh	r3, [r4, #16]
    b700:	2b00      	cmp	r3, #0
    b702:	f000 8085 	beq.w	b810 <uip_process+0x268>
			{
				if( uip_connr->timer-- == 0 )
    b706:	7ea3      	ldrb	r3, [r4, #26]
    b708:	2b00      	cmp	r3, #0
    b70a:	bf14      	ite	ne
    b70c:	2200      	movne	r2, #0
    b70e:	2201      	moveq	r2, #1
    b710:	b2d2      	uxtb	r2, r2
    b712:	f103 33ff 	add.w	r3, r3, #4294967295
    b716:	b2db      	uxtb	r3, r3
    b718:	76a3      	strb	r3, [r4, #26]
    b71a:	2a00      	cmp	r2, #0
    b71c:	f001 87ef 	beq.w	d6fe <uip_process+0x2156>
				{
					if
					(
						uip_connr->nrtx == UIP_MAXRTX ||
    b720:	7ee3      	ldrb	r3, [r4, #27]
			if( uip_outstanding(uip_connr) )
			{
				if( uip_connr->timer-- == 0 )
				{
					if
					(
    b722:	2b08      	cmp	r3, #8
    b724:	d008      	beq.n	b738 <uip_process+0x190>
						uip_connr->nrtx == UIP_MAXRTX ||
						(
							(uip_connr->tcpstateflags == UIP_SYN_SENT || uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
    b726:	7e63      	ldrb	r3, [r4, #25]
			if( uip_outstanding(uip_connr) )
			{
				if( uip_connr->timer-- == 0 )
				{
					if
					(
    b728:	2b02      	cmp	r3, #2
    b72a:	d002      	beq.n	b732 <uip_process+0x18a>
						uip_connr->nrtx == UIP_MAXRTX ||
						(
							(uip_connr->tcpstateflags == UIP_SYN_SENT || uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
    b72c:	7e63      	ldrb	r3, [r4, #25]
			if( uip_outstanding(uip_connr) )
			{
				if( uip_connr->timer-- == 0 )
				{
					if
					(
    b72e:	2b01      	cmp	r3, #1
    b730:	d11b      	bne.n	b76a <uip_process+0x1c2>
						uip_connr->nrtx == UIP_MAXRTX ||
						(
							(uip_connr->tcpstateflags == UIP_SYN_SENT || uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
							uip_connr->nrtx == UIP_MAXSYNRTX
    b732:	7ee3      	ldrb	r3, [r4, #27]
			if( uip_outstanding(uip_connr) )
			{
				if( uip_connr->timer-- == 0 )
				{
					if
					(
    b734:	2b05      	cmp	r3, #5
    b736:	d118      	bne.n	b76a <uip_process+0x1c2>
							(uip_connr->tcpstateflags == UIP_SYN_SENT || uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
							uip_connr->nrtx == UIP_MAXSYNRTX
						)
					)
					{
						uip_connr->tcpstateflags = UIP_CLOSED;
    b738:	f04f 0300 	mov.w	r3, #0
    b73c:	7663      	strb	r3, [r4, #25]

						/* We call UIP_APPCALL() with uip_flags set to
						UIP_TIMEDOUT to inform the application that the
						connection has timed out. */
						uip_flags = UIP_TIMEDOUT;
    b73e:	f64a 4334 	movw	r3, #44084	; 0xac34
    b742:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b746:	f06f 027f 	mvn.w	r2, #127	; 0x7f
    b74a:	701a      	strb	r2, [r3, #0]
						UIP_APPCALL();
    b74c:	f003 fc32 	bl	efb4 <httpd_appcall>

						/* We also send a reset packet to the remote host. */
						BUF->flags = TCP_RST | TCP_ACK;
    b750:	f240 63a4 	movw	r3, #1700	; 0x6a4
    b754:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b758:	681b      	ldr	r3, [r3, #0]
    b75a:	f103 030e 	add.w	r3, r3, #14
    b75e:	f04f 0214 	mov.w	r2, #20
    b762:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
						goto tcp_send_nodata;
    b766:	f001 bd9e 	b.w	d2a6 <uip_process+0x1cfe>
					}

					/* Exponential backoff. */
					uip_connr->timer = UIP_RTO << ( uip_connr->nrtx > 4 ? 4 : uip_connr->nrtx );
    b76a:	7ee3      	ldrb	r3, [r4, #27]
    b76c:	2b04      	cmp	r3, #4
    b76e:	d806      	bhi.n	b77e <uip_process+0x1d6>
    b770:	7ee3      	ldrb	r3, [r4, #27]
    b772:	f04f 0203 	mov.w	r2, #3
    b776:	fa02 f303 	lsl.w	r3, r2, r3
    b77a:	b2db      	uxtb	r3, r3
    b77c:	e001      	b.n	b782 <uip_process+0x1da>
    b77e:	f04f 0330 	mov.w	r3, #48	; 0x30
    b782:	76a3      	strb	r3, [r4, #26]
					++( uip_connr->nrtx );
    b784:	7ee3      	ldrb	r3, [r4, #27]
    b786:	f103 0301 	add.w	r3, r3, #1
    b78a:	b2db      	uxtb	r3, r3
    b78c:	76e3      	strb	r3, [r4, #27]
					depending on which state we are in. In ESTABLISHED, we
					call upon the application so that it may prepare the
					data for the retransmit. In SYN_RCVD, we resend the
					SYNACK that we sent earlier and in LAST_ACK we have to
					retransmit our FINACK. */
							UIP_STAT( ++uip_stat.tcp.rexmit );
    b78e:	f64c 4374 	movw	r3, #52340	; 0xcc74
    b792:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b796:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    b798:	f103 0301 	add.w	r3, r3, #1
    b79c:	b29a      	uxth	r2, r3
    b79e:	f64c 4374 	movw	r3, #52340	; 0xcc74
    b7a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b7a6:	855a      	strh	r2, [r3, #42]	; 0x2a
					switch( uip_connr->tcpstateflags & UIP_TS_MASK )
    b7a8:	7e63      	ldrb	r3, [r4, #25]
    b7aa:	f003 030f 	and.w	r3, r3, #15
    b7ae:	f103 33ff 	add.w	r3, r3, #4294967295
    b7b2:	2b07      	cmp	r3, #7
    b7b4:	f201 87a5 	bhi.w	d702 <uip_process+0x215a>
    b7b8:	a201      	add	r2, pc, #4	; (adr r2, b7c0 <uip_process+0x218>)
    b7ba:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    b7be:	bf00      	nop
    b7c0:	0000c697 	.word	0x0000c697
    b7c4:	0000b7e1 	.word	0x0000b7e1
    b7c8:	0000b7fb 	.word	0x0000b7fb
    b7cc:	0000cdf9 	.word	0x0000cdf9
    b7d0:	0000d703 	.word	0x0000d703
    b7d4:	0000cdf9 	.word	0x0000cdf9
    b7d8:	0000d703 	.word	0x0000d703
    b7dc:	0000cdf9 	.word	0x0000cdf9
							goto tcp_send_synack;

						#if UIP_ACTIVE_OPEN
							case UIP_SYN_SENT:
								/* In the SYN_SENT state, we retransmit out SYN. */
								BUF->flags = 0;
    b7e0:	f240 63a4 	movw	r3, #1700	; 0x6a4
    b7e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b7e8:	681b      	ldr	r3, [r3, #0]
    b7ea:	f103 030e 	add.w	r3, r3, #14
    b7ee:	f04f 0200 	mov.w	r2, #0
    b7f2:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
								goto tcp_send_syn;
    b7f6:	f000 bf5e 	b.w	c6b6 <uip_process+0x110e>
						case UIP_ESTABLISHED:
							/* In the ESTABLISHED state, we call upon the application
							to do the actual retransmit after which we jump into
							the code for sending out the packet (the apprexmit
							label). */
							uip_flags = UIP_REXMIT;
    b7fa:	f64a 4334 	movw	r3, #44084	; 0xac34
    b7fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b802:	f04f 0204 	mov.w	r2, #4
    b806:	701a      	strb	r2, [r3, #0]
							UIP_APPCALL();
    b808:	f003 fbd4 	bl	efb4 <httpd_appcall>
							goto apprexmit;
    b80c:	f001 bc39 	b.w	d082 <uip_process+0x1ada>
							/* In all these states we should retransmit a FINACK. */
							goto tcp_send_finack;
					}
				}
			}
			else if( (uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED )
    b810:	7e63      	ldrb	r3, [r4, #25]
    b812:	f003 030f 	and.w	r3, r3, #15
    b816:	2b03      	cmp	r3, #3
    b818:	f041 8775 	bne.w	d706 <uip_process+0x215e>
			{
				/* If there was no need for a retransmission, we poll the
				application for new data. */
				uip_flags = UIP_POLL;
    b81c:	f64a 4334 	movw	r3, #44084	; 0xac34
    b820:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b824:	f04f 0208 	mov.w	r2, #8
    b828:	701a      	strb	r2, [r3, #0]
				UIP_APPCALL();
    b82a:	f003 fbc3 	bl	efb4 <httpd_appcall>
				goto appsend;
    b82e:	f001 bbaf 	b.w	cf90 <uip_process+0x19e8>
			}
		}
	#endif

	/* This is where the input processing starts. */
	UIP_STAT( ++uip_stat.ip.recv );
    b832:	f64c 4374 	movw	r3, #52340	; 0xcc74
    b836:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b83a:	881b      	ldrh	r3, [r3, #0]
    b83c:	f103 0301 	add.w	r3, r3, #1
    b840:	b29a      	uxth	r2, r3
    b842:	f64c 4374 	movw	r3, #52340	; 0xcc74
    b846:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b84a:	801a      	strh	r2, [r3, #0]
			goto drop;
		}

	#else /* UIP_CONF_IPV6 */
		/* Check validity of the IP header. */
		if( BUF->vhl != 0x45 )
    b84c:	f240 63a4 	movw	r3, #1700	; 0x6a4
    b850:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b854:	681b      	ldr	r3, [r3, #0]
    b856:	f103 030e 	add.w	r3, r3, #14
    b85a:	781b      	ldrb	r3, [r3, #0]
    b85c:	2b45      	cmp	r3, #69	; 0x45
    b85e:	d01b      	beq.n	b898 <uip_process+0x2f0>
		{					/* IP version and header length. */
			UIP_STAT( ++uip_stat.ip.drop );
    b860:	f64c 4374 	movw	r3, #52340	; 0xcc74
    b864:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b868:	88db      	ldrh	r3, [r3, #6]
    b86a:	f103 0301 	add.w	r3, r3, #1
    b86e:	b29a      	uxth	r2, r3
    b870:	f64c 4374 	movw	r3, #52340	; 0xcc74
    b874:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b878:	80da      	strh	r2, [r3, #6]
			UIP_STAT( ++uip_stat.ip.vhlerr );
    b87a:	f64c 4374 	movw	r3, #52340	; 0xcc74
    b87e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b882:	891b      	ldrh	r3, [r3, #8]
    b884:	f103 0301 	add.w	r3, r3, #1
    b888:	b29a      	uxth	r2, r3
    b88a:	f64c 4374 	movw	r3, #52340	; 0xcc74
    b88e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b892:	811a      	strh	r2, [r3, #8]
			UIP_LOG( "ip: invalid version or header length." );
			goto drop;
    b894:	f001 bf4c 	b.w	d730 <uip_process+0x2188>
	uip_len is smaller the size reported in the IP header, we assume
	that the packet has been corrupted in transit. If the size of
	uip_len is larger than the size reported in the IP packet header,
	the packet has been padded and we set uip_len to the correct
	value.. */
	if( (BUF->len[ 0 ] << 8) + BUF->len[ 1 ] <= uip_len )
    b898:	f240 63a4 	movw	r3, #1700	; 0x6a4
    b89c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b8a0:	681b      	ldr	r3, [r3, #0]
    b8a2:	f103 030e 	add.w	r3, r3, #14
    b8a6:	789b      	ldrb	r3, [r3, #2]
    b8a8:	ea4f 2203 	mov.w	r2, r3, lsl #8
    b8ac:	f240 63a4 	movw	r3, #1700	; 0x6a4
    b8b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b8b4:	681b      	ldr	r3, [r3, #0]
    b8b6:	f103 030e 	add.w	r3, r3, #14
    b8ba:	78db      	ldrb	r3, [r3, #3]
    b8bc:	441a      	add	r2, r3
    b8be:	f64a 4328 	movw	r3, #44072	; 0xac28
    b8c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b8c6:	881b      	ldrh	r3, [r3, #0]
    b8c8:	429a      	cmp	r2, r3
    b8ca:	f301 871e 	bgt.w	d70a <uip_process+0x2162>
	{
		uip_len = ( BUF->len[ 0 ] << 8 ) + BUF->len[ 1 ];
    b8ce:	f240 63a4 	movw	r3, #1700	; 0x6a4
    b8d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b8d6:	681b      	ldr	r3, [r3, #0]
    b8d8:	f103 030e 	add.w	r3, r3, #14
    b8dc:	789b      	ldrb	r3, [r3, #2]
    b8de:	ea4f 2303 	mov.w	r3, r3, lsl #8
    b8e2:	b29a      	uxth	r2, r3
    b8e4:	f240 63a4 	movw	r3, #1700	; 0x6a4
    b8e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b8ec:	681b      	ldr	r3, [r3, #0]
    b8ee:	f103 030e 	add.w	r3, r3, #14
    b8f2:	78db      	ldrb	r3, [r3, #3]
    b8f4:	4413      	add	r3, r2
    b8f6:	b29a      	uxth	r2, r3
    b8f8:	f64a 4328 	movw	r3, #44072	; 0xac28
    b8fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b900:	801a      	strh	r2, [r3, #0]
		goto drop;
	}

	#if !UIP_CONF_IPV6
		/* Check the fragment flag. */
		if( (BUF->ipoffset[ 0 ] & 0x3f) != 0 || BUF->ipoffset[ 1 ] != 0 )
    b902:	f240 63a4 	movw	r3, #1700	; 0x6a4
    b906:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b90a:	681b      	ldr	r3, [r3, #0]
    b90c:	f103 030e 	add.w	r3, r3, #14
    b910:	799b      	ldrb	r3, [r3, #6]
    b912:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    b916:	2b00      	cmp	r3, #0
    b918:	d109      	bne.n	b92e <uip_process+0x386>
    b91a:	f240 63a4 	movw	r3, #1700	; 0x6a4
    b91e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b922:	681b      	ldr	r3, [r3, #0]
    b924:	f103 030e 	add.w	r3, r3, #14
    b928:	79db      	ldrb	r3, [r3, #7]
    b92a:	2b00      	cmp	r3, #0
    b92c:	d01b      	beq.n	b966 <uip_process+0x3be>
				if( uip_len == 0 )
				{
					goto drop;
				}
			#else /* UIP_REASSEMBLY */
				UIP_STAT( ++uip_stat.ip.drop );
    b92e:	f64c 4374 	movw	r3, #52340	; 0xcc74
    b932:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b936:	88db      	ldrh	r3, [r3, #6]
    b938:	f103 0301 	add.w	r3, r3, #1
    b93c:	b29a      	uxth	r2, r3
    b93e:	f64c 4374 	movw	r3, #52340	; 0xcc74
    b942:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b946:	80da      	strh	r2, [r3, #6]
				UIP_STAT( ++uip_stat.ip.fragerr );
    b948:	f64c 4374 	movw	r3, #52340	; 0xcc74
    b94c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b950:	89db      	ldrh	r3, [r3, #14]
    b952:	f103 0301 	add.w	r3, r3, #1
    b956:	b29a      	uxth	r2, r3
    b958:	f64c 4374 	movw	r3, #52340	; 0xcc74
    b95c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b960:	81da      	strh	r2, [r3, #14]
				UIP_LOG( "ip: fragment dropped." );
				goto drop;
    b962:	f001 bee5 	b.w	d730 <uip_process+0x2188>
			#endif /* UIP_REASSEMBLY */
		}
	#endif /* UIP_CONF_IPV6 */

	if( uip_ipaddr_cmp(&uip_hostaddr, &uip_all_zeroes_addr) )
    b966:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    b96a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b96e:	881a      	ldrh	r2, [r3, #0]
    b970:	f24b 73dc 	movw	r3, #47068	; 0xb7dc
    b974:	f2c0 0301 	movt	r3, #1
    b978:	881b      	ldrh	r3, [r3, #0]
    b97a:	429a      	cmp	r2, r3
    b97c:	d10b      	bne.n	b996 <uip_process+0x3ee>
    b97e:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    b982:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b986:	885a      	ldrh	r2, [r3, #2]
    b988:	f24b 73dc 	movw	r3, #47068	; 0xb7dc
    b98c:	f2c0 0301 	movt	r3, #1
    b990:	885b      	ldrh	r3, [r3, #2]
    b992:	429a      	cmp	r2, r3
    b994:	d038      	beq.n	ba08 <uip_process+0x460>
			}
		#endif /* UIP_BROADCAST */

		/* Check if the packet is destined for our IP address. */
		#if !UIP_CONF_IPV6
			if( !uip_ipaddr_cmp(&BUF->destipaddr, &uip_hostaddr) )
    b996:	f240 63a4 	movw	r3, #1700	; 0x6a4
    b99a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b99e:	681b      	ldr	r3, [r3, #0]
    b9a0:	f103 030e 	add.w	r3, r3, #14
    b9a4:	7c1a      	ldrb	r2, [r3, #16]
    b9a6:	7c5b      	ldrb	r3, [r3, #17]
    b9a8:	ea4f 2303 	mov.w	r3, r3, lsl #8
    b9ac:	ea43 0302 	orr.w	r3, r3, r2
    b9b0:	b29a      	uxth	r2, r3
    b9b2:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    b9b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b9ba:	881b      	ldrh	r3, [r3, #0]
    b9bc:	429a      	cmp	r2, r3
    b9be:	d114      	bne.n	b9ea <uip_process+0x442>
    b9c0:	f240 63a4 	movw	r3, #1700	; 0x6a4
    b9c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b9c8:	681b      	ldr	r3, [r3, #0]
    b9ca:	f103 030e 	add.w	r3, r3, #14
    b9ce:	7c9a      	ldrb	r2, [r3, #18]
    b9d0:	7cdb      	ldrb	r3, [r3, #19]
    b9d2:	ea4f 2303 	mov.w	r3, r3, lsl #8
    b9d6:	ea43 0302 	orr.w	r3, r3, r2
    b9da:	b29a      	uxth	r2, r3
    b9dc:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    b9e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b9e4:	885b      	ldrh	r3, [r3, #2]
    b9e6:	429a      	cmp	r2, r3
    b9e8:	d00e      	beq.n	ba08 <uip_process+0x460>
			{
				UIP_STAT( ++uip_stat.ip.drop );
    b9ea:	f64c 4374 	movw	r3, #52340	; 0xcc74
    b9ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b9f2:	88db      	ldrh	r3, [r3, #6]
    b9f4:	f103 0301 	add.w	r3, r3, #1
    b9f8:	b29a      	uxth	r2, r3
    b9fa:	f64c 4374 	movw	r3, #52340	; 0xcc74
    b9fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ba02:	80da      	strh	r2, [r3, #6]
				goto drop;
    ba04:	f001 be94 	b.w	d730 <uip_process+0x2188>
			}
		#endif /* UIP_CONF_IPV6 */
	}

	#if !UIP_CONF_IPV6
		if( uip_ipchksum() != 0xffff )
    ba08:	f7ff fb24 	bl	b054 <uip_ipchksum>
    ba0c:	4603      	mov	r3, r0
    ba0e:	461a      	mov	r2, r3
    ba10:	f64f 73ff 	movw	r3, #65535	; 0xffff
    ba14:	429a      	cmp	r2, r3
    ba16:	d01b      	beq.n	ba50 <uip_process+0x4a8>
		{
			/* Compute and check the IP header checksum. */
			UIP_STAT( ++uip_stat.ip.drop );
    ba18:	f64c 4374 	movw	r3, #52340	; 0xcc74
    ba1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ba20:	88db      	ldrh	r3, [r3, #6]
    ba22:	f103 0301 	add.w	r3, r3, #1
    ba26:	b29a      	uxth	r2, r3
    ba28:	f64c 4374 	movw	r3, #52340	; 0xcc74
    ba2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ba30:	80da      	strh	r2, [r3, #6]
			UIP_STAT( ++uip_stat.ip.chkerr );
    ba32:	f64c 4374 	movw	r3, #52340	; 0xcc74
    ba36:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ba3a:	8a1b      	ldrh	r3, [r3, #16]
    ba3c:	f103 0301 	add.w	r3, r3, #1
    ba40:	b29a      	uxth	r2, r3
    ba42:	f64c 4374 	movw	r3, #52340	; 0xcc74
    ba46:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ba4a:	821a      	strh	r2, [r3, #16]
			UIP_LOG( "ip: bad checksum." );
			goto drop;
    ba4c:	f001 be70 	b.w	d730 <uip_process+0x2188>
		}
	#endif /* UIP_CONF_IPV6 */

	if( BUF->proto == UIP_PROTO_TCP )
    ba50:	f240 63a4 	movw	r3, #1700	; 0x6a4
    ba54:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ba58:	681b      	ldr	r3, [r3, #0]
    ba5a:	f103 030e 	add.w	r3, r3, #14
    ba5e:	7a5b      	ldrb	r3, [r3, #9]
    ba60:	2b06      	cmp	r3, #6
    ba62:	f000 8151 	beq.w	bd08 <uip_process+0x760>
		}
	#endif /* UIP_UDP */

	#if !UIP_CONF_IPV6
		/* ICMPv4 processing code follows. */
		if( BUF->proto != UIP_PROTO_ICMP )
    ba66:	f240 63a4 	movw	r3, #1700	; 0x6a4
    ba6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ba6e:	681b      	ldr	r3, [r3, #0]
    ba70:	f103 030e 	add.w	r3, r3, #14
    ba74:	7a5b      	ldrb	r3, [r3, #9]
    ba76:	2b01      	cmp	r3, #1
    ba78:	d01b      	beq.n	bab2 <uip_process+0x50a>
		{
			/* We only allow ICMP packets from here. */
			UIP_STAT( ++uip_stat.ip.drop );
    ba7a:	f64c 4374 	movw	r3, #52340	; 0xcc74
    ba7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ba82:	88db      	ldrh	r3, [r3, #6]
    ba84:	f103 0301 	add.w	r3, r3, #1
    ba88:	b29a      	uxth	r2, r3
    ba8a:	f64c 4374 	movw	r3, #52340	; 0xcc74
    ba8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ba92:	80da      	strh	r2, [r3, #6]
			UIP_STAT( ++uip_stat.ip.protoerr );
    ba94:	f64c 4374 	movw	r3, #52340	; 0xcc74
    ba98:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ba9c:	8a5b      	ldrh	r3, [r3, #18]
    ba9e:	f103 0301 	add.w	r3, r3, #1
    baa2:	b29a      	uxth	r2, r3
    baa4:	f64c 4374 	movw	r3, #52340	; 0xcc74
    baa8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    baac:	825a      	strh	r2, [r3, #18]
			UIP_LOG( "ip: neither tcp nor icmp." );
			goto drop;
    baae:	f001 be3f 	b.w	d730 <uip_process+0x2188>

		#if UIP_PINGADDRCONF
			icmp_input :
		#endif /* UIP_PINGADDRCONF */

		UIP_STAT( ++uip_stat.icmp.recv );
    bab2:	f64c 4374 	movw	r3, #52340	; 0xcc74
    bab6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    baba:	8a9b      	ldrh	r3, [r3, #20]
    babc:	f103 0301 	add.w	r3, r3, #1
    bac0:	b29a      	uxth	r2, r3
    bac2:	f64c 4374 	movw	r3, #52340	; 0xcc74
    bac6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    baca:	829a      	strh	r2, [r3, #20]

		/* ICMP echo (i.e., ping) processing. This is simple, we only change
		 the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
		 checksum before we return the packet. */
		if( ICMPBUF->type != ICMP_ECHO )
    bacc:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bad0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bad4:	681b      	ldr	r3, [r3, #0]
    bad6:	f103 030e 	add.w	r3, r3, #14
    bada:	7d1b      	ldrb	r3, [r3, #20]
    badc:	2b08      	cmp	r3, #8
    bade:	d01b      	beq.n	bb18 <uip_process+0x570>
		{
			UIP_STAT( ++uip_stat.icmp.drop );
    bae0:	f64c 4374 	movw	r3, #52340	; 0xcc74
    bae4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bae8:	8b1b      	ldrh	r3, [r3, #24]
    baea:	f103 0301 	add.w	r3, r3, #1
    baee:	b29a      	uxth	r2, r3
    baf0:	f64c 4374 	movw	r3, #52340	; 0xcc74
    baf4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    baf8:	831a      	strh	r2, [r3, #24]
			UIP_STAT( ++uip_stat.icmp.typeerr );
    bafa:	f64c 4374 	movw	r3, #52340	; 0xcc74
    bafe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bb02:	8b5b      	ldrh	r3, [r3, #26]
    bb04:	f103 0301 	add.w	r3, r3, #1
    bb08:	b29a      	uxth	r2, r3
    bb0a:	f64c 4374 	movw	r3, #52340	; 0xcc74
    bb0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bb12:	835a      	strh	r2, [r3, #26]
			UIP_LOG( "icmp: not icmp echo." );
			goto drop;
    bb14:	f001 be0c 	b.w	d730 <uip_process+0x2188>
			{
				uip_hostaddr = BUF->destipaddr;
			}
		#endif /* UIP_PINGADDRCONF */

		ICMPBUF->type = ICMP_ECHO_REPLY;
    bb18:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bb1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bb20:	681b      	ldr	r3, [r3, #0]
    bb22:	f103 030e 	add.w	r3, r3, #14
    bb26:	f04f 0200 	mov.w	r2, #0
    bb2a:	751a      	strb	r2, [r3, #20]

		if( ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8)) )
    bb2c:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bb30:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bb34:	681b      	ldr	r3, [r3, #0]
    bb36:	f103 030e 	add.w	r3, r3, #14
    bb3a:	7d9a      	ldrb	r2, [r3, #22]
    bb3c:	7ddb      	ldrb	r3, [r3, #23]
    bb3e:	ea4f 2303 	mov.w	r3, r3, lsl #8
    bb42:	ea43 0302 	orr.w	r3, r3, r2
    bb46:	b29a      	uxth	r2, r3
    bb48:	f64f 73f6 	movw	r3, #65526	; 0xfff6
    bb4c:	429a      	cmp	r2, r3
    bb4e:	d927      	bls.n	bba0 <uip_process+0x5f8>
		{
			ICMPBUF->icmpchksum += HTONS( ICMP_ECHO << 8 ) + 1;
    bb50:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bb54:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bb58:	681b      	ldr	r3, [r3, #0]
    bb5a:	f103 020e 	add.w	r2, r3, #14
    bb5e:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bb62:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bb66:	681b      	ldr	r3, [r3, #0]
    bb68:	f103 030e 	add.w	r3, r3, #14
    bb6c:	7d99      	ldrb	r1, [r3, #22]
    bb6e:	7ddb      	ldrb	r3, [r3, #23]
    bb70:	ea4f 2303 	mov.w	r3, r3, lsl #8
    bb74:	ea43 0301 	orr.w	r3, r3, r1
    bb78:	b29b      	uxth	r3, r3
    bb7a:	f103 0309 	add.w	r3, r3, #9
    bb7e:	b29b      	uxth	r3, r3
    bb80:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    bb84:	f04f 0000 	mov.w	r0, #0
    bb88:	ea40 0101 	orr.w	r1, r0, r1
    bb8c:	7591      	strb	r1, [r2, #22]
    bb8e:	ea4f 2313 	mov.w	r3, r3, lsr #8
    bb92:	b29b      	uxth	r3, r3
    bb94:	f04f 0100 	mov.w	r1, #0
    bb98:	ea41 0303 	orr.w	r3, r1, r3
    bb9c:	75d3      	strb	r3, [r2, #23]
    bb9e:	e026      	b.n	bbee <uip_process+0x646>
		}
		else
		{
			ICMPBUF->icmpchksum += HTONS( ICMP_ECHO << 8 );
    bba0:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bba4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bba8:	681b      	ldr	r3, [r3, #0]
    bbaa:	f103 020e 	add.w	r2, r3, #14
    bbae:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bbb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bbb6:	681b      	ldr	r3, [r3, #0]
    bbb8:	f103 030e 	add.w	r3, r3, #14
    bbbc:	7d99      	ldrb	r1, [r3, #22]
    bbbe:	7ddb      	ldrb	r3, [r3, #23]
    bbc0:	ea4f 2303 	mov.w	r3, r3, lsl #8
    bbc4:	ea43 0301 	orr.w	r3, r3, r1
    bbc8:	b29b      	uxth	r3, r3
    bbca:	f103 0308 	add.w	r3, r3, #8
    bbce:	b29b      	uxth	r3, r3
    bbd0:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    bbd4:	f04f 0000 	mov.w	r0, #0
    bbd8:	ea40 0101 	orr.w	r1, r0, r1
    bbdc:	7591      	strb	r1, [r2, #22]
    bbde:	ea4f 2313 	mov.w	r3, r3, lsr #8
    bbe2:	b29b      	uxth	r3, r3
    bbe4:	f04f 0100 	mov.w	r1, #0
    bbe8:	ea41 0303 	orr.w	r3, r1, r3
    bbec:	75d3      	strb	r3, [r2, #23]
		}

		/* Swap IP addresses. */
		uip_ipaddr_copy( &BUF->destipaddr, &BUF->srcipaddr );
    bbee:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bbf2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bbf6:	681b      	ldr	r3, [r3, #0]
    bbf8:	f103 020e 	add.w	r2, r3, #14
    bbfc:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bc00:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bc04:	681b      	ldr	r3, [r3, #0]
    bc06:	f103 030e 	add.w	r3, r3, #14
    bc0a:	7b1b      	ldrb	r3, [r3, #12]
    bc0c:	7413      	strb	r3, [r2, #16]
    bc0e:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bc12:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bc16:	681b      	ldr	r3, [r3, #0]
    bc18:	f103 020e 	add.w	r2, r3, #14
    bc1c:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bc20:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bc24:	681b      	ldr	r3, [r3, #0]
    bc26:	f103 030e 	add.w	r3, r3, #14
    bc2a:	7b5b      	ldrb	r3, [r3, #13]
    bc2c:	7453      	strb	r3, [r2, #17]
    bc2e:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bc32:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bc36:	681b      	ldr	r3, [r3, #0]
    bc38:	f103 020e 	add.w	r2, r3, #14
    bc3c:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bc40:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bc44:	681b      	ldr	r3, [r3, #0]
    bc46:	f103 030e 	add.w	r3, r3, #14
    bc4a:	7b9b      	ldrb	r3, [r3, #14]
    bc4c:	7493      	strb	r3, [r2, #18]
    bc4e:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bc52:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bc56:	681b      	ldr	r3, [r3, #0]
    bc58:	f103 020e 	add.w	r2, r3, #14
    bc5c:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bc60:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bc64:	681b      	ldr	r3, [r3, #0]
    bc66:	f103 030e 	add.w	r3, r3, #14
    bc6a:	7bdb      	ldrb	r3, [r3, #15]
    bc6c:	74d3      	strb	r3, [r2, #19]
		uip_ipaddr_copy( &BUF->srcipaddr, &uip_hostaddr );
    bc6e:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bc72:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bc76:	681b      	ldr	r3, [r3, #0]
    bc78:	f103 020e 	add.w	r2, r3, #14
    bc7c:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    bc80:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bc84:	781b      	ldrb	r3, [r3, #0]
    bc86:	7313      	strb	r3, [r2, #12]
    bc88:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bc8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bc90:	681b      	ldr	r3, [r3, #0]
    bc92:	f103 020e 	add.w	r2, r3, #14
    bc96:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    bc9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bc9e:	785b      	ldrb	r3, [r3, #1]
    bca0:	7353      	strb	r3, [r2, #13]
    bca2:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bca6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bcaa:	681b      	ldr	r3, [r3, #0]
    bcac:	f103 020e 	add.w	r2, r3, #14
    bcb0:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    bcb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bcb8:	789b      	ldrb	r3, [r3, #2]
    bcba:	7393      	strb	r3, [r2, #14]
    bcbc:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bcc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bcc4:	681b      	ldr	r3, [r3, #0]
    bcc6:	f103 020e 	add.w	r2, r3, #14
    bcca:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    bcce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bcd2:	78db      	ldrb	r3, [r3, #3]
    bcd4:	73d3      	strb	r3, [r2, #15]

		UIP_STAT( ++uip_stat.icmp.sent );
    bcd6:	f64c 4374 	movw	r3, #52340	; 0xcc74
    bcda:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bcde:	8adb      	ldrh	r3, [r3, #22]
    bce0:	f103 0301 	add.w	r3, r3, #1
    bce4:	b29a      	uxth	r2, r3
    bce6:	f64c 4374 	movw	r3, #52340	; 0xcc74
    bcea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bcee:	82da      	strh	r2, [r3, #22]
		BUF->ttl = UIP_TTL;
    bcf0:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bcf4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bcf8:	681b      	ldr	r3, [r3, #0]
    bcfa:	f103 030e 	add.w	r3, r3, #14
    bcfe:	f04f 0240 	mov.w	r2, #64	; 0x40
    bd02:	721a      	strb	r2, [r3, #8]
		goto ip_send_nolen;
    bd04:	f001 bc57 	b.w	d5b6 <uip_process+0x200e>
	#endif /* UIP_CONF_IPV6 */

	if( BUF->proto == UIP_PROTO_TCP )
	{
		/* Check for TCP packet. If so, proceed with TCP input processing. */
		goto tcp_input;
    bd08:	bf00      	nop
	#endif /* UIP_UDP_CHECKSUMS */
		goto ip_send_nolen;
	#endif /* UIP_UDP */

	/* TCP input processing. */
	tcp_input : UIP_STAT( ++uip_stat.tcp.recv );
    bd0a:	f64c 4374 	movw	r3, #52340	; 0xcc74
    bd0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bd12:	8bdb      	ldrh	r3, [r3, #30]
    bd14:	f103 0301 	add.w	r3, r3, #1
    bd18:	b29a      	uxth	r2, r3
    bd1a:	f64c 4374 	movw	r3, #52340	; 0xcc74
    bd1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bd22:	83da      	strh	r2, [r3, #30]

	/* Start of TCP input header processing code. */
	if( uip_tcpchksum() != 0xffff )
    bd24:	f7ff fa0e 	bl	b144 <uip_tcpchksum>
    bd28:	4603      	mov	r3, r0
    bd2a:	461a      	mov	r2, r3
    bd2c:	f64f 73ff 	movw	r3, #65535	; 0xffff
    bd30:	429a      	cmp	r2, r3
    bd32:	d01b      	beq.n	bd6c <uip_process+0x7c4>
	{
		/* Compute and check the TCP checksum. */
		UIP_STAT( ++uip_stat.tcp.drop );
    bd34:	f64c 4374 	movw	r3, #52340	; 0xcc74
    bd38:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bd3c:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
    bd3e:	f103 0301 	add.w	r3, r3, #1
    bd42:	b29a      	uxth	r2, r3
    bd44:	f64c 4374 	movw	r3, #52340	; 0xcc74
    bd48:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bd4c:	845a      	strh	r2, [r3, #34]	; 0x22
		UIP_STAT( ++uip_stat.tcp.chkerr );
    bd4e:	f64c 4374 	movw	r3, #52340	; 0xcc74
    bd52:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bd56:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    bd58:	f103 0301 	add.w	r3, r3, #1
    bd5c:	b29a      	uxth	r2, r3
    bd5e:	f64c 4374 	movw	r3, #52340	; 0xcc74
    bd62:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bd66:	849a      	strh	r2, [r3, #36]	; 0x24
		UIP_LOG( "tcp: bad checksum." );
		goto drop;
    bd68:	f001 bce2 	b.w	d730 <uip_process+0x2188>
	}

	/* Demultiplex this segment. */

	/* First check any active connections. */
	for( uip_connr = &uip_conns[ 0 ]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr )
    bd6c:	f64a 4440 	movw	r4, #44096	; 0xac40
    bd70:	f2c2 0400 	movt	r4, #8192	; 0x2000
    bd74:	e049      	b.n	be0a <uip_process+0x862>
	{
		if
		(
			uip_connr->tcpstateflags != UIP_CLOSED &&
    bd76:	7e63      	ldrb	r3, [r4, #25]

	/* First check any active connections. */
	for( uip_connr = &uip_conns[ 0 ]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr )
	{
		if
		(
    bd78:	2b00      	cmp	r3, #0
    bd7a:	d044      	beq.n	be06 <uip_process+0x85e>
			uip_connr->tcpstateflags != UIP_CLOSED &&
			BUF->destport == uip_connr->lport &&
    bd7c:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bd80:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bd84:	681b      	ldr	r3, [r3, #0]
    bd86:	f103 030e 	add.w	r3, r3, #14
    bd8a:	7d9a      	ldrb	r2, [r3, #22]
    bd8c:	7ddb      	ldrb	r3, [r3, #23]
    bd8e:	ea4f 2303 	mov.w	r3, r3, lsl #8
    bd92:	ea43 0302 	orr.w	r3, r3, r2
    bd96:	b29a      	uxth	r2, r3
    bd98:	88a3      	ldrh	r3, [r4, #4]

	/* First check any active connections. */
	for( uip_connr = &uip_conns[ 0 ]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr )
	{
		if
		(
    bd9a:	429a      	cmp	r2, r3
    bd9c:	d133      	bne.n	be06 <uip_process+0x85e>
			uip_connr->tcpstateflags != UIP_CLOSED &&
			BUF->destport == uip_connr->lport &&
			BUF->srcport == uip_connr->rport &&
    bd9e:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bda2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bda6:	681b      	ldr	r3, [r3, #0]
    bda8:	f103 030e 	add.w	r3, r3, #14
    bdac:	7d1a      	ldrb	r2, [r3, #20]
    bdae:	7d5b      	ldrb	r3, [r3, #21]
    bdb0:	ea4f 2303 	mov.w	r3, r3, lsl #8
    bdb4:	ea43 0302 	orr.w	r3, r3, r2
    bdb8:	b29a      	uxth	r2, r3
    bdba:	88e3      	ldrh	r3, [r4, #6]

	/* First check any active connections. */
	for( uip_connr = &uip_conns[ 0 ]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr )
	{
		if
		(
    bdbc:	429a      	cmp	r2, r3
    bdbe:	d122      	bne.n	be06 <uip_process+0x85e>
			uip_connr->tcpstateflags != UIP_CLOSED &&
			BUF->destport == uip_connr->lport &&
			BUF->srcport == uip_connr->rport &&
			uip_ipaddr_cmp(&BUF->srcipaddr, &uip_connr->ripaddr)
    bdc0:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bdc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bdc8:	681b      	ldr	r3, [r3, #0]
    bdca:	f103 030e 	add.w	r3, r3, #14
    bdce:	7b1a      	ldrb	r2, [r3, #12]
    bdd0:	7b5b      	ldrb	r3, [r3, #13]
    bdd2:	ea4f 2303 	mov.w	r3, r3, lsl #8
    bdd6:	ea43 0302 	orr.w	r3, r3, r2
    bdda:	b29a      	uxth	r2, r3
    bddc:	8823      	ldrh	r3, [r4, #0]

	/* First check any active connections. */
	for( uip_connr = &uip_conns[ 0 ]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr )
	{
		if
		(
    bdde:	429a      	cmp	r2, r3
    bde0:	d111      	bne.n	be06 <uip_process+0x85e>
			uip_connr->tcpstateflags != UIP_CLOSED &&
			BUF->destport == uip_connr->lport &&
			BUF->srcport == uip_connr->rport &&
			uip_ipaddr_cmp(&BUF->srcipaddr, &uip_connr->ripaddr)
    bde2:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bde6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bdea:	681b      	ldr	r3, [r3, #0]
    bdec:	f103 030e 	add.w	r3, r3, #14
    bdf0:	7b9a      	ldrb	r2, [r3, #14]
    bdf2:	7bdb      	ldrb	r3, [r3, #15]
    bdf4:	ea4f 2303 	mov.w	r3, r3, lsl #8
    bdf8:	ea43 0302 	orr.w	r3, r3, r2
    bdfc:	b29a      	uxth	r2, r3
    bdfe:	8863      	ldrh	r3, [r4, #2]

	/* First check any active connections. */
	for( uip_connr = &uip_conns[ 0 ]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr )
	{
		if
		(
    be00:	429a      	cmp	r2, r3
    be02:	f000 84ad 	beq.w	c760 <uip_process+0x11b8>
	}

	/* Demultiplex this segment. */

	/* First check any active connections. */
	for( uip_connr = &uip_conns[ 0 ]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr )
    be06:	f104 04cc 	add.w	r4, r4, #204	; 0xcc
    be0a:	4b30      	ldr	r3, [pc, #192]	; (becc <uip_process+0x924>)
    be0c:	429c      	cmp	r4, r3
    be0e:	d9b2      	bls.n	bd76 <uip_process+0x7ce>

	/* If we didn't find and active connection that expected the packet,
	either this packet is an old duplicate, or this is a SYN packet
	destined for a connection in LISTEN. If the SYN flag isn't set,
	it is an old packet and we send a RST. */
	if( (BUF->flags & TCP_CTL) != TCP_SYN )
    be10:	f240 63a4 	movw	r3, #1700	; 0x6a4
    be14:	f2c2 0300 	movt	r3, #8192	; 0x2000
    be18:	681b      	ldr	r3, [r3, #0]
    be1a:	f103 030e 	add.w	r3, r3, #14
    be1e:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    be22:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    be26:	2b02      	cmp	r3, #2
    be28:	d152      	bne.n	bed0 <uip_process+0x928>
	{
		goto reset;
	}

	tmp16 = BUF->destport;
    be2a:	f240 63a4 	movw	r3, #1700	; 0x6a4
    be2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    be32:	681b      	ldr	r3, [r3, #0]
    be34:	f103 030e 	add.w	r3, r3, #14
    be38:	7d9a      	ldrb	r2, [r3, #22]
    be3a:	7ddb      	ldrb	r3, [r3, #23]
    be3c:	ea4f 2303 	mov.w	r3, r3, lsl #8
    be40:	ea43 0302 	orr.w	r3, r3, r2
    be44:	b29a      	uxth	r2, r3
    be46:	f642 7390 	movw	r3, #12176	; 0x2f90
    be4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    be4e:	801a      	strh	r2, [r3, #0]

	/* Next, check listening connections. */
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    be50:	f642 738e 	movw	r3, #12174	; 0x2f8e
    be54:	f2c2 0300 	movt	r3, #8192	; 0x2000
    be58:	f04f 0200 	mov.w	r2, #0
    be5c:	701a      	strb	r2, [r3, #0]
    be5e:	e020      	b.n	bea2 <uip_process+0x8fa>
	{
		if( tmp16 == uip_listenports[ c ] )
    be60:	f642 738e 	movw	r3, #12174	; 0x2f8e
    be64:	f2c2 0300 	movt	r3, #8192	; 0x2000
    be68:	781b      	ldrb	r3, [r3, #0]
    be6a:	461a      	mov	r2, r3
    be6c:	f64c 4320 	movw	r3, #52256	; 0xcc20
    be70:	f2c2 0300 	movt	r3, #8192	; 0x2000
    be74:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
    be78:	f642 7390 	movw	r3, #12176	; 0x2f90
    be7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    be80:	881b      	ldrh	r3, [r3, #0]
    be82:	429a      	cmp	r2, r3
    be84:	f000 8206 	beq.w	c294 <uip_process+0xcec>
	}

	tmp16 = BUF->destport;

	/* Next, check listening connections. */
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    be88:	f642 738e 	movw	r3, #12174	; 0x2f8e
    be8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    be90:	781b      	ldrb	r3, [r3, #0]
    be92:	f103 0301 	add.w	r3, r3, #1
    be96:	b2da      	uxtb	r2, r3
    be98:	f642 738e 	movw	r3, #12174	; 0x2f8e
    be9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bea0:	701a      	strb	r2, [r3, #0]
    bea2:	f642 738e 	movw	r3, #12174	; 0x2f8e
    bea6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    beaa:	781b      	ldrb	r3, [r3, #0]
    beac:	2b27      	cmp	r3, #39	; 0x27
    beae:	d9d7      	bls.n	be60 <uip_process+0x8b8>
			goto found_listen;
		}
	}

	/* No matching connection found, so we send a RST packet. */
	UIP_STAT( ++uip_stat.tcp.synrst );
    beb0:	f64c 4374 	movw	r3, #52340	; 0xcc74
    beb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    beb8:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
    beba:	f103 0301 	add.w	r3, r3, #1
    bebe:	b29a      	uxth	r2, r3
    bec0:	f64c 4374 	movw	r3, #52340	; 0xcc74
    bec4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bec8:	85da      	strh	r2, [r3, #46]	; 0x2e
    beca:	e002      	b.n	bed2 <uip_process+0x92a>
    becc:	2000cb54 	.word	0x2000cb54
	either this packet is an old duplicate, or this is a SYN packet
	destined for a connection in LISTEN. If the SYN flag isn't set,
	it is an old packet and we send a RST. */
	if( (BUF->flags & TCP_CTL) != TCP_SYN )
	{
		goto reset;
    bed0:	bf00      	nop
	/* No matching connection found, so we send a RST packet. */
	UIP_STAT( ++uip_stat.tcp.synrst );

reset:
	/* We do not send resets in response to resets. */
	if( BUF->flags & TCP_RST )
    bed2:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bed6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    beda:	681b      	ldr	r3, [r3, #0]
    bedc:	f103 030e 	add.w	r3, r3, #14
    bee0:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    bee4:	f003 0304 	and.w	r3, r3, #4
    bee8:	2b00      	cmp	r3, #0
    beea:	f041 8410 	bne.w	d70e <uip_process+0x2166>
	{
		goto drop;
	}

	UIP_STAT( ++uip_stat.tcp.rst );
    beee:	f64c 4374 	movw	r3, #52340	; 0xcc74
    bef2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bef6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    bef8:	f103 0301 	add.w	r3, r3, #1
    befc:	b29a      	uxth	r2, r3
    befe:	f64c 4374 	movw	r3, #52340	; 0xcc74
    bf02:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bf06:	851a      	strh	r2, [r3, #40]	; 0x28

	BUF->flags = TCP_RST | TCP_ACK;
    bf08:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bf0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bf10:	681b      	ldr	r3, [r3, #0]
    bf12:	f103 030e 	add.w	r3, r3, #14
    bf16:	f04f 0214 	mov.w	r2, #20
    bf1a:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
	uip_len = UIP_IPTCPH_LEN;
    bf1e:	f64a 4328 	movw	r3, #44072	; 0xac28
    bf22:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bf26:	f04f 0228 	mov.w	r2, #40	; 0x28
    bf2a:	801a      	strh	r2, [r3, #0]
	BUF->tcpoffset = 5 << 4;
    bf2c:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bf30:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bf34:	681b      	ldr	r3, [r3, #0]
    bf36:	f103 030e 	add.w	r3, r3, #14
    bf3a:	f04f 0250 	mov.w	r2, #80	; 0x50
    bf3e:	f883 2020 	strb.w	r2, [r3, #32]

	/* Flip the seqno and ackno fields in the TCP header. */
	c = BUF->seqno[ 3 ];
    bf42:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bf46:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bf4a:	681b      	ldr	r3, [r3, #0]
    bf4c:	f103 030e 	add.w	r3, r3, #14
    bf50:	7eda      	ldrb	r2, [r3, #27]
    bf52:	f642 738e 	movw	r3, #12174	; 0x2f8e
    bf56:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bf5a:	701a      	strb	r2, [r3, #0]
	BUF->seqno[ 3 ] = BUF->ackno[ 3 ];
    bf5c:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bf60:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bf64:	681b      	ldr	r3, [r3, #0]
    bf66:	f103 020e 	add.w	r2, r3, #14
    bf6a:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bf6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bf72:	681b      	ldr	r3, [r3, #0]
    bf74:	f103 030e 	add.w	r3, r3, #14
    bf78:	7fdb      	ldrb	r3, [r3, #31]
    bf7a:	76d3      	strb	r3, [r2, #27]
	BUF->ackno[ 3 ] = c;
    bf7c:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bf80:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bf84:	681b      	ldr	r3, [r3, #0]
    bf86:	f103 020e 	add.w	r2, r3, #14
    bf8a:	f642 738e 	movw	r3, #12174	; 0x2f8e
    bf8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bf92:	781b      	ldrb	r3, [r3, #0]
    bf94:	77d3      	strb	r3, [r2, #31]

	c = BUF->seqno[ 2 ];
    bf96:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bf9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bf9e:	681b      	ldr	r3, [r3, #0]
    bfa0:	f103 030e 	add.w	r3, r3, #14
    bfa4:	7e9a      	ldrb	r2, [r3, #26]
    bfa6:	f642 738e 	movw	r3, #12174	; 0x2f8e
    bfaa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bfae:	701a      	strb	r2, [r3, #0]
	BUF->seqno[ 2 ] = BUF->ackno[ 2 ];
    bfb0:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bfb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bfb8:	681b      	ldr	r3, [r3, #0]
    bfba:	f103 020e 	add.w	r2, r3, #14
    bfbe:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bfc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bfc6:	681b      	ldr	r3, [r3, #0]
    bfc8:	f103 030e 	add.w	r3, r3, #14
    bfcc:	7f9b      	ldrb	r3, [r3, #30]
    bfce:	7693      	strb	r3, [r2, #26]
	BUF->ackno[ 2 ] = c;
    bfd0:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bfd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bfd8:	681b      	ldr	r3, [r3, #0]
    bfda:	f103 020e 	add.w	r2, r3, #14
    bfde:	f642 738e 	movw	r3, #12174	; 0x2f8e
    bfe2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bfe6:	781b      	ldrb	r3, [r3, #0]
    bfe8:	7793      	strb	r3, [r2, #30]

	c = BUF->seqno[ 1 ];
    bfea:	f240 63a4 	movw	r3, #1700	; 0x6a4
    bfee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bff2:	681b      	ldr	r3, [r3, #0]
    bff4:	f103 030e 	add.w	r3, r3, #14
    bff8:	7e5a      	ldrb	r2, [r3, #25]
    bffa:	f642 738e 	movw	r3, #12174	; 0x2f8e
    bffe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c002:	701a      	strb	r2, [r3, #0]
	BUF->seqno[ 1 ] = BUF->ackno[ 1 ];
    c004:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c008:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c00c:	681b      	ldr	r3, [r3, #0]
    c00e:	f103 020e 	add.w	r2, r3, #14
    c012:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c016:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c01a:	681b      	ldr	r3, [r3, #0]
    c01c:	f103 030e 	add.w	r3, r3, #14
    c020:	7f5b      	ldrb	r3, [r3, #29]
    c022:	7653      	strb	r3, [r2, #25]
	BUF->ackno[ 1 ] = c;
    c024:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c028:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c02c:	681b      	ldr	r3, [r3, #0]
    c02e:	f103 020e 	add.w	r2, r3, #14
    c032:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c036:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c03a:	781b      	ldrb	r3, [r3, #0]
    c03c:	7753      	strb	r3, [r2, #29]

	c = BUF->seqno[ 0 ];
    c03e:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c042:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c046:	681b      	ldr	r3, [r3, #0]
    c048:	f103 030e 	add.w	r3, r3, #14
    c04c:	7e1a      	ldrb	r2, [r3, #24]
    c04e:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c052:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c056:	701a      	strb	r2, [r3, #0]
	BUF->seqno[ 0 ] = BUF->ackno[ 0 ];
    c058:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c05c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c060:	681b      	ldr	r3, [r3, #0]
    c062:	f103 020e 	add.w	r2, r3, #14
    c066:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c06a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c06e:	681b      	ldr	r3, [r3, #0]
    c070:	f103 030e 	add.w	r3, r3, #14
    c074:	7f1b      	ldrb	r3, [r3, #28]
    c076:	7613      	strb	r3, [r2, #24]
	BUF->ackno[ 0 ] = c;
    c078:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c07c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c080:	681b      	ldr	r3, [r3, #0]
    c082:	f103 020e 	add.w	r2, r3, #14
    c086:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c08a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c08e:	781b      	ldrb	r3, [r3, #0]
    c090:	7713      	strb	r3, [r2, #28]

	/* We also have to increase the sequence number we are
	acknowledging. If the least significant byte overflowed, we need
	to propagate the carry to the other bytes as well. */
	if( ++BUF->ackno[ 3 ] == 0 )
    c092:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c096:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c09a:	681b      	ldr	r3, [r3, #0]
    c09c:	f103 030e 	add.w	r3, r3, #14
    c0a0:	7fda      	ldrb	r2, [r3, #31]
    c0a2:	f102 0201 	add.w	r2, r2, #1
    c0a6:	b2d2      	uxtb	r2, r2
    c0a8:	77da      	strb	r2, [r3, #31]
    c0aa:	7fdb      	ldrb	r3, [r3, #31]
    c0ac:	2b00      	cmp	r3, #0
    c0ae:	d129      	bne.n	c104 <uip_process+0xb5c>
	{
		if( ++BUF->ackno[ 2 ] == 0 )
    c0b0:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c0b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c0b8:	681b      	ldr	r3, [r3, #0]
    c0ba:	f103 030e 	add.w	r3, r3, #14
    c0be:	7f9a      	ldrb	r2, [r3, #30]
    c0c0:	f102 0201 	add.w	r2, r2, #1
    c0c4:	b2d2      	uxtb	r2, r2
    c0c6:	779a      	strb	r2, [r3, #30]
    c0c8:	7f9b      	ldrb	r3, [r3, #30]
    c0ca:	2b00      	cmp	r3, #0
    c0cc:	d11a      	bne.n	c104 <uip_process+0xb5c>
		{
			if( ++BUF->ackno[ 1 ] == 0 )
    c0ce:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c0d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c0d6:	681b      	ldr	r3, [r3, #0]
    c0d8:	f103 030e 	add.w	r3, r3, #14
    c0dc:	7f5a      	ldrb	r2, [r3, #29]
    c0de:	f102 0201 	add.w	r2, r2, #1
    c0e2:	b2d2      	uxtb	r2, r2
    c0e4:	775a      	strb	r2, [r3, #29]
    c0e6:	7f5b      	ldrb	r3, [r3, #29]
    c0e8:	2b00      	cmp	r3, #0
    c0ea:	d10b      	bne.n	c104 <uip_process+0xb5c>
			{
				++BUF->ackno[ 0 ];
    c0ec:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c0f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c0f4:	681b      	ldr	r3, [r3, #0]
    c0f6:	f103 030e 	add.w	r3, r3, #14
    c0fa:	7f1a      	ldrb	r2, [r3, #28]
    c0fc:	f102 0201 	add.w	r2, r2, #1
    c100:	b2d2      	uxtb	r2, r2
    c102:	771a      	strb	r2, [r3, #28]
			}
		}
	}

	/* Swap port numbers. */
	tmp16 = BUF->srcport;
    c104:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c108:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c10c:	681b      	ldr	r3, [r3, #0]
    c10e:	f103 030e 	add.w	r3, r3, #14
    c112:	7d1a      	ldrb	r2, [r3, #20]
    c114:	7d5b      	ldrb	r3, [r3, #21]
    c116:	ea4f 2303 	mov.w	r3, r3, lsl #8
    c11a:	ea43 0302 	orr.w	r3, r3, r2
    c11e:	b29a      	uxth	r2, r3
    c120:	f642 7390 	movw	r3, #12176	; 0x2f90
    c124:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c128:	801a      	strh	r2, [r3, #0]
	BUF->srcport = BUF->destport;
    c12a:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c12e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c132:	681b      	ldr	r3, [r3, #0]
    c134:	f103 020e 	add.w	r2, r3, #14
    c138:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c13c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c140:	681b      	ldr	r3, [r3, #0]
    c142:	f103 030e 	add.w	r3, r3, #14
    c146:	7d99      	ldrb	r1, [r3, #22]
    c148:	7ddb      	ldrb	r3, [r3, #23]
    c14a:	ea4f 2303 	mov.w	r3, r3, lsl #8
    c14e:	ea43 0301 	orr.w	r3, r3, r1
    c152:	b29b      	uxth	r3, r3
    c154:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    c158:	f04f 0000 	mov.w	r0, #0
    c15c:	ea40 0101 	orr.w	r1, r0, r1
    c160:	7511      	strb	r1, [r2, #20]
    c162:	ea4f 2313 	mov.w	r3, r3, lsr #8
    c166:	b29b      	uxth	r3, r3
    c168:	f04f 0100 	mov.w	r1, #0
    c16c:	ea41 0303 	orr.w	r3, r1, r3
    c170:	7553      	strb	r3, [r2, #21]
	BUF->destport = tmp16;
    c172:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c176:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c17a:	681b      	ldr	r3, [r3, #0]
    c17c:	f103 020e 	add.w	r2, r3, #14
    c180:	f642 7390 	movw	r3, #12176	; 0x2f90
    c184:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c188:	881b      	ldrh	r3, [r3, #0]
    c18a:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    c18e:	f04f 0000 	mov.w	r0, #0
    c192:	ea40 0101 	orr.w	r1, r0, r1
    c196:	7591      	strb	r1, [r2, #22]
    c198:	ea4f 2313 	mov.w	r3, r3, lsr #8
    c19c:	b29b      	uxth	r3, r3
    c19e:	f04f 0100 	mov.w	r1, #0
    c1a2:	ea41 0303 	orr.w	r3, r1, r3
    c1a6:	75d3      	strb	r3, [r2, #23]

	/* Swap IP addresses. */
	uip_ipaddr_copy( &BUF->destipaddr, &BUF->srcipaddr );
    c1a8:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c1ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c1b0:	681b      	ldr	r3, [r3, #0]
    c1b2:	f103 020e 	add.w	r2, r3, #14
    c1b6:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c1ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c1be:	681b      	ldr	r3, [r3, #0]
    c1c0:	f103 030e 	add.w	r3, r3, #14
    c1c4:	7b1b      	ldrb	r3, [r3, #12]
    c1c6:	7413      	strb	r3, [r2, #16]
    c1c8:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c1cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c1d0:	681b      	ldr	r3, [r3, #0]
    c1d2:	f103 020e 	add.w	r2, r3, #14
    c1d6:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c1da:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c1de:	681b      	ldr	r3, [r3, #0]
    c1e0:	f103 030e 	add.w	r3, r3, #14
    c1e4:	7b5b      	ldrb	r3, [r3, #13]
    c1e6:	7453      	strb	r3, [r2, #17]
    c1e8:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c1ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c1f0:	681b      	ldr	r3, [r3, #0]
    c1f2:	f103 020e 	add.w	r2, r3, #14
    c1f6:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c1fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c1fe:	681b      	ldr	r3, [r3, #0]
    c200:	f103 030e 	add.w	r3, r3, #14
    c204:	7b9b      	ldrb	r3, [r3, #14]
    c206:	7493      	strb	r3, [r2, #18]
    c208:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c20c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c210:	681b      	ldr	r3, [r3, #0]
    c212:	f103 020e 	add.w	r2, r3, #14
    c216:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c21a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c21e:	681b      	ldr	r3, [r3, #0]
    c220:	f103 030e 	add.w	r3, r3, #14
    c224:	7bdb      	ldrb	r3, [r3, #15]
    c226:	74d3      	strb	r3, [r2, #19]
	uip_ipaddr_copy( &BUF->srcipaddr, &uip_hostaddr );
    c228:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c22c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c230:	681b      	ldr	r3, [r3, #0]
    c232:	f103 020e 	add.w	r2, r3, #14
    c236:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    c23a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c23e:	781b      	ldrb	r3, [r3, #0]
    c240:	7313      	strb	r3, [r2, #12]
    c242:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c246:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c24a:	681b      	ldr	r3, [r3, #0]
    c24c:	f103 020e 	add.w	r2, r3, #14
    c250:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    c254:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c258:	785b      	ldrb	r3, [r3, #1]
    c25a:	7353      	strb	r3, [r2, #13]
    c25c:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c260:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c264:	681b      	ldr	r3, [r3, #0]
    c266:	f103 020e 	add.w	r2, r3, #14
    c26a:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    c26e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c272:	789b      	ldrb	r3, [r3, #2]
    c274:	7393      	strb	r3, [r2, #14]
    c276:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c27a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c27e:	681b      	ldr	r3, [r3, #0]
    c280:	f103 020e 	add.w	r2, r3, #14
    c284:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    c288:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c28c:	78db      	ldrb	r3, [r3, #3]
    c28e:	73d3      	strb	r3, [r2, #15]

	/* And send out the RST packet! */
	goto tcp_send_noconn;
    c290:	f001 b925 	b.w	d4de <uip_process+0x1f36>
	/* Next, check listening connections. */
	for( c = 0; c < UIP_LISTENPORTS; ++c )
	{
		if( tmp16 == uip_listenports[ c ] )
		{
			goto found_listen;
    c294:	bf00      	nop
	connections are kept in the same table as used connections, but
	unused ones have the tcpstate set to CLOSED. Also, connections in
	TIME_WAIT are kept track of and we'll use the oldest one if no
	CLOSED connections are found. Thanks to Eddie C. Dost for a very
	nice algorithm for the TIME_WAIT search. */
	uip_connr = 0;
    c296:	f04f 0400 	mov.w	r4, #0
	for( c = 0; c < UIP_CONNS; ++c )
    c29a:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c29e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c2a2:	f04f 0200 	mov.w	r2, #0
    c2a6:	701a      	strb	r2, [r3, #0]
    c2a8:	e06a      	b.n	c380 <uip_process+0xdd8>
	{
		if( uip_conns[ c ].tcpstateflags == UIP_CLOSED )
    c2aa:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c2ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c2b2:	781b      	ldrb	r3, [r3, #0]
    c2b4:	461a      	mov	r2, r3
    c2b6:	f64a 4340 	movw	r3, #44096	; 0xac40
    c2ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c2be:	f04f 01cc 	mov.w	r1, #204	; 0xcc
    c2c2:	fb01 f202 	mul.w	r2, r1, r2
    c2c6:	4413      	add	r3, r2
    c2c8:	f103 0318 	add.w	r3, r3, #24
    c2cc:	785b      	ldrb	r3, [r3, #1]
    c2ce:	2b00      	cmp	r3, #0
    c2d0:	d10f      	bne.n	c2f2 <uip_process+0xd4a>
		{
			uip_connr = &uip_conns[ c ];
    c2d2:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c2d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c2da:	781b      	ldrb	r3, [r3, #0]
    c2dc:	f04f 02cc 	mov.w	r2, #204	; 0xcc
    c2e0:	fb02 f203 	mul.w	r2, r2, r3
    c2e4:	f64a 4340 	movw	r3, #44096	; 0xac40
    c2e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c2ec:	eb02 0403 	add.w	r4, r2, r3
			break;
    c2f0:	e04d      	b.n	c38e <uip_process+0xde6>
		}

		if( uip_conns[ c ].tcpstateflags == UIP_TIME_WAIT )
    c2f2:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c2f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c2fa:	781b      	ldrb	r3, [r3, #0]
    c2fc:	461a      	mov	r2, r3
    c2fe:	f64a 4340 	movw	r3, #44096	; 0xac40
    c302:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c306:	f04f 01cc 	mov.w	r1, #204	; 0xcc
    c30a:	fb01 f202 	mul.w	r2, r1, r2
    c30e:	4413      	add	r3, r2
    c310:	f103 0318 	add.w	r3, r3, #24
    c314:	785b      	ldrb	r3, [r3, #1]
    c316:	2b07      	cmp	r3, #7
    c318:	d125      	bne.n	c366 <uip_process+0xdbe>
		{
			if( uip_connr == 0 || uip_conns[ c ].timer > uip_connr->timer )
    c31a:	2c00      	cmp	r4, #0
    c31c:	d014      	beq.n	c348 <uip_process+0xda0>
    c31e:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c322:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c326:	781b      	ldrb	r3, [r3, #0]
    c328:	461a      	mov	r2, r3
    c32a:	f64a 4340 	movw	r3, #44096	; 0xac40
    c32e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c332:	f04f 01cc 	mov.w	r1, #204	; 0xcc
    c336:	fb01 f202 	mul.w	r2, r1, r2
    c33a:	4413      	add	r3, r2
    c33c:	f103 0318 	add.w	r3, r3, #24
    c340:	789a      	ldrb	r2, [r3, #2]
    c342:	7ea3      	ldrb	r3, [r4, #26]
    c344:	429a      	cmp	r2, r3
    c346:	d90e      	bls.n	c366 <uip_process+0xdbe>
			{
				uip_connr = &uip_conns[ c ];
    c348:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c34c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c350:	781b      	ldrb	r3, [r3, #0]
    c352:	f04f 02cc 	mov.w	r2, #204	; 0xcc
    c356:	fb02 f203 	mul.w	r2, r2, r3
    c35a:	f64a 4340 	movw	r3, #44096	; 0xac40
    c35e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c362:	eb02 0403 	add.w	r4, r2, r3
	unused ones have the tcpstate set to CLOSED. Also, connections in
	TIME_WAIT are kept track of and we'll use the oldest one if no
	CLOSED connections are found. Thanks to Eddie C. Dost for a very
	nice algorithm for the TIME_WAIT search. */
	uip_connr = 0;
	for( c = 0; c < UIP_CONNS; ++c )
    c366:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c36a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c36e:	781b      	ldrb	r3, [r3, #0]
    c370:	f103 0301 	add.w	r3, r3, #1
    c374:	b2da      	uxtb	r2, r3
    c376:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c37a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c37e:	701a      	strb	r2, [r3, #0]
    c380:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c384:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c388:	781b      	ldrb	r3, [r3, #0]
    c38a:	2b27      	cmp	r3, #39	; 0x27
    c38c:	d98d      	bls.n	c2aa <uip_process+0xd02>
				uip_connr = &uip_conns[ c ];
			}
		}
	}

	if( uip_connr == 0 )
    c38e:	2c00      	cmp	r4, #0
    c390:	d10e      	bne.n	c3b0 <uip_process+0xe08>
	{
		/* All connections are used already, we drop packet and hope that
		the remote end will retransmit the packet at a time when we
		have more spare connections. */
		UIP_STAT( ++uip_stat.tcp.syndrop );
    c392:	f64c 4374 	movw	r3, #52340	; 0xcc74
    c396:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c39a:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
    c39c:	f103 0301 	add.w	r3, r3, #1
    c3a0:	b29a      	uxth	r2, r3
    c3a2:	f64c 4374 	movw	r3, #52340	; 0xcc74
    c3a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c3aa:	859a      	strh	r2, [r3, #44]	; 0x2c
		UIP_LOG( "tcp: found no unused connections." );
		goto drop;
    c3ac:	f001 b9c0 	b.w	d730 <uip_process+0x2188>
	}

	uip_conn = uip_connr;
    c3b0:	f64a 433c 	movw	r3, #44092	; 0xac3c
    c3b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c3b8:	601c      	str	r4, [r3, #0]

	/* Fill in the necessary fields for the new connection. */
	uip_connr->rto = uip_connr->timer = UIP_RTO;
    c3ba:	f04f 0303 	mov.w	r3, #3
    c3be:	76a3      	strb	r3, [r4, #26]
    c3c0:	7ea3      	ldrb	r3, [r4, #26]
    c3c2:	7623      	strb	r3, [r4, #24]
	uip_connr->sa = 0;
    c3c4:	f04f 0300 	mov.w	r3, #0
    c3c8:	75a3      	strb	r3, [r4, #22]
	uip_connr->sv = 4;
    c3ca:	f04f 0304 	mov.w	r3, #4
    c3ce:	75e3      	strb	r3, [r4, #23]
	uip_connr->nrtx = 0;
    c3d0:	f04f 0300 	mov.w	r3, #0
    c3d4:	76e3      	strb	r3, [r4, #27]
	uip_connr->lport = BUF->destport;
    c3d6:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c3da:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c3de:	681b      	ldr	r3, [r3, #0]
    c3e0:	f103 030e 	add.w	r3, r3, #14
    c3e4:	7d9a      	ldrb	r2, [r3, #22]
    c3e6:	7ddb      	ldrb	r3, [r3, #23]
    c3e8:	ea4f 2303 	mov.w	r3, r3, lsl #8
    c3ec:	ea43 0302 	orr.w	r3, r3, r2
    c3f0:	b29b      	uxth	r3, r3
    c3f2:	80a3      	strh	r3, [r4, #4]
	uip_connr->rport = BUF->srcport;
    c3f4:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c3f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c3fc:	681b      	ldr	r3, [r3, #0]
    c3fe:	f103 030e 	add.w	r3, r3, #14
    c402:	7d1a      	ldrb	r2, [r3, #20]
    c404:	7d5b      	ldrb	r3, [r3, #21]
    c406:	ea4f 2303 	mov.w	r3, r3, lsl #8
    c40a:	ea43 0302 	orr.w	r3, r3, r2
    c40e:	b29b      	uxth	r3, r3
    c410:	80e3      	strh	r3, [r4, #6]
	uip_ipaddr_copy( &uip_connr->ripaddr, &BUF->srcipaddr );
    c412:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c416:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c41a:	681b      	ldr	r3, [r3, #0]
    c41c:	f103 030e 	add.w	r3, r3, #14
    c420:	7b1b      	ldrb	r3, [r3, #12]
    c422:	7023      	strb	r3, [r4, #0]
    c424:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c428:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c42c:	681b      	ldr	r3, [r3, #0]
    c42e:	f103 030e 	add.w	r3, r3, #14
    c432:	7b5b      	ldrb	r3, [r3, #13]
    c434:	7063      	strb	r3, [r4, #1]
    c436:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c43a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c43e:	681b      	ldr	r3, [r3, #0]
    c440:	f103 030e 	add.w	r3, r3, #14
    c444:	7b9b      	ldrb	r3, [r3, #14]
    c446:	70a3      	strb	r3, [r4, #2]
    c448:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c44c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c450:	681b      	ldr	r3, [r3, #0]
    c452:	f103 030e 	add.w	r3, r3, #14
    c456:	7bdb      	ldrb	r3, [r3, #15]
    c458:	70e3      	strb	r3, [r4, #3]
	uip_connr->tcpstateflags = UIP_SYN_RCVD;
    c45a:	f04f 0301 	mov.w	r3, #1
    c45e:	7663      	strb	r3, [r4, #25]

	uip_connr->snd_nxt[ 0 ] = iss[ 0 ];
    c460:	f642 7388 	movw	r3, #12168	; 0x2f88
    c464:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c468:	781b      	ldrb	r3, [r3, #0]
    c46a:	7323      	strb	r3, [r4, #12]
	uip_connr->snd_nxt[ 1 ] = iss[ 1 ];
    c46c:	f642 7388 	movw	r3, #12168	; 0x2f88
    c470:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c474:	785b      	ldrb	r3, [r3, #1]
    c476:	7363      	strb	r3, [r4, #13]
	uip_connr->snd_nxt[ 2 ] = iss[ 2 ];
    c478:	f642 7388 	movw	r3, #12168	; 0x2f88
    c47c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c480:	789b      	ldrb	r3, [r3, #2]
    c482:	73a3      	strb	r3, [r4, #14]
	uip_connr->snd_nxt[ 3 ] = iss[ 3 ];
    c484:	f642 7388 	movw	r3, #12168	; 0x2f88
    c488:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c48c:	78db      	ldrb	r3, [r3, #3]
    c48e:	73e3      	strb	r3, [r4, #15]
	uip_connr->len = 1;
    c490:	f04f 0301 	mov.w	r3, #1
    c494:	8223      	strh	r3, [r4, #16]

	/* rcv_nxt should be the seqno from the incoming packet + 1. */
	uip_connr->rcv_nxt[ 3 ] = BUF->seqno[ 3 ];
    c496:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c49a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c49e:	681b      	ldr	r3, [r3, #0]
    c4a0:	f103 030e 	add.w	r3, r3, #14
    c4a4:	7edb      	ldrb	r3, [r3, #27]
    c4a6:	72e3      	strb	r3, [r4, #11]
	uip_connr->rcv_nxt[ 2 ] = BUF->seqno[ 2 ];
    c4a8:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c4ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c4b0:	681b      	ldr	r3, [r3, #0]
    c4b2:	f103 030e 	add.w	r3, r3, #14
    c4b6:	7e9b      	ldrb	r3, [r3, #26]
    c4b8:	72a3      	strb	r3, [r4, #10]
	uip_connr->rcv_nxt[ 1 ] = BUF->seqno[ 1 ];
    c4ba:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c4be:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c4c2:	681b      	ldr	r3, [r3, #0]
    c4c4:	f103 030e 	add.w	r3, r3, #14
    c4c8:	7e5b      	ldrb	r3, [r3, #25]
    c4ca:	7263      	strb	r3, [r4, #9]
	uip_connr->rcv_nxt[ 0 ] = BUF->seqno[ 0 ];
    c4cc:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c4d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c4d4:	681b      	ldr	r3, [r3, #0]
    c4d6:	f103 030e 	add.w	r3, r3, #14
    c4da:	7e1b      	ldrb	r3, [r3, #24]
    c4dc:	7223      	strb	r3, [r4, #8]
	uip_add_rcv_nxt( 1 );
    c4de:	f04f 0001 	mov.w	r0, #1
    c4e2:	f7ff f81f 	bl	b524 <uip_add_rcv_nxt>

	/* Parse the TCP MSS option, if present. */
	if( (BUF->tcpoffset & 0xf0) > 0x50 )
    c4e6:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c4ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c4ee:	681b      	ldr	r3, [r3, #0]
    c4f0:	f103 030e 	add.w	r3, r3, #14
    c4f4:	f893 3020 	ldrb.w	r3, [r3, #32]
    c4f8:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    c4fc:	2b50      	cmp	r3, #80	; 0x50
    c4fe:	f340 80cf 	ble.w	c6a0 <uip_process+0x10f8>
	{
		for( c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2; )
    c502:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c506:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c50a:	f04f 0200 	mov.w	r2, #0
    c50e:	701a      	strb	r2, [r3, #0]
    c510:	e0a7      	b.n	c662 <uip_process+0x10ba>
		{
			opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
    c512:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c516:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c51a:	681a      	ldr	r2, [r3, #0]
    c51c:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c520:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c524:	781b      	ldrb	r3, [r3, #0]
    c526:	f103 0336 	add.w	r3, r3, #54	; 0x36
    c52a:	4413      	add	r3, r2
    c52c:	781a      	ldrb	r2, [r3, #0]
    c52e:	f642 738f 	movw	r3, #12175	; 0x2f8f
    c532:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c536:	701a      	strb	r2, [r3, #0]
			if( opt == TCP_OPT_END )
    c538:	f642 738f 	movw	r3, #12175	; 0x2f8f
    c53c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c540:	781b      	ldrb	r3, [r3, #0]
    c542:	2b00      	cmp	r3, #0
    c544:	f000 80a9 	beq.w	c69a <uip_process+0x10f2>
			{
				/* End of options. */
				break;
			}
			else if( opt == TCP_OPT_NOOP )
    c548:	f642 738f 	movw	r3, #12175	; 0x2f8f
    c54c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c550:	781b      	ldrb	r3, [r3, #0]
    c552:	2b01      	cmp	r3, #1
    c554:	d10d      	bne.n	c572 <uip_process+0xfca>
			{
				++c;
    c556:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c55a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c55e:	781b      	ldrb	r3, [r3, #0]
    c560:	f103 0301 	add.w	r3, r3, #1
    c564:	b2da      	uxtb	r2, r3
    c566:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c56a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c56e:	701a      	strb	r2, [r3, #0]
    c570:	e077      	b.n	c662 <uip_process+0x10ba>

				/* NOP option. */
			}
			else if( opt == TCP_OPT_MSS && uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN )
    c572:	f642 738f 	movw	r3, #12175	; 0x2f8f
    c576:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c57a:	781b      	ldrb	r3, [r3, #0]
    c57c:	2b02      	cmp	r3, #2
    c57e:	d146      	bne.n	c60e <uip_process+0x1066>
    c580:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c584:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c588:	681a      	ldr	r2, [r3, #0]
    c58a:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c58e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c592:	781b      	ldrb	r3, [r3, #0]
    c594:	f103 0337 	add.w	r3, r3, #55	; 0x37
    c598:	4413      	add	r3, r2
    c59a:	781b      	ldrb	r3, [r3, #0]
    c59c:	2b04      	cmp	r3, #4
    c59e:	d136      	bne.n	c60e <uip_process+0x1066>
			{
				/* An MSS option with the right option length. */
				tmp16 = ( (u16_t) uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8 ) | ( u16_t ) uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
    c5a0:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c5a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c5a8:	681a      	ldr	r2, [r3, #0]
    c5aa:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c5ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c5b2:	781b      	ldrb	r3, [r3, #0]
    c5b4:	f103 0338 	add.w	r3, r3, #56	; 0x38
    c5b8:	4413      	add	r3, r2
    c5ba:	781b      	ldrb	r3, [r3, #0]
    c5bc:	ea4f 2303 	mov.w	r3, r3, lsl #8
    c5c0:	b29a      	uxth	r2, r3
    c5c2:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c5c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c5ca:	6819      	ldr	r1, [r3, #0]
    c5cc:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c5d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c5d4:	781b      	ldrb	r3, [r3, #0]
    c5d6:	f103 0339 	add.w	r3, r3, #57	; 0x39
    c5da:	440b      	add	r3, r1
    c5dc:	781b      	ldrb	r3, [r3, #0]
    c5de:	ea42 0303 	orr.w	r3, r2, r3
    c5e2:	b29b      	uxth	r3, r3
    c5e4:	b29a      	uxth	r2, r3
    c5e6:	f642 7390 	movw	r3, #12176	; 0x2f90
    c5ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c5ee:	801a      	strh	r2, [r3, #0]
				uip_connr->initialmss = uip_connr->mss = tmp16 > UIP_TCP_MSS ? UIP_TCP_MSS : tmp16;
    c5f0:	f642 7390 	movw	r3, #12176	; 0x2f90
    c5f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c5f8:	881a      	ldrh	r2, [r3, #0]
    c5fa:	f240 5392 	movw	r3, #1426	; 0x592
    c5fe:	429a      	cmp	r2, r3
    c600:	bf38      	it	cc
    c602:	4613      	movcc	r3, r2
    c604:	b29b      	uxth	r3, r3
    c606:	8263      	strh	r3, [r4, #18]
    c608:	8a63      	ldrh	r3, [r4, #18]
    c60a:	82a3      	strh	r3, [r4, #20]

				/* And we are done processing options. */
				break;
    c60c:	e048      	b.n	c6a0 <uip_process+0x10f8>
			}
			else
			{
				/* All other options have a length field, so that we easily
				can skip past them. */
				if( uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0 )
    c60e:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c612:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c616:	681a      	ldr	r2, [r3, #0]
    c618:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c61c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c620:	781b      	ldrb	r3, [r3, #0]
    c622:	f103 0337 	add.w	r3, r3, #55	; 0x37
    c626:	4413      	add	r3, r2
    c628:	781b      	ldrb	r3, [r3, #0]
    c62a:	2b00      	cmp	r3, #0
    c62c:	d037      	beq.n	c69e <uip_process+0x10f6>
					/* If the length field is zero, the options are malformed
					and we don't process them further. */
					break;
				}

				c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    c62e:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c632:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c636:	681a      	ldr	r2, [r3, #0]
    c638:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c63c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c640:	781b      	ldrb	r3, [r3, #0]
    c642:	f103 0337 	add.w	r3, r3, #55	; 0x37
    c646:	4413      	add	r3, r2
    c648:	781a      	ldrb	r2, [r3, #0]
    c64a:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c64e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c652:	781b      	ldrb	r3, [r3, #0]
    c654:	4413      	add	r3, r2
    c656:	b2da      	uxtb	r2, r3
    c658:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c65c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c660:	701a      	strb	r2, [r3, #0]
	uip_add_rcv_nxt( 1 );

	/* Parse the TCP MSS option, if present. */
	if( (BUF->tcpoffset & 0xf0) > 0x50 )
	{
		for( c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2; )
    c662:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c666:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c66a:	781b      	ldrb	r3, [r3, #0]
    c66c:	461a      	mov	r2, r3
    c66e:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c672:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c676:	681b      	ldr	r3, [r3, #0]
    c678:	f103 030e 	add.w	r3, r3, #14
    c67c:	f893 3020 	ldrb.w	r3, [r3, #32]
    c680:	ea4f 1313 	mov.w	r3, r3, lsr #4
    c684:	b2db      	uxtb	r3, r3
    c686:	f1a3 0305 	sub.w	r3, r3, #5
    c68a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    c68e:	429a      	cmp	r2, r3
    c690:	f6ff af3f 	blt.w	c512 <uip_process+0xf6a>
    c694:	e004      	b.n	c6a0 <uip_process+0x10f8>
					switch( uip_connr->tcpstateflags & UIP_TS_MASK )
					{
						case UIP_SYN_RCVD:
							/* In the SYN_RCVD state, we should retransmit our
			   				SYNACK. */
							goto tcp_send_synack;
    c696:	bf00      	nop
    c698:	e002      	b.n	c6a0 <uip_process+0x10f8>
		{
			opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
			if( opt == TCP_OPT_END )
			{
				/* End of options. */
				break;
    c69a:	bf00      	nop
    c69c:	e000      	b.n	c6a0 <uip_process+0x10f8>
				can skip past them. */
				if( uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0 )
				{
					/* If the length field is zero, the options are malformed
					and we don't process them further. */
					break;
    c69e:	bf00      	nop
		}
	}

	/* Our response will be a SYNACK. */
	#if UIP_ACTIVE_OPEN
		tcp_send_synack : BUF->flags = TCP_ACK;
    c6a0:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c6a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c6a8:	681b      	ldr	r3, [r3, #0]
    c6aa:	f103 030e 	add.w	r3, r3, #14
    c6ae:	f04f 0210 	mov.w	r2, #16
    c6b2:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
tcp_send_syn:
		BUF->flags |= TCP_SYN;
    c6b6:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c6ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c6be:	681b      	ldr	r3, [r3, #0]
    c6c0:	f103 020e 	add.w	r2, r3, #14
    c6c4:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c6c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c6cc:	681b      	ldr	r3, [r3, #0]
    c6ce:	f103 030e 	add.w	r3, r3, #14
    c6d2:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    c6d6:	f043 0302 	orr.w	r3, r3, #2
    c6da:	b2db      	uxtb	r3, r3
    c6dc:	f882 3021 	strb.w	r3, [r2, #33]	; 0x21
		tcp_send_synack : BUF->flags = TCP_SYN | TCP_ACK;
	#endif /* UIP_ACTIVE_OPEN */

	/* We send out the TCP Maximum Segment Size option with our
	SYNACK. */
	BUF->optdata[ 0 ] = TCP_OPT_MSS;
    c6e0:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c6e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c6e8:	681b      	ldr	r3, [r3, #0]
    c6ea:	f103 030e 	add.w	r3, r3, #14
    c6ee:	f04f 0202 	mov.w	r2, #2
    c6f2:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
	BUF->optdata[ 1 ] = TCP_OPT_MSS_LEN;
    c6f6:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c6fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c6fe:	681b      	ldr	r3, [r3, #0]
    c700:	f103 030e 	add.w	r3, r3, #14
    c704:	f04f 0204 	mov.w	r2, #4
    c708:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
	BUF->optdata[ 2 ] = ( UIP_TCP_MSS ) / 256;
    c70c:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c710:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c714:	681b      	ldr	r3, [r3, #0]
    c716:	f103 030e 	add.w	r3, r3, #14
    c71a:	f04f 0205 	mov.w	r2, #5
    c71e:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
	BUF->optdata[ 3 ] = ( UIP_TCP_MSS ) & 255;
    c722:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c726:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c72a:	681b      	ldr	r3, [r3, #0]
    c72c:	f103 030e 	add.w	r3, r3, #14
    c730:	f06f 026d 	mvn.w	r2, #109	; 0x6d
    c734:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
	uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
    c738:	f64a 4328 	movw	r3, #44072	; 0xac28
    c73c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c740:	f04f 022c 	mov.w	r2, #44	; 0x2c
    c744:	801a      	strh	r2, [r3, #0]
	BUF->tcpoffset = ( (UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4 ) << 4;
    c746:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c74a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c74e:	681b      	ldr	r3, [r3, #0]
    c750:	f103 030e 	add.w	r3, r3, #14
    c754:	f04f 0260 	mov.w	r2, #96	; 0x60
    c758:	f883 2020 	strb.w	r2, [r3, #32]
	goto tcp_send;
    c75c:	f000 bdb5 	b.w	d2ca <uip_process+0x1d22>
			BUF->destport == uip_connr->lport &&
			BUF->srcport == uip_connr->rport &&
			uip_ipaddr_cmp(&BUF->srcipaddr, &uip_connr->ripaddr)
		)
		{
			goto found;
    c760:	bf00      	nop
	BUF->tcpoffset = ( (UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4 ) << 4;
	goto tcp_send;

	/* This label will be jumped to if we found an active connection. */
found:
	uip_conn = uip_connr;
    c762:	f64a 433c 	movw	r3, #44092	; 0xac3c
    c766:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c76a:	601c      	str	r4, [r3, #0]
	uip_flags = 0;
    c76c:	f64a 4334 	movw	r3, #44084	; 0xac34
    c770:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c774:	f04f 0200 	mov.w	r2, #0
    c778:	701a      	strb	r2, [r3, #0]

	/* We do a very naive form of TCP reset processing; we just accept
	any RST and kill our connection. We should in fact check if the
	sequence number of this reset is wihtin our advertised window
	before we accept the reset. */
	if( BUF->flags & TCP_RST )
    c77a:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c77e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c782:	681b      	ldr	r3, [r3, #0]
    c784:	f103 030e 	add.w	r3, r3, #14
    c788:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    c78c:	f003 0304 	and.w	r3, r3, #4
    c790:	2b00      	cmp	r3, #0
    c792:	d00d      	beq.n	c7b0 <uip_process+0x1208>
	{
		uip_connr->tcpstateflags = UIP_CLOSED;
    c794:	f04f 0300 	mov.w	r3, #0
    c798:	7663      	strb	r3, [r4, #25]
		UIP_LOG( "tcp: got reset, aborting connection." );
		uip_flags = UIP_ABORT;
    c79a:	f64a 4334 	movw	r3, #44084	; 0xac34
    c79e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c7a2:	f04f 0220 	mov.w	r2, #32
    c7a6:	701a      	strb	r2, [r3, #0]
		UIP_APPCALL();
    c7a8:	f002 fc04 	bl	efb4 <httpd_appcall>
		goto drop;
    c7ac:	f000 bfc0 	b.w	d730 <uip_process+0x2188>
	}

	/* Calculate the length of the data, if the application has sent
	any data to us. */
	c = ( BUF->tcpoffset >> 4 ) << 2;
    c7b0:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c7b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c7b8:	681b      	ldr	r3, [r3, #0]
    c7ba:	f103 030e 	add.w	r3, r3, #14
    c7be:	f893 3020 	ldrb.w	r3, [r3, #32]
    c7c2:	ea4f 1313 	mov.w	r3, r3, lsr #4
    c7c6:	b2db      	uxtb	r3, r3
    c7c8:	ea4f 0383 	mov.w	r3, r3, lsl #2
    c7cc:	b2da      	uxtb	r2, r3
    c7ce:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c7d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c7d6:	701a      	strb	r2, [r3, #0]

	/* uip_len will contain the length of the actual TCP data. This is
	calculated by subtracing the length of the TCP header (in
	c) and the length of the IP header (20 bytes). */
	uip_len = uip_len - c - UIP_IPH_LEN;
    c7d8:	f64a 4328 	movw	r3, #44072	; 0xac28
    c7dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c7e0:	881a      	ldrh	r2, [r3, #0]
    c7e2:	f642 738e 	movw	r3, #12174	; 0x2f8e
    c7e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c7ea:	781b      	ldrb	r3, [r3, #0]
    c7ec:	ebc3 0302 	rsb	r3, r3, r2
    c7f0:	b29b      	uxth	r3, r3
    c7f2:	f1a3 0314 	sub.w	r3, r3, #20
    c7f6:	b29a      	uxth	r2, r3
    c7f8:	f64a 4328 	movw	r3, #44072	; 0xac28
    c7fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c800:	801a      	strh	r2, [r3, #0]

	/* First, check if the sequence number of the incoming packet is
	what we're expecting next. If not, we send out an ACK with the
	correct numbers in. */
	if( !(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) )
    c802:	7e63      	ldrb	r3, [r4, #25]
    c804:	f003 030f 	and.w	r3, r3, #15
    c808:	2b02      	cmp	r3, #2
    c80a:	d10c      	bne.n	c826 <uip_process+0x127e>
    c80c:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c810:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c814:	681b      	ldr	r3, [r3, #0]
    c816:	f103 030e 	add.w	r3, r3, #14
    c81a:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    c81e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    c822:	2b12      	cmp	r3, #18
    c824:	d043      	beq.n	c8ae <uip_process+0x1306>
	{
		if
		(
			(uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
    c826:	f64a 4328 	movw	r3, #44072	; 0xac28
    c82a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c82e:	881b      	ldrh	r3, [r3, #0]
	what we're expecting next. If not, we send out an ACK with the
	correct numbers in. */
	if( !(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) )
	{
		if
		(
    c830:	2b00      	cmp	r3, #0
    c832:	d10c      	bne.n	c84e <uip_process+0x12a6>
			(uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
    c834:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c838:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c83c:	681b      	ldr	r3, [r3, #0]
    c83e:	f103 030e 	add.w	r3, r3, #14
    c842:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    c846:	f003 0303 	and.w	r3, r3, #3
	what we're expecting next. If not, we send out an ACK with the
	correct numbers in. */
	if( !(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) )
	{
		if
		(
    c84a:	2b00      	cmp	r3, #0
    c84c:	d02f      	beq.n	c8ae <uip_process+0x1306>
			(uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
			(
				BUF->seqno[ 0 ] != uip_connr->rcv_nxt[ 0 ] ||
    c84e:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c852:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c856:	681b      	ldr	r3, [r3, #0]
    c858:	f103 030e 	add.w	r3, r3, #14
    c85c:	7e1a      	ldrb	r2, [r3, #24]
    c85e:	7a23      	ldrb	r3, [r4, #8]
	what we're expecting next. If not, we send out an ACK with the
	correct numbers in. */
	if( !(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) )
	{
		if
		(
    c860:	429a      	cmp	r2, r3
    c862:	f040 8515 	bne.w	d290 <uip_process+0x1ce8>
			(uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
			(
				BUF->seqno[ 0 ] != uip_connr->rcv_nxt[ 0 ] ||
				BUF->seqno[ 1 ] != uip_connr->rcv_nxt[ 1 ] ||
    c866:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c86a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c86e:	681b      	ldr	r3, [r3, #0]
    c870:	f103 030e 	add.w	r3, r3, #14
    c874:	7e5a      	ldrb	r2, [r3, #25]
    c876:	7a63      	ldrb	r3, [r4, #9]
	what we're expecting next. If not, we send out an ACK with the
	correct numbers in. */
	if( !(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) )
	{
		if
		(
    c878:	429a      	cmp	r2, r3
    c87a:	f040 8509 	bne.w	d290 <uip_process+0x1ce8>
			(uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
			(
				BUF->seqno[ 0 ] != uip_connr->rcv_nxt[ 0 ] ||
				BUF->seqno[ 1 ] != uip_connr->rcv_nxt[ 1 ] ||
				BUF->seqno[ 2 ] != uip_connr->rcv_nxt[ 2 ] ||
    c87e:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c882:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c886:	681b      	ldr	r3, [r3, #0]
    c888:	f103 030e 	add.w	r3, r3, #14
    c88c:	7e9a      	ldrb	r2, [r3, #26]
    c88e:	7aa3      	ldrb	r3, [r4, #10]
	what we're expecting next. If not, we send out an ACK with the
	correct numbers in. */
	if( !(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) )
	{
		if
		(
    c890:	429a      	cmp	r2, r3
    c892:	f040 84fd 	bne.w	d290 <uip_process+0x1ce8>
			(uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
			(
				BUF->seqno[ 0 ] != uip_connr->rcv_nxt[ 0 ] ||
				BUF->seqno[ 1 ] != uip_connr->rcv_nxt[ 1 ] ||
				BUF->seqno[ 2 ] != uip_connr->rcv_nxt[ 2 ] ||
				BUF->seqno[ 3 ] != uip_connr->rcv_nxt[ 3 ]
    c896:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c89a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c89e:	681b      	ldr	r3, [r3, #0]
    c8a0:	f103 030e 	add.w	r3, r3, #14
    c8a4:	7eda      	ldrb	r2, [r3, #27]
    c8a6:	7ae3      	ldrb	r3, [r4, #11]
	what we're expecting next. If not, we send out an ACK with the
	correct numbers in. */
	if( !(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) )
	{
		if
		(
    c8a8:	429a      	cmp	r2, r3
    c8aa:	f040 84f1 	bne.w	d290 <uip_process+0x1ce8>

	/* Next, check if the incoming segment acknowledges any outstanding
	data. If so, we update the sequence number, reset the length of
	the outstanding data, calculate RTT estimations, and reset the
	retransmission timer. */
	if( (BUF->flags & TCP_ACK) && uip_outstanding(uip_connr) )
    c8ae:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c8b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c8b6:	681b      	ldr	r3, [r3, #0]
    c8b8:	f103 030e 	add.w	r3, r3, #14
    c8bc:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    c8c0:	f003 0310 	and.w	r3, r3, #16
    c8c4:	2b00      	cmp	r3, #0
    c8c6:	f000 80a1 	beq.w	ca0c <uip_process+0x1464>
    c8ca:	8a23      	ldrh	r3, [r4, #16]
    c8cc:	2b00      	cmp	r3, #0
    c8ce:	f000 809d 	beq.w	ca0c <uip_process+0x1464>
	{
		uip_add32( uip_connr->snd_nxt, uip_connr->len );
    c8d2:	f104 020c 	add.w	r2, r4, #12
    c8d6:	8a23      	ldrh	r3, [r4, #16]
    c8d8:	4610      	mov	r0, r2
    c8da:	4619      	mov	r1, r3
    c8dc:	f7fe fab0 	bl	ae40 <uip_add32>

		if
		(
			BUF->ackno[ 0 ] == uip_acc32[ 0 ] &&
    c8e0:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c8e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c8e8:	681b      	ldr	r3, [r3, #0]
    c8ea:	f103 030e 	add.w	r3, r3, #14
    c8ee:	7f1a      	ldrb	r2, [r3, #28]
    c8f0:	f64a 4330 	movw	r3, #44080	; 0xac30
    c8f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c8f8:	781b      	ldrb	r3, [r3, #0]
	if( (BUF->flags & TCP_ACK) && uip_outstanding(uip_connr) )
	{
		uip_add32( uip_connr->snd_nxt, uip_connr->len );

		if
		(
    c8fa:	429a      	cmp	r2, r3
    c8fc:	f040 8086 	bne.w	ca0c <uip_process+0x1464>
			BUF->ackno[ 0 ] == uip_acc32[ 0 ] &&
			BUF->ackno[ 1 ] == uip_acc32[ 1 ] &&
    c900:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c904:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c908:	681b      	ldr	r3, [r3, #0]
    c90a:	f103 030e 	add.w	r3, r3, #14
    c90e:	7f5a      	ldrb	r2, [r3, #29]
    c910:	f64a 4330 	movw	r3, #44080	; 0xac30
    c914:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c918:	785b      	ldrb	r3, [r3, #1]
	if( (BUF->flags & TCP_ACK) && uip_outstanding(uip_connr) )
	{
		uip_add32( uip_connr->snd_nxt, uip_connr->len );

		if
		(
    c91a:	429a      	cmp	r2, r3
    c91c:	d176      	bne.n	ca0c <uip_process+0x1464>
			BUF->ackno[ 0 ] == uip_acc32[ 0 ] &&
			BUF->ackno[ 1 ] == uip_acc32[ 1 ] &&
			BUF->ackno[ 2 ] == uip_acc32[ 2 ] &&
    c91e:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c922:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c926:	681b      	ldr	r3, [r3, #0]
    c928:	f103 030e 	add.w	r3, r3, #14
    c92c:	7f9a      	ldrb	r2, [r3, #30]
    c92e:	f64a 4330 	movw	r3, #44080	; 0xac30
    c932:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c936:	789b      	ldrb	r3, [r3, #2]
	if( (BUF->flags & TCP_ACK) && uip_outstanding(uip_connr) )
	{
		uip_add32( uip_connr->snd_nxt, uip_connr->len );

		if
		(
    c938:	429a      	cmp	r2, r3
    c93a:	d167      	bne.n	ca0c <uip_process+0x1464>
			BUF->ackno[ 0 ] == uip_acc32[ 0 ] &&
			BUF->ackno[ 1 ] == uip_acc32[ 1 ] &&
			BUF->ackno[ 2 ] == uip_acc32[ 2 ] &&
			BUF->ackno[ 3 ] == uip_acc32[ 3 ]
    c93c:	f240 63a4 	movw	r3, #1700	; 0x6a4
    c940:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c944:	681b      	ldr	r3, [r3, #0]
    c946:	f103 030e 	add.w	r3, r3, #14
    c94a:	7fda      	ldrb	r2, [r3, #31]
    c94c:	f64a 4330 	movw	r3, #44080	; 0xac30
    c950:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c954:	78db      	ldrb	r3, [r3, #3]
	if( (BUF->flags & TCP_ACK) && uip_outstanding(uip_connr) )
	{
		uip_add32( uip_connr->snd_nxt, uip_connr->len );

		if
		(
    c956:	429a      	cmp	r2, r3
    c958:	d158      	bne.n	ca0c <uip_process+0x1464>
			BUF->ackno[ 2 ] == uip_acc32[ 2 ] &&
			BUF->ackno[ 3 ] == uip_acc32[ 3 ]
		)
		{
			/* Update sequence number. */
			uip_connr->snd_nxt[ 0 ] = uip_acc32[ 0 ];
    c95a:	f64a 4330 	movw	r3, #44080	; 0xac30
    c95e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c962:	781b      	ldrb	r3, [r3, #0]
    c964:	7323      	strb	r3, [r4, #12]
			uip_connr->snd_nxt[ 1 ] = uip_acc32[ 1 ];
    c966:	f64a 4330 	movw	r3, #44080	; 0xac30
    c96a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c96e:	785b      	ldrb	r3, [r3, #1]
    c970:	7363      	strb	r3, [r4, #13]
			uip_connr->snd_nxt[ 2 ] = uip_acc32[ 2 ];
    c972:	f64a 4330 	movw	r3, #44080	; 0xac30
    c976:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c97a:	789b      	ldrb	r3, [r3, #2]
    c97c:	73a3      	strb	r3, [r4, #14]
			uip_connr->snd_nxt[ 3 ] = uip_acc32[ 3 ];
    c97e:	f64a 4330 	movw	r3, #44080	; 0xac30
    c982:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c986:	78db      	ldrb	r3, [r3, #3]
    c988:	73e3      	strb	r3, [r4, #15]

			/* Do RTT estimation, unless we have done retransmissions. */
			if( uip_connr->nrtx == 0 )
    c98a:	7ee3      	ldrb	r3, [r4, #27]
    c98c:	2b00      	cmp	r3, #0
    c98e:	d131      	bne.n	c9f4 <uip_process+0x144c>
			{
				signed char m;
				m = uip_connr->rto - uip_connr->timer;
    c990:	7e22      	ldrb	r2, [r4, #24]
    c992:	7ea3      	ldrb	r3, [r4, #26]
    c994:	ebc3 0302 	rsb	r3, r3, r2
    c998:	b2db      	uxtb	r3, r3
    c99a:	73fb      	strb	r3, [r7, #15]

				/* This is taken directly from VJs original code in his paper */
				m = m - ( uip_connr->sa >> 3 );
    c99c:	7bfa      	ldrb	r2, [r7, #15]
    c99e:	7da3      	ldrb	r3, [r4, #22]
    c9a0:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    c9a4:	b2db      	uxtb	r3, r3
    c9a6:	ebc3 0302 	rsb	r3, r3, r2
    c9aa:	b2db      	uxtb	r3, r3
    c9ac:	73fb      	strb	r3, [r7, #15]
				uip_connr->sa += m;
    c9ae:	7da2      	ldrb	r2, [r4, #22]
    c9b0:	7bfb      	ldrb	r3, [r7, #15]
    c9b2:	4413      	add	r3, r2
    c9b4:	b2db      	uxtb	r3, r3
    c9b6:	75a3      	strb	r3, [r4, #22]
				if( m < 0 )
    c9b8:	f997 300f 	ldrsb.w	r3, [r7, #15]
    c9bc:	2b00      	cmp	r3, #0
    c9be:	da03      	bge.n	c9c8 <uip_process+0x1420>
				{
					m = -m;
    c9c0:	7bfb      	ldrb	r3, [r7, #15]
    c9c2:	f1c3 0300 	rsb	r3, r3, #0
    c9c6:	73fb      	strb	r3, [r7, #15]
				}

				m = m - ( uip_connr->sv >> 2 );
    c9c8:	7bfa      	ldrb	r2, [r7, #15]
    c9ca:	7de3      	ldrb	r3, [r4, #23]
    c9cc:	ea4f 0393 	mov.w	r3, r3, lsr #2
    c9d0:	b2db      	uxtb	r3, r3
    c9d2:	ebc3 0302 	rsb	r3, r3, r2
    c9d6:	b2db      	uxtb	r3, r3
    c9d8:	73fb      	strb	r3, [r7, #15]
				uip_connr->sv += m;
    c9da:	7de2      	ldrb	r2, [r4, #23]
    c9dc:	7bfb      	ldrb	r3, [r7, #15]
    c9de:	4413      	add	r3, r2
    c9e0:	b2db      	uxtb	r3, r3
    c9e2:	75e3      	strb	r3, [r4, #23]
				uip_connr->rto = ( uip_connr->sa >> 3 ) + uip_connr->sv;
    c9e4:	7da3      	ldrb	r3, [r4, #22]
    c9e6:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    c9ea:	b2da      	uxtb	r2, r3
    c9ec:	7de3      	ldrb	r3, [r4, #23]
    c9ee:	4413      	add	r3, r2
    c9f0:	b2db      	uxtb	r3, r3
    c9f2:	7623      	strb	r3, [r4, #24]
			}

			/* Set the acknowledged flag. */
			uip_flags = UIP_ACKDATA;
    c9f4:	f64a 4334 	movw	r3, #44084	; 0xac34
    c9f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c9fc:	f04f 0201 	mov.w	r2, #1
    ca00:	701a      	strb	r2, [r3, #0]

			/* Reset the retransmission timer. */
			uip_connr->timer = uip_connr->rto;
    ca02:	7e23      	ldrb	r3, [r4, #24]
    ca04:	76a3      	strb	r3, [r4, #26]

			/* Reset length of outstanding data. */
			uip_connr->len = 0;
    ca06:	f04f 0300 	mov.w	r3, #0
    ca0a:	8223      	strh	r3, [r4, #16]
		}
	}

	/* Do different things depending on in what state the connection is. */
	switch( uip_connr->tcpstateflags & UIP_TS_MASK )
    ca0c:	7e63      	ldrb	r3, [r4, #25]
    ca0e:	f003 030f 	and.w	r3, r3, #15
    ca12:	f103 33ff 	add.w	r3, r3, #4294967295
    ca16:	2b07      	cmp	r3, #7
    ca18:	f200 867b 	bhi.w	d712 <uip_process+0x216a>
    ca1c:	a201      	add	r2, pc, #4	; (adr r2, ca24 <uip_process+0x147c>)
    ca1e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    ca22:	bf00      	nop
    ca24:	0000ca45 	.word	0x0000ca45
    ca28:	0000cac1 	.word	0x0000cac1
    ca2c:	0000cd5b 	.word	0x0000cd5b
    ca30:	0000d13f 	.word	0x0000d13f
    ca34:	0000d1f7 	.word	0x0000d1f7
    ca38:	0000d26b 	.word	0x0000d26b
    ca3c:	0000d28f 	.word	0x0000d28f
    ca40:	0000d10f 	.word	0x0000d10f
		case UIP_SYN_RCVD:
			/* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
	   		we are waiting for an ACK that acknowledges the data we sent
	   		out the last time. Therefore, we want to have the UIP_ACKDATA
	   		flag set. If so, we enter the ESTABLISHED state. */
			if( uip_flags & UIP_ACKDATA )
    ca44:	f64a 4334 	movw	r3, #44084	; 0xac34
    ca48:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ca4c:	781b      	ldrb	r3, [r3, #0]
    ca4e:	f003 0301 	and.w	r3, r3, #1
    ca52:	b2db      	uxtb	r3, r3
    ca54:	2b00      	cmp	r3, #0
    ca56:	f000 865e 	beq.w	d716 <uip_process+0x216e>
			{
				uip_connr->tcpstateflags = UIP_ESTABLISHED;
    ca5a:	f04f 0303 	mov.w	r3, #3
    ca5e:	7663      	strb	r3, [r4, #25]
				uip_flags = UIP_CONNECTED;
    ca60:	f64a 4334 	movw	r3, #44084	; 0xac34
    ca64:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ca68:	f04f 0240 	mov.w	r2, #64	; 0x40
    ca6c:	701a      	strb	r2, [r3, #0]
				uip_connr->len = 0;
    ca6e:	f04f 0300 	mov.w	r3, #0
    ca72:	8223      	strh	r3, [r4, #16]
				if( uip_len > 0 )
    ca74:	f64a 4328 	movw	r3, #44072	; 0xac28
    ca78:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ca7c:	881b      	ldrh	r3, [r3, #0]
    ca7e:	2b00      	cmp	r3, #0
    ca80:	d014      	beq.n	caac <uip_process+0x1504>
				{
					uip_flags |= UIP_NEWDATA;
    ca82:	f64a 4334 	movw	r3, #44084	; 0xac34
    ca86:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ca8a:	781b      	ldrb	r3, [r3, #0]
    ca8c:	f043 0302 	orr.w	r3, r3, #2
    ca90:	b2da      	uxtb	r2, r3
    ca92:	f64a 4334 	movw	r3, #44084	; 0xac34
    ca96:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ca9a:	701a      	strb	r2, [r3, #0]
					uip_add_rcv_nxt( uip_len );
    ca9c:	f64a 4328 	movw	r3, #44072	; 0xac28
    caa0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    caa4:	881b      	ldrh	r3, [r3, #0]
    caa6:	4618      	mov	r0, r3
    caa8:	f7fe fd3c 	bl	b524 <uip_add_rcv_nxt>
				}

				uip_slen = 0;
    caac:	f64c 43b4 	movw	r3, #52404	; 0xccb4
    cab0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cab4:	f04f 0200 	mov.w	r2, #0
    cab8:	801a      	strh	r2, [r3, #0]
				UIP_APPCALL();
    caba:	f002 fa7b 	bl	efb4 <httpd_appcall>
				goto appsend;
    cabe:	e267      	b.n	cf90 <uip_process+0x19e8>
			case UIP_SYN_SENT:
				/* In SYN_SENT, we wait for a SYNACK that is sent in response to
				our SYN. The rcv_nxt is set to sequence number in the SYNACK
				plus one, and we send an ACK. We move into the ESTABLISHED
				state. */
				if( (uip_flags & UIP_ACKDATA) && (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK) )
    cac0:	f64a 4334 	movw	r3, #44084	; 0xac34
    cac4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cac8:	781b      	ldrb	r3, [r3, #0]
    caca:	f003 0301 	and.w	r3, r3, #1
    cace:	b2db      	uxtb	r3, r3
    cad0:	2b00      	cmp	r3, #0
    cad2:	f000 812f 	beq.w	cd34 <uip_process+0x178c>
    cad6:	f240 63a4 	movw	r3, #1700	; 0x6a4
    cada:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cade:	681b      	ldr	r3, [r3, #0]
    cae0:	f103 030e 	add.w	r3, r3, #14
    cae4:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    cae8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    caec:	2b12      	cmp	r3, #18
    caee:	f040 8121 	bne.w	cd34 <uip_process+0x178c>
				{
					/* Parse the TCP MSS option, if present. */
					if( (BUF->tcpoffset & 0xf0) > 0x50 )
    caf2:	f240 63a4 	movw	r3, #1700	; 0x6a4
    caf6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cafa:	681b      	ldr	r3, [r3, #0]
    cafc:	f103 030e 	add.w	r3, r3, #14
    cb00:	f893 3020 	ldrb.w	r3, [r3, #32]
    cb04:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    cb08:	2b50      	cmp	r3, #80	; 0x50
    cb0a:	f340 80cd 	ble.w	cca8 <uip_process+0x1700>
					{
						for( c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2; )
    cb0e:	f642 738e 	movw	r3, #12174	; 0x2f8e
    cb12:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cb16:	f04f 0200 	mov.w	r2, #0
    cb1a:	701a      	strb	r2, [r3, #0]
    cb1c:	e0a7      	b.n	cc6e <uip_process+0x16c6>
						{
							opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
    cb1e:	f240 63a4 	movw	r3, #1700	; 0x6a4
    cb22:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cb26:	681a      	ldr	r2, [r3, #0]
    cb28:	f642 738e 	movw	r3, #12174	; 0x2f8e
    cb2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cb30:	781b      	ldrb	r3, [r3, #0]
    cb32:	f103 0336 	add.w	r3, r3, #54	; 0x36
    cb36:	4413      	add	r3, r2
    cb38:	781a      	ldrb	r2, [r3, #0]
    cb3a:	f642 738f 	movw	r3, #12175	; 0x2f8f
    cb3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cb42:	701a      	strb	r2, [r3, #0]
							if( opt == TCP_OPT_END )
    cb44:	f642 738f 	movw	r3, #12175	; 0x2f8f
    cb48:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cb4c:	781b      	ldrb	r3, [r3, #0]
    cb4e:	2b00      	cmp	r3, #0
    cb50:	f000 80a7 	beq.w	cca2 <uip_process+0x16fa>
							{
								/* End of options. */
								break;
							}
							else if( opt == TCP_OPT_NOOP )
    cb54:	f642 738f 	movw	r3, #12175	; 0x2f8f
    cb58:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cb5c:	781b      	ldrb	r3, [r3, #0]
    cb5e:	2b01      	cmp	r3, #1
    cb60:	d10d      	bne.n	cb7e <uip_process+0x15d6>
							{
								++c;
    cb62:	f642 738e 	movw	r3, #12174	; 0x2f8e
    cb66:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cb6a:	781b      	ldrb	r3, [r3, #0]
    cb6c:	f103 0301 	add.w	r3, r3, #1
    cb70:	b2da      	uxtb	r2, r3
    cb72:	f642 738e 	movw	r3, #12174	; 0x2f8e
    cb76:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cb7a:	701a      	strb	r2, [r3, #0]
    cb7c:	e077      	b.n	cc6e <uip_process+0x16c6>

								/* NOP option. */
							}
							else if( opt == TCP_OPT_MSS && uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN )
    cb7e:	f642 738f 	movw	r3, #12175	; 0x2f8f
    cb82:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cb86:	781b      	ldrb	r3, [r3, #0]
    cb88:	2b02      	cmp	r3, #2
    cb8a:	d146      	bne.n	cc1a <uip_process+0x1672>
    cb8c:	f240 63a4 	movw	r3, #1700	; 0x6a4
    cb90:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cb94:	681a      	ldr	r2, [r3, #0]
    cb96:	f642 738e 	movw	r3, #12174	; 0x2f8e
    cb9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cb9e:	781b      	ldrb	r3, [r3, #0]
    cba0:	f103 0337 	add.w	r3, r3, #55	; 0x37
    cba4:	4413      	add	r3, r2
    cba6:	781b      	ldrb	r3, [r3, #0]
    cba8:	2b04      	cmp	r3, #4
    cbaa:	d136      	bne.n	cc1a <uip_process+0x1672>
							{
								/* An MSS option with the right option length. */
								tmp16 = ( uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8 ) | uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
    cbac:	f240 63a4 	movw	r3, #1700	; 0x6a4
    cbb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cbb4:	681a      	ldr	r2, [r3, #0]
    cbb6:	f642 738e 	movw	r3, #12174	; 0x2f8e
    cbba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cbbe:	781b      	ldrb	r3, [r3, #0]
    cbc0:	f103 0338 	add.w	r3, r3, #56	; 0x38
    cbc4:	4413      	add	r3, r2
    cbc6:	781b      	ldrb	r3, [r3, #0]
    cbc8:	ea4f 2303 	mov.w	r3, r3, lsl #8
    cbcc:	b29a      	uxth	r2, r3
    cbce:	f240 63a4 	movw	r3, #1700	; 0x6a4
    cbd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cbd6:	6819      	ldr	r1, [r3, #0]
    cbd8:	f642 738e 	movw	r3, #12174	; 0x2f8e
    cbdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cbe0:	781b      	ldrb	r3, [r3, #0]
    cbe2:	f103 0339 	add.w	r3, r3, #57	; 0x39
    cbe6:	440b      	add	r3, r1
    cbe8:	781b      	ldrb	r3, [r3, #0]
    cbea:	ea42 0303 	orr.w	r3, r2, r3
    cbee:	b29b      	uxth	r3, r3
    cbf0:	b29a      	uxth	r2, r3
    cbf2:	f642 7390 	movw	r3, #12176	; 0x2f90
    cbf6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cbfa:	801a      	strh	r2, [r3, #0]
								uip_connr->initialmss = uip_connr->mss = tmp16 > UIP_TCP_MSS ? UIP_TCP_MSS : tmp16;
    cbfc:	f642 7390 	movw	r3, #12176	; 0x2f90
    cc00:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cc04:	881a      	ldrh	r2, [r3, #0]
    cc06:	f240 5392 	movw	r3, #1426	; 0x592
    cc0a:	429a      	cmp	r2, r3
    cc0c:	bf38      	it	cc
    cc0e:	4613      	movcc	r3, r2
    cc10:	b29b      	uxth	r3, r3
    cc12:	8263      	strh	r3, [r4, #18]
    cc14:	8a63      	ldrh	r3, [r4, #18]
    cc16:	82a3      	strh	r3, [r4, #20]

								/* And we are done processing options. */
								break;
    cc18:	e046      	b.n	cca8 <uip_process+0x1700>
							}
							else
							{
								/* All other options have a length field, so that we easily
								can skip past them. */
								if( uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0 )
    cc1a:	f240 63a4 	movw	r3, #1700	; 0x6a4
    cc1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cc22:	681a      	ldr	r2, [r3, #0]
    cc24:	f642 738e 	movw	r3, #12174	; 0x2f8e
    cc28:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cc2c:	781b      	ldrb	r3, [r3, #0]
    cc2e:	f103 0337 	add.w	r3, r3, #55	; 0x37
    cc32:	4413      	add	r3, r2
    cc34:	781b      	ldrb	r3, [r3, #0]
    cc36:	2b00      	cmp	r3, #0
    cc38:	d035      	beq.n	cca6 <uip_process+0x16fe>
									/* If the length field is zero, the options are malformed
									and we don't process them further. */
									break;
								}

								c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    cc3a:	f240 63a4 	movw	r3, #1700	; 0x6a4
    cc3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cc42:	681a      	ldr	r2, [r3, #0]
    cc44:	f642 738e 	movw	r3, #12174	; 0x2f8e
    cc48:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cc4c:	781b      	ldrb	r3, [r3, #0]
    cc4e:	f103 0337 	add.w	r3, r3, #55	; 0x37
    cc52:	4413      	add	r3, r2
    cc54:	781a      	ldrb	r2, [r3, #0]
    cc56:	f642 738e 	movw	r3, #12174	; 0x2f8e
    cc5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cc5e:	781b      	ldrb	r3, [r3, #0]
    cc60:	4413      	add	r3, r2
    cc62:	b2da      	uxtb	r2, r3
    cc64:	f642 738e 	movw	r3, #12174	; 0x2f8e
    cc68:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cc6c:	701a      	strb	r2, [r3, #0]
				if( (uip_flags & UIP_ACKDATA) && (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK) )
				{
					/* Parse the TCP MSS option, if present. */
					if( (BUF->tcpoffset & 0xf0) > 0x50 )
					{
						for( c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2; )
    cc6e:	f642 738e 	movw	r3, #12174	; 0x2f8e
    cc72:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cc76:	781b      	ldrb	r3, [r3, #0]
    cc78:	461a      	mov	r2, r3
    cc7a:	f240 63a4 	movw	r3, #1700	; 0x6a4
    cc7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cc82:	681b      	ldr	r3, [r3, #0]
    cc84:	f103 030e 	add.w	r3, r3, #14
    cc88:	f893 3020 	ldrb.w	r3, [r3, #32]
    cc8c:	ea4f 1313 	mov.w	r3, r3, lsr #4
    cc90:	b2db      	uxtb	r3, r3
    cc92:	f1a3 0305 	sub.w	r3, r3, #5
    cc96:	ea4f 0383 	mov.w	r3, r3, lsl #2
    cc9a:	429a      	cmp	r2, r3
    cc9c:	f6ff af3f 	blt.w	cb1e <uip_process+0x1576>
    cca0:	e002      	b.n	cca8 <uip_process+0x1700>
						{
							opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
							if( opt == TCP_OPT_END )
							{
								/* End of options. */
								break;
    cca2:	bf00      	nop
    cca4:	e000      	b.n	cca8 <uip_process+0x1700>
								can skip past them. */
								if( uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0 )
								{
									/* If the length field is zero, the options are malformed
									and we don't process them further. */
									break;
    cca6:	bf00      	nop
								c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
							}
						}
					}

					uip_connr->tcpstateflags = UIP_ESTABLISHED;
    cca8:	f04f 0303 	mov.w	r3, #3
    ccac:	7663      	strb	r3, [r4, #25]
					uip_connr->rcv_nxt[ 0 ] = BUF->seqno[ 0 ];
    ccae:	f240 63a4 	movw	r3, #1700	; 0x6a4
    ccb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ccb6:	681b      	ldr	r3, [r3, #0]
    ccb8:	f103 030e 	add.w	r3, r3, #14
    ccbc:	7e1b      	ldrb	r3, [r3, #24]
    ccbe:	7223      	strb	r3, [r4, #8]
					uip_connr->rcv_nxt[ 1 ] = BUF->seqno[ 1 ];
    ccc0:	f240 63a4 	movw	r3, #1700	; 0x6a4
    ccc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ccc8:	681b      	ldr	r3, [r3, #0]
    ccca:	f103 030e 	add.w	r3, r3, #14
    ccce:	7e5b      	ldrb	r3, [r3, #25]
    ccd0:	7263      	strb	r3, [r4, #9]
					uip_connr->rcv_nxt[ 2 ] = BUF->seqno[ 2 ];
    ccd2:	f240 63a4 	movw	r3, #1700	; 0x6a4
    ccd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ccda:	681b      	ldr	r3, [r3, #0]
    ccdc:	f103 030e 	add.w	r3, r3, #14
    cce0:	7e9b      	ldrb	r3, [r3, #26]
    cce2:	72a3      	strb	r3, [r4, #10]
					uip_connr->rcv_nxt[ 3 ] = BUF->seqno[ 3 ];
    cce4:	f240 63a4 	movw	r3, #1700	; 0x6a4
    cce8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ccec:	681b      	ldr	r3, [r3, #0]
    ccee:	f103 030e 	add.w	r3, r3, #14
    ccf2:	7edb      	ldrb	r3, [r3, #27]
    ccf4:	72e3      	strb	r3, [r4, #11]
					uip_add_rcv_nxt( 1 );
    ccf6:	f04f 0001 	mov.w	r0, #1
    ccfa:	f7fe fc13 	bl	b524 <uip_add_rcv_nxt>
					uip_flags = UIP_CONNECTED | UIP_NEWDATA;
    ccfe:	f64a 4334 	movw	r3, #44084	; 0xac34
    cd02:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cd06:	f04f 0242 	mov.w	r2, #66	; 0x42
    cd0a:	701a      	strb	r2, [r3, #0]
					uip_connr->len = 0;
    cd0c:	f04f 0300 	mov.w	r3, #0
    cd10:	8223      	strh	r3, [r4, #16]
					uip_len = 0;
    cd12:	f64a 4328 	movw	r3, #44072	; 0xac28
    cd16:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cd1a:	f04f 0200 	mov.w	r2, #0
    cd1e:	801a      	strh	r2, [r3, #0]
					uip_slen = 0;
    cd20:	f64c 43b4 	movw	r3, #52404	; 0xccb4
    cd24:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cd28:	f04f 0200 	mov.w	r2, #0
    cd2c:	801a      	strh	r2, [r3, #0]
					UIP_APPCALL();
    cd2e:	f002 f941 	bl	efb4 <httpd_appcall>
					goto appsend;
    cd32:	e12d      	b.n	cf90 <uip_process+0x19e8>
				}

				/* Inform the application that the connection failed */
				uip_flags = UIP_ABORT;
    cd34:	f64a 4334 	movw	r3, #44084	; 0xac34
    cd38:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cd3c:	f04f 0220 	mov.w	r2, #32
    cd40:	701a      	strb	r2, [r3, #0]
				UIP_APPCALL();
    cd42:	f002 f937 	bl	efb4 <httpd_appcall>

				/* The connection is closed after we send the RST */
				uip_conn->tcpstateflags = UIP_CLOSED;
    cd46:	f64a 433c 	movw	r3, #44092	; 0xac3c
    cd4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cd4e:	681b      	ldr	r3, [r3, #0]
    cd50:	f04f 0200 	mov.w	r2, #0
    cd54:	765a      	strb	r2, [r3, #25]
				goto reset;
    cd56:	f7ff b8bc 	b.w	bed2 <uip_process+0x92a>

			If the incoming packet is a FIN, we should close the connection on
			this side as well, and we send out a FIN and enter the LAST_ACK
			state. We require that there is no outstanding data; otherwise the
			sequence numbers will be screwed up. */
			if( BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED) )
    cd5a:	f240 63a4 	movw	r3, #1700	; 0x6a4
    cd5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cd62:	681b      	ldr	r3, [r3, #0]
    cd64:	f103 030e 	add.w	r3, r3, #14
    cd68:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    cd6c:	f003 0301 	and.w	r3, r3, #1
    cd70:	b2db      	uxtb	r3, r3
    cd72:	2b00      	cmp	r3, #0
    cd74:	d04d      	beq.n	ce12 <uip_process+0x186a>
    cd76:	7e63      	ldrb	r3, [r4, #25]
    cd78:	f003 0310 	and.w	r3, r3, #16
    cd7c:	2b00      	cmp	r3, #0
    cd7e:	d148      	bne.n	ce12 <uip_process+0x186a>
			{
				if( uip_outstanding(uip_connr) )
    cd80:	8a23      	ldrh	r3, [r4, #16]
    cd82:	2b00      	cmp	r3, #0
    cd84:	f040 84c9 	bne.w	d71a <uip_process+0x2172>
				{
					goto drop;
				}

				uip_add_rcv_nxt( 1 + uip_len );
    cd88:	f64a 4328 	movw	r3, #44072	; 0xac28
    cd8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cd90:	881b      	ldrh	r3, [r3, #0]
    cd92:	f103 0301 	add.w	r3, r3, #1
    cd96:	b29b      	uxth	r3, r3
    cd98:	4618      	mov	r0, r3
    cd9a:	f7fe fbc3 	bl	b524 <uip_add_rcv_nxt>
				uip_flags |= UIP_CLOSE;
    cd9e:	f64a 4334 	movw	r3, #44084	; 0xac34
    cda2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cda6:	781b      	ldrb	r3, [r3, #0]
    cda8:	f043 0310 	orr.w	r3, r3, #16
    cdac:	b2da      	uxtb	r2, r3
    cdae:	f64a 4334 	movw	r3, #44084	; 0xac34
    cdb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cdb6:	701a      	strb	r2, [r3, #0]
				if( uip_len > 0 )
    cdb8:	f64a 4328 	movw	r3, #44072	; 0xac28
    cdbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cdc0:	881b      	ldrh	r3, [r3, #0]
    cdc2:	2b00      	cmp	r3, #0
    cdc4:	d00c      	beq.n	cde0 <uip_process+0x1838>
				{
					uip_flags |= UIP_NEWDATA;
    cdc6:	f64a 4334 	movw	r3, #44084	; 0xac34
    cdca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cdce:	781b      	ldrb	r3, [r3, #0]
    cdd0:	f043 0302 	orr.w	r3, r3, #2
    cdd4:	b2da      	uxtb	r2, r3
    cdd6:	f64a 4334 	movw	r3, #44084	; 0xac34
    cdda:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cdde:	701a      	strb	r2, [r3, #0]
				}

				UIP_APPCALL();
    cde0:	f002 f8e8 	bl	efb4 <httpd_appcall>
				uip_connr->len = 1;
    cde4:	f04f 0301 	mov.w	r3, #1
    cde8:	8223      	strh	r3, [r4, #16]
				uip_connr->tcpstateflags = UIP_LAST_ACK;
    cdea:	f04f 0308 	mov.w	r3, #8
    cdee:	7663      	strb	r3, [r4, #25]
				uip_connr->nrtx = 0;
    cdf0:	f04f 0300 	mov.w	r3, #0
    cdf4:	76e3      	strb	r3, [r4, #27]
    cdf6:	e000      	b.n	cdfa <uip_process+0x1852>

						case UIP_FIN_WAIT_1:
						case UIP_CLOSING:
						case UIP_LAST_ACK:
							/* In all these states we should retransmit a FINACK. */
							goto tcp_send_finack;
    cdf8:	bf00      	nop
				UIP_APPCALL();
				uip_connr->len = 1;
				uip_connr->tcpstateflags = UIP_LAST_ACK;
				uip_connr->nrtx = 0;
	tcp_send_finack:
				BUF->flags = TCP_FIN | TCP_ACK;
    cdfa:	f240 63a4 	movw	r3, #1700	; 0x6a4
    cdfe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ce02:	681b      	ldr	r3, [r3, #0]
    ce04:	f103 030e 	add.w	r3, r3, #14
    ce08:	f04f 0211 	mov.w	r2, #17
    ce0c:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
				goto tcp_send_nodata;
    ce10:	e249      	b.n	d2a6 <uip_process+0x1cfe>
			}

			/* Check the URG flag. If this is set, the segment carries urgent
			data that we must pass to the application. */
			if( (BUF->flags & TCP_URG) != 0 )
    ce12:	f240 63a4 	movw	r3, #1700	; 0x6a4
    ce16:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ce1a:	681b      	ldr	r3, [r3, #0]
    ce1c:	f103 030e 	add.w	r3, r3, #14
    ce20:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    ce24:	f003 0320 	and.w	r3, r3, #32
    ce28:	2b00      	cmp	r3, #0
    ce2a:	d046      	beq.n	ceba <uip_process+0x1912>
					}
					else
					{
					uip_urglen = 0;
				#else /* UIP_URGDATA > 0 */
					uip_appdata = ( ( char * ) uip_appdata ) + ( (BUF->urgp[ 0 ] << 8) | BUF->urgp[ 1 ] );
    ce2c:	f64a 4338 	movw	r3, #44088	; 0xac38
    ce30:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ce34:	681a      	ldr	r2, [r3, #0]
    ce36:	f240 63a4 	movw	r3, #1700	; 0x6a4
    ce3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ce3e:	681b      	ldr	r3, [r3, #0]
    ce40:	f103 030e 	add.w	r3, r3, #14
    ce44:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
    ce48:	ea4f 2103 	mov.w	r1, r3, lsl #8
    ce4c:	f240 63a4 	movw	r3, #1700	; 0x6a4
    ce50:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ce54:	681b      	ldr	r3, [r3, #0]
    ce56:	f103 030e 	add.w	r3, r3, #14
    ce5a:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
    ce5e:	ea41 0303 	orr.w	r3, r1, r3
    ce62:	441a      	add	r2, r3
    ce64:	f64a 4338 	movw	r3, #44088	; 0xac38
    ce68:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ce6c:	601a      	str	r2, [r3, #0]
					uip_len -= ( BUF->urgp[ 0 ] << 8 ) | BUF->urgp[ 1 ];
    ce6e:	f64a 4328 	movw	r3, #44072	; 0xac28
    ce72:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ce76:	881a      	ldrh	r2, [r3, #0]
    ce78:	f240 63a4 	movw	r3, #1700	; 0x6a4
    ce7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ce80:	681b      	ldr	r3, [r3, #0]
    ce82:	f103 030e 	add.w	r3, r3, #14
    ce86:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
    ce8a:	ea4f 2303 	mov.w	r3, r3, lsl #8
    ce8e:	b299      	uxth	r1, r3
    ce90:	f240 63a4 	movw	r3, #1700	; 0x6a4
    ce94:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ce98:	681b      	ldr	r3, [r3, #0]
    ce9a:	f103 030e 	add.w	r3, r3, #14
    ce9e:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
    cea2:	ea41 0303 	orr.w	r3, r1, r3
    cea6:	b29b      	uxth	r3, r3
    cea8:	b29b      	uxth	r3, r3
    ceaa:	ebc3 0302 	rsb	r3, r3, r2
    ceae:	b29a      	uxth	r2, r3
    ceb0:	f64a 4328 	movw	r3, #44072	; 0xac28
    ceb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ceb8:	801a      	strh	r2, [r3, #0]
			/* If uip_len > 0 we have TCP data in the packet, and we flag this
			by setting the UIP_NEWDATA flag and update the sequence number
			we acknowledge. If the application has stopped the dataflow
			using uip_stop(), we must not accept any data packets from the
			remote host. */
			if( uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED) )
    ceba:	f64a 4328 	movw	r3, #44072	; 0xac28
    cebe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cec2:	881b      	ldrh	r3, [r3, #0]
    cec4:	2b00      	cmp	r3, #0
    cec6:	d019      	beq.n	cefc <uip_process+0x1954>
    cec8:	7e63      	ldrb	r3, [r4, #25]
    ceca:	f003 0310 	and.w	r3, r3, #16
    cece:	2b00      	cmp	r3, #0
    ced0:	d114      	bne.n	cefc <uip_process+0x1954>
			{
				uip_flags |= UIP_NEWDATA;
    ced2:	f64a 4334 	movw	r3, #44084	; 0xac34
    ced6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ceda:	781b      	ldrb	r3, [r3, #0]
    cedc:	f043 0302 	orr.w	r3, r3, #2
    cee0:	b2da      	uxtb	r2, r3
    cee2:	f64a 4334 	movw	r3, #44084	; 0xac34
    cee6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ceea:	701a      	strb	r2, [r3, #0]
				uip_add_rcv_nxt( uip_len );
    ceec:	f64a 4328 	movw	r3, #44072	; 0xac28
    cef0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cef4:	881b      	ldrh	r3, [r3, #0]
    cef6:	4618      	mov	r0, r3
    cef8:	f7fe fb14 	bl	b524 <uip_add_rcv_nxt>
			the initial MSS so that the application will send an entire MSS
			of data. This data will not be acknowledged by the receiver,
			and the application will retransmit it. This is called the
			"persistent timer" and uses the retransmission mechanim.
			*/
			tmp16 = ( (u16_t) BUF->wnd[ 0 ] << 8 ) + ( u16_t ) BUF->wnd[ 1 ];
    cefc:	f240 63a4 	movw	r3, #1700	; 0x6a4
    cf00:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cf04:	681b      	ldr	r3, [r3, #0]
    cf06:	f103 030e 	add.w	r3, r3, #14
    cf0a:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
    cf0e:	ea4f 2303 	mov.w	r3, r3, lsl #8
    cf12:	b29a      	uxth	r2, r3
    cf14:	f240 63a4 	movw	r3, #1700	; 0x6a4
    cf18:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cf1c:	681b      	ldr	r3, [r3, #0]
    cf1e:	f103 030e 	add.w	r3, r3, #14
    cf22:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
    cf26:	4413      	add	r3, r2
    cf28:	b29a      	uxth	r2, r3
    cf2a:	f642 7390 	movw	r3, #12176	; 0x2f90
    cf2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cf32:	801a      	strh	r2, [r3, #0]
			if( tmp16 > uip_connr->initialmss || tmp16 == 0 )
    cf34:	8aa2      	ldrh	r2, [r4, #20]
    cf36:	f642 7390 	movw	r3, #12176	; 0x2f90
    cf3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cf3e:	881b      	ldrh	r3, [r3, #0]
    cf40:	429a      	cmp	r2, r3
    cf42:	d306      	bcc.n	cf52 <uip_process+0x19aa>
    cf44:	f642 7390 	movw	r3, #12176	; 0x2f90
    cf48:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cf4c:	881b      	ldrh	r3, [r3, #0]
    cf4e:	2b00      	cmp	r3, #0
    cf50:	d105      	bne.n	cf5e <uip_process+0x19b6>
			{
				tmp16 = uip_connr->initialmss;
    cf52:	8aa2      	ldrh	r2, [r4, #20]
    cf54:	f642 7390 	movw	r3, #12176	; 0x2f90
    cf58:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cf5c:	801a      	strh	r2, [r3, #0]
			}

			uip_connr->mss = tmp16;
    cf5e:	f642 7390 	movw	r3, #12176	; 0x2f90
    cf62:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cf66:	881b      	ldrh	r3, [r3, #0]
    cf68:	8263      	strh	r3, [r4, #18]

			If the application wishes to send any data, this data should be
			put into the uip_appdata and the length of the data should be
			put into uip_len. If the application don't have any data to
			send, uip_len must be set to 0. */
			if( uip_flags & (UIP_NEWDATA | UIP_ACKDATA) )
    cf6a:	f64a 4334 	movw	r3, #44084	; 0xac34
    cf6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cf72:	781b      	ldrb	r3, [r3, #0]
    cf74:	f003 0303 	and.w	r3, r3, #3
    cf78:	2b00      	cmp	r3, #0
    cf7a:	f000 83d0 	beq.w	d71e <uip_process+0x2176>
			{
				uip_slen = 0;
    cf7e:	f64c 43b4 	movw	r3, #52404	; 0xccb4
    cf82:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cf86:	f04f 0200 	mov.w	r2, #0
    cf8a:	801a      	strh	r2, [r3, #0]
				UIP_APPCALL();
    cf8c:	f002 f812 	bl	efb4 <httpd_appcall>

appsend:
				if( uip_flags & UIP_ABORT )
    cf90:	f64a 4334 	movw	r3, #44084	; 0xac34
    cf94:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cf98:	781b      	ldrb	r3, [r3, #0]
    cf9a:	f003 0320 	and.w	r3, r3, #32
    cf9e:	2b00      	cmp	r3, #0
    cfa0:	d015      	beq.n	cfce <uip_process+0x1a26>
				{
					uip_slen = 0;
    cfa2:	f64c 43b4 	movw	r3, #52404	; 0xccb4
    cfa6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cfaa:	f04f 0200 	mov.w	r2, #0
    cfae:	801a      	strh	r2, [r3, #0]
					uip_connr->tcpstateflags = UIP_CLOSED;
    cfb0:	f04f 0300 	mov.w	r3, #0
    cfb4:	7663      	strb	r3, [r4, #25]
					BUF->flags = TCP_RST | TCP_ACK;
    cfb6:	f240 63a4 	movw	r3, #1700	; 0x6a4
    cfba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cfbe:	681b      	ldr	r3, [r3, #0]
    cfc0:	f103 030e 	add.w	r3, r3, #14
    cfc4:	f04f 0214 	mov.w	r2, #20
    cfc8:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
					goto tcp_send_nodata;
    cfcc:	e16b      	b.n	d2a6 <uip_process+0x1cfe>
				}

				if( uip_flags & UIP_CLOSE )
    cfce:	f64a 4334 	movw	r3, #44084	; 0xac34
    cfd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cfd6:	781b      	ldrb	r3, [r3, #0]
    cfd8:	f003 0310 	and.w	r3, r3, #16
    cfdc:	2b00      	cmp	r3, #0
    cfde:	d01b      	beq.n	d018 <uip_process+0x1a70>
				{
					uip_slen = 0;
    cfe0:	f64c 43b4 	movw	r3, #52404	; 0xccb4
    cfe4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cfe8:	f04f 0200 	mov.w	r2, #0
    cfec:	801a      	strh	r2, [r3, #0]
					uip_connr->len = 1;
    cfee:	f04f 0301 	mov.w	r3, #1
    cff2:	8223      	strh	r3, [r4, #16]
					uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
    cff4:	f04f 0304 	mov.w	r3, #4
    cff8:	7663      	strb	r3, [r4, #25]
					uip_connr->nrtx = 0;
    cffa:	f04f 0300 	mov.w	r3, #0
    cffe:	76e3      	strb	r3, [r4, #27]
					BUF->flags = TCP_FIN | TCP_ACK;
    d000:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d004:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d008:	681b      	ldr	r3, [r3, #0]
    d00a:	f103 030e 	add.w	r3, r3, #14
    d00e:	f04f 0211 	mov.w	r2, #17
    d012:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
					goto tcp_send_nodata;
    d016:	e146      	b.n	d2a6 <uip_process+0x1cfe>
				}

				/* If uip_slen > 0, the application has data to be sent. */
				if( uip_slen > 0 )
    d018:	f64c 43b4 	movw	r3, #52404	; 0xccb4
    d01c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d020:	881b      	ldrh	r3, [r3, #0]
    d022:	2b00      	cmp	r3, #0
    d024:	d02a      	beq.n	d07c <uip_process+0x1ad4>
				{
					/* If the connection has acknowledged data, the contents of
	   				the ->len variable should be discarded. */
					if( (uip_flags & UIP_ACKDATA) != 0 )
    d026:	f64a 4334 	movw	r3, #44084	; 0xac34
    d02a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d02e:	781b      	ldrb	r3, [r3, #0]
    d030:	f003 0301 	and.w	r3, r3, #1
    d034:	b2db      	uxtb	r3, r3
    d036:	2b00      	cmp	r3, #0
    d038:	d002      	beq.n	d040 <uip_process+0x1a98>
					{
						uip_connr->len = 0;
    d03a:	f04f 0300 	mov.w	r3, #0
    d03e:	8223      	strh	r3, [r4, #16]
					}

					/* If the ->len variable is non-zero the connection has
	   				already data in transit and cannot send anymore right
	   				now. */
					if( uip_connr->len == 0 )
    d040:	8a23      	ldrh	r3, [r4, #16]
    d042:	2b00      	cmp	r3, #0
    d044:	d114      	bne.n	d070 <uip_process+0x1ac8>
					{
						/* The application cannot send more than what is allowed by
		 				the mss (the minumum of the MSS and the available
		 				window). */
						if( uip_slen > uip_connr->mss )
    d046:	8a62      	ldrh	r2, [r4, #18]
    d048:	f64c 43b4 	movw	r3, #52404	; 0xccb4
    d04c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d050:	881b      	ldrh	r3, [r3, #0]
    d052:	429a      	cmp	r2, r3
    d054:	d205      	bcs.n	d062 <uip_process+0x1aba>
						{
							uip_slen = uip_connr->mss;
    d056:	8a62      	ldrh	r2, [r4, #18]
    d058:	f64c 43b4 	movw	r3, #52404	; 0xccb4
    d05c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d060:	801a      	strh	r2, [r3, #0]
						}

						/* Remember how much data we send out now so that we know
		 				when everything has been acknowledged. */
						uip_connr->len = uip_slen;
    d062:	f64c 43b4 	movw	r3, #52404	; 0xccb4
    d066:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d06a:	881b      	ldrh	r3, [r3, #0]
    d06c:	8223      	strh	r3, [r4, #16]
    d06e:	e005      	b.n	d07c <uip_process+0x1ad4>
					else
					{
						/* If the application already had unacknowledged data, we
		 				make sure that the application does not send (i.e.,
		 				retransmit) out more than it previously sent out. */
						uip_slen = uip_connr->len;
    d070:	8a22      	ldrh	r2, [r4, #16]
    d072:	f64c 43b4 	movw	r3, #52404	; 0xccb4
    d076:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d07a:	801a      	strh	r2, [r3, #0]
					}
				}

				uip_connr->nrtx = 0;
    d07c:	f04f 0300 	mov.w	r3, #0
    d080:	76e3      	strb	r3, [r4, #27]
apprexmit:
				uip_appdata = uip_sappdata;
    d082:	f64a 432c 	movw	r3, #44076	; 0xac2c
    d086:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d08a:	681a      	ldr	r2, [r3, #0]
    d08c:	f64a 4338 	movw	r3, #44088	; 0xac38
    d090:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d094:	601a      	str	r2, [r3, #0]

				/* If the application has data to be sent, or if the incoming
		 		packet had new data in it, we must send out a packet. */
				if( uip_slen > 0 && uip_connr->len > 0 )
    d096:	f64c 43b4 	movw	r3, #52404	; 0xccb4
    d09a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d09e:	881b      	ldrh	r3, [r3, #0]
    d0a0:	2b00      	cmp	r3, #0
    d0a2:	d017      	beq.n	d0d4 <uip_process+0x1b2c>
    d0a4:	8a23      	ldrh	r3, [r4, #16]
    d0a6:	2b00      	cmp	r3, #0
    d0a8:	d014      	beq.n	d0d4 <uip_process+0x1b2c>
				{
					/* Add the length of the IP and TCP headers. */
					uip_len = uip_connr->len + UIP_TCPIP_HLEN;
    d0aa:	8a23      	ldrh	r3, [r4, #16]
    d0ac:	f103 0328 	add.w	r3, r3, #40	; 0x28
    d0b0:	b29a      	uxth	r2, r3
    d0b2:	f64a 4328 	movw	r3, #44072	; 0xac28
    d0b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d0ba:	801a      	strh	r2, [r3, #0]

					/* We always set the ACK flag in response packets. */
					BUF->flags = TCP_ACK | TCP_PSH;
    d0bc:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d0c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d0c4:	681b      	ldr	r3, [r3, #0]
    d0c6:	f103 030e 	add.w	r3, r3, #14
    d0ca:	f04f 0218 	mov.w	r2, #24
    d0ce:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

					/* Send the packet. */
					goto tcp_send_noopts;
    d0d2:	e0ef      	b.n	d2b4 <uip_process+0x1d0c>
				}

				/* If there is no data to send, just send out a pure ACK if
				there is newdata. */
				if( uip_flags & UIP_NEWDATA )
    d0d4:	f64a 4334 	movw	r3, #44084	; 0xac34
    d0d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d0dc:	781b      	ldrb	r3, [r3, #0]
    d0de:	f003 0302 	and.w	r3, r3, #2
    d0e2:	2b00      	cmp	r3, #0
    d0e4:	f000 831d 	beq.w	d722 <uip_process+0x217a>
				{
					uip_len = UIP_TCPIP_HLEN;
    d0e8:	f64a 4328 	movw	r3, #44072	; 0xac28
    d0ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d0f0:	f04f 0228 	mov.w	r2, #40	; 0x28
    d0f4:	801a      	strh	r2, [r3, #0]
					BUF->flags = TCP_ACK;
    d0f6:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d0fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d0fe:	681b      	ldr	r3, [r3, #0]
    d100:	f103 030e 	add.w	r3, r3, #14
    d104:	f04f 0210 	mov.w	r2, #16
    d108:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
					goto tcp_send_noopts;
    d10c:	e0d2      	b.n	d2b4 <uip_process+0x1d0c>
			goto drop;

		case UIP_LAST_ACK:
			/* We can close this connection if the peer has acknowledged our
			FIN. This is indicated by the UIP_ACKDATA flag. */
			if( uip_flags & UIP_ACKDATA )
    d10e:	f64a 4334 	movw	r3, #44084	; 0xac34
    d112:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d116:	781b      	ldrb	r3, [r3, #0]
    d118:	f003 0301 	and.w	r3, r3, #1
    d11c:	b2db      	uxtb	r3, r3
    d11e:	2b00      	cmp	r3, #0
    d120:	d00b      	beq.n	d13a <uip_process+0x1b92>
			{
				uip_connr->tcpstateflags = UIP_CLOSED;
    d122:	f04f 0300 	mov.w	r3, #0
    d126:	7663      	strb	r3, [r4, #25]
				uip_flags = UIP_CLOSE;
    d128:	f64a 4334 	movw	r3, #44084	; 0xac34
    d12c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d130:	f04f 0210 	mov.w	r2, #16
    d134:	701a      	strb	r2, [r3, #0]
				UIP_APPCALL();
    d136:	f001 ff3d 	bl	efb4 <httpd_appcall>
			}

			break;
    d13a:	bf00      	nop
				uip_connr->tcpstateflags = UIP_TIME_WAIT;
				uip_connr->timer = 0;
			}
	}

	goto drop;
    d13c:	e2f8      	b.n	d730 <uip_process+0x2188>

		case UIP_FIN_WAIT_1:
			/* The application has closed the connection, but the remote host
			hasn't closed its end yet. Thus we do nothing but wait for a
			FIN from the other side. */
			if( uip_len > 0 )
    d13e:	f64a 4328 	movw	r3, #44072	; 0xac28
    d142:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d146:	881b      	ldrh	r3, [r3, #0]
    d148:	2b00      	cmp	r3, #0
    d14a:	d007      	beq.n	d15c <uip_process+0x1bb4>
			{
				uip_add_rcv_nxt( uip_len );
    d14c:	f64a 4328 	movw	r3, #44072	; 0xac28
    d150:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d154:	881b      	ldrh	r3, [r3, #0]
    d156:	4618      	mov	r0, r3
    d158:	f7fe f9e4 	bl	b524 <uip_add_rcv_nxt>
			}

			if( BUF->flags & TCP_FIN )
    d15c:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d160:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d164:	681b      	ldr	r3, [r3, #0]
    d166:	f103 030e 	add.w	r3, r3, #14
    d16a:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    d16e:	f003 0301 	and.w	r3, r3, #1
    d172:	b2db      	uxtb	r3, r3
    d174:	2b00      	cmp	r3, #0
    d176:	d024      	beq.n	d1c2 <uip_process+0x1c1a>
			{
				if( uip_flags & UIP_ACKDATA )
    d178:	f64a 4334 	movw	r3, #44084	; 0xac34
    d17c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d180:	781b      	ldrb	r3, [r3, #0]
    d182:	f003 0301 	and.w	r3, r3, #1
    d186:	b2db      	uxtb	r3, r3
    d188:	2b00      	cmp	r3, #0
    d18a:	d009      	beq.n	d1a0 <uip_process+0x1bf8>
				{
					uip_connr->tcpstateflags = UIP_TIME_WAIT;
    d18c:	f04f 0307 	mov.w	r3, #7
    d190:	7663      	strb	r3, [r4, #25]
					uip_connr->timer = 0;
    d192:	f04f 0300 	mov.w	r3, #0
    d196:	76a3      	strb	r3, [r4, #26]
					uip_connr->len = 0;
    d198:	f04f 0300 	mov.w	r3, #0
    d19c:	8223      	strh	r3, [r4, #16]
    d19e:	e002      	b.n	d1a6 <uip_process+0x1bfe>
				}
				else
				{
					uip_connr->tcpstateflags = UIP_CLOSING;
    d1a0:	f04f 0306 	mov.w	r3, #6
    d1a4:	7663      	strb	r3, [r4, #25]
				}

				uip_add_rcv_nxt( 1 );
    d1a6:	f04f 0001 	mov.w	r0, #1
    d1aa:	f7fe f9bb 	bl	b524 <uip_add_rcv_nxt>
				uip_flags = UIP_CLOSE;
    d1ae:	f64a 4334 	movw	r3, #44084	; 0xac34
    d1b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d1b6:	f04f 0210 	mov.w	r2, #16
    d1ba:	701a      	strb	r2, [r3, #0]
				UIP_APPCALL();
    d1bc:	f001 fefa 	bl	efb4 <httpd_appcall>
				goto tcp_send_ack;
    d1c0:	e066      	b.n	d290 <uip_process+0x1ce8>
			}
			else if( uip_flags & UIP_ACKDATA )
    d1c2:	f64a 4334 	movw	r3, #44084	; 0xac34
    d1c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d1ca:	781b      	ldrb	r3, [r3, #0]
    d1cc:	f003 0301 	and.w	r3, r3, #1
    d1d0:	b2db      	uxtb	r3, r3
    d1d2:	2b00      	cmp	r3, #0
    d1d4:	d006      	beq.n	d1e4 <uip_process+0x1c3c>
			{
				uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
    d1d6:	f04f 0305 	mov.w	r3, #5
    d1da:	7663      	strb	r3, [r4, #25]
				uip_connr->len = 0;
    d1dc:	f04f 0300 	mov.w	r3, #0
    d1e0:	8223      	strh	r3, [r4, #16]
				goto drop;
    d1e2:	e2a5      	b.n	d730 <uip_process+0x2188>
			}

			if( uip_len > 0 )
    d1e4:	f64a 4328 	movw	r3, #44072	; 0xac28
    d1e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d1ec:	881b      	ldrh	r3, [r3, #0]
    d1ee:	2b00      	cmp	r3, #0
    d1f0:	f000 8299 	beq.w	d726 <uip_process+0x217e>
			{
				goto tcp_send_ack;
    d1f4:	e04c      	b.n	d290 <uip_process+0x1ce8>
			}

			goto drop;

		case UIP_FIN_WAIT_2:
			if( uip_len > 0 )
    d1f6:	f64a 4328 	movw	r3, #44072	; 0xac28
    d1fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d1fe:	881b      	ldrh	r3, [r3, #0]
    d200:	2b00      	cmp	r3, #0
    d202:	d007      	beq.n	d214 <uip_process+0x1c6c>
			{
				uip_add_rcv_nxt( uip_len );
    d204:	f64a 4328 	movw	r3, #44072	; 0xac28
    d208:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d20c:	881b      	ldrh	r3, [r3, #0]
    d20e:	4618      	mov	r0, r3
    d210:	f7fe f988 	bl	b524 <uip_add_rcv_nxt>
			}

			if( BUF->flags & TCP_FIN )
    d214:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d218:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d21c:	681b      	ldr	r3, [r3, #0]
    d21e:	f103 030e 	add.w	r3, r3, #14
    d222:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    d226:	f003 0301 	and.w	r3, r3, #1
    d22a:	b2db      	uxtb	r3, r3
    d22c:	2b00      	cmp	r3, #0
    d22e:	d013      	beq.n	d258 <uip_process+0x1cb0>
			{
				uip_connr->tcpstateflags = UIP_TIME_WAIT;
    d230:	f04f 0307 	mov.w	r3, #7
    d234:	7663      	strb	r3, [r4, #25]
				uip_connr->timer = 0;
    d236:	f04f 0300 	mov.w	r3, #0
    d23a:	76a3      	strb	r3, [r4, #26]
				uip_add_rcv_nxt( 1 );
    d23c:	f04f 0001 	mov.w	r0, #1
    d240:	f7fe f970 	bl	b524 <uip_add_rcv_nxt>
				uip_flags = UIP_CLOSE;
    d244:	f64a 4334 	movw	r3, #44084	; 0xac34
    d248:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d24c:	f04f 0210 	mov.w	r2, #16
    d250:	701a      	strb	r2, [r3, #0]
				UIP_APPCALL();
    d252:	f001 feaf 	bl	efb4 <httpd_appcall>
				goto tcp_send_ack;
    d256:	e01b      	b.n	d290 <uip_process+0x1ce8>
			}

			if( uip_len > 0 )
    d258:	f64a 4328 	movw	r3, #44072	; 0xac28
    d25c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d260:	881b      	ldrh	r3, [r3, #0]
    d262:	2b00      	cmp	r3, #0
    d264:	f000 8261 	beq.w	d72a <uip_process+0x2182>
			{
				goto tcp_send_ack;
    d268:	e012      	b.n	d290 <uip_process+0x1ce8>

		case UIP_TIME_WAIT:
			goto tcp_send_ack;

		case UIP_CLOSING:
			if( uip_flags & UIP_ACKDATA )
    d26a:	f64a 4334 	movw	r3, #44084	; 0xac34
    d26e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d272:	781b      	ldrb	r3, [r3, #0]
    d274:	f003 0301 	and.w	r3, r3, #1
    d278:	b2db      	uxtb	r3, r3
    d27a:	2b00      	cmp	r3, #0
    d27c:	f000 8257 	beq.w	d72e <uip_process+0x2186>
			{
				uip_connr->tcpstateflags = UIP_TIME_WAIT;
    d280:	f04f 0307 	mov.w	r3, #7
    d284:	7663      	strb	r3, [r4, #25]
				uip_connr->timer = 0;
    d286:	f04f 0300 	mov.w	r3, #0
    d28a:	76a3      	strb	r3, [r4, #26]
			}
	}

	goto drop;
    d28c:	e250      	b.n	d730 <uip_process+0x2188>
			}

			goto drop;

		case UIP_TIME_WAIT:
			goto tcp_send_ack;
    d28e:	bf00      	nop
	goto drop;

	/* We jump here when we are ready to send the packet, and just want
	 to set the appropriate TCP sequence numbers in the TCP header. */
tcp_send_ack:
	BUF->flags = TCP_ACK;
    d290:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d294:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d298:	681b      	ldr	r3, [r3, #0]
    d29a:	f103 030e 	add.w	r3, r3, #14
    d29e:	f04f 0210 	mov.w	r2, #16
    d2a2:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

tcp_send_nodata:
	uip_len = UIP_IPTCPH_LEN;
    d2a6:	f64a 4328 	movw	r3, #44072	; 0xac28
    d2aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d2ae:	f04f 0228 	mov.w	r2, #40	; 0x28
    d2b2:	801a      	strh	r2, [r3, #0]

tcp_send_noopts:
	BUF->tcpoffset = ( UIP_TCPH_LEN / 4 ) << 4;
    d2b4:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d2b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d2bc:	681b      	ldr	r3, [r3, #0]
    d2be:	f103 030e 	add.w	r3, r3, #14
    d2c2:	f04f 0250 	mov.w	r2, #80	; 0x50
    d2c6:	f883 2020 	strb.w	r2, [r3, #32]
	/* We're done with the input processing. We are now ready to send a
	reply. Our job is to fill in all the fields of the TCP and IP
	headers before calculating the checksum and finally send the
	packet. */
tcp_send:
	BUF->ackno[ 0 ] = uip_connr->rcv_nxt[ 0 ];
    d2ca:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d2ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d2d2:	681b      	ldr	r3, [r3, #0]
    d2d4:	f103 030e 	add.w	r3, r3, #14
    d2d8:	7a22      	ldrb	r2, [r4, #8]
    d2da:	771a      	strb	r2, [r3, #28]
	BUF->ackno[ 1 ] = uip_connr->rcv_nxt[ 1 ];
    d2dc:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d2e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d2e4:	681b      	ldr	r3, [r3, #0]
    d2e6:	f103 030e 	add.w	r3, r3, #14
    d2ea:	7a62      	ldrb	r2, [r4, #9]
    d2ec:	775a      	strb	r2, [r3, #29]
	BUF->ackno[ 2 ] = uip_connr->rcv_nxt[ 2 ];
    d2ee:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d2f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d2f6:	681b      	ldr	r3, [r3, #0]
    d2f8:	f103 030e 	add.w	r3, r3, #14
    d2fc:	7aa2      	ldrb	r2, [r4, #10]
    d2fe:	779a      	strb	r2, [r3, #30]
	BUF->ackno[ 3 ] = uip_connr->rcv_nxt[ 3 ];
    d300:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d304:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d308:	681b      	ldr	r3, [r3, #0]
    d30a:	f103 030e 	add.w	r3, r3, #14
    d30e:	7ae2      	ldrb	r2, [r4, #11]
    d310:	77da      	strb	r2, [r3, #31]

	BUF->seqno[ 0 ] = uip_connr->snd_nxt[ 0 ];
    d312:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d316:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d31a:	681b      	ldr	r3, [r3, #0]
    d31c:	f103 030e 	add.w	r3, r3, #14
    d320:	7b22      	ldrb	r2, [r4, #12]
    d322:	761a      	strb	r2, [r3, #24]
	BUF->seqno[ 1 ] = uip_connr->snd_nxt[ 1 ];
    d324:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d328:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d32c:	681b      	ldr	r3, [r3, #0]
    d32e:	f103 030e 	add.w	r3, r3, #14
    d332:	7b62      	ldrb	r2, [r4, #13]
    d334:	765a      	strb	r2, [r3, #25]
	BUF->seqno[ 2 ] = uip_connr->snd_nxt[ 2 ];
    d336:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d33a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d33e:	681b      	ldr	r3, [r3, #0]
    d340:	f103 030e 	add.w	r3, r3, #14
    d344:	7ba2      	ldrb	r2, [r4, #14]
    d346:	769a      	strb	r2, [r3, #26]
	BUF->seqno[ 3 ] = uip_connr->snd_nxt[ 3 ];
    d348:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d34c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d350:	681b      	ldr	r3, [r3, #0]
    d352:	f103 030e 	add.w	r3, r3, #14
    d356:	7be2      	ldrb	r2, [r4, #15]
    d358:	76da      	strb	r2, [r3, #27]

	BUF->proto = UIP_PROTO_TCP;
    d35a:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d35e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d362:	681b      	ldr	r3, [r3, #0]
    d364:	f103 030e 	add.w	r3, r3, #14
    d368:	f04f 0206 	mov.w	r2, #6
    d36c:	725a      	strb	r2, [r3, #9]

	BUF->srcport = uip_connr->lport;
    d36e:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d372:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d376:	681b      	ldr	r3, [r3, #0]
    d378:	f103 030e 	add.w	r3, r3, #14
    d37c:	88a2      	ldrh	r2, [r4, #4]
    d37e:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    d382:	f04f 0000 	mov.w	r0, #0
    d386:	ea40 0101 	orr.w	r1, r0, r1
    d38a:	7519      	strb	r1, [r3, #20]
    d38c:	ea4f 2212 	mov.w	r2, r2, lsr #8
    d390:	b292      	uxth	r2, r2
    d392:	f04f 0100 	mov.w	r1, #0
    d396:	ea41 0202 	orr.w	r2, r1, r2
    d39a:	755a      	strb	r2, [r3, #21]
	BUF->destport = uip_connr->rport;
    d39c:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d3a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d3a4:	681b      	ldr	r3, [r3, #0]
    d3a6:	f103 030e 	add.w	r3, r3, #14
    d3aa:	88e2      	ldrh	r2, [r4, #6]
    d3ac:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    d3b0:	f04f 0000 	mov.w	r0, #0
    d3b4:	ea40 0101 	orr.w	r1, r0, r1
    d3b8:	7599      	strb	r1, [r3, #22]
    d3ba:	ea4f 2212 	mov.w	r2, r2, lsr #8
    d3be:	b292      	uxth	r2, r2
    d3c0:	f04f 0100 	mov.w	r1, #0
    d3c4:	ea41 0202 	orr.w	r2, r1, r2
    d3c8:	75da      	strb	r2, [r3, #23]

	uip_ipaddr_copy( &BUF->srcipaddr, &uip_hostaddr );
    d3ca:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d3ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d3d2:	681b      	ldr	r3, [r3, #0]
    d3d4:	f103 020e 	add.w	r2, r3, #14
    d3d8:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    d3dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d3e0:	781b      	ldrb	r3, [r3, #0]
    d3e2:	7313      	strb	r3, [r2, #12]
    d3e4:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d3e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d3ec:	681b      	ldr	r3, [r3, #0]
    d3ee:	f103 020e 	add.w	r2, r3, #14
    d3f2:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    d3f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d3fa:	785b      	ldrb	r3, [r3, #1]
    d3fc:	7353      	strb	r3, [r2, #13]
    d3fe:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d402:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d406:	681b      	ldr	r3, [r3, #0]
    d408:	f103 020e 	add.w	r2, r3, #14
    d40c:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    d410:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d414:	789b      	ldrb	r3, [r3, #2]
    d416:	7393      	strb	r3, [r2, #14]
    d418:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d41c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d420:	681b      	ldr	r3, [r3, #0]
    d422:	f103 020e 	add.w	r2, r3, #14
    d426:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    d42a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d42e:	78db      	ldrb	r3, [r3, #3]
    d430:	73d3      	strb	r3, [r2, #15]
	uip_ipaddr_copy( &BUF->destipaddr, &uip_connr->ripaddr );
    d432:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d436:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d43a:	681b      	ldr	r3, [r3, #0]
    d43c:	f103 030e 	add.w	r3, r3, #14
    d440:	7822      	ldrb	r2, [r4, #0]
    d442:	741a      	strb	r2, [r3, #16]
    d444:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d448:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d44c:	681b      	ldr	r3, [r3, #0]
    d44e:	f103 030e 	add.w	r3, r3, #14
    d452:	7862      	ldrb	r2, [r4, #1]
    d454:	745a      	strb	r2, [r3, #17]
    d456:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d45a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d45e:	681b      	ldr	r3, [r3, #0]
    d460:	f103 030e 	add.w	r3, r3, #14
    d464:	78a2      	ldrb	r2, [r4, #2]
    d466:	749a      	strb	r2, [r3, #18]
    d468:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d46c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d470:	681b      	ldr	r3, [r3, #0]
    d472:	f103 030e 	add.w	r3, r3, #14
    d476:	78e2      	ldrb	r2, [r4, #3]
    d478:	74da      	strb	r2, [r3, #19]

	if( uip_connr->tcpstateflags & UIP_STOPPED )
    d47a:	7e63      	ldrb	r3, [r4, #25]
    d47c:	f003 0310 	and.w	r3, r3, #16
    d480:	2b00      	cmp	r3, #0
    d482:	d016      	beq.n	d4b2 <uip_process+0x1f0a>
	{
		/* If the connection has issued uip_stop(), we advertise a zero
		window so that the remote host will stop sending data. */
		BUF->wnd[ 0 ] = BUF->wnd[ 1 ] = 0;
    d484:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d488:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d48c:	681b      	ldr	r3, [r3, #0]
    d48e:	f103 020e 	add.w	r2, r3, #14
    d492:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d496:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d49a:	681b      	ldr	r3, [r3, #0]
    d49c:	f103 030e 	add.w	r3, r3, #14
    d4a0:	f04f 0100 	mov.w	r1, #0
    d4a4:	f883 1023 	strb.w	r1, [r3, #35]	; 0x23
    d4a8:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
    d4ac:	f882 3022 	strb.w	r3, [r2, #34]	; 0x22
    d4b0:	e015      	b.n	d4de <uip_process+0x1f36>
	}
	else
	{
		BUF->wnd[ 0 ] = ( (UIP_RECEIVE_WINDOW) >> 8 );
    d4b2:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d4b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d4ba:	681b      	ldr	r3, [r3, #0]
    d4bc:	f103 030e 	add.w	r3, r3, #14
    d4c0:	f04f 0205 	mov.w	r2, #5
    d4c4:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
		BUF->wnd[ 1 ] = ( (UIP_RECEIVE_WINDOW) & 0xff );
    d4c8:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d4cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d4d0:	681b      	ldr	r3, [r3, #0]
    d4d2:	f103 030e 	add.w	r3, r3, #14
    d4d6:	f06f 026d 	mvn.w	r2, #109	; 0x6d
    d4da:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
	}

tcp_send_noconn:

	BUF->ttl = UIP_TTL;
    d4de:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d4e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d4e6:	681b      	ldr	r3, [r3, #0]
    d4e8:	f103 030e 	add.w	r3, r3, #14
    d4ec:	f04f 0240 	mov.w	r2, #64	; 0x40
    d4f0:	721a      	strb	r2, [r3, #8]
		/* For IPv6, the IP length field does not include the IPv6 IP header
		 length. */
		BUF->len[ 0 ] = ( (uip_len - UIP_IPH_LEN) >> 8 );
		BUF->len[ 1 ] = ( (uip_len - UIP_IPH_LEN) & 0xff );
	#else /* UIP_CONF_IPV6 */
		BUF->len[ 0 ] = ( uip_len >> 8 );
    d4f2:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d4f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d4fa:	681b      	ldr	r3, [r3, #0]
    d4fc:	f103 020e 	add.w	r2, r3, #14
    d500:	f64a 4328 	movw	r3, #44072	; 0xac28
    d504:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d508:	881b      	ldrh	r3, [r3, #0]
    d50a:	ea4f 2313 	mov.w	r3, r3, lsr #8
    d50e:	b29b      	uxth	r3, r3
    d510:	b2db      	uxtb	r3, r3
    d512:	7093      	strb	r3, [r2, #2]
		BUF->len[ 1 ] = ( uip_len & 0xff );
    d514:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d518:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d51c:	681b      	ldr	r3, [r3, #0]
    d51e:	f103 020e 	add.w	r2, r3, #14
    d522:	f64a 4328 	movw	r3, #44072	; 0xac28
    d526:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d52a:	881b      	ldrh	r3, [r3, #0]
    d52c:	b2db      	uxtb	r3, r3
    d52e:	70d3      	strb	r3, [r2, #3]
	#endif /* UIP_CONF_IPV6 */

	BUF->urgp[ 0 ] = BUF->urgp[ 1 ] = 0;
    d530:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d534:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d538:	681b      	ldr	r3, [r3, #0]
    d53a:	f103 020e 	add.w	r2, r3, #14
    d53e:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d542:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d546:	681b      	ldr	r3, [r3, #0]
    d548:	f103 030e 	add.w	r3, r3, #14
    d54c:	f04f 0100 	mov.w	r1, #0
    d550:	f883 1027 	strb.w	r1, [r3, #39]	; 0x27
    d554:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
    d558:	f882 3026 	strb.w	r3, [r2, #38]	; 0x26

	/* Calculate TCP checksum. */
	BUF->tcpchksum = 0;
    d55c:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d560:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d564:	681b      	ldr	r3, [r3, #0]
    d566:	f103 030e 	add.w	r3, r3, #14
    d56a:	f04f 0200 	mov.w	r2, #0
    d56e:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
    d572:	f04f 0200 	mov.w	r2, #0
    d576:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
	BUF->tcpchksum = ~( uip_tcpchksum() );
    d57a:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d57e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d582:	681b      	ldr	r3, [r3, #0]
    d584:	f103 040e 	add.w	r4, r3, #14
    d588:	f7fd fddc 	bl	b144 <uip_tcpchksum>
    d58c:	4603      	mov	r3, r0
    d58e:	ea6f 0303 	mvn.w	r3, r3
    d592:	b29b      	uxth	r3, r3
    d594:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    d598:	f04f 0100 	mov.w	r1, #0
    d59c:	ea41 0202 	orr.w	r2, r1, r2
    d5a0:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
    d5a4:	ea4f 2313 	mov.w	r3, r3, lsr #8
    d5a8:	b29b      	uxth	r3, r3
    d5aa:	f04f 0200 	mov.w	r2, #0
    d5ae:	ea42 0303 	orr.w	r3, r2, r3
    d5b2:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
	#if UIP_CONF_IPV6
		BUF->vtc = 0x60;
		BUF->tcflow = 0x00;
		BUF->flow = 0x00;
	#else /* UIP_CONF_IPV6 */
		BUF->vhl = 0x45;
    d5b6:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d5ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d5be:	681b      	ldr	r3, [r3, #0]
    d5c0:	f103 030e 	add.w	r3, r3, #14
    d5c4:	f04f 0245 	mov.w	r2, #69	; 0x45
    d5c8:	701a      	strb	r2, [r3, #0]
		BUF->tos = 0;
    d5ca:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d5ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d5d2:	681b      	ldr	r3, [r3, #0]
    d5d4:	f103 030e 	add.w	r3, r3, #14
    d5d8:	f04f 0200 	mov.w	r2, #0
    d5dc:	705a      	strb	r2, [r3, #1]
		BUF->ipoffset[ 0 ] = BUF->ipoffset[ 1 ] = 0;
    d5de:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d5e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d5e6:	681b      	ldr	r3, [r3, #0]
    d5e8:	f103 020e 	add.w	r2, r3, #14
    d5ec:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d5f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d5f4:	681b      	ldr	r3, [r3, #0]
    d5f6:	f103 030e 	add.w	r3, r3, #14
    d5fa:	f04f 0100 	mov.w	r1, #0
    d5fe:	71d9      	strb	r1, [r3, #7]
    d600:	79db      	ldrb	r3, [r3, #7]
    d602:	7193      	strb	r3, [r2, #6]
		++ipid;
    d604:	f642 7384 	movw	r3, #12164	; 0x2f84
    d608:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d60c:	881b      	ldrh	r3, [r3, #0]
    d60e:	f103 0301 	add.w	r3, r3, #1
    d612:	b29a      	uxth	r2, r3
    d614:	f642 7384 	movw	r3, #12164	; 0x2f84
    d618:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d61c:	801a      	strh	r2, [r3, #0]
		BUF->ipid[ 0 ] = ipid >> 8;
    d61e:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d622:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d626:	681b      	ldr	r3, [r3, #0]
    d628:	f103 020e 	add.w	r2, r3, #14
    d62c:	f642 7384 	movw	r3, #12164	; 0x2f84
    d630:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d634:	881b      	ldrh	r3, [r3, #0]
    d636:	ea4f 2313 	mov.w	r3, r3, lsr #8
    d63a:	b29b      	uxth	r3, r3
    d63c:	b2db      	uxtb	r3, r3
    d63e:	7113      	strb	r3, [r2, #4]
		BUF->ipid[ 1 ] = ipid & 0xff;
    d640:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d644:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d648:	681b      	ldr	r3, [r3, #0]
    d64a:	f103 020e 	add.w	r2, r3, #14
    d64e:	f642 7384 	movw	r3, #12164	; 0x2f84
    d652:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d656:	881b      	ldrh	r3, [r3, #0]
    d658:	b2db      	uxtb	r3, r3
    d65a:	7153      	strb	r3, [r2, #5]

		/* Calculate IP checksum. */
		BUF->ipchksum = 0;
    d65c:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d660:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d664:	681b      	ldr	r3, [r3, #0]
    d666:	f103 030e 	add.w	r3, r3, #14
    d66a:	f04f 0200 	mov.w	r2, #0
    d66e:	729a      	strb	r2, [r3, #10]
    d670:	f04f 0200 	mov.w	r2, #0
    d674:	72da      	strb	r2, [r3, #11]
		BUF->ipchksum = ~( uip_ipchksum() );
    d676:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d67a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d67e:	681b      	ldr	r3, [r3, #0]
    d680:	f103 040e 	add.w	r4, r3, #14
    d684:	f7fd fce6 	bl	b054 <uip_ipchksum>
    d688:	4603      	mov	r3, r0
    d68a:	ea6f 0303 	mvn.w	r3, r3
    d68e:	b29b      	uxth	r3, r3
    d690:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    d694:	f04f 0100 	mov.w	r1, #0
    d698:	ea41 0202 	orr.w	r2, r1, r2
    d69c:	72a2      	strb	r2, [r4, #10]
    d69e:	ea4f 2313 	mov.w	r3, r3, lsr #8
    d6a2:	b29b      	uxth	r3, r3
    d6a4:	f04f 0200 	mov.w	r2, #0
    d6a8:	ea42 0303 	orr.w	r3, r2, r3
    d6ac:	72e3      	strb	r3, [r4, #11]

		//DEBUG_PRINTF( "uip ip_send_nolen: chkecum 0x%04x\n", uip_ipchksum() );
	#endif /* UIP_CONF_IPV6 */

	UIP_STAT( ++uip_stat.tcp.sent );
    d6ae:	f64c 4374 	movw	r3, #52340	; 0xcc74
    d6b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d6b6:	8c1b      	ldrh	r3, [r3, #32]
    d6b8:	f103 0301 	add.w	r3, r3, #1
    d6bc:	b29a      	uxth	r2, r3
    d6be:	f64c 4374 	movw	r3, #52340	; 0xcc74
    d6c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d6c6:	841a      	strh	r2, [r3, #32]
	#if UIP_CONF_IPV6
send :
	#endif /* UIP_CONF_IPV6 */

	//DEBUG_PRINTF( "Sending packet with length %d (%d)\n", uip_len, (BUF->len[ 0 ] << 8) | BUF->len[ 1 ] );
	UIP_STAT( ++uip_stat.ip.sent );
    d6c8:	f64c 4374 	movw	r3, #52340	; 0xcc74
    d6cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d6d0:	885b      	ldrh	r3, [r3, #2]
    d6d2:	f103 0301 	add.w	r3, r3, #1
    d6d6:	b29a      	uxth	r2, r3
    d6d8:	f64c 4374 	movw	r3, #52340	; 0xcc74
    d6dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d6e0:	805a      	strh	r2, [r3, #2]

	/* Return and let the caller do the actual transmission. */
	uip_flags = 0;
    d6e2:	f64a 4334 	movw	r3, #44084	; 0xac34
    d6e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d6ea:	f04f 0200 	mov.w	r2, #0
    d6ee:	701a      	strb	r2, [r3, #0]
	return;
    d6f0:	e02d      	b.n	d74e <uip_process+0x21a6>
			uip_flags = UIP_POLL;
			UIP_APPCALL();
			goto appsend;
		}

		goto drop;
    d6f2:	bf00      	nop
    d6f4:	e01c      	b.n	d730 <uip_process+0x2188>
    d6f6:	bf00      	nop
    d6f8:	e01a      	b.n	d730 <uip_process+0x2188>
				UIP_APPCALL();
				goto appsend;
			}
		}

		goto drop;
    d6fa:	bf00      	nop
    d6fc:	e018      	b.n	d730 <uip_process+0x2188>
    d6fe:	bf00      	nop
    d700:	e016      	b.n	d730 <uip_process+0x2188>
    d702:	bf00      	nop
    d704:	e014      	b.n	d730 <uip_process+0x2188>
    d706:	bf00      	nop
    d708:	e012      	b.n	d730 <uip_process+0x2188>
		#endif /* UIP_CONF_IPV6 */
	}
	else
	{
		UIP_LOG( "ip: packet shorter than reported in IP header." );
		goto drop;
    d70a:	bf00      	nop
    d70c:	e010      	b.n	d730 <uip_process+0x2188>

reset:
	/* We do not send resets in response to resets. */
	if( BUF->flags & TCP_RST )
	{
		goto drop;
    d70e:	bf00      	nop
    d710:	e00e      	b.n	d730 <uip_process+0x2188>
				uip_connr->tcpstateflags = UIP_TIME_WAIT;
				uip_connr->timer = 0;
			}
	}

	goto drop;
    d712:	bf00      	nop
    d714:	e00c      	b.n	d730 <uip_process+0x2188>
				uip_slen = 0;
				UIP_APPCALL();
				goto appsend;
			}

			goto drop;
    d716:	bf00      	nop
    d718:	e00a      	b.n	d730 <uip_process+0x2188>
			sequence numbers will be screwed up. */
			if( BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED) )
			{
				if( uip_outstanding(uip_connr) )
				{
					goto drop;
    d71a:	bf00      	nop
    d71c:	e008      	b.n	d730 <uip_process+0x2188>
					BUF->flags = TCP_ACK;
					goto tcp_send_noopts;
				}
			}

			goto drop;
    d71e:	bf00      	nop
    d720:	e006      	b.n	d730 <uip_process+0x2188>
    d722:	bf00      	nop
    d724:	e004      	b.n	d730 <uip_process+0x2188>
			if( uip_len > 0 )
			{
				goto tcp_send_ack;
			}

			goto drop;
    d726:	bf00      	nop
    d728:	e002      	b.n	d730 <uip_process+0x2188>
			if( uip_len > 0 )
			{
				goto tcp_send_ack;
			}

			goto drop;
    d72a:	bf00      	nop
    d72c:	e000      	b.n	d730 <uip_process+0x2188>
				uip_connr->tcpstateflags = UIP_TIME_WAIT;
				uip_connr->timer = 0;
			}
	}

	goto drop;
    d72e:	bf00      	nop
	/* Return and let the caller do the actual transmission. */
	uip_flags = 0;
	return;

drop:
	uip_len = 0;
    d730:	f64a 4328 	movw	r3, #44072	; 0xac28
    d734:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d738:	f04f 0200 	mov.w	r2, #0
    d73c:	801a      	strh	r2, [r3, #0]
	uip_flags = 0;
    d73e:	f64a 4334 	movw	r3, #44084	; 0xac34
    d742:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d746:	f04f 0200 	mov.w	r2, #0
    d74a:	701a      	strb	r2, [r3, #0]
	return;
    d74c:	bf00      	nop
}
    d74e:	f107 0714 	add.w	r7, r7, #20
    d752:	46bd      	mov	sp, r7
    d754:	bd90      	pop	{r4, r7, pc}
    d756:	bf00      	nop

0000d758 <htons>:
/*---------------------------------------------------------------------------*/

u16_t htons( u16_t val )
{
    d758:	b480      	push	{r7}
    d75a:	b083      	sub	sp, #12
    d75c:	af00      	add	r7, sp, #0
    d75e:	4603      	mov	r3, r0
    d760:	80fb      	strh	r3, [r7, #6]
	return HTONS( val );
    d762:	88fb      	ldrh	r3, [r7, #6]
    d764:	ea4f 2303 	mov.w	r3, r3, lsl #8
    d768:	b29a      	uxth	r2, r3
    d76a:	88fb      	ldrh	r3, [r7, #6]
    d76c:	ea4f 2313 	mov.w	r3, r3, lsr #8
    d770:	b29b      	uxth	r3, r3
    d772:	ea42 0303 	orr.w	r3, r2, r3
    d776:	b29b      	uxth	r3, r3
    d778:	b29b      	uxth	r3, r3
}
    d77a:	4618      	mov	r0, r3
    d77c:	f107 070c 	add.w	r7, r7, #12
    d780:	46bd      	mov	sp, r7
    d782:	bc80      	pop	{r7}
    d784:	4770      	bx	lr
    d786:	bf00      	nop

0000d788 <htonl>:

u32_t htonl( u32_t val )
{
    d788:	b480      	push	{r7}
    d78a:	b083      	sub	sp, #12
    d78c:	af00      	add	r7, sp, #0
    d78e:	6078      	str	r0, [r7, #4]
	return HTONL( val );
    d790:	687b      	ldr	r3, [r7, #4]
    d792:	b29b      	uxth	r3, r3
    d794:	ea4f 2303 	mov.w	r3, r3, lsl #8
    d798:	b29a      	uxth	r2, r3
    d79a:	687b      	ldr	r3, [r7, #4]
    d79c:	b29b      	uxth	r3, r3
    d79e:	ea4f 2313 	mov.w	r3, r3, lsr #8
    d7a2:	b29b      	uxth	r3, r3
    d7a4:	ea42 0303 	orr.w	r3, r2, r3
    d7a8:	b29b      	uxth	r3, r3
    d7aa:	b29b      	uxth	r3, r3
    d7ac:	ea4f 4203 	mov.w	r2, r3, lsl #16
    d7b0:	687b      	ldr	r3, [r7, #4]
    d7b2:	ea4f 4313 	mov.w	r3, r3, lsr #16
    d7b6:	b29b      	uxth	r3, r3
    d7b8:	ea4f 2303 	mov.w	r3, r3, lsl #8
    d7bc:	b299      	uxth	r1, r3
    d7be:	687b      	ldr	r3, [r7, #4]
    d7c0:	ea4f 4313 	mov.w	r3, r3, lsr #16
    d7c4:	b29b      	uxth	r3, r3
    d7c6:	ea4f 2313 	mov.w	r3, r3, lsr #8
    d7ca:	b29b      	uxth	r3, r3
    d7cc:	ea41 0303 	orr.w	r3, r1, r3
    d7d0:	b29b      	uxth	r3, r3
    d7d2:	b29b      	uxth	r3, r3
    d7d4:	ea42 0303 	orr.w	r3, r2, r3
}
    d7d8:	4618      	mov	r0, r3
    d7da:	f107 070c 	add.w	r7, r7, #12
    d7de:	46bd      	mov	sp, r7
    d7e0:	bc80      	pop	{r7}
    d7e2:	4770      	bx	lr

0000d7e4 <uip_send>:
/*---------------------------------------------------------------------------*/

void uip_send( const void *data, int len )
{
    d7e4:	b580      	push	{r7, lr}
    d7e6:	b084      	sub	sp, #16
    d7e8:	af00      	add	r7, sp, #0
    d7ea:	6078      	str	r0, [r7, #4]
    d7ec:	6039      	str	r1, [r7, #0]
	int copylen;

	#define MIN( a, b ) ( (a) < (b) ? (a) : (b) )

	copylen = MIN( len, UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN - ( int )
    d7ee:	f240 63a4 	movw	r3, #1700	; 0x6a4
    d7f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d7f6:	681b      	ldr	r3, [r3, #0]
    d7f8:	f103 0336 	add.w	r3, r3, #54	; 0x36
    d7fc:	461a      	mov	r2, r3
    d7fe:	f64a 432c 	movw	r3, #44076	; 0xac2c
    d802:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d806:	681b      	ldr	r3, [r3, #0]
    d808:	ebc3 0302 	rsb	r3, r3, r2
    d80c:	f503 63b2 	add.w	r3, r3, #1424	; 0x590
    d810:	f103 0302 	add.w	r3, r3, #2
    d814:	683a      	ldr	r2, [r7, #0]
    d816:	4293      	cmp	r3, r2
    d818:	bfa8      	it	ge
    d81a:	4613      	movge	r3, r2
    d81c:	60fb      	str	r3, [r7, #12]
					   (( char * ) uip_sappdata - ( char * ) &uip_buf[UIP_LLH_LEN + UIP_TCPIP_HLEN]) );
	if( copylen > 0 )
    d81e:	68fb      	ldr	r3, [r7, #12]
    d820:	2b00      	cmp	r3, #0
    d822:	dd1d      	ble.n	d860 <uip_send+0x7c>
	{
		uip_slen = copylen;
    d824:	68fb      	ldr	r3, [r7, #12]
    d826:	b29a      	uxth	r2, r3
    d828:	f64c 43b4 	movw	r3, #52404	; 0xccb4
    d82c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d830:	801a      	strh	r2, [r3, #0]
		if( data != uip_sappdata )
    d832:	f64a 432c 	movw	r3, #44076	; 0xac2c
    d836:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d83a:	681b      	ldr	r3, [r3, #0]
    d83c:	687a      	ldr	r2, [r7, #4]
    d83e:	429a      	cmp	r2, r3
    d840:	d00e      	beq.n	d860 <uip_send+0x7c>
		{
			memcpy( uip_sappdata, (data), uip_slen );
    d842:	f64a 432c 	movw	r3, #44076	; 0xac2c
    d846:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d84a:	681a      	ldr	r2, [r3, #0]
    d84c:	f64c 43b4 	movw	r3, #52404	; 0xccb4
    d850:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d854:	881b      	ldrh	r3, [r3, #0]
    d856:	4610      	mov	r0, r2
    d858:	6879      	ldr	r1, [r7, #4]
    d85a:	461a      	mov	r2, r3
    d85c:	f007 faa2 	bl	14da4 <memcpy>
		}
	}
}
    d860:	f107 0710 	add.w	r7, r7, #16
    d864:	46bd      	mov	sp, r7
    d866:	bd80      	pop	{r7, pc}

0000d868 <uip_arp_init>:
 *
 */

/*-----------------------------------------------------------------------------------*/
void uip_arp_init( void )
{
    d868:	b580      	push	{r7, lr}
    d86a:	af00      	add	r7, sp, #0
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    d86c:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    d870:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d874:	f04f 0200 	mov.w	r2, #0
    d878:	701a      	strb	r2, [r3, #0]
    d87a:	e024      	b.n	d8c6 <uip_arp_init+0x5e>
	{
		memset( &arp_table[i].ipaddr, 0, 4 );
    d87c:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    d880:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d884:	781b      	ldrb	r3, [r3, #0]
    d886:	461a      	mov	r2, r3
    d888:	4613      	mov	r3, r2
    d88a:	ea4f 0343 	mov.w	r3, r3, lsl #1
    d88e:	4413      	add	r3, r2
    d890:	ea4f 0283 	mov.w	r2, r3, lsl #2
    d894:	f642 7394 	movw	r3, #12180	; 0x2f94
    d898:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d89c:	4413      	add	r3, r2
    d89e:	4618      	mov	r0, r3
    d8a0:	f04f 0100 	mov.w	r1, #0
    d8a4:	f04f 0204 	mov.w	r2, #4
    d8a8:	f007 fb44 	bl	14f34 <memset>
 */

/*-----------------------------------------------------------------------------------*/
void uip_arp_init( void )
{
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    d8ac:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    d8b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d8b4:	781b      	ldrb	r3, [r3, #0]
    d8b6:	f103 0301 	add.w	r3, r3, #1
    d8ba:	b2da      	uxtb	r2, r3
    d8bc:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    d8c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d8c4:	701a      	strb	r2, [r3, #0]
    d8c6:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    d8ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d8ce:	781b      	ldrb	r3, [r3, #0]
    d8d0:	2b07      	cmp	r3, #7
    d8d2:	d9d3      	bls.n	d87c <uip_arp_init+0x14>
	{
		memset( &arp_table[i].ipaddr, 0, 4 );
	}
}
    d8d4:	bd80      	pop	{r7, pc}
    d8d6:	bf00      	nop

0000d8d8 <uip_arp_timer>:
 *
 */

/*-----------------------------------------------------------------------------------*/
void uip_arp_timer( void )
{
    d8d8:	b580      	push	{r7, lr}
    d8da:	b082      	sub	sp, #8
    d8dc:	af00      	add	r7, sp, #0
	struct arp_entry	*tabptr;

	++arptime;
    d8de:	f642 73fa 	movw	r3, #12282	; 0x2ffa
    d8e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d8e6:	781b      	ldrb	r3, [r3, #0]
    d8e8:	f103 0301 	add.w	r3, r3, #1
    d8ec:	b2da      	uxtb	r2, r3
    d8ee:	f642 73fa 	movw	r3, #12282	; 0x2ffa
    d8f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d8f6:	701a      	strb	r2, [r3, #0]
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    d8f8:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    d8fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d900:	f04f 0200 	mov.w	r2, #0
    d904:	701a      	strb	r2, [r3, #0]
    d906:	e045      	b.n	d994 <uip_arp_timer+0xbc>
	{
		tabptr = &arp_table[i];
    d908:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    d90c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d910:	781b      	ldrb	r3, [r3, #0]
    d912:	461a      	mov	r2, r3
    d914:	4613      	mov	r3, r2
    d916:	ea4f 0343 	mov.w	r3, r3, lsl #1
    d91a:	4413      	add	r3, r2
    d91c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    d920:	461a      	mov	r2, r3
    d922:	f642 7394 	movw	r3, #12180	; 0x2f94
    d926:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d92a:	4413      	add	r3, r2
    d92c:	607b      	str	r3, [r7, #4]
		if( uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) && arptime - tabptr->time >= UIP_ARP_MAXAGE )
    d92e:	687b      	ldr	r3, [r7, #4]
    d930:	881a      	ldrh	r2, [r3, #0]
    d932:	f24b 73dc 	movw	r3, #47068	; 0xb7dc
    d936:	f2c0 0301 	movt	r3, #1
    d93a:	881b      	ldrh	r3, [r3, #0]
    d93c:	429a      	cmp	r2, r3
    d93e:	d11c      	bne.n	d97a <uip_arp_timer+0xa2>
    d940:	687b      	ldr	r3, [r7, #4]
    d942:	885a      	ldrh	r2, [r3, #2]
    d944:	f24b 73dc 	movw	r3, #47068	; 0xb7dc
    d948:	f2c0 0301 	movt	r3, #1
    d94c:	885b      	ldrh	r3, [r3, #2]
    d94e:	429a      	cmp	r2, r3
    d950:	d113      	bne.n	d97a <uip_arp_timer+0xa2>
    d952:	f642 73fa 	movw	r3, #12282	; 0x2ffa
    d956:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d95a:	781b      	ldrb	r3, [r3, #0]
    d95c:	461a      	mov	r2, r3
    d95e:	687b      	ldr	r3, [r7, #4]
    d960:	7a9b      	ldrb	r3, [r3, #10]
    d962:	ebc3 0302 	rsb	r3, r3, r2
    d966:	2b77      	cmp	r3, #119	; 0x77
    d968:	dd07      	ble.n	d97a <uip_arp_timer+0xa2>
		{
			memset( &tabptr->ipaddr, 0, 4 );
    d96a:	687b      	ldr	r3, [r7, #4]
    d96c:	4618      	mov	r0, r3
    d96e:	f04f 0100 	mov.w	r1, #0
    d972:	f04f 0204 	mov.w	r2, #4
    d976:	f007 fadd 	bl	14f34 <memset>
void uip_arp_timer( void )
{
	struct arp_entry	*tabptr;

	++arptime;
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    d97a:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    d97e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d982:	781b      	ldrb	r3, [r3, #0]
    d984:	f103 0301 	add.w	r3, r3, #1
    d988:	b2da      	uxtb	r2, r3
    d98a:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    d98e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d992:	701a      	strb	r2, [r3, #0]
    d994:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    d998:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d99c:	781b      	ldrb	r3, [r3, #0]
    d99e:	2b07      	cmp	r3, #7
    d9a0:	d9b2      	bls.n	d908 <uip_arp_timer+0x30>
		if( uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) && arptime - tabptr->time >= UIP_ARP_MAXAGE )
		{
			memset( &tabptr->ipaddr, 0, 4 );
		}
	}
}
    d9a2:	f107 0708 	add.w	r7, r7, #8
    d9a6:	46bd      	mov	sp, r7
    d9a8:	bd80      	pop	{r7, pc}
    d9aa:	bf00      	nop

0000d9ac <uip_arp_update>:

/*-----------------------------------------------------------------------------------*/
static void uip_arp_update( uip_ipaddr_t *ipaddr, struct uip_eth_addr *ethaddr )
{
    d9ac:	b590      	push	{r4, r7, lr}
    d9ae:	b083      	sub	sp, #12
    d9b0:	af00      	add	r7, sp, #0
    d9b2:	6078      	str	r0, [r7, #4]
    d9b4:	6039      	str	r1, [r7, #0]
	register struct arp_entry	*tabptr;

	/* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    d9b6:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    d9ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d9be:	f04f 0200 	mov.w	r2, #0
    d9c2:	701a      	strb	r2, [r3, #0]
    d9c4:	e049      	b.n	da5a <uip_arp_update+0xae>
	{
		tabptr = &arp_table[i];
    d9c6:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    d9ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d9ce:	781b      	ldrb	r3, [r3, #0]
    d9d0:	461a      	mov	r2, r3
    d9d2:	4613      	mov	r3, r2
    d9d4:	ea4f 0343 	mov.w	r3, r3, lsl #1
    d9d8:	4413      	add	r3, r2
    d9da:	ea4f 0383 	mov.w	r3, r3, lsl #2
    d9de:	461a      	mov	r2, r3
    d9e0:	f642 7394 	movw	r3, #12180	; 0x2f94
    d9e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d9e8:	eb02 0403 	add.w	r4, r2, r3

		/* Only check those entries that are actually in use. */
		if( !uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) )
    d9ec:	8822      	ldrh	r2, [r4, #0]
    d9ee:	f24b 73dc 	movw	r3, #47068	; 0xb7dc
    d9f2:	f2c0 0301 	movt	r3, #1
    d9f6:	881b      	ldrh	r3, [r3, #0]
    d9f8:	429a      	cmp	r2, r3
    d9fa:	d107      	bne.n	da0c <uip_arp_update+0x60>
    d9fc:	8862      	ldrh	r2, [r4, #2]
    d9fe:	f24b 73dc 	movw	r3, #47068	; 0xb7dc
    da02:	f2c0 0301 	movt	r3, #1
    da06:	885b      	ldrh	r3, [r3, #2]
    da08:	429a      	cmp	r2, r3
    da0a:	d019      	beq.n	da40 <uip_arp_update+0x94>
		{
			/* Check if the source IP address of the incoming packet matches
         the IP address in this ARP table entry. */
			if( uip_ipaddr_cmp(ipaddr, &tabptr->ipaddr) )
    da0c:	687b      	ldr	r3, [r7, #4]
    da0e:	881a      	ldrh	r2, [r3, #0]
    da10:	8823      	ldrh	r3, [r4, #0]
    da12:	429a      	cmp	r2, r3
    da14:	d114      	bne.n	da40 <uip_arp_update+0x94>
    da16:	687b      	ldr	r3, [r7, #4]
    da18:	885a      	ldrh	r2, [r3, #2]
    da1a:	8863      	ldrh	r3, [r4, #2]
    da1c:	429a      	cmp	r2, r3
    da1e:	d10f      	bne.n	da40 <uip_arp_update+0x94>
			{
				/* An old entry found, update this and return. */
				memcpy( tabptr->ethaddr.addr, ethaddr->addr, 6 );
    da20:	f104 0204 	add.w	r2, r4, #4
    da24:	683b      	ldr	r3, [r7, #0]
    da26:	4610      	mov	r0, r2
    da28:	4619      	mov	r1, r3
    da2a:	f04f 0206 	mov.w	r2, #6
    da2e:	f007 f9b9 	bl	14da4 <memcpy>
				tabptr->time = arptime;
    da32:	f642 73fa 	movw	r3, #12282	; 0x2ffa
    da36:	f2c2 0300 	movt	r3, #8192	; 0x2000
    da3a:	781b      	ldrb	r3, [r3, #0]
    da3c:	72a3      	strb	r3, [r4, #10]

				return;
    da3e:	e0f9      	b.n	dc34 <uip_arp_update+0x288>
	register struct arp_entry	*tabptr;

	/* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    da40:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    da44:	f2c2 0300 	movt	r3, #8192	; 0x2000
    da48:	781b      	ldrb	r3, [r3, #0]
    da4a:	f103 0301 	add.w	r3, r3, #1
    da4e:	b2da      	uxtb	r2, r3
    da50:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    da54:	f2c2 0300 	movt	r3, #8192	; 0x2000
    da58:	701a      	strb	r2, [r3, #0]
    da5a:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    da5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    da62:	781b      	ldrb	r3, [r3, #0]
    da64:	2b07      	cmp	r3, #7
    da66:	d9ae      	bls.n	d9c6 <uip_arp_update+0x1a>

	/* If we get here, no existing ARP table entry was found, so we
     create one. */

	/* First, we try to find an unused entry in the ARP table. */
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    da68:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    da6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    da70:	f04f 0200 	mov.w	r2, #0
    da74:	701a      	strb	r2, [r3, #0]
    da76:	e02f      	b.n	dad8 <uip_arp_update+0x12c>
	{
		tabptr = &arp_table[i];
    da78:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    da7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    da80:	781b      	ldrb	r3, [r3, #0]
    da82:	461a      	mov	r2, r3
    da84:	4613      	mov	r3, r2
    da86:	ea4f 0343 	mov.w	r3, r3, lsl #1
    da8a:	4413      	add	r3, r2
    da8c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    da90:	461a      	mov	r2, r3
    da92:	f642 7394 	movw	r3, #12180	; 0x2f94
    da96:	f2c2 0300 	movt	r3, #8192	; 0x2000
    da9a:	eb02 0403 	add.w	r4, r2, r3
		if( uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) )
    da9e:	8822      	ldrh	r2, [r4, #0]
    daa0:	f24b 73dc 	movw	r3, #47068	; 0xb7dc
    daa4:	f2c0 0301 	movt	r3, #1
    daa8:	881b      	ldrh	r3, [r3, #0]
    daaa:	429a      	cmp	r2, r3
    daac:	d107      	bne.n	dabe <uip_arp_update+0x112>
    daae:	8862      	ldrh	r2, [r4, #2]
    dab0:	f24b 73dc 	movw	r3, #47068	; 0xb7dc
    dab4:	f2c0 0301 	movt	r3, #1
    dab8:	885b      	ldrh	r3, [r3, #2]
    daba:	429a      	cmp	r2, r3
    dabc:	d014      	beq.n	dae8 <uip_arp_update+0x13c>

	/* If we get here, no existing ARP table entry was found, so we
     create one. */

	/* First, we try to find an unused entry in the ARP table. */
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    dabe:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    dac2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dac6:	781b      	ldrb	r3, [r3, #0]
    dac8:	f103 0301 	add.w	r3, r3, #1
    dacc:	b2da      	uxtb	r2, r3
    dace:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    dad2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dad6:	701a      	strb	r2, [r3, #0]
    dad8:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    dadc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dae0:	781b      	ldrb	r3, [r3, #0]
    dae2:	2b07      	cmp	r3, #7
    dae4:	d9c8      	bls.n	da78 <uip_arp_update+0xcc>
    dae6:	e000      	b.n	daea <uip_arp_update+0x13e>
	{
		tabptr = &arp_table[i];
		if( uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) )
		{
			break;
    dae8:	bf00      	nop
		}
	}

	/* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
	if( i == UIP_ARPTAB_SIZE )
    daea:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    daee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    daf2:	781b      	ldrb	r3, [r3, #0]
    daf4:	2b08      	cmp	r3, #8
    daf6:	f040 8082 	bne.w	dbfe <uip_arp_update+0x252>
	{
		tmpage = 0;
    dafa:	f642 73fb 	movw	r3, #12283	; 0x2ffb
    dafe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    db02:	f04f 0200 	mov.w	r2, #0
    db06:	701a      	strb	r2, [r3, #0]
		c = 0;
    db08:	f642 73f9 	movw	r3, #12281	; 0x2ff9
    db0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    db10:	f04f 0200 	mov.w	r2, #0
    db14:	701a      	strb	r2, [r3, #0]
		for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    db16:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    db1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    db1e:	f04f 0200 	mov.w	r2, #0
    db22:	701a      	strb	r2, [r3, #0]
    db24:	e047      	b.n	dbb6 <uip_arp_update+0x20a>
		{
			tabptr = &arp_table[i];
    db26:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    db2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    db2e:	781b      	ldrb	r3, [r3, #0]
    db30:	461a      	mov	r2, r3
    db32:	4613      	mov	r3, r2
    db34:	ea4f 0343 	mov.w	r3, r3, lsl #1
    db38:	4413      	add	r3, r2
    db3a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    db3e:	461a      	mov	r2, r3
    db40:	f642 7394 	movw	r3, #12180	; 0x2f94
    db44:	f2c2 0300 	movt	r3, #8192	; 0x2000
    db48:	eb02 0403 	add.w	r4, r2, r3
			if( arptime - tabptr->time > tmpage )
    db4c:	f642 73fa 	movw	r3, #12282	; 0x2ffa
    db50:	f2c2 0300 	movt	r3, #8192	; 0x2000
    db54:	781b      	ldrb	r3, [r3, #0]
    db56:	461a      	mov	r2, r3
    db58:	7aa3      	ldrb	r3, [r4, #10]
    db5a:	ebc3 0202 	rsb	r2, r3, r2
    db5e:	f642 73fb 	movw	r3, #12283	; 0x2ffb
    db62:	f2c2 0300 	movt	r3, #8192	; 0x2000
    db66:	781b      	ldrb	r3, [r3, #0]
    db68:	429a      	cmp	r2, r3
    db6a:	dd17      	ble.n	db9c <uip_arp_update+0x1f0>
			{
				tmpage = arptime - tabptr->time;
    db6c:	f642 73fa 	movw	r3, #12282	; 0x2ffa
    db70:	f2c2 0300 	movt	r3, #8192	; 0x2000
    db74:	781a      	ldrb	r2, [r3, #0]
    db76:	7aa3      	ldrb	r3, [r4, #10]
    db78:	ebc3 0302 	rsb	r3, r3, r2
    db7c:	b2da      	uxtb	r2, r3
    db7e:	f642 73fb 	movw	r3, #12283	; 0x2ffb
    db82:	f2c2 0300 	movt	r3, #8192	; 0x2000
    db86:	701a      	strb	r2, [r3, #0]
				c = i;
    db88:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    db8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    db90:	781a      	ldrb	r2, [r3, #0]
    db92:	f642 73f9 	movw	r3, #12281	; 0x2ff9
    db96:	f2c2 0300 	movt	r3, #8192	; 0x2000
    db9a:	701a      	strb	r2, [r3, #0]
     throw it away. */
	if( i == UIP_ARPTAB_SIZE )
	{
		tmpage = 0;
		c = 0;
		for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    db9c:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    dba0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dba4:	781b      	ldrb	r3, [r3, #0]
    dba6:	f103 0301 	add.w	r3, r3, #1
    dbaa:	b2da      	uxtb	r2, r3
    dbac:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    dbb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dbb4:	701a      	strb	r2, [r3, #0]
    dbb6:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    dbba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dbbe:	781b      	ldrb	r3, [r3, #0]
    dbc0:	2b07      	cmp	r3, #7
    dbc2:	d9b0      	bls.n	db26 <uip_arp_update+0x17a>
				tmpage = arptime - tabptr->time;
				c = i;
			}
		}

		i = c;
    dbc4:	f642 73f9 	movw	r3, #12281	; 0x2ff9
    dbc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dbcc:	781a      	ldrb	r2, [r3, #0]
    dbce:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    dbd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dbd6:	701a      	strb	r2, [r3, #0]
		tabptr = &arp_table[i];
    dbd8:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    dbdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dbe0:	781b      	ldrb	r3, [r3, #0]
    dbe2:	461a      	mov	r2, r3
    dbe4:	4613      	mov	r3, r2
    dbe6:	ea4f 0343 	mov.w	r3, r3, lsl #1
    dbea:	4413      	add	r3, r2
    dbec:	ea4f 0383 	mov.w	r3, r3, lsl #2
    dbf0:	461a      	mov	r2, r3
    dbf2:	f642 7394 	movw	r3, #12180	; 0x2f94
    dbf6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dbfa:	eb02 0403 	add.w	r4, r2, r3
	}

	/* Now, i is the ARP table entry which we will fill with the new
     information. */
	uip_ipaddr_copy( &tabptr->ipaddr, ipaddr );
    dbfe:	687b      	ldr	r3, [r7, #4]
    dc00:	781b      	ldrb	r3, [r3, #0]
    dc02:	7023      	strb	r3, [r4, #0]
    dc04:	687b      	ldr	r3, [r7, #4]
    dc06:	785b      	ldrb	r3, [r3, #1]
    dc08:	7063      	strb	r3, [r4, #1]
    dc0a:	687b      	ldr	r3, [r7, #4]
    dc0c:	789b      	ldrb	r3, [r3, #2]
    dc0e:	70a3      	strb	r3, [r4, #2]
    dc10:	687b      	ldr	r3, [r7, #4]
    dc12:	78db      	ldrb	r3, [r3, #3]
    dc14:	70e3      	strb	r3, [r4, #3]
	memcpy( tabptr->ethaddr.addr, ethaddr->addr, 6 );
    dc16:	f104 0204 	add.w	r2, r4, #4
    dc1a:	683b      	ldr	r3, [r7, #0]
    dc1c:	4610      	mov	r0, r2
    dc1e:	4619      	mov	r1, r3
    dc20:	f04f 0206 	mov.w	r2, #6
    dc24:	f007 f8be 	bl	14da4 <memcpy>
	tabptr->time = arptime;
    dc28:	f642 73fa 	movw	r3, #12282	; 0x2ffa
    dc2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dc30:	781b      	ldrb	r3, [r3, #0]
    dc32:	72a3      	strb	r3, [r4, #10]
}
    dc34:	f107 070c 	add.w	r7, r7, #12
    dc38:	46bd      	mov	sp, r7
    dc3a:	bd90      	pop	{r4, r7, pc}

0000dc3c <uip_arp_arpin>:
 * global variable uip_len.
 */

/*-----------------------------------------------------------------------------------*/
void uip_arp_arpin( void )
{
    dc3c:	b580      	push	{r7, lr}
    dc3e:	af00      	add	r7, sp, #0
	if( uip_len < sizeof(struct arp_hdr) )
    dc40:	f64a 4328 	movw	r3, #44072	; 0xac28
    dc44:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dc48:	881b      	ldrh	r3, [r3, #0]
    dc4a:	2b29      	cmp	r3, #41	; 0x29
    dc4c:	d807      	bhi.n	dc5e <uip_arp_arpin+0x22>
	{
		uip_len = 0;
    dc4e:	f64a 4328 	movw	r3, #44072	; 0xac28
    dc52:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dc56:	f04f 0200 	mov.w	r2, #0
    dc5a:	801a      	strh	r2, [r3, #0]
		return;
    dc5c:	e170      	b.n	df40 <uip_arp_arpin+0x304>
	}

	uip_len = 0;
    dc5e:	f64a 4328 	movw	r3, #44072	; 0xac28
    dc62:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dc66:	f04f 0200 	mov.w	r2, #0
    dc6a:	801a      	strh	r2, [r3, #0]

	switch( BUF->opcode )
    dc6c:	f240 63a4 	movw	r3, #1700	; 0x6a4
    dc70:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dc74:	681b      	ldr	r3, [r3, #0]
    dc76:	7d1a      	ldrb	r2, [r3, #20]
    dc78:	7d5b      	ldrb	r3, [r3, #21]
    dc7a:	ea4f 2303 	mov.w	r3, r3, lsl #8
    dc7e:	ea43 0302 	orr.w	r3, r3, r2
    dc82:	b29b      	uxth	r3, r3
    dc84:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    dc88:	d004      	beq.n	dc94 <uip_arp_arpin+0x58>
    dc8a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    dc8e:	f000 8112 	beq.w	deb6 <uip_arp_arpin+0x27a>
			}

			break;
	}

	return;
    dc92:	e155      	b.n	df40 <uip_arp_arpin+0x304>
			/*    if(BUF->dipaddr[0] == uip_hostaddr[0] &&
	  		BUF->dipaddr[1] == uip_hostaddr[1]) {*/

			//PRINTF( "uip_arp_arpin: request for %d.%d.%d.%d (we are %d.%d.%d.%d)\n", BUF->dipaddr.u8[0], BUF->dipaddr.u8[1], BUF->dipaddr.u8[2],			
			//BUF->dipaddr.u8[3], uip_hostaddr.u8[0], uip_hostaddr.u8[1], uip_hostaddr.u8[2], uip_hostaddr.u8[3] );
			if( uip_ipaddr_cmp(&BUF->dipaddr, &uip_hostaddr) )
    dc94:	f240 63a4 	movw	r3, #1700	; 0x6a4
    dc98:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dc9c:	681b      	ldr	r3, [r3, #0]
    dc9e:	f893 2026 	ldrb.w	r2, [r3, #38]	; 0x26
    dca2:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
    dca6:	ea4f 2303 	mov.w	r3, r3, lsl #8
    dcaa:	ea43 0302 	orr.w	r3, r3, r2
    dcae:	b29a      	uxth	r2, r3
    dcb0:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    dcb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dcb8:	881b      	ldrh	r3, [r3, #0]
    dcba:	429a      	cmp	r2, r3
    dcbc:	f040 8138 	bne.w	df30 <uip_arp_arpin+0x2f4>
    dcc0:	f240 63a4 	movw	r3, #1700	; 0x6a4
    dcc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dcc8:	681b      	ldr	r3, [r3, #0]
    dcca:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
    dcce:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
    dcd2:	ea4f 2303 	mov.w	r3, r3, lsl #8
    dcd6:	ea43 0302 	orr.w	r3, r3, r2
    dcda:	b29a      	uxth	r2, r3
    dcdc:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    dce0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dce4:	885b      	ldrh	r3, [r3, #2]
    dce6:	429a      	cmp	r2, r3
    dce8:	f040 8124 	bne.w	df34 <uip_arp_arpin+0x2f8>
			{
				/* First, we register the one who made the request in our ARP
				table, since it is likely that we will do more communication
				with this host in the future. */
				uip_arp_update( &BUF->sipaddr, &BUF->shwaddr );
    dcec:	f240 63a4 	movw	r3, #1700	; 0x6a4
    dcf0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dcf4:	681b      	ldr	r3, [r3, #0]
    dcf6:	f103 021c 	add.w	r2, r3, #28
    dcfa:	f240 63a4 	movw	r3, #1700	; 0x6a4
    dcfe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dd02:	681b      	ldr	r3, [r3, #0]
    dd04:	f103 0316 	add.w	r3, r3, #22
    dd08:	4610      	mov	r0, r2
    dd0a:	4619      	mov	r1, r3
    dd0c:	f7ff fe4e 	bl	d9ac <uip_arp_update>

				BUF->opcode = HTONS( ARP_REPLY );
    dd10:	f240 63a4 	movw	r3, #1700	; 0x6a4
    dd14:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dd18:	681b      	ldr	r3, [r3, #0]
    dd1a:	f04f 0200 	mov.w	r2, #0
    dd1e:	751a      	strb	r2, [r3, #20]
    dd20:	f04f 0200 	mov.w	r2, #0
    dd24:	f042 0202 	orr.w	r2, r2, #2
    dd28:	755a      	strb	r2, [r3, #21]

				memcpy( BUF->dhwaddr.addr, BUF->shwaddr.addr, 6 );
    dd2a:	f240 63a4 	movw	r3, #1700	; 0x6a4
    dd2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dd32:	681b      	ldr	r3, [r3, #0]
    dd34:	f103 0220 	add.w	r2, r3, #32
    dd38:	f240 63a4 	movw	r3, #1700	; 0x6a4
    dd3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dd40:	681b      	ldr	r3, [r3, #0]
    dd42:	f103 0316 	add.w	r3, r3, #22
    dd46:	4610      	mov	r0, r2
    dd48:	4619      	mov	r1, r3
    dd4a:	f04f 0206 	mov.w	r2, #6
    dd4e:	f007 f829 	bl	14da4 <memcpy>
				memcpy( BUF->shwaddr.addr, uip_ethaddr.addr, 6 );
    dd52:	f240 63a4 	movw	r3, #1700	; 0x6a4
    dd56:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dd5a:	681b      	ldr	r3, [r3, #0]
    dd5c:	f103 0316 	add.w	r3, r3, #22
    dd60:	4618      	mov	r0, r3
    dd62:	f642 717c 	movw	r1, #12156	; 0x2f7c
    dd66:	f2c2 0100 	movt	r1, #8192	; 0x2000
    dd6a:	f04f 0206 	mov.w	r2, #6
    dd6e:	f007 f819 	bl	14da4 <memcpy>
				memcpy( BUF->ethhdr.src.addr, uip_ethaddr.addr, 6 );
    dd72:	f240 63a4 	movw	r3, #1700	; 0x6a4
    dd76:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dd7a:	681b      	ldr	r3, [r3, #0]
    dd7c:	f103 0306 	add.w	r3, r3, #6
    dd80:	4618      	mov	r0, r3
    dd82:	f642 717c 	movw	r1, #12156	; 0x2f7c
    dd86:	f2c2 0100 	movt	r1, #8192	; 0x2000
    dd8a:	f04f 0206 	mov.w	r2, #6
    dd8e:	f007 f809 	bl	14da4 <memcpy>
				memcpy( BUF->ethhdr.dest.addr, BUF->dhwaddr.addr, 6 );
    dd92:	f240 63a4 	movw	r3, #1700	; 0x6a4
    dd96:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dd9a:	681b      	ldr	r3, [r3, #0]
    dd9c:	461a      	mov	r2, r3
    dd9e:	f240 63a4 	movw	r3, #1700	; 0x6a4
    dda2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dda6:	681b      	ldr	r3, [r3, #0]
    dda8:	f103 0320 	add.w	r3, r3, #32
    ddac:	4610      	mov	r0, r2
    ddae:	4619      	mov	r1, r3
    ddb0:	f04f 0206 	mov.w	r2, #6
    ddb4:	f006 fff6 	bl	14da4 <memcpy>

				uip_ipaddr_copy( &BUF->dipaddr, &BUF->sipaddr );
    ddb8:	f240 63a4 	movw	r3, #1700	; 0x6a4
    ddbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ddc0:	681b      	ldr	r3, [r3, #0]
    ddc2:	461a      	mov	r2, r3
    ddc4:	f240 63a4 	movw	r3, #1700	; 0x6a4
    ddc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ddcc:	681b      	ldr	r3, [r3, #0]
    ddce:	7f1b      	ldrb	r3, [r3, #28]
    ddd0:	f882 3026 	strb.w	r3, [r2, #38]	; 0x26
    ddd4:	f240 63a4 	movw	r3, #1700	; 0x6a4
    ddd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dddc:	681b      	ldr	r3, [r3, #0]
    ddde:	461a      	mov	r2, r3
    dde0:	f240 63a4 	movw	r3, #1700	; 0x6a4
    dde4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dde8:	681b      	ldr	r3, [r3, #0]
    ddea:	7f5b      	ldrb	r3, [r3, #29]
    ddec:	f882 3027 	strb.w	r3, [r2, #39]	; 0x27
    ddf0:	f240 63a4 	movw	r3, #1700	; 0x6a4
    ddf4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ddf8:	681b      	ldr	r3, [r3, #0]
    ddfa:	461a      	mov	r2, r3
    ddfc:	f240 63a4 	movw	r3, #1700	; 0x6a4
    de00:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de04:	681b      	ldr	r3, [r3, #0]
    de06:	7f9b      	ldrb	r3, [r3, #30]
    de08:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
    de0c:	f240 63a4 	movw	r3, #1700	; 0x6a4
    de10:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de14:	681b      	ldr	r3, [r3, #0]
    de16:	461a      	mov	r2, r3
    de18:	f240 63a4 	movw	r3, #1700	; 0x6a4
    de1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de20:	681b      	ldr	r3, [r3, #0]
    de22:	7fdb      	ldrb	r3, [r3, #31]
    de24:	f882 3029 	strb.w	r3, [r2, #41]	; 0x29
				uip_ipaddr_copy( &BUF->sipaddr, &uip_hostaddr );
    de28:	f240 63a4 	movw	r3, #1700	; 0x6a4
    de2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de30:	681b      	ldr	r3, [r3, #0]
    de32:	461a      	mov	r2, r3
    de34:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    de38:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de3c:	781b      	ldrb	r3, [r3, #0]
    de3e:	7713      	strb	r3, [r2, #28]
    de40:	f240 63a4 	movw	r3, #1700	; 0x6a4
    de44:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de48:	681b      	ldr	r3, [r3, #0]
    de4a:	461a      	mov	r2, r3
    de4c:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    de50:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de54:	785b      	ldrb	r3, [r3, #1]
    de56:	7753      	strb	r3, [r2, #29]
    de58:	f240 63a4 	movw	r3, #1700	; 0x6a4
    de5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de60:	681b      	ldr	r3, [r3, #0]
    de62:	461a      	mov	r2, r3
    de64:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    de68:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de6c:	789b      	ldrb	r3, [r3, #2]
    de6e:	7793      	strb	r3, [r2, #30]
    de70:	f240 63a4 	movw	r3, #1700	; 0x6a4
    de74:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de78:	681b      	ldr	r3, [r3, #0]
    de7a:	461a      	mov	r2, r3
    de7c:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    de80:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de84:	78db      	ldrb	r3, [r3, #3]
    de86:	77d3      	strb	r3, [r2, #31]

				BUF->ethhdr.type = HTONS( UIP_ETHTYPE_ARP );
    de88:	f240 63a4 	movw	r3, #1700	; 0x6a4
    de8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de90:	681b      	ldr	r3, [r3, #0]
    de92:	f04f 0200 	mov.w	r2, #0
    de96:	f042 0208 	orr.w	r2, r2, #8
    de9a:	731a      	strb	r2, [r3, #12]
    de9c:	f04f 0200 	mov.w	r2, #0
    dea0:	f042 0206 	orr.w	r2, r2, #6
    dea4:	735a      	strb	r2, [r3, #13]
				uip_len = sizeof( struct arp_hdr );
    dea6:	f64a 4328 	movw	r3, #44072	; 0xac28
    deaa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    deae:	f04f 022a 	mov.w	r2, #42	; 0x2a
    deb2:	801a      	strh	r2, [r3, #0]
			}

			break;
    deb4:	e03f      	b.n	df36 <uip_arp_arpin+0x2fa>

		case HTONS( ARP_REPLY ):
			/* ARP reply. We insert or update the ARP table if it was meant
			for us. */
			if( uip_ipaddr_cmp(&BUF->dipaddr, &uip_hostaddr) )
    deb6:	f240 63a4 	movw	r3, #1700	; 0x6a4
    deba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    debe:	681b      	ldr	r3, [r3, #0]
    dec0:	f893 2026 	ldrb.w	r2, [r3, #38]	; 0x26
    dec4:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
    dec8:	ea4f 2303 	mov.w	r3, r3, lsl #8
    decc:	ea43 0302 	orr.w	r3, r3, r2
    ded0:	b29a      	uxth	r2, r3
    ded2:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    ded6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    deda:	881b      	ldrh	r3, [r3, #0]
    dedc:	429a      	cmp	r2, r3
    dede:	d12c      	bne.n	df3a <uip_arp_arpin+0x2fe>
    dee0:	f240 63a4 	movw	r3, #1700	; 0x6a4
    dee4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dee8:	681b      	ldr	r3, [r3, #0]
    deea:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
    deee:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
    def2:	ea4f 2303 	mov.w	r3, r3, lsl #8
    def6:	ea43 0302 	orr.w	r3, r3, r2
    defa:	b29a      	uxth	r2, r3
    defc:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    df00:	f2c2 0300 	movt	r3, #8192	; 0x2000
    df04:	885b      	ldrh	r3, [r3, #2]
    df06:	429a      	cmp	r2, r3
    df08:	d119      	bne.n	df3e <uip_arp_arpin+0x302>
			{
				uip_arp_update( &BUF->sipaddr, &BUF->shwaddr );
    df0a:	f240 63a4 	movw	r3, #1700	; 0x6a4
    df0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    df12:	681b      	ldr	r3, [r3, #0]
    df14:	f103 021c 	add.w	r2, r3, #28
    df18:	f240 63a4 	movw	r3, #1700	; 0x6a4
    df1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    df20:	681b      	ldr	r3, [r3, #0]
    df22:	f103 0316 	add.w	r3, r3, #22
    df26:	4610      	mov	r0, r2
    df28:	4619      	mov	r1, r3
    df2a:	f7ff fd3f 	bl	d9ac <uip_arp_update>
			}

			break;
	}

	return;
    df2e:	e007      	b.n	df40 <uip_arp_arpin+0x304>

				BUF->ethhdr.type = HTONS( UIP_ETHTYPE_ARP );
				uip_len = sizeof( struct arp_hdr );
			}

			break;
    df30:	bf00      	nop
    df32:	e000      	b.n	df36 <uip_arp_arpin+0x2fa>
    df34:	bf00      	nop
			}

			break;
	}

	return;
    df36:	bf00      	nop
    df38:	e002      	b.n	df40 <uip_arp_arpin+0x304>
    df3a:	bf00      	nop
    df3c:	e000      	b.n	df40 <uip_arp_arpin+0x304>
    df3e:	bf00      	nop
}
    df40:	bd80      	pop	{r7, pc}
    df42:	bf00      	nop

0000df44 <uip_arp_out>:
 * uip_len.
 */

/*-----------------------------------------------------------------------------------*/
void uip_arp_out( void )
{
    df44:	b580      	push	{r7, lr}
    df46:	b082      	sub	sp, #8
    df48:	af00      	add	r7, sp, #0

     If not ARP table entry is found, we overwrite the original IP
     packet with an ARP request for the IP address. */

	/* First check if destination is a local broadcast. */
	if( uip_ipaddr_cmp(&IPBUF->destipaddr, &uip_broadcast_addr) )
    df4a:	f240 63a4 	movw	r3, #1700	; 0x6a4
    df4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    df52:	681b      	ldr	r3, [r3, #0]
    df54:	7f9a      	ldrb	r2, [r3, #30]
    df56:	7fdb      	ldrb	r3, [r3, #31]
    df58:	ea4f 2303 	mov.w	r3, r3, lsl #8
    df5c:	ea43 0302 	orr.w	r3, r3, r2
    df60:	b29a      	uxth	r2, r3
    df62:	f24b 73d8 	movw	r3, #47064	; 0xb7d8
    df66:	f2c0 0301 	movt	r3, #1
    df6a:	881b      	ldrh	r3, [r3, #0]
    df6c:	429a      	cmp	r2, r3
    df6e:	d123      	bne.n	dfb8 <uip_arp_out+0x74>
    df70:	f240 63a4 	movw	r3, #1700	; 0x6a4
    df74:	f2c2 0300 	movt	r3, #8192	; 0x2000
    df78:	681b      	ldr	r3, [r3, #0]
    df7a:	f893 2020 	ldrb.w	r2, [r3, #32]
    df7e:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    df82:	ea4f 2303 	mov.w	r3, r3, lsl #8
    df86:	ea43 0302 	orr.w	r3, r3, r2
    df8a:	b29a      	uxth	r2, r3
    df8c:	f24b 73d8 	movw	r3, #47064	; 0xb7d8
    df90:	f2c0 0301 	movt	r3, #1
    df94:	885b      	ldrh	r3, [r3, #2]
    df96:	429a      	cmp	r2, r3
    df98:	d10e      	bne.n	dfb8 <uip_arp_out+0x74>
	{
		memcpy( IPBUF->ethhdr.dest.addr, broadcast_ethaddr.addr, 6 );
    df9a:	f240 63a4 	movw	r3, #1700	; 0x6a4
    df9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dfa2:	681b      	ldr	r3, [r3, #0]
    dfa4:	4618      	mov	r0, r3
    dfa6:	f24b 71e0 	movw	r1, #47072	; 0xb7e0
    dfaa:	f2c0 0101 	movt	r1, #1
    dfae:	f04f 0206 	mov.w	r2, #6
    dfb2:	f006 fef7 	bl	14da4 <memcpy>

     If not ARP table entry is found, we overwrite the original IP
     packet with an ARP request for the IP address. */

	/* First check if destination is a local broadcast. */
	if( uip_ipaddr_cmp(&IPBUF->destipaddr, &uip_broadcast_addr) )
    dfb6:	e1db      	b.n	e370 <uip_arp_out+0x42c>
		memcpy( IPBUF->ethhdr.dest.addr, broadcast_ethaddr.addr, 6 );
	}
	else
	{
		/* Check if the destination address is on the local network. */
		if( !uip_ipaddr_maskcmp(&IPBUF->destipaddr, &uip_hostaddr, &uip_netmask) )
    dfb8:	f240 63a4 	movw	r3, #1700	; 0x6a4
    dfbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dfc0:	681b      	ldr	r3, [r3, #0]
    dfc2:	f103 031e 	add.w	r3, r3, #30
    dfc6:	881a      	ldrh	r2, [r3, #0]
    dfc8:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    dfcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dfd0:	881b      	ldrh	r3, [r3, #0]
    dfd2:	ea82 0303 	eor.w	r3, r2, r3
    dfd6:	b29a      	uxth	r2, r3
    dfd8:	f64c 43ac 	movw	r3, #52396	; 0xccac
    dfdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dfe0:	881b      	ldrh	r3, [r3, #0]
    dfe2:	ea02 0303 	and.w	r3, r2, r3
    dfe6:	b29b      	uxth	r3, r3
    dfe8:	2b00      	cmp	r3, #0
    dfea:	d113      	bne.n	e014 <uip_arp_out+0xd0>
    dfec:	f240 63a4 	movw	r3, #1700	; 0x6a4
    dff0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dff4:	681b      	ldr	r3, [r3, #0]
    dff6:	f103 0320 	add.w	r3, r3, #32
    dffa:	881a      	ldrh	r2, [r3, #0]
    dffc:	4b52      	ldr	r3, [pc, #328]	; (e148 <uip_arp_out+0x204>)
    dffe:	881b      	ldrh	r3, [r3, #0]
    e000:	ea82 0303 	eor.w	r3, r2, r3
    e004:	b29a      	uxth	r2, r3
    e006:	4b51      	ldr	r3, [pc, #324]	; (e14c <uip_arp_out+0x208>)
    e008:	881b      	ldrh	r3, [r3, #0]
    e00a:	ea02 0303 	and.w	r3, r2, r3
    e00e:	b29b      	uxth	r3, r3
    e010:	2b00      	cmp	r3, #0
    e012:	d028      	beq.n	e066 <uip_arp_out+0x122>
		{
			/* Destination address was not on the local network, so we need to
	 use the default router's IP address instead of the destination
	 address when determining the MAC address. */
			uip_ipaddr_copy( &ipaddr, &uip_draddr );
    e014:	f64c 4370 	movw	r3, #52336	; 0xcc70
    e018:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e01c:	781a      	ldrb	r2, [r3, #0]
    e01e:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e022:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e026:	701a      	strb	r2, [r3, #0]
    e028:	f64c 4370 	movw	r3, #52336	; 0xcc70
    e02c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e030:	785a      	ldrb	r2, [r3, #1]
    e032:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e036:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e03a:	705a      	strb	r2, [r3, #1]
    e03c:	f64c 4370 	movw	r3, #52336	; 0xcc70
    e040:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e044:	789a      	ldrb	r2, [r3, #2]
    e046:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e04a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e04e:	709a      	strb	r2, [r3, #2]
    e050:	f64c 4370 	movw	r3, #52336	; 0xcc70
    e054:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e058:	78da      	ldrb	r2, [r3, #3]
    e05a:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e05e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e062:	70da      	strb	r2, [r3, #3]
		memcpy( IPBUF->ethhdr.dest.addr, broadcast_ethaddr.addr, 6 );
	}
	else
	{
		/* Check if the destination address is on the local network. */
		if( !uip_ipaddr_maskcmp(&IPBUF->destipaddr, &uip_hostaddr, &uip_netmask) )
    e064:	e02d      	b.n	e0c2 <uip_arp_out+0x17e>
			uip_ipaddr_copy( &ipaddr, &uip_draddr );
		}
		else
		{
			/* Else, we use the destination IP address. */
			uip_ipaddr_copy( &ipaddr, &IPBUF->destipaddr );
    e066:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e06a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e06e:	681b      	ldr	r3, [r3, #0]
    e070:	7f9a      	ldrb	r2, [r3, #30]
    e072:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e076:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e07a:	701a      	strb	r2, [r3, #0]
    e07c:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e080:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e084:	681b      	ldr	r3, [r3, #0]
    e086:	7fda      	ldrb	r2, [r3, #31]
    e088:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e08c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e090:	705a      	strb	r2, [r3, #1]
    e092:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e096:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e09a:	681b      	ldr	r3, [r3, #0]
    e09c:	f893 2020 	ldrb.w	r2, [r3, #32]
    e0a0:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e0a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e0a8:	709a      	strb	r2, [r3, #2]
    e0aa:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e0ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e0b2:	681b      	ldr	r3, [r3, #0]
    e0b4:	f893 2021 	ldrb.w	r2, [r3, #33]	; 0x21
    e0b8:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e0bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e0c0:	70da      	strb	r2, [r3, #3]
		}

		for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    e0c2:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    e0c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e0ca:	f04f 0200 	mov.w	r2, #0
    e0ce:	701a      	strb	r2, [r3, #0]
    e0d0:	e031      	b.n	e136 <uip_arp_out+0x1f2>
		{
			tabptr = &arp_table[i];
    e0d2:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    e0d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e0da:	781b      	ldrb	r3, [r3, #0]
    e0dc:	461a      	mov	r2, r3
    e0de:	4613      	mov	r3, r2
    e0e0:	ea4f 0343 	mov.w	r3, r3, lsl #1
    e0e4:	4413      	add	r3, r2
    e0e6:	ea4f 0383 	mov.w	r3, r3, lsl #2
    e0ea:	461a      	mov	r2, r3
    e0ec:	f642 7394 	movw	r3, #12180	; 0x2f94
    e0f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e0f4:	4413      	add	r3, r2
    e0f6:	607b      	str	r3, [r7, #4]
			if( uip_ipaddr_cmp(&ipaddr, &tabptr->ipaddr) )
    e0f8:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e0fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e100:	881a      	ldrh	r2, [r3, #0]
    e102:	687b      	ldr	r3, [r7, #4]
    e104:	881b      	ldrh	r3, [r3, #0]
    e106:	429a      	cmp	r2, r3
    e108:	d108      	bne.n	e11c <uip_arp_out+0x1d8>
    e10a:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e10e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e112:	885a      	ldrh	r2, [r3, #2]
    e114:	687b      	ldr	r3, [r7, #4]
    e116:	885b      	ldrh	r3, [r3, #2]
    e118:	429a      	cmp	r2, r3
    e11a:	d019      	beq.n	e150 <uip_arp_out+0x20c>
		{
			/* Else, we use the destination IP address. */
			uip_ipaddr_copy( &ipaddr, &IPBUF->destipaddr );
		}

		for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    e11c:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    e120:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e124:	781b      	ldrb	r3, [r3, #0]
    e126:	f103 0301 	add.w	r3, r3, #1
    e12a:	b2da      	uxtb	r2, r3
    e12c:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    e130:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e134:	701a      	strb	r2, [r3, #0]
    e136:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    e13a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e13e:	781b      	ldrb	r3, [r3, #0]
    e140:	2b07      	cmp	r3, #7
    e142:	d9c6      	bls.n	e0d2 <uip_arp_out+0x18e>
    e144:	e005      	b.n	e152 <uip_arp_out+0x20e>
    e146:	bf00      	nop
    e148:	2000ccb2 	.word	0x2000ccb2
    e14c:	2000ccae 	.word	0x2000ccae
		{
			tabptr = &arp_table[i];
			if( uip_ipaddr_cmp(&ipaddr, &tabptr->ipaddr) )
			{
				break;
    e150:	bf00      	nop
			}
		}

		if( i == UIP_ARPTAB_SIZE )
    e152:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    e156:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e15a:	781b      	ldrb	r3, [r3, #0]
    e15c:	2b08      	cmp	r3, #8
    e15e:	f040 80f8 	bne.w	e352 <uip_arp_out+0x40e>
		{
			/* The destination address was not in our ARP table, so we
	 overwrite the IP packet with an ARP request. */
			memset( BUF->ethhdr.dest.addr, 0xff, 6 );
    e162:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e166:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e16a:	681b      	ldr	r3, [r3, #0]
    e16c:	4618      	mov	r0, r3
    e16e:	f04f 01ff 	mov.w	r1, #255	; 0xff
    e172:	f04f 0206 	mov.w	r2, #6
    e176:	f006 fedd 	bl	14f34 <memset>
			memset( BUF->dhwaddr.addr, 0x00, 6 );
    e17a:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e17e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e182:	681b      	ldr	r3, [r3, #0]
    e184:	f103 0320 	add.w	r3, r3, #32
    e188:	4618      	mov	r0, r3
    e18a:	f04f 0100 	mov.w	r1, #0
    e18e:	f04f 0206 	mov.w	r2, #6
    e192:	f006 fecf 	bl	14f34 <memset>
			memcpy( BUF->ethhdr.src.addr, uip_ethaddr.addr, 6 );
    e196:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e19a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e19e:	681b      	ldr	r3, [r3, #0]
    e1a0:	f103 0306 	add.w	r3, r3, #6
    e1a4:	4618      	mov	r0, r3
    e1a6:	f642 717c 	movw	r1, #12156	; 0x2f7c
    e1aa:	f2c2 0100 	movt	r1, #8192	; 0x2000
    e1ae:	f04f 0206 	mov.w	r2, #6
    e1b2:	f006 fdf7 	bl	14da4 <memcpy>
			memcpy( BUF->shwaddr.addr, uip_ethaddr.addr, 6 );
    e1b6:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e1ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e1be:	681b      	ldr	r3, [r3, #0]
    e1c0:	f103 0316 	add.w	r3, r3, #22
    e1c4:	4618      	mov	r0, r3
    e1c6:	f642 717c 	movw	r1, #12156	; 0x2f7c
    e1ca:	f2c2 0100 	movt	r1, #8192	; 0x2000
    e1ce:	f04f 0206 	mov.w	r2, #6
    e1d2:	f006 fde7 	bl	14da4 <memcpy>

			uip_ipaddr_copy( &BUF->dipaddr, &ipaddr );
    e1d6:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e1da:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e1de:	681b      	ldr	r3, [r3, #0]
    e1e0:	461a      	mov	r2, r3
    e1e2:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e1e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e1ea:	781b      	ldrb	r3, [r3, #0]
    e1ec:	f882 3026 	strb.w	r3, [r2, #38]	; 0x26
    e1f0:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e1f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e1f8:	681b      	ldr	r3, [r3, #0]
    e1fa:	461a      	mov	r2, r3
    e1fc:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e200:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e204:	785b      	ldrb	r3, [r3, #1]
    e206:	f882 3027 	strb.w	r3, [r2, #39]	; 0x27
    e20a:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e20e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e212:	681b      	ldr	r3, [r3, #0]
    e214:	461a      	mov	r2, r3
    e216:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e21a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e21e:	789b      	ldrb	r3, [r3, #2]
    e220:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
    e224:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e228:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e22c:	681b      	ldr	r3, [r3, #0]
    e22e:	461a      	mov	r2, r3
    e230:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e234:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e238:	78db      	ldrb	r3, [r3, #3]
    e23a:	f882 3029 	strb.w	r3, [r2, #41]	; 0x29
			uip_ipaddr_copy( &BUF->sipaddr, &uip_hostaddr );
    e23e:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e242:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e246:	681b      	ldr	r3, [r3, #0]
    e248:	461a      	mov	r2, r3
    e24a:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    e24e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e252:	781b      	ldrb	r3, [r3, #0]
    e254:	7713      	strb	r3, [r2, #28]
    e256:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e25a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e25e:	681b      	ldr	r3, [r3, #0]
    e260:	461a      	mov	r2, r3
    e262:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    e266:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e26a:	785b      	ldrb	r3, [r3, #1]
    e26c:	7753      	strb	r3, [r2, #29]
    e26e:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e272:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e276:	681b      	ldr	r3, [r3, #0]
    e278:	461a      	mov	r2, r3
    e27a:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    e27e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e282:	789b      	ldrb	r3, [r3, #2]
    e284:	7793      	strb	r3, [r2, #30]
    e286:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e28a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e28e:	681b      	ldr	r3, [r3, #0]
    e290:	461a      	mov	r2, r3
    e292:	f64c 43b0 	movw	r3, #52400	; 0xccb0
    e296:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e29a:	78db      	ldrb	r3, [r3, #3]
    e29c:	77d3      	strb	r3, [r2, #31]
			BUF->opcode = HTONS( ARP_REQUEST ); /* ARP request. */
    e29e:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e2a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e2a6:	681b      	ldr	r3, [r3, #0]
    e2a8:	f04f 0200 	mov.w	r2, #0
    e2ac:	751a      	strb	r2, [r3, #20]
    e2ae:	f04f 0200 	mov.w	r2, #0
    e2b2:	f042 0201 	orr.w	r2, r2, #1
    e2b6:	755a      	strb	r2, [r3, #21]
			BUF->hwtype = HTONS( ARP_HWTYPE_ETH );
    e2b8:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e2bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e2c0:	681b      	ldr	r3, [r3, #0]
    e2c2:	f04f 0200 	mov.w	r2, #0
    e2c6:	739a      	strb	r2, [r3, #14]
    e2c8:	f04f 0200 	mov.w	r2, #0
    e2cc:	f042 0201 	orr.w	r2, r2, #1
    e2d0:	73da      	strb	r2, [r3, #15]
			BUF->protocol = HTONS( UIP_ETHTYPE_IP );
    e2d2:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e2d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e2da:	681b      	ldr	r3, [r3, #0]
    e2dc:	f04f 0200 	mov.w	r2, #0
    e2e0:	f042 0208 	orr.w	r2, r2, #8
    e2e4:	741a      	strb	r2, [r3, #16]
    e2e6:	f04f 0200 	mov.w	r2, #0
    e2ea:	745a      	strb	r2, [r3, #17]
			BUF->hwlen = 6;
    e2ec:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e2f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e2f4:	681b      	ldr	r3, [r3, #0]
    e2f6:	f04f 0206 	mov.w	r2, #6
    e2fa:	749a      	strb	r2, [r3, #18]
			BUF->protolen = 4;
    e2fc:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e300:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e304:	681b      	ldr	r3, [r3, #0]
    e306:	f04f 0204 	mov.w	r2, #4
    e30a:	74da      	strb	r2, [r3, #19]
			BUF->ethhdr.type = HTONS( UIP_ETHTYPE_ARP );
    e30c:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e310:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e314:	681b      	ldr	r3, [r3, #0]
    e316:	f04f 0200 	mov.w	r2, #0
    e31a:	f042 0208 	orr.w	r2, r2, #8
    e31e:	731a      	strb	r2, [r3, #12]
    e320:	f04f 0200 	mov.w	r2, #0
    e324:	f042 0206 	orr.w	r2, r2, #6
    e328:	735a      	strb	r2, [r3, #13]

			uip_appdata = &uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN];
    e32a:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e32e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e332:	681b      	ldr	r3, [r3, #0]
    e334:	f103 0236 	add.w	r2, r3, #54	; 0x36
    e338:	f64a 4338 	movw	r3, #44088	; 0xac38
    e33c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e340:	601a      	str	r2, [r3, #0]

			uip_len = sizeof( struct arp_hdr );
    e342:	f64a 4328 	movw	r3, #44072	; 0xac28
    e346:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e34a:	f04f 022a 	mov.w	r2, #42	; 0x2a
    e34e:	801a      	strh	r2, [r3, #0]
			return;
    e350:	e038      	b.n	e3c4 <uip_arp_out+0x480>
		}

		/* Build an ethernet header. */
		memcpy( IPBUF->ethhdr.dest.addr, tabptr->ethaddr.addr, 6 );
    e352:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e356:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e35a:	681b      	ldr	r3, [r3, #0]
    e35c:	461a      	mov	r2, r3
    e35e:	687b      	ldr	r3, [r7, #4]
    e360:	f103 0304 	add.w	r3, r3, #4
    e364:	4610      	mov	r0, r2
    e366:	4619      	mov	r1, r3
    e368:	f04f 0206 	mov.w	r2, #6
    e36c:	f006 fd1a 	bl	14da4 <memcpy>
	}

	memcpy( IPBUF->ethhdr.src.addr, uip_ethaddr.addr, 6 );
    e370:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e374:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e378:	681b      	ldr	r3, [r3, #0]
    e37a:	f103 0306 	add.w	r3, r3, #6
    e37e:	4618      	mov	r0, r3
    e380:	f642 717c 	movw	r1, #12156	; 0x2f7c
    e384:	f2c2 0100 	movt	r1, #8192	; 0x2000
    e388:	f04f 0206 	mov.w	r2, #6
    e38c:	f006 fd0a 	bl	14da4 <memcpy>

	IPBUF->ethhdr.type = HTONS( UIP_ETHTYPE_IP );
    e390:	f240 63a4 	movw	r3, #1700	; 0x6a4
    e394:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e398:	681b      	ldr	r3, [r3, #0]
    e39a:	f04f 0200 	mov.w	r2, #0
    e39e:	f042 0208 	orr.w	r2, r2, #8
    e3a2:	731a      	strb	r2, [r3, #12]
    e3a4:	f04f 0200 	mov.w	r2, #0
    e3a8:	735a      	strb	r2, [r3, #13]

	uip_len += sizeof( struct uip_eth_hdr );
    e3aa:	f64a 4328 	movw	r3, #44072	; 0xac28
    e3ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e3b2:	881b      	ldrh	r3, [r3, #0]
    e3b4:	f103 030e 	add.w	r3, r3, #14
    e3b8:	b29a      	uxth	r2, r3
    e3ba:	f64a 4328 	movw	r3, #44072	; 0xac28
    e3be:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e3c2:	801a      	strh	r2, [r3, #0]
}
    e3c4:	f107 0708 	add.w	r7, r7, #8
    e3c8:	46bd      	mov	sp, r7
    e3ca:	bd80      	pop	{r7, pc}

0000e3cc <httpd_fs_strcmp>:
static u16_t	count[HTTPD_FS_NUMFILES];
#endif /* HTTPD_FS_STATISTICS */

/*-----------------------------------------------------------------------------------*/
static u8_t httpd_fs_strcmp( const char *str1, const char *str2 )
{
    e3cc:	b480      	push	{r7}
    e3ce:	b085      	sub	sp, #20
    e3d0:	af00      	add	r7, sp, #0
    e3d2:	6078      	str	r0, [r7, #4]
    e3d4:	6039      	str	r1, [r7, #0]
	u8_t	i;
	i = 0;
    e3d6:	f04f 0300 	mov.w	r3, #0
    e3da:	73fb      	strb	r3, [r7, #15]
loop:
	if( str2[i] == 0 || str1[i] == '\r' || str1[i] == '\n' )
    e3dc:	7bfa      	ldrb	r2, [r7, #15]
    e3de:	683b      	ldr	r3, [r7, #0]
    e3e0:	4413      	add	r3, r2
    e3e2:	781b      	ldrb	r3, [r3, #0]
    e3e4:	2b00      	cmp	r3, #0
    e3e6:	d00b      	beq.n	e400 <httpd_fs_strcmp+0x34>
    e3e8:	7bfa      	ldrb	r2, [r7, #15]
    e3ea:	687b      	ldr	r3, [r7, #4]
    e3ec:	4413      	add	r3, r2
    e3ee:	781b      	ldrb	r3, [r3, #0]
    e3f0:	2b0d      	cmp	r3, #13
    e3f2:	d005      	beq.n	e400 <httpd_fs_strcmp+0x34>
    e3f4:	7bfa      	ldrb	r2, [r7, #15]
    e3f6:	687b      	ldr	r3, [r7, #4]
    e3f8:	4413      	add	r3, r2
    e3fa:	781b      	ldrb	r3, [r3, #0]
    e3fc:	2b0a      	cmp	r3, #10
    e3fe:	d102      	bne.n	e406 <httpd_fs_strcmp+0x3a>
	{
		return 0;
    e400:	f04f 0300 	mov.w	r3, #0
    e404:	e011      	b.n	e42a <httpd_fs_strcmp+0x5e>
	}

	if( str1[i] != str2[i] )
    e406:	7bfa      	ldrb	r2, [r7, #15]
    e408:	687b      	ldr	r3, [r7, #4]
    e40a:	4413      	add	r3, r2
    e40c:	781a      	ldrb	r2, [r3, #0]
    e40e:	7bf9      	ldrb	r1, [r7, #15]
    e410:	683b      	ldr	r3, [r7, #0]
    e412:	440b      	add	r3, r1
    e414:	781b      	ldrb	r3, [r3, #0]
    e416:	429a      	cmp	r2, r3
    e418:	d002      	beq.n	e420 <httpd_fs_strcmp+0x54>
	{
		return 1;
    e41a:	f04f 0301 	mov.w	r3, #1
    e41e:	e004      	b.n	e42a <httpd_fs_strcmp+0x5e>
	}

	++i;
    e420:	7bfb      	ldrb	r3, [r7, #15]
    e422:	f103 0301 	add.w	r3, r3, #1
    e426:	73fb      	strb	r3, [r7, #15]
	goto loop;
    e428:	e7d8      	b.n	e3dc <httpd_fs_strcmp+0x10>
}
    e42a:	4618      	mov	r0, r3
    e42c:	f107 0714 	add.w	r7, r7, #20
    e430:	46bd      	mov	sp, r7
    e432:	bc80      	pop	{r7}
    e434:	4770      	bx	lr
    e436:	bf00      	nop

0000e438 <httpd_fs_open>:

/*-----------------------------------------------------------------------------------*/
int httpd_fs_open( const char *name, struct httpd_fs_file *file )
{
    e438:	b580      	push	{r7, lr}
    e43a:	b084      	sub	sp, #16
    e43c:	af00      	add	r7, sp, #0
    e43e:	6078      	str	r0, [r7, #4]
    e440:	6039      	str	r1, [r7, #0]
#if HTTPD_FS_STATISTICS
	u16_t								i = 0;
    e442:	f04f 0300 	mov.w	r3, #0
    e446:	817b      	strh	r3, [r7, #10]
#endif /* HTTPD_FS_STATISTICS */
	struct httpd_fsdata_file_noconst	*f;

	for( f = ( struct httpd_fsdata_file_noconst * ) HTTPD_FS_ROOT; f != NULL; f = ( struct httpd_fsdata_file_noconst * ) f->next )
    e448:	f244 0340 	movw	r3, #16448	; 0x4040
    e44c:	f2c0 0302 	movt	r3, #2
    e450:	60fb      	str	r3, [r7, #12]
    e452:	e02a      	b.n	e4aa <httpd_fs_open+0x72>
	{
		if( httpd_fs_strcmp(name, f->name) == 0 )
    e454:	68fb      	ldr	r3, [r7, #12]
    e456:	685b      	ldr	r3, [r3, #4]
    e458:	6878      	ldr	r0, [r7, #4]
    e45a:	4619      	mov	r1, r3
    e45c:	f7ff ffb6 	bl	e3cc <httpd_fs_strcmp>
    e460:	4603      	mov	r3, r0
    e462:	2b00      	cmp	r3, #0
    e464:	d11a      	bne.n	e49c <httpd_fs_open+0x64>
		{
			file->data = f->data;
    e466:	68fb      	ldr	r3, [r7, #12]
    e468:	689a      	ldr	r2, [r3, #8]
    e46a:	683b      	ldr	r3, [r7, #0]
    e46c:	601a      	str	r2, [r3, #0]
			file->len = f->len;
    e46e:	68fb      	ldr	r3, [r7, #12]
    e470:	68da      	ldr	r2, [r3, #12]
    e472:	683b      	ldr	r3, [r7, #0]
    e474:	605a      	str	r2, [r3, #4]
#if HTTPD_FS_STATISTICS
			++count[i];
    e476:	897a      	ldrh	r2, [r7, #10]
    e478:	f642 73fc 	movw	r3, #12284	; 0x2ffc
    e47c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e480:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    e484:	f103 0301 	add.w	r3, r3, #1
    e488:	b299      	uxth	r1, r3
    e48a:	f642 73fc 	movw	r3, #12284	; 0x2ffc
    e48e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e492:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
#endif /* HTTPD_FS_STATISTICS */
			return 1;
    e496:	f04f 0301 	mov.w	r3, #1
    e49a:	e00b      	b.n	e4b4 <httpd_fs_open+0x7c>
		}

#if HTTPD_FS_STATISTICS
		++i;
    e49c:	897b      	ldrh	r3, [r7, #10]
    e49e:	f103 0301 	add.w	r3, r3, #1
    e4a2:	817b      	strh	r3, [r7, #10]
#if HTTPD_FS_STATISTICS
	u16_t								i = 0;
#endif /* HTTPD_FS_STATISTICS */
	struct httpd_fsdata_file_noconst	*f;

	for( f = ( struct httpd_fsdata_file_noconst * ) HTTPD_FS_ROOT; f != NULL; f = ( struct httpd_fsdata_file_noconst * ) f->next )
    e4a4:	68fb      	ldr	r3, [r7, #12]
    e4a6:	681b      	ldr	r3, [r3, #0]
    e4a8:	60fb      	str	r3, [r7, #12]
    e4aa:	68fb      	ldr	r3, [r7, #12]
    e4ac:	2b00      	cmp	r3, #0
    e4ae:	d1d1      	bne.n	e454 <httpd_fs_open+0x1c>
#if HTTPD_FS_STATISTICS
		++i;
#endif /* HTTPD_FS_STATISTICS */
	}

	return 0;
    e4b0:	f04f 0300 	mov.w	r3, #0
}
    e4b4:	4618      	mov	r0, r3
    e4b6:	f107 0710 	add.w	r7, r7, #16
    e4ba:	46bd      	mov	sp, r7
    e4bc:	bd80      	pop	{r7, pc}
    e4be:	bf00      	nop

0000e4c0 <httpd_fs_init>:

/*-----------------------------------------------------------------------------------*/
void httpd_fs_init( void )
{
    e4c0:	b480      	push	{r7}
    e4c2:	b083      	sub	sp, #12
    e4c4:	af00      	add	r7, sp, #0
#if HTTPD_FS_STATISTICS
	u16_t	i;
	for( i = 0; i < HTTPD_FS_NUMFILES; i++ )
    e4c6:	f04f 0300 	mov.w	r3, #0
    e4ca:	80fb      	strh	r3, [r7, #6]
    e4cc:	e00c      	b.n	e4e8 <httpd_fs_init+0x28>
	{
		count[i] = 0;
    e4ce:	88fa      	ldrh	r2, [r7, #6]
    e4d0:	f642 73fc 	movw	r3, #12284	; 0x2ffc
    e4d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e4d8:	f04f 0100 	mov.w	r1, #0
    e4dc:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
/*-----------------------------------------------------------------------------------*/
void httpd_fs_init( void )
{
#if HTTPD_FS_STATISTICS
	u16_t	i;
	for( i = 0; i < HTTPD_FS_NUMFILES; i++ )
    e4e0:	88fb      	ldrh	r3, [r7, #6]
    e4e2:	f103 0301 	add.w	r3, r3, #1
    e4e6:	80fb      	strh	r3, [r7, #6]
    e4e8:	88fb      	ldrh	r3, [r7, #6]
    e4ea:	2b07      	cmp	r3, #7
    e4ec:	d9ef      	bls.n	e4ce <httpd_fs_init+0xe>
	{
		count[i] = 0;
	}

#endif /* HTTPD_FS_STATISTICS */
}
    e4ee:	f107 070c 	add.w	r7, r7, #12
    e4f2:	46bd      	mov	sp, r7
    e4f4:	bc80      	pop	{r7}
    e4f6:	4770      	bx	lr

0000e4f8 <httpd_fs_count>:

/*-----------------------------------------------------------------------------------*/
#if HTTPD_FS_STATISTICS
u16_t httpd_fs_count( char *name )
{
    e4f8:	b580      	push	{r7, lr}
    e4fa:	b084      	sub	sp, #16
    e4fc:	af00      	add	r7, sp, #0
    e4fe:	6078      	str	r0, [r7, #4]
	struct httpd_fsdata_file_noconst	*f;
	u16_t								i;

	i = 0;
    e500:	f04f 0300 	mov.w	r3, #0
    e504:	81fb      	strh	r3, [r7, #14]
	for( f = ( struct httpd_fsdata_file_noconst * ) HTTPD_FS_ROOT; f != NULL; f = ( struct httpd_fsdata_file_noconst * ) f->next )
    e506:	f244 0340 	movw	r3, #16448	; 0x4040
    e50a:	f2c0 0302 	movt	r3, #2
    e50e:	60bb      	str	r3, [r7, #8]
    e510:	e017      	b.n	e542 <httpd_fs_count+0x4a>
	{
		if( httpd_fs_strcmp(name, f->name) == 0 )
    e512:	68bb      	ldr	r3, [r7, #8]
    e514:	685b      	ldr	r3, [r3, #4]
    e516:	6878      	ldr	r0, [r7, #4]
    e518:	4619      	mov	r1, r3
    e51a:	f7ff ff57 	bl	e3cc <httpd_fs_strcmp>
    e51e:	4603      	mov	r3, r0
    e520:	2b00      	cmp	r3, #0
    e522:	d107      	bne.n	e534 <httpd_fs_count+0x3c>
		{
			return count[i];
    e524:	89fa      	ldrh	r2, [r7, #14]
    e526:	f642 73fc 	movw	r3, #12284	; 0x2ffc
    e52a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e52e:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    e532:	e00b      	b.n	e54c <httpd_fs_count+0x54>
		}

		++i;
    e534:	89fb      	ldrh	r3, [r7, #14]
    e536:	f103 0301 	add.w	r3, r3, #1
    e53a:	81fb      	strh	r3, [r7, #14]
{
	struct httpd_fsdata_file_noconst	*f;
	u16_t								i;

	i = 0;
	for( f = ( struct httpd_fsdata_file_noconst * ) HTTPD_FS_ROOT; f != NULL; f = ( struct httpd_fsdata_file_noconst * ) f->next )
    e53c:	68bb      	ldr	r3, [r7, #8]
    e53e:	681b      	ldr	r3, [r3, #0]
    e540:	60bb      	str	r3, [r7, #8]
    e542:	68bb      	ldr	r3, [r7, #8]
    e544:	2b00      	cmp	r3, #0
    e546:	d1e4      	bne.n	e512 <httpd_fs_count+0x1a>
		}

		++i;
	}

	return 0;
    e548:	f04f 0300 	mov.w	r3, #0
}
    e54c:	4618      	mov	r0, r3
    e54e:	f107 0710 	add.w	r7, r7, #16
    e552:	46bd      	mov	sp, r7
    e554:	bd80      	pop	{r7, pc}
    e556:	bf00      	nop

0000e558 <generate_part_of_file>:
#define ISO_slash		0x2f
#define ISO_colon		0x3a

/*---------------------------------------------------------------------------*/
static unsigned short generate_part_of_file( void *state )
{
    e558:	b580      	push	{r7, lr}
    e55a:	b084      	sub	sp, #16
    e55c:	af00      	add	r7, sp, #0
    e55e:	6078      	str	r0, [r7, #4]
	struct httpd_state	*s = ( struct httpd_state * ) state;
    e560:	687b      	ldr	r3, [r7, #4]
    e562:	60fb      	str	r3, [r7, #12]

	if( s->file.len > uip_mss() )
    e564:	68fb      	ldr	r3, [r7, #12]
    e566:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
    e56a:	f64a 433c 	movw	r3, #44092	; 0xac3c
    e56e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e572:	681b      	ldr	r3, [r3, #0]
    e574:	8a5b      	ldrh	r3, [r3, #18]
    e576:	429a      	cmp	r2, r3
    e578:	dd0a      	ble.n	e590 <generate_part_of_file+0x38>
	{
		s->len = uip_mss();
    e57a:	f64a 433c 	movw	r3, #44092	; 0xac3c
    e57e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e582:	681b      	ldr	r3, [r3, #0]
    e584:	8a5b      	ldrh	r3, [r3, #18]
    e586:	461a      	mov	r2, r3
    e588:	68fb      	ldr	r3, [r7, #12]
    e58a:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    e58e:	e005      	b.n	e59c <generate_part_of_file+0x44>
	}
	else
	{
		s->len = s->file.len;
    e590:	68fb      	ldr	r3, [r7, #12]
    e592:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
    e596:	68fb      	ldr	r3, [r7, #12]
    e598:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	}

	memcpy( uip_appdata, s->file.data, s->len );
    e59c:	f64a 4338 	movw	r3, #44088	; 0xac38
    e5a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e5a4:	6819      	ldr	r1, [r3, #0]
    e5a6:	68fb      	ldr	r3, [r7, #12]
    e5a8:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
    e5ac:	68fb      	ldr	r3, [r7, #12]
    e5ae:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    e5b2:	4608      	mov	r0, r1
    e5b4:	4611      	mov	r1, r2
    e5b6:	461a      	mov	r2, r3
    e5b8:	f006 fbf4 	bl	14da4 <memcpy>

	return s->len;
    e5bc:	68fb      	ldr	r3, [r7, #12]
    e5be:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    e5c2:	b29b      	uxth	r3, r3
}
    e5c4:	4618      	mov	r0, r3
    e5c6:	f107 0710 	add.w	r7, r7, #16
    e5ca:	46bd      	mov	sp, r7
    e5cc:	bd80      	pop	{r7, pc}
    e5ce:	bf00      	nop

0000e5d0 <send_file>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( send_file ( struct httpd_state *s ) )
{
    e5d0:	b580      	push	{r7, lr}
    e5d2:	b084      	sub	sp, #16
    e5d4:	af00      	add	r7, sp, #0
    e5d6:	6078      	str	r0, [r7, #4]
	PSOCK_BEGIN( &s->sout );
    e5d8:	f04f 0301 	mov.w	r3, #1
    e5dc:	73fb      	strb	r3, [r7, #15]
    e5de:	687b      	ldr	r3, [r7, #4]
    e5e0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    e5e2:	2b00      	cmp	r3, #0
    e5e4:	d002      	beq.n	e5ec <send_file+0x1c>
    e5e6:	2b67      	cmp	r3, #103	; 0x67
    e5e8:	d004      	beq.n	e5f4 <send_file+0x24>
    e5ea:	e02e      	b.n	e64a <send_file+0x7a>

	( void ) PT_YIELD_FLAG;
	
	do
	{
		PSOCK_GENERATOR_SEND( &s->sout, generate_part_of_file, s );
    e5ec:	687b      	ldr	r3, [r7, #4]
    e5ee:	f04f 0267 	mov.w	r2, #103	; 0x67
    e5f2:	851a      	strh	r2, [r3, #40]	; 0x28
    e5f4:	687b      	ldr	r3, [r7, #4]
    e5f6:	f103 0328 	add.w	r3, r3, #40	; 0x28
    e5fa:	4618      	mov	r0, r3
    e5fc:	f24e 5159 	movw	r1, #58713	; 0xe559
    e600:	f2c0 0100 	movt	r1, #0
    e604:	687a      	ldr	r2, [r7, #4]
    e606:	f7fc fa2d 	bl	aa64 <psock_generator_send>
    e60a:	4603      	mov	r3, r0
    e60c:	2b00      	cmp	r3, #0
    e60e:	d102      	bne.n	e616 <send_file+0x46>
    e610:	f04f 0300 	mov.w	r3, #0
    e614:	e022      	b.n	e65c <send_file+0x8c>
		s->file.len -= s->len;
    e616:	687b      	ldr	r3, [r7, #4]
    e618:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
    e61c:	687b      	ldr	r3, [r7, #4]
    e61e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    e622:	ebc3 0202 	rsb	r2, r3, r2
    e626:	687b      	ldr	r3, [r7, #4]
    e628:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
		s->file.data += s->len;
    e62c:	687b      	ldr	r3, [r7, #4]
    e62e:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
    e632:	687b      	ldr	r3, [r7, #4]
    e634:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    e638:	441a      	add	r2, r3
    e63a:	687b      	ldr	r3, [r7, #4]
    e63c:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
	} while( s->file.len > 0 );
    e640:	687b      	ldr	r3, [r7, #4]
    e642:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
    e646:	2b00      	cmp	r3, #0
    e648:	dcd0      	bgt.n	e5ec <send_file+0x1c>

	PSOCK_END( &s->sout );
    e64a:	f04f 0300 	mov.w	r3, #0
    e64e:	73fb      	strb	r3, [r7, #15]
    e650:	687b      	ldr	r3, [r7, #4]
    e652:	f04f 0200 	mov.w	r2, #0
    e656:	851a      	strh	r2, [r3, #40]	; 0x28
    e658:	f04f 0302 	mov.w	r3, #2
}
    e65c:	4618      	mov	r0, r3
    e65e:	f107 0710 	add.w	r7, r7, #16
    e662:	46bd      	mov	sp, r7
    e664:	bd80      	pop	{r7, pc}
    e666:	bf00      	nop

0000e668 <send_part_of_file>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( send_part_of_file ( struct httpd_state *s ) )
{
    e668:	b580      	push	{r7, lr}
    e66a:	b084      	sub	sp, #16
    e66c:	af00      	add	r7, sp, #0
    e66e:	6078      	str	r0, [r7, #4]
	PSOCK_BEGIN( &s->sout );
    e670:	f04f 0301 	mov.w	r3, #1
    e674:	73fb      	strb	r3, [r7, #15]
    e676:	687b      	ldr	r3, [r7, #4]
    e678:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    e67a:	2b00      	cmp	r3, #0
    e67c:	d002      	beq.n	e684 <send_part_of_file+0x1c>
    e67e:	2b75      	cmp	r3, #117	; 0x75
    e680:	d004      	beq.n	e68c <send_part_of_file+0x24>
    e682:	e017      	b.n	e6b4 <send_part_of_file+0x4c>
	( void ) PT_YIELD_FLAG;
	
	PSOCK_SEND( &s->sout, s->file.data, s->len );
    e684:	687b      	ldr	r3, [r7, #4]
    e686:	f04f 0275 	mov.w	r2, #117	; 0x75
    e68a:	851a      	strh	r2, [r3, #40]	; 0x28
    e68c:	687b      	ldr	r3, [r7, #4]
    e68e:	f103 0128 	add.w	r1, r3, #40	; 0x28
    e692:	687b      	ldr	r3, [r7, #4]
    e694:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
    e698:	687b      	ldr	r3, [r7, #4]
    e69a:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    e69e:	4608      	mov	r0, r1
    e6a0:	4611      	mov	r1, r2
    e6a2:	461a      	mov	r2, r3
    e6a4:	f7fc f994 	bl	a9d0 <psock_send>
    e6a8:	4603      	mov	r3, r0
    e6aa:	2b00      	cmp	r3, #0
    e6ac:	d102      	bne.n	e6b4 <send_part_of_file+0x4c>
    e6ae:	f04f 0300 	mov.w	r3, #0
    e6b2:	e008      	b.n	e6c6 <send_part_of_file+0x5e>

	PSOCK_END( &s->sout );
    e6b4:	f04f 0300 	mov.w	r3, #0
    e6b8:	73fb      	strb	r3, [r7, #15]
    e6ba:	687b      	ldr	r3, [r7, #4]
    e6bc:	f04f 0200 	mov.w	r2, #0
    e6c0:	851a      	strh	r2, [r3, #40]	; 0x28
    e6c2:	f04f 0302 	mov.w	r3, #2
}
    e6c6:	4618      	mov	r0, r3
    e6c8:	f107 0710 	add.w	r7, r7, #16
    e6cc:	46bd      	mov	sp, r7
    e6ce:	bd80      	pop	{r7, pc}

0000e6d0 <next_scriptstate>:

/*---------------------------------------------------------------------------*/
static void next_scriptstate( struct httpd_state *s )
{
    e6d0:	b580      	push	{r7, lr}
    e6d2:	b084      	sub	sp, #16
    e6d4:	af00      	add	r7, sp, #0
    e6d6:	6078      	str	r0, [r7, #4]
	char	*p;
	p = strchr( s->scriptptr, ISO_nl ) + 1;
    e6d8:	687b      	ldr	r3, [r7, #4]
    e6da:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
    e6de:	4618      	mov	r0, r3
    e6e0:	f04f 010a 	mov.w	r1, #10
    e6e4:	f006 fd6c 	bl	151c0 <strchr>
    e6e8:	4603      	mov	r3, r0
    e6ea:	f103 0301 	add.w	r3, r3, #1
    e6ee:	60fb      	str	r3, [r7, #12]
	s->scriptlen -= ( unsigned short ) ( p - s->scriptptr );
    e6f0:	687b      	ldr	r3, [r7, #4]
    e6f2:	f8d3 20a8 	ldr.w	r2, [r3, #168]	; 0xa8
    e6f6:	68fb      	ldr	r3, [r7, #12]
    e6f8:	b299      	uxth	r1, r3
    e6fa:	687b      	ldr	r3, [r7, #4]
    e6fc:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
    e700:	b29b      	uxth	r3, r3
    e702:	ebc3 0301 	rsb	r3, r3, r1
    e706:	b29b      	uxth	r3, r3
    e708:	ebc3 0202 	rsb	r2, r3, r2
    e70c:	687b      	ldr	r3, [r7, #4]
    e70e:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	s->scriptptr = p;
    e712:	687b      	ldr	r3, [r7, #4]
    e714:	68fa      	ldr	r2, [r7, #12]
    e716:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
}
    e71a:	f107 0710 	add.w	r7, r7, #16
    e71e:	46bd      	mov	sp, r7
    e720:	bd80      	pop	{r7, pc}
    e722:	bf00      	nop

0000e724 <handle_script>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( handle_script ( struct httpd_state *s ) )
{
    e724:	b580      	push	{r7, lr}
    e726:	b084      	sub	sp, #16
    e728:	af00      	add	r7, sp, #0
    e72a:	6078      	str	r0, [r7, #4]
	char	*ptr;

	PT_BEGIN( &s->scriptpt );
    e72c:	f04f 0301 	mov.w	r3, #1
    e730:	73fb      	strb	r3, [r7, #15]
    e732:	687b      	ldr	r3, [r7, #4]
    e734:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
    e738:	2b94      	cmp	r3, #148	; 0x94
    e73a:	d042      	beq.n	e7c2 <handle_script+0x9e>
    e73c:	2b94      	cmp	r3, #148	; 0x94
    e73e:	dc03      	bgt.n	e748 <handle_script+0x24>
    e740:	2b00      	cmp	r3, #0
    e742:	f000 80f3 	beq.w	e92c <handle_script+0x208>
    e746:	e0f8      	b.n	e93a <handle_script+0x216>
    e748:	2b98      	cmp	r3, #152	; 0x98
    e74a:	d048      	beq.n	e7de <handle_script+0xba>
    e74c:	2bc1      	cmp	r3, #193	; 0xc1
    e74e:	f000 80ce 	beq.w	e8ee <handle_script+0x1ca>
    e752:	e0f2      	b.n	e93a <handle_script+0x216>
	( void ) PT_YIELD_FLAG;
	while( s->file.len > 0 )
	{
		/* Check if we should start executing a script. */
		if( *s->file.data == ISO_percent && *(s->file.data + 1) == ISO_bang )
    e754:	687b      	ldr	r3, [r7, #4]
    e756:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    e75a:	781b      	ldrb	r3, [r3, #0]
    e75c:	2b25      	cmp	r3, #37	; 0x25
    e75e:	d161      	bne.n	e824 <handle_script+0x100>
    e760:	687b      	ldr	r3, [r7, #4]
    e762:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    e766:	f103 0301 	add.w	r3, r3, #1
    e76a:	781b      	ldrb	r3, [r3, #0]
    e76c:	2b21      	cmp	r3, #33	; 0x21
    e76e:	d159      	bne.n	e824 <handle_script+0x100>
		{
			s->scriptptr = s->file.data + 3;
    e770:	687b      	ldr	r3, [r7, #4]
    e772:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    e776:	f103 0203 	add.w	r2, r3, #3
    e77a:	687b      	ldr	r3, [r7, #4]
    e77c:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
			s->scriptlen = s->file.len - 3;
    e780:	687b      	ldr	r3, [r7, #4]
    e782:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
    e786:	f1a3 0203 	sub.w	r2, r3, #3
    e78a:	687b      	ldr	r3, [r7, #4]
    e78c:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
			if( *(s->scriptptr - 1) == ISO_colon )
    e790:	687b      	ldr	r3, [r7, #4]
    e792:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
    e796:	f103 33ff 	add.w	r3, r3, #4294967295
    e79a:	781b      	ldrb	r3, [r3, #0]
    e79c:	2b3a      	cmp	r3, #58	; 0x3a
    e79e:	d119      	bne.n	e7d4 <handle_script+0xb0>
			{
				httpd_fs_open( s->scriptptr + 1, &s->file );
    e7a0:	687b      	ldr	r3, [r7, #4]
    e7a2:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
    e7a6:	f103 0201 	add.w	r2, r3, #1
    e7aa:	687b      	ldr	r3, [r7, #4]
    e7ac:	f103 0398 	add.w	r3, r3, #152	; 0x98
    e7b0:	4610      	mov	r0, r2
    e7b2:	4619      	mov	r1, r3
    e7b4:	f7ff fe40 	bl	e438 <httpd_fs_open>
				PT_WAIT_THREAD( &s->scriptpt, send_file(s) );
    e7b8:	687b      	ldr	r3, [r7, #4]
    e7ba:	f04f 0294 	mov.w	r2, #148	; 0x94
    e7be:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    e7c2:	6878      	ldr	r0, [r7, #4]
    e7c4:	f7ff ff04 	bl	e5d0 <send_file>
    e7c8:	4603      	mov	r3, r0
    e7ca:	2b00      	cmp	r3, #0
    e7cc:	d11a      	bne.n	e804 <handle_script+0xe0>
    e7ce:	f04f 0300 	mov.w	r3, #0
    e7d2:	e0bc      	b.n	e94e <handle_script+0x22a>
			}
			else
			{
				PT_WAIT_THREAD( &s->scriptpt, httpd_cgi(s->scriptptr) (s, s->scriptptr) );
    e7d4:	687b      	ldr	r3, [r7, #4]
    e7d6:	f04f 0298 	mov.w	r2, #152	; 0x98
    e7da:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    e7de:	687b      	ldr	r3, [r7, #4]
    e7e0:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
    e7e4:	4618      	mov	r0, r3
    e7e6:	f7f2 fde1 	bl	13ac <httpd_cgi>
    e7ea:	4603      	mov	r3, r0
    e7ec:	687a      	ldr	r2, [r7, #4]
    e7ee:	f8d2 20a4 	ldr.w	r2, [r2, #164]	; 0xa4
    e7f2:	6878      	ldr	r0, [r7, #4]
    e7f4:	4611      	mov	r1, r2
    e7f6:	4798      	blx	r3
    e7f8:	4603      	mov	r3, r0
    e7fa:	2b00      	cmp	r3, #0
    e7fc:	d102      	bne.n	e804 <handle_script+0xe0>
    e7fe:	f04f 0300 	mov.w	r3, #0
    e802:	e0a4      	b.n	e94e <handle_script+0x22a>
			}

			next_scriptstate( s );
    e804:	6878      	ldr	r0, [r7, #4]
    e806:	f7ff ff63 	bl	e6d0 <next_scriptstate>

			/* The script is over, so we reset the pointers and continue
	 		sending the rest of the file. */
			s->file.data = s->scriptptr;
    e80a:	687b      	ldr	r3, [r7, #4]
    e80c:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
    e810:	687b      	ldr	r3, [r7, #4]
    e812:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
			s->file.len = s->scriptlen;
    e816:	687b      	ldr	r3, [r7, #4]
    e818:	f8d3 20a8 	ldr.w	r2, [r3, #168]	; 0xa8
    e81c:	687b      	ldr	r3, [r7, #4]
    e81e:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
	PT_BEGIN( &s->scriptpt );
	( void ) PT_YIELD_FLAG;
	while( s->file.len > 0 )
	{
		/* Check if we should start executing a script. */
		if( *s->file.data == ISO_percent && *(s->file.data + 1) == ISO_bang )
    e822:	e084      	b.n	e92e <handle_script+0x20a>
		}
		else
		{
			/* See if we find the start of script marker in the block of HTML
	 to be sent. */
			if( s->file.len > uip_mss() )
    e824:	687b      	ldr	r3, [r7, #4]
    e826:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
    e82a:	f64a 433c 	movw	r3, #44092	; 0xac3c
    e82e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e832:	681b      	ldr	r3, [r3, #0]
    e834:	8a5b      	ldrh	r3, [r3, #18]
    e836:	429a      	cmp	r2, r3
    e838:	dd0a      	ble.n	e850 <handle_script+0x12c>
			{
				s->len = uip_mss();
    e83a:	f64a 433c 	movw	r3, #44092	; 0xac3c
    e83e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e842:	681b      	ldr	r3, [r3, #0]
    e844:	8a5b      	ldrh	r3, [r3, #18]
    e846:	461a      	mov	r2, r3
    e848:	687b      	ldr	r3, [r7, #4]
    e84a:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    e84e:	e005      	b.n	e85c <handle_script+0x138>
			}
			else
			{
				s->len = s->file.len;
    e850:	687b      	ldr	r3, [r7, #4]
    e852:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
    e856:	687b      	ldr	r3, [r7, #4]
    e858:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
			}

			if( *s->file.data == ISO_percent )
    e85c:	687b      	ldr	r3, [r7, #4]
    e85e:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    e862:	781b      	ldrb	r3, [r3, #0]
    e864:	2b25      	cmp	r3, #37	; 0x25
    e866:	d10c      	bne.n	e882 <handle_script+0x15e>
			{
				ptr = strchr( s->file.data + 1, ISO_percent );
    e868:	687b      	ldr	r3, [r7, #4]
    e86a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    e86e:	f103 0301 	add.w	r3, r3, #1
    e872:	4618      	mov	r0, r3
    e874:	f04f 0125 	mov.w	r1, #37	; 0x25
    e878:	f006 fca2 	bl	151c0 <strchr>
    e87c:	4603      	mov	r3, r0
    e87e:	60bb      	str	r3, [r7, #8]
    e880:	e009      	b.n	e896 <handle_script+0x172>
			}
			else
			{
				ptr = strchr( s->file.data, ISO_percent );
    e882:	687b      	ldr	r3, [r7, #4]
    e884:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    e888:	4618      	mov	r0, r3
    e88a:	f04f 0125 	mov.w	r1, #37	; 0x25
    e88e:	f006 fc97 	bl	151c0 <strchr>
    e892:	4603      	mov	r3, r0
    e894:	60bb      	str	r3, [r7, #8]
			}

			if( ptr != NULL && ptr != s->file.data )
    e896:	68bb      	ldr	r3, [r7, #8]
    e898:	2b00      	cmp	r3, #0
    e89a:	d023      	beq.n	e8e4 <handle_script+0x1c0>
    e89c:	687b      	ldr	r3, [r7, #4]
    e89e:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
    e8a2:	68bb      	ldr	r3, [r7, #8]
    e8a4:	429a      	cmp	r2, r3
    e8a6:	d01d      	beq.n	e8e4 <handle_script+0x1c0>
			{
				s->len = ( int ) ( ptr - s->file.data );
    e8a8:	68ba      	ldr	r2, [r7, #8]
    e8aa:	687b      	ldr	r3, [r7, #4]
    e8ac:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    e8b0:	ebc3 0202 	rsb	r2, r3, r2
    e8b4:	687b      	ldr	r3, [r7, #4]
    e8b6:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
				if( s->len >= uip_mss() )
    e8ba:	687b      	ldr	r3, [r7, #4]
    e8bc:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
    e8c0:	f64a 433c 	movw	r3, #44092	; 0xac3c
    e8c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e8c8:	681b      	ldr	r3, [r3, #0]
    e8ca:	8a5b      	ldrh	r3, [r3, #18]
    e8cc:	429a      	cmp	r2, r3
    e8ce:	db09      	blt.n	e8e4 <handle_script+0x1c0>
				{
					s->len = uip_mss();
    e8d0:	f64a 433c 	movw	r3, #44092	; 0xac3c
    e8d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e8d8:	681b      	ldr	r3, [r3, #0]
    e8da:	8a5b      	ldrh	r3, [r3, #18]
    e8dc:	461a      	mov	r2, r3
    e8de:	687b      	ldr	r3, [r7, #4]
    e8e0:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
				}
			}

			PT_WAIT_THREAD( &s->scriptpt, send_part_of_file(s) );
    e8e4:	687b      	ldr	r3, [r7, #4]
    e8e6:	f04f 02c1 	mov.w	r2, #193	; 0xc1
    e8ea:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    e8ee:	6878      	ldr	r0, [r7, #4]
    e8f0:	f7ff feba 	bl	e668 <send_part_of_file>
    e8f4:	4603      	mov	r3, r0
    e8f6:	2b00      	cmp	r3, #0
    e8f8:	d102      	bne.n	e900 <handle_script+0x1dc>
    e8fa:	f04f 0300 	mov.w	r3, #0
    e8fe:	e026      	b.n	e94e <handle_script+0x22a>
			s->file.data += s->len;
    e900:	687b      	ldr	r3, [r7, #4]
    e902:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
    e906:	687b      	ldr	r3, [r7, #4]
    e908:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    e90c:	441a      	add	r2, r3
    e90e:	687b      	ldr	r3, [r7, #4]
    e910:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
			s->file.len -= s->len;
    e914:	687b      	ldr	r3, [r7, #4]
    e916:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
    e91a:	687b      	ldr	r3, [r7, #4]
    e91c:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    e920:	ebc3 0202 	rsb	r2, r3, r2
    e924:	687b      	ldr	r3, [r7, #4]
    e926:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
    e92a:	e000      	b.n	e92e <handle_script+0x20a>
{
	char	*ptr;

	PT_BEGIN( &s->scriptpt );
	( void ) PT_YIELD_FLAG;
	while( s->file.len > 0 )
    e92c:	bf00      	nop
    e92e:	687b      	ldr	r3, [r7, #4]
    e930:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
    e934:	2b00      	cmp	r3, #0
    e936:	f73f af0d 	bgt.w	e754 <handle_script+0x30>
			s->file.data += s->len;
			s->file.len -= s->len;
		}
	}

	PT_END( &s->scriptpt );
    e93a:	f04f 0300 	mov.w	r3, #0
    e93e:	73fb      	strb	r3, [r7, #15]
    e940:	687b      	ldr	r3, [r7, #4]
    e942:	f04f 0200 	mov.w	r2, #0
    e946:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    e94a:	f04f 0302 	mov.w	r3, #2
}
    e94e:	4618      	mov	r0, r3
    e950:	f107 0710 	add.w	r7, r7, #16
    e954:	46bd      	mov	sp, r7
    e956:	bd80      	pop	{r7, pc}

0000e958 <send_headers>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( send_headers ( struct httpd_state *s, const char *statushdr ) )
{
    e958:	b590      	push	{r4, r7, lr}
    e95a:	b085      	sub	sp, #20
    e95c:	af00      	add	r7, sp, #0
    e95e:	6078      	str	r0, [r7, #4]
    e960:	6039      	str	r1, [r7, #0]
	char	*ptr;

	PSOCK_BEGIN( &s->sout );
    e962:	f04f 0301 	mov.w	r3, #1
    e966:	73fb      	strb	r3, [r7, #15]
    e968:	687b      	ldr	r3, [r7, #4]
    e96a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    e96c:	2bde      	cmp	r3, #222	; 0xde
    e96e:	f000 80a3 	beq.w	eab8 <send_headers+0x160>
    e972:	2bde      	cmp	r3, #222	; 0xde
    e974:	dc0b      	bgt.n	e98e <send_headers+0x36>
    e976:	2bd1      	cmp	r3, #209	; 0xd1
    e978:	d01d      	beq.n	e9b6 <send_headers+0x5e>
    e97a:	2bd1      	cmp	r3, #209	; 0xd1
    e97c:	dc02      	bgt.n	e984 <send_headers+0x2c>
    e97e:	2b00      	cmp	r3, #0
    e980:	d015      	beq.n	e9ae <send_headers+0x56>
    e982:	e147      	b.n	ec14 <send_headers+0x2bc>
    e984:	2bd6      	cmp	r3, #214	; 0xd6
    e986:	d039      	beq.n	e9fc <send_headers+0xa4>
    e988:	2bda      	cmp	r3, #218	; 0xda
    e98a:	d06c      	beq.n	ea66 <send_headers+0x10e>
    e98c:	e142      	b.n	ec14 <send_headers+0x2bc>
    e98e:	2be6      	cmp	r3, #230	; 0xe6
    e990:	f000 80e3 	beq.w	eb5a <send_headers+0x202>
    e994:	2be6      	cmp	r3, #230	; 0xe6
    e996:	dc03      	bgt.n	e9a0 <send_headers+0x48>
    e998:	2be2      	cmp	r3, #226	; 0xe2
    e99a:	f000 80b6 	beq.w	eb0a <send_headers+0x1b2>
    e99e:	e139      	b.n	ec14 <send_headers+0x2bc>
    e9a0:	2bea      	cmp	r3, #234	; 0xea
    e9a2:	f000 8102 	beq.w	ebaa <send_headers+0x252>
    e9a6:	2bee      	cmp	r3, #238	; 0xee
    e9a8:	f000 811b 	beq.w	ebe2 <send_headers+0x28a>
    e9ac:	e132      	b.n	ec14 <send_headers+0x2bc>
	( void ) PT_YIELD_FLAG;
	PSOCK_SEND_STR( &s->sout, statushdr );
    e9ae:	687b      	ldr	r3, [r7, #4]
    e9b0:	f04f 02d1 	mov.w	r2, #209	; 0xd1
    e9b4:	851a      	strh	r2, [r3, #40]	; 0x28
    e9b6:	687b      	ldr	r3, [r7, #4]
    e9b8:	f103 0428 	add.w	r4, r3, #40	; 0x28
    e9bc:	6838      	ldr	r0, [r7, #0]
    e9be:	f006 fcbd 	bl	1533c <strlen>
    e9c2:	4603      	mov	r3, r0
    e9c4:	4620      	mov	r0, r4
    e9c6:	6839      	ldr	r1, [r7, #0]
    e9c8:	461a      	mov	r2, r3
    e9ca:	f7fc f801 	bl	a9d0 <psock_send>
    e9ce:	4603      	mov	r3, r0
    e9d0:	2b00      	cmp	r3, #0
    e9d2:	d102      	bne.n	e9da <send_headers+0x82>
    e9d4:	f04f 0300 	mov.w	r3, #0
    e9d8:	e125      	b.n	ec26 <send_headers+0x2ce>

	ptr = strrchr( s->filename, ISO_period );
    e9da:	687b      	ldr	r3, [r7, #4]
    e9dc:	f103 0382 	add.w	r3, r3, #130	; 0x82
    e9e0:	4618      	mov	r0, r3
    e9e2:	f04f 012e 	mov.w	r1, #46	; 0x2e
    e9e6:	f006 fd69 	bl	154bc <strrchr>
    e9ea:	4603      	mov	r3, r0
    e9ec:	60bb      	str	r3, [r7, #8]
	if( ptr == NULL )
    e9ee:	68bb      	ldr	r3, [r7, #8]
    e9f0:	2b00      	cmp	r3, #0
    e9f2:	d11c      	bne.n	ea2e <send_headers+0xd6>
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_binary );
    e9f4:	687b      	ldr	r3, [r7, #4]
    e9f6:	f04f 02d6 	mov.w	r2, #214	; 0xd6
    e9fa:	851a      	strh	r2, [r3, #40]	; 0x28
    e9fc:	687b      	ldr	r3, [r7, #4]
    e9fe:	f103 0428 	add.w	r4, r3, #40	; 0x28
    ea02:	f64b 10fc 	movw	r0, #47612	; 0xb9fc
    ea06:	f2c0 0001 	movt	r0, #1
    ea0a:	f006 fc97 	bl	1533c <strlen>
    ea0e:	4603      	mov	r3, r0
    ea10:	4620      	mov	r0, r4
    ea12:	f64b 11fc 	movw	r1, #47612	; 0xb9fc
    ea16:	f2c0 0101 	movt	r1, #1
    ea1a:	461a      	mov	r2, r3
    ea1c:	f7fb ffd8 	bl	a9d0 <psock_send>
    ea20:	4603      	mov	r3, r0
    ea22:	2b00      	cmp	r3, #0
    ea24:	f040 80f6 	bne.w	ec14 <send_headers+0x2bc>
    ea28:	f04f 0300 	mov.w	r3, #0
    ea2c:	e0fb      	b.n	ec26 <send_headers+0x2ce>
	}
	else if( strncmp(http_html, ptr, 5) == 0 || strncmp(http_shtml, ptr, 6) == 0 )
    ea2e:	f64b 2028 	movw	r0, #47656	; 0xba28
    ea32:	f2c0 0001 	movt	r0, #1
    ea36:	68b9      	ldr	r1, [r7, #8]
    ea38:	f04f 0205 	mov.w	r2, #5
    ea3c:	f006 fcae 	bl	1539c <strncmp>
    ea40:	4603      	mov	r3, r0
    ea42:	2b00      	cmp	r3, #0
    ea44:	d00b      	beq.n	ea5e <send_headers+0x106>
    ea46:	f64b 2030 	movw	r0, #47664	; 0xba30
    ea4a:	f2c0 0001 	movt	r0, #1
    ea4e:	68b9      	ldr	r1, [r7, #8]
    ea50:	f04f 0206 	mov.w	r2, #6
    ea54:	f006 fca2 	bl	1539c <strncmp>
    ea58:	4603      	mov	r3, r0
    ea5a:	2b00      	cmp	r3, #0
    ea5c:	d11c      	bne.n	ea98 <send_headers+0x140>
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_html );
    ea5e:	687b      	ldr	r3, [r7, #4]
    ea60:	f04f 02da 	mov.w	r2, #218	; 0xda
    ea64:	851a      	strh	r2, [r3, #40]	; 0x28
    ea66:	687b      	ldr	r3, [r7, #4]
    ea68:	f103 0428 	add.w	r4, r3, #40	; 0x28
    ea6c:	f64b 1050 	movw	r0, #47440	; 0xb950
    ea70:	f2c0 0001 	movt	r0, #1
    ea74:	f006 fc62 	bl	1533c <strlen>
    ea78:	4603      	mov	r3, r0
    ea7a:	4620      	mov	r0, r4
    ea7c:	f64b 1150 	movw	r1, #47440	; 0xb950
    ea80:	f2c0 0101 	movt	r1, #1
    ea84:	461a      	mov	r2, r3
    ea86:	f7fb ffa3 	bl	a9d0 <psock_send>
    ea8a:	4603      	mov	r3, r0
    ea8c:	2b00      	cmp	r3, #0
    ea8e:	f040 80c0 	bne.w	ec12 <send_headers+0x2ba>
    ea92:	f04f 0300 	mov.w	r3, #0
    ea96:	e0c6      	b.n	ec26 <send_headers+0x2ce>
	}
	else if( strncmp(http_css, ptr, 4) == 0 )
    ea98:	f64b 2040 	movw	r0, #47680	; 0xba40
    ea9c:	f2c0 0001 	movt	r0, #1
    eaa0:	68b9      	ldr	r1, [r7, #8]
    eaa2:	f04f 0204 	mov.w	r2, #4
    eaa6:	f006 fc79 	bl	1539c <strncmp>
    eaaa:	4603      	mov	r3, r0
    eaac:	2b00      	cmp	r3, #0
    eaae:	d11c      	bne.n	eaea <send_headers+0x192>
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_css );
    eab0:	687b      	ldr	r3, [r7, #4]
    eab2:	f04f 02de 	mov.w	r2, #222	; 0xde
    eab6:	851a      	strh	r2, [r3, #40]	; 0x28
    eab8:	687b      	ldr	r3, [r7, #4]
    eaba:	f103 0428 	add.w	r4, r3, #40	; 0x28
    eabe:	f64b 106c 	movw	r0, #47468	; 0xb96c
    eac2:	f2c0 0001 	movt	r0, #1
    eac6:	f006 fc39 	bl	1533c <strlen>
    eaca:	4603      	mov	r3, r0
    eacc:	4620      	mov	r0, r4
    eace:	f64b 116c 	movw	r1, #47468	; 0xb96c
    ead2:	f2c0 0101 	movt	r1, #1
    ead6:	461a      	mov	r2, r3
    ead8:	f7fb ff7a 	bl	a9d0 <psock_send>
    eadc:	4603      	mov	r3, r0
    eade:	2b00      	cmp	r3, #0
    eae0:	f040 8098 	bne.w	ec14 <send_headers+0x2bc>
    eae4:	f04f 0300 	mov.w	r3, #0
    eae8:	e09d      	b.n	ec26 <send_headers+0x2ce>
	}
	else if( strncmp(http_png, ptr, 4) == 0 )
    eaea:	f64b 2048 	movw	r0, #47688	; 0xba48
    eaee:	f2c0 0001 	movt	r0, #1
    eaf2:	68b9      	ldr	r1, [r7, #8]
    eaf4:	f04f 0204 	mov.w	r2, #4
    eaf8:	f006 fc50 	bl	1539c <strncmp>
    eafc:	4603      	mov	r3, r0
    eafe:	2b00      	cmp	r3, #0
    eb00:	d11b      	bne.n	eb3a <send_headers+0x1e2>
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_png );
    eb02:	687b      	ldr	r3, [r7, #4]
    eb04:	f04f 02e2 	mov.w	r2, #226	; 0xe2
    eb08:	851a      	strh	r2, [r3, #40]	; 0x28
    eb0a:	687b      	ldr	r3, [r7, #4]
    eb0c:	f103 0428 	add.w	r4, r3, #40	; 0x28
    eb10:	f64b 10a4 	movw	r0, #47524	; 0xb9a4
    eb14:	f2c0 0001 	movt	r0, #1
    eb18:	f006 fc10 	bl	1533c <strlen>
    eb1c:	4603      	mov	r3, r0
    eb1e:	4620      	mov	r0, r4
    eb20:	f64b 11a4 	movw	r1, #47524	; 0xb9a4
    eb24:	f2c0 0101 	movt	r1, #1
    eb28:	461a      	mov	r2, r3
    eb2a:	f7fb ff51 	bl	a9d0 <psock_send>
    eb2e:	4603      	mov	r3, r0
    eb30:	2b00      	cmp	r3, #0
    eb32:	d16f      	bne.n	ec14 <send_headers+0x2bc>
    eb34:	f04f 0300 	mov.w	r3, #0
    eb38:	e075      	b.n	ec26 <send_headers+0x2ce>
	}
	else if( strncmp(http_gif, ptr, 4) == 0 )
    eb3a:	f64b 2050 	movw	r0, #47696	; 0xba50
    eb3e:	f2c0 0001 	movt	r0, #1
    eb42:	68b9      	ldr	r1, [r7, #8]
    eb44:	f04f 0204 	mov.w	r2, #4
    eb48:	f006 fc28 	bl	1539c <strncmp>
    eb4c:	4603      	mov	r3, r0
    eb4e:	2b00      	cmp	r3, #0
    eb50:	d11b      	bne.n	eb8a <send_headers+0x232>
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_gif );
    eb52:	687b      	ldr	r3, [r7, #4]
    eb54:	f04f 02e6 	mov.w	r2, #230	; 0xe6
    eb58:	851a      	strh	r2, [r3, #40]	; 0x28
    eb5a:	687b      	ldr	r3, [r7, #4]
    eb5c:	f103 0428 	add.w	r4, r3, #40	; 0x28
    eb60:	f64b 10c0 	movw	r0, #47552	; 0xb9c0
    eb64:	f2c0 0001 	movt	r0, #1
    eb68:	f006 fbe8 	bl	1533c <strlen>
    eb6c:	4603      	mov	r3, r0
    eb6e:	4620      	mov	r0, r4
    eb70:	f64b 11c0 	movw	r1, #47552	; 0xb9c0
    eb74:	f2c0 0101 	movt	r1, #1
    eb78:	461a      	mov	r2, r3
    eb7a:	f7fb ff29 	bl	a9d0 <psock_send>
    eb7e:	4603      	mov	r3, r0
    eb80:	2b00      	cmp	r3, #0
    eb82:	d147      	bne.n	ec14 <send_headers+0x2bc>
    eb84:	f04f 0300 	mov.w	r3, #0
    eb88:	e04d      	b.n	ec26 <send_headers+0x2ce>
	}
	else if( strncmp(http_jpg, ptr, 4) == 0 )
    eb8a:	f64b 2058 	movw	r0, #47704	; 0xba58
    eb8e:	f2c0 0001 	movt	r0, #1
    eb92:	68b9      	ldr	r1, [r7, #8]
    eb94:	f04f 0204 	mov.w	r2, #4
    eb98:	f006 fc00 	bl	1539c <strncmp>
    eb9c:	4603      	mov	r3, r0
    eb9e:	2b00      	cmp	r3, #0
    eba0:	d11b      	bne.n	ebda <send_headers+0x282>
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_jpg );
    eba2:	687b      	ldr	r3, [r7, #4]
    eba4:	f04f 02ea 	mov.w	r2, #234	; 0xea
    eba8:	851a      	strh	r2, [r3, #40]	; 0x28
    ebaa:	687b      	ldr	r3, [r7, #4]
    ebac:	f103 0428 	add.w	r4, r3, #40	; 0x28
    ebb0:	f64b 10dc 	movw	r0, #47580	; 0xb9dc
    ebb4:	f2c0 0001 	movt	r0, #1
    ebb8:	f006 fbc0 	bl	1533c <strlen>
    ebbc:	4603      	mov	r3, r0
    ebbe:	4620      	mov	r0, r4
    ebc0:	f64b 11dc 	movw	r1, #47580	; 0xb9dc
    ebc4:	f2c0 0101 	movt	r1, #1
    ebc8:	461a      	mov	r2, r3
    ebca:	f7fb ff01 	bl	a9d0 <psock_send>
    ebce:	4603      	mov	r3, r0
    ebd0:	2b00      	cmp	r3, #0
    ebd2:	d11f      	bne.n	ec14 <send_headers+0x2bc>
    ebd4:	f04f 0300 	mov.w	r3, #0
    ebd8:	e025      	b.n	ec26 <send_headers+0x2ce>
	}
	else
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_plain );
    ebda:	687b      	ldr	r3, [r7, #4]
    ebdc:	f04f 02ee 	mov.w	r2, #238	; 0xee
    ebe0:	851a      	strh	r2, [r3, #40]	; 0x28
    ebe2:	687b      	ldr	r3, [r7, #4]
    ebe4:	f103 0428 	add.w	r4, r3, #40	; 0x28
    ebe8:	f64b 1030 	movw	r0, #47408	; 0xb930
    ebec:	f2c0 0001 	movt	r0, #1
    ebf0:	f006 fba4 	bl	1533c <strlen>
    ebf4:	4603      	mov	r3, r0
    ebf6:	4620      	mov	r0, r4
    ebf8:	f64b 1130 	movw	r1, #47408	; 0xb930
    ebfc:	f2c0 0101 	movt	r1, #1
    ec00:	461a      	mov	r2, r3
    ec02:	f7fb fee5 	bl	a9d0 <psock_send>
    ec06:	4603      	mov	r3, r0
    ec08:	2b00      	cmp	r3, #0
    ec0a:	d103      	bne.n	ec14 <send_headers+0x2bc>
    ec0c:	f04f 0300 	mov.w	r3, #0
    ec10:	e009      	b.n	ec26 <send_headers+0x2ce>
	ptr = strrchr( s->filename, ISO_period );
	if( ptr == NULL )
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_binary );
	}
	else if( strncmp(http_html, ptr, 5) == 0 || strncmp(http_shtml, ptr, 6) == 0 )
    ec12:	bf00      	nop
	else
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_plain );
	}

	PSOCK_END( &s->sout );
    ec14:	f04f 0300 	mov.w	r3, #0
    ec18:	73fb      	strb	r3, [r7, #15]
    ec1a:	687b      	ldr	r3, [r7, #4]
    ec1c:	f04f 0200 	mov.w	r2, #0
    ec20:	851a      	strh	r2, [r3, #40]	; 0x28
    ec22:	f04f 0302 	mov.w	r3, #2
}
    ec26:	4618      	mov	r0, r3
    ec28:	f107 0714 	add.w	r7, r7, #20
    ec2c:	46bd      	mov	sp, r7
    ec2e:	bd90      	pop	{r4, r7, pc}

0000ec30 <handle_output>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( handle_output ( struct httpd_state *s ) )
{
    ec30:	b580      	push	{r7, lr}
    ec32:	b084      	sub	sp, #16
    ec34:	af00      	add	r7, sp, #0
    ec36:	6078      	str	r0, [r7, #4]
	char	*ptr;

	PT_BEGIN( &s->outputpt );
    ec38:	f04f 0301 	mov.w	r3, #1
    ec3c:	73fb      	strb	r3, [r7, #15]
    ec3e:	687b      	ldr	r3, [r7, #4]
    ec40:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
    ec44:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    ec48:	d04c      	beq.n	ece4 <handle_output+0xb4>
    ec4a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    ec4e:	dc04      	bgt.n	ec5a <handle_output+0x2a>
    ec50:	2b00      	cmp	r3, #0
    ec52:	d00f      	beq.n	ec74 <handle_output+0x44>
    ec54:	2bff      	cmp	r3, #255	; 0xff
    ec56:	d033      	beq.n	ecc0 <handle_output+0x90>
    ec58:	e0a1      	b.n	ed9e <handle_output+0x16e>
    ec5a:	f240 1209 	movw	r2, #265	; 0x109
    ec5e:	4293      	cmp	r3, r2
    ec60:	d07e      	beq.n	ed60 <handle_output+0x130>
    ec62:	f240 120d 	movw	r2, #269	; 0x10d
    ec66:	4293      	cmp	r3, r2
    ec68:	f000 8088 	beq.w	ed7c <handle_output+0x14c>
    ec6c:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
    ec70:	d046      	beq.n	ed00 <handle_output+0xd0>
    ec72:	e094      	b.n	ed9e <handle_output+0x16e>
	( void ) PT_YIELD_FLAG;
	if( !httpd_fs_open(s->filename, &s->file) )
    ec74:	687b      	ldr	r3, [r7, #4]
    ec76:	f103 0282 	add.w	r2, r3, #130	; 0x82
    ec7a:	687b      	ldr	r3, [r7, #4]
    ec7c:	f103 0398 	add.w	r3, r3, #152	; 0x98
    ec80:	4610      	mov	r0, r2
    ec82:	4619      	mov	r1, r3
    ec84:	f7ff fbd8 	bl	e438 <httpd_fs_open>
    ec88:	4603      	mov	r3, r0
    ec8a:	2b00      	cmp	r3, #0
    ec8c:	d133      	bne.n	ecf6 <handle_output+0xc6>
	{
		httpd_fs_open( http_404_html, &s->file );
    ec8e:	687b      	ldr	r3, [r7, #4]
    ec90:	f103 0398 	add.w	r3, r3, #152	; 0x98
    ec94:	f64b 0068 	movw	r0, #47208	; 0xb868
    ec98:	f2c0 0001 	movt	r0, #1
    ec9c:	4619      	mov	r1, r3
    ec9e:	f7ff fbcb 	bl	e438 <httpd_fs_open>
		strcpy( s->filename, http_404_html );
    eca2:	687b      	ldr	r3, [r7, #4]
    eca4:	f103 0382 	add.w	r3, r3, #130	; 0x82
    eca8:	4618      	mov	r0, r3
    ecaa:	f64b 0168 	movw	r1, #47208	; 0xb868
    ecae:	f2c0 0101 	movt	r1, #1
    ecb2:	f006 fae5 	bl	15280 <strcpy>
		PT_WAIT_THREAD( &s->outputpt, send_headers(s, http_header_404) );
    ecb6:	687b      	ldr	r3, [r7, #4]
    ecb8:	f04f 02ff 	mov.w	r2, #255	; 0xff
    ecbc:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    ecc0:	6878      	ldr	r0, [r7, #4]
    ecc2:	f64b 01d4 	movw	r1, #47316	; 0xb8d4
    ecc6:	f2c0 0101 	movt	r1, #1
    ecca:	f7ff fe45 	bl	e958 <send_headers>
    ecce:	4603      	mov	r3, r0
    ecd0:	2b00      	cmp	r3, #0
    ecd2:	d102      	bne.n	ecda <handle_output+0xaa>
    ecd4:	f04f 0300 	mov.w	r3, #0
    ecd8:	e06b      	b.n	edb2 <handle_output+0x182>
		PT_WAIT_THREAD( &s->outputpt, send_file(s) );
    ecda:	687b      	ldr	r3, [r7, #4]
    ecdc:	f44f 7280 	mov.w	r2, #256	; 0x100
    ece0:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    ece4:	6878      	ldr	r0, [r7, #4]
    ece6:	f7ff fc73 	bl	e5d0 <send_file>
    ecea:	4603      	mov	r3, r0
    ecec:	2b00      	cmp	r3, #0
    ecee:	d14f      	bne.n	ed90 <handle_output+0x160>
    ecf0:	f04f 0300 	mov.w	r3, #0
    ecf4:	e05d      	b.n	edb2 <handle_output+0x182>
	}
	else
	{
		PT_WAIT_THREAD( &s->outputpt, send_headers(s, http_header_200) );
    ecf6:	687b      	ldr	r3, [r7, #4]
    ecf8:	f44f 7282 	mov.w	r2, #260	; 0x104
    ecfc:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    ed00:	6878      	ldr	r0, [r7, #4]
    ed02:	f64b 0180 	movw	r1, #47232	; 0xb880
    ed06:	f2c0 0101 	movt	r1, #1
    ed0a:	f7ff fe25 	bl	e958 <send_headers>
    ed0e:	4603      	mov	r3, r0
    ed10:	2b00      	cmp	r3, #0
    ed12:	d102      	bne.n	ed1a <handle_output+0xea>
    ed14:	f04f 0300 	mov.w	r3, #0
    ed18:	e04b      	b.n	edb2 <handle_output+0x182>
		ptr = strchr( s->filename, ISO_period );
    ed1a:	687b      	ldr	r3, [r7, #4]
    ed1c:	f103 0382 	add.w	r3, r3, #130	; 0x82
    ed20:	4618      	mov	r0, r3
    ed22:	f04f 012e 	mov.w	r1, #46	; 0x2e
    ed26:	f006 fa4b 	bl	151c0 <strchr>
    ed2a:	4603      	mov	r3, r0
    ed2c:	60bb      	str	r3, [r7, #8]
		if( ptr != NULL && strncmp(ptr, http_shtml, 6) == 0 )
    ed2e:	68bb      	ldr	r3, [r7, #8]
    ed30:	2b00      	cmp	r3, #0
    ed32:	d01e      	beq.n	ed72 <handle_output+0x142>
    ed34:	68b8      	ldr	r0, [r7, #8]
    ed36:	f64b 2130 	movw	r1, #47664	; 0xba30
    ed3a:	f2c0 0101 	movt	r1, #1
    ed3e:	f04f 0206 	mov.w	r2, #6
    ed42:	f006 fb2b 	bl	1539c <strncmp>
    ed46:	4603      	mov	r3, r0
    ed48:	2b00      	cmp	r3, #0
    ed4a:	d112      	bne.n	ed72 <handle_output+0x142>
		{
			PT_INIT( &s->scriptpt );
    ed4c:	687b      	ldr	r3, [r7, #4]
    ed4e:	f04f 0200 	mov.w	r2, #0
    ed52:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
			PT_WAIT_THREAD( &s->outputpt, handle_script(s) );
    ed56:	687b      	ldr	r3, [r7, #4]
    ed58:	f240 1209 	movw	r2, #265	; 0x109
    ed5c:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    ed60:	6878      	ldr	r0, [r7, #4]
    ed62:	f7ff fcdf 	bl	e724 <handle_script>
    ed66:	4603      	mov	r3, r0
    ed68:	2b00      	cmp	r3, #0
    ed6a:	d110      	bne.n	ed8e <handle_output+0x15e>
    ed6c:	f04f 0300 	mov.w	r3, #0
    ed70:	e01f      	b.n	edb2 <handle_output+0x182>
		}
		else
		{
			PT_WAIT_THREAD( &s->outputpt, send_file(s) );
    ed72:	687b      	ldr	r3, [r7, #4]
    ed74:	f240 120d 	movw	r2, #269	; 0x10d
    ed78:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    ed7c:	6878      	ldr	r0, [r7, #4]
    ed7e:	f7ff fc27 	bl	e5d0 <send_file>
    ed82:	4603      	mov	r3, r0
    ed84:	2b00      	cmp	r3, #0
    ed86:	d103      	bne.n	ed90 <handle_output+0x160>
    ed88:	f04f 0300 	mov.w	r3, #0
    ed8c:	e011      	b.n	edb2 <handle_output+0x182>
	}
	else
	{
		PT_WAIT_THREAD( &s->outputpt, send_headers(s, http_header_200) );
		ptr = strchr( s->filename, ISO_period );
		if( ptr != NULL && strncmp(ptr, http_shtml, 6) == 0 )
    ed8e:	bf00      	nop
		{
			PT_WAIT_THREAD( &s->outputpt, send_file(s) );
		}
	}

	PSOCK_CLOSE( &s->sout );
    ed90:	f64a 4334 	movw	r3, #44084	; 0xac34
    ed94:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ed98:	f04f 0210 	mov.w	r2, #16
    ed9c:	701a      	strb	r2, [r3, #0]
	PT_END( &s->outputpt );
    ed9e:	f04f 0300 	mov.w	r3, #0
    eda2:	73fb      	strb	r3, [r7, #15]
    eda4:	687b      	ldr	r3, [r7, #4]
    eda6:	f04f 0200 	mov.w	r2, #0
    edaa:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    edae:	f04f 0302 	mov.w	r3, #2
}
    edb2:	4618      	mov	r0, r3
    edb4:	f107 0710 	add.w	r7, r7, #16
    edb8:	46bd      	mov	sp, r7
    edba:	bd80      	pop	{r7, pc}

0000edbc <handle_input>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( handle_input ( struct httpd_state *s ) )
{
    edbc:	b580      	push	{r7, lr}
    edbe:	b084      	sub	sp, #16
    edc0:	af00      	add	r7, sp, #0
    edc2:	6078      	str	r0, [r7, #4]
	PSOCK_BEGIN( &s->sin );
    edc4:	f04f 0301 	mov.w	r3, #1
    edc8:	73fb      	strb	r3, [r7, #15]
    edca:	687b      	ldr	r3, [r7, #4]
    edcc:	889b      	ldrh	r3, [r3, #4]
    edce:	f5b3 7f8d 	cmp.w	r3, #282	; 0x11a
    edd2:	d012      	beq.n	edfa <handle_input+0x3e>
    edd4:	f5b3 7f8d 	cmp.w	r3, #282	; 0x11a
    edd8:	dc02      	bgt.n	ede0 <handle_input+0x24>
    edda:	2b00      	cmp	r3, #0
    eddc:	d009      	beq.n	edf2 <handle_input+0x36>
    edde:	e0c7      	b.n	ef70 <handle_input+0x1b4>
    ede0:	f240 1221 	movw	r2, #289	; 0x121
    ede4:	4293      	cmp	r3, r2
    ede6:	d037      	beq.n	ee58 <handle_input+0x9c>
    ede8:	f5b3 7fa0 	cmp.w	r3, #320	; 0x140
    edec:	f000 8093 	beq.w	ef16 <handle_input+0x15a>
    edf0:	e0be      	b.n	ef70 <handle_input+0x1b4>
	( void ) PT_YIELD_FLAG;
	PSOCK_READTO( &s->sin, ISO_space );
    edf2:	687b      	ldr	r3, [r7, #4]
    edf4:	f44f 728d 	mov.w	r2, #282	; 0x11a
    edf8:	809a      	strh	r2, [r3, #4]
    edfa:	687b      	ldr	r3, [r7, #4]
    edfc:	f103 0304 	add.w	r3, r3, #4
    ee00:	4618      	mov	r0, r3
    ee02:	f04f 0120 	mov.w	r1, #32
    ee06:	f7fb fec7 	bl	ab98 <psock_readto>
    ee0a:	4603      	mov	r3, r0
    ee0c:	2b00      	cmp	r3, #0
    ee0e:	d102      	bne.n	ee16 <handle_input+0x5a>
    ee10:	f04f 0300 	mov.w	r3, #0
    ee14:	e0b5      	b.n	ef82 <handle_input+0x1c6>

	if( strncmp(s->inputbuf, http_get, 4) != 0 )
    ee16:	687b      	ldr	r3, [r7, #4]
    ee18:	f103 0350 	add.w	r3, r3, #80	; 0x50
    ee1c:	4618      	mov	r0, r3
    ee1e:	f64b 0108 	movw	r1, #47112	; 0xb808
    ee22:	f2c0 0101 	movt	r1, #1
    ee26:	f04f 0204 	mov.w	r2, #4
    ee2a:	f006 fab7 	bl	1539c <strncmp>
    ee2e:	4603      	mov	r3, r0
    ee30:	2b00      	cmp	r3, #0
    ee32:	d00d      	beq.n	ee50 <handle_input+0x94>
	{
		PSOCK_CLOSE_EXIT( &s->sin );
    ee34:	f64a 4334 	movw	r3, #44084	; 0xac34
    ee38:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ee3c:	f04f 0210 	mov.w	r2, #16
    ee40:	701a      	strb	r2, [r3, #0]
    ee42:	687b      	ldr	r3, [r7, #4]
    ee44:	f04f 0200 	mov.w	r2, #0
    ee48:	809a      	strh	r2, [r3, #4]
    ee4a:	f04f 0301 	mov.w	r3, #1
    ee4e:	e098      	b.n	ef82 <handle_input+0x1c6>
	}

	PSOCK_READTO( &s->sin, ISO_space );
    ee50:	687b      	ldr	r3, [r7, #4]
    ee52:	f240 1221 	movw	r2, #289	; 0x121
    ee56:	809a      	strh	r2, [r3, #4]
    ee58:	687b      	ldr	r3, [r7, #4]
    ee5a:	f103 0304 	add.w	r3, r3, #4
    ee5e:	4618      	mov	r0, r3
    ee60:	f04f 0120 	mov.w	r1, #32
    ee64:	f7fb fe98 	bl	ab98 <psock_readto>
    ee68:	4603      	mov	r3, r0
    ee6a:	2b00      	cmp	r3, #0
    ee6c:	d102      	bne.n	ee74 <handle_input+0xb8>
    ee6e:	f04f 0300 	mov.w	r3, #0
    ee72:	e086      	b.n	ef82 <handle_input+0x1c6>

	if( s->inputbuf[0] != ISO_slash )
    ee74:	687b      	ldr	r3, [r7, #4]
    ee76:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
    ee7a:	2b2f      	cmp	r3, #47	; 0x2f
    ee7c:	d00d      	beq.n	ee9a <handle_input+0xde>
	{
		PSOCK_CLOSE_EXIT( &s->sin );
    ee7e:	f64a 4334 	movw	r3, #44084	; 0xac34
    ee82:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ee86:	f04f 0210 	mov.w	r2, #16
    ee8a:	701a      	strb	r2, [r3, #0]
    ee8c:	687b      	ldr	r3, [r7, #4]
    ee8e:	f04f 0200 	mov.w	r2, #0
    ee92:	809a      	strh	r2, [r3, #4]
    ee94:	f04f 0301 	mov.w	r3, #1
    ee98:	e073      	b.n	ef82 <handle_input+0x1c6>
	}

	if( s->inputbuf[1] == ISO_space )
    ee9a:	687b      	ldr	r3, [r7, #4]
    ee9c:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
    eea0:	2b20      	cmp	r3, #32
    eea2:	d10c      	bne.n	eebe <handle_input+0x102>
	{
		strncpy( s->filename, http_index_html, sizeof(s->filename) );
    eea4:	687b      	ldr	r3, [r7, #4]
    eea6:	f103 0382 	add.w	r3, r3, #130	; 0x82
    eeaa:	4618      	mov	r0, r3
    eeac:	f64b 015c 	movw	r1, #47196	; 0xb85c
    eeb0:	f2c0 0101 	movt	r1, #1
    eeb4:	f04f 0214 	mov.w	r2, #20
    eeb8:	f006 fac4 	bl	15444 <strncpy>
    eebc:	e020      	b.n	ef00 <handle_input+0x144>
	}
	else
	{
		s->inputbuf[PSOCK_DATALEN( &s->sin ) - 1] = 0;
    eebe:	687b      	ldr	r3, [r7, #4]
    eec0:	f103 0304 	add.w	r3, r3, #4
    eec4:	4618      	mov	r0, r3
    eec6:	f7fb fe29 	bl	ab1c <psock_datalen>
    eeca:	4603      	mov	r3, r0
    eecc:	f103 32ff 	add.w	r2, r3, #4294967295
    eed0:	687b      	ldr	r3, [r7, #4]
    eed2:	4413      	add	r3, r2
    eed4:	f04f 0200 	mov.w	r2, #0
    eed8:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
		
		/* Process any form input being sent to the server. */
		#if UIP_CONF_PROCESS_HTTPD_FORMS == 1
		{
			extern void vApplicationProcessFormInput( char *pcInputString );
			vApplicationProcessFormInput( s->inputbuf );
    eedc:	687b      	ldr	r3, [r7, #4]
    eede:	f103 0350 	add.w	r3, r3, #80	; 0x50
    eee2:	4618      	mov	r0, r3
    eee4:	f7f2 f9fc 	bl	12e0 <vApplicationProcessFormInput>
		}
		#endif
		
		strncpy( s->filename, &s->inputbuf[0], sizeof(s->filename) );
    eee8:	687b      	ldr	r3, [r7, #4]
    eeea:	f103 0282 	add.w	r2, r3, #130	; 0x82
    eeee:	687b      	ldr	r3, [r7, #4]
    eef0:	f103 0350 	add.w	r3, r3, #80	; 0x50
    eef4:	4610      	mov	r0, r2
    eef6:	4619      	mov	r1, r3
    eef8:	f04f 0214 	mov.w	r2, #20
    eefc:	f006 faa2 	bl	15444 <strncpy>
	}

	/*  httpd_log_file(uip_conn->ripaddr, s->filename);*/
	s->state = STATE_OUTPUT;
    ef00:	687b      	ldr	r3, [r7, #4]
    ef02:	f04f 0201 	mov.w	r2, #1
    ef06:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
    ef0a:	e000      	b.n	ef0e <handle_input+0x152>
		{
			s->inputbuf[PSOCK_DATALEN( &s->sin ) - 2] = 0;

			/*      httpd_log(&s->inputbuf[9]);*/
		}
	}
    ef0c:	bf00      	nop
	/*  httpd_log_file(uip_conn->ripaddr, s->filename);*/
	s->state = STATE_OUTPUT;

	while( 1 )
	{
		PSOCK_READTO( &s->sin, ISO_nl );
    ef0e:	687b      	ldr	r3, [r7, #4]
    ef10:	f44f 72a0 	mov.w	r2, #320	; 0x140
    ef14:	809a      	strh	r2, [r3, #4]
    ef16:	687b      	ldr	r3, [r7, #4]
    ef18:	f103 0304 	add.w	r3, r3, #4
    ef1c:	4618      	mov	r0, r3
    ef1e:	f04f 010a 	mov.w	r1, #10
    ef22:	f7fb fe39 	bl	ab98 <psock_readto>
    ef26:	4603      	mov	r3, r0
    ef28:	2b00      	cmp	r3, #0
    ef2a:	d102      	bne.n	ef32 <handle_input+0x176>
    ef2c:	f04f 0300 	mov.w	r3, #0
    ef30:	e027      	b.n	ef82 <handle_input+0x1c6>

		if( strncmp(s->inputbuf, http_referer, 8) == 0 )
    ef32:	687b      	ldr	r3, [r7, #4]
    ef34:	f103 0350 	add.w	r3, r3, #80	; 0x50
    ef38:	4618      	mov	r0, r3
    ef3a:	f64b 0174 	movw	r1, #47220	; 0xb874
    ef3e:	f2c0 0101 	movt	r1, #1
    ef42:	f04f 0208 	mov.w	r2, #8
    ef46:	f006 fa29 	bl	1539c <strncmp>
    ef4a:	4603      	mov	r3, r0
    ef4c:	2b00      	cmp	r3, #0
    ef4e:	d1dd      	bne.n	ef0c <handle_input+0x150>
		{
			s->inputbuf[PSOCK_DATALEN( &s->sin ) - 2] = 0;
    ef50:	687b      	ldr	r3, [r7, #4]
    ef52:	f103 0304 	add.w	r3, r3, #4
    ef56:	4618      	mov	r0, r3
    ef58:	f7fb fde0 	bl	ab1c <psock_datalen>
    ef5c:	4603      	mov	r3, r0
    ef5e:	f1a3 0202 	sub.w	r2, r3, #2
    ef62:	687b      	ldr	r3, [r7, #4]
    ef64:	4413      	add	r3, r2
    ef66:	f04f 0200 	mov.w	r2, #0
    ef6a:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

			/*      httpd_log(&s->inputbuf[9]);*/
		}
	}
    ef6e:	e7ce      	b.n	ef0e <handle_input+0x152>

	PSOCK_END( &s->sin );
    ef70:	f04f 0300 	mov.w	r3, #0
    ef74:	73fb      	strb	r3, [r7, #15]
    ef76:	687b      	ldr	r3, [r7, #4]
    ef78:	f04f 0200 	mov.w	r2, #0
    ef7c:	809a      	strh	r2, [r3, #4]
    ef7e:	f04f 0302 	mov.w	r3, #2
}
    ef82:	4618      	mov	r0, r3
    ef84:	f107 0710 	add.w	r7, r7, #16
    ef88:	46bd      	mov	sp, r7
    ef8a:	bd80      	pop	{r7, pc}

0000ef8c <handle_connection>:

/*---------------------------------------------------------------------------*/
static void handle_connection( struct httpd_state *s )
{
    ef8c:	b580      	push	{r7, lr}
    ef8e:	b082      	sub	sp, #8
    ef90:	af00      	add	r7, sp, #0
    ef92:	6078      	str	r0, [r7, #4]
	handle_input( s );
    ef94:	6878      	ldr	r0, [r7, #4]
    ef96:	f7ff ff11 	bl	edbc <handle_input>
	if( s->state == STATE_OUTPUT )
    ef9a:	687b      	ldr	r3, [r7, #4]
    ef9c:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
    efa0:	2b01      	cmp	r3, #1
    efa2:	d102      	bne.n	efaa <handle_connection+0x1e>
	{
		handle_output( s );
    efa4:	6878      	ldr	r0, [r7, #4]
    efa6:	f7ff fe43 	bl	ec30 <handle_output>
	}
}
    efaa:	f107 0708 	add.w	r7, r7, #8
    efae:	46bd      	mov	sp, r7
    efb0:	bd80      	pop	{r7, pc}
    efb2:	bf00      	nop

0000efb4 <httpd_appcall>:

/*---------------------------------------------------------------------------*/
void httpd_appcall( void )
{
    efb4:	b580      	push	{r7, lr}
    efb6:	b082      	sub	sp, #8
    efb8:	af00      	add	r7, sp, #0
	struct httpd_state	*s = ( struct httpd_state * ) &( uip_conn->appstate );
    efba:	f64a 433c 	movw	r3, #44092	; 0xac3c
    efbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    efc2:	681b      	ldr	r3, [r3, #0]
    efc4:	f103 031c 	add.w	r3, r3, #28
    efc8:	607b      	str	r3, [r7, #4]

	if( uip_closed() || uip_aborted() || uip_timedout() )
    efca:	f64a 4334 	movw	r3, #44084	; 0xac34
    efce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    efd2:	781b      	ldrb	r3, [r3, #0]
    efd4:	f003 0310 	and.w	r3, r3, #16
    efd8:	2b00      	cmp	r3, #0
    efda:	d173      	bne.n	f0c4 <httpd_appcall+0x110>
    efdc:	f64a 4334 	movw	r3, #44084	; 0xac34
    efe0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    efe4:	781b      	ldrb	r3, [r3, #0]
    efe6:	f003 0320 	and.w	r3, r3, #32
    efea:	2b00      	cmp	r3, #0
    efec:	d16a      	bne.n	f0c4 <httpd_appcall+0x110>
    efee:	f64a 4334 	movw	r3, #44084	; 0xac34
    eff2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    eff6:	781b      	ldrb	r3, [r3, #0]
    eff8:	b25b      	sxtb	r3, r3
    effa:	2b00      	cmp	r3, #0
    effc:	db62      	blt.n	f0c4 <httpd_appcall+0x110>
	{
	}
	else if( uip_connected() )
    effe:	f64a 4334 	movw	r3, #44084	; 0xac34
    f002:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f006:	781b      	ldrb	r3, [r3, #0]
    f008:	f003 0340 	and.w	r3, r3, #64	; 0x40
    f00c:	2b00      	cmp	r3, #0
    f00e:	d029      	beq.n	f064 <httpd_appcall+0xb0>
	{
		PSOCK_INIT( &s->sin, s->inputbuf, sizeof(s->inputbuf) - 1 );
    f010:	687b      	ldr	r3, [r7, #4]
    f012:	f103 0204 	add.w	r2, r3, #4
    f016:	687b      	ldr	r3, [r7, #4]
    f018:	f103 0350 	add.w	r3, r3, #80	; 0x50
    f01c:	4610      	mov	r0, r2
    f01e:	4619      	mov	r1, r3
    f020:	f04f 0231 	mov.w	r2, #49	; 0x31
    f024:	f7fb fe7e 	bl	ad24 <psock_init>
		PSOCK_INIT( &s->sout, s->inputbuf, sizeof(s->inputbuf) - 1 );
    f028:	687b      	ldr	r3, [r7, #4]
    f02a:	f103 0228 	add.w	r2, r3, #40	; 0x28
    f02e:	687b      	ldr	r3, [r7, #4]
    f030:	f103 0350 	add.w	r3, r3, #80	; 0x50
    f034:	4610      	mov	r0, r2
    f036:	4619      	mov	r1, r3
    f038:	f04f 0231 	mov.w	r2, #49	; 0x31
    f03c:	f7fb fe72 	bl	ad24 <psock_init>
		PT_INIT( &s->outputpt );
    f040:	687b      	ldr	r3, [r7, #4]
    f042:	f04f 0200 	mov.w	r2, #0
    f046:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
		s->state = STATE_WAITING;
    f04a:	687b      	ldr	r3, [r7, #4]
    f04c:	f04f 0200 	mov.w	r2, #0
    f050:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96

		/*    timer_set(&s->timer, CLOCK_SECOND * 100);*/
		s->timer = 0;
    f054:	687b      	ldr	r3, [r7, #4]
    f056:	f04f 0200 	mov.w	r2, #0
    f05a:	701a      	strb	r2, [r3, #0]
		handle_connection( s );
    f05c:	6878      	ldr	r0, [r7, #4]
    f05e:	f7ff ff95 	bl	ef8c <handle_connection>
    f062:	e02f      	b.n	f0c4 <httpd_appcall+0x110>
	}
	else if( s != NULL )
    f064:	687b      	ldr	r3, [r7, #4]
    f066:	2b00      	cmp	r3, #0
    f068:	d025      	beq.n	f0b6 <httpd_appcall+0x102>
	{
		if( uip_poll() )
    f06a:	f64a 4334 	movw	r3, #44084	; 0xac34
    f06e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f072:	781b      	ldrb	r3, [r3, #0]
    f074:	f003 0308 	and.w	r3, r3, #8
    f078:	2b00      	cmp	r3, #0
    f07a:	d012      	beq.n	f0a2 <httpd_appcall+0xee>
		{
			++s->timer;
    f07c:	687b      	ldr	r3, [r7, #4]
    f07e:	781b      	ldrb	r3, [r3, #0]
    f080:	f103 0301 	add.w	r3, r3, #1
    f084:	b2da      	uxtb	r2, r3
    f086:	687b      	ldr	r3, [r7, #4]
    f088:	701a      	strb	r2, [r3, #0]
			if( s->timer >= 20 )
    f08a:	687b      	ldr	r3, [r7, #4]
    f08c:	781b      	ldrb	r3, [r3, #0]
    f08e:	2b13      	cmp	r3, #19
    f090:	d90c      	bls.n	f0ac <httpd_appcall+0xf8>
			{
				uip_abort();
    f092:	f64a 4334 	movw	r3, #44084	; 0xac34
    f096:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f09a:	f04f 0220 	mov.w	r2, #32
    f09e:	701a      	strb	r2, [r3, #0]
    f0a0:	e005      	b.n	f0ae <httpd_appcall+0xfa>
			}
		}
		else
		{
			s->timer = 0;
    f0a2:	687b      	ldr	r3, [r7, #4]
    f0a4:	f04f 0200 	mov.w	r2, #0
    f0a8:	701a      	strb	r2, [r3, #0]
    f0aa:	e000      	b.n	f0ae <httpd_appcall+0xfa>
		if( uip_poll() )
		{
			++s->timer;
			if( s->timer >= 20 )
			{
				uip_abort();
    f0ac:	bf00      	nop
		else
		{
			s->timer = 0;
		}

		handle_connection( s );
    f0ae:	6878      	ldr	r0, [r7, #4]
    f0b0:	f7ff ff6c 	bl	ef8c <handle_connection>
    f0b4:	e006      	b.n	f0c4 <httpd_appcall+0x110>
	}
	else
	{
		uip_abort();
    f0b6:	f64a 4334 	movw	r3, #44084	; 0xac34
    f0ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f0be:	f04f 0220 	mov.w	r2, #32
    f0c2:	701a      	strb	r2, [r3, #0]
	}
}
    f0c4:	f107 0708 	add.w	r7, r7, #8
    f0c8:	46bd      	mov	sp, r7
    f0ca:	bd80      	pop	{r7, pc}

0000f0cc <httpd_init>:
 *
 *             This function initializes the web server and should be
 *             called at system boot-up.
 */
void httpd_init( void )
{
    f0cc:	b580      	push	{r7, lr}
    f0ce:	af00      	add	r7, sp, #0
	uip_listen( HTONS(80) );
    f0d0:	f44f 40a0 	mov.w	r0, #20480	; 0x5000
    f0d4:	f7fc f9e4 	bl	b4a0 <uip_listen>
}
    f0d8:	bd80      	pop	{r7, pc}
    f0da:	bf00      	nop

0000f0dc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    f0dc:	b480      	push	{r7}
    f0de:	b083      	sub	sp, #12
    f0e0:	af00      	add	r7, sp, #0
    f0e2:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    f0e4:	687b      	ldr	r3, [r7, #4]
    f0e6:	f103 0308 	add.w	r3, r3, #8
    f0ea:	461a      	mov	r2, r3
    f0ec:	687b      	ldr	r3, [r7, #4]
    f0ee:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    f0f0:	687b      	ldr	r3, [r7, #4]
    f0f2:	f04f 32ff 	mov.w	r2, #4294967295
    f0f6:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    f0f8:	687b      	ldr	r3, [r7, #4]
    f0fa:	f103 0308 	add.w	r3, r3, #8
    f0fe:	461a      	mov	r2, r3
    f100:	687b      	ldr	r3, [r7, #4]
    f102:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    f104:	687b      	ldr	r3, [r7, #4]
    f106:	f103 0308 	add.w	r3, r3, #8
    f10a:	461a      	mov	r2, r3
    f10c:	687b      	ldr	r3, [r7, #4]
    f10e:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    f110:	687b      	ldr	r3, [r7, #4]
    f112:	f04f 0200 	mov.w	r2, #0
    f116:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    f118:	f107 070c 	add.w	r7, r7, #12
    f11c:	46bd      	mov	sp, r7
    f11e:	bc80      	pop	{r7}
    f120:	4770      	bx	lr
    f122:	bf00      	nop

0000f124 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    f124:	b480      	push	{r7}
    f126:	b083      	sub	sp, #12
    f128:	af00      	add	r7, sp, #0
    f12a:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    f12c:	687b      	ldr	r3, [r7, #4]
    f12e:	f04f 0200 	mov.w	r2, #0
    f132:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    f134:	f107 070c 	add.w	r7, r7, #12
    f138:	46bd      	mov	sp, r7
    f13a:	bc80      	pop	{r7}
    f13c:	4770      	bx	lr
    f13e:	bf00      	nop

0000f140 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    f140:	b480      	push	{r7}
    f142:	b085      	sub	sp, #20
    f144:	af00      	add	r7, sp, #0
    f146:	6078      	str	r0, [r7, #4]
    f148:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
    f14a:	687b      	ldr	r3, [r7, #4]
    f14c:	685b      	ldr	r3, [r3, #4]
    f14e:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    f150:	683b      	ldr	r3, [r7, #0]
    f152:	68fa      	ldr	r2, [r7, #12]
    f154:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    f156:	68fb      	ldr	r3, [r7, #12]
    f158:	689a      	ldr	r2, [r3, #8]
    f15a:	683b      	ldr	r3, [r7, #0]
    f15c:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    f15e:	68fb      	ldr	r3, [r7, #12]
    f160:	689b      	ldr	r3, [r3, #8]
    f162:	683a      	ldr	r2, [r7, #0]
    f164:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
    f166:	68fb      	ldr	r3, [r7, #12]
    f168:	683a      	ldr	r2, [r7, #0]
    f16a:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    f16c:	683b      	ldr	r3, [r7, #0]
    f16e:	687a      	ldr	r2, [r7, #4]
    f170:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
    f172:	687b      	ldr	r3, [r7, #4]
    f174:	681b      	ldr	r3, [r3, #0]
    f176:	f103 0201 	add.w	r2, r3, #1
    f17a:	687b      	ldr	r3, [r7, #4]
    f17c:	601a      	str	r2, [r3, #0]
}
    f17e:	f107 0714 	add.w	r7, r7, #20
    f182:	46bd      	mov	sp, r7
    f184:	bc80      	pop	{r7}
    f186:	4770      	bx	lr

0000f188 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    f188:	b480      	push	{r7}
    f18a:	b085      	sub	sp, #20
    f18c:	af00      	add	r7, sp, #0
    f18e:	6078      	str	r0, [r7, #4]
    f190:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    f192:	683b      	ldr	r3, [r7, #0]
    f194:	681b      	ldr	r3, [r3, #0]
    f196:	60fb      	str	r3, [r7, #12]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    f198:	68fb      	ldr	r3, [r7, #12]
    f19a:	f1b3 3fff 	cmp.w	r3, #4294967295
    f19e:	d103      	bne.n	f1a8 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    f1a0:	687b      	ldr	r3, [r7, #4]
    f1a2:	691b      	ldr	r3, [r3, #16]
    f1a4:	60bb      	str	r3, [r7, #8]
    f1a6:	e00d      	b.n	f1c4 <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    f1a8:	687b      	ldr	r3, [r7, #4]
    f1aa:	f103 0308 	add.w	r3, r3, #8
    f1ae:	60bb      	str	r3, [r7, #8]
    f1b0:	e002      	b.n	f1b8 <vListInsert+0x30>
    f1b2:	68bb      	ldr	r3, [r7, #8]
    f1b4:	685b      	ldr	r3, [r3, #4]
    f1b6:	60bb      	str	r3, [r7, #8]
    f1b8:	68bb      	ldr	r3, [r7, #8]
    f1ba:	685b      	ldr	r3, [r3, #4]
    f1bc:	681a      	ldr	r2, [r3, #0]
    f1be:	68fb      	ldr	r3, [r7, #12]
    f1c0:	429a      	cmp	r2, r3
    f1c2:	d9f6      	bls.n	f1b2 <vListInsert+0x2a>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    f1c4:	68bb      	ldr	r3, [r7, #8]
    f1c6:	685a      	ldr	r2, [r3, #4]
    f1c8:	683b      	ldr	r3, [r7, #0]
    f1ca:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    f1cc:	683b      	ldr	r3, [r7, #0]
    f1ce:	685b      	ldr	r3, [r3, #4]
    f1d0:	683a      	ldr	r2, [r7, #0]
    f1d2:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
    f1d4:	683b      	ldr	r3, [r7, #0]
    f1d6:	68ba      	ldr	r2, [r7, #8]
    f1d8:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
    f1da:	68bb      	ldr	r3, [r7, #8]
    f1dc:	683a      	ldr	r2, [r7, #0]
    f1de:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    f1e0:	683b      	ldr	r3, [r7, #0]
    f1e2:	687a      	ldr	r2, [r7, #4]
    f1e4:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
    f1e6:	687b      	ldr	r3, [r7, #4]
    f1e8:	681b      	ldr	r3, [r3, #0]
    f1ea:	f103 0201 	add.w	r2, r3, #1
    f1ee:	687b      	ldr	r3, [r7, #4]
    f1f0:	601a      	str	r2, [r3, #0]
}
    f1f2:	f107 0714 	add.w	r7, r7, #20
    f1f6:	46bd      	mov	sp, r7
    f1f8:	bc80      	pop	{r7}
    f1fa:	4770      	bx	lr

0000f1fc <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    f1fc:	b480      	push	{r7}
    f1fe:	b085      	sub	sp, #20
    f200:	af00      	add	r7, sp, #0
    f202:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    f204:	687b      	ldr	r3, [r7, #4]
    f206:	691b      	ldr	r3, [r3, #16]
    f208:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    f20a:	687b      	ldr	r3, [r7, #4]
    f20c:	685b      	ldr	r3, [r3, #4]
    f20e:	687a      	ldr	r2, [r7, #4]
    f210:	6892      	ldr	r2, [r2, #8]
    f212:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    f214:	687b      	ldr	r3, [r7, #4]
    f216:	689b      	ldr	r3, [r3, #8]
    f218:	687a      	ldr	r2, [r7, #4]
    f21a:	6852      	ldr	r2, [r2, #4]
    f21c:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    f21e:	68fb      	ldr	r3, [r7, #12]
    f220:	685a      	ldr	r2, [r3, #4]
    f222:	687b      	ldr	r3, [r7, #4]
    f224:	429a      	cmp	r2, r3
    f226:	d103      	bne.n	f230 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    f228:	687b      	ldr	r3, [r7, #4]
    f22a:	689a      	ldr	r2, [r3, #8]
    f22c:	68fb      	ldr	r3, [r7, #12]
    f22e:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    f230:	687b      	ldr	r3, [r7, #4]
    f232:	f04f 0200 	mov.w	r2, #0
    f236:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
    f238:	68fb      	ldr	r3, [r7, #12]
    f23a:	681b      	ldr	r3, [r3, #0]
    f23c:	f103 32ff 	add.w	r2, r3, #4294967295
    f240:	68fb      	ldr	r3, [r7, #12]
    f242:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
    f244:	68fb      	ldr	r3, [r7, #12]
    f246:	681b      	ldr	r3, [r3, #0]
}
    f248:	4618      	mov	r0, r3
    f24a:	f107 0714 	add.w	r7, r7, #20
    f24e:	46bd      	mov	sp, r7
    f250:	bc80      	pop	{r7}
    f252:	4770      	bx	lr

0000f254 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    f254:	b580      	push	{r7, lr}
    f256:	b084      	sub	sp, #16
    f258:	af00      	add	r7, sp, #0
    f25a:	6078      	str	r0, [r7, #4]
    f25c:	6039      	str	r1, [r7, #0]
Queue_t * const pxQueue = xQueue;
    f25e:	687b      	ldr	r3, [r7, #4]
    f260:	60bb      	str	r3, [r7, #8]

	configASSERT( pxQueue );
    f262:	68bb      	ldr	r3, [r7, #8]
    f264:	2b00      	cmp	r3, #0
    f266:	d109      	bne.n	f27c <xQueueGenericReset+0x28>
    f268:	f04f 0328 	mov.w	r3, #40	; 0x28
    f26c:	f383 8811 	msr	BASEPRI, r3
    f270:	f3bf 8f6f 	isb	sy
    f274:	f3bf 8f4f 	dsb	sy
    f278:	60fb      	str	r3, [r7, #12]
    f27a:	e7fe      	b.n	f27a <xQueueGenericReset+0x26>

	taskENTER_CRITICAL();
    f27c:	f004 fffc 	bl	14278 <vPortEnterCritical>
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    f280:	68bb      	ldr	r3, [r7, #8]
    f282:	681a      	ldr	r2, [r3, #0]
    f284:	68bb      	ldr	r3, [r7, #8]
    f286:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    f288:	68b9      	ldr	r1, [r7, #8]
    f28a:	6c09      	ldr	r1, [r1, #64]	; 0x40
    f28c:	fb01 f303 	mul.w	r3, r1, r3
    f290:	441a      	add	r2, r3
    f292:	68bb      	ldr	r3, [r7, #8]
    f294:	609a      	str	r2, [r3, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    f296:	68bb      	ldr	r3, [r7, #8]
    f298:	f04f 0200 	mov.w	r2, #0
    f29c:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
    f29e:	68bb      	ldr	r3, [r7, #8]
    f2a0:	681a      	ldr	r2, [r3, #0]
    f2a2:	68bb      	ldr	r3, [r7, #8]
    f2a4:	605a      	str	r2, [r3, #4]
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    f2a6:	68bb      	ldr	r3, [r7, #8]
    f2a8:	681a      	ldr	r2, [r3, #0]
    f2aa:	68bb      	ldr	r3, [r7, #8]
    f2ac:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    f2ae:	f103 33ff 	add.w	r3, r3, #4294967295
    f2b2:	68b9      	ldr	r1, [r7, #8]
    f2b4:	6c09      	ldr	r1, [r1, #64]	; 0x40
    f2b6:	fb01 f303 	mul.w	r3, r1, r3
    f2ba:	441a      	add	r2, r3
    f2bc:	68bb      	ldr	r3, [r7, #8]
    f2be:	60da      	str	r2, [r3, #12]
		pxQueue->cRxLock = queueUNLOCKED;
    f2c0:	68bb      	ldr	r3, [r7, #8]
    f2c2:	f04f 32ff 	mov.w	r2, #4294967295
    f2c6:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
    f2ca:	68bb      	ldr	r3, [r7, #8]
    f2cc:	f04f 32ff 	mov.w	r2, #4294967295
    f2d0:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

		if( xNewQueue == pdFALSE )
    f2d4:	683b      	ldr	r3, [r7, #0]
    f2d6:	2b00      	cmp	r3, #0
    f2d8:	d118      	bne.n	f30c <xQueueGenericReset+0xb8>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    f2da:	68bb      	ldr	r3, [r7, #8]
    f2dc:	691b      	ldr	r3, [r3, #16]
    f2de:	2b00      	cmp	r3, #0
    f2e0:	d021      	beq.n	f326 <xQueueGenericReset+0xd2>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    f2e2:	68bb      	ldr	r3, [r7, #8]
    f2e4:	f103 0310 	add.w	r3, r3, #16
    f2e8:	4618      	mov	r0, r3
    f2ea:	f002 fd37 	bl	11d5c <xTaskRemoveFromEventList>
    f2ee:	4603      	mov	r3, r0
    f2f0:	2b00      	cmp	r3, #0
    f2f2:	d01a      	beq.n	f32a <xQueueGenericReset+0xd6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    f2f4:	f64e 5304 	movw	r3, #60676	; 0xed04
    f2f8:	f2ce 0300 	movt	r3, #57344	; 0xe000
    f2fc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    f300:	601a      	str	r2, [r3, #0]
    f302:	f3bf 8f4f 	dsb	sy
    f306:	f3bf 8f6f 	isb	sy
    f30a:	e00f      	b.n	f32c <xQueueGenericReset+0xd8>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    f30c:	68bb      	ldr	r3, [r7, #8]
    f30e:	f103 0310 	add.w	r3, r3, #16
    f312:	4618      	mov	r0, r3
    f314:	f7ff fee2 	bl	f0dc <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    f318:	68bb      	ldr	r3, [r7, #8]
    f31a:	f103 0324 	add.w	r3, r3, #36	; 0x24
    f31e:	4618      	mov	r0, r3
    f320:	f7ff fedc 	bl	f0dc <vListInitialise>
    f324:	e002      	b.n	f32c <xQueueGenericReset+0xd8>
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
				{
					queueYIELD_IF_USING_PREEMPTION();
    f326:	bf00      	nop
    f328:	e000      	b.n	f32c <xQueueGenericReset+0xd8>
    f32a:	bf00      	nop
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
		}
	}
	taskEXIT_CRITICAL();
    f32c:	f004 ffdc 	bl	142e8 <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    f330:	f04f 0301 	mov.w	r3, #1
}
    f334:	4618      	mov	r0, r3
    f336:	f107 0710 	add.w	r7, r7, #16
    f33a:	46bd      	mov	sp, r7
    f33c:	bd80      	pop	{r7, pc}
    f33e:	bf00      	nop

0000f340 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    f340:	b580      	push	{r7, lr}
    f342:	b08a      	sub	sp, #40	; 0x28
    f344:	af02      	add	r7, sp, #8
    f346:	60f8      	str	r0, [r7, #12]
    f348:	60b9      	str	r1, [r7, #8]
    f34a:	4613      	mov	r3, r2
    f34c:	71fb      	strb	r3, [r7, #7]
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
    f34e:	68fb      	ldr	r3, [r7, #12]
    f350:	2b00      	cmp	r3, #0
    f352:	d109      	bne.n	f368 <xQueueGenericCreate+0x28>
    f354:	f04f 0328 	mov.w	r3, #40	; 0x28
    f358:	f383 8811 	msr	BASEPRI, r3
    f35c:	f3bf 8f6f 	isb	sy
    f360:	f3bf 8f4f 	dsb	sy
    f364:	61fb      	str	r3, [r7, #28]
    f366:	e7fe      	b.n	f366 <xQueueGenericCreate+0x26>

		if( uxItemSize == ( UBaseType_t ) 0 )
    f368:	68bb      	ldr	r3, [r7, #8]
    f36a:	2b00      	cmp	r3, #0
    f36c:	d103      	bne.n	f376 <xQueueGenericCreate+0x36>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    f36e:	f04f 0300 	mov.w	r3, #0
    f372:	617b      	str	r3, [r7, #20]
    f374:	e004      	b.n	f380 <xQueueGenericCreate+0x40>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    f376:	68fb      	ldr	r3, [r7, #12]
    f378:	68ba      	ldr	r2, [r7, #8]
    f37a:	fb02 f303 	mul.w	r3, r2, r3
    f37e:	617b      	str	r3, [r7, #20]
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    f380:	697b      	ldr	r3, [r7, #20]
    f382:	f103 0350 	add.w	r3, r3, #80	; 0x50
    f386:	4618      	mov	r0, r3
    f388:	f004 fcfa 	bl	13d80 <pvPortMalloc>
    f38c:	4603      	mov	r3, r0
    f38e:	613b      	str	r3, [r7, #16]

		if( pxNewQueue != NULL )
    f390:	693b      	ldr	r3, [r7, #16]
    f392:	2b00      	cmp	r3, #0
    f394:	d00d      	beq.n	f3b2 <xQueueGenericCreate+0x72>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    f396:	693b      	ldr	r3, [r7, #16]
    f398:	61bb      	str	r3, [r7, #24]
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    f39a:	69bb      	ldr	r3, [r7, #24]
    f39c:	f103 0350 	add.w	r3, r3, #80	; 0x50
    f3a0:	61bb      	str	r3, [r7, #24]
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    f3a2:	79fb      	ldrb	r3, [r7, #7]
    f3a4:	693a      	ldr	r2, [r7, #16]
    f3a6:	9200      	str	r2, [sp, #0]
    f3a8:	68f8      	ldr	r0, [r7, #12]
    f3aa:	68b9      	ldr	r1, [r7, #8]
    f3ac:	69ba      	ldr	r2, [r7, #24]
    f3ae:	f000 f807 	bl	f3c0 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    f3b2:	693b      	ldr	r3, [r7, #16]
	}
    f3b4:	4618      	mov	r0, r3
    f3b6:	f107 0720 	add.w	r7, r7, #32
    f3ba:	46bd      	mov	sp, r7
    f3bc:	bd80      	pop	{r7, pc}
    f3be:	bf00      	nop

0000f3c0 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    f3c0:	b580      	push	{r7, lr}
    f3c2:	b084      	sub	sp, #16
    f3c4:	af00      	add	r7, sp, #0
    f3c6:	60f8      	str	r0, [r7, #12]
    f3c8:	60b9      	str	r1, [r7, #8]
    f3ca:	607a      	str	r2, [r7, #4]
    f3cc:	70fb      	strb	r3, [r7, #3]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    f3ce:	68bb      	ldr	r3, [r7, #8]
    f3d0:	2b00      	cmp	r3, #0
    f3d2:	d103      	bne.n	f3dc <prvInitialiseNewQueue+0x1c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    f3d4:	69ba      	ldr	r2, [r7, #24]
    f3d6:	69bb      	ldr	r3, [r7, #24]
    f3d8:	601a      	str	r2, [r3, #0]
    f3da:	e002      	b.n	f3e2 <prvInitialiseNewQueue+0x22>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    f3dc:	687a      	ldr	r2, [r7, #4]
    f3de:	69bb      	ldr	r3, [r7, #24]
    f3e0:	601a      	str	r2, [r3, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    f3e2:	69bb      	ldr	r3, [r7, #24]
    f3e4:	68fa      	ldr	r2, [r7, #12]
    f3e6:	63da      	str	r2, [r3, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
    f3e8:	69bb      	ldr	r3, [r7, #24]
    f3ea:	68ba      	ldr	r2, [r7, #8]
    f3ec:	641a      	str	r2, [r3, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    f3ee:	69b8      	ldr	r0, [r7, #24]
    f3f0:	f04f 0101 	mov.w	r1, #1
    f3f4:	f7ff ff2e 	bl	f254 <xQueueGenericReset>

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
    f3f8:	69bb      	ldr	r3, [r7, #24]
    f3fa:	78fa      	ldrb	r2, [r7, #3]
    f3fc:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    f400:	f107 0710 	add.w	r7, r7, #16
    f404:	46bd      	mov	sp, r7
    f406:	bd80      	pop	{r7, pc}

0000f408 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
    f408:	b580      	push	{r7, lr}
    f40a:	b082      	sub	sp, #8
    f40c:	af00      	add	r7, sp, #0
    f40e:	6078      	str	r0, [r7, #4]
		if( pxNewQueue != NULL )
    f410:	687b      	ldr	r3, [r7, #4]
    f412:	2b00      	cmp	r3, #0
    f414:	d014      	beq.n	f440 <prvInitialiseMutex+0x38>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
    f416:	687b      	ldr	r3, [r7, #4]
    f418:	f04f 0200 	mov.w	r2, #0
    f41c:	609a      	str	r2, [r3, #8]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    f41e:	687b      	ldr	r3, [r7, #4]
    f420:	f04f 0200 	mov.w	r2, #0
    f424:	601a      	str	r2, [r3, #0]

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
    f426:	687b      	ldr	r3, [r7, #4]
    f428:	f04f 0200 	mov.w	r2, #0
    f42c:	60da      	str	r2, [r3, #12]

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    f42e:	6878      	ldr	r0, [r7, #4]
    f430:	f04f 0100 	mov.w	r1, #0
    f434:	f04f 0200 	mov.w	r2, #0
    f438:	f04f 0300 	mov.w	r3, #0
    f43c:	f000 f894 	bl	f568 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
    f440:	f107 0708 	add.w	r7, r7, #8
    f444:	46bd      	mov	sp, r7
    f446:	bd80      	pop	{r7, pc}

0000f448 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    f448:	b580      	push	{r7, lr}
    f44a:	b086      	sub	sp, #24
    f44c:	af00      	add	r7, sp, #0
    f44e:	4603      	mov	r3, r0
    f450:	71fb      	strb	r3, [r7, #7]
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    f452:	f04f 0301 	mov.w	r3, #1
    f456:	613b      	str	r3, [r7, #16]
    f458:	f04f 0300 	mov.w	r3, #0
    f45c:	617b      	str	r3, [r7, #20]

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    f45e:	79fb      	ldrb	r3, [r7, #7]
    f460:	6938      	ldr	r0, [r7, #16]
    f462:	6979      	ldr	r1, [r7, #20]
    f464:	461a      	mov	r2, r3
    f466:	f7ff ff6b 	bl	f340 <xQueueGenericCreate>
    f46a:	4603      	mov	r3, r0
    f46c:	60fb      	str	r3, [r7, #12]
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
    f46e:	68f8      	ldr	r0, [r7, #12]
    f470:	f7ff ffca 	bl	f408 <prvInitialiseMutex>

		return xNewQueue;
    f474:	68fb      	ldr	r3, [r7, #12]
	}
    f476:	4618      	mov	r0, r3
    f478:	f107 0718 	add.w	r7, r7, #24
    f47c:	46bd      	mov	sp, r7
    f47e:	bd80      	pop	{r7, pc}

0000f480 <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
	{
    f480:	b590      	push	{r4, r7, lr}
    f482:	b087      	sub	sp, #28
    f484:	af00      	add	r7, sp, #0
    f486:	6078      	str	r0, [r7, #4]
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
    f488:	687b      	ldr	r3, [r7, #4]
    f48a:	613b      	str	r3, [r7, #16]

		configASSERT( pxMutex );
    f48c:	693b      	ldr	r3, [r7, #16]
    f48e:	2b00      	cmp	r3, #0
    f490:	d109      	bne.n	f4a6 <xQueueGiveMutexRecursive+0x26>
    f492:	f04f 0328 	mov.w	r3, #40	; 0x28
    f496:	f383 8811 	msr	BASEPRI, r3
    f49a:	f3bf 8f6f 	isb	sy
    f49e:	f3bf 8f4f 	dsb	sy
    f4a2:	617b      	str	r3, [r7, #20]
    f4a4:	e7fe      	b.n	f4a4 <xQueueGiveMutexRecursive+0x24>
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
    f4a6:	693b      	ldr	r3, [r7, #16]
    f4a8:	689c      	ldr	r4, [r3, #8]
    f4aa:	f002 ffed 	bl	12488 <xTaskGetCurrentTaskHandle>
    f4ae:	4603      	mov	r3, r0
    f4b0:	429c      	cmp	r4, r3
    f4b2:	d116      	bne.n	f4e2 <xQueueGiveMutexRecursive+0x62>
			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
    f4b4:	693b      	ldr	r3, [r7, #16]
    f4b6:	68db      	ldr	r3, [r3, #12]
    f4b8:	f103 32ff 	add.w	r2, r3, #4294967295
    f4bc:	693b      	ldr	r3, [r7, #16]
    f4be:	60da      	str	r2, [r3, #12]

			/* Has the recursive call count unwound to 0? */
			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
    f4c0:	693b      	ldr	r3, [r7, #16]
    f4c2:	68db      	ldr	r3, [r3, #12]
    f4c4:	2b00      	cmp	r3, #0
    f4c6:	d108      	bne.n	f4da <xQueueGiveMutexRecursive+0x5a>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
    f4c8:	6938      	ldr	r0, [r7, #16]
    f4ca:	f04f 0100 	mov.w	r1, #0
    f4ce:	f04f 0200 	mov.w	r2, #0
    f4d2:	f04f 0300 	mov.w	r3, #0
    f4d6:	f000 f847 	bl	f568 <xQueueGenericSend>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    f4da:	f04f 0301 	mov.w	r3, #1
    f4de:	60fb      	str	r3, [r7, #12]
    f4e0:	e002      	b.n	f4e8 <xQueueGiveMutexRecursive+0x68>
		}
		else
		{
			/* The mutex cannot be given because the calling task is not the
			holder. */
			xReturn = pdFAIL;
    f4e2:	f04f 0300 	mov.w	r3, #0
    f4e6:	60fb      	str	r3, [r7, #12]

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
    f4e8:	68fb      	ldr	r3, [r7, #12]
	}
    f4ea:	4618      	mov	r0, r3
    f4ec:	f107 071c 	add.w	r7, r7, #28
    f4f0:	46bd      	mov	sp, r7
    f4f2:	bd90      	pop	{r4, r7, pc}

0000f4f4 <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
	{
    f4f4:	b590      	push	{r4, r7, lr}
    f4f6:	b087      	sub	sp, #28
    f4f8:	af00      	add	r7, sp, #0
    f4fa:	6078      	str	r0, [r7, #4]
    f4fc:	6039      	str	r1, [r7, #0]
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
    f4fe:	687b      	ldr	r3, [r7, #4]
    f500:	613b      	str	r3, [r7, #16]

		configASSERT( pxMutex );
    f502:	693b      	ldr	r3, [r7, #16]
    f504:	2b00      	cmp	r3, #0
    f506:	d109      	bne.n	f51c <xQueueTakeMutexRecursive+0x28>
    f508:	f04f 0328 	mov.w	r3, #40	; 0x28
    f50c:	f383 8811 	msr	BASEPRI, r3
    f510:	f3bf 8f6f 	isb	sy
    f514:	f3bf 8f4f 	dsb	sy
    f518:	617b      	str	r3, [r7, #20]
    f51a:	e7fe      	b.n	f51a <xQueueTakeMutexRecursive+0x26>
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
    f51c:	693b      	ldr	r3, [r7, #16]
    f51e:	689c      	ldr	r4, [r3, #8]
    f520:	f002 ffb2 	bl	12488 <xTaskGetCurrentTaskHandle>
    f524:	4603      	mov	r3, r0
    f526:	429c      	cmp	r4, r3
    f528:	d109      	bne.n	f53e <xQueueTakeMutexRecursive+0x4a>
		{
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
    f52a:	693b      	ldr	r3, [r7, #16]
    f52c:	68db      	ldr	r3, [r3, #12]
    f52e:	f103 0201 	add.w	r2, r3, #1
    f532:	693b      	ldr	r3, [r7, #16]
    f534:	60da      	str	r2, [r3, #12]
			xReturn = pdPASS;
    f536:	f04f 0301 	mov.w	r3, #1
    f53a:	60fb      	str	r3, [r7, #12]
    f53c:	e00e      	b.n	f55c <xQueueTakeMutexRecursive+0x68>
		}
		else
		{
			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
    f53e:	6938      	ldr	r0, [r7, #16]
    f540:	6839      	ldr	r1, [r7, #0]
    f542:	f000 fb57 	bl	fbf4 <xQueueSemaphoreTake>
    f546:	4603      	mov	r3, r0
    f548:	60fb      	str	r3, [r7, #12]

			/* pdPASS will only be returned if the mutex was successfully
			obtained.  The calling task may have entered the Blocked state
			before reaching here. */
			if( xReturn != pdFAIL )
    f54a:	68fb      	ldr	r3, [r7, #12]
    f54c:	2b00      	cmp	r3, #0
    f54e:	d005      	beq.n	f55c <xQueueTakeMutexRecursive+0x68>
			{
				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
    f550:	693b      	ldr	r3, [r7, #16]
    f552:	68db      	ldr	r3, [r3, #12]
    f554:	f103 0201 	add.w	r2, r3, #1
    f558:	693b      	ldr	r3, [r7, #16]
    f55a:	60da      	str	r2, [r3, #12]
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
    f55c:	68fb      	ldr	r3, [r7, #12]
	}
    f55e:	4618      	mov	r0, r3
    f560:	f107 071c 	add.w	r7, r7, #28
    f564:	46bd      	mov	sp, r7
    f566:	bd90      	pop	{r4, r7, pc}

0000f568 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    f568:	b580      	push	{r7, lr}
    f56a:	b08e      	sub	sp, #56	; 0x38
    f56c:	af00      	add	r7, sp, #0
    f56e:	60f8      	str	r0, [r7, #12]
    f570:	60b9      	str	r1, [r7, #8]
    f572:	607a      	str	r2, [r7, #4]
    f574:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    f576:	f04f 0300 	mov.w	r3, #0
    f57a:	61fb      	str	r3, [r7, #28]
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    f57c:	68fb      	ldr	r3, [r7, #12]
    f57e:	627b      	str	r3, [r7, #36]	; 0x24

	configASSERT( pxQueue );
    f580:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f582:	2b00      	cmp	r3, #0
    f584:	d109      	bne.n	f59a <xQueueGenericSend+0x32>
    f586:	f04f 0328 	mov.w	r3, #40	; 0x28
    f58a:	f383 8811 	msr	BASEPRI, r3
    f58e:	f3bf 8f6f 	isb	sy
    f592:	f3bf 8f4f 	dsb	sy
    f596:	62bb      	str	r3, [r7, #40]	; 0x28
    f598:	e7fe      	b.n	f598 <xQueueGenericSend+0x30>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    f59a:	68bb      	ldr	r3, [r7, #8]
    f59c:	2b00      	cmp	r3, #0
    f59e:	d103      	bne.n	f5a8 <xQueueGenericSend+0x40>
    f5a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f5a2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    f5a4:	2b00      	cmp	r3, #0
    f5a6:	d102      	bne.n	f5ae <xQueueGenericSend+0x46>
    f5a8:	f04f 0301 	mov.w	r3, #1
    f5ac:	e001      	b.n	f5b2 <xQueueGenericSend+0x4a>
    f5ae:	f04f 0300 	mov.w	r3, #0
    f5b2:	2b00      	cmp	r3, #0
    f5b4:	d109      	bne.n	f5ca <xQueueGenericSend+0x62>
    f5b6:	f04f 0328 	mov.w	r3, #40	; 0x28
    f5ba:	f383 8811 	msr	BASEPRI, r3
    f5be:	f3bf 8f6f 	isb	sy
    f5c2:	f3bf 8f4f 	dsb	sy
    f5c6:	62fb      	str	r3, [r7, #44]	; 0x2c
    f5c8:	e7fe      	b.n	f5c8 <xQueueGenericSend+0x60>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    f5ca:	683b      	ldr	r3, [r7, #0]
    f5cc:	2b02      	cmp	r3, #2
    f5ce:	d103      	bne.n	f5d8 <xQueueGenericSend+0x70>
    f5d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f5d2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    f5d4:	2b01      	cmp	r3, #1
    f5d6:	d102      	bne.n	f5de <xQueueGenericSend+0x76>
    f5d8:	f04f 0301 	mov.w	r3, #1
    f5dc:	e001      	b.n	f5e2 <xQueueGenericSend+0x7a>
    f5de:	f04f 0300 	mov.w	r3, #0
    f5e2:	2b00      	cmp	r3, #0
    f5e4:	d109      	bne.n	f5fa <xQueueGenericSend+0x92>
    f5e6:	f04f 0328 	mov.w	r3, #40	; 0x28
    f5ea:	f383 8811 	msr	BASEPRI, r3
    f5ee:	f3bf 8f6f 	isb	sy
    f5f2:	f3bf 8f4f 	dsb	sy
    f5f6:	633b      	str	r3, [r7, #48]	; 0x30
    f5f8:	e7fe      	b.n	f5f8 <xQueueGenericSend+0x90>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    f5fa:	f002 ff55 	bl	124a8 <xTaskGetSchedulerState>
    f5fe:	4603      	mov	r3, r0
    f600:	2b00      	cmp	r3, #0
    f602:	d102      	bne.n	f60a <xQueueGenericSend+0xa2>
    f604:	687b      	ldr	r3, [r7, #4]
    f606:	2b00      	cmp	r3, #0
    f608:	d102      	bne.n	f610 <xQueueGenericSend+0xa8>
    f60a:	f04f 0301 	mov.w	r3, #1
    f60e:	e001      	b.n	f614 <xQueueGenericSend+0xac>
    f610:	f04f 0300 	mov.w	r3, #0
    f614:	2b00      	cmp	r3, #0
    f616:	d10a      	bne.n	f62e <xQueueGenericSend+0xc6>
    f618:	f04f 0328 	mov.w	r3, #40	; 0x28
    f61c:	f383 8811 	msr	BASEPRI, r3
    f620:	f3bf 8f6f 	isb	sy
    f624:	f3bf 8f4f 	dsb	sy
    f628:	637b      	str	r3, [r7, #52]	; 0x34
    f62a:	e7fe      	b.n	f62a <xQueueGenericSend+0xc2>
			( void ) xTaskResumeAll();

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	} /*lint -restore */
    f62c:	bf00      	nop
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    f62e:	f004 fe23 	bl	14278 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    f632:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f634:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    f636:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f638:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    f63a:	429a      	cmp	r2, r3
    f63c:	d302      	bcc.n	f644 <xQueueGenericSend+0xdc>
    f63e:	683b      	ldr	r3, [r7, #0]
    f640:	2b02      	cmp	r3, #2
    f642:	d134      	bne.n	f6ae <xQueueGenericSend+0x146>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    f644:	6a78      	ldr	r0, [r7, #36]	; 0x24
    f646:	68b9      	ldr	r1, [r7, #8]
    f648:	683a      	ldr	r2, [r7, #0]
    f64a:	f000 fe9d 	bl	10388 <prvCopyDataToQueue>
    f64e:	4603      	mov	r3, r0
    f650:	623b      	str	r3, [r7, #32]

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    f652:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f654:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    f656:	2b00      	cmp	r3, #0
    f658:	d014      	beq.n	f684 <xQueueGenericSend+0x11c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    f65a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f65c:	f103 0324 	add.w	r3, r3, #36	; 0x24
    f660:	4618      	mov	r0, r3
    f662:	f002 fb7b 	bl	11d5c <xTaskRemoveFromEventList>
    f666:	4603      	mov	r3, r0
    f668:	2b00      	cmp	r3, #0
    f66a:	d01a      	beq.n	f6a2 <xQueueGenericSend+0x13a>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    f66c:	f64e 5304 	movw	r3, #60676	; 0xed04
    f670:	f2ce 0300 	movt	r3, #57344	; 0xe000
    f674:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    f678:	601a      	str	r2, [r3, #0]
    f67a:	f3bf 8f4f 	dsb	sy
    f67e:	f3bf 8f6f 	isb	sy
    f682:	e00f      	b.n	f6a4 <xQueueGenericSend+0x13c>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    f684:	6a3b      	ldr	r3, [r7, #32]
    f686:	2b00      	cmp	r3, #0
    f688:	d00c      	beq.n	f6a4 <xQueueGenericSend+0x13c>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    f68a:	f64e 5304 	movw	r3, #60676	; 0xed04
    f68e:	f2ce 0300 	movt	r3, #57344	; 0xe000
    f692:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    f696:	601a      	str	r2, [r3, #0]
    f698:	f3bf 8f4f 	dsb	sy
    f69c:	f3bf 8f6f 	isb	sy
    f6a0:	e000      	b.n	f6a4 <xQueueGenericSend+0x13c>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    f6a2:	bf00      	nop
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    f6a4:	f004 fe20 	bl	142e8 <vPortExitCritical>
				return pdPASS;
    f6a8:	f04f 0301 	mov.w	r3, #1
    f6ac:	e06f      	b.n	f78e <xQueueGenericSend+0x226>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    f6ae:	687b      	ldr	r3, [r7, #4]
    f6b0:	2b00      	cmp	r3, #0
    f6b2:	d104      	bne.n	f6be <xQueueGenericSend+0x156>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    f6b4:	f004 fe18 	bl	142e8 <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    f6b8:	f04f 0300 	mov.w	r3, #0
    f6bc:	e067      	b.n	f78e <xQueueGenericSend+0x226>
				}
				else if( xEntryTimeSet == pdFALSE )
    f6be:	69fb      	ldr	r3, [r7, #28]
    f6c0:	2b00      	cmp	r3, #0
    f6c2:	d107      	bne.n	f6d4 <xQueueGenericSend+0x16c>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    f6c4:	f107 0314 	add.w	r3, r7, #20
    f6c8:	4618      	mov	r0, r3
    f6ca:	f002 fc57 	bl	11f7c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    f6ce:	f04f 0301 	mov.w	r3, #1
    f6d2:	61fb      	str	r3, [r7, #28]
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    f6d4:	f004 fe08 	bl	142e8 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    f6d8:	f001 feee 	bl	114b8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    f6dc:	f004 fdcc 	bl	14278 <vPortEnterCritical>
    f6e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f6e2:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
    f6e6:	b2db      	uxtb	r3, r3
    f6e8:	b25b      	sxtb	r3, r3
    f6ea:	f1b3 3fff 	cmp.w	r3, #4294967295
    f6ee:	d104      	bne.n	f6fa <xQueueGenericSend+0x192>
    f6f0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f6f2:	f04f 0200 	mov.w	r2, #0
    f6f6:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    f6fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f6fc:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
    f700:	b2db      	uxtb	r3, r3
    f702:	b25b      	sxtb	r3, r3
    f704:	f1b3 3fff 	cmp.w	r3, #4294967295
    f708:	d104      	bne.n	f714 <xQueueGenericSend+0x1ac>
    f70a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f70c:	f04f 0200 	mov.w	r2, #0
    f710:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
    f714:	f004 fde8 	bl	142e8 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    f718:	f107 0214 	add.w	r2, r7, #20
    f71c:	f107 0304 	add.w	r3, r7, #4
    f720:	4610      	mov	r0, r2
    f722:	4619      	mov	r1, r3
    f724:	f002 fc42 	bl	11fac <xTaskCheckForTimeOut>
    f728:	4603      	mov	r3, r0
    f72a:	2b00      	cmp	r3, #0
    f72c:	d128      	bne.n	f780 <xQueueGenericSend+0x218>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    f72e:	6a78      	ldr	r0, [r7, #36]	; 0x24
    f730:	f000 ff60 	bl	105f4 <prvIsQueueFull>
    f734:	4603      	mov	r3, r0
    f736:	2b00      	cmp	r3, #0
    f738:	d01c      	beq.n	f774 <xQueueGenericSend+0x20c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    f73a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f73c:	f103 0210 	add.w	r2, r3, #16
    f740:	687b      	ldr	r3, [r7, #4]
    f742:	4610      	mov	r0, r2
    f744:	4619      	mov	r1, r3
    f746:	f002 fa75 	bl	11c34 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    f74a:	6a78      	ldr	r0, [r7, #36]	; 0x24
    f74c:	f000 febc 	bl	104c8 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    f750:	f001 fec4 	bl	114dc <xTaskResumeAll>
    f754:	4603      	mov	r3, r0
    f756:	2b00      	cmp	r3, #0
    f758:	f47f af68 	bne.w	f62c <xQueueGenericSend+0xc4>
				{
					portYIELD_WITHIN_API();
    f75c:	f64e 5304 	movw	r3, #60676	; 0xed04
    f760:	f2ce 0300 	movt	r3, #57344	; 0xe000
    f764:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    f768:	601a      	str	r2, [r3, #0]
    f76a:	f3bf 8f4f 	dsb	sy
    f76e:	f3bf 8f6f 	isb	sy
			( void ) xTaskResumeAll();

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	} /*lint -restore */
    f772:	e75c      	b.n	f62e <xQueueGenericSend+0xc6>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    f774:	6a78      	ldr	r0, [r7, #36]	; 0x24
    f776:	f000 fea7 	bl	104c8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    f77a:	f001 feaf 	bl	114dc <xTaskResumeAll>
			( void ) xTaskResumeAll();

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	} /*lint -restore */
    f77e:	e756      	b.n	f62e <xQueueGenericSend+0xc6>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    f780:	6a78      	ldr	r0, [r7, #36]	; 0x24
    f782:	f000 fea1 	bl	104c8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    f786:	f001 fea9 	bl	114dc <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    f78a:	f04f 0300 	mov.w	r3, #0
		}
	} /*lint -restore */
}
    f78e:	4618      	mov	r0, r3
    f790:	f107 0738 	add.w	r7, r7, #56	; 0x38
    f794:	46bd      	mov	sp, r7
    f796:	bd80      	pop	{r7, pc}

0000f798 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    f798:	b580      	push	{r7, lr}
    f79a:	b08e      	sub	sp, #56	; 0x38
    f79c:	af00      	add	r7, sp, #0
    f79e:	60f8      	str	r0, [r7, #12]
    f7a0:	60b9      	str	r1, [r7, #8]
    f7a2:	607a      	str	r2, [r7, #4]
    f7a4:	603b      	str	r3, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    f7a6:	68fb      	ldr	r3, [r7, #12]
    f7a8:	61bb      	str	r3, [r7, #24]

	configASSERT( pxQueue );
    f7aa:	69bb      	ldr	r3, [r7, #24]
    f7ac:	2b00      	cmp	r3, #0
    f7ae:	d109      	bne.n	f7c4 <xQueueGenericSendFromISR+0x2c>
    f7b0:	f04f 0328 	mov.w	r3, #40	; 0x28
    f7b4:	f383 8811 	msr	BASEPRI, r3
    f7b8:	f3bf 8f6f 	isb	sy
    f7bc:	f3bf 8f4f 	dsb	sy
    f7c0:	623b      	str	r3, [r7, #32]
    f7c2:	e7fe      	b.n	f7c2 <xQueueGenericSendFromISR+0x2a>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    f7c4:	68bb      	ldr	r3, [r7, #8]
    f7c6:	2b00      	cmp	r3, #0
    f7c8:	d103      	bne.n	f7d2 <xQueueGenericSendFromISR+0x3a>
    f7ca:	69bb      	ldr	r3, [r7, #24]
    f7cc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    f7ce:	2b00      	cmp	r3, #0
    f7d0:	d102      	bne.n	f7d8 <xQueueGenericSendFromISR+0x40>
    f7d2:	f04f 0301 	mov.w	r3, #1
    f7d6:	e001      	b.n	f7dc <xQueueGenericSendFromISR+0x44>
    f7d8:	f04f 0300 	mov.w	r3, #0
    f7dc:	2b00      	cmp	r3, #0
    f7de:	d109      	bne.n	f7f4 <xQueueGenericSendFromISR+0x5c>
    f7e0:	f04f 0328 	mov.w	r3, #40	; 0x28
    f7e4:	f383 8811 	msr	BASEPRI, r3
    f7e8:	f3bf 8f6f 	isb	sy
    f7ec:	f3bf 8f4f 	dsb	sy
    f7f0:	627b      	str	r3, [r7, #36]	; 0x24
    f7f2:	e7fe      	b.n	f7f2 <xQueueGenericSendFromISR+0x5a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    f7f4:	683b      	ldr	r3, [r7, #0]
    f7f6:	2b02      	cmp	r3, #2
    f7f8:	d103      	bne.n	f802 <xQueueGenericSendFromISR+0x6a>
    f7fa:	69bb      	ldr	r3, [r7, #24]
    f7fc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    f7fe:	2b01      	cmp	r3, #1
    f800:	d102      	bne.n	f808 <xQueueGenericSendFromISR+0x70>
    f802:	f04f 0301 	mov.w	r3, #1
    f806:	e001      	b.n	f80c <xQueueGenericSendFromISR+0x74>
    f808:	f04f 0300 	mov.w	r3, #0
    f80c:	2b00      	cmp	r3, #0
    f80e:	d109      	bne.n	f824 <xQueueGenericSendFromISR+0x8c>
    f810:	f04f 0328 	mov.w	r3, #40	; 0x28
    f814:	f383 8811 	msr	BASEPRI, r3
    f818:	f3bf 8f6f 	isb	sy
    f81c:	f3bf 8f4f 	dsb	sy
    f820:	62bb      	str	r3, [r7, #40]	; 0x28
    f822:	e7fe      	b.n	f822 <xQueueGenericSendFromISR+0x8a>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    f824:	f004 fe0c 	bl	14440 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
    f828:	f3ef 8211 	mrs	r2, BASEPRI
    f82c:	f04f 0328 	mov.w	r3, #40	; 0x28
    f830:	f383 8811 	msr	BASEPRI, r3
    f834:	f3bf 8f6f 	isb	sy
    f838:	f3bf 8f4f 	dsb	sy
    f83c:	633a      	str	r2, [r7, #48]	; 0x30
    f83e:	62fb      	str	r3, [r7, #44]	; 0x2c
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
    f840:	6b3b      	ldr	r3, [r7, #48]	; 0x30
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    f842:	617b      	str	r3, [r7, #20]
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    f844:	69bb      	ldr	r3, [r7, #24]
    f846:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    f848:	69bb      	ldr	r3, [r7, #24]
    f84a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    f84c:	429a      	cmp	r2, r3
    f84e:	d302      	bcc.n	f856 <xQueueGenericSendFromISR+0xbe>
    f850:	683b      	ldr	r3, [r7, #0]
    f852:	2b02      	cmp	r3, #2
    f854:	d134      	bne.n	f8c0 <xQueueGenericSendFromISR+0x128>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    f856:	69bb      	ldr	r3, [r7, #24]
    f858:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
    f85c:	77fb      	strb	r3, [r7, #31]
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    f85e:	69b8      	ldr	r0, [r7, #24]
    f860:	68b9      	ldr	r1, [r7, #8]
    f862:	683a      	ldr	r2, [r7, #0]
    f864:	f000 fd90 	bl	10388 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    f868:	f997 301f 	ldrsb.w	r3, [r7, #31]
    f86c:	f1b3 3fff 	cmp.w	r3, #4294967295
    f870:	d114      	bne.n	f89c <xQueueGenericSendFromISR+0x104>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    f872:	69bb      	ldr	r3, [r7, #24]
    f874:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    f876:	2b00      	cmp	r3, #0
    f878:	d019      	beq.n	f8ae <xQueueGenericSendFromISR+0x116>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    f87a:	69bb      	ldr	r3, [r7, #24]
    f87c:	f103 0324 	add.w	r3, r3, #36	; 0x24
    f880:	4618      	mov	r0, r3
    f882:	f002 fa6b 	bl	11d5c <xTaskRemoveFromEventList>
    f886:	4603      	mov	r3, r0
    f888:	2b00      	cmp	r3, #0
    f88a:	d012      	beq.n	f8b2 <xQueueGenericSendFromISR+0x11a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    f88c:	687b      	ldr	r3, [r7, #4]
    f88e:	2b00      	cmp	r3, #0
    f890:	d011      	beq.n	f8b6 <xQueueGenericSendFromISR+0x11e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    f892:	687b      	ldr	r3, [r7, #4]
    f894:	f04f 0201 	mov.w	r2, #1
    f898:	601a      	str	r2, [r3, #0]
    f89a:	e00d      	b.n	f8b8 <xQueueGenericSendFromISR+0x120>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    f89c:	7ffb      	ldrb	r3, [r7, #31]
    f89e:	f103 0301 	add.w	r3, r3, #1
    f8a2:	b2db      	uxtb	r3, r3
    f8a4:	461a      	mov	r2, r3
    f8a6:	69bb      	ldr	r3, [r7, #24]
    f8a8:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
    f8ac:	e004      	b.n	f8b8 <xQueueGenericSendFromISR+0x120>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    f8ae:	bf00      	nop
    f8b0:	e002      	b.n	f8b8 <xQueueGenericSendFromISR+0x120>
    f8b2:	bf00      	nop
    f8b4:	e000      	b.n	f8b8 <xQueueGenericSendFromISR+0x120>
    f8b6:	bf00      	nop
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    f8b8:	f04f 0301 	mov.w	r3, #1
    f8bc:	613b      	str	r3, [r7, #16]
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    f8be:	e002      	b.n	f8c6 <xQueueGenericSendFromISR+0x12e>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    f8c0:	f04f 0300 	mov.w	r3, #0
    f8c4:	613b      	str	r3, [r7, #16]
    f8c6:	697b      	ldr	r3, [r7, #20]
    f8c8:	637b      	str	r3, [r7, #52]	; 0x34
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
    f8ca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    f8cc:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    f8d0:	693b      	ldr	r3, [r7, #16]
}
    f8d2:	4618      	mov	r0, r3
    f8d4:	f107 0738 	add.w	r7, r7, #56	; 0x38
    f8d8:	46bd      	mov	sp, r7
    f8da:	bd80      	pop	{r7, pc}

0000f8dc <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    f8dc:	b580      	push	{r7, lr}
    f8de:	b08e      	sub	sp, #56	; 0x38
    f8e0:	af00      	add	r7, sp, #0
    f8e2:	6078      	str	r0, [r7, #4]
    f8e4:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    f8e6:	687b      	ldr	r3, [r7, #4]
    f8e8:	617b      	str	r3, [r7, #20]
	item size is 0.  Don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */

	configASSERT( pxQueue );
    f8ea:	697b      	ldr	r3, [r7, #20]
    f8ec:	2b00      	cmp	r3, #0
    f8ee:	d109      	bne.n	f904 <xQueueGiveFromISR+0x28>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
    f8f0:	f04f 0328 	mov.w	r3, #40	; 0x28
    f8f4:	f383 8811 	msr	BASEPRI, r3
    f8f8:	f3bf 8f6f 	isb	sy
    f8fc:	f3bf 8f4f 	dsb	sy
    f900:	623b      	str	r3, [r7, #32]
    f902:	e7fe      	b.n	f902 <xQueueGiveFromISR+0x26>

	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
	if the item size is not 0. */
	configASSERT( pxQueue->uxItemSize == 0 );
    f904:	697b      	ldr	r3, [r7, #20]
    f906:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    f908:	2b00      	cmp	r3, #0
    f90a:	d009      	beq.n	f920 <xQueueGiveFromISR+0x44>
    f90c:	f04f 0328 	mov.w	r3, #40	; 0x28
    f910:	f383 8811 	msr	BASEPRI, r3
    f914:	f3bf 8f6f 	isb	sy
    f918:	f3bf 8f4f 	dsb	sy
    f91c:	627b      	str	r3, [r7, #36]	; 0x24
    f91e:	e7fe      	b.n	f91e <xQueueGiveFromISR+0x42>

	/* Normally a mutex would not be given from an interrupt, especially if
	there is a mutex holder, as priority inheritance makes no sense for an
	interrupts, only tasks. */
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
    f920:	697b      	ldr	r3, [r7, #20]
    f922:	681b      	ldr	r3, [r3, #0]
    f924:	2b00      	cmp	r3, #0
    f926:	d103      	bne.n	f930 <xQueueGiveFromISR+0x54>
    f928:	697b      	ldr	r3, [r7, #20]
    f92a:	689b      	ldr	r3, [r3, #8]
    f92c:	2b00      	cmp	r3, #0
    f92e:	d102      	bne.n	f936 <xQueueGiveFromISR+0x5a>
    f930:	f04f 0301 	mov.w	r3, #1
    f934:	e001      	b.n	f93a <xQueueGiveFromISR+0x5e>
    f936:	f04f 0300 	mov.w	r3, #0
    f93a:	2b00      	cmp	r3, #0
    f93c:	d109      	bne.n	f952 <xQueueGiveFromISR+0x76>
    f93e:	f04f 0328 	mov.w	r3, #40	; 0x28
    f942:	f383 8811 	msr	BASEPRI, r3
    f946:	f3bf 8f6f 	isb	sy
    f94a:	f3bf 8f4f 	dsb	sy
    f94e:	62bb      	str	r3, [r7, #40]	; 0x28
    f950:	e7fe      	b.n	f950 <xQueueGiveFromISR+0x74>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    f952:	f004 fd75 	bl	14440 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
    f956:	f3ef 8211 	mrs	r2, BASEPRI
    f95a:	f04f 0328 	mov.w	r3, #40	; 0x28
    f95e:	f383 8811 	msr	BASEPRI, r3
    f962:	f3bf 8f6f 	isb	sy
    f966:	f3bf 8f4f 	dsb	sy
    f96a:	633a      	str	r2, [r7, #48]	; 0x30
    f96c:	62fb      	str	r3, [r7, #44]	; 0x2c
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
    f96e:	6b3b      	ldr	r3, [r7, #48]	; 0x30

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    f970:	613b      	str	r3, [r7, #16]
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    f972:	697b      	ldr	r3, [r7, #20]
    f974:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    f976:	61bb      	str	r3, [r7, #24]

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    f978:	697b      	ldr	r3, [r7, #20]
    f97a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    f97c:	69bb      	ldr	r3, [r7, #24]
    f97e:	429a      	cmp	r2, r3
    f980:	d934      	bls.n	f9ec <xQueueGiveFromISR+0x110>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    f982:	697b      	ldr	r3, [r7, #20]
    f984:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
    f988:	77fb      	strb	r3, [r7, #31]
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    f98a:	69bb      	ldr	r3, [r7, #24]
    f98c:	f103 0201 	add.w	r2, r3, #1
    f990:	697b      	ldr	r3, [r7, #20]
    f992:	639a      	str	r2, [r3, #56]	; 0x38

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    f994:	f997 301f 	ldrsb.w	r3, [r7, #31]
    f998:	f1b3 3fff 	cmp.w	r3, #4294967295
    f99c:	d114      	bne.n	f9c8 <xQueueGiveFromISR+0xec>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    f99e:	697b      	ldr	r3, [r7, #20]
    f9a0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    f9a2:	2b00      	cmp	r3, #0
    f9a4:	d019      	beq.n	f9da <xQueueGiveFromISR+0xfe>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    f9a6:	697b      	ldr	r3, [r7, #20]
    f9a8:	f103 0324 	add.w	r3, r3, #36	; 0x24
    f9ac:	4618      	mov	r0, r3
    f9ae:	f002 f9d5 	bl	11d5c <xTaskRemoveFromEventList>
    f9b2:	4603      	mov	r3, r0
    f9b4:	2b00      	cmp	r3, #0
    f9b6:	d012      	beq.n	f9de <xQueueGiveFromISR+0x102>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    f9b8:	683b      	ldr	r3, [r7, #0]
    f9ba:	2b00      	cmp	r3, #0
    f9bc:	d011      	beq.n	f9e2 <xQueueGiveFromISR+0x106>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    f9be:	683b      	ldr	r3, [r7, #0]
    f9c0:	f04f 0201 	mov.w	r2, #1
    f9c4:	601a      	str	r2, [r3, #0]
    f9c6:	e00d      	b.n	f9e4 <xQueueGiveFromISR+0x108>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    f9c8:	7ffb      	ldrb	r3, [r7, #31]
    f9ca:	f103 0301 	add.w	r3, r3, #1
    f9ce:	b2db      	uxtb	r3, r3
    f9d0:	461a      	mov	r2, r3
    f9d2:	697b      	ldr	r3, [r7, #20]
    f9d4:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
    f9d8:	e004      	b.n	f9e4 <xQueueGiveFromISR+0x108>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    f9da:	bf00      	nop
    f9dc:	e002      	b.n	f9e4 <xQueueGiveFromISR+0x108>
    f9de:	bf00      	nop
    f9e0:	e000      	b.n	f9e4 <xQueueGiveFromISR+0x108>
    f9e2:	bf00      	nop
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    f9e4:	f04f 0301 	mov.w	r3, #1
    f9e8:	60fb      	str	r3, [r7, #12]
    f9ea:	e002      	b.n	f9f2 <xQueueGiveFromISR+0x116>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    f9ec:	f04f 0300 	mov.w	r3, #0
    f9f0:	60fb      	str	r3, [r7, #12]
    f9f2:	693b      	ldr	r3, [r7, #16]
    f9f4:	637b      	str	r3, [r7, #52]	; 0x34
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
    f9f6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    f9f8:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    f9fc:	68fb      	ldr	r3, [r7, #12]
}
    f9fe:	4618      	mov	r0, r3
    fa00:	f107 0738 	add.w	r7, r7, #56	; 0x38
    fa04:	46bd      	mov	sp, r7
    fa06:	bd80      	pop	{r7, pc}

0000fa08 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    fa08:	b580      	push	{r7, lr}
    fa0a:	b08c      	sub	sp, #48	; 0x30
    fa0c:	af00      	add	r7, sp, #0
    fa0e:	60f8      	str	r0, [r7, #12]
    fa10:	60b9      	str	r1, [r7, #8]
    fa12:	607a      	str	r2, [r7, #4]
BaseType_t xEntryTimeSet = pdFALSE;
    fa14:	f04f 0300 	mov.w	r3, #0
    fa18:	61bb      	str	r3, [r7, #24]
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    fa1a:	68fb      	ldr	r3, [r7, #12]
    fa1c:	61fb      	str	r3, [r7, #28]

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
    fa1e:	69fb      	ldr	r3, [r7, #28]
    fa20:	2b00      	cmp	r3, #0
    fa22:	d109      	bne.n	fa38 <xQueueReceive+0x30>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
    fa24:	f04f 0328 	mov.w	r3, #40	; 0x28
    fa28:	f383 8811 	msr	BASEPRI, r3
    fa2c:	f3bf 8f6f 	isb	sy
    fa30:	f3bf 8f4f 	dsb	sy
    fa34:	627b      	str	r3, [r7, #36]	; 0x24
    fa36:	e7fe      	b.n	fa36 <xQueueReceive+0x2e>

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    fa38:	68bb      	ldr	r3, [r7, #8]
    fa3a:	2b00      	cmp	r3, #0
    fa3c:	d103      	bne.n	fa46 <xQueueReceive+0x3e>
    fa3e:	69fb      	ldr	r3, [r7, #28]
    fa40:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    fa42:	2b00      	cmp	r3, #0
    fa44:	d102      	bne.n	fa4c <xQueueReceive+0x44>
    fa46:	f04f 0301 	mov.w	r3, #1
    fa4a:	e001      	b.n	fa50 <xQueueReceive+0x48>
    fa4c:	f04f 0300 	mov.w	r3, #0
    fa50:	2b00      	cmp	r3, #0
    fa52:	d109      	bne.n	fa68 <xQueueReceive+0x60>
    fa54:	f04f 0328 	mov.w	r3, #40	; 0x28
    fa58:	f383 8811 	msr	BASEPRI, r3
    fa5c:	f3bf 8f6f 	isb	sy
    fa60:	f3bf 8f4f 	dsb	sy
    fa64:	62bb      	str	r3, [r7, #40]	; 0x28
    fa66:	e7fe      	b.n	fa66 <xQueueReceive+0x5e>

	/* Cannot block if the scheduler is suspended. */
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    fa68:	f002 fd1e 	bl	124a8 <xTaskGetSchedulerState>
    fa6c:	4603      	mov	r3, r0
    fa6e:	2b00      	cmp	r3, #0
    fa70:	d102      	bne.n	fa78 <xQueueReceive+0x70>
    fa72:	687b      	ldr	r3, [r7, #4]
    fa74:	2b00      	cmp	r3, #0
    fa76:	d102      	bne.n	fa7e <xQueueReceive+0x76>
    fa78:	f04f 0301 	mov.w	r3, #1
    fa7c:	e001      	b.n	fa82 <xQueueReceive+0x7a>
    fa7e:	f04f 0300 	mov.w	r3, #0
    fa82:	2b00      	cmp	r3, #0
    fa84:	d10c      	bne.n	faa0 <xQueueReceive+0x98>
    fa86:	f04f 0328 	mov.w	r3, #40	; 0x28
    fa8a:	f383 8811 	msr	BASEPRI, r3
    fa8e:	f3bf 8f6f 	isb	sy
    fa92:	f3bf 8f4f 	dsb	sy
    fa96:	62fb      	str	r3, [r7, #44]	; 0x2c
    fa98:	e7fe      	b.n	fa98 <xQueueReceive+0x90>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    fa9a:	bf00      	nop
    fa9c:	e000      	b.n	faa0 <xQueueReceive+0x98>
    fa9e:	bf00      	nop
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    faa0:	f004 fbea 	bl	14278 <vPortEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    faa4:	69fb      	ldr	r3, [r7, #28]
    faa6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    faa8:	623b      	str	r3, [r7, #32]

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    faaa:	6a3b      	ldr	r3, [r7, #32]
    faac:	2b00      	cmp	r3, #0
    faae:	d025      	beq.n	fafc <xQueueReceive+0xf4>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    fab0:	69f8      	ldr	r0, [r7, #28]
    fab2:	68b9      	ldr	r1, [r7, #8]
    fab4:	f000 fce0 	bl	10478 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    fab8:	6a3b      	ldr	r3, [r7, #32]
    faba:	f103 32ff 	add.w	r2, r3, #4294967295
    fabe:	69fb      	ldr	r3, [r7, #28]
    fac0:	639a      	str	r2, [r3, #56]	; 0x38

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    fac2:	69fb      	ldr	r3, [r7, #28]
    fac4:	691b      	ldr	r3, [r3, #16]
    fac6:	2b00      	cmp	r3, #0
    fac8:	d013      	beq.n	faf2 <xQueueReceive+0xea>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    faca:	69fb      	ldr	r3, [r7, #28]
    facc:	f103 0310 	add.w	r3, r3, #16
    fad0:	4618      	mov	r0, r3
    fad2:	f002 f943 	bl	11d5c <xTaskRemoveFromEventList>
    fad6:	4603      	mov	r3, r0
    fad8:	2b00      	cmp	r3, #0
    fada:	d00a      	beq.n	faf2 <xQueueReceive+0xea>
					{
						queueYIELD_IF_USING_PREEMPTION();
    fadc:	f64e 5304 	movw	r3, #60676	; 0xed04
    fae0:	f2ce 0300 	movt	r3, #57344	; 0xe000
    fae4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    fae8:	601a      	str	r2, [r3, #0]
    faea:	f3bf 8f4f 	dsb	sy
    faee:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    faf2:	f004 fbf9 	bl	142e8 <vPortExitCritical>
				return pdPASS;
    faf6:	f04f 0301 	mov.w	r3, #1
    fafa:	e076      	b.n	fbea <xQueueReceive+0x1e2>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    fafc:	687b      	ldr	r3, [r7, #4]
    fafe:	2b00      	cmp	r3, #0
    fb00:	d104      	bne.n	fb0c <xQueueReceive+0x104>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    fb02:	f004 fbf1 	bl	142e8 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    fb06:	f04f 0300 	mov.w	r3, #0
    fb0a:	e06e      	b.n	fbea <xQueueReceive+0x1e2>
				}
				else if( xEntryTimeSet == pdFALSE )
    fb0c:	69bb      	ldr	r3, [r7, #24]
    fb0e:	2b00      	cmp	r3, #0
    fb10:	d107      	bne.n	fb22 <xQueueReceive+0x11a>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    fb12:	f107 0310 	add.w	r3, r7, #16
    fb16:	4618      	mov	r0, r3
    fb18:	f002 fa30 	bl	11f7c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    fb1c:	f04f 0301 	mov.w	r3, #1
    fb20:	61bb      	str	r3, [r7, #24]
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    fb22:	f004 fbe1 	bl	142e8 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    fb26:	f001 fcc7 	bl	114b8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    fb2a:	f004 fba5 	bl	14278 <vPortEnterCritical>
    fb2e:	69fb      	ldr	r3, [r7, #28]
    fb30:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
    fb34:	b2db      	uxtb	r3, r3
    fb36:	b25b      	sxtb	r3, r3
    fb38:	f1b3 3fff 	cmp.w	r3, #4294967295
    fb3c:	d104      	bne.n	fb48 <xQueueReceive+0x140>
    fb3e:	69fb      	ldr	r3, [r7, #28]
    fb40:	f04f 0200 	mov.w	r2, #0
    fb44:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    fb48:	69fb      	ldr	r3, [r7, #28]
    fb4a:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
    fb4e:	b2db      	uxtb	r3, r3
    fb50:	b25b      	sxtb	r3, r3
    fb52:	f1b3 3fff 	cmp.w	r3, #4294967295
    fb56:	d104      	bne.n	fb62 <xQueueReceive+0x15a>
    fb58:	69fb      	ldr	r3, [r7, #28]
    fb5a:	f04f 0200 	mov.w	r2, #0
    fb5e:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
    fb62:	f004 fbc1 	bl	142e8 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    fb66:	f107 0210 	add.w	r2, r7, #16
    fb6a:	f107 0304 	add.w	r3, r7, #4
    fb6e:	4610      	mov	r0, r2
    fb70:	4619      	mov	r1, r3
    fb72:	f002 fa1b 	bl	11fac <xTaskCheckForTimeOut>
    fb76:	4603      	mov	r3, r0
    fb78:	2b00      	cmp	r3, #0
    fb7a:	d128      	bne.n	fbce <xQueueReceive+0x1c6>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    fb7c:	69f8      	ldr	r0, [r7, #28]
    fb7e:	f000 fcf9 	bl	10574 <prvIsQueueEmpty>
    fb82:	4603      	mov	r3, r0
    fb84:	2b00      	cmp	r3, #0
    fb86:	d01c      	beq.n	fbc2 <xQueueReceive+0x1ba>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    fb88:	69fb      	ldr	r3, [r7, #28]
    fb8a:	f103 0224 	add.w	r2, r3, #36	; 0x24
    fb8e:	687b      	ldr	r3, [r7, #4]
    fb90:	4610      	mov	r0, r2
    fb92:	4619      	mov	r1, r3
    fb94:	f002 f84e 	bl	11c34 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    fb98:	69f8      	ldr	r0, [r7, #28]
    fb9a:	f000 fc95 	bl	104c8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    fb9e:	f001 fc9d 	bl	114dc <xTaskResumeAll>
    fba2:	4603      	mov	r3, r0
    fba4:	2b00      	cmp	r3, #0
    fba6:	f47f af78 	bne.w	fa9a <xQueueReceive+0x92>
				{
					portYIELD_WITHIN_API();
    fbaa:	f64e 5304 	movw	r3, #60676	; 0xed04
    fbae:	f2ce 0300 	movt	r3, #57344	; 0xe000
    fbb2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    fbb6:	601a      	str	r2, [r3, #0]
    fbb8:	f3bf 8f4f 	dsb	sy
    fbbc:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    fbc0:	e76e      	b.n	faa0 <xQueueReceive+0x98>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    fbc2:	69f8      	ldr	r0, [r7, #28]
    fbc4:	f000 fc80 	bl	104c8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    fbc8:	f001 fc88 	bl	114dc <xTaskResumeAll>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    fbcc:	e768      	b.n	faa0 <xQueueReceive+0x98>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    fbce:	69f8      	ldr	r0, [r7, #28]
    fbd0:	f000 fc7a 	bl	104c8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    fbd4:	f001 fc82 	bl	114dc <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    fbd8:	69f8      	ldr	r0, [r7, #28]
    fbda:	f000 fccb 	bl	10574 <prvIsQueueEmpty>
    fbde:	4603      	mov	r3, r0
    fbe0:	2b00      	cmp	r3, #0
    fbe2:	f43f af5c 	beq.w	fa9e <xQueueReceive+0x96>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    fbe6:	f04f 0300 	mov.w	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    fbea:	4618      	mov	r0, r3
    fbec:	f107 0730 	add.w	r7, r7, #48	; 0x30
    fbf0:	46bd      	mov	sp, r7
    fbf2:	bd80      	pop	{r7, pc}

0000fbf4 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    fbf4:	b580      	push	{r7, lr}
    fbf6:	b08e      	sub	sp, #56	; 0x38
    fbf8:	af00      	add	r7, sp, #0
    fbfa:	6078      	str	r0, [r7, #4]
    fbfc:	6039      	str	r1, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE;
    fbfe:	f04f 0300 	mov.w	r3, #0
    fc02:	617b      	str	r3, [r7, #20]
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    fc04:	687b      	ldr	r3, [r7, #4]
    fc06:	61bb      	str	r3, [r7, #24]

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
    fc08:	f04f 0300 	mov.w	r3, #0
    fc0c:	61fb      	str	r3, [r7, #28]
#endif

	/* Check the queue pointer is not NULL. */
	configASSERT( ( pxQueue ) );
    fc0e:	69bb      	ldr	r3, [r7, #24]
    fc10:	2b00      	cmp	r3, #0
    fc12:	d109      	bne.n	fc28 <xQueueSemaphoreTake+0x34>
    fc14:	f04f 0328 	mov.w	r3, #40	; 0x28
    fc18:	f383 8811 	msr	BASEPRI, r3
    fc1c:	f3bf 8f6f 	isb	sy
    fc20:	f3bf 8f4f 	dsb	sy
    fc24:	62bb      	str	r3, [r7, #40]	; 0x28
    fc26:	e7fe      	b.n	fc26 <xQueueSemaphoreTake+0x32>

	/* Check this really is a semaphore, in which case the item size will be
	0. */
	configASSERT( pxQueue->uxItemSize == 0 );
    fc28:	69bb      	ldr	r3, [r7, #24]
    fc2a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    fc2c:	2b00      	cmp	r3, #0
    fc2e:	d009      	beq.n	fc44 <xQueueSemaphoreTake+0x50>
    fc30:	f04f 0328 	mov.w	r3, #40	; 0x28
    fc34:	f383 8811 	msr	BASEPRI, r3
    fc38:	f3bf 8f6f 	isb	sy
    fc3c:	f3bf 8f4f 	dsb	sy
    fc40:	62fb      	str	r3, [r7, #44]	; 0x2c
    fc42:	e7fe      	b.n	fc42 <xQueueSemaphoreTake+0x4e>

	/* Cannot block if the scheduler is suspended. */
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    fc44:	f002 fc30 	bl	124a8 <xTaskGetSchedulerState>
    fc48:	4603      	mov	r3, r0
    fc4a:	2b00      	cmp	r3, #0
    fc4c:	d102      	bne.n	fc54 <xQueueSemaphoreTake+0x60>
    fc4e:	683b      	ldr	r3, [r7, #0]
    fc50:	2b00      	cmp	r3, #0
    fc52:	d102      	bne.n	fc5a <xQueueSemaphoreTake+0x66>
    fc54:	f04f 0301 	mov.w	r3, #1
    fc58:	e001      	b.n	fc5e <xQueueSemaphoreTake+0x6a>
    fc5a:	f04f 0300 	mov.w	r3, #0
    fc5e:	2b00      	cmp	r3, #0
    fc60:	d10c      	bne.n	fc7c <xQueueSemaphoreTake+0x88>
    fc62:	f04f 0328 	mov.w	r3, #40	; 0x28
    fc66:	f383 8811 	msr	BASEPRI, r3
    fc6a:	f3bf 8f6f 	isb	sy
    fc6e:	f3bf 8f4f 	dsb	sy
    fc72:	633b      	str	r3, [r7, #48]	; 0x30
    fc74:	e7fe      	b.n	fc74 <xQueueSemaphoreTake+0x80>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    fc76:	bf00      	nop
    fc78:	e000      	b.n	fc7c <xQueueSemaphoreTake+0x88>
    fc7a:	bf00      	nop
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    fc7c:	f004 fafc 	bl	14278 <vPortEnterCritical>
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    fc80:	69bb      	ldr	r3, [r7, #24]
    fc82:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    fc84:	623b      	str	r3, [r7, #32]

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    fc86:	6a3b      	ldr	r3, [r7, #32]
    fc88:	2b00      	cmp	r3, #0
    fc8a:	d02a      	beq.n	fce2 <xQueueSemaphoreTake+0xee>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    fc8c:	6a3b      	ldr	r3, [r7, #32]
    fc8e:	f103 32ff 	add.w	r2, r3, #4294967295
    fc92:	69bb      	ldr	r3, [r7, #24]
    fc94:	639a      	str	r2, [r3, #56]	; 0x38

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    fc96:	69bb      	ldr	r3, [r7, #24]
    fc98:	681b      	ldr	r3, [r3, #0]
    fc9a:	2b00      	cmp	r3, #0
    fc9c:	d104      	bne.n	fca8 <xQueueSemaphoreTake+0xb4>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    fc9e:	f002 ffdf 	bl	12c60 <pvTaskIncrementMutexHeldCount>
    fca2:	4602      	mov	r2, r0
    fca4:	69bb      	ldr	r3, [r7, #24]
    fca6:	609a      	str	r2, [r3, #8]
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    fca8:	69bb      	ldr	r3, [r7, #24]
    fcaa:	691b      	ldr	r3, [r3, #16]
    fcac:	2b00      	cmp	r3, #0
    fcae:	d013      	beq.n	fcd8 <xQueueSemaphoreTake+0xe4>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    fcb0:	69bb      	ldr	r3, [r7, #24]
    fcb2:	f103 0310 	add.w	r3, r3, #16
    fcb6:	4618      	mov	r0, r3
    fcb8:	f002 f850 	bl	11d5c <xTaskRemoveFromEventList>
    fcbc:	4603      	mov	r3, r0
    fcbe:	2b00      	cmp	r3, #0
    fcc0:	d00a      	beq.n	fcd8 <xQueueSemaphoreTake+0xe4>
					{
						queueYIELD_IF_USING_PREEMPTION();
    fcc2:	f64e 5304 	movw	r3, #60676	; 0xed04
    fcc6:	f2ce 0300 	movt	r3, #57344	; 0xe000
    fcca:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    fcce:	601a      	str	r2, [r3, #0]
    fcd0:	f3bf 8f4f 	dsb	sy
    fcd4:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    fcd8:	f004 fb06 	bl	142e8 <vPortExitCritical>
				return pdPASS;
    fcdc:	f04f 0301 	mov.w	r3, #1
    fce0:	e0a3      	b.n	fe2a <xQueueSemaphoreTake+0x236>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    fce2:	683b      	ldr	r3, [r7, #0]
    fce4:	2b00      	cmp	r3, #0
    fce6:	d111      	bne.n	fd0c <xQueueSemaphoreTake+0x118>
					/* For inheritance to have occurred there must have been an
					initial timeout, and an adjusted timeout cannot become 0, as
					if it were 0 the function would have exited. */
					#if( configUSE_MUTEXES == 1 )
					{
						configASSERT( xInheritanceOccurred == pdFALSE );
    fce8:	69fb      	ldr	r3, [r7, #28]
    fcea:	2b00      	cmp	r3, #0
    fcec:	d009      	beq.n	fd02 <xQueueSemaphoreTake+0x10e>
    fcee:	f04f 0328 	mov.w	r3, #40	; 0x28
    fcf2:	f383 8811 	msr	BASEPRI, r3
    fcf6:	f3bf 8f6f 	isb	sy
    fcfa:	f3bf 8f4f 	dsb	sy
    fcfe:	637b      	str	r3, [r7, #52]	; 0x34
    fd00:	e7fe      	b.n	fd00 <xQueueSemaphoreTake+0x10c>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    fd02:	f004 faf1 	bl	142e8 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    fd06:	f04f 0300 	mov.w	r3, #0
    fd0a:	e08e      	b.n	fe2a <xQueueSemaphoreTake+0x236>
				}
				else if( xEntryTimeSet == pdFALSE )
    fd0c:	697b      	ldr	r3, [r7, #20]
    fd0e:	2b00      	cmp	r3, #0
    fd10:	d107      	bne.n	fd22 <xQueueSemaphoreTake+0x12e>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    fd12:	f107 030c 	add.w	r3, r7, #12
    fd16:	4618      	mov	r0, r3
    fd18:	f002 f930 	bl	11f7c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    fd1c:	f04f 0301 	mov.w	r3, #1
    fd20:	617b      	str	r3, [r7, #20]
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    fd22:	f004 fae1 	bl	142e8 <vPortExitCritical>

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    fd26:	f001 fbc7 	bl	114b8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    fd2a:	f004 faa5 	bl	14278 <vPortEnterCritical>
    fd2e:	69bb      	ldr	r3, [r7, #24]
    fd30:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
    fd34:	b2db      	uxtb	r3, r3
    fd36:	b25b      	sxtb	r3, r3
    fd38:	f1b3 3fff 	cmp.w	r3, #4294967295
    fd3c:	d104      	bne.n	fd48 <xQueueSemaphoreTake+0x154>
    fd3e:	69bb      	ldr	r3, [r7, #24]
    fd40:	f04f 0200 	mov.w	r2, #0
    fd44:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    fd48:	69bb      	ldr	r3, [r7, #24]
    fd4a:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
    fd4e:	b2db      	uxtb	r3, r3
    fd50:	b25b      	sxtb	r3, r3
    fd52:	f1b3 3fff 	cmp.w	r3, #4294967295
    fd56:	d104      	bne.n	fd62 <xQueueSemaphoreTake+0x16e>
    fd58:	69bb      	ldr	r3, [r7, #24]
    fd5a:	f04f 0200 	mov.w	r2, #0
    fd5e:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
    fd62:	f004 fac1 	bl	142e8 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    fd66:	f107 020c 	add.w	r2, r7, #12
    fd6a:	463b      	mov	r3, r7
    fd6c:	4610      	mov	r0, r2
    fd6e:	4619      	mov	r1, r3
    fd70:	f002 f91c 	bl	11fac <xTaskCheckForTimeOut>
    fd74:	4603      	mov	r3, r0
    fd76:	2b00      	cmp	r3, #0
    fd78:	d137      	bne.n	fdea <xQueueSemaphoreTake+0x1f6>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    fd7a:	69b8      	ldr	r0, [r7, #24]
    fd7c:	f000 fbfa 	bl	10574 <prvIsQueueEmpty>
    fd80:	4603      	mov	r3, r0
    fd82:	2b00      	cmp	r3, #0
    fd84:	d02b      	beq.n	fdde <xQueueSemaphoreTake+0x1ea>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    fd86:	69bb      	ldr	r3, [r7, #24]
    fd88:	681b      	ldr	r3, [r3, #0]
    fd8a:	2b00      	cmp	r3, #0
    fd8c:	d10a      	bne.n	fda4 <xQueueSemaphoreTake+0x1b0>
					{
						taskENTER_CRITICAL();
    fd8e:	f004 fa73 	bl	14278 <vPortEnterCritical>
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    fd92:	69bb      	ldr	r3, [r7, #24]
    fd94:	689b      	ldr	r3, [r3, #8]
    fd96:	4618      	mov	r0, r3
    fd98:	f002 fbaa 	bl	124f0 <xTaskPriorityInherit>
    fd9c:	4603      	mov	r3, r0
    fd9e:	61fb      	str	r3, [r7, #28]
						}
						taskEXIT_CRITICAL();
    fda0:	f004 faa2 	bl	142e8 <vPortExitCritical>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    fda4:	69bb      	ldr	r3, [r7, #24]
    fda6:	f103 0224 	add.w	r2, r3, #36	; 0x24
    fdaa:	683b      	ldr	r3, [r7, #0]
    fdac:	4610      	mov	r0, r2
    fdae:	4619      	mov	r1, r3
    fdb0:	f001 ff40 	bl	11c34 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    fdb4:	69b8      	ldr	r0, [r7, #24]
    fdb6:	f000 fb87 	bl	104c8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    fdba:	f001 fb8f 	bl	114dc <xTaskResumeAll>
    fdbe:	4603      	mov	r3, r0
    fdc0:	2b00      	cmp	r3, #0
    fdc2:	f47f af58 	bne.w	fc76 <xQueueSemaphoreTake+0x82>
				{
					portYIELD_WITHIN_API();
    fdc6:	f64e 5304 	movw	r3, #60676	; 0xed04
    fdca:	f2ce 0300 	movt	r3, #57344	; 0xe000
    fdce:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    fdd2:	601a      	str	r2, [r3, #0]
    fdd4:	f3bf 8f4f 	dsb	sy
    fdd8:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    fddc:	e74e      	b.n	fc7c <xQueueSemaphoreTake+0x88>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    fdde:	69b8      	ldr	r0, [r7, #24]
    fde0:	f000 fb72 	bl	104c8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    fde4:	f001 fb7a 	bl	114dc <xTaskResumeAll>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    fde8:	e748      	b.n	fc7c <xQueueSemaphoreTake+0x88>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    fdea:	69b8      	ldr	r0, [r7, #24]
    fdec:	f000 fb6c 	bl	104c8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    fdf0:	f001 fb74 	bl	114dc <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    fdf4:	69b8      	ldr	r0, [r7, #24]
    fdf6:	f000 fbbd 	bl	10574 <prvIsQueueEmpty>
    fdfa:	4603      	mov	r3, r0
    fdfc:	2b00      	cmp	r3, #0
    fdfe:	f43f af3c 	beq.w	fc7a <xQueueSemaphoreTake+0x86>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
    fe02:	69fb      	ldr	r3, [r7, #28]
    fe04:	2b00      	cmp	r3, #0
    fe06:	d00e      	beq.n	fe26 <xQueueSemaphoreTake+0x232>
					{
						taskENTER_CRITICAL();
    fe08:	f004 fa36 	bl	14278 <vPortEnterCritical>
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
    fe0c:	69b8      	ldr	r0, [r7, #24]
    fe0e:	f000 faa1 	bl	10354 <prvGetDisinheritPriorityAfterTimeout>
    fe12:	4603      	mov	r3, r0
    fe14:	627b      	str	r3, [r7, #36]	; 0x24
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    fe16:	69bb      	ldr	r3, [r7, #24]
    fe18:	689b      	ldr	r3, [r3, #8]
    fe1a:	4618      	mov	r0, r3
    fe1c:	6a79      	ldr	r1, [r7, #36]	; 0x24
    fe1e:	f002 fcc3 	bl	127a8 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
    fe22:	f004 fa61 	bl	142e8 <vPortExitCritical>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    fe26:	f04f 0300 	mov.w	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    fe2a:	4618      	mov	r0, r3
    fe2c:	f107 0738 	add.w	r7, r7, #56	; 0x38
    fe30:	46bd      	mov	sp, r7
    fe32:	bd80      	pop	{r7, pc}

0000fe34 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    fe34:	b580      	push	{r7, lr}
    fe36:	b08e      	sub	sp, #56	; 0x38
    fe38:	af00      	add	r7, sp, #0
    fe3a:	60f8      	str	r0, [r7, #12]
    fe3c:	60b9      	str	r1, [r7, #8]
    fe3e:	607a      	str	r2, [r7, #4]
BaseType_t xEntryTimeSet = pdFALSE;
    fe40:	f04f 0300 	mov.w	r3, #0
    fe44:	61fb      	str	r3, [r7, #28]
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    fe46:	68fb      	ldr	r3, [r7, #12]
    fe48:	627b      	str	r3, [r7, #36]	; 0x24

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
    fe4a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    fe4c:	2b00      	cmp	r3, #0
    fe4e:	d109      	bne.n	fe64 <xQueuePeek+0x30>
    fe50:	f04f 0328 	mov.w	r3, #40	; 0x28
    fe54:	f383 8811 	msr	BASEPRI, r3
    fe58:	f3bf 8f6f 	isb	sy
    fe5c:	f3bf 8f4f 	dsb	sy
    fe60:	62fb      	str	r3, [r7, #44]	; 0x2c
    fe62:	e7fe      	b.n	fe62 <xQueuePeek+0x2e>

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    fe64:	68bb      	ldr	r3, [r7, #8]
    fe66:	2b00      	cmp	r3, #0
    fe68:	d103      	bne.n	fe72 <xQueuePeek+0x3e>
    fe6a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    fe6c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    fe6e:	2b00      	cmp	r3, #0
    fe70:	d102      	bne.n	fe78 <xQueuePeek+0x44>
    fe72:	f04f 0301 	mov.w	r3, #1
    fe76:	e001      	b.n	fe7c <xQueuePeek+0x48>
    fe78:	f04f 0300 	mov.w	r3, #0
    fe7c:	2b00      	cmp	r3, #0
    fe7e:	d109      	bne.n	fe94 <xQueuePeek+0x60>
    fe80:	f04f 0328 	mov.w	r3, #40	; 0x28
    fe84:	f383 8811 	msr	BASEPRI, r3
    fe88:	f3bf 8f6f 	isb	sy
    fe8c:	f3bf 8f4f 	dsb	sy
    fe90:	633b      	str	r3, [r7, #48]	; 0x30
    fe92:	e7fe      	b.n	fe92 <xQueuePeek+0x5e>

	/* Cannot block if the scheduler is suspended. */
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    fe94:	f002 fb08 	bl	124a8 <xTaskGetSchedulerState>
    fe98:	4603      	mov	r3, r0
    fe9a:	2b00      	cmp	r3, #0
    fe9c:	d102      	bne.n	fea4 <xQueuePeek+0x70>
    fe9e:	687b      	ldr	r3, [r7, #4]
    fea0:	2b00      	cmp	r3, #0
    fea2:	d102      	bne.n	feaa <xQueuePeek+0x76>
    fea4:	f04f 0301 	mov.w	r3, #1
    fea8:	e001      	b.n	feae <xQueuePeek+0x7a>
    feaa:	f04f 0300 	mov.w	r3, #0
    feae:	2b00      	cmp	r3, #0
    feb0:	d10c      	bne.n	fecc <xQueuePeek+0x98>
    feb2:	f04f 0328 	mov.w	r3, #40	; 0x28
    feb6:	f383 8811 	msr	BASEPRI, r3
    feba:	f3bf 8f6f 	isb	sy
    febe:	f3bf 8f4f 	dsb	sy
    fec2:	637b      	str	r3, [r7, #52]	; 0x34
    fec4:	e7fe      	b.n	fec4 <xQueuePeek+0x90>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    fec6:	bf00      	nop
    fec8:	e000      	b.n	fecc <xQueuePeek+0x98>
    feca:	bf00      	nop
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    fecc:	f004 f9d4 	bl	14278 <vPortEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    fed0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    fed2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    fed4:	62bb      	str	r3, [r7, #40]	; 0x28

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    fed6:	6abb      	ldr	r3, [r7, #40]	; 0x28
    fed8:	2b00      	cmp	r3, #0
    feda:	d026      	beq.n	ff2a <xQueuePeek+0xf6>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    fedc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    fede:	68db      	ldr	r3, [r3, #12]
    fee0:	623b      	str	r3, [r7, #32]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    fee2:	6a78      	ldr	r0, [r7, #36]	; 0x24
    fee4:	68b9      	ldr	r1, [r7, #8]
    fee6:	f000 fac7 	bl	10478 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    feea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    feec:	6a3a      	ldr	r2, [r7, #32]
    feee:	60da      	str	r2, [r3, #12]

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    fef0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    fef2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    fef4:	2b00      	cmp	r3, #0
    fef6:	d013      	beq.n	ff20 <xQueuePeek+0xec>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    fef8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    fefa:	f103 0324 	add.w	r3, r3, #36	; 0x24
    fefe:	4618      	mov	r0, r3
    ff00:	f001 ff2c 	bl	11d5c <xTaskRemoveFromEventList>
    ff04:	4603      	mov	r3, r0
    ff06:	2b00      	cmp	r3, #0
    ff08:	d00a      	beq.n	ff20 <xQueuePeek+0xec>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    ff0a:	f64e 5304 	movw	r3, #60676	; 0xed04
    ff0e:	f2ce 0300 	movt	r3, #57344	; 0xe000
    ff12:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    ff16:	601a      	str	r2, [r3, #0]
    ff18:	f3bf 8f4f 	dsb	sy
    ff1c:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    ff20:	f004 f9e2 	bl	142e8 <vPortExitCritical>
				return pdPASS;
    ff24:	f04f 0301 	mov.w	r3, #1
    ff28:	e076      	b.n	10018 <RAM_SIZE+0x18>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    ff2a:	687b      	ldr	r3, [r7, #4]
    ff2c:	2b00      	cmp	r3, #0
    ff2e:	d104      	bne.n	ff3a <xQueuePeek+0x106>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    ff30:	f004 f9da 	bl	142e8 <vPortExitCritical>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    ff34:	f04f 0300 	mov.w	r3, #0
    ff38:	e06e      	b.n	10018 <RAM_SIZE+0x18>
				}
				else if( xEntryTimeSet == pdFALSE )
    ff3a:	69fb      	ldr	r3, [r7, #28]
    ff3c:	2b00      	cmp	r3, #0
    ff3e:	d107      	bne.n	ff50 <xQueuePeek+0x11c>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    ff40:	f107 0314 	add.w	r3, r7, #20
    ff44:	4618      	mov	r0, r3
    ff46:	f002 f819 	bl	11f7c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    ff4a:	f04f 0301 	mov.w	r3, #1
    ff4e:	61fb      	str	r3, [r7, #28]
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    ff50:	f004 f9ca 	bl	142e8 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    ff54:	f001 fab0 	bl	114b8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    ff58:	f004 f98e 	bl	14278 <vPortEnterCritical>
    ff5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    ff5e:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
    ff62:	b2db      	uxtb	r3, r3
    ff64:	b25b      	sxtb	r3, r3
    ff66:	f1b3 3fff 	cmp.w	r3, #4294967295
    ff6a:	d104      	bne.n	ff76 <xQueuePeek+0x142>
    ff6c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    ff6e:	f04f 0200 	mov.w	r2, #0
    ff72:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    ff76:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    ff78:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
    ff7c:	b2db      	uxtb	r3, r3
    ff7e:	b25b      	sxtb	r3, r3
    ff80:	f1b3 3fff 	cmp.w	r3, #4294967295
    ff84:	d104      	bne.n	ff90 <xQueuePeek+0x15c>
    ff86:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    ff88:	f04f 0200 	mov.w	r2, #0
    ff8c:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
    ff90:	f004 f9aa 	bl	142e8 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    ff94:	f107 0214 	add.w	r2, r7, #20
    ff98:	f107 0304 	add.w	r3, r7, #4
    ff9c:	4610      	mov	r0, r2
    ff9e:	4619      	mov	r1, r3
    ffa0:	f002 f804 	bl	11fac <xTaskCheckForTimeOut>
    ffa4:	4603      	mov	r3, r0
    ffa6:	2b00      	cmp	r3, #0
    ffa8:	d128      	bne.n	fffc <xQueuePeek+0x1c8>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    ffaa:	6a78      	ldr	r0, [r7, #36]	; 0x24
    ffac:	f000 fae2 	bl	10574 <prvIsQueueEmpty>
    ffb0:	4603      	mov	r3, r0
    ffb2:	2b00      	cmp	r3, #0
    ffb4:	d01c      	beq.n	fff0 <xQueuePeek+0x1bc>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    ffb6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    ffb8:	f103 0224 	add.w	r2, r3, #36	; 0x24
    ffbc:	687b      	ldr	r3, [r7, #4]
    ffbe:	4610      	mov	r0, r2
    ffc0:	4619      	mov	r1, r3
    ffc2:	f001 fe37 	bl	11c34 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    ffc6:	6a78      	ldr	r0, [r7, #36]	; 0x24
    ffc8:	f000 fa7e 	bl	104c8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    ffcc:	f001 fa86 	bl	114dc <xTaskResumeAll>
    ffd0:	4603      	mov	r3, r0
    ffd2:	2b00      	cmp	r3, #0
    ffd4:	f47f af77 	bne.w	fec6 <xQueuePeek+0x92>
				{
					portYIELD_WITHIN_API();
    ffd8:	f64e 5304 	movw	r3, #60676	; 0xed04
    ffdc:	f2ce 0300 	movt	r3, #57344	; 0xe000
    ffe0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    ffe4:	601a      	str	r2, [r3, #0]
    ffe6:	f3bf 8f4f 	dsb	sy
    ffea:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    ffee:	e76d      	b.n	fecc <xQueuePeek+0x98>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    fff0:	6a78      	ldr	r0, [r7, #36]	; 0x24
    fff2:	f000 fa69 	bl	104c8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    fff6:	f001 fa71 	bl	114dc <xTaskResumeAll>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    fffa:	e767      	b.n	fecc <xQueuePeek+0x98>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    fffc:	6a78      	ldr	r0, [r7, #36]	; 0x24
    fffe:	f000 fa63 	bl	104c8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
   10002:	f001 fa6b 	bl	114dc <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   10006:	6a78      	ldr	r0, [r7, #36]	; 0x24
   10008:	f000 fab4 	bl	10574 <prvIsQueueEmpty>
   1000c:	4603      	mov	r3, r0
   1000e:	2b00      	cmp	r3, #0
   10010:	f43f af5b 	beq.w	feca <xQueuePeek+0x96>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
   10014:	f04f 0300 	mov.w	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
   10018:	4618      	mov	r0, r3
   1001a:	f107 0738 	add.w	r7, r7, #56	; 0x38
   1001e:	46bd      	mov	sp, r7
   10020:	bd80      	pop	{r7, pc}
   10022:	bf00      	nop

00010024 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
   10024:	b580      	push	{r7, lr}
   10026:	b08e      	sub	sp, #56	; 0x38
   10028:	af00      	add	r7, sp, #0
   1002a:	60f8      	str	r0, [r7, #12]
   1002c:	60b9      	str	r1, [r7, #8]
   1002e:	607a      	str	r2, [r7, #4]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
   10030:	68fb      	ldr	r3, [r7, #12]
   10032:	61bb      	str	r3, [r7, #24]

	configASSERT( pxQueue );
   10034:	69bb      	ldr	r3, [r7, #24]
   10036:	2b00      	cmp	r3, #0
   10038:	d109      	bne.n	1004e <xQueueReceiveFromISR+0x2a>
   1003a:	f04f 0328 	mov.w	r3, #40	; 0x28
   1003e:	f383 8811 	msr	BASEPRI, r3
   10042:	f3bf 8f6f 	isb	sy
   10046:	f3bf 8f4f 	dsb	sy
   1004a:	627b      	str	r3, [r7, #36]	; 0x24
   1004c:	e7fe      	b.n	1004c <xQueueReceiveFromISR+0x28>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   1004e:	68bb      	ldr	r3, [r7, #8]
   10050:	2b00      	cmp	r3, #0
   10052:	d103      	bne.n	1005c <xQueueReceiveFromISR+0x38>
   10054:	69bb      	ldr	r3, [r7, #24]
   10056:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   10058:	2b00      	cmp	r3, #0
   1005a:	d102      	bne.n	10062 <xQueueReceiveFromISR+0x3e>
   1005c:	f04f 0301 	mov.w	r3, #1
   10060:	e001      	b.n	10066 <xQueueReceiveFromISR+0x42>
   10062:	f04f 0300 	mov.w	r3, #0
   10066:	2b00      	cmp	r3, #0
   10068:	d109      	bne.n	1007e <xQueueReceiveFromISR+0x5a>
   1006a:	f04f 0328 	mov.w	r3, #40	; 0x28
   1006e:	f383 8811 	msr	BASEPRI, r3
   10072:	f3bf 8f6f 	isb	sy
   10076:	f3bf 8f4f 	dsb	sy
   1007a:	62bb      	str	r3, [r7, #40]	; 0x28
   1007c:	e7fe      	b.n	1007c <xQueueReceiveFromISR+0x58>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1007e:	f004 f9df 	bl	14440 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
   10082:	f3ef 8211 	mrs	r2, BASEPRI
   10086:	f04f 0328 	mov.w	r3, #40	; 0x28
   1008a:	f383 8811 	msr	BASEPRI, r3
   1008e:	f3bf 8f6f 	isb	sy
   10092:	f3bf 8f4f 	dsb	sy
   10096:	633a      	str	r2, [r7, #48]	; 0x30
   10098:	62fb      	str	r3, [r7, #44]	; 0x2c
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
   1009a:	6b3b      	ldr	r3, [r7, #48]	; 0x30

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   1009c:	617b      	str	r3, [r7, #20]
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   1009e:	69bb      	ldr	r3, [r7, #24]
   100a0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   100a2:	61fb      	str	r3, [r7, #28]

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   100a4:	69fb      	ldr	r3, [r7, #28]
   100a6:	2b00      	cmp	r3, #0
   100a8:	d03a      	beq.n	10120 <xQueueReceiveFromISR+0xfc>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
   100aa:	69bb      	ldr	r3, [r7, #24]
   100ac:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
   100b0:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
   100b4:	69b8      	ldr	r0, [r7, #24]
   100b6:	68b9      	ldr	r1, [r7, #8]
   100b8:	f000 f9de 	bl	10478 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
   100bc:	69fb      	ldr	r3, [r7, #28]
   100be:	f103 32ff 	add.w	r2, r3, #4294967295
   100c2:	69bb      	ldr	r3, [r7, #24]
   100c4:	639a      	str	r2, [r3, #56]	; 0x38

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
   100c6:	f997 3023 	ldrsb.w	r3, [r7, #35]	; 0x23
   100ca:	f1b3 3fff 	cmp.w	r3, #4294967295
   100ce:	d114      	bne.n	100fa <xQueueReceiveFromISR+0xd6>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   100d0:	69bb      	ldr	r3, [r7, #24]
   100d2:	691b      	ldr	r3, [r3, #16]
   100d4:	2b00      	cmp	r3, #0
   100d6:	d01a      	beq.n	1010e <xQueueReceiveFromISR+0xea>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   100d8:	69bb      	ldr	r3, [r7, #24]
   100da:	f103 0310 	add.w	r3, r3, #16
   100de:	4618      	mov	r0, r3
   100e0:	f001 fe3c 	bl	11d5c <xTaskRemoveFromEventList>
   100e4:	4603      	mov	r3, r0
   100e6:	2b00      	cmp	r3, #0
   100e8:	d013      	beq.n	10112 <xQueueReceiveFromISR+0xee>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
   100ea:	687b      	ldr	r3, [r7, #4]
   100ec:	2b00      	cmp	r3, #0
   100ee:	d012      	beq.n	10116 <xQueueReceiveFromISR+0xf2>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
   100f0:	687b      	ldr	r3, [r7, #4]
   100f2:	f04f 0201 	mov.w	r2, #1
   100f6:	601a      	str	r2, [r3, #0]
   100f8:	e00e      	b.n	10118 <xQueueReceiveFromISR+0xf4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
   100fa:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   100fe:	f103 0301 	add.w	r3, r3, #1
   10102:	b2db      	uxtb	r3, r3
   10104:	461a      	mov	r2, r3
   10106:	69bb      	ldr	r3, [r7, #24]
   10108:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
   1010c:	e004      	b.n	10118 <xQueueReceiveFromISR+0xf4>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
   1010e:	bf00      	nop
   10110:	e002      	b.n	10118 <xQueueReceiveFromISR+0xf4>
   10112:	bf00      	nop
   10114:	e000      	b.n	10118 <xQueueReceiveFromISR+0xf4>
   10116:	bf00      	nop
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
			}

			xReturn = pdPASS;
   10118:	f04f 0301 	mov.w	r3, #1
   1011c:	613b      	str	r3, [r7, #16]
   1011e:	e002      	b.n	10126 <xQueueReceiveFromISR+0x102>
		}
		else
		{
			xReturn = pdFAIL;
   10120:	f04f 0300 	mov.w	r3, #0
   10124:	613b      	str	r3, [r7, #16]
   10126:	697b      	ldr	r3, [r7, #20]
   10128:	637b      	str	r3, [r7, #52]	; 0x34
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   1012a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1012c:	f383 8811 	msr	BASEPRI, r3
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
   10130:	693b      	ldr	r3, [r7, #16]
}
   10132:	4618      	mov	r0, r3
   10134:	f107 0738 	add.w	r7, r7, #56	; 0x38
   10138:	46bd      	mov	sp, r7
   1013a:	bd80      	pop	{r7, pc}

0001013c <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
   1013c:	b580      	push	{r7, lr}
   1013e:	b08c      	sub	sp, #48	; 0x30
   10140:	af00      	add	r7, sp, #0
   10142:	6078      	str	r0, [r7, #4]
   10144:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
   10146:	687b      	ldr	r3, [r7, #4]
   10148:	617b      	str	r3, [r7, #20]

	configASSERT( pxQueue );
   1014a:	697b      	ldr	r3, [r7, #20]
   1014c:	2b00      	cmp	r3, #0
   1014e:	d109      	bne.n	10164 <xQueuePeekFromISR+0x28>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   10150:	f04f 0328 	mov.w	r3, #40	; 0x28
   10154:	f383 8811 	msr	BASEPRI, r3
   10158:	f3bf 8f6f 	isb	sy
   1015c:	f3bf 8f4f 	dsb	sy
   10160:	61bb      	str	r3, [r7, #24]
   10162:	e7fe      	b.n	10162 <xQueuePeekFromISR+0x26>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   10164:	683b      	ldr	r3, [r7, #0]
   10166:	2b00      	cmp	r3, #0
   10168:	d103      	bne.n	10172 <xQueuePeekFromISR+0x36>
   1016a:	697b      	ldr	r3, [r7, #20]
   1016c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   1016e:	2b00      	cmp	r3, #0
   10170:	d102      	bne.n	10178 <xQueuePeekFromISR+0x3c>
   10172:	f04f 0301 	mov.w	r3, #1
   10176:	e001      	b.n	1017c <xQueuePeekFromISR+0x40>
   10178:	f04f 0300 	mov.w	r3, #0
   1017c:	2b00      	cmp	r3, #0
   1017e:	d109      	bne.n	10194 <xQueuePeekFromISR+0x58>
   10180:	f04f 0328 	mov.w	r3, #40	; 0x28
   10184:	f383 8811 	msr	BASEPRI, r3
   10188:	f3bf 8f6f 	isb	sy
   1018c:	f3bf 8f4f 	dsb	sy
   10190:	61fb      	str	r3, [r7, #28]
   10192:	e7fe      	b.n	10192 <xQueuePeekFromISR+0x56>
	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
   10194:	697b      	ldr	r3, [r7, #20]
   10196:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   10198:	2b00      	cmp	r3, #0
   1019a:	d109      	bne.n	101b0 <xQueuePeekFromISR+0x74>
   1019c:	f04f 0328 	mov.w	r3, #40	; 0x28
   101a0:	f383 8811 	msr	BASEPRI, r3
   101a4:	f3bf 8f6f 	isb	sy
   101a8:	f3bf 8f4f 	dsb	sy
   101ac:	623b      	str	r3, [r7, #32]
   101ae:	e7fe      	b.n	101ae <xQueuePeekFromISR+0x72>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   101b0:	f004 f946 	bl	14440 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
   101b4:	f3ef 8211 	mrs	r2, BASEPRI
   101b8:	f04f 0328 	mov.w	r3, #40	; 0x28
   101bc:	f383 8811 	msr	BASEPRI, r3
   101c0:	f3bf 8f6f 	isb	sy
   101c4:	f3bf 8f4f 	dsb	sy
   101c8:	62ba      	str	r2, [r7, #40]	; 0x28
   101ca:	627b      	str	r3, [r7, #36]	; 0x24
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
   101cc:	6abb      	ldr	r3, [r7, #40]	; 0x28

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   101ce:	60fb      	str	r3, [r7, #12]
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
   101d0:	697b      	ldr	r3, [r7, #20]
   101d2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   101d4:	2b00      	cmp	r3, #0
   101d6:	d00d      	beq.n	101f4 <xQueuePeekFromISR+0xb8>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
   101d8:	697b      	ldr	r3, [r7, #20]
   101da:	68db      	ldr	r3, [r3, #12]
   101dc:	613b      	str	r3, [r7, #16]
			prvCopyDataFromQueue( pxQueue, pvBuffer );
   101de:	6978      	ldr	r0, [r7, #20]
   101e0:	6839      	ldr	r1, [r7, #0]
   101e2:	f000 f949 	bl	10478 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
   101e6:	697b      	ldr	r3, [r7, #20]
   101e8:	693a      	ldr	r2, [r7, #16]
   101ea:	60da      	str	r2, [r3, #12]

			xReturn = pdPASS;
   101ec:	f04f 0301 	mov.w	r3, #1
   101f0:	60bb      	str	r3, [r7, #8]
   101f2:	e002      	b.n	101fa <xQueuePeekFromISR+0xbe>
		}
		else
		{
			xReturn = pdFAIL;
   101f4:	f04f 0300 	mov.w	r3, #0
   101f8:	60bb      	str	r3, [r7, #8]
   101fa:	68fb      	ldr	r3, [r7, #12]
   101fc:	62fb      	str	r3, [r7, #44]	; 0x2c
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   101fe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   10200:	f383 8811 	msr	BASEPRI, r3
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
   10204:	68bb      	ldr	r3, [r7, #8]
}
   10206:	4618      	mov	r0, r3
   10208:	f107 0730 	add.w	r7, r7, #48	; 0x30
   1020c:	46bd      	mov	sp, r7
   1020e:	bd80      	pop	{r7, pc}

00010210 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
   10210:	b580      	push	{r7, lr}
   10212:	b084      	sub	sp, #16
   10214:	af00      	add	r7, sp, #0
   10216:	6078      	str	r0, [r7, #4]
UBaseType_t uxReturn;

	configASSERT( xQueue );
   10218:	687b      	ldr	r3, [r7, #4]
   1021a:	2b00      	cmp	r3, #0
   1021c:	d109      	bne.n	10232 <uxQueueMessagesWaiting+0x22>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   1021e:	f04f 0328 	mov.w	r3, #40	; 0x28
   10222:	f383 8811 	msr	BASEPRI, r3
   10226:	f3bf 8f6f 	isb	sy
   1022a:	f3bf 8f4f 	dsb	sy
   1022e:	60fb      	str	r3, [r7, #12]
   10230:	e7fe      	b.n	10230 <uxQueueMessagesWaiting+0x20>

	taskENTER_CRITICAL();
   10232:	f004 f821 	bl	14278 <vPortEnterCritical>
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
   10236:	687b      	ldr	r3, [r7, #4]
   10238:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   1023a:	60bb      	str	r3, [r7, #8]
	}
	taskEXIT_CRITICAL();
   1023c:	f004 f854 	bl	142e8 <vPortExitCritical>

	return uxReturn;
   10240:	68bb      	ldr	r3, [r7, #8]
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   10242:	4618      	mov	r0, r3
   10244:	f107 0710 	add.w	r7, r7, #16
   10248:	46bd      	mov	sp, r7
   1024a:	bd80      	pop	{r7, pc}

0001024c <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
   1024c:	b580      	push	{r7, lr}
   1024e:	b086      	sub	sp, #24
   10250:	af00      	add	r7, sp, #0
   10252:	6078      	str	r0, [r7, #4]
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
   10254:	687b      	ldr	r3, [r7, #4]
   10256:	613b      	str	r3, [r7, #16]

	configASSERT( pxQueue );
   10258:	693b      	ldr	r3, [r7, #16]
   1025a:	2b00      	cmp	r3, #0
   1025c:	d109      	bne.n	10272 <uxQueueSpacesAvailable+0x26>
   1025e:	f04f 0328 	mov.w	r3, #40	; 0x28
   10262:	f383 8811 	msr	BASEPRI, r3
   10266:	f3bf 8f6f 	isb	sy
   1026a:	f3bf 8f4f 	dsb	sy
   1026e:	617b      	str	r3, [r7, #20]
   10270:	e7fe      	b.n	10270 <uxQueueSpacesAvailable+0x24>

	taskENTER_CRITICAL();
   10272:	f004 f801 	bl	14278 <vPortEnterCritical>
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
   10276:	693b      	ldr	r3, [r7, #16]
   10278:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   1027a:	693b      	ldr	r3, [r7, #16]
   1027c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   1027e:	ebc3 0302 	rsb	r3, r3, r2
   10282:	60fb      	str	r3, [r7, #12]
	}
	taskEXIT_CRITICAL();
   10284:	f004 f830 	bl	142e8 <vPortExitCritical>

	return uxReturn;
   10288:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   1028a:	4618      	mov	r0, r3
   1028c:	f107 0718 	add.w	r7, r7, #24
   10290:	46bd      	mov	sp, r7
   10292:	bd80      	pop	{r7, pc}

00010294 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
   10294:	b480      	push	{r7}
   10296:	b087      	sub	sp, #28
   10298:	af00      	add	r7, sp, #0
   1029a:	6078      	str	r0, [r7, #4]
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
   1029c:	687b      	ldr	r3, [r7, #4]
   1029e:	613b      	str	r3, [r7, #16]

	configASSERT( pxQueue );
   102a0:	693b      	ldr	r3, [r7, #16]
   102a2:	2b00      	cmp	r3, #0
   102a4:	d109      	bne.n	102ba <uxQueueMessagesWaitingFromISR+0x26>
   102a6:	f04f 0328 	mov.w	r3, #40	; 0x28
   102aa:	f383 8811 	msr	BASEPRI, r3
   102ae:	f3bf 8f6f 	isb	sy
   102b2:	f3bf 8f4f 	dsb	sy
   102b6:	617b      	str	r3, [r7, #20]
   102b8:	e7fe      	b.n	102b8 <uxQueueMessagesWaitingFromISR+0x24>
	uxReturn = pxQueue->uxMessagesWaiting;
   102ba:	693b      	ldr	r3, [r7, #16]
   102bc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   102be:	60fb      	str	r3, [r7, #12]

	return uxReturn;
   102c0:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   102c2:	4618      	mov	r0, r3
   102c4:	f107 071c 	add.w	r7, r7, #28
   102c8:	46bd      	mov	sp, r7
   102ca:	bc80      	pop	{r7}
   102cc:	4770      	bx	lr
   102ce:	bf00      	nop

000102d0 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
   102d0:	b580      	push	{r7, lr}
   102d2:	b084      	sub	sp, #16
   102d4:	af00      	add	r7, sp, #0
   102d6:	6078      	str	r0, [r7, #4]
Queue_t * const pxQueue = xQueue;
   102d8:	687b      	ldr	r3, [r7, #4]
   102da:	60bb      	str	r3, [r7, #8]

	configASSERT( pxQueue );
   102dc:	68bb      	ldr	r3, [r7, #8]
   102de:	2b00      	cmp	r3, #0
   102e0:	d109      	bne.n	102f6 <vQueueDelete+0x26>
   102e2:	f04f 0328 	mov.w	r3, #40	; 0x28
   102e6:	f383 8811 	msr	BASEPRI, r3
   102ea:	f3bf 8f6f 	isb	sy
   102ee:	f3bf 8f4f 	dsb	sy
   102f2:	60fb      	str	r3, [r7, #12]
   102f4:	e7fe      	b.n	102f4 <vQueueDelete+0x24>

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
   102f6:	68b8      	ldr	r0, [r7, #8]
   102f8:	f003 fdf8 	bl	13eec <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
   102fc:	f107 0710 	add.w	r7, r7, #16
   10300:	46bd      	mov	sp, r7
   10302:	bd80      	pop	{r7, pc}

00010304 <uxQueueGetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
	{
   10304:	b480      	push	{r7}
   10306:	b083      	sub	sp, #12
   10308:	af00      	add	r7, sp, #0
   1030a:	6078      	str	r0, [r7, #4]
		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
   1030c:	687b      	ldr	r3, [r7, #4]
   1030e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
	}
   10310:	4618      	mov	r0, r3
   10312:	f107 070c 	add.w	r7, r7, #12
   10316:	46bd      	mov	sp, r7
   10318:	bc80      	pop	{r7}
   1031a:	4770      	bx	lr

0001031c <vQueueSetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
	{
   1031c:	b480      	push	{r7}
   1031e:	b083      	sub	sp, #12
   10320:	af00      	add	r7, sp, #0
   10322:	6078      	str	r0, [r7, #4]
   10324:	6039      	str	r1, [r7, #0]
		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
   10326:	687b      	ldr	r3, [r7, #4]
   10328:	683a      	ldr	r2, [r7, #0]
   1032a:	649a      	str	r2, [r3, #72]	; 0x48
	}
   1032c:	f107 070c 	add.w	r7, r7, #12
   10330:	46bd      	mov	sp, r7
   10332:	bc80      	pop	{r7}
   10334:	4770      	bx	lr
   10336:	bf00      	nop

00010338 <ucQueueGetQueueType>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
	{
   10338:	b480      	push	{r7}
   1033a:	b083      	sub	sp, #12
   1033c:	af00      	add	r7, sp, #0
   1033e:	6078      	str	r0, [r7, #4]
		return ( ( Queue_t * ) xQueue )->ucQueueType;
   10340:	687b      	ldr	r3, [r7, #4]
   10342:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
	}
   10346:	4618      	mov	r0, r3
   10348:	f107 070c 	add.w	r7, r7, #12
   1034c:	46bd      	mov	sp, r7
   1034e:	bc80      	pop	{r7}
   10350:	4770      	bx	lr
   10352:	bf00      	nop

00010354 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
   10354:	b480      	push	{r7}
   10356:	b085      	sub	sp, #20
   10358:	af00      	add	r7, sp, #0
   1035a:	6078      	str	r0, [r7, #4]
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
   1035c:	687b      	ldr	r3, [r7, #4]
   1035e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   10360:	2b00      	cmp	r3, #0
   10362:	d006      	beq.n	10372 <prvGetDisinheritPriorityAfterTimeout+0x1e>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
   10364:	687b      	ldr	r3, [r7, #4]
   10366:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   10368:	681b      	ldr	r3, [r3, #0]
   1036a:	f1c3 0305 	rsb	r3, r3, #5
   1036e:	60fb      	str	r3, [r7, #12]
   10370:	e002      	b.n	10378 <prvGetDisinheritPriorityAfterTimeout+0x24>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
   10372:	f04f 0300 	mov.w	r3, #0
   10376:	60fb      	str	r3, [r7, #12]
		}

		return uxHighestPriorityOfWaitingTasks;
   10378:	68fb      	ldr	r3, [r7, #12]
	}
   1037a:	4618      	mov	r0, r3
   1037c:	f107 0714 	add.w	r7, r7, #20
   10380:	46bd      	mov	sp, r7
   10382:	bc80      	pop	{r7}
   10384:	4770      	bx	lr
   10386:	bf00      	nop

00010388 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
   10388:	b580      	push	{r7, lr}
   1038a:	b086      	sub	sp, #24
   1038c:	af00      	add	r7, sp, #0
   1038e:	60f8      	str	r0, [r7, #12]
   10390:	60b9      	str	r1, [r7, #8]
   10392:	607a      	str	r2, [r7, #4]
BaseType_t xReturn = pdFALSE;
   10394:	f04f 0300 	mov.w	r3, #0
   10398:	613b      	str	r3, [r7, #16]
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   1039a:	68fb      	ldr	r3, [r7, #12]
   1039c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   1039e:	617b      	str	r3, [r7, #20]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
   103a0:	68fb      	ldr	r3, [r7, #12]
   103a2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   103a4:	2b00      	cmp	r3, #0
   103a6:	d10f      	bne.n	103c8 <prvCopyDataToQueue+0x40>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   103a8:	68fb      	ldr	r3, [r7, #12]
   103aa:	681b      	ldr	r3, [r3, #0]
   103ac:	2b00      	cmp	r3, #0
   103ae:	d155      	bne.n	1045c <prvCopyDataToQueue+0xd4>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
   103b0:	68fb      	ldr	r3, [r7, #12]
   103b2:	689b      	ldr	r3, [r3, #8]
   103b4:	4618      	mov	r0, r3
   103b6:	f002 f951 	bl	1265c <xTaskPriorityDisinherit>
   103ba:	4603      	mov	r3, r0
   103bc:	613b      	str	r3, [r7, #16]
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
   103be:	68fb      	ldr	r3, [r7, #12]
   103c0:	f04f 0200 	mov.w	r2, #0
   103c4:	609a      	str	r2, [r3, #8]
   103c6:	e04c      	b.n	10462 <prvCopyDataToQueue+0xda>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
   103c8:	687b      	ldr	r3, [r7, #4]
   103ca:	2b00      	cmp	r3, #0
   103cc:	d11a      	bne.n	10404 <prvCopyDataToQueue+0x7c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
   103ce:	68fb      	ldr	r3, [r7, #12]
   103d0:	685a      	ldr	r2, [r3, #4]
   103d2:	68fb      	ldr	r3, [r7, #12]
   103d4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   103d6:	4610      	mov	r0, r2
   103d8:	68b9      	ldr	r1, [r7, #8]
   103da:	461a      	mov	r2, r3
   103dc:	f004 fce2 	bl	14da4 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
   103e0:	68fb      	ldr	r3, [r7, #12]
   103e2:	685a      	ldr	r2, [r3, #4]
   103e4:	68fb      	ldr	r3, [r7, #12]
   103e6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   103e8:	441a      	add	r2, r3
   103ea:	68fb      	ldr	r3, [r7, #12]
   103ec:	605a      	str	r2, [r3, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   103ee:	68fb      	ldr	r3, [r7, #12]
   103f0:	685a      	ldr	r2, [r3, #4]
   103f2:	68fb      	ldr	r3, [r7, #12]
   103f4:	689b      	ldr	r3, [r3, #8]
   103f6:	429a      	cmp	r2, r3
   103f8:	d332      	bcc.n	10460 <prvCopyDataToQueue+0xd8>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
   103fa:	68fb      	ldr	r3, [r7, #12]
   103fc:	681a      	ldr	r2, [r3, #0]
   103fe:	68fb      	ldr	r3, [r7, #12]
   10400:	605a      	str	r2, [r3, #4]
   10402:	e02e      	b.n	10462 <prvCopyDataToQueue+0xda>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
   10404:	68fb      	ldr	r3, [r7, #12]
   10406:	68da      	ldr	r2, [r3, #12]
   10408:	68fb      	ldr	r3, [r7, #12]
   1040a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   1040c:	4610      	mov	r0, r2
   1040e:	68b9      	ldr	r1, [r7, #8]
   10410:	461a      	mov	r2, r3
   10412:	f004 fcc7 	bl	14da4 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
   10416:	68fb      	ldr	r3, [r7, #12]
   10418:	68da      	ldr	r2, [r3, #12]
   1041a:	68fb      	ldr	r3, [r7, #12]
   1041c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   1041e:	f1c3 0300 	rsb	r3, r3, #0
   10422:	441a      	add	r2, r3
   10424:	68fb      	ldr	r3, [r7, #12]
   10426:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   10428:	68fb      	ldr	r3, [r7, #12]
   1042a:	68da      	ldr	r2, [r3, #12]
   1042c:	68fb      	ldr	r3, [r7, #12]
   1042e:	681b      	ldr	r3, [r3, #0]
   10430:	429a      	cmp	r2, r3
   10432:	d208      	bcs.n	10446 <prvCopyDataToQueue+0xbe>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
   10434:	68fb      	ldr	r3, [r7, #12]
   10436:	689a      	ldr	r2, [r3, #8]
   10438:	68fb      	ldr	r3, [r7, #12]
   1043a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   1043c:	f1c3 0300 	rsb	r3, r3, #0
   10440:	441a      	add	r2, r3
   10442:	68fb      	ldr	r3, [r7, #12]
   10444:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
   10446:	687b      	ldr	r3, [r7, #4]
   10448:	2b02      	cmp	r3, #2
   1044a:	d10a      	bne.n	10462 <prvCopyDataToQueue+0xda>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   1044c:	697b      	ldr	r3, [r7, #20]
   1044e:	2b00      	cmp	r3, #0
   10450:	d007      	beq.n	10462 <prvCopyDataToQueue+0xda>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
   10452:	697b      	ldr	r3, [r7, #20]
   10454:	f103 33ff 	add.w	r3, r3, #4294967295
   10458:	617b      	str	r3, [r7, #20]
   1045a:	e002      	b.n	10462 <prvCopyDataToQueue+0xda>
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
   1045c:	bf00      	nop
   1045e:	e000      	b.n	10462 <prvCopyDataToQueue+0xda>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
   10460:	bf00      	nop
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   10462:	697b      	ldr	r3, [r7, #20]
   10464:	f103 0201 	add.w	r2, r3, #1
   10468:	68fb      	ldr	r3, [r7, #12]
   1046a:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
   1046c:	693b      	ldr	r3, [r7, #16]
}
   1046e:	4618      	mov	r0, r3
   10470:	f107 0718 	add.w	r7, r7, #24
   10474:	46bd      	mov	sp, r7
   10476:	bd80      	pop	{r7, pc}

00010478 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
   10478:	b580      	push	{r7, lr}
   1047a:	b082      	sub	sp, #8
   1047c:	af00      	add	r7, sp, #0
   1047e:	6078      	str	r0, [r7, #4]
   10480:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
   10482:	687b      	ldr	r3, [r7, #4]
   10484:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   10486:	2b00      	cmp	r3, #0
   10488:	d019      	beq.n	104be <prvCopyDataFromQueue+0x46>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
   1048a:	687b      	ldr	r3, [r7, #4]
   1048c:	68da      	ldr	r2, [r3, #12]
   1048e:	687b      	ldr	r3, [r7, #4]
   10490:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   10492:	441a      	add	r2, r3
   10494:	687b      	ldr	r3, [r7, #4]
   10496:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
   10498:	687b      	ldr	r3, [r7, #4]
   1049a:	68da      	ldr	r2, [r3, #12]
   1049c:	687b      	ldr	r3, [r7, #4]
   1049e:	689b      	ldr	r3, [r3, #8]
   104a0:	429a      	cmp	r2, r3
   104a2:	d303      	bcc.n	104ac <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
   104a4:	687b      	ldr	r3, [r7, #4]
   104a6:	681a      	ldr	r2, [r3, #0]
   104a8:	687b      	ldr	r3, [r7, #4]
   104aa:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
   104ac:	687b      	ldr	r3, [r7, #4]
   104ae:	68da      	ldr	r2, [r3, #12]
   104b0:	687b      	ldr	r3, [r7, #4]
   104b2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   104b4:	6838      	ldr	r0, [r7, #0]
   104b6:	4611      	mov	r1, r2
   104b8:	461a      	mov	r2, r3
   104ba:	f004 fc73 	bl	14da4 <memcpy>
	}
}
   104be:	f107 0708 	add.w	r7, r7, #8
   104c2:	46bd      	mov	sp, r7
   104c4:	bd80      	pop	{r7, pc}
   104c6:	bf00      	nop

000104c8 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
   104c8:	b580      	push	{r7, lr}
   104ca:	b084      	sub	sp, #16
   104cc:	af00      	add	r7, sp, #0
   104ce:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
   104d0:	f003 fed2 	bl	14278 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
   104d4:	687b      	ldr	r3, [r7, #4]
   104d6:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   104da:	73bb      	strb	r3, [r7, #14]

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
   104dc:	e012      	b.n	10504 <prvUnlockQueue+0x3c>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   104de:	687b      	ldr	r3, [r7, #4]
   104e0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   104e2:	2b00      	cmp	r3, #0
   104e4:	d013      	beq.n	1050e <prvUnlockQueue+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   104e6:	687b      	ldr	r3, [r7, #4]
   104e8:	f103 0324 	add.w	r3, r3, #36	; 0x24
   104ec:	4618      	mov	r0, r3
   104ee:	f001 fc35 	bl	11d5c <xTaskRemoveFromEventList>
   104f2:	4603      	mov	r3, r0
   104f4:	2b00      	cmp	r3, #0
   104f6:	d001      	beq.n	104fc <prvUnlockQueue+0x34>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
   104f8:	f001 fdc2 	bl	12080 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
   104fc:	7bbb      	ldrb	r3, [r7, #14]
   104fe:	f103 33ff 	add.w	r3, r3, #4294967295
   10502:	73bb      	strb	r3, [r7, #14]
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
   10504:	f997 300e 	ldrsb.w	r3, [r7, #14]
   10508:	2b00      	cmp	r3, #0
   1050a:	dce8      	bgt.n	104de <prvUnlockQueue+0x16>
   1050c:	e000      	b.n	10510 <prvUnlockQueue+0x48>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
   1050e:	bf00      	nop
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
   10510:	687b      	ldr	r3, [r7, #4]
   10512:	f04f 32ff 	mov.w	r2, #4294967295
   10516:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
   1051a:	f003 fee5 	bl	142e8 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
   1051e:	f003 feab 	bl	14278 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
   10522:	687b      	ldr	r3, [r7, #4]
   10524:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
   10528:	73fb      	strb	r3, [r7, #15]

		while( cRxLock > queueLOCKED_UNMODIFIED )
   1052a:	e012      	b.n	10552 <prvUnlockQueue+0x8a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1052c:	687b      	ldr	r3, [r7, #4]
   1052e:	691b      	ldr	r3, [r3, #16]
   10530:	2b00      	cmp	r3, #0
   10532:	d013      	beq.n	1055c <prvUnlockQueue+0x94>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   10534:	687b      	ldr	r3, [r7, #4]
   10536:	f103 0310 	add.w	r3, r3, #16
   1053a:	4618      	mov	r0, r3
   1053c:	f001 fc0e 	bl	11d5c <xTaskRemoveFromEventList>
   10540:	4603      	mov	r3, r0
   10542:	2b00      	cmp	r3, #0
   10544:	d001      	beq.n	1054a <prvUnlockQueue+0x82>
				{
					vTaskMissedYield();
   10546:	f001 fd9b 	bl	12080 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
   1054a:	7bfb      	ldrb	r3, [r7, #15]
   1054c:	f103 33ff 	add.w	r3, r3, #4294967295
   10550:	73fb      	strb	r3, [r7, #15]
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
   10552:	f997 300f 	ldrsb.w	r3, [r7, #15]
   10556:	2b00      	cmp	r3, #0
   10558:	dce8      	bgt.n	1052c <prvUnlockQueue+0x64>
   1055a:	e000      	b.n	1055e <prvUnlockQueue+0x96>

				--cRxLock;
			}
			else
			{
				break;
   1055c:	bf00      	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
   1055e:	687b      	ldr	r3, [r7, #4]
   10560:	f04f 32ff 	mov.w	r2, #4294967295
   10564:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
   10568:	f003 febe 	bl	142e8 <vPortExitCritical>
}
   1056c:	f107 0710 	add.w	r7, r7, #16
   10570:	46bd      	mov	sp, r7
   10572:	bd80      	pop	{r7, pc}

00010574 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
   10574:	b580      	push	{r7, lr}
   10576:	b084      	sub	sp, #16
   10578:	af00      	add	r7, sp, #0
   1057a:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
   1057c:	f003 fe7c 	bl	14278 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
   10580:	687b      	ldr	r3, [r7, #4]
   10582:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   10584:	2b00      	cmp	r3, #0
   10586:	d103      	bne.n	10590 <prvIsQueueEmpty+0x1c>
		{
			xReturn = pdTRUE;
   10588:	f04f 0301 	mov.w	r3, #1
   1058c:	60fb      	str	r3, [r7, #12]
   1058e:	e002      	b.n	10596 <prvIsQueueEmpty+0x22>
		}
		else
		{
			xReturn = pdFALSE;
   10590:	f04f 0300 	mov.w	r3, #0
   10594:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
   10596:	f003 fea7 	bl	142e8 <vPortExitCritical>

	return xReturn;
   1059a:	68fb      	ldr	r3, [r7, #12]
}
   1059c:	4618      	mov	r0, r3
   1059e:	f107 0710 	add.w	r7, r7, #16
   105a2:	46bd      	mov	sp, r7
   105a4:	bd80      	pop	{r7, pc}
   105a6:	bf00      	nop

000105a8 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
   105a8:	b480      	push	{r7}
   105aa:	b087      	sub	sp, #28
   105ac:	af00      	add	r7, sp, #0
   105ae:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
   105b0:	687b      	ldr	r3, [r7, #4]
   105b2:	613b      	str	r3, [r7, #16]

	configASSERT( pxQueue );
   105b4:	693b      	ldr	r3, [r7, #16]
   105b6:	2b00      	cmp	r3, #0
   105b8:	d109      	bne.n	105ce <xQueueIsQueueEmptyFromISR+0x26>
   105ba:	f04f 0328 	mov.w	r3, #40	; 0x28
   105be:	f383 8811 	msr	BASEPRI, r3
   105c2:	f3bf 8f6f 	isb	sy
   105c6:	f3bf 8f4f 	dsb	sy
   105ca:	617b      	str	r3, [r7, #20]
   105cc:	e7fe      	b.n	105cc <xQueueIsQueueEmptyFromISR+0x24>
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
   105ce:	693b      	ldr	r3, [r7, #16]
   105d0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   105d2:	2b00      	cmp	r3, #0
   105d4:	d103      	bne.n	105de <xQueueIsQueueEmptyFromISR+0x36>
	{
		xReturn = pdTRUE;
   105d6:	f04f 0301 	mov.w	r3, #1
   105da:	60fb      	str	r3, [r7, #12]
   105dc:	e002      	b.n	105e4 <xQueueIsQueueEmptyFromISR+0x3c>
	}
	else
	{
		xReturn = pdFALSE;
   105de:	f04f 0300 	mov.w	r3, #0
   105e2:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
   105e4:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
   105e6:	4618      	mov	r0, r3
   105e8:	f107 071c 	add.w	r7, r7, #28
   105ec:	46bd      	mov	sp, r7
   105ee:	bc80      	pop	{r7}
   105f0:	4770      	bx	lr
   105f2:	bf00      	nop

000105f4 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
   105f4:	b580      	push	{r7, lr}
   105f6:	b084      	sub	sp, #16
   105f8:	af00      	add	r7, sp, #0
   105fa:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
   105fc:	f003 fe3c 	bl	14278 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   10600:	687b      	ldr	r3, [r7, #4]
   10602:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   10604:	687b      	ldr	r3, [r7, #4]
   10606:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   10608:	429a      	cmp	r2, r3
   1060a:	d103      	bne.n	10614 <prvIsQueueFull+0x20>
		{
			xReturn = pdTRUE;
   1060c:	f04f 0301 	mov.w	r3, #1
   10610:	60fb      	str	r3, [r7, #12]
   10612:	e002      	b.n	1061a <prvIsQueueFull+0x26>
		}
		else
		{
			xReturn = pdFALSE;
   10614:	f04f 0300 	mov.w	r3, #0
   10618:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
   1061a:	f003 fe65 	bl	142e8 <vPortExitCritical>

	return xReturn;
   1061e:	68fb      	ldr	r3, [r7, #12]
}
   10620:	4618      	mov	r0, r3
   10622:	f107 0710 	add.w	r7, r7, #16
   10626:	46bd      	mov	sp, r7
   10628:	bd80      	pop	{r7, pc}
   1062a:	bf00      	nop

0001062c <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
   1062c:	b480      	push	{r7}
   1062e:	b087      	sub	sp, #28
   10630:	af00      	add	r7, sp, #0
   10632:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
   10634:	687b      	ldr	r3, [r7, #4]
   10636:	613b      	str	r3, [r7, #16]

	configASSERT( pxQueue );
   10638:	693b      	ldr	r3, [r7, #16]
   1063a:	2b00      	cmp	r3, #0
   1063c:	d109      	bne.n	10652 <xQueueIsQueueFullFromISR+0x26>
   1063e:	f04f 0328 	mov.w	r3, #40	; 0x28
   10642:	f383 8811 	msr	BASEPRI, r3
   10646:	f3bf 8f6f 	isb	sy
   1064a:	f3bf 8f4f 	dsb	sy
   1064e:	617b      	str	r3, [r7, #20]
   10650:	e7fe      	b.n	10650 <xQueueIsQueueFullFromISR+0x24>
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   10652:	693b      	ldr	r3, [r7, #16]
   10654:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   10656:	693b      	ldr	r3, [r7, #16]
   10658:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   1065a:	429a      	cmp	r2, r3
   1065c:	d103      	bne.n	10666 <xQueueIsQueueFullFromISR+0x3a>
	{
		xReturn = pdTRUE;
   1065e:	f04f 0301 	mov.w	r3, #1
   10662:	60fb      	str	r3, [r7, #12]
   10664:	e002      	b.n	1066c <xQueueIsQueueFullFromISR+0x40>
	}
	else
	{
		xReturn = pdFALSE;
   10666:	f04f 0300 	mov.w	r3, #0
   1066a:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
   1066c:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
   1066e:	4618      	mov	r0, r3
   10670:	f107 071c 	add.w	r7, r7, #28
   10674:	46bd      	mov	sp, r7
   10676:	bc80      	pop	{r7}
   10678:	4770      	bx	lr
   1067a:	bf00      	nop

0001067c <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
   1067c:	b580      	push	{r7, lr}
   1067e:	b086      	sub	sp, #24
   10680:	af00      	add	r7, sp, #0
   10682:	60f8      	str	r0, [r7, #12]
   10684:	60b9      	str	r1, [r7, #8]
   10686:	607a      	str	r2, [r7, #4]
	Queue_t * const pxQueue = xQueue;
   10688:	68fb      	ldr	r3, [r7, #12]
   1068a:	617b      	str	r3, [r7, #20]
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
   1068c:	f003 fdf4 	bl	14278 <vPortEnterCritical>
   10690:	697b      	ldr	r3, [r7, #20]
   10692:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
   10696:	b2db      	uxtb	r3, r3
   10698:	b25b      	sxtb	r3, r3
   1069a:	f1b3 3fff 	cmp.w	r3, #4294967295
   1069e:	d104      	bne.n	106aa <vQueueWaitForMessageRestricted+0x2e>
   106a0:	697b      	ldr	r3, [r7, #20]
   106a2:	f04f 0200 	mov.w	r2, #0
   106a6:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
   106aa:	697b      	ldr	r3, [r7, #20]
   106ac:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   106b0:	b2db      	uxtb	r3, r3
   106b2:	b25b      	sxtb	r3, r3
   106b4:	f1b3 3fff 	cmp.w	r3, #4294967295
   106b8:	d104      	bne.n	106c4 <vQueueWaitForMessageRestricted+0x48>
   106ba:	697b      	ldr	r3, [r7, #20]
   106bc:	f04f 0200 	mov.w	r2, #0
   106c0:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
   106c4:	f003 fe10 	bl	142e8 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
   106c8:	697b      	ldr	r3, [r7, #20]
   106ca:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   106cc:	2b00      	cmp	r3, #0
   106ce:	d107      	bne.n	106e0 <vQueueWaitForMessageRestricted+0x64>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
   106d0:	697b      	ldr	r3, [r7, #20]
   106d2:	f103 0324 	add.w	r3, r3, #36	; 0x24
   106d6:	4618      	mov	r0, r3
   106d8:	68b9      	ldr	r1, [r7, #8]
   106da:	687a      	ldr	r2, [r7, #4]
   106dc:	f001 fb12 	bl	11d04 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
   106e0:	6978      	ldr	r0, [r7, #20]
   106e2:	f7ff fef1 	bl	104c8 <prvUnlockQueue>
	}
   106e6:	f107 0718 	add.w	r7, r7, #24
   106ea:	46bd      	mov	sp, r7
   106ec:	bd80      	pop	{r7, pc}
   106ee:	bf00      	nop

000106f0 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
   106f0:	b580      	push	{r7, lr}
   106f2:	b08c      	sub	sp, #48	; 0x30
   106f4:	af04      	add	r7, sp, #16
   106f6:	60f8      	str	r0, [r7, #12]
   106f8:	60b9      	str	r1, [r7, #8]
   106fa:	603b      	str	r3, [r7, #0]
   106fc:	4613      	mov	r3, r2
   106fe:	80fb      	strh	r3, [r7, #6]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
   10700:	88fb      	ldrh	r3, [r7, #6]
   10702:	ea4f 0383 	mov.w	r3, r3, lsl #2
   10706:	4618      	mov	r0, r3
   10708:	f003 fb3a 	bl	13d80 <pvPortMalloc>
   1070c:	4603      	mov	r3, r0
   1070e:	61fb      	str	r3, [r7, #28]

			if( pxStack != NULL )
   10710:	69fb      	ldr	r3, [r7, #28]
   10712:	2b00      	cmp	r3, #0
   10714:	d010      	beq.n	10738 <xTaskCreate+0x48>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
   10716:	f04f 005c 	mov.w	r0, #92	; 0x5c
   1071a:	f003 fb31 	bl	13d80 <pvPortMalloc>
   1071e:	4603      	mov	r3, r0
   10720:	617b      	str	r3, [r7, #20]

				if( pxNewTCB != NULL )
   10722:	697b      	ldr	r3, [r7, #20]
   10724:	2b00      	cmp	r3, #0
   10726:	d003      	beq.n	10730 <xTaskCreate+0x40>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
   10728:	697b      	ldr	r3, [r7, #20]
   1072a:	69fa      	ldr	r2, [r7, #28]
   1072c:	631a      	str	r2, [r3, #48]	; 0x30
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
   1072e:	e006      	b.n	1073e <xTaskCreate+0x4e>
   10730:	69f8      	ldr	r0, [r7, #28]
   10732:	f003 fbdb 	bl	13eec <vPortFree>
   10736:	e002      	b.n	1073e <xTaskCreate+0x4e>
				}
			}
			else
			{
				pxNewTCB = NULL;
   10738:	f04f 0300 	mov.w	r3, #0
   1073c:	617b      	str	r3, [r7, #20]
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
   1073e:	697b      	ldr	r3, [r7, #20]
   10740:	2b00      	cmp	r3, #0
   10742:	d016      	beq.n	10772 <xTaskCreate+0x82>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
   10744:	88fb      	ldrh	r3, [r7, #6]
   10746:	6aba      	ldr	r2, [r7, #40]	; 0x28
   10748:	9200      	str	r2, [sp, #0]
   1074a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   1074c:	9201      	str	r2, [sp, #4]
   1074e:	697a      	ldr	r2, [r7, #20]
   10750:	9202      	str	r2, [sp, #8]
   10752:	f04f 0200 	mov.w	r2, #0
   10756:	9203      	str	r2, [sp, #12]
   10758:	68f8      	ldr	r0, [r7, #12]
   1075a:	68b9      	ldr	r1, [r7, #8]
   1075c:	461a      	mov	r2, r3
   1075e:	683b      	ldr	r3, [r7, #0]
   10760:	f000 f810 	bl	10784 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
   10764:	6978      	ldr	r0, [r7, #20]
   10766:	f000 f8b1 	bl	108cc <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
   1076a:	f04f 0301 	mov.w	r3, #1
   1076e:	61bb      	str	r3, [r7, #24]
   10770:	e002      	b.n	10778 <xTaskCreate+0x88>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   10772:	f04f 33ff 	mov.w	r3, #4294967295
   10776:	61bb      	str	r3, [r7, #24]
		}

		return xReturn;
   10778:	69bb      	ldr	r3, [r7, #24]
	}
   1077a:	4618      	mov	r0, r3
   1077c:	f107 0720 	add.w	r7, r7, #32
   10780:	46bd      	mov	sp, r7
   10782:	bd80      	pop	{r7, pc}

00010784 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
   10784:	b580      	push	{r7, lr}
   10786:	b088      	sub	sp, #32
   10788:	af00      	add	r7, sp, #0
   1078a:	60f8      	str	r0, [r7, #12]
   1078c:	60b9      	str	r1, [r7, #8]
   1078e:	607a      	str	r2, [r7, #4]
   10790:	603b      	str	r3, [r7, #0]
			xRunPrivileged = pdFALSE;
		}
		uxPriority &= ~portPRIVILEGE_BIT;
	#endif /* portUSING_MPU_WRAPPERS == 1 */

	configASSERT( pcName );
   10792:	68bb      	ldr	r3, [r7, #8]
   10794:	2b00      	cmp	r3, #0
   10796:	d109      	bne.n	107ac <prvInitialiseNewTask+0x28>
   10798:	f04f 0328 	mov.w	r3, #40	; 0x28
   1079c:	f383 8811 	msr	BASEPRI, r3
   107a0:	f3bf 8f6f 	isb	sy
   107a4:	f3bf 8f4f 	dsb	sy
   107a8:	61bb      	str	r3, [r7, #24]
   107aa:	e7fe      	b.n	107aa <prvInitialiseNewTask+0x26>

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
   107ac:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   107ae:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   107b0:	687b      	ldr	r3, [r7, #4]
   107b2:	ea4f 0383 	mov.w	r3, r3, lsl #2
   107b6:	4610      	mov	r0, r2
   107b8:	f04f 01a5 	mov.w	r1, #165	; 0xa5
   107bc:	461a      	mov	r2, r3
   107be:	f004 fbb9 	bl	14f34 <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
   107c2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   107c4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   107c6:	687b      	ldr	r3, [r7, #4]
   107c8:	f103 33ff 	add.w	r3, r3, #4294967295
   107cc:	ea4f 0383 	mov.w	r3, r3, lsl #2
   107d0:	4413      	add	r3, r2
   107d2:	613b      	str	r3, [r7, #16]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
   107d4:	693b      	ldr	r3, [r7, #16]
   107d6:	f023 0307 	bic.w	r3, r3, #7
   107da:	613b      	str	r3, [r7, #16]

		/* Check the alignment of the calculated top of stack is correct. */
		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
   107dc:	693b      	ldr	r3, [r7, #16]
   107de:	f003 0307 	and.w	r3, r3, #7
   107e2:	2b00      	cmp	r3, #0
   107e4:	d009      	beq.n	107fa <prvInitialiseNewTask+0x76>
   107e6:	f04f 0328 	mov.w	r3, #40	; 0x28
   107ea:	f383 8811 	msr	BASEPRI, r3
   107ee:	f3bf 8f6f 	isb	sy
   107f2:	f3bf 8f4f 	dsb	sy
   107f6:	61fb      	str	r3, [r7, #28]
   107f8:	e7fe      	b.n	107f8 <prvInitialiseNewTask+0x74>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   107fa:	f04f 0300 	mov.w	r3, #0
   107fe:	617b      	str	r3, [r7, #20]
   10800:	e012      	b.n	10828 <prvInitialiseNewTask+0xa4>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
   10802:	6979      	ldr	r1, [r7, #20]
   10804:	68ba      	ldr	r2, [r7, #8]
   10806:	697b      	ldr	r3, [r7, #20]
   10808:	4413      	add	r3, r2
   1080a:	781a      	ldrb	r2, [r3, #0]
   1080c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1080e:	440b      	add	r3, r1
   10810:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == ( char ) 0x00 )
   10814:	68ba      	ldr	r2, [r7, #8]
   10816:	697b      	ldr	r3, [r7, #20]
   10818:	4413      	add	r3, r2
   1081a:	781b      	ldrb	r3, [r3, #0]
   1081c:	2b00      	cmp	r3, #0
   1081e:	d007      	beq.n	10830 <prvInitialiseNewTask+0xac>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   10820:	697b      	ldr	r3, [r7, #20]
   10822:	f103 0301 	add.w	r3, r3, #1
   10826:	617b      	str	r3, [r7, #20]
   10828:	697b      	ldr	r3, [r7, #20]
   1082a:	2b09      	cmp	r3, #9
   1082c:	d9e9      	bls.n	10802 <prvInitialiseNewTask+0x7e>
   1082e:	e000      	b.n	10832 <prvInitialiseNewTask+0xae>
		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == ( char ) 0x00 )
		{
			break;
   10830:	bf00      	nop
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
   10832:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   10834:	f04f 0200 	mov.w	r2, #0
   10838:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   1083c:	6abb      	ldr	r3, [r7, #40]	; 0x28
   1083e:	2b04      	cmp	r3, #4
   10840:	d902      	bls.n	10848 <prvInitialiseNewTask+0xc4>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   10842:	f04f 0304 	mov.w	r3, #4
   10846:	62bb      	str	r3, [r7, #40]	; 0x28
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
   10848:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1084a:	6aba      	ldr	r2, [r7, #40]	; 0x28
   1084c:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
   1084e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   10850:	6aba      	ldr	r2, [r7, #40]	; 0x28
   10852:	649a      	str	r2, [r3, #72]	; 0x48
		pxNewTCB->uxMutexesHeld = 0;
   10854:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   10856:	f04f 0200 	mov.w	r2, #0
   1085a:	64da      	str	r2, [r3, #76]	; 0x4c
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
   1085c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1085e:	f103 0304 	add.w	r3, r3, #4
   10862:	4618      	mov	r0, r3
   10864:	f7fe fc5e 	bl	f124 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
   10868:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1086a:	f103 0318 	add.w	r3, r3, #24
   1086e:	4618      	mov	r0, r3
   10870:	f7fe fc58 	bl	f124 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
   10874:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   10876:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   10878:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1087a:	6abb      	ldr	r3, [r7, #40]	; 0x28
   1087c:	f1c3 0205 	rsb	r2, r3, #5
   10880:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   10882:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
   10884:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   10886:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   10888:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif /* configUSE_APPLICATION_TASK_TAG */

	#if ( configGENERATE_RUN_TIME_STATS == 1 )
	{
		pxNewTCB->ulRunTimeCounter = 0UL;
   1088a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1088c:	f04f 0200 	mov.w	r2, #0
   10890:	651a      	str	r2, [r3, #80]	; 0x50
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
   10892:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   10894:	f04f 0200 	mov.w	r2, #0
   10898:	655a      	str	r2, [r3, #84]	; 0x54
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   1089a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1089c:	f04f 0200 	mov.w	r2, #0
   108a0:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   108a4:	6938      	ldr	r0, [r7, #16]
   108a6:	68f9      	ldr	r1, [r7, #12]
   108a8:	683a      	ldr	r2, [r7, #0]
   108aa:	f003 fbab 	bl	14004 <pxPortInitialiseStack>
   108ae:	4603      	mov	r3, r0
   108b0:	461a      	mov	r2, r3
   108b2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   108b4:	601a      	str	r2, [r3, #0]
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
   108b6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   108b8:	2b00      	cmp	r3, #0
   108ba:	d002      	beq.n	108c2 <prvInitialiseNewTask+0x13e>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
   108bc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   108be:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   108c0:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   108c2:	f107 0720 	add.w	r7, r7, #32
   108c6:	46bd      	mov	sp, r7
   108c8:	bd80      	pop	{r7, pc}
   108ca:	bf00      	nop

000108cc <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
   108cc:	b580      	push	{r7, lr}
   108ce:	b082      	sub	sp, #8
   108d0:	af00      	add	r7, sp, #0
   108d2:	6078      	str	r0, [r7, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
   108d4:	f003 fcd0 	bl	14278 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
   108d8:	f243 03e4 	movw	r3, #12516	; 0x30e4
   108dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   108e0:	681b      	ldr	r3, [r3, #0]
   108e2:	f103 0201 	add.w	r2, r3, #1
   108e6:	f243 03e4 	movw	r3, #12516	; 0x30e4
   108ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
   108ee:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
   108f0:	f243 030c 	movw	r3, #12300	; 0x300c
   108f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   108f8:	681b      	ldr	r3, [r3, #0]
   108fa:	2b00      	cmp	r3, #0
   108fc:	d10f      	bne.n	1091e <prvAddNewTaskToReadyList+0x52>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
   108fe:	f243 030c 	movw	r3, #12300	; 0x300c
   10902:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10906:	687a      	ldr	r2, [r7, #4]
   10908:	601a      	str	r2, [r3, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
   1090a:	f243 03e4 	movw	r3, #12516	; 0x30e4
   1090e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10912:	681b      	ldr	r3, [r3, #0]
   10914:	2b01      	cmp	r3, #1
   10916:	d11a      	bne.n	1094e <prvAddNewTaskToReadyList+0x82>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
   10918:	f001 fc04 	bl	12124 <prvInitialiseTaskLists>
   1091c:	e018      	b.n	10950 <prvAddNewTaskToReadyList+0x84>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
   1091e:	f243 03f0 	movw	r3, #12528	; 0x30f0
   10922:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10926:	681b      	ldr	r3, [r3, #0]
   10928:	2b00      	cmp	r3, #0
   1092a:	d111      	bne.n	10950 <prvAddNewTaskToReadyList+0x84>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
   1092c:	f243 030c 	movw	r3, #12300	; 0x300c
   10930:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10934:	681b      	ldr	r3, [r3, #0]
   10936:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10938:	687b      	ldr	r3, [r7, #4]
   1093a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1093c:	429a      	cmp	r2, r3
   1093e:	d807      	bhi.n	10950 <prvAddNewTaskToReadyList+0x84>
				{
					pxCurrentTCB = pxNewTCB;
   10940:	f243 030c 	movw	r3, #12300	; 0x300c
   10944:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10948:	687a      	ldr	r2, [r7, #4]
   1094a:	601a      	str	r2, [r3, #0]
   1094c:	e000      	b.n	10950 <prvAddNewTaskToReadyList+0x84>
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
   1094e:	bf00      	nop
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
   10950:	f243 1300 	movw	r3, #12544	; 0x3100
   10954:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10958:	681b      	ldr	r3, [r3, #0]
   1095a:	f103 0201 	add.w	r2, r3, #1
   1095e:	f243 1300 	movw	r3, #12544	; 0x3100
   10962:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10966:	601a      	str	r2, [r3, #0]

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			/* Add a counter into the TCB for tracing only. */
			pxNewTCB->uxTCBNumber = uxTaskNumber;
   10968:	f243 1300 	movw	r3, #12544	; 0x3100
   1096c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10970:	681a      	ldr	r2, [r3, #0]
   10972:	687b      	ldr	r3, [r7, #4]
   10974:	641a      	str	r2, [r3, #64]	; 0x40
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
   10976:	687b      	ldr	r3, [r7, #4]
   10978:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1097a:	f04f 0201 	mov.w	r2, #1
   1097e:	fa02 f203 	lsl.w	r2, r2, r3
   10982:	f243 03ec 	movw	r3, #12524	; 0x30ec
   10986:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1098a:	681b      	ldr	r3, [r3, #0]
   1098c:	ea42 0203 	orr.w	r2, r2, r3
   10990:	f243 03ec 	movw	r3, #12524	; 0x30ec
   10994:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10998:	601a      	str	r2, [r3, #0]
   1099a:	687b      	ldr	r3, [r7, #4]
   1099c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1099e:	4613      	mov	r3, r2
   109a0:	ea4f 0383 	mov.w	r3, r3, lsl #2
   109a4:	4413      	add	r3, r2
   109a6:	ea4f 0383 	mov.w	r3, r3, lsl #2
   109aa:	461a      	mov	r2, r3
   109ac:	f243 0310 	movw	r3, #12304	; 0x3010
   109b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   109b4:	441a      	add	r2, r3
   109b6:	687b      	ldr	r3, [r7, #4]
   109b8:	f103 0304 	add.w	r3, r3, #4
   109bc:	4610      	mov	r0, r2
   109be:	4619      	mov	r1, r3
   109c0:	f7fe fbbe 	bl	f140 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
   109c4:	f003 fc90 	bl	142e8 <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
   109c8:	f243 03f0 	movw	r3, #12528	; 0x30f0
   109cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   109d0:	681b      	ldr	r3, [r3, #0]
   109d2:	2b00      	cmp	r3, #0
   109d4:	d014      	beq.n	10a00 <prvAddNewTaskToReadyList+0x134>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
   109d6:	f243 030c 	movw	r3, #12300	; 0x300c
   109da:	f2c2 0300 	movt	r3, #8192	; 0x2000
   109de:	681b      	ldr	r3, [r3, #0]
   109e0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   109e2:	687b      	ldr	r3, [r7, #4]
   109e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   109e6:	429a      	cmp	r2, r3
   109e8:	d20a      	bcs.n	10a00 <prvAddNewTaskToReadyList+0x134>
		{
			taskYIELD_IF_USING_PREEMPTION();
   109ea:	f64e 5304 	movw	r3, #60676	; 0xed04
   109ee:	f2ce 0300 	movt	r3, #57344	; 0xe000
   109f2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   109f6:	601a      	str	r2, [r3, #0]
   109f8:	f3bf 8f4f 	dsb	sy
   109fc:	f3bf 8f6f 	isb	sy
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   10a00:	f107 0708 	add.w	r7, r7, #8
   10a04:	46bd      	mov	sp, r7
   10a06:	bd80      	pop	{r7, pc}

00010a08 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
   10a08:	b580      	push	{r7, lr}
   10a0a:	b084      	sub	sp, #16
   10a0c:	af00      	add	r7, sp, #0
   10a0e:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
   10a10:	f003 fc32 	bl	14278 <vPortEnterCritical>
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
   10a14:	687b      	ldr	r3, [r7, #4]
   10a16:	2b00      	cmp	r3, #0
   10a18:	d105      	bne.n	10a26 <vTaskDelete+0x1e>
   10a1a:	f243 030c 	movw	r3, #12300	; 0x300c
   10a1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10a22:	681b      	ldr	r3, [r3, #0]
   10a24:	e000      	b.n	10a28 <vTaskDelete+0x20>
   10a26:	687b      	ldr	r3, [r7, #4]
   10a28:	60bb      	str	r3, [r7, #8]

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   10a2a:	68bb      	ldr	r3, [r7, #8]
   10a2c:	f103 0304 	add.w	r3, r3, #4
   10a30:	4618      	mov	r0, r3
   10a32:	f7fe fbe3 	bl	f1fc <uxListRemove>
   10a36:	4603      	mov	r3, r0
   10a38:	2b00      	cmp	r3, #0
   10a3a:	d124      	bne.n	10a86 <vTaskDelete+0x7e>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   10a3c:	68bb      	ldr	r3, [r7, #8]
   10a3e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10a40:	4613      	mov	r3, r2
   10a42:	ea4f 0383 	mov.w	r3, r3, lsl #2
   10a46:	4413      	add	r3, r2
   10a48:	ea4f 0383 	mov.w	r3, r3, lsl #2
   10a4c:	461a      	mov	r2, r3
   10a4e:	f243 0310 	movw	r3, #12304	; 0x3010
   10a52:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10a56:	4413      	add	r3, r2
   10a58:	681b      	ldr	r3, [r3, #0]
   10a5a:	2b00      	cmp	r3, #0
   10a5c:	d113      	bne.n	10a86 <vTaskDelete+0x7e>
   10a5e:	68bb      	ldr	r3, [r7, #8]
   10a60:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   10a62:	f04f 0201 	mov.w	r2, #1
   10a66:	fa02 f303 	lsl.w	r3, r2, r3
   10a6a:	ea6f 0203 	mvn.w	r2, r3
   10a6e:	f243 03ec 	movw	r3, #12524	; 0x30ec
   10a72:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10a76:	681b      	ldr	r3, [r3, #0]
   10a78:	ea02 0203 	and.w	r2, r2, r3
   10a7c:	f243 03ec 	movw	r3, #12524	; 0x30ec
   10a80:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10a84:	601a      	str	r2, [r3, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   10a86:	68bb      	ldr	r3, [r7, #8]
   10a88:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   10a8a:	2b00      	cmp	r3, #0
   10a8c:	d005      	beq.n	10a9a <vTaskDelete+0x92>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   10a8e:	68bb      	ldr	r3, [r7, #8]
   10a90:	f103 0318 	add.w	r3, r3, #24
   10a94:	4618      	mov	r0, r3
   10a96:	f7fe fbb1 	bl	f1fc <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
   10a9a:	f243 1300 	movw	r3, #12544	; 0x3100
   10a9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10aa2:	681b      	ldr	r3, [r3, #0]
   10aa4:	f103 0201 	add.w	r2, r3, #1
   10aa8:	f243 1300 	movw	r3, #12544	; 0x3100
   10aac:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10ab0:	601a      	str	r2, [r3, #0]

			if( pxTCB == pxCurrentTCB )
   10ab2:	f243 030c 	movw	r3, #12300	; 0x300c
   10ab6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10aba:	681b      	ldr	r3, [r3, #0]
   10abc:	68ba      	ldr	r2, [r7, #8]
   10abe:	429a      	cmp	r2, r3
   10ac0:	d116      	bne.n	10af0 <vTaskDelete+0xe8>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
   10ac2:	68bb      	ldr	r3, [r7, #8]
   10ac4:	f103 0304 	add.w	r3, r3, #4
   10ac8:	f243 00b8 	movw	r0, #12472	; 0x30b8
   10acc:	f2c2 0000 	movt	r0, #8192	; 0x2000
   10ad0:	4619      	mov	r1, r3
   10ad2:	f7fe fb35 	bl	f140 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
   10ad6:	f243 03cc 	movw	r3, #12492	; 0x30cc
   10ada:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10ade:	681b      	ldr	r3, [r3, #0]
   10ae0:	f103 0201 	add.w	r2, r3, #1
   10ae4:	f243 03cc 	movw	r3, #12492	; 0x30cc
   10ae8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10aec:	601a      	str	r2, [r3, #0]
   10aee:	e010      	b.n	10b12 <vTaskDelete+0x10a>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
   10af0:	f243 03e4 	movw	r3, #12516	; 0x30e4
   10af4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10af8:	681b      	ldr	r3, [r3, #0]
   10afa:	f103 32ff 	add.w	r2, r3, #4294967295
   10afe:	f243 03e4 	movw	r3, #12516	; 0x30e4
   10b02:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10b06:	601a      	str	r2, [r3, #0]
				prvDeleteTCB( pxTCB );
   10b08:	68b8      	ldr	r0, [r7, #8]
   10b0a:	f001 fc85 	bl	12418 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
   10b0e:	f001 fc93 	bl	12438 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
   10b12:	f003 fbe9 	bl	142e8 <vPortExitCritical>

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
   10b16:	f243 03f0 	movw	r3, #12528	; 0x30f0
   10b1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10b1e:	681b      	ldr	r3, [r3, #0]
   10b20:	2b00      	cmp	r3, #0
   10b22:	d023      	beq.n	10b6c <vTaskDelete+0x164>
		{
			if( pxTCB == pxCurrentTCB )
   10b24:	f243 030c 	movw	r3, #12300	; 0x300c
   10b28:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10b2c:	681b      	ldr	r3, [r3, #0]
   10b2e:	68ba      	ldr	r2, [r7, #8]
   10b30:	429a      	cmp	r2, r3
   10b32:	d11b      	bne.n	10b6c <vTaskDelete+0x164>
			{
				configASSERT( uxSchedulerSuspended == 0 );
   10b34:	f243 130c 	movw	r3, #12556	; 0x310c
   10b38:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10b3c:	681b      	ldr	r3, [r3, #0]
   10b3e:	2b00      	cmp	r3, #0
   10b40:	d009      	beq.n	10b56 <vTaskDelete+0x14e>
   10b42:	f04f 0328 	mov.w	r3, #40	; 0x28
   10b46:	f383 8811 	msr	BASEPRI, r3
   10b4a:	f3bf 8f6f 	isb	sy
   10b4e:	f3bf 8f4f 	dsb	sy
   10b52:	60fb      	str	r3, [r7, #12]
   10b54:	e7fe      	b.n	10b54 <vTaskDelete+0x14c>
				portYIELD_WITHIN_API();
   10b56:	f64e 5304 	movw	r3, #60676	; 0xed04
   10b5a:	f2ce 0300 	movt	r3, #57344	; 0xe000
   10b5e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   10b62:	601a      	str	r2, [r3, #0]
   10b64:	f3bf 8f4f 	dsb	sy
   10b68:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
   10b6c:	f107 0710 	add.w	r7, r7, #16
   10b70:	46bd      	mov	sp, r7
   10b72:	bd80      	pop	{r7, pc}

00010b74 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
   10b74:	b580      	push	{r7, lr}
   10b76:	b08a      	sub	sp, #40	; 0x28
   10b78:	af00      	add	r7, sp, #0
   10b7a:	6078      	str	r0, [r7, #4]
   10b7c:	6039      	str	r1, [r7, #0]
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
   10b7e:	f04f 0300 	mov.w	r3, #0
   10b82:	617b      	str	r3, [r7, #20]

		configASSERT( pxPreviousWakeTime );
   10b84:	687b      	ldr	r3, [r7, #4]
   10b86:	2b00      	cmp	r3, #0
   10b88:	d109      	bne.n	10b9e <vTaskDelayUntil+0x2a>
   10b8a:	f04f 0328 	mov.w	r3, #40	; 0x28
   10b8e:	f383 8811 	msr	BASEPRI, r3
   10b92:	f3bf 8f6f 	isb	sy
   10b96:	f3bf 8f4f 	dsb	sy
   10b9a:	61fb      	str	r3, [r7, #28]
   10b9c:	e7fe      	b.n	10b9c <vTaskDelayUntil+0x28>
		configASSERT( ( xTimeIncrement > 0U ) );
   10b9e:	683b      	ldr	r3, [r7, #0]
   10ba0:	2b00      	cmp	r3, #0
   10ba2:	d109      	bne.n	10bb8 <vTaskDelayUntil+0x44>
   10ba4:	f04f 0328 	mov.w	r3, #40	; 0x28
   10ba8:	f383 8811 	msr	BASEPRI, r3
   10bac:	f3bf 8f6f 	isb	sy
   10bb0:	f3bf 8f4f 	dsb	sy
   10bb4:	623b      	str	r3, [r7, #32]
   10bb6:	e7fe      	b.n	10bb6 <vTaskDelayUntil+0x42>
		configASSERT( uxSchedulerSuspended == 0 );
   10bb8:	f243 130c 	movw	r3, #12556	; 0x310c
   10bbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10bc0:	681b      	ldr	r3, [r3, #0]
   10bc2:	2b00      	cmp	r3, #0
   10bc4:	d009      	beq.n	10bda <vTaskDelayUntil+0x66>
   10bc6:	f04f 0328 	mov.w	r3, #40	; 0x28
   10bca:	f383 8811 	msr	BASEPRI, r3
   10bce:	f3bf 8f6f 	isb	sy
   10bd2:	f3bf 8f4f 	dsb	sy
   10bd6:	627b      	str	r3, [r7, #36]	; 0x24
   10bd8:	e7fe      	b.n	10bd8 <vTaskDelayUntil+0x64>

		vTaskSuspendAll();
   10bda:	f000 fc6d 	bl	114b8 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
   10bde:	f243 03e8 	movw	r3, #12520	; 0x30e8
   10be2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10be6:	681b      	ldr	r3, [r3, #0]
   10be8:	61bb      	str	r3, [r7, #24]

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
   10bea:	687b      	ldr	r3, [r7, #4]
   10bec:	681a      	ldr	r2, [r3, #0]
   10bee:	683b      	ldr	r3, [r7, #0]
   10bf0:	4413      	add	r3, r2
   10bf2:	60fb      	str	r3, [r7, #12]

			if( xConstTickCount < *pxPreviousWakeTime )
   10bf4:	687b      	ldr	r3, [r7, #4]
   10bf6:	681a      	ldr	r2, [r3, #0]
   10bf8:	69bb      	ldr	r3, [r7, #24]
   10bfa:	429a      	cmp	r2, r3
   10bfc:	d90c      	bls.n	10c18 <vTaskDelayUntil+0xa4>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
   10bfe:	687b      	ldr	r3, [r7, #4]
   10c00:	681a      	ldr	r2, [r3, #0]
   10c02:	68fb      	ldr	r3, [r7, #12]
   10c04:	429a      	cmp	r2, r3
   10c06:	d914      	bls.n	10c32 <vTaskDelayUntil+0xbe>
   10c08:	68fa      	ldr	r2, [r7, #12]
   10c0a:	69bb      	ldr	r3, [r7, #24]
   10c0c:	429a      	cmp	r2, r3
   10c0e:	d912      	bls.n	10c36 <vTaskDelayUntil+0xc2>
				{
					xShouldDelay = pdTRUE;
   10c10:	f04f 0301 	mov.w	r3, #1
   10c14:	617b      	str	r3, [r7, #20]
   10c16:	e00f      	b.n	10c38 <vTaskDelayUntil+0xc4>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
   10c18:	687b      	ldr	r3, [r7, #4]
   10c1a:	681a      	ldr	r2, [r3, #0]
   10c1c:	68fb      	ldr	r3, [r7, #12]
   10c1e:	429a      	cmp	r2, r3
   10c20:	d803      	bhi.n	10c2a <vTaskDelayUntil+0xb6>
   10c22:	68fa      	ldr	r2, [r7, #12]
   10c24:	69bb      	ldr	r3, [r7, #24]
   10c26:	429a      	cmp	r2, r3
   10c28:	d906      	bls.n	10c38 <vTaskDelayUntil+0xc4>
				{
					xShouldDelay = pdTRUE;
   10c2a:	f04f 0301 	mov.w	r3, #1
   10c2e:	617b      	str	r3, [r7, #20]
   10c30:	e002      	b.n	10c38 <vTaskDelayUntil+0xc4>
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
   10c32:	bf00      	nop
   10c34:	e000      	b.n	10c38 <vTaskDelayUntil+0xc4>
   10c36:	bf00      	nop
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
   10c38:	687b      	ldr	r3, [r7, #4]
   10c3a:	68fa      	ldr	r2, [r7, #12]
   10c3c:	601a      	str	r2, [r3, #0]

			if( xShouldDelay != pdFALSE )
   10c3e:	697b      	ldr	r3, [r7, #20]
   10c40:	2b00      	cmp	r3, #0
   10c42:	d008      	beq.n	10c56 <vTaskDelayUntil+0xe2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
   10c44:	68fa      	ldr	r2, [r7, #12]
   10c46:	69bb      	ldr	r3, [r7, #24]
   10c48:	ebc3 0302 	rsb	r3, r3, r2
   10c4c:	4618      	mov	r0, r3
   10c4e:	f04f 0100 	mov.w	r1, #0
   10c52:	f002 fb7b 	bl	1334c <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
   10c56:	f000 fc41 	bl	114dc <xTaskResumeAll>
   10c5a:	4603      	mov	r3, r0
   10c5c:	613b      	str	r3, [r7, #16]

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
   10c5e:	693b      	ldr	r3, [r7, #16]
   10c60:	2b00      	cmp	r3, #0
   10c62:	d10a      	bne.n	10c7a <vTaskDelayUntil+0x106>
		{
			portYIELD_WITHIN_API();
   10c64:	f64e 5304 	movw	r3, #60676	; 0xed04
   10c68:	f2ce 0300 	movt	r3, #57344	; 0xe000
   10c6c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   10c70:	601a      	str	r2, [r3, #0]
   10c72:	f3bf 8f4f 	dsb	sy
   10c76:	f3bf 8f6f 	isb	sy
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   10c7a:	f107 0728 	add.w	r7, r7, #40	; 0x28
   10c7e:	46bd      	mov	sp, r7
   10c80:	bd80      	pop	{r7, pc}
   10c82:	bf00      	nop

00010c84 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
   10c84:	b580      	push	{r7, lr}
   10c86:	b084      	sub	sp, #16
   10c88:	af00      	add	r7, sp, #0
   10c8a:	6078      	str	r0, [r7, #4]
	BaseType_t xAlreadyYielded = pdFALSE;
   10c8c:	f04f 0300 	mov.w	r3, #0
   10c90:	60bb      	str	r3, [r7, #8]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
   10c92:	687b      	ldr	r3, [r7, #4]
   10c94:	2b00      	cmp	r3, #0
   10c96:	d01b      	beq.n	10cd0 <vTaskDelay+0x4c>
		{
			configASSERT( uxSchedulerSuspended == 0 );
   10c98:	f243 130c 	movw	r3, #12556	; 0x310c
   10c9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10ca0:	681b      	ldr	r3, [r3, #0]
   10ca2:	2b00      	cmp	r3, #0
   10ca4:	d009      	beq.n	10cba <vTaskDelay+0x36>
   10ca6:	f04f 0328 	mov.w	r3, #40	; 0x28
   10caa:	f383 8811 	msr	BASEPRI, r3
   10cae:	f3bf 8f6f 	isb	sy
   10cb2:	f3bf 8f4f 	dsb	sy
   10cb6:	60fb      	str	r3, [r7, #12]
   10cb8:	e7fe      	b.n	10cb8 <vTaskDelay+0x34>
			vTaskSuspendAll();
   10cba:	f000 fbfd 	bl	114b8 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
   10cbe:	6878      	ldr	r0, [r7, #4]
   10cc0:	f04f 0100 	mov.w	r1, #0
   10cc4:	f002 fb42 	bl	1334c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
   10cc8:	f000 fc08 	bl	114dc <xTaskResumeAll>
   10ccc:	4603      	mov	r3, r0
   10cce:	60bb      	str	r3, [r7, #8]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
   10cd0:	68bb      	ldr	r3, [r7, #8]
   10cd2:	2b00      	cmp	r3, #0
   10cd4:	d10a      	bne.n	10cec <vTaskDelay+0x68>
		{
			portYIELD_WITHIN_API();
   10cd6:	f64e 5304 	movw	r3, #60676	; 0xed04
   10cda:	f2ce 0300 	movt	r3, #57344	; 0xe000
   10cde:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   10ce2:	601a      	str	r2, [r3, #0]
   10ce4:	f3bf 8f4f 	dsb	sy
   10ce8:	f3bf 8f6f 	isb	sy
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   10cec:	f107 0710 	add.w	r7, r7, #16
   10cf0:	46bd      	mov	sp, r7
   10cf2:	bd80      	pop	{r7, pc}

00010cf4 <eTaskGetState>:
/*-----------------------------------------------------------*/

#if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )

	eTaskState eTaskGetState( TaskHandle_t xTask )
	{
   10cf4:	b580      	push	{r7, lr}
   10cf6:	b088      	sub	sp, #32
   10cf8:	af00      	add	r7, sp, #0
   10cfa:	6078      	str	r0, [r7, #4]
	eTaskState eReturn;
	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
	const TCB_t * const pxTCB = xTask;
   10cfc:	687b      	ldr	r3, [r7, #4]
   10cfe:	61bb      	str	r3, [r7, #24]

		configASSERT( pxTCB );
   10d00:	69bb      	ldr	r3, [r7, #24]
   10d02:	2b00      	cmp	r3, #0
   10d04:	d109      	bne.n	10d1a <eTaskGetState+0x26>
   10d06:	f04f 0328 	mov.w	r3, #40	; 0x28
   10d0a:	f383 8811 	msr	BASEPRI, r3
   10d0e:	f3bf 8f6f 	isb	sy
   10d12:	f3bf 8f4f 	dsb	sy
   10d16:	61fb      	str	r3, [r7, #28]
   10d18:	e7fe      	b.n	10d18 <eTaskGetState+0x24>

		if( pxTCB == pxCurrentTCB )
   10d1a:	f243 030c 	movw	r3, #12300	; 0x300c
   10d1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10d22:	681b      	ldr	r3, [r3, #0]
   10d24:	69ba      	ldr	r2, [r7, #24]
   10d26:	429a      	cmp	r2, r3
   10d28:	d103      	bne.n	10d32 <eTaskGetState+0x3e>
		{
			/* The task calling this function is querying its own state. */
			eReturn = eRunning;
   10d2a:	f04f 0300 	mov.w	r3, #0
   10d2e:	72fb      	strb	r3, [r7, #11]
   10d30:	e04c      	b.n	10dcc <eTaskGetState+0xd8>
		}
		else
		{
			taskENTER_CRITICAL();
   10d32:	f003 faa1 	bl	14278 <vPortEnterCritical>
			{
				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
   10d36:	69bb      	ldr	r3, [r7, #24]
   10d38:	695b      	ldr	r3, [r3, #20]
   10d3a:	60fb      	str	r3, [r7, #12]
				pxDelayedList = pxDelayedTaskList;
   10d3c:	f243 039c 	movw	r3, #12444	; 0x309c
   10d40:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10d44:	681b      	ldr	r3, [r3, #0]
   10d46:	613b      	str	r3, [r7, #16]
				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
   10d48:	f243 03a0 	movw	r3, #12448	; 0x30a0
   10d4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10d50:	681b      	ldr	r3, [r3, #0]
   10d52:	617b      	str	r3, [r7, #20]
			}
			taskEXIT_CRITICAL();
   10d54:	f003 fac8 	bl	142e8 <vPortExitCritical>

			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
   10d58:	68fa      	ldr	r2, [r7, #12]
   10d5a:	693b      	ldr	r3, [r7, #16]
   10d5c:	429a      	cmp	r2, r3
   10d5e:	d003      	beq.n	10d68 <eTaskGetState+0x74>
   10d60:	68fa      	ldr	r2, [r7, #12]
   10d62:	697b      	ldr	r3, [r7, #20]
   10d64:	429a      	cmp	r2, r3
   10d66:	d103      	bne.n	10d70 <eTaskGetState+0x7c>
			{
				/* The task being queried is referenced from one of the Blocked
				lists. */
				eReturn = eBlocked;
   10d68:	f04f 0302 	mov.w	r3, #2
   10d6c:	72fb      	strb	r3, [r7, #11]
				pxDelayedList = pxDelayedTaskList;
				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
			}
			taskEXIT_CRITICAL();

			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
   10d6e:	e02d      	b.n	10dcc <eTaskGetState+0xd8>
				lists. */
				eReturn = eBlocked;
			}

			#if ( INCLUDE_vTaskSuspend == 1 )
				else if( pxStateList == &xSuspendedTaskList )
   10d70:	68fa      	ldr	r2, [r7, #12]
   10d72:	f243 03d0 	movw	r3, #12496	; 0x30d0
   10d76:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10d7a:	429a      	cmp	r2, r3
   10d7c:	d115      	bne.n	10daa <eTaskGetState+0xb6>
				{
					/* The task being queried is referenced from the suspended
					list.  Is it genuinely suspended or is it blocked
					indefinitely? */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
   10d7e:	69bb      	ldr	r3, [r7, #24]
   10d80:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   10d82:	2b00      	cmp	r3, #0
   10d84:	d10d      	bne.n	10da2 <eTaskGetState+0xae>
						{
							/* The task does not appear on the event list item of
							and of the RTOS objects, but could still be in the
							blocked state if it is waiting on its notification
							rather than waiting on an object. */
							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
   10d86:	69bb      	ldr	r3, [r7, #24]
   10d88:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
   10d8c:	b2db      	uxtb	r3, r3
   10d8e:	2b01      	cmp	r3, #1
   10d90:	d103      	bne.n	10d9a <eTaskGetState+0xa6>
							{
								eReturn = eBlocked;
   10d92:	f04f 0302 	mov.w	r3, #2
   10d96:	72fb      	strb	r3, [r7, #11]
						}
						#endif
					}
					else
					{
						eReturn = eBlocked;
   10d98:	e018      	b.n	10dcc <eTaskGetState+0xd8>
							{
								eReturn = eBlocked;
							}
							else
							{
								eReturn = eSuspended;
   10d9a:	f04f 0303 	mov.w	r3, #3
   10d9e:	72fb      	strb	r3, [r7, #11]
						}
						#endif
					}
					else
					{
						eReturn = eBlocked;
   10da0:	e014      	b.n	10dcc <eTaskGetState+0xd8>
   10da2:	f04f 0302 	mov.w	r3, #2
   10da6:	72fb      	strb	r3, [r7, #11]
   10da8:	e010      	b.n	10dcc <eTaskGetState+0xd8>
					}
				}
			#endif

			#if ( INCLUDE_vTaskDelete == 1 )
				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
   10daa:	68fa      	ldr	r2, [r7, #12]
   10dac:	f243 03b8 	movw	r3, #12472	; 0x30b8
   10db0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10db4:	429a      	cmp	r2, r3
   10db6:	d002      	beq.n	10dbe <eTaskGetState+0xca>
   10db8:	68fb      	ldr	r3, [r7, #12]
   10dba:	2b00      	cmp	r3, #0
   10dbc:	d103      	bne.n	10dc6 <eTaskGetState+0xd2>
				{
					/* The task being queried is referenced from the deleted
					tasks list, or it is not referenced from any lists at
					all. */
					eReturn = eDeleted;
   10dbe:	f04f 0304 	mov.w	r3, #4
   10dc2:	72fb      	strb	r3, [r7, #11]
					}
				}
			#endif

			#if ( INCLUDE_vTaskDelete == 1 )
				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
   10dc4:	e002      	b.n	10dcc <eTaskGetState+0xd8>

			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
			{
				/* If the task is not in any other state, it must be in the
				Ready (including pending ready) state. */
				eReturn = eReady;
   10dc6:	f04f 0301 	mov.w	r3, #1
   10dca:	72fb      	strb	r3, [r7, #11]
			}
		}

		return eReturn;
   10dcc:	7afb      	ldrb	r3, [r7, #11]
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   10dce:	4618      	mov	r0, r3
   10dd0:	f107 0720 	add.w	r7, r7, #32
   10dd4:	46bd      	mov	sp, r7
   10dd6:	bd80      	pop	{r7, pc}

00010dd8 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
	{
   10dd8:	b580      	push	{r7, lr}
   10dda:	b084      	sub	sp, #16
   10ddc:	af00      	add	r7, sp, #0
   10dde:	6078      	str	r0, [r7, #4]
	TCB_t const *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
   10de0:	f003 fa4a 	bl	14278 <vPortEnterCritical>
		{
			/* If null is passed in here then it is the priority of the task
			that called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
   10de4:	687b      	ldr	r3, [r7, #4]
   10de6:	2b00      	cmp	r3, #0
   10de8:	d105      	bne.n	10df6 <uxTaskPriorityGet+0x1e>
   10dea:	f243 030c 	movw	r3, #12300	; 0x300c
   10dee:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10df2:	681b      	ldr	r3, [r3, #0]
   10df4:	e000      	b.n	10df8 <uxTaskPriorityGet+0x20>
   10df6:	687b      	ldr	r3, [r7, #4]
   10df8:	60bb      	str	r3, [r7, #8]
			uxReturn = pxTCB->uxPriority;
   10dfa:	68bb      	ldr	r3, [r7, #8]
   10dfc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   10dfe:	60fb      	str	r3, [r7, #12]
		}
		taskEXIT_CRITICAL();
   10e00:	f003 fa72 	bl	142e8 <vPortExitCritical>

		return uxReturn;
   10e04:	68fb      	ldr	r3, [r7, #12]
	}
   10e06:	4618      	mov	r0, r3
   10e08:	f107 0710 	add.w	r7, r7, #16
   10e0c:	46bd      	mov	sp, r7
   10e0e:	bd80      	pop	{r7, pc}

00010e10 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
	{
   10e10:	b580      	push	{r7, lr}
   10e12:	b088      	sub	sp, #32
   10e14:	af00      	add	r7, sp, #0
   10e16:	6078      	str	r0, [r7, #4]
		below the maximum system call interrupt priority.  FreeRTOS maintains a
		separate interrupt safe API to ensure interrupt entry is as fast and as
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   10e18:	f003 fb12 	bl	14440 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
   10e1c:	f3ef 8211 	mrs	r2, BASEPRI
   10e20:	f04f 0328 	mov.w	r3, #40	; 0x28
   10e24:	f383 8811 	msr	BASEPRI, r3
   10e28:	f3bf 8f6f 	isb	sy
   10e2c:	f3bf 8f4f 	dsb	sy
   10e30:	61ba      	str	r2, [r7, #24]
   10e32:	617b      	str	r3, [r7, #20]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
   10e34:	69bb      	ldr	r3, [r7, #24]

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
   10e36:	613b      	str	r3, [r7, #16]
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
   10e38:	687b      	ldr	r3, [r7, #4]
   10e3a:	2b00      	cmp	r3, #0
   10e3c:	d105      	bne.n	10e4a <uxTaskPriorityGetFromISR+0x3a>
   10e3e:	f243 030c 	movw	r3, #12300	; 0x300c
   10e42:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10e46:	681b      	ldr	r3, [r3, #0]
   10e48:	e000      	b.n	10e4c <uxTaskPriorityGetFromISR+0x3c>
   10e4a:	687b      	ldr	r3, [r7, #4]
   10e4c:	60bb      	str	r3, [r7, #8]
			uxReturn = pxTCB->uxPriority;
   10e4e:	68bb      	ldr	r3, [r7, #8]
   10e50:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   10e52:	60fb      	str	r3, [r7, #12]
   10e54:	693b      	ldr	r3, [r7, #16]
   10e56:	61fb      	str	r3, [r7, #28]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   10e58:	69fb      	ldr	r3, [r7, #28]
   10e5a:	f383 8811 	msr	BASEPRI, r3
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
   10e5e:	68fb      	ldr	r3, [r7, #12]
	}
   10e60:	4618      	mov	r0, r3
   10e62:	f107 0720 	add.w	r7, r7, #32
   10e66:	46bd      	mov	sp, r7
   10e68:	bd80      	pop	{r7, pc}
   10e6a:	bf00      	nop

00010e6c <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
   10e6c:	b580      	push	{r7, lr}
   10e6e:	b088      	sub	sp, #32
   10e70:	af00      	add	r7, sp, #0
   10e72:	6078      	str	r0, [r7, #4]
   10e74:	6039      	str	r1, [r7, #0]
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
   10e76:	f04f 0300 	mov.w	r3, #0
   10e7a:	61bb      	str	r3, [r7, #24]

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
   10e7c:	683b      	ldr	r3, [r7, #0]
   10e7e:	2b04      	cmp	r3, #4
   10e80:	d909      	bls.n	10e96 <vTaskPrioritySet+0x2a>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   10e82:	f04f 0328 	mov.w	r3, #40	; 0x28
   10e86:	f383 8811 	msr	BASEPRI, r3
   10e8a:	f3bf 8f6f 	isb	sy
   10e8e:	f3bf 8f4f 	dsb	sy
   10e92:	61fb      	str	r3, [r7, #28]
   10e94:	e7fe      	b.n	10e94 <vTaskPrioritySet+0x28>

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   10e96:	683b      	ldr	r3, [r7, #0]
   10e98:	2b04      	cmp	r3, #4
   10e9a:	d902      	bls.n	10ea2 <vTaskPrioritySet+0x36>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   10e9c:	f04f 0304 	mov.w	r3, #4
   10ea0:	603b      	str	r3, [r7, #0]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
   10ea2:	f003 f9e9 	bl	14278 <vPortEnterCritical>
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
   10ea6:	687b      	ldr	r3, [r7, #4]
   10ea8:	2b00      	cmp	r3, #0
   10eaa:	d105      	bne.n	10eb8 <vTaskPrioritySet+0x4c>
   10eac:	f243 030c 	movw	r3, #12300	; 0x300c
   10eb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10eb4:	681b      	ldr	r3, [r3, #0]
   10eb6:	e000      	b.n	10eba <vTaskPrioritySet+0x4e>
   10eb8:	687b      	ldr	r3, [r7, #4]
   10eba:	60fb      	str	r3, [r7, #12]

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
   10ebc:	68fb      	ldr	r3, [r7, #12]
   10ebe:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   10ec0:	613b      	str	r3, [r7, #16]
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
   10ec2:	693a      	ldr	r2, [r7, #16]
   10ec4:	683b      	ldr	r3, [r7, #0]
   10ec6:	429a      	cmp	r2, r3
   10ec8:	f000 80a2 	beq.w	11010 <vTaskPrioritySet+0x1a4>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
   10ecc:	683a      	ldr	r2, [r7, #0]
   10ece:	693b      	ldr	r3, [r7, #16]
   10ed0:	429a      	cmp	r2, r3
   10ed2:	d914      	bls.n	10efe <vTaskPrioritySet+0x92>
				{
					if( pxTCB != pxCurrentTCB )
   10ed4:	f243 030c 	movw	r3, #12300	; 0x300c
   10ed8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10edc:	681b      	ldr	r3, [r3, #0]
   10ede:	68fa      	ldr	r2, [r7, #12]
   10ee0:	429a      	cmp	r2, r3
   10ee2:	d018      	beq.n	10f16 <vTaskPrioritySet+0xaa>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
   10ee4:	f243 030c 	movw	r3, #12300	; 0x300c
   10ee8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10eec:	681b      	ldr	r3, [r3, #0]
   10eee:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10ef0:	683b      	ldr	r3, [r7, #0]
   10ef2:	429a      	cmp	r2, r3
   10ef4:	d811      	bhi.n	10f1a <vTaskPrioritySet+0xae>
						{
							xYieldRequired = pdTRUE;
   10ef6:	f04f 0301 	mov.w	r3, #1
   10efa:	61bb      	str	r3, [r7, #24]
   10efc:	e00e      	b.n	10f1c <vTaskPrioritySet+0xb0>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
   10efe:	f243 030c 	movw	r3, #12300	; 0x300c
   10f02:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10f06:	681b      	ldr	r3, [r3, #0]
   10f08:	68fa      	ldr	r2, [r7, #12]
   10f0a:	429a      	cmp	r2, r3
   10f0c:	d106      	bne.n	10f1c <vTaskPrioritySet+0xb0>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
   10f0e:	f04f 0301 	mov.w	r3, #1
   10f12:	61bb      	str	r3, [r7, #24]
   10f14:	e002      	b.n	10f1c <vTaskPrioritySet+0xb0>
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
						{
							xYieldRequired = pdTRUE;
   10f16:	bf00      	nop
   10f18:	e000      	b.n	10f1c <vTaskPrioritySet+0xb0>
   10f1a:	bf00      	nop
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
   10f1c:	68fb      	ldr	r3, [r7, #12]
   10f1e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   10f20:	617b      	str	r3, [r7, #20]

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
   10f22:	68fb      	ldr	r3, [r7, #12]
   10f24:	6c9a      	ldr	r2, [r3, #72]	; 0x48
   10f26:	68fb      	ldr	r3, [r7, #12]
   10f28:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   10f2a:	429a      	cmp	r2, r3
   10f2c:	d102      	bne.n	10f34 <vTaskPrioritySet+0xc8>
					{
						pxTCB->uxPriority = uxNewPriority;
   10f2e:	68fb      	ldr	r3, [r7, #12]
   10f30:	683a      	ldr	r2, [r7, #0]
   10f32:	62da      	str	r2, [r3, #44]	; 0x2c
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
   10f34:	68fb      	ldr	r3, [r7, #12]
   10f36:	683a      	ldr	r2, [r7, #0]
   10f38:	649a      	str	r2, [r3, #72]	; 0x48
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   10f3a:	68fb      	ldr	r3, [r7, #12]
   10f3c:	699b      	ldr	r3, [r3, #24]
   10f3e:	2b00      	cmp	r3, #0
   10f40:	db04      	blt.n	10f4c <vTaskPrioritySet+0xe0>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   10f42:	683b      	ldr	r3, [r7, #0]
   10f44:	f1c3 0205 	rsb	r2, r3, #5
   10f48:	68fb      	ldr	r3, [r7, #12]
   10f4a:	619a      	str	r2, [r3, #24]

				/* If the task is in the blocked or suspended list we need do
				nothing more than change its priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
   10f4c:	68fb      	ldr	r3, [r7, #12]
   10f4e:	6959      	ldr	r1, [r3, #20]
   10f50:	697a      	ldr	r2, [r7, #20]
   10f52:	4613      	mov	r3, r2
   10f54:	ea4f 0383 	mov.w	r3, r3, lsl #2
   10f58:	4413      	add	r3, r2
   10f5a:	ea4f 0383 	mov.w	r3, r3, lsl #2
   10f5e:	461a      	mov	r2, r3
   10f60:	f243 0310 	movw	r3, #12304	; 0x3010
   10f64:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10f68:	4413      	add	r3, r2
   10f6a:	4299      	cmp	r1, r3
   10f6c:	d142      	bne.n	10ff4 <vTaskPrioritySet+0x188>
				{
					/* The task is currently in its ready list - remove before
					adding it to it's new ready list.  As we are in a critical
					section we can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   10f6e:	68fb      	ldr	r3, [r7, #12]
   10f70:	f103 0304 	add.w	r3, r3, #4
   10f74:	4618      	mov	r0, r3
   10f76:	f7fe f941 	bl	f1fc <uxListRemove>
   10f7a:	4603      	mov	r3, r0
   10f7c:	2b00      	cmp	r3, #0
   10f7e:	d112      	bne.n	10fa6 <vTaskPrioritySet+0x13a>
					{
						/* It is known that the task is in its ready list so
						there is no need to check again and the port level
						reset macro can be called directly. */
						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
   10f80:	697b      	ldr	r3, [r7, #20]
   10f82:	f04f 0201 	mov.w	r2, #1
   10f86:	fa02 f303 	lsl.w	r3, r2, r3
   10f8a:	ea6f 0203 	mvn.w	r2, r3
   10f8e:	f243 03ec 	movw	r3, #12524	; 0x30ec
   10f92:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10f96:	681b      	ldr	r3, [r3, #0]
   10f98:	ea02 0203 	and.w	r2, r2, r3
   10f9c:	f243 03ec 	movw	r3, #12524	; 0x30ec
   10fa0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10fa4:	601a      	str	r2, [r3, #0]
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
   10fa6:	68fb      	ldr	r3, [r7, #12]
   10fa8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   10faa:	f04f 0201 	mov.w	r2, #1
   10fae:	fa02 f203 	lsl.w	r2, r2, r3
   10fb2:	f243 03ec 	movw	r3, #12524	; 0x30ec
   10fb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10fba:	681b      	ldr	r3, [r3, #0]
   10fbc:	ea42 0203 	orr.w	r2, r2, r3
   10fc0:	f243 03ec 	movw	r3, #12524	; 0x30ec
   10fc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10fc8:	601a      	str	r2, [r3, #0]
   10fca:	68fb      	ldr	r3, [r7, #12]
   10fcc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10fce:	4613      	mov	r3, r2
   10fd0:	ea4f 0383 	mov.w	r3, r3, lsl #2
   10fd4:	4413      	add	r3, r2
   10fd6:	ea4f 0383 	mov.w	r3, r3, lsl #2
   10fda:	461a      	mov	r2, r3
   10fdc:	f243 0310 	movw	r3, #12304	; 0x3010
   10fe0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10fe4:	441a      	add	r2, r3
   10fe6:	68fb      	ldr	r3, [r7, #12]
   10fe8:	f103 0304 	add.w	r3, r3, #4
   10fec:	4610      	mov	r0, r2
   10fee:	4619      	mov	r1, r3
   10ff0:	f7fe f8a6 	bl	f140 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
   10ff4:	69bb      	ldr	r3, [r7, #24]
   10ff6:	2b00      	cmp	r3, #0
   10ff8:	d00a      	beq.n	11010 <vTaskPrioritySet+0x1a4>
				{
					taskYIELD_IF_USING_PREEMPTION();
   10ffa:	f64e 5304 	movw	r3, #60676	; 0xed04
   10ffe:	f2ce 0300 	movt	r3, #57344	; 0xe000
   11002:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   11006:	601a      	str	r2, [r3, #0]
   11008:	f3bf 8f4f 	dsb	sy
   1100c:	f3bf 8f6f 	isb	sy
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
   11010:	f003 f96a 	bl	142e8 <vPortExitCritical>
	}
   11014:	f107 0720 	add.w	r7, r7, #32
   11018:	46bd      	mov	sp, r7
   1101a:	bd80      	pop	{r7, pc}

0001101c <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
   1101c:	b580      	push	{r7, lr}
   1101e:	b084      	sub	sp, #16
   11020:	af00      	add	r7, sp, #0
   11022:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
   11024:	f003 f928 	bl	14278 <vPortEnterCritical>
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
   11028:	687b      	ldr	r3, [r7, #4]
   1102a:	2b00      	cmp	r3, #0
   1102c:	d105      	bne.n	1103a <vTaskSuspend+0x1e>
   1102e:	f243 030c 	movw	r3, #12300	; 0x300c
   11032:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11036:	681b      	ldr	r3, [r3, #0]
   11038:	e000      	b.n	1103c <vTaskSuspend+0x20>
   1103a:	687b      	ldr	r3, [r7, #4]
   1103c:	60bb      	str	r3, [r7, #8]

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   1103e:	68bb      	ldr	r3, [r7, #8]
   11040:	f103 0304 	add.w	r3, r3, #4
   11044:	4618      	mov	r0, r3
   11046:	f7fe f8d9 	bl	f1fc <uxListRemove>
   1104a:	4603      	mov	r3, r0
   1104c:	2b00      	cmp	r3, #0
   1104e:	d124      	bne.n	1109a <vTaskSuspend+0x7e>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   11050:	68bb      	ldr	r3, [r7, #8]
   11052:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11054:	4613      	mov	r3, r2
   11056:	ea4f 0383 	mov.w	r3, r3, lsl #2
   1105a:	4413      	add	r3, r2
   1105c:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11060:	461a      	mov	r2, r3
   11062:	f243 0310 	movw	r3, #12304	; 0x3010
   11066:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1106a:	4413      	add	r3, r2
   1106c:	681b      	ldr	r3, [r3, #0]
   1106e:	2b00      	cmp	r3, #0
   11070:	d113      	bne.n	1109a <vTaskSuspend+0x7e>
   11072:	68bb      	ldr	r3, [r7, #8]
   11074:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11076:	f04f 0201 	mov.w	r2, #1
   1107a:	fa02 f303 	lsl.w	r3, r2, r3
   1107e:	ea6f 0203 	mvn.w	r2, r3
   11082:	f243 03ec 	movw	r3, #12524	; 0x30ec
   11086:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1108a:	681b      	ldr	r3, [r3, #0]
   1108c:	ea02 0203 	and.w	r2, r2, r3
   11090:	f243 03ec 	movw	r3, #12524	; 0x30ec
   11094:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11098:	601a      	str	r2, [r3, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   1109a:	68bb      	ldr	r3, [r7, #8]
   1109c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1109e:	2b00      	cmp	r3, #0
   110a0:	d005      	beq.n	110ae <vTaskSuspend+0x92>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   110a2:	68bb      	ldr	r3, [r7, #8]
   110a4:	f103 0318 	add.w	r3, r3, #24
   110a8:	4618      	mov	r0, r3
   110aa:	f7fe f8a7 	bl	f1fc <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
   110ae:	68bb      	ldr	r3, [r7, #8]
   110b0:	f103 0304 	add.w	r3, r3, #4
   110b4:	f243 00d0 	movw	r0, #12496	; 0x30d0
   110b8:	f2c2 0000 	movt	r0, #8192	; 0x2000
   110bc:	4619      	mov	r1, r3
   110be:	f7fe f83f 	bl	f140 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
   110c2:	68bb      	ldr	r3, [r7, #8]
   110c4:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
   110c8:	b2db      	uxtb	r3, r3
   110ca:	2b01      	cmp	r3, #1
   110cc:	d104      	bne.n	110d8 <vTaskSuspend+0xbc>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   110ce:	68bb      	ldr	r3, [r7, #8]
   110d0:	f04f 0200 	mov.w	r2, #0
   110d4:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
   110d8:	f003 f906 	bl	142e8 <vPortExitCritical>

		if( xSchedulerRunning != pdFALSE )
   110dc:	f243 03f0 	movw	r3, #12528	; 0x30f0
   110e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   110e4:	681b      	ldr	r3, [r3, #0]
   110e6:	2b00      	cmp	r3, #0
   110e8:	d005      	beq.n	110f6 <vTaskSuspend+0xda>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
   110ea:	f003 f8c5 	bl	14278 <vPortEnterCritical>
			{
				prvResetNextTaskUnblockTime();
   110ee:	f001 f9a3 	bl	12438 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
   110f2:	f003 f8f9 	bl	142e8 <vPortExitCritical>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
   110f6:	f243 030c 	movw	r3, #12300	; 0x300c
   110fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
   110fe:	681b      	ldr	r3, [r3, #0]
   11100:	68ba      	ldr	r2, [r7, #8]
   11102:	429a      	cmp	r2, r3
   11104:	d139      	bne.n	1117a <vTaskSuspend+0x15e>
		{
			if( xSchedulerRunning != pdFALSE )
   11106:	f243 03f0 	movw	r3, #12528	; 0x30f0
   1110a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1110e:	681b      	ldr	r3, [r3, #0]
   11110:	2b00      	cmp	r3, #0
   11112:	d01c      	beq.n	1114e <vTaskSuspend+0x132>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
   11114:	f243 130c 	movw	r3, #12556	; 0x310c
   11118:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1111c:	681b      	ldr	r3, [r3, #0]
   1111e:	2b00      	cmp	r3, #0
   11120:	d009      	beq.n	11136 <vTaskSuspend+0x11a>
   11122:	f04f 0328 	mov.w	r3, #40	; 0x28
   11126:	f383 8811 	msr	BASEPRI, r3
   1112a:	f3bf 8f6f 	isb	sy
   1112e:	f3bf 8f4f 	dsb	sy
   11132:	60fb      	str	r3, [r7, #12]
   11134:	e7fe      	b.n	11134 <vTaskSuspend+0x118>
				portYIELD_WITHIN_API();
   11136:	f64e 5304 	movw	r3, #60676	; 0xed04
   1113a:	f2ce 0300 	movt	r3, #57344	; 0xe000
   1113e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   11142:	601a      	str	r2, [r3, #0]
   11144:	f3bf 8f4f 	dsb	sy
   11148:	f3bf 8f6f 	isb	sy
   1114c:	e015      	b.n	1117a <vTaskSuspend+0x15e>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
   1114e:	f243 03d0 	movw	r3, #12496	; 0x30d0
   11152:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11156:	681a      	ldr	r2, [r3, #0]
   11158:	f243 03e4 	movw	r3, #12516	; 0x30e4
   1115c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11160:	681b      	ldr	r3, [r3, #0]
   11162:	429a      	cmp	r2, r3
   11164:	d107      	bne.n	11176 <vTaskSuspend+0x15a>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
   11166:	f243 030c 	movw	r3, #12300	; 0x300c
   1116a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1116e:	f04f 0200 	mov.w	r2, #0
   11172:	601a      	str	r2, [r3, #0]
   11174:	e001      	b.n	1117a <vTaskSuspend+0x15e>
				}
				else
				{
					vTaskSwitchContext();
   11176:	f000 fc89 	bl	11a8c <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   1117a:	f107 0710 	add.w	r7, r7, #16
   1117e:	46bd      	mov	sp, r7
   11180:	bd80      	pop	{r7, pc}
   11182:	bf00      	nop

00011184 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
   11184:	b480      	push	{r7}
   11186:	b087      	sub	sp, #28
   11188:	af00      	add	r7, sp, #0
   1118a:	6078      	str	r0, [r7, #4]
	BaseType_t xReturn = pdFALSE;
   1118c:	f04f 0300 	mov.w	r3, #0
   11190:	60fb      	str	r3, [r7, #12]
	const TCB_t * const pxTCB = xTask;
   11192:	687b      	ldr	r3, [r7, #4]
   11194:	613b      	str	r3, [r7, #16]

		/* Accesses xPendingReadyList so must be called from a critical
		section. */

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );
   11196:	687b      	ldr	r3, [r7, #4]
   11198:	2b00      	cmp	r3, #0
   1119a:	d109      	bne.n	111b0 <prvTaskIsTaskSuspended+0x2c>
   1119c:	f04f 0328 	mov.w	r3, #40	; 0x28
   111a0:	f383 8811 	msr	BASEPRI, r3
   111a4:	f3bf 8f6f 	isb	sy
   111a8:	f3bf 8f4f 	dsb	sy
   111ac:	617b      	str	r3, [r7, #20]
   111ae:	e7fe      	b.n	111ae <prvTaskIsTaskSuspended+0x2a>

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
   111b0:	693b      	ldr	r3, [r7, #16]
   111b2:	695a      	ldr	r2, [r3, #20]
   111b4:	f243 03d0 	movw	r3, #12496	; 0x30d0
   111b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   111bc:	429a      	cmp	r2, r3
   111be:	d10e      	bne.n	111de <prvTaskIsTaskSuspended+0x5a>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
   111c0:	693b      	ldr	r3, [r7, #16]
   111c2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   111c4:	f243 03a4 	movw	r3, #12452	; 0x30a4
   111c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   111cc:	429a      	cmp	r2, r3
   111ce:	d006      	beq.n	111de <prvTaskIsTaskSuspended+0x5a>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
   111d0:	693b      	ldr	r3, [r7, #16]
   111d2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   111d4:	2b00      	cmp	r3, #0
   111d6:	d102      	bne.n	111de <prvTaskIsTaskSuspended+0x5a>
				{
					xReturn = pdTRUE;
   111d8:	f04f 0301 	mov.w	r3, #1
   111dc:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
   111de:	68fb      	ldr	r3, [r7, #12]
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   111e0:	4618      	mov	r0, r3
   111e2:	f107 071c 	add.w	r7, r7, #28
   111e6:	46bd      	mov	sp, r7
   111e8:	bc80      	pop	{r7}
   111ea:	4770      	bx	lr

000111ec <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
   111ec:	b580      	push	{r7, lr}
   111ee:	b084      	sub	sp, #16
   111f0:	af00      	add	r7, sp, #0
   111f2:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = xTaskToResume;
   111f4:	687b      	ldr	r3, [r7, #4]
   111f6:	60bb      	str	r3, [r7, #8]

		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );
   111f8:	687b      	ldr	r3, [r7, #4]
   111fa:	2b00      	cmp	r3, #0
   111fc:	d109      	bne.n	11212 <vTaskResume+0x26>
   111fe:	f04f 0328 	mov.w	r3, #40	; 0x28
   11202:	f383 8811 	msr	BASEPRI, r3
   11206:	f3bf 8f6f 	isb	sy
   1120a:	f3bf 8f4f 	dsb	sy
   1120e:	60fb      	str	r3, [r7, #12]
   11210:	e7fe      	b.n	11210 <vTaskResume+0x24>

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
   11212:	f243 030c 	movw	r3, #12300	; 0x300c
   11216:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1121a:	681b      	ldr	r3, [r3, #0]
   1121c:	68ba      	ldr	r2, [r7, #8]
   1121e:	429a      	cmp	r2, r3
   11220:	d04e      	beq.n	112c0 <vTaskResume+0xd4>
   11222:	68bb      	ldr	r3, [r7, #8]
   11224:	2b00      	cmp	r3, #0
   11226:	d04b      	beq.n	112c0 <vTaskResume+0xd4>
		{
			taskENTER_CRITICAL();
   11228:	f003 f826 	bl	14278 <vPortEnterCritical>
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
   1122c:	68b8      	ldr	r0, [r7, #8]
   1122e:	f7ff ffa9 	bl	11184 <prvTaskIsTaskSuspended>
   11232:	4603      	mov	r3, r0
   11234:	2b00      	cmp	r3, #0
   11236:	d041      	beq.n	112bc <vTaskResume+0xd0>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
   11238:	68bb      	ldr	r3, [r7, #8]
   1123a:	f103 0304 	add.w	r3, r3, #4
   1123e:	4618      	mov	r0, r3
   11240:	f7fd ffdc 	bl	f1fc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   11244:	68bb      	ldr	r3, [r7, #8]
   11246:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11248:	f04f 0201 	mov.w	r2, #1
   1124c:	fa02 f203 	lsl.w	r2, r2, r3
   11250:	f243 03ec 	movw	r3, #12524	; 0x30ec
   11254:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11258:	681b      	ldr	r3, [r3, #0]
   1125a:	ea42 0203 	orr.w	r2, r2, r3
   1125e:	f243 03ec 	movw	r3, #12524	; 0x30ec
   11262:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11266:	601a      	str	r2, [r3, #0]
   11268:	68bb      	ldr	r3, [r7, #8]
   1126a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1126c:	4613      	mov	r3, r2
   1126e:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11272:	4413      	add	r3, r2
   11274:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11278:	461a      	mov	r2, r3
   1127a:	f243 0310 	movw	r3, #12304	; 0x3010
   1127e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11282:	441a      	add	r2, r3
   11284:	68bb      	ldr	r3, [r7, #8]
   11286:	f103 0304 	add.w	r3, r3, #4
   1128a:	4610      	mov	r0, r2
   1128c:	4619      	mov	r1, r3
   1128e:	f7fd ff57 	bl	f140 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   11292:	68bb      	ldr	r3, [r7, #8]
   11294:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11296:	f243 030c 	movw	r3, #12300	; 0x300c
   1129a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1129e:	681b      	ldr	r3, [r3, #0]
   112a0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   112a2:	429a      	cmp	r2, r3
   112a4:	d30a      	bcc.n	112bc <vTaskResume+0xd0>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
   112a6:	f64e 5304 	movw	r3, #60676	; 0xed04
   112aa:	f2ce 0300 	movt	r3, #57344	; 0xe000
   112ae:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   112b2:	601a      	str	r2, [r3, #0]
   112b4:	f3bf 8f4f 	dsb	sy
   112b8:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
   112bc:	f003 f814 	bl	142e8 <vPortExitCritical>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   112c0:	f107 0710 	add.w	r7, r7, #16
   112c4:	46bd      	mov	sp, r7
   112c6:	bd80      	pop	{r7, pc}

000112c8 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
   112c8:	b580      	push	{r7, lr}
   112ca:	b08a      	sub	sp, #40	; 0x28
   112cc:	af00      	add	r7, sp, #0
   112ce:	6078      	str	r0, [r7, #4]
	BaseType_t xYieldRequired = pdFALSE;
   112d0:	f04f 0300 	mov.w	r3, #0
   112d4:	60fb      	str	r3, [r7, #12]
	TCB_t * const pxTCB = xTaskToResume;
   112d6:	687b      	ldr	r3, [r7, #4]
   112d8:	613b      	str	r3, [r7, #16]
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToResume );
   112da:	687b      	ldr	r3, [r7, #4]
   112dc:	2b00      	cmp	r3, #0
   112de:	d109      	bne.n	112f4 <xTaskResumeFromISR+0x2c>
   112e0:	f04f 0328 	mov.w	r3, #40	; 0x28
   112e4:	f383 8811 	msr	BASEPRI, r3
   112e8:	f3bf 8f6f 	isb	sy
   112ec:	f3bf 8f4f 	dsb	sy
   112f0:	61bb      	str	r3, [r7, #24]
   112f2:	e7fe      	b.n	112f2 <xTaskResumeFromISR+0x2a>
		below the maximum system call interrupt priority.  FreeRTOS maintains a
		separate interrupt safe API to ensure interrupt entry is as fast and as
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   112f4:	f003 f8a4 	bl	14440 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
   112f8:	f3ef 8211 	mrs	r2, BASEPRI
   112fc:	f04f 0328 	mov.w	r3, #40	; 0x28
   11300:	f383 8811 	msr	BASEPRI, r3
   11304:	f3bf 8f6f 	isb	sy
   11308:	f3bf 8f4f 	dsb	sy
   1130c:	623a      	str	r2, [r7, #32]
   1130e:	61fb      	str	r3, [r7, #28]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
   11310:	6a3b      	ldr	r3, [r7, #32]

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   11312:	617b      	str	r3, [r7, #20]
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
   11314:	6938      	ldr	r0, [r7, #16]
   11316:	f7ff ff35 	bl	11184 <prvTaskIsTaskSuspended>
   1131a:	4603      	mov	r3, r0
   1131c:	2b00      	cmp	r3, #0
   1131e:	d04b      	beq.n	113b8 <xTaskResumeFromISR+0xf0>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   11320:	f243 130c 	movw	r3, #12556	; 0x310c
   11324:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11328:	681b      	ldr	r3, [r3, #0]
   1132a:	2b00      	cmp	r3, #0
   1132c:	d13a      	bne.n	113a4 <xTaskResumeFromISR+0xdc>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1132e:	693b      	ldr	r3, [r7, #16]
   11330:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11332:	f243 030c 	movw	r3, #12300	; 0x300c
   11336:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1133a:	681b      	ldr	r3, [r3, #0]
   1133c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1133e:	429a      	cmp	r2, r3
   11340:	d302      	bcc.n	11348 <xTaskResumeFromISR+0x80>
					{
						xYieldRequired = pdTRUE;
   11342:	f04f 0301 	mov.w	r3, #1
   11346:	60fb      	str	r3, [r7, #12]
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   11348:	693b      	ldr	r3, [r7, #16]
   1134a:	f103 0304 	add.w	r3, r3, #4
   1134e:	4618      	mov	r0, r3
   11350:	f7fd ff54 	bl	f1fc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   11354:	693b      	ldr	r3, [r7, #16]
   11356:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11358:	f04f 0201 	mov.w	r2, #1
   1135c:	fa02 f203 	lsl.w	r2, r2, r3
   11360:	f243 03ec 	movw	r3, #12524	; 0x30ec
   11364:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11368:	681b      	ldr	r3, [r3, #0]
   1136a:	ea42 0203 	orr.w	r2, r2, r3
   1136e:	f243 03ec 	movw	r3, #12524	; 0x30ec
   11372:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11376:	601a      	str	r2, [r3, #0]
   11378:	693b      	ldr	r3, [r7, #16]
   1137a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1137c:	4613      	mov	r3, r2
   1137e:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11382:	4413      	add	r3, r2
   11384:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11388:	461a      	mov	r2, r3
   1138a:	f243 0310 	movw	r3, #12304	; 0x3010
   1138e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11392:	441a      	add	r2, r3
   11394:	693b      	ldr	r3, [r7, #16]
   11396:	f103 0304 	add.w	r3, r3, #4
   1139a:	4610      	mov	r0, r2
   1139c:	4619      	mov	r1, r3
   1139e:	f7fd fecf 	bl	f140 <vListInsertEnd>
   113a2:	e009      	b.n	113b8 <xTaskResumeFromISR+0xf0>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   113a4:	693b      	ldr	r3, [r7, #16]
   113a6:	f103 0318 	add.w	r3, r3, #24
   113aa:	f243 00a4 	movw	r0, #12452	; 0x30a4
   113ae:	f2c2 0000 	movt	r0, #8192	; 0x2000
   113b2:	4619      	mov	r1, r3
   113b4:	f7fd fec4 	bl	f140 <vListInsertEnd>
   113b8:	697b      	ldr	r3, [r7, #20]
   113ba:	627b      	str	r3, [r7, #36]	; 0x24
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   113bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   113be:	f383 8811 	msr	BASEPRI, r3
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
   113c2:	68fb      	ldr	r3, [r7, #12]
	}
   113c4:	4618      	mov	r0, r3
   113c6:	f107 0728 	add.w	r7, r7, #40	; 0x28
   113ca:	46bd      	mov	sp, r7
   113cc:	bd80      	pop	{r7, pc}
   113ce:	bf00      	nop

000113d0 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
   113d0:	b580      	push	{r7, lr}
   113d2:	b086      	sub	sp, #24
   113d4:	af02      	add	r7, sp, #8
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
   113d6:	f04f 0300 	mov.w	r3, #0
   113da:	9300      	str	r3, [sp, #0]
   113dc:	f243 1308 	movw	r3, #12552	; 0x3108
   113e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   113e4:	9301      	str	r3, [sp, #4]
   113e6:	f242 00ed 	movw	r0, #8429	; 0x20ed
   113ea:	f2c0 0001 	movt	r0, #1
   113ee:	f244 0154 	movw	r1, #16468	; 0x4054
   113f2:	f2c0 0102 	movt	r1, #2
   113f6:	f04f 025a 	mov.w	r2, #90	; 0x5a
   113fa:	f04f 0300 	mov.w	r3, #0
   113fe:	f7ff f977 	bl	106f0 <xTaskCreate>
   11402:	4603      	mov	r3, r0
   11404:	607b      	str	r3, [r7, #4]
	}
	#endif /* configSUPPORT_STATIC_ALLOCATION */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
   11406:	687b      	ldr	r3, [r7, #4]
   11408:	2b01      	cmp	r3, #1
   1140a:	d103      	bne.n	11414 <vTaskStartScheduler+0x44>
		{
			xReturn = xTimerCreateTimerTask();
   1140c:	f002 f826 	bl	1345c <xTimerCreateTimerTask>
   11410:	4603      	mov	r3, r0
   11412:	607b      	str	r3, [r7, #4]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
   11414:	687b      	ldr	r3, [r7, #4]
   11416:	2b01      	cmp	r3, #1
   11418:	d122      	bne.n	11460 <vTaskStartScheduler+0x90>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   1141a:	f04f 0328 	mov.w	r3, #40	; 0x28
   1141e:	f383 8811 	msr	BASEPRI, r3
   11422:	f3bf 8f6f 	isb	sy
   11426:	f3bf 8f4f 	dsb	sy
   1142a:	60bb      	str	r3, [r7, #8]
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
   1142c:	f243 1304 	movw	r3, #12548	; 0x3104
   11430:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11434:	f04f 32ff 	mov.w	r2, #4294967295
   11438:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
   1143a:	f243 03f0 	movw	r3, #12528	; 0x30f0
   1143e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11442:	f04f 0201 	mov.w	r2, #1
   11446:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
   11448:	f243 03e8 	movw	r3, #12520	; 0x30e8
   1144c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11450:	f04f 0200 	mov.w	r2, #0
   11454:	601a      	str	r2, [r3, #0]
		macro must be defined to configure the timer/counter used to generate
		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
		is set to 0 and the following line fails to build then ensure you do not
		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
		FreeRTOSConfig.h file. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
   11456:	f7ef fbc9 	bl	bec <vMainConfigureTimerForRunTimeStats>

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
   1145a:	f002 fe59 	bl	14110 <xPortStartScheduler>
   1145e:	e00d      	b.n	1147c <vTaskStartScheduler+0xac>
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
   11460:	687b      	ldr	r3, [r7, #4]
   11462:	f1b3 3fff 	cmp.w	r3, #4294967295
   11466:	d109      	bne.n	1147c <vTaskStartScheduler+0xac>
   11468:	f04f 0328 	mov.w	r3, #40	; 0x28
   1146c:	f383 8811 	msr	BASEPRI, r3
   11470:	f3bf 8f6f 	isb	sy
   11474:	f3bf 8f4f 	dsb	sy
   11478:	60fb      	str	r3, [r7, #12]
   1147a:	e7fe      	b.n	1147a <vTaskStartScheduler+0xaa>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
   1147c:	f107 0710 	add.w	r7, r7, #16
   11480:	46bd      	mov	sp, r7
   11482:	bd80      	pop	{r7, pc}

00011484 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
   11484:	b580      	push	{r7, lr}
   11486:	b082      	sub	sp, #8
   11488:	af00      	add	r7, sp, #0
   1148a:	f04f 0328 	mov.w	r3, #40	; 0x28
   1148e:	f383 8811 	msr	BASEPRI, r3
   11492:	f3bf 8f6f 	isb	sy
   11496:	f3bf 8f4f 	dsb	sy
   1149a:	607b      	str	r3, [r7, #4]
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
	xSchedulerRunning = pdFALSE;
   1149c:	f243 03f0 	movw	r3, #12528	; 0x30f0
   114a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   114a4:	f04f 0200 	mov.w	r2, #0
   114a8:	601a      	str	r2, [r3, #0]
	vPortEndScheduler();
   114aa:	f002 fecb 	bl	14244 <vPortEndScheduler>
}
   114ae:	f107 0708 	add.w	r7, r7, #8
   114b2:	46bd      	mov	sp, r7
   114b4:	bd80      	pop	{r7, pc}
   114b6:	bf00      	nop

000114b8 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
   114b8:	b480      	push	{r7}
   114ba:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
   114bc:	f243 130c 	movw	r3, #12556	; 0x310c
   114c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   114c4:	681b      	ldr	r3, [r3, #0]
   114c6:	f103 0201 	add.w	r2, r3, #1
   114ca:	f243 130c 	movw	r3, #12556	; 0x310c
   114ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
   114d2:	601a      	str	r2, [r3, #0]
}
   114d4:	46bd      	mov	sp, r7
   114d6:	bc80      	pop	{r7}
   114d8:	4770      	bx	lr
   114da:	bf00      	nop

000114dc <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
   114dc:	b580      	push	{r7, lr}
   114de:	b084      	sub	sp, #16
   114e0:	af00      	add	r7, sp, #0
TCB_t *pxTCB = NULL;
   114e2:	f04f 0300 	mov.w	r3, #0
   114e6:	603b      	str	r3, [r7, #0]
BaseType_t xAlreadyYielded = pdFALSE;
   114e8:	f04f 0300 	mov.w	r3, #0
   114ec:	607b      	str	r3, [r7, #4]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
   114ee:	f243 130c 	movw	r3, #12556	; 0x310c
   114f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   114f6:	681b      	ldr	r3, [r3, #0]
   114f8:	2b00      	cmp	r3, #0
   114fa:	d109      	bne.n	11510 <xTaskResumeAll+0x34>
   114fc:	f04f 0328 	mov.w	r3, #40	; 0x28
   11500:	f383 8811 	msr	BASEPRI, r3
   11504:	f3bf 8f6f 	isb	sy
   11508:	f3bf 8f4f 	dsb	sy
   1150c:	60fb      	str	r3, [r7, #12]
   1150e:	e7fe      	b.n	1150e <xTaskResumeAll+0x32>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
   11510:	f002 feb2 	bl	14278 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
   11514:	f243 130c 	movw	r3, #12556	; 0x310c
   11518:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1151c:	681b      	ldr	r3, [r3, #0]
   1151e:	f103 32ff 	add.w	r2, r3, #4294967295
   11522:	f243 130c 	movw	r3, #12556	; 0x310c
   11526:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1152a:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   1152c:	f243 130c 	movw	r3, #12556	; 0x310c
   11530:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11534:	681b      	ldr	r3, [r3, #0]
   11536:	2b00      	cmp	r3, #0
   11538:	f040 8098 	bne.w	1166c <xTaskResumeAll+0x190>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   1153c:	f243 03e4 	movw	r3, #12516	; 0x30e4
   11540:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11544:	681b      	ldr	r3, [r3, #0]
   11546:	2b00      	cmp	r3, #0
   11548:	f000 8090 	beq.w	1166c <xTaskResumeAll+0x190>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   1154c:	e04a      	b.n	115e4 <xTaskResumeAll+0x108>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   1154e:	f243 03a4 	movw	r3, #12452	; 0x30a4
   11552:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11556:	68db      	ldr	r3, [r3, #12]
   11558:	68db      	ldr	r3, [r3, #12]
   1155a:	603b      	str	r3, [r7, #0]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   1155c:	683b      	ldr	r3, [r7, #0]
   1155e:	f103 0318 	add.w	r3, r3, #24
   11562:	4618      	mov	r0, r3
   11564:	f7fd fe4a 	bl	f1fc <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   11568:	683b      	ldr	r3, [r7, #0]
   1156a:	f103 0304 	add.w	r3, r3, #4
   1156e:	4618      	mov	r0, r3
   11570:	f7fd fe44 	bl	f1fc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   11574:	683b      	ldr	r3, [r7, #0]
   11576:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11578:	f04f 0201 	mov.w	r2, #1
   1157c:	fa02 f203 	lsl.w	r2, r2, r3
   11580:	f243 03ec 	movw	r3, #12524	; 0x30ec
   11584:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11588:	681b      	ldr	r3, [r3, #0]
   1158a:	ea42 0203 	orr.w	r2, r2, r3
   1158e:	f243 03ec 	movw	r3, #12524	; 0x30ec
   11592:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11596:	601a      	str	r2, [r3, #0]
   11598:	683b      	ldr	r3, [r7, #0]
   1159a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1159c:	4613      	mov	r3, r2
   1159e:	ea4f 0383 	mov.w	r3, r3, lsl #2
   115a2:	4413      	add	r3, r2
   115a4:	ea4f 0383 	mov.w	r3, r3, lsl #2
   115a8:	461a      	mov	r2, r3
   115aa:	f243 0310 	movw	r3, #12304	; 0x3010
   115ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
   115b2:	441a      	add	r2, r3
   115b4:	683b      	ldr	r3, [r7, #0]
   115b6:	f103 0304 	add.w	r3, r3, #4
   115ba:	4610      	mov	r0, r2
   115bc:	4619      	mov	r1, r3
   115be:	f7fd fdbf 	bl	f140 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   115c2:	683b      	ldr	r3, [r7, #0]
   115c4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   115c6:	f243 030c 	movw	r3, #12300	; 0x300c
   115ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
   115ce:	681b      	ldr	r3, [r3, #0]
   115d0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   115d2:	429a      	cmp	r2, r3
   115d4:	d306      	bcc.n	115e4 <xTaskResumeAll+0x108>
					{
						xYieldPending = pdTRUE;
   115d6:	f243 03f8 	movw	r3, #12536	; 0x30f8
   115da:	f2c2 0300 	movt	r3, #8192	; 0x2000
   115de:	f04f 0201 	mov.w	r2, #1
   115e2:	601a      	str	r2, [r3, #0]
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   115e4:	f243 03a4 	movw	r3, #12452	; 0x30a4
   115e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   115ec:	681b      	ldr	r3, [r3, #0]
   115ee:	2b00      	cmp	r3, #0
   115f0:	d1ad      	bne.n	1154e <xTaskResumeAll+0x72>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
   115f2:	683b      	ldr	r3, [r7, #0]
   115f4:	2b00      	cmp	r3, #0
   115f6:	d001      	beq.n	115fc <xTaskResumeAll+0x120>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
   115f8:	f000 ff1e 	bl	12438 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
   115fc:	f243 03f4 	movw	r3, #12532	; 0x30f4
   11600:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11604:	681b      	ldr	r3, [r3, #0]
   11606:	60bb      	str	r3, [r7, #8]

					if( uxPendedCounts > ( UBaseType_t ) 0U )
   11608:	68bb      	ldr	r3, [r7, #8]
   1160a:	2b00      	cmp	r3, #0
   1160c:	d019      	beq.n	11642 <xTaskResumeAll+0x166>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
   1160e:	f000 f93b 	bl	11888 <xTaskIncrementTick>
   11612:	4603      	mov	r3, r0
   11614:	2b00      	cmp	r3, #0
   11616:	d006      	beq.n	11626 <xTaskResumeAll+0x14a>
							{
								xYieldPending = pdTRUE;
   11618:	f243 03f8 	movw	r3, #12536	; 0x30f8
   1161c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11620:	f04f 0201 	mov.w	r2, #1
   11624:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
   11626:	68bb      	ldr	r3, [r7, #8]
   11628:	f103 33ff 	add.w	r3, r3, #4294967295
   1162c:	60bb      	str	r3, [r7, #8]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
   1162e:	68bb      	ldr	r3, [r7, #8]
   11630:	2b00      	cmp	r3, #0
   11632:	d1ec      	bne.n	1160e <xTaskResumeAll+0x132>

						uxPendedTicks = 0;
   11634:	f243 03f4 	movw	r3, #12532	; 0x30f4
   11638:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1163c:	f04f 0200 	mov.w	r2, #0
   11640:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
   11642:	f243 03f8 	movw	r3, #12536	; 0x30f8
   11646:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1164a:	681b      	ldr	r3, [r3, #0]
   1164c:	2b00      	cmp	r3, #0
   1164e:	d00d      	beq.n	1166c <xTaskResumeAll+0x190>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
   11650:	f04f 0301 	mov.w	r3, #1
   11654:	607b      	str	r3, [r7, #4]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
   11656:	f64e 5304 	movw	r3, #60676	; 0xed04
   1165a:	f2ce 0300 	movt	r3, #57344	; 0xe000
   1165e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   11662:	601a      	str	r2, [r3, #0]
   11664:	f3bf 8f4f 	dsb	sy
   11668:	f3bf 8f6f 	isb	sy
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
   1166c:	f002 fe3c 	bl	142e8 <vPortExitCritical>

	return xAlreadyYielded;
   11670:	687b      	ldr	r3, [r7, #4]
}
   11672:	4618      	mov	r0, r3
   11674:	f107 0710 	add.w	r7, r7, #16
   11678:	46bd      	mov	sp, r7
   1167a:	bd80      	pop	{r7, pc}

0001167c <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
   1167c:	b480      	push	{r7}
   1167e:	b083      	sub	sp, #12
   11680:	af00      	add	r7, sp, #0
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
   11682:	f243 03e8 	movw	r3, #12520	; 0x30e8
   11686:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1168a:	681b      	ldr	r3, [r3, #0]
   1168c:	607b      	str	r3, [r7, #4]
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
   1168e:	687b      	ldr	r3, [r7, #4]
}
   11690:	4618      	mov	r0, r3
   11692:	f107 070c 	add.w	r7, r7, #12
   11696:	46bd      	mov	sp, r7
   11698:	bc80      	pop	{r7}
   1169a:	4770      	bx	lr

0001169c <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
   1169c:	b580      	push	{r7, lr}
   1169e:	b082      	sub	sp, #8
   116a0:	af00      	add	r7, sp, #0
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   116a2:	f002 fecd 	bl	14440 <vPortValidateInterruptPriority>

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
   116a6:	f04f 0300 	mov.w	r3, #0
   116aa:	607b      	str	r3, [r7, #4]
	{
		xReturn = xTickCount;
   116ac:	f243 03e8 	movw	r3, #12520	; 0x30e8
   116b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   116b4:	681b      	ldr	r3, [r3, #0]
   116b6:	603b      	str	r3, [r7, #0]
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
   116b8:	683b      	ldr	r3, [r7, #0]
}
   116ba:	4618      	mov	r0, r3
   116bc:	f107 0708 	add.w	r7, r7, #8
   116c0:	46bd      	mov	sp, r7
   116c2:	bd80      	pop	{r7, pc}

000116c4 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
   116c4:	b480      	push	{r7}
   116c6:	af00      	add	r7, sp, #0
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
   116c8:	f243 03e4 	movw	r3, #12516	; 0x30e4
   116cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   116d0:	681b      	ldr	r3, [r3, #0]
}
   116d2:	4618      	mov	r0, r3
   116d4:	46bd      	mov	sp, r7
   116d6:	bc80      	pop	{r7}
   116d8:	4770      	bx	lr
   116da:	bf00      	nop

000116dc <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
   116dc:	b480      	push	{r7}
   116de:	b085      	sub	sp, #20
   116e0:	af00      	add	r7, sp, #0
   116e2:	6078      	str	r0, [r7, #4]
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
   116e4:	687b      	ldr	r3, [r7, #4]
   116e6:	2b00      	cmp	r3, #0
   116e8:	d105      	bne.n	116f6 <pcTaskGetName+0x1a>
   116ea:	f243 030c 	movw	r3, #12300	; 0x300c
   116ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
   116f2:	681b      	ldr	r3, [r3, #0]
   116f4:	e000      	b.n	116f8 <pcTaskGetName+0x1c>
   116f6:	687b      	ldr	r3, [r7, #4]
   116f8:	60bb      	str	r3, [r7, #8]
	configASSERT( pxTCB );
   116fa:	68bb      	ldr	r3, [r7, #8]
   116fc:	2b00      	cmp	r3, #0
   116fe:	d109      	bne.n	11714 <pcTaskGetName+0x38>
   11700:	f04f 0328 	mov.w	r3, #40	; 0x28
   11704:	f383 8811 	msr	BASEPRI, r3
   11708:	f3bf 8f6f 	isb	sy
   1170c:	f3bf 8f4f 	dsb	sy
   11710:	60fb      	str	r3, [r7, #12]
   11712:	e7fe      	b.n	11712 <pcTaskGetName+0x36>
	return &( pxTCB->pcTaskName[ 0 ] );
   11714:	68bb      	ldr	r3, [r7, #8]
   11716:	f103 0334 	add.w	r3, r3, #52	; 0x34
}
   1171a:	4618      	mov	r0, r3
   1171c:	f107 0714 	add.w	r7, r7, #20
   11720:	46bd      	mov	sp, r7
   11722:	bc80      	pop	{r7}
   11724:	4770      	bx	lr
   11726:	bf00      	nop

00011728 <uxTaskGetSystemState>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
	{
   11728:	b580      	push	{r7, lr}
   1172a:	b086      	sub	sp, #24
   1172c:	af00      	add	r7, sp, #0
   1172e:	60f8      	str	r0, [r7, #12]
   11730:	60b9      	str	r1, [r7, #8]
   11732:	607a      	str	r2, [r7, #4]
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
   11734:	f04f 0300 	mov.w	r3, #0
   11738:	613b      	str	r3, [r7, #16]
   1173a:	f04f 0305 	mov.w	r3, #5
   1173e:	617b      	str	r3, [r7, #20]

		vTaskSuspendAll();
   11740:	f7ff feba 	bl	114b8 <vTaskSuspendAll>
		{
			/* Is there a space in the array for each task in the system? */
			if( uxArraySize >= uxCurrentNumberOfTasks )
   11744:	f243 03e4 	movw	r3, #12516	; 0x30e4
   11748:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1174c:	681b      	ldr	r3, [r3, #0]
   1174e:	68ba      	ldr	r2, [r7, #8]
   11750:	429a      	cmp	r2, r3
   11752:	f0c0 8091 	bcc.w	11878 <uxTaskGetSystemState+0x150>
			{
				/* Fill in an TaskStatus_t structure with information on each
				task in the Ready state. */
				do
				{
					uxQueue--;
   11756:	697b      	ldr	r3, [r7, #20]
   11758:	f103 33ff 	add.w	r3, r3, #4294967295
   1175c:	617b      	str	r3, [r7, #20]
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
   1175e:	693a      	ldr	r2, [r7, #16]
   11760:	4613      	mov	r3, r2
   11762:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   11766:	4413      	add	r3, r2
   11768:	ea4f 0383 	mov.w	r3, r3, lsl #2
   1176c:	461a      	mov	r2, r3
   1176e:	68fb      	ldr	r3, [r7, #12]
   11770:	eb02 0103 	add.w	r1, r2, r3
   11774:	697a      	ldr	r2, [r7, #20]
   11776:	4613      	mov	r3, r2
   11778:	ea4f 0383 	mov.w	r3, r3, lsl #2
   1177c:	4413      	add	r3, r2
   1177e:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11782:	461a      	mov	r2, r3
   11784:	f243 0310 	movw	r3, #12304	; 0x3010
   11788:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1178c:	4413      	add	r3, r2
   1178e:	4608      	mov	r0, r1
   11790:	4619      	mov	r1, r3
   11792:	f04f 0201 	mov.w	r2, #1
   11796:	f000 fdc3 	bl	12320 <prvListTasksWithinSingleList>
   1179a:	4603      	mov	r3, r0
   1179c:	693a      	ldr	r2, [r7, #16]
   1179e:	4413      	add	r3, r2
   117a0:	613b      	str	r3, [r7, #16]

				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   117a2:	697b      	ldr	r3, [r7, #20]
   117a4:	2b00      	cmp	r3, #0
   117a6:	d1d6      	bne.n	11756 <uxTaskGetSystemState+0x2e>

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
   117a8:	693a      	ldr	r2, [r7, #16]
   117aa:	4613      	mov	r3, r2
   117ac:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   117b0:	4413      	add	r3, r2
   117b2:	ea4f 0383 	mov.w	r3, r3, lsl #2
   117b6:	461a      	mov	r2, r3
   117b8:	68fb      	ldr	r3, [r7, #12]
   117ba:	441a      	add	r2, r3
   117bc:	f243 039c 	movw	r3, #12444	; 0x309c
   117c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   117c4:	681b      	ldr	r3, [r3, #0]
   117c6:	4610      	mov	r0, r2
   117c8:	4619      	mov	r1, r3
   117ca:	f04f 0202 	mov.w	r2, #2
   117ce:	f000 fda7 	bl	12320 <prvListTasksWithinSingleList>
   117d2:	4603      	mov	r3, r0
   117d4:	693a      	ldr	r2, [r7, #16]
   117d6:	4413      	add	r3, r2
   117d8:	613b      	str	r3, [r7, #16]
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
   117da:	693a      	ldr	r2, [r7, #16]
   117dc:	4613      	mov	r3, r2
   117de:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   117e2:	4413      	add	r3, r2
   117e4:	ea4f 0383 	mov.w	r3, r3, lsl #2
   117e8:	461a      	mov	r2, r3
   117ea:	68fb      	ldr	r3, [r7, #12]
   117ec:	441a      	add	r2, r3
   117ee:	f243 03a0 	movw	r3, #12448	; 0x30a0
   117f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   117f6:	681b      	ldr	r3, [r3, #0]
   117f8:	4610      	mov	r0, r2
   117fa:	4619      	mov	r1, r3
   117fc:	f04f 0202 	mov.w	r2, #2
   11800:	f000 fd8e 	bl	12320 <prvListTasksWithinSingleList>
   11804:	4603      	mov	r3, r0
   11806:	693a      	ldr	r2, [r7, #16]
   11808:	4413      	add	r3, r2
   1180a:	613b      	str	r3, [r7, #16]

				#if( INCLUDE_vTaskDelete == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task that has been deleted but not yet cleaned up. */
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
   1180c:	693a      	ldr	r2, [r7, #16]
   1180e:	4613      	mov	r3, r2
   11810:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   11814:	4413      	add	r3, r2
   11816:	ea4f 0383 	mov.w	r3, r3, lsl #2
   1181a:	461a      	mov	r2, r3
   1181c:	68fb      	ldr	r3, [r7, #12]
   1181e:	4413      	add	r3, r2
   11820:	4618      	mov	r0, r3
   11822:	f243 01b8 	movw	r1, #12472	; 0x30b8
   11826:	f2c2 0100 	movt	r1, #8192	; 0x2000
   1182a:	f04f 0204 	mov.w	r2, #4
   1182e:	f000 fd77 	bl	12320 <prvListTasksWithinSingleList>
   11832:	4603      	mov	r3, r0
   11834:	693a      	ldr	r2, [r7, #16]
   11836:	4413      	add	r3, r2
   11838:	613b      	str	r3, [r7, #16]

				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task in the Suspended state. */
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
   1183a:	693a      	ldr	r2, [r7, #16]
   1183c:	4613      	mov	r3, r2
   1183e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   11842:	4413      	add	r3, r2
   11844:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11848:	461a      	mov	r2, r3
   1184a:	68fb      	ldr	r3, [r7, #12]
   1184c:	4413      	add	r3, r2
   1184e:	4618      	mov	r0, r3
   11850:	f243 01d0 	movw	r1, #12496	; 0x30d0
   11854:	f2c2 0100 	movt	r1, #8192	; 0x2000
   11858:	f04f 0203 	mov.w	r2, #3
   1185c:	f000 fd60 	bl	12320 <prvListTasksWithinSingleList>
   11860:	4603      	mov	r3, r0
   11862:	693a      	ldr	r2, [r7, #16]
   11864:	4413      	add	r3, r2
   11866:	613b      	str	r3, [r7, #16]
				}
				#endif

				#if ( configGENERATE_RUN_TIME_STATS == 1)
				{
					if( pulTotalRunTime != NULL )
   11868:	687b      	ldr	r3, [r7, #4]
   1186a:	2b00      	cmp	r3, #0
   1186c:	d004      	beq.n	11878 <uxTaskGetSystemState+0x150>
					{
						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
						#else
							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   1186e:	f7ef f9d1 	bl	c14 <ulGetRunTimeCounterValue>
   11872:	4602      	mov	r2, r0
   11874:	687b      	ldr	r3, [r7, #4]
   11876:	601a      	str	r2, [r3, #0]
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		( void ) xTaskResumeAll();
   11878:	f7ff fe30 	bl	114dc <xTaskResumeAll>

		return uxTask;
   1187c:	693b      	ldr	r3, [r7, #16]
	}
   1187e:	4618      	mov	r0, r3
   11880:	f107 0718 	add.w	r7, r7, #24
   11884:	46bd      	mov	sp, r7
   11886:	bd80      	pop	{r7, pc}

00011888 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
   11888:	b580      	push	{r7, lr}
   1188a:	b086      	sub	sp, #24
   1188c:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
   1188e:	f04f 0300 	mov.w	r3, #0
   11892:	60bb      	str	r3, [r7, #8]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   11894:	f243 130c 	movw	r3, #12556	; 0x310c
   11898:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1189c:	681b      	ldr	r3, [r3, #0]
   1189e:	2b00      	cmp	r3, #0
   118a0:	f040 80d5 	bne.w	11a4e <xTaskIncrementTick+0x1c6>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
   118a4:	f243 03e8 	movw	r3, #12520	; 0x30e8
   118a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   118ac:	681b      	ldr	r3, [r3, #0]
   118ae:	f103 0301 	add.w	r3, r3, #1
   118b2:	60fb      	str	r3, [r7, #12]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
   118b4:	f243 03e8 	movw	r3, #12520	; 0x30e8
   118b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   118bc:	68fa      	ldr	r2, [r7, #12]
   118be:	601a      	str	r2, [r3, #0]

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
   118c0:	68fb      	ldr	r3, [r7, #12]
   118c2:	2b00      	cmp	r3, #0
   118c4:	d135      	bne.n	11932 <xTaskIncrementTick+0xaa>
		{
			taskSWITCH_DELAYED_LISTS();
   118c6:	f243 039c 	movw	r3, #12444	; 0x309c
   118ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
   118ce:	681b      	ldr	r3, [r3, #0]
   118d0:	681b      	ldr	r3, [r3, #0]
   118d2:	2b00      	cmp	r3, #0
   118d4:	d009      	beq.n	118ea <xTaskIncrementTick+0x62>
   118d6:	f04f 0328 	mov.w	r3, #40	; 0x28
   118da:	f383 8811 	msr	BASEPRI, r3
   118de:	f3bf 8f6f 	isb	sy
   118e2:	f3bf 8f4f 	dsb	sy
   118e6:	617b      	str	r3, [r7, #20]
   118e8:	e7fe      	b.n	118e8 <xTaskIncrementTick+0x60>
   118ea:	f243 039c 	movw	r3, #12444	; 0x309c
   118ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
   118f2:	681b      	ldr	r3, [r3, #0]
   118f4:	613b      	str	r3, [r7, #16]
   118f6:	f243 03a0 	movw	r3, #12448	; 0x30a0
   118fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
   118fe:	681a      	ldr	r2, [r3, #0]
   11900:	f243 039c 	movw	r3, #12444	; 0x309c
   11904:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11908:	601a      	str	r2, [r3, #0]
   1190a:	f243 03a0 	movw	r3, #12448	; 0x30a0
   1190e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11912:	693a      	ldr	r2, [r7, #16]
   11914:	601a      	str	r2, [r3, #0]
   11916:	f243 03fc 	movw	r3, #12540	; 0x30fc
   1191a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1191e:	681b      	ldr	r3, [r3, #0]
   11920:	f103 0201 	add.w	r2, r3, #1
   11924:	f243 03fc 	movw	r3, #12540	; 0x30fc
   11928:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1192c:	601a      	str	r2, [r3, #0]
   1192e:	f000 fd83 	bl	12438 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
   11932:	f243 1304 	movw	r3, #12548	; 0x3104
   11936:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1193a:	681b      	ldr	r3, [r3, #0]
   1193c:	68fa      	ldr	r2, [r7, #12]
   1193e:	429a      	cmp	r2, r3
   11940:	d36c      	bcc.n	11a1c <xTaskIncrementTick+0x194>
   11942:	e000      	b.n	11946 <xTaskIncrementTick+0xbe>
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
   11944:	bf00      	nop
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   11946:	f243 039c 	movw	r3, #12444	; 0x309c
   1194a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1194e:	681b      	ldr	r3, [r3, #0]
   11950:	681b      	ldr	r3, [r3, #0]
   11952:	2b00      	cmp	r3, #0
   11954:	d107      	bne.n	11966 <xTaskIncrementTick+0xde>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   11956:	f243 1304 	movw	r3, #12548	; 0x3104
   1195a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1195e:	f04f 32ff 	mov.w	r2, #4294967295
   11962:	601a      	str	r2, [r3, #0]
					break;
   11964:	e05a      	b.n	11a1c <xTaskIncrementTick+0x194>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   11966:	f243 039c 	movw	r3, #12444	; 0x309c
   1196a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1196e:	681b      	ldr	r3, [r3, #0]
   11970:	68db      	ldr	r3, [r3, #12]
   11972:	68db      	ldr	r3, [r3, #12]
   11974:	603b      	str	r3, [r7, #0]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
   11976:	683b      	ldr	r3, [r7, #0]
   11978:	685b      	ldr	r3, [r3, #4]
   1197a:	607b      	str	r3, [r7, #4]

					if( xConstTickCount < xItemValue )
   1197c:	68fa      	ldr	r2, [r7, #12]
   1197e:	687b      	ldr	r3, [r7, #4]
   11980:	429a      	cmp	r2, r3
   11982:	d206      	bcs.n	11992 <xTaskIncrementTick+0x10a>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
   11984:	f243 1304 	movw	r3, #12548	; 0x3104
   11988:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1198c:	687a      	ldr	r2, [r7, #4]
   1198e:	601a      	str	r2, [r3, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
   11990:	e044      	b.n	11a1c <xTaskIncrementTick+0x194>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   11992:	683b      	ldr	r3, [r7, #0]
   11994:	f103 0304 	add.w	r3, r3, #4
   11998:	4618      	mov	r0, r3
   1199a:	f7fd fc2f 	bl	f1fc <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   1199e:	683b      	ldr	r3, [r7, #0]
   119a0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   119a2:	2b00      	cmp	r3, #0
   119a4:	d005      	beq.n	119b2 <xTaskIncrementTick+0x12a>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   119a6:	683b      	ldr	r3, [r7, #0]
   119a8:	f103 0318 	add.w	r3, r3, #24
   119ac:	4618      	mov	r0, r3
   119ae:	f7fd fc25 	bl	f1fc <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
   119b2:	683b      	ldr	r3, [r7, #0]
   119b4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   119b6:	f04f 0201 	mov.w	r2, #1
   119ba:	fa02 f203 	lsl.w	r2, r2, r3
   119be:	f243 03ec 	movw	r3, #12524	; 0x30ec
   119c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   119c6:	681b      	ldr	r3, [r3, #0]
   119c8:	ea42 0203 	orr.w	r2, r2, r3
   119cc:	f243 03ec 	movw	r3, #12524	; 0x30ec
   119d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   119d4:	601a      	str	r2, [r3, #0]
   119d6:	683b      	ldr	r3, [r7, #0]
   119d8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   119da:	4613      	mov	r3, r2
   119dc:	ea4f 0383 	mov.w	r3, r3, lsl #2
   119e0:	4413      	add	r3, r2
   119e2:	ea4f 0383 	mov.w	r3, r3, lsl #2
   119e6:	461a      	mov	r2, r3
   119e8:	f243 0310 	movw	r3, #12304	; 0x3010
   119ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
   119f0:	441a      	add	r2, r3
   119f2:	683b      	ldr	r3, [r7, #0]
   119f4:	f103 0304 	add.w	r3, r3, #4
   119f8:	4610      	mov	r0, r2
   119fa:	4619      	mov	r1, r3
   119fc:	f7fd fba0 	bl	f140 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   11a00:	683b      	ldr	r3, [r7, #0]
   11a02:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11a04:	f243 030c 	movw	r3, #12300	; 0x300c
   11a08:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11a0c:	681b      	ldr	r3, [r3, #0]
   11a0e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11a10:	429a      	cmp	r2, r3
   11a12:	d397      	bcc.n	11944 <xTaskIncrementTick+0xbc>
						{
							xSwitchRequired = pdTRUE;
   11a14:	f04f 0301 	mov.w	r3, #1
   11a18:	60bb      	str	r3, [r7, #8]
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
   11a1a:	e794      	b.n	11946 <xTaskIncrementTick+0xbe>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   11a1c:	f243 030c 	movw	r3, #12300	; 0x300c
   11a20:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11a24:	681b      	ldr	r3, [r3, #0]
   11a26:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11a28:	4613      	mov	r3, r2
   11a2a:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11a2e:	4413      	add	r3, r2
   11a30:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11a34:	461a      	mov	r2, r3
   11a36:	f243 0310 	movw	r3, #12304	; 0x3010
   11a3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11a3e:	4413      	add	r3, r2
   11a40:	681b      	ldr	r3, [r3, #0]
   11a42:	2b01      	cmp	r3, #1
   11a44:	d910      	bls.n	11a68 <xTaskIncrementTick+0x1e0>
			{
				xSwitchRequired = pdTRUE;
   11a46:	f04f 0301 	mov.w	r3, #1
   11a4a:	60bb      	str	r3, [r7, #8]
   11a4c:	e00d      	b.n	11a6a <xTaskIncrementTick+0x1e2>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
   11a4e:	f243 03f4 	movw	r3, #12532	; 0x30f4
   11a52:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11a56:	681b      	ldr	r3, [r3, #0]
   11a58:	f103 0201 	add.w	r2, r3, #1
   11a5c:	f243 03f4 	movw	r3, #12532	; 0x30f4
   11a60:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11a64:	601a      	str	r2, [r3, #0]
   11a66:	e000      	b.n	11a6a <xTaskIncrementTick+0x1e2>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
   11a68:	bf00      	nop
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
   11a6a:	f243 03f8 	movw	r3, #12536	; 0x30f8
   11a6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11a72:	681b      	ldr	r3, [r3, #0]
   11a74:	2b00      	cmp	r3, #0
   11a76:	d002      	beq.n	11a7e <xTaskIncrementTick+0x1f6>
		{
			xSwitchRequired = pdTRUE;
   11a78:	f04f 0301 	mov.w	r3, #1
   11a7c:	60bb      	str	r3, [r7, #8]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
   11a7e:	68bb      	ldr	r3, [r7, #8]
}
   11a80:	4618      	mov	r0, r3
   11a82:	f107 0718 	add.w	r7, r7, #24
   11a86:	46bd      	mov	sp, r7
   11a88:	bd80      	pop	{r7, pc}
   11a8a:	bf00      	nop

00011a8c <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
   11a8c:	b580      	push	{r7, lr}
   11a8e:	b088      	sub	sp, #32
   11a90:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   11a92:	f243 130c 	movw	r3, #12556	; 0x310c
   11a96:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11a9a:	681b      	ldr	r3, [r3, #0]
   11a9c:	2b00      	cmp	r3, #0
   11a9e:	d007      	beq.n	11ab0 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
   11aa0:	f243 03f8 	movw	r3, #12536	; 0x30f8
   11aa4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11aa8:	f04f 0201 	mov.w	r2, #1
   11aac:	601a      	str	r2, [r3, #0]
   11aae:	e0bc      	b.n	11c2a <vTaskSwitchContext+0x19e>
	}
	else
	{
		xYieldPending = pdFALSE;
   11ab0:	f243 03f8 	movw	r3, #12536	; 0x30f8
   11ab4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11ab8:	f04f 0200 	mov.w	r2, #0
   11abc:	601a      	str	r2, [r3, #0]
		#if ( configGENERATE_RUN_TIME_STATS == 1 )
		{
				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
				#else
					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   11abe:	f7ef f8a9 	bl	c14 <ulGetRunTimeCounterValue>
   11ac2:	4602      	mov	r2, r0
   11ac4:	f243 1314 	movw	r3, #12564	; 0x3114
   11ac8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11acc:	601a      	str	r2, [r3, #0]
				stored in ulTaskSwitchedInTime.  Note that there is no overflow
				protection here so count values are only valid until the timer
				overflows.  The guard against negative values is to protect
				against suspect run time stat counter implementations - which
				are provided by the application, not the kernel. */
				if( ulTotalRunTime > ulTaskSwitchedInTime )
   11ace:	f243 1314 	movw	r3, #12564	; 0x3114
   11ad2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11ad6:	681a      	ldr	r2, [r3, #0]
   11ad8:	f243 1310 	movw	r3, #12560	; 0x3110
   11adc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11ae0:	681b      	ldr	r3, [r3, #0]
   11ae2:	429a      	cmp	r2, r3
   11ae4:	d913      	bls.n	11b0e <vTaskSwitchContext+0x82>
				{
					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
   11ae6:	f243 030c 	movw	r3, #12300	; 0x300c
   11aea:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11aee:	681a      	ldr	r2, [r3, #0]
   11af0:	6d11      	ldr	r1, [r2, #80]	; 0x50
   11af2:	f243 1314 	movw	r3, #12564	; 0x3114
   11af6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11afa:	6818      	ldr	r0, [r3, #0]
   11afc:	f243 1310 	movw	r3, #12560	; 0x3110
   11b00:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11b04:	681b      	ldr	r3, [r3, #0]
   11b06:	ebc3 0300 	rsb	r3, r3, r0
   11b0a:	440b      	add	r3, r1
   11b0c:	6513      	str	r3, [r2, #80]	; 0x50
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				ulTaskSwitchedInTime = ulTotalRunTime;
   11b0e:	f243 1314 	movw	r3, #12564	; 0x3114
   11b12:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11b16:	681a      	ldr	r2, [r3, #0]
   11b18:	f243 1310 	movw	r3, #12560	; 0x3110
   11b1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11b20:	601a      	str	r2, [r3, #0]
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();
   11b22:	f243 030c 	movw	r3, #12300	; 0x300c
   11b26:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11b2a:	681b      	ldr	r3, [r3, #0]
   11b2c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   11b2e:	607b      	str	r3, [r7, #4]
   11b30:	f04f 33a5 	mov.w	r3, #2779096485	; 0xa5a5a5a5
   11b34:	60bb      	str	r3, [r7, #8]
   11b36:	687b      	ldr	r3, [r7, #4]
   11b38:	681a      	ldr	r2, [r3, #0]
   11b3a:	68bb      	ldr	r3, [r7, #8]
   11b3c:	429a      	cmp	r2, r3
   11b3e:	d114      	bne.n	11b6a <vTaskSwitchContext+0xde>
   11b40:	687b      	ldr	r3, [r7, #4]
   11b42:	f103 0304 	add.w	r3, r3, #4
   11b46:	681a      	ldr	r2, [r3, #0]
   11b48:	68bb      	ldr	r3, [r7, #8]
   11b4a:	429a      	cmp	r2, r3
   11b4c:	d10d      	bne.n	11b6a <vTaskSwitchContext+0xde>
   11b4e:	687b      	ldr	r3, [r7, #4]
   11b50:	f103 0308 	add.w	r3, r3, #8
   11b54:	681a      	ldr	r2, [r3, #0]
   11b56:	68bb      	ldr	r3, [r7, #8]
   11b58:	429a      	cmp	r2, r3
   11b5a:	d106      	bne.n	11b6a <vTaskSwitchContext+0xde>
   11b5c:	687b      	ldr	r3, [r7, #4]
   11b5e:	f103 030c 	add.w	r3, r3, #12
   11b62:	681a      	ldr	r2, [r3, #0]
   11b64:	68bb      	ldr	r3, [r7, #8]
   11b66:	429a      	cmp	r2, r3
   11b68:	d00f      	beq.n	11b8a <vTaskSwitchContext+0xfe>
   11b6a:	f243 030c 	movw	r3, #12300	; 0x300c
   11b6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11b72:	681a      	ldr	r2, [r3, #0]
   11b74:	f243 030c 	movw	r3, #12300	; 0x300c
   11b78:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11b7c:	681b      	ldr	r3, [r3, #0]
   11b7e:	f103 0334 	add.w	r3, r3, #52	; 0x34
   11b82:	4610      	mov	r0, r2
   11b84:	4619      	mov	r1, r3
   11b86:	f7ee fffd 	bl	b84 <vApplicationStackOverflowHook>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   11b8a:	f243 03ec 	movw	r3, #12524	; 0x30ec
   11b8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11b92:	681b      	ldr	r3, [r3, #0]
   11b94:	617b      	str	r3, [r7, #20]
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
	{
	uint8_t ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
   11b96:	697b      	ldr	r3, [r7, #20]
   11b98:	fab3 f383 	clz	r3, r3
   11b9c:	76fb      	strb	r3, [r7, #27]
		return ucReturn;
   11b9e:	7efb      	ldrb	r3, [r7, #27]
   11ba0:	f1c3 031f 	rsb	r3, r3, #31
   11ba4:	60fb      	str	r3, [r7, #12]
   11ba6:	68fa      	ldr	r2, [r7, #12]
   11ba8:	4613      	mov	r3, r2
   11baa:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11bae:	4413      	add	r3, r2
   11bb0:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11bb4:	461a      	mov	r2, r3
   11bb6:	f243 0310 	movw	r3, #12304	; 0x3010
   11bba:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11bbe:	4413      	add	r3, r2
   11bc0:	681b      	ldr	r3, [r3, #0]
   11bc2:	2b00      	cmp	r3, #0
   11bc4:	d109      	bne.n	11bda <vTaskSwitchContext+0x14e>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   11bc6:	f04f 0328 	mov.w	r3, #40	; 0x28
   11bca:	f383 8811 	msr	BASEPRI, r3
   11bce:	f3bf 8f6f 	isb	sy
   11bd2:	f3bf 8f4f 	dsb	sy
   11bd6:	61fb      	str	r3, [r7, #28]
   11bd8:	e7fe      	b.n	11bd8 <vTaskSwitchContext+0x14c>
   11bda:	68fa      	ldr	r2, [r7, #12]
   11bdc:	4613      	mov	r3, r2
   11bde:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11be2:	4413      	add	r3, r2
   11be4:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11be8:	461a      	mov	r2, r3
   11bea:	f243 0310 	movw	r3, #12304	; 0x3010
   11bee:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11bf2:	4413      	add	r3, r2
   11bf4:	613b      	str	r3, [r7, #16]
   11bf6:	693b      	ldr	r3, [r7, #16]
   11bf8:	685b      	ldr	r3, [r3, #4]
   11bfa:	685a      	ldr	r2, [r3, #4]
   11bfc:	693b      	ldr	r3, [r7, #16]
   11bfe:	605a      	str	r2, [r3, #4]
   11c00:	693b      	ldr	r3, [r7, #16]
   11c02:	685a      	ldr	r2, [r3, #4]
   11c04:	693b      	ldr	r3, [r7, #16]
   11c06:	f103 0308 	add.w	r3, r3, #8
   11c0a:	429a      	cmp	r2, r3
   11c0c:	d104      	bne.n	11c18 <vTaskSwitchContext+0x18c>
   11c0e:	693b      	ldr	r3, [r7, #16]
   11c10:	685b      	ldr	r3, [r3, #4]
   11c12:	685a      	ldr	r2, [r3, #4]
   11c14:	693b      	ldr	r3, [r7, #16]
   11c16:	605a      	str	r2, [r3, #4]
   11c18:	693b      	ldr	r3, [r7, #16]
   11c1a:	685b      	ldr	r3, [r3, #4]
   11c1c:	68db      	ldr	r3, [r3, #12]
   11c1e:	461a      	mov	r2, r3
   11c20:	f243 030c 	movw	r3, #12300	; 0x300c
   11c24:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11c28:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
   11c2a:	f107 0720 	add.w	r7, r7, #32
   11c2e:	46bd      	mov	sp, r7
   11c30:	bd80      	pop	{r7, pc}
   11c32:	bf00      	nop

00011c34 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
   11c34:	b580      	push	{r7, lr}
   11c36:	b084      	sub	sp, #16
   11c38:	af00      	add	r7, sp, #0
   11c3a:	6078      	str	r0, [r7, #4]
   11c3c:	6039      	str	r1, [r7, #0]
	configASSERT( pxEventList );
   11c3e:	687b      	ldr	r3, [r7, #4]
   11c40:	2b00      	cmp	r3, #0
   11c42:	d109      	bne.n	11c58 <vTaskPlaceOnEventList+0x24>
   11c44:	f04f 0328 	mov.w	r3, #40	; 0x28
   11c48:	f383 8811 	msr	BASEPRI, r3
   11c4c:	f3bf 8f6f 	isb	sy
   11c50:	f3bf 8f4f 	dsb	sy
   11c54:	60fb      	str	r3, [r7, #12]
   11c56:	e7fe      	b.n	11c56 <vTaskPlaceOnEventList+0x22>

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   11c58:	f243 030c 	movw	r3, #12300	; 0x300c
   11c5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11c60:	681b      	ldr	r3, [r3, #0]
   11c62:	f103 0318 	add.w	r3, r3, #24
   11c66:	6878      	ldr	r0, [r7, #4]
   11c68:	4619      	mov	r1, r3
   11c6a:	f7fd fa8d 	bl	f188 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   11c6e:	6838      	ldr	r0, [r7, #0]
   11c70:	f04f 0101 	mov.w	r1, #1
   11c74:	f001 fb6a 	bl	1334c <prvAddCurrentTaskToDelayedList>
}
   11c78:	f107 0710 	add.w	r7, r7, #16
   11c7c:	46bd      	mov	sp, r7
   11c7e:	bd80      	pop	{r7, pc}

00011c80 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
   11c80:	b580      	push	{r7, lr}
   11c82:	b086      	sub	sp, #24
   11c84:	af00      	add	r7, sp, #0
   11c86:	60f8      	str	r0, [r7, #12]
   11c88:	60b9      	str	r1, [r7, #8]
   11c8a:	607a      	str	r2, [r7, #4]
	configASSERT( pxEventList );
   11c8c:	68fb      	ldr	r3, [r7, #12]
   11c8e:	2b00      	cmp	r3, #0
   11c90:	d109      	bne.n	11ca6 <vTaskPlaceOnUnorderedEventList+0x26>
   11c92:	f04f 0328 	mov.w	r3, #40	; 0x28
   11c96:	f383 8811 	msr	BASEPRI, r3
   11c9a:	f3bf 8f6f 	isb	sy
   11c9e:	f3bf 8f4f 	dsb	sy
   11ca2:	613b      	str	r3, [r7, #16]
   11ca4:	e7fe      	b.n	11ca4 <vTaskPlaceOnUnorderedEventList+0x24>

	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event groups implementation. */
	configASSERT( uxSchedulerSuspended != 0 );
   11ca6:	f243 130c 	movw	r3, #12556	; 0x310c
   11caa:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11cae:	681b      	ldr	r3, [r3, #0]
   11cb0:	2b00      	cmp	r3, #0
   11cb2:	d109      	bne.n	11cc8 <vTaskPlaceOnUnorderedEventList+0x48>
   11cb4:	f04f 0328 	mov.w	r3, #40	; 0x28
   11cb8:	f383 8811 	msr	BASEPRI, r3
   11cbc:	f3bf 8f6f 	isb	sy
   11cc0:	f3bf 8f4f 	dsb	sy
   11cc4:	617b      	str	r3, [r7, #20]
   11cc6:	e7fe      	b.n	11cc6 <vTaskPlaceOnUnorderedEventList+0x46>

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   11cc8:	f243 030c 	movw	r3, #12300	; 0x300c
   11ccc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11cd0:	681b      	ldr	r3, [r3, #0]
   11cd2:	68ba      	ldr	r2, [r7, #8]
   11cd4:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
   11cd8:	619a      	str	r2, [r3, #24]
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   11cda:	f243 030c 	movw	r3, #12300	; 0x300c
   11cde:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11ce2:	681b      	ldr	r3, [r3, #0]
   11ce4:	f103 0318 	add.w	r3, r3, #24
   11ce8:	68f8      	ldr	r0, [r7, #12]
   11cea:	4619      	mov	r1, r3
   11cec:	f7fd fa28 	bl	f140 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   11cf0:	6878      	ldr	r0, [r7, #4]
   11cf2:	f04f 0101 	mov.w	r1, #1
   11cf6:	f001 fb29 	bl	1334c <prvAddCurrentTaskToDelayedList>
}
   11cfa:	f107 0718 	add.w	r7, r7, #24
   11cfe:	46bd      	mov	sp, r7
   11d00:	bd80      	pop	{r7, pc}
   11d02:	bf00      	nop

00011d04 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if( configUSE_TIMERS == 1 )

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
   11d04:	b580      	push	{r7, lr}
   11d06:	b086      	sub	sp, #24
   11d08:	af00      	add	r7, sp, #0
   11d0a:	60f8      	str	r0, [r7, #12]
   11d0c:	60b9      	str	r1, [r7, #8]
   11d0e:	607a      	str	r2, [r7, #4]
		configASSERT( pxEventList );
   11d10:	68fb      	ldr	r3, [r7, #12]
   11d12:	2b00      	cmp	r3, #0
   11d14:	d109      	bne.n	11d2a <vTaskPlaceOnEventListRestricted+0x26>
   11d16:	f04f 0328 	mov.w	r3, #40	; 0x28
   11d1a:	f383 8811 	msr	BASEPRI, r3
   11d1e:	f3bf 8f6f 	isb	sy
   11d22:	f3bf 8f4f 	dsb	sy
   11d26:	617b      	str	r3, [r7, #20]
   11d28:	e7fe      	b.n	11d28 <vTaskPlaceOnEventListRestricted+0x24>

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   11d2a:	f243 030c 	movw	r3, #12300	; 0x300c
   11d2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11d32:	681b      	ldr	r3, [r3, #0]
   11d34:	f103 0318 	add.w	r3, r3, #24
   11d38:	68f8      	ldr	r0, [r7, #12]
   11d3a:	4619      	mov	r1, r3
   11d3c:	f7fd fa00 	bl	f140 <vListInsertEnd>

		/* If the task should block indefinitely then set the block time to a
		value that will be recognised as an indefinite delay inside the
		prvAddCurrentTaskToDelayedList() function. */
		if( xWaitIndefinitely != pdFALSE )
   11d40:	687b      	ldr	r3, [r7, #4]
   11d42:	2b00      	cmp	r3, #0
   11d44:	d002      	beq.n	11d4c <vTaskPlaceOnEventListRestricted+0x48>
		{
			xTicksToWait = portMAX_DELAY;
   11d46:	f04f 33ff 	mov.w	r3, #4294967295
   11d4a:	60bb      	str	r3, [r7, #8]
		}

		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
   11d4c:	68b8      	ldr	r0, [r7, #8]
   11d4e:	6879      	ldr	r1, [r7, #4]
   11d50:	f001 fafc 	bl	1334c <prvAddCurrentTaskToDelayedList>
	}
   11d54:	f107 0718 	add.w	r7, r7, #24
   11d58:	46bd      	mov	sp, r7
   11d5a:	bd80      	pop	{r7, pc}

00011d5c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
   11d5c:	b580      	push	{r7, lr}
   11d5e:	b086      	sub	sp, #24
   11d60:	af00      	add	r7, sp, #0
   11d62:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   11d64:	687b      	ldr	r3, [r7, #4]
   11d66:	68db      	ldr	r3, [r3, #12]
   11d68:	68db      	ldr	r3, [r3, #12]
   11d6a:	60fb      	str	r3, [r7, #12]
	configASSERT( pxUnblockedTCB );
   11d6c:	68fb      	ldr	r3, [r7, #12]
   11d6e:	2b00      	cmp	r3, #0
   11d70:	d109      	bne.n	11d86 <xTaskRemoveFromEventList+0x2a>
   11d72:	f04f 0328 	mov.w	r3, #40	; 0x28
   11d76:	f383 8811 	msr	BASEPRI, r3
   11d7a:	f3bf 8f6f 	isb	sy
   11d7e:	f3bf 8f4f 	dsb	sy
   11d82:	617b      	str	r3, [r7, #20]
   11d84:	e7fe      	b.n	11d84 <xTaskRemoveFromEventList+0x28>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   11d86:	68fb      	ldr	r3, [r7, #12]
   11d88:	f103 0318 	add.w	r3, r3, #24
   11d8c:	4618      	mov	r0, r3
   11d8e:	f7fd fa35 	bl	f1fc <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   11d92:	f243 130c 	movw	r3, #12556	; 0x310c
   11d96:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11d9a:	681b      	ldr	r3, [r3, #0]
   11d9c:	2b00      	cmp	r3, #0
   11d9e:	d12d      	bne.n	11dfc <xTaskRemoveFromEventList+0xa0>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   11da0:	68fb      	ldr	r3, [r7, #12]
   11da2:	f103 0304 	add.w	r3, r3, #4
   11da6:	4618      	mov	r0, r3
   11da8:	f7fd fa28 	bl	f1fc <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
   11dac:	68fb      	ldr	r3, [r7, #12]
   11dae:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11db0:	f04f 0201 	mov.w	r2, #1
   11db4:	fa02 f203 	lsl.w	r2, r2, r3
   11db8:	f243 03ec 	movw	r3, #12524	; 0x30ec
   11dbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11dc0:	681b      	ldr	r3, [r3, #0]
   11dc2:	ea42 0203 	orr.w	r2, r2, r3
   11dc6:	f243 03ec 	movw	r3, #12524	; 0x30ec
   11dca:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11dce:	601a      	str	r2, [r3, #0]
   11dd0:	68fb      	ldr	r3, [r7, #12]
   11dd2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11dd4:	4613      	mov	r3, r2
   11dd6:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11dda:	4413      	add	r3, r2
   11ddc:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11de0:	461a      	mov	r2, r3
   11de2:	f243 0310 	movw	r3, #12304	; 0x3010
   11de6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11dea:	441a      	add	r2, r3
   11dec:	68fb      	ldr	r3, [r7, #12]
   11dee:	f103 0304 	add.w	r3, r3, #4
   11df2:	4610      	mov	r0, r2
   11df4:	4619      	mov	r1, r3
   11df6:	f7fd f9a3 	bl	f140 <vListInsertEnd>
   11dfa:	e009      	b.n	11e10 <xTaskRemoveFromEventList+0xb4>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   11dfc:	68fb      	ldr	r3, [r7, #12]
   11dfe:	f103 0318 	add.w	r3, r3, #24
   11e02:	f243 00a4 	movw	r0, #12452	; 0x30a4
   11e06:	f2c2 0000 	movt	r0, #8192	; 0x2000
   11e0a:	4619      	mov	r1, r3
   11e0c:	f7fd f998 	bl	f140 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   11e10:	68fb      	ldr	r3, [r7, #12]
   11e12:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11e14:	f243 030c 	movw	r3, #12300	; 0x300c
   11e18:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11e1c:	681b      	ldr	r3, [r3, #0]
   11e1e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11e20:	429a      	cmp	r2, r3
   11e22:	d90a      	bls.n	11e3a <xTaskRemoveFromEventList+0xde>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
   11e24:	f04f 0301 	mov.w	r3, #1
   11e28:	613b      	str	r3, [r7, #16]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
   11e2a:	f243 03f8 	movw	r3, #12536	; 0x30f8
   11e2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11e32:	f04f 0201 	mov.w	r2, #1
   11e36:	601a      	str	r2, [r3, #0]
   11e38:	e002      	b.n	11e40 <xTaskRemoveFromEventList+0xe4>
	}
	else
	{
		xReturn = pdFALSE;
   11e3a:	f04f 0300 	mov.w	r3, #0
   11e3e:	613b      	str	r3, [r7, #16]
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
   11e40:	693b      	ldr	r3, [r7, #16]
}
   11e42:	4618      	mov	r0, r3
   11e44:	f107 0718 	add.w	r7, r7, #24
   11e48:	46bd      	mov	sp, r7
   11e4a:	bd80      	pop	{r7, pc}

00011e4c <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
   11e4c:	b580      	push	{r7, lr}
   11e4e:	b086      	sub	sp, #24
   11e50:	af00      	add	r7, sp, #0
   11e52:	6078      	str	r0, [r7, #4]
   11e54:	6039      	str	r1, [r7, #0]
TCB_t *pxUnblockedTCB;

	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );
   11e56:	f243 130c 	movw	r3, #12556	; 0x310c
   11e5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11e5e:	681b      	ldr	r3, [r3, #0]
   11e60:	2b00      	cmp	r3, #0
   11e62:	d109      	bne.n	11e78 <vTaskRemoveFromUnorderedEventList+0x2c>
   11e64:	f04f 0328 	mov.w	r3, #40	; 0x28
   11e68:	f383 8811 	msr	BASEPRI, r3
   11e6c:	f3bf 8f6f 	isb	sy
   11e70:	f3bf 8f4f 	dsb	sy
   11e74:	613b      	str	r3, [r7, #16]
   11e76:	e7fe      	b.n	11e76 <vTaskRemoveFromUnorderedEventList+0x2a>

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   11e78:	683b      	ldr	r3, [r7, #0]
   11e7a:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
   11e7e:	687b      	ldr	r3, [r7, #4]
   11e80:	601a      	str	r2, [r3, #0]

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   11e82:	687b      	ldr	r3, [r7, #4]
   11e84:	68db      	ldr	r3, [r3, #12]
   11e86:	60fb      	str	r3, [r7, #12]
	configASSERT( pxUnblockedTCB );
   11e88:	68fb      	ldr	r3, [r7, #12]
   11e8a:	2b00      	cmp	r3, #0
   11e8c:	d109      	bne.n	11ea2 <vTaskRemoveFromUnorderedEventList+0x56>
   11e8e:	f04f 0328 	mov.w	r3, #40	; 0x28
   11e92:	f383 8811 	msr	BASEPRI, r3
   11e96:	f3bf 8f6f 	isb	sy
   11e9a:	f3bf 8f4f 	dsb	sy
   11e9e:	617b      	str	r3, [r7, #20]
   11ea0:	e7fe      	b.n	11ea0 <vTaskRemoveFromUnorderedEventList+0x54>
	( void ) uxListRemove( pxEventListItem );
   11ea2:	6878      	ldr	r0, [r7, #4]
   11ea4:	f7fd f9aa 	bl	f1fc <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   11ea8:	68fb      	ldr	r3, [r7, #12]
   11eaa:	f103 0304 	add.w	r3, r3, #4
   11eae:	4618      	mov	r0, r3
   11eb0:	f7fd f9a4 	bl	f1fc <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
   11eb4:	68fb      	ldr	r3, [r7, #12]
   11eb6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11eb8:	f04f 0201 	mov.w	r2, #1
   11ebc:	fa02 f203 	lsl.w	r2, r2, r3
   11ec0:	f243 03ec 	movw	r3, #12524	; 0x30ec
   11ec4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11ec8:	681b      	ldr	r3, [r3, #0]
   11eca:	ea42 0203 	orr.w	r2, r2, r3
   11ece:	f243 03ec 	movw	r3, #12524	; 0x30ec
   11ed2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11ed6:	601a      	str	r2, [r3, #0]
   11ed8:	68fb      	ldr	r3, [r7, #12]
   11eda:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11edc:	4613      	mov	r3, r2
   11ede:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11ee2:	4413      	add	r3, r2
   11ee4:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11ee8:	461a      	mov	r2, r3
   11eea:	f243 0310 	movw	r3, #12304	; 0x3010
   11eee:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11ef2:	441a      	add	r2, r3
   11ef4:	68fb      	ldr	r3, [r7, #12]
   11ef6:	f103 0304 	add.w	r3, r3, #4
   11efa:	4610      	mov	r0, r2
   11efc:	4619      	mov	r1, r3
   11efe:	f7fd f91f 	bl	f140 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   11f02:	68fb      	ldr	r3, [r7, #12]
   11f04:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11f06:	f243 030c 	movw	r3, #12300	; 0x300c
   11f0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11f0e:	681b      	ldr	r3, [r3, #0]
   11f10:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11f12:	429a      	cmp	r2, r3
   11f14:	d906      	bls.n	11f24 <vTaskRemoveFromUnorderedEventList+0xd8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
   11f16:	f243 03f8 	movw	r3, #12536	; 0x30f8
   11f1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11f1e:	f04f 0201 	mov.w	r2, #1
   11f22:	601a      	str	r2, [r3, #0]
	}
}
   11f24:	f107 0718 	add.w	r7, r7, #24
   11f28:	46bd      	mov	sp, r7
   11f2a:	bd80      	pop	{r7, pc}

00011f2c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
   11f2c:	b580      	push	{r7, lr}
   11f2e:	b084      	sub	sp, #16
   11f30:	af00      	add	r7, sp, #0
   11f32:	6078      	str	r0, [r7, #4]
	configASSERT( pxTimeOut );
   11f34:	687b      	ldr	r3, [r7, #4]
   11f36:	2b00      	cmp	r3, #0
   11f38:	d109      	bne.n	11f4e <vTaskSetTimeOutState+0x22>
   11f3a:	f04f 0328 	mov.w	r3, #40	; 0x28
   11f3e:	f383 8811 	msr	BASEPRI, r3
   11f42:	f3bf 8f6f 	isb	sy
   11f46:	f3bf 8f4f 	dsb	sy
   11f4a:	60fb      	str	r3, [r7, #12]
   11f4c:	e7fe      	b.n	11f4c <vTaskSetTimeOutState+0x20>
	taskENTER_CRITICAL();
   11f4e:	f002 f993 	bl	14278 <vPortEnterCritical>
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
   11f52:	f243 03fc 	movw	r3, #12540	; 0x30fc
   11f56:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11f5a:	681a      	ldr	r2, [r3, #0]
   11f5c:	687b      	ldr	r3, [r7, #4]
   11f5e:	601a      	str	r2, [r3, #0]
		pxTimeOut->xTimeOnEntering = xTickCount;
   11f60:	f243 03e8 	movw	r3, #12520	; 0x30e8
   11f64:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11f68:	681a      	ldr	r2, [r3, #0]
   11f6a:	687b      	ldr	r3, [r7, #4]
   11f6c:	605a      	str	r2, [r3, #4]
	}
	taskEXIT_CRITICAL();
   11f6e:	f002 f9bb 	bl	142e8 <vPortExitCritical>
}
   11f72:	f107 0710 	add.w	r7, r7, #16
   11f76:	46bd      	mov	sp, r7
   11f78:	bd80      	pop	{r7, pc}
   11f7a:	bf00      	nop

00011f7c <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
   11f7c:	b480      	push	{r7}
   11f7e:	b083      	sub	sp, #12
   11f80:	af00      	add	r7, sp, #0
   11f82:	6078      	str	r0, [r7, #4]
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
   11f84:	f243 03fc 	movw	r3, #12540	; 0x30fc
   11f88:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11f8c:	681a      	ldr	r2, [r3, #0]
   11f8e:	687b      	ldr	r3, [r7, #4]
   11f90:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
   11f92:	f243 03e8 	movw	r3, #12520	; 0x30e8
   11f96:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11f9a:	681a      	ldr	r2, [r3, #0]
   11f9c:	687b      	ldr	r3, [r7, #4]
   11f9e:	605a      	str	r2, [r3, #4]
}
   11fa0:	f107 070c 	add.w	r7, r7, #12
   11fa4:	46bd      	mov	sp, r7
   11fa6:	bc80      	pop	{r7}
   11fa8:	4770      	bx	lr
   11faa:	bf00      	nop

00011fac <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
   11fac:	b580      	push	{r7, lr}
   11fae:	b088      	sub	sp, #32
   11fb0:	af00      	add	r7, sp, #0
   11fb2:	6078      	str	r0, [r7, #4]
   11fb4:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
   11fb6:	687b      	ldr	r3, [r7, #4]
   11fb8:	2b00      	cmp	r3, #0
   11fba:	d109      	bne.n	11fd0 <xTaskCheckForTimeOut+0x24>
   11fbc:	f04f 0328 	mov.w	r3, #40	; 0x28
   11fc0:	f383 8811 	msr	BASEPRI, r3
   11fc4:	f3bf 8f6f 	isb	sy
   11fc8:	f3bf 8f4f 	dsb	sy
   11fcc:	61bb      	str	r3, [r7, #24]
   11fce:	e7fe      	b.n	11fce <xTaskCheckForTimeOut+0x22>
	configASSERT( pxTicksToWait );
   11fd0:	683b      	ldr	r3, [r7, #0]
   11fd2:	2b00      	cmp	r3, #0
   11fd4:	d109      	bne.n	11fea <xTaskCheckForTimeOut+0x3e>
   11fd6:	f04f 0328 	mov.w	r3, #40	; 0x28
   11fda:	f383 8811 	msr	BASEPRI, r3
   11fde:	f3bf 8f6f 	isb	sy
   11fe2:	f3bf 8f4f 	dsb	sy
   11fe6:	61fb      	str	r3, [r7, #28]
   11fe8:	e7fe      	b.n	11fe8 <xTaskCheckForTimeOut+0x3c>

	taskENTER_CRITICAL();
   11fea:	f002 f945 	bl	14278 <vPortEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
   11fee:	f243 03e8 	movw	r3, #12520	; 0x30e8
   11ff2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11ff6:	681b      	ldr	r3, [r3, #0]
   11ff8:	613b      	str	r3, [r7, #16]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
   11ffa:	687b      	ldr	r3, [r7, #4]
   11ffc:	685b      	ldr	r3, [r3, #4]
   11ffe:	693a      	ldr	r2, [r7, #16]
   12000:	ebc3 0302 	rsb	r3, r3, r2
   12004:	617b      	str	r3, [r7, #20]
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
   12006:	683b      	ldr	r3, [r7, #0]
   12008:	681b      	ldr	r3, [r3, #0]
   1200a:	f1b3 3fff 	cmp.w	r3, #4294967295
   1200e:	d103      	bne.n	12018 <xTaskCheckForTimeOut+0x6c>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
   12010:	f04f 0300 	mov.w	r3, #0
   12014:	60fb      	str	r3, [r7, #12]
   12016:	e02b      	b.n	12070 <xTaskCheckForTimeOut+0xc4>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   12018:	687b      	ldr	r3, [r7, #4]
   1201a:	681a      	ldr	r2, [r3, #0]
   1201c:	f243 03fc 	movw	r3, #12540	; 0x30fc
   12020:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12024:	681b      	ldr	r3, [r3, #0]
   12026:	429a      	cmp	r2, r3
   12028:	d008      	beq.n	1203c <xTaskCheckForTimeOut+0x90>
   1202a:	687b      	ldr	r3, [r7, #4]
   1202c:	685a      	ldr	r2, [r3, #4]
   1202e:	693b      	ldr	r3, [r7, #16]
   12030:	429a      	cmp	r2, r3
   12032:	d803      	bhi.n	1203c <xTaskCheckForTimeOut+0x90>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
   12034:	f04f 0301 	mov.w	r3, #1
   12038:	60fb      	str	r3, [r7, #12]
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   1203a:	e019      	b.n	12070 <xTaskCheckForTimeOut+0xc4>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
   1203c:	683b      	ldr	r3, [r7, #0]
   1203e:	681a      	ldr	r2, [r3, #0]
   12040:	697b      	ldr	r3, [r7, #20]
   12042:	429a      	cmp	r2, r3
   12044:	d90d      	bls.n	12062 <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
   12046:	683b      	ldr	r3, [r7, #0]
   12048:	681a      	ldr	r2, [r3, #0]
   1204a:	697b      	ldr	r3, [r7, #20]
   1204c:	ebc3 0202 	rsb	r2, r3, r2
   12050:	683b      	ldr	r3, [r7, #0]
   12052:	601a      	str	r2, [r3, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
   12054:	6878      	ldr	r0, [r7, #4]
   12056:	f7ff ff91 	bl	11f7c <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
   1205a:	f04f 0300 	mov.w	r3, #0
   1205e:	60fb      	str	r3, [r7, #12]
   12060:	e006      	b.n	12070 <xTaskCheckForTimeOut+0xc4>
		}
		else
		{
			*pxTicksToWait = 0;
   12062:	683b      	ldr	r3, [r7, #0]
   12064:	f04f 0200 	mov.w	r2, #0
   12068:	601a      	str	r2, [r3, #0]
			xReturn = pdTRUE;
   1206a:	f04f 0301 	mov.w	r3, #1
   1206e:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
   12070:	f002 f93a 	bl	142e8 <vPortExitCritical>

	return xReturn;
   12074:	68fb      	ldr	r3, [r7, #12]
}
   12076:	4618      	mov	r0, r3
   12078:	f107 0720 	add.w	r7, r7, #32
   1207c:	46bd      	mov	sp, r7
   1207e:	bd80      	pop	{r7, pc}

00012080 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
   12080:	b480      	push	{r7}
   12082:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
   12084:	f243 03f8 	movw	r3, #12536	; 0x30f8
   12088:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1208c:	f04f 0201 	mov.w	r2, #1
   12090:	601a      	str	r2, [r3, #0]
}
   12092:	46bd      	mov	sp, r7
   12094:	bc80      	pop	{r7}
   12096:	4770      	bx	lr

00012098 <uxTaskGetTaskNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
	{
   12098:	b480      	push	{r7}
   1209a:	b085      	sub	sp, #20
   1209c:	af00      	add	r7, sp, #0
   1209e:	6078      	str	r0, [r7, #4]
	UBaseType_t uxReturn;
	TCB_t const *pxTCB;

		if( xTask != NULL )
   120a0:	687b      	ldr	r3, [r7, #4]
   120a2:	2b00      	cmp	r3, #0
   120a4:	d005      	beq.n	120b2 <uxTaskGetTaskNumber+0x1a>
		{
			pxTCB = xTask;
   120a6:	687b      	ldr	r3, [r7, #4]
   120a8:	60fb      	str	r3, [r7, #12]
			uxReturn = pxTCB->uxTaskNumber;
   120aa:	68fb      	ldr	r3, [r7, #12]
   120ac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   120ae:	60bb      	str	r3, [r7, #8]
   120b0:	e002      	b.n	120b8 <uxTaskGetTaskNumber+0x20>
		}
		else
		{
			uxReturn = 0U;
   120b2:	f04f 0300 	mov.w	r3, #0
   120b6:	60bb      	str	r3, [r7, #8]
		}

		return uxReturn;
   120b8:	68bb      	ldr	r3, [r7, #8]
	}
   120ba:	4618      	mov	r0, r3
   120bc:	f107 0714 	add.w	r7, r7, #20
   120c0:	46bd      	mov	sp, r7
   120c2:	bc80      	pop	{r7}
   120c4:	4770      	bx	lr
   120c6:	bf00      	nop

000120c8 <vTaskSetTaskNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
	{
   120c8:	b480      	push	{r7}
   120ca:	b085      	sub	sp, #20
   120cc:	af00      	add	r7, sp, #0
   120ce:	6078      	str	r0, [r7, #4]
   120d0:	6039      	str	r1, [r7, #0]
	TCB_t * pxTCB;

		if( xTask != NULL )
   120d2:	687b      	ldr	r3, [r7, #4]
   120d4:	2b00      	cmp	r3, #0
   120d6:	d004      	beq.n	120e2 <vTaskSetTaskNumber+0x1a>
		{
			pxTCB = xTask;
   120d8:	687b      	ldr	r3, [r7, #4]
   120da:	60fb      	str	r3, [r7, #12]
			pxTCB->uxTaskNumber = uxHandle;
   120dc:	68fb      	ldr	r3, [r7, #12]
   120de:	683a      	ldr	r2, [r7, #0]
   120e0:	645a      	str	r2, [r3, #68]	; 0x44
		}
	}
   120e2:	f107 0714 	add.w	r7, r7, #20
   120e6:	46bd      	mov	sp, r7
   120e8:	bc80      	pop	{r7}
   120ea:	4770      	bx	lr

000120ec <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
   120ec:	b580      	push	{r7, lr}
   120ee:	b082      	sub	sp, #8
   120f0:	af00      	add	r7, sp, #0
   120f2:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
   120f4:	f000 f868 	bl	121c8 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
   120f8:	f243 0310 	movw	r3, #12304	; 0x3010
   120fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12100:	681b      	ldr	r3, [r3, #0]
   12102:	2b01      	cmp	r3, #1
   12104:	d90a      	bls.n	1211c <prvIdleTask+0x30>
			{
				taskYIELD();
   12106:	f64e 5304 	movw	r3, #60676	; 0xed04
   1210a:	f2ce 0300 	movt	r3, #57344	; 0xe000
   1210e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   12112:	601a      	str	r2, [r3, #0]
   12114:	f3bf 8f4f 	dsb	sy
   12118:	f3bf 8f6f 	isb	sy
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
   1211c:	f7ee fd42 	bl	ba4 <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
   12120:	e7e8      	b.n	120f4 <prvIdleTask+0x8>
   12122:	bf00      	nop

00012124 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
   12124:	b580      	push	{r7, lr}
   12126:	b082      	sub	sp, #8
   12128:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   1212a:	f04f 0300 	mov.w	r3, #0
   1212e:	607b      	str	r3, [r7, #4]
   12130:	e013      	b.n	1215a <prvInitialiseTaskLists+0x36>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   12132:	687a      	ldr	r2, [r7, #4]
   12134:	4613      	mov	r3, r2
   12136:	ea4f 0383 	mov.w	r3, r3, lsl #2
   1213a:	4413      	add	r3, r2
   1213c:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12140:	461a      	mov	r2, r3
   12142:	f243 0310 	movw	r3, #12304	; 0x3010
   12146:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1214a:	4413      	add	r3, r2
   1214c:	4618      	mov	r0, r3
   1214e:	f7fc ffc5 	bl	f0dc <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   12152:	687b      	ldr	r3, [r7, #4]
   12154:	f103 0301 	add.w	r3, r3, #1
   12158:	607b      	str	r3, [r7, #4]
   1215a:	687b      	ldr	r3, [r7, #4]
   1215c:	2b04      	cmp	r3, #4
   1215e:	d9e8      	bls.n	12132 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
   12160:	f243 0074 	movw	r0, #12404	; 0x3074
   12164:	f2c2 0000 	movt	r0, #8192	; 0x2000
   12168:	f7fc ffb8 	bl	f0dc <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
   1216c:	f243 0088 	movw	r0, #12424	; 0x3088
   12170:	f2c2 0000 	movt	r0, #8192	; 0x2000
   12174:	f7fc ffb2 	bl	f0dc <vListInitialise>
	vListInitialise( &xPendingReadyList );
   12178:	f243 00a4 	movw	r0, #12452	; 0x30a4
   1217c:	f2c2 0000 	movt	r0, #8192	; 0x2000
   12180:	f7fc ffac 	bl	f0dc <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
   12184:	f243 00b8 	movw	r0, #12472	; 0x30b8
   12188:	f2c2 0000 	movt	r0, #8192	; 0x2000
   1218c:	f7fc ffa6 	bl	f0dc <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
   12190:	f243 00d0 	movw	r0, #12496	; 0x30d0
   12194:	f2c2 0000 	movt	r0, #8192	; 0x2000
   12198:	f7fc ffa0 	bl	f0dc <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
   1219c:	f243 039c 	movw	r3, #12444	; 0x309c
   121a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   121a4:	f243 0274 	movw	r2, #12404	; 0x3074
   121a8:	f2c2 0200 	movt	r2, #8192	; 0x2000
   121ac:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   121ae:	f243 03a0 	movw	r3, #12448	; 0x30a0
   121b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   121b6:	f243 0288 	movw	r2, #12424	; 0x3088
   121ba:	f2c2 0200 	movt	r2, #8192	; 0x2000
   121be:	601a      	str	r2, [r3, #0]
}
   121c0:	f107 0708 	add.w	r7, r7, #8
   121c4:	46bd      	mov	sp, r7
   121c6:	bd80      	pop	{r7, pc}

000121c8 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
   121c8:	b580      	push	{r7, lr}
   121ca:	b082      	sub	sp, #8
   121cc:	af00      	add	r7, sp, #0
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   121ce:	e02b      	b.n	12228 <prvCheckTasksWaitingTermination+0x60>
		{
			taskENTER_CRITICAL();
   121d0:	f002 f852 	bl	14278 <vPortEnterCritical>
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   121d4:	f243 03b8 	movw	r3, #12472	; 0x30b8
   121d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   121dc:	68db      	ldr	r3, [r3, #12]
   121de:	68db      	ldr	r3, [r3, #12]
   121e0:	607b      	str	r3, [r7, #4]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   121e2:	687b      	ldr	r3, [r7, #4]
   121e4:	f103 0304 	add.w	r3, r3, #4
   121e8:	4618      	mov	r0, r3
   121ea:	f7fd f807 	bl	f1fc <uxListRemove>
				--uxCurrentNumberOfTasks;
   121ee:	f243 03e4 	movw	r3, #12516	; 0x30e4
   121f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   121f6:	681b      	ldr	r3, [r3, #0]
   121f8:	f103 32ff 	add.w	r2, r3, #4294967295
   121fc:	f243 03e4 	movw	r3, #12516	; 0x30e4
   12200:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12204:	601a      	str	r2, [r3, #0]
				--uxDeletedTasksWaitingCleanUp;
   12206:	f243 03cc 	movw	r3, #12492	; 0x30cc
   1220a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1220e:	681b      	ldr	r3, [r3, #0]
   12210:	f103 32ff 	add.w	r2, r3, #4294967295
   12214:	f243 03cc 	movw	r3, #12492	; 0x30cc
   12218:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1221c:	601a      	str	r2, [r3, #0]
			}
			taskEXIT_CRITICAL();
   1221e:	f002 f863 	bl	142e8 <vPortExitCritical>

			prvDeleteTCB( pxTCB );
   12222:	6878      	ldr	r0, [r7, #4]
   12224:	f000 f8f8 	bl	12418 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   12228:	f243 03cc 	movw	r3, #12492	; 0x30cc
   1222c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12230:	681b      	ldr	r3, [r3, #0]
   12232:	2b00      	cmp	r3, #0
   12234:	d1cc      	bne.n	121d0 <prvCheckTasksWaitingTermination+0x8>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
   12236:	f107 0708 	add.w	r7, r7, #8
   1223a:	46bd      	mov	sp, r7
   1223c:	bd80      	pop	{r7, pc}
   1223e:	bf00      	nop

00012240 <vTaskGetInfo>:
/*-----------------------------------------------------------*/

#if( configUSE_TRACE_FACILITY == 1 )

	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
	{
   12240:	b580      	push	{r7, lr}
   12242:	b086      	sub	sp, #24
   12244:	af00      	add	r7, sp, #0
   12246:	60f8      	str	r0, [r7, #12]
   12248:	60b9      	str	r1, [r7, #8]
   1224a:	607a      	str	r2, [r7, #4]
   1224c:	70fb      	strb	r3, [r7, #3]
	TCB_t *pxTCB;

		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );
   1224e:	68fb      	ldr	r3, [r7, #12]
   12250:	2b00      	cmp	r3, #0
   12252:	d105      	bne.n	12260 <vTaskGetInfo+0x20>
   12254:	f243 030c 	movw	r3, #12300	; 0x300c
   12258:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1225c:	681b      	ldr	r3, [r3, #0]
   1225e:	e000      	b.n	12262 <vTaskGetInfo+0x22>
   12260:	68fb      	ldr	r3, [r7, #12]
   12262:	617b      	str	r3, [r7, #20]

		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
   12264:	68bb      	ldr	r3, [r7, #8]
   12266:	697a      	ldr	r2, [r7, #20]
   12268:	601a      	str	r2, [r3, #0]
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
   1226a:	697b      	ldr	r3, [r7, #20]
   1226c:	f103 0234 	add.w	r2, r3, #52	; 0x34
   12270:	68bb      	ldr	r3, [r7, #8]
   12272:	605a      	str	r2, [r3, #4]
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
   12274:	697b      	ldr	r3, [r7, #20]
   12276:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12278:	68bb      	ldr	r3, [r7, #8]
   1227a:	611a      	str	r2, [r3, #16]
		pxTaskStatus->pxStackBase = pxTCB->pxStack;
   1227c:	697b      	ldr	r3, [r7, #20]
   1227e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   12280:	68bb      	ldr	r3, [r7, #8]
   12282:	61da      	str	r2, [r3, #28]
		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
   12284:	697b      	ldr	r3, [r7, #20]
   12286:	6c1a      	ldr	r2, [r3, #64]	; 0x40
   12288:	68bb      	ldr	r3, [r7, #8]
   1228a:	609a      	str	r2, [r3, #8]

		#if ( configUSE_MUTEXES == 1 )
		{
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
   1228c:	697b      	ldr	r3, [r7, #20]
   1228e:	6c9a      	ldr	r2, [r3, #72]	; 0x48
   12290:	68bb      	ldr	r3, [r7, #8]
   12292:	615a      	str	r2, [r3, #20]
		}
		#endif

		#if ( configGENERATE_RUN_TIME_STATS == 1 )
		{
			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
   12294:	697b      	ldr	r3, [r7, #20]
   12296:	6d1a      	ldr	r2, [r3, #80]	; 0x50
   12298:	68bb      	ldr	r3, [r7, #8]
   1229a:	619a      	str	r2, [r3, #24]
		#endif

		/* Obtaining the task state is a little fiddly, so is only done if the
		value of eState passed into this function is eInvalid - otherwise the
		state is just set to whatever is passed in. */
		if( eState != eInvalid )
   1229c:	78fb      	ldrb	r3, [r7, #3]
   1229e:	2b05      	cmp	r3, #5
   122a0:	d01f      	beq.n	122e2 <vTaskGetInfo+0xa2>
		{
			if( pxTCB == pxCurrentTCB )
   122a2:	f243 030c 	movw	r3, #12300	; 0x300c
   122a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   122aa:	681b      	ldr	r3, [r3, #0]
   122ac:	697a      	ldr	r2, [r7, #20]
   122ae:	429a      	cmp	r2, r3
   122b0:	d104      	bne.n	122bc <vTaskGetInfo+0x7c>
			{
				pxTaskStatus->eCurrentState = eRunning;
   122b2:	68bb      	ldr	r3, [r7, #8]
   122b4:	f04f 0200 	mov.w	r2, #0
   122b8:	731a      	strb	r2, [r3, #12]
							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
							{
								pxTaskStatus->eCurrentState = eBlocked;
							}
						}
						( void ) xTaskResumeAll();
   122ba:	e01b      	b.n	122f4 <vTaskGetInfo+0xb4>
			{
				pxTaskStatus->eCurrentState = eRunning;
			}
			else
			{
				pxTaskStatus->eCurrentState = eState;
   122bc:	68bb      	ldr	r3, [r7, #8]
   122be:	78fa      	ldrb	r2, [r7, #3]
   122c0:	731a      	strb	r2, [r3, #12]
				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* If the task is in the suspended list then there is a
					chance it is actually just blocked indefinitely - so really
					it should be reported as being in the Blocked state. */
					if( eState == eSuspended )
   122c2:	78fb      	ldrb	r3, [r7, #3]
   122c4:	2b03      	cmp	r3, #3
   122c6:	d114      	bne.n	122f2 <vTaskGetInfo+0xb2>
					{
						vTaskSuspendAll();
   122c8:	f7ff f8f6 	bl	114b8 <vTaskSuspendAll>
						{
							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   122cc:	697b      	ldr	r3, [r7, #20]
   122ce:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   122d0:	2b00      	cmp	r3, #0
   122d2:	d003      	beq.n	122dc <vTaskGetInfo+0x9c>
							{
								pxTaskStatus->eCurrentState = eBlocked;
   122d4:	68bb      	ldr	r3, [r7, #8]
   122d6:	f04f 0202 	mov.w	r2, #2
   122da:	731a      	strb	r2, [r3, #12]
							}
						}
						( void ) xTaskResumeAll();
   122dc:	f7ff f8fe 	bl	114dc <xTaskResumeAll>
   122e0:	e008      	b.n	122f4 <vTaskGetInfo+0xb4>
				#endif /* INCLUDE_vTaskSuspend */
			}
		}
		else
		{
			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
   122e2:	6978      	ldr	r0, [r7, #20]
   122e4:	f7fe fd06 	bl	10cf4 <eTaskGetState>
   122e8:	4603      	mov	r3, r0
   122ea:	461a      	mov	r2, r3
   122ec:	68bb      	ldr	r3, [r7, #8]
   122ee:	731a      	strb	r2, [r3, #12]
   122f0:	e000      	b.n	122f4 <vTaskGetInfo+0xb4>
							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
							{
								pxTaskStatus->eCurrentState = eBlocked;
							}
						}
						( void ) xTaskResumeAll();
   122f2:	bf00      	nop
			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
		}

		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
		parameter is provided to allow it to be skipped. */
		if( xGetFreeStackSpace != pdFALSE )
   122f4:	687b      	ldr	r3, [r7, #4]
   122f6:	2b00      	cmp	r3, #0
   122f8:	d009      	beq.n	1230e <vTaskGetInfo+0xce>
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
			}
			#else
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
   122fa:	697b      	ldr	r3, [r7, #20]
   122fc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   122fe:	4618      	mov	r0, r3
   12300:	f000 f86a 	bl	123d8 <prvTaskCheckFreeStackSpace>
   12304:	4603      	mov	r3, r0
   12306:	461a      	mov	r2, r3
   12308:	68bb      	ldr	r3, [r7, #8]
   1230a:	841a      	strh	r2, [r3, #32]
   1230c:	e003      	b.n	12316 <vTaskGetInfo+0xd6>
			}
			#endif
		}
		else
		{
			pxTaskStatus->usStackHighWaterMark = 0;
   1230e:	68bb      	ldr	r3, [r7, #8]
   12310:	f04f 0200 	mov.w	r2, #0
   12314:	841a      	strh	r2, [r3, #32]
		}
	}
   12316:	f107 0718 	add.w	r7, r7, #24
   1231a:	46bd      	mov	sp, r7
   1231c:	bd80      	pop	{r7, pc}
   1231e:	bf00      	nop

00012320 <prvListTasksWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
   12320:	b580      	push	{r7, lr}
   12322:	b08a      	sub	sp, #40	; 0x28
   12324:	af00      	add	r7, sp, #0
   12326:	60f8      	str	r0, [r7, #12]
   12328:	60b9      	str	r1, [r7, #8]
   1232a:	4613      	mov	r3, r2
   1232c:	71fb      	strb	r3, [r7, #7]
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
   1232e:	f04f 0300 	mov.w	r3, #0
   12332:	61fb      	str	r3, [r7, #28]

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
   12334:	68bb      	ldr	r3, [r7, #8]
   12336:	681b      	ldr	r3, [r3, #0]
   12338:	2b00      	cmp	r3, #0
   1233a:	d046      	beq.n	123ca <prvListTasksWithinSingleList+0xaa>
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   1233c:	68bb      	ldr	r3, [r7, #8]
   1233e:	623b      	str	r3, [r7, #32]
   12340:	6a3b      	ldr	r3, [r7, #32]
   12342:	685b      	ldr	r3, [r3, #4]
   12344:	685a      	ldr	r2, [r3, #4]
   12346:	6a3b      	ldr	r3, [r7, #32]
   12348:	605a      	str	r2, [r3, #4]
   1234a:	6a3b      	ldr	r3, [r7, #32]
   1234c:	685a      	ldr	r2, [r3, #4]
   1234e:	6a3b      	ldr	r3, [r7, #32]
   12350:	f103 0308 	add.w	r3, r3, #8
   12354:	429a      	cmp	r2, r3
   12356:	d104      	bne.n	12362 <prvListTasksWithinSingleList+0x42>
   12358:	6a3b      	ldr	r3, [r7, #32]
   1235a:	685b      	ldr	r3, [r3, #4]
   1235c:	685a      	ldr	r2, [r3, #4]
   1235e:	6a3b      	ldr	r3, [r7, #32]
   12360:	605a      	str	r2, [r3, #4]
   12362:	6a3b      	ldr	r3, [r7, #32]
   12364:	685b      	ldr	r3, [r3, #4]
   12366:	68db      	ldr	r3, [r3, #12]
   12368:	61bb      	str	r3, [r7, #24]
			pxTaskStatusArray array for each task that is referenced from
			pxList.  See the definition of TaskStatus_t in task.h for the
			meaning of each TaskStatus_t structure member. */
			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   1236a:	68bb      	ldr	r3, [r7, #8]
   1236c:	627b      	str	r3, [r7, #36]	; 0x24
   1236e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   12370:	685b      	ldr	r3, [r3, #4]
   12372:	685a      	ldr	r2, [r3, #4]
   12374:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   12376:	605a      	str	r2, [r3, #4]
   12378:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1237a:	685a      	ldr	r2, [r3, #4]
   1237c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1237e:	f103 0308 	add.w	r3, r3, #8
   12382:	429a      	cmp	r2, r3
   12384:	d104      	bne.n	12390 <prvListTasksWithinSingleList+0x70>
   12386:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   12388:	685b      	ldr	r3, [r3, #4]
   1238a:	685a      	ldr	r2, [r3, #4]
   1238c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1238e:	605a      	str	r2, [r3, #4]
   12390:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   12392:	685b      	ldr	r3, [r3, #4]
   12394:	68db      	ldr	r3, [r3, #12]
   12396:	617b      	str	r3, [r7, #20]
				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
   12398:	69fa      	ldr	r2, [r7, #28]
   1239a:	4613      	mov	r3, r2
   1239c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   123a0:	4413      	add	r3, r2
   123a2:	ea4f 0383 	mov.w	r3, r3, lsl #2
   123a6:	461a      	mov	r2, r3
   123a8:	68fb      	ldr	r3, [r7, #12]
   123aa:	441a      	add	r2, r3
   123ac:	79fb      	ldrb	r3, [r7, #7]
   123ae:	6978      	ldr	r0, [r7, #20]
   123b0:	4611      	mov	r1, r2
   123b2:	f04f 0201 	mov.w	r2, #1
   123b6:	f7ff ff43 	bl	12240 <vTaskGetInfo>
				uxTask++;
   123ba:	69fb      	ldr	r3, [r7, #28]
   123bc:	f103 0301 	add.w	r3, r3, #1
   123c0:	61fb      	str	r3, [r7, #28]
			} while( pxNextTCB != pxFirstTCB );
   123c2:	697a      	ldr	r2, [r7, #20]
   123c4:	69bb      	ldr	r3, [r7, #24]
   123c6:	429a      	cmp	r2, r3
   123c8:	d1cf      	bne.n	1236a <prvListTasksWithinSingleList+0x4a>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return uxTask;
   123ca:	69fb      	ldr	r3, [r7, #28]
	}
   123cc:	4618      	mov	r0, r3
   123ce:	f107 0728 	add.w	r7, r7, #40	; 0x28
   123d2:	46bd      	mov	sp, r7
   123d4:	bd80      	pop	{r7, pc}
   123d6:	bf00      	nop

000123d8 <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
   123d8:	b480      	push	{r7}
   123da:	b085      	sub	sp, #20
   123dc:	af00      	add	r7, sp, #0
   123de:	6078      	str	r0, [r7, #4]
	uint32_t ulCount = 0U;
   123e0:	f04f 0300 	mov.w	r3, #0
   123e4:	60fb      	str	r3, [r7, #12]

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
   123e6:	e007      	b.n	123f8 <prvTaskCheckFreeStackSpace+0x20>
		{
			pucStackByte -= portSTACK_GROWTH;
   123e8:	687b      	ldr	r3, [r7, #4]
   123ea:	f103 0301 	add.w	r3, r3, #1
   123ee:	607b      	str	r3, [r7, #4]
			ulCount++;
   123f0:	68fb      	ldr	r3, [r7, #12]
   123f2:	f103 0301 	add.w	r3, r3, #1
   123f6:	60fb      	str	r3, [r7, #12]

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
   123f8:	687b      	ldr	r3, [r7, #4]
   123fa:	781b      	ldrb	r3, [r3, #0]
   123fc:	2ba5      	cmp	r3, #165	; 0xa5
   123fe:	d0f3      	beq.n	123e8 <prvTaskCheckFreeStackSpace+0x10>
		{
			pucStackByte -= portSTACK_GROWTH;
			ulCount++;
		}

		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
   12400:	68fb      	ldr	r3, [r7, #12]
   12402:	ea4f 0393 	mov.w	r3, r3, lsr #2
   12406:	60fb      	str	r3, [r7, #12]

		return ( configSTACK_DEPTH_TYPE ) ulCount;
   12408:	68fb      	ldr	r3, [r7, #12]
   1240a:	b29b      	uxth	r3, r3
	}
   1240c:	4618      	mov	r0, r3
   1240e:	f107 0714 	add.w	r7, r7, #20
   12412:	46bd      	mov	sp, r7
   12414:	bc80      	pop	{r7}
   12416:	4770      	bx	lr

00012418 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
   12418:	b580      	push	{r7, lr}
   1241a:	b082      	sub	sp, #8
   1241c:	af00      	add	r7, sp, #0
   1241e:	6078      	str	r0, [r7, #4]

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
   12420:	687b      	ldr	r3, [r7, #4]
   12422:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   12424:	4618      	mov	r0, r3
   12426:	f001 fd61 	bl	13eec <vPortFree>
			vPortFree( pxTCB );
   1242a:	6878      	ldr	r0, [r7, #4]
   1242c:	f001 fd5e 	bl	13eec <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
   12430:	f107 0708 	add.w	r7, r7, #8
   12434:	46bd      	mov	sp, r7
   12436:	bd80      	pop	{r7, pc}

00012438 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
   12438:	b480      	push	{r7}
   1243a:	b083      	sub	sp, #12
   1243c:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   1243e:	f243 039c 	movw	r3, #12444	; 0x309c
   12442:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12446:	681b      	ldr	r3, [r3, #0]
   12448:	681b      	ldr	r3, [r3, #0]
   1244a:	2b00      	cmp	r3, #0
   1244c:	d107      	bne.n	1245e <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
   1244e:	f243 1304 	movw	r3, #12548	; 0x3104
   12452:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12456:	f04f 32ff 	mov.w	r2, #4294967295
   1245a:	601a      	str	r2, [r3, #0]
   1245c:	e00e      	b.n	1247c <prvResetNextTaskUnblockTime+0x44>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   1245e:	f243 039c 	movw	r3, #12444	; 0x309c
   12462:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12466:	681b      	ldr	r3, [r3, #0]
   12468:	68db      	ldr	r3, [r3, #12]
   1246a:	68db      	ldr	r3, [r3, #12]
   1246c:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
   1246e:	687b      	ldr	r3, [r7, #4]
   12470:	685a      	ldr	r2, [r3, #4]
   12472:	f243 1304 	movw	r3, #12548	; 0x3104
   12476:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1247a:	601a      	str	r2, [r3, #0]
	}
}
   1247c:	f107 070c 	add.w	r7, r7, #12
   12480:	46bd      	mov	sp, r7
   12482:	bc80      	pop	{r7}
   12484:	4770      	bx	lr
   12486:	bf00      	nop

00012488 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
   12488:	b480      	push	{r7}
   1248a:	b083      	sub	sp, #12
   1248c:	af00      	add	r7, sp, #0
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
   1248e:	f243 030c 	movw	r3, #12300	; 0x300c
   12492:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12496:	681b      	ldr	r3, [r3, #0]
   12498:	607b      	str	r3, [r7, #4]

		return xReturn;
   1249a:	687b      	ldr	r3, [r7, #4]
	}
   1249c:	4618      	mov	r0, r3
   1249e:	f107 070c 	add.w	r7, r7, #12
   124a2:	46bd      	mov	sp, r7
   124a4:	bc80      	pop	{r7}
   124a6:	4770      	bx	lr

000124a8 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
   124a8:	b480      	push	{r7}
   124aa:	b083      	sub	sp, #12
   124ac:	af00      	add	r7, sp, #0
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
   124ae:	f243 03f0 	movw	r3, #12528	; 0x30f0
   124b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   124b6:	681b      	ldr	r3, [r3, #0]
   124b8:	2b00      	cmp	r3, #0
   124ba:	d103      	bne.n	124c4 <xTaskGetSchedulerState+0x1c>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
   124bc:	f04f 0301 	mov.w	r3, #1
   124c0:	607b      	str	r3, [r7, #4]
   124c2:	e00d      	b.n	124e0 <xTaskGetSchedulerState+0x38>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   124c4:	f243 130c 	movw	r3, #12556	; 0x310c
   124c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   124cc:	681b      	ldr	r3, [r3, #0]
   124ce:	2b00      	cmp	r3, #0
   124d0:	d103      	bne.n	124da <xTaskGetSchedulerState+0x32>
			{
				xReturn = taskSCHEDULER_RUNNING;
   124d2:	f04f 0302 	mov.w	r3, #2
   124d6:	607b      	str	r3, [r7, #4]
   124d8:	e002      	b.n	124e0 <xTaskGetSchedulerState+0x38>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
   124da:	f04f 0300 	mov.w	r3, #0
   124de:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
   124e0:	687b      	ldr	r3, [r7, #4]
	}
   124e2:	4618      	mov	r0, r3
   124e4:	f107 070c 	add.w	r7, r7, #12
   124e8:	46bd      	mov	sp, r7
   124ea:	bc80      	pop	{r7}
   124ec:	4770      	bx	lr
   124ee:	bf00      	nop

000124f0 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
   124f0:	b580      	push	{r7, lr}
   124f2:	b084      	sub	sp, #16
   124f4:	af00      	add	r7, sp, #0
   124f6:	6078      	str	r0, [r7, #4]
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
   124f8:	687b      	ldr	r3, [r7, #4]
   124fa:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn = pdFALSE;
   124fc:	f04f 0300 	mov.w	r3, #0
   12500:	60fb      	str	r3, [r7, #12]

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
   12502:	687b      	ldr	r3, [r7, #4]
   12504:	2b00      	cmp	r3, #0
   12506:	f000 80a2 	beq.w	1264e <xTaskPriorityInherit+0x15e>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
   1250a:	68bb      	ldr	r3, [r7, #8]
   1250c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1250e:	f243 030c 	movw	r3, #12300	; 0x300c
   12512:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12516:	681b      	ldr	r3, [r3, #0]
   12518:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1251a:	429a      	cmp	r2, r3
   1251c:	f080 808a 	bcs.w	12634 <xTaskPriorityInherit+0x144>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   12520:	68bb      	ldr	r3, [r7, #8]
   12522:	699b      	ldr	r3, [r3, #24]
   12524:	2b00      	cmp	r3, #0
   12526:	db09      	blt.n	1253c <xTaskPriorityInherit+0x4c>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   12528:	f243 030c 	movw	r3, #12300	; 0x300c
   1252c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12530:	681b      	ldr	r3, [r3, #0]
   12532:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   12534:	f1c3 0205 	rsb	r2, r3, #5
   12538:	68bb      	ldr	r3, [r7, #8]
   1253a:	619a      	str	r2, [r3, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
   1253c:	68bb      	ldr	r3, [r7, #8]
   1253e:	6959      	ldr	r1, [r3, #20]
   12540:	68bb      	ldr	r3, [r7, #8]
   12542:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12544:	4613      	mov	r3, r2
   12546:	ea4f 0383 	mov.w	r3, r3, lsl #2
   1254a:	4413      	add	r3, r2
   1254c:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12550:	461a      	mov	r2, r3
   12552:	f243 0310 	movw	r3, #12304	; 0x3010
   12556:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1255a:	4413      	add	r3, r2
   1255c:	4299      	cmp	r1, r3
   1255e:	d15d      	bne.n	1261c <xTaskPriorityInherit+0x12c>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   12560:	68bb      	ldr	r3, [r7, #8]
   12562:	f103 0304 	add.w	r3, r3, #4
   12566:	4618      	mov	r0, r3
   12568:	f7fc fe48 	bl	f1fc <uxListRemove>
   1256c:	4603      	mov	r3, r0
   1256e:	2b00      	cmp	r3, #0
   12570:	d124      	bne.n	125bc <xTaskPriorityInherit+0xcc>
					{
						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
   12572:	68bb      	ldr	r3, [r7, #8]
   12574:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12576:	4613      	mov	r3, r2
   12578:	ea4f 0383 	mov.w	r3, r3, lsl #2
   1257c:	4413      	add	r3, r2
   1257e:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12582:	461a      	mov	r2, r3
   12584:	f243 0310 	movw	r3, #12304	; 0x3010
   12588:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1258c:	4413      	add	r3, r2
   1258e:	681b      	ldr	r3, [r3, #0]
   12590:	2b00      	cmp	r3, #0
   12592:	d113      	bne.n	125bc <xTaskPriorityInherit+0xcc>
   12594:	68bb      	ldr	r3, [r7, #8]
   12596:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   12598:	f04f 0201 	mov.w	r2, #1
   1259c:	fa02 f303 	lsl.w	r3, r2, r3
   125a0:	ea6f 0203 	mvn.w	r2, r3
   125a4:	f243 03ec 	movw	r3, #12524	; 0x30ec
   125a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   125ac:	681b      	ldr	r3, [r3, #0]
   125ae:	ea02 0203 	and.w	r2, r2, r3
   125b2:	f243 03ec 	movw	r3, #12524	; 0x30ec
   125b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   125ba:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   125bc:	f243 030c 	movw	r3, #12300	; 0x300c
   125c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   125c4:	681b      	ldr	r3, [r3, #0]
   125c6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   125c8:	68bb      	ldr	r3, [r7, #8]
   125ca:	62da      	str	r2, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
   125cc:	68bb      	ldr	r3, [r7, #8]
   125ce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   125d0:	f04f 0201 	mov.w	r2, #1
   125d4:	fa02 f203 	lsl.w	r2, r2, r3
   125d8:	f243 03ec 	movw	r3, #12524	; 0x30ec
   125dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   125e0:	681b      	ldr	r3, [r3, #0]
   125e2:	ea42 0203 	orr.w	r2, r2, r3
   125e6:	f243 03ec 	movw	r3, #12524	; 0x30ec
   125ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
   125ee:	601a      	str	r2, [r3, #0]
   125f0:	68bb      	ldr	r3, [r7, #8]
   125f2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   125f4:	4613      	mov	r3, r2
   125f6:	ea4f 0383 	mov.w	r3, r3, lsl #2
   125fa:	4413      	add	r3, r2
   125fc:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12600:	461a      	mov	r2, r3
   12602:	f243 0310 	movw	r3, #12304	; 0x3010
   12606:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1260a:	441a      	add	r2, r3
   1260c:	68bb      	ldr	r3, [r7, #8]
   1260e:	f103 0304 	add.w	r3, r3, #4
   12612:	4610      	mov	r0, r2
   12614:	4619      	mov	r1, r3
   12616:	f7fc fd93 	bl	f140 <vListInsertEnd>
   1261a:	e007      	b.n	1262c <xTaskPriorityInherit+0x13c>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   1261c:	f243 030c 	movw	r3, #12300	; 0x300c
   12620:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12624:	681b      	ldr	r3, [r3, #0]
   12626:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12628:	68bb      	ldr	r3, [r7, #8]
   1262a:	62da      	str	r2, [r3, #44]	; 0x2c
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
   1262c:	f04f 0301 	mov.w	r3, #1
   12630:	60fb      	str	r3, [r7, #12]
   12632:	e00c      	b.n	1264e <xTaskPriorityInherit+0x15e>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
   12634:	68bb      	ldr	r3, [r7, #8]
   12636:	6c9a      	ldr	r2, [r3, #72]	; 0x48
   12638:	f243 030c 	movw	r3, #12300	; 0x300c
   1263c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12640:	681b      	ldr	r3, [r3, #0]
   12642:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   12644:	429a      	cmp	r2, r3
   12646:	d202      	bcs.n	1264e <xTaskPriorityInherit+0x15e>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
   12648:	f04f 0301 	mov.w	r3, #1
   1264c:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
   1264e:	68fb      	ldr	r3, [r7, #12]
	}
   12650:	4618      	mov	r0, r3
   12652:	f107 0710 	add.w	r7, r7, #16
   12656:	46bd      	mov	sp, r7
   12658:	bd80      	pop	{r7, pc}
   1265a:	bf00      	nop

0001265c <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
   1265c:	b580      	push	{r7, lr}
   1265e:	b086      	sub	sp, #24
   12660:	af00      	add	r7, sp, #0
   12662:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = pxMutexHolder;
   12664:	687b      	ldr	r3, [r7, #4]
   12666:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn = pdFALSE;
   12668:	f04f 0300 	mov.w	r3, #0
   1266c:	60fb      	str	r3, [r7, #12]

		if( pxMutexHolder != NULL )
   1266e:	687b      	ldr	r3, [r7, #4]
   12670:	2b00      	cmp	r3, #0
   12672:	f000 8092 	beq.w	1279a <xTaskPriorityDisinherit+0x13e>
		{
			/* A task can only have an inherited priority if it holds the mutex.
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
   12676:	f243 030c 	movw	r3, #12300	; 0x300c
   1267a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1267e:	681b      	ldr	r3, [r3, #0]
   12680:	68ba      	ldr	r2, [r7, #8]
   12682:	429a      	cmp	r2, r3
   12684:	d009      	beq.n	1269a <xTaskPriorityDisinherit+0x3e>
   12686:	f04f 0328 	mov.w	r3, #40	; 0x28
   1268a:	f383 8811 	msr	BASEPRI, r3
   1268e:	f3bf 8f6f 	isb	sy
   12692:	f3bf 8f4f 	dsb	sy
   12696:	613b      	str	r3, [r7, #16]
   12698:	e7fe      	b.n	12698 <xTaskPriorityDisinherit+0x3c>
			configASSERT( pxTCB->uxMutexesHeld );
   1269a:	68bb      	ldr	r3, [r7, #8]
   1269c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   1269e:	2b00      	cmp	r3, #0
   126a0:	d109      	bne.n	126b6 <xTaskPriorityDisinherit+0x5a>
   126a2:	f04f 0328 	mov.w	r3, #40	; 0x28
   126a6:	f383 8811 	msr	BASEPRI, r3
   126aa:	f3bf 8f6f 	isb	sy
   126ae:	f3bf 8f4f 	dsb	sy
   126b2:	617b      	str	r3, [r7, #20]
   126b4:	e7fe      	b.n	126b4 <xTaskPriorityDisinherit+0x58>
			( pxTCB->uxMutexesHeld )--;
   126b6:	68bb      	ldr	r3, [r7, #8]
   126b8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   126ba:	f103 32ff 	add.w	r2, r3, #4294967295
   126be:	68bb      	ldr	r3, [r7, #8]
   126c0:	64da      	str	r2, [r3, #76]	; 0x4c

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   126c2:	68bb      	ldr	r3, [r7, #8]
   126c4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   126c6:	68bb      	ldr	r3, [r7, #8]
   126c8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   126ca:	429a      	cmp	r2, r3
   126cc:	d065      	beq.n	1279a <xTaskPriorityDisinherit+0x13e>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
   126ce:	68bb      	ldr	r3, [r7, #8]
   126d0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   126d2:	2b00      	cmp	r3, #0
   126d4:	d161      	bne.n	1279a <xTaskPriorityDisinherit+0x13e>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   126d6:	68bb      	ldr	r3, [r7, #8]
   126d8:	f103 0304 	add.w	r3, r3, #4
   126dc:	4618      	mov	r0, r3
   126de:	f7fc fd8d 	bl	f1fc <uxListRemove>
   126e2:	4603      	mov	r3, r0
   126e4:	2b00      	cmp	r3, #0
   126e6:	d124      	bne.n	12732 <xTaskPriorityDisinherit+0xd6>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   126e8:	68bb      	ldr	r3, [r7, #8]
   126ea:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   126ec:	4613      	mov	r3, r2
   126ee:	ea4f 0383 	mov.w	r3, r3, lsl #2
   126f2:	4413      	add	r3, r2
   126f4:	ea4f 0383 	mov.w	r3, r3, lsl #2
   126f8:	461a      	mov	r2, r3
   126fa:	f243 0310 	movw	r3, #12304	; 0x3010
   126fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12702:	4413      	add	r3, r2
   12704:	681b      	ldr	r3, [r3, #0]
   12706:	2b00      	cmp	r3, #0
   12708:	d113      	bne.n	12732 <xTaskPriorityDisinherit+0xd6>
   1270a:	68bb      	ldr	r3, [r7, #8]
   1270c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1270e:	f04f 0201 	mov.w	r2, #1
   12712:	fa02 f303 	lsl.w	r3, r2, r3
   12716:	ea6f 0203 	mvn.w	r2, r3
   1271a:	f243 03ec 	movw	r3, #12524	; 0x30ec
   1271e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12722:	681b      	ldr	r3, [r3, #0]
   12724:	ea02 0203 	and.w	r2, r2, r3
   12728:	f243 03ec 	movw	r3, #12524	; 0x30ec
   1272c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12730:	601a      	str	r2, [r3, #0]
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
   12732:	68bb      	ldr	r3, [r7, #8]
   12734:	6c9a      	ldr	r2, [r3, #72]	; 0x48
   12736:	68bb      	ldr	r3, [r7, #8]
   12738:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1273a:	68bb      	ldr	r3, [r7, #8]
   1273c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1273e:	f1c3 0205 	rsb	r2, r3, #5
   12742:	68bb      	ldr	r3, [r7, #8]
   12744:	619a      	str	r2, [r3, #24]
					prvAddTaskToReadyList( pxTCB );
   12746:	68bb      	ldr	r3, [r7, #8]
   12748:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1274a:	f04f 0201 	mov.w	r2, #1
   1274e:	fa02 f203 	lsl.w	r2, r2, r3
   12752:	f243 03ec 	movw	r3, #12524	; 0x30ec
   12756:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1275a:	681b      	ldr	r3, [r3, #0]
   1275c:	ea42 0203 	orr.w	r2, r2, r3
   12760:	f243 03ec 	movw	r3, #12524	; 0x30ec
   12764:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12768:	601a      	str	r2, [r3, #0]
   1276a:	68bb      	ldr	r3, [r7, #8]
   1276c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1276e:	4613      	mov	r3, r2
   12770:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12774:	4413      	add	r3, r2
   12776:	ea4f 0383 	mov.w	r3, r3, lsl #2
   1277a:	461a      	mov	r2, r3
   1277c:	f243 0310 	movw	r3, #12304	; 0x3010
   12780:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12784:	441a      	add	r2, r3
   12786:	68bb      	ldr	r3, [r7, #8]
   12788:	f103 0304 	add.w	r3, r3, #4
   1278c:	4610      	mov	r0, r2
   1278e:	4619      	mov	r1, r3
   12790:	f7fc fcd6 	bl	f140 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
   12794:	f04f 0301 	mov.w	r3, #1
   12798:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
   1279a:	68fb      	ldr	r3, [r7, #12]
	}
   1279c:	4618      	mov	r0, r3
   1279e:	f107 0718 	add.w	r7, r7, #24
   127a2:	46bd      	mov	sp, r7
   127a4:	bd80      	pop	{r7, pc}
   127a6:	bf00      	nop

000127a8 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
   127a8:	b580      	push	{r7, lr}
   127aa:	b088      	sub	sp, #32
   127ac:	af00      	add	r7, sp, #0
   127ae:	6078      	str	r0, [r7, #4]
   127b0:	6039      	str	r1, [r7, #0]
	TCB_t * const pxTCB = pxMutexHolder;
   127b2:	687b      	ldr	r3, [r7, #4]
   127b4:	60bb      	str	r3, [r7, #8]
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
   127b6:	f04f 0301 	mov.w	r3, #1
   127ba:	617b      	str	r3, [r7, #20]

		if( pxMutexHolder != NULL )
   127bc:	687b      	ldr	r3, [r7, #4]
   127be:	2b00      	cmp	r3, #0
   127c0:	f000 80ac 	beq.w	1291c <vTaskPriorityDisinheritAfterTimeout+0x174>
		{
			/* If pxMutexHolder is not NULL then the holder must hold at least
			one mutex. */
			configASSERT( pxTCB->uxMutexesHeld );
   127c4:	68bb      	ldr	r3, [r7, #8]
   127c6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   127c8:	2b00      	cmp	r3, #0
   127ca:	d109      	bne.n	127e0 <vTaskPriorityDisinheritAfterTimeout+0x38>
   127cc:	f04f 0328 	mov.w	r3, #40	; 0x28
   127d0:	f383 8811 	msr	BASEPRI, r3
   127d4:	f3bf 8f6f 	isb	sy
   127d8:	f3bf 8f4f 	dsb	sy
   127dc:	61bb      	str	r3, [r7, #24]
   127de:	e7fe      	b.n	127de <vTaskPriorityDisinheritAfterTimeout+0x36>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
   127e0:	68bb      	ldr	r3, [r7, #8]
   127e2:	6c9a      	ldr	r2, [r3, #72]	; 0x48
   127e4:	683b      	ldr	r3, [r7, #0]
   127e6:	429a      	cmp	r2, r3
   127e8:	d202      	bcs.n	127f0 <vTaskPriorityDisinheritAfterTimeout+0x48>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
   127ea:	683b      	ldr	r3, [r7, #0]
   127ec:	613b      	str	r3, [r7, #16]
   127ee:	e002      	b.n	127f6 <vTaskPriorityDisinheritAfterTimeout+0x4e>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
   127f0:	68bb      	ldr	r3, [r7, #8]
   127f2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   127f4:	613b      	str	r3, [r7, #16]
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
   127f6:	68bb      	ldr	r3, [r7, #8]
   127f8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   127fa:	693b      	ldr	r3, [r7, #16]
   127fc:	429a      	cmp	r2, r3
   127fe:	f000 808d 	beq.w	1291c <vTaskPriorityDisinheritAfterTimeout+0x174>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
   12802:	68bb      	ldr	r3, [r7, #8]
   12804:	6cda      	ldr	r2, [r3, #76]	; 0x4c
   12806:	697b      	ldr	r3, [r7, #20]
   12808:	429a      	cmp	r2, r3
   1280a:	f040 8087 	bne.w	1291c <vTaskPriorityDisinheritAfterTimeout+0x174>
				{
					/* If a task has timed out because it already holds the
					mutex it was trying to obtain then it cannot of inherited
					its own priority. */
					configASSERT( pxTCB != pxCurrentTCB );
   1280e:	f243 030c 	movw	r3, #12300	; 0x300c
   12812:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12816:	681b      	ldr	r3, [r3, #0]
   12818:	68ba      	ldr	r2, [r7, #8]
   1281a:	429a      	cmp	r2, r3
   1281c:	d109      	bne.n	12832 <vTaskPriorityDisinheritAfterTimeout+0x8a>
   1281e:	f04f 0328 	mov.w	r3, #40	; 0x28
   12822:	f383 8811 	msr	BASEPRI, r3
   12826:	f3bf 8f6f 	isb	sy
   1282a:	f3bf 8f4f 	dsb	sy
   1282e:	61fb      	str	r3, [r7, #28]
   12830:	e7fe      	b.n	12830 <vTaskPriorityDisinheritAfterTimeout+0x88>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
   12832:	68bb      	ldr	r3, [r7, #8]
   12834:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   12836:	60fb      	str	r3, [r7, #12]
					pxTCB->uxPriority = uxPriorityToUse;
   12838:	68bb      	ldr	r3, [r7, #8]
   1283a:	693a      	ldr	r2, [r7, #16]
   1283c:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   1283e:	68bb      	ldr	r3, [r7, #8]
   12840:	699b      	ldr	r3, [r3, #24]
   12842:	2b00      	cmp	r3, #0
   12844:	db04      	blt.n	12850 <vTaskPriorityDisinheritAfterTimeout+0xa8>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   12846:	693b      	ldr	r3, [r7, #16]
   12848:	f1c3 0205 	rsb	r2, r3, #5
   1284c:	68bb      	ldr	r3, [r7, #8]
   1284e:	619a      	str	r2, [r3, #24]
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
   12850:	68bb      	ldr	r3, [r7, #8]
   12852:	6959      	ldr	r1, [r3, #20]
   12854:	68fa      	ldr	r2, [r7, #12]
   12856:	4613      	mov	r3, r2
   12858:	ea4f 0383 	mov.w	r3, r3, lsl #2
   1285c:	4413      	add	r3, r2
   1285e:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12862:	461a      	mov	r2, r3
   12864:	f243 0310 	movw	r3, #12304	; 0x3010
   12868:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1286c:	4413      	add	r3, r2
   1286e:	4299      	cmp	r1, r3
   12870:	d154      	bne.n	1291c <vTaskPriorityDisinheritAfterTimeout+0x174>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   12872:	68bb      	ldr	r3, [r7, #8]
   12874:	f103 0304 	add.w	r3, r3, #4
   12878:	4618      	mov	r0, r3
   1287a:	f7fc fcbf 	bl	f1fc <uxListRemove>
   1287e:	4603      	mov	r3, r0
   12880:	2b00      	cmp	r3, #0
   12882:	d124      	bne.n	128ce <vTaskPriorityDisinheritAfterTimeout+0x126>
						{
							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   12884:	68bb      	ldr	r3, [r7, #8]
   12886:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12888:	4613      	mov	r3, r2
   1288a:	ea4f 0383 	mov.w	r3, r3, lsl #2
   1288e:	4413      	add	r3, r2
   12890:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12894:	461a      	mov	r2, r3
   12896:	f243 0310 	movw	r3, #12304	; 0x3010
   1289a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1289e:	4413      	add	r3, r2
   128a0:	681b      	ldr	r3, [r3, #0]
   128a2:	2b00      	cmp	r3, #0
   128a4:	d113      	bne.n	128ce <vTaskPriorityDisinheritAfterTimeout+0x126>
   128a6:	68bb      	ldr	r3, [r7, #8]
   128a8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   128aa:	f04f 0201 	mov.w	r2, #1
   128ae:	fa02 f303 	lsl.w	r3, r2, r3
   128b2:	ea6f 0203 	mvn.w	r2, r3
   128b6:	f243 03ec 	movw	r3, #12524	; 0x30ec
   128ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
   128be:	681b      	ldr	r3, [r3, #0]
   128c0:	ea02 0203 	and.w	r2, r2, r3
   128c4:	f243 03ec 	movw	r3, #12524	; 0x30ec
   128c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   128cc:	601a      	str	r2, [r3, #0]
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
   128ce:	68bb      	ldr	r3, [r7, #8]
   128d0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   128d2:	f04f 0201 	mov.w	r2, #1
   128d6:	fa02 f203 	lsl.w	r2, r2, r3
   128da:	f243 03ec 	movw	r3, #12524	; 0x30ec
   128de:	f2c2 0300 	movt	r3, #8192	; 0x2000
   128e2:	681b      	ldr	r3, [r3, #0]
   128e4:	ea42 0203 	orr.w	r2, r2, r3
   128e8:	f243 03ec 	movw	r3, #12524	; 0x30ec
   128ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
   128f0:	601a      	str	r2, [r3, #0]
   128f2:	68bb      	ldr	r3, [r7, #8]
   128f4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   128f6:	4613      	mov	r3, r2
   128f8:	ea4f 0383 	mov.w	r3, r3, lsl #2
   128fc:	4413      	add	r3, r2
   128fe:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12902:	461a      	mov	r2, r3
   12904:	f243 0310 	movw	r3, #12304	; 0x3010
   12908:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1290c:	441a      	add	r2, r3
   1290e:	68bb      	ldr	r3, [r7, #8]
   12910:	f103 0304 	add.w	r3, r3, #4
   12914:	4610      	mov	r0, r2
   12916:	4619      	mov	r1, r3
   12918:	f7fc fc12 	bl	f140 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   1291c:	f107 0720 	add.w	r7, r7, #32
   12920:	46bd      	mov	sp, r7
   12922:	bd80      	pop	{r7, pc}

00012924 <prvWriteNameToBuffer>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )

	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
	{
   12924:	b580      	push	{r7, lr}
   12926:	b084      	sub	sp, #16
   12928:	af00      	add	r7, sp, #0
   1292a:	6078      	str	r0, [r7, #4]
   1292c:	6039      	str	r1, [r7, #0]
	size_t x;

		/* Start by copying the entire string. */
		strcpy( pcBuffer, pcTaskName );
   1292e:	6878      	ldr	r0, [r7, #4]
   12930:	6839      	ldr	r1, [r7, #0]
   12932:	f002 fca5 	bl	15280 <strcpy>

		/* Pad the end of the string with spaces to ensure columns line up when
		printed out. */
		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
   12936:	6878      	ldr	r0, [r7, #4]
   12938:	f002 fd00 	bl	1533c <strlen>
   1293c:	4603      	mov	r3, r0
   1293e:	60fb      	str	r3, [r7, #12]
   12940:	e009      	b.n	12956 <prvWriteNameToBuffer+0x32>
		{
			pcBuffer[ x ] = ' ';
   12942:	687a      	ldr	r2, [r7, #4]
   12944:	68fb      	ldr	r3, [r7, #12]
   12946:	4413      	add	r3, r2
   12948:	f04f 0220 	mov.w	r2, #32
   1294c:	701a      	strb	r2, [r3, #0]
		/* Start by copying the entire string. */
		strcpy( pcBuffer, pcTaskName );

		/* Pad the end of the string with spaces to ensure columns line up when
		printed out. */
		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
   1294e:	68fb      	ldr	r3, [r7, #12]
   12950:	f103 0301 	add.w	r3, r3, #1
   12954:	60fb      	str	r3, [r7, #12]
   12956:	68fb      	ldr	r3, [r7, #12]
   12958:	2b08      	cmp	r3, #8
   1295a:	d9f2      	bls.n	12942 <prvWriteNameToBuffer+0x1e>
		{
			pcBuffer[ x ] = ' ';
		}

		/* Terminate. */
		pcBuffer[ x ] = ( char ) 0x00;
   1295c:	687a      	ldr	r2, [r7, #4]
   1295e:	68fb      	ldr	r3, [r7, #12]
   12960:	4413      	add	r3, r2
   12962:	f04f 0200 	mov.w	r2, #0
   12966:	701a      	strb	r2, [r3, #0]

		/* Return the new end of string. */
		return &( pcBuffer[ x ] );
   12968:	687a      	ldr	r2, [r7, #4]
   1296a:	68fb      	ldr	r3, [r7, #12]
   1296c:	4413      	add	r3, r2
	}
   1296e:	4618      	mov	r0, r3
   12970:	f107 0710 	add.w	r7, r7, #16
   12974:	46bd      	mov	sp, r7
   12976:	bd80      	pop	{r7, pc}

00012978 <vTaskList>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	void vTaskList( char * pcWriteBuffer )
	{
   12978:	b580      	push	{r7, lr}
   1297a:	b088      	sub	sp, #32
   1297c:	af02      	add	r7, sp, #8
   1297e:	6078      	str	r0, [r7, #4]
		 * through a call to vTaskList().
		 */


		/* Make sure the write buffer does not contain a string. */
		*pcWriteBuffer = ( char ) 0x00;
   12980:	687b      	ldr	r3, [r7, #4]
   12982:	f04f 0200 	mov.w	r2, #0
   12986:	701a      	strb	r2, [r3, #0]

		/* Take a snapshot of the number of tasks in case it changes while this
		function is executing. */
		uxArraySize = uxCurrentNumberOfTasks;
   12988:	f243 03e4 	movw	r3, #12516	; 0x30e4
   1298c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12990:	681b      	ldr	r3, [r3, #0]
   12992:	60fb      	str	r3, [r7, #12]

		/* Allocate an array index for each task.  NOTE!  if
		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
		equate to NULL. */
		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */
   12994:	f243 03e4 	movw	r3, #12516	; 0x30e4
   12998:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1299c:	681a      	ldr	r2, [r3, #0]
   1299e:	4613      	mov	r3, r2
   129a0:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   129a4:	4413      	add	r3, r2
   129a6:	ea4f 0383 	mov.w	r3, r3, lsl #2
   129aa:	4618      	mov	r0, r3
   129ac:	f001 f9e8 	bl	13d80 <pvPortMalloc>
   129b0:	4603      	mov	r3, r0
   129b2:	60bb      	str	r3, [r7, #8]

		if( pxTaskStatusArray != NULL )
   129b4:	68bb      	ldr	r3, [r7, #8]
   129b6:	2b00      	cmp	r3, #0
   129b8:	f000 8091 	beq.w	12ade <vTaskList+0x166>
		{
			/* Generate the (binary) data. */
			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
   129bc:	68b8      	ldr	r0, [r7, #8]
   129be:	68f9      	ldr	r1, [r7, #12]
   129c0:	f04f 0200 	mov.w	r2, #0
   129c4:	f7fe feb0 	bl	11728 <uxTaskGetSystemState>
   129c8:	4603      	mov	r3, r0
   129ca:	60fb      	str	r3, [r7, #12]

			/* Create a human readable table from the binary data. */
			for( x = 0; x < uxArraySize; x++ )
   129cc:	f04f 0300 	mov.w	r3, #0
   129d0:	613b      	str	r3, [r7, #16]
   129d2:	e07c      	b.n	12ace <vTaskList+0x156>
			{
				switch( pxTaskStatusArray[ x ].eCurrentState )
   129d4:	693a      	ldr	r2, [r7, #16]
   129d6:	4613      	mov	r3, r2
   129d8:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   129dc:	4413      	add	r3, r2
   129de:	ea4f 0383 	mov.w	r3, r3, lsl #2
   129e2:	461a      	mov	r2, r3
   129e4:	68bb      	ldr	r3, [r7, #8]
   129e6:	4413      	add	r3, r2
   129e8:	7b1b      	ldrb	r3, [r3, #12]
   129ea:	2b04      	cmp	r3, #4
   129ec:	d820      	bhi.n	12a30 <vTaskList+0xb8>
   129ee:	a201      	add	r2, pc, #4	; (adr r2, 129f4 <vTaskList+0x7c>)
   129f0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   129f4:	00012a09 	.word	0x00012a09
   129f8:	00012a11 	.word	0x00012a11
   129fc:	00012a19 	.word	0x00012a19
   12a00:	00012a21 	.word	0x00012a21
   12a04:	00012a29 	.word	0x00012a29
				{
					case eRunning:		cStatus = tskRUNNING_CHAR;
   12a08:	f04f 0358 	mov.w	r3, #88	; 0x58
   12a0c:	75fb      	strb	r3, [r7, #23]
										break;
   12a0e:	e012      	b.n	12a36 <vTaskList+0xbe>

					case eReady:		cStatus = tskREADY_CHAR;
   12a10:	f04f 0352 	mov.w	r3, #82	; 0x52
   12a14:	75fb      	strb	r3, [r7, #23]
										break;
   12a16:	e00e      	b.n	12a36 <vTaskList+0xbe>

					case eBlocked:		cStatus = tskBLOCKED_CHAR;
   12a18:	f04f 0342 	mov.w	r3, #66	; 0x42
   12a1c:	75fb      	strb	r3, [r7, #23]
										break;
   12a1e:	e00a      	b.n	12a36 <vTaskList+0xbe>

					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
   12a20:	f04f 0353 	mov.w	r3, #83	; 0x53
   12a24:	75fb      	strb	r3, [r7, #23]
										break;
   12a26:	e006      	b.n	12a36 <vTaskList+0xbe>

					case eDeleted:		cStatus = tskDELETED_CHAR;
   12a28:	f04f 0344 	mov.w	r3, #68	; 0x44
   12a2c:	75fb      	strb	r3, [r7, #23]
										break;
   12a2e:	e002      	b.n	12a36 <vTaskList+0xbe>

					case eInvalid:		/* Fall through. */
					default:			/* Should not get here, but it is included
										to prevent static checking errors. */
										cStatus = ( char ) 0x00;
   12a30:	f04f 0300 	mov.w	r3, #0
   12a34:	75fb      	strb	r3, [r7, #23]
										break;
				}

				/* Write the task name to the string, padding with spaces so it
				can be printed in tabular form more easily. */
				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
   12a36:	693a      	ldr	r2, [r7, #16]
   12a38:	4613      	mov	r3, r2
   12a3a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   12a3e:	4413      	add	r3, r2
   12a40:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12a44:	461a      	mov	r2, r3
   12a46:	68bb      	ldr	r3, [r7, #8]
   12a48:	4413      	add	r3, r2
   12a4a:	685b      	ldr	r3, [r3, #4]
   12a4c:	6878      	ldr	r0, [r7, #4]
   12a4e:	4619      	mov	r1, r3
   12a50:	f7ff ff68 	bl	12924 <prvWriteNameToBuffer>
   12a54:	4603      	mov	r3, r0
   12a56:	607b      	str	r3, [r7, #4]

				/* Write the rest of the string. */
				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
   12a58:	f897 e017 	ldrb.w	lr, [r7, #23]
   12a5c:	693a      	ldr	r2, [r7, #16]
   12a5e:	4613      	mov	r3, r2
   12a60:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   12a64:	4413      	add	r3, r2
   12a66:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12a6a:	461a      	mov	r2, r3
   12a6c:	68bb      	ldr	r3, [r7, #8]
   12a6e:	4413      	add	r3, r2
   12a70:	f8d3 c010 	ldr.w	ip, [r3, #16]
   12a74:	693a      	ldr	r2, [r7, #16]
   12a76:	4613      	mov	r3, r2
   12a78:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   12a7c:	4413      	add	r3, r2
   12a7e:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12a82:	461a      	mov	r2, r3
   12a84:	68bb      	ldr	r3, [r7, #8]
   12a86:	4413      	add	r3, r2
   12a88:	8c1b      	ldrh	r3, [r3, #32]
   12a8a:	4619      	mov	r1, r3
   12a8c:	693a      	ldr	r2, [r7, #16]
   12a8e:	4613      	mov	r3, r2
   12a90:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   12a94:	4413      	add	r3, r2
   12a96:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12a9a:	461a      	mov	r2, r3
   12a9c:	68bb      	ldr	r3, [r7, #8]
   12a9e:	4413      	add	r3, r2
   12aa0:	689b      	ldr	r3, [r3, #8]
   12aa2:	9100      	str	r1, [sp, #0]
   12aa4:	9301      	str	r3, [sp, #4]
   12aa6:	6878      	ldr	r0, [r7, #4]
   12aa8:	f244 015c 	movw	r1, #16476	; 0x405c
   12aac:	f2c0 0102 	movt	r1, #2
   12ab0:	4672      	mov	r2, lr
   12ab2:	4663      	mov	r3, ip
   12ab4:	f002 fb16 	bl	150e4 <sprintf>
				pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
   12ab8:	6878      	ldr	r0, [r7, #4]
   12aba:	f002 fc3f 	bl	1533c <strlen>
   12abe:	4603      	mov	r3, r0
   12ac0:	687a      	ldr	r2, [r7, #4]
   12ac2:	4413      	add	r3, r2
   12ac4:	607b      	str	r3, [r7, #4]
		{
			/* Generate the (binary) data. */
			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );

			/* Create a human readable table from the binary data. */
			for( x = 0; x < uxArraySize; x++ )
   12ac6:	693b      	ldr	r3, [r7, #16]
   12ac8:	f103 0301 	add.w	r3, r3, #1
   12acc:	613b      	str	r3, [r7, #16]
   12ace:	693a      	ldr	r2, [r7, #16]
   12ad0:	68fb      	ldr	r3, [r7, #12]
   12ad2:	429a      	cmp	r2, r3
   12ad4:	f4ff af7e 	bcc.w	129d4 <vTaskList+0x5c>
				pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
			}

			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
			is 0 then vPortFree() will be #defined to nothing. */
			vPortFree( pxTaskStatusArray );
   12ad8:	68b8      	ldr	r0, [r7, #8]
   12ada:	f001 fa07 	bl	13eec <vPortFree>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   12ade:	f107 0718 	add.w	r7, r7, #24
   12ae2:	46bd      	mov	sp, r7
   12ae4:	bd80      	pop	{r7, pc}
   12ae6:	bf00      	nop

00012ae8 <vTaskGetRunTimeStats>:
/*----------------------------------------------------------*/

#if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	void vTaskGetRunTimeStats( char *pcWriteBuffer )
	{
   12ae8:	b580      	push	{r7, lr}
   12aea:	b088      	sub	sp, #32
   12aec:	af00      	add	r7, sp, #0
   12aee:	6078      	str	r0, [r7, #4]
		 * directly to get access to raw stats data, rather than indirectly
		 * through a call to vTaskGetRunTimeStats().
		 */

		/* Make sure the write buffer does not contain a string. */
		*pcWriteBuffer = ( char ) 0x00;
   12af0:	687b      	ldr	r3, [r7, #4]
   12af2:	f04f 0200 	mov.w	r2, #0
   12af6:	701a      	strb	r2, [r3, #0]

		/* Take a snapshot of the number of tasks in case it changes while this
		function is executing. */
		uxArraySize = uxCurrentNumberOfTasks;
   12af8:	f243 03e4 	movw	r3, #12516	; 0x30e4
   12afc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12b00:	681b      	ldr	r3, [r3, #0]
   12b02:	617b      	str	r3, [r7, #20]

		/* Allocate an array index for each task.  NOTE!  If
		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
		equate to NULL. */
		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */
   12b04:	f243 03e4 	movw	r3, #12516	; 0x30e4
   12b08:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12b0c:	681a      	ldr	r2, [r3, #0]
   12b0e:	4613      	mov	r3, r2
   12b10:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   12b14:	4413      	add	r3, r2
   12b16:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12b1a:	4618      	mov	r0, r3
   12b1c:	f001 f930 	bl	13d80 <pvPortMalloc>
   12b20:	4603      	mov	r3, r0
   12b22:	613b      	str	r3, [r7, #16]

		if( pxTaskStatusArray != NULL )
   12b24:	693b      	ldr	r3, [r7, #16]
   12b26:	2b00      	cmp	r3, #0
   12b28:	d076      	beq.n	12c18 <vTaskGetRunTimeStats+0x130>
		{
			/* Generate the (binary) data. */
			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
   12b2a:	f107 030c 	add.w	r3, r7, #12
   12b2e:	6938      	ldr	r0, [r7, #16]
   12b30:	6979      	ldr	r1, [r7, #20]
   12b32:	461a      	mov	r2, r3
   12b34:	f7fe fdf8 	bl	11728 <uxTaskGetSystemState>
   12b38:	4603      	mov	r3, r0
   12b3a:	617b      	str	r3, [r7, #20]

			/* For percentage calculations. */
			ulTotalTime /= 100UL;
   12b3c:	68fa      	ldr	r2, [r7, #12]
   12b3e:	f248 531f 	movw	r3, #34079	; 0x851f
   12b42:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
   12b46:	fba3 1302 	umull	r1, r3, r3, r2
   12b4a:	ea4f 1353 	mov.w	r3, r3, lsr #5
   12b4e:	60fb      	str	r3, [r7, #12]

			/* Avoid divide by zero errors. */
			if( ulTotalTime > 0UL )
   12b50:	68fb      	ldr	r3, [r7, #12]
   12b52:	2b00      	cmp	r3, #0
   12b54:	d05d      	beq.n	12c12 <vTaskGetRunTimeStats+0x12a>
			{
				/* Create a human readable table from the binary data. */
				for( x = 0; x < uxArraySize; x++ )
   12b56:	f04f 0300 	mov.w	r3, #0
   12b5a:	61bb      	str	r3, [r7, #24]
   12b5c:	e055      	b.n	12c0a <vTaskGetRunTimeStats+0x122>
				{
					/* What percentage of the total run time has the task used?
					This will always be rounded down to the nearest integer.
					ulTotalRunTimeDiv100 has already been divided by 100. */
					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
   12b5e:	69ba      	ldr	r2, [r7, #24]
   12b60:	4613      	mov	r3, r2
   12b62:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   12b66:	4413      	add	r3, r2
   12b68:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12b6c:	461a      	mov	r2, r3
   12b6e:	693b      	ldr	r3, [r7, #16]
   12b70:	4413      	add	r3, r2
   12b72:	699a      	ldr	r2, [r3, #24]
   12b74:	68fb      	ldr	r3, [r7, #12]
   12b76:	fbb2 f3f3 	udiv	r3, r2, r3
   12b7a:	61fb      	str	r3, [r7, #28]

					/* Write the task name to the string, padding with
					spaces so it can be printed in tabular form more
					easily. */
					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
   12b7c:	69ba      	ldr	r2, [r7, #24]
   12b7e:	4613      	mov	r3, r2
   12b80:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   12b84:	4413      	add	r3, r2
   12b86:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12b8a:	461a      	mov	r2, r3
   12b8c:	693b      	ldr	r3, [r7, #16]
   12b8e:	4413      	add	r3, r2
   12b90:	685b      	ldr	r3, [r3, #4]
   12b92:	6878      	ldr	r0, [r7, #4]
   12b94:	4619      	mov	r1, r3
   12b96:	f7ff fec5 	bl	12924 <prvWriteNameToBuffer>
   12b9a:	4603      	mov	r3, r0
   12b9c:	607b      	str	r3, [r7, #4]

					if( ulStatsAsPercentage > 0UL )
   12b9e:	69fb      	ldr	r3, [r7, #28]
   12ba0:	2b00      	cmp	r3, #0
   12ba2:	d014      	beq.n	12bce <vTaskGetRunTimeStats+0xe6>
						}
						#else
						{
							/* sizeof( int ) == sizeof( long ) so a smaller
							printf() library can be used. */
							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
   12ba4:	69ba      	ldr	r2, [r7, #24]
   12ba6:	4613      	mov	r3, r2
   12ba8:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   12bac:	4413      	add	r3, r2
   12bae:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12bb2:	461a      	mov	r2, r3
   12bb4:	693b      	ldr	r3, [r7, #16]
   12bb6:	4413      	add	r3, r2
   12bb8:	699b      	ldr	r3, [r3, #24]
   12bba:	6878      	ldr	r0, [r7, #4]
   12bbc:	f244 016c 	movw	r1, #16492	; 0x406c
   12bc0:	f2c0 0102 	movt	r1, #2
   12bc4:	461a      	mov	r2, r3
   12bc6:	69fb      	ldr	r3, [r7, #28]
   12bc8:	f002 fa8c 	bl	150e4 <sprintf>
   12bcc:	e012      	b.n	12bf4 <vTaskGetRunTimeStats+0x10c>
						}
						#else
						{
							/* sizeof( int ) == sizeof( long ) so a smaller
							printf() library can be used. */
							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
   12bce:	69ba      	ldr	r2, [r7, #24]
   12bd0:	4613      	mov	r3, r2
   12bd2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   12bd6:	4413      	add	r3, r2
   12bd8:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12bdc:	461a      	mov	r2, r3
   12bde:	693b      	ldr	r3, [r7, #16]
   12be0:	4413      	add	r3, r2
   12be2:	699b      	ldr	r3, [r3, #24]
   12be4:	6878      	ldr	r0, [r7, #4]
   12be6:	f244 0178 	movw	r1, #16504	; 0x4078
   12bea:	f2c0 0102 	movt	r1, #2
   12bee:	461a      	mov	r2, r3
   12bf0:	f002 fa78 	bl	150e4 <sprintf>
						}
						#endif
					}

					pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
   12bf4:	6878      	ldr	r0, [r7, #4]
   12bf6:	f002 fba1 	bl	1533c <strlen>
   12bfa:	4603      	mov	r3, r0
   12bfc:	687a      	ldr	r2, [r7, #4]
   12bfe:	4413      	add	r3, r2
   12c00:	607b      	str	r3, [r7, #4]

			/* Avoid divide by zero errors. */
			if( ulTotalTime > 0UL )
			{
				/* Create a human readable table from the binary data. */
				for( x = 0; x < uxArraySize; x++ )
   12c02:	69bb      	ldr	r3, [r7, #24]
   12c04:	f103 0301 	add.w	r3, r3, #1
   12c08:	61bb      	str	r3, [r7, #24]
   12c0a:	69ba      	ldr	r2, [r7, #24]
   12c0c:	697b      	ldr	r3, [r7, #20]
   12c0e:	429a      	cmp	r2, r3
   12c10:	d3a5      	bcc.n	12b5e <vTaskGetRunTimeStats+0x76>
				mtCOVERAGE_TEST_MARKER();
			}

			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
			is 0 then vPortFree() will be #defined to nothing. */
			vPortFree( pxTaskStatusArray );
   12c12:	6938      	ldr	r0, [r7, #16]
   12c14:	f001 f96a 	bl	13eec <vPortFree>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   12c18:	f107 0720 	add.w	r7, r7, #32
   12c1c:	46bd      	mov	sp, r7
   12c1e:	bd80      	pop	{r7, pc}

00012c20 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
   12c20:	b480      	push	{r7}
   12c22:	b083      	sub	sp, #12
   12c24:	af00      	add	r7, sp, #0
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
   12c26:	f243 030c 	movw	r3, #12300	; 0x300c
   12c2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12c2e:	681b      	ldr	r3, [r3, #0]
   12c30:	699b      	ldr	r3, [r3, #24]
   12c32:	607b      	str	r3, [r7, #4]

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   12c34:	f243 030c 	movw	r3, #12300	; 0x300c
   12c38:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12c3c:	681a      	ldr	r2, [r3, #0]
   12c3e:	f243 030c 	movw	r3, #12300	; 0x300c
   12c42:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12c46:	681b      	ldr	r3, [r3, #0]
   12c48:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   12c4a:	f1c3 0305 	rsb	r3, r3, #5
   12c4e:	6193      	str	r3, [r2, #24]

	return uxReturn;
   12c50:	687b      	ldr	r3, [r7, #4]
}
   12c52:	4618      	mov	r0, r3
   12c54:	f107 070c 	add.w	r7, r7, #12
   12c58:	46bd      	mov	sp, r7
   12c5a:	bc80      	pop	{r7}
   12c5c:	4770      	bx	lr
   12c5e:	bf00      	nop

00012c60 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
   12c60:	b480      	push	{r7}
   12c62:	af00      	add	r7, sp, #0
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
   12c64:	f243 030c 	movw	r3, #12300	; 0x300c
   12c68:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12c6c:	681b      	ldr	r3, [r3, #0]
   12c6e:	2b00      	cmp	r3, #0
   12c70:	d008      	beq.n	12c84 <pvTaskIncrementMutexHeldCount+0x24>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
   12c72:	f243 030c 	movw	r3, #12300	; 0x300c
   12c76:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12c7a:	681b      	ldr	r3, [r3, #0]
   12c7c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
   12c7e:	f102 0201 	add.w	r2, r2, #1
   12c82:	64da      	str	r2, [r3, #76]	; 0x4c
		}

		return pxCurrentTCB;
   12c84:	f243 030c 	movw	r3, #12300	; 0x300c
   12c88:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12c8c:	681b      	ldr	r3, [r3, #0]
	}
   12c8e:	4618      	mov	r0, r3
   12c90:	46bd      	mov	sp, r7
   12c92:	bc80      	pop	{r7}
   12c94:	4770      	bx	lr
   12c96:	bf00      	nop

00012c98 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
   12c98:	b580      	push	{r7, lr}
   12c9a:	b084      	sub	sp, #16
   12c9c:	af00      	add	r7, sp, #0
   12c9e:	6078      	str	r0, [r7, #4]
   12ca0:	6039      	str	r1, [r7, #0]
	uint32_t ulReturn;

		taskENTER_CRITICAL();
   12ca2:	f001 fae9 	bl	14278 <vPortEnterCritical>
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
   12ca6:	f243 030c 	movw	r3, #12300	; 0x300c
   12caa:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12cae:	681b      	ldr	r3, [r3, #0]
   12cb0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   12cb2:	2b00      	cmp	r3, #0
   12cb4:	d11b      	bne.n	12cee <ulTaskNotifyTake+0x56>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
   12cb6:	f243 030c 	movw	r3, #12300	; 0x300c
   12cba:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12cbe:	681b      	ldr	r3, [r3, #0]
   12cc0:	f04f 0201 	mov.w	r2, #1
   12cc4:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

				if( xTicksToWait > ( TickType_t ) 0 )
   12cc8:	683b      	ldr	r3, [r7, #0]
   12cca:	2b00      	cmp	r3, #0
   12ccc:	d00f      	beq.n	12cee <ulTaskNotifyTake+0x56>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   12cce:	6838      	ldr	r0, [r7, #0]
   12cd0:	f04f 0101 	mov.w	r1, #1
   12cd4:	f000 fb3a 	bl	1334c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
   12cd8:	f64e 5304 	movw	r3, #60676	; 0xed04
   12cdc:	f2ce 0300 	movt	r3, #57344	; 0xe000
   12ce0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   12ce4:	601a      	str	r2, [r3, #0]
   12ce6:	f3bf 8f4f 	dsb	sy
   12cea:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
   12cee:	f001 fafb 	bl	142e8 <vPortExitCritical>

		taskENTER_CRITICAL();
   12cf2:	f001 fac1 	bl	14278 <vPortEnterCritical>
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
   12cf6:	f243 030c 	movw	r3, #12300	; 0x300c
   12cfa:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12cfe:	681b      	ldr	r3, [r3, #0]
   12d00:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   12d02:	60fb      	str	r3, [r7, #12]

			if( ulReturn != 0UL )
   12d04:	68fb      	ldr	r3, [r7, #12]
   12d06:	2b00      	cmp	r3, #0
   12d08:	d014      	beq.n	12d34 <ulTaskNotifyTake+0x9c>
			{
				if( xClearCountOnExit != pdFALSE )
   12d0a:	687b      	ldr	r3, [r7, #4]
   12d0c:	2b00      	cmp	r3, #0
   12d0e:	d008      	beq.n	12d22 <ulTaskNotifyTake+0x8a>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
   12d10:	f243 030c 	movw	r3, #12300	; 0x300c
   12d14:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12d18:	681b      	ldr	r3, [r3, #0]
   12d1a:	f04f 0200 	mov.w	r2, #0
   12d1e:	655a      	str	r2, [r3, #84]	; 0x54
   12d20:	e008      	b.n	12d34 <ulTaskNotifyTake+0x9c>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
   12d22:	f243 030c 	movw	r3, #12300	; 0x300c
   12d26:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12d2a:	681b      	ldr	r3, [r3, #0]
   12d2c:	68fa      	ldr	r2, [r7, #12]
   12d2e:	f102 32ff 	add.w	r2, r2, #4294967295
   12d32:	655a      	str	r2, [r3, #84]	; 0x54
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   12d34:	f243 030c 	movw	r3, #12300	; 0x300c
   12d38:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12d3c:	681b      	ldr	r3, [r3, #0]
   12d3e:	f04f 0200 	mov.w	r2, #0
   12d42:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
		}
		taskEXIT_CRITICAL();
   12d46:	f001 facf 	bl	142e8 <vPortExitCritical>

		return ulReturn;
   12d4a:	68fb      	ldr	r3, [r7, #12]
	}
   12d4c:	4618      	mov	r0, r3
   12d4e:	f107 0710 	add.w	r7, r7, #16
   12d52:	46bd      	mov	sp, r7
   12d54:	bd80      	pop	{r7, pc}
   12d56:	bf00      	nop

00012d58 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
   12d58:	b580      	push	{r7, lr}
   12d5a:	b086      	sub	sp, #24
   12d5c:	af00      	add	r7, sp, #0
   12d5e:	60f8      	str	r0, [r7, #12]
   12d60:	60b9      	str	r1, [r7, #8]
   12d62:	607a      	str	r2, [r7, #4]
   12d64:	603b      	str	r3, [r7, #0]
	BaseType_t xReturn;

		taskENTER_CRITICAL();
   12d66:	f001 fa87 	bl	14278 <vPortEnterCritical>
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
   12d6a:	f243 030c 	movw	r3, #12300	; 0x300c
   12d6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12d72:	681b      	ldr	r3, [r3, #0]
   12d74:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
   12d78:	b2db      	uxtb	r3, r3
   12d7a:	2b02      	cmp	r3, #2
   12d7c:	d027      	beq.n	12dce <xTaskNotifyWait+0x76>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
   12d7e:	f243 030c 	movw	r3, #12300	; 0x300c
   12d82:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12d86:	681b      	ldr	r3, [r3, #0]
   12d88:	6d59      	ldr	r1, [r3, #84]	; 0x54
   12d8a:	68fa      	ldr	r2, [r7, #12]
   12d8c:	ea6f 0202 	mvn.w	r2, r2
   12d90:	ea01 0202 	and.w	r2, r1, r2
   12d94:	655a      	str	r2, [r3, #84]	; 0x54

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
   12d96:	f243 030c 	movw	r3, #12300	; 0x300c
   12d9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12d9e:	681b      	ldr	r3, [r3, #0]
   12da0:	f04f 0201 	mov.w	r2, #1
   12da4:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

				if( xTicksToWait > ( TickType_t ) 0 )
   12da8:	683b      	ldr	r3, [r7, #0]
   12daa:	2b00      	cmp	r3, #0
   12dac:	d00f      	beq.n	12dce <xTaskNotifyWait+0x76>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   12dae:	6838      	ldr	r0, [r7, #0]
   12db0:	f04f 0101 	mov.w	r1, #1
   12db4:	f000 faca 	bl	1334c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
   12db8:	f64e 5304 	movw	r3, #60676	; 0xed04
   12dbc:	f2ce 0300 	movt	r3, #57344	; 0xe000
   12dc0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   12dc4:	601a      	str	r2, [r3, #0]
   12dc6:	f3bf 8f4f 	dsb	sy
   12dca:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
   12dce:	f001 fa8b 	bl	142e8 <vPortExitCritical>

		taskENTER_CRITICAL();
   12dd2:	f001 fa51 	bl	14278 <vPortEnterCritical>
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
   12dd6:	687b      	ldr	r3, [r7, #4]
   12dd8:	2b00      	cmp	r3, #0
   12dda:	d007      	beq.n	12dec <xTaskNotifyWait+0x94>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
   12ddc:	f243 030c 	movw	r3, #12300	; 0x300c
   12de0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12de4:	681b      	ldr	r3, [r3, #0]
   12de6:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   12de8:	687b      	ldr	r3, [r7, #4]
   12dea:	601a      	str	r2, [r3, #0]

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
   12dec:	f243 030c 	movw	r3, #12300	; 0x300c
   12df0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12df4:	681b      	ldr	r3, [r3, #0]
   12df6:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
   12dfa:	b2db      	uxtb	r3, r3
   12dfc:	2b02      	cmp	r3, #2
   12dfe:	d003      	beq.n	12e08 <xTaskNotifyWait+0xb0>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
   12e00:	f04f 0300 	mov.w	r3, #0
   12e04:	617b      	str	r3, [r7, #20]
   12e06:	e00e      	b.n	12e26 <xTaskNotifyWait+0xce>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
   12e08:	f243 030c 	movw	r3, #12300	; 0x300c
   12e0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12e10:	681b      	ldr	r3, [r3, #0]
   12e12:	6d59      	ldr	r1, [r3, #84]	; 0x54
   12e14:	68ba      	ldr	r2, [r7, #8]
   12e16:	ea6f 0202 	mvn.w	r2, r2
   12e1a:	ea01 0202 	and.w	r2, r1, r2
   12e1e:	655a      	str	r2, [r3, #84]	; 0x54
				xReturn = pdTRUE;
   12e20:	f04f 0301 	mov.w	r3, #1
   12e24:	617b      	str	r3, [r7, #20]
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   12e26:	f243 030c 	movw	r3, #12300	; 0x300c
   12e2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12e2e:	681b      	ldr	r3, [r3, #0]
   12e30:	f04f 0200 	mov.w	r2, #0
   12e34:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
		}
		taskEXIT_CRITICAL();
   12e38:	f001 fa56 	bl	142e8 <vPortExitCritical>

		return xReturn;
   12e3c:	697b      	ldr	r3, [r7, #20]
	}
   12e3e:	4618      	mov	r0, r3
   12e40:	f107 0718 	add.w	r7, r7, #24
   12e44:	46bd      	mov	sp, r7
   12e46:	bd80      	pop	{r7, pc}

00012e48 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
   12e48:	b580      	push	{r7, lr}
   12e4a:	b08a      	sub	sp, #40	; 0x28
   12e4c:	af00      	add	r7, sp, #0
   12e4e:	60f8      	str	r0, [r7, #12]
   12e50:	60b9      	str	r1, [r7, #8]
   12e52:	603b      	str	r3, [r7, #0]
   12e54:	4613      	mov	r3, r2
   12e56:	71fb      	strb	r3, [r7, #7]
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
   12e58:	f04f 0301 	mov.w	r3, #1
   12e5c:	617b      	str	r3, [r7, #20]
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
   12e5e:	68fb      	ldr	r3, [r7, #12]
   12e60:	2b00      	cmp	r3, #0
   12e62:	d109      	bne.n	12e78 <xTaskGenericNotify+0x30>
   12e64:	f04f 0328 	mov.w	r3, #40	; 0x28
   12e68:	f383 8811 	msr	BASEPRI, r3
   12e6c:	f3bf 8f6f 	isb	sy
   12e70:	f3bf 8f4f 	dsb	sy
   12e74:	61fb      	str	r3, [r7, #28]
   12e76:	e7fe      	b.n	12e76 <xTaskGenericNotify+0x2e>
		pxTCB = xTaskToNotify;
   12e78:	68fb      	ldr	r3, [r7, #12]
   12e7a:	613b      	str	r3, [r7, #16]

		taskENTER_CRITICAL();
   12e7c:	f001 f9fc 	bl	14278 <vPortEnterCritical>
		{
			if( pulPreviousNotificationValue != NULL )
   12e80:	683b      	ldr	r3, [r7, #0]
   12e82:	2b00      	cmp	r3, #0
   12e84:	d003      	beq.n	12e8e <xTaskGenericNotify+0x46>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
   12e86:	693b      	ldr	r3, [r7, #16]
   12e88:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   12e8a:	683b      	ldr	r3, [r7, #0]
   12e8c:	601a      	str	r2, [r3, #0]
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
   12e8e:	693b      	ldr	r3, [r7, #16]
   12e90:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
   12e94:	76fb      	strb	r3, [r7, #27]

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   12e96:	693b      	ldr	r3, [r7, #16]
   12e98:	f04f 0202 	mov.w	r2, #2
   12e9c:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

			switch( eAction )
   12ea0:	79fb      	ldrb	r3, [r7, #7]
   12ea2:	2b04      	cmp	r3, #4
   12ea4:	d82a      	bhi.n	12efc <xTaskGenericNotify+0xb4>
   12ea6:	a201      	add	r2, pc, #4	; (adr r2, 12eac <xTaskGenericNotify+0x64>)
   12ea8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   12eac:	00012f1b 	.word	0x00012f1b
   12eb0:	00012ec1 	.word	0x00012ec1
   12eb4:	00012ed1 	.word	0x00012ed1
   12eb8:	00012edf 	.word	0x00012edf
   12ebc:	00012ee7 	.word	0x00012ee7
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
   12ec0:	693b      	ldr	r3, [r7, #16]
   12ec2:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   12ec4:	68bb      	ldr	r3, [r7, #8]
   12ec6:	ea42 0203 	orr.w	r2, r2, r3
   12eca:	693b      	ldr	r3, [r7, #16]
   12ecc:	655a      	str	r2, [r3, #84]	; 0x54
					break;
   12ece:	e025      	b.n	12f1c <xTaskGenericNotify+0xd4>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
   12ed0:	693b      	ldr	r3, [r7, #16]
   12ed2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   12ed4:	f103 0201 	add.w	r2, r3, #1
   12ed8:	693b      	ldr	r3, [r7, #16]
   12eda:	655a      	str	r2, [r3, #84]	; 0x54
					break;
   12edc:	e01e      	b.n	12f1c <xTaskGenericNotify+0xd4>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
   12ede:	693b      	ldr	r3, [r7, #16]
   12ee0:	68ba      	ldr	r2, [r7, #8]
   12ee2:	655a      	str	r2, [r3, #84]	; 0x54
					break;
   12ee4:	e01a      	b.n	12f1c <xTaskGenericNotify+0xd4>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
   12ee6:	7efb      	ldrb	r3, [r7, #27]
   12ee8:	2b02      	cmp	r3, #2
   12eea:	d003      	beq.n	12ef4 <xTaskGenericNotify+0xac>
					{
						pxTCB->ulNotifiedValue = ulValue;
   12eec:	693b      	ldr	r3, [r7, #16]
   12eee:	68ba      	ldr	r2, [r7, #8]
   12ef0:	655a      	str	r2, [r3, #84]	; 0x54
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
   12ef2:	e013      	b.n	12f1c <xTaskGenericNotify+0xd4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
   12ef4:	f04f 0300 	mov.w	r3, #0
   12ef8:	617b      	str	r3, [r7, #20]
					}
					break;
   12efa:	e00f      	b.n	12f1c <xTaskGenericNotify+0xd4>

				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
   12efc:	693b      	ldr	r3, [r7, #16]
   12efe:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   12f00:	f1b3 3fff 	cmp.w	r3, #4294967295
   12f04:	d00a      	beq.n	12f1c <xTaskGenericNotify+0xd4>
   12f06:	f04f 0328 	mov.w	r3, #40	; 0x28
   12f0a:	f383 8811 	msr	BASEPRI, r3
   12f0e:	f3bf 8f6f 	isb	sy
   12f12:	f3bf 8f4f 	dsb	sy
   12f16:	623b      	str	r3, [r7, #32]
   12f18:	e7fe      	b.n	12f18 <xTaskGenericNotify+0xd0>
					break;

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
   12f1a:	bf00      	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   12f1c:	7efb      	ldrb	r3, [r7, #27]
   12f1e:	2b01      	cmp	r3, #1
   12f20:	d14f      	bne.n	12fc2 <xTaskGenericNotify+0x17a>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   12f22:	693b      	ldr	r3, [r7, #16]
   12f24:	f103 0304 	add.w	r3, r3, #4
   12f28:	4618      	mov	r0, r3
   12f2a:	f7fc f967 	bl	f1fc <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
   12f2e:	693b      	ldr	r3, [r7, #16]
   12f30:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   12f32:	f04f 0201 	mov.w	r2, #1
   12f36:	fa02 f203 	lsl.w	r2, r2, r3
   12f3a:	f243 03ec 	movw	r3, #12524	; 0x30ec
   12f3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12f42:	681b      	ldr	r3, [r3, #0]
   12f44:	ea42 0203 	orr.w	r2, r2, r3
   12f48:	f243 03ec 	movw	r3, #12524	; 0x30ec
   12f4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12f50:	601a      	str	r2, [r3, #0]
   12f52:	693b      	ldr	r3, [r7, #16]
   12f54:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12f56:	4613      	mov	r3, r2
   12f58:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12f5c:	4413      	add	r3, r2
   12f5e:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12f62:	461a      	mov	r2, r3
   12f64:	f243 0310 	movw	r3, #12304	; 0x3010
   12f68:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12f6c:	441a      	add	r2, r3
   12f6e:	693b      	ldr	r3, [r7, #16]
   12f70:	f103 0304 	add.w	r3, r3, #4
   12f74:	4610      	mov	r0, r2
   12f76:	4619      	mov	r1, r3
   12f78:	f7fc f8e2 	bl	f140 <vListInsertEnd>

				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   12f7c:	693b      	ldr	r3, [r7, #16]
   12f7e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   12f80:	2b00      	cmp	r3, #0
   12f82:	d009      	beq.n	12f98 <xTaskGenericNotify+0x150>
   12f84:	f04f 0328 	mov.w	r3, #40	; 0x28
   12f88:	f383 8811 	msr	BASEPRI, r3
   12f8c:	f3bf 8f6f 	isb	sy
   12f90:	f3bf 8f4f 	dsb	sy
   12f94:	627b      	str	r3, [r7, #36]	; 0x24
   12f96:	e7fe      	b.n	12f96 <xTaskGenericNotify+0x14e>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   12f98:	693b      	ldr	r3, [r7, #16]
   12f9a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12f9c:	f243 030c 	movw	r3, #12300	; 0x300c
   12fa0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12fa4:	681b      	ldr	r3, [r3, #0]
   12fa6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   12fa8:	429a      	cmp	r2, r3
   12faa:	d90a      	bls.n	12fc2 <xTaskGenericNotify+0x17a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
   12fac:	f64e 5304 	movw	r3, #60676	; 0xed04
   12fb0:	f2ce 0300 	movt	r3, #57344	; 0xe000
   12fb4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   12fb8:	601a      	str	r2, [r3, #0]
   12fba:	f3bf 8f4f 	dsb	sy
   12fbe:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
   12fc2:	f001 f991 	bl	142e8 <vPortExitCritical>

		return xReturn;
   12fc6:	697b      	ldr	r3, [r7, #20]
	}
   12fc8:	4618      	mov	r0, r3
   12fca:	f107 0728 	add.w	r7, r7, #40	; 0x28
   12fce:	46bd      	mov	sp, r7
   12fd0:	bd80      	pop	{r7, pc}
   12fd2:	bf00      	nop

00012fd4 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
   12fd4:	b580      	push	{r7, lr}
   12fd6:	b08e      	sub	sp, #56	; 0x38
   12fd8:	af00      	add	r7, sp, #0
   12fda:	60f8      	str	r0, [r7, #12]
   12fdc:	60b9      	str	r1, [r7, #8]
   12fde:	603b      	str	r3, [r7, #0]
   12fe0:	4613      	mov	r3, r2
   12fe2:	71fb      	strb	r3, [r7, #7]
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
   12fe4:	f04f 0301 	mov.w	r3, #1
   12fe8:	61bb      	str	r3, [r7, #24]
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
   12fea:	68fb      	ldr	r3, [r7, #12]
   12fec:	2b00      	cmp	r3, #0
   12fee:	d109      	bne.n	13004 <xTaskGenericNotifyFromISR+0x30>
   12ff0:	f04f 0328 	mov.w	r3, #40	; 0x28
   12ff4:	f383 8811 	msr	BASEPRI, r3
   12ff8:	f3bf 8f6f 	isb	sy
   12ffc:	f3bf 8f4f 	dsb	sy
   13000:	623b      	str	r3, [r7, #32]
   13002:	e7fe      	b.n	13002 <xTaskGenericNotifyFromISR+0x2e>
		below the maximum system call interrupt priority.  FreeRTOS maintains a
		separate interrupt safe API to ensure interrupt entry is as fast and as
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   13004:	f001 fa1c 	bl	14440 <vPortValidateInterruptPriority>

		pxTCB = xTaskToNotify;
   13008:	68fb      	ldr	r3, [r7, #12]
   1300a:	613b      	str	r3, [r7, #16]

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
   1300c:	f3ef 8211 	mrs	r2, BASEPRI
   13010:	f04f 0328 	mov.w	r3, #40	; 0x28
   13014:	f383 8811 	msr	BASEPRI, r3
   13018:	f3bf 8f6f 	isb	sy
   1301c:	f3bf 8f4f 	dsb	sy
   13020:	62ba      	str	r2, [r7, #40]	; 0x28
   13022:	627b      	str	r3, [r7, #36]	; 0x24
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
   13024:	6abb      	ldr	r3, [r7, #40]	; 0x28

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   13026:	61fb      	str	r3, [r7, #28]
		{
			if( pulPreviousNotificationValue != NULL )
   13028:	683b      	ldr	r3, [r7, #0]
   1302a:	2b00      	cmp	r3, #0
   1302c:	d003      	beq.n	13036 <xTaskGenericNotifyFromISR+0x62>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
   1302e:	693b      	ldr	r3, [r7, #16]
   13030:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   13032:	683b      	ldr	r3, [r7, #0]
   13034:	601a      	str	r2, [r3, #0]
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
   13036:	693b      	ldr	r3, [r7, #16]
   13038:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
   1303c:	75fb      	strb	r3, [r7, #23]
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   1303e:	693b      	ldr	r3, [r7, #16]
   13040:	f04f 0202 	mov.w	r2, #2
   13044:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

			switch( eAction )
   13048:	79fb      	ldrb	r3, [r7, #7]
   1304a:	2b04      	cmp	r3, #4
   1304c:	d82a      	bhi.n	130a4 <xTaskGenericNotifyFromISR+0xd0>
   1304e:	a201      	add	r2, pc, #4	; (adr r2, 13054 <xTaskGenericNotifyFromISR+0x80>)
   13050:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   13054:	000130c3 	.word	0x000130c3
   13058:	00013069 	.word	0x00013069
   1305c:	00013079 	.word	0x00013079
   13060:	00013087 	.word	0x00013087
   13064:	0001308f 	.word	0x0001308f
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
   13068:	693b      	ldr	r3, [r7, #16]
   1306a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   1306c:	68bb      	ldr	r3, [r7, #8]
   1306e:	ea42 0203 	orr.w	r2, r2, r3
   13072:	693b      	ldr	r3, [r7, #16]
   13074:	655a      	str	r2, [r3, #84]	; 0x54
					break;
   13076:	e025      	b.n	130c4 <xTaskGenericNotifyFromISR+0xf0>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
   13078:	693b      	ldr	r3, [r7, #16]
   1307a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   1307c:	f103 0201 	add.w	r2, r3, #1
   13080:	693b      	ldr	r3, [r7, #16]
   13082:	655a      	str	r2, [r3, #84]	; 0x54
					break;
   13084:	e01e      	b.n	130c4 <xTaskGenericNotifyFromISR+0xf0>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
   13086:	693b      	ldr	r3, [r7, #16]
   13088:	68ba      	ldr	r2, [r7, #8]
   1308a:	655a      	str	r2, [r3, #84]	; 0x54
					break;
   1308c:	e01a      	b.n	130c4 <xTaskGenericNotifyFromISR+0xf0>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
   1308e:	7dfb      	ldrb	r3, [r7, #23]
   13090:	2b02      	cmp	r3, #2
   13092:	d003      	beq.n	1309c <xTaskGenericNotifyFromISR+0xc8>
					{
						pxTCB->ulNotifiedValue = ulValue;
   13094:	693b      	ldr	r3, [r7, #16]
   13096:	68ba      	ldr	r2, [r7, #8]
   13098:	655a      	str	r2, [r3, #84]	; 0x54
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
   1309a:	e013      	b.n	130c4 <xTaskGenericNotifyFromISR+0xf0>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
   1309c:	f04f 0300 	mov.w	r3, #0
   130a0:	61bb      	str	r3, [r7, #24]
					}
					break;
   130a2:	e00f      	b.n	130c4 <xTaskGenericNotifyFromISR+0xf0>

				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
   130a4:	693b      	ldr	r3, [r7, #16]
   130a6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   130a8:	f1b3 3fff 	cmp.w	r3, #4294967295
   130ac:	d00a      	beq.n	130c4 <xTaskGenericNotifyFromISR+0xf0>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   130ae:	f04f 0328 	mov.w	r3, #40	; 0x28
   130b2:	f383 8811 	msr	BASEPRI, r3
   130b6:	f3bf 8f6f 	isb	sy
   130ba:	f3bf 8f4f 	dsb	sy
   130be:	62fb      	str	r3, [r7, #44]	; 0x2c
   130c0:	e7fe      	b.n	130c0 <xTaskGenericNotifyFromISR+0xec>
					break;

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
   130c2:	bf00      	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   130c4:	7dfb      	ldrb	r3, [r7, #23]
   130c6:	2b01      	cmp	r3, #1
   130c8:	d164      	bne.n	13194 <xTaskGenericNotifyFromISR+0x1c0>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   130ca:	693b      	ldr	r3, [r7, #16]
   130cc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   130ce:	2b00      	cmp	r3, #0
   130d0:	d009      	beq.n	130e6 <xTaskGenericNotifyFromISR+0x112>
   130d2:	f04f 0328 	mov.w	r3, #40	; 0x28
   130d6:	f383 8811 	msr	BASEPRI, r3
   130da:	f3bf 8f6f 	isb	sy
   130de:	f3bf 8f4f 	dsb	sy
   130e2:	633b      	str	r3, [r7, #48]	; 0x30
   130e4:	e7fe      	b.n	130e4 <xTaskGenericNotifyFromISR+0x110>

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   130e6:	f243 130c 	movw	r3, #12556	; 0x310c
   130ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
   130ee:	681b      	ldr	r3, [r3, #0]
   130f0:	2b00      	cmp	r3, #0
   130f2:	d12d      	bne.n	13150 <xTaskGenericNotifyFromISR+0x17c>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   130f4:	693b      	ldr	r3, [r7, #16]
   130f6:	f103 0304 	add.w	r3, r3, #4
   130fa:	4618      	mov	r0, r3
   130fc:	f7fc f87e 	bl	f1fc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   13100:	693b      	ldr	r3, [r7, #16]
   13102:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13104:	f04f 0201 	mov.w	r2, #1
   13108:	fa02 f203 	lsl.w	r2, r2, r3
   1310c:	f243 03ec 	movw	r3, #12524	; 0x30ec
   13110:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13114:	681b      	ldr	r3, [r3, #0]
   13116:	ea42 0203 	orr.w	r2, r2, r3
   1311a:	f243 03ec 	movw	r3, #12524	; 0x30ec
   1311e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13122:	601a      	str	r2, [r3, #0]
   13124:	693b      	ldr	r3, [r7, #16]
   13126:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13128:	4613      	mov	r3, r2
   1312a:	ea4f 0383 	mov.w	r3, r3, lsl #2
   1312e:	4413      	add	r3, r2
   13130:	ea4f 0383 	mov.w	r3, r3, lsl #2
   13134:	461a      	mov	r2, r3
   13136:	f243 0310 	movw	r3, #12304	; 0x3010
   1313a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1313e:	441a      	add	r2, r3
   13140:	693b      	ldr	r3, [r7, #16]
   13142:	f103 0304 	add.w	r3, r3, #4
   13146:	4610      	mov	r0, r2
   13148:	4619      	mov	r1, r3
   1314a:	f7fb fff9 	bl	f140 <vListInsertEnd>
   1314e:	e009      	b.n	13164 <xTaskGenericNotifyFromISR+0x190>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   13150:	693b      	ldr	r3, [r7, #16]
   13152:	f103 0318 	add.w	r3, r3, #24
   13156:	f243 00a4 	movw	r0, #12452	; 0x30a4
   1315a:	f2c2 0000 	movt	r0, #8192	; 0x2000
   1315e:	4619      	mov	r1, r3
   13160:	f7fb ffee 	bl	f140 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   13164:	693b      	ldr	r3, [r7, #16]
   13166:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13168:	f243 030c 	movw	r3, #12300	; 0x300c
   1316c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13170:	681b      	ldr	r3, [r3, #0]
   13172:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13174:	429a      	cmp	r2, r3
   13176:	d90d      	bls.n	13194 <xTaskGenericNotifyFromISR+0x1c0>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
   13178:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1317a:	2b00      	cmp	r3, #0
   1317c:	d003      	beq.n	13186 <xTaskGenericNotifyFromISR+0x1b2>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
   1317e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   13180:	f04f 0201 	mov.w	r2, #1
   13184:	601a      	str	r2, [r3, #0]
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
   13186:	f243 03f8 	movw	r3, #12536	; 0x30f8
   1318a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1318e:	f04f 0201 	mov.w	r2, #1
   13192:	601a      	str	r2, [r3, #0]
   13194:	69fb      	ldr	r3, [r7, #28]
   13196:	637b      	str	r3, [r7, #52]	; 0x34
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   13198:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1319a:	f383 8811 	msr	BASEPRI, r3
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
   1319e:	69bb      	ldr	r3, [r7, #24]
	}
   131a0:	4618      	mov	r0, r3
   131a2:	f107 0738 	add.w	r7, r7, #56	; 0x38
   131a6:	46bd      	mov	sp, r7
   131a8:	bd80      	pop	{r7, pc}
   131aa:	bf00      	nop

000131ac <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
   131ac:	b580      	push	{r7, lr}
   131ae:	b08a      	sub	sp, #40	; 0x28
   131b0:	af00      	add	r7, sp, #0
   131b2:	6078      	str	r0, [r7, #4]
   131b4:	6039      	str	r1, [r7, #0]
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
   131b6:	687b      	ldr	r3, [r7, #4]
   131b8:	2b00      	cmp	r3, #0
   131ba:	d109      	bne.n	131d0 <vTaskNotifyGiveFromISR+0x24>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   131bc:	f04f 0328 	mov.w	r3, #40	; 0x28
   131c0:	f383 8811 	msr	BASEPRI, r3
   131c4:	f3bf 8f6f 	isb	sy
   131c8:	f3bf 8f4f 	dsb	sy
   131cc:	617b      	str	r3, [r7, #20]
   131ce:	e7fe      	b.n	131ce <vTaskNotifyGiveFromISR+0x22>
		below the maximum system call interrupt priority.  FreeRTOS maintains a
		separate interrupt safe API to ensure interrupt entry is as fast and as
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   131d0:	f001 f936 	bl	14440 <vPortValidateInterruptPriority>

		pxTCB = xTaskToNotify;
   131d4:	687b      	ldr	r3, [r7, #4]
   131d6:	60bb      	str	r3, [r7, #8]

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
   131d8:	f3ef 8211 	mrs	r2, BASEPRI
   131dc:	f04f 0328 	mov.w	r3, #40	; 0x28
   131e0:	f383 8811 	msr	BASEPRI, r3
   131e4:	f3bf 8f6f 	isb	sy
   131e8:	f3bf 8f4f 	dsb	sy
   131ec:	61fa      	str	r2, [r7, #28]
   131ee:	61bb      	str	r3, [r7, #24]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
   131f0:	69fb      	ldr	r3, [r7, #28]

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   131f2:	613b      	str	r3, [r7, #16]
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
   131f4:	68bb      	ldr	r3, [r7, #8]
   131f6:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
   131fa:	73fb      	strb	r3, [r7, #15]
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   131fc:	68bb      	ldr	r3, [r7, #8]
   131fe:	f04f 0202 	mov.w	r2, #2
   13202:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
   13206:	68bb      	ldr	r3, [r7, #8]
   13208:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   1320a:	f103 0201 	add.w	r2, r3, #1
   1320e:	68bb      	ldr	r3, [r7, #8]
   13210:	655a      	str	r2, [r3, #84]	; 0x54

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   13212:	7bfb      	ldrb	r3, [r7, #15]
   13214:	2b01      	cmp	r3, #1
   13216:	d164      	bne.n	132e2 <vTaskNotifyGiveFromISR+0x136>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   13218:	68bb      	ldr	r3, [r7, #8]
   1321a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1321c:	2b00      	cmp	r3, #0
   1321e:	d009      	beq.n	13234 <vTaskNotifyGiveFromISR+0x88>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   13220:	f04f 0328 	mov.w	r3, #40	; 0x28
   13224:	f383 8811 	msr	BASEPRI, r3
   13228:	f3bf 8f6f 	isb	sy
   1322c:	f3bf 8f4f 	dsb	sy
   13230:	623b      	str	r3, [r7, #32]
   13232:	e7fe      	b.n	13232 <vTaskNotifyGiveFromISR+0x86>

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   13234:	f243 130c 	movw	r3, #12556	; 0x310c
   13238:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1323c:	681b      	ldr	r3, [r3, #0]
   1323e:	2b00      	cmp	r3, #0
   13240:	d12d      	bne.n	1329e <vTaskNotifyGiveFromISR+0xf2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   13242:	68bb      	ldr	r3, [r7, #8]
   13244:	f103 0304 	add.w	r3, r3, #4
   13248:	4618      	mov	r0, r3
   1324a:	f7fb ffd7 	bl	f1fc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   1324e:	68bb      	ldr	r3, [r7, #8]
   13250:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13252:	f04f 0201 	mov.w	r2, #1
   13256:	fa02 f203 	lsl.w	r2, r2, r3
   1325a:	f243 03ec 	movw	r3, #12524	; 0x30ec
   1325e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13262:	681b      	ldr	r3, [r3, #0]
   13264:	ea42 0203 	orr.w	r2, r2, r3
   13268:	f243 03ec 	movw	r3, #12524	; 0x30ec
   1326c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13270:	601a      	str	r2, [r3, #0]
   13272:	68bb      	ldr	r3, [r7, #8]
   13274:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13276:	4613      	mov	r3, r2
   13278:	ea4f 0383 	mov.w	r3, r3, lsl #2
   1327c:	4413      	add	r3, r2
   1327e:	ea4f 0383 	mov.w	r3, r3, lsl #2
   13282:	461a      	mov	r2, r3
   13284:	f243 0310 	movw	r3, #12304	; 0x3010
   13288:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1328c:	441a      	add	r2, r3
   1328e:	68bb      	ldr	r3, [r7, #8]
   13290:	f103 0304 	add.w	r3, r3, #4
   13294:	4610      	mov	r0, r2
   13296:	4619      	mov	r1, r3
   13298:	f7fb ff52 	bl	f140 <vListInsertEnd>
   1329c:	e009      	b.n	132b2 <vTaskNotifyGiveFromISR+0x106>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   1329e:	68bb      	ldr	r3, [r7, #8]
   132a0:	f103 0318 	add.w	r3, r3, #24
   132a4:	f243 00a4 	movw	r0, #12452	; 0x30a4
   132a8:	f2c2 0000 	movt	r0, #8192	; 0x2000
   132ac:	4619      	mov	r1, r3
   132ae:	f7fb ff47 	bl	f140 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   132b2:	68bb      	ldr	r3, [r7, #8]
   132b4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   132b6:	f243 030c 	movw	r3, #12300	; 0x300c
   132ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
   132be:	681b      	ldr	r3, [r3, #0]
   132c0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   132c2:	429a      	cmp	r2, r3
   132c4:	d90d      	bls.n	132e2 <vTaskNotifyGiveFromISR+0x136>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
   132c6:	683b      	ldr	r3, [r7, #0]
   132c8:	2b00      	cmp	r3, #0
   132ca:	d003      	beq.n	132d4 <vTaskNotifyGiveFromISR+0x128>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
   132cc:	683b      	ldr	r3, [r7, #0]
   132ce:	f04f 0201 	mov.w	r2, #1
   132d2:	601a      	str	r2, [r3, #0]
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
   132d4:	f243 03f8 	movw	r3, #12536	; 0x30f8
   132d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   132dc:	f04f 0201 	mov.w	r2, #1
   132e0:	601a      	str	r2, [r3, #0]
   132e2:	693b      	ldr	r3, [r7, #16]
   132e4:	627b      	str	r3, [r7, #36]	; 0x24
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   132e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   132e8:	f383 8811 	msr	BASEPRI, r3
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
   132ec:	f107 0728 	add.w	r7, r7, #40	; 0x28
   132f0:	46bd      	mov	sp, r7
   132f2:	bd80      	pop	{r7, pc}

000132f4 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
   132f4:	b580      	push	{r7, lr}
   132f6:	b084      	sub	sp, #16
   132f8:	af00      	add	r7, sp, #0
   132fa:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
   132fc:	687b      	ldr	r3, [r7, #4]
   132fe:	2b00      	cmp	r3, #0
   13300:	d105      	bne.n	1330e <xTaskNotifyStateClear+0x1a>
   13302:	f243 030c 	movw	r3, #12300	; 0x300c
   13306:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1330a:	681b      	ldr	r3, [r3, #0]
   1330c:	e000      	b.n	13310 <xTaskNotifyStateClear+0x1c>
   1330e:	687b      	ldr	r3, [r7, #4]
   13310:	60bb      	str	r3, [r7, #8]

		taskENTER_CRITICAL();
   13312:	f000 ffb1 	bl	14278 <vPortEnterCritical>
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
   13316:	68bb      	ldr	r3, [r7, #8]
   13318:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
   1331c:	b2db      	uxtb	r3, r3
   1331e:	2b02      	cmp	r3, #2
   13320:	d108      	bne.n	13334 <xTaskNotifyStateClear+0x40>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   13322:	68bb      	ldr	r3, [r7, #8]
   13324:	f04f 0200 	mov.w	r2, #0
   13328:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
				xReturn = pdPASS;
   1332c:	f04f 0301 	mov.w	r3, #1
   13330:	60fb      	str	r3, [r7, #12]
   13332:	e002      	b.n	1333a <xTaskNotifyStateClear+0x46>
			}
			else
			{
				xReturn = pdFAIL;
   13334:	f04f 0300 	mov.w	r3, #0
   13338:	60fb      	str	r3, [r7, #12]
			}
		}
		taskEXIT_CRITICAL();
   1333a:	f000 ffd5 	bl	142e8 <vPortExitCritical>

		return xReturn;
   1333e:	68fb      	ldr	r3, [r7, #12]
	}
   13340:	4618      	mov	r0, r3
   13342:	f107 0710 	add.w	r7, r7, #16
   13346:	46bd      	mov	sp, r7
   13348:	bd80      	pop	{r7, pc}
   1334a:	bf00      	nop

0001334c <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
   1334c:	b580      	push	{r7, lr}
   1334e:	b084      	sub	sp, #16
   13350:	af00      	add	r7, sp, #0
   13352:	6078      	str	r0, [r7, #4]
   13354:	6039      	str	r1, [r7, #0]
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
   13356:	f243 03e8 	movw	r3, #12520	; 0x30e8
   1335a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1335e:	681b      	ldr	r3, [r3, #0]
   13360:	60fb      	str	r3, [r7, #12]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   13362:	f243 030c 	movw	r3, #12300	; 0x300c
   13366:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1336a:	681b      	ldr	r3, [r3, #0]
   1336c:	f103 0304 	add.w	r3, r3, #4
   13370:	4618      	mov	r0, r3
   13372:	f7fb ff43 	bl	f1fc <uxListRemove>
   13376:	4603      	mov	r3, r0
   13378:	2b00      	cmp	r3, #0
   1337a:	d117      	bne.n	133ac <prvAddCurrentTaskToDelayedList+0x60>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
   1337c:	f243 030c 	movw	r3, #12300	; 0x300c
   13380:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13384:	681b      	ldr	r3, [r3, #0]
   13386:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13388:	f04f 0201 	mov.w	r2, #1
   1338c:	fa02 f303 	lsl.w	r3, r2, r3
   13390:	ea6f 0203 	mvn.w	r2, r3
   13394:	f243 03ec 	movw	r3, #12524	; 0x30ec
   13398:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1339c:	681b      	ldr	r3, [r3, #0]
   1339e:	ea02 0203 	and.w	r2, r2, r3
   133a2:	f243 03ec 	movw	r3, #12524	; 0x30ec
   133a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   133aa:	601a      	str	r2, [r3, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   133ac:	687b      	ldr	r3, [r7, #4]
   133ae:	f1b3 3fff 	cmp.w	r3, #4294967295
   133b2:	d111      	bne.n	133d8 <prvAddCurrentTaskToDelayedList+0x8c>
   133b4:	683b      	ldr	r3, [r7, #0]
   133b6:	2b00      	cmp	r3, #0
   133b8:	d00e      	beq.n	133d8 <prvAddCurrentTaskToDelayedList+0x8c>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
   133ba:	f243 030c 	movw	r3, #12300	; 0x300c
   133be:	f2c2 0300 	movt	r3, #8192	; 0x2000
   133c2:	681b      	ldr	r3, [r3, #0]
   133c4:	f103 0304 	add.w	r3, r3, #4
   133c8:	f243 00d0 	movw	r0, #12496	; 0x30d0
   133cc:	f2c2 0000 	movt	r0, #8192	; 0x2000
   133d0:	4619      	mov	r1, r3
   133d2:	f7fb feb5 	bl	f140 <vListInsertEnd>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   133d6:	e03d      	b.n	13454 <prvAddCurrentTaskToDelayedList+0x108>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
   133d8:	68fa      	ldr	r2, [r7, #12]
   133da:	687b      	ldr	r3, [r7, #4]
   133dc:	4413      	add	r3, r2
   133de:	60bb      	str	r3, [r7, #8]

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   133e0:	f243 030c 	movw	r3, #12300	; 0x300c
   133e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   133e8:	681b      	ldr	r3, [r3, #0]
   133ea:	68ba      	ldr	r2, [r7, #8]
   133ec:	605a      	str	r2, [r3, #4]

			if( xTimeToWake < xConstTickCount )
   133ee:	68ba      	ldr	r2, [r7, #8]
   133f0:	68fb      	ldr	r3, [r7, #12]
   133f2:	429a      	cmp	r2, r3
   133f4:	d210      	bcs.n	13418 <prvAddCurrentTaskToDelayedList+0xcc>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   133f6:	f243 03a0 	movw	r3, #12448	; 0x30a0
   133fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
   133fe:	681a      	ldr	r2, [r3, #0]
   13400:	f243 030c 	movw	r3, #12300	; 0x300c
   13404:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13408:	681b      	ldr	r3, [r3, #0]
   1340a:	f103 0304 	add.w	r3, r3, #4
   1340e:	4610      	mov	r0, r2
   13410:	4619      	mov	r1, r3
   13412:	f7fb feb9 	bl	f188 <vListInsert>
   13416:	e01d      	b.n	13454 <prvAddCurrentTaskToDelayedList+0x108>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   13418:	f243 039c 	movw	r3, #12444	; 0x309c
   1341c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13420:	681a      	ldr	r2, [r3, #0]
   13422:	f243 030c 	movw	r3, #12300	; 0x300c
   13426:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1342a:	681b      	ldr	r3, [r3, #0]
   1342c:	f103 0304 	add.w	r3, r3, #4
   13430:	4610      	mov	r0, r2
   13432:	4619      	mov	r1, r3
   13434:	f7fb fea8 	bl	f188 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
   13438:	f243 1304 	movw	r3, #12548	; 0x3104
   1343c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13440:	681b      	ldr	r3, [r3, #0]
   13442:	68ba      	ldr	r2, [r7, #8]
   13444:	429a      	cmp	r2, r3
   13446:	d205      	bcs.n	13454 <prvAddCurrentTaskToDelayedList+0x108>
				{
					xNextTaskUnblockTime = xTimeToWake;
   13448:	f243 1304 	movw	r3, #12548	; 0x3104
   1344c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13450:	68ba      	ldr	r2, [r7, #8]
   13452:	601a      	str	r2, [r3, #0]

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
   13454:	f107 0710 	add.w	r7, r7, #16
   13458:	46bd      	mov	sp, r7
   1345a:	bd80      	pop	{r7, pc}

0001345c <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
   1345c:	b580      	push	{r7, lr}
   1345e:	b084      	sub	sp, #16
   13460:	af02      	add	r7, sp, #8
BaseType_t xReturn = pdFAIL;
   13462:	f04f 0300 	mov.w	r3, #0
   13466:	603b      	str	r3, [r7, #0]

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
   13468:	f000 fbce 	bl	13c08 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
   1346c:	f243 1348 	movw	r3, #12616	; 0x3148
   13470:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13474:	681b      	ldr	r3, [r3, #0]
   13476:	2b00      	cmp	r3, #0
   13478:	d017      	beq.n	134aa <xTimerCreateTimerTask+0x4e>
				xReturn = pdPASS;
			}
		}
		#else
		{
			xReturn = xTaskCreate(	prvTimerTask,
   1347a:	f04f 0302 	mov.w	r3, #2
   1347e:	9300      	str	r3, [sp, #0]
   13480:	f243 134c 	movw	r3, #12620	; 0x314c
   13484:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13488:	9301      	str	r3, [sp, #4]
   1348a:	f243 70b9 	movw	r0, #14265	; 0x37b9
   1348e:	f2c0 0001 	movt	r0, #1
   13492:	f244 0184 	movw	r1, #16516	; 0x4084
   13496:	f2c0 0102 	movt	r1, #2
   1349a:	f04f 02b4 	mov.w	r2, #180	; 0xb4
   1349e:	f04f 0300 	mov.w	r3, #0
   134a2:	f7fd f925 	bl	106f0 <xTaskCreate>
   134a6:	4603      	mov	r3, r0
   134a8:	603b      	str	r3, [r7, #0]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
   134aa:	683b      	ldr	r3, [r7, #0]
   134ac:	2b00      	cmp	r3, #0
   134ae:	d109      	bne.n	134c4 <xTimerCreateTimerTask+0x68>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   134b0:	f04f 0328 	mov.w	r3, #40	; 0x28
   134b4:	f383 8811 	msr	BASEPRI, r3
   134b8:	f3bf 8f6f 	isb	sy
   134bc:	f3bf 8f4f 	dsb	sy
   134c0:	607b      	str	r3, [r7, #4]
   134c2:	e7fe      	b.n	134c2 <xTimerCreateTimerTask+0x66>
	return xReturn;
   134c4:	683b      	ldr	r3, [r7, #0]
}
   134c6:	4618      	mov	r0, r3
   134c8:	f107 0708 	add.w	r7, r7, #8
   134cc:	46bd      	mov	sp, r7
   134ce:	bd80      	pop	{r7, pc}

000134d0 <xTimerCreate>:
	TimerHandle_t xTimerCreate(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
								const TickType_t xTimerPeriodInTicks,
								const UBaseType_t uxAutoReload,
								void * const pvTimerID,
								TimerCallbackFunction_t pxCallbackFunction )
	{
   134d0:	b580      	push	{r7, lr}
   134d2:	b088      	sub	sp, #32
   134d4:	af02      	add	r7, sp, #8
   134d6:	60f8      	str	r0, [r7, #12]
   134d8:	60b9      	str	r1, [r7, #8]
   134da:	607a      	str	r2, [r7, #4]
   134dc:	603b      	str	r3, [r7, #0]
	Timer_t *pxNewTimer;

		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
   134de:	f04f 002c 	mov.w	r0, #44	; 0x2c
   134e2:	f000 fc4d 	bl	13d80 <pvPortMalloc>
   134e6:	4603      	mov	r3, r0
   134e8:	617b      	str	r3, [r7, #20]

		if( pxNewTimer != NULL )
   134ea:	697b      	ldr	r3, [r7, #20]
   134ec:	2b00      	cmp	r3, #0
   134ee:	d009      	beq.n	13504 <xTimerCreate+0x34>
		{
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
   134f0:	6a3b      	ldr	r3, [r7, #32]
   134f2:	9300      	str	r3, [sp, #0]
   134f4:	697b      	ldr	r3, [r7, #20]
   134f6:	9301      	str	r3, [sp, #4]
   134f8:	68f8      	ldr	r0, [r7, #12]
   134fa:	68b9      	ldr	r1, [r7, #8]
   134fc:	687a      	ldr	r2, [r7, #4]
   134fe:	683b      	ldr	r3, [r7, #0]
   13500:	f000 f806 	bl	13510 <prvInitialiseNewTimer>
				pxNewTimer->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */
		}

		return pxNewTimer;
   13504:	697b      	ldr	r3, [r7, #20]
	}
   13506:	4618      	mov	r0, r3
   13508:	f107 0718 	add.w	r7, r7, #24
   1350c:	46bd      	mov	sp, r7
   1350e:	bd80      	pop	{r7, pc}

00013510 <prvInitialiseNewTimer>:
									const TickType_t xTimerPeriodInTicks,
									const UBaseType_t uxAutoReload,
									void * const pvTimerID,
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer )
{
   13510:	b580      	push	{r7, lr}
   13512:	b086      	sub	sp, #24
   13514:	af00      	add	r7, sp, #0
   13516:	60f8      	str	r0, [r7, #12]
   13518:	60b9      	str	r1, [r7, #8]
   1351a:	607a      	str	r2, [r7, #4]
   1351c:	603b      	str	r3, [r7, #0]
	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );
   1351e:	68bb      	ldr	r3, [r7, #8]
   13520:	2b00      	cmp	r3, #0
   13522:	d109      	bne.n	13538 <prvInitialiseNewTimer+0x28>
   13524:	f04f 0328 	mov.w	r3, #40	; 0x28
   13528:	f383 8811 	msr	BASEPRI, r3
   1352c:	f3bf 8f6f 	isb	sy
   13530:	f3bf 8f4f 	dsb	sy
   13534:	617b      	str	r3, [r7, #20]
   13536:	e7fe      	b.n	13536 <prvInitialiseNewTimer+0x26>

	if( pxNewTimer != NULL )
   13538:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1353a:	2b00      	cmp	r3, #0
   1353c:	d016      	beq.n	1356c <prvInitialiseNewTimer+0x5c>
	{
		/* Ensure the infrastructure used by the timer service task has been
		created/initialised. */
		prvCheckForValidListAndQueue();
   1353e:	f000 fb63 	bl	13c08 <prvCheckForValidListAndQueue>

		/* Initialise the timer structure members using the function
		parameters. */
		pxNewTimer->pcTimerName = pcTimerName;
   13542:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   13544:	68fa      	ldr	r2, [r7, #12]
   13546:	601a      	str	r2, [r3, #0]
		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
   13548:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1354a:	68ba      	ldr	r2, [r7, #8]
   1354c:	619a      	str	r2, [r3, #24]
		pxNewTimer->uxAutoReload = uxAutoReload;
   1354e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   13550:	687a      	ldr	r2, [r7, #4]
   13552:	61da      	str	r2, [r3, #28]
		pxNewTimer->pvTimerID = pvTimerID;
   13554:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   13556:	683a      	ldr	r2, [r7, #0]
   13558:	621a      	str	r2, [r3, #32]
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
   1355a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1355c:	6a3a      	ldr	r2, [r7, #32]
   1355e:	625a      	str	r2, [r3, #36]	; 0x24
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
   13560:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   13562:	f103 0304 	add.w	r3, r3, #4
   13566:	4618      	mov	r0, r3
   13568:	f7fb fddc 	bl	f124 <vListInitialiseItem>
		traceTIMER_CREATE( pxNewTimer );
	}
}
   1356c:	f107 0718 	add.w	r7, r7, #24
   13570:	46bd      	mov	sp, r7
   13572:	bd80      	pop	{r7, pc}

00013574 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
   13574:	b580      	push	{r7, lr}
   13576:	b08a      	sub	sp, #40	; 0x28
   13578:	af00      	add	r7, sp, #0
   1357a:	60f8      	str	r0, [r7, #12]
   1357c:	60b9      	str	r1, [r7, #8]
   1357e:	607a      	str	r2, [r7, #4]
   13580:	603b      	str	r3, [r7, #0]
BaseType_t xReturn = pdFAIL;
   13582:	f04f 0300 	mov.w	r3, #0
   13586:	623b      	str	r3, [r7, #32]
DaemonTaskMessage_t xMessage;

	configASSERT( xTimer );
   13588:	68fb      	ldr	r3, [r7, #12]
   1358a:	2b00      	cmp	r3, #0
   1358c:	d109      	bne.n	135a2 <xTimerGenericCommand+0x2e>
   1358e:	f04f 0328 	mov.w	r3, #40	; 0x28
   13592:	f383 8811 	msr	BASEPRI, r3
   13596:	f3bf 8f6f 	isb	sy
   1359a:	f3bf 8f4f 	dsb	sy
   1359e:	627b      	str	r3, [r7, #36]	; 0x24
   135a0:	e7fe      	b.n	135a0 <xTimerGenericCommand+0x2c>

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
   135a2:	f243 1348 	movw	r3, #12616	; 0x3148
   135a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   135aa:	681b      	ldr	r3, [r3, #0]
   135ac:	2b00      	cmp	r3, #0
   135ae:	d040      	beq.n	13632 <xTimerGenericCommand+0xbe>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
   135b0:	68bb      	ldr	r3, [r7, #8]
   135b2:	617b      	str	r3, [r7, #20]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
   135b4:	687b      	ldr	r3, [r7, #4]
   135b6:	61bb      	str	r3, [r7, #24]
		xMessage.u.xTimerParameters.pxTimer = xTimer;
   135b8:	68fb      	ldr	r3, [r7, #12]
   135ba:	61fb      	str	r3, [r7, #28]

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
   135bc:	68bb      	ldr	r3, [r7, #8]
   135be:	2b05      	cmp	r3, #5
   135c0:	dc27      	bgt.n	13612 <xTimerGenericCommand+0x9e>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
   135c2:	f7fe ff71 	bl	124a8 <xTaskGetSchedulerState>
   135c6:	4603      	mov	r3, r0
   135c8:	2b02      	cmp	r3, #2
   135ca:	d110      	bne.n	135ee <xTimerGenericCommand+0x7a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
   135cc:	f243 1348 	movw	r3, #12616	; 0x3148
   135d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   135d4:	681a      	ldr	r2, [r3, #0]
   135d6:	f107 0314 	add.w	r3, r7, #20
   135da:	4610      	mov	r0, r2
   135dc:	4619      	mov	r1, r3
   135de:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   135e0:	f04f 0300 	mov.w	r3, #0
   135e4:	f7fb ffc0 	bl	f568 <xQueueGenericSend>
   135e8:	4603      	mov	r3, r0
   135ea:	623b      	str	r3, [r7, #32]
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
   135ec:	e021      	b.n	13632 <xTimerGenericCommand+0xbe>
   135ee:	f243 1348 	movw	r3, #12616	; 0x3148
   135f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   135f6:	681a      	ldr	r2, [r3, #0]
   135f8:	f107 0314 	add.w	r3, r7, #20
   135fc:	4610      	mov	r0, r2
   135fe:	4619      	mov	r1, r3
   13600:	f04f 0200 	mov.w	r2, #0
   13604:	f04f 0300 	mov.w	r3, #0
   13608:	f7fb ffae 	bl	f568 <xQueueGenericSend>
   1360c:	4603      	mov	r3, r0
   1360e:	623b      	str	r3, [r7, #32]
   13610:	e00f      	b.n	13632 <xTimerGenericCommand+0xbe>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
   13612:	f243 1348 	movw	r3, #12616	; 0x3148
   13616:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1361a:	681a      	ldr	r2, [r3, #0]
   1361c:	f107 0314 	add.w	r3, r7, #20
   13620:	4610      	mov	r0, r2
   13622:	4619      	mov	r1, r3
   13624:	683a      	ldr	r2, [r7, #0]
   13626:	f04f 0300 	mov.w	r3, #0
   1362a:	f7fc f8b5 	bl	f798 <xQueueGenericSendFromISR>
   1362e:	4603      	mov	r3, r0
   13630:	623b      	str	r3, [r7, #32]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
   13632:	6a3b      	ldr	r3, [r7, #32]
}
   13634:	4618      	mov	r0, r3
   13636:	f107 0728 	add.w	r7, r7, #40	; 0x28
   1363a:	46bd      	mov	sp, r7
   1363c:	bd80      	pop	{r7, pc}
   1363e:	bf00      	nop

00013640 <xTimerGetTimerDaemonTaskHandle>:
/*-----------------------------------------------------------*/

TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
{
   13640:	b480      	push	{r7}
   13642:	b083      	sub	sp, #12
   13644:	af00      	add	r7, sp, #0
	/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
	started, then xTimerTaskHandle will be NULL. */
	configASSERT( ( xTimerTaskHandle != NULL ) );
   13646:	f243 134c 	movw	r3, #12620	; 0x314c
   1364a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1364e:	681b      	ldr	r3, [r3, #0]
   13650:	2b00      	cmp	r3, #0
   13652:	d109      	bne.n	13668 <xTimerGetTimerDaemonTaskHandle+0x28>
   13654:	f04f 0328 	mov.w	r3, #40	; 0x28
   13658:	f383 8811 	msr	BASEPRI, r3
   1365c:	f3bf 8f6f 	isb	sy
   13660:	f3bf 8f4f 	dsb	sy
   13664:	607b      	str	r3, [r7, #4]
   13666:	e7fe      	b.n	13666 <xTimerGetTimerDaemonTaskHandle+0x26>
	return xTimerTaskHandle;
   13668:	f243 134c 	movw	r3, #12620	; 0x314c
   1366c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13670:	681b      	ldr	r3, [r3, #0]
}
   13672:	4618      	mov	r0, r3
   13674:	f107 070c 	add.w	r7, r7, #12
   13678:	46bd      	mov	sp, r7
   1367a:	bc80      	pop	{r7}
   1367c:	4770      	bx	lr
   1367e:	bf00      	nop

00013680 <xTimerGetPeriod>:
/*-----------------------------------------------------------*/

TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
{
   13680:	b480      	push	{r7}
   13682:	b085      	sub	sp, #20
   13684:	af00      	add	r7, sp, #0
   13686:	6078      	str	r0, [r7, #4]
Timer_t *pxTimer = xTimer;
   13688:	687b      	ldr	r3, [r7, #4]
   1368a:	60bb      	str	r3, [r7, #8]

	configASSERT( xTimer );
   1368c:	687b      	ldr	r3, [r7, #4]
   1368e:	2b00      	cmp	r3, #0
   13690:	d109      	bne.n	136a6 <xTimerGetPeriod+0x26>
   13692:	f04f 0328 	mov.w	r3, #40	; 0x28
   13696:	f383 8811 	msr	BASEPRI, r3
   1369a:	f3bf 8f6f 	isb	sy
   1369e:	f3bf 8f4f 	dsb	sy
   136a2:	60fb      	str	r3, [r7, #12]
   136a4:	e7fe      	b.n	136a4 <xTimerGetPeriod+0x24>
	return pxTimer->xTimerPeriodInTicks;
   136a6:	68bb      	ldr	r3, [r7, #8]
   136a8:	699b      	ldr	r3, [r3, #24]
}
   136aa:	4618      	mov	r0, r3
   136ac:	f107 0714 	add.w	r7, r7, #20
   136b0:	46bd      	mov	sp, r7
   136b2:	bc80      	pop	{r7}
   136b4:	4770      	bx	lr
   136b6:	bf00      	nop

000136b8 <xTimerGetExpiryTime>:
/*-----------------------------------------------------------*/

TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
{
   136b8:	b480      	push	{r7}
   136ba:	b087      	sub	sp, #28
   136bc:	af00      	add	r7, sp, #0
   136be:	6078      	str	r0, [r7, #4]
Timer_t * pxTimer =  xTimer;
   136c0:	687b      	ldr	r3, [r7, #4]
   136c2:	60fb      	str	r3, [r7, #12]
TickType_t xReturn;

	configASSERT( xTimer );
   136c4:	687b      	ldr	r3, [r7, #4]
   136c6:	2b00      	cmp	r3, #0
   136c8:	d109      	bne.n	136de <xTimerGetExpiryTime+0x26>
   136ca:	f04f 0328 	mov.w	r3, #40	; 0x28
   136ce:	f383 8811 	msr	BASEPRI, r3
   136d2:	f3bf 8f6f 	isb	sy
   136d6:	f3bf 8f4f 	dsb	sy
   136da:	617b      	str	r3, [r7, #20]
   136dc:	e7fe      	b.n	136dc <xTimerGetExpiryTime+0x24>
	xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
   136de:	68fb      	ldr	r3, [r7, #12]
   136e0:	685b      	ldr	r3, [r3, #4]
   136e2:	613b      	str	r3, [r7, #16]
	return xReturn;
   136e4:	693b      	ldr	r3, [r7, #16]
}
   136e6:	4618      	mov	r0, r3
   136e8:	f107 071c 	add.w	r7, r7, #28
   136ec:	46bd      	mov	sp, r7
   136ee:	bc80      	pop	{r7}
   136f0:	4770      	bx	lr
   136f2:	bf00      	nop

000136f4 <pcTimerGetName>:
/*-----------------------------------------------------------*/

const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
   136f4:	b480      	push	{r7}
   136f6:	b085      	sub	sp, #20
   136f8:	af00      	add	r7, sp, #0
   136fa:	6078      	str	r0, [r7, #4]
Timer_t *pxTimer = xTimer;
   136fc:	687b      	ldr	r3, [r7, #4]
   136fe:	60bb      	str	r3, [r7, #8]

	configASSERT( xTimer );
   13700:	687b      	ldr	r3, [r7, #4]
   13702:	2b00      	cmp	r3, #0
   13704:	d109      	bne.n	1371a <pcTimerGetName+0x26>
   13706:	f04f 0328 	mov.w	r3, #40	; 0x28
   1370a:	f383 8811 	msr	BASEPRI, r3
   1370e:	f3bf 8f6f 	isb	sy
   13712:	f3bf 8f4f 	dsb	sy
   13716:	60fb      	str	r3, [r7, #12]
   13718:	e7fe      	b.n	13718 <pcTimerGetName+0x24>
	return pxTimer->pcTimerName;
   1371a:	68bb      	ldr	r3, [r7, #8]
   1371c:	681b      	ldr	r3, [r3, #0]
}
   1371e:	4618      	mov	r0, r3
   13720:	f107 0714 	add.w	r7, r7, #20
   13724:	46bd      	mov	sp, r7
   13726:	bc80      	pop	{r7}
   13728:	4770      	bx	lr
   1372a:	bf00      	nop

0001372c <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
   1372c:	b580      	push	{r7, lr}
   1372e:	b088      	sub	sp, #32
   13730:	af02      	add	r7, sp, #8
   13732:	6078      	str	r0, [r7, #4]
   13734:	6039      	str	r1, [r7, #0]
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   13736:	f243 1340 	movw	r3, #12608	; 0x3140
   1373a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1373e:	681b      	ldr	r3, [r3, #0]
   13740:	68db      	ldr	r3, [r3, #12]
   13742:	68db      	ldr	r3, [r3, #12]
   13744:	613b      	str	r3, [r7, #16]

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   13746:	693b      	ldr	r3, [r7, #16]
   13748:	f103 0304 	add.w	r3, r3, #4
   1374c:	4618      	mov	r0, r3
   1374e:	f7fb fd55 	bl	f1fc <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   13752:	693b      	ldr	r3, [r7, #16]
   13754:	69db      	ldr	r3, [r3, #28]
   13756:	2b01      	cmp	r3, #1
   13758:	d126      	bne.n	137a8 <prvProcessExpiredTimer+0x7c>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
   1375a:	693b      	ldr	r3, [r7, #16]
   1375c:	699a      	ldr	r2, [r3, #24]
   1375e:	687b      	ldr	r3, [r7, #4]
   13760:	4413      	add	r3, r2
   13762:	6938      	ldr	r0, [r7, #16]
   13764:	4619      	mov	r1, r3
   13766:	683a      	ldr	r2, [r7, #0]
   13768:	687b      	ldr	r3, [r7, #4]
   1376a:	f000 f8e3 	bl	13934 <prvInsertTimerInActiveList>
   1376e:	4603      	mov	r3, r0
   13770:	2b00      	cmp	r3, #0
   13772:	d019      	beq.n	137a8 <prvProcessExpiredTimer+0x7c>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
   13774:	f04f 0300 	mov.w	r3, #0
   13778:	9300      	str	r3, [sp, #0]
   1377a:	6938      	ldr	r0, [r7, #16]
   1377c:	f04f 0100 	mov.w	r1, #0
   13780:	687a      	ldr	r2, [r7, #4]
   13782:	f04f 0300 	mov.w	r3, #0
   13786:	f7ff fef5 	bl	13574 <xTimerGenericCommand>
   1378a:	4603      	mov	r3, r0
   1378c:	60fb      	str	r3, [r7, #12]
			configASSERT( xResult );
   1378e:	68fb      	ldr	r3, [r7, #12]
   13790:	2b00      	cmp	r3, #0
   13792:	d109      	bne.n	137a8 <prvProcessExpiredTimer+0x7c>
   13794:	f04f 0328 	mov.w	r3, #40	; 0x28
   13798:	f383 8811 	msr	BASEPRI, r3
   1379c:	f3bf 8f6f 	isb	sy
   137a0:	f3bf 8f4f 	dsb	sy
   137a4:	617b      	str	r3, [r7, #20]
   137a6:	e7fe      	b.n	137a6 <prvProcessExpiredTimer+0x7a>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   137a8:	693b      	ldr	r3, [r7, #16]
   137aa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   137ac:	6938      	ldr	r0, [r7, #16]
   137ae:	4798      	blx	r3
}
   137b0:	f107 0718 	add.w	r7, r7, #24
   137b4:	46bd      	mov	sp, r7
   137b6:	bd80      	pop	{r7, pc}

000137b8 <prvTimerTask>:
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
   137b8:	b580      	push	{r7, lr}
   137ba:	b084      	sub	sp, #16
   137bc:	af00      	add	r7, sp, #0
   137be:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
   137c0:	f107 0308 	add.w	r3, r7, #8
   137c4:	4618      	mov	r0, r3
   137c6:	f000 f863 	bl	13890 <prvGetNextExpireTime>
   137ca:	4603      	mov	r3, r0
   137cc:	60fb      	str	r3, [r7, #12]

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
   137ce:	68bb      	ldr	r3, [r7, #8]
   137d0:	68f8      	ldr	r0, [r7, #12]
   137d2:	4619      	mov	r1, r3
   137d4:	f000 f804 	bl	137e0 <prvProcessTimerOrBlockTask>

		/* Empty the command queue. */
		prvProcessReceivedCommands();
   137d8:	f000 f8f8 	bl	139cc <prvProcessReceivedCommands>
	}
   137dc:	e7f0      	b.n	137c0 <prvTimerTask+0x8>
   137de:	bf00      	nop

000137e0 <prvProcessTimerOrBlockTask>:
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
   137e0:	b580      	push	{r7, lr}
   137e2:	b084      	sub	sp, #16
   137e4:	af00      	add	r7, sp, #0
   137e6:	6078      	str	r0, [r7, #4]
   137e8:	6039      	str	r1, [r7, #0]
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
   137ea:	f7fd fe65 	bl	114b8 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   137ee:	f107 0308 	add.w	r3, r7, #8
   137f2:	4618      	mov	r0, r3
   137f4:	f000 f876 	bl	138e4 <prvSampleTimeNow>
   137f8:	4603      	mov	r3, r0
   137fa:	60fb      	str	r3, [r7, #12]
		if( xTimerListsWereSwitched == pdFALSE )
   137fc:	68bb      	ldr	r3, [r7, #8]
   137fe:	2b00      	cmp	r3, #0
   13800:	d13e      	bne.n	13880 <prvProcessTimerOrBlockTask+0xa0>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
   13802:	683b      	ldr	r3, [r7, #0]
   13804:	2b00      	cmp	r3, #0
   13806:	d10b      	bne.n	13820 <prvProcessTimerOrBlockTask+0x40>
   13808:	687a      	ldr	r2, [r7, #4]
   1380a:	68fb      	ldr	r3, [r7, #12]
   1380c:	429a      	cmp	r2, r3
   1380e:	d807      	bhi.n	13820 <prvProcessTimerOrBlockTask+0x40>
			{
				( void ) xTaskResumeAll();
   13810:	f7fd fe64 	bl	114dc <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
   13814:	6878      	ldr	r0, [r7, #4]
   13816:	68f9      	ldr	r1, [r7, #12]
   13818:	f7ff ff88 	bl	1372c <prvProcessExpiredTimer>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
   1381c:	bf00      	nop
   1381e:	e033      	b.n	13888 <prvProcessTimerOrBlockTask+0xa8>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
   13820:	683b      	ldr	r3, [r7, #0]
   13822:	2b00      	cmp	r3, #0
   13824:	d00d      	beq.n	13842 <prvProcessTimerOrBlockTask+0x62>
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
   13826:	f243 1344 	movw	r3, #12612	; 0x3144
   1382a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1382e:	681b      	ldr	r3, [r3, #0]
   13830:	681b      	ldr	r3, [r3, #0]
   13832:	2b00      	cmp	r3, #0
   13834:	d102      	bne.n	1383c <prvProcessTimerOrBlockTask+0x5c>
   13836:	f04f 0301 	mov.w	r3, #1
   1383a:	e001      	b.n	13840 <prvProcessTimerOrBlockTask+0x60>
   1383c:	f04f 0300 	mov.w	r3, #0
   13840:	603b      	str	r3, [r7, #0]
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
   13842:	f243 1348 	movw	r3, #12616	; 0x3148
   13846:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1384a:	681a      	ldr	r2, [r3, #0]
   1384c:	6879      	ldr	r1, [r7, #4]
   1384e:	68fb      	ldr	r3, [r7, #12]
   13850:	ebc3 0301 	rsb	r3, r3, r1
   13854:	4610      	mov	r0, r2
   13856:	4619      	mov	r1, r3
   13858:	683a      	ldr	r2, [r7, #0]
   1385a:	f7fc ff0f 	bl	1067c <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
   1385e:	f7fd fe3d 	bl	114dc <xTaskResumeAll>
   13862:	4603      	mov	r3, r0
   13864:	2b00      	cmp	r3, #0
   13866:	d10e      	bne.n	13886 <prvProcessTimerOrBlockTask+0xa6>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
   13868:	f64e 5304 	movw	r3, #60676	; 0xed04
   1386c:	f2ce 0300 	movt	r3, #57344	; 0xe000
   13870:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   13874:	601a      	str	r2, [r3, #0]
   13876:	f3bf 8f4f 	dsb	sy
   1387a:	f3bf 8f6f 	isb	sy
   1387e:	e003      	b.n	13888 <prvProcessTimerOrBlockTask+0xa8>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
   13880:	f7fd fe2c 	bl	114dc <xTaskResumeAll>
   13884:	e000      	b.n	13888 <prvProcessTimerOrBlockTask+0xa8>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
   13886:	bf00      	nop
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
   13888:	f107 0710 	add.w	r7, r7, #16
   1388c:	46bd      	mov	sp, r7
   1388e:	bd80      	pop	{r7, pc}

00013890 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
{
   13890:	b480      	push	{r7}
   13892:	b085      	sub	sp, #20
   13894:	af00      	add	r7, sp, #0
   13896:	6078      	str	r0, [r7, #4]
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
   13898:	f243 1340 	movw	r3, #12608	; 0x3140
   1389c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   138a0:	681b      	ldr	r3, [r3, #0]
   138a2:	681b      	ldr	r3, [r3, #0]
   138a4:	2b00      	cmp	r3, #0
   138a6:	d102      	bne.n	138ae <prvGetNextExpireTime+0x1e>
   138a8:	f04f 0301 	mov.w	r3, #1
   138ac:	e001      	b.n	138b2 <prvGetNextExpireTime+0x22>
   138ae:	f04f 0300 	mov.w	r3, #0
   138b2:	687a      	ldr	r2, [r7, #4]
   138b4:	6013      	str	r3, [r2, #0]
	if( *pxListWasEmpty == pdFALSE )
   138b6:	687b      	ldr	r3, [r7, #4]
   138b8:	681b      	ldr	r3, [r3, #0]
   138ba:	2b00      	cmp	r3, #0
   138bc:	d108      	bne.n	138d0 <prvGetNextExpireTime+0x40>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   138be:	f243 1340 	movw	r3, #12608	; 0x3140
   138c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   138c6:	681b      	ldr	r3, [r3, #0]
   138c8:	68db      	ldr	r3, [r3, #12]
   138ca:	681b      	ldr	r3, [r3, #0]
   138cc:	60fb      	str	r3, [r7, #12]
   138ce:	e002      	b.n	138d6 <prvGetNextExpireTime+0x46>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
   138d0:	f04f 0300 	mov.w	r3, #0
   138d4:	60fb      	str	r3, [r7, #12]
	}

	return xNextExpireTime;
   138d6:	68fb      	ldr	r3, [r7, #12]
}
   138d8:	4618      	mov	r0, r3
   138da:	f107 0714 	add.w	r7, r7, #20
   138de:	46bd      	mov	sp, r7
   138e0:	bc80      	pop	{r7}
   138e2:	4770      	bx	lr

000138e4 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
   138e4:	b580      	push	{r7, lr}
   138e6:	b084      	sub	sp, #16
   138e8:	af00      	add	r7, sp, #0
   138ea:	6078      	str	r0, [r7, #4]
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
   138ec:	f7fd fec6 	bl	1167c <xTaskGetTickCount>
   138f0:	4603      	mov	r3, r0
   138f2:	60fb      	str	r3, [r7, #12]

	if( xTimeNow < xLastTime )
   138f4:	f243 1350 	movw	r3, #12624	; 0x3150
   138f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   138fc:	681b      	ldr	r3, [r3, #0]
   138fe:	68fa      	ldr	r2, [r7, #12]
   13900:	429a      	cmp	r2, r3
   13902:	d206      	bcs.n	13912 <prvSampleTimeNow+0x2e>
	{
		prvSwitchTimerLists();
   13904:	f000 f906 	bl	13b14 <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
   13908:	687b      	ldr	r3, [r7, #4]
   1390a:	f04f 0201 	mov.w	r2, #1
   1390e:	601a      	str	r2, [r3, #0]
   13910:	e003      	b.n	1391a <prvSampleTimeNow+0x36>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
   13912:	687b      	ldr	r3, [r7, #4]
   13914:	f04f 0200 	mov.w	r2, #0
   13918:	601a      	str	r2, [r3, #0]
	}

	xLastTime = xTimeNow;
   1391a:	f243 1350 	movw	r3, #12624	; 0x3150
   1391e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13922:	68fa      	ldr	r2, [r7, #12]
   13924:	601a      	str	r2, [r3, #0]

	return xTimeNow;
   13926:	68fb      	ldr	r3, [r7, #12]
}
   13928:	4618      	mov	r0, r3
   1392a:	f107 0710 	add.w	r7, r7, #16
   1392e:	46bd      	mov	sp, r7
   13930:	bd80      	pop	{r7, pc}
   13932:	bf00      	nop

00013934 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
   13934:	b580      	push	{r7, lr}
   13936:	b086      	sub	sp, #24
   13938:	af00      	add	r7, sp, #0
   1393a:	60f8      	str	r0, [r7, #12]
   1393c:	60b9      	str	r1, [r7, #8]
   1393e:	607a      	str	r2, [r7, #4]
   13940:	603b      	str	r3, [r7, #0]
BaseType_t xProcessTimerNow = pdFALSE;
   13942:	f04f 0300 	mov.w	r3, #0
   13946:	617b      	str	r3, [r7, #20]

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
   13948:	68fb      	ldr	r3, [r7, #12]
   1394a:	68ba      	ldr	r2, [r7, #8]
   1394c:	605a      	str	r2, [r3, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   1394e:	68fb      	ldr	r3, [r7, #12]
   13950:	68fa      	ldr	r2, [r7, #12]
   13952:	611a      	str	r2, [r3, #16]

	if( xNextExpiryTime <= xTimeNow )
   13954:	68ba      	ldr	r2, [r7, #8]
   13956:	687b      	ldr	r3, [r7, #4]
   13958:	429a      	cmp	r2, r3
   1395a:	d818      	bhi.n	1398e <prvInsertTimerInActiveList+0x5a>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1395c:	687a      	ldr	r2, [r7, #4]
   1395e:	683b      	ldr	r3, [r7, #0]
   13960:	ebc3 0202 	rsb	r2, r3, r2
   13964:	68fb      	ldr	r3, [r7, #12]
   13966:	699b      	ldr	r3, [r3, #24]
   13968:	429a      	cmp	r2, r3
   1396a:	d303      	bcc.n	13974 <prvInsertTimerInActiveList+0x40>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
   1396c:	f04f 0301 	mov.w	r3, #1
   13970:	617b      	str	r3, [r7, #20]
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
   13972:	e024      	b.n	139be <prvInsertTimerInActiveList+0x8a>
   13974:	f243 1344 	movw	r3, #12612	; 0x3144
   13978:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1397c:	681a      	ldr	r2, [r3, #0]
   1397e:	68fb      	ldr	r3, [r7, #12]
   13980:	f103 0304 	add.w	r3, r3, #4
   13984:	4610      	mov	r0, r2
   13986:	4619      	mov	r1, r3
   13988:	f7fb fbfe 	bl	f188 <vListInsert>
   1398c:	e017      	b.n	139be <prvInsertTimerInActiveList+0x8a>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
   1398e:	687a      	ldr	r2, [r7, #4]
   13990:	683b      	ldr	r3, [r7, #0]
   13992:	429a      	cmp	r2, r3
   13994:	d207      	bcs.n	139a6 <prvInsertTimerInActiveList+0x72>
   13996:	68ba      	ldr	r2, [r7, #8]
   13998:	683b      	ldr	r3, [r7, #0]
   1399a:	429a      	cmp	r2, r3
   1399c:	d303      	bcc.n	139a6 <prvInsertTimerInActiveList+0x72>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
   1399e:	f04f 0301 	mov.w	r3, #1
   139a2:	617b      	str	r3, [r7, #20]
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
   139a4:	e00b      	b.n	139be <prvInsertTimerInActiveList+0x8a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   139a6:	f243 1340 	movw	r3, #12608	; 0x3140
   139aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
   139ae:	681a      	ldr	r2, [r3, #0]
   139b0:	68fb      	ldr	r3, [r7, #12]
   139b2:	f103 0304 	add.w	r3, r3, #4
   139b6:	4610      	mov	r0, r2
   139b8:	4619      	mov	r1, r3
   139ba:	f7fb fbe5 	bl	f188 <vListInsert>
		}
	}

	return xProcessTimerNow;
   139be:	697b      	ldr	r3, [r7, #20]
}
   139c0:	4618      	mov	r0, r3
   139c2:	f107 0718 	add.w	r7, r7, #24
   139c6:	46bd      	mov	sp, r7
   139c8:	bd80      	pop	{r7, pc}
   139ca:	bf00      	nop

000139cc <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
   139cc:	b580      	push	{r7, lr}
   139ce:	b08c      	sub	sp, #48	; 0x30
   139d0:	af02      	add	r7, sp, #8
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
   139d2:	e089      	b.n	13ae8 <prvProcessReceivedCommands+0x11c>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
   139d4:	68bb      	ldr	r3, [r7, #8]
   139d6:	2b00      	cmp	r3, #0
   139d8:	f2c0 8086 	blt.w	13ae8 <prvProcessReceivedCommands+0x11c>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
   139dc:	693b      	ldr	r3, [r7, #16]
   139de:	617b      	str	r3, [r7, #20]

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
   139e0:	697b      	ldr	r3, [r7, #20]
   139e2:	695b      	ldr	r3, [r3, #20]
   139e4:	2b00      	cmp	r3, #0
   139e6:	d005      	beq.n	139f4 <prvProcessReceivedCommands+0x28>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   139e8:	697b      	ldr	r3, [r7, #20]
   139ea:	f103 0304 	add.w	r3, r3, #4
   139ee:	4618      	mov	r0, r3
   139f0:	f7fb fc04 	bl	f1fc <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   139f4:	f107 0304 	add.w	r3, r7, #4
   139f8:	4618      	mov	r0, r3
   139fa:	f7ff ff73 	bl	138e4 <prvSampleTimeNow>
   139fe:	4603      	mov	r3, r0
   13a00:	61fb      	str	r3, [r7, #28]

			switch( xMessage.xMessageID )
   13a02:	68bb      	ldr	r3, [r7, #8]
   13a04:	2b09      	cmp	r3, #9
   13a06:	d86f      	bhi.n	13ae8 <prvProcessReceivedCommands+0x11c>
   13a08:	a201      	add	r2, pc, #4	; (adr r2, 13a10 <prvProcessReceivedCommands+0x44>)
   13a0a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   13a0e:	bf00      	nop
   13a10:	00013a39 	.word	0x00013a39
   13a14:	00013a39 	.word	0x00013a39
   13a18:	00013a39 	.word	0x00013a39
   13a1c:	00013ae9 	.word	0x00013ae9
   13a20:	00013a9f 	.word	0x00013a9f
   13a24:	00013ad7 	.word	0x00013ad7
   13a28:	00013a39 	.word	0x00013a39
   13a2c:	00013a39 	.word	0x00013a39
   13a30:	00013ae9 	.word	0x00013ae9
   13a34:	00013a9f 	.word	0x00013a9f
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
   13a38:	68fa      	ldr	r2, [r7, #12]
   13a3a:	697b      	ldr	r3, [r7, #20]
   13a3c:	699b      	ldr	r3, [r3, #24]
   13a3e:	441a      	add	r2, r3
   13a40:	68fb      	ldr	r3, [r7, #12]
   13a42:	6978      	ldr	r0, [r7, #20]
   13a44:	4611      	mov	r1, r2
   13a46:	69fa      	ldr	r2, [r7, #28]
   13a48:	f7ff ff74 	bl	13934 <prvInsertTimerInActiveList>
   13a4c:	4603      	mov	r3, r0
   13a4e:	2b00      	cmp	r3, #0
   13a50:	d045      	beq.n	13ade <prvProcessReceivedCommands+0x112>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   13a52:	697b      	ldr	r3, [r7, #20]
   13a54:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   13a56:	6978      	ldr	r0, [r7, #20]
   13a58:	4798      	blx	r3
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   13a5a:	697b      	ldr	r3, [r7, #20]
   13a5c:	69db      	ldr	r3, [r3, #28]
   13a5e:	2b01      	cmp	r3, #1
   13a60:	d13f      	bne.n	13ae2 <prvProcessReceivedCommands+0x116>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
   13a62:	68fa      	ldr	r2, [r7, #12]
   13a64:	697b      	ldr	r3, [r7, #20]
   13a66:	699b      	ldr	r3, [r3, #24]
   13a68:	4413      	add	r3, r2
   13a6a:	f04f 0200 	mov.w	r2, #0
   13a6e:	9200      	str	r2, [sp, #0]
   13a70:	6978      	ldr	r0, [r7, #20]
   13a72:	f04f 0100 	mov.w	r1, #0
   13a76:	461a      	mov	r2, r3
   13a78:	f04f 0300 	mov.w	r3, #0
   13a7c:	f7ff fd7a 	bl	13574 <xTimerGenericCommand>
   13a80:	4603      	mov	r3, r0
   13a82:	61bb      	str	r3, [r7, #24]
							configASSERT( xResult );
   13a84:	69bb      	ldr	r3, [r7, #24]
   13a86:	2b00      	cmp	r3, #0
   13a88:	d12d      	bne.n	13ae6 <prvProcessReceivedCommands+0x11a>
   13a8a:	f04f 0328 	mov.w	r3, #40	; 0x28
   13a8e:	f383 8811 	msr	BASEPRI, r3
   13a92:	f3bf 8f6f 	isb	sy
   13a96:	f3bf 8f4f 	dsb	sy
   13a9a:	623b      	str	r3, [r7, #32]
   13a9c:	e7fe      	b.n	13a9c <prvProcessReceivedCommands+0xd0>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
   13a9e:	68fa      	ldr	r2, [r7, #12]
   13aa0:	697b      	ldr	r3, [r7, #20]
   13aa2:	619a      	str	r2, [r3, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
   13aa4:	697b      	ldr	r3, [r7, #20]
   13aa6:	699b      	ldr	r3, [r3, #24]
   13aa8:	2b00      	cmp	r3, #0
   13aaa:	d109      	bne.n	13ac0 <prvProcessReceivedCommands+0xf4>
   13aac:	f04f 0328 	mov.w	r3, #40	; 0x28
   13ab0:	f383 8811 	msr	BASEPRI, r3
   13ab4:	f3bf 8f6f 	isb	sy
   13ab8:	f3bf 8f4f 	dsb	sy
   13abc:	627b      	str	r3, [r7, #36]	; 0x24
   13abe:	e7fe      	b.n	13abe <prvProcessReceivedCommands+0xf2>
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
   13ac0:	697b      	ldr	r3, [r7, #20]
   13ac2:	699a      	ldr	r2, [r3, #24]
   13ac4:	69fb      	ldr	r3, [r7, #28]
   13ac6:	4413      	add	r3, r2
   13ac8:	6978      	ldr	r0, [r7, #20]
   13aca:	4619      	mov	r1, r3
   13acc:	69fa      	ldr	r2, [r7, #28]
   13ace:	69fb      	ldr	r3, [r7, #28]
   13ad0:	f7ff ff30 	bl	13934 <prvInsertTimerInActiveList>
					break;
   13ad4:	e008      	b.n	13ae8 <prvProcessReceivedCommands+0x11c>
					allocated. */
					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
					{
						/* The timer can only have been allocated dynamically -
						free it again. */
						vPortFree( pxTimer );
   13ad6:	6978      	ldr	r0, [r7, #20]
   13ad8:	f000 fa08 	bl	13eec <vPortFree>
   13adc:	e004      	b.n	13ae8 <prvProcessReceivedCommands+0x11c>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					break;
   13ade:	bf00      	nop
   13ae0:	e002      	b.n	13ae8 <prvProcessReceivedCommands+0x11c>
   13ae2:	bf00      	nop
   13ae4:	e000      	b.n	13ae8 <prvProcessReceivedCommands+0x11c>
   13ae6:	bf00      	nop
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
   13ae8:	f243 1348 	movw	r3, #12616	; 0x3148
   13aec:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13af0:	681a      	ldr	r2, [r3, #0]
   13af2:	f107 0308 	add.w	r3, r7, #8
   13af6:	4610      	mov	r0, r2
   13af8:	4619      	mov	r1, r3
   13afa:	f04f 0200 	mov.w	r2, #0
   13afe:	f7fb ff83 	bl	fa08 <xQueueReceive>
   13b02:	4603      	mov	r3, r0
   13b04:	2b00      	cmp	r3, #0
   13b06:	f47f af65 	bne.w	139d4 <prvProcessReceivedCommands+0x8>
					/* Don't expect to get here. */
					break;
			}
		}
	}
}
   13b0a:	f107 0728 	add.w	r7, r7, #40	; 0x28
   13b0e:	46bd      	mov	sp, r7
   13b10:	bd80      	pop	{r7, pc}
   13b12:	bf00      	nop

00013b14 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
   13b14:	b580      	push	{r7, lr}
   13b16:	b088      	sub	sp, #32
   13b18:	af02      	add	r7, sp, #8

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
   13b1a:	e053      	b.n	13bc4 <prvSwitchTimerLists+0xb0>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   13b1c:	f243 1340 	movw	r3, #12608	; 0x3140
   13b20:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13b24:	681b      	ldr	r3, [r3, #0]
   13b26:	68db      	ldr	r3, [r3, #12]
   13b28:	681b      	ldr	r3, [r3, #0]
   13b2a:	603b      	str	r3, [r7, #0]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   13b2c:	f243 1340 	movw	r3, #12608	; 0x3140
   13b30:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13b34:	681b      	ldr	r3, [r3, #0]
   13b36:	68db      	ldr	r3, [r3, #12]
   13b38:	68db      	ldr	r3, [r3, #12]
   13b3a:	60fb      	str	r3, [r7, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   13b3c:	68fb      	ldr	r3, [r7, #12]
   13b3e:	f103 0304 	add.w	r3, r3, #4
   13b42:	4618      	mov	r0, r3
   13b44:	f7fb fb5a 	bl	f1fc <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   13b48:	68fb      	ldr	r3, [r7, #12]
   13b4a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   13b4c:	68f8      	ldr	r0, [r7, #12]
   13b4e:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   13b50:	68fb      	ldr	r3, [r7, #12]
   13b52:	69db      	ldr	r3, [r3, #28]
   13b54:	2b01      	cmp	r3, #1
   13b56:	d135      	bne.n	13bc4 <prvSwitchTimerLists+0xb0>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
   13b58:	68fb      	ldr	r3, [r7, #12]
   13b5a:	699a      	ldr	r2, [r3, #24]
   13b5c:	683b      	ldr	r3, [r7, #0]
   13b5e:	4413      	add	r3, r2
   13b60:	607b      	str	r3, [r7, #4]
			if( xReloadTime > xNextExpireTime )
   13b62:	687a      	ldr	r2, [r7, #4]
   13b64:	683b      	ldr	r3, [r7, #0]
   13b66:	429a      	cmp	r2, r3
   13b68:	d912      	bls.n	13b90 <prvSwitchTimerLists+0x7c>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
   13b6a:	68fb      	ldr	r3, [r7, #12]
   13b6c:	687a      	ldr	r2, [r7, #4]
   13b6e:	605a      	str	r2, [r3, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   13b70:	68fb      	ldr	r3, [r7, #12]
   13b72:	68fa      	ldr	r2, [r7, #12]
   13b74:	611a      	str	r2, [r3, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   13b76:	f243 1340 	movw	r3, #12608	; 0x3140
   13b7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13b7e:	681a      	ldr	r2, [r3, #0]
   13b80:	68fb      	ldr	r3, [r7, #12]
   13b82:	f103 0304 	add.w	r3, r3, #4
   13b86:	4610      	mov	r0, r2
   13b88:	4619      	mov	r1, r3
   13b8a:	f7fb fafd 	bl	f188 <vListInsert>
   13b8e:	e019      	b.n	13bc4 <prvSwitchTimerLists+0xb0>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
   13b90:	f04f 0300 	mov.w	r3, #0
   13b94:	9300      	str	r3, [sp, #0]
   13b96:	68f8      	ldr	r0, [r7, #12]
   13b98:	f04f 0100 	mov.w	r1, #0
   13b9c:	683a      	ldr	r2, [r7, #0]
   13b9e:	f04f 0300 	mov.w	r3, #0
   13ba2:	f7ff fce7 	bl	13574 <xTimerGenericCommand>
   13ba6:	4603      	mov	r3, r0
   13ba8:	613b      	str	r3, [r7, #16]
				configASSERT( xResult );
   13baa:	693b      	ldr	r3, [r7, #16]
   13bac:	2b00      	cmp	r3, #0
   13bae:	d109      	bne.n	13bc4 <prvSwitchTimerLists+0xb0>
   13bb0:	f04f 0328 	mov.w	r3, #40	; 0x28
   13bb4:	f383 8811 	msr	BASEPRI, r3
   13bb8:	f3bf 8f6f 	isb	sy
   13bbc:	f3bf 8f4f 	dsb	sy
   13bc0:	617b      	str	r3, [r7, #20]
   13bc2:	e7fe      	b.n	13bc2 <prvSwitchTimerLists+0xae>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
   13bc4:	f243 1340 	movw	r3, #12608	; 0x3140
   13bc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13bcc:	681b      	ldr	r3, [r3, #0]
   13bce:	681b      	ldr	r3, [r3, #0]
   13bd0:	2b00      	cmp	r3, #0
   13bd2:	d1a3      	bne.n	13b1c <prvSwitchTimerLists+0x8>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
   13bd4:	f243 1340 	movw	r3, #12608	; 0x3140
   13bd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13bdc:	681b      	ldr	r3, [r3, #0]
   13bde:	60bb      	str	r3, [r7, #8]
	pxCurrentTimerList = pxOverflowTimerList;
   13be0:	f243 1344 	movw	r3, #12612	; 0x3144
   13be4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13be8:	681a      	ldr	r2, [r3, #0]
   13bea:	f243 1340 	movw	r3, #12608	; 0x3140
   13bee:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13bf2:	601a      	str	r2, [r3, #0]
	pxOverflowTimerList = pxTemp;
   13bf4:	f243 1344 	movw	r3, #12612	; 0x3144
   13bf8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13bfc:	68ba      	ldr	r2, [r7, #8]
   13bfe:	601a      	str	r2, [r3, #0]
}
   13c00:	f107 0718 	add.w	r7, r7, #24
   13c04:	46bd      	mov	sp, r7
   13c06:	bd80      	pop	{r7, pc}

00013c08 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
   13c08:	b580      	push	{r7, lr}
   13c0a:	af00      	add	r7, sp, #0
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
   13c0c:	f000 fb34 	bl	14278 <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
   13c10:	f243 1348 	movw	r3, #12616	; 0x3148
   13c14:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13c18:	681b      	ldr	r3, [r3, #0]
   13c1a:	2b00      	cmp	r3, #0
   13c1c:	d12b      	bne.n	13c76 <prvCheckForValidListAndQueue+0x6e>
		{
			vListInitialise( &xActiveTimerList1 );
   13c1e:	f243 1018 	movw	r0, #12568	; 0x3118
   13c22:	f2c2 0000 	movt	r0, #8192	; 0x2000
   13c26:	f7fb fa59 	bl	f0dc <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
   13c2a:	f243 102c 	movw	r0, #12588	; 0x312c
   13c2e:	f2c2 0000 	movt	r0, #8192	; 0x2000
   13c32:	f7fb fa53 	bl	f0dc <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
   13c36:	f243 1340 	movw	r3, #12608	; 0x3140
   13c3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13c3e:	f243 1218 	movw	r2, #12568	; 0x3118
   13c42:	f2c2 0200 	movt	r2, #8192	; 0x2000
   13c46:	601a      	str	r2, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
   13c48:	f243 1344 	movw	r3, #12612	; 0x3144
   13c4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13c50:	f243 122c 	movw	r2, #12588	; 0x312c
   13c54:	f2c2 0200 	movt	r2, #8192	; 0x2000
   13c58:	601a      	str	r2, [r3, #0]

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
   13c5a:	f04f 000a 	mov.w	r0, #10
   13c5e:	f04f 010c 	mov.w	r1, #12
   13c62:	f04f 0200 	mov.w	r2, #0
   13c66:	f7fb fb6b 	bl	f340 <xQueueGenericCreate>
   13c6a:	4602      	mov	r2, r0
   13c6c:	f243 1348 	movw	r3, #12616	; 0x3148
   13c70:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13c74:	601a      	str	r2, [r3, #0]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
   13c76:	f000 fb37 	bl	142e8 <vPortExitCritical>
}
   13c7a:	bd80      	pop	{r7, pc}

00013c7c <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
{
   13c7c:	b580      	push	{r7, lr}
   13c7e:	b086      	sub	sp, #24
   13c80:	af00      	add	r7, sp, #0
   13c82:	6078      	str	r0, [r7, #4]
BaseType_t xTimerIsInActiveList;
Timer_t *pxTimer = xTimer;
   13c84:	687b      	ldr	r3, [r7, #4]
   13c86:	613b      	str	r3, [r7, #16]

	configASSERT( xTimer );
   13c88:	687b      	ldr	r3, [r7, #4]
   13c8a:	2b00      	cmp	r3, #0
   13c8c:	d109      	bne.n	13ca2 <xTimerIsTimerActive+0x26>
   13c8e:	f04f 0328 	mov.w	r3, #40	; 0x28
   13c92:	f383 8811 	msr	BASEPRI, r3
   13c96:	f3bf 8f6f 	isb	sy
   13c9a:	f3bf 8f4f 	dsb	sy
   13c9e:	617b      	str	r3, [r7, #20]
   13ca0:	e7fe      	b.n	13ca0 <xTimerIsTimerActive+0x24>

	/* Is the timer in the list of active timers? */
	taskENTER_CRITICAL();
   13ca2:	f000 fae9 	bl	14278 <vPortEnterCritical>
	{
		/* Checking to see if it is in the NULL list in effect checks to see if
		it is referenced from either the current or the overflow timer lists in
		one go, but the logic has to be reversed, hence the '!'. */
		if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdTRUE )
   13ca6:	693b      	ldr	r3, [r7, #16]
   13ca8:	695b      	ldr	r3, [r3, #20]
   13caa:	2b00      	cmp	r3, #0
   13cac:	d103      	bne.n	13cb6 <xTimerIsTimerActive+0x3a>
		{
			xTimerIsInActiveList = pdFALSE;
   13cae:	f04f 0300 	mov.w	r3, #0
   13cb2:	60fb      	str	r3, [r7, #12]
   13cb4:	e002      	b.n	13cbc <xTimerIsTimerActive+0x40>
		}
		else
		{
			xTimerIsInActiveList = pdTRUE;
   13cb6:	f04f 0301 	mov.w	r3, #1
   13cba:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
   13cbc:	f000 fb14 	bl	142e8 <vPortExitCritical>

	return xTimerIsInActiveList;
   13cc0:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 Can't be pointer to const due to the typedef. */
   13cc2:	4618      	mov	r0, r3
   13cc4:	f107 0718 	add.w	r7, r7, #24
   13cc8:	46bd      	mov	sp, r7
   13cca:	bd80      	pop	{r7, pc}

00013ccc <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

void *pvTimerGetTimerID( const TimerHandle_t xTimer )
{
   13ccc:	b580      	push	{r7, lr}
   13cce:	b086      	sub	sp, #24
   13cd0:	af00      	add	r7, sp, #0
   13cd2:	6078      	str	r0, [r7, #4]
Timer_t * const pxTimer = xTimer;
   13cd4:	687b      	ldr	r3, [r7, #4]
   13cd6:	60fb      	str	r3, [r7, #12]
void *pvReturn;

	configASSERT( xTimer );
   13cd8:	687b      	ldr	r3, [r7, #4]
   13cda:	2b00      	cmp	r3, #0
   13cdc:	d109      	bne.n	13cf2 <pvTimerGetTimerID+0x26>
   13cde:	f04f 0328 	mov.w	r3, #40	; 0x28
   13ce2:	f383 8811 	msr	BASEPRI, r3
   13ce6:	f3bf 8f6f 	isb	sy
   13cea:	f3bf 8f4f 	dsb	sy
   13cee:	617b      	str	r3, [r7, #20]
   13cf0:	e7fe      	b.n	13cf0 <pvTimerGetTimerID+0x24>

	taskENTER_CRITICAL();
   13cf2:	f000 fac1 	bl	14278 <vPortEnterCritical>
	{
		pvReturn = pxTimer->pvTimerID;
   13cf6:	68fb      	ldr	r3, [r7, #12]
   13cf8:	6a1b      	ldr	r3, [r3, #32]
   13cfa:	613b      	str	r3, [r7, #16]
	}
	taskEXIT_CRITICAL();
   13cfc:	f000 faf4 	bl	142e8 <vPortExitCritical>

	return pvReturn;
   13d00:	693b      	ldr	r3, [r7, #16]
}
   13d02:	4618      	mov	r0, r3
   13d04:	f107 0718 	add.w	r7, r7, #24
   13d08:	46bd      	mov	sp, r7
   13d0a:	bd80      	pop	{r7, pc}

00013d0c <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
{
   13d0c:	b580      	push	{r7, lr}
   13d0e:	b084      	sub	sp, #16
   13d10:	af00      	add	r7, sp, #0
   13d12:	6078      	str	r0, [r7, #4]
   13d14:	6039      	str	r1, [r7, #0]
Timer_t * const pxTimer = xTimer;
   13d16:	687b      	ldr	r3, [r7, #4]
   13d18:	60bb      	str	r3, [r7, #8]

	configASSERT( xTimer );
   13d1a:	687b      	ldr	r3, [r7, #4]
   13d1c:	2b00      	cmp	r3, #0
   13d1e:	d109      	bne.n	13d34 <vTimerSetTimerID+0x28>
   13d20:	f04f 0328 	mov.w	r3, #40	; 0x28
   13d24:	f383 8811 	msr	BASEPRI, r3
   13d28:	f3bf 8f6f 	isb	sy
   13d2c:	f3bf 8f4f 	dsb	sy
   13d30:	60fb      	str	r3, [r7, #12]
   13d32:	e7fe      	b.n	13d32 <vTimerSetTimerID+0x26>

	taskENTER_CRITICAL();
   13d34:	f000 faa0 	bl	14278 <vPortEnterCritical>
	{
		pxTimer->pvTimerID = pvNewID;
   13d38:	68bb      	ldr	r3, [r7, #8]
   13d3a:	683a      	ldr	r2, [r7, #0]
   13d3c:	621a      	str	r2, [r3, #32]
	}
	taskEXIT_CRITICAL();
   13d3e:	f000 fad3 	bl	142e8 <vPortExitCritical>
}
   13d42:	f107 0710 	add.w	r7, r7, #16
   13d46:	46bd      	mov	sp, r7
   13d48:	bd80      	pop	{r7, pc}
   13d4a:	bf00      	nop

00013d4c <uxTimerGetTimerNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTimerGetTimerNumber( TimerHandle_t xTimer )
	{
   13d4c:	b480      	push	{r7}
   13d4e:	b083      	sub	sp, #12
   13d50:	af00      	add	r7, sp, #0
   13d52:	6078      	str	r0, [r7, #4]
		return ( ( Timer_t * ) xTimer )->uxTimerNumber;
   13d54:	687b      	ldr	r3, [r7, #4]
   13d56:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	}
   13d58:	4618      	mov	r0, r3
   13d5a:	f107 070c 	add.w	r7, r7, #12
   13d5e:	46bd      	mov	sp, r7
   13d60:	bc80      	pop	{r7}
   13d62:	4770      	bx	lr

00013d64 <vTimerSetTimerNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTimerSetTimerNumber( TimerHandle_t xTimer, UBaseType_t uxTimerNumber )
	{
   13d64:	b480      	push	{r7}
   13d66:	b083      	sub	sp, #12
   13d68:	af00      	add	r7, sp, #0
   13d6a:	6078      	str	r0, [r7, #4]
   13d6c:	6039      	str	r1, [r7, #0]
		( ( Timer_t * ) xTimer )->uxTimerNumber = uxTimerNumber;
   13d6e:	687b      	ldr	r3, [r7, #4]
   13d70:	683a      	ldr	r2, [r7, #0]
   13d72:	629a      	str	r2, [r3, #40]	; 0x28
	}
   13d74:	f107 070c 	add.w	r7, r7, #12
   13d78:	46bd      	mov	sp, r7
   13d7a:	bc80      	pop	{r7}
   13d7c:	4770      	bx	lr
   13d7e:	bf00      	nop

00013d80 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
   13d80:	b580      	push	{r7, lr}
   13d82:	b088      	sub	sp, #32
   13d84:	af00      	add	r7, sp, #0
   13d86:	6078      	str	r0, [r7, #4]
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
   13d88:	f04f 0300 	mov.w	r3, #0
   13d8c:	617b      	str	r3, [r7, #20]

	vTaskSuspendAll();
   13d8e:	f7fd fb93 	bl	114b8 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
   13d92:	f64a 1364 	movw	r3, #43364	; 0xa964
   13d96:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13d9a:	681b      	ldr	r3, [r3, #0]
   13d9c:	2b00      	cmp	r3, #0
   13d9e:	d108      	bne.n	13db2 <pvPortMalloc+0x32>
		{
			prvHeapInit();
   13da0:	f000 f8fa 	bl	13f98 <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
   13da4:	f64a 1364 	movw	r3, #43364	; 0xa964
   13da8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13dac:	f04f 0201 	mov.w	r2, #1
   13db0:	601a      	str	r2, [r3, #0]
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
   13db2:	687b      	ldr	r3, [r7, #4]
   13db4:	2b00      	cmp	r3, #0
   13db6:	d012      	beq.n	13dde <pvPortMalloc+0x5e>
		{
			xWantedSize += heapSTRUCT_SIZE;
   13db8:	f244 038c 	movw	r3, #16524	; 0x408c
   13dbc:	f2c0 0302 	movt	r3, #2
   13dc0:	881b      	ldrh	r3, [r3, #0]
   13dc2:	687a      	ldr	r2, [r7, #4]
   13dc4:	4413      	add	r3, r2
   13dc6:	607b      	str	r3, [r7, #4]

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
   13dc8:	687b      	ldr	r3, [r7, #4]
   13dca:	f003 0307 	and.w	r3, r3, #7
   13dce:	2b00      	cmp	r3, #0
   13dd0:	d005      	beq.n	13dde <pvPortMalloc+0x5e>
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
   13dd2:	687b      	ldr	r3, [r7, #4]
   13dd4:	f023 0307 	bic.w	r3, r3, #7
   13dd8:	f103 0308 	add.w	r3, r3, #8
   13ddc:	607b      	str	r3, [r7, #4]
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
   13dde:	687b      	ldr	r3, [r7, #4]
   13de0:	2b00      	cmp	r3, #0
   13de2:	d075      	beq.n	13ed0 <pvPortMalloc+0x150>
   13de4:	687a      	ldr	r2, [r7, #4]
   13de6:	f247 73f7 	movw	r3, #30711	; 0x77f7
   13dea:	429a      	cmp	r2, r3
   13dec:	d870      	bhi.n	13ed0 <pvPortMalloc+0x150>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
   13dee:	f64a 1354 	movw	r3, #43348	; 0xa954
   13df2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13df6:	60fb      	str	r3, [r7, #12]
			pxBlock = xStart.pxNextFreeBlock;
   13df8:	f64a 1354 	movw	r3, #43348	; 0xa954
   13dfc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13e00:	681b      	ldr	r3, [r3, #0]
   13e02:	60bb      	str	r3, [r7, #8]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
   13e04:	e004      	b.n	13e10 <pvPortMalloc+0x90>
			{
				pxPreviousBlock = pxBlock;
   13e06:	68bb      	ldr	r3, [r7, #8]
   13e08:	60fb      	str	r3, [r7, #12]
				pxBlock = pxBlock->pxNextFreeBlock;
   13e0a:	68bb      	ldr	r3, [r7, #8]
   13e0c:	681b      	ldr	r3, [r3, #0]
   13e0e:	60bb      	str	r3, [r7, #8]
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
   13e10:	68bb      	ldr	r3, [r7, #8]
   13e12:	685a      	ldr	r2, [r3, #4]
   13e14:	687b      	ldr	r3, [r7, #4]
   13e16:	429a      	cmp	r2, r3
   13e18:	d203      	bcs.n	13e22 <pvPortMalloc+0xa2>
   13e1a:	68bb      	ldr	r3, [r7, #8]
   13e1c:	681b      	ldr	r3, [r3, #0]
   13e1e:	2b00      	cmp	r3, #0
   13e20:	d1f1      	bne.n	13e06 <pvPortMalloc+0x86>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
   13e22:	68ba      	ldr	r2, [r7, #8]
   13e24:	f64a 135c 	movw	r3, #43356	; 0xa95c
   13e28:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13e2c:	429a      	cmp	r2, r3
   13e2e:	d04f      	beq.n	13ed0 <pvPortMalloc+0x150>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
   13e30:	68fb      	ldr	r3, [r7, #12]
   13e32:	681a      	ldr	r2, [r3, #0]
   13e34:	f244 038c 	movw	r3, #16524	; 0x408c
   13e38:	f2c0 0302 	movt	r3, #2
   13e3c:	881b      	ldrh	r3, [r3, #0]
   13e3e:	4413      	add	r3, r2
   13e40:	617b      	str	r3, [r7, #20]

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
   13e42:	68bb      	ldr	r3, [r7, #8]
   13e44:	681a      	ldr	r2, [r3, #0]
   13e46:	68fb      	ldr	r3, [r7, #12]
   13e48:	601a      	str	r2, [r3, #0]

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
   13e4a:	68bb      	ldr	r3, [r7, #8]
   13e4c:	685a      	ldr	r2, [r3, #4]
   13e4e:	687b      	ldr	r3, [r7, #4]
   13e50:	ebc3 0202 	rsb	r2, r3, r2
   13e54:	f244 038c 	movw	r3, #16524	; 0x408c
   13e58:	f2c0 0302 	movt	r3, #2
   13e5c:	881b      	ldrh	r3, [r3, #0]
   13e5e:	ea4f 0343 	mov.w	r3, r3, lsl #1
   13e62:	429a      	cmp	r2, r3
   13e64:	d926      	bls.n	13eb4 <pvPortMalloc+0x134>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
   13e66:	68ba      	ldr	r2, [r7, #8]
   13e68:	687b      	ldr	r3, [r7, #4]
   13e6a:	4413      	add	r3, r2
   13e6c:	613b      	str	r3, [r7, #16]

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
   13e6e:	68bb      	ldr	r3, [r7, #8]
   13e70:	685a      	ldr	r2, [r3, #4]
   13e72:	687b      	ldr	r3, [r7, #4]
   13e74:	ebc3 0202 	rsb	r2, r3, r2
   13e78:	693b      	ldr	r3, [r7, #16]
   13e7a:	605a      	str	r2, [r3, #4]
					pxBlock->xBlockSize = xWantedSize;
   13e7c:	68bb      	ldr	r3, [r7, #8]
   13e7e:	687a      	ldr	r2, [r7, #4]
   13e80:	605a      	str	r2, [r3, #4]

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
   13e82:	693b      	ldr	r3, [r7, #16]
   13e84:	685b      	ldr	r3, [r3, #4]
   13e86:	61fb      	str	r3, [r7, #28]
   13e88:	f64a 1354 	movw	r3, #43348	; 0xa954
   13e8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13e90:	61bb      	str	r3, [r7, #24]
   13e92:	e002      	b.n	13e9a <pvPortMalloc+0x11a>
   13e94:	69bb      	ldr	r3, [r7, #24]
   13e96:	681b      	ldr	r3, [r3, #0]
   13e98:	61bb      	str	r3, [r7, #24]
   13e9a:	69bb      	ldr	r3, [r7, #24]
   13e9c:	681b      	ldr	r3, [r3, #0]
   13e9e:	685a      	ldr	r2, [r3, #4]
   13ea0:	69fb      	ldr	r3, [r7, #28]
   13ea2:	429a      	cmp	r2, r3
   13ea4:	d3f6      	bcc.n	13e94 <pvPortMalloc+0x114>
   13ea6:	69bb      	ldr	r3, [r7, #24]
   13ea8:	681a      	ldr	r2, [r3, #0]
   13eaa:	693b      	ldr	r3, [r7, #16]
   13eac:	601a      	str	r2, [r3, #0]
   13eae:	69bb      	ldr	r3, [r7, #24]
   13eb0:	693a      	ldr	r2, [r7, #16]
   13eb2:	601a      	str	r2, [r3, #0]
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
   13eb4:	f240 03d0 	movw	r3, #208	; 0xd0
   13eb8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13ebc:	681a      	ldr	r2, [r3, #0]
   13ebe:	68bb      	ldr	r3, [r7, #8]
   13ec0:	685b      	ldr	r3, [r3, #4]
   13ec2:	ebc3 0202 	rsb	r2, r3, r2
   13ec6:	f240 03d0 	movw	r3, #208	; 0xd0
   13eca:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13ece:	601a      	str	r2, [r3, #0]
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
   13ed0:	f7fd fb04 	bl	114dc <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
   13ed4:	697b      	ldr	r3, [r7, #20]
   13ed6:	2b00      	cmp	r3, #0
   13ed8:	d101      	bne.n	13ede <pvPortMalloc+0x15e>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
   13eda:	f7ec fe4f 	bl	b7c <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
   13ede:	697b      	ldr	r3, [r7, #20]
}
   13ee0:	4618      	mov	r0, r3
   13ee2:	f107 0720 	add.w	r7, r7, #32
   13ee6:	46bd      	mov	sp, r7
   13ee8:	bd80      	pop	{r7, pc}
   13eea:	bf00      	nop

00013eec <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
   13eec:	b580      	push	{r7, lr}
   13eee:	b086      	sub	sp, #24
   13ef0:	af00      	add	r7, sp, #0
   13ef2:	6078      	str	r0, [r7, #4]
uint8_t *puc = ( uint8_t * ) pv;
   13ef4:	687b      	ldr	r3, [r7, #4]
   13ef6:	60bb      	str	r3, [r7, #8]
BlockLink_t *pxLink;

	if( pv != NULL )
   13ef8:	687b      	ldr	r3, [r7, #4]
   13efa:	2b00      	cmp	r3, #0
   13efc:	d035      	beq.n	13f6a <vPortFree+0x7e>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
   13efe:	f244 038c 	movw	r3, #16524	; 0x408c
   13f02:	f2c0 0302 	movt	r3, #2
   13f06:	881b      	ldrh	r3, [r3, #0]
   13f08:	f1c3 0300 	rsb	r3, r3, #0
   13f0c:	68ba      	ldr	r2, [r7, #8]
   13f0e:	4413      	add	r3, r2
   13f10:	60bb      	str	r3, [r7, #8]

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
   13f12:	68bb      	ldr	r3, [r7, #8]
   13f14:	60fb      	str	r3, [r7, #12]

		vTaskSuspendAll();
   13f16:	f7fd facf 	bl	114b8 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
   13f1a:	68fb      	ldr	r3, [r7, #12]
   13f1c:	685b      	ldr	r3, [r3, #4]
   13f1e:	617b      	str	r3, [r7, #20]
   13f20:	f64a 1354 	movw	r3, #43348	; 0xa954
   13f24:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13f28:	613b      	str	r3, [r7, #16]
   13f2a:	e002      	b.n	13f32 <vPortFree+0x46>
   13f2c:	693b      	ldr	r3, [r7, #16]
   13f2e:	681b      	ldr	r3, [r3, #0]
   13f30:	613b      	str	r3, [r7, #16]
   13f32:	693b      	ldr	r3, [r7, #16]
   13f34:	681b      	ldr	r3, [r3, #0]
   13f36:	685a      	ldr	r2, [r3, #4]
   13f38:	697b      	ldr	r3, [r7, #20]
   13f3a:	429a      	cmp	r2, r3
   13f3c:	d3f6      	bcc.n	13f2c <vPortFree+0x40>
   13f3e:	693b      	ldr	r3, [r7, #16]
   13f40:	681a      	ldr	r2, [r3, #0]
   13f42:	68fb      	ldr	r3, [r7, #12]
   13f44:	601a      	str	r2, [r3, #0]
   13f46:	693b      	ldr	r3, [r7, #16]
   13f48:	68fa      	ldr	r2, [r7, #12]
   13f4a:	601a      	str	r2, [r3, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
   13f4c:	68fb      	ldr	r3, [r7, #12]
   13f4e:	685a      	ldr	r2, [r3, #4]
   13f50:	f240 03d0 	movw	r3, #208	; 0xd0
   13f54:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13f58:	681b      	ldr	r3, [r3, #0]
   13f5a:	441a      	add	r2, r3
   13f5c:	f240 03d0 	movw	r3, #208	; 0xd0
   13f60:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13f64:	601a      	str	r2, [r3, #0]
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
   13f66:	f7fd fab9 	bl	114dc <xTaskResumeAll>
	}
}
   13f6a:	f107 0718 	add.w	r7, r7, #24
   13f6e:	46bd      	mov	sp, r7
   13f70:	bd80      	pop	{r7, pc}
   13f72:	bf00      	nop

00013f74 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
   13f74:	b480      	push	{r7}
   13f76:	af00      	add	r7, sp, #0
	return xFreeBytesRemaining;
   13f78:	f240 03d0 	movw	r3, #208	; 0xd0
   13f7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13f80:	681b      	ldr	r3, [r3, #0]
}
   13f82:	4618      	mov	r0, r3
   13f84:	46bd      	mov	sp, r7
   13f86:	bc80      	pop	{r7}
   13f88:	4770      	bx	lr
   13f8a:	bf00      	nop

00013f8c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
   13f8c:	b480      	push	{r7}
   13f8e:	af00      	add	r7, sp, #0
	/* This just exists to keep the linker quiet. */
}
   13f90:	46bd      	mov	sp, r7
   13f92:	bc80      	pop	{r7}
   13f94:	4770      	bx	lr
   13f96:	bf00      	nop

00013f98 <prvHeapInit>:
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
   13f98:	b480      	push	{r7}
   13f9a:	b083      	sub	sp, #12
   13f9c:	af00      	add	r7, sp, #0
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
   13f9e:	4b18      	ldr	r3, [pc, #96]	; (14000 <prvHeapInit+0x68>)
   13fa0:	f023 0307 	bic.w	r3, r3, #7
   13fa4:	607b      	str	r3, [r7, #4]

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
   13fa6:	687a      	ldr	r2, [r7, #4]
   13fa8:	f64a 1354 	movw	r3, #43348	; 0xa954
   13fac:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13fb0:	601a      	str	r2, [r3, #0]
	xStart.xBlockSize = ( size_t ) 0;
   13fb2:	f64a 1354 	movw	r3, #43348	; 0xa954
   13fb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13fba:	f04f 0200 	mov.w	r2, #0
   13fbe:	605a      	str	r2, [r3, #4]

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
   13fc0:	f64a 135c 	movw	r3, #43356	; 0xa95c
   13fc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13fc8:	f247 72f8 	movw	r2, #30712	; 0x77f8
   13fcc:	605a      	str	r2, [r3, #4]
	xEnd.pxNextFreeBlock = NULL;
   13fce:	f64a 135c 	movw	r3, #43356	; 0xa95c
   13fd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13fd6:	f04f 0200 	mov.w	r2, #0
   13fda:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
   13fdc:	687b      	ldr	r3, [r7, #4]
   13fde:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
   13fe0:	683b      	ldr	r3, [r7, #0]
   13fe2:	f247 72f8 	movw	r2, #30712	; 0x77f8
   13fe6:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
   13fe8:	683a      	ldr	r2, [r7, #0]
   13fea:	f64a 135c 	movw	r3, #43356	; 0xa95c
   13fee:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13ff2:	6013      	str	r3, [r2, #0]
}
   13ff4:	f107 070c 	add.w	r7, r7, #12
   13ff8:	46bd      	mov	sp, r7
   13ffa:	bc80      	pop	{r7}
   13ffc:	4770      	bx	lr
   13ffe:	bf00      	nop
   14000:	2000315c 	.word	0x2000315c

00014004 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
   14004:	b480      	push	{r7}
   14006:	b085      	sub	sp, #20
   14008:	af00      	add	r7, sp, #0
   1400a:	60f8      	str	r0, [r7, #12]
   1400c:	60b9      	str	r1, [r7, #8]
   1400e:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
   14010:	68fb      	ldr	r3, [r7, #12]
   14012:	f1a3 0304 	sub.w	r3, r3, #4
   14016:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
   14018:	68fb      	ldr	r3, [r7, #12]
   1401a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   1401e:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   14020:	68fb      	ldr	r3, [r7, #12]
   14022:	f1a3 0304 	sub.w	r3, r3, #4
   14026:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
   14028:	68bb      	ldr	r3, [r7, #8]
   1402a:	f023 0201 	bic.w	r2, r3, #1
   1402e:	68fb      	ldr	r3, [r7, #12]
   14030:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   14032:	68fb      	ldr	r3, [r7, #12]
   14034:	f1a3 0304 	sub.w	r3, r3, #4
   14038:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
   1403a:	f244 036d 	movw	r3, #16493	; 0x406d
   1403e:	f2c0 0301 	movt	r3, #1
   14042:	68fa      	ldr	r2, [r7, #12]
   14044:	6013      	str	r3, [r2, #0]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
   14046:	68fb      	ldr	r3, [r7, #12]
   14048:	f1a3 0314 	sub.w	r3, r3, #20
   1404c:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
   1404e:	687a      	ldr	r2, [r7, #4]
   14050:	68fb      	ldr	r3, [r7, #12]
   14052:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
   14054:	68fb      	ldr	r3, [r7, #12]
   14056:	f1a3 0320 	sub.w	r3, r3, #32
   1405a:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
   1405c:	68fb      	ldr	r3, [r7, #12]
}
   1405e:	4618      	mov	r0, r3
   14060:	f107 0714 	add.w	r7, r7, #20
   14064:	46bd      	mov	sp, r7
   14066:	bc80      	pop	{r7}
   14068:	4770      	bx	lr
   1406a:	bf00      	nop

0001406c <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
   1406c:	b480      	push	{r7}
   1406e:	b085      	sub	sp, #20
   14070:	af00      	add	r7, sp, #0
volatile uint32_t ulDummy = 0UL;
   14072:	f04f 0300 	mov.w	r3, #0
   14076:	607b      	str	r3, [r7, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
   14078:	f240 03d4 	movw	r3, #212	; 0xd4
   1407c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14080:	681b      	ldr	r3, [r3, #0]
   14082:	f1b3 3fff 	cmp.w	r3, #4294967295
   14086:	d009      	beq.n	1409c <prvTaskExitError+0x30>
   14088:	f04f 0328 	mov.w	r3, #40	; 0x28
   1408c:	f383 8811 	msr	BASEPRI, r3
   14090:	f3bf 8f6f 	isb	sy
   14094:	f3bf 8f4f 	dsb	sy
   14098:	60bb      	str	r3, [r7, #8]
   1409a:	e7fe      	b.n	1409a <prvTaskExitError+0x2e>
   1409c:	f04f 0328 	mov.w	r3, #40	; 0x28
   140a0:	f383 8811 	msr	BASEPRI, r3
   140a4:	f3bf 8f6f 	isb	sy
   140a8:	f3bf 8f4f 	dsb	sy
   140ac:	60fb      	str	r3, [r7, #12]
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
   140ae:	687b      	ldr	r3, [r7, #4]
   140b0:	2b00      	cmp	r3, #0
   140b2:	d0fc      	beq.n	140ae <prvTaskExitError+0x42>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
   140b4:	f107 0714 	add.w	r7, r7, #20
   140b8:	46bd      	mov	sp, r7
   140ba:	bc80      	pop	{r7}
   140bc:	4770      	bx	lr
   140be:	bf00      	nop

000140c0 <SVC_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
   140c0:	4b07      	ldr	r3, [pc, #28]	; (140e0 <pxCurrentTCBConst2>)
   140c2:	6819      	ldr	r1, [r3, #0]
   140c4:	6808      	ldr	r0, [r1, #0]
   140c6:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   140ca:	f380 8809 	msr	PSP, r0
   140ce:	f3bf 8f6f 	isb	sy
   140d2:	f04f 0000 	mov.w	r0, #0
   140d6:	f380 8811 	msr	BASEPRI, r0
   140da:	f04e 0e0d 	orr.w	lr, lr, #13
   140de:	4770      	bx	lr

000140e0 <pxCurrentTCBConst2>:
   140e0:	2000300c 	.word	0x2000300c
   140e4:	f3af 8000 	nop.w
   140e8:	f3af 8000 	nop.w
   140ec:	f3af 8000 	nop.w

000140f0 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
   140f0:	4806      	ldr	r0, [pc, #24]	; (1410c <prvPortStartFirstTask+0x1c>)
   140f2:	6800      	ldr	r0, [r0, #0]
   140f4:	6800      	ldr	r0, [r0, #0]
   140f6:	f380 8808 	msr	MSP, r0
   140fa:	b662      	cpsie	i
   140fc:	b661      	cpsie	f
   140fe:	f3bf 8f4f 	dsb	sy
   14102:	f3bf 8f6f 	isb	sy
   14106:	df00      	svc	0
   14108:	bf00      	nop
   1410a:	0000      	.short	0x0000
   1410c:	e000ed08 	.word	0xe000ed08

00014110 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
   14110:	b580      	push	{r7, lr}
   14112:	b084      	sub	sp, #16
   14114:	af00      	add	r7, sp, #0
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	#if( configASSERT_DEFINED == 1 )
	{
		volatile uint32_t ulOriginalPriority;
		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
   14116:	f24e 4300 	movw	r3, #58368	; 0xe400
   1411a:	f2ce 0300 	movt	r3, #57344	; 0xe000
   1411e:	60bb      	str	r3, [r7, #8]
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
   14120:	68bb      	ldr	r3, [r7, #8]
   14122:	781b      	ldrb	r3, [r3, #0]
   14124:	b2db      	uxtb	r3, r3
   14126:	607b      	str	r3, [r7, #4]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
   14128:	68bb      	ldr	r3, [r7, #8]
   1412a:	f04f 32ff 	mov.w	r2, #4294967295
   1412e:	701a      	strb	r2, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
   14130:	68bb      	ldr	r3, [r7, #8]
   14132:	781b      	ldrb	r3, [r3, #0]
   14134:	b2db      	uxtb	r3, r3
   14136:	70fb      	strb	r3, [r7, #3]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
   14138:	78fb      	ldrb	r3, [r7, #3]
   1413a:	b2db      	uxtb	r3, r3
   1413c:	461a      	mov	r2, r3
   1413e:	f002 0228 	and.w	r2, r2, #40	; 0x28
   14142:	f64a 1368 	movw	r3, #43368	; 0xa968
   14146:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1414a:	701a      	strb	r2, [r3, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
   1414c:	f64a 136c 	movw	r3, #43372	; 0xa96c
   14150:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14154:	f04f 0207 	mov.w	r2, #7
   14158:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
   1415a:	e011      	b.n	14180 <xPortStartScheduler+0x70>
		{
			ulMaxPRIGROUPValue--;
   1415c:	f64a 136c 	movw	r3, #43372	; 0xa96c
   14160:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14164:	681b      	ldr	r3, [r3, #0]
   14166:	f103 32ff 	add.w	r2, r3, #4294967295
   1416a:	f64a 136c 	movw	r3, #43372	; 0xa96c
   1416e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14172:	601a      	str	r2, [r3, #0]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
   14174:	78fb      	ldrb	r3, [r7, #3]
   14176:	b2db      	uxtb	r3, r3
   14178:	ea4f 0343 	mov.w	r3, r3, lsl #1
   1417c:	b2db      	uxtb	r3, r3
   1417e:	70fb      	strb	r3, [r7, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
   14180:	78fb      	ldrb	r3, [r7, #3]
   14182:	b2db      	uxtb	r3, r3
   14184:	b25b      	sxtb	r3, r3
   14186:	2b00      	cmp	r3, #0
   14188:	dbe8      	blt.n	1415c <xPortStartScheduler+0x4c>
		#ifdef configPRIO_BITS
		{
			/* Check the FreeRTOS configuration that defines the number of
			priority bits matches the number of priority bits actually queried
			from the hardware. */
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
   1418a:	f64a 136c 	movw	r3, #43372	; 0xa96c
   1418e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14192:	681b      	ldr	r3, [r3, #0]
   14194:	f1c3 0307 	rsb	r3, r3, #7
   14198:	2b05      	cmp	r3, #5
   1419a:	d009      	beq.n	141b0 <xPortStartScheduler+0xa0>
   1419c:	f04f 0328 	mov.w	r3, #40	; 0x28
   141a0:	f383 8811 	msr	BASEPRI, r3
   141a4:	f3bf 8f6f 	isb	sy
   141a8:	f3bf 8f4f 	dsb	sy
   141ac:	60fb      	str	r3, [r7, #12]
   141ae:	e7fe      	b.n	141ae <xPortStartScheduler+0x9e>
		}
		#endif

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
   141b0:	f64a 136c 	movw	r3, #43372	; 0xa96c
   141b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   141b8:	681b      	ldr	r3, [r3, #0]
   141ba:	ea4f 2203 	mov.w	r2, r3, lsl #8
   141be:	f64a 136c 	movw	r3, #43372	; 0xa96c
   141c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   141c6:	601a      	str	r2, [r3, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
   141c8:	f64a 136c 	movw	r3, #43372	; 0xa96c
   141cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   141d0:	681b      	ldr	r3, [r3, #0]
   141d2:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
   141d6:	f64a 136c 	movw	r3, #43372	; 0xa96c
   141da:	f2c2 0300 	movt	r3, #8192	; 0x2000
   141de:	601a      	str	r2, [r3, #0]

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pucFirstUserPriorityRegister = ulOriginalPriority;
   141e0:	687b      	ldr	r3, [r7, #4]
   141e2:	b2da      	uxtb	r2, r3
   141e4:	68bb      	ldr	r3, [r7, #8]
   141e6:	701a      	strb	r2, [r3, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
   141e8:	f64e 5320 	movw	r3, #60704	; 0xed20
   141ec:	f2ce 0300 	movt	r3, #57344	; 0xe000
   141f0:	f64e 5220 	movw	r2, #60704	; 0xed20
   141f4:	f2ce 0200 	movt	r2, #57344	; 0xe000
   141f8:	6812      	ldr	r2, [r2, #0]
   141fa:	f442 0278 	orr.w	r2, r2, #16252928	; 0xf80000
   141fe:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
   14200:	f64e 5320 	movw	r3, #60704	; 0xed20
   14204:	f2ce 0300 	movt	r3, #57344	; 0xe000
   14208:	f64e 5220 	movw	r2, #60704	; 0xed20
   1420c:	f2ce 0200 	movt	r2, #57344	; 0xe000
   14210:	6812      	ldr	r2, [r2, #0]
   14212:	f042 4278 	orr.w	r2, r2, #4160749568	; 0xf8000000
   14216:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
   14218:	f000 f8e4 	bl	143e4 <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
   1421c:	f240 03d4 	movw	r3, #212	; 0xd4
   14220:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14224:	f04f 0200 	mov.w	r2, #0
   14228:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
   1422a:	f7ff ff61 	bl	140f0 <prvPortStartFirstTask>
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS.  Call
	vTaskSwitchContext() so link time optimisation does not remove the
	symbol. */
	vTaskSwitchContext();
   1422e:	f7fd fc2d 	bl	11a8c <vTaskSwitchContext>
	prvTaskExitError();
   14232:	f7ff ff1b 	bl	1406c <prvTaskExitError>

	/* Should not get here! */
	return 0;
   14236:	f04f 0300 	mov.w	r3, #0
}
   1423a:	4618      	mov	r0, r3
   1423c:	f107 0710 	add.w	r7, r7, #16
   14240:	46bd      	mov	sp, r7
   14242:	bd80      	pop	{r7, pc}

00014244 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
   14244:	b480      	push	{r7}
   14246:	b083      	sub	sp, #12
   14248:	af00      	add	r7, sp, #0
	/* Not implemented in ports where there is nothing to return to.
	Artificially force an assert. */
	configASSERT( uxCriticalNesting == 1000UL );
   1424a:	f240 03d4 	movw	r3, #212	; 0xd4
   1424e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14252:	681b      	ldr	r3, [r3, #0]
   14254:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
   14258:	d009      	beq.n	1426e <vPortEndScheduler+0x2a>
   1425a:	f04f 0328 	mov.w	r3, #40	; 0x28
   1425e:	f383 8811 	msr	BASEPRI, r3
   14262:	f3bf 8f6f 	isb	sy
   14266:	f3bf 8f4f 	dsb	sy
   1426a:	607b      	str	r3, [r7, #4]
   1426c:	e7fe      	b.n	1426c <vPortEndScheduler+0x28>
}
   1426e:	f107 070c 	add.w	r7, r7, #12
   14272:	46bd      	mov	sp, r7
   14274:	bc80      	pop	{r7}
   14276:	4770      	bx	lr

00014278 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
   14278:	b480      	push	{r7}
   1427a:	b083      	sub	sp, #12
   1427c:	af00      	add	r7, sp, #0
   1427e:	f04f 0328 	mov.w	r3, #40	; 0x28
   14282:	f383 8811 	msr	BASEPRI, r3
   14286:	f3bf 8f6f 	isb	sy
   1428a:	f3bf 8f4f 	dsb	sy
   1428e:	603b      	str	r3, [r7, #0]
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
   14290:	f240 03d4 	movw	r3, #212	; 0xd4
   14294:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14298:	681b      	ldr	r3, [r3, #0]
   1429a:	f103 0201 	add.w	r2, r3, #1
   1429e:	f240 03d4 	movw	r3, #212	; 0xd4
   142a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   142a6:	601a      	str	r2, [r3, #0]
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
   142a8:	f240 03d4 	movw	r3, #212	; 0xd4
   142ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
   142b0:	681b      	ldr	r3, [r3, #0]
   142b2:	2b01      	cmp	r3, #1
   142b4:	d112      	bne.n	142dc <vPortEnterCritical+0x64>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
   142b6:	f64e 5304 	movw	r3, #60676	; 0xed04
   142ba:	f2ce 0300 	movt	r3, #57344	; 0xe000
   142be:	681b      	ldr	r3, [r3, #0]
   142c0:	f003 03ff 	and.w	r3, r3, #255	; 0xff
   142c4:	2b00      	cmp	r3, #0
   142c6:	d009      	beq.n	142dc <vPortEnterCritical+0x64>
   142c8:	f04f 0328 	mov.w	r3, #40	; 0x28
   142cc:	f383 8811 	msr	BASEPRI, r3
   142d0:	f3bf 8f6f 	isb	sy
   142d4:	f3bf 8f4f 	dsb	sy
   142d8:	607b      	str	r3, [r7, #4]
   142da:	e7fe      	b.n	142da <vPortEnterCritical+0x62>
	}
}
   142dc:	f107 070c 	add.w	r7, r7, #12
   142e0:	46bd      	mov	sp, r7
   142e2:	bc80      	pop	{r7}
   142e4:	4770      	bx	lr
   142e6:	bf00      	nop

000142e8 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
   142e8:	b480      	push	{r7}
   142ea:	b083      	sub	sp, #12
   142ec:	af00      	add	r7, sp, #0
	configASSERT( uxCriticalNesting );
   142ee:	f240 03d4 	movw	r3, #212	; 0xd4
   142f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   142f6:	681b      	ldr	r3, [r3, #0]
   142f8:	2b00      	cmp	r3, #0
   142fa:	d109      	bne.n	14310 <vPortExitCritical+0x28>
   142fc:	f04f 0328 	mov.w	r3, #40	; 0x28
   14300:	f383 8811 	msr	BASEPRI, r3
   14304:	f3bf 8f6f 	isb	sy
   14308:	f3bf 8f4f 	dsb	sy
   1430c:	603b      	str	r3, [r7, #0]
   1430e:	e7fe      	b.n	1430e <vPortExitCritical+0x26>
	uxCriticalNesting--;
   14310:	f240 03d4 	movw	r3, #212	; 0xd4
   14314:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14318:	681b      	ldr	r3, [r3, #0]
   1431a:	f103 32ff 	add.w	r2, r3, #4294967295
   1431e:	f240 03d4 	movw	r3, #212	; 0xd4
   14322:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14326:	601a      	str	r2, [r3, #0]
	if( uxCriticalNesting == 0 )
   14328:	f240 03d4 	movw	r3, #212	; 0xd4
   1432c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14330:	681b      	ldr	r3, [r3, #0]
   14332:	2b00      	cmp	r3, #0
   14334:	d105      	bne.n	14342 <vPortExitCritical+0x5a>
   14336:	f04f 0300 	mov.w	r3, #0
   1433a:	607b      	str	r3, [r7, #4]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   1433c:	687b      	ldr	r3, [r7, #4]
   1433e:	f383 8811 	msr	BASEPRI, r3
	{
		portENABLE_INTERRUPTS();
	}
}
   14342:	f107 070c 	add.w	r7, r7, #12
   14346:	46bd      	mov	sp, r7
   14348:	bc80      	pop	{r7}
   1434a:	4770      	bx	lr
   1434c:	0000      	lsls	r0, r0, #0
	...

00014350 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
   14350:	f3ef 8009 	mrs	r0, PSP
   14354:	f3bf 8f6f 	isb	sy
   14358:	4b0d      	ldr	r3, [pc, #52]	; (14390 <pxCurrentTCBConst>)
   1435a:	681a      	ldr	r2, [r3, #0]
   1435c:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   14360:	6010      	str	r0, [r2, #0]
   14362:	e92d 4008 	stmdb	sp!, {r3, lr}
   14366:	f04f 0028 	mov.w	r0, #40	; 0x28
   1436a:	f380 8811 	msr	BASEPRI, r0
   1436e:	f7fd fb8d 	bl	11a8c <vTaskSwitchContext>
   14372:	f04f 0000 	mov.w	r0, #0
   14376:	f380 8811 	msr	BASEPRI, r0
   1437a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   1437e:	6819      	ldr	r1, [r3, #0]
   14380:	6808      	ldr	r0, [r1, #0]
   14382:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   14386:	f380 8809 	msr	PSP, r0
   1438a:	f3bf 8f6f 	isb	sy
   1438e:	4770      	bx	lr

00014390 <pxCurrentTCBConst>:
   14390:	2000300c 	.word	0x2000300c
   14394:	f3af 8000 	nop.w
   14398:	f3af 8000 	nop.w
   1439c:	f3af 8000 	nop.w

000143a0 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
   143a0:	b580      	push	{r7, lr}
   143a2:	b082      	sub	sp, #8
   143a4:	af00      	add	r7, sp, #0

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   143a6:	f04f 0328 	mov.w	r3, #40	; 0x28
   143aa:	f383 8811 	msr	BASEPRI, r3
   143ae:	f3bf 8f6f 	isb	sy
   143b2:	f3bf 8f4f 	dsb	sy
   143b6:	603b      	str	r3, [r7, #0]
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
   143b8:	f7fd fa66 	bl	11888 <xTaskIncrementTick>
   143bc:	4603      	mov	r3, r0
   143be:	2b00      	cmp	r3, #0
   143c0:	d006      	beq.n	143d0 <SysTick_Handler+0x30>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   143c2:	f64e 5304 	movw	r3, #60676	; 0xed04
   143c6:	f2ce 0300 	movt	r3, #57344	; 0xe000
   143ca:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   143ce:	601a      	str	r2, [r3, #0]
   143d0:	f04f 0300 	mov.w	r3, #0
   143d4:	607b      	str	r3, [r7, #4]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   143d6:	687b      	ldr	r3, [r7, #4]
   143d8:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
   143dc:	f107 0708 	add.w	r7, r7, #8
   143e0:	46bd      	mov	sp, r7
   143e2:	bd80      	pop	{r7, pc}

000143e4 <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
   143e4:	b480      	push	{r7}
   143e6:	af00      	add	r7, sp, #0
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Stop and clear the SysTick. */
	portNVIC_SYSTICK_CTRL_REG = 0UL;
   143e8:	f24e 0310 	movw	r3, #57360	; 0xe010
   143ec:	f2ce 0300 	movt	r3, #57344	; 0xe000
   143f0:	f04f 0200 	mov.w	r2, #0
   143f4:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
   143f6:	f24e 0318 	movw	r3, #57368	; 0xe018
   143fa:	f2ce 0300 	movt	r3, #57344	; 0xe000
   143fe:	f04f 0200 	mov.w	r2, #0
   14402:	601a      	str	r2, [r3, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
   14404:	f24e 0314 	movw	r3, #57364	; 0xe014
   14408:	f2ce 0300 	movt	r3, #57344	; 0xe000
   1440c:	f240 02b4 	movw	r2, #180	; 0xb4
   14410:	f2c2 0200 	movt	r2, #8192	; 0x2000
   14414:	6811      	ldr	r1, [r2, #0]
   14416:	f644 52d3 	movw	r2, #19923	; 0x4dd3
   1441a:	f2c1 0262 	movt	r2, #4194	; 0x1062
   1441e:	fba2 0201 	umull	r0, r2, r2, r1
   14422:	ea4f 1292 	mov.w	r2, r2, lsr #6
   14426:	f102 32ff 	add.w	r2, r2, #4294967295
   1442a:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
   1442c:	f24e 0310 	movw	r3, #57360	; 0xe010
   14430:	f2ce 0300 	movt	r3, #57344	; 0xe000
   14434:	f04f 0207 	mov.w	r2, #7
   14438:	601a      	str	r2, [r3, #0]
}
   1443a:	46bd      	mov	sp, r7
   1443c:	bc80      	pop	{r7}
   1443e:	4770      	bx	lr

00014440 <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
   14440:	b480      	push	{r7}
   14442:	b085      	sub	sp, #20
   14444:	af00      	add	r7, sp, #0
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
   14446:	f3ef 8305 	mrs	r3, IPSR
   1444a:	603b      	str	r3, [r7, #0]

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
   1444c:	683b      	ldr	r3, [r7, #0]
   1444e:	2b0f      	cmp	r3, #15
   14450:	d91a      	bls.n	14488 <vPortValidateInterruptPriority+0x48>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
   14452:	f244 0390 	movw	r3, #16528	; 0x4090
   14456:	f2c0 0302 	movt	r3, #2
   1445a:	681a      	ldr	r2, [r3, #0]
   1445c:	683b      	ldr	r3, [r7, #0]
   1445e:	4413      	add	r3, r2
   14460:	781b      	ldrb	r3, [r3, #0]
   14462:	71fb      	strb	r3, [r7, #7]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
   14464:	f64a 1368 	movw	r3, #43368	; 0xa968
   14468:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1446c:	781b      	ldrb	r3, [r3, #0]
   1446e:	79fa      	ldrb	r2, [r7, #7]
   14470:	429a      	cmp	r2, r3
   14472:	d209      	bcs.n	14488 <vPortValidateInterruptPriority+0x48>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   14474:	f04f 0328 	mov.w	r3, #40	; 0x28
   14478:	f383 8811 	msr	BASEPRI, r3
   1447c:	f3bf 8f6f 	isb	sy
   14480:	f3bf 8f4f 	dsb	sy
   14484:	60bb      	str	r3, [r7, #8]
   14486:	e7fe      	b.n	14486 <vPortValidateInterruptPriority+0x46>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
   14488:	f64e 530c 	movw	r3, #60684	; 0xed0c
   1448c:	f2ce 0300 	movt	r3, #57344	; 0xe000
   14490:	681b      	ldr	r3, [r3, #0]
   14492:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
   14496:	f64a 136c 	movw	r3, #43372	; 0xa96c
   1449a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1449e:	681b      	ldr	r3, [r3, #0]
   144a0:	429a      	cmp	r2, r3
   144a2:	d909      	bls.n	144b8 <vPortValidateInterruptPriority+0x78>
   144a4:	f04f 0328 	mov.w	r3, #40	; 0x28
   144a8:	f383 8811 	msr	BASEPRI, r3
   144ac:	f3bf 8f6f 	isb	sy
   144b0:	f3bf 8f4f 	dsb	sy
   144b4:	60fb      	str	r3, [r7, #12]
   144b6:	e7fe      	b.n	144b6 <vPortValidateInterruptPriority+0x76>
	}
   144b8:	f107 0714 	add.w	r7, r7, #20
   144bc:	46bd      	mov	sp, r7
   144be:	bc80      	pop	{r7}
   144c0:	4770      	bx	lr
   144c2:	bf00      	nop

000144c4 <__aeabi_drsub>:
   144c4:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
   144c8:	e002      	b.n	144d0 <__adddf3>
   144ca:	bf00      	nop

000144cc <__aeabi_dsub>:
   144cc:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

000144d0 <__adddf3>:
   144d0:	b530      	push	{r4, r5, lr}
   144d2:	ea4f 0441 	mov.w	r4, r1, lsl #1
   144d6:	ea4f 0543 	mov.w	r5, r3, lsl #1
   144da:	ea94 0f05 	teq	r4, r5
   144de:	bf08      	it	eq
   144e0:	ea90 0f02 	teqeq	r0, r2
   144e4:	bf1f      	itttt	ne
   144e6:	ea54 0c00 	orrsne.w	ip, r4, r0
   144ea:	ea55 0c02 	orrsne.w	ip, r5, r2
   144ee:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
   144f2:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   144f6:	f000 80e2 	beq.w	146be <__adddf3+0x1ee>
   144fa:	ea4f 5454 	mov.w	r4, r4, lsr #21
   144fe:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
   14502:	bfb8      	it	lt
   14504:	426d      	neglt	r5, r5
   14506:	dd0c      	ble.n	14522 <__adddf3+0x52>
   14508:	442c      	add	r4, r5
   1450a:	ea80 0202 	eor.w	r2, r0, r2
   1450e:	ea81 0303 	eor.w	r3, r1, r3
   14512:	ea82 0000 	eor.w	r0, r2, r0
   14516:	ea83 0101 	eor.w	r1, r3, r1
   1451a:	ea80 0202 	eor.w	r2, r0, r2
   1451e:	ea81 0303 	eor.w	r3, r1, r3
   14522:	2d36      	cmp	r5, #54	; 0x36
   14524:	bf88      	it	hi
   14526:	bd30      	pophi	{r4, r5, pc}
   14528:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   1452c:	ea4f 3101 	mov.w	r1, r1, lsl #12
   14530:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
   14534:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
   14538:	d002      	beq.n	14540 <__adddf3+0x70>
   1453a:	4240      	negs	r0, r0
   1453c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   14540:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
   14544:	ea4f 3303 	mov.w	r3, r3, lsl #12
   14548:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
   1454c:	d002      	beq.n	14554 <__adddf3+0x84>
   1454e:	4252      	negs	r2, r2
   14550:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   14554:	ea94 0f05 	teq	r4, r5
   14558:	f000 80a7 	beq.w	146aa <__adddf3+0x1da>
   1455c:	f1a4 0401 	sub.w	r4, r4, #1
   14560:	f1d5 0e20 	rsbs	lr, r5, #32
   14564:	db0d      	blt.n	14582 <__adddf3+0xb2>
   14566:	fa02 fc0e 	lsl.w	ip, r2, lr
   1456a:	fa22 f205 	lsr.w	r2, r2, r5
   1456e:	1880      	adds	r0, r0, r2
   14570:	f141 0100 	adc.w	r1, r1, #0
   14574:	fa03 f20e 	lsl.w	r2, r3, lr
   14578:	1880      	adds	r0, r0, r2
   1457a:	fa43 f305 	asr.w	r3, r3, r5
   1457e:	4159      	adcs	r1, r3
   14580:	e00e      	b.n	145a0 <__adddf3+0xd0>
   14582:	f1a5 0520 	sub.w	r5, r5, #32
   14586:	f10e 0e20 	add.w	lr, lr, #32
   1458a:	2a01      	cmp	r2, #1
   1458c:	fa03 fc0e 	lsl.w	ip, r3, lr
   14590:	bf28      	it	cs
   14592:	f04c 0c02 	orrcs.w	ip, ip, #2
   14596:	fa43 f305 	asr.w	r3, r3, r5
   1459a:	18c0      	adds	r0, r0, r3
   1459c:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
   145a0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   145a4:	d507      	bpl.n	145b6 <__adddf3+0xe6>
   145a6:	f04f 0e00 	mov.w	lr, #0
   145aa:	f1dc 0c00 	rsbs	ip, ip, #0
   145ae:	eb7e 0000 	sbcs.w	r0, lr, r0
   145b2:	eb6e 0101 	sbc.w	r1, lr, r1
   145b6:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
   145ba:	d31b      	bcc.n	145f4 <__adddf3+0x124>
   145bc:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
   145c0:	d30c      	bcc.n	145dc <__adddf3+0x10c>
   145c2:	0849      	lsrs	r1, r1, #1
   145c4:	ea5f 0030 	movs.w	r0, r0, rrx
   145c8:	ea4f 0c3c 	mov.w	ip, ip, rrx
   145cc:	f104 0401 	add.w	r4, r4, #1
   145d0:	ea4f 5244 	mov.w	r2, r4, lsl #21
   145d4:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
   145d8:	f080 809a 	bcs.w	14710 <__adddf3+0x240>
   145dc:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   145e0:	bf08      	it	eq
   145e2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   145e6:	f150 0000 	adcs.w	r0, r0, #0
   145ea:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   145ee:	ea41 0105 	orr.w	r1, r1, r5
   145f2:	bd30      	pop	{r4, r5, pc}
   145f4:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
   145f8:	4140      	adcs	r0, r0
   145fa:	eb41 0101 	adc.w	r1, r1, r1
   145fe:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   14602:	f1a4 0401 	sub.w	r4, r4, #1
   14606:	d1e9      	bne.n	145dc <__adddf3+0x10c>
   14608:	f091 0f00 	teq	r1, #0
   1460c:	bf04      	itt	eq
   1460e:	4601      	moveq	r1, r0
   14610:	2000      	moveq	r0, #0
   14612:	fab1 f381 	clz	r3, r1
   14616:	bf08      	it	eq
   14618:	3320      	addeq	r3, #32
   1461a:	f1a3 030b 	sub.w	r3, r3, #11
   1461e:	f1b3 0220 	subs.w	r2, r3, #32
   14622:	da0c      	bge.n	1463e <__adddf3+0x16e>
   14624:	320c      	adds	r2, #12
   14626:	dd08      	ble.n	1463a <__adddf3+0x16a>
   14628:	f102 0c14 	add.w	ip, r2, #20
   1462c:	f1c2 020c 	rsb	r2, r2, #12
   14630:	fa01 f00c 	lsl.w	r0, r1, ip
   14634:	fa21 f102 	lsr.w	r1, r1, r2
   14638:	e00c      	b.n	14654 <__adddf3+0x184>
   1463a:	f102 0214 	add.w	r2, r2, #20
   1463e:	bfd8      	it	le
   14640:	f1c2 0c20 	rsble	ip, r2, #32
   14644:	fa01 f102 	lsl.w	r1, r1, r2
   14648:	fa20 fc0c 	lsr.w	ip, r0, ip
   1464c:	bfdc      	itt	le
   1464e:	ea41 010c 	orrle.w	r1, r1, ip
   14652:	4090      	lslle	r0, r2
   14654:	1ae4      	subs	r4, r4, r3
   14656:	bfa2      	ittt	ge
   14658:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
   1465c:	4329      	orrge	r1, r5
   1465e:	bd30      	popge	{r4, r5, pc}
   14660:	ea6f 0404 	mvn.w	r4, r4
   14664:	3c1f      	subs	r4, #31
   14666:	da1c      	bge.n	146a2 <__adddf3+0x1d2>
   14668:	340c      	adds	r4, #12
   1466a:	dc0e      	bgt.n	1468a <__adddf3+0x1ba>
   1466c:	f104 0414 	add.w	r4, r4, #20
   14670:	f1c4 0220 	rsb	r2, r4, #32
   14674:	fa20 f004 	lsr.w	r0, r0, r4
   14678:	fa01 f302 	lsl.w	r3, r1, r2
   1467c:	ea40 0003 	orr.w	r0, r0, r3
   14680:	fa21 f304 	lsr.w	r3, r1, r4
   14684:	ea45 0103 	orr.w	r1, r5, r3
   14688:	bd30      	pop	{r4, r5, pc}
   1468a:	f1c4 040c 	rsb	r4, r4, #12
   1468e:	f1c4 0220 	rsb	r2, r4, #32
   14692:	fa20 f002 	lsr.w	r0, r0, r2
   14696:	fa01 f304 	lsl.w	r3, r1, r4
   1469a:	ea40 0003 	orr.w	r0, r0, r3
   1469e:	4629      	mov	r1, r5
   146a0:	bd30      	pop	{r4, r5, pc}
   146a2:	fa21 f004 	lsr.w	r0, r1, r4
   146a6:	4629      	mov	r1, r5
   146a8:	bd30      	pop	{r4, r5, pc}
   146aa:	f094 0f00 	teq	r4, #0
   146ae:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
   146b2:	bf06      	itte	eq
   146b4:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
   146b8:	3401      	addeq	r4, #1
   146ba:	3d01      	subne	r5, #1
   146bc:	e74e      	b.n	1455c <__adddf3+0x8c>
   146be:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   146c2:	bf18      	it	ne
   146c4:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   146c8:	d029      	beq.n	1471e <__adddf3+0x24e>
   146ca:	ea94 0f05 	teq	r4, r5
   146ce:	bf08      	it	eq
   146d0:	ea90 0f02 	teqeq	r0, r2
   146d4:	d005      	beq.n	146e2 <__adddf3+0x212>
   146d6:	ea54 0c00 	orrs.w	ip, r4, r0
   146da:	bf04      	itt	eq
   146dc:	4619      	moveq	r1, r3
   146de:	4610      	moveq	r0, r2
   146e0:	bd30      	pop	{r4, r5, pc}
   146e2:	ea91 0f03 	teq	r1, r3
   146e6:	bf1e      	ittt	ne
   146e8:	2100      	movne	r1, #0
   146ea:	2000      	movne	r0, #0
   146ec:	bd30      	popne	{r4, r5, pc}
   146ee:	ea5f 5c54 	movs.w	ip, r4, lsr #21
   146f2:	d105      	bne.n	14700 <__adddf3+0x230>
   146f4:	0040      	lsls	r0, r0, #1
   146f6:	4149      	adcs	r1, r1
   146f8:	bf28      	it	cs
   146fa:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
   146fe:	bd30      	pop	{r4, r5, pc}
   14700:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
   14704:	bf3c      	itt	cc
   14706:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
   1470a:	bd30      	popcc	{r4, r5, pc}
   1470c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   14710:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
   14714:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   14718:	f04f 0000 	mov.w	r0, #0
   1471c:	bd30      	pop	{r4, r5, pc}
   1471e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   14722:	bf1a      	itte	ne
   14724:	4619      	movne	r1, r3
   14726:	4610      	movne	r0, r2
   14728:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
   1472c:	bf1c      	itt	ne
   1472e:	460b      	movne	r3, r1
   14730:	4602      	movne	r2, r0
   14732:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   14736:	bf06      	itte	eq
   14738:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
   1473c:	ea91 0f03 	teqeq	r1, r3
   14740:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
   14744:	bd30      	pop	{r4, r5, pc}
   14746:	bf00      	nop

00014748 <__aeabi_ui2d>:
   14748:	f090 0f00 	teq	r0, #0
   1474c:	bf04      	itt	eq
   1474e:	2100      	moveq	r1, #0
   14750:	4770      	bxeq	lr
   14752:	b530      	push	{r4, r5, lr}
   14754:	f44f 6480 	mov.w	r4, #1024	; 0x400
   14758:	f104 0432 	add.w	r4, r4, #50	; 0x32
   1475c:	f04f 0500 	mov.w	r5, #0
   14760:	f04f 0100 	mov.w	r1, #0
   14764:	e750      	b.n	14608 <__adddf3+0x138>
   14766:	bf00      	nop

00014768 <__aeabi_i2d>:
   14768:	f090 0f00 	teq	r0, #0
   1476c:	bf04      	itt	eq
   1476e:	2100      	moveq	r1, #0
   14770:	4770      	bxeq	lr
   14772:	b530      	push	{r4, r5, lr}
   14774:	f44f 6480 	mov.w	r4, #1024	; 0x400
   14778:	f104 0432 	add.w	r4, r4, #50	; 0x32
   1477c:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
   14780:	bf48      	it	mi
   14782:	4240      	negmi	r0, r0
   14784:	f04f 0100 	mov.w	r1, #0
   14788:	e73e      	b.n	14608 <__adddf3+0x138>
   1478a:	bf00      	nop

0001478c <__aeabi_f2d>:
   1478c:	0042      	lsls	r2, r0, #1
   1478e:	ea4f 01e2 	mov.w	r1, r2, asr #3
   14792:	ea4f 0131 	mov.w	r1, r1, rrx
   14796:	ea4f 7002 	mov.w	r0, r2, lsl #28
   1479a:	bf1f      	itttt	ne
   1479c:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
   147a0:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   147a4:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
   147a8:	4770      	bxne	lr
   147aa:	f092 0f00 	teq	r2, #0
   147ae:	bf14      	ite	ne
   147b0:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   147b4:	4770      	bxeq	lr
   147b6:	b530      	push	{r4, r5, lr}
   147b8:	f44f 7460 	mov.w	r4, #896	; 0x380
   147bc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   147c0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   147c4:	e720      	b.n	14608 <__adddf3+0x138>
   147c6:	bf00      	nop

000147c8 <__aeabi_ul2d>:
   147c8:	ea50 0201 	orrs.w	r2, r0, r1
   147cc:	bf08      	it	eq
   147ce:	4770      	bxeq	lr
   147d0:	b530      	push	{r4, r5, lr}
   147d2:	f04f 0500 	mov.w	r5, #0
   147d6:	e00a      	b.n	147ee <__aeabi_l2d+0x16>

000147d8 <__aeabi_l2d>:
   147d8:	ea50 0201 	orrs.w	r2, r0, r1
   147dc:	bf08      	it	eq
   147de:	4770      	bxeq	lr
   147e0:	b530      	push	{r4, r5, lr}
   147e2:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
   147e6:	d502      	bpl.n	147ee <__aeabi_l2d+0x16>
   147e8:	4240      	negs	r0, r0
   147ea:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   147ee:	f44f 6480 	mov.w	r4, #1024	; 0x400
   147f2:	f104 0432 	add.w	r4, r4, #50	; 0x32
   147f6:	ea5f 5c91 	movs.w	ip, r1, lsr #22
   147fa:	f43f aedc 	beq.w	145b6 <__adddf3+0xe6>
   147fe:	f04f 0203 	mov.w	r2, #3
   14802:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   14806:	bf18      	it	ne
   14808:	3203      	addne	r2, #3
   1480a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   1480e:	bf18      	it	ne
   14810:	3203      	addne	r2, #3
   14812:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
   14816:	f1c2 0320 	rsb	r3, r2, #32
   1481a:	fa00 fc03 	lsl.w	ip, r0, r3
   1481e:	fa20 f002 	lsr.w	r0, r0, r2
   14822:	fa01 fe03 	lsl.w	lr, r1, r3
   14826:	ea40 000e 	orr.w	r0, r0, lr
   1482a:	fa21 f102 	lsr.w	r1, r1, r2
   1482e:	4414      	add	r4, r2
   14830:	e6c1      	b.n	145b6 <__adddf3+0xe6>
   14832:	bf00      	nop

00014834 <__aeabi_dmul>:
   14834:	b570      	push	{r4, r5, r6, lr}
   14836:	f04f 0cff 	mov.w	ip, #255	; 0xff
   1483a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   1483e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   14842:	bf1d      	ittte	ne
   14844:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   14848:	ea94 0f0c 	teqne	r4, ip
   1484c:	ea95 0f0c 	teqne	r5, ip
   14850:	f000 f8de 	bleq	14a10 <__aeabi_dmul+0x1dc>
   14854:	442c      	add	r4, r5
   14856:	ea81 0603 	eor.w	r6, r1, r3
   1485a:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
   1485e:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
   14862:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
   14866:	bf18      	it	ne
   14868:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
   1486c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   14870:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   14874:	d038      	beq.n	148e8 <__aeabi_dmul+0xb4>
   14876:	fba0 ce02 	umull	ip, lr, r0, r2
   1487a:	f04f 0500 	mov.w	r5, #0
   1487e:	fbe1 e502 	umlal	lr, r5, r1, r2
   14882:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
   14886:	fbe0 e503 	umlal	lr, r5, r0, r3
   1488a:	f04f 0600 	mov.w	r6, #0
   1488e:	fbe1 5603 	umlal	r5, r6, r1, r3
   14892:	f09c 0f00 	teq	ip, #0
   14896:	bf18      	it	ne
   14898:	f04e 0e01 	orrne.w	lr, lr, #1
   1489c:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
   148a0:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
   148a4:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
   148a8:	d204      	bcs.n	148b4 <__aeabi_dmul+0x80>
   148aa:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
   148ae:	416d      	adcs	r5, r5
   148b0:	eb46 0606 	adc.w	r6, r6, r6
   148b4:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
   148b8:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
   148bc:	ea4f 20c5 	mov.w	r0, r5, lsl #11
   148c0:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
   148c4:	ea4f 2ece 	mov.w	lr, lr, lsl #11
   148c8:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   148cc:	bf88      	it	hi
   148ce:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   148d2:	d81e      	bhi.n	14912 <__aeabi_dmul+0xde>
   148d4:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
   148d8:	bf08      	it	eq
   148da:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
   148de:	f150 0000 	adcs.w	r0, r0, #0
   148e2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   148e6:	bd70      	pop	{r4, r5, r6, pc}
   148e8:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
   148ec:	ea46 0101 	orr.w	r1, r6, r1
   148f0:	ea40 0002 	orr.w	r0, r0, r2
   148f4:	ea81 0103 	eor.w	r1, r1, r3
   148f8:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
   148fc:	bfc2      	ittt	gt
   148fe:	ebd4 050c 	rsbsgt	r5, r4, ip
   14902:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   14906:	bd70      	popgt	{r4, r5, r6, pc}
   14908:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   1490c:	f04f 0e00 	mov.w	lr, #0
   14910:	3c01      	subs	r4, #1
   14912:	f300 80ab 	bgt.w	14a6c <__aeabi_dmul+0x238>
   14916:	f114 0f36 	cmn.w	r4, #54	; 0x36
   1491a:	bfde      	ittt	le
   1491c:	2000      	movle	r0, #0
   1491e:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
   14922:	bd70      	pople	{r4, r5, r6, pc}
   14924:	f1c4 0400 	rsb	r4, r4, #0
   14928:	3c20      	subs	r4, #32
   1492a:	da35      	bge.n	14998 <__aeabi_dmul+0x164>
   1492c:	340c      	adds	r4, #12
   1492e:	dc1b      	bgt.n	14968 <__aeabi_dmul+0x134>
   14930:	f104 0414 	add.w	r4, r4, #20
   14934:	f1c4 0520 	rsb	r5, r4, #32
   14938:	fa00 f305 	lsl.w	r3, r0, r5
   1493c:	fa20 f004 	lsr.w	r0, r0, r4
   14940:	fa01 f205 	lsl.w	r2, r1, r5
   14944:	ea40 0002 	orr.w	r0, r0, r2
   14948:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
   1494c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   14950:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   14954:	fa21 f604 	lsr.w	r6, r1, r4
   14958:	eb42 0106 	adc.w	r1, r2, r6
   1495c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   14960:	bf08      	it	eq
   14962:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   14966:	bd70      	pop	{r4, r5, r6, pc}
   14968:	f1c4 040c 	rsb	r4, r4, #12
   1496c:	f1c4 0520 	rsb	r5, r4, #32
   14970:	fa00 f304 	lsl.w	r3, r0, r4
   14974:	fa20 f005 	lsr.w	r0, r0, r5
   14978:	fa01 f204 	lsl.w	r2, r1, r4
   1497c:	ea40 0002 	orr.w	r0, r0, r2
   14980:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   14984:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   14988:	f141 0100 	adc.w	r1, r1, #0
   1498c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   14990:	bf08      	it	eq
   14992:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   14996:	bd70      	pop	{r4, r5, r6, pc}
   14998:	f1c4 0520 	rsb	r5, r4, #32
   1499c:	fa00 f205 	lsl.w	r2, r0, r5
   149a0:	ea4e 0e02 	orr.w	lr, lr, r2
   149a4:	fa20 f304 	lsr.w	r3, r0, r4
   149a8:	fa01 f205 	lsl.w	r2, r1, r5
   149ac:	ea43 0302 	orr.w	r3, r3, r2
   149b0:	fa21 f004 	lsr.w	r0, r1, r4
   149b4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   149b8:	fa21 f204 	lsr.w	r2, r1, r4
   149bc:	ea20 0002 	bic.w	r0, r0, r2
   149c0:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
   149c4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   149c8:	bf08      	it	eq
   149ca:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   149ce:	bd70      	pop	{r4, r5, r6, pc}
   149d0:	f094 0f00 	teq	r4, #0
   149d4:	d10f      	bne.n	149f6 <__aeabi_dmul+0x1c2>
   149d6:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
   149da:	0040      	lsls	r0, r0, #1
   149dc:	eb41 0101 	adc.w	r1, r1, r1
   149e0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   149e4:	bf08      	it	eq
   149e6:	3c01      	subeq	r4, #1
   149e8:	d0f7      	beq.n	149da <__aeabi_dmul+0x1a6>
   149ea:	ea41 0106 	orr.w	r1, r1, r6
   149ee:	f095 0f00 	teq	r5, #0
   149f2:	bf18      	it	ne
   149f4:	4770      	bxne	lr
   149f6:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
   149fa:	0052      	lsls	r2, r2, #1
   149fc:	eb43 0303 	adc.w	r3, r3, r3
   14a00:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
   14a04:	bf08      	it	eq
   14a06:	3d01      	subeq	r5, #1
   14a08:	d0f7      	beq.n	149fa <__aeabi_dmul+0x1c6>
   14a0a:	ea43 0306 	orr.w	r3, r3, r6
   14a0e:	4770      	bx	lr
   14a10:	ea94 0f0c 	teq	r4, ip
   14a14:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   14a18:	bf18      	it	ne
   14a1a:	ea95 0f0c 	teqne	r5, ip
   14a1e:	d00c      	beq.n	14a3a <__aeabi_dmul+0x206>
   14a20:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   14a24:	bf18      	it	ne
   14a26:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   14a2a:	d1d1      	bne.n	149d0 <__aeabi_dmul+0x19c>
   14a2c:	ea81 0103 	eor.w	r1, r1, r3
   14a30:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   14a34:	f04f 0000 	mov.w	r0, #0
   14a38:	bd70      	pop	{r4, r5, r6, pc}
   14a3a:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   14a3e:	bf06      	itte	eq
   14a40:	4610      	moveq	r0, r2
   14a42:	4619      	moveq	r1, r3
   14a44:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   14a48:	d019      	beq.n	14a7e <__aeabi_dmul+0x24a>
   14a4a:	ea94 0f0c 	teq	r4, ip
   14a4e:	d102      	bne.n	14a56 <__aeabi_dmul+0x222>
   14a50:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
   14a54:	d113      	bne.n	14a7e <__aeabi_dmul+0x24a>
   14a56:	ea95 0f0c 	teq	r5, ip
   14a5a:	d105      	bne.n	14a68 <__aeabi_dmul+0x234>
   14a5c:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
   14a60:	bf1c      	itt	ne
   14a62:	4610      	movne	r0, r2
   14a64:	4619      	movne	r1, r3
   14a66:	d10a      	bne.n	14a7e <__aeabi_dmul+0x24a>
   14a68:	ea81 0103 	eor.w	r1, r1, r3
   14a6c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   14a70:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   14a74:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   14a78:	f04f 0000 	mov.w	r0, #0
   14a7c:	bd70      	pop	{r4, r5, r6, pc}
   14a7e:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   14a82:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
   14a86:	bd70      	pop	{r4, r5, r6, pc}

00014a88 <__aeabi_ddiv>:
   14a88:	b570      	push	{r4, r5, r6, lr}
   14a8a:	f04f 0cff 	mov.w	ip, #255	; 0xff
   14a8e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   14a92:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   14a96:	bf1d      	ittte	ne
   14a98:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   14a9c:	ea94 0f0c 	teqne	r4, ip
   14aa0:	ea95 0f0c 	teqne	r5, ip
   14aa4:	f000 f8a7 	bleq	14bf6 <__aeabi_ddiv+0x16e>
   14aa8:	eba4 0405 	sub.w	r4, r4, r5
   14aac:	ea81 0e03 	eor.w	lr, r1, r3
   14ab0:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   14ab4:	ea4f 3101 	mov.w	r1, r1, lsl #12
   14ab8:	f000 8088 	beq.w	14bcc <__aeabi_ddiv+0x144>
   14abc:	ea4f 3303 	mov.w	r3, r3, lsl #12
   14ac0:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   14ac4:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
   14ac8:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
   14acc:	ea4f 2202 	mov.w	r2, r2, lsl #8
   14ad0:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
   14ad4:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
   14ad8:	ea4f 2600 	mov.w	r6, r0, lsl #8
   14adc:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
   14ae0:	429d      	cmp	r5, r3
   14ae2:	bf08      	it	eq
   14ae4:	4296      	cmpeq	r6, r2
   14ae6:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
   14aea:	f504 7440 	add.w	r4, r4, #768	; 0x300
   14aee:	d202      	bcs.n	14af6 <__aeabi_ddiv+0x6e>
   14af0:	085b      	lsrs	r3, r3, #1
   14af2:	ea4f 0232 	mov.w	r2, r2, rrx
   14af6:	1ab6      	subs	r6, r6, r2
   14af8:	eb65 0503 	sbc.w	r5, r5, r3
   14afc:	085b      	lsrs	r3, r3, #1
   14afe:	ea4f 0232 	mov.w	r2, r2, rrx
   14b02:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
   14b06:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
   14b0a:	ebb6 0e02 	subs.w	lr, r6, r2
   14b0e:	eb75 0e03 	sbcs.w	lr, r5, r3
   14b12:	bf22      	ittt	cs
   14b14:	1ab6      	subcs	r6, r6, r2
   14b16:	4675      	movcs	r5, lr
   14b18:	ea40 000c 	orrcs.w	r0, r0, ip
   14b1c:	085b      	lsrs	r3, r3, #1
   14b1e:	ea4f 0232 	mov.w	r2, r2, rrx
   14b22:	ebb6 0e02 	subs.w	lr, r6, r2
   14b26:	eb75 0e03 	sbcs.w	lr, r5, r3
   14b2a:	bf22      	ittt	cs
   14b2c:	1ab6      	subcs	r6, r6, r2
   14b2e:	4675      	movcs	r5, lr
   14b30:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
   14b34:	085b      	lsrs	r3, r3, #1
   14b36:	ea4f 0232 	mov.w	r2, r2, rrx
   14b3a:	ebb6 0e02 	subs.w	lr, r6, r2
   14b3e:	eb75 0e03 	sbcs.w	lr, r5, r3
   14b42:	bf22      	ittt	cs
   14b44:	1ab6      	subcs	r6, r6, r2
   14b46:	4675      	movcs	r5, lr
   14b48:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
   14b4c:	085b      	lsrs	r3, r3, #1
   14b4e:	ea4f 0232 	mov.w	r2, r2, rrx
   14b52:	ebb6 0e02 	subs.w	lr, r6, r2
   14b56:	eb75 0e03 	sbcs.w	lr, r5, r3
   14b5a:	bf22      	ittt	cs
   14b5c:	1ab6      	subcs	r6, r6, r2
   14b5e:	4675      	movcs	r5, lr
   14b60:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
   14b64:	ea55 0e06 	orrs.w	lr, r5, r6
   14b68:	d018      	beq.n	14b9c <__aeabi_ddiv+0x114>
   14b6a:	ea4f 1505 	mov.w	r5, r5, lsl #4
   14b6e:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
   14b72:	ea4f 1606 	mov.w	r6, r6, lsl #4
   14b76:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   14b7a:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
   14b7e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
   14b82:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
   14b86:	d1c0      	bne.n	14b0a <__aeabi_ddiv+0x82>
   14b88:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   14b8c:	d10b      	bne.n	14ba6 <__aeabi_ddiv+0x11e>
   14b8e:	ea41 0100 	orr.w	r1, r1, r0
   14b92:	f04f 0000 	mov.w	r0, #0
   14b96:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
   14b9a:	e7b6      	b.n	14b0a <__aeabi_ddiv+0x82>
   14b9c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   14ba0:	bf04      	itt	eq
   14ba2:	4301      	orreq	r1, r0
   14ba4:	2000      	moveq	r0, #0
   14ba6:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   14baa:	bf88      	it	hi
   14bac:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   14bb0:	f63f aeaf 	bhi.w	14912 <__aeabi_dmul+0xde>
   14bb4:	ebb5 0c03 	subs.w	ip, r5, r3
   14bb8:	bf04      	itt	eq
   14bba:	ebb6 0c02 	subseq.w	ip, r6, r2
   14bbe:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   14bc2:	f150 0000 	adcs.w	r0, r0, #0
   14bc6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   14bca:	bd70      	pop	{r4, r5, r6, pc}
   14bcc:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
   14bd0:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
   14bd4:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
   14bd8:	bfc2      	ittt	gt
   14bda:	ebd4 050c 	rsbsgt	r5, r4, ip
   14bde:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   14be2:	bd70      	popgt	{r4, r5, r6, pc}
   14be4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   14be8:	f04f 0e00 	mov.w	lr, #0
   14bec:	3c01      	subs	r4, #1
   14bee:	e690      	b.n	14912 <__aeabi_dmul+0xde>
   14bf0:	ea45 0e06 	orr.w	lr, r5, r6
   14bf4:	e68d      	b.n	14912 <__aeabi_dmul+0xde>
   14bf6:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   14bfa:	ea94 0f0c 	teq	r4, ip
   14bfe:	bf08      	it	eq
   14c00:	ea95 0f0c 	teqeq	r5, ip
   14c04:	f43f af3b 	beq.w	14a7e <__aeabi_dmul+0x24a>
   14c08:	ea94 0f0c 	teq	r4, ip
   14c0c:	d10a      	bne.n	14c24 <__aeabi_ddiv+0x19c>
   14c0e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   14c12:	f47f af34 	bne.w	14a7e <__aeabi_dmul+0x24a>
   14c16:	ea95 0f0c 	teq	r5, ip
   14c1a:	f47f af25 	bne.w	14a68 <__aeabi_dmul+0x234>
   14c1e:	4610      	mov	r0, r2
   14c20:	4619      	mov	r1, r3
   14c22:	e72c      	b.n	14a7e <__aeabi_dmul+0x24a>
   14c24:	ea95 0f0c 	teq	r5, ip
   14c28:	d106      	bne.n	14c38 <__aeabi_ddiv+0x1b0>
   14c2a:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   14c2e:	f43f aefd 	beq.w	14a2c <__aeabi_dmul+0x1f8>
   14c32:	4610      	mov	r0, r2
   14c34:	4619      	mov	r1, r3
   14c36:	e722      	b.n	14a7e <__aeabi_dmul+0x24a>
   14c38:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   14c3c:	bf18      	it	ne
   14c3e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   14c42:	f47f aec5 	bne.w	149d0 <__aeabi_dmul+0x19c>
   14c46:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
   14c4a:	f47f af0d 	bne.w	14a68 <__aeabi_dmul+0x234>
   14c4e:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
   14c52:	f47f aeeb 	bne.w	14a2c <__aeabi_dmul+0x1f8>
   14c56:	e712      	b.n	14a7e <__aeabi_dmul+0x24a>

00014c58 <clock>:
   14c58:	f240 03d8 	movw	r3, #216	; 0xd8
   14c5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14c60:	b500      	push	{lr}
   14c62:	b085      	sub	sp, #20
   14c64:	4669      	mov	r1, sp
   14c66:	6818      	ldr	r0, [r3, #0]
   14c68:	f002 f9b6 	bl	16fd8 <_times_r>
   14c6c:	f1b0 3fff 	cmp.w	r0, #4294967295
   14c70:	d006      	beq.n	14c80 <clock+0x28>
   14c72:	9b00      	ldr	r3, [sp, #0]
   14c74:	9801      	ldr	r0, [sp, #4]
   14c76:	18c0      	adds	r0, r0, r3
   14c78:	9b02      	ldr	r3, [sp, #8]
   14c7a:	18c0      	adds	r0, r0, r3
   14c7c:	9b03      	ldr	r3, [sp, #12]
   14c7e:	18c0      	adds	r0, r0, r3
   14c80:	b005      	add	sp, #20
   14c82:	bd00      	pop	{pc}

00014c84 <gcvt>:
   14c84:	b5f0      	push	{r4, r5, r6, r7, lr}
   14c86:	4615      	mov	r5, r2
   14c88:	461c      	mov	r4, r3
   14c8a:	b085      	sub	sp, #20
   14c8c:	2200      	movs	r2, #0
   14c8e:	2300      	movs	r3, #0
   14c90:	4606      	mov	r6, r0
   14c92:	460f      	mov	r7, r1
   14c94:	f005 fbda 	bl	1a44c <__aeabi_dcmplt>
   14c98:	b9a8      	cbnz	r0, 14cc6 <gcvt+0x42>
   14c9a:	4620      	mov	r0, r4
   14c9c:	f240 01d8 	movw	r1, #216	; 0xd8
   14ca0:	9500      	str	r5, [sp, #0]
   14ca2:	f2c2 0100 	movt	r1, #8192	; 0x2000
   14ca6:	9001      	str	r0, [sp, #4]
   14ca8:	4632      	mov	r2, r6
   14caa:	463b      	mov	r3, r7
   14cac:	6808      	ldr	r0, [r1, #0]
   14cae:	2167      	movs	r1, #103	; 0x67
   14cb0:	9102      	str	r1, [sp, #8]
   14cb2:	2100      	movs	r1, #0
   14cb4:	9103      	str	r1, [sp, #12]
   14cb6:	f003 fa07 	bl	180c8 <_gcvt>
   14cba:	2800      	cmp	r0, #0
   14cbc:	bf14      	ite	ne
   14cbe:	4620      	movne	r0, r4
   14cc0:	2000      	moveq	r0, #0
   14cc2:	b005      	add	sp, #20
   14cc4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   14cc6:	4620      	mov	r0, r4
   14cc8:	232d      	movs	r3, #45	; 0x2d
   14cca:	3d01      	subs	r5, #1
   14ccc:	f800 3b01 	strb.w	r3, [r0], #1
   14cd0:	e7e4      	b.n	14c9c <gcvt+0x18>
   14cd2:	bf00      	nop

00014cd4 <gcvtf>:
   14cd4:	b570      	push	{r4, r5, r6, lr}
   14cd6:	4614      	mov	r4, r2
   14cd8:	460d      	mov	r5, r1
   14cda:	f7ff fd57 	bl	1478c <__aeabi_f2d>
   14cde:	462a      	mov	r2, r5
   14ce0:	4623      	mov	r3, r4
   14ce2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   14ce6:	e7cd      	b.n	14c84 <gcvt>

00014ce8 <ecvt>:
   14ce8:	b510      	push	{r4, lr}
   14cea:	b082      	sub	sp, #8
   14cec:	2400      	movs	r4, #0
   14cee:	9401      	str	r4, [sp, #4]
   14cf0:	9c04      	ldr	r4, [sp, #16]
   14cf2:	9400      	str	r4, [sp, #0]
   14cf4:	f003 faec 	bl	182d0 <ecvtbuf>
   14cf8:	b002      	add	sp, #8
   14cfa:	bd10      	pop	{r4, pc}

00014cfc <ecvtf>:
   14cfc:	b570      	push	{r4, r5, r6, lr}
   14cfe:	4615      	mov	r5, r2
   14d00:	b082      	sub	sp, #8
   14d02:	460e      	mov	r6, r1
   14d04:	461c      	mov	r4, r3
   14d06:	f7ff fd41 	bl	1478c <__aeabi_f2d>
   14d0a:	4632      	mov	r2, r6
   14d0c:	462b      	mov	r3, r5
   14d0e:	9400      	str	r4, [sp, #0]
   14d10:	f7ff ffea 	bl	14ce8 <ecvt>
   14d14:	b002      	add	sp, #8
   14d16:	bd70      	pop	{r4, r5, r6, pc}

00014d18 <fcvt>:
   14d18:	b510      	push	{r4, lr}
   14d1a:	b082      	sub	sp, #8
   14d1c:	2400      	movs	r4, #0
   14d1e:	9401      	str	r4, [sp, #4]
   14d20:	9c04      	ldr	r4, [sp, #16]
   14d22:	9400      	str	r4, [sp, #0]
   14d24:	f003 fb2e 	bl	18384 <fcvtbuf>
   14d28:	b002      	add	sp, #8
   14d2a:	bd10      	pop	{r4, pc}

00014d2c <fcvtf>:
   14d2c:	b570      	push	{r4, r5, r6, lr}
   14d2e:	4615      	mov	r5, r2
   14d30:	b082      	sub	sp, #8
   14d32:	460e      	mov	r6, r1
   14d34:	461c      	mov	r4, r3
   14d36:	f7ff fd29 	bl	1478c <__aeabi_f2d>
   14d3a:	4632      	mov	r2, r6
   14d3c:	462b      	mov	r3, r5
   14d3e:	9400      	str	r4, [sp, #0]
   14d40:	f7ff ffea 	bl	14d18 <fcvt>
   14d44:	b002      	add	sp, #8
   14d46:	bd70      	pop	{r4, r5, r6, pc}

00014d48 <__errno>:
   14d48:	f240 03d8 	movw	r3, #216	; 0xd8
   14d4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14d50:	6818      	ldr	r0, [r3, #0]
   14d52:	4770      	bx	lr

00014d54 <__libc_init_array>:
   14d54:	b570      	push	{r4, r5, r6, lr}
   14d56:	f244 2698 	movw	r6, #17048	; 0x4298
   14d5a:	f244 2598 	movw	r5, #17048	; 0x4298
   14d5e:	f2c0 0602 	movt	r6, #2
   14d62:	f2c0 0502 	movt	r5, #2
   14d66:	1b76      	subs	r6, r6, r5
   14d68:	10b6      	asrs	r6, r6, #2
   14d6a:	d006      	beq.n	14d7a <__libc_init_array+0x26>
   14d6c:	2400      	movs	r4, #0
   14d6e:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   14d72:	3401      	adds	r4, #1
   14d74:	4798      	blx	r3
   14d76:	42a6      	cmp	r6, r4
   14d78:	d8f9      	bhi.n	14d6e <__libc_init_array+0x1a>
   14d7a:	f244 2598 	movw	r5, #17048	; 0x4298
   14d7e:	f244 269c 	movw	r6, #17052	; 0x429c
   14d82:	f2c0 0502 	movt	r5, #2
   14d86:	f2c0 0602 	movt	r6, #2
   14d8a:	1b76      	subs	r6, r6, r5
   14d8c:	f00f fa78 	bl	24280 <_init>
   14d90:	10b6      	asrs	r6, r6, #2
   14d92:	d006      	beq.n	14da2 <__libc_init_array+0x4e>
   14d94:	2400      	movs	r4, #0
   14d96:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   14d9a:	3401      	adds	r4, #1
   14d9c:	4798      	blx	r3
   14d9e:	42a6      	cmp	r6, r4
   14da0:	d8f9      	bhi.n	14d96 <__libc_init_array+0x42>
   14da2:	bd70      	pop	{r4, r5, r6, pc}

00014da4 <memcpy>:
   14da4:	2a03      	cmp	r2, #3
   14da6:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
   14daa:	d80b      	bhi.n	14dc4 <memcpy+0x20>
   14dac:	b13a      	cbz	r2, 14dbe <memcpy+0x1a>
   14dae:	2300      	movs	r3, #0
   14db0:	f811 c003 	ldrb.w	ip, [r1, r3]
   14db4:	f800 c003 	strb.w	ip, [r0, r3]
   14db8:	3301      	adds	r3, #1
   14dba:	4293      	cmp	r3, r2
   14dbc:	d1f8      	bne.n	14db0 <memcpy+0xc>
   14dbe:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
   14dc2:	4770      	bx	lr
   14dc4:	1882      	adds	r2, r0, r2
   14dc6:	460c      	mov	r4, r1
   14dc8:	4603      	mov	r3, r0
   14dca:	e003      	b.n	14dd4 <memcpy+0x30>
   14dcc:	f814 1c01 	ldrb.w	r1, [r4, #-1]
   14dd0:	f803 1c01 	strb.w	r1, [r3, #-1]
   14dd4:	f003 0603 	and.w	r6, r3, #3
   14dd8:	4619      	mov	r1, r3
   14dda:	46a4      	mov	ip, r4
   14ddc:	3301      	adds	r3, #1
   14dde:	3401      	adds	r4, #1
   14de0:	2e00      	cmp	r6, #0
   14de2:	d1f3      	bne.n	14dcc <memcpy+0x28>
   14de4:	f01c 0403 	ands.w	r4, ip, #3
   14de8:	4663      	mov	r3, ip
   14dea:	bf08      	it	eq
   14dec:	ebc1 0c02 	rsbeq	ip, r1, r2
   14df0:	d068      	beq.n	14ec4 <memcpy+0x120>
   14df2:	4265      	negs	r5, r4
   14df4:	f1c4 0a04 	rsb	sl, r4, #4
   14df8:	eb0c 0705 	add.w	r7, ip, r5
   14dfc:	4633      	mov	r3, r6
   14dfe:	ea4f 0aca 	mov.w	sl, sl, lsl #3
   14e02:	f85c 6005 	ldr.w	r6, [ip, r5]
   14e06:	ea4f 08c4 	mov.w	r8, r4, lsl #3
   14e0a:	1a55      	subs	r5, r2, r1
   14e0c:	e008      	b.n	14e20 <memcpy+0x7c>
   14e0e:	f857 4f04 	ldr.w	r4, [r7, #4]!
   14e12:	4626      	mov	r6, r4
   14e14:	fa04 f40a 	lsl.w	r4, r4, sl
   14e18:	ea49 0404 	orr.w	r4, r9, r4
   14e1c:	50cc      	str	r4, [r1, r3]
   14e1e:	3304      	adds	r3, #4
   14e20:	185c      	adds	r4, r3, r1
   14e22:	2d03      	cmp	r5, #3
   14e24:	fa26 f908 	lsr.w	r9, r6, r8
   14e28:	f1a5 0504 	sub.w	r5, r5, #4
   14e2c:	eb0c 0603 	add.w	r6, ip, r3
   14e30:	dced      	bgt.n	14e0e <memcpy+0x6a>
   14e32:	2300      	movs	r3, #0
   14e34:	e002      	b.n	14e3c <memcpy+0x98>
   14e36:	5cf1      	ldrb	r1, [r6, r3]
   14e38:	54e1      	strb	r1, [r4, r3]
   14e3a:	3301      	adds	r3, #1
   14e3c:	1919      	adds	r1, r3, r4
   14e3e:	4291      	cmp	r1, r2
   14e40:	d3f9      	bcc.n	14e36 <memcpy+0x92>
   14e42:	e7bc      	b.n	14dbe <memcpy+0x1a>
   14e44:	f853 4c40 	ldr.w	r4, [r3, #-64]
   14e48:	f841 4c40 	str.w	r4, [r1, #-64]
   14e4c:	f853 4c3c 	ldr.w	r4, [r3, #-60]
   14e50:	f841 4c3c 	str.w	r4, [r1, #-60]
   14e54:	f853 4c38 	ldr.w	r4, [r3, #-56]
   14e58:	f841 4c38 	str.w	r4, [r1, #-56]
   14e5c:	f853 4c34 	ldr.w	r4, [r3, #-52]
   14e60:	f841 4c34 	str.w	r4, [r1, #-52]
   14e64:	f853 4c30 	ldr.w	r4, [r3, #-48]
   14e68:	f841 4c30 	str.w	r4, [r1, #-48]
   14e6c:	f853 4c2c 	ldr.w	r4, [r3, #-44]
   14e70:	f841 4c2c 	str.w	r4, [r1, #-44]
   14e74:	f853 4c28 	ldr.w	r4, [r3, #-40]
   14e78:	f841 4c28 	str.w	r4, [r1, #-40]
   14e7c:	f853 4c24 	ldr.w	r4, [r3, #-36]
   14e80:	f841 4c24 	str.w	r4, [r1, #-36]
   14e84:	f853 4c20 	ldr.w	r4, [r3, #-32]
   14e88:	f841 4c20 	str.w	r4, [r1, #-32]
   14e8c:	f853 4c1c 	ldr.w	r4, [r3, #-28]
   14e90:	f841 4c1c 	str.w	r4, [r1, #-28]
   14e94:	f853 4c18 	ldr.w	r4, [r3, #-24]
   14e98:	f841 4c18 	str.w	r4, [r1, #-24]
   14e9c:	f853 4c14 	ldr.w	r4, [r3, #-20]
   14ea0:	f841 4c14 	str.w	r4, [r1, #-20]
   14ea4:	f853 4c10 	ldr.w	r4, [r3, #-16]
   14ea8:	f841 4c10 	str.w	r4, [r1, #-16]
   14eac:	f853 4c0c 	ldr.w	r4, [r3, #-12]
   14eb0:	f841 4c0c 	str.w	r4, [r1, #-12]
   14eb4:	f853 4c08 	ldr.w	r4, [r3, #-8]
   14eb8:	f841 4c08 	str.w	r4, [r1, #-8]
   14ebc:	f853 4c04 	ldr.w	r4, [r3, #-4]
   14ec0:	f841 4c04 	str.w	r4, [r1, #-4]
   14ec4:	461c      	mov	r4, r3
   14ec6:	460d      	mov	r5, r1
   14ec8:	3340      	adds	r3, #64	; 0x40
   14eca:	3140      	adds	r1, #64	; 0x40
   14ecc:	f1bc 0f3f 	cmp.w	ip, #63	; 0x3f
   14ed0:	f1ac 0c40 	sub.w	ip, ip, #64	; 0x40
   14ed4:	dcb6      	bgt.n	14e44 <memcpy+0xa0>
   14ed6:	4621      	mov	r1, r4
   14ed8:	462b      	mov	r3, r5
   14eda:	1b54      	subs	r4, r2, r5
   14edc:	e00f      	b.n	14efe <memcpy+0x15a>
   14ede:	f851 5c10 	ldr.w	r5, [r1, #-16]
   14ee2:	f843 5c10 	str.w	r5, [r3, #-16]
   14ee6:	f851 5c0c 	ldr.w	r5, [r1, #-12]
   14eea:	f843 5c0c 	str.w	r5, [r3, #-12]
   14eee:	f851 5c08 	ldr.w	r5, [r1, #-8]
   14ef2:	f843 5c08 	str.w	r5, [r3, #-8]
   14ef6:	f851 5c04 	ldr.w	r5, [r1, #-4]
   14efa:	f843 5c04 	str.w	r5, [r3, #-4]
   14efe:	2c0f      	cmp	r4, #15
   14f00:	460d      	mov	r5, r1
   14f02:	469c      	mov	ip, r3
   14f04:	f101 0110 	add.w	r1, r1, #16
   14f08:	f103 0310 	add.w	r3, r3, #16
   14f0c:	f1a4 0410 	sub.w	r4, r4, #16
   14f10:	dce5      	bgt.n	14ede <memcpy+0x13a>
   14f12:	ebcc 0102 	rsb	r1, ip, r2
   14f16:	2300      	movs	r3, #0
   14f18:	e003      	b.n	14f22 <memcpy+0x17e>
   14f1a:	58ec      	ldr	r4, [r5, r3]
   14f1c:	f84c 4003 	str.w	r4, [ip, r3]
   14f20:	3304      	adds	r3, #4
   14f22:	195e      	adds	r6, r3, r5
   14f24:	2903      	cmp	r1, #3
   14f26:	eb03 040c 	add.w	r4, r3, ip
   14f2a:	f1a1 0104 	sub.w	r1, r1, #4
   14f2e:	dcf4      	bgt.n	14f1a <memcpy+0x176>
   14f30:	e77f      	b.n	14e32 <memcpy+0x8e>
   14f32:	bf00      	nop

00014f34 <memset>:
   14f34:	2a03      	cmp	r2, #3
   14f36:	b2c9      	uxtb	r1, r1
   14f38:	b430      	push	{r4, r5}
   14f3a:	d807      	bhi.n	14f4c <memset+0x18>
   14f3c:	b122      	cbz	r2, 14f48 <memset+0x14>
   14f3e:	2300      	movs	r3, #0
   14f40:	54c1      	strb	r1, [r0, r3]
   14f42:	3301      	adds	r3, #1
   14f44:	4293      	cmp	r3, r2
   14f46:	d1fb      	bne.n	14f40 <memset+0xc>
   14f48:	bc30      	pop	{r4, r5}
   14f4a:	4770      	bx	lr
   14f4c:	eb00 0c02 	add.w	ip, r0, r2
   14f50:	4603      	mov	r3, r0
   14f52:	e001      	b.n	14f58 <memset+0x24>
   14f54:	f803 1c01 	strb.w	r1, [r3, #-1]
   14f58:	f003 0403 	and.w	r4, r3, #3
   14f5c:	461a      	mov	r2, r3
   14f5e:	3301      	adds	r3, #1
   14f60:	2c00      	cmp	r4, #0
   14f62:	d1f7      	bne.n	14f54 <memset+0x20>
   14f64:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
   14f68:	ebc2 040c 	rsb	r4, r2, ip
   14f6c:	fb03 f301 	mul.w	r3, r3, r1
   14f70:	e01f      	b.n	14fb2 <memset+0x7e>
   14f72:	f842 3c40 	str.w	r3, [r2, #-64]
   14f76:	f842 3c3c 	str.w	r3, [r2, #-60]
   14f7a:	f842 3c38 	str.w	r3, [r2, #-56]
   14f7e:	f842 3c34 	str.w	r3, [r2, #-52]
   14f82:	f842 3c30 	str.w	r3, [r2, #-48]
   14f86:	f842 3c2c 	str.w	r3, [r2, #-44]
   14f8a:	f842 3c28 	str.w	r3, [r2, #-40]
   14f8e:	f842 3c24 	str.w	r3, [r2, #-36]
   14f92:	f842 3c20 	str.w	r3, [r2, #-32]
   14f96:	f842 3c1c 	str.w	r3, [r2, #-28]
   14f9a:	f842 3c18 	str.w	r3, [r2, #-24]
   14f9e:	f842 3c14 	str.w	r3, [r2, #-20]
   14fa2:	f842 3c10 	str.w	r3, [r2, #-16]
   14fa6:	f842 3c0c 	str.w	r3, [r2, #-12]
   14faa:	f842 3c08 	str.w	r3, [r2, #-8]
   14fae:	f842 3c04 	str.w	r3, [r2, #-4]
   14fb2:	4615      	mov	r5, r2
   14fb4:	3240      	adds	r2, #64	; 0x40
   14fb6:	2c3f      	cmp	r4, #63	; 0x3f
   14fb8:	f1a4 0440 	sub.w	r4, r4, #64	; 0x40
   14fbc:	dcd9      	bgt.n	14f72 <memset+0x3e>
   14fbe:	462a      	mov	r2, r5
   14fc0:	ebc5 040c 	rsb	r4, r5, ip
   14fc4:	e007      	b.n	14fd6 <memset+0xa2>
   14fc6:	f842 3c10 	str.w	r3, [r2, #-16]
   14fca:	f842 3c0c 	str.w	r3, [r2, #-12]
   14fce:	f842 3c08 	str.w	r3, [r2, #-8]
   14fd2:	f842 3c04 	str.w	r3, [r2, #-4]
   14fd6:	4615      	mov	r5, r2
   14fd8:	3210      	adds	r2, #16
   14fda:	2c0f      	cmp	r4, #15
   14fdc:	f1a4 0410 	sub.w	r4, r4, #16
   14fe0:	dcf1      	bgt.n	14fc6 <memset+0x92>
   14fe2:	462a      	mov	r2, r5
   14fe4:	ebc5 050c 	rsb	r5, r5, ip
   14fe8:	e001      	b.n	14fee <memset+0xba>
   14fea:	f842 3c04 	str.w	r3, [r2, #-4]
   14fee:	4614      	mov	r4, r2
   14ff0:	3204      	adds	r2, #4
   14ff2:	2d03      	cmp	r5, #3
   14ff4:	f1a5 0504 	sub.w	r5, r5, #4
   14ff8:	dcf7      	bgt.n	14fea <memset+0xb6>
   14ffa:	e001      	b.n	15000 <memset+0xcc>
   14ffc:	f804 1b01 	strb.w	r1, [r4], #1
   15000:	4564      	cmp	r4, ip
   15002:	d3fb      	bcc.n	14ffc <memset+0xc8>
   15004:	e7a0      	b.n	14f48 <memset+0x14>
   15006:	bf00      	nop

00015008 <snprintf>:
   15008:	b40c      	push	{r2, r3}
   1500a:	f240 03d8 	movw	r3, #216	; 0xd8
   1500e:	b5f0      	push	{r4, r5, r6, r7, lr}
   15010:	f2c2 0300 	movt	r3, #8192	; 0x2000
   15014:	1e0c      	subs	r4, r1, #0
   15016:	b09d      	sub	sp, #116	; 0x74
   15018:	4605      	mov	r5, r0
   1501a:	681e      	ldr	r6, [r3, #0]
   1501c:	db28      	blt.n	15070 <snprintf+0x68>
   1501e:	af23      	add	r7, sp, #140	; 0x8c
   15020:	9a22      	ldr	r2, [sp, #136]	; 0x88
   15022:	463b      	mov	r3, r7
   15024:	4630      	mov	r0, r6
   15026:	a901      	add	r1, sp, #4
   15028:	bf0c      	ite	eq
   1502a:	46a4      	moveq	ip, r4
   1502c:	f104 3cff 	addne.w	ip, r4, #4294967295
   15030:	f44f 7e02 	mov.w	lr, #520	; 0x208
   15034:	9505      	str	r5, [sp, #20]
   15036:	f8ad e010 	strh.w	lr, [sp, #16]
   1503a:	f04f 3eff 	mov.w	lr, #4294967295
   1503e:	f8cd c018 	str.w	ip, [sp, #24]
   15042:	9501      	str	r5, [sp, #4]
   15044:	f8ad e012 	strh.w	lr, [sp, #18]
   15048:	f8cd c00c 	str.w	ip, [sp, #12]
   1504c:	971b      	str	r7, [sp, #108]	; 0x6c
   1504e:	f000 fd7d 	bl	15b4c <_svfprintf_r>
   15052:	f1b0 3fff 	cmp.w	r0, #4294967295
   15056:	db08      	blt.n	1506a <snprintf+0x62>
   15058:	b114      	cbz	r4, 15060 <snprintf+0x58>
   1505a:	9b01      	ldr	r3, [sp, #4]
   1505c:	2200      	movs	r2, #0
   1505e:	701a      	strb	r2, [r3, #0]
   15060:	b01d      	add	sp, #116	; 0x74
   15062:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   15066:	b002      	add	sp, #8
   15068:	4770      	bx	lr
   1506a:	238b      	movs	r3, #139	; 0x8b
   1506c:	6033      	str	r3, [r6, #0]
   1506e:	e7f3      	b.n	15058 <snprintf+0x50>
   15070:	238b      	movs	r3, #139	; 0x8b
   15072:	f04f 30ff 	mov.w	r0, #4294967295
   15076:	6033      	str	r3, [r6, #0]
   15078:	e7f2      	b.n	15060 <snprintf+0x58>
   1507a:	bf00      	nop

0001507c <_snprintf_r>:
   1507c:	b408      	push	{r3}
   1507e:	b5f0      	push	{r4, r5, r6, r7, lr}
   15080:	1e14      	subs	r4, r2, #0
   15082:	b09c      	sub	sp, #112	; 0x70
   15084:	4606      	mov	r6, r0
   15086:	460d      	mov	r5, r1
   15088:	db27      	blt.n	150da <_snprintf_r+0x5e>
   1508a:	af22      	add	r7, sp, #136	; 0x88
   1508c:	9a21      	ldr	r2, [sp, #132]	; 0x84
   1508e:	463b      	mov	r3, r7
   15090:	a901      	add	r1, sp, #4
   15092:	bf0c      	ite	eq
   15094:	46a4      	moveq	ip, r4
   15096:	f104 3cff 	addne.w	ip, r4, #4294967295
   1509a:	f44f 7e02 	mov.w	lr, #520	; 0x208
   1509e:	9505      	str	r5, [sp, #20]
   150a0:	f8ad e010 	strh.w	lr, [sp, #16]
   150a4:	f04f 3eff 	mov.w	lr, #4294967295
   150a8:	f8cd c018 	str.w	ip, [sp, #24]
   150ac:	9501      	str	r5, [sp, #4]
   150ae:	f8ad e012 	strh.w	lr, [sp, #18]
   150b2:	f8cd c00c 	str.w	ip, [sp, #12]
   150b6:	971b      	str	r7, [sp, #108]	; 0x6c
   150b8:	f000 fd48 	bl	15b4c <_svfprintf_r>
   150bc:	f1b0 3fff 	cmp.w	r0, #4294967295
   150c0:	db08      	blt.n	150d4 <_snprintf_r+0x58>
   150c2:	b114      	cbz	r4, 150ca <_snprintf_r+0x4e>
   150c4:	9b01      	ldr	r3, [sp, #4]
   150c6:	2200      	movs	r2, #0
   150c8:	701a      	strb	r2, [r3, #0]
   150ca:	b01c      	add	sp, #112	; 0x70
   150cc:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   150d0:	b001      	add	sp, #4
   150d2:	4770      	bx	lr
   150d4:	238b      	movs	r3, #139	; 0x8b
   150d6:	6033      	str	r3, [r6, #0]
   150d8:	e7f3      	b.n	150c2 <_snprintf_r+0x46>
   150da:	238b      	movs	r3, #139	; 0x8b
   150dc:	6003      	str	r3, [r0, #0]
   150de:	f04f 30ff 	mov.w	r0, #4294967295
   150e2:	e7f2      	b.n	150ca <_snprintf_r+0x4e>

000150e4 <sprintf>:
   150e4:	b40e      	push	{r1, r2, r3}
   150e6:	f240 03d8 	movw	r3, #216	; 0xd8
   150ea:	b530      	push	{r4, r5, lr}
   150ec:	b09c      	sub	sp, #112	; 0x70
   150ee:	ac1f      	add	r4, sp, #124	; 0x7c
   150f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   150f4:	4605      	mov	r5, r0
   150f6:	a901      	add	r1, sp, #4
   150f8:	f854 2b04 	ldr.w	r2, [r4], #4
   150fc:	f04f 3cff 	mov.w	ip, #4294967295
   15100:	6818      	ldr	r0, [r3, #0]
   15102:	f44f 7302 	mov.w	r3, #520	; 0x208
   15106:	f8ad 3010 	strh.w	r3, [sp, #16]
   1510a:	4623      	mov	r3, r4
   1510c:	9505      	str	r5, [sp, #20]
   1510e:	9501      	str	r5, [sp, #4]
   15110:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
   15114:	f8ad c012 	strh.w	ip, [sp, #18]
   15118:	9506      	str	r5, [sp, #24]
   1511a:	9503      	str	r5, [sp, #12]
   1511c:	941b      	str	r4, [sp, #108]	; 0x6c
   1511e:	f000 fd15 	bl	15b4c <_svfprintf_r>
   15122:	9b01      	ldr	r3, [sp, #4]
   15124:	2200      	movs	r2, #0
   15126:	701a      	strb	r2, [r3, #0]
   15128:	b01c      	add	sp, #112	; 0x70
   1512a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   1512e:	b003      	add	sp, #12
   15130:	4770      	bx	lr
   15132:	bf00      	nop

00015134 <_sprintf_r>:
   15134:	b40c      	push	{r2, r3}
   15136:	460b      	mov	r3, r1
   15138:	b510      	push	{r4, lr}
   1513a:	b09c      	sub	sp, #112	; 0x70
   1513c:	ac1e      	add	r4, sp, #120	; 0x78
   1513e:	a901      	add	r1, sp, #4
   15140:	9305      	str	r3, [sp, #20]
   15142:	f44f 7c02 	mov.w	ip, #520	; 0x208
   15146:	f854 2b04 	ldr.w	r2, [r4], #4
   1514a:	9301      	str	r3, [sp, #4]
   1514c:	f04f 33ff 	mov.w	r3, #4294967295
   15150:	f8ad 3012 	strh.w	r3, [sp, #18]
   15154:	4623      	mov	r3, r4
   15156:	941b      	str	r4, [sp, #108]	; 0x6c
   15158:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
   1515c:	f8ad c010 	strh.w	ip, [sp, #16]
   15160:	9406      	str	r4, [sp, #24]
   15162:	9403      	str	r4, [sp, #12]
   15164:	f000 fcf2 	bl	15b4c <_svfprintf_r>
   15168:	9b01      	ldr	r3, [sp, #4]
   1516a:	2200      	movs	r2, #0
   1516c:	701a      	strb	r2, [r3, #0]
   1516e:	b01c      	add	sp, #112	; 0x70
   15170:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   15174:	b002      	add	sp, #8
   15176:	4770      	bx	lr

00015178 <strcat>:
   15178:	f010 0f03 	tst.w	r0, #3
   1517c:	b510      	push	{r4, lr}
   1517e:	4604      	mov	r4, r0
   15180:	bf18      	it	ne
   15182:	4600      	movne	r0, r0
   15184:	d111      	bne.n	151aa <strcat+0x32>
   15186:	6823      	ldr	r3, [r4, #0]
   15188:	4620      	mov	r0, r4
   1518a:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   1518e:	ea22 0303 	bic.w	r3, r2, r3
   15192:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   15196:	d108      	bne.n	151aa <strcat+0x32>
   15198:	f850 3f04 	ldr.w	r3, [r0, #4]!
   1519c:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   151a0:	ea22 0303 	bic.w	r3, r2, r3
   151a4:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   151a8:	d0f6      	beq.n	15198 <strcat+0x20>
   151aa:	7803      	ldrb	r3, [r0, #0]
   151ac:	b11b      	cbz	r3, 151b6 <strcat+0x3e>
   151ae:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   151b2:	2b00      	cmp	r3, #0
   151b4:	d1fb      	bne.n	151ae <strcat+0x36>
   151b6:	f000 f863 	bl	15280 <strcpy>
   151ba:	4620      	mov	r0, r4
   151bc:	bd10      	pop	{r4, pc}
   151be:	bf00      	nop

000151c0 <strchr>:
   151c0:	b2c9      	uxtb	r1, r1
   151c2:	b430      	push	{r4, r5}
   151c4:	b119      	cbz	r1, 151ce <strchr+0xe>
   151c6:	e024      	b.n	15212 <strchr+0x52>
   151c8:	7803      	ldrb	r3, [r0, #0]
   151ca:	b1d3      	cbz	r3, 15202 <strchr+0x42>
   151cc:	3001      	adds	r0, #1
   151ce:	f010 0f03 	tst.w	r0, #3
   151d2:	d1f9      	bne.n	151c8 <strchr+0x8>
   151d4:	6803      	ldr	r3, [r0, #0]
   151d6:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   151da:	ea22 0303 	bic.w	r3, r2, r3
   151de:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   151e2:	d108      	bne.n	151f6 <strchr+0x36>
   151e4:	f850 3f04 	ldr.w	r3, [r0, #4]!
   151e8:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   151ec:	ea22 0303 	bic.w	r3, r2, r3
   151f0:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   151f4:	d0f6      	beq.n	151e4 <strchr+0x24>
   151f6:	7803      	ldrb	r3, [r0, #0]
   151f8:	b11b      	cbz	r3, 15202 <strchr+0x42>
   151fa:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   151fe:	2b00      	cmp	r3, #0
   15200:	d1fb      	bne.n	151fa <strchr+0x3a>
   15202:	bc30      	pop	{r4, r5}
   15204:	4770      	bx	lr
   15206:	7803      	ldrb	r3, [r0, #0]
   15208:	2b00      	cmp	r3, #0
   1520a:	d036      	beq.n	1527a <strchr+0xba>
   1520c:	4299      	cmp	r1, r3
   1520e:	d0f8      	beq.n	15202 <strchr+0x42>
   15210:	3001      	adds	r0, #1
   15212:	f010 0f03 	tst.w	r0, #3
   15216:	d1f6      	bne.n	15206 <strchr+0x46>
   15218:	6803      	ldr	r3, [r0, #0]
   1521a:	ea41 2501 	orr.w	r5, r1, r1, lsl #8
   1521e:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   15222:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
   15226:	ea22 0203 	bic.w	r2, r2, r3
   1522a:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   1522e:	d11b      	bne.n	15268 <strchr+0xa8>
   15230:	ea85 0303 	eor.w	r3, r5, r3
   15234:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   15238:	ea22 0303 	bic.w	r3, r2, r3
   1523c:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   15240:	d003      	beq.n	1524a <strchr+0x8a>
   15242:	e011      	b.n	15268 <strchr+0xa8>
   15244:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   15248:	d10e      	bne.n	15268 <strchr+0xa8>
   1524a:	f850 3f04 	ldr.w	r3, [r0, #4]!
   1524e:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
   15252:	ea85 0203 	eor.w	r2, r5, r3
   15256:	ea24 0303 	bic.w	r3, r4, r3
   1525a:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
   1525e:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   15262:	ea2c 0202 	bic.w	r2, ip, r2
   15266:	d0ed      	beq.n	15244 <strchr+0x84>
   15268:	7803      	ldrb	r3, [r0, #0]
   1526a:	b91b      	cbnz	r3, 15274 <strchr+0xb4>
   1526c:	e005      	b.n	1527a <strchr+0xba>
   1526e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   15272:	b113      	cbz	r3, 1527a <strchr+0xba>
   15274:	4299      	cmp	r1, r3
   15276:	d1fa      	bne.n	1526e <strchr+0xae>
   15278:	e7c3      	b.n	15202 <strchr+0x42>
   1527a:	2000      	movs	r0, #0
   1527c:	e7c1      	b.n	15202 <strchr+0x42>
   1527e:	bf00      	nop

00015280 <strcpy>:
   15280:	ea80 0201 	eor.w	r2, r0, r1
   15284:	4684      	mov	ip, r0
   15286:	f012 0f03 	tst.w	r2, #3
   1528a:	d14f      	bne.n	1532c <strcpy+0xac>
   1528c:	f011 0f03 	tst.w	r1, #3
   15290:	d132      	bne.n	152f8 <strcpy+0x78>
   15292:	f84d 4d04 	str.w	r4, [sp, #-4]!
   15296:	f011 0f04 	tst.w	r1, #4
   1529a:	f851 3b04 	ldr.w	r3, [r1], #4
   1529e:	d00b      	beq.n	152b8 <strcpy+0x38>
   152a0:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   152a4:	439a      	bics	r2, r3
   152a6:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   152aa:	bf04      	itt	eq
   152ac:	f84c 3b04 	streq.w	r3, [ip], #4
   152b0:	f851 3b04 	ldreq.w	r3, [r1], #4
   152b4:	d116      	bne.n	152e4 <strcpy+0x64>
   152b6:	bf00      	nop
   152b8:	f851 4b04 	ldr.w	r4, [r1], #4
   152bc:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   152c0:	439a      	bics	r2, r3
   152c2:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   152c6:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
   152ca:	d10b      	bne.n	152e4 <strcpy+0x64>
   152cc:	f84c 3b04 	str.w	r3, [ip], #4
   152d0:	43a2      	bics	r2, r4
   152d2:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   152d6:	bf04      	itt	eq
   152d8:	f851 3b04 	ldreq.w	r3, [r1], #4
   152dc:	f84c 4b04 	streq.w	r4, [ip], #4
   152e0:	d0ea      	beq.n	152b8 <strcpy+0x38>
   152e2:	4623      	mov	r3, r4
   152e4:	f80c 3b01 	strb.w	r3, [ip], #1
   152e8:	f013 0fff 	tst.w	r3, #255	; 0xff
   152ec:	ea4f 2333 	mov.w	r3, r3, ror #8
   152f0:	d1f8      	bne.n	152e4 <strcpy+0x64>
   152f2:	f85d 4b04 	ldr.w	r4, [sp], #4
   152f6:	4770      	bx	lr
   152f8:	f011 0f01 	tst.w	r1, #1
   152fc:	d006      	beq.n	1530c <strcpy+0x8c>
   152fe:	f811 2b01 	ldrb.w	r2, [r1], #1
   15302:	f80c 2b01 	strb.w	r2, [ip], #1
   15306:	2a00      	cmp	r2, #0
   15308:	bf08      	it	eq
   1530a:	4770      	bxeq	lr
   1530c:	f011 0f02 	tst.w	r1, #2
   15310:	d0bf      	beq.n	15292 <strcpy+0x12>
   15312:	f831 2b02 	ldrh.w	r2, [r1], #2
   15316:	f012 0fff 	tst.w	r2, #255	; 0xff
   1531a:	bf16      	itet	ne
   1531c:	f82c 2b02 	strhne.w	r2, [ip], #2
   15320:	f88c 2000 	strbeq.w	r2, [ip]
   15324:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
   15328:	d1b3      	bne.n	15292 <strcpy+0x12>
   1532a:	4770      	bx	lr
   1532c:	f811 2b01 	ldrb.w	r2, [r1], #1
   15330:	f80c 2b01 	strb.w	r2, [ip], #1
   15334:	2a00      	cmp	r2, #0
   15336:	d1f9      	bne.n	1532c <strcpy+0xac>
   15338:	4770      	bx	lr
   1533a:	bf00      	nop

0001533c <strlen>:
   1533c:	f020 0103 	bic.w	r1, r0, #3
   15340:	f010 0003 	ands.w	r0, r0, #3
   15344:	f1c0 0000 	rsb	r0, r0, #0
   15348:	f851 3b04 	ldr.w	r3, [r1], #4
   1534c:	f100 0c04 	add.w	ip, r0, #4
   15350:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
   15354:	f06f 0200 	mvn.w	r2, #0
   15358:	bf1c      	itt	ne
   1535a:	fa22 f20c 	lsrne.w	r2, r2, ip
   1535e:	4313      	orrne	r3, r2
   15360:	f04f 0c01 	mov.w	ip, #1
   15364:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
   15368:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
   1536c:	eba3 020c 	sub.w	r2, r3, ip
   15370:	ea22 0203 	bic.w	r2, r2, r3
   15374:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
   15378:	bf04      	itt	eq
   1537a:	f851 3b04 	ldreq.w	r3, [r1], #4
   1537e:	3004      	addeq	r0, #4
   15380:	d0f4      	beq.n	1536c <strlen+0x30>
   15382:	f013 0fff 	tst.w	r3, #255	; 0xff
   15386:	bf1f      	itttt	ne
   15388:	3001      	addne	r0, #1
   1538a:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
   1538e:	3001      	addne	r0, #1
   15390:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
   15394:	bf18      	it	ne
   15396:	3001      	addne	r0, #1
   15398:	4770      	bx	lr
   1539a:	bf00      	nop

0001539c <strncmp>:
   1539c:	b430      	push	{r4, r5}
   1539e:	4613      	mov	r3, r2
   153a0:	2a00      	cmp	r2, #0
   153a2:	d043      	beq.n	1542c <strncmp+0x90>
   153a4:	ea41 0200 	orr.w	r2, r1, r0
   153a8:	f012 0f03 	tst.w	r2, #3
   153ac:	d125      	bne.n	153fa <strncmp+0x5e>
   153ae:	2b03      	cmp	r3, #3
   153b0:	4604      	mov	r4, r0
   153b2:	460d      	mov	r5, r1
   153b4:	d93d      	bls.n	15432 <strncmp+0x96>
   153b6:	6802      	ldr	r2, [r0, #0]
   153b8:	6809      	ldr	r1, [r1, #0]
   153ba:	428a      	cmp	r2, r1
   153bc:	d139      	bne.n	15432 <strncmp+0x96>
   153be:	3b04      	subs	r3, #4
   153c0:	d034      	beq.n	1542c <strncmp+0x90>
   153c2:	f1a2 3101 	sub.w	r1, r2, #16843009	; 0x1010101
   153c6:	ea21 0202 	bic.w	r2, r1, r2
   153ca:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   153ce:	d00d      	beq.n	153ec <strncmp+0x50>
   153d0:	e02c      	b.n	1542c <strncmp+0x90>
   153d2:	6822      	ldr	r2, [r4, #0]
   153d4:	6829      	ldr	r1, [r5, #0]
   153d6:	f1a2 3001 	sub.w	r0, r2, #16843009	; 0x1010101
   153da:	428a      	cmp	r2, r1
   153dc:	ea20 0002 	bic.w	r0, r0, r2
   153e0:	d127      	bne.n	15432 <strncmp+0x96>
   153e2:	3b04      	subs	r3, #4
   153e4:	d022      	beq.n	1542c <strncmp+0x90>
   153e6:	f010 3f80 	tst.w	r0, #2155905152	; 0x80808080
   153ea:	d11f      	bne.n	1542c <strncmp+0x90>
   153ec:	3404      	adds	r4, #4
   153ee:	3504      	adds	r5, #4
   153f0:	2b03      	cmp	r3, #3
   153f2:	d8ee      	bhi.n	153d2 <strncmp+0x36>
   153f4:	4620      	mov	r0, r4
   153f6:	4629      	mov	r1, r5
   153f8:	b1f3      	cbz	r3, 15438 <strncmp+0x9c>
   153fa:	7804      	ldrb	r4, [r0, #0]
   153fc:	3b01      	subs	r3, #1
   153fe:	f891 c000 	ldrb.w	ip, [r1]
   15402:	4564      	cmp	r4, ip
   15404:	d10f      	bne.n	15426 <strncmp+0x8a>
   15406:	b18b      	cbz	r3, 1542c <strncmp+0x90>
   15408:	b184      	cbz	r4, 1542c <strncmp+0x90>
   1540a:	3b01      	subs	r3, #1
   1540c:	2200      	movs	r2, #0
   1540e:	e002      	b.n	15416 <strncmp+0x7a>
   15410:	b163      	cbz	r3, 1542c <strncmp+0x90>
   15412:	b15c      	cbz	r4, 1542c <strncmp+0x90>
   15414:	3b01      	subs	r3, #1
   15416:	1884      	adds	r4, r0, r2
   15418:	188d      	adds	r5, r1, r2
   1541a:	3201      	adds	r2, #1
   1541c:	7864      	ldrb	r4, [r4, #1]
   1541e:	f895 c001 	ldrb.w	ip, [r5, #1]
   15422:	4564      	cmp	r4, ip
   15424:	d0f4      	beq.n	15410 <strncmp+0x74>
   15426:	ebcc 0004 	rsb	r0, ip, r4
   1542a:	e000      	b.n	1542e <strncmp+0x92>
   1542c:	2000      	movs	r0, #0
   1542e:	bc30      	pop	{r4, r5}
   15430:	4770      	bx	lr
   15432:	4620      	mov	r0, r4
   15434:	4629      	mov	r1, r5
   15436:	e7e0      	b.n	153fa <strncmp+0x5e>
   15438:	7824      	ldrb	r4, [r4, #0]
   1543a:	f895 c000 	ldrb.w	ip, [r5]
   1543e:	ebcc 0004 	rsb	r0, ip, r4
   15442:	e7f4      	b.n	1542e <strncmp+0x92>

00015444 <strncpy>:
   15444:	ea41 0300 	orr.w	r3, r1, r0
   15448:	f013 0f03 	tst.w	r3, #3
   1544c:	bf14      	ite	ne
   1544e:	2300      	movne	r3, #0
   15450:	2301      	moveq	r3, #1
   15452:	2a03      	cmp	r2, #3
   15454:	bf94      	ite	ls
   15456:	2300      	movls	r3, #0
   15458:	f003 0301 	andhi.w	r3, r3, #1
   1545c:	b430      	push	{r4, r5}
   1545e:	2b00      	cmp	r3, #0
   15460:	d02a      	beq.n	154b8 <strncpy+0x74>
   15462:	4604      	mov	r4, r0
   15464:	680b      	ldr	r3, [r1, #0]
   15466:	f1a3 3c01 	sub.w	ip, r3, #16843009	; 0x1010101
   1546a:	ea2c 0c03 	bic.w	ip, ip, r3
   1546e:	f01c 3f80 	tst.w	ip, #2155905152	; 0x80808080
   15472:	d105      	bne.n	15480 <strncpy+0x3c>
   15474:	3a04      	subs	r2, #4
   15476:	3104      	adds	r1, #4
   15478:	2a03      	cmp	r2, #3
   1547a:	f844 3b04 	str.w	r3, [r4], #4
   1547e:	d8f1      	bhi.n	15464 <strncpy+0x20>
   15480:	4623      	mov	r3, r4
   15482:	b1ba      	cbz	r2, 154b4 <strncpy+0x70>
   15484:	780d      	ldrb	r5, [r1, #0]
   15486:	461c      	mov	r4, r3
   15488:	3a01      	subs	r2, #1
   1548a:	f804 5b01 	strb.w	r5, [r4], #1
   1548e:	b155      	cbz	r5, 154a6 <strncpy+0x62>
   15490:	3302      	adds	r3, #2
   15492:	b17a      	cbz	r2, 154b4 <strncpy+0x70>
   15494:	f811 5f01 	ldrb.w	r5, [r1, #1]!
   15498:	461c      	mov	r4, r3
   1549a:	3a01      	subs	r2, #1
   1549c:	f803 5c01 	strb.w	r5, [r3, #-1]
   154a0:	3301      	adds	r3, #1
   154a2:	2d00      	cmp	r5, #0
   154a4:	d1f5      	bne.n	15492 <strncpy+0x4e>
   154a6:	b12a      	cbz	r2, 154b4 <strncpy+0x70>
   154a8:	2300      	movs	r3, #0
   154aa:	4619      	mov	r1, r3
   154ac:	54e1      	strb	r1, [r4, r3]
   154ae:	3301      	adds	r3, #1
   154b0:	4293      	cmp	r3, r2
   154b2:	d1fb      	bne.n	154ac <strncpy+0x68>
   154b4:	bc30      	pop	{r4, r5}
   154b6:	4770      	bx	lr
   154b8:	4603      	mov	r3, r0
   154ba:	e7e2      	b.n	15482 <strncpy+0x3e>

000154bc <strrchr>:
   154bc:	b570      	push	{r4, r5, r6, lr}
   154be:	4603      	mov	r3, r0
   154c0:	460c      	mov	r4, r1
   154c2:	b161      	cbz	r1, 154de <strrchr+0x22>
   154c4:	2500      	movs	r5, #0
   154c6:	e000      	b.n	154ca <strrchr+0xe>
   154c8:	4615      	mov	r5, r2
   154ca:	4618      	mov	r0, r3
   154cc:	4621      	mov	r1, r4
   154ce:	f7ff fe77 	bl	151c0 <strchr>
   154d2:	4602      	mov	r2, r0
   154d4:	1c43      	adds	r3, r0, #1
   154d6:	2800      	cmp	r0, #0
   154d8:	d1f6      	bne.n	154c8 <strrchr+0xc>
   154da:	4628      	mov	r0, r5
   154dc:	bd70      	pop	{r4, r5, r6, pc}
   154de:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   154e2:	f7ff be6d 	b.w	151c0 <strchr>
   154e6:	bf00      	nop

000154e8 <critical_factorization>:
   154e8:	2301      	movs	r3, #1
   154ea:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
   154ee:	461c      	mov	r4, r3
   154f0:	2500      	movs	r5, #0
   154f2:	f04f 36ff 	mov.w	r6, #4294967295
   154f6:	eb04 0c05 	add.w	ip, r4, r5
   154fa:	19a7      	adds	r7, r4, r6
   154fc:	458c      	cmp	ip, r1
   154fe:	d20d      	bcs.n	1551c <critical_factorization+0x34>
   15500:	5c3f      	ldrb	r7, [r7, r0]
   15502:	f810 800c 	ldrb.w	r8, [r0, ip]
   15506:	45b8      	cmp	r8, r7
   15508:	d22f      	bcs.n	1556a <critical_factorization+0x82>
   1550a:	ebc6 030c 	rsb	r3, r6, ip
   1550e:	2401      	movs	r4, #1
   15510:	4665      	mov	r5, ip
   15512:	eb04 0c05 	add.w	ip, r4, r5
   15516:	19a7      	adds	r7, r4, r6
   15518:	458c      	cmp	ip, r1
   1551a:	d3f1      	bcc.n	15500 <critical_factorization+0x18>
   1551c:	f04f 0a01 	mov.w	sl, #1
   15520:	2500      	movs	r5, #0
   15522:	4654      	mov	r4, sl
   15524:	f04f 37ff 	mov.w	r7, #4294967295
   15528:	eb04 0c05 	add.w	ip, r4, r5
   1552c:	6013      	str	r3, [r2, #0]
   1552e:	4561      	cmp	r1, ip
   15530:	eb04 0807 	add.w	r8, r4, r7
   15534:	d90f      	bls.n	15556 <critical_factorization+0x6e>
   15536:	f818 8000 	ldrb.w	r8, [r8, r0]
   1553a:	f810 900c 	ldrb.w	r9, [r0, ip]
   1553e:	45c1      	cmp	r9, r8
   15540:	d924      	bls.n	1558c <critical_factorization+0xa4>
   15542:	ebc7 0a0c 	rsb	sl, r7, ip
   15546:	2401      	movs	r4, #1
   15548:	4665      	mov	r5, ip
   1554a:	eb04 0c05 	add.w	ip, r4, r5
   1554e:	eb04 0807 	add.w	r8, r4, r7
   15552:	4561      	cmp	r1, ip
   15554:	d8ef      	bhi.n	15536 <critical_factorization+0x4e>
   15556:	3701      	adds	r7, #1
   15558:	1c70      	adds	r0, r6, #1
   1555a:	4287      	cmp	r7, r0
   1555c:	bf24      	itt	cs
   1555e:	4653      	movcs	r3, sl
   15560:	4638      	movcs	r0, r7
   15562:	6013      	str	r3, [r2, #0]
   15564:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
   15568:	4770      	bx	lr
   1556a:	d006      	beq.n	1557a <critical_factorization+0x92>
   1556c:	2301      	movs	r3, #1
   1556e:	462e      	mov	r6, r5
   15570:	eb05 0c03 	add.w	ip, r5, r3
   15574:	461c      	mov	r4, r3
   15576:	4665      	mov	r5, ip
   15578:	e7cb      	b.n	15512 <critical_factorization+0x2a>
   1557a:	429c      	cmp	r4, r3
   1557c:	f104 0401 	add.w	r4, r4, #1
   15580:	bf18      	it	ne
   15582:	46ac      	movne	ip, r5
   15584:	d1c4      	bne.n	15510 <critical_factorization+0x28>
   15586:	2401      	movs	r4, #1
   15588:	4665      	mov	r5, ip
   1558a:	e7c2      	b.n	15512 <critical_factorization+0x2a>
   1558c:	d007      	beq.n	1559e <critical_factorization+0xb6>
   1558e:	f04f 0a01 	mov.w	sl, #1
   15592:	462f      	mov	r7, r5
   15594:	eb05 0c0a 	add.w	ip, r5, sl
   15598:	4654      	mov	r4, sl
   1559a:	4665      	mov	r5, ip
   1559c:	e7d5      	b.n	1554a <critical_factorization+0x62>
   1559e:	4554      	cmp	r4, sl
   155a0:	f104 0401 	add.w	r4, r4, #1
   155a4:	bf18      	it	ne
   155a6:	46ac      	movne	ip, r5
   155a8:	d1ce      	bne.n	15548 <critical_factorization+0x60>
   155aa:	2401      	movs	r4, #1
   155ac:	4665      	mov	r5, ip
   155ae:	e7cc      	b.n	1554a <critical_factorization+0x62>

000155b0 <two_way_long_needle>:
   155b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   155b4:	f5ad 6d84 	sub.w	sp, sp, #1056	; 0x420
   155b8:	b081      	sub	sp, #4
   155ba:	4606      	mov	r6, r0
   155bc:	4610      	mov	r0, r2
   155be:	4689      	mov	r9, r1
   155c0:	9203      	str	r2, [sp, #12]
   155c2:	f50d 6282 	add.w	r2, sp, #1040	; 0x410
   155c6:	4619      	mov	r1, r3
   155c8:	320c      	adds	r2, #12
   155ca:	461c      	mov	r4, r3
   155cc:	f7ff ff8c 	bl	154e8 <critical_factorization>
   155d0:	2300      	movs	r3, #0
   155d2:	aa07      	add	r2, sp, #28
   155d4:	4680      	mov	r8, r0
   155d6:	50d4      	str	r4, [r2, r3]
   155d8:	3304      	adds	r3, #4
   155da:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
   155de:	d1fa      	bne.n	155d6 <two_way_long_needle+0x26>
   155e0:	b164      	cbz	r4, 155fc <two_way_long_needle+0x4c>
   155e2:	f8dd c00c 	ldr.w	ip, [sp, #12]
   155e6:	1e62      	subs	r2, r4, #1
   155e8:	2300      	movs	r3, #0
   155ea:	a807      	add	r0, sp, #28
   155ec:	f81c 1003 	ldrb.w	r1, [ip, r3]
   155f0:	3301      	adds	r3, #1
   155f2:	f840 2021 	str.w	r2, [r0, r1, lsl #2]
   155f6:	3a01      	subs	r2, #1
   155f8:	429c      	cmp	r4, r3
   155fa:	d8f7      	bhi.n	155ec <two_way_long_needle+0x3c>
   155fc:	9803      	ldr	r0, [sp, #12]
   155fe:	4642      	mov	r2, r8
   15600:	f8dd 141c 	ldr.w	r1, [sp, #1052]	; 0x41c
   15604:	1841      	adds	r1, r0, r1
   15606:	f003 fc95 	bl	18f34 <memcmp>
   1560a:	4605      	mov	r5, r0
   1560c:	2800      	cmp	r0, #0
   1560e:	f040 808b 	bne.w	15728 <two_way_long_needle+0x178>
   15612:	9402      	str	r4, [sp, #8]
   15614:	4682      	mov	sl, r0
   15616:	9b02      	ldr	r3, [sp, #8]
   15618:	f1c8 0201 	rsb	r2, r8, #1
   1561c:	9903      	ldr	r1, [sp, #12]
   1561e:	1e67      	subs	r7, r4, #1
   15620:	9205      	str	r2, [sp, #20]
   15622:	eb0a 0403 	add.w	r4, sl, r3
   15626:	464a      	mov	r2, r9
   15628:	f108 30ff 	add.w	r0, r8, #4294967295
   1562c:	4441      	add	r1, r8
   1562e:	9001      	str	r0, [sp, #4]
   15630:	9104      	str	r1, [sp, #16]
   15632:	18b0      	adds	r0, r6, r2
   15634:	2100      	movs	r1, #0
   15636:	1aa2      	subs	r2, r4, r2
   15638:	f8dd b00c 	ldr.w	fp, [sp, #12]
   1563c:	f003 fc40 	bl	18ec0 <memchr>
   15640:	4603      	mov	r3, r0
   15642:	2800      	cmp	r0, #0
   15644:	d159      	bne.n	156fa <two_way_long_needle+0x14a>
   15646:	2c00      	cmp	r4, #0
   15648:	d057      	beq.n	156fa <two_way_long_needle+0x14a>
   1564a:	19a2      	adds	r2, r4, r6
   1564c:	a807      	add	r0, sp, #28
   1564e:	f812 2c01 	ldrb.w	r2, [r2, #-1]
   15652:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
   15656:	2a00      	cmp	r2, #0
   15658:	d15b      	bne.n	15712 <two_way_long_needle+0x162>
   1565a:	4545      	cmp	r5, r8
   1565c:	bf2c      	ite	cs
   1565e:	462b      	movcs	r3, r5
   15660:	4643      	movcc	r3, r8
   15662:	42bb      	cmp	r3, r7
   15664:	d213      	bcs.n	1568e <two_way_long_needle+0xde>
   15666:	eb03 000a 	add.w	r0, r3, sl
   1566a:	f81b c003 	ldrb.w	ip, [fp, r3]
   1566e:	1832      	adds	r2, r6, r0
   15670:	eb0b 0103 	add.w	r1, fp, r3
   15674:	5c30      	ldrb	r0, [r6, r0]
   15676:	4584      	cmp	ip, r0
   15678:	d006      	beq.n	15688 <two_way_long_needle+0xd8>
   1567a:	e044      	b.n	15706 <two_way_long_needle+0x156>
   1567c:	f811 cf01 	ldrb.w	ip, [r1, #1]!
   15680:	f812 0f01 	ldrb.w	r0, [r2, #1]!
   15684:	4584      	cmp	ip, r0
   15686:	d13e      	bne.n	15706 <two_way_long_needle+0x156>
   15688:	3301      	adds	r3, #1
   1568a:	42bb      	cmp	r3, r7
   1568c:	d3f6      	bcc.n	1567c <two_way_long_needle+0xcc>
   1568e:	4545      	cmp	r5, r8
   15690:	f080 80b0 	bcs.w	157f4 <two_way_long_needle+0x244>
   15694:	9901      	ldr	r1, [sp, #4]
   15696:	9b01      	ldr	r3, [sp, #4]
   15698:	eb01 020a 	add.w	r2, r1, sl
   1569c:	f81b 1001 	ldrb.w	r1, [fp, r1]
   156a0:	5d92      	ldrb	r2, [r2, r6]
   156a2:	4291      	cmp	r1, r2
   156a4:	f040 80a6 	bne.w	157f4 <two_way_long_needle+0x244>
   156a8:	eb0a 0208 	add.w	r2, sl, r8
   156ac:	9904      	ldr	r1, [sp, #16]
   156ae:	18b2      	adds	r2, r6, r2
   156b0:	46a1      	mov	r9, r4
   156b2:	e008      	b.n	156c6 <two_way_long_needle+0x116>
   156b4:	f811 4c02 	ldrb.w	r4, [r1, #-2]
   156b8:	3901      	subs	r1, #1
   156ba:	f812 cc02 	ldrb.w	ip, [r2, #-2]
   156be:	3a01      	subs	r2, #1
   156c0:	4564      	cmp	r4, ip
   156c2:	d104      	bne.n	156ce <two_way_long_needle+0x11e>
   156c4:	4603      	mov	r3, r0
   156c6:	429d      	cmp	r5, r3
   156c8:	f103 30ff 	add.w	r0, r3, #4294967295
   156cc:	d3f2      	bcc.n	156b4 <two_way_long_needle+0x104>
   156ce:	3501      	adds	r5, #1
   156d0:	464c      	mov	r4, r9
   156d2:	429d      	cmp	r5, r3
   156d4:	f200 8093 	bhi.w	157fe <two_way_long_needle+0x24e>
   156d8:	f8dd 541c 	ldr.w	r5, [sp, #1052]	; 0x41c
   156dc:	9a02      	ldr	r2, [sp, #8]
   156de:	44aa      	add	sl, r5
   156e0:	1b55      	subs	r5, r2, r5
   156e2:	4622      	mov	r2, r4
   156e4:	9b02      	ldr	r3, [sp, #8]
   156e6:	18b0      	adds	r0, r6, r2
   156e8:	2100      	movs	r1, #0
   156ea:	eb0a 0403 	add.w	r4, sl, r3
   156ee:	1aa2      	subs	r2, r4, r2
   156f0:	f003 fbe6 	bl	18ec0 <memchr>
   156f4:	4603      	mov	r3, r0
   156f6:	2800      	cmp	r0, #0
   156f8:	d0a5      	beq.n	15646 <two_way_long_needle+0x96>
   156fa:	2000      	movs	r0, #0
   156fc:	b009      	add	sp, #36	; 0x24
   156fe:	f50d 6d80 	add.w	sp, sp, #1024	; 0x400
   15702:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15706:	9905      	ldr	r1, [sp, #20]
   15708:	2500      	movs	r5, #0
   1570a:	4622      	mov	r2, r4
   1570c:	448a      	add	sl, r1
   1570e:	449a      	add	sl, r3
   15710:	e7e8      	b.n	156e4 <two_way_long_needle+0x134>
   15712:	b135      	cbz	r5, 15722 <two_way_long_needle+0x172>
   15714:	f8dd 141c 	ldr.w	r1, [sp, #1052]	; 0x41c
   15718:	428a      	cmp	r2, r1
   1571a:	d202      	bcs.n	15722 <two_way_long_needle+0x172>
   1571c:	9802      	ldr	r0, [sp, #8]
   1571e:	461d      	mov	r5, r3
   15720:	1a42      	subs	r2, r0, r1
   15722:	4492      	add	sl, r2
   15724:	4622      	mov	r2, r4
   15726:	e7dd      	b.n	156e4 <two_way_long_needle+0x134>
   15728:	9803      	ldr	r0, [sp, #12]
   1572a:	ebc8 0304 	rsb	r3, r8, r4
   1572e:	464a      	mov	r2, r9
   15730:	2700      	movs	r7, #0
   15732:	1e65      	subs	r5, r4, #1
   15734:	f108 3aff 	add.w	sl, r8, #4294967295
   15738:	eb00 0b08 	add.w	fp, r0, r8
   1573c:	46a1      	mov	r9, r4
   1573e:	4543      	cmp	r3, r8
   15740:	bf38      	it	cc
   15742:	4643      	movcc	r3, r8
   15744:	f1c8 0101 	rsb	r1, r8, #1
   15748:	3301      	adds	r3, #1
   1574a:	9101      	str	r1, [sp, #4]
   1574c:	f8cd 341c 	str.w	r3, [sp, #1052]	; 0x41c
   15750:	eb07 0409 	add.w	r4, r7, r9
   15754:	18b0      	adds	r0, r6, r2
   15756:	2100      	movs	r1, #0
   15758:	1aa2      	subs	r2, r4, r2
   1575a:	f003 fbb1 	bl	18ec0 <memchr>
   1575e:	2800      	cmp	r0, #0
   15760:	d1cb      	bne.n	156fa <two_way_long_needle+0x14a>
   15762:	2c00      	cmp	r4, #0
   15764:	d0c9      	beq.n	156fa <two_way_long_needle+0x14a>
   15766:	19a3      	adds	r3, r4, r6
   15768:	aa07      	add	r2, sp, #28
   1576a:	f813 3c01 	ldrb.w	r3, [r3, #-1]
   1576e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15772:	2b00      	cmp	r3, #0
   15774:	d135      	bne.n	157e2 <two_way_long_needle+0x232>
   15776:	45a8      	cmp	r8, r5
   15778:	d214      	bcs.n	157a4 <two_way_long_needle+0x1f4>
   1577a:	eb07 0308 	add.w	r3, r7, r8
   1577e:	f89b 2000 	ldrb.w	r2, [fp]
   15782:	18f1      	adds	r1, r6, r3
   15784:	5cf3      	ldrb	r3, [r6, r3]
   15786:	429a      	cmp	r2, r3
   15788:	bf04      	itt	eq
   1578a:	465a      	moveq	r2, fp
   1578c:	4643      	moveq	r3, r8
   1578e:	d006      	beq.n	1579e <two_way_long_needle+0x1ee>
   15790:	e02a      	b.n	157e8 <two_way_long_needle+0x238>
   15792:	f812 cf01 	ldrb.w	ip, [r2, #1]!
   15796:	f811 0f01 	ldrb.w	r0, [r1, #1]!
   1579a:	4584      	cmp	ip, r0
   1579c:	d125      	bne.n	157ea <two_way_long_needle+0x23a>
   1579e:	3301      	adds	r3, #1
   157a0:	42ab      	cmp	r3, r5
   157a2:	d3f6      	bcc.n	15792 <two_way_long_needle+0x1e2>
   157a4:	f1ba 3fff 	cmp.w	sl, #4294967295
   157a8:	4653      	mov	r3, sl
   157aa:	d016      	beq.n	157da <two_way_long_needle+0x22a>
   157ac:	9803      	ldr	r0, [sp, #12]
   157ae:	eb0a 0207 	add.w	r2, sl, r7
   157b2:	5d92      	ldrb	r2, [r2, r6]
   157b4:	f810 100a 	ldrb.w	r1, [r0, sl]
   157b8:	4291      	cmp	r1, r2
   157ba:	d110      	bne.n	157de <two_way_long_needle+0x22e>
   157bc:	eb07 0208 	add.w	r2, r7, r8
   157c0:	4659      	mov	r1, fp
   157c2:	18b2      	adds	r2, r6, r2
   157c4:	e007      	b.n	157d6 <two_way_long_needle+0x226>
   157c6:	f811 cc02 	ldrb.w	ip, [r1, #-2]
   157ca:	3901      	subs	r1, #1
   157cc:	f812 0c02 	ldrb.w	r0, [r2, #-2]
   157d0:	3a01      	subs	r2, #1
   157d2:	4584      	cmp	ip, r0
   157d4:	d103      	bne.n	157de <two_way_long_needle+0x22e>
   157d6:	3b01      	subs	r3, #1
   157d8:	d2f5      	bcs.n	157c6 <two_way_long_needle+0x216>
   157da:	19f0      	adds	r0, r6, r7
   157dc:	e78e      	b.n	156fc <two_way_long_needle+0x14c>
   157de:	f8dd 341c 	ldr.w	r3, [sp, #1052]	; 0x41c
   157e2:	18ff      	adds	r7, r7, r3
   157e4:	4622      	mov	r2, r4
   157e6:	e7b3      	b.n	15750 <two_way_long_needle+0x1a0>
   157e8:	4643      	mov	r3, r8
   157ea:	9a01      	ldr	r2, [sp, #4]
   157ec:	19d7      	adds	r7, r2, r7
   157ee:	4622      	mov	r2, r4
   157f0:	18ff      	adds	r7, r7, r3
   157f2:	e7ad      	b.n	15750 <two_way_long_needle+0x1a0>
   157f4:	4643      	mov	r3, r8
   157f6:	3501      	adds	r5, #1
   157f8:	429d      	cmp	r5, r3
   157fa:	f67f af6d 	bls.w	156d8 <two_way_long_needle+0x128>
   157fe:	eb06 000a 	add.w	r0, r6, sl
   15802:	e77b      	b.n	156fc <two_way_long_needle+0x14c>

00015804 <strstr>:
   15804:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15808:	7803      	ldrb	r3, [r0, #0]
   1580a:	b087      	sub	sp, #28
   1580c:	4606      	mov	r6, r0
   1580e:	460d      	mov	r5, r1
   15810:	2b00      	cmp	r3, #0
   15812:	f000 8104 	beq.w	15a1e <strstr+0x21a>
   15816:	780a      	ldrb	r2, [r1, #0]
   15818:	b192      	cbz	r2, 15840 <strstr+0x3c>
   1581a:	4601      	mov	r1, r0
   1581c:	462c      	mov	r4, r5
   1581e:	2001      	movs	r0, #1
   15820:	e001      	b.n	15826 <strstr+0x22>
   15822:	7822      	ldrb	r2, [r4, #0]
   15824:	b182      	cbz	r2, 15848 <strstr+0x44>
   15826:	4293      	cmp	r3, r2
   15828:	bf14      	ite	ne
   1582a:	2000      	movne	r0, #0
   1582c:	f000 0001 	andeq.w	r0, r0, #1
   15830:	784b      	ldrb	r3, [r1, #1]
   15832:	3401      	adds	r4, #1
   15834:	3101      	adds	r1, #1
   15836:	2b00      	cmp	r3, #0
   15838:	d1f3      	bne.n	15822 <strstr+0x1e>
   1583a:	7823      	ldrb	r3, [r4, #0]
   1583c:	b123      	cbz	r3, 15848 <strstr+0x44>
   1583e:	2600      	movs	r6, #0
   15840:	4630      	mov	r0, r6
   15842:	b007      	add	sp, #28
   15844:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15848:	2800      	cmp	r0, #0
   1584a:	d1f9      	bne.n	15840 <strstr+0x3c>
   1584c:	1c70      	adds	r0, r6, #1
   1584e:	7829      	ldrb	r1, [r5, #0]
   15850:	f7ff fcb6 	bl	151c0 <strchr>
   15854:	1b64      	subs	r4, r4, r5
   15856:	2c01      	cmp	r4, #1
   15858:	bf14      	ite	ne
   1585a:	2300      	movne	r3, #0
   1585c:	2301      	moveq	r3, #1
   1585e:	2800      	cmp	r0, #0
   15860:	bf08      	it	eq
   15862:	f043 0301 	orreq.w	r3, r3, #1
   15866:	4607      	mov	r7, r0
   15868:	b97b      	cbnz	r3, 1588a <strstr+0x86>
   1586a:	1936      	adds	r6, r6, r4
   1586c:	42b0      	cmp	r0, r6
   1586e:	bf8c      	ite	hi
   15870:	f04f 0a01 	movhi.w	sl, #1
   15874:	ebc0 0a06 	rsbls	sl, r0, r6
   15878:	2c1f      	cmp	r4, #31
   1587a:	d908      	bls.n	1588e <strstr+0x8a>
   1587c:	4651      	mov	r1, sl
   1587e:	462a      	mov	r2, r5
   15880:	4623      	mov	r3, r4
   15882:	f7ff fe95 	bl	155b0 <two_way_long_needle>
   15886:	4606      	mov	r6, r0
   15888:	e7da      	b.n	15840 <strstr+0x3c>
   1588a:	4606      	mov	r6, r0
   1588c:	e7d8      	b.n	15840 <strstr+0x3c>
   1588e:	4621      	mov	r1, r4
   15890:	aa05      	add	r2, sp, #20
   15892:	4628      	mov	r0, r5
   15894:	f7ff fe28 	bl	154e8 <critical_factorization>
   15898:	9905      	ldr	r1, [sp, #20]
   1589a:	1869      	adds	r1, r5, r1
   1589c:	4680      	mov	r8, r0
   1589e:	4628      	mov	r0, r5
   158a0:	4642      	mov	r2, r8
   158a2:	f003 fb47 	bl	18f34 <memcmp>
   158a6:	4606      	mov	r6, r0
   158a8:	2800      	cmp	r0, #0
   158aa:	d158      	bne.n	1595e <strstr+0x15a>
   158ac:	f108 32ff 	add.w	r2, r8, #4294967295
   158b0:	eb05 0308 	add.w	r3, r5, r8
   158b4:	9201      	str	r2, [sp, #4]
   158b6:	46c3      	mov	fp, r8
   158b8:	f1c8 0201 	rsb	r2, r8, #1
   158bc:	4681      	mov	r9, r0
   158be:	9203      	str	r2, [sp, #12]
   158c0:	46a8      	mov	r8, r5
   158c2:	4652      	mov	r2, sl
   158c4:	9302      	str	r3, [sp, #8]
   158c6:	eb09 0504 	add.w	r5, r9, r4
   158ca:	18b8      	adds	r0, r7, r2
   158cc:	2100      	movs	r1, #0
   158ce:	1aaa      	subs	r2, r5, r2
   158d0:	f003 faf6 	bl	18ec0 <memchr>
   158d4:	2800      	cmp	r0, #0
   158d6:	d1b2      	bne.n	1583e <strstr+0x3a>
   158d8:	2d00      	cmp	r5, #0
   158da:	d0b0      	beq.n	1583e <strstr+0x3a>
   158dc:	455e      	cmp	r6, fp
   158de:	bf2c      	ite	cs
   158e0:	4633      	movcs	r3, r6
   158e2:	465b      	movcc	r3, fp
   158e4:	429c      	cmp	r4, r3
   158e6:	d913      	bls.n	15910 <strstr+0x10c>
   158e8:	eb03 0009 	add.w	r0, r3, r9
   158ec:	f818 c003 	ldrb.w	ip, [r8, r3]
   158f0:	183a      	adds	r2, r7, r0
   158f2:	eb08 0103 	add.w	r1, r8, r3
   158f6:	5c38      	ldrb	r0, [r7, r0]
   158f8:	4584      	cmp	ip, r0
   158fa:	d006      	beq.n	1590a <strstr+0x106>
   158fc:	e085      	b.n	15a0a <strstr+0x206>
   158fe:	f811 cf01 	ldrb.w	ip, [r1, #1]!
   15902:	f812 0f01 	ldrb.w	r0, [r2, #1]!
   15906:	4584      	cmp	ip, r0
   15908:	d17f      	bne.n	15a0a <strstr+0x206>
   1590a:	3301      	adds	r3, #1
   1590c:	429c      	cmp	r4, r3
   1590e:	d8f6      	bhi.n	158fe <strstr+0xfa>
   15910:	45b3      	cmp	fp, r6
   15912:	f240 8087 	bls.w	15a24 <strstr+0x220>
   15916:	9b01      	ldr	r3, [sp, #4]
   15918:	eb03 0209 	add.w	r2, r3, r9
   1591c:	f818 1003 	ldrb.w	r1, [r8, r3]
   15920:	5dd2      	ldrb	r2, [r2, r7]
   15922:	4291      	cmp	r1, r2
   15924:	d17e      	bne.n	15a24 <strstr+0x220>
   15926:	eb09 020b 	add.w	r2, r9, fp
   1592a:	9902      	ldr	r1, [sp, #8]
   1592c:	18ba      	adds	r2, r7, r2
   1592e:	46aa      	mov	sl, r5
   15930:	e008      	b.n	15944 <strstr+0x140>
   15932:	f811 5c02 	ldrb.w	r5, [r1, #-2]
   15936:	3901      	subs	r1, #1
   15938:	f812 cc02 	ldrb.w	ip, [r2, #-2]
   1593c:	3a01      	subs	r2, #1
   1593e:	4565      	cmp	r5, ip
   15940:	d104      	bne.n	1594c <strstr+0x148>
   15942:	4603      	mov	r3, r0
   15944:	429e      	cmp	r6, r3
   15946:	f103 30ff 	add.w	r0, r3, #4294967295
   1594a:	d3f2      	bcc.n	15932 <strstr+0x12e>
   1594c:	4655      	mov	r5, sl
   1594e:	3601      	adds	r6, #1
   15950:	429e      	cmp	r6, r3
   15952:	d869      	bhi.n	15a28 <strstr+0x224>
   15954:	9e05      	ldr	r6, [sp, #20]
   15956:	462a      	mov	r2, r5
   15958:	44b1      	add	r9, r6
   1595a:	1ba6      	subs	r6, r4, r6
   1595c:	e7b3      	b.n	158c6 <strstr+0xc2>
   1595e:	f1c8 0201 	rsb	r2, r8, #1
   15962:	ebc8 0304 	rsb	r3, r8, r4
   15966:	9201      	str	r2, [sp, #4]
   15968:	2600      	movs	r6, #0
   1596a:	4652      	mov	r2, sl
   1596c:	eb05 0908 	add.w	r9, r5, r8
   15970:	f108 3bff 	add.w	fp, r8, #4294967295
   15974:	46aa      	mov	sl, r5
   15976:	4543      	cmp	r3, r8
   15978:	bf38      	it	cc
   1597a:	4643      	movcc	r3, r8
   1597c:	3301      	adds	r3, #1
   1597e:	9305      	str	r3, [sp, #20]
   15980:	1935      	adds	r5, r6, r4
   15982:	18b8      	adds	r0, r7, r2
   15984:	2100      	movs	r1, #0
   15986:	1aaa      	subs	r2, r5, r2
   15988:	f003 fa9a 	bl	18ec0 <memchr>
   1598c:	2800      	cmp	r0, #0
   1598e:	f47f af56 	bne.w	1583e <strstr+0x3a>
   15992:	2d00      	cmp	r5, #0
   15994:	f43f af53 	beq.w	1583e <strstr+0x3a>
   15998:	4544      	cmp	r4, r8
   1599a:	d915      	bls.n	159c8 <strstr+0x1c4>
   1599c:	eb06 0308 	add.w	r3, r6, r8
   159a0:	f899 2000 	ldrb.w	r2, [r9]
   159a4:	18f9      	adds	r1, r7, r3
   159a6:	5cfb      	ldrb	r3, [r7, r3]
   159a8:	429a      	cmp	r2, r3
   159aa:	bf12      	itee	ne
   159ac:	4643      	movne	r3, r8
   159ae:	464a      	moveq	r2, r9
   159b0:	4643      	moveq	r3, r8
   159b2:	d006      	beq.n	159c2 <strstr+0x1be>
   159b4:	e024      	b.n	15a00 <strstr+0x1fc>
   159b6:	f812 cf01 	ldrb.w	ip, [r2, #1]!
   159ba:	f811 0f01 	ldrb.w	r0, [r1, #1]!
   159be:	4584      	cmp	ip, r0
   159c0:	d11e      	bne.n	15a00 <strstr+0x1fc>
   159c2:	3301      	adds	r3, #1
   159c4:	429c      	cmp	r4, r3
   159c6:	d8f6      	bhi.n	159b6 <strstr+0x1b2>
   159c8:	f1bb 3fff 	cmp.w	fp, #4294967295
   159cc:	465b      	mov	r3, fp
   159ce:	d015      	beq.n	159fc <strstr+0x1f8>
   159d0:	eb06 020b 	add.w	r2, r6, fp
   159d4:	f81a 100b 	ldrb.w	r1, [sl, fp]
   159d8:	5dd2      	ldrb	r2, [r2, r7]
   159da:	4291      	cmp	r1, r2
   159dc:	d11b      	bne.n	15a16 <strstr+0x212>
   159de:	eb06 0208 	add.w	r2, r6, r8
   159e2:	4649      	mov	r1, r9
   159e4:	18ba      	adds	r2, r7, r2
   159e6:	e007      	b.n	159f8 <strstr+0x1f4>
   159e8:	f811 cc02 	ldrb.w	ip, [r1, #-2]
   159ec:	3901      	subs	r1, #1
   159ee:	f812 0c02 	ldrb.w	r0, [r2, #-2]
   159f2:	3a01      	subs	r2, #1
   159f4:	4584      	cmp	ip, r0
   159f6:	d10e      	bne.n	15a16 <strstr+0x212>
   159f8:	3b01      	subs	r3, #1
   159fa:	d2f5      	bcs.n	159e8 <strstr+0x1e4>
   159fc:	19be      	adds	r6, r7, r6
   159fe:	e71f      	b.n	15840 <strstr+0x3c>
   15a00:	9a01      	ldr	r2, [sp, #4]
   15a02:	1996      	adds	r6, r2, r6
   15a04:	462a      	mov	r2, r5
   15a06:	18f6      	adds	r6, r6, r3
   15a08:	e7ba      	b.n	15980 <strstr+0x17c>
   15a0a:	9a03      	ldr	r2, [sp, #12]
   15a0c:	2600      	movs	r6, #0
   15a0e:	4491      	add	r9, r2
   15a10:	462a      	mov	r2, r5
   15a12:	4499      	add	r9, r3
   15a14:	e757      	b.n	158c6 <strstr+0xc2>
   15a16:	9b05      	ldr	r3, [sp, #20]
   15a18:	462a      	mov	r2, r5
   15a1a:	18f6      	adds	r6, r6, r3
   15a1c:	e7b0      	b.n	15980 <strstr+0x17c>
   15a1e:	460c      	mov	r4, r1
   15a20:	2001      	movs	r0, #1
   15a22:	e70a      	b.n	1583a <strstr+0x36>
   15a24:	465b      	mov	r3, fp
   15a26:	e792      	b.n	1594e <strstr+0x14a>
   15a28:	eb07 0609 	add.w	r6, r7, r9
   15a2c:	e708      	b.n	15840 <strstr+0x3c>
   15a2e:	bf00      	nop

00015a30 <__sprint_r>:
   15a30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15a34:	b085      	sub	sp, #20
   15a36:	4692      	mov	sl, r2
   15a38:	460c      	mov	r4, r1
   15a3a:	9003      	str	r0, [sp, #12]
   15a3c:	6890      	ldr	r0, [r2, #8]
   15a3e:	6817      	ldr	r7, [r2, #0]
   15a40:	2800      	cmp	r0, #0
   15a42:	f000 8081 	beq.w	15b48 <__sprint_r+0x118>
   15a46:	f04f 0900 	mov.w	r9, #0
   15a4a:	680b      	ldr	r3, [r1, #0]
   15a4c:	464d      	mov	r5, r9
   15a4e:	2d00      	cmp	r5, #0
   15a50:	d054      	beq.n	15afc <__sprint_r+0xcc>
   15a52:	68a6      	ldr	r6, [r4, #8]
   15a54:	42b5      	cmp	r5, r6
   15a56:	46b0      	mov	r8, r6
   15a58:	bf3e      	ittt	cc
   15a5a:	4618      	movcc	r0, r3
   15a5c:	462e      	movcc	r6, r5
   15a5e:	46a8      	movcc	r8, r5
   15a60:	d33c      	bcc.n	15adc <__sprint_r+0xac>
   15a62:	89a0      	ldrh	r0, [r4, #12]
   15a64:	f410 6f90 	tst.w	r0, #1152	; 0x480
   15a68:	bf08      	it	eq
   15a6a:	4618      	moveq	r0, r3
   15a6c:	d036      	beq.n	15adc <__sprint_r+0xac>
   15a6e:	6962      	ldr	r2, [r4, #20]
   15a70:	6921      	ldr	r1, [r4, #16]
   15a72:	eb02 0b42 	add.w	fp, r2, r2, lsl #1
   15a76:	1a5b      	subs	r3, r3, r1
   15a78:	f103 0c01 	add.w	ip, r3, #1
   15a7c:	eb0b 7bdb 	add.w	fp, fp, fp, lsr #31
   15a80:	44ac      	add	ip, r5
   15a82:	ea4f 0b6b 	mov.w	fp, fp, asr #1
   15a86:	45e3      	cmp	fp, ip
   15a88:	465a      	mov	r2, fp
   15a8a:	bf3c      	itt	cc
   15a8c:	46e3      	movcc	fp, ip
   15a8e:	465a      	movcc	r2, fp
   15a90:	f410 6f80 	tst.w	r0, #1024	; 0x400
   15a94:	d037      	beq.n	15b06 <__sprint_r+0xd6>
   15a96:	4611      	mov	r1, r2
   15a98:	9803      	ldr	r0, [sp, #12]
   15a9a:	9301      	str	r3, [sp, #4]
   15a9c:	f002 ff3e 	bl	1891c <_malloc_r>
   15aa0:	9b01      	ldr	r3, [sp, #4]
   15aa2:	2800      	cmp	r0, #0
   15aa4:	d03b      	beq.n	15b1e <__sprint_r+0xee>
   15aa6:	461a      	mov	r2, r3
   15aa8:	6921      	ldr	r1, [r4, #16]
   15aaa:	9301      	str	r3, [sp, #4]
   15aac:	9002      	str	r0, [sp, #8]
   15aae:	f7ff f979 	bl	14da4 <memcpy>
   15ab2:	89a2      	ldrh	r2, [r4, #12]
   15ab4:	9b01      	ldr	r3, [sp, #4]
   15ab6:	f8dd c008 	ldr.w	ip, [sp, #8]
   15aba:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
   15abe:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   15ac2:	81a2      	strh	r2, [r4, #12]
   15ac4:	462e      	mov	r6, r5
   15ac6:	46a8      	mov	r8, r5
   15ac8:	ebc3 020b 	rsb	r2, r3, fp
   15acc:	eb0c 0003 	add.w	r0, ip, r3
   15ad0:	60a2      	str	r2, [r4, #8]
   15ad2:	f8c4 c010 	str.w	ip, [r4, #16]
   15ad6:	6020      	str	r0, [r4, #0]
   15ad8:	f8c4 b014 	str.w	fp, [r4, #20]
   15adc:	4642      	mov	r2, r8
   15ade:	4649      	mov	r1, r9
   15ae0:	f003 fa5a 	bl	18f98 <memmove>
   15ae4:	68a2      	ldr	r2, [r4, #8]
   15ae6:	6823      	ldr	r3, [r4, #0]
   15ae8:	1b96      	subs	r6, r2, r6
   15aea:	60a6      	str	r6, [r4, #8]
   15aec:	f8da 2008 	ldr.w	r2, [sl, #8]
   15af0:	4443      	add	r3, r8
   15af2:	6023      	str	r3, [r4, #0]
   15af4:	1b55      	subs	r5, r2, r5
   15af6:	f8ca 5008 	str.w	r5, [sl, #8]
   15afa:	b1fd      	cbz	r5, 15b3c <__sprint_r+0x10c>
   15afc:	f8d7 9000 	ldr.w	r9, [r7]
   15b00:	687d      	ldr	r5, [r7, #4]
   15b02:	3708      	adds	r7, #8
   15b04:	e7a3      	b.n	15a4e <__sprint_r+0x1e>
   15b06:	9803      	ldr	r0, [sp, #12]
   15b08:	9301      	str	r3, [sp, #4]
   15b0a:	f003 ff51 	bl	199b0 <_realloc_r>
   15b0e:	9b01      	ldr	r3, [sp, #4]
   15b10:	4684      	mov	ip, r0
   15b12:	2800      	cmp	r0, #0
   15b14:	d1d6      	bne.n	15ac4 <__sprint_r+0x94>
   15b16:	9803      	ldr	r0, [sp, #12]
   15b18:	6921      	ldr	r1, [r4, #16]
   15b1a:	f002 fdd5 	bl	186c8 <_free_r>
   15b1e:	9a03      	ldr	r2, [sp, #12]
   15b20:	230c      	movs	r3, #12
   15b22:	f04f 30ff 	mov.w	r0, #4294967295
   15b26:	6013      	str	r3, [r2, #0]
   15b28:	2300      	movs	r3, #0
   15b2a:	89a2      	ldrh	r2, [r4, #12]
   15b2c:	f8ca 3004 	str.w	r3, [sl, #4]
   15b30:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   15b34:	f8ca 3008 	str.w	r3, [sl, #8]
   15b38:	81a2      	strh	r2, [r4, #12]
   15b3a:	e002      	b.n	15b42 <__sprint_r+0x112>
   15b3c:	4628      	mov	r0, r5
   15b3e:	f8ca 5004 	str.w	r5, [sl, #4]
   15b42:	b005      	add	sp, #20
   15b44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15b48:	6050      	str	r0, [r2, #4]
   15b4a:	e7fa      	b.n	15b42 <__sprint_r+0x112>

00015b4c <_svfprintf_r>:
   15b4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15b50:	b0c5      	sub	sp, #276	; 0x114
   15b52:	460e      	mov	r6, r1
   15b54:	469a      	mov	sl, r3
   15b56:	4615      	mov	r5, r2
   15b58:	9009      	str	r0, [sp, #36]	; 0x24
   15b5a:	f002 fe9b 	bl	18894 <_localeconv_r>
   15b5e:	89b3      	ldrh	r3, [r6, #12]
   15b60:	f013 0f80 	tst.w	r3, #128	; 0x80
   15b64:	6800      	ldr	r0, [r0, #0]
   15b66:	901b      	str	r0, [sp, #108]	; 0x6c
   15b68:	d003      	beq.n	15b72 <_svfprintf_r+0x26>
   15b6a:	6933      	ldr	r3, [r6, #16]
   15b6c:	2b00      	cmp	r3, #0
   15b6e:	f001 808c 	beq.w	16c8a <_svfprintf_r+0x113e>
   15b72:	f10d 0974 	add.w	r9, sp, #116	; 0x74
   15b76:	46b3      	mov	fp, r6
   15b78:	464c      	mov	r4, r9
   15b7a:	2200      	movs	r2, #0
   15b7c:	9210      	str	r2, [sp, #64]	; 0x40
   15b7e:	2300      	movs	r3, #0
   15b80:	9218      	str	r2, [sp, #96]	; 0x60
   15b82:	9217      	str	r2, [sp, #92]	; 0x5c
   15b84:	921a      	str	r2, [sp, #104]	; 0x68
   15b86:	920d      	str	r2, [sp, #52]	; 0x34
   15b88:	aa2d      	add	r2, sp, #180	; 0xb4
   15b8a:	9319      	str	r3, [sp, #100]	; 0x64
   15b8c:	3228      	adds	r2, #40	; 0x28
   15b8e:	f10d 03f7 	add.w	r3, sp, #247	; 0xf7
   15b92:	9216      	str	r2, [sp, #88]	; 0x58
   15b94:	9307      	str	r3, [sp, #28]
   15b96:	2300      	movs	r3, #0
   15b98:	f8cd 90dc 	str.w	r9, [sp, #220]	; 0xdc
   15b9c:	9338      	str	r3, [sp, #224]	; 0xe0
   15b9e:	9339      	str	r3, [sp, #228]	; 0xe4
   15ba0:	782b      	ldrb	r3, [r5, #0]
   15ba2:	f1b3 0225 	subs.w	r2, r3, #37	; 0x25
   15ba6:	bf18      	it	ne
   15ba8:	2201      	movne	r2, #1
   15baa:	2b00      	cmp	r3, #0
   15bac:	bf0c      	ite	eq
   15bae:	2200      	moveq	r2, #0
   15bb0:	f002 0201 	andne.w	r2, r2, #1
   15bb4:	b302      	cbz	r2, 15bf8 <_svfprintf_r+0xac>
   15bb6:	462e      	mov	r6, r5
   15bb8:	f816 3f01 	ldrb.w	r3, [r6, #1]!
   15bbc:	1e1a      	subs	r2, r3, #0
   15bbe:	bf18      	it	ne
   15bc0:	2201      	movne	r2, #1
   15bc2:	2b25      	cmp	r3, #37	; 0x25
   15bc4:	bf0c      	ite	eq
   15bc6:	2200      	moveq	r2, #0
   15bc8:	f002 0201 	andne.w	r2, r2, #1
   15bcc:	2a00      	cmp	r2, #0
   15bce:	d1f3      	bne.n	15bb8 <_svfprintf_r+0x6c>
   15bd0:	1b77      	subs	r7, r6, r5
   15bd2:	bf08      	it	eq
   15bd4:	4635      	moveq	r5, r6
   15bd6:	d00f      	beq.n	15bf8 <_svfprintf_r+0xac>
   15bd8:	6067      	str	r7, [r4, #4]
   15bda:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   15bdc:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   15bde:	3301      	adds	r3, #1
   15be0:	6025      	str	r5, [r4, #0]
   15be2:	19d2      	adds	r2, r2, r7
   15be4:	2b07      	cmp	r3, #7
   15be6:	9239      	str	r2, [sp, #228]	; 0xe4
   15be8:	9338      	str	r3, [sp, #224]	; 0xe0
   15bea:	dc79      	bgt.n	15ce0 <_svfprintf_r+0x194>
   15bec:	3408      	adds	r4, #8
   15bee:	980d      	ldr	r0, [sp, #52]	; 0x34
   15bf0:	4635      	mov	r5, r6
   15bf2:	19c0      	adds	r0, r0, r7
   15bf4:	900d      	str	r0, [sp, #52]	; 0x34
   15bf6:	7833      	ldrb	r3, [r6, #0]
   15bf8:	2b00      	cmp	r3, #0
   15bfa:	f000 8737 	beq.w	16a6c <_svfprintf_r+0xf20>
   15bfe:	2100      	movs	r1, #0
   15c00:	f04f 0200 	mov.w	r2, #0
   15c04:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
   15c08:	1c6b      	adds	r3, r5, #1
   15c0a:	910c      	str	r1, [sp, #48]	; 0x30
   15c0c:	f04f 38ff 	mov.w	r8, #4294967295
   15c10:	f88d 210f 	strb.w	r2, [sp, #271]	; 0x10f
   15c14:	468a      	mov	sl, r1
   15c16:	786a      	ldrb	r2, [r5, #1]
   15c18:	202b      	movs	r0, #43	; 0x2b
   15c1a:	f04f 0c20 	mov.w	ip, #32
   15c1e:	1c5d      	adds	r5, r3, #1
   15c20:	f1a2 0320 	sub.w	r3, r2, #32
   15c24:	2b58      	cmp	r3, #88	; 0x58
   15c26:	f200 8219 	bhi.w	1605c <_svfprintf_r+0x510>
   15c2a:	e8df f013 	tbh	[pc, r3, lsl #1]
   15c2e:	0229      	.short	0x0229
   15c30:	02170217 	.word	0x02170217
   15c34:	02170235 	.word	0x02170235
   15c38:	02170217 	.word	0x02170217
   15c3c:	02170217 	.word	0x02170217
   15c40:	023c0217 	.word	0x023c0217
   15c44:	02170248 	.word	0x02170248
   15c48:	02cf02c8 	.word	0x02cf02c8
   15c4c:	02ef0217 	.word	0x02ef0217
   15c50:	02f602f6 	.word	0x02f602f6
   15c54:	02f602f6 	.word	0x02f602f6
   15c58:	02f602f6 	.word	0x02f602f6
   15c5c:	02f602f6 	.word	0x02f602f6
   15c60:	021702f6 	.word	0x021702f6
   15c64:	02170217 	.word	0x02170217
   15c68:	02170217 	.word	0x02170217
   15c6c:	02170217 	.word	0x02170217
   15c70:	02170217 	.word	0x02170217
   15c74:	024f0217 	.word	0x024f0217
   15c78:	02170288 	.word	0x02170288
   15c7c:	02170288 	.word	0x02170288
   15c80:	02170217 	.word	0x02170217
   15c84:	02c10217 	.word	0x02c10217
   15c88:	02170217 	.word	0x02170217
   15c8c:	021703ee 	.word	0x021703ee
   15c90:	02170217 	.word	0x02170217
   15c94:	02170217 	.word	0x02170217
   15c98:	02170393 	.word	0x02170393
   15c9c:	03ad0217 	.word	0x03ad0217
   15ca0:	02170217 	.word	0x02170217
   15ca4:	02170217 	.word	0x02170217
   15ca8:	02170217 	.word	0x02170217
   15cac:	02170217 	.word	0x02170217
   15cb0:	02170217 	.word	0x02170217
   15cb4:	03d803c7 	.word	0x03d803c7
   15cb8:	02880288 	.word	0x02880288
   15cbc:	030b0288 	.word	0x030b0288
   15cc0:	021703d8 	.word	0x021703d8
   15cc4:	030f0217 	.word	0x030f0217
   15cc8:	03190217 	.word	0x03190217
   15ccc:	033e0329 	.word	0x033e0329
   15cd0:	0217038c 	.word	0x0217038c
   15cd4:	02170359 	.word	0x02170359
   15cd8:	02170384 	.word	0x02170384
   15cdc:	00ea0217 	.word	0x00ea0217
   15ce0:	9809      	ldr	r0, [sp, #36]	; 0x24
   15ce2:	4659      	mov	r1, fp
   15ce4:	aa37      	add	r2, sp, #220	; 0xdc
   15ce6:	f7ff fea3 	bl	15a30 <__sprint_r>
   15cea:	2800      	cmp	r0, #0
   15cec:	d17c      	bne.n	15de8 <_svfprintf_r+0x29c>
   15cee:	464c      	mov	r4, r9
   15cf0:	e77d      	b.n	15bee <_svfprintf_r+0xa2>
   15cf2:	9918      	ldr	r1, [sp, #96]	; 0x60
   15cf4:	2901      	cmp	r1, #1
   15cf6:	f340 8452 	ble.w	1659e <_svfprintf_r+0xa52>
   15cfa:	9a11      	ldr	r2, [sp, #68]	; 0x44
   15cfc:	2301      	movs	r3, #1
   15cfe:	6063      	str	r3, [r4, #4]
   15d00:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   15d02:	6022      	str	r2, [r4, #0]
   15d04:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   15d06:	3301      	adds	r3, #1
   15d08:	9338      	str	r3, [sp, #224]	; 0xe0
   15d0a:	3201      	adds	r2, #1
   15d0c:	2b07      	cmp	r3, #7
   15d0e:	9239      	str	r2, [sp, #228]	; 0xe4
   15d10:	f300 8596 	bgt.w	16840 <_svfprintf_r+0xcf4>
   15d14:	3408      	adds	r4, #8
   15d16:	2301      	movs	r3, #1
   15d18:	6063      	str	r3, [r4, #4]
   15d1a:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   15d1c:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   15d1e:	3301      	adds	r3, #1
   15d20:	981b      	ldr	r0, [sp, #108]	; 0x6c
   15d22:	3201      	adds	r2, #1
   15d24:	2b07      	cmp	r3, #7
   15d26:	9239      	str	r2, [sp, #228]	; 0xe4
   15d28:	6020      	str	r0, [r4, #0]
   15d2a:	9338      	str	r3, [sp, #224]	; 0xe0
   15d2c:	f300 857d 	bgt.w	1682a <_svfprintf_r+0xcde>
   15d30:	3408      	adds	r4, #8
   15d32:	9810      	ldr	r0, [sp, #64]	; 0x40
   15d34:	2200      	movs	r2, #0
   15d36:	2300      	movs	r3, #0
   15d38:	9919      	ldr	r1, [sp, #100]	; 0x64
   15d3a:	f004 fb7d 	bl	1a438 <__aeabi_dcmpeq>
   15d3e:	2800      	cmp	r0, #0
   15d40:	f040 8503 	bne.w	1674a <_svfprintf_r+0xbfe>
   15d44:	9918      	ldr	r1, [sp, #96]	; 0x60
   15d46:	9b11      	ldr	r3, [sp, #68]	; 0x44
   15d48:	1e4a      	subs	r2, r1, #1
   15d4a:	6062      	str	r2, [r4, #4]
   15d4c:	1c59      	adds	r1, r3, #1
   15d4e:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   15d50:	6021      	str	r1, [r4, #0]
   15d52:	9939      	ldr	r1, [sp, #228]	; 0xe4
   15d54:	3301      	adds	r3, #1
   15d56:	9338      	str	r3, [sp, #224]	; 0xe0
   15d58:	188a      	adds	r2, r1, r2
   15d5a:	2b07      	cmp	r3, #7
   15d5c:	9239      	str	r2, [sp, #228]	; 0xe4
   15d5e:	f300 842f 	bgt.w	165c0 <_svfprintf_r+0xa74>
   15d62:	3408      	adds	r4, #8
   15d64:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   15d66:	981a      	ldr	r0, [sp, #104]	; 0x68
   15d68:	6062      	str	r2, [r4, #4]
   15d6a:	aa3e      	add	r2, sp, #248	; 0xf8
   15d6c:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   15d6e:	6022      	str	r2, [r4, #0]
   15d70:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   15d72:	3301      	adds	r3, #1
   15d74:	9338      	str	r3, [sp, #224]	; 0xe0
   15d76:	1812      	adds	r2, r2, r0
   15d78:	2b07      	cmp	r3, #7
   15d7a:	9239      	str	r2, [sp, #228]	; 0xe4
   15d7c:	f300 814f 	bgt.w	1601e <_svfprintf_r+0x4d2>
   15d80:	f104 0308 	add.w	r3, r4, #8
   15d84:	f01a 0f04 	tst.w	sl, #4
   15d88:	f000 8156 	beq.w	16038 <_svfprintf_r+0x4ec>
   15d8c:	990c      	ldr	r1, [sp, #48]	; 0x30
   15d8e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   15d90:	1a8e      	subs	r6, r1, r2
   15d92:	2e00      	cmp	r6, #0
   15d94:	f340 8150 	ble.w	16038 <_svfprintf_r+0x4ec>
   15d98:	2e10      	cmp	r6, #16
   15d9a:	f244 079c 	movw	r7, #16540	; 0x409c
   15d9e:	bfd8      	it	le
   15da0:	f2c0 0702 	movtle	r7, #2
   15da4:	f340 83de 	ble.w	16564 <_svfprintf_r+0xa18>
   15da8:	2410      	movs	r4, #16
   15daa:	f2c0 0702 	movt	r7, #2
   15dae:	f10d 08dc 	add.w	r8, sp, #220	; 0xdc
   15db2:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
   15db6:	e003      	b.n	15dc0 <_svfprintf_r+0x274>
   15db8:	3e10      	subs	r6, #16
   15dba:	2e10      	cmp	r6, #16
   15dbc:	f340 83d2 	ble.w	16564 <_svfprintf_r+0xa18>
   15dc0:	605c      	str	r4, [r3, #4]
   15dc2:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   15dc4:	9939      	ldr	r1, [sp, #228]	; 0xe4
   15dc6:	3201      	adds	r2, #1
   15dc8:	601f      	str	r7, [r3, #0]
   15dca:	3110      	adds	r1, #16
   15dcc:	2a07      	cmp	r2, #7
   15dce:	9139      	str	r1, [sp, #228]	; 0xe4
   15dd0:	f103 0308 	add.w	r3, r3, #8
   15dd4:	9238      	str	r2, [sp, #224]	; 0xe0
   15dd6:	ddef      	ble.n	15db8 <_svfprintf_r+0x26c>
   15dd8:	4650      	mov	r0, sl
   15dda:	4659      	mov	r1, fp
   15ddc:	4642      	mov	r2, r8
   15dde:	f7ff fe27 	bl	15a30 <__sprint_r>
   15de2:	464b      	mov	r3, r9
   15de4:	2800      	cmp	r0, #0
   15de6:	d0e7      	beq.n	15db8 <_svfprintf_r+0x26c>
   15de8:	465e      	mov	r6, fp
   15dea:	89b3      	ldrh	r3, [r6, #12]
   15dec:	980d      	ldr	r0, [sp, #52]	; 0x34
   15dee:	f013 0f40 	tst.w	r3, #64	; 0x40
   15df2:	bf18      	it	ne
   15df4:	f04f 30ff 	movne.w	r0, #4294967295
   15df8:	900d      	str	r0, [sp, #52]	; 0x34
   15dfa:	980d      	ldr	r0, [sp, #52]	; 0x34
   15dfc:	b045      	add	sp, #276	; 0x114
   15dfe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15e02:	f01a 0f20 	tst.w	sl, #32
   15e06:	f244 00e0 	movw	r0, #16608	; 0x40e0
   15e0a:	f2c0 0002 	movt	r0, #2
   15e0e:	9214      	str	r2, [sp, #80]	; 0x50
   15e10:	9017      	str	r0, [sp, #92]	; 0x5c
   15e12:	f000 82c3 	beq.w	1639c <_svfprintf_r+0x850>
   15e16:	990a      	ldr	r1, [sp, #40]	; 0x28
   15e18:	1dcb      	adds	r3, r1, #7
   15e1a:	f023 0307 	bic.w	r3, r3, #7
   15e1e:	f103 0208 	add.w	r2, r3, #8
   15e22:	920a      	str	r2, [sp, #40]	; 0x28
   15e24:	e9d3 6700 	ldrd	r6, r7, [r3]
   15e28:	ea56 0107 	orrs.w	r1, r6, r7
   15e2c:	bf0c      	ite	eq
   15e2e:	2200      	moveq	r2, #0
   15e30:	2201      	movne	r2, #1
   15e32:	ea1a 0f02 	tst.w	sl, r2
   15e36:	f040 84bc 	bne.w	167b2 <_svfprintf_r+0xc66>
   15e3a:	2302      	movs	r3, #2
   15e3c:	f04f 0100 	mov.w	r1, #0
   15e40:	f88d 110f 	strb.w	r1, [sp, #271]	; 0x10f
   15e44:	f1b8 0f00 	cmp.w	r8, #0
   15e48:	bfa8      	it	ge
   15e4a:	f02a 0a80 	bicge.w	sl, sl, #128	; 0x80
   15e4e:	f1b8 0f00 	cmp.w	r8, #0
   15e52:	bf18      	it	ne
   15e54:	f042 0201 	orrne.w	r2, r2, #1
   15e58:	2a00      	cmp	r2, #0
   15e5a:	f000 8160 	beq.w	1611e <_svfprintf_r+0x5d2>
   15e5e:	2b01      	cmp	r3, #1
   15e60:	f000 8434 	beq.w	166cc <_svfprintf_r+0xb80>
   15e64:	2b02      	cmp	r3, #2
   15e66:	f000 8417 	beq.w	16698 <_svfprintf_r+0xb4c>
   15e6a:	9916      	ldr	r1, [sp, #88]	; 0x58
   15e6c:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
   15e70:	9111      	str	r1, [sp, #68]	; 0x44
   15e72:	ea4f 08d6 	mov.w	r8, r6, lsr #3
   15e76:	ea4f 0cd7 	mov.w	ip, r7, lsr #3
   15e7a:	ea48 7847 	orr.w	r8, r8, r7, lsl #29
   15e7e:	f006 0007 	and.w	r0, r6, #7
   15e82:	4667      	mov	r7, ip
   15e84:	4646      	mov	r6, r8
   15e86:	3030      	adds	r0, #48	; 0x30
   15e88:	ea56 0207 	orrs.w	r2, r6, r7
   15e8c:	f801 0d01 	strb.w	r0, [r1, #-1]!
   15e90:	d1ef      	bne.n	15e72 <_svfprintf_r+0x326>
   15e92:	f01a 0f01 	tst.w	sl, #1
   15e96:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
   15e9a:	9111      	str	r1, [sp, #68]	; 0x44
   15e9c:	f040 84db 	bne.w	16856 <_svfprintf_r+0xd0a>
   15ea0:	9b16      	ldr	r3, [sp, #88]	; 0x58
   15ea2:	1a5b      	subs	r3, r3, r1
   15ea4:	930e      	str	r3, [sp, #56]	; 0x38
   15ea6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   15ea8:	f8cd 8054 	str.w	r8, [sp, #84]	; 0x54
   15eac:	4543      	cmp	r3, r8
   15eae:	bfb8      	it	lt
   15eb0:	4643      	movlt	r3, r8
   15eb2:	930b      	str	r3, [sp, #44]	; 0x2c
   15eb4:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
   15eb8:	b113      	cbz	r3, 15ec0 <_svfprintf_r+0x374>
   15eba:	990b      	ldr	r1, [sp, #44]	; 0x2c
   15ebc:	3101      	adds	r1, #1
   15ebe:	910b      	str	r1, [sp, #44]	; 0x2c
   15ec0:	f01a 0202 	ands.w	r2, sl, #2
   15ec4:	9213      	str	r2, [sp, #76]	; 0x4c
   15ec6:	d002      	beq.n	15ece <_svfprintf_r+0x382>
   15ec8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15eca:	3302      	adds	r3, #2
   15ecc:	930b      	str	r3, [sp, #44]	; 0x2c
   15ece:	f01a 0084 	ands.w	r0, sl, #132	; 0x84
   15ed2:	9012      	str	r0, [sp, #72]	; 0x48
   15ed4:	d138      	bne.n	15f48 <_svfprintf_r+0x3fc>
   15ed6:	990c      	ldr	r1, [sp, #48]	; 0x30
   15ed8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   15eda:	1a8e      	subs	r6, r1, r2
   15edc:	2e00      	cmp	r6, #0
   15ede:	dd33      	ble.n	15f48 <_svfprintf_r+0x3fc>
   15ee0:	2e10      	cmp	r6, #16
   15ee2:	f244 079c 	movw	r7, #16540	; 0x409c
   15ee6:	bfd8      	it	le
   15ee8:	f2c0 0702 	movtle	r7, #2
   15eec:	dd20      	ble.n	15f30 <_svfprintf_r+0x3e4>
   15eee:	f04f 0810 	mov.w	r8, #16
   15ef2:	f2c0 0702 	movt	r7, #2
   15ef6:	e002      	b.n	15efe <_svfprintf_r+0x3b2>
   15ef8:	3e10      	subs	r6, #16
   15efa:	2e10      	cmp	r6, #16
   15efc:	dd18      	ble.n	15f30 <_svfprintf_r+0x3e4>
   15efe:	f8c4 8004 	str.w	r8, [r4, #4]
   15f02:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   15f04:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   15f06:	3301      	adds	r3, #1
   15f08:	6027      	str	r7, [r4, #0]
   15f0a:	3210      	adds	r2, #16
   15f0c:	2b07      	cmp	r3, #7
   15f0e:	9239      	str	r2, [sp, #228]	; 0xe4
   15f10:	f104 0408 	add.w	r4, r4, #8
   15f14:	9338      	str	r3, [sp, #224]	; 0xe0
   15f16:	ddef      	ble.n	15ef8 <_svfprintf_r+0x3ac>
   15f18:	9809      	ldr	r0, [sp, #36]	; 0x24
   15f1a:	4659      	mov	r1, fp
   15f1c:	aa37      	add	r2, sp, #220	; 0xdc
   15f1e:	464c      	mov	r4, r9
   15f20:	f7ff fd86 	bl	15a30 <__sprint_r>
   15f24:	2800      	cmp	r0, #0
   15f26:	f47f af5f 	bne.w	15de8 <_svfprintf_r+0x29c>
   15f2a:	3e10      	subs	r6, #16
   15f2c:	2e10      	cmp	r6, #16
   15f2e:	dce6      	bgt.n	15efe <_svfprintf_r+0x3b2>
   15f30:	6066      	str	r6, [r4, #4]
   15f32:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   15f34:	6027      	str	r7, [r4, #0]
   15f36:	1c5a      	adds	r2, r3, #1
   15f38:	9b39      	ldr	r3, [sp, #228]	; 0xe4
   15f3a:	9238      	str	r2, [sp, #224]	; 0xe0
   15f3c:	199b      	adds	r3, r3, r6
   15f3e:	2a07      	cmp	r2, #7
   15f40:	9339      	str	r3, [sp, #228]	; 0xe4
   15f42:	f300 83f7 	bgt.w	16734 <_svfprintf_r+0xbe8>
   15f46:	3408      	adds	r4, #8
   15f48:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
   15f4c:	b173      	cbz	r3, 15f6c <_svfprintf_r+0x420>
   15f4e:	2301      	movs	r3, #1
   15f50:	6063      	str	r3, [r4, #4]
   15f52:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   15f54:	aa43      	add	r2, sp, #268	; 0x10c
   15f56:	3203      	adds	r2, #3
   15f58:	6022      	str	r2, [r4, #0]
   15f5a:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   15f5c:	3301      	adds	r3, #1
   15f5e:	9338      	str	r3, [sp, #224]	; 0xe0
   15f60:	3201      	adds	r2, #1
   15f62:	2b07      	cmp	r3, #7
   15f64:	9239      	str	r2, [sp, #228]	; 0xe4
   15f66:	f300 8340 	bgt.w	165ea <_svfprintf_r+0xa9e>
   15f6a:	3408      	adds	r4, #8
   15f6c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   15f6e:	b16b      	cbz	r3, 15f8c <_svfprintf_r+0x440>
   15f70:	2302      	movs	r3, #2
   15f72:	6063      	str	r3, [r4, #4]
   15f74:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   15f76:	aa43      	add	r2, sp, #268	; 0x10c
   15f78:	6022      	str	r2, [r4, #0]
   15f7a:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   15f7c:	3301      	adds	r3, #1
   15f7e:	9338      	str	r3, [sp, #224]	; 0xe0
   15f80:	3202      	adds	r2, #2
   15f82:	2b07      	cmp	r3, #7
   15f84:	9239      	str	r2, [sp, #228]	; 0xe4
   15f86:	f300 833a 	bgt.w	165fe <_svfprintf_r+0xab2>
   15f8a:	3408      	adds	r4, #8
   15f8c:	9812      	ldr	r0, [sp, #72]	; 0x48
   15f8e:	2880      	cmp	r0, #128	; 0x80
   15f90:	f000 82b2 	beq.w	164f8 <_svfprintf_r+0x9ac>
   15f94:	9815      	ldr	r0, [sp, #84]	; 0x54
   15f96:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   15f98:	1ac6      	subs	r6, r0, r3
   15f9a:	2e00      	cmp	r6, #0
   15f9c:	dd2e      	ble.n	15ffc <_svfprintf_r+0x4b0>
   15f9e:	2e10      	cmp	r6, #16
   15fa0:	4fa7      	ldr	r7, [pc, #668]	; (16240 <_svfprintf_r+0x6f4>)
   15fa2:	bfc8      	it	gt
   15fa4:	f04f 0810 	movgt.w	r8, #16
   15fa8:	dc03      	bgt.n	15fb2 <_svfprintf_r+0x466>
   15faa:	e01b      	b.n	15fe4 <_svfprintf_r+0x498>
   15fac:	3e10      	subs	r6, #16
   15fae:	2e10      	cmp	r6, #16
   15fb0:	dd18      	ble.n	15fe4 <_svfprintf_r+0x498>
   15fb2:	f8c4 8004 	str.w	r8, [r4, #4]
   15fb6:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   15fb8:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   15fba:	3301      	adds	r3, #1
   15fbc:	6027      	str	r7, [r4, #0]
   15fbe:	3210      	adds	r2, #16
   15fc0:	2b07      	cmp	r3, #7
   15fc2:	9239      	str	r2, [sp, #228]	; 0xe4
   15fc4:	f104 0408 	add.w	r4, r4, #8
   15fc8:	9338      	str	r3, [sp, #224]	; 0xe0
   15fca:	ddef      	ble.n	15fac <_svfprintf_r+0x460>
   15fcc:	9809      	ldr	r0, [sp, #36]	; 0x24
   15fce:	4659      	mov	r1, fp
   15fd0:	aa37      	add	r2, sp, #220	; 0xdc
   15fd2:	464c      	mov	r4, r9
   15fd4:	f7ff fd2c 	bl	15a30 <__sprint_r>
   15fd8:	2800      	cmp	r0, #0
   15fda:	f47f af05 	bne.w	15de8 <_svfprintf_r+0x29c>
   15fde:	3e10      	subs	r6, #16
   15fe0:	2e10      	cmp	r6, #16
   15fe2:	dce6      	bgt.n	15fb2 <_svfprintf_r+0x466>
   15fe4:	6066      	str	r6, [r4, #4]
   15fe6:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   15fe8:	6027      	str	r7, [r4, #0]
   15fea:	1c5a      	adds	r2, r3, #1
   15fec:	9b39      	ldr	r3, [sp, #228]	; 0xe4
   15fee:	9238      	str	r2, [sp, #224]	; 0xe0
   15ff0:	199b      	adds	r3, r3, r6
   15ff2:	2a07      	cmp	r2, #7
   15ff4:	9339      	str	r3, [sp, #228]	; 0xe4
   15ff6:	f300 82ee 	bgt.w	165d6 <_svfprintf_r+0xa8a>
   15ffa:	3408      	adds	r4, #8
   15ffc:	f41a 7f80 	tst.w	sl, #256	; 0x100
   16000:	f040 8219 	bne.w	16436 <_svfprintf_r+0x8ea>
   16004:	990e      	ldr	r1, [sp, #56]	; 0x38
   16006:	9a11      	ldr	r2, [sp, #68]	; 0x44
   16008:	6061      	str	r1, [r4, #4]
   1600a:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   1600c:	6022      	str	r2, [r4, #0]
   1600e:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   16010:	3301      	adds	r3, #1
   16012:	9338      	str	r3, [sp, #224]	; 0xe0
   16014:	1852      	adds	r2, r2, r1
   16016:	2b07      	cmp	r3, #7
   16018:	9239      	str	r2, [sp, #228]	; 0xe4
   1601a:	f77f aeb1 	ble.w	15d80 <_svfprintf_r+0x234>
   1601e:	9809      	ldr	r0, [sp, #36]	; 0x24
   16020:	4659      	mov	r1, fp
   16022:	aa37      	add	r2, sp, #220	; 0xdc
   16024:	f7ff fd04 	bl	15a30 <__sprint_r>
   16028:	2800      	cmp	r0, #0
   1602a:	f47f aedd 	bne.w	15de8 <_svfprintf_r+0x29c>
   1602e:	f01a 0f04 	tst.w	sl, #4
   16032:	464b      	mov	r3, r9
   16034:	f47f aeaa 	bne.w	15d8c <_svfprintf_r+0x240>
   16038:	9b39      	ldr	r3, [sp, #228]	; 0xe4
   1603a:	980d      	ldr	r0, [sp, #52]	; 0x34
   1603c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1603e:	990c      	ldr	r1, [sp, #48]	; 0x30
   16040:	428a      	cmp	r2, r1
   16042:	bfac      	ite	ge
   16044:	1880      	addge	r0, r0, r2
   16046:	1840      	addlt	r0, r0, r1
   16048:	900d      	str	r0, [sp, #52]	; 0x34
   1604a:	2b00      	cmp	r3, #0
   1604c:	f040 829e 	bne.w	1658c <_svfprintf_r+0xa40>
   16050:	2300      	movs	r3, #0
   16052:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
   16056:	9338      	str	r3, [sp, #224]	; 0xe0
   16058:	464c      	mov	r4, r9
   1605a:	e5a1      	b.n	15ba0 <_svfprintf_r+0x54>
   1605c:	9214      	str	r2, [sp, #80]	; 0x50
   1605e:	2a00      	cmp	r2, #0
   16060:	f000 8504 	beq.w	16a6c <_svfprintf_r+0xf20>
   16064:	2001      	movs	r0, #1
   16066:	f88d 20b4 	strb.w	r2, [sp, #180]	; 0xb4
   1606a:	f04f 0100 	mov.w	r1, #0
   1606e:	aa2d      	add	r2, sp, #180	; 0xb4
   16070:	900b      	str	r0, [sp, #44]	; 0x2c
   16072:	f88d 110f 	strb.w	r1, [sp, #271]	; 0x10f
   16076:	9211      	str	r2, [sp, #68]	; 0x44
   16078:	900e      	str	r0, [sp, #56]	; 0x38
   1607a:	2100      	movs	r1, #0
   1607c:	9115      	str	r1, [sp, #84]	; 0x54
   1607e:	e71f      	b.n	15ec0 <_svfprintf_r+0x374>
   16080:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
   16084:	2b00      	cmp	r3, #0
   16086:	f040 840c 	bne.w	168a2 <_svfprintf_r+0xd56>
   1608a:	990a      	ldr	r1, [sp, #40]	; 0x28
   1608c:	462b      	mov	r3, r5
   1608e:	f88d c10f 	strb.w	ip, [sp, #271]	; 0x10f
   16092:	782a      	ldrb	r2, [r5, #0]
   16094:	910a      	str	r1, [sp, #40]	; 0x28
   16096:	e5c2      	b.n	15c1e <_svfprintf_r+0xd2>
   16098:	990a      	ldr	r1, [sp, #40]	; 0x28
   1609a:	f04a 0a01 	orr.w	sl, sl, #1
   1609e:	782a      	ldrb	r2, [r5, #0]
   160a0:	462b      	mov	r3, r5
   160a2:	910a      	str	r1, [sp, #40]	; 0x28
   160a4:	e5bb      	b.n	15c1e <_svfprintf_r+0xd2>
   160a6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   160a8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   160aa:	681b      	ldr	r3, [r3, #0]
   160ac:	1d11      	adds	r1, r2, #4
   160ae:	2b00      	cmp	r3, #0
   160b0:	930c      	str	r3, [sp, #48]	; 0x30
   160b2:	f2c0 85b2 	blt.w	16c1a <_svfprintf_r+0x10ce>
   160b6:	782a      	ldrb	r2, [r5, #0]
   160b8:	462b      	mov	r3, r5
   160ba:	910a      	str	r1, [sp, #40]	; 0x28
   160bc:	e5af      	b.n	15c1e <_svfprintf_r+0xd2>
   160be:	990a      	ldr	r1, [sp, #40]	; 0x28
   160c0:	462b      	mov	r3, r5
   160c2:	f88d 010f 	strb.w	r0, [sp, #271]	; 0x10f
   160c6:	782a      	ldrb	r2, [r5, #0]
   160c8:	910a      	str	r1, [sp, #40]	; 0x28
   160ca:	e5a8      	b.n	15c1e <_svfprintf_r+0xd2>
   160cc:	f04a 0a10 	orr.w	sl, sl, #16
   160d0:	9214      	str	r2, [sp, #80]	; 0x50
   160d2:	f01a 0f20 	tst.w	sl, #32
   160d6:	f000 8187 	beq.w	163e8 <_svfprintf_r+0x89c>
   160da:	980a      	ldr	r0, [sp, #40]	; 0x28
   160dc:	1dc3      	adds	r3, r0, #7
   160de:	f023 0307 	bic.w	r3, r3, #7
   160e2:	f103 0108 	add.w	r1, r3, #8
   160e6:	910a      	str	r1, [sp, #40]	; 0x28
   160e8:	e9d3 6700 	ldrd	r6, r7, [r3]
   160ec:	2e00      	cmp	r6, #0
   160ee:	f177 0000 	sbcs.w	r0, r7, #0
   160f2:	f2c0 8376 	blt.w	167e2 <_svfprintf_r+0xc96>
   160f6:	ea56 0107 	orrs.w	r1, r6, r7
   160fa:	f04f 0301 	mov.w	r3, #1
   160fe:	bf0c      	ite	eq
   16100:	2200      	moveq	r2, #0
   16102:	2201      	movne	r2, #1
   16104:	f1b8 0f00 	cmp.w	r8, #0
   16108:	bfa8      	it	ge
   1610a:	f02a 0a80 	bicge.w	sl, sl, #128	; 0x80
   1610e:	f1b8 0f00 	cmp.w	r8, #0
   16112:	bf18      	it	ne
   16114:	f042 0201 	orrne.w	r2, r2, #1
   16118:	2a00      	cmp	r2, #0
   1611a:	f47f aea0 	bne.w	15e5e <_svfprintf_r+0x312>
   1611e:	2b00      	cmp	r3, #0
   16120:	f040 81e5 	bne.w	164ee <_svfprintf_r+0x9a2>
   16124:	f01a 0f01 	tst.w	sl, #1
   16128:	f000 81e1 	beq.w	164ee <_svfprintf_r+0x9a2>
   1612c:	2330      	movs	r3, #48	; 0x30
   1612e:	f88d 30db 	strb.w	r3, [sp, #219]	; 0xdb
   16132:	ab2d      	add	r3, sp, #180	; 0xb4
   16134:	2001      	movs	r0, #1
   16136:	3327      	adds	r3, #39	; 0x27
   16138:	900e      	str	r0, [sp, #56]	; 0x38
   1613a:	9311      	str	r3, [sp, #68]	; 0x44
   1613c:	e6b3      	b.n	15ea6 <_svfprintf_r+0x35a>
   1613e:	f01a 0f08 	tst.w	sl, #8
   16142:	9214      	str	r2, [sp, #80]	; 0x50
   16144:	f000 83bf 	beq.w	168c6 <_svfprintf_r+0xd7a>
   16148:	980a      	ldr	r0, [sp, #40]	; 0x28
   1614a:	1dc3      	adds	r3, r0, #7
   1614c:	f023 0307 	bic.w	r3, r3, #7
   16150:	f103 0108 	add.w	r1, r3, #8
   16154:	910a      	str	r1, [sp, #40]	; 0x28
   16156:	685e      	ldr	r6, [r3, #4]
   16158:	681f      	ldr	r7, [r3, #0]
   1615a:	9619      	str	r6, [sp, #100]	; 0x64
   1615c:	9710      	str	r7, [sp, #64]	; 0x40
   1615e:	4638      	mov	r0, r7
   16160:	4631      	mov	r1, r6
   16162:	f003 fdff 	bl	19d64 <__isinfd>
   16166:	4603      	mov	r3, r0
   16168:	2800      	cmp	r0, #0
   1616a:	f000 8493 	beq.w	16a94 <_svfprintf_r+0xf48>
   1616e:	4638      	mov	r0, r7
   16170:	2200      	movs	r2, #0
   16172:	2300      	movs	r3, #0
   16174:	4631      	mov	r1, r6
   16176:	f004 f969 	bl	1a44c <__aeabi_dcmplt>
   1617a:	2800      	cmp	r0, #0
   1617c:	f040 8415 	bne.w	169aa <_svfprintf_r+0xe5e>
   16180:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
   16184:	2003      	movs	r0, #3
   16186:	f244 02d4 	movw	r2, #16596	; 0x40d4
   1618a:	f244 01d0 	movw	r1, #16592	; 0x40d0
   1618e:	900b      	str	r0, [sp, #44]	; 0x2c
   16190:	9814      	ldr	r0, [sp, #80]	; 0x50
   16192:	f2c0 0102 	movt	r1, #2
   16196:	f2c0 0202 	movt	r2, #2
   1619a:	f02a 0a80 	bic.w	sl, sl, #128	; 0x80
   1619e:	2847      	cmp	r0, #71	; 0x47
   161a0:	bfd8      	it	le
   161a2:	460a      	movle	r2, r1
   161a4:	2103      	movs	r1, #3
   161a6:	9211      	str	r2, [sp, #68]	; 0x44
   161a8:	2200      	movs	r2, #0
   161aa:	910e      	str	r1, [sp, #56]	; 0x38
   161ac:	9215      	str	r2, [sp, #84]	; 0x54
   161ae:	e683      	b.n	15eb8 <_svfprintf_r+0x36c>
   161b0:	990a      	ldr	r1, [sp, #40]	; 0x28
   161b2:	f04a 0a08 	orr.w	sl, sl, #8
   161b6:	782a      	ldrb	r2, [r5, #0]
   161b8:	462b      	mov	r3, r5
   161ba:	910a      	str	r1, [sp, #40]	; 0x28
   161bc:	e52f      	b.n	15c1e <_svfprintf_r+0xd2>
   161be:	990a      	ldr	r1, [sp, #40]	; 0x28
   161c0:	782a      	ldrb	r2, [r5, #0]
   161c2:	f04a 0a04 	orr.w	sl, sl, #4
   161c6:	462b      	mov	r3, r5
   161c8:	910a      	str	r1, [sp, #40]	; 0x28
   161ca:	e528      	b.n	15c1e <_svfprintf_r+0xd2>
   161cc:	462b      	mov	r3, r5
   161ce:	f813 2b01 	ldrb.w	r2, [r3], #1
   161d2:	2a2a      	cmp	r2, #42	; 0x2a
   161d4:	f000 86cf 	beq.w	16f76 <_svfprintf_r+0x142a>
   161d8:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
   161dc:	2909      	cmp	r1, #9
   161de:	bf88      	it	hi
   161e0:	f04f 0800 	movhi.w	r8, #0
   161e4:	d810      	bhi.n	16208 <_svfprintf_r+0x6bc>
   161e6:	3502      	adds	r5, #2
   161e8:	f04f 0800 	mov.w	r8, #0
   161ec:	f815 2c01 	ldrb.w	r2, [r5, #-1]
   161f0:	eb08 0888 	add.w	r8, r8, r8, lsl #2
   161f4:	462b      	mov	r3, r5
   161f6:	3501      	adds	r5, #1
   161f8:	eb01 0848 	add.w	r8, r1, r8, lsl #1
   161fc:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
   16200:	2909      	cmp	r1, #9
   16202:	d9f3      	bls.n	161ec <_svfprintf_r+0x6a0>
   16204:	ea48 78e8 	orr.w	r8, r8, r8, asr #31
   16208:	461d      	mov	r5, r3
   1620a:	e509      	b.n	15c20 <_svfprintf_r+0xd4>
   1620c:	990a      	ldr	r1, [sp, #40]	; 0x28
   1620e:	f04a 0a80 	orr.w	sl, sl, #128	; 0x80
   16212:	782a      	ldrb	r2, [r5, #0]
   16214:	462b      	mov	r3, r5
   16216:	910a      	str	r1, [sp, #40]	; 0x28
   16218:	e501      	b.n	15c1e <_svfprintf_r+0xd2>
   1621a:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
   1621e:	2600      	movs	r6, #0
   16220:	462b      	mov	r3, r5
   16222:	eb06 0686 	add.w	r6, r6, r6, lsl #2
   16226:	f813 2b01 	ldrb.w	r2, [r3], #1
   1622a:	eb01 0646 	add.w	r6, r1, r6, lsl #1
   1622e:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
   16232:	461d      	mov	r5, r3
   16234:	2909      	cmp	r1, #9
   16236:	d9f3      	bls.n	16220 <_svfprintf_r+0x6d4>
   16238:	960c      	str	r6, [sp, #48]	; 0x30
   1623a:	461d      	mov	r5, r3
   1623c:	e4f0      	b.n	15c20 <_svfprintf_r+0xd4>
   1623e:	bf00      	nop
   16240:	000240ac 	.word	0x000240ac
   16244:	f04a 0a40 	orr.w	sl, sl, #64	; 0x40
   16248:	990a      	ldr	r1, [sp, #40]	; 0x28
   1624a:	e734      	b.n	160b6 <_svfprintf_r+0x56a>
   1624c:	782a      	ldrb	r2, [r5, #0]
   1624e:	2a6c      	cmp	r2, #108	; 0x6c
   16250:	f000 8418 	beq.w	16a84 <_svfprintf_r+0xf38>
   16254:	990a      	ldr	r1, [sp, #40]	; 0x28
   16256:	f04a 0a10 	orr.w	sl, sl, #16
   1625a:	462b      	mov	r3, r5
   1625c:	910a      	str	r1, [sp, #40]	; 0x28
   1625e:	e4de      	b.n	15c1e <_svfprintf_r+0xd2>
   16260:	f01a 0f20 	tst.w	sl, #32
   16264:	f000 8323 	beq.w	168ae <_svfprintf_r+0xd62>
   16268:	990a      	ldr	r1, [sp, #40]	; 0x28
   1626a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   1626c:	680b      	ldr	r3, [r1, #0]
   1626e:	4610      	mov	r0, r2
   16270:	ea4f 71e0 	mov.w	r1, r0, asr #31
   16274:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   16276:	e9c3 0100 	strd	r0, r1, [r3]
   1627a:	f102 0a04 	add.w	sl, r2, #4
   1627e:	e48f      	b.n	15ba0 <_svfprintf_r+0x54>
   16280:	f01a 0320 	ands.w	r3, sl, #32
   16284:	9214      	str	r2, [sp, #80]	; 0x50
   16286:	f000 80c7 	beq.w	16418 <_svfprintf_r+0x8cc>
   1628a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1628c:	1dda      	adds	r2, r3, #7
   1628e:	2300      	movs	r3, #0
   16290:	f022 0207 	bic.w	r2, r2, #7
   16294:	f102 0008 	add.w	r0, r2, #8
   16298:	900a      	str	r0, [sp, #40]	; 0x28
   1629a:	e9d2 6700 	ldrd	r6, r7, [r2]
   1629e:	ea56 0107 	orrs.w	r1, r6, r7
   162a2:	bf0c      	ite	eq
   162a4:	2200      	moveq	r2, #0
   162a6:	2201      	movne	r2, #1
   162a8:	e5c8      	b.n	15e3c <_svfprintf_r+0x2f0>
   162aa:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   162ac:	f244 00e0 	movw	r0, #16608	; 0x40e0
   162b0:	990a      	ldr	r1, [sp, #40]	; 0x28
   162b2:	2378      	movs	r3, #120	; 0x78
   162b4:	f2c0 0002 	movt	r0, #2
   162b8:	9314      	str	r3, [sp, #80]	; 0x50
   162ba:	6816      	ldr	r6, [r2, #0]
   162bc:	3104      	adds	r1, #4
   162be:	f88d 310d 	strb.w	r3, [sp, #269]	; 0x10d
   162c2:	f04a 0a02 	orr.w	sl, sl, #2
   162c6:	2330      	movs	r3, #48	; 0x30
   162c8:	1e32      	subs	r2, r6, #0
   162ca:	bf18      	it	ne
   162cc:	2201      	movne	r2, #1
   162ce:	f88d 310c 	strb.w	r3, [sp, #268]	; 0x10c
   162d2:	4636      	mov	r6, r6
   162d4:	f04f 0700 	mov.w	r7, #0
   162d8:	9017      	str	r0, [sp, #92]	; 0x5c
   162da:	2302      	movs	r3, #2
   162dc:	910a      	str	r1, [sp, #40]	; 0x28
   162de:	e5ad      	b.n	15e3c <_svfprintf_r+0x2f0>
   162e0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   162e2:	9214      	str	r2, [sp, #80]	; 0x50
   162e4:	f04f 0200 	mov.w	r2, #0
   162e8:	1d18      	adds	r0, r3, #4
   162ea:	f88d 210f 	strb.w	r2, [sp, #271]	; 0x10f
   162ee:	681b      	ldr	r3, [r3, #0]
   162f0:	900a      	str	r0, [sp, #40]	; 0x28
   162f2:	9311      	str	r3, [sp, #68]	; 0x44
   162f4:	2b00      	cmp	r3, #0
   162f6:	f000 854d 	beq.w	16d94 <_svfprintf_r+0x1248>
   162fa:	f1b8 0f00 	cmp.w	r8, #0
   162fe:	9811      	ldr	r0, [sp, #68]	; 0x44
   16300:	f2c0 852a 	blt.w	16d58 <_svfprintf_r+0x120c>
   16304:	2100      	movs	r1, #0
   16306:	4642      	mov	r2, r8
   16308:	f002 fdda 	bl	18ec0 <memchr>
   1630c:	4603      	mov	r3, r0
   1630e:	2800      	cmp	r0, #0
   16310:	f000 856e 	beq.w	16df0 <_svfprintf_r+0x12a4>
   16314:	9811      	ldr	r0, [sp, #68]	; 0x44
   16316:	1a1b      	subs	r3, r3, r0
   16318:	930e      	str	r3, [sp, #56]	; 0x38
   1631a:	4543      	cmp	r3, r8
   1631c:	f340 8482 	ble.w	16c24 <_svfprintf_r+0x10d8>
   16320:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
   16324:	2100      	movs	r1, #0
   16326:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
   1632a:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
   1632e:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
   16332:	9115      	str	r1, [sp, #84]	; 0x54
   16334:	e5c0      	b.n	15eb8 <_svfprintf_r+0x36c>
   16336:	f01a 0f20 	tst.w	sl, #32
   1633a:	9214      	str	r2, [sp, #80]	; 0x50
   1633c:	d010      	beq.n	16360 <_svfprintf_r+0x814>
   1633e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16340:	1dda      	adds	r2, r3, #7
   16342:	2301      	movs	r3, #1
   16344:	e7a4      	b.n	16290 <_svfprintf_r+0x744>
   16346:	990a      	ldr	r1, [sp, #40]	; 0x28
   16348:	f04a 0a20 	orr.w	sl, sl, #32
   1634c:	782a      	ldrb	r2, [r5, #0]
   1634e:	462b      	mov	r3, r5
   16350:	910a      	str	r1, [sp, #40]	; 0x28
   16352:	e464      	b.n	15c1e <_svfprintf_r+0xd2>
   16354:	f04a 0a10 	orr.w	sl, sl, #16
   16358:	9214      	str	r2, [sp, #80]	; 0x50
   1635a:	f01a 0f20 	tst.w	sl, #32
   1635e:	d1ee      	bne.n	1633e <_svfprintf_r+0x7f2>
   16360:	f01a 0f10 	tst.w	sl, #16
   16364:	f040 8254 	bne.w	16810 <_svfprintf_r+0xcc4>
   16368:	f01a 0f40 	tst.w	sl, #64	; 0x40
   1636c:	f000 8250 	beq.w	16810 <_svfprintf_r+0xcc4>
   16370:	980a      	ldr	r0, [sp, #40]	; 0x28
   16372:	2301      	movs	r3, #1
   16374:	1d01      	adds	r1, r0, #4
   16376:	910a      	str	r1, [sp, #40]	; 0x28
   16378:	8806      	ldrh	r6, [r0, #0]
   1637a:	1e32      	subs	r2, r6, #0
   1637c:	bf18      	it	ne
   1637e:	2201      	movne	r2, #1
   16380:	4636      	mov	r6, r6
   16382:	f04f 0700 	mov.w	r7, #0
   16386:	e559      	b.n	15e3c <_svfprintf_r+0x2f0>
   16388:	f01a 0f20 	tst.w	sl, #32
   1638c:	9214      	str	r2, [sp, #80]	; 0x50
   1638e:	f244 02bc 	movw	r2, #16572	; 0x40bc
   16392:	f2c0 0202 	movt	r2, #2
   16396:	9217      	str	r2, [sp, #92]	; 0x5c
   16398:	f47f ad3d 	bne.w	15e16 <_svfprintf_r+0x2ca>
   1639c:	f01a 0f10 	tst.w	sl, #16
   163a0:	f040 822d 	bne.w	167fe <_svfprintf_r+0xcb2>
   163a4:	f01a 0f40 	tst.w	sl, #64	; 0x40
   163a8:	f000 8229 	beq.w	167fe <_svfprintf_r+0xcb2>
   163ac:	990a      	ldr	r1, [sp, #40]	; 0x28
   163ae:	1d0a      	adds	r2, r1, #4
   163b0:	920a      	str	r2, [sp, #40]	; 0x28
   163b2:	880e      	ldrh	r6, [r1, #0]
   163b4:	4636      	mov	r6, r6
   163b6:	f04f 0700 	mov.w	r7, #0
   163ba:	e535      	b.n	15e28 <_svfprintf_r+0x2dc>
   163bc:	9214      	str	r2, [sp, #80]	; 0x50
   163be:	2001      	movs	r0, #1
   163c0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   163c2:	f04f 0100 	mov.w	r1, #0
   163c6:	900b      	str	r0, [sp, #44]	; 0x2c
   163c8:	900e      	str	r0, [sp, #56]	; 0x38
   163ca:	6813      	ldr	r3, [r2, #0]
   163cc:	3204      	adds	r2, #4
   163ce:	f88d 110f 	strb.w	r1, [sp, #271]	; 0x10f
   163d2:	920a      	str	r2, [sp, #40]	; 0x28
   163d4:	aa2d      	add	r2, sp, #180	; 0xb4
   163d6:	f88d 30b4 	strb.w	r3, [sp, #180]	; 0xb4
   163da:	9211      	str	r2, [sp, #68]	; 0x44
   163dc:	e64d      	b.n	1607a <_svfprintf_r+0x52e>
   163de:	f01a 0f20 	tst.w	sl, #32
   163e2:	9214      	str	r2, [sp, #80]	; 0x50
   163e4:	f47f ae79 	bne.w	160da <_svfprintf_r+0x58e>
   163e8:	f01a 0f10 	tst.w	sl, #16
   163ec:	f040 81ed 	bne.w	167ca <_svfprintf_r+0xc7e>
   163f0:	f01a 0f40 	tst.w	sl, #64	; 0x40
   163f4:	f000 81e9 	beq.w	167ca <_svfprintf_r+0xc7e>
   163f8:	980a      	ldr	r0, [sp, #40]	; 0x28
   163fa:	1d01      	adds	r1, r0, #4
   163fc:	910a      	str	r1, [sp, #40]	; 0x28
   163fe:	f9b0 6000 	ldrsh.w	r6, [r0]
   16402:	4636      	mov	r6, r6
   16404:	ea4f 77e6 	mov.w	r7, r6, asr #31
   16408:	e670      	b.n	160ec <_svfprintf_r+0x5a0>
   1640a:	f04a 0a10 	orr.w	sl, sl, #16
   1640e:	9214      	str	r2, [sp, #80]	; 0x50
   16410:	f01a 0320 	ands.w	r3, sl, #32
   16414:	f47f af39 	bne.w	1628a <_svfprintf_r+0x73e>
   16418:	f01a 0210 	ands.w	r2, sl, #16
   1641c:	f000 825f 	beq.w	168de <_svfprintf_r+0xd92>
   16420:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   16422:	1d10      	adds	r0, r2, #4
   16424:	900a      	str	r0, [sp, #40]	; 0x28
   16426:	6816      	ldr	r6, [r2, #0]
   16428:	1e32      	subs	r2, r6, #0
   1642a:	bf18      	it	ne
   1642c:	2201      	movne	r2, #1
   1642e:	4636      	mov	r6, r6
   16430:	f04f 0700 	mov.w	r7, #0
   16434:	e502      	b.n	15e3c <_svfprintf_r+0x2f0>
   16436:	9b14      	ldr	r3, [sp, #80]	; 0x50
   16438:	2b65      	cmp	r3, #101	; 0x65
   1643a:	f77f ac5a 	ble.w	15cf2 <_svfprintf_r+0x1a6>
   1643e:	9810      	ldr	r0, [sp, #64]	; 0x40
   16440:	2200      	movs	r2, #0
   16442:	2300      	movs	r3, #0
   16444:	9919      	ldr	r1, [sp, #100]	; 0x64
   16446:	f003 fff7 	bl	1a438 <__aeabi_dcmpeq>
   1644a:	2800      	cmp	r0, #0
   1644c:	f000 80e1 	beq.w	16612 <_svfprintf_r+0xac6>
   16450:	2301      	movs	r3, #1
   16452:	6063      	str	r3, [r4, #4]
   16454:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   16456:	f244 03fc 	movw	r3, #16636	; 0x40fc
   1645a:	f2c0 0302 	movt	r3, #2
   1645e:	6023      	str	r3, [r4, #0]
   16460:	9b39      	ldr	r3, [sp, #228]	; 0xe4
   16462:	3201      	adds	r2, #1
   16464:	9238      	str	r2, [sp, #224]	; 0xe0
   16466:	3301      	adds	r3, #1
   16468:	2a07      	cmp	r2, #7
   1646a:	9339      	str	r3, [sp, #228]	; 0xe4
   1646c:	bfd8      	it	le
   1646e:	f104 0308 	addle.w	r3, r4, #8
   16472:	f300 829f 	bgt.w	169b4 <_svfprintf_r+0xe68>
   16476:	9a42      	ldr	r2, [sp, #264]	; 0x108
   16478:	9818      	ldr	r0, [sp, #96]	; 0x60
   1647a:	4282      	cmp	r2, r0
   1647c:	db03      	blt.n	16486 <_svfprintf_r+0x93a>
   1647e:	f01a 0f01 	tst.w	sl, #1
   16482:	f43f ac7f 	beq.w	15d84 <_svfprintf_r+0x238>
   16486:	991b      	ldr	r1, [sp, #108]	; 0x6c
   16488:	2201      	movs	r2, #1
   1648a:	605a      	str	r2, [r3, #4]
   1648c:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   1648e:	6019      	str	r1, [r3, #0]
   16490:	9939      	ldr	r1, [sp, #228]	; 0xe4
   16492:	3201      	adds	r2, #1
   16494:	9238      	str	r2, [sp, #224]	; 0xe0
   16496:	3101      	adds	r1, #1
   16498:	2a07      	cmp	r2, #7
   1649a:	9139      	str	r1, [sp, #228]	; 0xe4
   1649c:	f300 83eb 	bgt.w	16c76 <_svfprintf_r+0x112a>
   164a0:	3308      	adds	r3, #8
   164a2:	9a18      	ldr	r2, [sp, #96]	; 0x60
   164a4:	1e56      	subs	r6, r2, #1
   164a6:	2e00      	cmp	r6, #0
   164a8:	f77f ac6c 	ble.w	15d84 <_svfprintf_r+0x238>
   164ac:	2e10      	cmp	r6, #16
   164ae:	4fa0      	ldr	r7, [pc, #640]	; (16730 <_svfprintf_r+0xbe4>)
   164b0:	f340 81e9 	ble.w	16886 <_svfprintf_r+0xd3a>
   164b4:	2410      	movs	r4, #16
   164b6:	f10d 08dc 	add.w	r8, sp, #220	; 0xdc
   164ba:	e003      	b.n	164c4 <_svfprintf_r+0x978>
   164bc:	3e10      	subs	r6, #16
   164be:	2e10      	cmp	r6, #16
   164c0:	f340 81e1 	ble.w	16886 <_svfprintf_r+0xd3a>
   164c4:	605c      	str	r4, [r3, #4]
   164c6:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   164c8:	9939      	ldr	r1, [sp, #228]	; 0xe4
   164ca:	3201      	adds	r2, #1
   164cc:	601f      	str	r7, [r3, #0]
   164ce:	3110      	adds	r1, #16
   164d0:	2a07      	cmp	r2, #7
   164d2:	9139      	str	r1, [sp, #228]	; 0xe4
   164d4:	f103 0308 	add.w	r3, r3, #8
   164d8:	9238      	str	r2, [sp, #224]	; 0xe0
   164da:	ddef      	ble.n	164bc <_svfprintf_r+0x970>
   164dc:	9809      	ldr	r0, [sp, #36]	; 0x24
   164de:	4659      	mov	r1, fp
   164e0:	4642      	mov	r2, r8
   164e2:	f7ff faa5 	bl	15a30 <__sprint_r>
   164e6:	464b      	mov	r3, r9
   164e8:	2800      	cmp	r0, #0
   164ea:	d0e7      	beq.n	164bc <_svfprintf_r+0x970>
   164ec:	e47c      	b.n	15de8 <_svfprintf_r+0x29c>
   164ee:	9916      	ldr	r1, [sp, #88]	; 0x58
   164f0:	2200      	movs	r2, #0
   164f2:	920e      	str	r2, [sp, #56]	; 0x38
   164f4:	9111      	str	r1, [sp, #68]	; 0x44
   164f6:	e4d6      	b.n	15ea6 <_svfprintf_r+0x35a>
   164f8:	990c      	ldr	r1, [sp, #48]	; 0x30
   164fa:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   164fc:	1a8e      	subs	r6, r1, r2
   164fe:	2e00      	cmp	r6, #0
   16500:	f77f ad48 	ble.w	15f94 <_svfprintf_r+0x448>
   16504:	2e10      	cmp	r6, #16
   16506:	4f8a      	ldr	r7, [pc, #552]	; (16730 <_svfprintf_r+0xbe4>)
   16508:	bfc8      	it	gt
   1650a:	f04f 0810 	movgt.w	r8, #16
   1650e:	dc03      	bgt.n	16518 <_svfprintf_r+0x9cc>
   16510:	e01b      	b.n	1654a <_svfprintf_r+0x9fe>
   16512:	3e10      	subs	r6, #16
   16514:	2e10      	cmp	r6, #16
   16516:	dd18      	ble.n	1654a <_svfprintf_r+0x9fe>
   16518:	f8c4 8004 	str.w	r8, [r4, #4]
   1651c:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   1651e:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   16520:	3301      	adds	r3, #1
   16522:	6027      	str	r7, [r4, #0]
   16524:	3210      	adds	r2, #16
   16526:	2b07      	cmp	r3, #7
   16528:	9239      	str	r2, [sp, #228]	; 0xe4
   1652a:	f104 0408 	add.w	r4, r4, #8
   1652e:	9338      	str	r3, [sp, #224]	; 0xe0
   16530:	ddef      	ble.n	16512 <_svfprintf_r+0x9c6>
   16532:	9809      	ldr	r0, [sp, #36]	; 0x24
   16534:	4659      	mov	r1, fp
   16536:	aa37      	add	r2, sp, #220	; 0xdc
   16538:	464c      	mov	r4, r9
   1653a:	f7ff fa79 	bl	15a30 <__sprint_r>
   1653e:	2800      	cmp	r0, #0
   16540:	f47f ac52 	bne.w	15de8 <_svfprintf_r+0x29c>
   16544:	3e10      	subs	r6, #16
   16546:	2e10      	cmp	r6, #16
   16548:	dce6      	bgt.n	16518 <_svfprintf_r+0x9cc>
   1654a:	6066      	str	r6, [r4, #4]
   1654c:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   1654e:	6027      	str	r7, [r4, #0]
   16550:	1c5a      	adds	r2, r3, #1
   16552:	9b39      	ldr	r3, [sp, #228]	; 0xe4
   16554:	9238      	str	r2, [sp, #224]	; 0xe0
   16556:	199b      	adds	r3, r3, r6
   16558:	2a07      	cmp	r2, #7
   1655a:	9339      	str	r3, [sp, #228]	; 0xe4
   1655c:	f300 8188 	bgt.w	16870 <_svfprintf_r+0xd24>
   16560:	3408      	adds	r4, #8
   16562:	e517      	b.n	15f94 <_svfprintf_r+0x448>
   16564:	605e      	str	r6, [r3, #4]
   16566:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   16568:	601f      	str	r7, [r3, #0]
   1656a:	9b39      	ldr	r3, [sp, #228]	; 0xe4
   1656c:	3201      	adds	r2, #1
   1656e:	9238      	str	r2, [sp, #224]	; 0xe0
   16570:	18f3      	adds	r3, r6, r3
   16572:	2a07      	cmp	r2, #7
   16574:	9339      	str	r3, [sp, #228]	; 0xe4
   16576:	f77f ad60 	ble.w	1603a <_svfprintf_r+0x4ee>
   1657a:	9809      	ldr	r0, [sp, #36]	; 0x24
   1657c:	4659      	mov	r1, fp
   1657e:	aa37      	add	r2, sp, #220	; 0xdc
   16580:	f7ff fa56 	bl	15a30 <__sprint_r>
   16584:	2800      	cmp	r0, #0
   16586:	f43f ad57 	beq.w	16038 <_svfprintf_r+0x4ec>
   1658a:	e42d      	b.n	15de8 <_svfprintf_r+0x29c>
   1658c:	9809      	ldr	r0, [sp, #36]	; 0x24
   1658e:	4659      	mov	r1, fp
   16590:	aa37      	add	r2, sp, #220	; 0xdc
   16592:	f7ff fa4d 	bl	15a30 <__sprint_r>
   16596:	2800      	cmp	r0, #0
   16598:	f43f ad5a 	beq.w	16050 <_svfprintf_r+0x504>
   1659c:	e424      	b.n	15de8 <_svfprintf_r+0x29c>
   1659e:	f01a 0f01 	tst.w	sl, #1
   165a2:	f47f abaa 	bne.w	15cfa <_svfprintf_r+0x1ae>
   165a6:	2301      	movs	r3, #1
   165a8:	6063      	str	r3, [r4, #4]
   165aa:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   165ac:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   165ae:	3301      	adds	r3, #1
   165b0:	9911      	ldr	r1, [sp, #68]	; 0x44
   165b2:	3201      	adds	r2, #1
   165b4:	2b07      	cmp	r3, #7
   165b6:	9239      	str	r2, [sp, #228]	; 0xe4
   165b8:	6021      	str	r1, [r4, #0]
   165ba:	9338      	str	r3, [sp, #224]	; 0xe0
   165bc:	f77f abd1 	ble.w	15d62 <_svfprintf_r+0x216>
   165c0:	9809      	ldr	r0, [sp, #36]	; 0x24
   165c2:	4659      	mov	r1, fp
   165c4:	aa37      	add	r2, sp, #220	; 0xdc
   165c6:	f7ff fa33 	bl	15a30 <__sprint_r>
   165ca:	2800      	cmp	r0, #0
   165cc:	f47f ac0c 	bne.w	15de8 <_svfprintf_r+0x29c>
   165d0:	464c      	mov	r4, r9
   165d2:	f7ff bbc7 	b.w	15d64 <_svfprintf_r+0x218>
   165d6:	9809      	ldr	r0, [sp, #36]	; 0x24
   165d8:	4659      	mov	r1, fp
   165da:	aa37      	add	r2, sp, #220	; 0xdc
   165dc:	f7ff fa28 	bl	15a30 <__sprint_r>
   165e0:	2800      	cmp	r0, #0
   165e2:	f47f ac01 	bne.w	15de8 <_svfprintf_r+0x29c>
   165e6:	464c      	mov	r4, r9
   165e8:	e508      	b.n	15ffc <_svfprintf_r+0x4b0>
   165ea:	9809      	ldr	r0, [sp, #36]	; 0x24
   165ec:	4659      	mov	r1, fp
   165ee:	aa37      	add	r2, sp, #220	; 0xdc
   165f0:	f7ff fa1e 	bl	15a30 <__sprint_r>
   165f4:	2800      	cmp	r0, #0
   165f6:	f47f abf7 	bne.w	15de8 <_svfprintf_r+0x29c>
   165fa:	464c      	mov	r4, r9
   165fc:	e4b6      	b.n	15f6c <_svfprintf_r+0x420>
   165fe:	9809      	ldr	r0, [sp, #36]	; 0x24
   16600:	4659      	mov	r1, fp
   16602:	aa37      	add	r2, sp, #220	; 0xdc
   16604:	f7ff fa14 	bl	15a30 <__sprint_r>
   16608:	2800      	cmp	r0, #0
   1660a:	f47f abed 	bne.w	15de8 <_svfprintf_r+0x29c>
   1660e:	464c      	mov	r4, r9
   16610:	e4bc      	b.n	15f8c <_svfprintf_r+0x440>
   16612:	9b42      	ldr	r3, [sp, #264]	; 0x108
   16614:	2b00      	cmp	r3, #0
   16616:	f340 81d9 	ble.w	169cc <_svfprintf_r+0xe80>
   1661a:	9918      	ldr	r1, [sp, #96]	; 0x60
   1661c:	428b      	cmp	r3, r1
   1661e:	f2c0 816f 	blt.w	16900 <_svfprintf_r+0xdb4>
   16622:	9a11      	ldr	r2, [sp, #68]	; 0x44
   16624:	6061      	str	r1, [r4, #4]
   16626:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   16628:	6022      	str	r2, [r4, #0]
   1662a:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   1662c:	3301      	adds	r3, #1
   1662e:	9338      	str	r3, [sp, #224]	; 0xe0
   16630:	1852      	adds	r2, r2, r1
   16632:	2b07      	cmp	r3, #7
   16634:	9239      	str	r2, [sp, #228]	; 0xe4
   16636:	bfd8      	it	le
   16638:	f104 0308 	addle.w	r3, r4, #8
   1663c:	f300 83ba 	bgt.w	16db4 <_svfprintf_r+0x1268>
   16640:	9c42      	ldr	r4, [sp, #264]	; 0x108
   16642:	9818      	ldr	r0, [sp, #96]	; 0x60
   16644:	1a24      	subs	r4, r4, r0
   16646:	2c00      	cmp	r4, #0
   16648:	f340 819b 	ble.w	16982 <_svfprintf_r+0xe36>
   1664c:	2c10      	cmp	r4, #16
   1664e:	4f38      	ldr	r7, [pc, #224]	; (16730 <_svfprintf_r+0xbe4>)
   16650:	f340 818b 	ble.w	1696a <_svfprintf_r+0xe1e>
   16654:	f8cd a038 	str.w	sl, [sp, #56]	; 0x38
   16658:	2610      	movs	r6, #16
   1665a:	46aa      	mov	sl, r5
   1665c:	f10d 08dc 	add.w	r8, sp, #220	; 0xdc
   16660:	9d09      	ldr	r5, [sp, #36]	; 0x24
   16662:	e003      	b.n	1666c <_svfprintf_r+0xb20>
   16664:	3c10      	subs	r4, #16
   16666:	2c10      	cmp	r4, #16
   16668:	f340 817c 	ble.w	16964 <_svfprintf_r+0xe18>
   1666c:	605e      	str	r6, [r3, #4]
   1666e:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   16670:	9939      	ldr	r1, [sp, #228]	; 0xe4
   16672:	3201      	adds	r2, #1
   16674:	601f      	str	r7, [r3, #0]
   16676:	3110      	adds	r1, #16
   16678:	2a07      	cmp	r2, #7
   1667a:	9139      	str	r1, [sp, #228]	; 0xe4
   1667c:	f103 0308 	add.w	r3, r3, #8
   16680:	9238      	str	r2, [sp, #224]	; 0xe0
   16682:	ddef      	ble.n	16664 <_svfprintf_r+0xb18>
   16684:	4628      	mov	r0, r5
   16686:	4659      	mov	r1, fp
   16688:	4642      	mov	r2, r8
   1668a:	f7ff f9d1 	bl	15a30 <__sprint_r>
   1668e:	464b      	mov	r3, r9
   16690:	2800      	cmp	r0, #0
   16692:	d0e7      	beq.n	16664 <_svfprintf_r+0xb18>
   16694:	f7ff bba8 	b.w	15de8 <_svfprintf_r+0x29c>
   16698:	9816      	ldr	r0, [sp, #88]	; 0x58
   1669a:	f8dd c05c 	ldr.w	ip, [sp, #92]	; 0x5c
   1669e:	4603      	mov	r3, r0
   166a0:	9011      	str	r0, [sp, #68]	; 0x44
   166a2:	0931      	lsrs	r1, r6, #4
   166a4:	f006 020f 	and.w	r2, r6, #15
   166a8:	ea41 7107 	orr.w	r1, r1, r7, lsl #28
   166ac:	0938      	lsrs	r0, r7, #4
   166ae:	f81c 2002 	ldrb.w	r2, [ip, r2]
   166b2:	460e      	mov	r6, r1
   166b4:	4607      	mov	r7, r0
   166b6:	ea56 0107 	orrs.w	r1, r6, r7
   166ba:	f803 2d01 	strb.w	r2, [r3, #-1]!
   166be:	d1f0      	bne.n	166a2 <_svfprintf_r+0xb56>
   166c0:	9a16      	ldr	r2, [sp, #88]	; 0x58
   166c2:	9311      	str	r3, [sp, #68]	; 0x44
   166c4:	1ad2      	subs	r2, r2, r3
   166c6:	920e      	str	r2, [sp, #56]	; 0x38
   166c8:	f7ff bbed 	b.w	15ea6 <_svfprintf_r+0x35a>
   166cc:	2300      	movs	r3, #0
   166ce:	2209      	movs	r2, #9
   166d0:	42b2      	cmp	r2, r6
   166d2:	eb73 0007 	sbcs.w	r0, r3, r7
   166d6:	9b16      	ldr	r3, [sp, #88]	; 0x58
   166d8:	bf3e      	ittt	cc
   166da:	f8cd 802c 	strcc.w	r8, [sp, #44]	; 0x2c
   166de:	46a0      	movcc	r8, r4
   166e0:	461c      	movcc	r4, r3
   166e2:	d21a      	bcs.n	1671a <_svfprintf_r+0xbce>
   166e4:	4630      	mov	r0, r6
   166e6:	4639      	mov	r1, r7
   166e8:	220a      	movs	r2, #10
   166ea:	2300      	movs	r3, #0
   166ec:	f003 fefe 	bl	1a4ec <__aeabi_uldivmod>
   166f0:	4630      	mov	r0, r6
   166f2:	4639      	mov	r1, r7
   166f4:	2300      	movs	r3, #0
   166f6:	f102 0c30 	add.w	ip, r2, #48	; 0x30
   166fa:	220a      	movs	r2, #10
   166fc:	f804 cd01 	strb.w	ip, [r4, #-1]!
   16700:	f003 fef4 	bl	1a4ec <__aeabi_uldivmod>
   16704:	4606      	mov	r6, r0
   16706:	460f      	mov	r7, r1
   16708:	2009      	movs	r0, #9
   1670a:	2100      	movs	r1, #0
   1670c:	42b0      	cmp	r0, r6
   1670e:	41b9      	sbcs	r1, r7
   16710:	d3e8      	bcc.n	166e4 <_svfprintf_r+0xb98>
   16712:	4623      	mov	r3, r4
   16714:	4644      	mov	r4, r8
   16716:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
   1671a:	1e5a      	subs	r2, r3, #1
   1671c:	3630      	adds	r6, #48	; 0x30
   1671e:	9211      	str	r2, [sp, #68]	; 0x44
   16720:	f803 6c01 	strb.w	r6, [r3, #-1]
   16724:	9b16      	ldr	r3, [sp, #88]	; 0x58
   16726:	1a9b      	subs	r3, r3, r2
   16728:	930e      	str	r3, [sp, #56]	; 0x38
   1672a:	f7ff bbbc 	b.w	15ea6 <_svfprintf_r+0x35a>
   1672e:	bf00      	nop
   16730:	000240ac 	.word	0x000240ac
   16734:	9809      	ldr	r0, [sp, #36]	; 0x24
   16736:	4659      	mov	r1, fp
   16738:	aa37      	add	r2, sp, #220	; 0xdc
   1673a:	f7ff f979 	bl	15a30 <__sprint_r>
   1673e:	2800      	cmp	r0, #0
   16740:	f47f ab52 	bne.w	15de8 <_svfprintf_r+0x29c>
   16744:	464c      	mov	r4, r9
   16746:	f7ff bbff 	b.w	15f48 <_svfprintf_r+0x3fc>
   1674a:	9818      	ldr	r0, [sp, #96]	; 0x60
   1674c:	1e46      	subs	r6, r0, #1
   1674e:	2e00      	cmp	r6, #0
   16750:	f77f ab08 	ble.w	15d64 <_svfprintf_r+0x218>
   16754:	2e10      	cmp	r6, #16
   16756:	4f9c      	ldr	r7, [pc, #624]	; (169c8 <_svfprintf_r+0xe7c>)
   16758:	bfc8      	it	gt
   1675a:	f04f 0810 	movgt.w	r8, #16
   1675e:	dc03      	bgt.n	16768 <_svfprintf_r+0xc1c>
   16760:	e01b      	b.n	1679a <_svfprintf_r+0xc4e>
   16762:	3e10      	subs	r6, #16
   16764:	2e10      	cmp	r6, #16
   16766:	dd18      	ble.n	1679a <_svfprintf_r+0xc4e>
   16768:	f8c4 8004 	str.w	r8, [r4, #4]
   1676c:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   1676e:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   16770:	3301      	adds	r3, #1
   16772:	6027      	str	r7, [r4, #0]
   16774:	3210      	adds	r2, #16
   16776:	2b07      	cmp	r3, #7
   16778:	9239      	str	r2, [sp, #228]	; 0xe4
   1677a:	f104 0408 	add.w	r4, r4, #8
   1677e:	9338      	str	r3, [sp, #224]	; 0xe0
   16780:	ddef      	ble.n	16762 <_svfprintf_r+0xc16>
   16782:	9809      	ldr	r0, [sp, #36]	; 0x24
   16784:	4659      	mov	r1, fp
   16786:	aa37      	add	r2, sp, #220	; 0xdc
   16788:	464c      	mov	r4, r9
   1678a:	f7ff f951 	bl	15a30 <__sprint_r>
   1678e:	2800      	cmp	r0, #0
   16790:	f47f ab2a 	bne.w	15de8 <_svfprintf_r+0x29c>
   16794:	3e10      	subs	r6, #16
   16796:	2e10      	cmp	r6, #16
   16798:	dce6      	bgt.n	16768 <_svfprintf_r+0xc1c>
   1679a:	6066      	str	r6, [r4, #4]
   1679c:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   1679e:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   167a0:	3301      	adds	r3, #1
   167a2:	6027      	str	r7, [r4, #0]
   167a4:	1992      	adds	r2, r2, r6
   167a6:	2b07      	cmp	r3, #7
   167a8:	9239      	str	r2, [sp, #228]	; 0xe4
   167aa:	9338      	str	r3, [sp, #224]	; 0xe0
   167ac:	f77f aad9 	ble.w	15d62 <_svfprintf_r+0x216>
   167b0:	e706      	b.n	165c0 <_svfprintf_r+0xa74>
   167b2:	9814      	ldr	r0, [sp, #80]	; 0x50
   167b4:	2130      	movs	r1, #48	; 0x30
   167b6:	f04a 0a02 	orr.w	sl, sl, #2
   167ba:	2201      	movs	r2, #1
   167bc:	2302      	movs	r3, #2
   167be:	f88d 110c 	strb.w	r1, [sp, #268]	; 0x10c
   167c2:	f88d 010d 	strb.w	r0, [sp, #269]	; 0x10d
   167c6:	f7ff bb39 	b.w	15e3c <_svfprintf_r+0x2f0>
   167ca:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   167cc:	1d13      	adds	r3, r2, #4
   167ce:	6816      	ldr	r6, [r2, #0]
   167d0:	930a      	str	r3, [sp, #40]	; 0x28
   167d2:	4636      	mov	r6, r6
   167d4:	ea4f 77e6 	mov.w	r7, r6, asr #31
   167d8:	2e00      	cmp	r6, #0
   167da:	f177 0000 	sbcs.w	r0, r7, #0
   167de:	f6bf ac8a 	bge.w	160f6 <_svfprintf_r+0x5aa>
   167e2:	4276      	negs	r6, r6
   167e4:	eb67 0747 	sbc.w	r7, r7, r7, lsl #1
   167e8:	232d      	movs	r3, #45	; 0x2d
   167ea:	ea56 0207 	orrs.w	r2, r6, r7
   167ee:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
   167f2:	bf0c      	ite	eq
   167f4:	2200      	moveq	r2, #0
   167f6:	2201      	movne	r2, #1
   167f8:	2301      	movs	r3, #1
   167fa:	f7ff bb23 	b.w	15e44 <_svfprintf_r+0x2f8>
   167fe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16800:	1d18      	adds	r0, r3, #4
   16802:	681e      	ldr	r6, [r3, #0]
   16804:	900a      	str	r0, [sp, #40]	; 0x28
   16806:	4636      	mov	r6, r6
   16808:	f04f 0700 	mov.w	r7, #0
   1680c:	f7ff bb0c 	b.w	15e28 <_svfprintf_r+0x2dc>
   16810:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   16812:	1d13      	adds	r3, r2, #4
   16814:	6816      	ldr	r6, [r2, #0]
   16816:	930a      	str	r3, [sp, #40]	; 0x28
   16818:	2301      	movs	r3, #1
   1681a:	1e32      	subs	r2, r6, #0
   1681c:	bf18      	it	ne
   1681e:	2201      	movne	r2, #1
   16820:	4636      	mov	r6, r6
   16822:	f04f 0700 	mov.w	r7, #0
   16826:	f7ff bb09 	b.w	15e3c <_svfprintf_r+0x2f0>
   1682a:	9809      	ldr	r0, [sp, #36]	; 0x24
   1682c:	4659      	mov	r1, fp
   1682e:	aa37      	add	r2, sp, #220	; 0xdc
   16830:	f7ff f8fe 	bl	15a30 <__sprint_r>
   16834:	2800      	cmp	r0, #0
   16836:	f47f aad7 	bne.w	15de8 <_svfprintf_r+0x29c>
   1683a:	464c      	mov	r4, r9
   1683c:	f7ff ba79 	b.w	15d32 <_svfprintf_r+0x1e6>
   16840:	9809      	ldr	r0, [sp, #36]	; 0x24
   16842:	4659      	mov	r1, fp
   16844:	aa37      	add	r2, sp, #220	; 0xdc
   16846:	f7ff f8f3 	bl	15a30 <__sprint_r>
   1684a:	2800      	cmp	r0, #0
   1684c:	f47f aacc 	bne.w	15de8 <_svfprintf_r+0x29c>
   16850:	464c      	mov	r4, r9
   16852:	f7ff ba60 	b.w	15d16 <_svfprintf_r+0x1ca>
   16856:	2830      	cmp	r0, #48	; 0x30
   16858:	f000 8296 	beq.w	16d88 <_svfprintf_r+0x123c>
   1685c:	9a11      	ldr	r2, [sp, #68]	; 0x44
   1685e:	2330      	movs	r3, #48	; 0x30
   16860:	f802 3d01 	strb.w	r3, [r2, #-1]!
   16864:	9b16      	ldr	r3, [sp, #88]	; 0x58
   16866:	9211      	str	r2, [sp, #68]	; 0x44
   16868:	1a9b      	subs	r3, r3, r2
   1686a:	930e      	str	r3, [sp, #56]	; 0x38
   1686c:	f7ff bb1b 	b.w	15ea6 <_svfprintf_r+0x35a>
   16870:	9809      	ldr	r0, [sp, #36]	; 0x24
   16872:	4659      	mov	r1, fp
   16874:	aa37      	add	r2, sp, #220	; 0xdc
   16876:	f7ff f8db 	bl	15a30 <__sprint_r>
   1687a:	2800      	cmp	r0, #0
   1687c:	f47f aab4 	bne.w	15de8 <_svfprintf_r+0x29c>
   16880:	464c      	mov	r4, r9
   16882:	f7ff bb87 	b.w	15f94 <_svfprintf_r+0x448>
   16886:	605e      	str	r6, [r3, #4]
   16888:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   1688a:	9939      	ldr	r1, [sp, #228]	; 0xe4
   1688c:	3201      	adds	r2, #1
   1688e:	601f      	str	r7, [r3, #0]
   16890:	1989      	adds	r1, r1, r6
   16892:	2a07      	cmp	r2, #7
   16894:	9139      	str	r1, [sp, #228]	; 0xe4
   16896:	9238      	str	r2, [sp, #224]	; 0xe0
   16898:	f73f abc1 	bgt.w	1601e <_svfprintf_r+0x4d2>
   1689c:	3308      	adds	r3, #8
   1689e:	f7ff ba71 	b.w	15d84 <_svfprintf_r+0x238>
   168a2:	990a      	ldr	r1, [sp, #40]	; 0x28
   168a4:	462b      	mov	r3, r5
   168a6:	782a      	ldrb	r2, [r5, #0]
   168a8:	910a      	str	r1, [sp, #40]	; 0x28
   168aa:	f7ff b9b8 	b.w	15c1e <_svfprintf_r+0xd2>
   168ae:	f01a 0f10 	tst.w	sl, #16
   168b2:	f000 81cd 	beq.w	16c50 <_svfprintf_r+0x1104>
   168b6:	980a      	ldr	r0, [sp, #40]	; 0x28
   168b8:	990d      	ldr	r1, [sp, #52]	; 0x34
   168ba:	f100 0a04 	add.w	sl, r0, #4
   168be:	6803      	ldr	r3, [r0, #0]
   168c0:	6019      	str	r1, [r3, #0]
   168c2:	f7ff b96d 	b.w	15ba0 <_svfprintf_r+0x54>
   168c6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   168c8:	1dd3      	adds	r3, r2, #7
   168ca:	f023 0307 	bic.w	r3, r3, #7
   168ce:	f103 0008 	add.w	r0, r3, #8
   168d2:	900a      	str	r0, [sp, #40]	; 0x28
   168d4:	685e      	ldr	r6, [r3, #4]
   168d6:	681f      	ldr	r7, [r3, #0]
   168d8:	9619      	str	r6, [sp, #100]	; 0x64
   168da:	9710      	str	r7, [sp, #64]	; 0x40
   168dc:	e43f      	b.n	1615e <_svfprintf_r+0x612>
   168de:	f01a 0340 	ands.w	r3, sl, #64	; 0x40
   168e2:	f000 81a9 	beq.w	16c38 <_svfprintf_r+0x10ec>
   168e6:	990a      	ldr	r1, [sp, #40]	; 0x28
   168e8:	4613      	mov	r3, r2
   168ea:	1d0a      	adds	r2, r1, #4
   168ec:	920a      	str	r2, [sp, #40]	; 0x28
   168ee:	880e      	ldrh	r6, [r1, #0]
   168f0:	1e32      	subs	r2, r6, #0
   168f2:	bf18      	it	ne
   168f4:	2201      	movne	r2, #1
   168f6:	4636      	mov	r6, r6
   168f8:	f04f 0700 	mov.w	r7, #0
   168fc:	f7ff ba9e 	b.w	15e3c <_svfprintf_r+0x2f0>
   16900:	9a11      	ldr	r2, [sp, #68]	; 0x44
   16902:	6063      	str	r3, [r4, #4]
   16904:	9938      	ldr	r1, [sp, #224]	; 0xe0
   16906:	6022      	str	r2, [r4, #0]
   16908:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   1690a:	3101      	adds	r1, #1
   1690c:	9138      	str	r1, [sp, #224]	; 0xe0
   1690e:	18d3      	adds	r3, r2, r3
   16910:	2907      	cmp	r1, #7
   16912:	9339      	str	r3, [sp, #228]	; 0xe4
   16914:	f300 8262 	bgt.w	16ddc <_svfprintf_r+0x1290>
   16918:	3408      	adds	r4, #8
   1691a:	2301      	movs	r3, #1
   1691c:	9e42      	ldr	r6, [sp, #264]	; 0x108
   1691e:	6063      	str	r3, [r4, #4]
   16920:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   16922:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   16924:	3301      	adds	r3, #1
   16926:	981b      	ldr	r0, [sp, #108]	; 0x6c
   16928:	3201      	adds	r2, #1
   1692a:	2b07      	cmp	r3, #7
   1692c:	9338      	str	r3, [sp, #224]	; 0xe0
   1692e:	bfd8      	it	le
   16930:	f104 0308 	addle.w	r3, r4, #8
   16934:	6020      	str	r0, [r4, #0]
   16936:	9239      	str	r2, [sp, #228]	; 0xe4
   16938:	f300 8246 	bgt.w	16dc8 <_svfprintf_r+0x127c>
   1693c:	9a42      	ldr	r2, [sp, #264]	; 0x108
   1693e:	9911      	ldr	r1, [sp, #68]	; 0x44
   16940:	9818      	ldr	r0, [sp, #96]	; 0x60
   16942:	198e      	adds	r6, r1, r6
   16944:	601e      	str	r6, [r3, #0]
   16946:	1a81      	subs	r1, r0, r2
   16948:	6059      	str	r1, [r3, #4]
   1694a:	9939      	ldr	r1, [sp, #228]	; 0xe4
   1694c:	1a8a      	subs	r2, r1, r2
   1694e:	9938      	ldr	r1, [sp, #224]	; 0xe0
   16950:	1812      	adds	r2, r2, r0
   16952:	9239      	str	r2, [sp, #228]	; 0xe4
   16954:	3101      	adds	r1, #1
   16956:	9138      	str	r1, [sp, #224]	; 0xe0
   16958:	2907      	cmp	r1, #7
   1695a:	f73f ab60 	bgt.w	1601e <_svfprintf_r+0x4d2>
   1695e:	3308      	adds	r3, #8
   16960:	f7ff ba10 	b.w	15d84 <_svfprintf_r+0x238>
   16964:	4655      	mov	r5, sl
   16966:	f8dd a038 	ldr.w	sl, [sp, #56]	; 0x38
   1696a:	605c      	str	r4, [r3, #4]
   1696c:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   1696e:	9939      	ldr	r1, [sp, #228]	; 0xe4
   16970:	3201      	adds	r2, #1
   16972:	601f      	str	r7, [r3, #0]
   16974:	1909      	adds	r1, r1, r4
   16976:	2a07      	cmp	r2, #7
   16978:	9139      	str	r1, [sp, #228]	; 0xe4
   1697a:	9238      	str	r2, [sp, #224]	; 0xe0
   1697c:	f300 827f 	bgt.w	16e7e <_svfprintf_r+0x1332>
   16980:	3308      	adds	r3, #8
   16982:	f01a 0f01 	tst.w	sl, #1
   16986:	f43f a9fd 	beq.w	15d84 <_svfprintf_r+0x238>
   1698a:	991b      	ldr	r1, [sp, #108]	; 0x6c
   1698c:	2201      	movs	r2, #1
   1698e:	605a      	str	r2, [r3, #4]
   16990:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   16992:	6019      	str	r1, [r3, #0]
   16994:	9939      	ldr	r1, [sp, #228]	; 0xe4
   16996:	3201      	adds	r2, #1
   16998:	9238      	str	r2, [sp, #224]	; 0xe0
   1699a:	3101      	adds	r1, #1
   1699c:	2a07      	cmp	r2, #7
   1699e:	9139      	str	r1, [sp, #228]	; 0xe4
   169a0:	f73f ab3d 	bgt.w	1601e <_svfprintf_r+0x4d2>
   169a4:	3308      	adds	r3, #8
   169a6:	f7ff b9ed 	b.w	15d84 <_svfprintf_r+0x238>
   169aa:	232d      	movs	r3, #45	; 0x2d
   169ac:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
   169b0:	f7ff bbe8 	b.w	16184 <_svfprintf_r+0x638>
   169b4:	9809      	ldr	r0, [sp, #36]	; 0x24
   169b6:	4659      	mov	r1, fp
   169b8:	aa37      	add	r2, sp, #220	; 0xdc
   169ba:	f7ff f839 	bl	15a30 <__sprint_r>
   169be:	2800      	cmp	r0, #0
   169c0:	f47f aa12 	bne.w	15de8 <_svfprintf_r+0x29c>
   169c4:	464b      	mov	r3, r9
   169c6:	e556      	b.n	16476 <_svfprintf_r+0x92a>
   169c8:	000240ac 	.word	0x000240ac
   169cc:	2301      	movs	r3, #1
   169ce:	6063      	str	r3, [r4, #4]
   169d0:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   169d2:	f244 03fc 	movw	r3, #16636	; 0x40fc
   169d6:	f2c0 0302 	movt	r3, #2
   169da:	6023      	str	r3, [r4, #0]
   169dc:	9b39      	ldr	r3, [sp, #228]	; 0xe4
   169de:	3201      	adds	r2, #1
   169e0:	9238      	str	r2, [sp, #224]	; 0xe0
   169e2:	3301      	adds	r3, #1
   169e4:	2a07      	cmp	r2, #7
   169e6:	9339      	str	r3, [sp, #228]	; 0xe4
   169e8:	bfd8      	it	le
   169ea:	f104 0308 	addle.w	r3, r4, #8
   169ee:	f300 8173 	bgt.w	16cd8 <_svfprintf_r+0x118c>
   169f2:	9a42      	ldr	r2, [sp, #264]	; 0x108
   169f4:	b92a      	cbnz	r2, 16a02 <_svfprintf_r+0xeb6>
   169f6:	9818      	ldr	r0, [sp, #96]	; 0x60
   169f8:	b918      	cbnz	r0, 16a02 <_svfprintf_r+0xeb6>
   169fa:	f01a 0f01 	tst.w	sl, #1
   169fe:	f43f a9c1 	beq.w	15d84 <_svfprintf_r+0x238>
   16a02:	991b      	ldr	r1, [sp, #108]	; 0x6c
   16a04:	2201      	movs	r2, #1
   16a06:	605a      	str	r2, [r3, #4]
   16a08:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   16a0a:	6019      	str	r1, [r3, #0]
   16a0c:	9939      	ldr	r1, [sp, #228]	; 0xe4
   16a0e:	3201      	adds	r2, #1
   16a10:	9238      	str	r2, [sp, #224]	; 0xe0
   16a12:	3101      	adds	r1, #1
   16a14:	2a07      	cmp	r2, #7
   16a16:	9139      	str	r1, [sp, #228]	; 0xe4
   16a18:	f300 8168 	bgt.w	16cec <_svfprintf_r+0x11a0>
   16a1c:	3308      	adds	r3, #8
   16a1e:	9c42      	ldr	r4, [sp, #264]	; 0x108
   16a20:	4264      	negs	r4, r4
   16a22:	2c00      	cmp	r4, #0
   16a24:	f340 8187 	ble.w	16d36 <_svfprintf_r+0x11ea>
   16a28:	2c10      	cmp	r4, #16
   16a2a:	4f9e      	ldr	r7, [pc, #632]	; (16ca4 <_svfprintf_r+0x1158>)
   16a2c:	f340 81a0 	ble.w	16d70 <_svfprintf_r+0x1224>
   16a30:	2610      	movs	r6, #16
   16a32:	f10d 08dc 	add.w	r8, sp, #220	; 0xdc
   16a36:	e003      	b.n	16a40 <_svfprintf_r+0xef4>
   16a38:	3c10      	subs	r4, #16
   16a3a:	2c10      	cmp	r4, #16
   16a3c:	f340 8198 	ble.w	16d70 <_svfprintf_r+0x1224>
   16a40:	605e      	str	r6, [r3, #4]
   16a42:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   16a44:	9939      	ldr	r1, [sp, #228]	; 0xe4
   16a46:	3201      	adds	r2, #1
   16a48:	601f      	str	r7, [r3, #0]
   16a4a:	3110      	adds	r1, #16
   16a4c:	2a07      	cmp	r2, #7
   16a4e:	9139      	str	r1, [sp, #228]	; 0xe4
   16a50:	f103 0308 	add.w	r3, r3, #8
   16a54:	9238      	str	r2, [sp, #224]	; 0xe0
   16a56:	ddef      	ble.n	16a38 <_svfprintf_r+0xeec>
   16a58:	9809      	ldr	r0, [sp, #36]	; 0x24
   16a5a:	4659      	mov	r1, fp
   16a5c:	4642      	mov	r2, r8
   16a5e:	f7fe ffe7 	bl	15a30 <__sprint_r>
   16a62:	464b      	mov	r3, r9
   16a64:	2800      	cmp	r0, #0
   16a66:	d0e7      	beq.n	16a38 <_svfprintf_r+0xeec>
   16a68:	f7ff b9be 	b.w	15de8 <_svfprintf_r+0x29c>
   16a6c:	9b39      	ldr	r3, [sp, #228]	; 0xe4
   16a6e:	465e      	mov	r6, fp
   16a70:	2b00      	cmp	r3, #0
   16a72:	f43f a9ba 	beq.w	15dea <_svfprintf_r+0x29e>
   16a76:	9809      	ldr	r0, [sp, #36]	; 0x24
   16a78:	4659      	mov	r1, fp
   16a7a:	aa37      	add	r2, sp, #220	; 0xdc
   16a7c:	f7fe ffd8 	bl	15a30 <__sprint_r>
   16a80:	f7ff b9b3 	b.w	15dea <_svfprintf_r+0x29e>
   16a84:	990a      	ldr	r1, [sp, #40]	; 0x28
   16a86:	f04a 0a20 	orr.w	sl, sl, #32
   16a8a:	786a      	ldrb	r2, [r5, #1]
   16a8c:	1c6b      	adds	r3, r5, #1
   16a8e:	910a      	str	r1, [sp, #40]	; 0x28
   16a90:	f7ff b8c5 	b.w	15c1e <_svfprintf_r+0xd2>
   16a94:	4638      	mov	r0, r7
   16a96:	4631      	mov	r1, r6
   16a98:	9308      	str	r3, [sp, #32]
   16a9a:	f003 f975 	bl	19d88 <__isnand>
   16a9e:	9b08      	ldr	r3, [sp, #32]
   16aa0:	2800      	cmp	r0, #0
   16aa2:	f040 8101 	bne.w	16ca8 <_svfprintf_r+0x115c>
   16aa6:	f1b8 3fff 	cmp.w	r8, #4294967295
   16aaa:	bf08      	it	eq
   16aac:	f108 0807 	addeq.w	r8, r8, #7
   16ab0:	d00e      	beq.n	16ad0 <_svfprintf_r+0xf84>
   16ab2:	9a14      	ldr	r2, [sp, #80]	; 0x50
   16ab4:	2a67      	cmp	r2, #103	; 0x67
   16ab6:	bf14      	ite	ne
   16ab8:	2300      	movne	r3, #0
   16aba:	2301      	moveq	r3, #1
   16abc:	2a47      	cmp	r2, #71	; 0x47
   16abe:	bf08      	it	eq
   16ac0:	f043 0301 	orreq.w	r3, r3, #1
   16ac4:	b123      	cbz	r3, 16ad0 <_svfprintf_r+0xf84>
   16ac6:	f1b8 0f00 	cmp.w	r8, #0
   16aca:	bf08      	it	eq
   16acc:	f04f 0801 	moveq.w	r8, #1
   16ad0:	4633      	mov	r3, r6
   16ad2:	463a      	mov	r2, r7
   16ad4:	e9cd 233a 	strd	r2, r3, [sp, #232]	; 0xe8
   16ad8:	f44a 7a80 	orr.w	sl, sl, #256	; 0x100
   16adc:	9b3b      	ldr	r3, [sp, #236]	; 0xec
   16ade:	2b00      	cmp	r3, #0
   16ae0:	f2c0 820a 	blt.w	16ef8 <_svfprintf_r+0x13ac>
   16ae4:	2300      	movs	r3, #0
   16ae6:	9315      	str	r3, [sp, #84]	; 0x54
   16ae8:	9914      	ldr	r1, [sp, #80]	; 0x50
   16aea:	2966      	cmp	r1, #102	; 0x66
   16aec:	bf14      	ite	ne
   16aee:	2300      	movne	r3, #0
   16af0:	2301      	moveq	r3, #1
   16af2:	2946      	cmp	r1, #70	; 0x46
   16af4:	bf08      	it	eq
   16af6:	f043 0301 	orreq.w	r3, r3, #1
   16afa:	9312      	str	r3, [sp, #72]	; 0x48
   16afc:	2b00      	cmp	r3, #0
   16afe:	f000 818a 	beq.w	16e16 <_svfprintf_r+0x12ca>
   16b02:	2303      	movs	r3, #3
   16b04:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
   16b08:	990b      	ldr	r1, [sp, #44]	; 0x2c
   16b0a:	970e      	str	r7, [sp, #56]	; 0x38
   16b0c:	960f      	str	r6, [sp, #60]	; 0x3c
   16b0e:	9300      	str	r3, [sp, #0]
   16b10:	9809      	ldr	r0, [sp, #36]	; 0x24
   16b12:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
   16b16:	9101      	str	r1, [sp, #4]
   16b18:	a942      	add	r1, sp, #264	; 0x108
   16b1a:	9102      	str	r1, [sp, #8]
   16b1c:	a941      	add	r1, sp, #260	; 0x104
   16b1e:	9103      	str	r1, [sp, #12]
   16b20:	a940      	add	r1, sp, #256	; 0x100
   16b22:	9104      	str	r1, [sp, #16]
   16b24:	f000 faec 	bl	17100 <_dtoa_r>
   16b28:	9a14      	ldr	r2, [sp, #80]	; 0x50
   16b2a:	f1b2 0367 	subs.w	r3, r2, #103	; 0x67
   16b2e:	bf18      	it	ne
   16b30:	2301      	movne	r3, #1
   16b32:	2a47      	cmp	r2, #71	; 0x47
   16b34:	bf0c      	ite	eq
   16b36:	2300      	moveq	r3, #0
   16b38:	f003 0301 	andne.w	r3, r3, #1
   16b3c:	9011      	str	r0, [sp, #68]	; 0x44
   16b3e:	b92b      	cbnz	r3, 16b4c <_svfprintf_r+0x1000>
   16b40:	f01a 0f01 	tst.w	sl, #1
   16b44:	bf08      	it	eq
   16b46:	f8dd c100 	ldreq.w	ip, [sp, #256]	; 0x100
   16b4a:	d01a      	beq.n	16b82 <_svfprintf_r+0x1036>
   16b4c:	9b11      	ldr	r3, [sp, #68]	; 0x44
   16b4e:	980b      	ldr	r0, [sp, #44]	; 0x2c
   16b50:	9912      	ldr	r1, [sp, #72]	; 0x48
   16b52:	eb03 0c00 	add.w	ip, r3, r0
   16b56:	b129      	cbz	r1, 16b64 <_svfprintf_r+0x1018>
   16b58:	781b      	ldrb	r3, [r3, #0]
   16b5a:	2b30      	cmp	r3, #48	; 0x30
   16b5c:	f000 80d0 	beq.w	16d00 <_svfprintf_r+0x11b4>
   16b60:	9b42      	ldr	r3, [sp, #264]	; 0x108
   16b62:	449c      	add	ip, r3
   16b64:	4638      	mov	r0, r7
   16b66:	2200      	movs	r2, #0
   16b68:	2300      	movs	r3, #0
   16b6a:	4631      	mov	r1, r6
   16b6c:	f8cd c020 	str.w	ip, [sp, #32]
   16b70:	f003 fc62 	bl	1a438 <__aeabi_dcmpeq>
   16b74:	f8dd c020 	ldr.w	ip, [sp, #32]
   16b78:	2800      	cmp	r0, #0
   16b7a:	f000 8173 	beq.w	16e64 <_svfprintf_r+0x1318>
   16b7e:	f8cd c100 	str.w	ip, [sp, #256]	; 0x100
   16b82:	9814      	ldr	r0, [sp, #80]	; 0x50
   16b84:	9911      	ldr	r1, [sp, #68]	; 0x44
   16b86:	2867      	cmp	r0, #103	; 0x67
   16b88:	bf14      	ite	ne
   16b8a:	2300      	movne	r3, #0
   16b8c:	2301      	moveq	r3, #1
   16b8e:	2847      	cmp	r0, #71	; 0x47
   16b90:	bf08      	it	eq
   16b92:	f043 0301 	orreq.w	r3, r3, #1
   16b96:	ebc1 010c 	rsb	r1, r1, ip
   16b9a:	9118      	str	r1, [sp, #96]	; 0x60
   16b9c:	2b00      	cmp	r3, #0
   16b9e:	f000 814a 	beq.w	16e36 <_svfprintf_r+0x12ea>
   16ba2:	9a42      	ldr	r2, [sp, #264]	; 0x108
   16ba4:	f112 0f03 	cmn.w	r2, #3
   16ba8:	920e      	str	r2, [sp, #56]	; 0x38
   16baa:	db02      	blt.n	16bb2 <_svfprintf_r+0x1066>
   16bac:	4590      	cmp	r8, r2
   16bae:	f280 814b 	bge.w	16e48 <_svfprintf_r+0x12fc>
   16bb2:	9b14      	ldr	r3, [sp, #80]	; 0x50
   16bb4:	3b02      	subs	r3, #2
   16bb6:	9314      	str	r3, [sp, #80]	; 0x50
   16bb8:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   16bba:	9814      	ldr	r0, [sp, #80]	; 0x50
   16bbc:	1e53      	subs	r3, r2, #1
   16bbe:	9342      	str	r3, [sp, #264]	; 0x108
   16bc0:	2b00      	cmp	r3, #0
   16bc2:	f88d 00f8 	strb.w	r0, [sp, #248]	; 0xf8
   16bc6:	f2c0 81d1 	blt.w	16f6c <_svfprintf_r+0x1420>
   16bca:	222b      	movs	r2, #43	; 0x2b
   16bcc:	f88d 20f9 	strb.w	r2, [sp, #249]	; 0xf9
   16bd0:	2b09      	cmp	r3, #9
   16bd2:	f300 8162 	bgt.w	16e9a <_svfprintf_r+0x134e>
   16bd6:	a93f      	add	r1, sp, #252	; 0xfc
   16bd8:	3330      	adds	r3, #48	; 0x30
   16bda:	f88d 30fb 	strb.w	r3, [sp, #251]	; 0xfb
   16bde:	2330      	movs	r3, #48	; 0x30
   16be0:	f88d 30fa 	strb.w	r3, [sp, #250]	; 0xfa
   16be4:	ab3e      	add	r3, sp, #248	; 0xf8
   16be6:	9a18      	ldr	r2, [sp, #96]	; 0x60
   16be8:	1acb      	subs	r3, r1, r3
   16bea:	9918      	ldr	r1, [sp, #96]	; 0x60
   16bec:	931a      	str	r3, [sp, #104]	; 0x68
   16bee:	1859      	adds	r1, r3, r1
   16bf0:	2a01      	cmp	r2, #1
   16bf2:	910e      	str	r1, [sp, #56]	; 0x38
   16bf4:	f340 81cc 	ble.w	16f90 <_svfprintf_r+0x1444>
   16bf8:	980e      	ldr	r0, [sp, #56]	; 0x38
   16bfa:	3001      	adds	r0, #1
   16bfc:	900e      	str	r0, [sp, #56]	; 0x38
   16bfe:	ea20 71e0 	bic.w	r1, r0, r0, asr #31
   16c02:	910b      	str	r1, [sp, #44]	; 0x2c
   16c04:	9b15      	ldr	r3, [sp, #84]	; 0x54
   16c06:	2b00      	cmp	r3, #0
   16c08:	f000 80fd 	beq.w	16e06 <_svfprintf_r+0x12ba>
   16c0c:	232d      	movs	r3, #45	; 0x2d
   16c0e:	2000      	movs	r0, #0
   16c10:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
   16c14:	9015      	str	r0, [sp, #84]	; 0x54
   16c16:	f7ff b950 	b.w	15eba <_svfprintf_r+0x36e>
   16c1a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   16c1c:	425b      	negs	r3, r3
   16c1e:	930c      	str	r3, [sp, #48]	; 0x30
   16c20:	f7ff bace 	b.w	161c0 <_svfprintf_r+0x674>
   16c24:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   16c26:	2000      	movs	r0, #0
   16c28:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
   16c2c:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
   16c30:	9015      	str	r0, [sp, #84]	; 0x54
   16c32:	920b      	str	r2, [sp, #44]	; 0x2c
   16c34:	f7ff b940 	b.w	15eb8 <_svfprintf_r+0x36c>
   16c38:	980a      	ldr	r0, [sp, #40]	; 0x28
   16c3a:	1d01      	adds	r1, r0, #4
   16c3c:	910a      	str	r1, [sp, #40]	; 0x28
   16c3e:	6806      	ldr	r6, [r0, #0]
   16c40:	1e32      	subs	r2, r6, #0
   16c42:	bf18      	it	ne
   16c44:	2201      	movne	r2, #1
   16c46:	4636      	mov	r6, r6
   16c48:	f04f 0700 	mov.w	r7, #0
   16c4c:	f7ff b8f6 	b.w	15e3c <_svfprintf_r+0x2f0>
   16c50:	f01a 0f40 	tst.w	sl, #64	; 0x40
   16c54:	bf17      	itett	ne
   16c56:	9a0a      	ldrne	r2, [sp, #40]	; 0x28
   16c58:	990a      	ldreq	r1, [sp, #40]	; 0x28
   16c5a:	980d      	ldrne	r0, [sp, #52]	; 0x34
   16c5c:	f102 0a04 	addne.w	sl, r2, #4
   16c60:	bf11      	iteee	ne
   16c62:	6813      	ldrne	r3, [r2, #0]
   16c64:	f101 0a04 	addeq.w	sl, r1, #4
   16c68:	680b      	ldreq	r3, [r1, #0]
   16c6a:	9a0d      	ldreq	r2, [sp, #52]	; 0x34
   16c6c:	bf14      	ite	ne
   16c6e:	8018      	strhne	r0, [r3, #0]
   16c70:	601a      	streq	r2, [r3, #0]
   16c72:	f7fe bf95 	b.w	15ba0 <_svfprintf_r+0x54>
   16c76:	9809      	ldr	r0, [sp, #36]	; 0x24
   16c78:	4659      	mov	r1, fp
   16c7a:	aa37      	add	r2, sp, #220	; 0xdc
   16c7c:	f7fe fed8 	bl	15a30 <__sprint_r>
   16c80:	2800      	cmp	r0, #0
   16c82:	f47f a8b1 	bne.w	15de8 <_svfprintf_r+0x29c>
   16c86:	464b      	mov	r3, r9
   16c88:	e40b      	b.n	164a2 <_svfprintf_r+0x956>
   16c8a:	9809      	ldr	r0, [sp, #36]	; 0x24
   16c8c:	2140      	movs	r1, #64	; 0x40
   16c8e:	f001 fe45 	bl	1891c <_malloc_r>
   16c92:	6030      	str	r0, [r6, #0]
   16c94:	6130      	str	r0, [r6, #16]
   16c96:	2800      	cmp	r0, #0
   16c98:	f000 818d 	beq.w	16fb6 <_svfprintf_r+0x146a>
   16c9c:	2340      	movs	r3, #64	; 0x40
   16c9e:	6173      	str	r3, [r6, #20]
   16ca0:	f7fe bf67 	b.w	15b72 <_svfprintf_r+0x26>
   16ca4:	000240ac 	.word	0x000240ac
   16ca8:	2003      	movs	r0, #3
   16caa:	f244 02dc 	movw	r2, #16604	; 0x40dc
   16cae:	f244 01d8 	movw	r1, #16600	; 0x40d8
   16cb2:	900b      	str	r0, [sp, #44]	; 0x2c
   16cb4:	9814      	ldr	r0, [sp, #80]	; 0x50
   16cb6:	f2c0 0102 	movt	r1, #2
   16cba:	f2c0 0202 	movt	r2, #2
   16cbe:	9315      	str	r3, [sp, #84]	; 0x54
   16cc0:	2847      	cmp	r0, #71	; 0x47
   16cc2:	bfd8      	it	le
   16cc4:	460a      	movle	r2, r1
   16cc6:	f02a 0a80 	bic.w	sl, sl, #128	; 0x80
   16cca:	2103      	movs	r1, #3
   16ccc:	9211      	str	r2, [sp, #68]	; 0x44
   16cce:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
   16cd2:	910e      	str	r1, [sp, #56]	; 0x38
   16cd4:	f7ff b8f0 	b.w	15eb8 <_svfprintf_r+0x36c>
   16cd8:	9809      	ldr	r0, [sp, #36]	; 0x24
   16cda:	4659      	mov	r1, fp
   16cdc:	aa37      	add	r2, sp, #220	; 0xdc
   16cde:	f7fe fea7 	bl	15a30 <__sprint_r>
   16ce2:	2800      	cmp	r0, #0
   16ce4:	f47f a880 	bne.w	15de8 <_svfprintf_r+0x29c>
   16ce8:	464b      	mov	r3, r9
   16cea:	e682      	b.n	169f2 <_svfprintf_r+0xea6>
   16cec:	9809      	ldr	r0, [sp, #36]	; 0x24
   16cee:	4659      	mov	r1, fp
   16cf0:	aa37      	add	r2, sp, #220	; 0xdc
   16cf2:	f7fe fe9d 	bl	15a30 <__sprint_r>
   16cf6:	2800      	cmp	r0, #0
   16cf8:	f47f a876 	bne.w	15de8 <_svfprintf_r+0x29c>
   16cfc:	464b      	mov	r3, r9
   16cfe:	e68e      	b.n	16a1e <_svfprintf_r+0xed2>
   16d00:	4638      	mov	r0, r7
   16d02:	2200      	movs	r2, #0
   16d04:	2300      	movs	r3, #0
   16d06:	4631      	mov	r1, r6
   16d08:	f8cd c020 	str.w	ip, [sp, #32]
   16d0c:	f003 fb94 	bl	1a438 <__aeabi_dcmpeq>
   16d10:	f8dd c020 	ldr.w	ip, [sp, #32]
   16d14:	2800      	cmp	r0, #0
   16d16:	f47f af23 	bne.w	16b60 <_svfprintf_r+0x1014>
   16d1a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   16d1c:	f1c2 0301 	rsb	r3, r2, #1
   16d20:	9342      	str	r3, [sp, #264]	; 0x108
   16d22:	e71e      	b.n	16b62 <_svfprintf_r+0x1016>
   16d24:	9809      	ldr	r0, [sp, #36]	; 0x24
   16d26:	4659      	mov	r1, fp
   16d28:	aa37      	add	r2, sp, #220	; 0xdc
   16d2a:	f7fe fe81 	bl	15a30 <__sprint_r>
   16d2e:	2800      	cmp	r0, #0
   16d30:	f47f a85a 	bne.w	15de8 <_svfprintf_r+0x29c>
   16d34:	464b      	mov	r3, r9
   16d36:	9a18      	ldr	r2, [sp, #96]	; 0x60
   16d38:	9811      	ldr	r0, [sp, #68]	; 0x44
   16d3a:	605a      	str	r2, [r3, #4]
   16d3c:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   16d3e:	9939      	ldr	r1, [sp, #228]	; 0xe4
   16d40:	6018      	str	r0, [r3, #0]
   16d42:	3201      	adds	r2, #1
   16d44:	9818      	ldr	r0, [sp, #96]	; 0x60
   16d46:	9238      	str	r2, [sp, #224]	; 0xe0
   16d48:	1809      	adds	r1, r1, r0
   16d4a:	2a07      	cmp	r2, #7
   16d4c:	9139      	str	r1, [sp, #228]	; 0xe4
   16d4e:	f73f a966 	bgt.w	1601e <_svfprintf_r+0x4d2>
   16d52:	3308      	adds	r3, #8
   16d54:	f7ff b816 	b.w	15d84 <_svfprintf_r+0x238>
   16d58:	2100      	movs	r1, #0
   16d5a:	9115      	str	r1, [sp, #84]	; 0x54
   16d5c:	f7fe faee 	bl	1533c <strlen>
   16d60:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
   16d64:	ea20 72e0 	bic.w	r2, r0, r0, asr #31
   16d68:	900e      	str	r0, [sp, #56]	; 0x38
   16d6a:	920b      	str	r2, [sp, #44]	; 0x2c
   16d6c:	f7ff b8a4 	b.w	15eb8 <_svfprintf_r+0x36c>
   16d70:	605c      	str	r4, [r3, #4]
   16d72:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   16d74:	601f      	str	r7, [r3, #0]
   16d76:	1c51      	adds	r1, r2, #1
   16d78:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   16d7a:	9138      	str	r1, [sp, #224]	; 0xe0
   16d7c:	1912      	adds	r2, r2, r4
   16d7e:	2907      	cmp	r1, #7
   16d80:	9239      	str	r2, [sp, #228]	; 0xe4
   16d82:	dccf      	bgt.n	16d24 <_svfprintf_r+0x11d8>
   16d84:	3308      	adds	r3, #8
   16d86:	e7d6      	b.n	16d36 <_svfprintf_r+0x11ea>
   16d88:	9916      	ldr	r1, [sp, #88]	; 0x58
   16d8a:	9811      	ldr	r0, [sp, #68]	; 0x44
   16d8c:	1a08      	subs	r0, r1, r0
   16d8e:	900e      	str	r0, [sp, #56]	; 0x38
   16d90:	f7ff b889 	b.w	15ea6 <_svfprintf_r+0x35a>
   16d94:	f1b8 0f06 	cmp.w	r8, #6
   16d98:	bf34      	ite	cc
   16d9a:	4641      	movcc	r1, r8
   16d9c:	2106      	movcs	r1, #6
   16d9e:	f244 02f4 	movw	r2, #16628	; 0x40f4
   16da2:	f2c0 0202 	movt	r2, #2
   16da6:	ea21 73e1 	bic.w	r3, r1, r1, asr #31
   16daa:	910e      	str	r1, [sp, #56]	; 0x38
   16dac:	9211      	str	r2, [sp, #68]	; 0x44
   16dae:	930b      	str	r3, [sp, #44]	; 0x2c
   16db0:	f7ff b963 	b.w	1607a <_svfprintf_r+0x52e>
   16db4:	9809      	ldr	r0, [sp, #36]	; 0x24
   16db6:	4659      	mov	r1, fp
   16db8:	aa37      	add	r2, sp, #220	; 0xdc
   16dba:	f7fe fe39 	bl	15a30 <__sprint_r>
   16dbe:	2800      	cmp	r0, #0
   16dc0:	f47f a812 	bne.w	15de8 <_svfprintf_r+0x29c>
   16dc4:	464b      	mov	r3, r9
   16dc6:	e43b      	b.n	16640 <_svfprintf_r+0xaf4>
   16dc8:	9809      	ldr	r0, [sp, #36]	; 0x24
   16dca:	4659      	mov	r1, fp
   16dcc:	aa37      	add	r2, sp, #220	; 0xdc
   16dce:	f7fe fe2f 	bl	15a30 <__sprint_r>
   16dd2:	2800      	cmp	r0, #0
   16dd4:	f47f a808 	bne.w	15de8 <_svfprintf_r+0x29c>
   16dd8:	464b      	mov	r3, r9
   16dda:	e5af      	b.n	1693c <_svfprintf_r+0xdf0>
   16ddc:	9809      	ldr	r0, [sp, #36]	; 0x24
   16dde:	4659      	mov	r1, fp
   16de0:	aa37      	add	r2, sp, #220	; 0xdc
   16de2:	f7fe fe25 	bl	15a30 <__sprint_r>
   16de6:	2800      	cmp	r0, #0
   16de8:	f47e affe 	bne.w	15de8 <_svfprintf_r+0x29c>
   16dec:	464c      	mov	r4, r9
   16dee:	e594      	b.n	1691a <_svfprintf_r+0xdce>
   16df0:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
   16df4:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
   16df8:	9015      	str	r0, [sp, #84]	; 0x54
   16dfa:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
   16dfe:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
   16e02:	f7ff b859 	b.w	15eb8 <_svfprintf_r+0x36c>
   16e06:	980e      	ldr	r0, [sp, #56]	; 0x38
   16e08:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
   16e0c:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   16e10:	900b      	str	r0, [sp, #44]	; 0x2c
   16e12:	f7ff b851 	b.w	15eb8 <_svfprintf_r+0x36c>
   16e16:	9a14      	ldr	r2, [sp, #80]	; 0x50
   16e18:	2a65      	cmp	r2, #101	; 0x65
   16e1a:	bf14      	ite	ne
   16e1c:	2300      	movne	r3, #0
   16e1e:	2301      	moveq	r3, #1
   16e20:	2a45      	cmp	r2, #69	; 0x45
   16e22:	bf08      	it	eq
   16e24:	f043 0301 	orreq.w	r3, r3, #1
   16e28:	2b00      	cmp	r3, #0
   16e2a:	d032      	beq.n	16e92 <_svfprintf_r+0x1346>
   16e2c:	f108 0301 	add.w	r3, r8, #1
   16e30:	930b      	str	r3, [sp, #44]	; 0x2c
   16e32:	2302      	movs	r3, #2
   16e34:	e668      	b.n	16b08 <_svfprintf_r+0xfbc>
   16e36:	9814      	ldr	r0, [sp, #80]	; 0x50
   16e38:	2865      	cmp	r0, #101	; 0x65
   16e3a:	dd62      	ble.n	16f02 <_svfprintf_r+0x13b6>
   16e3c:	9a14      	ldr	r2, [sp, #80]	; 0x50
   16e3e:	2a66      	cmp	r2, #102	; 0x66
   16e40:	bf1c      	itt	ne
   16e42:	9b42      	ldrne	r3, [sp, #264]	; 0x108
   16e44:	930e      	strne	r3, [sp, #56]	; 0x38
   16e46:	d06f      	beq.n	16f28 <_svfprintf_r+0x13dc>
   16e48:	9a18      	ldr	r2, [sp, #96]	; 0x60
   16e4a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   16e4c:	429a      	cmp	r2, r3
   16e4e:	dc5b      	bgt.n	16f08 <_svfprintf_r+0x13bc>
   16e50:	f01a 0f01 	tst.w	sl, #1
   16e54:	f040 8081 	bne.w	16f5a <_svfprintf_r+0x140e>
   16e58:	ea23 70e3 	bic.w	r0, r3, r3, asr #31
   16e5c:	2167      	movs	r1, #103	; 0x67
   16e5e:	900b      	str	r0, [sp, #44]	; 0x2c
   16e60:	9114      	str	r1, [sp, #80]	; 0x50
   16e62:	e6cf      	b.n	16c04 <_svfprintf_r+0x10b8>
   16e64:	9b40      	ldr	r3, [sp, #256]	; 0x100
   16e66:	459c      	cmp	ip, r3
   16e68:	bf98      	it	ls
   16e6a:	469c      	movls	ip, r3
   16e6c:	f67f ae89 	bls.w	16b82 <_svfprintf_r+0x1036>
   16e70:	2230      	movs	r2, #48	; 0x30
   16e72:	f803 2b01 	strb.w	r2, [r3], #1
   16e76:	459c      	cmp	ip, r3
   16e78:	9340      	str	r3, [sp, #256]	; 0x100
   16e7a:	d8fa      	bhi.n	16e72 <_svfprintf_r+0x1326>
   16e7c:	e681      	b.n	16b82 <_svfprintf_r+0x1036>
   16e7e:	9809      	ldr	r0, [sp, #36]	; 0x24
   16e80:	4659      	mov	r1, fp
   16e82:	aa37      	add	r2, sp, #220	; 0xdc
   16e84:	f7fe fdd4 	bl	15a30 <__sprint_r>
   16e88:	2800      	cmp	r0, #0
   16e8a:	f47e afad 	bne.w	15de8 <_svfprintf_r+0x29c>
   16e8e:	464b      	mov	r3, r9
   16e90:	e577      	b.n	16982 <_svfprintf_r+0xe36>
   16e92:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
   16e96:	3302      	adds	r3, #2
   16e98:	e636      	b.n	16b08 <_svfprintf_r+0xfbc>
   16e9a:	f246 6c67 	movw	ip, #26215	; 0x6667
   16e9e:	f10d 00f7 	add.w	r0, sp, #247	; 0xf7
   16ea2:	f2c6 6c66 	movt	ip, #26214	; 0x6666
   16ea6:	fb8c 2103 	smull	r2, r1, ip, r3
   16eaa:	17da      	asrs	r2, r3, #31
   16eac:	ebc2 02a1 	rsb	r2, r2, r1, asr #2
   16eb0:	eb02 0182 	add.w	r1, r2, r2, lsl #2
   16eb4:	eba3 0141 	sub.w	r1, r3, r1, lsl #1
   16eb8:	4613      	mov	r3, r2
   16eba:	3130      	adds	r1, #48	; 0x30
   16ebc:	2a09      	cmp	r2, #9
   16ebe:	f800 1d01 	strb.w	r1, [r0, #-1]!
   16ec2:	dcf0      	bgt.n	16ea6 <_svfprintf_r+0x135a>
   16ec4:	3330      	adds	r3, #48	; 0x30
   16ec6:	1e42      	subs	r2, r0, #1
   16ec8:	b2d9      	uxtb	r1, r3
   16eca:	f800 1c01 	strb.w	r1, [r0, #-1]
   16ece:	9b07      	ldr	r3, [sp, #28]
   16ed0:	4293      	cmp	r3, r2
   16ed2:	bf98      	it	ls
   16ed4:	f10d 01fa 	addls.w	r1, sp, #250	; 0xfa
   16ed8:	f67f ae84 	bls.w	16be4 <_svfprintf_r+0x1098>
   16edc:	4602      	mov	r2, r0
   16ede:	f10d 03fb 	add.w	r3, sp, #251	; 0xfb
   16ee2:	e001      	b.n	16ee8 <_svfprintf_r+0x139c>
   16ee4:	f812 1b01 	ldrb.w	r1, [r2], #1
   16ee8:	f803 1c01 	strb.w	r1, [r3, #-1]
   16eec:	4619      	mov	r1, r3
   16eee:	9807      	ldr	r0, [sp, #28]
   16ef0:	3301      	adds	r3, #1
   16ef2:	4290      	cmp	r0, r2
   16ef4:	d8f6      	bhi.n	16ee4 <_svfprintf_r+0x1398>
   16ef6:	e675      	b.n	16be4 <_svfprintf_r+0x1098>
   16ef8:	202d      	movs	r0, #45	; 0x2d
   16efa:	f106 4600 	add.w	r6, r6, #2147483648	; 0x80000000
   16efe:	9015      	str	r0, [sp, #84]	; 0x54
   16f00:	e5f2      	b.n	16ae8 <_svfprintf_r+0xf9c>
   16f02:	9942      	ldr	r1, [sp, #264]	; 0x108
   16f04:	910e      	str	r1, [sp, #56]	; 0x38
   16f06:	e657      	b.n	16bb8 <_svfprintf_r+0x106c>
   16f08:	990e      	ldr	r1, [sp, #56]	; 0x38
   16f0a:	9818      	ldr	r0, [sp, #96]	; 0x60
   16f0c:	2900      	cmp	r1, #0
   16f0e:	bfda      	itte	le
   16f10:	9a0e      	ldrle	r2, [sp, #56]	; 0x38
   16f12:	f1c2 0302 	rsble	r3, r2, #2
   16f16:	2301      	movgt	r3, #1
   16f18:	181b      	adds	r3, r3, r0
   16f1a:	2167      	movs	r1, #103	; 0x67
   16f1c:	ea23 72e3 	bic.w	r2, r3, r3, asr #31
   16f20:	930e      	str	r3, [sp, #56]	; 0x38
   16f22:	9114      	str	r1, [sp, #80]	; 0x50
   16f24:	920b      	str	r2, [sp, #44]	; 0x2c
   16f26:	e66d      	b.n	16c04 <_svfprintf_r+0x10b8>
   16f28:	9842      	ldr	r0, [sp, #264]	; 0x108
   16f2a:	2800      	cmp	r0, #0
   16f2c:	900e      	str	r0, [sp, #56]	; 0x38
   16f2e:	dd38      	ble.n	16fa2 <_svfprintf_r+0x1456>
   16f30:	f1b8 0f00 	cmp.w	r8, #0
   16f34:	d107      	bne.n	16f46 <_svfprintf_r+0x13fa>
   16f36:	f01a 0f01 	tst.w	sl, #1
   16f3a:	bf04      	itt	eq
   16f3c:	ea20 71e0 	biceq.w	r1, r0, r0, asr #31
   16f40:	910b      	streq	r1, [sp, #44]	; 0x2c
   16f42:	f43f ae5f 	beq.w	16c04 <_svfprintf_r+0x10b8>
   16f46:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   16f48:	2066      	movs	r0, #102	; 0x66
   16f4a:	9014      	str	r0, [sp, #80]	; 0x50
   16f4c:	1c53      	adds	r3, r2, #1
   16f4e:	4443      	add	r3, r8
   16f50:	930e      	str	r3, [sp, #56]	; 0x38
   16f52:	ea23 71e3 	bic.w	r1, r3, r3, asr #31
   16f56:	910b      	str	r1, [sp, #44]	; 0x2c
   16f58:	e654      	b.n	16c04 <_svfprintf_r+0x10b8>
   16f5a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   16f5c:	2367      	movs	r3, #103	; 0x67
   16f5e:	9314      	str	r3, [sp, #80]	; 0x50
   16f60:	3201      	adds	r2, #1
   16f62:	920e      	str	r2, [sp, #56]	; 0x38
   16f64:	ea22 70e2 	bic.w	r0, r2, r2, asr #31
   16f68:	900b      	str	r0, [sp, #44]	; 0x2c
   16f6a:	e64b      	b.n	16c04 <_svfprintf_r+0x10b8>
   16f6c:	222d      	movs	r2, #45	; 0x2d
   16f6e:	425b      	negs	r3, r3
   16f70:	f88d 20f9 	strb.w	r2, [sp, #249]	; 0xf9
   16f74:	e62c      	b.n	16bd0 <_svfprintf_r+0x1084>
   16f76:	990a      	ldr	r1, [sp, #40]	; 0x28
   16f78:	781a      	ldrb	r2, [r3, #0]
   16f7a:	f8d1 8000 	ldr.w	r8, [r1]
   16f7e:	3104      	adds	r1, #4
   16f80:	910a      	str	r1, [sp, #40]	; 0x28
   16f82:	f1b8 0f00 	cmp.w	r8, #0
   16f86:	bfb8      	it	lt
   16f88:	f04f 38ff 	movlt.w	r8, #4294967295
   16f8c:	f7fe be47 	b.w	15c1e <_svfprintf_r+0xd2>
   16f90:	f01a 0f01 	tst.w	sl, #1
   16f94:	bf04      	itt	eq
   16f96:	ea21 73e1 	biceq.w	r3, r1, r1, asr #31
   16f9a:	930b      	streq	r3, [sp, #44]	; 0x2c
   16f9c:	f43f ae32 	beq.w	16c04 <_svfprintf_r+0x10b8>
   16fa0:	e62a      	b.n	16bf8 <_svfprintf_r+0x10ac>
   16fa2:	f1b8 0f00 	cmp.w	r8, #0
   16fa6:	d10e      	bne.n	16fc6 <_svfprintf_r+0x147a>
   16fa8:	f01a 0f01 	tst.w	sl, #1
   16fac:	d10b      	bne.n	16fc6 <_svfprintf_r+0x147a>
   16fae:	2201      	movs	r2, #1
   16fb0:	920b      	str	r2, [sp, #44]	; 0x2c
   16fb2:	920e      	str	r2, [sp, #56]	; 0x38
   16fb4:	e626      	b.n	16c04 <_svfprintf_r+0x10b8>
   16fb6:	9809      	ldr	r0, [sp, #36]	; 0x24
   16fb8:	230c      	movs	r3, #12
   16fba:	f04f 31ff 	mov.w	r1, #4294967295
   16fbe:	910d      	str	r1, [sp, #52]	; 0x34
   16fc0:	6003      	str	r3, [r0, #0]
   16fc2:	f7fe bf1a 	b.w	15dfa <_svfprintf_r+0x2ae>
   16fc6:	f108 0302 	add.w	r3, r8, #2
   16fca:	2066      	movs	r0, #102	; 0x66
   16fcc:	ea23 71e3 	bic.w	r1, r3, r3, asr #31
   16fd0:	930e      	str	r3, [sp, #56]	; 0x38
   16fd2:	9014      	str	r0, [sp, #80]	; 0x50
   16fd4:	910b      	str	r1, [sp, #44]	; 0x2c
   16fd6:	e615      	b.n	16c04 <_svfprintf_r+0x10b8>

00016fd8 <_times_r>:
   16fd8:	4608      	mov	r0, r1
   16fda:	f7f3 bb49 	b.w	a670 <_times>
   16fde:	bf00      	nop

00016fe0 <quorem>:
   16fe0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16fe4:	6903      	ldr	r3, [r0, #16]
   16fe6:	690e      	ldr	r6, [r1, #16]
   16fe8:	4682      	mov	sl, r0
   16fea:	4689      	mov	r9, r1
   16fec:	429e      	cmp	r6, r3
   16fee:	f300 8083 	bgt.w	170f8 <quorem+0x118>
   16ff2:	1cf2      	adds	r2, r6, #3
   16ff4:	f101 0514 	add.w	r5, r1, #20
   16ff8:	f100 0414 	add.w	r4, r0, #20
   16ffc:	3e01      	subs	r6, #1
   16ffe:	0092      	lsls	r2, r2, #2
   17000:	188b      	adds	r3, r1, r2
   17002:	1812      	adds	r2, r2, r0
   17004:	f103 0804 	add.w	r8, r3, #4
   17008:	6859      	ldr	r1, [r3, #4]
   1700a:	6850      	ldr	r0, [r2, #4]
   1700c:	3101      	adds	r1, #1
   1700e:	f003 f87f 	bl	1a110 <__aeabi_uidiv>
   17012:	4607      	mov	r7, r0
   17014:	2800      	cmp	r0, #0
   17016:	d039      	beq.n	1708c <quorem+0xac>
   17018:	2300      	movs	r3, #0
   1701a:	469c      	mov	ip, r3
   1701c:	461a      	mov	r2, r3
   1701e:	58e9      	ldr	r1, [r5, r3]
   17020:	58e0      	ldr	r0, [r4, r3]
   17022:	fa1f fe81 	uxth.w	lr, r1
   17026:	ea4f 4b11 	mov.w	fp, r1, lsr #16
   1702a:	b281      	uxth	r1, r0
   1702c:	fb0e ce07 	mla	lr, lr, r7, ip
   17030:	1851      	adds	r1, r2, r1
   17032:	fb0b fc07 	mul.w	ip, fp, r7
   17036:	eb0c 4c1e 	add.w	ip, ip, lr, lsr #16
   1703a:	fa1f fe8e 	uxth.w	lr, lr
   1703e:	ebce 0101 	rsb	r1, lr, r1
   17042:	fa1f f28c 	uxth.w	r2, ip
   17046:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
   1704a:	ebc2 4210 	rsb	r2, r2, r0, lsr #16
   1704e:	fa1f fe81 	uxth.w	lr, r1
   17052:	eb02 4221 	add.w	r2, r2, r1, asr #16
   17056:	ea4e 4102 	orr.w	r1, lr, r2, lsl #16
   1705a:	50e1      	str	r1, [r4, r3]
   1705c:	3304      	adds	r3, #4
   1705e:	1412      	asrs	r2, r2, #16
   17060:	1959      	adds	r1, r3, r5
   17062:	4588      	cmp	r8, r1
   17064:	d2db      	bcs.n	1701e <quorem+0x3e>
   17066:	1d32      	adds	r2, r6, #4
   17068:	eb0a 0382 	add.w	r3, sl, r2, lsl #2
   1706c:	6859      	ldr	r1, [r3, #4]
   1706e:	b969      	cbnz	r1, 1708c <quorem+0xac>
   17070:	429c      	cmp	r4, r3
   17072:	d209      	bcs.n	17088 <quorem+0xa8>
   17074:	f85a 2022 	ldr.w	r2, [sl, r2, lsl #2]
   17078:	b112      	cbz	r2, 17080 <quorem+0xa0>
   1707a:	e005      	b.n	17088 <quorem+0xa8>
   1707c:	681a      	ldr	r2, [r3, #0]
   1707e:	b91a      	cbnz	r2, 17088 <quorem+0xa8>
   17080:	3b04      	subs	r3, #4
   17082:	3e01      	subs	r6, #1
   17084:	429c      	cmp	r4, r3
   17086:	d3f9      	bcc.n	1707c <quorem+0x9c>
   17088:	f8ca 6010 	str.w	r6, [sl, #16]
   1708c:	4649      	mov	r1, r9
   1708e:	4650      	mov	r0, sl
   17090:	f002 f834 	bl	190fc <__mcmp>
   17094:	2800      	cmp	r0, #0
   17096:	db2c      	blt.n	170f2 <quorem+0x112>
   17098:	2300      	movs	r3, #0
   1709a:	3701      	adds	r7, #1
   1709c:	469c      	mov	ip, r3
   1709e:	58ea      	ldr	r2, [r5, r3]
   170a0:	58e0      	ldr	r0, [r4, r3]
   170a2:	b291      	uxth	r1, r2
   170a4:	0c12      	lsrs	r2, r2, #16
   170a6:	fa1f f980 	uxth.w	r9, r0
   170aa:	ebc2 4210 	rsb	r2, r2, r0, lsr #16
   170ae:	ebc1 0109 	rsb	r1, r1, r9
   170b2:	4461      	add	r1, ip
   170b4:	eb02 4221 	add.w	r2, r2, r1, asr #16
   170b8:	b289      	uxth	r1, r1
   170ba:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
   170be:	50e1      	str	r1, [r4, r3]
   170c0:	3304      	adds	r3, #4
   170c2:	ea4f 4c22 	mov.w	ip, r2, asr #16
   170c6:	195a      	adds	r2, r3, r5
   170c8:	4590      	cmp	r8, r2
   170ca:	d2e8      	bcs.n	1709e <quorem+0xbe>
   170cc:	1d32      	adds	r2, r6, #4
   170ce:	eb0a 0382 	add.w	r3, sl, r2, lsl #2
   170d2:	6859      	ldr	r1, [r3, #4]
   170d4:	b969      	cbnz	r1, 170f2 <quorem+0x112>
   170d6:	429c      	cmp	r4, r3
   170d8:	d209      	bcs.n	170ee <quorem+0x10e>
   170da:	f85a 2022 	ldr.w	r2, [sl, r2, lsl #2]
   170de:	b112      	cbz	r2, 170e6 <quorem+0x106>
   170e0:	e005      	b.n	170ee <quorem+0x10e>
   170e2:	681a      	ldr	r2, [r3, #0]
   170e4:	b91a      	cbnz	r2, 170ee <quorem+0x10e>
   170e6:	3b04      	subs	r3, #4
   170e8:	3e01      	subs	r6, #1
   170ea:	429c      	cmp	r4, r3
   170ec:	d3f9      	bcc.n	170e2 <quorem+0x102>
   170ee:	f8ca 6010 	str.w	r6, [sl, #16]
   170f2:	4638      	mov	r0, r7
   170f4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   170f8:	2000      	movs	r0, #0
   170fa:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   170fe:	bf00      	nop

00017100 <_dtoa_r>:
   17100:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17104:	6a46      	ldr	r6, [r0, #36]	; 0x24
   17106:	b0a1      	sub	sp, #132	; 0x84
   17108:	4604      	mov	r4, r0
   1710a:	4690      	mov	r8, r2
   1710c:	4699      	mov	r9, r3
   1710e:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
   17110:	2e00      	cmp	r6, #0
   17112:	f000 8423 	beq.w	1795c <_dtoa_r+0x85c>
   17116:	6832      	ldr	r2, [r6, #0]
   17118:	b182      	cbz	r2, 1713c <_dtoa_r+0x3c>
   1711a:	6a61      	ldr	r1, [r4, #36]	; 0x24
   1711c:	f04f 0c01 	mov.w	ip, #1
   17120:	6876      	ldr	r6, [r6, #4]
   17122:	4620      	mov	r0, r4
   17124:	680b      	ldr	r3, [r1, #0]
   17126:	6056      	str	r6, [r2, #4]
   17128:	684a      	ldr	r2, [r1, #4]
   1712a:	4619      	mov	r1, r3
   1712c:	fa0c f202 	lsl.w	r2, ip, r2
   17130:	609a      	str	r2, [r3, #8]
   17132:	f002 f91d 	bl	19370 <_Bfree>
   17136:	6a63      	ldr	r3, [r4, #36]	; 0x24
   17138:	2200      	movs	r2, #0
   1713a:	601a      	str	r2, [r3, #0]
   1713c:	f1b9 0600 	subs.w	r6, r9, #0
   17140:	db38      	blt.n	171b4 <_dtoa_r+0xb4>
   17142:	2300      	movs	r3, #0
   17144:	602b      	str	r3, [r5, #0]
   17146:	f240 0300 	movw	r3, #0
   1714a:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
   1714e:	461a      	mov	r2, r3
   17150:	ea06 0303 	and.w	r3, r6, r3
   17154:	4293      	cmp	r3, r2
   17156:	d017      	beq.n	17188 <_dtoa_r+0x88>
   17158:	2200      	movs	r2, #0
   1715a:	2300      	movs	r3, #0
   1715c:	4640      	mov	r0, r8
   1715e:	4649      	mov	r1, r9
   17160:	e9cd 8906 	strd	r8, r9, [sp, #24]
   17164:	f003 f968 	bl	1a438 <__aeabi_dcmpeq>
   17168:	2800      	cmp	r0, #0
   1716a:	d029      	beq.n	171c0 <_dtoa_r+0xc0>
   1716c:	982c      	ldr	r0, [sp, #176]	; 0xb0
   1716e:	2301      	movs	r3, #1
   17170:	992e      	ldr	r1, [sp, #184]	; 0xb8
   17172:	6003      	str	r3, [r0, #0]
   17174:	2900      	cmp	r1, #0
   17176:	f000 80d0 	beq.w	1731a <_dtoa_r+0x21a>
   1717a:	4b79      	ldr	r3, [pc, #484]	; (17360 <_dtoa_r+0x260>)
   1717c:	1e58      	subs	r0, r3, #1
   1717e:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
   17180:	6013      	str	r3, [r2, #0]
   17182:	b021      	add	sp, #132	; 0x84
   17184:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   17188:	982c      	ldr	r0, [sp, #176]	; 0xb0
   1718a:	f242 730f 	movw	r3, #9999	; 0x270f
   1718e:	6003      	str	r3, [r0, #0]
   17190:	f1b8 0f00 	cmp.w	r8, #0
   17194:	f000 8095 	beq.w	172c2 <_dtoa_r+0x1c2>
   17198:	f244 100c 	movw	r0, #16652	; 0x410c
   1719c:	f2c0 0002 	movt	r0, #2
   171a0:	992e      	ldr	r1, [sp, #184]	; 0xb8
   171a2:	2900      	cmp	r1, #0
   171a4:	d0ed      	beq.n	17182 <_dtoa_r+0x82>
   171a6:	78c2      	ldrb	r2, [r0, #3]
   171a8:	1cc3      	adds	r3, r0, #3
   171aa:	2a00      	cmp	r2, #0
   171ac:	d0e7      	beq.n	1717e <_dtoa_r+0x7e>
   171ae:	f100 0308 	add.w	r3, r0, #8
   171b2:	e7e4      	b.n	1717e <_dtoa_r+0x7e>
   171b4:	f026 4600 	bic.w	r6, r6, #2147483648	; 0x80000000
   171b8:	2301      	movs	r3, #1
   171ba:	46b1      	mov	r9, r6
   171bc:	602b      	str	r3, [r5, #0]
   171be:	e7c2      	b.n	17146 <_dtoa_r+0x46>
   171c0:	4620      	mov	r0, r4
   171c2:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   171c6:	a91e      	add	r1, sp, #120	; 0x78
   171c8:	9100      	str	r1, [sp, #0]
   171ca:	a91f      	add	r1, sp, #124	; 0x7c
   171cc:	9101      	str	r1, [sp, #4]
   171ce:	f002 f921 	bl	19414 <__d2b>
   171d2:	f3c6 550a 	ubfx	r5, r6, #20, #11
   171d6:	4683      	mov	fp, r0
   171d8:	2d00      	cmp	r5, #0
   171da:	d07e      	beq.n	172da <_dtoa_r+0x1da>
   171dc:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
   171e0:	f5a5 757e 	sub.w	r5, r5, #1016	; 0x3f8
   171e4:	9f1f      	ldr	r7, [sp, #124]	; 0x7c
   171e6:	3d07      	subs	r5, #7
   171e8:	f021 437f 	bic.w	r3, r1, #4278190080	; 0xff000000
   171ec:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
   171f0:	f043 517e 	orr.w	r1, r3, #1065353216	; 0x3f800000
   171f4:	2300      	movs	r3, #0
   171f6:	f441 01e0 	orr.w	r1, r1, #7340032	; 0x700000
   171fa:	9319      	str	r3, [sp, #100]	; 0x64
   171fc:	f240 0300 	movw	r3, #0
   17200:	2200      	movs	r2, #0
   17202:	f6c3 73f8 	movt	r3, #16376	; 0x3ff8
   17206:	f7fd f961 	bl	144cc <__aeabi_dsub>
   1720a:	a34f      	add	r3, pc, #316	; (adr r3, 17348 <_dtoa_r+0x248>)
   1720c:	e9d3 2300 	ldrd	r2, r3, [r3]
   17210:	f7fd fb10 	bl	14834 <__aeabi_dmul>
   17214:	a34e      	add	r3, pc, #312	; (adr r3, 17350 <_dtoa_r+0x250>)
   17216:	e9d3 2300 	ldrd	r2, r3, [r3]
   1721a:	f7fd f959 	bl	144d0 <__adddf3>
   1721e:	e9cd 0108 	strd	r0, r1, [sp, #32]
   17222:	4628      	mov	r0, r5
   17224:	f7fd faa0 	bl	14768 <__aeabi_i2d>
   17228:	a34b      	add	r3, pc, #300	; (adr r3, 17358 <_dtoa_r+0x258>)
   1722a:	e9d3 2300 	ldrd	r2, r3, [r3]
   1722e:	f7fd fb01 	bl	14834 <__aeabi_dmul>
   17232:	4602      	mov	r2, r0
   17234:	460b      	mov	r3, r1
   17236:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   1723a:	f7fd f949 	bl	144d0 <__adddf3>
   1723e:	e9cd 0108 	strd	r0, r1, [sp, #32]
   17242:	f003 f92b 	bl	1a49c <__aeabi_d2iz>
   17246:	2200      	movs	r2, #0
   17248:	2300      	movs	r3, #0
   1724a:	4606      	mov	r6, r0
   1724c:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   17250:	f003 f8fc 	bl	1a44c <__aeabi_dcmplt>
   17254:	b140      	cbz	r0, 17268 <_dtoa_r+0x168>
   17256:	4630      	mov	r0, r6
   17258:	f7fd fa86 	bl	14768 <__aeabi_i2d>
   1725c:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
   17260:	f003 f8ea 	bl	1a438 <__aeabi_dcmpeq>
   17264:	b900      	cbnz	r0, 17268 <_dtoa_r+0x168>
   17266:	3e01      	subs	r6, #1
   17268:	2e16      	cmp	r6, #22
   1726a:	d95b      	bls.n	17324 <_dtoa_r+0x224>
   1726c:	2301      	movs	r3, #1
   1726e:	9318      	str	r3, [sp, #96]	; 0x60
   17270:	3f01      	subs	r7, #1
   17272:	ebb7 0a05 	subs.w	sl, r7, r5
   17276:	bf42      	ittt	mi
   17278:	f1ca 0a00 	rsbmi	sl, sl, #0
   1727c:	f8cd a03c 	strmi.w	sl, [sp, #60]	; 0x3c
   17280:	f04f 0a00 	movmi.w	sl, #0
   17284:	d401      	bmi.n	1728a <_dtoa_r+0x18a>
   17286:	2200      	movs	r2, #0
   17288:	920f      	str	r2, [sp, #60]	; 0x3c
   1728a:	2e00      	cmp	r6, #0
   1728c:	f2c0 8371 	blt.w	17972 <_dtoa_r+0x872>
   17290:	44b2      	add	sl, r6
   17292:	2300      	movs	r3, #0
   17294:	9617      	str	r6, [sp, #92]	; 0x5c
   17296:	9315      	str	r3, [sp, #84]	; 0x54
   17298:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
   1729a:	2b09      	cmp	r3, #9
   1729c:	d862      	bhi.n	17364 <_dtoa_r+0x264>
   1729e:	2b05      	cmp	r3, #5
   172a0:	f340 8677 	ble.w	17f92 <_dtoa_r+0xe92>
   172a4:	982a      	ldr	r0, [sp, #168]	; 0xa8
   172a6:	2700      	movs	r7, #0
   172a8:	3804      	subs	r0, #4
   172aa:	902a      	str	r0, [sp, #168]	; 0xa8
   172ac:	992a      	ldr	r1, [sp, #168]	; 0xa8
   172ae:	1e8b      	subs	r3, r1, #2
   172b0:	2b03      	cmp	r3, #3
   172b2:	f200 83dd 	bhi.w	17a70 <_dtoa_r+0x970>
   172b6:	e8df f013 	tbh	[pc, r3, lsl #1]
   172ba:	03a5      	.short	0x03a5
   172bc:	03d503d8 	.word	0x03d503d8
   172c0:	03c4      	.short	0x03c4
   172c2:	f026 467f 	bic.w	r6, r6, #4278190080	; 0xff000000
   172c6:	f426 0670 	bic.w	r6, r6, #15728640	; 0xf00000
   172ca:	2e00      	cmp	r6, #0
   172cc:	f47f af64 	bne.w	17198 <_dtoa_r+0x98>
   172d0:	f244 1000 	movw	r0, #16640	; 0x4100
   172d4:	f2c0 0002 	movt	r0, #2
   172d8:	e762      	b.n	171a0 <_dtoa_r+0xa0>
   172da:	9f1f      	ldr	r7, [sp, #124]	; 0x7c
   172dc:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   172de:	18fb      	adds	r3, r7, r3
   172e0:	f503 6386 	add.w	r3, r3, #1072	; 0x430
   172e4:	1c9d      	adds	r5, r3, #2
   172e6:	2d20      	cmp	r5, #32
   172e8:	bfdc      	itt	le
   172ea:	f1c5 0020 	rsble	r0, r5, #32
   172ee:	fa08 f000 	lslle.w	r0, r8, r0
   172f2:	dd08      	ble.n	17306 <_dtoa_r+0x206>
   172f4:	3b1e      	subs	r3, #30
   172f6:	f1c5 0240 	rsb	r2, r5, #64	; 0x40
   172fa:	fa16 f202 	lsls.w	r2, r6, r2
   172fe:	fa28 f303 	lsr.w	r3, r8, r3
   17302:	ea42 0003 	orr.w	r0, r2, r3
   17306:	f7fd fa1f 	bl	14748 <__aeabi_ui2d>
   1730a:	f5a5 6586 	sub.w	r5, r5, #1072	; 0x430
   1730e:	2201      	movs	r2, #1
   17310:	3d03      	subs	r5, #3
   17312:	9219      	str	r2, [sp, #100]	; 0x64
   17314:	f1a1 71f8 	sub.w	r1, r1, #32505856	; 0x1f00000
   17318:	e770      	b.n	171fc <_dtoa_r+0xfc>
   1731a:	f244 00fc 	movw	r0, #16636	; 0x40fc
   1731e:	f2c0 0002 	movt	r0, #2
   17322:	e72e      	b.n	17182 <_dtoa_r+0x82>
   17324:	f244 1358 	movw	r3, #16728	; 0x4158
   17328:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
   1732c:	f2c0 0302 	movt	r3, #2
   17330:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
   17334:	e9d3 2300 	ldrd	r2, r3, [r3]
   17338:	f003 f888 	bl	1a44c <__aeabi_dcmplt>
   1733c:	2800      	cmp	r0, #0
   1733e:	f040 8320 	bne.w	17982 <_dtoa_r+0x882>
   17342:	9018      	str	r0, [sp, #96]	; 0x60
   17344:	e794      	b.n	17270 <_dtoa_r+0x170>
   17346:	bf00      	nop
   17348:	636f4361 	.word	0x636f4361
   1734c:	3fd287a7 	.word	0x3fd287a7
   17350:	8b60c8b3 	.word	0x8b60c8b3
   17354:	3fc68a28 	.word	0x3fc68a28
   17358:	509f79fb 	.word	0x509f79fb
   1735c:	3fd34413 	.word	0x3fd34413
   17360:	000240fd 	.word	0x000240fd
   17364:	2300      	movs	r3, #0
   17366:	f04f 30ff 	mov.w	r0, #4294967295
   1736a:	461f      	mov	r7, r3
   1736c:	2101      	movs	r1, #1
   1736e:	932a      	str	r3, [sp, #168]	; 0xa8
   17370:	9011      	str	r0, [sp, #68]	; 0x44
   17372:	9116      	str	r1, [sp, #88]	; 0x58
   17374:	9008      	str	r0, [sp, #32]
   17376:	932b      	str	r3, [sp, #172]	; 0xac
   17378:	6a65      	ldr	r5, [r4, #36]	; 0x24
   1737a:	2300      	movs	r3, #0
   1737c:	606b      	str	r3, [r5, #4]
   1737e:	4620      	mov	r0, r4
   17380:	6869      	ldr	r1, [r5, #4]
   17382:	f002 f811 	bl	193a8 <_Balloc>
   17386:	6a63      	ldr	r3, [r4, #36]	; 0x24
   17388:	6028      	str	r0, [r5, #0]
   1738a:	681b      	ldr	r3, [r3, #0]
   1738c:	9310      	str	r3, [sp, #64]	; 0x40
   1738e:	2f00      	cmp	r7, #0
   17390:	f000 815b 	beq.w	1764a <_dtoa_r+0x54a>
   17394:	2e00      	cmp	r6, #0
   17396:	f340 842a 	ble.w	17bee <_dtoa_r+0xaee>
   1739a:	f244 1358 	movw	r3, #16728	; 0x4158
   1739e:	f006 020f 	and.w	r2, r6, #15
   173a2:	f2c0 0302 	movt	r3, #2
   173a6:	1135      	asrs	r5, r6, #4
   173a8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   173ac:	f015 0f10 	tst.w	r5, #16
   173b0:	e9d3 0100 	ldrd	r0, r1, [r3]
   173b4:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   173b8:	f000 82e7 	beq.w	1798a <_dtoa_r+0x88a>
   173bc:	f244 2330 	movw	r3, #16944	; 0x4230
   173c0:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
   173c4:	f2c0 0302 	movt	r3, #2
   173c8:	f005 050f 	and.w	r5, r5, #15
   173cc:	f04f 0803 	mov.w	r8, #3
   173d0:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
   173d4:	f7fd fb58 	bl	14a88 <__aeabi_ddiv>
   173d8:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
   173dc:	b1bd      	cbz	r5, 1740e <_dtoa_r+0x30e>
   173de:	f244 2730 	movw	r7, #16944	; 0x4230
   173e2:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
   173e6:	f2c0 0702 	movt	r7, #2
   173ea:	f015 0f01 	tst.w	r5, #1
   173ee:	4610      	mov	r0, r2
   173f0:	4619      	mov	r1, r3
   173f2:	d007      	beq.n	17404 <_dtoa_r+0x304>
   173f4:	e9d7 2300 	ldrd	r2, r3, [r7]
   173f8:	f108 0801 	add.w	r8, r8, #1
   173fc:	f7fd fa1a 	bl	14834 <__aeabi_dmul>
   17400:	4602      	mov	r2, r0
   17402:	460b      	mov	r3, r1
   17404:	3708      	adds	r7, #8
   17406:	106d      	asrs	r5, r5, #1
   17408:	d1ef      	bne.n	173ea <_dtoa_r+0x2ea>
   1740a:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
   1740e:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
   17412:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
   17416:	f7fd fb37 	bl	14a88 <__aeabi_ddiv>
   1741a:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   1741e:	9918      	ldr	r1, [sp, #96]	; 0x60
   17420:	2900      	cmp	r1, #0
   17422:	f000 80de 	beq.w	175e2 <_dtoa_r+0x4e2>
   17426:	f240 0300 	movw	r3, #0
   1742a:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   1742e:	2200      	movs	r2, #0
   17430:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
   17434:	f04f 0500 	mov.w	r5, #0
   17438:	f003 f808 	bl	1a44c <__aeabi_dcmplt>
   1743c:	b108      	cbz	r0, 17442 <_dtoa_r+0x342>
   1743e:	f04f 0501 	mov.w	r5, #1
   17442:	9a08      	ldr	r2, [sp, #32]
   17444:	2a00      	cmp	r2, #0
   17446:	bfd4      	ite	le
   17448:	2500      	movle	r5, #0
   1744a:	f005 0501 	andgt.w	r5, r5, #1
   1744e:	2d00      	cmp	r5, #0
   17450:	f000 80c7 	beq.w	175e2 <_dtoa_r+0x4e2>
   17454:	9b11      	ldr	r3, [sp, #68]	; 0x44
   17456:	2b00      	cmp	r3, #0
   17458:	f340 80f5 	ble.w	17646 <_dtoa_r+0x546>
   1745c:	f240 0300 	movw	r3, #0
   17460:	2200      	movs	r2, #0
   17462:	f2c4 0324 	movt	r3, #16420	; 0x4024
   17466:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   1746a:	f7fd f9e3 	bl	14834 <__aeabi_dmul>
   1746e:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   17472:	f108 0001 	add.w	r0, r8, #1
   17476:	1e71      	subs	r1, r6, #1
   17478:	9112      	str	r1, [sp, #72]	; 0x48
   1747a:	f7fd f975 	bl	14768 <__aeabi_i2d>
   1747e:	4602      	mov	r2, r0
   17480:	460b      	mov	r3, r1
   17482:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   17486:	f7fd f9d5 	bl	14834 <__aeabi_dmul>
   1748a:	f240 0300 	movw	r3, #0
   1748e:	2200      	movs	r2, #0
   17490:	f2c4 031c 	movt	r3, #16412	; 0x401c
   17494:	f7fd f81c 	bl	144d0 <__adddf3>
   17498:	f8dd c044 	ldr.w	ip, [sp, #68]	; 0x44
   1749c:	4680      	mov	r8, r0
   1749e:	f1a1 7950 	sub.w	r9, r1, #54525952	; 0x3400000
   174a2:	9b16      	ldr	r3, [sp, #88]	; 0x58
   174a4:	2b00      	cmp	r3, #0
   174a6:	f000 83ad 	beq.w	17c04 <_dtoa_r+0xb04>
   174aa:	f244 1358 	movw	r3, #16728	; 0x4158
   174ae:	f240 0100 	movw	r1, #0
   174b2:	f2c0 0302 	movt	r3, #2
   174b6:	2000      	movs	r0, #0
   174b8:	eb03 03cc 	add.w	r3, r3, ip, lsl #3
   174bc:	f6c3 71e0 	movt	r1, #16352	; 0x3fe0
   174c0:	f8cd c00c 	str.w	ip, [sp, #12]
   174c4:	e953 2302 	ldrd	r2, r3, [r3, #-8]
   174c8:	f7fd fade 	bl	14a88 <__aeabi_ddiv>
   174cc:	4642      	mov	r2, r8
   174ce:	464b      	mov	r3, r9
   174d0:	9d10      	ldr	r5, [sp, #64]	; 0x40
   174d2:	f7fc fffb 	bl	144cc <__aeabi_dsub>
   174d6:	4680      	mov	r8, r0
   174d8:	4689      	mov	r9, r1
   174da:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   174de:	f002 ffdd 	bl	1a49c <__aeabi_d2iz>
   174e2:	4607      	mov	r7, r0
   174e4:	f7fd f940 	bl	14768 <__aeabi_i2d>
   174e8:	4602      	mov	r2, r0
   174ea:	460b      	mov	r3, r1
   174ec:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   174f0:	f7fc ffec 	bl	144cc <__aeabi_dsub>
   174f4:	f107 0330 	add.w	r3, r7, #48	; 0x30
   174f8:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   174fc:	4640      	mov	r0, r8
   174fe:	f805 3b01 	strb.w	r3, [r5], #1
   17502:	4649      	mov	r1, r9
   17504:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
   17508:	f002 ffbe 	bl	1a488 <__aeabi_dcmpgt>
   1750c:	2800      	cmp	r0, #0
   1750e:	f040 8213 	bne.w	17938 <_dtoa_r+0x838>
   17512:	f240 0100 	movw	r1, #0
   17516:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
   1751a:	2000      	movs	r0, #0
   1751c:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
   17520:	f7fc ffd4 	bl	144cc <__aeabi_dsub>
   17524:	4602      	mov	r2, r0
   17526:	460b      	mov	r3, r1
   17528:	4640      	mov	r0, r8
   1752a:	4649      	mov	r1, r9
   1752c:	f002 ffac 	bl	1a488 <__aeabi_dcmpgt>
   17530:	f8dd c00c 	ldr.w	ip, [sp, #12]
   17534:	2800      	cmp	r0, #0
   17536:	f040 83e7 	bne.w	17d08 <_dtoa_r+0xc08>
   1753a:	f1bc 0f01 	cmp.w	ip, #1
   1753e:	f340 8082 	ble.w	17646 <_dtoa_r+0x546>
   17542:	f8cd b068 	str.w	fp, [sp, #104]	; 0x68
   17546:	2701      	movs	r7, #1
   17548:	f8cd a070 	str.w	sl, [sp, #112]	; 0x70
   1754c:	961d      	str	r6, [sp, #116]	; 0x74
   1754e:	4666      	mov	r6, ip
   17550:	e9dd ab0c 	ldrd	sl, fp, [sp, #48]	; 0x30
   17554:	940c      	str	r4, [sp, #48]	; 0x30
   17556:	e010      	b.n	1757a <_dtoa_r+0x47a>
   17558:	f240 0100 	movw	r1, #0
   1755c:	2000      	movs	r0, #0
   1755e:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
   17562:	f7fc ffb3 	bl	144cc <__aeabi_dsub>
   17566:	4642      	mov	r2, r8
   17568:	464b      	mov	r3, r9
   1756a:	f002 ff6f 	bl	1a44c <__aeabi_dcmplt>
   1756e:	2800      	cmp	r0, #0
   17570:	f040 83c7 	bne.w	17d02 <_dtoa_r+0xc02>
   17574:	42b7      	cmp	r7, r6
   17576:	f280 848b 	bge.w	17e90 <_dtoa_r+0xd90>
   1757a:	f240 0300 	movw	r3, #0
   1757e:	4640      	mov	r0, r8
   17580:	4649      	mov	r1, r9
   17582:	2200      	movs	r2, #0
   17584:	f2c4 0324 	movt	r3, #16420	; 0x4024
   17588:	3501      	adds	r5, #1
   1758a:	f7fd f953 	bl	14834 <__aeabi_dmul>
   1758e:	f240 0300 	movw	r3, #0
   17592:	2200      	movs	r2, #0
   17594:	f2c4 0324 	movt	r3, #16420	; 0x4024
   17598:	4680      	mov	r8, r0
   1759a:	4689      	mov	r9, r1
   1759c:	4650      	mov	r0, sl
   1759e:	4659      	mov	r1, fp
   175a0:	f7fd f948 	bl	14834 <__aeabi_dmul>
   175a4:	468b      	mov	fp, r1
   175a6:	4682      	mov	sl, r0
   175a8:	f002 ff78 	bl	1a49c <__aeabi_d2iz>
   175ac:	4604      	mov	r4, r0
   175ae:	f7fd f8db 	bl	14768 <__aeabi_i2d>
   175b2:	3430      	adds	r4, #48	; 0x30
   175b4:	4602      	mov	r2, r0
   175b6:	460b      	mov	r3, r1
   175b8:	4650      	mov	r0, sl
   175ba:	4659      	mov	r1, fp
   175bc:	f7fc ff86 	bl	144cc <__aeabi_dsub>
   175c0:	9a10      	ldr	r2, [sp, #64]	; 0x40
   175c2:	464b      	mov	r3, r9
   175c4:	55d4      	strb	r4, [r2, r7]
   175c6:	4642      	mov	r2, r8
   175c8:	3701      	adds	r7, #1
   175ca:	4682      	mov	sl, r0
   175cc:	468b      	mov	fp, r1
   175ce:	f002 ff3d 	bl	1a44c <__aeabi_dcmplt>
   175d2:	4652      	mov	r2, sl
   175d4:	465b      	mov	r3, fp
   175d6:	2800      	cmp	r0, #0
   175d8:	d0be      	beq.n	17558 <_dtoa_r+0x458>
   175da:	f8dd b068 	ldr.w	fp, [sp, #104]	; 0x68
   175de:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   175e0:	e1aa      	b.n	17938 <_dtoa_r+0x838>
   175e2:	4640      	mov	r0, r8
   175e4:	f7fd f8c0 	bl	14768 <__aeabi_i2d>
   175e8:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
   175ec:	f7fd f922 	bl	14834 <__aeabi_dmul>
   175f0:	f240 0300 	movw	r3, #0
   175f4:	2200      	movs	r2, #0
   175f6:	f2c4 031c 	movt	r3, #16412	; 0x401c
   175fa:	f7fc ff69 	bl	144d0 <__adddf3>
   175fe:	9a08      	ldr	r2, [sp, #32]
   17600:	f1a1 7550 	sub.w	r5, r1, #54525952	; 0x3400000
   17604:	4680      	mov	r8, r0
   17606:	46a9      	mov	r9, r5
   17608:	2a00      	cmp	r2, #0
   1760a:	f040 82ec 	bne.w	17be6 <_dtoa_r+0xae6>
   1760e:	f240 0300 	movw	r3, #0
   17612:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   17616:	2200      	movs	r2, #0
   17618:	f2c4 0314 	movt	r3, #16404	; 0x4014
   1761c:	f7fc ff56 	bl	144cc <__aeabi_dsub>
   17620:	4642      	mov	r2, r8
   17622:	462b      	mov	r3, r5
   17624:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   17628:	f002 ff2e 	bl	1a488 <__aeabi_dcmpgt>
   1762c:	2800      	cmp	r0, #0
   1762e:	f040 824a 	bne.w	17ac6 <_dtoa_r+0x9c6>
   17632:	4642      	mov	r2, r8
   17634:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   17638:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
   1763c:	f002 ff06 	bl	1a44c <__aeabi_dcmplt>
   17640:	2800      	cmp	r0, #0
   17642:	f040 81d5 	bne.w	179f0 <_dtoa_r+0x8f0>
   17646:	e9dd 8906 	ldrd	r8, r9, [sp, #24]
   1764a:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   1764c:	ea6f 0703 	mvn.w	r7, r3
   17650:	ea4f 77d7 	mov.w	r7, r7, lsr #31
   17654:	2e0e      	cmp	r6, #14
   17656:	bfcc      	ite	gt
   17658:	2700      	movgt	r7, #0
   1765a:	f007 0701 	andle.w	r7, r7, #1
   1765e:	2f00      	cmp	r7, #0
   17660:	f000 80b7 	beq.w	177d2 <_dtoa_r+0x6d2>
   17664:	982b      	ldr	r0, [sp, #172]	; 0xac
   17666:	f244 1358 	movw	r3, #16728	; 0x4158
   1766a:	f2c0 0302 	movt	r3, #2
   1766e:	9908      	ldr	r1, [sp, #32]
   17670:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
   17674:	0fc2      	lsrs	r2, r0, #31
   17676:	2900      	cmp	r1, #0
   17678:	bfcc      	ite	gt
   1767a:	2200      	movgt	r2, #0
   1767c:	f002 0201 	andle.w	r2, r2, #1
   17680:	e9d3 0100 	ldrd	r0, r1, [r3]
   17684:	e9cd 0104 	strd	r0, r1, [sp, #16]
   17688:	2a00      	cmp	r2, #0
   1768a:	f040 81a0 	bne.w	179ce <_dtoa_r+0x8ce>
   1768e:	4602      	mov	r2, r0
   17690:	460b      	mov	r3, r1
   17692:	4640      	mov	r0, r8
   17694:	4649      	mov	r1, r9
   17696:	f7fd f9f7 	bl	14a88 <__aeabi_ddiv>
   1769a:	9d10      	ldr	r5, [sp, #64]	; 0x40
   1769c:	f002 fefe 	bl	1a49c <__aeabi_d2iz>
   176a0:	4682      	mov	sl, r0
   176a2:	f7fd f861 	bl	14768 <__aeabi_i2d>
   176a6:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   176aa:	f7fd f8c3 	bl	14834 <__aeabi_dmul>
   176ae:	4602      	mov	r2, r0
   176b0:	460b      	mov	r3, r1
   176b2:	4640      	mov	r0, r8
   176b4:	4649      	mov	r1, r9
   176b6:	f7fc ff09 	bl	144cc <__aeabi_dsub>
   176ba:	f10a 0330 	add.w	r3, sl, #48	; 0x30
   176be:	f805 3b01 	strb.w	r3, [r5], #1
   176c2:	9a08      	ldr	r2, [sp, #32]
   176c4:	2a01      	cmp	r2, #1
   176c6:	4680      	mov	r8, r0
   176c8:	4689      	mov	r9, r1
   176ca:	d052      	beq.n	17772 <_dtoa_r+0x672>
   176cc:	f240 0300 	movw	r3, #0
   176d0:	2200      	movs	r2, #0
   176d2:	f2c4 0324 	movt	r3, #16420	; 0x4024
   176d6:	f7fd f8ad 	bl	14834 <__aeabi_dmul>
   176da:	2200      	movs	r2, #0
   176dc:	2300      	movs	r3, #0
   176de:	e9cd 0106 	strd	r0, r1, [sp, #24]
   176e2:	f002 fea9 	bl	1a438 <__aeabi_dcmpeq>
   176e6:	2800      	cmp	r0, #0
   176e8:	f040 81eb 	bne.w	17ac2 <_dtoa_r+0x9c2>
   176ec:	9810      	ldr	r0, [sp, #64]	; 0x40
   176ee:	f04f 0801 	mov.w	r8, #1
   176f2:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
   176f6:	46a3      	mov	fp, r4
   176f8:	1c87      	adds	r7, r0, #2
   176fa:	960f      	str	r6, [sp, #60]	; 0x3c
   176fc:	f8dd 9020 	ldr.w	r9, [sp, #32]
   17700:	e9dd 4506 	ldrd	r4, r5, [sp, #24]
   17704:	e00a      	b.n	1771c <_dtoa_r+0x61c>
   17706:	f7fd f895 	bl	14834 <__aeabi_dmul>
   1770a:	2200      	movs	r2, #0
   1770c:	2300      	movs	r3, #0
   1770e:	4604      	mov	r4, r0
   17710:	460d      	mov	r5, r1
   17712:	f002 fe91 	bl	1a438 <__aeabi_dcmpeq>
   17716:	2800      	cmp	r0, #0
   17718:	f040 81ce 	bne.w	17ab8 <_dtoa_r+0x9b8>
   1771c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   17720:	4620      	mov	r0, r4
   17722:	4629      	mov	r1, r5
   17724:	f108 0801 	add.w	r8, r8, #1
   17728:	f7fd f9ae 	bl	14a88 <__aeabi_ddiv>
   1772c:	463e      	mov	r6, r7
   1772e:	f002 feb5 	bl	1a49c <__aeabi_d2iz>
   17732:	4682      	mov	sl, r0
   17734:	f7fd f818 	bl	14768 <__aeabi_i2d>
   17738:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   1773c:	f7fd f87a 	bl	14834 <__aeabi_dmul>
   17740:	4602      	mov	r2, r0
   17742:	460b      	mov	r3, r1
   17744:	4620      	mov	r0, r4
   17746:	4629      	mov	r1, r5
   17748:	f7fc fec0 	bl	144cc <__aeabi_dsub>
   1774c:	2200      	movs	r2, #0
   1774e:	f10a 0c30 	add.w	ip, sl, #48	; 0x30
   17752:	f807 cc01 	strb.w	ip, [r7, #-1]
   17756:	3701      	adds	r7, #1
   17758:	45c1      	cmp	r9, r8
   1775a:	f240 0300 	movw	r3, #0
   1775e:	f2c4 0324 	movt	r3, #16420	; 0x4024
   17762:	d1d0      	bne.n	17706 <_dtoa_r+0x606>
   17764:	4635      	mov	r5, r6
   17766:	465c      	mov	r4, fp
   17768:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
   1776a:	4680      	mov	r8, r0
   1776c:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
   17770:	4689      	mov	r9, r1
   17772:	4642      	mov	r2, r8
   17774:	464b      	mov	r3, r9
   17776:	4640      	mov	r0, r8
   17778:	4649      	mov	r1, r9
   1777a:	f7fc fea9 	bl	144d0 <__adddf3>
   1777e:	4680      	mov	r8, r0
   17780:	4689      	mov	r9, r1
   17782:	4642      	mov	r2, r8
   17784:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   17788:	464b      	mov	r3, r9
   1778a:	f002 fe5f 	bl	1a44c <__aeabi_dcmplt>
   1778e:	b960      	cbnz	r0, 177aa <_dtoa_r+0x6aa>
   17790:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   17794:	4642      	mov	r2, r8
   17796:	464b      	mov	r3, r9
   17798:	f002 fe4e 	bl	1a438 <__aeabi_dcmpeq>
   1779c:	2800      	cmp	r0, #0
   1779e:	f000 8190 	beq.w	17ac2 <_dtoa_r+0x9c2>
   177a2:	f01a 0f01 	tst.w	sl, #1
   177a6:	f000 818c 	beq.w	17ac2 <_dtoa_r+0x9c2>
   177aa:	9910      	ldr	r1, [sp, #64]	; 0x40
   177ac:	e000      	b.n	177b0 <_dtoa_r+0x6b0>
   177ae:	461d      	mov	r5, r3
   177b0:	f815 2c01 	ldrb.w	r2, [r5, #-1]
   177b4:	1e6b      	subs	r3, r5, #1
   177b6:	2a39      	cmp	r2, #57	; 0x39
   177b8:	f040 8367 	bne.w	17e8a <_dtoa_r+0xd8a>
   177bc:	428b      	cmp	r3, r1
   177be:	d1f6      	bne.n	177ae <_dtoa_r+0x6ae>
   177c0:	9910      	ldr	r1, [sp, #64]	; 0x40
   177c2:	2330      	movs	r3, #48	; 0x30
   177c4:	3601      	adds	r6, #1
   177c6:	2231      	movs	r2, #49	; 0x31
   177c8:	700b      	strb	r3, [r1, #0]
   177ca:	9b10      	ldr	r3, [sp, #64]	; 0x40
   177cc:	701a      	strb	r2, [r3, #0]
   177ce:	9612      	str	r6, [sp, #72]	; 0x48
   177d0:	e0b2      	b.n	17938 <_dtoa_r+0x838>
   177d2:	9a16      	ldr	r2, [sp, #88]	; 0x58
   177d4:	2a00      	cmp	r2, #0
   177d6:	f040 80df 	bne.w	17998 <_dtoa_r+0x898>
   177da:	9f15      	ldr	r7, [sp, #84]	; 0x54
   177dc:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
   177de:	920c      	str	r2, [sp, #48]	; 0x30
   177e0:	2d00      	cmp	r5, #0
   177e2:	bfd4      	ite	le
   177e4:	2300      	movle	r3, #0
   177e6:	2301      	movgt	r3, #1
   177e8:	f1ba 0f00 	cmp.w	sl, #0
   177ec:	bfd4      	ite	le
   177ee:	2300      	movle	r3, #0
   177f0:	f003 0301 	andgt.w	r3, r3, #1
   177f4:	b14b      	cbz	r3, 1780a <_dtoa_r+0x70a>
   177f6:	45aa      	cmp	sl, r5
   177f8:	bfb4      	ite	lt
   177fa:	4653      	movlt	r3, sl
   177fc:	462b      	movge	r3, r5
   177fe:	980f      	ldr	r0, [sp, #60]	; 0x3c
   17800:	ebc3 0a0a 	rsb	sl, r3, sl
   17804:	1aed      	subs	r5, r5, r3
   17806:	1ac0      	subs	r0, r0, r3
   17808:	900f      	str	r0, [sp, #60]	; 0x3c
   1780a:	9915      	ldr	r1, [sp, #84]	; 0x54
   1780c:	2900      	cmp	r1, #0
   1780e:	dd1c      	ble.n	1784a <_dtoa_r+0x74a>
   17810:	9a16      	ldr	r2, [sp, #88]	; 0x58
   17812:	2a00      	cmp	r2, #0
   17814:	f000 82e9 	beq.w	17dea <_dtoa_r+0xcea>
   17818:	2f00      	cmp	r7, #0
   1781a:	dd12      	ble.n	17842 <_dtoa_r+0x742>
   1781c:	990c      	ldr	r1, [sp, #48]	; 0x30
   1781e:	463a      	mov	r2, r7
   17820:	4620      	mov	r0, r4
   17822:	f002 f821 	bl	19868 <__pow5mult>
   17826:	465a      	mov	r2, fp
   17828:	900c      	str	r0, [sp, #48]	; 0x30
   1782a:	4620      	mov	r0, r4
   1782c:	990c      	ldr	r1, [sp, #48]	; 0x30
   1782e:	f001 ff33 	bl	19698 <__multiply>
   17832:	4659      	mov	r1, fp
   17834:	4603      	mov	r3, r0
   17836:	4620      	mov	r0, r4
   17838:	9303      	str	r3, [sp, #12]
   1783a:	f001 fd99 	bl	19370 <_Bfree>
   1783e:	9b03      	ldr	r3, [sp, #12]
   17840:	469b      	mov	fp, r3
   17842:	9b15      	ldr	r3, [sp, #84]	; 0x54
   17844:	1bda      	subs	r2, r3, r7
   17846:	f040 8311 	bne.w	17e6c <_dtoa_r+0xd6c>
   1784a:	2101      	movs	r1, #1
   1784c:	4620      	mov	r0, r4
   1784e:	f001 ffbd 	bl	197cc <__i2b>
   17852:	9006      	str	r0, [sp, #24]
   17854:	9817      	ldr	r0, [sp, #92]	; 0x5c
   17856:	2800      	cmp	r0, #0
   17858:	dd05      	ble.n	17866 <_dtoa_r+0x766>
   1785a:	9906      	ldr	r1, [sp, #24]
   1785c:	4620      	mov	r0, r4
   1785e:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   17860:	f002 f802 	bl	19868 <__pow5mult>
   17864:	9006      	str	r0, [sp, #24]
   17866:	992a      	ldr	r1, [sp, #168]	; 0xa8
   17868:	2901      	cmp	r1, #1
   1786a:	f340 810a 	ble.w	17a82 <_dtoa_r+0x982>
   1786e:	2700      	movs	r7, #0
   17870:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   17872:	2b00      	cmp	r3, #0
   17874:	f040 8261 	bne.w	17d3a <_dtoa_r+0xc3a>
   17878:	2301      	movs	r3, #1
   1787a:	4453      	add	r3, sl
   1787c:	f013 031f 	ands.w	r3, r3, #31
   17880:	f040 812a 	bne.w	17ad8 <_dtoa_r+0x9d8>
   17884:	231c      	movs	r3, #28
   17886:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   17888:	449a      	add	sl, r3
   1788a:	18ed      	adds	r5, r5, r3
   1788c:	18d2      	adds	r2, r2, r3
   1788e:	920f      	str	r2, [sp, #60]	; 0x3c
   17890:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   17892:	2b00      	cmp	r3, #0
   17894:	dd05      	ble.n	178a2 <_dtoa_r+0x7a2>
   17896:	4659      	mov	r1, fp
   17898:	461a      	mov	r2, r3
   1789a:	4620      	mov	r0, r4
   1789c:	f001 fe9e 	bl	195dc <__lshift>
   178a0:	4683      	mov	fp, r0
   178a2:	f1ba 0f00 	cmp.w	sl, #0
   178a6:	dd05      	ble.n	178b4 <_dtoa_r+0x7b4>
   178a8:	9906      	ldr	r1, [sp, #24]
   178aa:	4652      	mov	r2, sl
   178ac:	4620      	mov	r0, r4
   178ae:	f001 fe95 	bl	195dc <__lshift>
   178b2:	9006      	str	r0, [sp, #24]
   178b4:	9818      	ldr	r0, [sp, #96]	; 0x60
   178b6:	2800      	cmp	r0, #0
   178b8:	f040 8229 	bne.w	17d0e <_dtoa_r+0xc0e>
   178bc:	982a      	ldr	r0, [sp, #168]	; 0xa8
   178be:	9908      	ldr	r1, [sp, #32]
   178c0:	2802      	cmp	r0, #2
   178c2:	bfd4      	ite	le
   178c4:	2300      	movle	r3, #0
   178c6:	2301      	movgt	r3, #1
   178c8:	2900      	cmp	r1, #0
   178ca:	bfcc      	ite	gt
   178cc:	2300      	movgt	r3, #0
   178ce:	f003 0301 	andle.w	r3, r3, #1
   178d2:	2b00      	cmp	r3, #0
   178d4:	f000 810c 	beq.w	17af0 <_dtoa_r+0x9f0>
   178d8:	2900      	cmp	r1, #0
   178da:	f040 808c 	bne.w	179f6 <_dtoa_r+0x8f6>
   178de:	2205      	movs	r2, #5
   178e0:	9906      	ldr	r1, [sp, #24]
   178e2:	9b08      	ldr	r3, [sp, #32]
   178e4:	4620      	mov	r0, r4
   178e6:	f001 ff7b 	bl	197e0 <__multadd>
   178ea:	9006      	str	r0, [sp, #24]
   178ec:	4658      	mov	r0, fp
   178ee:	9906      	ldr	r1, [sp, #24]
   178f0:	f001 fc04 	bl	190fc <__mcmp>
   178f4:	2800      	cmp	r0, #0
   178f6:	dd7e      	ble.n	179f6 <_dtoa_r+0x8f6>
   178f8:	9d10      	ldr	r5, [sp, #64]	; 0x40
   178fa:	3601      	adds	r6, #1
   178fc:	2700      	movs	r7, #0
   178fe:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
   17902:	2331      	movs	r3, #49	; 0x31
   17904:	f805 3b01 	strb.w	r3, [r5], #1
   17908:	9906      	ldr	r1, [sp, #24]
   1790a:	4620      	mov	r0, r4
   1790c:	f001 fd30 	bl	19370 <_Bfree>
   17910:	f1ba 0f00 	cmp.w	sl, #0
   17914:	f000 80d5 	beq.w	17ac2 <_dtoa_r+0x9c2>
   17918:	1e3b      	subs	r3, r7, #0
   1791a:	bf18      	it	ne
   1791c:	2301      	movne	r3, #1
   1791e:	4557      	cmp	r7, sl
   17920:	bf0c      	ite	eq
   17922:	2300      	moveq	r3, #0
   17924:	f003 0301 	andne.w	r3, r3, #1
   17928:	2b00      	cmp	r3, #0
   1792a:	f040 80d0 	bne.w	17ace <_dtoa_r+0x9ce>
   1792e:	4651      	mov	r1, sl
   17930:	4620      	mov	r0, r4
   17932:	f001 fd1d 	bl	19370 <_Bfree>
   17936:	9612      	str	r6, [sp, #72]	; 0x48
   17938:	4620      	mov	r0, r4
   1793a:	4659      	mov	r1, fp
   1793c:	f001 fd18 	bl	19370 <_Bfree>
   17940:	9a12      	ldr	r2, [sp, #72]	; 0x48
   17942:	1c53      	adds	r3, r2, #1
   17944:	2200      	movs	r2, #0
   17946:	702a      	strb	r2, [r5, #0]
   17948:	982c      	ldr	r0, [sp, #176]	; 0xb0
   1794a:	992e      	ldr	r1, [sp, #184]	; 0xb8
   1794c:	6003      	str	r3, [r0, #0]
   1794e:	2900      	cmp	r1, #0
   17950:	f000 81d4 	beq.w	17cfc <_dtoa_r+0xbfc>
   17954:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
   17956:	9810      	ldr	r0, [sp, #64]	; 0x40
   17958:	6015      	str	r5, [r2, #0]
   1795a:	e412      	b.n	17182 <_dtoa_r+0x82>
   1795c:	2010      	movs	r0, #16
   1795e:	f000 ffd5 	bl	1890c <malloc>
   17962:	60c6      	str	r6, [r0, #12]
   17964:	6046      	str	r6, [r0, #4]
   17966:	6086      	str	r6, [r0, #8]
   17968:	6006      	str	r6, [r0, #0]
   1796a:	4606      	mov	r6, r0
   1796c:	6260      	str	r0, [r4, #36]	; 0x24
   1796e:	f7ff bbd2 	b.w	17116 <_dtoa_r+0x16>
   17972:	980f      	ldr	r0, [sp, #60]	; 0x3c
   17974:	4271      	negs	r1, r6
   17976:	2200      	movs	r2, #0
   17978:	9115      	str	r1, [sp, #84]	; 0x54
   1797a:	1b80      	subs	r0, r0, r6
   1797c:	9217      	str	r2, [sp, #92]	; 0x5c
   1797e:	900f      	str	r0, [sp, #60]	; 0x3c
   17980:	e48a      	b.n	17298 <_dtoa_r+0x198>
   17982:	2100      	movs	r1, #0
   17984:	3e01      	subs	r6, #1
   17986:	9118      	str	r1, [sp, #96]	; 0x60
   17988:	e472      	b.n	17270 <_dtoa_r+0x170>
   1798a:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   1798e:	f04f 0802 	mov.w	r8, #2
   17992:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
   17996:	e521      	b.n	173dc <_dtoa_r+0x2dc>
   17998:	982a      	ldr	r0, [sp, #168]	; 0xa8
   1799a:	2801      	cmp	r0, #1
   1799c:	f340 826c 	ble.w	17e78 <_dtoa_r+0xd78>
   179a0:	9a08      	ldr	r2, [sp, #32]
   179a2:	9815      	ldr	r0, [sp, #84]	; 0x54
   179a4:	1e53      	subs	r3, r2, #1
   179a6:	4298      	cmp	r0, r3
   179a8:	f2c0 8258 	blt.w	17e5c <_dtoa_r+0xd5c>
   179ac:	1ac7      	subs	r7, r0, r3
   179ae:	9b08      	ldr	r3, [sp, #32]
   179b0:	2b00      	cmp	r3, #0
   179b2:	bfa8      	it	ge
   179b4:	9d0f      	ldrge	r5, [sp, #60]	; 0x3c
   179b6:	f2c0 8273 	blt.w	17ea0 <_dtoa_r+0xda0>
   179ba:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   179bc:	4620      	mov	r0, r4
   179be:	2101      	movs	r1, #1
   179c0:	449a      	add	sl, r3
   179c2:	18d2      	adds	r2, r2, r3
   179c4:	920f      	str	r2, [sp, #60]	; 0x3c
   179c6:	f001 ff01 	bl	197cc <__i2b>
   179ca:	900c      	str	r0, [sp, #48]	; 0x30
   179cc:	e708      	b.n	177e0 <_dtoa_r+0x6e0>
   179ce:	9b08      	ldr	r3, [sp, #32]
   179d0:	b973      	cbnz	r3, 179f0 <_dtoa_r+0x8f0>
   179d2:	f240 0300 	movw	r3, #0
   179d6:	2200      	movs	r2, #0
   179d8:	f2c4 0314 	movt	r3, #16404	; 0x4014
   179dc:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   179e0:	f7fc ff28 	bl	14834 <__aeabi_dmul>
   179e4:	4642      	mov	r2, r8
   179e6:	464b      	mov	r3, r9
   179e8:	f002 fd44 	bl	1a474 <__aeabi_dcmpge>
   179ec:	2800      	cmp	r0, #0
   179ee:	d06a      	beq.n	17ac6 <_dtoa_r+0x9c6>
   179f0:	2200      	movs	r2, #0
   179f2:	9206      	str	r2, [sp, #24]
   179f4:	920c      	str	r2, [sp, #48]	; 0x30
   179f6:	9b2b      	ldr	r3, [sp, #172]	; 0xac
   179f8:	2700      	movs	r7, #0
   179fa:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
   179fe:	43de      	mvns	r6, r3
   17a00:	9d10      	ldr	r5, [sp, #64]	; 0x40
   17a02:	e781      	b.n	17908 <_dtoa_r+0x808>
   17a04:	2100      	movs	r1, #0
   17a06:	9116      	str	r1, [sp, #88]	; 0x58
   17a08:	982b      	ldr	r0, [sp, #172]	; 0xac
   17a0a:	2800      	cmp	r0, #0
   17a0c:	f340 819f 	ble.w	17d4e <_dtoa_r+0xc4e>
   17a10:	982b      	ldr	r0, [sp, #172]	; 0xac
   17a12:	4601      	mov	r1, r0
   17a14:	9011      	str	r0, [sp, #68]	; 0x44
   17a16:	9008      	str	r0, [sp, #32]
   17a18:	6a65      	ldr	r5, [r4, #36]	; 0x24
   17a1a:	2200      	movs	r2, #0
   17a1c:	2917      	cmp	r1, #23
   17a1e:	606a      	str	r2, [r5, #4]
   17a20:	f240 82ab 	bls.w	17f7a <_dtoa_r+0xe7a>
   17a24:	2304      	movs	r3, #4
   17a26:	005b      	lsls	r3, r3, #1
   17a28:	3201      	adds	r2, #1
   17a2a:	f103 0014 	add.w	r0, r3, #20
   17a2e:	4288      	cmp	r0, r1
   17a30:	d9f9      	bls.n	17a26 <_dtoa_r+0x926>
   17a32:	9b08      	ldr	r3, [sp, #32]
   17a34:	606a      	str	r2, [r5, #4]
   17a36:	2b0e      	cmp	r3, #14
   17a38:	bf8c      	ite	hi
   17a3a:	2700      	movhi	r7, #0
   17a3c:	f007 0701 	andls.w	r7, r7, #1
   17a40:	e49d      	b.n	1737e <_dtoa_r+0x27e>
   17a42:	2201      	movs	r2, #1
   17a44:	9216      	str	r2, [sp, #88]	; 0x58
   17a46:	9b2b      	ldr	r3, [sp, #172]	; 0xac
   17a48:	18f3      	adds	r3, r6, r3
   17a4a:	9311      	str	r3, [sp, #68]	; 0x44
   17a4c:	1c59      	adds	r1, r3, #1
   17a4e:	2900      	cmp	r1, #0
   17a50:	bfc8      	it	gt
   17a52:	9108      	strgt	r1, [sp, #32]
   17a54:	dce0      	bgt.n	17a18 <_dtoa_r+0x918>
   17a56:	290e      	cmp	r1, #14
   17a58:	bf8c      	ite	hi
   17a5a:	2700      	movhi	r7, #0
   17a5c:	f007 0701 	andls.w	r7, r7, #1
   17a60:	9108      	str	r1, [sp, #32]
   17a62:	e489      	b.n	17378 <_dtoa_r+0x278>
   17a64:	2301      	movs	r3, #1
   17a66:	9316      	str	r3, [sp, #88]	; 0x58
   17a68:	e7ce      	b.n	17a08 <_dtoa_r+0x908>
   17a6a:	2200      	movs	r2, #0
   17a6c:	9216      	str	r2, [sp, #88]	; 0x58
   17a6e:	e7ea      	b.n	17a46 <_dtoa_r+0x946>
   17a70:	f04f 33ff 	mov.w	r3, #4294967295
   17a74:	2700      	movs	r7, #0
   17a76:	2001      	movs	r0, #1
   17a78:	9311      	str	r3, [sp, #68]	; 0x44
   17a7a:	9016      	str	r0, [sp, #88]	; 0x58
   17a7c:	9308      	str	r3, [sp, #32]
   17a7e:	972b      	str	r7, [sp, #172]	; 0xac
   17a80:	e47a      	b.n	17378 <_dtoa_r+0x278>
   17a82:	f1b8 0f00 	cmp.w	r8, #0
   17a86:	f47f aef2 	bne.w	1786e <_dtoa_r+0x76e>
   17a8a:	f029 437f 	bic.w	r3, r9, #4278190080	; 0xff000000
   17a8e:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
   17a92:	2b00      	cmp	r3, #0
   17a94:	f47f aeeb 	bne.w	1786e <_dtoa_r+0x76e>
   17a98:	f240 0300 	movw	r3, #0
   17a9c:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
   17aa0:	ea09 0303 	and.w	r3, r9, r3
   17aa4:	2b00      	cmp	r3, #0
   17aa6:	f43f aee2 	beq.w	1786e <_dtoa_r+0x76e>
   17aaa:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   17aac:	f10a 0a01 	add.w	sl, sl, #1
   17ab0:	2701      	movs	r7, #1
   17ab2:	3201      	adds	r2, #1
   17ab4:	920f      	str	r2, [sp, #60]	; 0x3c
   17ab6:	e6db      	b.n	17870 <_dtoa_r+0x770>
   17ab8:	4635      	mov	r5, r6
   17aba:	465c      	mov	r4, fp
   17abc:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
   17abe:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
   17ac2:	9612      	str	r6, [sp, #72]	; 0x48
   17ac4:	e738      	b.n	17938 <_dtoa_r+0x838>
   17ac6:	2000      	movs	r0, #0
   17ac8:	9006      	str	r0, [sp, #24]
   17aca:	900c      	str	r0, [sp, #48]	; 0x30
   17acc:	e714      	b.n	178f8 <_dtoa_r+0x7f8>
   17ace:	4639      	mov	r1, r7
   17ad0:	4620      	mov	r0, r4
   17ad2:	f001 fc4d 	bl	19370 <_Bfree>
   17ad6:	e72a      	b.n	1792e <_dtoa_r+0x82e>
   17ad8:	f1c3 0320 	rsb	r3, r3, #32
   17adc:	2b04      	cmp	r3, #4
   17ade:	f340 8254 	ble.w	17f8a <_dtoa_r+0xe8a>
   17ae2:	990f      	ldr	r1, [sp, #60]	; 0x3c
   17ae4:	3b04      	subs	r3, #4
   17ae6:	449a      	add	sl, r3
   17ae8:	18ed      	adds	r5, r5, r3
   17aea:	18c9      	adds	r1, r1, r3
   17aec:	910f      	str	r1, [sp, #60]	; 0x3c
   17aee:	e6cf      	b.n	17890 <_dtoa_r+0x790>
   17af0:	9916      	ldr	r1, [sp, #88]	; 0x58
   17af2:	2900      	cmp	r1, #0
   17af4:	f000 8131 	beq.w	17d5a <_dtoa_r+0xc5a>
   17af8:	2d00      	cmp	r5, #0
   17afa:	dd05      	ble.n	17b08 <_dtoa_r+0xa08>
   17afc:	990c      	ldr	r1, [sp, #48]	; 0x30
   17afe:	462a      	mov	r2, r5
   17b00:	4620      	mov	r0, r4
   17b02:	f001 fd6b 	bl	195dc <__lshift>
   17b06:	900c      	str	r0, [sp, #48]	; 0x30
   17b08:	2f00      	cmp	r7, #0
   17b0a:	f040 81ea 	bne.w	17ee2 <_dtoa_r+0xde2>
   17b0e:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
   17b12:	9d10      	ldr	r5, [sp, #64]	; 0x40
   17b14:	2301      	movs	r3, #1
   17b16:	f008 0001 	and.w	r0, r8, #1
   17b1a:	9f0c      	ldr	r7, [sp, #48]	; 0x30
   17b1c:	9011      	str	r0, [sp, #68]	; 0x44
   17b1e:	950f      	str	r5, [sp, #60]	; 0x3c
   17b20:	461d      	mov	r5, r3
   17b22:	960c      	str	r6, [sp, #48]	; 0x30
   17b24:	9906      	ldr	r1, [sp, #24]
   17b26:	4658      	mov	r0, fp
   17b28:	f7ff fa5a 	bl	16fe0 <quorem>
   17b2c:	4639      	mov	r1, r7
   17b2e:	3030      	adds	r0, #48	; 0x30
   17b30:	900b      	str	r0, [sp, #44]	; 0x2c
   17b32:	4658      	mov	r0, fp
   17b34:	f001 fae2 	bl	190fc <__mcmp>
   17b38:	9906      	ldr	r1, [sp, #24]
   17b3a:	4652      	mov	r2, sl
   17b3c:	4606      	mov	r6, r0
   17b3e:	4620      	mov	r0, r4
   17b40:	f001 fcd0 	bl	194e4 <__mdiff>
   17b44:	68c3      	ldr	r3, [r0, #12]
   17b46:	4680      	mov	r8, r0
   17b48:	2b00      	cmp	r3, #0
   17b4a:	d03d      	beq.n	17bc8 <_dtoa_r+0xac8>
   17b4c:	f04f 0901 	mov.w	r9, #1
   17b50:	4641      	mov	r1, r8
   17b52:	4620      	mov	r0, r4
   17b54:	f001 fc0c 	bl	19370 <_Bfree>
   17b58:	992a      	ldr	r1, [sp, #168]	; 0xa8
   17b5a:	ea59 0101 	orrs.w	r1, r9, r1
   17b5e:	d103      	bne.n	17b68 <_dtoa_r+0xa68>
   17b60:	9a11      	ldr	r2, [sp, #68]	; 0x44
   17b62:	2a00      	cmp	r2, #0
   17b64:	f000 81eb 	beq.w	17f3e <_dtoa_r+0xe3e>
   17b68:	2e00      	cmp	r6, #0
   17b6a:	f2c0 819e 	blt.w	17eaa <_dtoa_r+0xdaa>
   17b6e:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
   17b70:	4332      	orrs	r2, r6
   17b72:	d103      	bne.n	17b7c <_dtoa_r+0xa7c>
   17b74:	9b11      	ldr	r3, [sp, #68]	; 0x44
   17b76:	2b00      	cmp	r3, #0
   17b78:	f000 8197 	beq.w	17eaa <_dtoa_r+0xdaa>
   17b7c:	f1b9 0f00 	cmp.w	r9, #0
   17b80:	f300 81ce 	bgt.w	17f20 <_dtoa_r+0xe20>
   17b84:	990f      	ldr	r1, [sp, #60]	; 0x3c
   17b86:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   17b88:	f801 2b01 	strb.w	r2, [r1], #1
   17b8c:	9b08      	ldr	r3, [sp, #32]
   17b8e:	910f      	str	r1, [sp, #60]	; 0x3c
   17b90:	429d      	cmp	r5, r3
   17b92:	f000 81c2 	beq.w	17f1a <_dtoa_r+0xe1a>
   17b96:	4659      	mov	r1, fp
   17b98:	220a      	movs	r2, #10
   17b9a:	2300      	movs	r3, #0
   17b9c:	4620      	mov	r0, r4
   17b9e:	f001 fe1f 	bl	197e0 <__multadd>
   17ba2:	4557      	cmp	r7, sl
   17ba4:	4639      	mov	r1, r7
   17ba6:	4683      	mov	fp, r0
   17ba8:	d014      	beq.n	17bd4 <_dtoa_r+0xad4>
   17baa:	220a      	movs	r2, #10
   17bac:	2300      	movs	r3, #0
   17bae:	4620      	mov	r0, r4
   17bb0:	3501      	adds	r5, #1
   17bb2:	f001 fe15 	bl	197e0 <__multadd>
   17bb6:	4651      	mov	r1, sl
   17bb8:	220a      	movs	r2, #10
   17bba:	2300      	movs	r3, #0
   17bbc:	4607      	mov	r7, r0
   17bbe:	4620      	mov	r0, r4
   17bc0:	f001 fe0e 	bl	197e0 <__multadd>
   17bc4:	4682      	mov	sl, r0
   17bc6:	e7ad      	b.n	17b24 <_dtoa_r+0xa24>
   17bc8:	4658      	mov	r0, fp
   17bca:	4641      	mov	r1, r8
   17bcc:	f001 fa96 	bl	190fc <__mcmp>
   17bd0:	4681      	mov	r9, r0
   17bd2:	e7bd      	b.n	17b50 <_dtoa_r+0xa50>
   17bd4:	4620      	mov	r0, r4
   17bd6:	220a      	movs	r2, #10
   17bd8:	2300      	movs	r3, #0
   17bda:	3501      	adds	r5, #1
   17bdc:	f001 fe00 	bl	197e0 <__multadd>
   17be0:	4607      	mov	r7, r0
   17be2:	4682      	mov	sl, r0
   17be4:	e79e      	b.n	17b24 <_dtoa_r+0xa24>
   17be6:	9612      	str	r6, [sp, #72]	; 0x48
   17be8:	f8dd c020 	ldr.w	ip, [sp, #32]
   17bec:	e459      	b.n	174a2 <_dtoa_r+0x3a2>
   17bee:	4275      	negs	r5, r6
   17bf0:	2d00      	cmp	r5, #0
   17bf2:	f040 8101 	bne.w	17df8 <_dtoa_r+0xcf8>
   17bf6:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
   17bfa:	f04f 0802 	mov.w	r8, #2
   17bfe:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   17c02:	e40c      	b.n	1741e <_dtoa_r+0x31e>
   17c04:	f244 1158 	movw	r1, #16728	; 0x4158
   17c08:	4642      	mov	r2, r8
   17c0a:	f2c0 0102 	movt	r1, #2
   17c0e:	464b      	mov	r3, r9
   17c10:	eb01 01cc 	add.w	r1, r1, ip, lsl #3
   17c14:	f8cd c00c 	str.w	ip, [sp, #12]
   17c18:	9d10      	ldr	r5, [sp, #64]	; 0x40
   17c1a:	e951 0102 	ldrd	r0, r1, [r1, #-8]
   17c1e:	f7fc fe09 	bl	14834 <__aeabi_dmul>
   17c22:	e9cd 011a 	strd	r0, r1, [sp, #104]	; 0x68
   17c26:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   17c2a:	f002 fc37 	bl	1a49c <__aeabi_d2iz>
   17c2e:	4607      	mov	r7, r0
   17c30:	f7fc fd9a 	bl	14768 <__aeabi_i2d>
   17c34:	460b      	mov	r3, r1
   17c36:	4602      	mov	r2, r0
   17c38:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   17c3c:	f7fc fc46 	bl	144cc <__aeabi_dsub>
   17c40:	f107 0330 	add.w	r3, r7, #48	; 0x30
   17c44:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   17c48:	f805 3b01 	strb.w	r3, [r5], #1
   17c4c:	f8dd c00c 	ldr.w	ip, [sp, #12]
   17c50:	f1bc 0f01 	cmp.w	ip, #1
   17c54:	d029      	beq.n	17caa <_dtoa_r+0xbaa>
   17c56:	46d1      	mov	r9, sl
   17c58:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   17c5c:	46b2      	mov	sl, r6
   17c5e:	9e10      	ldr	r6, [sp, #64]	; 0x40
   17c60:	951c      	str	r5, [sp, #112]	; 0x70
   17c62:	2701      	movs	r7, #1
   17c64:	4665      	mov	r5, ip
   17c66:	46a0      	mov	r8, r4
   17c68:	f240 0300 	movw	r3, #0
   17c6c:	2200      	movs	r2, #0
   17c6e:	f2c4 0324 	movt	r3, #16420	; 0x4024
   17c72:	f7fc fddf 	bl	14834 <__aeabi_dmul>
   17c76:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   17c7a:	f002 fc0f 	bl	1a49c <__aeabi_d2iz>
   17c7e:	4604      	mov	r4, r0
   17c80:	f7fc fd72 	bl	14768 <__aeabi_i2d>
   17c84:	3430      	adds	r4, #48	; 0x30
   17c86:	4602      	mov	r2, r0
   17c88:	460b      	mov	r3, r1
   17c8a:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   17c8e:	f7fc fc1d 	bl	144cc <__aeabi_dsub>
   17c92:	55f4      	strb	r4, [r6, r7]
   17c94:	3701      	adds	r7, #1
   17c96:	42af      	cmp	r7, r5
   17c98:	d1e6      	bne.n	17c68 <_dtoa_r+0xb68>
   17c9a:	9d1c      	ldr	r5, [sp, #112]	; 0x70
   17c9c:	3f01      	subs	r7, #1
   17c9e:	4656      	mov	r6, sl
   17ca0:	4644      	mov	r4, r8
   17ca2:	46ca      	mov	sl, r9
   17ca4:	19ed      	adds	r5, r5, r7
   17ca6:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   17caa:	f240 0300 	movw	r3, #0
   17cae:	2200      	movs	r2, #0
   17cb0:	f6c3 73e0 	movt	r3, #16352	; 0x3fe0
   17cb4:	e9dd 011a 	ldrd	r0, r1, [sp, #104]	; 0x68
   17cb8:	f7fc fc0a 	bl	144d0 <__adddf3>
   17cbc:	4602      	mov	r2, r0
   17cbe:	460b      	mov	r3, r1
   17cc0:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   17cc4:	f002 fbe0 	bl	1a488 <__aeabi_dcmpgt>
   17cc8:	b9f0      	cbnz	r0, 17d08 <_dtoa_r+0xc08>
   17cca:	f240 0100 	movw	r1, #0
   17cce:	e9dd 231a 	ldrd	r2, r3, [sp, #104]	; 0x68
   17cd2:	2000      	movs	r0, #0
   17cd4:	f6c3 71e0 	movt	r1, #16352	; 0x3fe0
   17cd8:	f7fc fbf8 	bl	144cc <__aeabi_dsub>
   17cdc:	4602      	mov	r2, r0
   17cde:	460b      	mov	r3, r1
   17ce0:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   17ce4:	f002 fbb2 	bl	1a44c <__aeabi_dcmplt>
   17ce8:	2800      	cmp	r0, #0
   17cea:	f43f acac 	beq.w	17646 <_dtoa_r+0x546>
   17cee:	462b      	mov	r3, r5
   17cf0:	461d      	mov	r5, r3
   17cf2:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
   17cf6:	2a30      	cmp	r2, #48	; 0x30
   17cf8:	d0fa      	beq.n	17cf0 <_dtoa_r+0xbf0>
   17cfa:	e61d      	b.n	17938 <_dtoa_r+0x838>
   17cfc:	9810      	ldr	r0, [sp, #64]	; 0x40
   17cfe:	f7ff ba40 	b.w	17182 <_dtoa_r+0x82>
   17d02:	f8dd b068 	ldr.w	fp, [sp, #104]	; 0x68
   17d06:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   17d08:	9e12      	ldr	r6, [sp, #72]	; 0x48
   17d0a:	9910      	ldr	r1, [sp, #64]	; 0x40
   17d0c:	e550      	b.n	177b0 <_dtoa_r+0x6b0>
   17d0e:	4658      	mov	r0, fp
   17d10:	9906      	ldr	r1, [sp, #24]
   17d12:	f001 f9f3 	bl	190fc <__mcmp>
   17d16:	2800      	cmp	r0, #0
   17d18:	f6bf add0 	bge.w	178bc <_dtoa_r+0x7bc>
   17d1c:	4659      	mov	r1, fp
   17d1e:	4620      	mov	r0, r4
   17d20:	220a      	movs	r2, #10
   17d22:	2300      	movs	r3, #0
   17d24:	f001 fd5c 	bl	197e0 <__multadd>
   17d28:	9916      	ldr	r1, [sp, #88]	; 0x58
   17d2a:	3e01      	subs	r6, #1
   17d2c:	4683      	mov	fp, r0
   17d2e:	2900      	cmp	r1, #0
   17d30:	f040 8119 	bne.w	17f66 <_dtoa_r+0xe66>
   17d34:	9a11      	ldr	r2, [sp, #68]	; 0x44
   17d36:	9208      	str	r2, [sp, #32]
   17d38:	e5c0      	b.n	178bc <_dtoa_r+0x7bc>
   17d3a:	9806      	ldr	r0, [sp, #24]
   17d3c:	6903      	ldr	r3, [r0, #16]
   17d3e:	eb00 0383 	add.w	r3, r0, r3, lsl #2
   17d42:	6918      	ldr	r0, [r3, #16]
   17d44:	f001 f988 	bl	19058 <__hi0bits>
   17d48:	f1c0 0320 	rsb	r3, r0, #32
   17d4c:	e595      	b.n	1787a <_dtoa_r+0x77a>
   17d4e:	2101      	movs	r1, #1
   17d50:	9111      	str	r1, [sp, #68]	; 0x44
   17d52:	9108      	str	r1, [sp, #32]
   17d54:	912b      	str	r1, [sp, #172]	; 0xac
   17d56:	f7ff bb0f 	b.w	17378 <_dtoa_r+0x278>
   17d5a:	9d10      	ldr	r5, [sp, #64]	; 0x40
   17d5c:	46b1      	mov	r9, r6
   17d5e:	9f16      	ldr	r7, [sp, #88]	; 0x58
   17d60:	46aa      	mov	sl, r5
   17d62:	f8dd 8018 	ldr.w	r8, [sp, #24]
   17d66:	9e08      	ldr	r6, [sp, #32]
   17d68:	e002      	b.n	17d70 <_dtoa_r+0xc70>
   17d6a:	f001 fd39 	bl	197e0 <__multadd>
   17d6e:	4683      	mov	fp, r0
   17d70:	4641      	mov	r1, r8
   17d72:	4658      	mov	r0, fp
   17d74:	f7ff f934 	bl	16fe0 <quorem>
   17d78:	3501      	adds	r5, #1
   17d7a:	220a      	movs	r2, #10
   17d7c:	2300      	movs	r3, #0
   17d7e:	4659      	mov	r1, fp
   17d80:	f100 0c30 	add.w	ip, r0, #48	; 0x30
   17d84:	f80a c007 	strb.w	ip, [sl, r7]
   17d88:	3701      	adds	r7, #1
   17d8a:	4620      	mov	r0, r4
   17d8c:	42be      	cmp	r6, r7
   17d8e:	dcec      	bgt.n	17d6a <_dtoa_r+0xc6a>
   17d90:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
   17d94:	464e      	mov	r6, r9
   17d96:	2700      	movs	r7, #0
   17d98:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
   17d9c:	4659      	mov	r1, fp
   17d9e:	2201      	movs	r2, #1
   17da0:	4620      	mov	r0, r4
   17da2:	f001 fc1b 	bl	195dc <__lshift>
   17da6:	9906      	ldr	r1, [sp, #24]
   17da8:	4683      	mov	fp, r0
   17daa:	f001 f9a7 	bl	190fc <__mcmp>
   17dae:	2800      	cmp	r0, #0
   17db0:	dd0f      	ble.n	17dd2 <_dtoa_r+0xcd2>
   17db2:	9910      	ldr	r1, [sp, #64]	; 0x40
   17db4:	e000      	b.n	17db8 <_dtoa_r+0xcb8>
   17db6:	461d      	mov	r5, r3
   17db8:	f815 2c01 	ldrb.w	r2, [r5, #-1]
   17dbc:	1e6b      	subs	r3, r5, #1
   17dbe:	2a39      	cmp	r2, #57	; 0x39
   17dc0:	f040 808c 	bne.w	17edc <_dtoa_r+0xddc>
   17dc4:	428b      	cmp	r3, r1
   17dc6:	d1f6      	bne.n	17db6 <_dtoa_r+0xcb6>
   17dc8:	9910      	ldr	r1, [sp, #64]	; 0x40
   17dca:	2331      	movs	r3, #49	; 0x31
   17dcc:	3601      	adds	r6, #1
   17dce:	700b      	strb	r3, [r1, #0]
   17dd0:	e59a      	b.n	17908 <_dtoa_r+0x808>
   17dd2:	d103      	bne.n	17ddc <_dtoa_r+0xcdc>
   17dd4:	980b      	ldr	r0, [sp, #44]	; 0x2c
   17dd6:	f010 0f01 	tst.w	r0, #1
   17dda:	d1ea      	bne.n	17db2 <_dtoa_r+0xcb2>
   17ddc:	462b      	mov	r3, r5
   17dde:	461d      	mov	r5, r3
   17de0:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
   17de4:	2a30      	cmp	r2, #48	; 0x30
   17de6:	d0fa      	beq.n	17dde <_dtoa_r+0xcde>
   17de8:	e58e      	b.n	17908 <_dtoa_r+0x808>
   17dea:	4659      	mov	r1, fp
   17dec:	9a15      	ldr	r2, [sp, #84]	; 0x54
   17dee:	4620      	mov	r0, r4
   17df0:	f001 fd3a 	bl	19868 <__pow5mult>
   17df4:	4683      	mov	fp, r0
   17df6:	e528      	b.n	1784a <_dtoa_r+0x74a>
   17df8:	f005 030f 	and.w	r3, r5, #15
   17dfc:	f244 1258 	movw	r2, #16728	; 0x4158
   17e00:	f2c0 0202 	movt	r2, #2
   17e04:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
   17e08:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   17e0c:	e9d3 2300 	ldrd	r2, r3, [r3]
   17e10:	f7fc fd10 	bl	14834 <__aeabi_dmul>
   17e14:	112d      	asrs	r5, r5, #4
   17e16:	bf08      	it	eq
   17e18:	f04f 0802 	moveq.w	r8, #2
   17e1c:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   17e20:	f43f aafd 	beq.w	1741e <_dtoa_r+0x31e>
   17e24:	f244 2730 	movw	r7, #16944	; 0x4230
   17e28:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
   17e2c:	f04f 0802 	mov.w	r8, #2
   17e30:	f2c0 0702 	movt	r7, #2
   17e34:	f015 0f01 	tst.w	r5, #1
   17e38:	4610      	mov	r0, r2
   17e3a:	4619      	mov	r1, r3
   17e3c:	d007      	beq.n	17e4e <_dtoa_r+0xd4e>
   17e3e:	e9d7 2300 	ldrd	r2, r3, [r7]
   17e42:	f108 0801 	add.w	r8, r8, #1
   17e46:	f7fc fcf5 	bl	14834 <__aeabi_dmul>
   17e4a:	4602      	mov	r2, r0
   17e4c:	460b      	mov	r3, r1
   17e4e:	3708      	adds	r7, #8
   17e50:	106d      	asrs	r5, r5, #1
   17e52:	d1ef      	bne.n	17e34 <_dtoa_r+0xd34>
   17e54:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
   17e58:	f7ff bae1 	b.w	1741e <_dtoa_r+0x31e>
   17e5c:	9915      	ldr	r1, [sp, #84]	; 0x54
   17e5e:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   17e60:	1a5b      	subs	r3, r3, r1
   17e62:	18c9      	adds	r1, r1, r3
   17e64:	18d2      	adds	r2, r2, r3
   17e66:	9115      	str	r1, [sp, #84]	; 0x54
   17e68:	9217      	str	r2, [sp, #92]	; 0x5c
   17e6a:	e5a0      	b.n	179ae <_dtoa_r+0x8ae>
   17e6c:	4659      	mov	r1, fp
   17e6e:	4620      	mov	r0, r4
   17e70:	f001 fcfa 	bl	19868 <__pow5mult>
   17e74:	4683      	mov	fp, r0
   17e76:	e4e8      	b.n	1784a <_dtoa_r+0x74a>
   17e78:	9919      	ldr	r1, [sp, #100]	; 0x64
   17e7a:	2900      	cmp	r1, #0
   17e7c:	d047      	beq.n	17f0e <_dtoa_r+0xe0e>
   17e7e:	f503 6386 	add.w	r3, r3, #1072	; 0x430
   17e82:	9f15      	ldr	r7, [sp, #84]	; 0x54
   17e84:	3303      	adds	r3, #3
   17e86:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
   17e88:	e597      	b.n	179ba <_dtoa_r+0x8ba>
   17e8a:	3201      	adds	r2, #1
   17e8c:	b2d2      	uxtb	r2, r2
   17e8e:	e49d      	b.n	177cc <_dtoa_r+0x6cc>
   17e90:	f8dd b068 	ldr.w	fp, [sp, #104]	; 0x68
   17e94:	f8dd a070 	ldr.w	sl, [sp, #112]	; 0x70
   17e98:	9e1d      	ldr	r6, [sp, #116]	; 0x74
   17e9a:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   17e9c:	f7ff bbd3 	b.w	17646 <_dtoa_r+0x546>
   17ea0:	990f      	ldr	r1, [sp, #60]	; 0x3c
   17ea2:	2300      	movs	r3, #0
   17ea4:	9808      	ldr	r0, [sp, #32]
   17ea6:	1a0d      	subs	r5, r1, r0
   17ea8:	e587      	b.n	179ba <_dtoa_r+0x8ba>
   17eaa:	f1b9 0f00 	cmp.w	r9, #0
   17eae:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
   17eb0:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   17eb2:	dd0f      	ble.n	17ed4 <_dtoa_r+0xdd4>
   17eb4:	4659      	mov	r1, fp
   17eb6:	2201      	movs	r2, #1
   17eb8:	4620      	mov	r0, r4
   17eba:	f001 fb8f 	bl	195dc <__lshift>
   17ebe:	9906      	ldr	r1, [sp, #24]
   17ec0:	4683      	mov	fp, r0
   17ec2:	f001 f91b 	bl	190fc <__mcmp>
   17ec6:	2800      	cmp	r0, #0
   17ec8:	dd47      	ble.n	17f5a <_dtoa_r+0xe5a>
   17eca:	990b      	ldr	r1, [sp, #44]	; 0x2c
   17ecc:	2939      	cmp	r1, #57	; 0x39
   17ece:	d031      	beq.n	17f34 <_dtoa_r+0xe34>
   17ed0:	3101      	adds	r1, #1
   17ed2:	910b      	str	r1, [sp, #44]	; 0x2c
   17ed4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   17ed6:	f805 2b01 	strb.w	r2, [r5], #1
   17eda:	e515      	b.n	17908 <_dtoa_r+0x808>
   17edc:	3201      	adds	r2, #1
   17ede:	701a      	strb	r2, [r3, #0]
   17ee0:	e512      	b.n	17908 <_dtoa_r+0x808>
   17ee2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   17ee4:	4620      	mov	r0, r4
   17ee6:	6851      	ldr	r1, [r2, #4]
   17ee8:	f001 fa5e 	bl	193a8 <_Balloc>
   17eec:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   17eee:	f103 010c 	add.w	r1, r3, #12
   17ef2:	691a      	ldr	r2, [r3, #16]
   17ef4:	3202      	adds	r2, #2
   17ef6:	0092      	lsls	r2, r2, #2
   17ef8:	4605      	mov	r5, r0
   17efa:	300c      	adds	r0, #12
   17efc:	f7fc ff52 	bl	14da4 <memcpy>
   17f00:	4620      	mov	r0, r4
   17f02:	4629      	mov	r1, r5
   17f04:	2201      	movs	r2, #1
   17f06:	f001 fb69 	bl	195dc <__lshift>
   17f0a:	4682      	mov	sl, r0
   17f0c:	e601      	b.n	17b12 <_dtoa_r+0xa12>
   17f0e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17f10:	9f15      	ldr	r7, [sp, #84]	; 0x54
   17f12:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
   17f14:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
   17f18:	e54f      	b.n	179ba <_dtoa_r+0x8ba>
   17f1a:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
   17f1c:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   17f1e:	e73d      	b.n	17d9c <_dtoa_r+0xc9c>
   17f20:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17f22:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
   17f24:	2b39      	cmp	r3, #57	; 0x39
   17f26:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   17f28:	d004      	beq.n	17f34 <_dtoa_r+0xe34>
   17f2a:	980b      	ldr	r0, [sp, #44]	; 0x2c
   17f2c:	1c43      	adds	r3, r0, #1
   17f2e:	f805 3b01 	strb.w	r3, [r5], #1
   17f32:	e4e9      	b.n	17908 <_dtoa_r+0x808>
   17f34:	2339      	movs	r3, #57	; 0x39
   17f36:	f805 3b01 	strb.w	r3, [r5], #1
   17f3a:	9910      	ldr	r1, [sp, #64]	; 0x40
   17f3c:	e73c      	b.n	17db8 <_dtoa_r+0xcb8>
   17f3e:	980b      	ldr	r0, [sp, #44]	; 0x2c
   17f40:	4633      	mov	r3, r6
   17f42:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
   17f44:	2839      	cmp	r0, #57	; 0x39
   17f46:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   17f48:	d0f4      	beq.n	17f34 <_dtoa_r+0xe34>
   17f4a:	2b00      	cmp	r3, #0
   17f4c:	dd01      	ble.n	17f52 <_dtoa_r+0xe52>
   17f4e:	3001      	adds	r0, #1
   17f50:	900b      	str	r0, [sp, #44]	; 0x2c
   17f52:	990b      	ldr	r1, [sp, #44]	; 0x2c
   17f54:	f805 1b01 	strb.w	r1, [r5], #1
   17f58:	e4d6      	b.n	17908 <_dtoa_r+0x808>
   17f5a:	d1bb      	bne.n	17ed4 <_dtoa_r+0xdd4>
   17f5c:	980b      	ldr	r0, [sp, #44]	; 0x2c
   17f5e:	f010 0f01 	tst.w	r0, #1
   17f62:	d0b7      	beq.n	17ed4 <_dtoa_r+0xdd4>
   17f64:	e7b1      	b.n	17eca <_dtoa_r+0xdca>
   17f66:	2300      	movs	r3, #0
   17f68:	990c      	ldr	r1, [sp, #48]	; 0x30
   17f6a:	4620      	mov	r0, r4
   17f6c:	220a      	movs	r2, #10
   17f6e:	f001 fc37 	bl	197e0 <__multadd>
   17f72:	9b11      	ldr	r3, [sp, #68]	; 0x44
   17f74:	9308      	str	r3, [sp, #32]
   17f76:	900c      	str	r0, [sp, #48]	; 0x30
   17f78:	e4a0      	b.n	178bc <_dtoa_r+0x7bc>
   17f7a:	9908      	ldr	r1, [sp, #32]
   17f7c:	290e      	cmp	r1, #14
   17f7e:	bf8c      	ite	hi
   17f80:	2700      	movhi	r7, #0
   17f82:	f007 0701 	andls.w	r7, r7, #1
   17f86:	f7ff b9fa 	b.w	1737e <_dtoa_r+0x27e>
   17f8a:	f43f ac81 	beq.w	17890 <_dtoa_r+0x790>
   17f8e:	331c      	adds	r3, #28
   17f90:	e479      	b.n	17886 <_dtoa_r+0x786>
   17f92:	2701      	movs	r7, #1
   17f94:	f7ff b98a 	b.w	172ac <_dtoa_r+0x1ac>

00017f98 <print_e>:
   17f98:	b5f0      	push	{r4, r5, r6, r7, lr}
   17f9a:	b08b      	sub	sp, #44	; 0x2c
   17f9c:	460e      	mov	r6, r1
   17f9e:	2102      	movs	r1, #2
   17fa0:	9c10      	ldr	r4, [sp, #64]	; 0x40
   17fa2:	9100      	str	r1, [sp, #0]
   17fa4:	9f12      	ldr	r7, [sp, #72]	; 0x48
   17fa6:	1c61      	adds	r1, r4, #1
   17fa8:	f89d 5044 	ldrb.w	r5, [sp, #68]	; 0x44
   17fac:	9101      	str	r1, [sp, #4]
   17fae:	a907      	add	r1, sp, #28
   17fb0:	9102      	str	r1, [sp, #8]
   17fb2:	a909      	add	r1, sp, #36	; 0x24
   17fb4:	9103      	str	r1, [sp, #12]
   17fb6:	a908      	add	r1, sp, #32
   17fb8:	9104      	str	r1, [sp, #16]
   17fba:	f7ff f8a1 	bl	17100 <_dtoa_r>
   17fbe:	f242 730f 	movw	r3, #9999	; 0x270f
   17fc2:	4601      	mov	r1, r0
   17fc4:	9807      	ldr	r0, [sp, #28]
   17fc6:	4298      	cmp	r0, r3
   17fc8:	d079      	beq.n	180be <print_e+0x126>
   17fca:	780a      	ldrb	r2, [r1, #0]
   17fcc:	4633      	mov	r3, r6
   17fce:	4327      	orrs	r7, r4
   17fd0:	bf08      	it	eq
   17fd2:	463c      	moveq	r4, r7
   17fd4:	f803 2b01 	strb.w	r2, [r3], #1
   17fd8:	d020      	beq.n	1801c <print_e+0x84>
   17fda:	222e      	movs	r2, #46	; 0x2e
   17fdc:	7072      	strb	r2, [r6, #1]
   17fde:	784a      	ldrb	r2, [r1, #1]
   17fe0:	2c00      	cmp	r4, #0
   17fe2:	bfd4      	ite	le
   17fe4:	2700      	movle	r7, #0
   17fe6:	2701      	movgt	r7, #1
   17fe8:	3301      	adds	r3, #1
   17fea:	2a00      	cmp	r2, #0
   17fec:	bf0c      	ite	eq
   17fee:	2700      	moveq	r7, #0
   17ff0:	f007 0701 	andne.w	r7, r7, #1
   17ff4:	b197      	cbz	r7, 1801c <print_e+0x84>
   17ff6:	3603      	adds	r6, #3
   17ff8:	f806 2c01 	strb.w	r2, [r6, #-1]
   17ffc:	3c01      	subs	r4, #1
   17ffe:	788a      	ldrb	r2, [r1, #2]
   18000:	4633      	mov	r3, r6
   18002:	3101      	adds	r1, #1
   18004:	3601      	adds	r6, #1
   18006:	1e10      	subs	r0, r2, #0
   18008:	bf18      	it	ne
   1800a:	2001      	movne	r0, #1
   1800c:	2c00      	cmp	r4, #0
   1800e:	bfd4      	ite	le
   18010:	2000      	movle	r0, #0
   18012:	f000 0001 	andgt.w	r0, r0, #1
   18016:	2800      	cmp	r0, #0
   18018:	d1ee      	bne.n	17ff8 <print_e+0x60>
   1801a:	9807      	ldr	r0, [sp, #28]
   1801c:	2d67      	cmp	r5, #103	; 0x67
   1801e:	d040      	beq.n	180a2 <print_e+0x10a>
   18020:	2d47      	cmp	r5, #71	; 0x47
   18022:	d04a      	beq.n	180ba <print_e+0x122>
   18024:	2c00      	cmp	r4, #0
   18026:	dd06      	ble.n	18036 <print_e+0x9e>
   18028:	2200      	movs	r2, #0
   1802a:	2130      	movs	r1, #48	; 0x30
   1802c:	5499      	strb	r1, [r3, r2]
   1802e:	3201      	adds	r2, #1
   18030:	42a2      	cmp	r2, r4
   18032:	d1fb      	bne.n	1802c <print_e+0x94>
   18034:	189b      	adds	r3, r3, r2
   18036:	461c      	mov	r4, r3
   18038:	3801      	subs	r0, #1
   1803a:	f804 5b01 	strb.w	r5, [r4], #1
   1803e:	d436      	bmi.n	180ae <print_e+0x116>
   18040:	3401      	adds	r4, #1
   18042:	4602      	mov	r2, r0
   18044:	212b      	movs	r1, #43	; 0x2b
   18046:	7059      	strb	r1, [r3, #1]
   18048:	2a63      	cmp	r2, #99	; 0x63
   1804a:	dd11      	ble.n	18070 <print_e+0xd8>
   1804c:	f248 531f 	movw	r3, #34079	; 0x851f
   18050:	17d1      	asrs	r1, r2, #31
   18052:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
   18056:	fb83 5302 	smull	r5, r3, r3, r2
   1805a:	ebc1 1363 	rsb	r3, r1, r3, asr #5
   1805e:	f103 0230 	add.w	r2, r3, #48	; 0x30
   18062:	f804 2b01 	strb.w	r2, [r4], #1
   18066:	f06f 0263 	mvn.w	r2, #99	; 0x63
   1806a:	fb02 0203 	mla	r2, r2, r3, r0
   1806e:	4610      	mov	r0, r2
   18070:	f246 6167 	movw	r1, #26215	; 0x6667
   18074:	ea4f 7ce2 	mov.w	ip, r2, asr #31
   18078:	f2c6 6166 	movt	r1, #26214	; 0x6666
   1807c:	4623      	mov	r3, r4
   1807e:	fb81 5202 	smull	r5, r2, r1, r2
   18082:	ebcc 02a2 	rsb	r2, ip, r2, asr #2
   18086:	f102 0130 	add.w	r1, r2, #48	; 0x30
   1808a:	f803 1b01 	strb.w	r1, [r3], #1
   1808e:	f06f 0109 	mvn.w	r1, #9
   18092:	fb01 0202 	mla	r2, r1, r2, r0
   18096:	3230      	adds	r2, #48	; 0x30
   18098:	7062      	strb	r2, [r4, #1]
   1809a:	2200      	movs	r2, #0
   1809c:	705a      	strb	r2, [r3, #1]
   1809e:	b00b      	add	sp, #44	; 0x2c
   180a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   180a2:	2565      	movs	r5, #101	; 0x65
   180a4:	461c      	mov	r4, r3
   180a6:	3801      	subs	r0, #1
   180a8:	f804 5b01 	strb.w	r5, [r4], #1
   180ac:	d5c8      	bpl.n	18040 <print_e+0xa8>
   180ae:	4242      	negs	r2, r0
   180b0:	212d      	movs	r1, #45	; 0x2d
   180b2:	3401      	adds	r4, #1
   180b4:	7059      	strb	r1, [r3, #1]
   180b6:	4610      	mov	r0, r2
   180b8:	e7c6      	b.n	18048 <print_e+0xb0>
   180ba:	2545      	movs	r5, #69	; 0x45
   180bc:	e7bb      	b.n	18036 <print_e+0x9e>
   180be:	4630      	mov	r0, r6
   180c0:	f7fd f8de 	bl	15280 <strcpy>
   180c4:	e7eb      	b.n	1809e <print_e+0x106>
   180c6:	bf00      	nop

000180c8 <_gcvt>:
   180c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   180cc:	4616      	mov	r6, r2
   180ce:	b08b      	sub	sp, #44	; 0x2c
   180d0:	461d      	mov	r5, r3
   180d2:	4680      	mov	r8, r0
   180d4:	469b      	mov	fp, r3
   180d6:	2200      	movs	r2, #0
   180d8:	2300      	movs	r3, #0
   180da:	4630      	mov	r0, r6
   180dc:	4629      	mov	r1, r5
   180de:	9c14      	ldr	r4, [sp, #80]	; 0x50
   180e0:	9f15      	ldr	r7, [sp, #84]	; 0x54
   180e2:	f8dd 905c 	ldr.w	r9, [sp, #92]	; 0x5c
   180e6:	f89d a058 	ldrb.w	sl, [sp, #88]	; 0x58
   180ea:	f002 f9af 	bl	1a44c <__aeabi_dcmplt>
   180ee:	b108      	cbz	r0, 180f4 <_gcvt+0x2c>
   180f0:	f105 4500 	add.w	r5, r5, #2147483648	; 0x80000000
   180f4:	4630      	mov	r0, r6
   180f6:	2200      	movs	r2, #0
   180f8:	2300      	movs	r3, #0
   180fa:	4629      	mov	r1, r5
   180fc:	f002 f99c 	bl	1a438 <__aeabi_dcmpeq>
   18100:	2800      	cmp	r0, #0
   18102:	f040 80c5 	bne.w	18290 <_gcvt+0x1c8>
   18106:	4630      	mov	r0, r6
   18108:	a36f      	add	r3, pc, #444	; (adr r3, 182c8 <_gcvt+0x200>)
   1810a:	e9d3 2300 	ldrd	r2, r3, [r3]
   1810e:	4629      	mov	r1, r5
   18110:	f002 f9a6 	bl	1a460 <__aeabi_dcmple>
   18114:	2800      	cmp	r0, #0
   18116:	f040 80ab 	bne.w	18270 <_gcvt+0x1a8>
   1811a:	4620      	mov	r0, r4
   1811c:	f001 f8b8 	bl	19290 <_mprec_log10>
   18120:	4632      	mov	r2, r6
   18122:	462b      	mov	r3, r5
   18124:	f002 f99c 	bl	1a460 <__aeabi_dcmple>
   18128:	2800      	cmp	r0, #0
   1812a:	f040 80a1 	bne.w	18270 <_gcvt+0x1a8>
   1812e:	f240 0300 	movw	r3, #0
   18132:	4630      	mov	r0, r6
   18134:	2200      	movs	r2, #0
   18136:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
   1813a:	4629      	mov	r1, r5
   1813c:	f002 f986 	bl	1a44c <__aeabi_dcmplt>
   18140:	2800      	cmp	r0, #0
   18142:	f040 80aa 	bne.w	1829a <_gcvt+0x1d2>
   18146:	4632      	mov	r2, r6
   18148:	4640      	mov	r0, r8
   1814a:	462b      	mov	r3, r5
   1814c:	2102      	movs	r1, #2
   1814e:	9401      	str	r4, [sp, #4]
   18150:	9100      	str	r1, [sp, #0]
   18152:	a909      	add	r1, sp, #36	; 0x24
   18154:	9102      	str	r1, [sp, #8]
   18156:	a908      	add	r1, sp, #32
   18158:	9103      	str	r1, [sp, #12]
   1815a:	a907      	add	r1, sp, #28
   1815c:	9104      	str	r1, [sp, #16]
   1815e:	f7fe ffcf 	bl	17100 <_dtoa_r>
   18162:	9a09      	ldr	r2, [sp, #36]	; 0x24
   18164:	f242 730f 	movw	r3, #9999	; 0x270f
   18168:	429a      	cmp	r2, r3
   1816a:	f000 80a1 	beq.w	182b0 <_gcvt+0x1e8>
   1816e:	7805      	ldrb	r5, [r0, #0]
   18170:	2d00      	cmp	r5, #0
   18172:	f000 80a2 	beq.w	182ba <_gcvt+0x1f2>
   18176:	2a00      	cmp	r2, #0
   18178:	bfc8      	it	gt
   1817a:	463b      	movgt	r3, r7
   1817c:	dc02      	bgt.n	18184 <_gcvt+0xbc>
   1817e:	e09e      	b.n	182be <_gcvt+0x1f6>
   18180:	2a00      	cmp	r2, #0
   18182:	dd25      	ble.n	181d0 <_gcvt+0x108>
   18184:	f803 5b01 	strb.w	r5, [r3], #1
   18188:	3c01      	subs	r4, #1
   1818a:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1818c:	3a01      	subs	r2, #1
   1818e:	9209      	str	r2, [sp, #36]	; 0x24
   18190:	f810 5f01 	ldrb.w	r5, [r0, #1]!
   18194:	2d00      	cmp	r5, #0
   18196:	d1f3      	bne.n	18180 <_gcvt+0xb8>
   18198:	2a00      	cmp	r2, #0
   1819a:	bfd4      	ite	le
   1819c:	2200      	movle	r2, #0
   1819e:	2201      	movgt	r2, #1
   181a0:	2c00      	cmp	r4, #0
   181a2:	bfd4      	ite	le
   181a4:	2200      	movle	r2, #0
   181a6:	f002 0201 	andgt.w	r2, r2, #1
   181aa:	b18a      	cbz	r2, 181d0 <_gcvt+0x108>
   181ac:	2130      	movs	r1, #48	; 0x30
   181ae:	f803 1b01 	strb.w	r1, [r3], #1
   181b2:	3c01      	subs	r4, #1
   181b4:	9a09      	ldr	r2, [sp, #36]	; 0x24
   181b6:	3a01      	subs	r2, #1
   181b8:	9209      	str	r2, [sp, #36]	; 0x24
   181ba:	2a00      	cmp	r2, #0
   181bc:	bfd4      	ite	le
   181be:	2200      	movle	r2, #0
   181c0:	2201      	movgt	r2, #1
   181c2:	2c00      	cmp	r4, #0
   181c4:	bfd4      	ite	le
   181c6:	2200      	movle	r2, #0
   181c8:	f002 0201 	andgt.w	r2, r2, #1
   181cc:	2a00      	cmp	r2, #0
   181ce:	d1ee      	bne.n	181ae <_gcvt+0xe6>
   181d0:	f1b9 0f00 	cmp.w	r9, #0
   181d4:	d102      	bne.n	181dc <_gcvt+0x114>
   181d6:	7802      	ldrb	r2, [r0, #0]
   181d8:	2a00      	cmp	r2, #0
   181da:	d046      	beq.n	1826a <_gcvt+0x1a2>
   181dc:	42bb      	cmp	r3, r7
   181de:	bf18      	it	ne
   181e0:	461a      	movne	r2, r3
   181e2:	d060      	beq.n	182a6 <_gcvt+0x1de>
   181e4:	4613      	mov	r3, r2
   181e6:	212e      	movs	r1, #46	; 0x2e
   181e8:	2c00      	cmp	r4, #0
   181ea:	bfd4      	ite	le
   181ec:	f04f 0c00 	movle.w	ip, #0
   181f0:	f04f 0c01 	movgt.w	ip, #1
   181f4:	f803 1b01 	strb.w	r1, [r3], #1
   181f8:	9909      	ldr	r1, [sp, #36]	; 0x24
   181fa:	ea1c 71d1 	ands.w	r1, ip, r1, lsr #31
   181fe:	d012      	beq.n	18226 <_gcvt+0x15e>
   18200:	3202      	adds	r2, #2
   18202:	2530      	movs	r5, #48	; 0x30
   18204:	f802 5c01 	strb.w	r5, [r2, #-1]
   18208:	3c01      	subs	r4, #1
   1820a:	9909      	ldr	r1, [sp, #36]	; 0x24
   1820c:	2c00      	cmp	r4, #0
   1820e:	bfd4      	ite	le
   18210:	f04f 0c00 	movle.w	ip, #0
   18214:	f04f 0c01 	movgt.w	ip, #1
   18218:	4613      	mov	r3, r2
   1821a:	3201      	adds	r2, #1
   1821c:	3101      	adds	r1, #1
   1821e:	9109      	str	r1, [sp, #36]	; 0x24
   18220:	ea1c 71d1 	ands.w	r1, ip, r1, lsr #31
   18224:	d1ee      	bne.n	18204 <_gcvt+0x13c>
   18226:	7802      	ldrb	r2, [r0, #0]
   18228:	2a00      	cmp	r2, #0
   1822a:	bf0c      	ite	eq
   1822c:	2100      	moveq	r1, #0
   1822e:	f00c 0101 	andne.w	r1, ip, #1
   18232:	b171      	cbz	r1, 18252 <_gcvt+0x18a>
   18234:	f803 2b01 	strb.w	r2, [r3], #1
   18238:	3c01      	subs	r4, #1
   1823a:	f810 2f01 	ldrb.w	r2, [r0, #1]!
   1823e:	1e11      	subs	r1, r2, #0
   18240:	bf18      	it	ne
   18242:	2101      	movne	r1, #1
   18244:	2c00      	cmp	r4, #0
   18246:	bfd4      	ite	le
   18248:	2100      	movle	r1, #0
   1824a:	f001 0101 	andgt.w	r1, r1, #1
   1824e:	2900      	cmp	r1, #0
   18250:	d1f0      	bne.n	18234 <_gcvt+0x16c>
   18252:	f1b9 0f00 	cmp.w	r9, #0
   18256:	d008      	beq.n	1826a <_gcvt+0x1a2>
   18258:	2c00      	cmp	r4, #0
   1825a:	dd06      	ble.n	1826a <_gcvt+0x1a2>
   1825c:	2200      	movs	r2, #0
   1825e:	2130      	movs	r1, #48	; 0x30
   18260:	5499      	strb	r1, [r3, r2]
   18262:	3201      	adds	r2, #1
   18264:	42a2      	cmp	r2, r4
   18266:	d1fb      	bne.n	18260 <_gcvt+0x198>
   18268:	189b      	adds	r3, r3, r2
   1826a:	2200      	movs	r2, #0
   1826c:	701a      	strb	r2, [r3, #0]
   1826e:	e00b      	b.n	18288 <_gcvt+0x1c0>
   18270:	4632      	mov	r2, r6
   18272:	4640      	mov	r0, r8
   18274:	462b      	mov	r3, r5
   18276:	4639      	mov	r1, r7
   18278:	3c01      	subs	r4, #1
   1827a:	f8cd a004 	str.w	sl, [sp, #4]
   1827e:	f8cd 9008 	str.w	r9, [sp, #8]
   18282:	9400      	str	r4, [sp, #0]
   18284:	f7ff fe88 	bl	17f98 <print_e>
   18288:	4638      	mov	r0, r7
   1828a:	b00b      	add	sp, #44	; 0x2c
   1828c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   18290:	2330      	movs	r3, #48	; 0x30
   18292:	703b      	strb	r3, [r7, #0]
   18294:	2300      	movs	r3, #0
   18296:	707b      	strb	r3, [r7, #1]
   18298:	e7f6      	b.n	18288 <_gcvt+0x1c0>
   1829a:	4632      	mov	r2, r6
   1829c:	4640      	mov	r0, r8
   1829e:	462b      	mov	r3, r5
   182a0:	9401      	str	r4, [sp, #4]
   182a2:	2103      	movs	r1, #3
   182a4:	e754      	b.n	18150 <_gcvt+0x88>
   182a6:	463a      	mov	r2, r7
   182a8:	2330      	movs	r3, #48	; 0x30
   182aa:	f802 3b01 	strb.w	r3, [r2], #1
   182ae:	e799      	b.n	181e4 <_gcvt+0x11c>
   182b0:	4601      	mov	r1, r0
   182b2:	4638      	mov	r0, r7
   182b4:	f7fc ffe4 	bl	15280 <strcpy>
   182b8:	e7e6      	b.n	18288 <_gcvt+0x1c0>
   182ba:	463b      	mov	r3, r7
   182bc:	e76c      	b.n	18198 <_gcvt+0xd0>
   182be:	463b      	mov	r3, r7
   182c0:	e786      	b.n	181d0 <_gcvt+0x108>
   182c2:	bf00      	nop
   182c4:	f3af 8000 	nop.w
   182c8:	eb1c432d 	.word	0xeb1c432d
   182cc:	3f1a36e2 	.word	0x3f1a36e2

000182d0 <ecvtbuf>:
   182d0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   182d4:	b08b      	sub	sp, #44	; 0x2c
   182d6:	4615      	mov	r5, r2
   182d8:	461e      	mov	r6, r3
   182da:	9c13      	ldr	r4, [sp, #76]	; 0x4c
   182dc:	4680      	mov	r8, r0
   182de:	4689      	mov	r9, r1
   182e0:	2c00      	cmp	r4, #0
   182e2:	d033      	beq.n	1834c <ecvtbuf+0x7c>
   182e4:	f240 03d8 	movw	r3, #216	; 0xd8
   182e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   182ec:	6818      	ldr	r0, [r3, #0]
   182ee:	9912      	ldr	r1, [sp, #72]	; 0x48
   182f0:	464b      	mov	r3, r9
   182f2:	4642      	mov	r2, r8
   182f4:	9602      	str	r6, [sp, #8]
   182f6:	9501      	str	r5, [sp, #4]
   182f8:	9103      	str	r1, [sp, #12]
   182fa:	2102      	movs	r1, #2
   182fc:	9100      	str	r1, [sp, #0]
   182fe:	a909      	add	r1, sp, #36	; 0x24
   18300:	9104      	str	r1, [sp, #16]
   18302:	f7fe fefd 	bl	17100 <_dtoa_r>
   18306:	9b09      	ldr	r3, [sp, #36]	; 0x24
   18308:	4298      	cmp	r0, r3
   1830a:	d237      	bcs.n	1837c <ecvtbuf+0xac>
   1830c:	4602      	mov	r2, r0
   1830e:	4621      	mov	r1, r4
   18310:	2300      	movs	r3, #0
   18312:	f810 c003 	ldrb.w	ip, [r0, r3]
   18316:	3201      	adds	r2, #1
   18318:	3101      	adds	r1, #1
   1831a:	f804 c003 	strb.w	ip, [r4, r3]
   1831e:	3301      	adds	r3, #1
   18320:	9e09      	ldr	r6, [sp, #36]	; 0x24
   18322:	4296      	cmp	r6, r2
   18324:	d8f5      	bhi.n	18312 <ecvtbuf+0x42>
   18326:	429d      	cmp	r5, r3
   18328:	dd0a      	ble.n	18340 <ecvtbuf+0x70>
   1832a:	2200      	movs	r2, #0
   1832c:	f04f 0c30 	mov.w	ip, #48	; 0x30
   18330:	f801 c002 	strb.w	ip, [r1, r2]
   18334:	3201      	adds	r2, #1
   18336:	18d0      	adds	r0, r2, r3
   18338:	4285      	cmp	r5, r0
   1833a:	dcf9      	bgt.n	18330 <ecvtbuf+0x60>
   1833c:	1aed      	subs	r5, r5, r3
   1833e:	1949      	adds	r1, r1, r5
   18340:	2300      	movs	r3, #0
   18342:	700b      	strb	r3, [r1, #0]
   18344:	4620      	mov	r0, r4
   18346:	b00b      	add	sp, #44	; 0x2c
   18348:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1834c:	f240 07d8 	movw	r7, #216	; 0xd8
   18350:	f2c2 0700 	movt	r7, #8192	; 0x2000
   18354:	6838      	ldr	r0, [r7, #0]
   18356:	6b03      	ldr	r3, [r0, #48]	; 0x30
   18358:	4293      	cmp	r3, r2
   1835a:	bfc8      	it	gt
   1835c:	6b44      	ldrgt	r4, [r0, #52]	; 0x34
   1835e:	dcc6      	bgt.n	182ee <ecvtbuf+0x1e>
   18360:	1c53      	adds	r3, r2, #1
   18362:	6b41      	ldr	r1, [r0, #52]	; 0x34
   18364:	461a      	mov	r2, r3
   18366:	9307      	str	r3, [sp, #28]
   18368:	f001 fb22 	bl	199b0 <_realloc_r>
   1836c:	9b07      	ldr	r3, [sp, #28]
   1836e:	4604      	mov	r4, r0
   18370:	2800      	cmp	r0, #0
   18372:	d0e7      	beq.n	18344 <ecvtbuf+0x74>
   18374:	6838      	ldr	r0, [r7, #0]
   18376:	6303      	str	r3, [r0, #48]	; 0x30
   18378:	6344      	str	r4, [r0, #52]	; 0x34
   1837a:	e7b8      	b.n	182ee <ecvtbuf+0x1e>
   1837c:	4621      	mov	r1, r4
   1837e:	2300      	movs	r3, #0
   18380:	e7d1      	b.n	18326 <ecvtbuf+0x56>
   18382:	bf00      	nop

00018384 <fcvtbuf>:
   18384:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18388:	b08b      	sub	sp, #44	; 0x2c
   1838a:	4614      	mov	r4, r2
   1838c:	461e      	mov	r6, r3
   1838e:	9d15      	ldr	r5, [sp, #84]	; 0x54
   18390:	4680      	mov	r8, r0
   18392:	4689      	mov	r9, r1
   18394:	f8dd a050 	ldr.w	sl, [sp, #80]	; 0x50
   18398:	2d00      	cmp	r5, #0
   1839a:	d04e      	beq.n	1843a <fcvtbuf+0xb6>
   1839c:	f240 03d8 	movw	r3, #216	; 0xd8
   183a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   183a4:	681f      	ldr	r7, [r3, #0]
   183a6:	f240 0300 	movw	r3, #0
   183aa:	4640      	mov	r0, r8
   183ac:	4649      	mov	r1, r9
   183ae:	2200      	movs	r2, #0
   183b0:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
   183b4:	f002 f84a 	bl	1a44c <__aeabi_dcmplt>
   183b8:	b150      	cbz	r0, 183d0 <fcvtbuf+0x4c>
   183ba:	f240 0300 	movw	r3, #0
   183be:	4640      	mov	r0, r8
   183c0:	4649      	mov	r1, r9
   183c2:	2200      	movs	r2, #0
   183c4:	f6cb 73f0 	movt	r3, #49136	; 0xbff0
   183c8:	f002 f85e 	bl	1a488 <__aeabi_dcmpgt>
   183cc:	2800      	cmp	r0, #0
   183ce:	d12d      	bne.n	1842c <fcvtbuf+0xa8>
   183d0:	4638      	mov	r0, r7
   183d2:	4642      	mov	r2, r8
   183d4:	464b      	mov	r3, r9
   183d6:	2103      	movs	r1, #3
   183d8:	f8cd a00c 	str.w	sl, [sp, #12]
   183dc:	9100      	str	r1, [sp, #0]
   183de:	a909      	add	r1, sp, #36	; 0x24
   183e0:	9401      	str	r4, [sp, #4]
   183e2:	9104      	str	r1, [sp, #16]
   183e4:	9602      	str	r6, [sp, #8]
   183e6:	f7fe fe8b 	bl	17100 <_dtoa_r>
   183ea:	6831      	ldr	r1, [r6, #0]
   183ec:	462a      	mov	r2, r5
   183ee:	9b09      	ldr	r3, [sp, #36]	; 0x24
   183f0:	4249      	negs	r1, r1
   183f2:	4298      	cmp	r0, r3
   183f4:	d207      	bcs.n	18406 <fcvtbuf+0x82>
   183f6:	f810 3b01 	ldrb.w	r3, [r0], #1
   183fa:	3101      	adds	r1, #1
   183fc:	f802 3b01 	strb.w	r3, [r2], #1
   18400:	9b09      	ldr	r3, [sp, #36]	; 0x24
   18402:	4283      	cmp	r3, r0
   18404:	d8f7      	bhi.n	183f6 <fcvtbuf+0x72>
   18406:	428c      	cmp	r4, r1
   18408:	dd0a      	ble.n	18420 <fcvtbuf+0x9c>
   1840a:	2300      	movs	r3, #0
   1840c:	f04f 0c30 	mov.w	ip, #48	; 0x30
   18410:	f802 c003 	strb.w	ip, [r2, r3]
   18414:	3301      	adds	r3, #1
   18416:	1858      	adds	r0, r3, r1
   18418:	4284      	cmp	r4, r0
   1841a:	dcf9      	bgt.n	18410 <fcvtbuf+0x8c>
   1841c:	1a64      	subs	r4, r4, r1
   1841e:	1912      	adds	r2, r2, r4
   18420:	2300      	movs	r3, #0
   18422:	7013      	strb	r3, [r2, #0]
   18424:	4628      	mov	r0, r5
   18426:	b00b      	add	sp, #44	; 0x2c
   18428:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1842c:	4638      	mov	r0, r7
   1842e:	4642      	mov	r2, r8
   18430:	464b      	mov	r3, r9
   18432:	f8cd a00c 	str.w	sl, [sp, #12]
   18436:	2102      	movs	r1, #2
   18438:	e7d0      	b.n	183dc <fcvtbuf+0x58>
   1843a:	f240 03d8 	movw	r3, #216	; 0xd8
   1843e:	3223      	adds	r2, #35	; 0x23
   18440:	f2c2 0300 	movt	r3, #8192	; 0x2000
   18444:	681f      	ldr	r7, [r3, #0]
   18446:	6b39      	ldr	r1, [r7, #48]	; 0x30
   18448:	4291      	cmp	r1, r2
   1844a:	bfc8      	it	gt
   1844c:	6b7d      	ldrgt	r5, [r7, #52]	; 0x34
   1844e:	dcaa      	bgt.n	183a6 <fcvtbuf+0x22>
   18450:	f104 0b24 	add.w	fp, r4, #36	; 0x24
   18454:	4638      	mov	r0, r7
   18456:	465a      	mov	r2, fp
   18458:	6b79      	ldr	r1, [r7, #52]	; 0x34
   1845a:	9307      	str	r3, [sp, #28]
   1845c:	f001 faa8 	bl	199b0 <_realloc_r>
   18460:	9b07      	ldr	r3, [sp, #28]
   18462:	4605      	mov	r5, r0
   18464:	2800      	cmp	r0, #0
   18466:	d0dd      	beq.n	18424 <fcvtbuf+0xa0>
   18468:	681f      	ldr	r7, [r3, #0]
   1846a:	f8c7 b030 	str.w	fp, [r7, #48]	; 0x30
   1846e:	6378      	str	r0, [r7, #52]	; 0x34
   18470:	e799      	b.n	183a6 <fcvtbuf+0x22>
   18472:	bf00      	nop

00018474 <_dcvt>:
   18474:	b5f0      	push	{r4, r5, r6, r7, lr}
   18476:	b08b      	sub	sp, #44	; 0x2c
   18478:	460d      	mov	r5, r1
   1847a:	f89d 6048 	ldrb.w	r6, [sp, #72]	; 0x48
   1847e:	9c10      	ldr	r4, [sp, #64]	; 0x40
   18480:	f1a6 0145 	sub.w	r1, r6, #69	; 0x45
   18484:	9f13      	ldr	r7, [sp, #76]	; 0x4c
   18486:	2922      	cmp	r1, #34	; 0x22
   18488:	d86f      	bhi.n	1856a <_dcvt+0xf6>
   1848a:	e8df f011 	tbh	[pc, r1, lsl #1]
   1848e:	00b1      	.short	0x00b1
   18490:	0071007b 	.word	0x0071007b
   18494:	006e006e 	.word	0x006e006e
   18498:	006e006e 	.word	0x006e006e
   1849c:	006e006e 	.word	0x006e006e
   184a0:	006e006e 	.word	0x006e006e
   184a4:	006e006e 	.word	0x006e006e
   184a8:	006e006e 	.word	0x006e006e
   184ac:	006e006e 	.word	0x006e006e
   184b0:	006e006e 	.word	0x006e006e
   184b4:	006e006e 	.word	0x006e006e
   184b8:	006e006e 	.word	0x006e006e
   184bc:	006e006e 	.word	0x006e006e
   184c0:	006e006e 	.word	0x006e006e
   184c4:	006e006e 	.word	0x006e006e
   184c8:	006e006e 	.word	0x006e006e
   184cc:	00b1006e 	.word	0x00b1006e
   184d0:	0071007b 	.word	0x0071007b
   184d4:	4601      	mov	r1, r0
   184d6:	462b      	mov	r3, r5
   184d8:	2f00      	cmp	r7, #0
   184da:	f000 8090 	beq.w	185fe <_dcvt+0x18a>
   184de:	4288      	cmp	r0, r1
   184e0:	461a      	mov	r2, r3
   184e2:	f000 8090 	beq.w	18606 <_dcvt+0x192>
   184e6:	4613      	mov	r3, r2
   184e8:	202e      	movs	r0, #46	; 0x2e
   184ea:	2c00      	cmp	r4, #0
   184ec:	bfd4      	ite	le
   184ee:	f04f 0c00 	movle.w	ip, #0
   184f2:	f04f 0c01 	movgt.w	ip, #1
   184f6:	f803 0b01 	strb.w	r0, [r3], #1
   184fa:	9809      	ldr	r0, [sp, #36]	; 0x24
   184fc:	ea1c 70d0 	ands.w	r0, ip, r0, lsr #31
   18500:	d012      	beq.n	18528 <_dcvt+0xb4>
   18502:	3202      	adds	r2, #2
   18504:	2630      	movs	r6, #48	; 0x30
   18506:	f802 6c01 	strb.w	r6, [r2, #-1]
   1850a:	3c01      	subs	r4, #1
   1850c:	9809      	ldr	r0, [sp, #36]	; 0x24
   1850e:	2c00      	cmp	r4, #0
   18510:	bfd4      	ite	le
   18512:	f04f 0c00 	movle.w	ip, #0
   18516:	f04f 0c01 	movgt.w	ip, #1
   1851a:	4613      	mov	r3, r2
   1851c:	3201      	adds	r2, #1
   1851e:	3001      	adds	r0, #1
   18520:	9009      	str	r0, [sp, #36]	; 0x24
   18522:	ea1c 70d0 	ands.w	r0, ip, r0, lsr #31
   18526:	d1ee      	bne.n	18506 <_dcvt+0x92>
   18528:	780a      	ldrb	r2, [r1, #0]
   1852a:	2a00      	cmp	r2, #0
   1852c:	bf0c      	ite	eq
   1852e:	2000      	moveq	r0, #0
   18530:	f00c 0001 	andne.w	r0, ip, #1
   18534:	b170      	cbz	r0, 18554 <_dcvt+0xe0>
   18536:	f803 2b01 	strb.w	r2, [r3], #1
   1853a:	3c01      	subs	r4, #1
   1853c:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   18540:	1e10      	subs	r0, r2, #0
   18542:	bf18      	it	ne
   18544:	2001      	movne	r0, #1
   18546:	2c00      	cmp	r4, #0
   18548:	bfd4      	ite	le
   1854a:	2000      	movle	r0, #0
   1854c:	f000 0001 	andgt.w	r0, r0, #1
   18550:	2800      	cmp	r0, #0
   18552:	d1f0      	bne.n	18536 <_dcvt+0xc2>
   18554:	2c00      	cmp	r4, #0
   18556:	dd06      	ble.n	18566 <_dcvt+0xf2>
   18558:	2200      	movs	r2, #0
   1855a:	2130      	movs	r1, #48	; 0x30
   1855c:	5499      	strb	r1, [r3, r2]
   1855e:	3201      	adds	r2, #1
   18560:	42a2      	cmp	r2, r4
   18562:	d1fb      	bne.n	1855c <_dcvt+0xe8>
   18564:	189b      	adds	r3, r3, r2
   18566:	2200      	movs	r2, #0
   18568:	701a      	strb	r2, [r3, #0]
   1856a:	4628      	mov	r0, r5
   1856c:	b00b      	add	sp, #44	; 0x2c
   1856e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   18570:	2c00      	cmp	r4, #0
   18572:	bf08      	it	eq
   18574:	2401      	moveq	r4, #1
   18576:	9602      	str	r6, [sp, #8]
   18578:	9703      	str	r7, [sp, #12]
   1857a:	9400      	str	r4, [sp, #0]
   1857c:	9501      	str	r5, [sp, #4]
   1857e:	f7ff fda3 	bl	180c8 <_gcvt>
   18582:	e7f2      	b.n	1856a <_dcvt+0xf6>
   18584:	2103      	movs	r1, #3
   18586:	9401      	str	r4, [sp, #4]
   18588:	9100      	str	r1, [sp, #0]
   1858a:	a909      	add	r1, sp, #36	; 0x24
   1858c:	9102      	str	r1, [sp, #8]
   1858e:	a908      	add	r1, sp, #32
   18590:	9103      	str	r1, [sp, #12]
   18592:	a907      	add	r1, sp, #28
   18594:	9104      	str	r1, [sp, #16]
   18596:	f7fe fdb3 	bl	17100 <_dtoa_r>
   1859a:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1859c:	f242 730f 	movw	r3, #9999	; 0x270f
   185a0:	2c00      	cmp	r4, #0
   185a2:	bf18      	it	ne
   185a4:	2701      	movne	r7, #1
   185a6:	429a      	cmp	r2, r3
   185a8:	d031      	beq.n	1860e <_dcvt+0x19a>
   185aa:	7806      	ldrb	r6, [r0, #0]
   185ac:	2e00      	cmp	r6, #0
   185ae:	d033      	beq.n	18618 <_dcvt+0x1a4>
   185b0:	2a00      	cmp	r2, #0
   185b2:	bfc4      	itt	gt
   185b4:	462b      	movgt	r3, r5
   185b6:	4601      	movgt	r1, r0
   185b8:	dc02      	bgt.n	185c0 <_dcvt+0x14c>
   185ba:	e78b      	b.n	184d4 <_dcvt+0x60>
   185bc:	2a00      	cmp	r2, #0
   185be:	dd8b      	ble.n	184d8 <_dcvt+0x64>
   185c0:	f803 6b01 	strb.w	r6, [r3], #1
   185c4:	9a09      	ldr	r2, [sp, #36]	; 0x24
   185c6:	3a01      	subs	r2, #1
   185c8:	9209      	str	r2, [sp, #36]	; 0x24
   185ca:	f811 6f01 	ldrb.w	r6, [r1, #1]!
   185ce:	2e00      	cmp	r6, #0
   185d0:	d1f4      	bne.n	185bc <_dcvt+0x148>
   185d2:	2a00      	cmp	r2, #0
   185d4:	dd80      	ble.n	184d8 <_dcvt+0x64>
   185d6:	f04f 0c30 	mov.w	ip, #48	; 0x30
   185da:	f803 cb01 	strb.w	ip, [r3], #1
   185de:	9a09      	ldr	r2, [sp, #36]	; 0x24
   185e0:	3a01      	subs	r2, #1
   185e2:	9209      	str	r2, [sp, #36]	; 0x24
   185e4:	2a00      	cmp	r2, #0
   185e6:	dcf8      	bgt.n	185da <_dcvt+0x166>
   185e8:	2f00      	cmp	r7, #0
   185ea:	f47f af78 	bne.w	184de <_dcvt+0x6a>
   185ee:	e006      	b.n	185fe <_dcvt+0x18a>
   185f0:	4629      	mov	r1, r5
   185f2:	9400      	str	r4, [sp, #0]
   185f4:	9601      	str	r6, [sp, #4]
   185f6:	9702      	str	r7, [sp, #8]
   185f8:	f7ff fcce 	bl	17f98 <print_e>
   185fc:	e7b5      	b.n	1856a <_dcvt+0xf6>
   185fe:	780a      	ldrb	r2, [r1, #0]
   18600:	2a00      	cmp	r2, #0
   18602:	d0b0      	beq.n	18566 <_dcvt+0xf2>
   18604:	e76b      	b.n	184de <_dcvt+0x6a>
   18606:	2330      	movs	r3, #48	; 0x30
   18608:	f802 3b01 	strb.w	r3, [r2], #1
   1860c:	e76b      	b.n	184e6 <_dcvt+0x72>
   1860e:	4601      	mov	r1, r0
   18610:	4628      	mov	r0, r5
   18612:	f7fc fe35 	bl	15280 <strcpy>
   18616:	e7a8      	b.n	1856a <_dcvt+0xf6>
   18618:	4601      	mov	r1, r0
   1861a:	462b      	mov	r3, r5
   1861c:	e7d9      	b.n	185d2 <_dcvt+0x15e>
   1861e:	bf00      	nop

00018620 <_malloc_trim_r>:
   18620:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   18622:	f240 14dc 	movw	r4, #476	; 0x1dc
   18626:	f2c2 0400 	movt	r4, #8192	; 0x2000
   1862a:	460f      	mov	r7, r1
   1862c:	4605      	mov	r5, r0
   1862e:	f000 fd0f 	bl	19050 <__malloc_lock>
   18632:	68a3      	ldr	r3, [r4, #8]
   18634:	685e      	ldr	r6, [r3, #4]
   18636:	f026 0603 	bic.w	r6, r6, #3
   1863a:	f506 637e 	add.w	r3, r6, #4064	; 0xfe0
   1863e:	330f      	adds	r3, #15
   18640:	1bdf      	subs	r7, r3, r7
   18642:	0b3f      	lsrs	r7, r7, #12
   18644:	3f01      	subs	r7, #1
   18646:	033f      	lsls	r7, r7, #12
   18648:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
   1864c:	db07      	blt.n	1865e <_malloc_trim_r+0x3e>
   1864e:	2100      	movs	r1, #0
   18650:	4628      	mov	r0, r5
   18652:	f001 fba7 	bl	19da4 <_sbrk_r>
   18656:	68a3      	ldr	r3, [r4, #8]
   18658:	18f3      	adds	r3, r6, r3
   1865a:	4283      	cmp	r3, r0
   1865c:	d004      	beq.n	18668 <_malloc_trim_r+0x48>
   1865e:	4628      	mov	r0, r5
   18660:	f000 fcf8 	bl	19054 <__malloc_unlock>
   18664:	2000      	movs	r0, #0
   18666:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   18668:	4279      	negs	r1, r7
   1866a:	4628      	mov	r0, r5
   1866c:	f001 fb9a 	bl	19da4 <_sbrk_r>
   18670:	f1b0 3fff 	cmp.w	r0, #4294967295
   18674:	d010      	beq.n	18698 <_malloc_trim_r+0x78>
   18676:	68a2      	ldr	r2, [r4, #8]
   18678:	f64a 1380 	movw	r3, #43392	; 0xa980
   1867c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   18680:	1bf6      	subs	r6, r6, r7
   18682:	f046 0601 	orr.w	r6, r6, #1
   18686:	4628      	mov	r0, r5
   18688:	6056      	str	r6, [r2, #4]
   1868a:	681a      	ldr	r2, [r3, #0]
   1868c:	1bd7      	subs	r7, r2, r7
   1868e:	601f      	str	r7, [r3, #0]
   18690:	f000 fce0 	bl	19054 <__malloc_unlock>
   18694:	2001      	movs	r0, #1
   18696:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   18698:	2100      	movs	r1, #0
   1869a:	4628      	mov	r0, r5
   1869c:	f001 fb82 	bl	19da4 <_sbrk_r>
   186a0:	68a3      	ldr	r3, [r4, #8]
   186a2:	1ac2      	subs	r2, r0, r3
   186a4:	2a0f      	cmp	r2, #15
   186a6:	ddda      	ble.n	1865e <_malloc_trim_r+0x3e>
   186a8:	f240 54e4 	movw	r4, #1508	; 0x5e4
   186ac:	f64a 1180 	movw	r1, #43392	; 0xa980
   186b0:	f2c2 0400 	movt	r4, #8192	; 0x2000
   186b4:	f2c2 0100 	movt	r1, #8192	; 0x2000
   186b8:	f042 0201 	orr.w	r2, r2, #1
   186bc:	6824      	ldr	r4, [r4, #0]
   186be:	1b00      	subs	r0, r0, r4
   186c0:	6008      	str	r0, [r1, #0]
   186c2:	605a      	str	r2, [r3, #4]
   186c4:	e7cb      	b.n	1865e <_malloc_trim_r+0x3e>
   186c6:	bf00      	nop

000186c8 <_free_r>:
   186c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   186cc:	4605      	mov	r5, r0
   186ce:	460c      	mov	r4, r1
   186d0:	2900      	cmp	r1, #0
   186d2:	f000 8088 	beq.w	187e6 <_free_r+0x11e>
   186d6:	f000 fcbb 	bl	19050 <__malloc_lock>
   186da:	f1a4 0208 	sub.w	r2, r4, #8
   186de:	f240 10dc 	movw	r0, #476	; 0x1dc
   186e2:	6856      	ldr	r6, [r2, #4]
   186e4:	f2c2 0000 	movt	r0, #8192	; 0x2000
   186e8:	f026 0301 	bic.w	r3, r6, #1
   186ec:	f8d0 c008 	ldr.w	ip, [r0, #8]
   186f0:	18d1      	adds	r1, r2, r3
   186f2:	458c      	cmp	ip, r1
   186f4:	684f      	ldr	r7, [r1, #4]
   186f6:	f027 0703 	bic.w	r7, r7, #3
   186fa:	f000 8095 	beq.w	18828 <_free_r+0x160>
   186fe:	f016 0601 	ands.w	r6, r6, #1
   18702:	604f      	str	r7, [r1, #4]
   18704:	d05f      	beq.n	187c6 <_free_r+0xfe>
   18706:	2600      	movs	r6, #0
   18708:	19cc      	adds	r4, r1, r7
   1870a:	6864      	ldr	r4, [r4, #4]
   1870c:	f014 0f01 	tst.w	r4, #1
   18710:	d106      	bne.n	18720 <_free_r+0x58>
   18712:	19db      	adds	r3, r3, r7
   18714:	2e00      	cmp	r6, #0
   18716:	d07a      	beq.n	1880e <_free_r+0x146>
   18718:	688c      	ldr	r4, [r1, #8]
   1871a:	68c9      	ldr	r1, [r1, #12]
   1871c:	608c      	str	r4, [r1, #8]
   1871e:	60e1      	str	r1, [r4, #12]
   18720:	f043 0101 	orr.w	r1, r3, #1
   18724:	50d3      	str	r3, [r2, r3]
   18726:	6051      	str	r1, [r2, #4]
   18728:	2e00      	cmp	r6, #0
   1872a:	d147      	bne.n	187bc <_free_r+0xf4>
   1872c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   18730:	d35b      	bcc.n	187ea <_free_r+0x122>
   18732:	0a59      	lsrs	r1, r3, #9
   18734:	2904      	cmp	r1, #4
   18736:	bf9e      	ittt	ls
   18738:	ea4f 1c93 	movls.w	ip, r3, lsr #6
   1873c:	f10c 0c38 	addls.w	ip, ip, #56	; 0x38
   18740:	ea4f 04cc 	movls.w	r4, ip, lsl #3
   18744:	d928      	bls.n	18798 <_free_r+0xd0>
   18746:	2914      	cmp	r1, #20
   18748:	bf9c      	itt	ls
   1874a:	f101 0c5b 	addls.w	ip, r1, #91	; 0x5b
   1874e:	ea4f 04cc 	movls.w	r4, ip, lsl #3
   18752:	d921      	bls.n	18798 <_free_r+0xd0>
   18754:	2954      	cmp	r1, #84	; 0x54
   18756:	bf9e      	ittt	ls
   18758:	ea4f 3c13 	movls.w	ip, r3, lsr #12
   1875c:	f10c 0c6e 	addls.w	ip, ip, #110	; 0x6e
   18760:	ea4f 04cc 	movls.w	r4, ip, lsl #3
   18764:	d918      	bls.n	18798 <_free_r+0xd0>
   18766:	f5b1 7faa 	cmp.w	r1, #340	; 0x154
   1876a:	bf9e      	ittt	ls
   1876c:	ea4f 3cd3 	movls.w	ip, r3, lsr #15
   18770:	f10c 0c77 	addls.w	ip, ip, #119	; 0x77
   18774:	ea4f 04cc 	movls.w	r4, ip, lsl #3
   18778:	d90e      	bls.n	18798 <_free_r+0xd0>
   1877a:	f240 5c54 	movw	ip, #1364	; 0x554
   1877e:	4561      	cmp	r1, ip
   18780:	bf95      	itete	ls
   18782:	ea4f 4c93 	movls.w	ip, r3, lsr #18
   18786:	f44f 747c 	movhi.w	r4, #1008	; 0x3f0
   1878a:	f10c 0c7c 	addls.w	ip, ip, #124	; 0x7c
   1878e:	f04f 0c7e 	movhi.w	ip, #126	; 0x7e
   18792:	bf98      	it	ls
   18794:	ea4f 04cc 	movls.w	r4, ip, lsl #3
   18798:	1904      	adds	r4, r0, r4
   1879a:	68a1      	ldr	r1, [r4, #8]
   1879c:	42a1      	cmp	r1, r4
   1879e:	d103      	bne.n	187a8 <_free_r+0xe0>
   187a0:	e064      	b.n	1886c <_free_r+0x1a4>
   187a2:	6889      	ldr	r1, [r1, #8]
   187a4:	428c      	cmp	r4, r1
   187a6:	d004      	beq.n	187b2 <_free_r+0xea>
   187a8:	6848      	ldr	r0, [r1, #4]
   187aa:	f020 0003 	bic.w	r0, r0, #3
   187ae:	4283      	cmp	r3, r0
   187b0:	d3f7      	bcc.n	187a2 <_free_r+0xda>
   187b2:	68cb      	ldr	r3, [r1, #12]
   187b4:	60d3      	str	r3, [r2, #12]
   187b6:	6091      	str	r1, [r2, #8]
   187b8:	60ca      	str	r2, [r1, #12]
   187ba:	609a      	str	r2, [r3, #8]
   187bc:	4628      	mov	r0, r5
   187be:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   187c2:	f000 bc47 	b.w	19054 <__malloc_unlock>
   187c6:	f854 4c08 	ldr.w	r4, [r4, #-8]
   187ca:	f100 0c08 	add.w	ip, r0, #8
   187ce:	1b12      	subs	r2, r2, r4
   187d0:	191b      	adds	r3, r3, r4
   187d2:	6894      	ldr	r4, [r2, #8]
   187d4:	4564      	cmp	r4, ip
   187d6:	d047      	beq.n	18868 <_free_r+0x1a0>
   187d8:	f8d2 c00c 	ldr.w	ip, [r2, #12]
   187dc:	f8cc 4008 	str.w	r4, [ip, #8]
   187e0:	f8c4 c00c 	str.w	ip, [r4, #12]
   187e4:	e790      	b.n	18708 <_free_r+0x40>
   187e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   187ea:	08db      	lsrs	r3, r3, #3
   187ec:	f04f 0c01 	mov.w	ip, #1
   187f0:	6846      	ldr	r6, [r0, #4]
   187f2:	eb00 01c3 	add.w	r1, r0, r3, lsl #3
   187f6:	109b      	asrs	r3, r3, #2
   187f8:	fa0c f303 	lsl.w	r3, ip, r3
   187fc:	60d1      	str	r1, [r2, #12]
   187fe:	688c      	ldr	r4, [r1, #8]
   18800:	ea46 0303 	orr.w	r3, r6, r3
   18804:	6043      	str	r3, [r0, #4]
   18806:	6094      	str	r4, [r2, #8]
   18808:	60e2      	str	r2, [r4, #12]
   1880a:	608a      	str	r2, [r1, #8]
   1880c:	e7d6      	b.n	187bc <_free_r+0xf4>
   1880e:	688c      	ldr	r4, [r1, #8]
   18810:	4f1c      	ldr	r7, [pc, #112]	; (18884 <_free_r+0x1bc>)
   18812:	42bc      	cmp	r4, r7
   18814:	d181      	bne.n	1871a <_free_r+0x52>
   18816:	50d3      	str	r3, [r2, r3]
   18818:	f043 0301 	orr.w	r3, r3, #1
   1881c:	60e2      	str	r2, [r4, #12]
   1881e:	60a2      	str	r2, [r4, #8]
   18820:	6053      	str	r3, [r2, #4]
   18822:	6094      	str	r4, [r2, #8]
   18824:	60d4      	str	r4, [r2, #12]
   18826:	e7c9      	b.n	187bc <_free_r+0xf4>
   18828:	18fb      	adds	r3, r7, r3
   1882a:	f016 0f01 	tst.w	r6, #1
   1882e:	d107      	bne.n	18840 <_free_r+0x178>
   18830:	f854 1c08 	ldr.w	r1, [r4, #-8]
   18834:	1a52      	subs	r2, r2, r1
   18836:	185b      	adds	r3, r3, r1
   18838:	68d4      	ldr	r4, [r2, #12]
   1883a:	6891      	ldr	r1, [r2, #8]
   1883c:	60a1      	str	r1, [r4, #8]
   1883e:	60cc      	str	r4, [r1, #12]
   18840:	f240 51e8 	movw	r1, #1512	; 0x5e8
   18844:	6082      	str	r2, [r0, #8]
   18846:	f2c2 0100 	movt	r1, #8192	; 0x2000
   1884a:	f043 0001 	orr.w	r0, r3, #1
   1884e:	6050      	str	r0, [r2, #4]
   18850:	680a      	ldr	r2, [r1, #0]
   18852:	4293      	cmp	r3, r2
   18854:	d3b2      	bcc.n	187bc <_free_r+0xf4>
   18856:	f64a 137c 	movw	r3, #43388	; 0xa97c
   1885a:	4628      	mov	r0, r5
   1885c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   18860:	6819      	ldr	r1, [r3, #0]
   18862:	f7ff fedd 	bl	18620 <_malloc_trim_r>
   18866:	e7a9      	b.n	187bc <_free_r+0xf4>
   18868:	2601      	movs	r6, #1
   1886a:	e74d      	b.n	18708 <_free_r+0x40>
   1886c:	2601      	movs	r6, #1
   1886e:	6844      	ldr	r4, [r0, #4]
   18870:	ea4f 0cac 	mov.w	ip, ip, asr #2
   18874:	460b      	mov	r3, r1
   18876:	fa06 fc0c 	lsl.w	ip, r6, ip
   1887a:	ea44 040c 	orr.w	r4, r4, ip
   1887e:	6044      	str	r4, [r0, #4]
   18880:	e798      	b.n	187b4 <_free_r+0xec>
   18882:	bf00      	nop
   18884:	200001e4 	.word	0x200001e4

00018888 <__locale_charset>:
   18888:	f244 1310 	movw	r3, #16656	; 0x4110
   1888c:	f2c0 0302 	movt	r3, #2
   18890:	6818      	ldr	r0, [r3, #0]
   18892:	4770      	bx	lr

00018894 <_localeconv_r>:
   18894:	4800      	ldr	r0, [pc, #0]	; (18898 <_localeconv_r+0x4>)
   18896:	4770      	bx	lr
   18898:	00024114 	.word	0x00024114

0001889c <localeconv>:
   1889c:	4800      	ldr	r0, [pc, #0]	; (188a0 <localeconv+0x4>)
   1889e:	4770      	bx	lr
   188a0:	00024114 	.word	0x00024114

000188a4 <_setlocale_r>:
   188a4:	b570      	push	{r4, r5, r6, lr}
   188a6:	4605      	mov	r5, r0
   188a8:	460e      	mov	r6, r1
   188aa:	4614      	mov	r4, r2
   188ac:	b172      	cbz	r2, 188cc <_setlocale_r+0x28>
   188ae:	f244 0198 	movw	r1, #16536	; 0x4098
   188b2:	4610      	mov	r0, r2
   188b4:	f2c0 0102 	movt	r1, #2
   188b8:	f001 fa88 	bl	19dcc <strcmp>
   188bc:	b958      	cbnz	r0, 188d6 <_setlocale_r+0x32>
   188be:	f244 0098 	movw	r0, #16536	; 0x4098
   188c2:	622c      	str	r4, [r5, #32]
   188c4:	f2c0 0002 	movt	r0, #2
   188c8:	61ee      	str	r6, [r5, #28]
   188ca:	bd70      	pop	{r4, r5, r6, pc}
   188cc:	f244 0098 	movw	r0, #16536	; 0x4098
   188d0:	f2c0 0002 	movt	r0, #2
   188d4:	bd70      	pop	{r4, r5, r6, pc}
   188d6:	f244 01cc 	movw	r1, #16588	; 0x40cc
   188da:	4620      	mov	r0, r4
   188dc:	f2c0 0102 	movt	r1, #2
   188e0:	f001 fa74 	bl	19dcc <strcmp>
   188e4:	2800      	cmp	r0, #0
   188e6:	d0ea      	beq.n	188be <_setlocale_r+0x1a>
   188e8:	2000      	movs	r0, #0
   188ea:	bd70      	pop	{r4, r5, r6, pc}

000188ec <setlocale>:
   188ec:	f240 03d8 	movw	r3, #216	; 0xd8
   188f0:	460a      	mov	r2, r1
   188f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   188f6:	4601      	mov	r1, r0
   188f8:	6818      	ldr	r0, [r3, #0]
   188fa:	e7d3      	b.n	188a4 <_setlocale_r>

000188fc <free>:
   188fc:	f240 03d8 	movw	r3, #216	; 0xd8
   18900:	4601      	mov	r1, r0
   18902:	f2c2 0300 	movt	r3, #8192	; 0x2000
   18906:	6818      	ldr	r0, [r3, #0]
   18908:	f7ff bede 	b.w	186c8 <_free_r>

0001890c <malloc>:
   1890c:	f240 03d8 	movw	r3, #216	; 0xd8
   18910:	4601      	mov	r1, r0
   18912:	f2c2 0300 	movt	r3, #8192	; 0x2000
   18916:	6818      	ldr	r0, [r3, #0]
   18918:	f000 b800 	b.w	1891c <_malloc_r>

0001891c <_malloc_r>:
   1891c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18920:	f101 040b 	add.w	r4, r1, #11
   18924:	2c16      	cmp	r4, #22
   18926:	b083      	sub	sp, #12
   18928:	4606      	mov	r6, r0
   1892a:	d82f      	bhi.n	1898c <_malloc_r+0x70>
   1892c:	2300      	movs	r3, #0
   1892e:	2410      	movs	r4, #16
   18930:	428c      	cmp	r4, r1
   18932:	bf2c      	ite	cs
   18934:	4619      	movcs	r1, r3
   18936:	f043 0101 	orrcc.w	r1, r3, #1
   1893a:	2900      	cmp	r1, #0
   1893c:	d130      	bne.n	189a0 <_malloc_r+0x84>
   1893e:	4630      	mov	r0, r6
   18940:	f000 fb86 	bl	19050 <__malloc_lock>
   18944:	f5b4 7ffc 	cmp.w	r4, #504	; 0x1f8
   18948:	d22e      	bcs.n	189a8 <_malloc_r+0x8c>
   1894a:	ea4f 0ed4 	mov.w	lr, r4, lsr #3
   1894e:	f240 15dc 	movw	r5, #476	; 0x1dc
   18952:	f2c2 0500 	movt	r5, #8192	; 0x2000
   18956:	eb05 02ce 	add.w	r2, r5, lr, lsl #3
   1895a:	68d3      	ldr	r3, [r2, #12]
   1895c:	4293      	cmp	r3, r2
   1895e:	f000 8206 	beq.w	18d6e <_malloc_r+0x452>
   18962:	685a      	ldr	r2, [r3, #4]
   18964:	f103 0508 	add.w	r5, r3, #8
   18968:	68d9      	ldr	r1, [r3, #12]
   1896a:	4630      	mov	r0, r6
   1896c:	f022 0c03 	bic.w	ip, r2, #3
   18970:	689a      	ldr	r2, [r3, #8]
   18972:	4463      	add	r3, ip
   18974:	685c      	ldr	r4, [r3, #4]
   18976:	608a      	str	r2, [r1, #8]
   18978:	f044 0401 	orr.w	r4, r4, #1
   1897c:	60d1      	str	r1, [r2, #12]
   1897e:	605c      	str	r4, [r3, #4]
   18980:	f000 fb68 	bl	19054 <__malloc_unlock>
   18984:	4628      	mov	r0, r5
   18986:	b003      	add	sp, #12
   18988:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1898c:	f024 0407 	bic.w	r4, r4, #7
   18990:	0fe3      	lsrs	r3, r4, #31
   18992:	428c      	cmp	r4, r1
   18994:	bf2c      	ite	cs
   18996:	4619      	movcs	r1, r3
   18998:	f043 0101 	orrcc.w	r1, r3, #1
   1899c:	2900      	cmp	r1, #0
   1899e:	d0ce      	beq.n	1893e <_malloc_r+0x22>
   189a0:	230c      	movs	r3, #12
   189a2:	2500      	movs	r5, #0
   189a4:	6033      	str	r3, [r6, #0]
   189a6:	e7ed      	b.n	18984 <_malloc_r+0x68>
   189a8:	ea5f 2e54 	movs.w	lr, r4, lsr #9
   189ac:	bf04      	itt	eq
   189ae:	ea4f 0ed4 	moveq.w	lr, r4, lsr #3
   189b2:	ea4f 00ce 	moveq.w	r0, lr, lsl #3
   189b6:	f040 8090 	bne.w	18ada <_malloc_r+0x1be>
   189ba:	f240 15dc 	movw	r5, #476	; 0x1dc
   189be:	f2c2 0500 	movt	r5, #8192	; 0x2000
   189c2:	1828      	adds	r0, r5, r0
   189c4:	68c3      	ldr	r3, [r0, #12]
   189c6:	4298      	cmp	r0, r3
   189c8:	d106      	bne.n	189d8 <_malloc_r+0xbc>
   189ca:	e00d      	b.n	189e8 <_malloc_r+0xcc>
   189cc:	2a00      	cmp	r2, #0
   189ce:	f280 816f 	bge.w	18cb0 <_malloc_r+0x394>
   189d2:	68db      	ldr	r3, [r3, #12]
   189d4:	4298      	cmp	r0, r3
   189d6:	d007      	beq.n	189e8 <_malloc_r+0xcc>
   189d8:	6859      	ldr	r1, [r3, #4]
   189da:	f021 0103 	bic.w	r1, r1, #3
   189de:	1b0a      	subs	r2, r1, r4
   189e0:	2a0f      	cmp	r2, #15
   189e2:	ddf3      	ble.n	189cc <_malloc_r+0xb0>
   189e4:	f10e 3eff 	add.w	lr, lr, #4294967295
   189e8:	f10e 0e01 	add.w	lr, lr, #1
   189ec:	f240 17dc 	movw	r7, #476	; 0x1dc
   189f0:	f2c2 0700 	movt	r7, #8192	; 0x2000
   189f4:	f107 0108 	add.w	r1, r7, #8
   189f8:	688b      	ldr	r3, [r1, #8]
   189fa:	4299      	cmp	r1, r3
   189fc:	bf08      	it	eq
   189fe:	687a      	ldreq	r2, [r7, #4]
   18a00:	d026      	beq.n	18a50 <_malloc_r+0x134>
   18a02:	685a      	ldr	r2, [r3, #4]
   18a04:	f022 0c03 	bic.w	ip, r2, #3
   18a08:	ebc4 020c 	rsb	r2, r4, ip
   18a0c:	2a0f      	cmp	r2, #15
   18a0e:	f300 8194 	bgt.w	18d3a <_malloc_r+0x41e>
   18a12:	2a00      	cmp	r2, #0
   18a14:	60c9      	str	r1, [r1, #12]
   18a16:	6089      	str	r1, [r1, #8]
   18a18:	f280 8099 	bge.w	18b4e <_malloc_r+0x232>
   18a1c:	f5bc 7f00 	cmp.w	ip, #512	; 0x200
   18a20:	f080 8165 	bcs.w	18cee <_malloc_r+0x3d2>
   18a24:	ea4f 0cdc 	mov.w	ip, ip, lsr #3
   18a28:	f04f 0a01 	mov.w	sl, #1
   18a2c:	687a      	ldr	r2, [r7, #4]
   18a2e:	eb07 00cc 	add.w	r0, r7, ip, lsl #3
   18a32:	ea4f 0cac 	mov.w	ip, ip, asr #2
   18a36:	fa0a fc0c 	lsl.w	ip, sl, ip
   18a3a:	60d8      	str	r0, [r3, #12]
   18a3c:	f8d0 8008 	ldr.w	r8, [r0, #8]
   18a40:	ea4c 0202 	orr.w	r2, ip, r2
   18a44:	607a      	str	r2, [r7, #4]
   18a46:	f8c3 8008 	str.w	r8, [r3, #8]
   18a4a:	f8c8 300c 	str.w	r3, [r8, #12]
   18a4e:	6083      	str	r3, [r0, #8]
   18a50:	f04f 0c01 	mov.w	ip, #1
   18a54:	ea4f 03ae 	mov.w	r3, lr, asr #2
   18a58:	fa0c fc03 	lsl.w	ip, ip, r3
   18a5c:	4594      	cmp	ip, r2
   18a5e:	f200 8082 	bhi.w	18b66 <_malloc_r+0x24a>
   18a62:	ea12 0f0c 	tst.w	r2, ip
   18a66:	d108      	bne.n	18a7a <_malloc_r+0x15e>
   18a68:	f02e 0e03 	bic.w	lr, lr, #3
   18a6c:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
   18a70:	f10e 0e04 	add.w	lr, lr, #4
   18a74:	ea12 0f0c 	tst.w	r2, ip
   18a78:	d0f8      	beq.n	18a6c <_malloc_r+0x150>
   18a7a:	eb07 09ce 	add.w	r9, r7, lr, lsl #3
   18a7e:	46f2      	mov	sl, lr
   18a80:	46c8      	mov	r8, r9
   18a82:	f8d8 300c 	ldr.w	r3, [r8, #12]
   18a86:	4598      	cmp	r8, r3
   18a88:	d107      	bne.n	18a9a <_malloc_r+0x17e>
   18a8a:	e168      	b.n	18d5e <_malloc_r+0x442>
   18a8c:	2a00      	cmp	r2, #0
   18a8e:	f280 8178 	bge.w	18d82 <_malloc_r+0x466>
   18a92:	68db      	ldr	r3, [r3, #12]
   18a94:	4598      	cmp	r8, r3
   18a96:	f000 8162 	beq.w	18d5e <_malloc_r+0x442>
   18a9a:	6858      	ldr	r0, [r3, #4]
   18a9c:	f020 0003 	bic.w	r0, r0, #3
   18aa0:	1b02      	subs	r2, r0, r4
   18aa2:	2a0f      	cmp	r2, #15
   18aa4:	ddf2      	ble.n	18a8c <_malloc_r+0x170>
   18aa6:	461d      	mov	r5, r3
   18aa8:	191f      	adds	r7, r3, r4
   18aaa:	f8d3 c00c 	ldr.w	ip, [r3, #12]
   18aae:	f044 0e01 	orr.w	lr, r4, #1
   18ab2:	f855 4f08 	ldr.w	r4, [r5, #8]!
   18ab6:	4630      	mov	r0, r6
   18ab8:	50ba      	str	r2, [r7, r2]
   18aba:	f042 0201 	orr.w	r2, r2, #1
   18abe:	f8c3 e004 	str.w	lr, [r3, #4]
   18ac2:	f8cc 4008 	str.w	r4, [ip, #8]
   18ac6:	f8c4 c00c 	str.w	ip, [r4, #12]
   18aca:	608f      	str	r7, [r1, #8]
   18acc:	60cf      	str	r7, [r1, #12]
   18ace:	607a      	str	r2, [r7, #4]
   18ad0:	60b9      	str	r1, [r7, #8]
   18ad2:	60f9      	str	r1, [r7, #12]
   18ad4:	f000 fabe 	bl	19054 <__malloc_unlock>
   18ad8:	e754      	b.n	18984 <_malloc_r+0x68>
   18ada:	f1be 0f04 	cmp.w	lr, #4
   18ade:	bf9e      	ittt	ls
   18ae0:	ea4f 1e94 	movls.w	lr, r4, lsr #6
   18ae4:	f10e 0e38 	addls.w	lr, lr, #56	; 0x38
   18ae8:	ea4f 00ce 	movls.w	r0, lr, lsl #3
   18aec:	f67f af65 	bls.w	189ba <_malloc_r+0x9e>
   18af0:	f1be 0f14 	cmp.w	lr, #20
   18af4:	bf9c      	itt	ls
   18af6:	f10e 0e5b 	addls.w	lr, lr, #91	; 0x5b
   18afa:	ea4f 00ce 	movls.w	r0, lr, lsl #3
   18afe:	f67f af5c 	bls.w	189ba <_malloc_r+0x9e>
   18b02:	f1be 0f54 	cmp.w	lr, #84	; 0x54
   18b06:	bf9e      	ittt	ls
   18b08:	ea4f 3e14 	movls.w	lr, r4, lsr #12
   18b0c:	f10e 0e6e 	addls.w	lr, lr, #110	; 0x6e
   18b10:	ea4f 00ce 	movls.w	r0, lr, lsl #3
   18b14:	f67f af51 	bls.w	189ba <_malloc_r+0x9e>
   18b18:	f5be 7faa 	cmp.w	lr, #340	; 0x154
   18b1c:	bf9e      	ittt	ls
   18b1e:	ea4f 3ed4 	movls.w	lr, r4, lsr #15
   18b22:	f10e 0e77 	addls.w	lr, lr, #119	; 0x77
   18b26:	ea4f 00ce 	movls.w	r0, lr, lsl #3
   18b2a:	f67f af46 	bls.w	189ba <_malloc_r+0x9e>
   18b2e:	f240 5354 	movw	r3, #1364	; 0x554
   18b32:	459e      	cmp	lr, r3
   18b34:	bf95      	itete	ls
   18b36:	ea4f 4e94 	movls.w	lr, r4, lsr #18
   18b3a:	f44f 707c 	movhi.w	r0, #1008	; 0x3f0
   18b3e:	f10e 0e7c 	addls.w	lr, lr, #124	; 0x7c
   18b42:	f04f 0e7e 	movhi.w	lr, #126	; 0x7e
   18b46:	bf98      	it	ls
   18b48:	ea4f 00ce 	movls.w	r0, lr, lsl #3
   18b4c:	e735      	b.n	189ba <_malloc_r+0x9e>
   18b4e:	eb03 020c 	add.w	r2, r3, ip
   18b52:	f103 0508 	add.w	r5, r3, #8
   18b56:	4630      	mov	r0, r6
   18b58:	6853      	ldr	r3, [r2, #4]
   18b5a:	f043 0301 	orr.w	r3, r3, #1
   18b5e:	6053      	str	r3, [r2, #4]
   18b60:	f000 fa78 	bl	19054 <__malloc_unlock>
   18b64:	e70e      	b.n	18984 <_malloc_r+0x68>
   18b66:	f8d7 8008 	ldr.w	r8, [r7, #8]
   18b6a:	f8d8 3004 	ldr.w	r3, [r8, #4]
   18b6e:	f023 0903 	bic.w	r9, r3, #3
   18b72:	ebc4 0209 	rsb	r2, r4, r9
   18b76:	454c      	cmp	r4, r9
   18b78:	bf94      	ite	ls
   18b7a:	2300      	movls	r3, #0
   18b7c:	2301      	movhi	r3, #1
   18b7e:	2a0f      	cmp	r2, #15
   18b80:	bfd8      	it	le
   18b82:	f043 0301 	orrle.w	r3, r3, #1
   18b86:	2b00      	cmp	r3, #0
   18b88:	f000 80a1 	beq.w	18cce <_malloc_r+0x3b2>
   18b8c:	f64a 1b7c 	movw	fp, #43388	; 0xa97c
   18b90:	f8d5 2408 	ldr.w	r2, [r5, #1032]	; 0x408
   18b94:	f2c2 0b00 	movt	fp, #8192	; 0x2000
   18b98:	f8db 3000 	ldr.w	r3, [fp]
   18b9c:	3310      	adds	r3, #16
   18b9e:	191b      	adds	r3, r3, r4
   18ba0:	f1b2 3fff 	cmp.w	r2, #4294967295
   18ba4:	d006      	beq.n	18bb4 <_malloc_r+0x298>
   18ba6:	f503 637e 	add.w	r3, r3, #4064	; 0xfe0
   18baa:	331f      	adds	r3, #31
   18bac:	f423 637e 	bic.w	r3, r3, #4064	; 0xfe0
   18bb0:	f023 031f 	bic.w	r3, r3, #31
   18bb4:	4619      	mov	r1, r3
   18bb6:	4630      	mov	r0, r6
   18bb8:	9301      	str	r3, [sp, #4]
   18bba:	f001 f8f3 	bl	19da4 <_sbrk_r>
   18bbe:	9b01      	ldr	r3, [sp, #4]
   18bc0:	f1b0 3fff 	cmp.w	r0, #4294967295
   18bc4:	4682      	mov	sl, r0
   18bc6:	f000 80f4 	beq.w	18db2 <_malloc_r+0x496>
   18bca:	eb08 0109 	add.w	r1, r8, r9
   18bce:	4281      	cmp	r1, r0
   18bd0:	f200 80ec 	bhi.w	18dac <_malloc_r+0x490>
   18bd4:	f8db 2004 	ldr.w	r2, [fp, #4]
   18bd8:	189a      	adds	r2, r3, r2
   18bda:	4551      	cmp	r1, sl
   18bdc:	f8cb 2004 	str.w	r2, [fp, #4]
   18be0:	f000 8145 	beq.w	18e6e <_malloc_r+0x552>
   18be4:	f8d5 5408 	ldr.w	r5, [r5, #1032]	; 0x408
   18be8:	f240 10dc 	movw	r0, #476	; 0x1dc
   18bec:	f2c2 0000 	movt	r0, #8192	; 0x2000
   18bf0:	f1b5 3fff 	cmp.w	r5, #4294967295
   18bf4:	bf08      	it	eq
   18bf6:	f8c0 a408 	streq.w	sl, [r0, #1032]	; 0x408
   18bfa:	d003      	beq.n	18c04 <_malloc_r+0x2e8>
   18bfc:	4452      	add	r2, sl
   18bfe:	1a51      	subs	r1, r2, r1
   18c00:	f8cb 1004 	str.w	r1, [fp, #4]
   18c04:	f01a 0507 	ands.w	r5, sl, #7
   18c08:	4630      	mov	r0, r6
   18c0a:	bf17      	itett	ne
   18c0c:	f1c5 0508 	rsbne	r5, r5, #8
   18c10:	f44f 5580 	moveq.w	r5, #4096	; 0x1000
   18c14:	44aa      	addne	sl, r5
   18c16:	f505 5580 	addne.w	r5, r5, #4096	; 0x1000
   18c1a:	4453      	add	r3, sl
   18c1c:	051b      	lsls	r3, r3, #20
   18c1e:	0d1b      	lsrs	r3, r3, #20
   18c20:	1aed      	subs	r5, r5, r3
   18c22:	4629      	mov	r1, r5
   18c24:	f001 f8be 	bl	19da4 <_sbrk_r>
   18c28:	f1b0 3fff 	cmp.w	r0, #4294967295
   18c2c:	f000 812c 	beq.w	18e88 <_malloc_r+0x56c>
   18c30:	ebca 0100 	rsb	r1, sl, r0
   18c34:	1949      	adds	r1, r1, r5
   18c36:	f041 0101 	orr.w	r1, r1, #1
   18c3a:	f8db 2004 	ldr.w	r2, [fp, #4]
   18c3e:	f64a 137c 	movw	r3, #43388	; 0xa97c
   18c42:	f8c7 a008 	str.w	sl, [r7, #8]
   18c46:	f2c2 0300 	movt	r3, #8192	; 0x2000
   18c4a:	18aa      	adds	r2, r5, r2
   18c4c:	45b8      	cmp	r8, r7
   18c4e:	f8cb 2004 	str.w	r2, [fp, #4]
   18c52:	f8ca 1004 	str.w	r1, [sl, #4]
   18c56:	d017      	beq.n	18c88 <_malloc_r+0x36c>
   18c58:	f1b9 0f0f 	cmp.w	r9, #15
   18c5c:	f240 80df 	bls.w	18e1e <_malloc_r+0x502>
   18c60:	f1a9 010c 	sub.w	r1, r9, #12
   18c64:	2505      	movs	r5, #5
   18c66:	f021 0107 	bic.w	r1, r1, #7
   18c6a:	eb08 0001 	add.w	r0, r8, r1
   18c6e:	290f      	cmp	r1, #15
   18c70:	6085      	str	r5, [r0, #8]
   18c72:	6045      	str	r5, [r0, #4]
   18c74:	f8d8 0004 	ldr.w	r0, [r8, #4]
   18c78:	f000 0001 	and.w	r0, r0, #1
   18c7c:	ea41 0000 	orr.w	r0, r1, r0
   18c80:	f8c8 0004 	str.w	r0, [r8, #4]
   18c84:	f200 80ac 	bhi.w	18de0 <_malloc_r+0x4c4>
   18c88:	46d0      	mov	r8, sl
   18c8a:	f64a 137c 	movw	r3, #43388	; 0xa97c
   18c8e:	f8db 102c 	ldr.w	r1, [fp, #44]	; 0x2c
   18c92:	f2c2 0300 	movt	r3, #8192	; 0x2000
   18c96:	428a      	cmp	r2, r1
   18c98:	f8db 1030 	ldr.w	r1, [fp, #48]	; 0x30
   18c9c:	bf88      	it	hi
   18c9e:	62da      	strhi	r2, [r3, #44]	; 0x2c
   18ca0:	f64a 137c 	movw	r3, #43388	; 0xa97c
   18ca4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   18ca8:	428a      	cmp	r2, r1
   18caa:	bf88      	it	hi
   18cac:	631a      	strhi	r2, [r3, #48]	; 0x30
   18cae:	e082      	b.n	18db6 <_malloc_r+0x49a>
   18cb0:	185c      	adds	r4, r3, r1
   18cb2:	689a      	ldr	r2, [r3, #8]
   18cb4:	68d9      	ldr	r1, [r3, #12]
   18cb6:	4630      	mov	r0, r6
   18cb8:	6866      	ldr	r6, [r4, #4]
   18cba:	f103 0508 	add.w	r5, r3, #8
   18cbe:	608a      	str	r2, [r1, #8]
   18cc0:	f046 0301 	orr.w	r3, r6, #1
   18cc4:	60d1      	str	r1, [r2, #12]
   18cc6:	6063      	str	r3, [r4, #4]
   18cc8:	f000 f9c4 	bl	19054 <__malloc_unlock>
   18ccc:	e65a      	b.n	18984 <_malloc_r+0x68>
   18cce:	eb08 0304 	add.w	r3, r8, r4
   18cd2:	f042 0201 	orr.w	r2, r2, #1
   18cd6:	f044 0401 	orr.w	r4, r4, #1
   18cda:	4630      	mov	r0, r6
   18cdc:	f8c8 4004 	str.w	r4, [r8, #4]
   18ce0:	f108 0508 	add.w	r5, r8, #8
   18ce4:	605a      	str	r2, [r3, #4]
   18ce6:	60bb      	str	r3, [r7, #8]
   18ce8:	f000 f9b4 	bl	19054 <__malloc_unlock>
   18cec:	e64a      	b.n	18984 <_malloc_r+0x68>
   18cee:	ea4f 225c 	mov.w	r2, ip, lsr #9
   18cf2:	2a04      	cmp	r2, #4
   18cf4:	d954      	bls.n	18da0 <_malloc_r+0x484>
   18cf6:	2a14      	cmp	r2, #20
   18cf8:	f200 8089 	bhi.w	18e0e <_malloc_r+0x4f2>
   18cfc:	325b      	adds	r2, #91	; 0x5b
   18cfe:	ea4f 08c2 	mov.w	r8, r2, lsl #3
   18d02:	44a8      	add	r8, r5
   18d04:	f240 17dc 	movw	r7, #476	; 0x1dc
   18d08:	f2c2 0700 	movt	r7, #8192	; 0x2000
   18d0c:	f8d8 0008 	ldr.w	r0, [r8, #8]
   18d10:	4540      	cmp	r0, r8
   18d12:	d103      	bne.n	18d1c <_malloc_r+0x400>
   18d14:	e06f      	b.n	18df6 <_malloc_r+0x4da>
   18d16:	6880      	ldr	r0, [r0, #8]
   18d18:	4580      	cmp	r8, r0
   18d1a:	d004      	beq.n	18d26 <_malloc_r+0x40a>
   18d1c:	6842      	ldr	r2, [r0, #4]
   18d1e:	f022 0203 	bic.w	r2, r2, #3
   18d22:	4594      	cmp	ip, r2
   18d24:	d3f7      	bcc.n	18d16 <_malloc_r+0x3fa>
   18d26:	f8d0 c00c 	ldr.w	ip, [r0, #12]
   18d2a:	f8c3 c00c 	str.w	ip, [r3, #12]
   18d2e:	6098      	str	r0, [r3, #8]
   18d30:	687a      	ldr	r2, [r7, #4]
   18d32:	60c3      	str	r3, [r0, #12]
   18d34:	f8cc 3008 	str.w	r3, [ip, #8]
   18d38:	e68a      	b.n	18a50 <_malloc_r+0x134>
   18d3a:	191f      	adds	r7, r3, r4
   18d3c:	4630      	mov	r0, r6
   18d3e:	f044 0401 	orr.w	r4, r4, #1
   18d42:	60cf      	str	r7, [r1, #12]
   18d44:	605c      	str	r4, [r3, #4]
   18d46:	f103 0508 	add.w	r5, r3, #8
   18d4a:	50ba      	str	r2, [r7, r2]
   18d4c:	f042 0201 	orr.w	r2, r2, #1
   18d50:	608f      	str	r7, [r1, #8]
   18d52:	607a      	str	r2, [r7, #4]
   18d54:	60b9      	str	r1, [r7, #8]
   18d56:	60f9      	str	r1, [r7, #12]
   18d58:	f000 f97c 	bl	19054 <__malloc_unlock>
   18d5c:	e612      	b.n	18984 <_malloc_r+0x68>
   18d5e:	f10a 0a01 	add.w	sl, sl, #1
   18d62:	f01a 0f03 	tst.w	sl, #3
   18d66:	d05f      	beq.n	18e28 <_malloc_r+0x50c>
   18d68:	f103 0808 	add.w	r8, r3, #8
   18d6c:	e689      	b.n	18a82 <_malloc_r+0x166>
   18d6e:	f103 0208 	add.w	r2, r3, #8
   18d72:	68d3      	ldr	r3, [r2, #12]
   18d74:	429a      	cmp	r2, r3
   18d76:	bf08      	it	eq
   18d78:	f10e 0e02 	addeq.w	lr, lr, #2
   18d7c:	f43f ae36 	beq.w	189ec <_malloc_r+0xd0>
   18d80:	e5ef      	b.n	18962 <_malloc_r+0x46>
   18d82:	461d      	mov	r5, r3
   18d84:	1819      	adds	r1, r3, r0
   18d86:	68da      	ldr	r2, [r3, #12]
   18d88:	4630      	mov	r0, r6
   18d8a:	f855 3f08 	ldr.w	r3, [r5, #8]!
   18d8e:	684c      	ldr	r4, [r1, #4]
   18d90:	6093      	str	r3, [r2, #8]
   18d92:	f044 0401 	orr.w	r4, r4, #1
   18d96:	60da      	str	r2, [r3, #12]
   18d98:	604c      	str	r4, [r1, #4]
   18d9a:	f000 f95b 	bl	19054 <__malloc_unlock>
   18d9e:	e5f1      	b.n	18984 <_malloc_r+0x68>
   18da0:	ea4f 129c 	mov.w	r2, ip, lsr #6
   18da4:	3238      	adds	r2, #56	; 0x38
   18da6:	ea4f 08c2 	mov.w	r8, r2, lsl #3
   18daa:	e7aa      	b.n	18d02 <_malloc_r+0x3e6>
   18dac:	45b8      	cmp	r8, r7
   18dae:	f43f af11 	beq.w	18bd4 <_malloc_r+0x2b8>
   18db2:	f8d7 8008 	ldr.w	r8, [r7, #8]
   18db6:	f8d8 2004 	ldr.w	r2, [r8, #4]
   18dba:	f022 0203 	bic.w	r2, r2, #3
   18dbe:	4294      	cmp	r4, r2
   18dc0:	bf94      	ite	ls
   18dc2:	2300      	movls	r3, #0
   18dc4:	2301      	movhi	r3, #1
   18dc6:	1b12      	subs	r2, r2, r4
   18dc8:	2a0f      	cmp	r2, #15
   18dca:	bfd8      	it	le
   18dcc:	f043 0301 	orrle.w	r3, r3, #1
   18dd0:	2b00      	cmp	r3, #0
   18dd2:	f43f af7c 	beq.w	18cce <_malloc_r+0x3b2>
   18dd6:	4630      	mov	r0, r6
   18dd8:	2500      	movs	r5, #0
   18dda:	f000 f93b 	bl	19054 <__malloc_unlock>
   18dde:	e5d1      	b.n	18984 <_malloc_r+0x68>
   18de0:	f108 0108 	add.w	r1, r8, #8
   18de4:	4630      	mov	r0, r6
   18de6:	9301      	str	r3, [sp, #4]
   18de8:	f7ff fc6e 	bl	186c8 <_free_r>
   18dec:	9b01      	ldr	r3, [sp, #4]
   18dee:	f8d7 8008 	ldr.w	r8, [r7, #8]
   18df2:	685a      	ldr	r2, [r3, #4]
   18df4:	e749      	b.n	18c8a <_malloc_r+0x36e>
   18df6:	f04f 0a01 	mov.w	sl, #1
   18dfa:	f8d7 8004 	ldr.w	r8, [r7, #4]
   18dfe:	1092      	asrs	r2, r2, #2
   18e00:	4684      	mov	ip, r0
   18e02:	fa0a f202 	lsl.w	r2, sl, r2
   18e06:	ea48 0202 	orr.w	r2, r8, r2
   18e0a:	607a      	str	r2, [r7, #4]
   18e0c:	e78d      	b.n	18d2a <_malloc_r+0x40e>
   18e0e:	2a54      	cmp	r2, #84	; 0x54
   18e10:	d824      	bhi.n	18e5c <_malloc_r+0x540>
   18e12:	ea4f 321c 	mov.w	r2, ip, lsr #12
   18e16:	326e      	adds	r2, #110	; 0x6e
   18e18:	ea4f 08c2 	mov.w	r8, r2, lsl #3
   18e1c:	e771      	b.n	18d02 <_malloc_r+0x3e6>
   18e1e:	2301      	movs	r3, #1
   18e20:	46d0      	mov	r8, sl
   18e22:	f8ca 3004 	str.w	r3, [sl, #4]
   18e26:	e7c6      	b.n	18db6 <_malloc_r+0x49a>
   18e28:	464a      	mov	r2, r9
   18e2a:	f01e 0f03 	tst.w	lr, #3
   18e2e:	4613      	mov	r3, r2
   18e30:	f10e 3eff 	add.w	lr, lr, #4294967295
   18e34:	d033      	beq.n	18e9e <_malloc_r+0x582>
   18e36:	f853 2908 	ldr.w	r2, [r3], #-8
   18e3a:	429a      	cmp	r2, r3
   18e3c:	d0f5      	beq.n	18e2a <_malloc_r+0x50e>
   18e3e:	687b      	ldr	r3, [r7, #4]
   18e40:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
   18e44:	459c      	cmp	ip, r3
   18e46:	f63f ae8e 	bhi.w	18b66 <_malloc_r+0x24a>
   18e4a:	f1bc 0f00 	cmp.w	ip, #0
   18e4e:	f43f ae8a 	beq.w	18b66 <_malloc_r+0x24a>
   18e52:	ea1c 0f03 	tst.w	ip, r3
   18e56:	d027      	beq.n	18ea8 <_malloc_r+0x58c>
   18e58:	46d6      	mov	lr, sl
   18e5a:	e60e      	b.n	18a7a <_malloc_r+0x15e>
   18e5c:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
   18e60:	d815      	bhi.n	18e8e <_malloc_r+0x572>
   18e62:	ea4f 32dc 	mov.w	r2, ip, lsr #15
   18e66:	3277      	adds	r2, #119	; 0x77
   18e68:	ea4f 08c2 	mov.w	r8, r2, lsl #3
   18e6c:	e749      	b.n	18d02 <_malloc_r+0x3e6>
   18e6e:	0508      	lsls	r0, r1, #20
   18e70:	0d00      	lsrs	r0, r0, #20
   18e72:	2800      	cmp	r0, #0
   18e74:	f47f aeb6 	bne.w	18be4 <_malloc_r+0x2c8>
   18e78:	f8d7 8008 	ldr.w	r8, [r7, #8]
   18e7c:	444b      	add	r3, r9
   18e7e:	f043 0301 	orr.w	r3, r3, #1
   18e82:	f8c8 3004 	str.w	r3, [r8, #4]
   18e86:	e700      	b.n	18c8a <_malloc_r+0x36e>
   18e88:	2101      	movs	r1, #1
   18e8a:	2500      	movs	r5, #0
   18e8c:	e6d5      	b.n	18c3a <_malloc_r+0x31e>
   18e8e:	f240 5054 	movw	r0, #1364	; 0x554
   18e92:	4282      	cmp	r2, r0
   18e94:	d90d      	bls.n	18eb2 <_malloc_r+0x596>
   18e96:	f44f 787c 	mov.w	r8, #1008	; 0x3f0
   18e9a:	227e      	movs	r2, #126	; 0x7e
   18e9c:	e731      	b.n	18d02 <_malloc_r+0x3e6>
   18e9e:	687b      	ldr	r3, [r7, #4]
   18ea0:	ea23 030c 	bic.w	r3, r3, ip
   18ea4:	607b      	str	r3, [r7, #4]
   18ea6:	e7cb      	b.n	18e40 <_malloc_r+0x524>
   18ea8:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
   18eac:	f10a 0a04 	add.w	sl, sl, #4
   18eb0:	e7cf      	b.n	18e52 <_malloc_r+0x536>
   18eb2:	ea4f 429c 	mov.w	r2, ip, lsr #18
   18eb6:	327c      	adds	r2, #124	; 0x7c
   18eb8:	ea4f 08c2 	mov.w	r8, r2, lsl #3
   18ebc:	e721      	b.n	18d02 <_malloc_r+0x3e6>
   18ebe:	bf00      	nop

00018ec0 <memchr>:
   18ec0:	f010 0f03 	tst.w	r0, #3
   18ec4:	b2c9      	uxtb	r1, r1
   18ec6:	b410      	push	{r4}
   18ec8:	d010      	beq.n	18eec <memchr+0x2c>
   18eca:	2a00      	cmp	r2, #0
   18ecc:	d02f      	beq.n	18f2e <memchr+0x6e>
   18ece:	7803      	ldrb	r3, [r0, #0]
   18ed0:	428b      	cmp	r3, r1
   18ed2:	d02a      	beq.n	18f2a <memchr+0x6a>
   18ed4:	3a01      	subs	r2, #1
   18ed6:	e005      	b.n	18ee4 <memchr+0x24>
   18ed8:	2a00      	cmp	r2, #0
   18eda:	d028      	beq.n	18f2e <memchr+0x6e>
   18edc:	7803      	ldrb	r3, [r0, #0]
   18ede:	3a01      	subs	r2, #1
   18ee0:	428b      	cmp	r3, r1
   18ee2:	d022      	beq.n	18f2a <memchr+0x6a>
   18ee4:	3001      	adds	r0, #1
   18ee6:	f010 0f03 	tst.w	r0, #3
   18eea:	d1f5      	bne.n	18ed8 <memchr+0x18>
   18eec:	2a03      	cmp	r2, #3
   18eee:	d911      	bls.n	18f14 <memchr+0x54>
   18ef0:	ea41 2401 	orr.w	r4, r1, r1, lsl #8
   18ef4:	ea44 4404 	orr.w	r4, r4, r4, lsl #16
   18ef8:	6803      	ldr	r3, [r0, #0]
   18efa:	ea84 0303 	eor.w	r3, r4, r3
   18efe:	f1a3 3c01 	sub.w	ip, r3, #16843009	; 0x1010101
   18f02:	ea2c 0303 	bic.w	r3, ip, r3
   18f06:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   18f0a:	d103      	bne.n	18f14 <memchr+0x54>
   18f0c:	3a04      	subs	r2, #4
   18f0e:	3004      	adds	r0, #4
   18f10:	2a03      	cmp	r2, #3
   18f12:	d8f1      	bhi.n	18ef8 <memchr+0x38>
   18f14:	b15a      	cbz	r2, 18f2e <memchr+0x6e>
   18f16:	7803      	ldrb	r3, [r0, #0]
   18f18:	428b      	cmp	r3, r1
   18f1a:	d006      	beq.n	18f2a <memchr+0x6a>
   18f1c:	3a01      	subs	r2, #1
   18f1e:	b132      	cbz	r2, 18f2e <memchr+0x6e>
   18f20:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   18f24:	3a01      	subs	r2, #1
   18f26:	428b      	cmp	r3, r1
   18f28:	d1f9      	bne.n	18f1e <memchr+0x5e>
   18f2a:	bc10      	pop	{r4}
   18f2c:	4770      	bx	lr
   18f2e:	2000      	movs	r0, #0
   18f30:	e7fb      	b.n	18f2a <memchr+0x6a>
   18f32:	bf00      	nop

00018f34 <memcmp>:
   18f34:	2a03      	cmp	r2, #3
   18f36:	b430      	push	{r4, r5}
   18f38:	4605      	mov	r5, r0
   18f3a:	460c      	mov	r4, r1
   18f3c:	d925      	bls.n	18f8a <memcmp+0x56>
   18f3e:	ea41 0300 	orr.w	r3, r1, r0
   18f42:	f013 0f03 	tst.w	r3, #3
   18f46:	d015      	beq.n	18f74 <memcmp+0x40>
   18f48:	7828      	ldrb	r0, [r5, #0]
   18f4a:	f894 c000 	ldrb.w	ip, [r4]
   18f4e:	4560      	cmp	r0, ip
   18f50:	d11e      	bne.n	18f90 <memcmp+0x5c>
   18f52:	3a01      	subs	r2, #1
   18f54:	2300      	movs	r3, #0
   18f56:	e006      	b.n	18f66 <memcmp+0x32>
   18f58:	7840      	ldrb	r0, [r0, #1]
   18f5a:	3301      	adds	r3, #1
   18f5c:	f891 c001 	ldrb.w	ip, [r1, #1]
   18f60:	3a01      	subs	r2, #1
   18f62:	4560      	cmp	r0, ip
   18f64:	d114      	bne.n	18f90 <memcmp+0x5c>
   18f66:	18e8      	adds	r0, r5, r3
   18f68:	18e1      	adds	r1, r4, r3
   18f6a:	2a00      	cmp	r2, #0
   18f6c:	d1f4      	bne.n	18f58 <memcmp+0x24>
   18f6e:	2000      	movs	r0, #0
   18f70:	bc30      	pop	{r4, r5}
   18f72:	4770      	bx	lr
   18f74:	6804      	ldr	r4, [r0, #0]
   18f76:	680b      	ldr	r3, [r1, #0]
   18f78:	429c      	cmp	r4, r3
   18f7a:	d104      	bne.n	18f86 <memcmp+0x52>
   18f7c:	3a04      	subs	r2, #4
   18f7e:	3004      	adds	r0, #4
   18f80:	3104      	adds	r1, #4
   18f82:	2a03      	cmp	r2, #3
   18f84:	d8f6      	bhi.n	18f74 <memcmp+0x40>
   18f86:	4605      	mov	r5, r0
   18f88:	460c      	mov	r4, r1
   18f8a:	2a00      	cmp	r2, #0
   18f8c:	d1dc      	bne.n	18f48 <memcmp+0x14>
   18f8e:	e7ee      	b.n	18f6e <memcmp+0x3a>
   18f90:	ebcc 0000 	rsb	r0, ip, r0
   18f94:	e7ec      	b.n	18f70 <memcmp+0x3c>
   18f96:	bf00      	nop

00018f98 <memmove>:
   18f98:	4288      	cmp	r0, r1
   18f9a:	468c      	mov	ip, r1
   18f9c:	b470      	push	{r4, r5, r6}
   18f9e:	4605      	mov	r5, r0
   18fa0:	4614      	mov	r4, r2
   18fa2:	d90e      	bls.n	18fc2 <memmove+0x2a>
   18fa4:	188b      	adds	r3, r1, r2
   18fa6:	4298      	cmp	r0, r3
   18fa8:	d20b      	bcs.n	18fc2 <memmove+0x2a>
   18faa:	b142      	cbz	r2, 18fbe <memmove+0x26>
   18fac:	ebc2 0c03 	rsb	ip, r2, r3
   18fb0:	4601      	mov	r1, r0
   18fb2:	1e53      	subs	r3, r2, #1
   18fb4:	f81c 2003 	ldrb.w	r2, [ip, r3]
   18fb8:	54ca      	strb	r2, [r1, r3]
   18fba:	3b01      	subs	r3, #1
   18fbc:	d2fa      	bcs.n	18fb4 <memmove+0x1c>
   18fbe:	bc70      	pop	{r4, r5, r6}
   18fc0:	4770      	bx	lr
   18fc2:	2a0f      	cmp	r2, #15
   18fc4:	d809      	bhi.n	18fda <memmove+0x42>
   18fc6:	2c00      	cmp	r4, #0
   18fc8:	d0f9      	beq.n	18fbe <memmove+0x26>
   18fca:	2300      	movs	r3, #0
   18fcc:	f81c 2003 	ldrb.w	r2, [ip, r3]
   18fd0:	54ea      	strb	r2, [r5, r3]
   18fd2:	3301      	adds	r3, #1
   18fd4:	42a3      	cmp	r3, r4
   18fd6:	d1f9      	bne.n	18fcc <memmove+0x34>
   18fd8:	e7f1      	b.n	18fbe <memmove+0x26>
   18fda:	ea41 0300 	orr.w	r3, r1, r0
   18fde:	f013 0f03 	tst.w	r3, #3
   18fe2:	d1f0      	bne.n	18fc6 <memmove+0x2e>
   18fe4:	4694      	mov	ip, r2
   18fe6:	460c      	mov	r4, r1
   18fe8:	4603      	mov	r3, r0
   18fea:	6825      	ldr	r5, [r4, #0]
   18fec:	f1ac 0c10 	sub.w	ip, ip, #16
   18ff0:	601d      	str	r5, [r3, #0]
   18ff2:	6865      	ldr	r5, [r4, #4]
   18ff4:	605d      	str	r5, [r3, #4]
   18ff6:	68a5      	ldr	r5, [r4, #8]
   18ff8:	609d      	str	r5, [r3, #8]
   18ffa:	68e5      	ldr	r5, [r4, #12]
   18ffc:	3410      	adds	r4, #16
   18ffe:	60dd      	str	r5, [r3, #12]
   19000:	3310      	adds	r3, #16
   19002:	f1bc 0f0f 	cmp.w	ip, #15
   19006:	d8f0      	bhi.n	18fea <memmove+0x52>
   19008:	3a10      	subs	r2, #16
   1900a:	ea4f 1c12 	mov.w	ip, r2, lsr #4
   1900e:	f10c 0501 	add.w	r5, ip, #1
   19012:	ebcc 7c0c 	rsb	ip, ip, ip, lsl #28
   19016:	012d      	lsls	r5, r5, #4
   19018:	eb02 160c 	add.w	r6, r2, ip, lsl #4
   1901c:	eb01 0c05 	add.w	ip, r1, r5
   19020:	1945      	adds	r5, r0, r5
   19022:	2e03      	cmp	r6, #3
   19024:	4634      	mov	r4, r6
   19026:	d9ce      	bls.n	18fc6 <memmove+0x2e>
   19028:	2300      	movs	r3, #0
   1902a:	f85c 2003 	ldr.w	r2, [ip, r3]
   1902e:	50ea      	str	r2, [r5, r3]
   19030:	3304      	adds	r3, #4
   19032:	1af2      	subs	r2, r6, r3
   19034:	2a03      	cmp	r2, #3
   19036:	d8f8      	bhi.n	1902a <memmove+0x92>
   19038:	3e04      	subs	r6, #4
   1903a:	08b3      	lsrs	r3, r6, #2
   1903c:	1c5a      	adds	r2, r3, #1
   1903e:	ebc3 7383 	rsb	r3, r3, r3, lsl #30
   19042:	0092      	lsls	r2, r2, #2
   19044:	4494      	add	ip, r2
   19046:	eb06 0483 	add.w	r4, r6, r3, lsl #2
   1904a:	18ad      	adds	r5, r5, r2
   1904c:	e7bb      	b.n	18fc6 <memmove+0x2e>
   1904e:	bf00      	nop

00019050 <__malloc_lock>:
   19050:	4770      	bx	lr
   19052:	bf00      	nop

00019054 <__malloc_unlock>:
   19054:	4770      	bx	lr
   19056:	bf00      	nop

00019058 <__hi0bits>:
   19058:	0c02      	lsrs	r2, r0, #16
   1905a:	4603      	mov	r3, r0
   1905c:	0412      	lsls	r2, r2, #16
   1905e:	b1b2      	cbz	r2, 1908e <__hi0bits+0x36>
   19060:	2000      	movs	r0, #0
   19062:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
   19066:	d101      	bne.n	1906c <__hi0bits+0x14>
   19068:	3008      	adds	r0, #8
   1906a:	021b      	lsls	r3, r3, #8
   1906c:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
   19070:	d101      	bne.n	19076 <__hi0bits+0x1e>
   19072:	3004      	adds	r0, #4
   19074:	011b      	lsls	r3, r3, #4
   19076:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
   1907a:	d101      	bne.n	19080 <__hi0bits+0x28>
   1907c:	3002      	adds	r0, #2
   1907e:	009b      	lsls	r3, r3, #2
   19080:	2b00      	cmp	r3, #0
   19082:	db03      	blt.n	1908c <__hi0bits+0x34>
   19084:	f013 4f80 	tst.w	r3, #1073741824	; 0x40000000
   19088:	d004      	beq.n	19094 <__hi0bits+0x3c>
   1908a:	3001      	adds	r0, #1
   1908c:	4770      	bx	lr
   1908e:	0403      	lsls	r3, r0, #16
   19090:	2010      	movs	r0, #16
   19092:	e7e6      	b.n	19062 <__hi0bits+0xa>
   19094:	2020      	movs	r0, #32
   19096:	4770      	bx	lr

00019098 <__lo0bits>:
   19098:	6803      	ldr	r3, [r0, #0]
   1909a:	4602      	mov	r2, r0
   1909c:	f013 0007 	ands.w	r0, r3, #7
   190a0:	d009      	beq.n	190b6 <__lo0bits+0x1e>
   190a2:	f013 0f01 	tst.w	r3, #1
   190a6:	d121      	bne.n	190ec <__lo0bits+0x54>
   190a8:	f013 0f02 	tst.w	r3, #2
   190ac:	d122      	bne.n	190f4 <__lo0bits+0x5c>
   190ae:	089b      	lsrs	r3, r3, #2
   190b0:	2002      	movs	r0, #2
   190b2:	6013      	str	r3, [r2, #0]
   190b4:	4770      	bx	lr
   190b6:	b299      	uxth	r1, r3
   190b8:	b909      	cbnz	r1, 190be <__lo0bits+0x26>
   190ba:	0c1b      	lsrs	r3, r3, #16
   190bc:	2010      	movs	r0, #16
   190be:	f013 0fff 	tst.w	r3, #255	; 0xff
   190c2:	d101      	bne.n	190c8 <__lo0bits+0x30>
   190c4:	3008      	adds	r0, #8
   190c6:	0a1b      	lsrs	r3, r3, #8
   190c8:	f013 0f0f 	tst.w	r3, #15
   190cc:	d101      	bne.n	190d2 <__lo0bits+0x3a>
   190ce:	3004      	adds	r0, #4
   190d0:	091b      	lsrs	r3, r3, #4
   190d2:	f013 0f03 	tst.w	r3, #3
   190d6:	d101      	bne.n	190dc <__lo0bits+0x44>
   190d8:	3002      	adds	r0, #2
   190da:	089b      	lsrs	r3, r3, #2
   190dc:	f013 0f01 	tst.w	r3, #1
   190e0:	d102      	bne.n	190e8 <__lo0bits+0x50>
   190e2:	085b      	lsrs	r3, r3, #1
   190e4:	d004      	beq.n	190f0 <__lo0bits+0x58>
   190e6:	3001      	adds	r0, #1
   190e8:	6013      	str	r3, [r2, #0]
   190ea:	4770      	bx	lr
   190ec:	2000      	movs	r0, #0
   190ee:	4770      	bx	lr
   190f0:	2020      	movs	r0, #32
   190f2:	4770      	bx	lr
   190f4:	085b      	lsrs	r3, r3, #1
   190f6:	2001      	movs	r0, #1
   190f8:	6013      	str	r3, [r2, #0]
   190fa:	4770      	bx	lr

000190fc <__mcmp>:
   190fc:	4603      	mov	r3, r0
   190fe:	690a      	ldr	r2, [r1, #16]
   19100:	6900      	ldr	r0, [r0, #16]
   19102:	b410      	push	{r4}
   19104:	1a80      	subs	r0, r0, r2
   19106:	d111      	bne.n	1912c <__mcmp+0x30>
   19108:	3204      	adds	r2, #4
   1910a:	f103 0c14 	add.w	ip, r3, #20
   1910e:	0092      	lsls	r2, r2, #2
   19110:	189b      	adds	r3, r3, r2
   19112:	1889      	adds	r1, r1, r2
   19114:	3104      	adds	r1, #4
   19116:	3304      	adds	r3, #4
   19118:	f853 4c04 	ldr.w	r4, [r3, #-4]
   1911c:	3b04      	subs	r3, #4
   1911e:	f851 2c04 	ldr.w	r2, [r1, #-4]
   19122:	3904      	subs	r1, #4
   19124:	4294      	cmp	r4, r2
   19126:	d103      	bne.n	19130 <__mcmp+0x34>
   19128:	459c      	cmp	ip, r3
   1912a:	d3f5      	bcc.n	19118 <__mcmp+0x1c>
   1912c:	bc10      	pop	{r4}
   1912e:	4770      	bx	lr
   19130:	bf38      	it	cc
   19132:	f04f 30ff 	movcc.w	r0, #4294967295
   19136:	d3f9      	bcc.n	1912c <__mcmp+0x30>
   19138:	2001      	movs	r0, #1
   1913a:	e7f7      	b.n	1912c <__mcmp+0x30>

0001913c <__ulp>:
   1913c:	f240 0300 	movw	r3, #0
   19140:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
   19144:	ea01 0303 	and.w	r3, r1, r3
   19148:	f1a3 7350 	sub.w	r3, r3, #54525952	; 0x3400000
   1914c:	2b00      	cmp	r3, #0
   1914e:	dd02      	ble.n	19156 <__ulp+0x1a>
   19150:	4619      	mov	r1, r3
   19152:	2000      	movs	r0, #0
   19154:	4770      	bx	lr
   19156:	425b      	negs	r3, r3
   19158:	151b      	asrs	r3, r3, #20
   1915a:	2b13      	cmp	r3, #19
   1915c:	dd0e      	ble.n	1917c <__ulp+0x40>
   1915e:	3b14      	subs	r3, #20
   19160:	2b1e      	cmp	r3, #30
   19162:	dd03      	ble.n	1916c <__ulp+0x30>
   19164:	2301      	movs	r3, #1
   19166:	2100      	movs	r1, #0
   19168:	4618      	mov	r0, r3
   1916a:	4770      	bx	lr
   1916c:	2201      	movs	r2, #1
   1916e:	f1c3 031f 	rsb	r3, r3, #31
   19172:	2100      	movs	r1, #0
   19174:	fa12 f303 	lsls.w	r3, r2, r3
   19178:	4618      	mov	r0, r3
   1917a:	4770      	bx	lr
   1917c:	f44f 2200 	mov.w	r2, #524288	; 0x80000
   19180:	2000      	movs	r0, #0
   19182:	fa52 f103 	asrs.w	r1, r2, r3
   19186:	4770      	bx	lr

00019188 <__b2d>:
   19188:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1918c:	6904      	ldr	r4, [r0, #16]
   1918e:	f100 0614 	add.w	r6, r0, #20
   19192:	460f      	mov	r7, r1
   19194:	3404      	adds	r4, #4
   19196:	f850 5024 	ldr.w	r5, [r0, r4, lsl #2]
   1919a:	eb00 0484 	add.w	r4, r0, r4, lsl #2
   1919e:	46a0      	mov	r8, r4
   191a0:	4628      	mov	r0, r5
   191a2:	f7ff ff59 	bl	19058 <__hi0bits>
   191a6:	280a      	cmp	r0, #10
   191a8:	f1c0 0320 	rsb	r3, r0, #32
   191ac:	603b      	str	r3, [r7, #0]
   191ae:	dc14      	bgt.n	191da <__b2d+0x52>
   191b0:	42a6      	cmp	r6, r4
   191b2:	f1c0 030b 	rsb	r3, r0, #11
   191b6:	d237      	bcs.n	19228 <__b2d+0xa0>
   191b8:	f854 1c04 	ldr.w	r1, [r4, #-4]
   191bc:	40d9      	lsrs	r1, r3
   191be:	fa25 fc03 	lsr.w	ip, r5, r3
   191c2:	3015      	adds	r0, #21
   191c4:	f04c 537e 	orr.w	r3, ip, #1065353216	; 0x3f800000
   191c8:	4085      	lsls	r5, r0
   191ca:	f443 03e0 	orr.w	r3, r3, #7340032	; 0x700000
   191ce:	ea41 0205 	orr.w	r2, r1, r5
   191d2:	4610      	mov	r0, r2
   191d4:	4619      	mov	r1, r3
   191d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   191da:	42a6      	cmp	r6, r4
   191dc:	d320      	bcc.n	19220 <__b2d+0x98>
   191de:	2100      	movs	r1, #0
   191e0:	380b      	subs	r0, #11
   191e2:	bf02      	ittt	eq
   191e4:	f045 537e 	orreq.w	r3, r5, #1065353216	; 0x3f800000
   191e8:	460a      	moveq	r2, r1
   191ea:	f443 03e0 	orreq.w	r3, r3, #7340032	; 0x700000
   191ee:	d0f0      	beq.n	191d2 <__b2d+0x4a>
   191f0:	42b4      	cmp	r4, r6
   191f2:	f1c0 0320 	rsb	r3, r0, #32
   191f6:	d919      	bls.n	1922c <__b2d+0xa4>
   191f8:	f854 4c04 	ldr.w	r4, [r4, #-4]
   191fc:	40dc      	lsrs	r4, r3
   191fe:	4085      	lsls	r5, r0
   19200:	fa21 fc03 	lsr.w	ip, r1, r3
   19204:	f045 557e 	orr.w	r5, r5, #1065353216	; 0x3f800000
   19208:	fa11 f000 	lsls.w	r0, r1, r0
   1920c:	f445 05e0 	orr.w	r5, r5, #7340032	; 0x700000
   19210:	ea44 0200 	orr.w	r2, r4, r0
   19214:	ea45 030c 	orr.w	r3, r5, ip
   19218:	4610      	mov	r0, r2
   1921a:	4619      	mov	r1, r3
   1921c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   19220:	f854 1c04 	ldr.w	r1, [r4, #-4]
   19224:	3c04      	subs	r4, #4
   19226:	e7db      	b.n	191e0 <__b2d+0x58>
   19228:	2100      	movs	r1, #0
   1922a:	e7c8      	b.n	191be <__b2d+0x36>
   1922c:	2400      	movs	r4, #0
   1922e:	e7e6      	b.n	191fe <__b2d+0x76>

00019230 <__ratio>:
   19230:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   19234:	b083      	sub	sp, #12
   19236:	460e      	mov	r6, r1
   19238:	a901      	add	r1, sp, #4
   1923a:	4607      	mov	r7, r0
   1923c:	f7ff ffa4 	bl	19188 <__b2d>
   19240:	460d      	mov	r5, r1
   19242:	4604      	mov	r4, r0
   19244:	4669      	mov	r1, sp
   19246:	4630      	mov	r0, r6
   19248:	f7ff ff9e 	bl	19188 <__b2d>
   1924c:	f8dd c004 	ldr.w	ip, [sp, #4]
   19250:	46a9      	mov	r9, r5
   19252:	46a0      	mov	r8, r4
   19254:	460b      	mov	r3, r1
   19256:	4602      	mov	r2, r0
   19258:	6931      	ldr	r1, [r6, #16]
   1925a:	4616      	mov	r6, r2
   1925c:	6938      	ldr	r0, [r7, #16]
   1925e:	461f      	mov	r7, r3
   19260:	1a40      	subs	r0, r0, r1
   19262:	9900      	ldr	r1, [sp, #0]
   19264:	ebc1 010c 	rsb	r1, r1, ip
   19268:	eb01 1140 	add.w	r1, r1, r0, lsl #5
   1926c:	2900      	cmp	r1, #0
   1926e:	bfc9      	itett	gt
   19270:	eb05 5901 	addgt.w	r9, r5, r1, lsl #20
   19274:	eba3 5701 	suble.w	r7, r3, r1, lsl #20
   19278:	4624      	movgt	r4, r4
   1927a:	464d      	movgt	r5, r9
   1927c:	bfdc      	itt	le
   1927e:	4612      	movle	r2, r2
   19280:	463b      	movle	r3, r7
   19282:	4620      	mov	r0, r4
   19284:	4629      	mov	r1, r5
   19286:	f7fb fbff 	bl	14a88 <__aeabi_ddiv>
   1928a:	b003      	add	sp, #12
   1928c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00019290 <_mprec_log10>:
   19290:	2817      	cmp	r0, #23
   19292:	b510      	push	{r4, lr}
   19294:	4604      	mov	r4, r0
   19296:	dd0e      	ble.n	192b6 <_mprec_log10+0x26>
   19298:	f240 0100 	movw	r1, #0
   1929c:	2000      	movs	r0, #0
   1929e:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
   192a2:	f240 0300 	movw	r3, #0
   192a6:	2200      	movs	r2, #0
   192a8:	f2c4 0324 	movt	r3, #16420	; 0x4024
   192ac:	f7fb fac2 	bl	14834 <__aeabi_dmul>
   192b0:	3c01      	subs	r4, #1
   192b2:	d1f6      	bne.n	192a2 <_mprec_log10+0x12>
   192b4:	bd10      	pop	{r4, pc}
   192b6:	f244 1358 	movw	r3, #16728	; 0x4158
   192ba:	f2c0 0302 	movt	r3, #2
   192be:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
   192c2:	e9d3 0100 	ldrd	r0, r1, [r3]
   192c6:	bd10      	pop	{r4, pc}

000192c8 <__copybits>:
   192c8:	6913      	ldr	r3, [r2, #16]
   192ca:	3901      	subs	r1, #1
   192cc:	f102 0c14 	add.w	ip, r2, #20
   192d0:	b410      	push	{r4}
   192d2:	eb02 0283 	add.w	r2, r2, r3, lsl #2
   192d6:	114c      	asrs	r4, r1, #5
   192d8:	3214      	adds	r2, #20
   192da:	3401      	adds	r4, #1
   192dc:	4594      	cmp	ip, r2
   192de:	eb00 0484 	add.w	r4, r0, r4, lsl #2
   192e2:	d20f      	bcs.n	19304 <__copybits+0x3c>
   192e4:	2300      	movs	r3, #0
   192e6:	f85c 1003 	ldr.w	r1, [ip, r3]
   192ea:	50c1      	str	r1, [r0, r3]
   192ec:	3304      	adds	r3, #4
   192ee:	eb03 010c 	add.w	r1, r3, ip
   192f2:	428a      	cmp	r2, r1
   192f4:	d8f7      	bhi.n	192e6 <__copybits+0x1e>
   192f6:	ea6f 0c0c 	mvn.w	ip, ip
   192fa:	4462      	add	r2, ip
   192fc:	f022 0203 	bic.w	r2, r2, #3
   19300:	3204      	adds	r2, #4
   19302:	1880      	adds	r0, r0, r2
   19304:	4284      	cmp	r4, r0
   19306:	d904      	bls.n	19312 <__copybits+0x4a>
   19308:	2300      	movs	r3, #0
   1930a:	f840 3b04 	str.w	r3, [r0], #4
   1930e:	4284      	cmp	r4, r0
   19310:	d8fb      	bhi.n	1930a <__copybits+0x42>
   19312:	bc10      	pop	{r4}
   19314:	4770      	bx	lr
   19316:	bf00      	nop

00019318 <__any_on>:
   19318:	6902      	ldr	r2, [r0, #16]
   1931a:	114b      	asrs	r3, r1, #5
   1931c:	429a      	cmp	r2, r3
   1931e:	db10      	blt.n	19342 <__any_on+0x2a>
   19320:	dd0e      	ble.n	19340 <__any_on+0x28>
   19322:	f011 011f 	ands.w	r1, r1, #31
   19326:	d00b      	beq.n	19340 <__any_on+0x28>
   19328:	461a      	mov	r2, r3
   1932a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
   1932e:	695b      	ldr	r3, [r3, #20]
   19330:	fa23 fc01 	lsr.w	ip, r3, r1
   19334:	fa0c f101 	lsl.w	r1, ip, r1
   19338:	4299      	cmp	r1, r3
   1933a:	d002      	beq.n	19342 <__any_on+0x2a>
   1933c:	2001      	movs	r0, #1
   1933e:	4770      	bx	lr
   19340:	461a      	mov	r2, r3
   19342:	3204      	adds	r2, #4
   19344:	f100 0114 	add.w	r1, r0, #20
   19348:	eb00 0382 	add.w	r3, r0, r2, lsl #2
   1934c:	f103 0c04 	add.w	ip, r3, #4
   19350:	4561      	cmp	r1, ip
   19352:	d20b      	bcs.n	1936c <__any_on+0x54>
   19354:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
   19358:	2a00      	cmp	r2, #0
   1935a:	d1ef      	bne.n	1933c <__any_on+0x24>
   1935c:	4299      	cmp	r1, r3
   1935e:	d205      	bcs.n	1936c <__any_on+0x54>
   19360:	f853 2d04 	ldr.w	r2, [r3, #-4]!
   19364:	2a00      	cmp	r2, #0
   19366:	d1e9      	bne.n	1933c <__any_on+0x24>
   19368:	4299      	cmp	r1, r3
   1936a:	d3f9      	bcc.n	19360 <__any_on+0x48>
   1936c:	2000      	movs	r0, #0
   1936e:	4770      	bx	lr

00019370 <_Bfree>:
   19370:	b530      	push	{r4, r5, lr}
   19372:	6a45      	ldr	r5, [r0, #36]	; 0x24
   19374:	b083      	sub	sp, #12
   19376:	4604      	mov	r4, r0
   19378:	b155      	cbz	r5, 19390 <_Bfree+0x20>
   1937a:	b139      	cbz	r1, 1938c <_Bfree+0x1c>
   1937c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1937e:	684a      	ldr	r2, [r1, #4]
   19380:	68db      	ldr	r3, [r3, #12]
   19382:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
   19386:	6008      	str	r0, [r1, #0]
   19388:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
   1938c:	b003      	add	sp, #12
   1938e:	bd30      	pop	{r4, r5, pc}
   19390:	2010      	movs	r0, #16
   19392:	9101      	str	r1, [sp, #4]
   19394:	f7ff faba 	bl	1890c <malloc>
   19398:	9901      	ldr	r1, [sp, #4]
   1939a:	6260      	str	r0, [r4, #36]	; 0x24
   1939c:	60c5      	str	r5, [r0, #12]
   1939e:	6045      	str	r5, [r0, #4]
   193a0:	6085      	str	r5, [r0, #8]
   193a2:	6005      	str	r5, [r0, #0]
   193a4:	e7e9      	b.n	1937a <_Bfree+0xa>
   193a6:	bf00      	nop

000193a8 <_Balloc>:
   193a8:	b570      	push	{r4, r5, r6, lr}
   193aa:	6a44      	ldr	r4, [r0, #36]	; 0x24
   193ac:	4606      	mov	r6, r0
   193ae:	460d      	mov	r5, r1
   193b0:	b164      	cbz	r4, 193cc <_Balloc+0x24>
   193b2:	68e2      	ldr	r2, [r4, #12]
   193b4:	b1a2      	cbz	r2, 193e0 <_Balloc+0x38>
   193b6:	f852 3025 	ldr.w	r3, [r2, r5, lsl #2]
   193ba:	b1eb      	cbz	r3, 193f8 <_Balloc+0x50>
   193bc:	6819      	ldr	r1, [r3, #0]
   193be:	f842 1025 	str.w	r1, [r2, r5, lsl #2]
   193c2:	2200      	movs	r2, #0
   193c4:	60da      	str	r2, [r3, #12]
   193c6:	611a      	str	r2, [r3, #16]
   193c8:	4618      	mov	r0, r3
   193ca:	bd70      	pop	{r4, r5, r6, pc}
   193cc:	2010      	movs	r0, #16
   193ce:	f7ff fa9d 	bl	1890c <malloc>
   193d2:	2300      	movs	r3, #0
   193d4:	4604      	mov	r4, r0
   193d6:	6270      	str	r0, [r6, #36]	; 0x24
   193d8:	60c3      	str	r3, [r0, #12]
   193da:	6043      	str	r3, [r0, #4]
   193dc:	6083      	str	r3, [r0, #8]
   193de:	6003      	str	r3, [r0, #0]
   193e0:	2210      	movs	r2, #16
   193e2:	4630      	mov	r0, r6
   193e4:	2104      	movs	r1, #4
   193e6:	f000 fddf 	bl	19fa8 <_calloc_r>
   193ea:	6a73      	ldr	r3, [r6, #36]	; 0x24
   193ec:	60e0      	str	r0, [r4, #12]
   193ee:	68da      	ldr	r2, [r3, #12]
   193f0:	2a00      	cmp	r2, #0
   193f2:	d1e0      	bne.n	193b6 <_Balloc+0xe>
   193f4:	4613      	mov	r3, r2
   193f6:	e7e7      	b.n	193c8 <_Balloc+0x20>
   193f8:	2401      	movs	r4, #1
   193fa:	4630      	mov	r0, r6
   193fc:	4621      	mov	r1, r4
   193fe:	40ac      	lsls	r4, r5
   19400:	1d62      	adds	r2, r4, #5
   19402:	0092      	lsls	r2, r2, #2
   19404:	f000 fdd0 	bl	19fa8 <_calloc_r>
   19408:	4603      	mov	r3, r0
   1940a:	2800      	cmp	r0, #0
   1940c:	d0dc      	beq.n	193c8 <_Balloc+0x20>
   1940e:	6045      	str	r5, [r0, #4]
   19410:	6084      	str	r4, [r0, #8]
   19412:	e7d6      	b.n	193c2 <_Balloc+0x1a>

00019414 <__d2b>:
   19414:	e92d 45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
   19418:	b083      	sub	sp, #12
   1941a:	2101      	movs	r1, #1
   1941c:	461d      	mov	r5, r3
   1941e:	4614      	mov	r4, r2
   19420:	9f0a      	ldr	r7, [sp, #40]	; 0x28
   19422:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
   19424:	f7ff ffc0 	bl	193a8 <_Balloc>
   19428:	f025 4200 	bic.w	r2, r5, #2147483648	; 0x80000000
   1942c:	f025 437f 	bic.w	r3, r5, #4278190080	; 0xff000000
   19430:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
   19434:	4615      	mov	r5, r2
   19436:	ea5f 5a12 	movs.w	sl, r2, lsr #20
   1943a:	9300      	str	r3, [sp, #0]
   1943c:	bf1c      	itt	ne
   1943e:	f443 1380 	orrne.w	r3, r3, #1048576	; 0x100000
   19442:	9300      	strne	r3, [sp, #0]
   19444:	4680      	mov	r8, r0
   19446:	2c00      	cmp	r4, #0
   19448:	d023      	beq.n	19492 <__d2b+0x7e>
   1944a:	a802      	add	r0, sp, #8
   1944c:	f840 4d04 	str.w	r4, [r0, #-4]!
   19450:	f7ff fe22 	bl	19098 <__lo0bits>
   19454:	4603      	mov	r3, r0
   19456:	2800      	cmp	r0, #0
   19458:	d137      	bne.n	194ca <__d2b+0xb6>
   1945a:	9901      	ldr	r1, [sp, #4]
   1945c:	9a00      	ldr	r2, [sp, #0]
   1945e:	f8c8 1014 	str.w	r1, [r8, #20]
   19462:	2a00      	cmp	r2, #0
   19464:	bf14      	ite	ne
   19466:	2402      	movne	r4, #2
   19468:	2401      	moveq	r4, #1
   1946a:	f8c8 2018 	str.w	r2, [r8, #24]
   1946e:	f8c8 4010 	str.w	r4, [r8, #16]
   19472:	f1ba 0f00 	cmp.w	sl, #0
   19476:	d01b      	beq.n	194b0 <__d2b+0x9c>
   19478:	f5aa 6a86 	sub.w	sl, sl, #1072	; 0x430
   1947c:	f1c3 0235 	rsb	r2, r3, #53	; 0x35
   19480:	f1aa 0a03 	sub.w	sl, sl, #3
   19484:	4453      	add	r3, sl
   19486:	603b      	str	r3, [r7, #0]
   19488:	6032      	str	r2, [r6, #0]
   1948a:	4640      	mov	r0, r8
   1948c:	b003      	add	sp, #12
   1948e:	e8bd 85f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, pc}
   19492:	4668      	mov	r0, sp
   19494:	f7ff fe00 	bl	19098 <__lo0bits>
   19498:	2301      	movs	r3, #1
   1949a:	461c      	mov	r4, r3
   1949c:	f8c8 3010 	str.w	r3, [r8, #16]
   194a0:	9b00      	ldr	r3, [sp, #0]
   194a2:	f8c8 3014 	str.w	r3, [r8, #20]
   194a6:	f100 0320 	add.w	r3, r0, #32
   194aa:	f1ba 0f00 	cmp.w	sl, #0
   194ae:	d1e3      	bne.n	19478 <__d2b+0x64>
   194b0:	eb08 0284 	add.w	r2, r8, r4, lsl #2
   194b4:	f5a3 6386 	sub.w	r3, r3, #1072	; 0x430
   194b8:	3b02      	subs	r3, #2
   194ba:	603b      	str	r3, [r7, #0]
   194bc:	6910      	ldr	r0, [r2, #16]
   194be:	f7ff fdcb 	bl	19058 <__hi0bits>
   194c2:	ebc0 1044 	rsb	r0, r0, r4, lsl #5
   194c6:	6030      	str	r0, [r6, #0]
   194c8:	e7df      	b.n	1948a <__d2b+0x76>
   194ca:	9a00      	ldr	r2, [sp, #0]
   194cc:	f1c0 0120 	rsb	r1, r0, #32
   194d0:	fa12 f101 	lsls.w	r1, r2, r1
   194d4:	40c2      	lsrs	r2, r0
   194d6:	9801      	ldr	r0, [sp, #4]
   194d8:	4301      	orrs	r1, r0
   194da:	f8c8 1014 	str.w	r1, [r8, #20]
   194de:	9200      	str	r2, [sp, #0]
   194e0:	e7bf      	b.n	19462 <__d2b+0x4e>
   194e2:	bf00      	nop

000194e4 <__mdiff>:
   194e4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   194e8:	6913      	ldr	r3, [r2, #16]
   194ea:	690f      	ldr	r7, [r1, #16]
   194ec:	460c      	mov	r4, r1
   194ee:	4615      	mov	r5, r2
   194f0:	1aff      	subs	r7, r7, r3
   194f2:	2f00      	cmp	r7, #0
   194f4:	d04f      	beq.n	19596 <__mdiff+0xb2>
   194f6:	db6a      	blt.n	195ce <__mdiff+0xea>
   194f8:	2700      	movs	r7, #0
   194fa:	f101 0614 	add.w	r6, r1, #20
   194fe:	6861      	ldr	r1, [r4, #4]
   19500:	f7ff ff52 	bl	193a8 <_Balloc>
   19504:	f8d5 8010 	ldr.w	r8, [r5, #16]
   19508:	f8d4 c010 	ldr.w	ip, [r4, #16]
   1950c:	f105 0114 	add.w	r1, r5, #20
   19510:	2200      	movs	r2, #0
   19512:	eb05 0588 	add.w	r5, r5, r8, lsl #2
   19516:	eb04 048c 	add.w	r4, r4, ip, lsl #2
   1951a:	f105 0814 	add.w	r8, r5, #20
   1951e:	3414      	adds	r4, #20
   19520:	f100 0314 	add.w	r3, r0, #20
   19524:	60c7      	str	r7, [r0, #12]
   19526:	f851 7b04 	ldr.w	r7, [r1], #4
   1952a:	f856 5b04 	ldr.w	r5, [r6], #4
   1952e:	46bb      	mov	fp, r7
   19530:	fa1f fa87 	uxth.w	sl, r7
   19534:	0c3f      	lsrs	r7, r7, #16
   19536:	fa1f f985 	uxth.w	r9, r5
   1953a:	ebc7 4715 	rsb	r7, r7, r5, lsr #16
   1953e:	ebca 0a09 	rsb	sl, sl, r9
   19542:	4452      	add	r2, sl
   19544:	eb07 4722 	add.w	r7, r7, r2, asr #16
   19548:	b292      	uxth	r2, r2
   1954a:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
   1954e:	f843 2b04 	str.w	r2, [r3], #4
   19552:	143a      	asrs	r2, r7, #16
   19554:	4588      	cmp	r8, r1
   19556:	d8e6      	bhi.n	19526 <__mdiff+0x42>
   19558:	42a6      	cmp	r6, r4
   1955a:	d20e      	bcs.n	1957a <__mdiff+0x96>
   1955c:	f856 1b04 	ldr.w	r1, [r6], #4
   19560:	b28d      	uxth	r5, r1
   19562:	0c09      	lsrs	r1, r1, #16
   19564:	1952      	adds	r2, r2, r5
   19566:	eb01 4122 	add.w	r1, r1, r2, asr #16
   1956a:	b292      	uxth	r2, r2
   1956c:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
   19570:	f843 2b04 	str.w	r2, [r3], #4
   19574:	140a      	asrs	r2, r1, #16
   19576:	42b4      	cmp	r4, r6
   19578:	d8f0      	bhi.n	1955c <__mdiff+0x78>
   1957a:	f853 2c04 	ldr.w	r2, [r3, #-4]
   1957e:	b932      	cbnz	r2, 1958e <__mdiff+0xaa>
   19580:	f853 2c08 	ldr.w	r2, [r3, #-8]
   19584:	f10c 3cff 	add.w	ip, ip, #4294967295
   19588:	3b04      	subs	r3, #4
   1958a:	2a00      	cmp	r2, #0
   1958c:	d0f8      	beq.n	19580 <__mdiff+0x9c>
   1958e:	f8c0 c010 	str.w	ip, [r0, #16]
   19592:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   19596:	3304      	adds	r3, #4
   19598:	f101 0614 	add.w	r6, r1, #20
   1959c:	009b      	lsls	r3, r3, #2
   1959e:	18d2      	adds	r2, r2, r3
   195a0:	18cb      	adds	r3, r1, r3
   195a2:	3304      	adds	r3, #4
   195a4:	3204      	adds	r2, #4
   195a6:	f853 cc04 	ldr.w	ip, [r3, #-4]
   195aa:	3b04      	subs	r3, #4
   195ac:	f852 1c04 	ldr.w	r1, [r2, #-4]
   195b0:	3a04      	subs	r2, #4
   195b2:	458c      	cmp	ip, r1
   195b4:	d10a      	bne.n	195cc <__mdiff+0xe8>
   195b6:	429e      	cmp	r6, r3
   195b8:	d3f5      	bcc.n	195a6 <__mdiff+0xc2>
   195ba:	2100      	movs	r1, #0
   195bc:	f7ff fef4 	bl	193a8 <_Balloc>
   195c0:	2301      	movs	r3, #1
   195c2:	6103      	str	r3, [r0, #16]
   195c4:	2300      	movs	r3, #0
   195c6:	6143      	str	r3, [r0, #20]
   195c8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   195cc:	d297      	bcs.n	194fe <__mdiff+0x1a>
   195ce:	4623      	mov	r3, r4
   195d0:	462c      	mov	r4, r5
   195d2:	2701      	movs	r7, #1
   195d4:	461d      	mov	r5, r3
   195d6:	f104 0614 	add.w	r6, r4, #20
   195da:	e790      	b.n	194fe <__mdiff+0x1a>

000195dc <__lshift>:
   195dc:	e92d 45f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, sl, lr}
   195e0:	690d      	ldr	r5, [r1, #16]
   195e2:	688b      	ldr	r3, [r1, #8]
   195e4:	1156      	asrs	r6, r2, #5
   195e6:	3501      	adds	r5, #1
   195e8:	460c      	mov	r4, r1
   195ea:	19ad      	adds	r5, r5, r6
   195ec:	4690      	mov	r8, r2
   195ee:	429d      	cmp	r5, r3
   195f0:	4682      	mov	sl, r0
   195f2:	6849      	ldr	r1, [r1, #4]
   195f4:	dd03      	ble.n	195fe <__lshift+0x22>
   195f6:	005b      	lsls	r3, r3, #1
   195f8:	3101      	adds	r1, #1
   195fa:	429d      	cmp	r5, r3
   195fc:	dcfb      	bgt.n	195f6 <__lshift+0x1a>
   195fe:	4650      	mov	r0, sl
   19600:	f7ff fed2 	bl	193a8 <_Balloc>
   19604:	2e00      	cmp	r6, #0
   19606:	4607      	mov	r7, r0
   19608:	f100 0214 	add.w	r2, r0, #20
   1960c:	dd0a      	ble.n	19624 <__lshift+0x48>
   1960e:	2300      	movs	r3, #0
   19610:	4619      	mov	r1, r3
   19612:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
   19616:	3301      	adds	r3, #1
   19618:	42b3      	cmp	r3, r6
   1961a:	d1fa      	bne.n	19612 <__lshift+0x36>
   1961c:	eb07 0383 	add.w	r3, r7, r3, lsl #2
   19620:	f103 0214 	add.w	r2, r3, #20
   19624:	6920      	ldr	r0, [r4, #16]
   19626:	f104 0314 	add.w	r3, r4, #20
   1962a:	eb04 0080 	add.w	r0, r4, r0, lsl #2
   1962e:	3014      	adds	r0, #20
   19630:	f018 081f 	ands.w	r8, r8, #31
   19634:	d01b      	beq.n	1966e <__lshift+0x92>
   19636:	f1c8 0e20 	rsb	lr, r8, #32
   1963a:	2100      	movs	r1, #0
   1963c:	681e      	ldr	r6, [r3, #0]
   1963e:	fa06 fc08 	lsl.w	ip, r6, r8
   19642:	ea41 010c 	orr.w	r1, r1, ip
   19646:	f842 1b04 	str.w	r1, [r2], #4
   1964a:	f853 1b04 	ldr.w	r1, [r3], #4
   1964e:	4298      	cmp	r0, r3
   19650:	fa21 f10e 	lsr.w	r1, r1, lr
   19654:	d8f2      	bhi.n	1963c <__lshift+0x60>
   19656:	6011      	str	r1, [r2, #0]
   19658:	b101      	cbz	r1, 1965c <__lshift+0x80>
   1965a:	3501      	adds	r5, #1
   1965c:	4650      	mov	r0, sl
   1965e:	3d01      	subs	r5, #1
   19660:	4621      	mov	r1, r4
   19662:	613d      	str	r5, [r7, #16]
   19664:	f7ff fe84 	bl	19370 <_Bfree>
   19668:	4638      	mov	r0, r7
   1966a:	e8bd 85f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, sl, pc}
   1966e:	f853 1008 	ldr.w	r1, [r3, r8]
   19672:	f842 1008 	str.w	r1, [r2, r8]
   19676:	f108 0804 	add.w	r8, r8, #4
   1967a:	eb08 0103 	add.w	r1, r8, r3
   1967e:	4288      	cmp	r0, r1
   19680:	d9ec      	bls.n	1965c <__lshift+0x80>
   19682:	f853 1008 	ldr.w	r1, [r3, r8]
   19686:	f842 1008 	str.w	r1, [r2, r8]
   1968a:	f108 0804 	add.w	r8, r8, #4
   1968e:	eb08 0103 	add.w	r1, r8, r3
   19692:	4288      	cmp	r0, r1
   19694:	d8eb      	bhi.n	1966e <__lshift+0x92>
   19696:	e7e1      	b.n	1965c <__lshift+0x80>

00019698 <__multiply>:
   19698:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1969c:	f8d1 8010 	ldr.w	r8, [r1, #16]
   196a0:	6917      	ldr	r7, [r2, #16]
   196a2:	460d      	mov	r5, r1
   196a4:	4616      	mov	r6, r2
   196a6:	b087      	sub	sp, #28
   196a8:	45b8      	cmp	r8, r7
   196aa:	bfb5      	itete	lt
   196ac:	4615      	movlt	r5, r2
   196ae:	463b      	movge	r3, r7
   196b0:	460b      	movlt	r3, r1
   196b2:	4647      	movge	r7, r8
   196b4:	bfb4      	ite	lt
   196b6:	461e      	movlt	r6, r3
   196b8:	4698      	movge	r8, r3
   196ba:	68ab      	ldr	r3, [r5, #8]
   196bc:	eb08 0407 	add.w	r4, r8, r7
   196c0:	6869      	ldr	r1, [r5, #4]
   196c2:	429c      	cmp	r4, r3
   196c4:	bfc8      	it	gt
   196c6:	3101      	addgt	r1, #1
   196c8:	f7ff fe6e 	bl	193a8 <_Balloc>
   196cc:	eb00 0384 	add.w	r3, r0, r4, lsl #2
   196d0:	f100 0b14 	add.w	fp, r0, #20
   196d4:	3314      	adds	r3, #20
   196d6:	9003      	str	r0, [sp, #12]
   196d8:	459b      	cmp	fp, r3
   196da:	9304      	str	r3, [sp, #16]
   196dc:	d206      	bcs.n	196ec <__multiply+0x54>
   196de:	9904      	ldr	r1, [sp, #16]
   196e0:	465b      	mov	r3, fp
   196e2:	2200      	movs	r2, #0
   196e4:	f843 2b04 	str.w	r2, [r3], #4
   196e8:	4299      	cmp	r1, r3
   196ea:	d8fb      	bhi.n	196e4 <__multiply+0x4c>
   196ec:	eb06 0888 	add.w	r8, r6, r8, lsl #2
   196f0:	f106 0914 	add.w	r9, r6, #20
   196f4:	f108 0814 	add.w	r8, r8, #20
   196f8:	eb05 0c87 	add.w	ip, r5, r7, lsl #2
   196fc:	3514      	adds	r5, #20
   196fe:	45c1      	cmp	r9, r8
   19700:	f8cd 8004 	str.w	r8, [sp, #4]
   19704:	f10c 0c14 	add.w	ip, ip, #20
   19708:	9502      	str	r5, [sp, #8]
   1970a:	d24b      	bcs.n	197a4 <__multiply+0x10c>
   1970c:	f04f 0a00 	mov.w	sl, #0
   19710:	9405      	str	r4, [sp, #20]
   19712:	f859 400a 	ldr.w	r4, [r9, sl]
   19716:	eb0a 080b 	add.w	r8, sl, fp
   1971a:	b2a0      	uxth	r0, r4
   1971c:	b1d8      	cbz	r0, 19756 <__multiply+0xbe>
   1971e:	9a02      	ldr	r2, [sp, #8]
   19720:	4643      	mov	r3, r8
   19722:	2400      	movs	r4, #0
   19724:	f852 5b04 	ldr.w	r5, [r2], #4
   19728:	6819      	ldr	r1, [r3, #0]
   1972a:	b2af      	uxth	r7, r5
   1972c:	0c2d      	lsrs	r5, r5, #16
   1972e:	b28e      	uxth	r6, r1
   19730:	0c09      	lsrs	r1, r1, #16
   19732:	fb00 6607 	mla	r6, r0, r7, r6
   19736:	fb00 1105 	mla	r1, r0, r5, r1
   1973a:	1936      	adds	r6, r6, r4
   1973c:	eb01 4116 	add.w	r1, r1, r6, lsr #16
   19740:	b2b6      	uxth	r6, r6
   19742:	0c0c      	lsrs	r4, r1, #16
   19744:	4594      	cmp	ip, r2
   19746:	ea46 4601 	orr.w	r6, r6, r1, lsl #16
   1974a:	f843 6b04 	str.w	r6, [r3], #4
   1974e:	d8e9      	bhi.n	19724 <__multiply+0x8c>
   19750:	601c      	str	r4, [r3, #0]
   19752:	f859 400a 	ldr.w	r4, [r9, sl]
   19756:	0c24      	lsrs	r4, r4, #16
   19758:	d01c      	beq.n	19794 <__multiply+0xfc>
   1975a:	f85b 200a 	ldr.w	r2, [fp, sl]
   1975e:	4641      	mov	r1, r8
   19760:	9b02      	ldr	r3, [sp, #8]
   19762:	2500      	movs	r5, #0
   19764:	4610      	mov	r0, r2
   19766:	881e      	ldrh	r6, [r3, #0]
   19768:	b297      	uxth	r7, r2
   1976a:	fb06 5504 	mla	r5, r6, r4, r5
   1976e:	eb05 4510 	add.w	r5, r5, r0, lsr #16
   19772:	ea47 4705 	orr.w	r7, r7, r5, lsl #16
   19776:	600f      	str	r7, [r1, #0]
   19778:	f851 0f04 	ldr.w	r0, [r1, #4]!
   1977c:	f853 2b04 	ldr.w	r2, [r3], #4
   19780:	b286      	uxth	r6, r0
   19782:	0c12      	lsrs	r2, r2, #16
   19784:	fb02 6204 	mla	r2, r2, r4, r6
   19788:	eb02 4215 	add.w	r2, r2, r5, lsr #16
   1978c:	0c15      	lsrs	r5, r2, #16
   1978e:	459c      	cmp	ip, r3
   19790:	d8e9      	bhi.n	19766 <__multiply+0xce>
   19792:	600a      	str	r2, [r1, #0]
   19794:	f10a 0a04 	add.w	sl, sl, #4
   19798:	9a01      	ldr	r2, [sp, #4]
   1979a:	eb0a 0309 	add.w	r3, sl, r9
   1979e:	429a      	cmp	r2, r3
   197a0:	d8b7      	bhi.n	19712 <__multiply+0x7a>
   197a2:	9c05      	ldr	r4, [sp, #20]
   197a4:	2c00      	cmp	r4, #0
   197a6:	dd0b      	ble.n	197c0 <__multiply+0x128>
   197a8:	9a04      	ldr	r2, [sp, #16]
   197aa:	f852 3c04 	ldr.w	r3, [r2, #-4]
   197ae:	b93b      	cbnz	r3, 197c0 <__multiply+0x128>
   197b0:	4613      	mov	r3, r2
   197b2:	e003      	b.n	197bc <__multiply+0x124>
   197b4:	f853 2c08 	ldr.w	r2, [r3, #-8]
   197b8:	3b04      	subs	r3, #4
   197ba:	b90a      	cbnz	r2, 197c0 <__multiply+0x128>
   197bc:	3c01      	subs	r4, #1
   197be:	d1f9      	bne.n	197b4 <__multiply+0x11c>
   197c0:	9b03      	ldr	r3, [sp, #12]
   197c2:	4618      	mov	r0, r3
   197c4:	611c      	str	r4, [r3, #16]
   197c6:	b007      	add	sp, #28
   197c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000197cc <__i2b>:
   197cc:	b510      	push	{r4, lr}
   197ce:	460c      	mov	r4, r1
   197d0:	2101      	movs	r1, #1
   197d2:	f7ff fde9 	bl	193a8 <_Balloc>
   197d6:	2201      	movs	r2, #1
   197d8:	6144      	str	r4, [r0, #20]
   197da:	6102      	str	r2, [r0, #16]
   197dc:	bd10      	pop	{r4, pc}
   197de:	bf00      	nop

000197e0 <__multadd>:
   197e0:	e92d 45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
   197e4:	460d      	mov	r5, r1
   197e6:	2100      	movs	r1, #0
   197e8:	4606      	mov	r6, r0
   197ea:	692c      	ldr	r4, [r5, #16]
   197ec:	b083      	sub	sp, #12
   197ee:	f105 0814 	add.w	r8, r5, #20
   197f2:	4608      	mov	r0, r1
   197f4:	f858 7001 	ldr.w	r7, [r8, r1]
   197f8:	3001      	adds	r0, #1
   197fa:	fa1f fa87 	uxth.w	sl, r7
   197fe:	ea4f 4c17 	mov.w	ip, r7, lsr #16
   19802:	fb0a 3302 	mla	r3, sl, r2, r3
   19806:	fb0c fc02 	mul.w	ip, ip, r2
   1980a:	eb0c 4c13 	add.w	ip, ip, r3, lsr #16
   1980e:	b29b      	uxth	r3, r3
   19810:	eb03 430c 	add.w	r3, r3, ip, lsl #16
   19814:	f848 3001 	str.w	r3, [r8, r1]
   19818:	3104      	adds	r1, #4
   1981a:	4284      	cmp	r4, r0
   1981c:	ea4f 431c 	mov.w	r3, ip, lsr #16
   19820:	dce8      	bgt.n	197f4 <__multadd+0x14>
   19822:	b13b      	cbz	r3, 19834 <__multadd+0x54>
   19824:	68aa      	ldr	r2, [r5, #8]
   19826:	4294      	cmp	r4, r2
   19828:	da08      	bge.n	1983c <__multadd+0x5c>
   1982a:	eb05 0284 	add.w	r2, r5, r4, lsl #2
   1982e:	3401      	adds	r4, #1
   19830:	612c      	str	r4, [r5, #16]
   19832:	6153      	str	r3, [r2, #20]
   19834:	4628      	mov	r0, r5
   19836:	b003      	add	sp, #12
   19838:	e8bd 85f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, pc}
   1983c:	6869      	ldr	r1, [r5, #4]
   1983e:	4630      	mov	r0, r6
   19840:	9301      	str	r3, [sp, #4]
   19842:	3101      	adds	r1, #1
   19844:	f7ff fdb0 	bl	193a8 <_Balloc>
   19848:	692a      	ldr	r2, [r5, #16]
   1984a:	f105 010c 	add.w	r1, r5, #12
   1984e:	3202      	adds	r2, #2
   19850:	0092      	lsls	r2, r2, #2
   19852:	4607      	mov	r7, r0
   19854:	300c      	adds	r0, #12
   19856:	f7fb faa5 	bl	14da4 <memcpy>
   1985a:	4629      	mov	r1, r5
   1985c:	4630      	mov	r0, r6
   1985e:	463d      	mov	r5, r7
   19860:	f7ff fd86 	bl	19370 <_Bfree>
   19864:	9b01      	ldr	r3, [sp, #4]
   19866:	e7e0      	b.n	1982a <__multadd+0x4a>

00019868 <__pow5mult>:
   19868:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1986c:	4615      	mov	r5, r2
   1986e:	f012 0203 	ands.w	r2, r2, #3
   19872:	4604      	mov	r4, r0
   19874:	4688      	mov	r8, r1
   19876:	d12c      	bne.n	198d2 <__pow5mult+0x6a>
   19878:	10ad      	asrs	r5, r5, #2
   1987a:	d01e      	beq.n	198ba <__pow5mult+0x52>
   1987c:	6a66      	ldr	r6, [r4, #36]	; 0x24
   1987e:	2e00      	cmp	r6, #0
   19880:	d034      	beq.n	198ec <__pow5mult+0x84>
   19882:	68b7      	ldr	r7, [r6, #8]
   19884:	2f00      	cmp	r7, #0
   19886:	d03b      	beq.n	19900 <__pow5mult+0x98>
   19888:	f015 0f01 	tst.w	r5, #1
   1988c:	d108      	bne.n	198a0 <__pow5mult+0x38>
   1988e:	106d      	asrs	r5, r5, #1
   19890:	d013      	beq.n	198ba <__pow5mult+0x52>
   19892:	683e      	ldr	r6, [r7, #0]
   19894:	b1a6      	cbz	r6, 198c0 <__pow5mult+0x58>
   19896:	4630      	mov	r0, r6
   19898:	4607      	mov	r7, r0
   1989a:	f015 0f01 	tst.w	r5, #1
   1989e:	d0f6      	beq.n	1988e <__pow5mult+0x26>
   198a0:	4641      	mov	r1, r8
   198a2:	463a      	mov	r2, r7
   198a4:	4620      	mov	r0, r4
   198a6:	f7ff fef7 	bl	19698 <__multiply>
   198aa:	4641      	mov	r1, r8
   198ac:	4606      	mov	r6, r0
   198ae:	4620      	mov	r0, r4
   198b0:	f7ff fd5e 	bl	19370 <_Bfree>
   198b4:	106d      	asrs	r5, r5, #1
   198b6:	46b0      	mov	r8, r6
   198b8:	d1eb      	bne.n	19892 <__pow5mult+0x2a>
   198ba:	4640      	mov	r0, r8
   198bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   198c0:	4639      	mov	r1, r7
   198c2:	463a      	mov	r2, r7
   198c4:	4620      	mov	r0, r4
   198c6:	f7ff fee7 	bl	19698 <__multiply>
   198ca:	6038      	str	r0, [r7, #0]
   198cc:	4607      	mov	r7, r0
   198ce:	6006      	str	r6, [r0, #0]
   198d0:	e7e3      	b.n	1989a <__pow5mult+0x32>
   198d2:	f244 1c58 	movw	ip, #16728	; 0x4158
   198d6:	2300      	movs	r3, #0
   198d8:	f2c0 0c02 	movt	ip, #2
   198dc:	eb0c 0282 	add.w	r2, ip, r2, lsl #2
   198e0:	f8d2 20c4 	ldr.w	r2, [r2, #196]	; 0xc4
   198e4:	f7ff ff7c 	bl	197e0 <__multadd>
   198e8:	4680      	mov	r8, r0
   198ea:	e7c5      	b.n	19878 <__pow5mult+0x10>
   198ec:	2010      	movs	r0, #16
   198ee:	f7ff f80d 	bl	1890c <malloc>
   198f2:	2300      	movs	r3, #0
   198f4:	4606      	mov	r6, r0
   198f6:	6260      	str	r0, [r4, #36]	; 0x24
   198f8:	60c3      	str	r3, [r0, #12]
   198fa:	6043      	str	r3, [r0, #4]
   198fc:	6083      	str	r3, [r0, #8]
   198fe:	6003      	str	r3, [r0, #0]
   19900:	4620      	mov	r0, r4
   19902:	f240 2171 	movw	r1, #625	; 0x271
   19906:	f7ff ff61 	bl	197cc <__i2b>
   1990a:	2300      	movs	r3, #0
   1990c:	60b0      	str	r0, [r6, #8]
   1990e:	4607      	mov	r7, r0
   19910:	6003      	str	r3, [r0, #0]
   19912:	e7b9      	b.n	19888 <__pow5mult+0x20>

00019914 <__s2b>:
   19914:	e92d 45f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, sl, lr}
   19918:	461e      	mov	r6, r3
   1991a:	f648 6339 	movw	r3, #36409	; 0x8e39
   1991e:	f106 0c08 	add.w	ip, r6, #8
   19922:	f6c3 03e3 	movt	r3, #14563	; 0x38e3
   19926:	4688      	mov	r8, r1
   19928:	4605      	mov	r5, r0
   1992a:	4617      	mov	r7, r2
   1992c:	fb83 130c 	smull	r1, r3, r3, ip
   19930:	ea4f 7cec 	mov.w	ip, ip, asr #31
   19934:	ebcc 0c63 	rsb	ip, ip, r3, asr #1
   19938:	f1bc 0f01 	cmp.w	ip, #1
   1993c:	dd35      	ble.n	199aa <__s2b+0x96>
   1993e:	2100      	movs	r1, #0
   19940:	2201      	movs	r2, #1
   19942:	0052      	lsls	r2, r2, #1
   19944:	3101      	adds	r1, #1
   19946:	4594      	cmp	ip, r2
   19948:	dcfb      	bgt.n	19942 <__s2b+0x2e>
   1994a:	4628      	mov	r0, r5
   1994c:	f7ff fd2c 	bl	193a8 <_Balloc>
   19950:	9b08      	ldr	r3, [sp, #32]
   19952:	6143      	str	r3, [r0, #20]
   19954:	2301      	movs	r3, #1
   19956:	2f09      	cmp	r7, #9
   19958:	6103      	str	r3, [r0, #16]
   1995a:	dd22      	ble.n	199a2 <__s2b+0x8e>
   1995c:	f108 0a09 	add.w	sl, r8, #9
   19960:	2409      	movs	r4, #9
   19962:	f818 3004 	ldrb.w	r3, [r8, r4]
   19966:	4601      	mov	r1, r0
   19968:	220a      	movs	r2, #10
   1996a:	3401      	adds	r4, #1
   1996c:	3b30      	subs	r3, #48	; 0x30
   1996e:	4628      	mov	r0, r5
   19970:	f7ff ff36 	bl	197e0 <__multadd>
   19974:	42a7      	cmp	r7, r4
   19976:	dcf4      	bgt.n	19962 <__s2b+0x4e>
   19978:	eb0a 0807 	add.w	r8, sl, r7
   1997c:	f1a8 0808 	sub.w	r8, r8, #8
   19980:	42be      	cmp	r6, r7
   19982:	dd0c      	ble.n	1999e <__s2b+0x8a>
   19984:	2400      	movs	r4, #0
   19986:	f818 3004 	ldrb.w	r3, [r8, r4]
   1998a:	4601      	mov	r1, r0
   1998c:	3401      	adds	r4, #1
   1998e:	220a      	movs	r2, #10
   19990:	3b30      	subs	r3, #48	; 0x30
   19992:	4628      	mov	r0, r5
   19994:	f7ff ff24 	bl	197e0 <__multadd>
   19998:	19e3      	adds	r3, r4, r7
   1999a:	429e      	cmp	r6, r3
   1999c:	dcf3      	bgt.n	19986 <__s2b+0x72>
   1999e:	e8bd 85f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, sl, pc}
   199a2:	f108 080a 	add.w	r8, r8, #10
   199a6:	2709      	movs	r7, #9
   199a8:	e7ea      	b.n	19980 <__s2b+0x6c>
   199aa:	2100      	movs	r1, #0
   199ac:	e7cd      	b.n	1994a <__s2b+0x36>
   199ae:	bf00      	nop

000199b0 <_realloc_r>:
   199b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   199b4:	4691      	mov	r9, r2
   199b6:	b083      	sub	sp, #12
   199b8:	4607      	mov	r7, r0
   199ba:	460e      	mov	r6, r1
   199bc:	2900      	cmp	r1, #0
   199be:	f000 813a 	beq.w	19c36 <_realloc_r+0x286>
   199c2:	f1a1 0808 	sub.w	r8, r1, #8
   199c6:	f109 040b 	add.w	r4, r9, #11
   199ca:	f7ff fb41 	bl	19050 <__malloc_lock>
   199ce:	2c16      	cmp	r4, #22
   199d0:	f8d8 1004 	ldr.w	r1, [r8, #4]
   199d4:	460b      	mov	r3, r1
   199d6:	f200 80a0 	bhi.w	19b1a <_realloc_r+0x16a>
   199da:	2210      	movs	r2, #16
   199dc:	2500      	movs	r5, #0
   199de:	4614      	mov	r4, r2
   199e0:	454c      	cmp	r4, r9
   199e2:	bf38      	it	cc
   199e4:	f045 0501 	orrcc.w	r5, r5, #1
   199e8:	2d00      	cmp	r5, #0
   199ea:	f040 812a 	bne.w	19c42 <_realloc_r+0x292>
   199ee:	f021 0a03 	bic.w	sl, r1, #3
   199f2:	4592      	cmp	sl, r2
   199f4:	bfa2      	ittt	ge
   199f6:	4640      	movge	r0, r8
   199f8:	4655      	movge	r5, sl
   199fa:	f108 0808 	addge.w	r8, r8, #8
   199fe:	da75      	bge.n	19aec <_realloc_r+0x13c>
   19a00:	f240 13dc 	movw	r3, #476	; 0x1dc
   19a04:	eb08 000a 	add.w	r0, r8, sl
   19a08:	f2c2 0300 	movt	r3, #8192	; 0x2000
   19a0c:	f8d3 e008 	ldr.w	lr, [r3, #8]
   19a10:	4586      	cmp	lr, r0
   19a12:	f000 811a 	beq.w	19c4a <_realloc_r+0x29a>
   19a16:	f8d0 c004 	ldr.w	ip, [r0, #4]
   19a1a:	f02c 0b01 	bic.w	fp, ip, #1
   19a1e:	4483      	add	fp, r0
   19a20:	f8db b004 	ldr.w	fp, [fp, #4]
   19a24:	f01b 0f01 	tst.w	fp, #1
   19a28:	d07c      	beq.n	19b24 <_realloc_r+0x174>
   19a2a:	46ac      	mov	ip, r5
   19a2c:	4628      	mov	r0, r5
   19a2e:	f011 0f01 	tst.w	r1, #1
   19a32:	f040 809b 	bne.w	19b6c <_realloc_r+0x1bc>
   19a36:	f856 1c08 	ldr.w	r1, [r6, #-8]
   19a3a:	ebc1 0b08 	rsb	fp, r1, r8
   19a3e:	f8db 5004 	ldr.w	r5, [fp, #4]
   19a42:	f025 0503 	bic.w	r5, r5, #3
   19a46:	2800      	cmp	r0, #0
   19a48:	f000 80dd 	beq.w	19c06 <_realloc_r+0x256>
   19a4c:	4570      	cmp	r0, lr
   19a4e:	f000 811f 	beq.w	19c90 <_realloc_r+0x2e0>
   19a52:	eb05 030a 	add.w	r3, r5, sl
   19a56:	eb0c 0503 	add.w	r5, ip, r3
   19a5a:	4295      	cmp	r5, r2
   19a5c:	bfb8      	it	lt
   19a5e:	461d      	movlt	r5, r3
   19a60:	f2c0 80d2 	blt.w	19c08 <_realloc_r+0x258>
   19a64:	6881      	ldr	r1, [r0, #8]
   19a66:	465b      	mov	r3, fp
   19a68:	68c0      	ldr	r0, [r0, #12]
   19a6a:	f1aa 0204 	sub.w	r2, sl, #4
   19a6e:	2a24      	cmp	r2, #36	; 0x24
   19a70:	6081      	str	r1, [r0, #8]
   19a72:	60c8      	str	r0, [r1, #12]
   19a74:	f853 1f08 	ldr.w	r1, [r3, #8]!
   19a78:	f8db 000c 	ldr.w	r0, [fp, #12]
   19a7c:	6081      	str	r1, [r0, #8]
   19a7e:	60c8      	str	r0, [r1, #12]
   19a80:	f200 80d0 	bhi.w	19c24 <_realloc_r+0x274>
   19a84:	2a13      	cmp	r2, #19
   19a86:	469c      	mov	ip, r3
   19a88:	d921      	bls.n	19ace <_realloc_r+0x11e>
   19a8a:	4631      	mov	r1, r6
   19a8c:	f10b 0c10 	add.w	ip, fp, #16
   19a90:	f851 0b04 	ldr.w	r0, [r1], #4
   19a94:	f8cb 0008 	str.w	r0, [fp, #8]
   19a98:	6870      	ldr	r0, [r6, #4]
   19a9a:	1d0e      	adds	r6, r1, #4
   19a9c:	2a1b      	cmp	r2, #27
   19a9e:	f8cb 000c 	str.w	r0, [fp, #12]
   19aa2:	d914      	bls.n	19ace <_realloc_r+0x11e>
   19aa4:	6848      	ldr	r0, [r1, #4]
   19aa6:	1d31      	adds	r1, r6, #4
   19aa8:	f10b 0c18 	add.w	ip, fp, #24
   19aac:	f8cb 0010 	str.w	r0, [fp, #16]
   19ab0:	6870      	ldr	r0, [r6, #4]
   19ab2:	1d0e      	adds	r6, r1, #4
   19ab4:	2a24      	cmp	r2, #36	; 0x24
   19ab6:	f8cb 0014 	str.w	r0, [fp, #20]
   19aba:	d108      	bne.n	19ace <_realloc_r+0x11e>
   19abc:	684a      	ldr	r2, [r1, #4]
   19abe:	f10b 0c20 	add.w	ip, fp, #32
   19ac2:	f8cb 2018 	str.w	r2, [fp, #24]
   19ac6:	6872      	ldr	r2, [r6, #4]
   19ac8:	3608      	adds	r6, #8
   19aca:	f8cb 201c 	str.w	r2, [fp, #28]
   19ace:	4631      	mov	r1, r6
   19ad0:	4698      	mov	r8, r3
   19ad2:	4662      	mov	r2, ip
   19ad4:	4658      	mov	r0, fp
   19ad6:	f851 3b04 	ldr.w	r3, [r1], #4
   19ada:	f842 3b04 	str.w	r3, [r2], #4
   19ade:	6873      	ldr	r3, [r6, #4]
   19ae0:	f8cc 3004 	str.w	r3, [ip, #4]
   19ae4:	684b      	ldr	r3, [r1, #4]
   19ae6:	6053      	str	r3, [r2, #4]
   19ae8:	f8db 3004 	ldr.w	r3, [fp, #4]
   19aec:	ebc4 0c05 	rsb	ip, r4, r5
   19af0:	f1bc 0f0f 	cmp.w	ip, #15
   19af4:	d826      	bhi.n	19b44 <_realloc_r+0x194>
   19af6:	1942      	adds	r2, r0, r5
   19af8:	f003 0301 	and.w	r3, r3, #1
   19afc:	ea43 0505 	orr.w	r5, r3, r5
   19b00:	6045      	str	r5, [r0, #4]
   19b02:	6853      	ldr	r3, [r2, #4]
   19b04:	f043 0301 	orr.w	r3, r3, #1
   19b08:	6053      	str	r3, [r2, #4]
   19b0a:	4638      	mov	r0, r7
   19b0c:	4645      	mov	r5, r8
   19b0e:	f7ff faa1 	bl	19054 <__malloc_unlock>
   19b12:	4628      	mov	r0, r5
   19b14:	b003      	add	sp, #12
   19b16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   19b1a:	f024 0407 	bic.w	r4, r4, #7
   19b1e:	4622      	mov	r2, r4
   19b20:	0fe5      	lsrs	r5, r4, #31
   19b22:	e75d      	b.n	199e0 <_realloc_r+0x30>
   19b24:	f02c 0c03 	bic.w	ip, ip, #3
   19b28:	eb0c 050a 	add.w	r5, ip, sl
   19b2c:	4295      	cmp	r5, r2
   19b2e:	f6ff af7e 	blt.w	19a2e <_realloc_r+0x7e>
   19b32:	6882      	ldr	r2, [r0, #8]
   19b34:	460b      	mov	r3, r1
   19b36:	68c1      	ldr	r1, [r0, #12]
   19b38:	4640      	mov	r0, r8
   19b3a:	f108 0808 	add.w	r8, r8, #8
   19b3e:	608a      	str	r2, [r1, #8]
   19b40:	60d1      	str	r1, [r2, #12]
   19b42:	e7d3      	b.n	19aec <_realloc_r+0x13c>
   19b44:	1901      	adds	r1, r0, r4
   19b46:	f003 0301 	and.w	r3, r3, #1
   19b4a:	eb01 020c 	add.w	r2, r1, ip
   19b4e:	ea43 0404 	orr.w	r4, r3, r4
   19b52:	f04c 0301 	orr.w	r3, ip, #1
   19b56:	6044      	str	r4, [r0, #4]
   19b58:	604b      	str	r3, [r1, #4]
   19b5a:	4638      	mov	r0, r7
   19b5c:	6853      	ldr	r3, [r2, #4]
   19b5e:	3108      	adds	r1, #8
   19b60:	f043 0301 	orr.w	r3, r3, #1
   19b64:	6053      	str	r3, [r2, #4]
   19b66:	f7fe fdaf 	bl	186c8 <_free_r>
   19b6a:	e7ce      	b.n	19b0a <_realloc_r+0x15a>
   19b6c:	4649      	mov	r1, r9
   19b6e:	4638      	mov	r0, r7
   19b70:	f7fe fed4 	bl	1891c <_malloc_r>
   19b74:	4605      	mov	r5, r0
   19b76:	2800      	cmp	r0, #0
   19b78:	d041      	beq.n	19bfe <_realloc_r+0x24e>
   19b7a:	f8d8 3004 	ldr.w	r3, [r8, #4]
   19b7e:	f1a0 0208 	sub.w	r2, r0, #8
   19b82:	f023 0101 	bic.w	r1, r3, #1
   19b86:	4441      	add	r1, r8
   19b88:	428a      	cmp	r2, r1
   19b8a:	f000 80d7 	beq.w	19d3c <_realloc_r+0x38c>
   19b8e:	f1aa 0204 	sub.w	r2, sl, #4
   19b92:	4631      	mov	r1, r6
   19b94:	2a24      	cmp	r2, #36	; 0x24
   19b96:	d878      	bhi.n	19c8a <_realloc_r+0x2da>
   19b98:	2a13      	cmp	r2, #19
   19b9a:	4603      	mov	r3, r0
   19b9c:	d921      	bls.n	19be2 <_realloc_r+0x232>
   19b9e:	4634      	mov	r4, r6
   19ba0:	f854 3b04 	ldr.w	r3, [r4], #4
   19ba4:	1d21      	adds	r1, r4, #4
   19ba6:	f840 3b04 	str.w	r3, [r0], #4
   19baa:	1d03      	adds	r3, r0, #4
   19bac:	f8d6 c004 	ldr.w	ip, [r6, #4]
   19bb0:	2a1b      	cmp	r2, #27
   19bb2:	f8c5 c004 	str.w	ip, [r5, #4]
   19bb6:	d914      	bls.n	19be2 <_realloc_r+0x232>
   19bb8:	f8d4 e004 	ldr.w	lr, [r4, #4]
   19bbc:	1d1c      	adds	r4, r3, #4
   19bbe:	f101 0c04 	add.w	ip, r1, #4
   19bc2:	f8c0 e004 	str.w	lr, [r0, #4]
   19bc6:	6848      	ldr	r0, [r1, #4]
   19bc8:	f10c 0104 	add.w	r1, ip, #4
   19bcc:	6058      	str	r0, [r3, #4]
   19bce:	1d23      	adds	r3, r4, #4
   19bd0:	2a24      	cmp	r2, #36	; 0x24
   19bd2:	d106      	bne.n	19be2 <_realloc_r+0x232>
   19bd4:	f8dc 2004 	ldr.w	r2, [ip, #4]
   19bd8:	6062      	str	r2, [r4, #4]
   19bda:	684a      	ldr	r2, [r1, #4]
   19bdc:	3108      	adds	r1, #8
   19bde:	605a      	str	r2, [r3, #4]
   19be0:	3308      	adds	r3, #8
   19be2:	4608      	mov	r0, r1
   19be4:	461a      	mov	r2, r3
   19be6:	f850 4b04 	ldr.w	r4, [r0], #4
   19bea:	f842 4b04 	str.w	r4, [r2], #4
   19bee:	6849      	ldr	r1, [r1, #4]
   19bf0:	6059      	str	r1, [r3, #4]
   19bf2:	6843      	ldr	r3, [r0, #4]
   19bf4:	6053      	str	r3, [r2, #4]
   19bf6:	4631      	mov	r1, r6
   19bf8:	4638      	mov	r0, r7
   19bfa:	f7fe fd65 	bl	186c8 <_free_r>
   19bfe:	4638      	mov	r0, r7
   19c00:	f7ff fa28 	bl	19054 <__malloc_unlock>
   19c04:	e785      	b.n	19b12 <_realloc_r+0x162>
   19c06:	4455      	add	r5, sl
   19c08:	4295      	cmp	r5, r2
   19c0a:	dbaf      	blt.n	19b6c <_realloc_r+0x1bc>
   19c0c:	465b      	mov	r3, fp
   19c0e:	f8db 000c 	ldr.w	r0, [fp, #12]
   19c12:	f1aa 0204 	sub.w	r2, sl, #4
   19c16:	f853 1f08 	ldr.w	r1, [r3, #8]!
   19c1a:	2a24      	cmp	r2, #36	; 0x24
   19c1c:	6081      	str	r1, [r0, #8]
   19c1e:	60c8      	str	r0, [r1, #12]
   19c20:	f67f af30 	bls.w	19a84 <_realloc_r+0xd4>
   19c24:	4618      	mov	r0, r3
   19c26:	4631      	mov	r1, r6
   19c28:	4698      	mov	r8, r3
   19c2a:	f7ff f9b5 	bl	18f98 <memmove>
   19c2e:	4658      	mov	r0, fp
   19c30:	f8db 3004 	ldr.w	r3, [fp, #4]
   19c34:	e75a      	b.n	19aec <_realloc_r+0x13c>
   19c36:	4611      	mov	r1, r2
   19c38:	b003      	add	sp, #12
   19c3a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   19c3e:	f7fe be6d 	b.w	1891c <_malloc_r>
   19c42:	230c      	movs	r3, #12
   19c44:	2500      	movs	r5, #0
   19c46:	603b      	str	r3, [r7, #0]
   19c48:	e763      	b.n	19b12 <_realloc_r+0x162>
   19c4a:	f8de 5004 	ldr.w	r5, [lr, #4]
   19c4e:	f104 0b10 	add.w	fp, r4, #16
   19c52:	f025 0c03 	bic.w	ip, r5, #3
   19c56:	eb0c 000a 	add.w	r0, ip, sl
   19c5a:	4558      	cmp	r0, fp
   19c5c:	bfb8      	it	lt
   19c5e:	4670      	movlt	r0, lr
   19c60:	f6ff aee5 	blt.w	19a2e <_realloc_r+0x7e>
   19c64:	eb08 0204 	add.w	r2, r8, r4
   19c68:	1b01      	subs	r1, r0, r4
   19c6a:	f041 0101 	orr.w	r1, r1, #1
   19c6e:	609a      	str	r2, [r3, #8]
   19c70:	6051      	str	r1, [r2, #4]
   19c72:	4638      	mov	r0, r7
   19c74:	f8d8 1004 	ldr.w	r1, [r8, #4]
   19c78:	4635      	mov	r5, r6
   19c7a:	f001 0301 	and.w	r3, r1, #1
   19c7e:	431c      	orrs	r4, r3
   19c80:	f8c8 4004 	str.w	r4, [r8, #4]
   19c84:	f7ff f9e6 	bl	19054 <__malloc_unlock>
   19c88:	e743      	b.n	19b12 <_realloc_r+0x162>
   19c8a:	f7ff f985 	bl	18f98 <memmove>
   19c8e:	e7b2      	b.n	19bf6 <_realloc_r+0x246>
   19c90:	4455      	add	r5, sl
   19c92:	f104 0110 	add.w	r1, r4, #16
   19c96:	44ac      	add	ip, r5
   19c98:	458c      	cmp	ip, r1
   19c9a:	dbb5      	blt.n	19c08 <_realloc_r+0x258>
   19c9c:	465d      	mov	r5, fp
   19c9e:	f8db 000c 	ldr.w	r0, [fp, #12]
   19ca2:	f1aa 0204 	sub.w	r2, sl, #4
   19ca6:	f855 1f08 	ldr.w	r1, [r5, #8]!
   19caa:	2a24      	cmp	r2, #36	; 0x24
   19cac:	6081      	str	r1, [r0, #8]
   19cae:	60c8      	str	r0, [r1, #12]
   19cb0:	d84c      	bhi.n	19d4c <_realloc_r+0x39c>
   19cb2:	2a13      	cmp	r2, #19
   19cb4:	4628      	mov	r0, r5
   19cb6:	d924      	bls.n	19d02 <_realloc_r+0x352>
   19cb8:	4631      	mov	r1, r6
   19cba:	f10b 0010 	add.w	r0, fp, #16
   19cbe:	f851 eb04 	ldr.w	lr, [r1], #4
   19cc2:	f8cb e008 	str.w	lr, [fp, #8]
   19cc6:	f8d6 e004 	ldr.w	lr, [r6, #4]
   19cca:	1d0e      	adds	r6, r1, #4
   19ccc:	2a1b      	cmp	r2, #27
   19cce:	f8cb e00c 	str.w	lr, [fp, #12]
   19cd2:	d916      	bls.n	19d02 <_realloc_r+0x352>
   19cd4:	f8d1 e004 	ldr.w	lr, [r1, #4]
   19cd8:	1d31      	adds	r1, r6, #4
   19cda:	f10b 0018 	add.w	r0, fp, #24
   19cde:	f8cb e010 	str.w	lr, [fp, #16]
   19ce2:	f8d6 e004 	ldr.w	lr, [r6, #4]
   19ce6:	1d0e      	adds	r6, r1, #4
   19ce8:	2a24      	cmp	r2, #36	; 0x24
   19cea:	f8cb e014 	str.w	lr, [fp, #20]
   19cee:	d108      	bne.n	19d02 <_realloc_r+0x352>
   19cf0:	684a      	ldr	r2, [r1, #4]
   19cf2:	f10b 0020 	add.w	r0, fp, #32
   19cf6:	f8cb 2018 	str.w	r2, [fp, #24]
   19cfa:	6872      	ldr	r2, [r6, #4]
   19cfc:	3608      	adds	r6, #8
   19cfe:	f8cb 201c 	str.w	r2, [fp, #28]
   19d02:	4631      	mov	r1, r6
   19d04:	4602      	mov	r2, r0
   19d06:	f851 eb04 	ldr.w	lr, [r1], #4
   19d0a:	f842 eb04 	str.w	lr, [r2], #4
   19d0e:	6876      	ldr	r6, [r6, #4]
   19d10:	6046      	str	r6, [r0, #4]
   19d12:	6849      	ldr	r1, [r1, #4]
   19d14:	6051      	str	r1, [r2, #4]
   19d16:	eb0b 0204 	add.w	r2, fp, r4
   19d1a:	ebc4 010c 	rsb	r1, r4, ip
   19d1e:	f041 0101 	orr.w	r1, r1, #1
   19d22:	609a      	str	r2, [r3, #8]
   19d24:	6051      	str	r1, [r2, #4]
   19d26:	4638      	mov	r0, r7
   19d28:	f8db 1004 	ldr.w	r1, [fp, #4]
   19d2c:	f001 0301 	and.w	r3, r1, #1
   19d30:	431c      	orrs	r4, r3
   19d32:	f8cb 4004 	str.w	r4, [fp, #4]
   19d36:	f7ff f98d 	bl	19054 <__malloc_unlock>
   19d3a:	e6ea      	b.n	19b12 <_realloc_r+0x162>
   19d3c:	6855      	ldr	r5, [r2, #4]
   19d3e:	4640      	mov	r0, r8
   19d40:	f108 0808 	add.w	r8, r8, #8
   19d44:	f025 0503 	bic.w	r5, r5, #3
   19d48:	4455      	add	r5, sl
   19d4a:	e6cf      	b.n	19aec <_realloc_r+0x13c>
   19d4c:	4631      	mov	r1, r6
   19d4e:	4628      	mov	r0, r5
   19d50:	9300      	str	r3, [sp, #0]
   19d52:	f8cd c004 	str.w	ip, [sp, #4]
   19d56:	f7ff f91f 	bl	18f98 <memmove>
   19d5a:	f8dd c004 	ldr.w	ip, [sp, #4]
   19d5e:	9b00      	ldr	r3, [sp, #0]
   19d60:	e7d9      	b.n	19d16 <_realloc_r+0x366>
   19d62:	bf00      	nop

00019d64 <__isinfd>:
   19d64:	4602      	mov	r2, r0
   19d66:	4240      	negs	r0, r0
   19d68:	ea40 0302 	orr.w	r3, r0, r2
   19d6c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   19d70:	ea41 73d3 	orr.w	r3, r1, r3, lsr #31
   19d74:	f1c3 43fe 	rsb	r3, r3, #2130706432	; 0x7f000000
   19d78:	f503 0370 	add.w	r3, r3, #15728640	; 0xf00000
   19d7c:	4258      	negs	r0, r3
   19d7e:	ea40 0303 	orr.w	r3, r0, r3
   19d82:	17d8      	asrs	r0, r3, #31
   19d84:	3001      	adds	r0, #1
   19d86:	4770      	bx	lr

00019d88 <__isnand>:
   19d88:	4602      	mov	r2, r0
   19d8a:	4240      	negs	r0, r0
   19d8c:	4310      	orrs	r0, r2
   19d8e:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   19d92:	ea41 70d0 	orr.w	r0, r1, r0, lsr #31
   19d96:	f1c0 40fe 	rsb	r0, r0, #2130706432	; 0x7f000000
   19d9a:	f500 0070 	add.w	r0, r0, #15728640	; 0xf00000
   19d9e:	0fc0      	lsrs	r0, r0, #31
   19da0:	4770      	bx	lr
   19da2:	bf00      	nop

00019da4 <_sbrk_r>:
   19da4:	b538      	push	{r3, r4, r5, lr}
   19da6:	f64c 44b8 	movw	r4, #52408	; 0xccb8
   19daa:	f2c2 0400 	movt	r4, #8192	; 0x2000
   19dae:	4605      	mov	r5, r0
   19db0:	4608      	mov	r0, r1
   19db2:	2300      	movs	r3, #0
   19db4:	6023      	str	r3, [r4, #0]
   19db6:	f7f0 fbff 	bl	a5b8 <_sbrk>
   19dba:	f1b0 3fff 	cmp.w	r0, #4294967295
   19dbe:	d000      	beq.n	19dc2 <_sbrk_r+0x1e>
   19dc0:	bd38      	pop	{r3, r4, r5, pc}
   19dc2:	6823      	ldr	r3, [r4, #0]
   19dc4:	2b00      	cmp	r3, #0
   19dc6:	d0fb      	beq.n	19dc0 <_sbrk_r+0x1c>
   19dc8:	602b      	str	r3, [r5, #0]
   19dca:	bd38      	pop	{r3, r4, r5, pc}

00019dcc <strcmp>:
   19dcc:	ea80 0201 	eor.w	r2, r0, r1
   19dd0:	f012 0f03 	tst.w	r2, #3
   19dd4:	d13a      	bne.n	19e4c <strcmp_unaligned>
   19dd6:	f010 0203 	ands.w	r2, r0, #3
   19dda:	f020 0003 	bic.w	r0, r0, #3
   19dde:	f021 0103 	bic.w	r1, r1, #3
   19de2:	f850 cb04 	ldr.w	ip, [r0], #4
   19de6:	bf08      	it	eq
   19de8:	f851 3b04 	ldreq.w	r3, [r1], #4
   19dec:	d00d      	beq.n	19e0a <strcmp+0x3e>
   19dee:	f082 0203 	eor.w	r2, r2, #3
   19df2:	ea4f 02c2 	mov.w	r2, r2, lsl #3
   19df6:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
   19dfa:	fa23 f202 	lsr.w	r2, r3, r2
   19dfe:	f851 3b04 	ldr.w	r3, [r1], #4
   19e02:	ea4c 0c02 	orr.w	ip, ip, r2
   19e06:	ea43 0302 	orr.w	r3, r3, r2
   19e0a:	bf00      	nop
   19e0c:	f1ac 3201 	sub.w	r2, ip, #16843009	; 0x1010101
   19e10:	459c      	cmp	ip, r3
   19e12:	bf01      	itttt	eq
   19e14:	ea22 020c 	biceq.w	r2, r2, ip
   19e18:	f012 3f80 	tsteq.w	r2, #2155905152	; 0x80808080
   19e1c:	f850 cb04 	ldreq.w	ip, [r0], #4
   19e20:	f851 3b04 	ldreq.w	r3, [r1], #4
   19e24:	d0f2      	beq.n	19e0c <strcmp+0x40>
   19e26:	ea4f 600c 	mov.w	r0, ip, lsl #24
   19e2a:	ea4f 2c1c 	mov.w	ip, ip, lsr #8
   19e2e:	2801      	cmp	r0, #1
   19e30:	bf28      	it	cs
   19e32:	ebb0 6f03 	cmpcs.w	r0, r3, lsl #24
   19e36:	bf08      	it	eq
   19e38:	0a1b      	lsreq	r3, r3, #8
   19e3a:	d0f4      	beq.n	19e26 <strcmp+0x5a>
   19e3c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
   19e40:	ea4f 6010 	mov.w	r0, r0, lsr #24
   19e44:	eba0 0003 	sub.w	r0, r0, r3
   19e48:	4770      	bx	lr
   19e4a:	bf00      	nop

00019e4c <strcmp_unaligned>:
   19e4c:	f010 0f03 	tst.w	r0, #3
   19e50:	d00a      	beq.n	19e68 <strcmp_unaligned+0x1c>
   19e52:	f810 2b01 	ldrb.w	r2, [r0], #1
   19e56:	f811 3b01 	ldrb.w	r3, [r1], #1
   19e5a:	2a01      	cmp	r2, #1
   19e5c:	bf28      	it	cs
   19e5e:	429a      	cmpcs	r2, r3
   19e60:	d0f4      	beq.n	19e4c <strcmp_unaligned>
   19e62:	eba2 0003 	sub.w	r0, r2, r3
   19e66:	4770      	bx	lr
   19e68:	f84d 5d04 	str.w	r5, [sp, #-4]!
   19e6c:	f84d 4d04 	str.w	r4, [sp, #-4]!
   19e70:	f04f 0201 	mov.w	r2, #1
   19e74:	ea42 2202 	orr.w	r2, r2, r2, lsl #8
   19e78:	ea42 4202 	orr.w	r2, r2, r2, lsl #16
   19e7c:	f001 0c03 	and.w	ip, r1, #3
   19e80:	f021 0103 	bic.w	r1, r1, #3
   19e84:	f850 4b04 	ldr.w	r4, [r0], #4
   19e88:	f851 5b04 	ldr.w	r5, [r1], #4
   19e8c:	f1bc 0f02 	cmp.w	ip, #2
   19e90:	d026      	beq.n	19ee0 <strcmp_unaligned+0x94>
   19e92:	d84b      	bhi.n	19f2c <strcmp_unaligned+0xe0>
   19e94:	f024 4c7f 	bic.w	ip, r4, #4278190080	; 0xff000000
   19e98:	ebbc 2f15 	cmp.w	ip, r5, lsr #8
   19e9c:	eba4 0302 	sub.w	r3, r4, r2
   19ea0:	ea23 0304 	bic.w	r3, r3, r4
   19ea4:	d10d      	bne.n	19ec2 <strcmp_unaligned+0x76>
   19ea6:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
   19eaa:	bf08      	it	eq
   19eac:	f851 5b04 	ldreq.w	r5, [r1], #4
   19eb0:	d10a      	bne.n	19ec8 <strcmp_unaligned+0x7c>
   19eb2:	ea8c 0c04 	eor.w	ip, ip, r4
   19eb6:	ebbc 6f05 	cmp.w	ip, r5, lsl #24
   19eba:	d10c      	bne.n	19ed6 <strcmp_unaligned+0x8a>
   19ebc:	f850 4b04 	ldr.w	r4, [r0], #4
   19ec0:	e7e8      	b.n	19e94 <strcmp_unaligned+0x48>
   19ec2:	ea4f 2515 	mov.w	r5, r5, lsr #8
   19ec6:	e05c      	b.n	19f82 <strcmp_unaligned+0x136>
   19ec8:	f033 437f 	bics.w	r3, r3, #4278190080	; 0xff000000
   19ecc:	d152      	bne.n	19f74 <strcmp_unaligned+0x128>
   19ece:	780d      	ldrb	r5, [r1, #0]
   19ed0:	ea4f 6c14 	mov.w	ip, r4, lsr #24
   19ed4:	e055      	b.n	19f82 <strcmp_unaligned+0x136>
   19ed6:	ea4f 6c14 	mov.w	ip, r4, lsr #24
   19eda:	f005 05ff 	and.w	r5, r5, #255	; 0xff
   19ede:	e050      	b.n	19f82 <strcmp_unaligned+0x136>
   19ee0:	ea4f 4c04 	mov.w	ip, r4, lsl #16
   19ee4:	eba4 0302 	sub.w	r3, r4, r2
   19ee8:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
   19eec:	ea23 0304 	bic.w	r3, r3, r4
   19ef0:	ebbc 4f15 	cmp.w	ip, r5, lsr #16
   19ef4:	d117      	bne.n	19f26 <strcmp_unaligned+0xda>
   19ef6:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
   19efa:	bf08      	it	eq
   19efc:	f851 5b04 	ldreq.w	r5, [r1], #4
   19f00:	d107      	bne.n	19f12 <strcmp_unaligned+0xc6>
   19f02:	ea8c 0c04 	eor.w	ip, ip, r4
   19f06:	ebbc 4f05 	cmp.w	ip, r5, lsl #16
   19f0a:	d108      	bne.n	19f1e <strcmp_unaligned+0xd2>
   19f0c:	f850 4b04 	ldr.w	r4, [r0], #4
   19f10:	e7e6      	b.n	19ee0 <strcmp_unaligned+0x94>
   19f12:	041b      	lsls	r3, r3, #16
   19f14:	d12e      	bne.n	19f74 <strcmp_unaligned+0x128>
   19f16:	880d      	ldrh	r5, [r1, #0]
   19f18:	ea4f 4c14 	mov.w	ip, r4, lsr #16
   19f1c:	e031      	b.n	19f82 <strcmp_unaligned+0x136>
   19f1e:	ea4f 4505 	mov.w	r5, r5, lsl #16
   19f22:	ea4f 4c14 	mov.w	ip, r4, lsr #16
   19f26:	ea4f 4515 	mov.w	r5, r5, lsr #16
   19f2a:	e02a      	b.n	19f82 <strcmp_unaligned+0x136>
   19f2c:	f004 0cff 	and.w	ip, r4, #255	; 0xff
   19f30:	ebbc 6f15 	cmp.w	ip, r5, lsr #24
   19f34:	eba4 0302 	sub.w	r3, r4, r2
   19f38:	ea23 0304 	bic.w	r3, r3, r4
   19f3c:	d10d      	bne.n	19f5a <strcmp_unaligned+0x10e>
   19f3e:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
   19f42:	bf08      	it	eq
   19f44:	f851 5b04 	ldreq.w	r5, [r1], #4
   19f48:	d10a      	bne.n	19f60 <strcmp_unaligned+0x114>
   19f4a:	ea8c 0c04 	eor.w	ip, ip, r4
   19f4e:	ebbc 2f05 	cmp.w	ip, r5, lsl #8
   19f52:	d10a      	bne.n	19f6a <strcmp_unaligned+0x11e>
   19f54:	f850 4b04 	ldr.w	r4, [r0], #4
   19f58:	e7e8      	b.n	19f2c <strcmp_unaligned+0xe0>
   19f5a:	ea4f 6515 	mov.w	r5, r5, lsr #24
   19f5e:	e010      	b.n	19f82 <strcmp_unaligned+0x136>
   19f60:	f014 0fff 	tst.w	r4, #255	; 0xff
   19f64:	d006      	beq.n	19f74 <strcmp_unaligned+0x128>
   19f66:	f851 5b04 	ldr.w	r5, [r1], #4
   19f6a:	ea4f 2c14 	mov.w	ip, r4, lsr #8
   19f6e:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
   19f72:	e006      	b.n	19f82 <strcmp_unaligned+0x136>
   19f74:	f04f 0000 	mov.w	r0, #0
   19f78:	f85d 4b04 	ldr.w	r4, [sp], #4
   19f7c:	f85d 5b04 	ldr.w	r5, [sp], #4
   19f80:	4770      	bx	lr
   19f82:	f00c 02ff 	and.w	r2, ip, #255	; 0xff
   19f86:	f005 00ff 	and.w	r0, r5, #255	; 0xff
   19f8a:	2801      	cmp	r0, #1
   19f8c:	bf28      	it	cs
   19f8e:	4290      	cmpcs	r0, r2
   19f90:	bf04      	itt	eq
   19f92:	ea4f 2c1c 	moveq.w	ip, ip, lsr #8
   19f96:	0a2d      	lsreq	r5, r5, #8
   19f98:	d0f3      	beq.n	19f82 <strcmp_unaligned+0x136>
   19f9a:	eba2 0000 	sub.w	r0, r2, r0
   19f9e:	f85d 4b04 	ldr.w	r4, [sp], #4
   19fa2:	f85d 5b04 	ldr.w	r5, [sp], #4
   19fa6:	4770      	bx	lr

00019fa8 <_calloc_r>:
   19fa8:	b538      	push	{r3, r4, r5, lr}
   19faa:	fb01 f102 	mul.w	r1, r1, r2
   19fae:	f7fe fcb5 	bl	1891c <_malloc_r>
   19fb2:	4604      	mov	r4, r0
   19fb4:	b1f8      	cbz	r0, 19ff6 <_calloc_r+0x4e>
   19fb6:	f850 2c04 	ldr.w	r2, [r0, #-4]
   19fba:	f022 0203 	bic.w	r2, r2, #3
   19fbe:	3a04      	subs	r2, #4
   19fc0:	2a24      	cmp	r2, #36	; 0x24
   19fc2:	d81a      	bhi.n	19ffa <_calloc_r+0x52>
   19fc4:	2a13      	cmp	r2, #19
   19fc6:	4603      	mov	r3, r0
   19fc8:	d90f      	bls.n	19fea <_calloc_r+0x42>
   19fca:	2100      	movs	r1, #0
   19fcc:	f840 1b04 	str.w	r1, [r0], #4
   19fd0:	1d03      	adds	r3, r0, #4
   19fd2:	2a1b      	cmp	r2, #27
   19fd4:	6061      	str	r1, [r4, #4]
   19fd6:	d908      	bls.n	19fea <_calloc_r+0x42>
   19fd8:	1d1d      	adds	r5, r3, #4
   19fda:	6041      	str	r1, [r0, #4]
   19fdc:	6059      	str	r1, [r3, #4]
   19fde:	1d2b      	adds	r3, r5, #4
   19fe0:	2a24      	cmp	r2, #36	; 0x24
   19fe2:	bf02      	ittt	eq
   19fe4:	6069      	streq	r1, [r5, #4]
   19fe6:	6059      	streq	r1, [r3, #4]
   19fe8:	3308      	addeq	r3, #8
   19fea:	461a      	mov	r2, r3
   19fec:	2100      	movs	r1, #0
   19fee:	f842 1b04 	str.w	r1, [r2], #4
   19ff2:	6059      	str	r1, [r3, #4]
   19ff4:	6051      	str	r1, [r2, #4]
   19ff6:	4620      	mov	r0, r4
   19ff8:	bd38      	pop	{r3, r4, r5, pc}
   19ffa:	2100      	movs	r1, #0
   19ffc:	f7fa ff9a 	bl	14f34 <memset>
   1a000:	4620      	mov	r0, r4
   1a002:	bd38      	pop	{r3, r4, r5, pc}

0001a004 <_wrapup_reent>:
   1a004:	b570      	push	{r4, r5, r6, lr}
   1a006:	4604      	mov	r4, r0
   1a008:	b188      	cbz	r0, 1a02e <_wrapup_reent+0x2a>
   1a00a:	f104 0248 	add.w	r2, r4, #72	; 0x48
   1a00e:	6853      	ldr	r3, [r2, #4]
   1a010:	1e5d      	subs	r5, r3, #1
   1a012:	d407      	bmi.n	1a024 <_wrapup_reent+0x20>
   1a014:	3302      	adds	r3, #2
   1a016:	eb02 0683 	add.w	r6, r2, r3, lsl #2
   1a01a:	f856 3d04 	ldr.w	r3, [r6, #-4]!
   1a01e:	4798      	blx	r3
   1a020:	3d01      	subs	r5, #1
   1a022:	d5fa      	bpl.n	1a01a <_wrapup_reent+0x16>
   1a024:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1a026:	b10b      	cbz	r3, 1a02c <_wrapup_reent+0x28>
   1a028:	4620      	mov	r0, r4
   1a02a:	4798      	blx	r3
   1a02c:	bd70      	pop	{r4, r5, r6, pc}
   1a02e:	f240 03d8 	movw	r3, #216	; 0xd8
   1a032:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1a036:	681c      	ldr	r4, [r3, #0]
   1a038:	e7e7      	b.n	1a00a <_wrapup_reent+0x6>
   1a03a:	bf00      	nop

0001a03c <cleanup_glue>:
   1a03c:	b570      	push	{r4, r5, r6, lr}
   1a03e:	460c      	mov	r4, r1
   1a040:	6809      	ldr	r1, [r1, #0]
   1a042:	4605      	mov	r5, r0
   1a044:	b109      	cbz	r1, 1a04a <cleanup_glue+0xe>
   1a046:	f7ff fff9 	bl	1a03c <cleanup_glue>
   1a04a:	4628      	mov	r0, r5
   1a04c:	4621      	mov	r1, r4
   1a04e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   1a052:	f7fe bb39 	b.w	186c8 <_free_r>
   1a056:	bf00      	nop

0001a058 <_reclaim_reent>:
   1a058:	f240 03d8 	movw	r3, #216	; 0xd8
   1a05c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1a060:	b570      	push	{r4, r5, r6, lr}
   1a062:	681b      	ldr	r3, [r3, #0]
   1a064:	4605      	mov	r5, r0
   1a066:	4298      	cmp	r0, r3
   1a068:	d046      	beq.n	1a0f8 <_reclaim_reent+0xa0>
   1a06a:	6a43      	ldr	r3, [r0, #36]	; 0x24
   1a06c:	4619      	mov	r1, r3
   1a06e:	b1bb      	cbz	r3, 1a0a0 <_reclaim_reent+0x48>
   1a070:	68da      	ldr	r2, [r3, #12]
   1a072:	b1aa      	cbz	r2, 1a0a0 <_reclaim_reent+0x48>
   1a074:	2600      	movs	r6, #0
   1a076:	5991      	ldr	r1, [r2, r6]
   1a078:	b141      	cbz	r1, 1a08c <_reclaim_reent+0x34>
   1a07a:	680c      	ldr	r4, [r1, #0]
   1a07c:	4628      	mov	r0, r5
   1a07e:	f7fe fb23 	bl	186c8 <_free_r>
   1a082:	4621      	mov	r1, r4
   1a084:	2c00      	cmp	r4, #0
   1a086:	d1f8      	bne.n	1a07a <_reclaim_reent+0x22>
   1a088:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   1a08a:	68da      	ldr	r2, [r3, #12]
   1a08c:	3604      	adds	r6, #4
   1a08e:	2e3c      	cmp	r6, #60	; 0x3c
   1a090:	d001      	beq.n	1a096 <_reclaim_reent+0x3e>
   1a092:	68da      	ldr	r2, [r3, #12]
   1a094:	e7ef      	b.n	1a076 <_reclaim_reent+0x1e>
   1a096:	4611      	mov	r1, r2
   1a098:	4628      	mov	r0, r5
   1a09a:	f7fe fb15 	bl	186c8 <_free_r>
   1a09e:	6a69      	ldr	r1, [r5, #36]	; 0x24
   1a0a0:	6809      	ldr	r1, [r1, #0]
   1a0a2:	b111      	cbz	r1, 1a0aa <_reclaim_reent+0x52>
   1a0a4:	4628      	mov	r0, r5
   1a0a6:	f7fe fb0f 	bl	186c8 <_free_r>
   1a0aa:	6969      	ldr	r1, [r5, #20]
   1a0ac:	b111      	cbz	r1, 1a0b4 <_reclaim_reent+0x5c>
   1a0ae:	4628      	mov	r0, r5
   1a0b0:	f7fe fb0a 	bl	186c8 <_free_r>
   1a0b4:	6a69      	ldr	r1, [r5, #36]	; 0x24
   1a0b6:	b111      	cbz	r1, 1a0be <_reclaim_reent+0x66>
   1a0b8:	4628      	mov	r0, r5
   1a0ba:	f7fe fb05 	bl	186c8 <_free_r>
   1a0be:	6ba9      	ldr	r1, [r5, #56]	; 0x38
   1a0c0:	b111      	cbz	r1, 1a0c8 <_reclaim_reent+0x70>
   1a0c2:	4628      	mov	r0, r5
   1a0c4:	f7fe fb00 	bl	186c8 <_free_r>
   1a0c8:	6be9      	ldr	r1, [r5, #60]	; 0x3c
   1a0ca:	b111      	cbz	r1, 1a0d2 <_reclaim_reent+0x7a>
   1a0cc:	4628      	mov	r0, r5
   1a0ce:	f7fe fafb 	bl	186c8 <_free_r>
   1a0d2:	6c29      	ldr	r1, [r5, #64]	; 0x40
   1a0d4:	b111      	cbz	r1, 1a0dc <_reclaim_reent+0x84>
   1a0d6:	4628      	mov	r0, r5
   1a0d8:	f7fe faf6 	bl	186c8 <_free_r>
   1a0dc:	6cab      	ldr	r3, [r5, #72]	; 0x48
   1a0de:	f8d3 1088 	ldr.w	r1, [r3, #136]	; 0x88
   1a0e2:	b111      	cbz	r1, 1a0ea <_reclaim_reent+0x92>
   1a0e4:	4628      	mov	r0, r5
   1a0e6:	f7fe faef 	bl	186c8 <_free_r>
   1a0ea:	6b69      	ldr	r1, [r5, #52]	; 0x34
   1a0ec:	b111      	cbz	r1, 1a0f4 <_reclaim_reent+0x9c>
   1a0ee:	4628      	mov	r0, r5
   1a0f0:	f7fe faea 	bl	186c8 <_free_r>
   1a0f4:	69ab      	ldr	r3, [r5, #24]
   1a0f6:	b903      	cbnz	r3, 1a0fa <_reclaim_reent+0xa2>
   1a0f8:	bd70      	pop	{r4, r5, r6, pc}
   1a0fa:	6aab      	ldr	r3, [r5, #40]	; 0x28
   1a0fc:	4628      	mov	r0, r5
   1a0fe:	4798      	blx	r3
   1a100:	f8d5 10d8 	ldr.w	r1, [r5, #216]	; 0xd8
   1a104:	2900      	cmp	r1, #0
   1a106:	d0f7      	beq.n	1a0f8 <_reclaim_reent+0xa0>
   1a108:	4628      	mov	r0, r5
   1a10a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   1a10e:	e795      	b.n	1a03c <cleanup_glue>

0001a110 <__aeabi_uidiv>:
   1a110:	1e4a      	subs	r2, r1, #1
   1a112:	bf08      	it	eq
   1a114:	4770      	bxeq	lr
   1a116:	f0c0 8124 	bcc.w	1a362 <__aeabi_uidiv+0x252>
   1a11a:	4288      	cmp	r0, r1
   1a11c:	f240 8116 	bls.w	1a34c <__aeabi_uidiv+0x23c>
   1a120:	4211      	tst	r1, r2
   1a122:	f000 8117 	beq.w	1a354 <__aeabi_uidiv+0x244>
   1a126:	fab0 f380 	clz	r3, r0
   1a12a:	fab1 f281 	clz	r2, r1
   1a12e:	eba2 0303 	sub.w	r3, r2, r3
   1a132:	f1c3 031f 	rsb	r3, r3, #31
   1a136:	a204      	add	r2, pc, #16	; (adr r2, 1a148 <__aeabi_uidiv+0x38>)
   1a138:	eb02 1303 	add.w	r3, r2, r3, lsl #4
   1a13c:	f04f 0200 	mov.w	r2, #0
   1a140:	469f      	mov	pc, r3
   1a142:	bf00      	nop
   1a144:	f3af 8000 	nop.w
   1a148:	ebb0 7fc1 	cmp.w	r0, r1, lsl #31
   1a14c:	bf00      	nop
   1a14e:	eb42 0202 	adc.w	r2, r2, r2
   1a152:	bf28      	it	cs
   1a154:	eba0 70c1 	subcs.w	r0, r0, r1, lsl #31
   1a158:	ebb0 7f81 	cmp.w	r0, r1, lsl #30
   1a15c:	bf00      	nop
   1a15e:	eb42 0202 	adc.w	r2, r2, r2
   1a162:	bf28      	it	cs
   1a164:	eba0 7081 	subcs.w	r0, r0, r1, lsl #30
   1a168:	ebb0 7f41 	cmp.w	r0, r1, lsl #29
   1a16c:	bf00      	nop
   1a16e:	eb42 0202 	adc.w	r2, r2, r2
   1a172:	bf28      	it	cs
   1a174:	eba0 7041 	subcs.w	r0, r0, r1, lsl #29
   1a178:	ebb0 7f01 	cmp.w	r0, r1, lsl #28
   1a17c:	bf00      	nop
   1a17e:	eb42 0202 	adc.w	r2, r2, r2
   1a182:	bf28      	it	cs
   1a184:	eba0 7001 	subcs.w	r0, r0, r1, lsl #28
   1a188:	ebb0 6fc1 	cmp.w	r0, r1, lsl #27
   1a18c:	bf00      	nop
   1a18e:	eb42 0202 	adc.w	r2, r2, r2
   1a192:	bf28      	it	cs
   1a194:	eba0 60c1 	subcs.w	r0, r0, r1, lsl #27
   1a198:	ebb0 6f81 	cmp.w	r0, r1, lsl #26
   1a19c:	bf00      	nop
   1a19e:	eb42 0202 	adc.w	r2, r2, r2
   1a1a2:	bf28      	it	cs
   1a1a4:	eba0 6081 	subcs.w	r0, r0, r1, lsl #26
   1a1a8:	ebb0 6f41 	cmp.w	r0, r1, lsl #25
   1a1ac:	bf00      	nop
   1a1ae:	eb42 0202 	adc.w	r2, r2, r2
   1a1b2:	bf28      	it	cs
   1a1b4:	eba0 6041 	subcs.w	r0, r0, r1, lsl #25
   1a1b8:	ebb0 6f01 	cmp.w	r0, r1, lsl #24
   1a1bc:	bf00      	nop
   1a1be:	eb42 0202 	adc.w	r2, r2, r2
   1a1c2:	bf28      	it	cs
   1a1c4:	eba0 6001 	subcs.w	r0, r0, r1, lsl #24
   1a1c8:	ebb0 5fc1 	cmp.w	r0, r1, lsl #23
   1a1cc:	bf00      	nop
   1a1ce:	eb42 0202 	adc.w	r2, r2, r2
   1a1d2:	bf28      	it	cs
   1a1d4:	eba0 50c1 	subcs.w	r0, r0, r1, lsl #23
   1a1d8:	ebb0 5f81 	cmp.w	r0, r1, lsl #22
   1a1dc:	bf00      	nop
   1a1de:	eb42 0202 	adc.w	r2, r2, r2
   1a1e2:	bf28      	it	cs
   1a1e4:	eba0 5081 	subcs.w	r0, r0, r1, lsl #22
   1a1e8:	ebb0 5f41 	cmp.w	r0, r1, lsl #21
   1a1ec:	bf00      	nop
   1a1ee:	eb42 0202 	adc.w	r2, r2, r2
   1a1f2:	bf28      	it	cs
   1a1f4:	eba0 5041 	subcs.w	r0, r0, r1, lsl #21
   1a1f8:	ebb0 5f01 	cmp.w	r0, r1, lsl #20
   1a1fc:	bf00      	nop
   1a1fe:	eb42 0202 	adc.w	r2, r2, r2
   1a202:	bf28      	it	cs
   1a204:	eba0 5001 	subcs.w	r0, r0, r1, lsl #20
   1a208:	ebb0 4fc1 	cmp.w	r0, r1, lsl #19
   1a20c:	bf00      	nop
   1a20e:	eb42 0202 	adc.w	r2, r2, r2
   1a212:	bf28      	it	cs
   1a214:	eba0 40c1 	subcs.w	r0, r0, r1, lsl #19
   1a218:	ebb0 4f81 	cmp.w	r0, r1, lsl #18
   1a21c:	bf00      	nop
   1a21e:	eb42 0202 	adc.w	r2, r2, r2
   1a222:	bf28      	it	cs
   1a224:	eba0 4081 	subcs.w	r0, r0, r1, lsl #18
   1a228:	ebb0 4f41 	cmp.w	r0, r1, lsl #17
   1a22c:	bf00      	nop
   1a22e:	eb42 0202 	adc.w	r2, r2, r2
   1a232:	bf28      	it	cs
   1a234:	eba0 4041 	subcs.w	r0, r0, r1, lsl #17
   1a238:	ebb0 4f01 	cmp.w	r0, r1, lsl #16
   1a23c:	bf00      	nop
   1a23e:	eb42 0202 	adc.w	r2, r2, r2
   1a242:	bf28      	it	cs
   1a244:	eba0 4001 	subcs.w	r0, r0, r1, lsl #16
   1a248:	ebb0 3fc1 	cmp.w	r0, r1, lsl #15
   1a24c:	bf00      	nop
   1a24e:	eb42 0202 	adc.w	r2, r2, r2
   1a252:	bf28      	it	cs
   1a254:	eba0 30c1 	subcs.w	r0, r0, r1, lsl #15
   1a258:	ebb0 3f81 	cmp.w	r0, r1, lsl #14
   1a25c:	bf00      	nop
   1a25e:	eb42 0202 	adc.w	r2, r2, r2
   1a262:	bf28      	it	cs
   1a264:	eba0 3081 	subcs.w	r0, r0, r1, lsl #14
   1a268:	ebb0 3f41 	cmp.w	r0, r1, lsl #13
   1a26c:	bf00      	nop
   1a26e:	eb42 0202 	adc.w	r2, r2, r2
   1a272:	bf28      	it	cs
   1a274:	eba0 3041 	subcs.w	r0, r0, r1, lsl #13
   1a278:	ebb0 3f01 	cmp.w	r0, r1, lsl #12
   1a27c:	bf00      	nop
   1a27e:	eb42 0202 	adc.w	r2, r2, r2
   1a282:	bf28      	it	cs
   1a284:	eba0 3001 	subcs.w	r0, r0, r1, lsl #12
   1a288:	ebb0 2fc1 	cmp.w	r0, r1, lsl #11
   1a28c:	bf00      	nop
   1a28e:	eb42 0202 	adc.w	r2, r2, r2
   1a292:	bf28      	it	cs
   1a294:	eba0 20c1 	subcs.w	r0, r0, r1, lsl #11
   1a298:	ebb0 2f81 	cmp.w	r0, r1, lsl #10
   1a29c:	bf00      	nop
   1a29e:	eb42 0202 	adc.w	r2, r2, r2
   1a2a2:	bf28      	it	cs
   1a2a4:	eba0 2081 	subcs.w	r0, r0, r1, lsl #10
   1a2a8:	ebb0 2f41 	cmp.w	r0, r1, lsl #9
   1a2ac:	bf00      	nop
   1a2ae:	eb42 0202 	adc.w	r2, r2, r2
   1a2b2:	bf28      	it	cs
   1a2b4:	eba0 2041 	subcs.w	r0, r0, r1, lsl #9
   1a2b8:	ebb0 2f01 	cmp.w	r0, r1, lsl #8
   1a2bc:	bf00      	nop
   1a2be:	eb42 0202 	adc.w	r2, r2, r2
   1a2c2:	bf28      	it	cs
   1a2c4:	eba0 2001 	subcs.w	r0, r0, r1, lsl #8
   1a2c8:	ebb0 1fc1 	cmp.w	r0, r1, lsl #7
   1a2cc:	bf00      	nop
   1a2ce:	eb42 0202 	adc.w	r2, r2, r2
   1a2d2:	bf28      	it	cs
   1a2d4:	eba0 10c1 	subcs.w	r0, r0, r1, lsl #7
   1a2d8:	ebb0 1f81 	cmp.w	r0, r1, lsl #6
   1a2dc:	bf00      	nop
   1a2de:	eb42 0202 	adc.w	r2, r2, r2
   1a2e2:	bf28      	it	cs
   1a2e4:	eba0 1081 	subcs.w	r0, r0, r1, lsl #6
   1a2e8:	ebb0 1f41 	cmp.w	r0, r1, lsl #5
   1a2ec:	bf00      	nop
   1a2ee:	eb42 0202 	adc.w	r2, r2, r2
   1a2f2:	bf28      	it	cs
   1a2f4:	eba0 1041 	subcs.w	r0, r0, r1, lsl #5
   1a2f8:	ebb0 1f01 	cmp.w	r0, r1, lsl #4
   1a2fc:	bf00      	nop
   1a2fe:	eb42 0202 	adc.w	r2, r2, r2
   1a302:	bf28      	it	cs
   1a304:	eba0 1001 	subcs.w	r0, r0, r1, lsl #4
   1a308:	ebb0 0fc1 	cmp.w	r0, r1, lsl #3
   1a30c:	bf00      	nop
   1a30e:	eb42 0202 	adc.w	r2, r2, r2
   1a312:	bf28      	it	cs
   1a314:	eba0 00c1 	subcs.w	r0, r0, r1, lsl #3
   1a318:	ebb0 0f81 	cmp.w	r0, r1, lsl #2
   1a31c:	bf00      	nop
   1a31e:	eb42 0202 	adc.w	r2, r2, r2
   1a322:	bf28      	it	cs
   1a324:	eba0 0081 	subcs.w	r0, r0, r1, lsl #2
   1a328:	ebb0 0f41 	cmp.w	r0, r1, lsl #1
   1a32c:	bf00      	nop
   1a32e:	eb42 0202 	adc.w	r2, r2, r2
   1a332:	bf28      	it	cs
   1a334:	eba0 0041 	subcs.w	r0, r0, r1, lsl #1
   1a338:	ebb0 0f01 	cmp.w	r0, r1
   1a33c:	bf00      	nop
   1a33e:	eb42 0202 	adc.w	r2, r2, r2
   1a342:	bf28      	it	cs
   1a344:	eba0 0001 	subcs.w	r0, r0, r1
   1a348:	4610      	mov	r0, r2
   1a34a:	4770      	bx	lr
   1a34c:	bf0c      	ite	eq
   1a34e:	2001      	moveq	r0, #1
   1a350:	2000      	movne	r0, #0
   1a352:	4770      	bx	lr
   1a354:	fab1 f281 	clz	r2, r1
   1a358:	f1c2 021f 	rsb	r2, r2, #31
   1a35c:	fa20 f002 	lsr.w	r0, r0, r2
   1a360:	4770      	bx	lr
   1a362:	b108      	cbz	r0, 1a368 <__aeabi_uidiv+0x258>
   1a364:	f04f 30ff 	mov.w	r0, #4294967295
   1a368:	f000 b80e 	b.w	1a388 <__aeabi_idiv0>

0001a36c <__aeabi_uidivmod>:
   1a36c:	2900      	cmp	r1, #0
   1a36e:	d0f8      	beq.n	1a362 <__aeabi_uidiv+0x252>
   1a370:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
   1a374:	f7ff fecc 	bl	1a110 <__aeabi_uidiv>
   1a378:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
   1a37c:	fb02 f300 	mul.w	r3, r2, r0
   1a380:	eba1 0103 	sub.w	r1, r1, r3
   1a384:	4770      	bx	lr
   1a386:	bf00      	nop

0001a388 <__aeabi_idiv0>:
   1a388:	4770      	bx	lr
   1a38a:	bf00      	nop

0001a38c <__gedf2>:
   1a38c:	f04f 3cff 	mov.w	ip, #4294967295
   1a390:	e006      	b.n	1a3a0 <__cmpdf2+0x4>
   1a392:	bf00      	nop

0001a394 <__ledf2>:
   1a394:	f04f 0c01 	mov.w	ip, #1
   1a398:	e002      	b.n	1a3a0 <__cmpdf2+0x4>
   1a39a:	bf00      	nop

0001a39c <__cmpdf2>:
   1a39c:	f04f 0c01 	mov.w	ip, #1
   1a3a0:	f84d cd04 	str.w	ip, [sp, #-4]!
   1a3a4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   1a3a8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   1a3ac:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   1a3b0:	bf18      	it	ne
   1a3b2:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
   1a3b6:	d01b      	beq.n	1a3f0 <__cmpdf2+0x54>
   1a3b8:	b001      	add	sp, #4
   1a3ba:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
   1a3be:	bf0c      	ite	eq
   1a3c0:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
   1a3c4:	ea91 0f03 	teqne	r1, r3
   1a3c8:	bf02      	ittt	eq
   1a3ca:	ea90 0f02 	teqeq	r0, r2
   1a3ce:	2000      	moveq	r0, #0
   1a3d0:	4770      	bxeq	lr
   1a3d2:	f110 0f00 	cmn.w	r0, #0
   1a3d6:	ea91 0f03 	teq	r1, r3
   1a3da:	bf58      	it	pl
   1a3dc:	4299      	cmppl	r1, r3
   1a3de:	bf08      	it	eq
   1a3e0:	4290      	cmpeq	r0, r2
   1a3e2:	bf2c      	ite	cs
   1a3e4:	17d8      	asrcs	r0, r3, #31
   1a3e6:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
   1a3ea:	f040 0001 	orr.w	r0, r0, #1
   1a3ee:	4770      	bx	lr
   1a3f0:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   1a3f4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   1a3f8:	d102      	bne.n	1a400 <__cmpdf2+0x64>
   1a3fa:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
   1a3fe:	d107      	bne.n	1a410 <__cmpdf2+0x74>
   1a400:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   1a404:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   1a408:	d1d6      	bne.n	1a3b8 <__cmpdf2+0x1c>
   1a40a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
   1a40e:	d0d3      	beq.n	1a3b8 <__cmpdf2+0x1c>
   1a410:	f85d 0b04 	ldr.w	r0, [sp], #4
   1a414:	4770      	bx	lr
   1a416:	bf00      	nop

0001a418 <__aeabi_cdrcmple>:
   1a418:	4684      	mov	ip, r0
   1a41a:	4610      	mov	r0, r2
   1a41c:	4662      	mov	r2, ip
   1a41e:	468c      	mov	ip, r1
   1a420:	4619      	mov	r1, r3
   1a422:	4663      	mov	r3, ip
   1a424:	e000      	b.n	1a428 <__aeabi_cdcmpeq>
   1a426:	bf00      	nop

0001a428 <__aeabi_cdcmpeq>:
   1a428:	b501      	push	{r0, lr}
   1a42a:	f7ff ffb7 	bl	1a39c <__cmpdf2>
   1a42e:	2800      	cmp	r0, #0
   1a430:	bf48      	it	mi
   1a432:	f110 0f00 	cmnmi.w	r0, #0
   1a436:	bd01      	pop	{r0, pc}

0001a438 <__aeabi_dcmpeq>:
   1a438:	f84d ed08 	str.w	lr, [sp, #-8]!
   1a43c:	f7ff fff4 	bl	1a428 <__aeabi_cdcmpeq>
   1a440:	bf0c      	ite	eq
   1a442:	2001      	moveq	r0, #1
   1a444:	2000      	movne	r0, #0
   1a446:	f85d fb08 	ldr.w	pc, [sp], #8
   1a44a:	bf00      	nop

0001a44c <__aeabi_dcmplt>:
   1a44c:	f84d ed08 	str.w	lr, [sp, #-8]!
   1a450:	f7ff ffea 	bl	1a428 <__aeabi_cdcmpeq>
   1a454:	bf34      	ite	cc
   1a456:	2001      	movcc	r0, #1
   1a458:	2000      	movcs	r0, #0
   1a45a:	f85d fb08 	ldr.w	pc, [sp], #8
   1a45e:	bf00      	nop

0001a460 <__aeabi_dcmple>:
   1a460:	f84d ed08 	str.w	lr, [sp, #-8]!
   1a464:	f7ff ffe0 	bl	1a428 <__aeabi_cdcmpeq>
   1a468:	bf94      	ite	ls
   1a46a:	2001      	movls	r0, #1
   1a46c:	2000      	movhi	r0, #0
   1a46e:	f85d fb08 	ldr.w	pc, [sp], #8
   1a472:	bf00      	nop

0001a474 <__aeabi_dcmpge>:
   1a474:	f84d ed08 	str.w	lr, [sp, #-8]!
   1a478:	f7ff ffce 	bl	1a418 <__aeabi_cdrcmple>
   1a47c:	bf94      	ite	ls
   1a47e:	2001      	movls	r0, #1
   1a480:	2000      	movhi	r0, #0
   1a482:	f85d fb08 	ldr.w	pc, [sp], #8
   1a486:	bf00      	nop

0001a488 <__aeabi_dcmpgt>:
   1a488:	f84d ed08 	str.w	lr, [sp, #-8]!
   1a48c:	f7ff ffc4 	bl	1a418 <__aeabi_cdrcmple>
   1a490:	bf34      	ite	cc
   1a492:	2001      	movcc	r0, #1
   1a494:	2000      	movcs	r0, #0
   1a496:	f85d fb08 	ldr.w	pc, [sp], #8
   1a49a:	bf00      	nop

0001a49c <__aeabi_d2iz>:
   1a49c:	ea4f 0241 	mov.w	r2, r1, lsl #1
   1a4a0:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   1a4a4:	d215      	bcs.n	1a4d2 <__aeabi_d2iz+0x36>
   1a4a6:	d511      	bpl.n	1a4cc <__aeabi_d2iz+0x30>
   1a4a8:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   1a4ac:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   1a4b0:	d912      	bls.n	1a4d8 <__aeabi_d2iz+0x3c>
   1a4b2:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   1a4b6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   1a4ba:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   1a4be:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   1a4c2:	fa23 f002 	lsr.w	r0, r3, r2
   1a4c6:	bf18      	it	ne
   1a4c8:	4240      	negne	r0, r0
   1a4ca:	4770      	bx	lr
   1a4cc:	f04f 0000 	mov.w	r0, #0
   1a4d0:	4770      	bx	lr
   1a4d2:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   1a4d6:	d105      	bne.n	1a4e4 <__aeabi_d2iz+0x48>
   1a4d8:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
   1a4dc:	bf08      	it	eq
   1a4de:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
   1a4e2:	4770      	bx	lr
   1a4e4:	f04f 0000 	mov.w	r0, #0
   1a4e8:	4770      	bx	lr
   1a4ea:	bf00      	nop

0001a4ec <__aeabi_uldivmod>:
   1a4ec:	b94b      	cbnz	r3, 1a502 <__aeabi_uldivmod+0x16>
   1a4ee:	b942      	cbnz	r2, 1a502 <__aeabi_uldivmod+0x16>
   1a4f0:	2900      	cmp	r1, #0
   1a4f2:	bf08      	it	eq
   1a4f4:	2800      	cmpeq	r0, #0
   1a4f6:	d002      	beq.n	1a4fe <__aeabi_uldivmod+0x12>
   1a4f8:	f04f 31ff 	mov.w	r1, #4294967295
   1a4fc:	4608      	mov	r0, r1
   1a4fe:	f7ff bf43 	b.w	1a388 <__aeabi_idiv0>
   1a502:	b082      	sub	sp, #8
   1a504:	46ec      	mov	ip, sp
   1a506:	e92d 5000 	stmdb	sp!, {ip, lr}
   1a50a:	f000 f805 	bl	1a518 <__gnu_uldivmod_helper>
   1a50e:	f8dd e004 	ldr.w	lr, [sp, #4]
   1a512:	b002      	add	sp, #8
   1a514:	bc0c      	pop	{r2, r3}
   1a516:	4770      	bx	lr

0001a518 <__gnu_uldivmod_helper>:
   1a518:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1a51a:	4614      	mov	r4, r2
   1a51c:	461d      	mov	r5, r3
   1a51e:	4606      	mov	r6, r0
   1a520:	460f      	mov	r7, r1
   1a522:	f000 f9d7 	bl	1a8d4 <__udivdi3>
   1a526:	fb00 f505 	mul.w	r5, r0, r5
   1a52a:	fba0 2304 	umull	r2, r3, r0, r4
   1a52e:	fb04 5401 	mla	r4, r4, r1, r5
   1a532:	18e3      	adds	r3, r4, r3
   1a534:	1ab6      	subs	r6, r6, r2
   1a536:	eb67 0703 	sbc.w	r7, r7, r3
   1a53a:	9b06      	ldr	r3, [sp, #24]
   1a53c:	e9c3 6700 	strd	r6, r7, [r3]
   1a540:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1a542:	bf00      	nop

0001a544 <__gnu_ldivmod_helper>:
   1a544:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1a546:	4614      	mov	r4, r2
   1a548:	461d      	mov	r5, r3
   1a54a:	4606      	mov	r6, r0
   1a54c:	460f      	mov	r7, r1
   1a54e:	f000 f80f 	bl	1a570 <__divdi3>
   1a552:	fb00 f505 	mul.w	r5, r0, r5
   1a556:	fba0 2304 	umull	r2, r3, r0, r4
   1a55a:	fb04 5401 	mla	r4, r4, r1, r5
   1a55e:	18e3      	adds	r3, r4, r3
   1a560:	1ab6      	subs	r6, r6, r2
   1a562:	eb67 0703 	sbc.w	r7, r7, r3
   1a566:	9b06      	ldr	r3, [sp, #24]
   1a568:	e9c3 6700 	strd	r6, r7, [r3]
   1a56c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1a56e:	bf00      	nop

0001a570 <__divdi3>:
   1a570:	2900      	cmp	r1, #0
   1a572:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1a576:	b085      	sub	sp, #20
   1a578:	f2c0 80c8 	blt.w	1a70c <__divdi3+0x19c>
   1a57c:	2600      	movs	r6, #0
   1a57e:	2b00      	cmp	r3, #0
   1a580:	f2c0 80bf 	blt.w	1a702 <__divdi3+0x192>
   1a584:	4689      	mov	r9, r1
   1a586:	4614      	mov	r4, r2
   1a588:	4605      	mov	r5, r0
   1a58a:	469b      	mov	fp, r3
   1a58c:	2b00      	cmp	r3, #0
   1a58e:	d14a      	bne.n	1a626 <__divdi3+0xb6>
   1a590:	428a      	cmp	r2, r1
   1a592:	d957      	bls.n	1a644 <__divdi3+0xd4>
   1a594:	fab2 f382 	clz	r3, r2
   1a598:	b153      	cbz	r3, 1a5b0 <__divdi3+0x40>
   1a59a:	f1c3 0020 	rsb	r0, r3, #32
   1a59e:	fa01 f903 	lsl.w	r9, r1, r3
   1a5a2:	fa25 f800 	lsr.w	r8, r5, r0
   1a5a6:	fa12 f403 	lsls.w	r4, r2, r3
   1a5aa:	409d      	lsls	r5, r3
   1a5ac:	ea48 0909 	orr.w	r9, r8, r9
   1a5b0:	0c27      	lsrs	r7, r4, #16
   1a5b2:	4648      	mov	r0, r9
   1a5b4:	4639      	mov	r1, r7
   1a5b6:	fa1f fb84 	uxth.w	fp, r4
   1a5ba:	f7ff fda9 	bl	1a110 <__aeabi_uidiv>
   1a5be:	4639      	mov	r1, r7
   1a5c0:	4682      	mov	sl, r0
   1a5c2:	4648      	mov	r0, r9
   1a5c4:	f7ff fed2 	bl	1a36c <__aeabi_uidivmod>
   1a5c8:	0c2a      	lsrs	r2, r5, #16
   1a5ca:	fb0b f30a 	mul.w	r3, fp, sl
   1a5ce:	ea42 4901 	orr.w	r9, r2, r1, lsl #16
   1a5d2:	454b      	cmp	r3, r9
   1a5d4:	d909      	bls.n	1a5ea <__divdi3+0x7a>
   1a5d6:	eb19 0904 	adds.w	r9, r9, r4
   1a5da:	f10a 3aff 	add.w	sl, sl, #4294967295
   1a5de:	d204      	bcs.n	1a5ea <__divdi3+0x7a>
   1a5e0:	454b      	cmp	r3, r9
   1a5e2:	bf84      	itt	hi
   1a5e4:	f10a 3aff 	addhi.w	sl, sl, #4294967295
   1a5e8:	44a1      	addhi	r9, r4
   1a5ea:	ebc3 0909 	rsb	r9, r3, r9
   1a5ee:	4639      	mov	r1, r7
   1a5f0:	4648      	mov	r0, r9
   1a5f2:	b2ad      	uxth	r5, r5
   1a5f4:	f7ff fd8c 	bl	1a110 <__aeabi_uidiv>
   1a5f8:	4639      	mov	r1, r7
   1a5fa:	4680      	mov	r8, r0
   1a5fc:	4648      	mov	r0, r9
   1a5fe:	f7ff feb5 	bl	1a36c <__aeabi_uidivmod>
   1a602:	fb0b fb08 	mul.w	fp, fp, r8
   1a606:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
   1a60a:	45ab      	cmp	fp, r5
   1a60c:	d907      	bls.n	1a61e <__divdi3+0xae>
   1a60e:	192d      	adds	r5, r5, r4
   1a610:	f108 38ff 	add.w	r8, r8, #4294967295
   1a614:	d203      	bcs.n	1a61e <__divdi3+0xae>
   1a616:	45ab      	cmp	fp, r5
   1a618:	bf88      	it	hi
   1a61a:	f108 38ff 	addhi.w	r8, r8, #4294967295
   1a61e:	ea48 480a 	orr.w	r8, r8, sl, lsl #16
   1a622:	2700      	movs	r7, #0
   1a624:	e003      	b.n	1a62e <__divdi3+0xbe>
   1a626:	428b      	cmp	r3, r1
   1a628:	d957      	bls.n	1a6da <__divdi3+0x16a>
   1a62a:	2700      	movs	r7, #0
   1a62c:	46b8      	mov	r8, r7
   1a62e:	4642      	mov	r2, r8
   1a630:	463b      	mov	r3, r7
   1a632:	b116      	cbz	r6, 1a63a <__divdi3+0xca>
   1a634:	4252      	negs	r2, r2
   1a636:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   1a63a:	4619      	mov	r1, r3
   1a63c:	4610      	mov	r0, r2
   1a63e:	b005      	add	sp, #20
   1a640:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1a644:	b922      	cbnz	r2, 1a650 <__divdi3+0xe0>
   1a646:	4611      	mov	r1, r2
   1a648:	2001      	movs	r0, #1
   1a64a:	f7ff fd61 	bl	1a110 <__aeabi_uidiv>
   1a64e:	4604      	mov	r4, r0
   1a650:	fab4 f884 	clz	r8, r4
   1a654:	f1b8 0f00 	cmp.w	r8, #0
   1a658:	d15e      	bne.n	1a718 <__divdi3+0x1a8>
   1a65a:	ebc4 0809 	rsb	r8, r4, r9
   1a65e:	0c27      	lsrs	r7, r4, #16
   1a660:	fa1f f984 	uxth.w	r9, r4
   1a664:	2101      	movs	r1, #1
   1a666:	9102      	str	r1, [sp, #8]
   1a668:	4639      	mov	r1, r7
   1a66a:	4640      	mov	r0, r8
   1a66c:	f7ff fd50 	bl	1a110 <__aeabi_uidiv>
   1a670:	4639      	mov	r1, r7
   1a672:	4682      	mov	sl, r0
   1a674:	4640      	mov	r0, r8
   1a676:	f7ff fe79 	bl	1a36c <__aeabi_uidivmod>
   1a67a:	ea4f 4815 	mov.w	r8, r5, lsr #16
   1a67e:	fb09 f30a 	mul.w	r3, r9, sl
   1a682:	ea48 4b01 	orr.w	fp, r8, r1, lsl #16
   1a686:	455b      	cmp	r3, fp
   1a688:	d909      	bls.n	1a69e <__divdi3+0x12e>
   1a68a:	eb1b 0b04 	adds.w	fp, fp, r4
   1a68e:	f10a 3aff 	add.w	sl, sl, #4294967295
   1a692:	d204      	bcs.n	1a69e <__divdi3+0x12e>
   1a694:	455b      	cmp	r3, fp
   1a696:	bf84      	itt	hi
   1a698:	f10a 3aff 	addhi.w	sl, sl, #4294967295
   1a69c:	44a3      	addhi	fp, r4
   1a69e:	ebc3 0b0b 	rsb	fp, r3, fp
   1a6a2:	4639      	mov	r1, r7
   1a6a4:	4658      	mov	r0, fp
   1a6a6:	b2ad      	uxth	r5, r5
   1a6a8:	f7ff fd32 	bl	1a110 <__aeabi_uidiv>
   1a6ac:	4639      	mov	r1, r7
   1a6ae:	4680      	mov	r8, r0
   1a6b0:	4658      	mov	r0, fp
   1a6b2:	f7ff fe5b 	bl	1a36c <__aeabi_uidivmod>
   1a6b6:	fb09 f908 	mul.w	r9, r9, r8
   1a6ba:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
   1a6be:	45a9      	cmp	r9, r5
   1a6c0:	d907      	bls.n	1a6d2 <__divdi3+0x162>
   1a6c2:	192d      	adds	r5, r5, r4
   1a6c4:	f108 38ff 	add.w	r8, r8, #4294967295
   1a6c8:	d203      	bcs.n	1a6d2 <__divdi3+0x162>
   1a6ca:	45a9      	cmp	r9, r5
   1a6cc:	bf88      	it	hi
   1a6ce:	f108 38ff 	addhi.w	r8, r8, #4294967295
   1a6d2:	ea48 480a 	orr.w	r8, r8, sl, lsl #16
   1a6d6:	9f02      	ldr	r7, [sp, #8]
   1a6d8:	e7a9      	b.n	1a62e <__divdi3+0xbe>
   1a6da:	fab3 f783 	clz	r7, r3
   1a6de:	2f00      	cmp	r7, #0
   1a6e0:	d168      	bne.n	1a7b4 <__divdi3+0x244>
   1a6e2:	428b      	cmp	r3, r1
   1a6e4:	bf2c      	ite	cs
   1a6e6:	f04f 0900 	movcs.w	r9, #0
   1a6ea:	f04f 0901 	movcc.w	r9, #1
   1a6ee:	4282      	cmp	r2, r0
   1a6f0:	bf8c      	ite	hi
   1a6f2:	464c      	movhi	r4, r9
   1a6f4:	f049 0401 	orrls.w	r4, r9, #1
   1a6f8:	2c00      	cmp	r4, #0
   1a6fa:	d096      	beq.n	1a62a <__divdi3+0xba>
   1a6fc:	f04f 0801 	mov.w	r8, #1
   1a700:	e795      	b.n	1a62e <__divdi3+0xbe>
   1a702:	4252      	negs	r2, r2
   1a704:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   1a708:	43f6      	mvns	r6, r6
   1a70a:	e73b      	b.n	1a584 <__divdi3+0x14>
   1a70c:	4240      	negs	r0, r0
   1a70e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   1a712:	f04f 36ff 	mov.w	r6, #4294967295
   1a716:	e732      	b.n	1a57e <__divdi3+0xe>
   1a718:	fa04 f408 	lsl.w	r4, r4, r8
   1a71c:	f1c8 0720 	rsb	r7, r8, #32
   1a720:	fa35 f307 	lsrs.w	r3, r5, r7
   1a724:	fa29 fa07 	lsr.w	sl, r9, r7
   1a728:	0c27      	lsrs	r7, r4, #16
   1a72a:	fa09 fb08 	lsl.w	fp, r9, r8
   1a72e:	4639      	mov	r1, r7
   1a730:	4650      	mov	r0, sl
   1a732:	ea43 020b 	orr.w	r2, r3, fp
   1a736:	9202      	str	r2, [sp, #8]
   1a738:	f7ff fcea 	bl	1a110 <__aeabi_uidiv>
   1a73c:	4639      	mov	r1, r7
   1a73e:	fa1f f984 	uxth.w	r9, r4
   1a742:	4683      	mov	fp, r0
   1a744:	4650      	mov	r0, sl
   1a746:	f7ff fe11 	bl	1a36c <__aeabi_uidivmod>
   1a74a:	9802      	ldr	r0, [sp, #8]
   1a74c:	fb09 f20b 	mul.w	r2, r9, fp
   1a750:	0c03      	lsrs	r3, r0, #16
   1a752:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   1a756:	429a      	cmp	r2, r3
   1a758:	d904      	bls.n	1a764 <__divdi3+0x1f4>
   1a75a:	191b      	adds	r3, r3, r4
   1a75c:	f10b 3bff 	add.w	fp, fp, #4294967295
   1a760:	f0c0 80b1 	bcc.w	1a8c6 <__divdi3+0x356>
   1a764:	1a9b      	subs	r3, r3, r2
   1a766:	4639      	mov	r1, r7
   1a768:	4618      	mov	r0, r3
   1a76a:	9301      	str	r3, [sp, #4]
   1a76c:	f7ff fcd0 	bl	1a110 <__aeabi_uidiv>
   1a770:	9901      	ldr	r1, [sp, #4]
   1a772:	4682      	mov	sl, r0
   1a774:	4608      	mov	r0, r1
   1a776:	4639      	mov	r1, r7
   1a778:	f7ff fdf8 	bl	1a36c <__aeabi_uidivmod>
   1a77c:	f8dd c008 	ldr.w	ip, [sp, #8]
   1a780:	fb09 f30a 	mul.w	r3, r9, sl
   1a784:	fa1f f08c 	uxth.w	r0, ip
   1a788:	ea40 4201 	orr.w	r2, r0, r1, lsl #16
   1a78c:	4293      	cmp	r3, r2
   1a78e:	d908      	bls.n	1a7a2 <__divdi3+0x232>
   1a790:	1912      	adds	r2, r2, r4
   1a792:	f10a 3aff 	add.w	sl, sl, #4294967295
   1a796:	d204      	bcs.n	1a7a2 <__divdi3+0x232>
   1a798:	4293      	cmp	r3, r2
   1a79a:	bf84      	itt	hi
   1a79c:	f10a 3aff 	addhi.w	sl, sl, #4294967295
   1a7a0:	1912      	addhi	r2, r2, r4
   1a7a2:	fa05 f508 	lsl.w	r5, r5, r8
   1a7a6:	ea4a 4e0b 	orr.w	lr, sl, fp, lsl #16
   1a7aa:	ebc3 0802 	rsb	r8, r3, r2
   1a7ae:	f8cd e008 	str.w	lr, [sp, #8]
   1a7b2:	e759      	b.n	1a668 <__divdi3+0xf8>
   1a7b4:	f1c7 0020 	rsb	r0, r7, #32
   1a7b8:	fa03 fa07 	lsl.w	sl, r3, r7
   1a7bc:	40c2      	lsrs	r2, r0
   1a7be:	fa35 f300 	lsrs.w	r3, r5, r0
   1a7c2:	ea42 0b0a 	orr.w	fp, r2, sl
   1a7c6:	fa21 f800 	lsr.w	r8, r1, r0
   1a7ca:	fa01 f907 	lsl.w	r9, r1, r7
   1a7ce:	4640      	mov	r0, r8
   1a7d0:	ea4f 4a1b 	mov.w	sl, fp, lsr #16
   1a7d4:	ea43 0109 	orr.w	r1, r3, r9
   1a7d8:	9102      	str	r1, [sp, #8]
   1a7da:	4651      	mov	r1, sl
   1a7dc:	fa1f f28b 	uxth.w	r2, fp
   1a7e0:	9203      	str	r2, [sp, #12]
   1a7e2:	f7ff fc95 	bl	1a110 <__aeabi_uidiv>
   1a7e6:	4651      	mov	r1, sl
   1a7e8:	4681      	mov	r9, r0
   1a7ea:	4640      	mov	r0, r8
   1a7ec:	f7ff fdbe 	bl	1a36c <__aeabi_uidivmod>
   1a7f0:	9b03      	ldr	r3, [sp, #12]
   1a7f2:	f8dd c008 	ldr.w	ip, [sp, #8]
   1a7f6:	fb03 f209 	mul.w	r2, r3, r9
   1a7fa:	ea4f 401c 	mov.w	r0, ip, lsr #16
   1a7fe:	fa14 f307 	lsls.w	r3, r4, r7
   1a802:	ea40 4401 	orr.w	r4, r0, r1, lsl #16
   1a806:	42a2      	cmp	r2, r4
   1a808:	d904      	bls.n	1a814 <__divdi3+0x2a4>
   1a80a:	eb14 040b 	adds.w	r4, r4, fp
   1a80e:	f109 39ff 	add.w	r9, r9, #4294967295
   1a812:	d352      	bcc.n	1a8ba <__divdi3+0x34a>
   1a814:	1aa4      	subs	r4, r4, r2
   1a816:	4651      	mov	r1, sl
   1a818:	4620      	mov	r0, r4
   1a81a:	9301      	str	r3, [sp, #4]
   1a81c:	f7ff fc78 	bl	1a110 <__aeabi_uidiv>
   1a820:	4651      	mov	r1, sl
   1a822:	4680      	mov	r8, r0
   1a824:	4620      	mov	r0, r4
   1a826:	f7ff fda1 	bl	1a36c <__aeabi_uidivmod>
   1a82a:	9803      	ldr	r0, [sp, #12]
   1a82c:	f8dd c008 	ldr.w	ip, [sp, #8]
   1a830:	fb00 f208 	mul.w	r2, r0, r8
   1a834:	fa1f f38c 	uxth.w	r3, ip
   1a838:	ea43 4001 	orr.w	r0, r3, r1, lsl #16
   1a83c:	9b01      	ldr	r3, [sp, #4]
   1a83e:	4282      	cmp	r2, r0
   1a840:	d904      	bls.n	1a84c <__divdi3+0x2dc>
   1a842:	eb10 000b 	adds.w	r0, r0, fp
   1a846:	f108 38ff 	add.w	r8, r8, #4294967295
   1a84a:	d330      	bcc.n	1a8ae <__divdi3+0x33e>
   1a84c:	ea48 4809 	orr.w	r8, r8, r9, lsl #16
   1a850:	fa1f fc83 	uxth.w	ip, r3
   1a854:	0c1b      	lsrs	r3, r3, #16
   1a856:	1a80      	subs	r0, r0, r2
   1a858:	fa1f fe88 	uxth.w	lr, r8
   1a85c:	ea4f 4a18 	mov.w	sl, r8, lsr #16
   1a860:	fb0c f90e 	mul.w	r9, ip, lr
   1a864:	fb0c fc0a 	mul.w	ip, ip, sl
   1a868:	fb03 c10e 	mla	r1, r3, lr, ip
   1a86c:	fb03 f20a 	mul.w	r2, r3, sl
   1a870:	eb01 4119 	add.w	r1, r1, r9, lsr #16
   1a874:	458c      	cmp	ip, r1
   1a876:	bf88      	it	hi
   1a878:	f502 3280 	addhi.w	r2, r2, #65536	; 0x10000
   1a87c:	eb02 4e11 	add.w	lr, r2, r1, lsr #16
   1a880:	4570      	cmp	r0, lr
   1a882:	d310      	bcc.n	1a8a6 <__divdi3+0x336>
   1a884:	fa1f f989 	uxth.w	r9, r9
   1a888:	fa05 f707 	lsl.w	r7, r5, r7
   1a88c:	eb09 4001 	add.w	r0, r9, r1, lsl #16
   1a890:	bf14      	ite	ne
   1a892:	2200      	movne	r2, #0
   1a894:	2201      	moveq	r2, #1
   1a896:	4287      	cmp	r7, r0
   1a898:	bf2c      	ite	cs
   1a89a:	2700      	movcs	r7, #0
   1a89c:	f002 0701 	andcc.w	r7, r2, #1
   1a8a0:	2f00      	cmp	r7, #0
   1a8a2:	f43f aec4 	beq.w	1a62e <__divdi3+0xbe>
   1a8a6:	f108 38ff 	add.w	r8, r8, #4294967295
   1a8aa:	2700      	movs	r7, #0
   1a8ac:	e6bf      	b.n	1a62e <__divdi3+0xbe>
   1a8ae:	4282      	cmp	r2, r0
   1a8b0:	bf84      	itt	hi
   1a8b2:	4458      	addhi	r0, fp
   1a8b4:	f108 38ff 	addhi.w	r8, r8, #4294967295
   1a8b8:	e7c8      	b.n	1a84c <__divdi3+0x2dc>
   1a8ba:	42a2      	cmp	r2, r4
   1a8bc:	bf84      	itt	hi
   1a8be:	f109 39ff 	addhi.w	r9, r9, #4294967295
   1a8c2:	445c      	addhi	r4, fp
   1a8c4:	e7a6      	b.n	1a814 <__divdi3+0x2a4>
   1a8c6:	429a      	cmp	r2, r3
   1a8c8:	bf84      	itt	hi
   1a8ca:	f10b 3bff 	addhi.w	fp, fp, #4294967295
   1a8ce:	191b      	addhi	r3, r3, r4
   1a8d0:	e748      	b.n	1a764 <__divdi3+0x1f4>
   1a8d2:	bf00      	nop

0001a8d4 <__udivdi3>:
   1a8d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1a8d8:	460c      	mov	r4, r1
   1a8da:	b083      	sub	sp, #12
   1a8dc:	4680      	mov	r8, r0
   1a8de:	4616      	mov	r6, r2
   1a8e0:	4689      	mov	r9, r1
   1a8e2:	461f      	mov	r7, r3
   1a8e4:	4615      	mov	r5, r2
   1a8e6:	468a      	mov	sl, r1
   1a8e8:	2b00      	cmp	r3, #0
   1a8ea:	d14b      	bne.n	1a984 <__udivdi3+0xb0>
   1a8ec:	428a      	cmp	r2, r1
   1a8ee:	d95c      	bls.n	1a9aa <__udivdi3+0xd6>
   1a8f0:	fab2 f382 	clz	r3, r2
   1a8f4:	b15b      	cbz	r3, 1a90e <__udivdi3+0x3a>
   1a8f6:	f1c3 0020 	rsb	r0, r3, #32
   1a8fa:	fa01 fa03 	lsl.w	sl, r1, r3
   1a8fe:	fa28 f200 	lsr.w	r2, r8, r0
   1a902:	fa16 f503 	lsls.w	r5, r6, r3
   1a906:	fa08 f803 	lsl.w	r8, r8, r3
   1a90a:	ea42 0a0a 	orr.w	sl, r2, sl
   1a90e:	0c2e      	lsrs	r6, r5, #16
   1a910:	4650      	mov	r0, sl
   1a912:	4631      	mov	r1, r6
   1a914:	b2af      	uxth	r7, r5
   1a916:	f7ff fbfb 	bl	1a110 <__aeabi_uidiv>
   1a91a:	4631      	mov	r1, r6
   1a91c:	ea4f 4418 	mov.w	r4, r8, lsr #16
   1a920:	4681      	mov	r9, r0
   1a922:	4650      	mov	r0, sl
   1a924:	f7ff fd22 	bl	1a36c <__aeabi_uidivmod>
   1a928:	fb07 f309 	mul.w	r3, r7, r9
   1a92c:	ea44 4a01 	orr.w	sl, r4, r1, lsl #16
   1a930:	4553      	cmp	r3, sl
   1a932:	d909      	bls.n	1a948 <__udivdi3+0x74>
   1a934:	eb1a 0a05 	adds.w	sl, sl, r5
   1a938:	f109 39ff 	add.w	r9, r9, #4294967295
   1a93c:	d204      	bcs.n	1a948 <__udivdi3+0x74>
   1a93e:	4553      	cmp	r3, sl
   1a940:	bf84      	itt	hi
   1a942:	f109 39ff 	addhi.w	r9, r9, #4294967295
   1a946:	44aa      	addhi	sl, r5
   1a948:	ebc3 0a0a 	rsb	sl, r3, sl
   1a94c:	4631      	mov	r1, r6
   1a94e:	4650      	mov	r0, sl
   1a950:	fa1f f888 	uxth.w	r8, r8
   1a954:	f7ff fbdc 	bl	1a110 <__aeabi_uidiv>
   1a958:	4631      	mov	r1, r6
   1a95a:	4604      	mov	r4, r0
   1a95c:	4650      	mov	r0, sl
   1a95e:	f7ff fd05 	bl	1a36c <__aeabi_uidivmod>
   1a962:	fb07 f704 	mul.w	r7, r7, r4
   1a966:	ea48 4801 	orr.w	r8, r8, r1, lsl #16
   1a96a:	4547      	cmp	r7, r8
   1a96c:	d906      	bls.n	1a97c <__udivdi3+0xa8>
   1a96e:	3c01      	subs	r4, #1
   1a970:	eb18 0805 	adds.w	r8, r8, r5
   1a974:	d202      	bcs.n	1a97c <__udivdi3+0xa8>
   1a976:	4547      	cmp	r7, r8
   1a978:	bf88      	it	hi
   1a97a:	3c01      	subhi	r4, #1
   1a97c:	ea44 4409 	orr.w	r4, r4, r9, lsl #16
   1a980:	2600      	movs	r6, #0
   1a982:	e05c      	b.n	1aa3e <__udivdi3+0x16a>
   1a984:	428b      	cmp	r3, r1
   1a986:	d858      	bhi.n	1aa3a <__udivdi3+0x166>
   1a988:	fab3 f683 	clz	r6, r3
   1a98c:	2e00      	cmp	r6, #0
   1a98e:	d15b      	bne.n	1aa48 <__udivdi3+0x174>
   1a990:	428b      	cmp	r3, r1
   1a992:	bf2c      	ite	cs
   1a994:	2200      	movcs	r2, #0
   1a996:	2201      	movcc	r2, #1
   1a998:	4285      	cmp	r5, r0
   1a99a:	bf8c      	ite	hi
   1a99c:	4615      	movhi	r5, r2
   1a99e:	f042 0501 	orrls.w	r5, r2, #1
   1a9a2:	2d00      	cmp	r5, #0
   1a9a4:	d049      	beq.n	1aa3a <__udivdi3+0x166>
   1a9a6:	2401      	movs	r4, #1
   1a9a8:	e049      	b.n	1aa3e <__udivdi3+0x16a>
   1a9aa:	b922      	cbnz	r2, 1a9b6 <__udivdi3+0xe2>
   1a9ac:	4611      	mov	r1, r2
   1a9ae:	2001      	movs	r0, #1
   1a9b0:	f7ff fbae 	bl	1a110 <__aeabi_uidiv>
   1a9b4:	4605      	mov	r5, r0
   1a9b6:	fab5 f685 	clz	r6, r5
   1a9ba:	2e00      	cmp	r6, #0
   1a9bc:	f040 80ba 	bne.w	1ab34 <__udivdi3+0x260>
   1a9c0:	1b64      	subs	r4, r4, r5
   1a9c2:	0c2f      	lsrs	r7, r5, #16
   1a9c4:	fa1f fa85 	uxth.w	sl, r5
   1a9c8:	2601      	movs	r6, #1
   1a9ca:	4639      	mov	r1, r7
   1a9cc:	4620      	mov	r0, r4
   1a9ce:	f7ff fb9f 	bl	1a110 <__aeabi_uidiv>
   1a9d2:	4639      	mov	r1, r7
   1a9d4:	ea4f 4b18 	mov.w	fp, r8, lsr #16
   1a9d8:	4681      	mov	r9, r0
   1a9da:	4620      	mov	r0, r4
   1a9dc:	f7ff fcc6 	bl	1a36c <__aeabi_uidivmod>
   1a9e0:	fb0a f309 	mul.w	r3, sl, r9
   1a9e4:	ea4b 4b01 	orr.w	fp, fp, r1, lsl #16
   1a9e8:	455b      	cmp	r3, fp
   1a9ea:	d909      	bls.n	1aa00 <__udivdi3+0x12c>
   1a9ec:	eb1b 0b05 	adds.w	fp, fp, r5
   1a9f0:	f109 39ff 	add.w	r9, r9, #4294967295
   1a9f4:	d204      	bcs.n	1aa00 <__udivdi3+0x12c>
   1a9f6:	455b      	cmp	r3, fp
   1a9f8:	bf84      	itt	hi
   1a9fa:	f109 39ff 	addhi.w	r9, r9, #4294967295
   1a9fe:	44ab      	addhi	fp, r5
   1aa00:	ebc3 0b0b 	rsb	fp, r3, fp
   1aa04:	4639      	mov	r1, r7
   1aa06:	4658      	mov	r0, fp
   1aa08:	fa1f f888 	uxth.w	r8, r8
   1aa0c:	f7ff fb80 	bl	1a110 <__aeabi_uidiv>
   1aa10:	4639      	mov	r1, r7
   1aa12:	4604      	mov	r4, r0
   1aa14:	4658      	mov	r0, fp
   1aa16:	f7ff fca9 	bl	1a36c <__aeabi_uidivmod>
   1aa1a:	fb0a fa04 	mul.w	sl, sl, r4
   1aa1e:	ea48 4801 	orr.w	r8, r8, r1, lsl #16
   1aa22:	45c2      	cmp	sl, r8
   1aa24:	d906      	bls.n	1aa34 <__udivdi3+0x160>
   1aa26:	3c01      	subs	r4, #1
   1aa28:	eb18 0805 	adds.w	r8, r8, r5
   1aa2c:	d202      	bcs.n	1aa34 <__udivdi3+0x160>
   1aa2e:	45c2      	cmp	sl, r8
   1aa30:	bf88      	it	hi
   1aa32:	3c01      	subhi	r4, #1
   1aa34:	ea44 4409 	orr.w	r4, r4, r9, lsl #16
   1aa38:	e001      	b.n	1aa3e <__udivdi3+0x16a>
   1aa3a:	2600      	movs	r6, #0
   1aa3c:	4634      	mov	r4, r6
   1aa3e:	4631      	mov	r1, r6
   1aa40:	4620      	mov	r0, r4
   1aa42:	b003      	add	sp, #12
   1aa44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1aa48:	f1c6 0020 	rsb	r0, r6, #32
   1aa4c:	40b3      	lsls	r3, r6
   1aa4e:	fa32 f700 	lsrs.w	r7, r2, r0
   1aa52:	fa21 fb00 	lsr.w	fp, r1, r0
   1aa56:	431f      	orrs	r7, r3
   1aa58:	fa14 f206 	lsls.w	r2, r4, r6
   1aa5c:	fa28 f100 	lsr.w	r1, r8, r0
   1aa60:	4658      	mov	r0, fp
   1aa62:	ea4f 4a17 	mov.w	sl, r7, lsr #16
   1aa66:	4311      	orrs	r1, r2
   1aa68:	9100      	str	r1, [sp, #0]
   1aa6a:	4651      	mov	r1, sl
   1aa6c:	b2bb      	uxth	r3, r7
   1aa6e:	9301      	str	r3, [sp, #4]
   1aa70:	f7ff fb4e 	bl	1a110 <__aeabi_uidiv>
   1aa74:	4651      	mov	r1, sl
   1aa76:	40b5      	lsls	r5, r6
   1aa78:	4681      	mov	r9, r0
   1aa7a:	4658      	mov	r0, fp
   1aa7c:	f7ff fc76 	bl	1a36c <__aeabi_uidivmod>
   1aa80:	9c01      	ldr	r4, [sp, #4]
   1aa82:	9800      	ldr	r0, [sp, #0]
   1aa84:	fb04 f309 	mul.w	r3, r4, r9
   1aa88:	ea4f 4c10 	mov.w	ip, r0, lsr #16
   1aa8c:	ea4c 4b01 	orr.w	fp, ip, r1, lsl #16
   1aa90:	455b      	cmp	r3, fp
   1aa92:	d905      	bls.n	1aaa0 <__udivdi3+0x1cc>
   1aa94:	eb1b 0b07 	adds.w	fp, fp, r7
   1aa98:	f109 39ff 	add.w	r9, r9, #4294967295
   1aa9c:	f0c0 808e 	bcc.w	1abbc <__udivdi3+0x2e8>
   1aaa0:	ebc3 0b0b 	rsb	fp, r3, fp
   1aaa4:	4651      	mov	r1, sl
   1aaa6:	4658      	mov	r0, fp
   1aaa8:	f7ff fb32 	bl	1a110 <__aeabi_uidiv>
   1aaac:	4651      	mov	r1, sl
   1aaae:	4604      	mov	r4, r0
   1aab0:	4658      	mov	r0, fp
   1aab2:	f7ff fc5b 	bl	1a36c <__aeabi_uidivmod>
   1aab6:	9801      	ldr	r0, [sp, #4]
   1aab8:	9a00      	ldr	r2, [sp, #0]
   1aaba:	fb00 f304 	mul.w	r3, r0, r4
   1aabe:	fa1f fc82 	uxth.w	ip, r2
   1aac2:	ea4c 4201 	orr.w	r2, ip, r1, lsl #16
   1aac6:	4293      	cmp	r3, r2
   1aac8:	d906      	bls.n	1aad8 <__udivdi3+0x204>
   1aaca:	3c01      	subs	r4, #1
   1aacc:	19d2      	adds	r2, r2, r7
   1aace:	d203      	bcs.n	1aad8 <__udivdi3+0x204>
   1aad0:	4293      	cmp	r3, r2
   1aad2:	d901      	bls.n	1aad8 <__udivdi3+0x204>
   1aad4:	19d2      	adds	r2, r2, r7
   1aad6:	3c01      	subs	r4, #1
   1aad8:	ea44 4409 	orr.w	r4, r4, r9, lsl #16
   1aadc:	b2a8      	uxth	r0, r5
   1aade:	1ad2      	subs	r2, r2, r3
   1aae0:	0c2d      	lsrs	r5, r5, #16
   1aae2:	fa1f fc84 	uxth.w	ip, r4
   1aae6:	0c23      	lsrs	r3, r4, #16
   1aae8:	fb00 f70c 	mul.w	r7, r0, ip
   1aaec:	fb00 fe03 	mul.w	lr, r0, r3
   1aaf0:	fb05 e10c 	mla	r1, r5, ip, lr
   1aaf4:	fb05 f503 	mul.w	r5, r5, r3
   1aaf8:	eb01 4117 	add.w	r1, r1, r7, lsr #16
   1aafc:	458e      	cmp	lr, r1
   1aafe:	bf88      	it	hi
   1ab00:	f505 3580 	addhi.w	r5, r5, #65536	; 0x10000
   1ab04:	eb05 4511 	add.w	r5, r5, r1, lsr #16
   1ab08:	42aa      	cmp	r2, r5
   1ab0a:	d310      	bcc.n	1ab2e <__udivdi3+0x25a>
   1ab0c:	b2bf      	uxth	r7, r7
   1ab0e:	fa08 f606 	lsl.w	r6, r8, r6
   1ab12:	eb07 4201 	add.w	r2, r7, r1, lsl #16
   1ab16:	bf14      	ite	ne
   1ab18:	f04f 0e00 	movne.w	lr, #0
   1ab1c:	f04f 0e01 	moveq.w	lr, #1
   1ab20:	4296      	cmp	r6, r2
   1ab22:	bf2c      	ite	cs
   1ab24:	2600      	movcs	r6, #0
   1ab26:	f00e 0601 	andcc.w	r6, lr, #1
   1ab2a:	2e00      	cmp	r6, #0
   1ab2c:	d087      	beq.n	1aa3e <__udivdi3+0x16a>
   1ab2e:	3c01      	subs	r4, #1
   1ab30:	2600      	movs	r6, #0
   1ab32:	e784      	b.n	1aa3e <__udivdi3+0x16a>
   1ab34:	40b5      	lsls	r5, r6
   1ab36:	f1c6 0120 	rsb	r1, r6, #32
   1ab3a:	fa24 f901 	lsr.w	r9, r4, r1
   1ab3e:	fa28 f201 	lsr.w	r2, r8, r1
   1ab42:	0c2f      	lsrs	r7, r5, #16
   1ab44:	40b4      	lsls	r4, r6
   1ab46:	4639      	mov	r1, r7
   1ab48:	4648      	mov	r0, r9
   1ab4a:	4322      	orrs	r2, r4
   1ab4c:	9200      	str	r2, [sp, #0]
   1ab4e:	f7ff fadf 	bl	1a110 <__aeabi_uidiv>
   1ab52:	4639      	mov	r1, r7
   1ab54:	fa1f fa85 	uxth.w	sl, r5
   1ab58:	4683      	mov	fp, r0
   1ab5a:	4648      	mov	r0, r9
   1ab5c:	f7ff fc06 	bl	1a36c <__aeabi_uidivmod>
   1ab60:	9b00      	ldr	r3, [sp, #0]
   1ab62:	0c1a      	lsrs	r2, r3, #16
   1ab64:	fb0a f30b 	mul.w	r3, sl, fp
   1ab68:	ea42 4401 	orr.w	r4, r2, r1, lsl #16
   1ab6c:	42a3      	cmp	r3, r4
   1ab6e:	d903      	bls.n	1ab78 <__udivdi3+0x2a4>
   1ab70:	1964      	adds	r4, r4, r5
   1ab72:	f10b 3bff 	add.w	fp, fp, #4294967295
   1ab76:	d327      	bcc.n	1abc8 <__udivdi3+0x2f4>
   1ab78:	1ae4      	subs	r4, r4, r3
   1ab7a:	4639      	mov	r1, r7
   1ab7c:	4620      	mov	r0, r4
   1ab7e:	f7ff fac7 	bl	1a110 <__aeabi_uidiv>
   1ab82:	4639      	mov	r1, r7
   1ab84:	4681      	mov	r9, r0
   1ab86:	4620      	mov	r0, r4
   1ab88:	f7ff fbf0 	bl	1a36c <__aeabi_uidivmod>
   1ab8c:	9800      	ldr	r0, [sp, #0]
   1ab8e:	fb0a f309 	mul.w	r3, sl, r9
   1ab92:	fa1f fc80 	uxth.w	ip, r0
   1ab96:	ea4c 4401 	orr.w	r4, ip, r1, lsl #16
   1ab9a:	42a3      	cmp	r3, r4
   1ab9c:	d908      	bls.n	1abb0 <__udivdi3+0x2dc>
   1ab9e:	1964      	adds	r4, r4, r5
   1aba0:	f109 39ff 	add.w	r9, r9, #4294967295
   1aba4:	d204      	bcs.n	1abb0 <__udivdi3+0x2dc>
   1aba6:	42a3      	cmp	r3, r4
   1aba8:	bf84      	itt	hi
   1abaa:	f109 39ff 	addhi.w	r9, r9, #4294967295
   1abae:	1964      	addhi	r4, r4, r5
   1abb0:	fa08 f806 	lsl.w	r8, r8, r6
   1abb4:	1ae4      	subs	r4, r4, r3
   1abb6:	ea49 460b 	orr.w	r6, r9, fp, lsl #16
   1abba:	e706      	b.n	1a9ca <__udivdi3+0xf6>
   1abbc:	455b      	cmp	r3, fp
   1abbe:	bf84      	itt	hi
   1abc0:	f109 39ff 	addhi.w	r9, r9, #4294967295
   1abc4:	44bb      	addhi	fp, r7
   1abc6:	e76b      	b.n	1aaa0 <__udivdi3+0x1cc>
   1abc8:	42a3      	cmp	r3, r4
   1abca:	bf84      	itt	hi
   1abcc:	f10b 3bff 	addhi.w	fp, fp, #4294967295
   1abd0:	1964      	addhi	r4, r4, r5
   1abd2:	e7d1      	b.n	1ab78 <__udivdi3+0x2a4>
   1abd4:	00007852 	.word	0x00007852
   1abd8:	00005854 	.word	0x00005854
   1abdc:	63656843 	.word	0x63656843
   1abe0:	6d69546b 	.word	0x6d69546b
   1abe4:	00007265 	.word	0x00007265
   1abe8:	00504975 	.word	0x00504975
   1abec:	74726175 	.word	0x74726175
   1abf0:	7361745f 	.word	0x7361745f
   1abf4:	0000006b 	.word	0x0000006b
   1abf8:	206c6c41 	.word	0x206c6c41
   1abfc:	6b736174 	.word	0x6b736174
   1ac00:	75722073 	.word	0x75722073
   1ac04:	6e696e6e 	.word	0x6e696e6e
   1ac08:	69772067 	.word	0x69772067
   1ac0c:	756f6874 	.word	0x756f6874
   1ac10:	72652074 	.word	0x72652074
   1ac14:	00726f72 	.word	0x00726f72
   1ac18:	2a2a2a0a 	.word	0x2a2a2a0a
   1ac1c:	2a2a2a2a 	.word	0x2a2a2a2a
   1ac20:	57202a2a 	.word	0x57202a2a
   1ac24:	6f636c65 	.word	0x6f636c65
   1ac28:	7420656d 	.word	0x7420656d
   1ac2c:	6874206f 	.word	0x6874206f
   1ac30:	654d2065 	.word	0x654d2065
   1ac34:	72757361 	.word	0x72757361
   1ac38:	6e656d65 	.word	0x6e656d65
   1ac3c:	79532074 	.word	0x79532074
   1ac40:	6d657473 	.word	0x6d657473
   1ac44:	2a2a2020 	.word	0x2a2a2020
   1ac48:	2a2a2a2a 	.word	0x2a2a2a2a
   1ac4c:	0a2a2a2a 	.word	0x0a2a2a2a
   1ac50:	0000000d 	.word	0x0000000d
   1ac54:	00000d0a 	.word	0x00000d0a
   1ac58:	2a2a2a2a 	.word	0x2a2a2a2a
   1ac5c:	2a2a2a2a 	.word	0x2a2a2a2a
   1ac60:	6d53202a 	.word	0x6d53202a
   1ac64:	46747261 	.word	0x46747261
   1ac68:	6f697375 	.word	0x6f697375
   1ac6c:	6c50206e 	.word	0x6c50206e
   1ac70:	4d207961 	.word	0x4d207961
   1ac74:	20756e65 	.word	0x20756e65
   1ac78:	2a2a2a2a 	.word	0x2a2a2a2a
   1ac7c:	2a2a2a2a 	.word	0x2a2a2a2a
   1ac80:	2a2a2a2a 	.word	0x2a2a2a2a
   1ac84:	0d0a2a2a 	.word	0x0d0a2a2a
   1ac88:	00000000 	.word	0x00000000
   1ac8c:	2a2a2a2a 	.word	0x2a2a2a2a
   1ac90:	2a2a2a2a 	.word	0x2a2a2a2a
   1ac94:	2e30202a 	.word	0x2e30202a
   1ac98:	754d2020 	.word	0x754d2020
   1ac9c:	6d69746c 	.word	0x6d69746c
   1aca0:	72657465 	.word	0x72657465
   1aca4:	2a2a2a20 	.word	0x2a2a2a20
   1aca8:	2a2a2a2a 	.word	0x2a2a2a2a
   1acac:	2a2a2a2a 	.word	0x2a2a2a2a
   1acb0:	2a2a2a2a 	.word	0x2a2a2a2a
   1acb4:	2a2a2a2a 	.word	0x2a2a2a2a
   1acb8:	0d0a2a2a 	.word	0x0d0a2a2a
   1acbc:	00000000 	.word	0x00000000
   1acc0:	0000000a 	.word	0x0000000a
   1acc4:	61766e49 	.word	0x61766e49
   1acc8:	2064696c 	.word	0x2064696c
   1accc:	2079654b 	.word	0x2079654b
   1acd0:	00000d0a 	.word	0x00000d0a
   1acd4:	2a2a2a2a 	.word	0x2a2a2a2a
   1acd8:	656c5020 	.word	0x656c5020
   1acdc:	20657361 	.word	0x20657361
   1ace0:	65746e45 	.word	0x65746e45
   1ace4:	6f592072 	.word	0x6f592072
   1ace8:	43207275 	.word	0x43207275
   1acec:	63696f68 	.word	0x63696f68
   1acf0:	20202065 	.word	0x20202065
   1acf4:	2a202020 	.word	0x2a202020
   1acf8:	2a2a2a2a 	.word	0x2a2a2a2a
   1acfc:	0d0a202a 	.word	0x0d0a202a
   1ad00:	00000000 	.word	0x00000000
   1ad04:	54505241 	.word	0x54505241
   1ad08:	72656d69 	.word	0x72656d69
   1ad0c:	00000000 	.word	0x00000000
   1ad10:	69726550 	.word	0x69726550
   1ad14:	6369646f 	.word	0x6369646f
   1ad18:	656d6954 	.word	0x656d6954
   1ad1c:	00000072 	.word	0x00000072
   1ad20:	732e6f69 	.word	0x732e6f69
   1ad24:	6c6d7468 	.word	0x6c6d7468
   1ad28:	00000000 	.word	0x00000000
   1ad2c:	3044454c 	.word	0x3044454c
   1ad30:	0000313d 	.word	0x0000313d

0001ad34 <ulARPTimerExpired.4126>:
   1ad34:	00000004                                ....

0001ad38 <ulPeriodicTimerExpired.4127>:
   1ad38:	00000008 656c6966 6174732d 00007374     ....file-stats..
   1ad48:	2d706374 6e6e6f63 69746365 00736e6f     tcp-connections.
   1ad58:	2d74656e 74617473 00000073 736f7472     net-stats...rtos
   1ad68:	6174732d 00007374 2d6e7572 656d6974     -stats..run-time
   1ad78:	00000000 2d64656c 00006f69 2d746f70     ....led-io..pot-
   1ad88:	746c6f76 00656761 00753525 3e72743c     voltage.%5u.<tr>
   1ad98:	3e64743c 2f3c6425 3c3e6474 253e6474     <td>%d</td><td>%
   1ada8:	75252e75 2e75252e 253a7525 742f3c75     u.%u.%u.%u:%u</t
   1adb8:	743c3e64 73253e64 64742f3c 64743c3e     d><td>%s</td><td
   1adc8:	3c75253e 3e64742f 3e64743c 2f3c7525     >%u</td><td>%u</
   1add8:	3c3e6474 253e6474 63252063 64742f3c     td><td>%c %c</td
   1ade8:	742f3c3e 0a0d3e72 00000000 0a753525     ></tr>......%5u.
   1adf8:	00000000 3c3e703c 523e7262 65726665     ....<p><br>Refre
   1ae08:	63206873 746e756f 25203d20 3e703c64     sh count = %d<p>
   1ae18:	3e72623c 00007325 63656863 0064656b     <br>%s..checked.
   1ae28:	00000000 706e693c 74207475 3d657079     ....<input type=
   1ae38:	65686322 6f626b63 6e202278 3d656d61     "checkbox" name=
   1ae48:	44454c22 76202230 65756c61 2231223d     "LED0" value="1"
   1ae58:	3e732520 3c44454c 703c3e70 3e703c3e      %s>LED<p><p><p>
   1ae68:	20776152 746c6f76 20656761 75706e69     Raw voltage inpu
   1ae78:	73692074 00642520 3c3e703c 523e7262     t is %d.<p><br>R
   1ae88:	65726665 63206873 746e756f 25203d20     efresh count = %
   1ae98:	00000064 66322e25 00000000              d...%.2f....

0001aea4 <file>:
   1aea4:	0001ad3c 00001451                       <...Q...

0001aeac <tcp>:
   1aeac:	0001ad48 000015e5                       H.......

0001aeb4 <net>:
   1aeb4:	0001ad58 000016e5                       X.......

0001aebc <rtos>:
   1aebc:	0001ad64 000017fd                       d.......

0001aec4 <run>:
   1aec4:	0001ad70 00001981                       p.......

0001aecc <io>:
   1aecc:	0001ad7c 000019e9                       |.......

0001aed4 <output>:
   1aed4:	0001ad84 00001a89                       ........

0001aedc <closed>:
   1aedc:	534f4c43 00004445                       CLOSED..

0001aee4 <syn_rcvd>:
   1aee4:	2d4e5953 44564352 00000000              SYN-RCVD....

0001aef0 <syn_sent>:
   1aef0:	2d4e5953 544e4553 00000000              SYN-SENT....

0001aefc <established>:
   1aefc:	41545345 53494c42 00444548              ESTABLISHED.

0001af08 <fin_wait_1>:
   1af08:	2d4e4946 54494157 0000312d              FIN-WAIT-1..

0001af14 <fin_wait_2>:
   1af14:	2d4e4946 54494157 0000322d              FIN-WAIT-2..

0001af20 <closing>:
   1af20:	534f4c43 00474e49                       CLOSING.

0001af28 <time_wait>:
   1af28:	454d4954 4941572d 00000054              TIME-WAIT...

0001af34 <last_ack>:
   1af34:	5453414c 4b43412d 00000000              LAST-ACK....

0001af40 <g_ace_current_resistors>:
   1af40:	000186a0 00000001 00000001 00000001     ................

0001af50 <g_ace_external_varef_used>:
   1af50:	00000000                                ....

0001af54 <g_ace_channel_0_name>:
   1af54:	72727543 4d746e65 74696e6f 305f726f     CurrentMonitor_0
   1af64:	00000000                                ....

0001af68 <g_ace_channel_1_name>:
   1af68:	746c6f56 4d656761 74696e6f 305f726f     VoltageMonitor_0
   1af78:	00000000                                ....

0001af7c <g_ace_channel_2_name>:
   1af7c:	706d6554 74617265 4d657275 74696e6f     TemperatureMonit
   1af8c:	305f726f 00000000                       or_0....

0001af94 <g_ace_ppe_transforms_desc_table>:
   1af94:	00130012 00004000 001c001b 00004000     .....@.......@..
   1afa4:	00250024 00004000                       $.%..@..

0001afac <g_ace_sse_proc_0_name>:
   1afac:	30434441 49414d5f 0000004e              ADC0_MAIN...

0001afb8 <g_ace_sse_proc_0_sequence>:
   1afb8:	16011705 8a0c152d 00001309 000014c3     ....-...........
   1afc8:	155c8a04 000014c4 970c152d 0000132f     ..\.....-.../...
   1afd8:	000014c8 10029704                       ........

0001afe0 <g_ace_sse_proc_1_name>:
   1afe0:	31434441 49414d5f 0000004e              ADC1_MAIN...

0001afec <g_ace_sse_proc_1_sequence>:
   1afec:	26012705 00002200                       .'.&."..

0001aff4 <g_config_reg_lut>:
   1aff4:	40013000 40013004 40013008 4001300c     .0.@.0.@.0.@.0.@
   1b004:	40013010 40013014 40013018 4001301c     .0.@.0.@.0.@.0.@
   1b014:	40013020 40013024 40013028 4001302c      0.@$0.@(0.@,0.@
   1b024:	40013030 40013034 40013038 4001303c     00.@40.@80.@<0.@
   1b034:	40013040 40013044 40013048 4001304c     @0.@D0.@H0.@L0.@
   1b044:	40013050 40013054 40013058 4001305c     P0.@T0.@X0.@\0.@
   1b054:	40013060 40013064 40013068 4001306c     `0.@d0.@h0.@l0.@
   1b064:	40013070 40013074 40013078 4001307c     p0.@t0.@x0.@|0.@

0001b074 <g_gpio_irqn_lut>:
   1b074:	00210020 00230022 00250024 00270026      .!.".#.$.%.&.'.
   1b084:	00290028 002b002a 002d002c 002f002e     (.).*.+.,.-.../.
   1b094:	00310030 00330032 00350034 00370036     0.1.2.3.4.5.6.7.
   1b0a4:	00390038 003b003a 003d003c 003f003e     8.9.:.;.<.=.>.?.

0001b0b4 <crc32_table>:
   1b0b4:	00000000 77073096 ee0e612c 990951ba     .....0.w,a...Q..
   1b0c4:	076dc419 706af48f e963a535 9e6495a3     ..m...jp5.c...d.
   1b0d4:	0edb8832 79dcb8a4 e0d5e91e 97d2d988     2......y........
   1b0e4:	09b64c2b 7eb17cbd e7b82d07 90bf1d91     +L...|.~.-......
   1b0f4:	1db71064 6ab020f2 f3b97148 84be41de     d.... .jHq...A..
   1b104:	1adad47d 6ddde4eb f4d4b551 83d385c7     }......mQ.......
   1b114:	136c9856 646ba8c0 fd62f97a 8a65c9ec     V.l...kdz.b...e.
   1b124:	14015c4f 63066cd9 fa0f3d63 8d080df5     O\...l.cc=......
   1b134:	3b6e20c8 4c69105e d56041e4 a2677172     . n;^.iL.A`.rqg.
   1b144:	3c03e4d1 4b04d447 d20d85fd a50ab56b     ...<G..K....k...
   1b154:	35b5a8fa 42b2986c dbbbc9d6 acbcf940     ...5l..B....@...
   1b164:	32d86ce3 45df5c75 dcd60dcf abd13d59     .l.2u\.E....Y=..
   1b174:	26d930ac 51de003a c8d75180 bfd06116     .0.&:..Q.Q...a..
   1b184:	21b4f4b5 56b3c423 cfba9599 b8bda50f     ...!#..V........
   1b194:	2802b89e 5f058808 c60cd9b2 b10be924     ...(..._....$...
   1b1a4:	2f6f7c87 58684c11 c1611dab b6662d3d     .|o/.LhX..a.=-f.
   1b1b4:	76dc4190 01db7106 98d220bc efd5102a     .A.v.q... ..*...
   1b1c4:	71b18589 06b6b51f 9fbfe4a5 e8b8d433     ...q........3...
   1b1d4:	7807c9a2 0f00f934 9609a88e e10e9818     ...x4...........
   1b1e4:	7f6a0dbb 086d3d2d 91646c97 e6635c01     ..j.-=m..ld..\c.
   1b1f4:	6b6b51f4 1c6c6162 856530d8 f262004e     .Qkkbal..0e.N.b.
   1b204:	6c0695ed 1b01a57b 8208f4c1 f50fc457     ...l{.......W...
   1b214:	65b0d9c6 12b7e950 8bbeb8ea fcb9887c     ...eP.......|...
   1b224:	62dd1ddf 15da2d49 8cd37cf3 fbd44c65     ...bI-...|..eL..
   1b234:	4db26158 3ab551ce a3bc0074 d4bb30e2     Xa.M.Q.:t....0..
   1b244:	4adfa541 3dd895d7 a4d1c46d d3d6f4fb     A..J...=m.......
   1b254:	4369e96a 346ed9fc ad678846 da60b8d0     j.iC..n4F.g...`.
   1b264:	44042d73 33031de5 aa0a4c5f dd0d7cc9     s-.D...3_L...|..
   1b274:	5005713c 270241aa be0b1010 c90c2086     <q.P.A.'..... ..
   1b284:	5768b525 206f85b3 b966d409 ce61e49f     %.hW..o ..f...a.
   1b294:	5edef90e 29d9c998 b0d09822 c7d7a8b4     ...^...)".......
   1b2a4:	59b33d17 2eb40d81 b7bd5c3b c0ba6cad     .=.Y....;\...l..
   1b2b4:	edb88320 9abfb3b6 03b6e20c 74b1d29a      ..............t
   1b2c4:	ead54739 9dd277af 04db2615 73dc1683     9G...w...&.....s
   1b2d4:	e3630b12 94643b84 0d6d6a3e 7a6a5aa8     ..c..;d.>jm..Zjz
   1b2e4:	e40ecf0b 9309ff9d 0a00ae27 7d079eb1     ........'......}
   1b2f4:	f00f9344 8708a3d2 1e01f268 6906c2fe     D.......h......i
   1b304:	f762575d 806567cb 196c3671 6e6b06e7     ]Wb..ge.q6l...kn
   1b314:	fed41b76 89d32be0 10da7a5a 67dd4acc     v....+..Zz...J.g
   1b324:	f9b9df6f 8ebeeff9 17b7be43 60b08ed5     o.......C......`
   1b334:	d6d6a3e8 a1d1937e 38d8c2c4 4fdff252     ....~......8R..O
   1b344:	d1bb67f1 a6bc5767 3fb506dd 48b2364b     .g..gW.....?K6.H
   1b354:	d80d2bda af0a1b4c 36034af6 41047a60     .+..L....J.6`z.A
   1b364:	df60efc3 a867df55 316e8eef 4669be79     ..`.U.g...n1y.iF
   1b374:	cb61b38c bc66831a 256fd2a0 5268e236     ..a...f...o%6.hR
   1b384:	cc0c7795 bb0b4703 220216b9 5505262f     .w...G....."/&.U
   1b394:	c5ba3bbe b2bd0b28 2bb45a92 5cb36a04     .;..(....Z.+.j.\
   1b3a4:	c2d7ffa7 b5d0cf31 2cd99e8b 5bdeae1d     ....1......,...[
   1b3b4:	9b64c2b0 ec63f226 756aa39c 026d930a     ..d.&.c...ju..m.
   1b3c4:	9c0906a9 eb0e363f 72076785 05005713     ....?6...g.r.W..
   1b3d4:	95bf4a82 e2b87a14 7bb12bae 0cb61b38     .J...z...+.{8...
   1b3e4:	92d28e9b e5d5be0d 7cdcefb7 0bdbdf21     ...........|!...
   1b3f4:	86d3d2d4 f1d4e242 68ddb3f8 1fda836e     ....B......hn...
   1b404:	81be16cd f6b9265b 6fb077e1 18b74777     ....[&...w.owG..
   1b414:	88085ae6 ff0f6a70 66063bca 11010b5c     .Z..pj...;.f\...
   1b424:	8f659eff f862ae69 616bffd3 166ccf45     ..e.i.b...kaE.l.
   1b434:	a00ae278 d70dd2ee 4e048354 3903b3c2     x.......T..N...9
   1b444:	a7672661 d06016f7 4969474d 3e6e77db     a&g...`.MGiI.wn>
   1b454:	aed16a4a d9d65adc 40df0b66 37d83bf0     Jj...Z..f..@.;.7
   1b464:	a9bcae53 debb9ec5 47b2cf7f 30b5ffe9     S..........G...0
   1b474:	bdbdf21c cabac28a 53b39330 24b4a3a6     ........0..S...$
   1b484:	bad03605 cdd70693 54de5729 23d967bf     .6......)W.T.g.#
   1b494:	b3667a2e c4614ab8 5d681b02 2a6f2b94     .zf..Ja...h].+o*
   1b4a4:	b40bbe37 c30c8ea1 5a05df1b 2d02ef8d     7..........Z...-

0001b4b4 <unknown_error>:
   1b4b4:	6e6b6e55 206e776f 6f727265 00000072     Unknown error...

0001b4c4 <ErrorMessages>:
   1b4c4:	65206f4e 726f7272 63636f20 64657275     No error occured
	...
   1b4ec:	6874654d 6620646f 656c6961 00000064     Method failed...
	...
   1b514:	6e6f7257 61702067 656d6172 20726574     Wrong parameter 
   1b524:	65736170 6f742064 6e756620 6f697463     pased to functio
   1b534:	0000006e 00000000 6d617246 73692065     n.......Frame is
   1b544:	6f6f7420 6e6f6c20 00000067 00000000      too long.......
	...
   1b564:	20746f4e 756f6e65 73206867 65636170     Not enough space
   1b574:	206e6920 66667562 00007265 00000000      in buffer......
	...
   1b58c:	20746f4e 756f6e65 73206867 65636170     Not enough space
   1b59c:	206e6920 66667562 00007265 00000000      in buffer......
	...
   1b5b4:	656d6954 756f2064 00000074 00000000     Timed out.......
	...
   1b5dc:	6d617246 73692065 6f6f7420 616d7320     Frame is too sma
   1b5ec:	00006c6c 00000000 00000000 00000000     ll..............
	...

0001b604 <C.18.3199>:
   1b604:	10131200 00001115                       ........

0001b60c <channel_type_lut>:
   1b60c:	01000000 01000002 00000002 00ffff00     ................
   1b61c:	01000000 01000002 00000002 00ffff00     ................
   1b62c:	01000000 ffffff02 000000ff 00ffff00     ................

0001b63c <channel_quad_lut>:
   1b63c:	000000ff 01010100 ffffff01 ffffffff     ................
   1b64c:	020202ff 03030302 ffffff03 ffffffff     ................
   1b65c:	040404ff ffffff04 ffffffff ffffffff     ................

0001b66c <abps_channel_lut>:
   1b66c:	ff0000ff ff0101ff ffffffff ffffffff     ................
   1b67c:	ff0202ff ff0303ff ffffffff ffffffff     ................
   1b68c:	ff0404ff ffffffff ffffffff ffffffff     ................

0001b69c <abps_idx_lut>:
   1b69c:	ff0100ff ff0302ff ffffffff ffffffff     ................
   1b6ac:	ff0504ff ff0706ff ffffffff ffffffff     ................
   1b6bc:	ff0908ff ffffffff ffffffff ffffffff     ................

0001b6cc <apbs_gain_lut>:
   1b6cc:	0204080c                                ....

0001b6d0 <apbs_range>:
   1b6d0:	28003c00 0a001400                       .<.(....

0001b6d8 <sse_pc_ctrl_lut>:
   1b6d8:	40020048 40020088 400200c8              H..@...@...@

0001b6e4 <sse_pc_lo_lut>:
   1b6e4:	40020040 40020080 400200c0              @..@...@...@

0001b6f0 <sse_pc_hi_lut>:
   1b6f0:	40020044 40020084 400200c4              D..@...@...@

0001b6fc <p_mtd_data>:
   1b6fc:	60080010                                ...`

0001b700 <C.24.3277>:
   1b700:	02010006 02010003 04040403 05060604     ................

0001b710 <C.36.3341>:
	...
   1b738:	00000001 00000002 00000003 00000000     ................
	...

0001b750 <C.18.3187>:
   1b750:	40004000 00000000                       .@.@....

0001b758 <adc_status_reg_lut>:
   1b758:	40021000 40021004 40021008              ...@...@...@

0001b764 <dac_ctrl_reg_lut>:
   1b764:	40020060 400200a0 400200e0              `..@...@...@

0001b770 <dac_enable_masks_lut>:
   1b770:	00000010 00000020 00000040              .... ...@...

0001b77c <dac_byte01_reg_lut>:
   1b77c:	40020500 40020504 40020508              ...@...@...@

0001b788 <dac_byte2_reg_lut>:
   1b788:	4002006c 400200ac 400200ec              l..@...@...@

0001b794 <p_mtd_data>:
   1b794:	60080010                                ...`

0001b798 <comp_id_2_scb_lut>:
   1b798:	01010000 03030202 00000404              ............

0001b7a4 <C.18.3512>:
   1b7a4:	00040200                                ....

0001b7a8 <C.18.2576>:
   1b7a8:	00000001 00000002 00000004 00000001     ................
   1b7b8:	70616548 646e6120 61747320 63206b63     Heap and stack c
   1b7c8:	696c6c6f 6e6f6973 0000000a              ollision....

0001b7d4 <uart_instance>:
   1b7d4:	2000a9e4                                ... 

0001b7d8 <uip_broadcast_addr>:
   1b7d8:	ffffffff                                ....

0001b7dc <uip_all_zeroes_addr>:
   1b7dc:	00000000                                ....

0001b7e0 <broadcast_ethaddr>:
   1b7e0:	ffffffff 0000ffff                       ........

0001b7e8 <http_http>:
   1b7e8:	70747468 002f2f3a                       http://.

0001b7f0 <http_200>:
   1b7f0:	20303032 00000000                       200 ....

0001b7f8 <http_301>:
   1b7f8:	20313033 00000000                       301 ....

0001b800 <http_302>:
   1b800:	20323033 00000000                       302 ....

0001b808 <http_get>:
   1b808:	20544547 00000000                       GET ....

0001b810 <http_10>:
   1b810:	50545448 302e312f 00000000              HTTP/1.0....

0001b81c <http_11>:
   1b81c:	50545448 312e312f 00000000              HTTP/1.1....

0001b828 <http_content_type>:
   1b828:	746e6f63 2d746e65 65707974 0000203a     content-type: ..

0001b838 <http_texthtml>:
   1b838:	74786574 6d74682f 0000006c              text/html...

0001b844 <http_location>:
   1b844:	61636f6c 6e6f6974 0000203a              location: ..

0001b850 <http_host>:
   1b850:	74736f68 0000203a                       host: ..

0001b858 <http_crnl>:
   1b858:	00000a0d                                ....

0001b85c <http_index_html>:
   1b85c:	646e692f 682e7865 006c6d74              /index.html.

0001b868 <http_404_html>:
   1b868:	3430342f 6d74682e 0000006c              /404.html...

0001b874 <http_referer>:
   1b874:	65666552 3a726572 00000000              Referer:....

0001b880 <http_header_200>:
   1b880:	50545448 302e312f 30303220 0d4b4f20     HTTP/1.0 200 OK.
   1b890:	7265530a 3a726576 50497520 302e312f     .Server: uIP/1.0
   1b8a0:	74746820 2f2f3a70 2e777777 73636973      http://www.sics
   1b8b0:	2f65732e 6164617e 69752f6d 0a0d2f70     .se/~adam/uip/..
   1b8c0:	6e6e6f43 69746365 203a6e6f 736f6c63     Connection: clos
   1b8d0:	000a0d65                                e...

0001b8d4 <http_header_404>:
   1b8d4:	50545448 302e312f 34303420 746f4e20     HTTP/1.0 404 Not
   1b8e4:	756f6620 0a0d646e 76726553 203a7265      found..Server: 
   1b8f4:	2f504975 20302e31 70747468 772f2f3a     uIP/1.0 http://w
   1b904:	732e7777 2e736369 7e2f6573 6d616461     ww.sics.se/~adam
   1b914:	7069752f 430a0d2f 656e6e6f 6f697463     /uip/..Connectio
   1b924:	63203a6e 65736f6c 00000a0d              n: close....

0001b930 <http_content_type_plain>:
   1b930:	746e6f43 2d746e65 65707974 6574203a     Content-type: te
   1b940:	702f7478 6e69616c 0a0d0a0d 00000000     xt/plain........

0001b950 <http_content_type_html>:
   1b950:	746e6f43 2d746e65 65707974 6574203a     Content-type: te
   1b960:	682f7478 0d6c6d74 000a0d0a              xt/html.....

0001b96c <http_content_type_css>:
   1b96c:	746e6f43 2d746e65 65707974 6574203a     Content-type: te
   1b97c:	632f7478 0a0d7373 00000a0d              xt/css......

0001b988 <http_content_type_text>:
   1b988:	746e6f43 2d746e65 65707974 6574203a     Content-type: te
   1b998:	742f7478 0d747865 000a0d0a              xt/text.....

0001b9a4 <http_content_type_png>:
   1b9a4:	746e6f43 2d746e65 65707974 6d69203a     Content-type: im
   1b9b4:	2f656761 0d676e70 000a0d0a              age/png.....

0001b9c0 <http_content_type_gif>:
   1b9c0:	746e6f43 2d746e65 65707974 6d69203a     Content-type: im
   1b9d0:	2f656761 0d666967 000a0d0a              age/gif.....

0001b9dc <http_content_type_jpg>:
   1b9dc:	746e6f43 2d746e65 65707974 6d69203a     Content-type: im
   1b9ec:	2f656761 6765706a 0a0d0a0d 00000000     age/jpeg........

0001b9fc <http_content_type_binary>:
   1b9fc:	746e6f43 2d746e65 65707974 7061203a     Content-type: ap
   1ba0c:	63696c70 6f697461 636f2f6e 2d746574     plication/octet-
   1ba1c:	65727473 0a0d6d61 00000a0d              stream......

0001ba28 <http_html>:
   1ba28:	6d74682e 0000006c                       .html...

0001ba30 <http_shtml>:
   1ba30:	7468732e 00006c6d                       .shtml..

0001ba38 <http_htm>:
   1ba38:	6d74682e 00000000                       .htm....

0001ba40 <http_css>:
   1ba40:	7373632e 00000000                       .css....

0001ba48 <http_png>:
   1ba48:	676e702e 00000000                       .png....

0001ba50 <http_gif>:
   1ba50:	6669672e 00000000                       .gif....

0001ba58 <http_jpg>:
   1ba58:	67706a2e 00000000                       .jpg....

0001ba60 <http_text>:
   1ba60:	7478742e 00000000                       .txt....

0001ba68 <http_txt>:
   1ba68:	7478742e 00000000                       .txt....

0001ba70 <data_404_html>:
   1ba70:	3430342f 6d74682e 683c006c 3e6c6d74     /404.html.<html>
   1ba80:	20200a0d 646f623c 67622079 6f6c6f63     ..  <body bgcolo
   1ba90:	77223d72 65746968 0a0d3e22 20202020     r="white">..    
   1baa0:	6e65633c 3e726574 20200a0d 20202020     <center>..      
   1bab0:	3e31683c 20343034 6966202d 6e20656c     <h1>404 - file n
   1bac0:	6620746f 646e756f 31682f3c 200a0d3e     ot found</h1>.. 
   1bad0:	20202020 33683c20 206f473e 6820613c          <h3>Go <a h
   1bae0:	3d666572 3e222f22 65726568 3e612f3c     ref="/">here</a>
   1baf0:	736e6920 64616574 682f3c2e 0a0d3e33      instead.</h3>..
   1bb00:	20202020 65632f3c 7265746e 200a0d3e         </center>.. 
   1bb10:	622f3c20 3e79646f 2f3c0a0d 6c6d7468      </body>..</html
   1bb20:	0000003e                                >...

0001bb24 <data_index_html>:
   1bb24:	646e692f 682e7865 006c6d74 4f44213c     /index.html.<!DO
   1bb34:	50595443 74682045 0d3e6c6d 74683c0a     CTYPE html>..<ht
   1bb44:	0d3e6c6d 3c0a0d0a 64616568 200a0d3e     ml>....<head>.. 
   1bb54:	3c202020 6174656d 74746820 71652d70        <meta http-eq
   1bb64:	3d766975 6e6f4322 746e6574 7079542d     uiv="Content-Typ
   1bb74:	63202265 65746e6f 223d746e 74786574     e" content="text
   1bb84:	6d74682f 63203b6c 73726168 753d7465     /html; charset=u
   1bb94:	382d6674 3e2f2022 20200a0d 743c2020     tf-8" />..    <t
   1bba4:	656c7469 6572463e 4f545265 726f2e53     itle>FreeRTOS.or
   1bbb4:	49752067 45572050 65732042 72657672     g uIP WEB server
   1bbc4:	6d656420 742f3c6f 656c7469 3c0a0d3e      demo</title>..<
   1bbd4:	6165682f 0a0d3e64 623c0a0d 3e79646f     /head>....<body>
   1bbe4:	20200a0d 663c2020 20746e6f 65636166     ..    <font face
   1bbf4:	7261223d 226c6169 200a0d3e 20202020     ="arial">..     
   1bc04:	3c202020 72682061 223d6665 65646e69        <a href="inde
   1bc14:	74682e78 3e226c6d 6b736154 61745320     x.html">Task Sta
   1bc24:	73737374 2f3c7373 3c203e61 3c7c3e62     tsssss</a> <b>|<
   1bc34:	203e622f 6820613c 3d666572 6e757222     /b> <a href="run
   1bc44:	656d6974 7468732e 3e226c6d 206e7552     time.shtml">Run 
   1bc54:	656d6954 61745320 2f3c7374 3c203e61     Time Stats</a> <
   1bc64:	3c7c3e62 203e622f 6820613c 3d666572     b>|</b> <a href=
   1bc74:	61747322 732e7374 6c6d7468 43543e22     "stats.shtml">TC
   1bc84:	74532050 3c737461 203e612f 7c3e623c     P Stats</a> <b>|
   1bc94:	3e622f3c 20613c20 66657268 6374223d     </b> <a href="tc
   1bca4:	68732e70 226c6d74 6e6f433e 7463656e     p.shtml">Connect
   1bcb4:	736e6f69 3e612f3c 3e623c20 622f3c7c     ions</a> <b>|</b
   1bcc4:	613c203e 65726820 68223d66 3a707474     > <a href="http:
   1bcd4:	77772f2f 72662e77 74726565 6f2e736f     //www.freertos.o
   1bce4:	222f6772 6572463e 4f545265 6f482053     rg/">FreeRTOS Ho
   1bcf4:	6170656d 2f3c6567 20203e61 20202020     mepage</a>      
   1bd04:	623c2020 2f3c7c3e 3c203e62 72682061       <b>|</b> <a hr
   1bd14:	223d6665 732e6f69 6c6d7468 4f493e22     ef="io.shtml">IO
   1bd24:	3e612f3c 3e623c20 622f3c7c 613c203e     </a> <b>|</b> <a
   1bd34:	65726820 6c223d66 2e6f676f 2267706a      href="logo.jpg"
   1bd44:	4b37333e 67706a20 3e612f3c 20200a0d     >37K jpg</a>..  
   1bd54:	20202020 623c2020 0a0d3e72 20202020           <br>..    
   1bd64:	20202020 0d3e703c 2020200a 20202020         <p>..       
   1bd74:	20202020 72683c20 200a0d3e 20202020          <hr>..     
   1bd84:	20202020 3c202020 0d3e7262 2020200a            <br>..   
   1bd94:	20202020 20202020 3e703c20 20200a0d              <p>..  
   1bda4:	20202020 20202020 20202020 703c2020                   <p
   1bdb4:	6968543e 61702073 69206567 69732073     >This page is si
   1bdc4:	616c696d 6f742072 65687420 6d6f6820     milar to the hom
   1bdd4:	61702065 62206567 75207475 20736573     e page but uses 
   1bde4:	53626557 656b636f 66207374 7220726f     WebSockets for r
   1bdf4:	2d6c6165 656d6974 64707520 73657461     eal-time updates
   1be04:	702f3c2e 200a0d3e 20202020 20202020     .</p>..         
   1be14:	20202020 3c202020 20766964 73616c63            <div clas
   1be24:	63223d73 7265766f 0a0d3e22 20202020     s="cover">..    
   1be34:	20202020 20202020 20202020 20202020                     
   1be44:	6e61633c 20736176 223d6469 72616863     <canvas id="char
   1be54:	6e614374 22736176 64697720 223d6874     tCanvas" width="
   1be64:	22323135 69656820 3d746867 30303122     512" height="100
   1be74:	2f3c3e22 766e6163 0d3e7361 2020200a     "></canvas>..   
   1be84:	20202020 20202020 20202020 642f3c20                  </d
   1be94:	0d3e7669 200a0d0a 20202020 20202020     iv>....         
   1bea4:	20202020 3c202020 543e3268 206b7361            <h2>Task 
   1beb4:	74617473 69747369 65207363 65746964     statistics edite
   1bec4:	682f3c64 0a0d3e32 20200a0d 20202020     d</h2>....      
   1bed4:	20202020 20202020 623c2020 44454c3e               <b>LED
   1bee4:	646e6120 44434c20 3c4f4920 3c3e622f      and LCD IO</b><
   1bef4:	0d3e7262 200a0d0a 20202020 20202020     br>....         
   1bf04:	20202020 3c202020 0a0d3e70 20202020            <p>..    
   1bf14:	20202020 20202020 20202020 20202020                     
   1bf24:	20657355 20656874 63656863 6f62206b     Use the check bo
   1bf34:	6f742078 72757420 6e6f206e 20726f20     x to turn on or 
   1bf44:	2066666f 2044454c 74202c34 206e6568     off LED 4, then 
   1bf54:	63696c63 5522206b 74616470 4f492065     click "Update IO
   1bf64:	0a0d2e22 0a0d0a0d 20202020 20202020     ".......        
   1bf74:	20202020 20202020 20202020 0d3e703c                 <p>.
   1bf84:	2020200a 20202020 20202020 20202020     .               
   1bf94:	20202020 20202020 6f663c20 6e206d72              <form n
   1bfa4:	3d656d61 6f466122 20226d72 69746361     ame="aForm" acti
   1bfb4:	223d6e6f 646e692f 682e7865 226c6d74     on="/index.html"
   1bfc4:	74656d20 3d646f68 74656722 0a0d3e22      method="get">..
   1bfd4:	20202020 20202020 20202020 20202020                     
   1bfe4:	20202020 20202020 20202020 70202125                 %! p
   1bff4:	762d746f 61746c6f 0a0d6567 20202020     ot-voltage..    
   1c004:	20202020 20202020 20202020 20202020                     
   1c014:	20202020 20202020 0d3e703c 2020200a             <p>..   
   1c024:	20202020 20202020 20202020 20202020                     
   1c034:	20202020 20202020 20202020 6e693c20                  <in
   1c044:	20747570 65707974 7573223d 74696d62     put type="submit
   1c054:	61762022 3d65756c 64705522 20657461     " value="Update 
   1c064:	3e224f49 20200a0d 20202020 20202020     IO">..          
   1c074:	20202020 20202020 20202020 2f3c2020                   </
   1c084:	6d726f66 200a0d3e 20202020 20202020     form>..         
   1c094:	20202020 20202020 20202020 3c202020                    <
   1c0a4:	0d3e7262 2020200a 20202020 20202020     br>..           
   1c0b4:	20202020 20202020 20202020 3e703c20                  <p>
   1c0c4:	0a0d0a0d 20202020 6f662f3c 0d3e746e     ....    </font>.
   1c0d4:	0d0a0d0a 3c0a0d0a 646f622f 0a0d3e79     .......</body>..
   1c0e4:	2f3c0a0d 6c6d7468 0000003e              ..</html>...

0001c0f0 <data_io_shtml>:
   1c0f0:	2e6f692f 6d746873 213c006c 54434f44     /io.shtml.<!DOCT
   1c100:	20455059 4c4d5448 42555020 2043494c     YPE HTML PUBLIC 
   1c110:	2f2f2d22 2f433357 4454442f 4d544820     "-//W3C//DTD HTM
   1c120:	2e34204c 54203130 736e6172 6f697469     L 4.01 Transitio
   1c130:	2f6c616e 224e452f 74682220 2f3a7074     nal//EN" "http:/
   1c140:	7777772f 2e33772e 2f67726f 682f5254     /www.w3.org/TR/h
   1c150:	346c6d74 6f6f6c2f 642e6573 3e226474     tml4/loose.dtd">
   1c160:	683c0a0d 3e6c6d74 0a0d0a0d 6165683c     ..<html>....<hea
   1c170:	0a0d3e64 20202020 7469743c 463e656c     d>..    <title>F
   1c180:	52656572 2e534f54 2067726f 20504975     reeRTOS.org uIP 
   1c190:	20424557 76726573 64207265 3c6f6d65     WEB server demo<
   1c1a0:	7469742f 0d3e656c 682f3c0a 3e646165     /title>..</head>
   1c1b0:	0a0d0a0d 0a0d0a0d 646f623c 0a0d3e79     ........<body>..
   1c1c0:	20202020 6e6f663c 61662074 223d6563         <font face="
   1c1d0:	61697261 0d3e226c 2020200a 20202020     arial">..       
   1c1e0:	20613c20 66657268 6e69223d 2e786564      <a href="index.
   1c1f0:	6d746873 543e226c 206b7361 74617453     shtml">Task Stat
   1c200:	612f3c73 623c203e 2f3c7c3e 3c203e62     s</a> <b>|</b> <
   1c210:	72682061 223d6665 746e7572 2e656d69     a href="runtime.
   1c220:	6d746873 523e226c 54206e75 20656d69     shtml">Run Time 
   1c230:	74617453 612f3c73 623c203e 2f3c7c3e     Stats</a> <b>|</
   1c240:	3c203e62 72682061 223d6665 74617473     b> <a href="stat
   1c250:	68732e73 226c6d74 5043543e 61745320     s.shtml">TCP Sta
   1c260:	2f3c7374 3c203e61 3c7c3e62 203e622f     ts</a> <b>|</b> 
   1c270:	6820613c 3d666572 70637422 7468732e     <a href="tcp.sht
   1c280:	3e226c6d 6e6e6f43 69746365 3c736e6f     ml">Connections<
   1c290:	203e612f 7c3e623c 3e622f3c 20613c20     /a> <b>|</b> <a 
   1c2a0:	66657268 7468223d 2f3a7074 7777772f     href="http://www
   1c2b0:	6572662e 6f747265 726f2e73 3e222f67     .freertos.org/">
   1c2c0:	65657246 534f5452 6d6f4820 67617065     FreeRTOS Homepag
   1c2d0:	612f3c65 2020203e 20202020 3e623c20     e</a>        <b>
   1c2e0:	622f3c7c 613c203e 65726820 69223d66     |</b> <a href="i
   1c2f0:	68732e6f 226c6d74 3c4f493e 203e612f     o.shtml">IO</a> 
   1c300:	7c3e623c 3e622f3c 20613c20 66657268     <b>|</b> <a href
   1c310:	6f6c223d 6a2e6f67 3e226770 204b3733     ="logo.jpg">37K 
   1c320:	3c67706a 0d3e612f 2020200a 20202020     jpg</a>..       
   1c330:	72623c20 200a0d3e 20202020 3c202020      <br>..        <
   1c340:	0a0d3e70 20202020 20202020 20202020     p>..            
   1c350:	3e72683c 20200a0d 20202020 20202020     <hr>..          
   1c360:	623c2020 44454c3e 646e6120 44434c20       <b>LED and LCD
   1c370:	3c4f4920 3c3e622f 0d3e7262 2020200a      IO</b><br>..   
   1c380:	20202020 20202020 3e703c20 0a0d0a0d              <p>....
   1c390:	20202020 20202020 20202020 20202020                     
   1c3a0:	553e703c 74206573 63206568 6b636568     <p>Use the check
   1c3b0:	786f6220 206f7420 6e727574 206e6f20      box to turn on 
   1c3c0:	6f20726f 4c206666 34204445 6874202c     or off LED 4, th
   1c3d0:	63206e65 6b63696c 70552220 65746164     en click "Update
   1c3e0:	224f4920 702f3c2e 200a0d3e 20202020      IO".</p>..     
   1c3f0:	20202020 20202020 3c202020 0a0d3e70                <p>..
   1c400:	20202020 20202020 20202020 20202020                     
   1c410:	20202020 726f663c 616e206d 223d656d         <form name="
   1c420:	726f4661 6120226d 6f697463 2f223d6e     aForm" action="/
   1c430:	732e6f69 6c6d7468 656d2022 646f6874     io.shtml" method
   1c440:	6567223d 0d3e2274 2020200a 20202020     ="get">..       
   1c450:	20202020 20202020 20202020 20202020                     
   1c460:	20212520 2d64656c 0a0d6f69 20202020      %! led-io..    
   1c470:	20202020 20202020 20202020 20202020                     
   1c480:	20202020 0d3e703c 2020200a 20202020         <p>..       
   1c490:	20202020 20202020 20202020 20202020                     
   1c4a0:	20202020 6e693c20 20747570 65707974          <input type
   1c4b0:	7573223d 74696d62 61762022 3d65756c     ="submit" value=
   1c4c0:	64705522 20657461 3e224f49 20200a0d     "Update IO">..  
   1c4d0:	20202020 20202020 20202020 20202020                     
   1c4e0:	2f3c2020 6d726f66 200a0d3e 20202020       </form>..     
   1c4f0:	20202020 20202020 20202020 3c202020                    <
   1c500:	0d3e7262 2020200a 20202020 20202020     br>..           
   1c510:	20202020 20202020 3e703c20 20200a0d              <p>..  
   1c520:	2f3c2020 746e6f66 0d0a0d3e 2020200a       </font>....   
   1c530:	69643c20 6c632076 3d737361 766f6322      <div class="cov
   1c540:	3e227265 20200a0d 20202020 633c2020     er">..        <c
   1c550:	61766e61 64692073 6863223d 43747261     anvas id="chartC
   1c560:	61766e61 77202273 68746469 3135223d     anvas" width="51
   1c570:	68202232 68676965 31223d74 3e223030     2" height="100">
   1c580:	61632f3c 7361766e 200a0d3e 3c202020     </canvas>..    <
   1c590:	7669642f 0d0a0d3e 2020200a 20703c20     /div>....    <p 
   1c5a0:	223d6469 6f6d6564 2f3c3e22 0a0d3e70     id="demo"></p>..
   1c5b0:	0a0d0a0d 20202020 7263733c 3e747069     ....    <script>
   1c5c0:	20200a0d 20202020 20212020 636e7566     ..        ! func
   1c5d0:	6e6f6974 20296528 200a0d7b 20202020     tion(e) {..     
   1c5e0:	20202020 76202020 74207261 7b203d20            var t = {
   1c5f0:	20200a0d 20202020 20202020 20202020     ..              
   1c600:	78652020 646e6574 7566203a 6974636e       extend: functi
   1c610:	29286e6f 0a0d7b20 20202020 20202020     on() {..        
   1c620:	20202020 20202020 20202020 75677261                 argu
   1c630:	746e656d 5d305b73 61203d20 6d756772     ments[0] = argum
   1c640:	73746e65 205d305b 7b207c7c 0a0d3b7d     ents[0] || {};..
   1c650:	20202020 20202020 20202020 20202020                     
   1c660:	20202020 20726f66 72617628 3d206520         for (var e =
   1c670:	203b3120 203c2065 75677261 746e656d      1; e < argument
   1c680:	656c2e73 6874676e 2065203b 31203d2b     s.length; e += 1
   1c690:	200a0d29 20202020 20202020 20202020     )..             
   1c6a0:	20202020 20202020 66202020 2820726f                for (
   1c6b0:	20726176 6e692069 67726120 6e656d75     var i in argumen
   1c6c0:	655b7374 6120295d 6d756772 73746e65     ts[e]) arguments
   1c6d0:	2e5d655b 4f736168 72506e77 7265706f     [e].hasOwnProper
   1c6e0:	69287974 26262029 6f222820 63656a62     ty(i) && ("objec
   1c6f0:	3d202274 7974203d 666f6570 67726120     t" == typeof arg
   1c700:	6e656d75 655b7374 5d695b5d 61203f20     uments[e][i] ? a
   1c710:	6d756772 73746e65 5b5d655b 69205d69     rguments[e][i] i
   1c720:	6174736e 6f65636e 72412066 20796172     nstanceof Array 
   1c730:	7261203f 656d7567 5b73746e 695b5d30     ? arguments[0][i
   1c740:	203d205d 75677261 746e656d 5d655b73     ] = arguments[e]
   1c750:	205d695b 7261203a 656d7567 5b73746e     [i] : arguments[
   1c760:	695b5d30 203d205d 78652e74 646e6574     0][i] = t.extend
   1c770:	67726128 6e656d75 305b7374 5d695b5d     (arguments[0][i]
   1c780:	7261202c 656d7567 5b73746e 695b5d65     , arguments[e][i
   1c790:	3a20295d 67726120 6e656d75 305b7374     ]) : arguments[0
   1c7a0:	5d695b5d 61203d20 6d756772 73746e65     ][i] = arguments
   1c7b0:	5b5d655b 3b295d69 20200a0d 20202020     [e][i]);..      
   1c7c0:	20202020 20202020 20202020 65722020                   re
   1c7d0:	6e727574 67726120 6e656d75 305b7374     turn arguments[0
   1c7e0:	200a0d5d 20202020 20202020 20202020     ]..             
   1c7f0:	7d202020 20200a0d 20202020 20202020        }..          
   1c800:	3b7d2020 0a0d0a0d 20202020 20202020       };....        
   1c810:	20202020 636e7566 6e6f6974 65286920         function i(e
   1c820:	0d7b2029 2020200a 20202020 20202020     ) {..           
   1c830:	20202020 69687420 706f2e73 6e6f6974          this.option
   1c840:	203d2073 78652e74 646e6574 2c7d7b28     s = t.extend({},
   1c850:	642e6920 75616665 704f746c 6e6f6974      i.defaultOption
   1c860:	65202c73 74202c29 2e736968 61656c63     s, e), this.clea
   1c870:	0d292872 2020200a 20202020 20202020     r()..           
   1c880:	0a0d7d20 20200a0d 20202020 20202020      }....          
   1c890:	75662020 6974636e 61206e6f 20296528       function a(e) 
   1c8a0:	200a0d7b 20202020 20202020 20202020     {..             
   1c8b0:	74202020 2e736968 6974706f 20736e6f        this.options 
   1c8c0:	2e74203d 65747865 7b28646e 61202c7d     = t.extend({}, a
   1c8d0:	6665642e 746c7561 72616843 74704f74     .defaultChartOpt
   1c8e0:	736e6f69 2965202c 6874202c 732e7369     ions, e), this.s
   1c8f0:	65697265 74655373 5b203d20 74202c5d     eriesSet = [], t
   1c900:	2e736968 72727563 56746e65 65756c61     his.currentValue
   1c910:	676e6152 203d2065 74202c31 2e736968     Range = 1, this.
   1c920:	72727563 56746e65 694d7369 6c61566e     currentVisMinVal
   1c930:	3d206575 202c3020 73696874 73616c2e     ue = 0, this.las
   1c940:	6e655274 54726564 4d656d69 696c6c69     tRenderTimeMilli
   1c950:	203d2073 200a0d30 20202020 20202020     s = 0..         
   1c960:	7d202020 20200a0d 20202020 20202020        }..          
   1c970:	2e692020 61666564 4f746c75 6f697470       i.defaultOptio
   1c980:	3d20736e 0a0d7b20 20202020 20202020     ns = {..        
   1c990:	20202020 20202020 65736572 756f4274             resetBou
   1c9a0:	4973646e 7265746e 3a6c6176 33653320     ndsInterval: 3e3
   1c9b0:	200a0d2c 20202020 20202020 20202020     ,..             
   1c9c0:	72202020 74657365 6e756f42 203a7364        resetBounds: 
   1c9d0:	0a0d3021 20202020 20202020 20202020     !0..            
   1c9e0:	69202c7d 6f72702e 79746f74 632e6570     }, i.prototype.c
   1c9f0:	7261656c 66203d20 74636e75 286e6f69     lear = function(
   1ca00:	0d7b2029 2020200a 20202020 20202020     ) {..           
   1ca10:	20202020 69687420 61642e73 3d206174          this.data =
   1ca20:	2c5d5b20 69687420 616d2e73 6c615678      [], this.maxVal
   1ca30:	3d206575 6d754e20 2e726562 2c4e614e     ue = Number.NaN,
   1ca40:	69687420 696d2e73 6c61566e 3d206575      this.minValue =
   1ca50:	6d754e20 2e726562 0d4e614e 2020200a      Number.NaN..   
   1ca60:	20202020 20202020 202c7d20 72702e69              }, i.pr
   1ca70:	746f746f 2e657079 65736572 756f4274     ototype.resetBou
   1ca80:	2073646e 7566203d 6974636e 29286e6f     nds = function()
   1ca90:	0a0d7b20 20202020 20202020 20202020      {..            
   1caa0:	20202020 28206669 73696874 7461642e         if (this.dat
   1cab0:	656c2e61 6874676e 0d7b2029 2020200a     a.length) {..   
   1cac0:	20202020 20202020 20202020 20202020                     
   1cad0:	69687420 616d2e73 6c615678 3d206575      this.maxValue =
   1cae0:	69687420 61642e73 305b6174 5d315b5d      this.data[0][1]
   1caf0:	6874202c 6d2e7369 61566e69 2065756c     , this.minValue 
   1cb00:	6874203d 642e7369 5b617461 315b5d30     = this.data[0][1
   1cb10:	0a0d3b5d 20202020 20202020 20202020     ];..            
   1cb20:	20202020 20202020 20726f66 72617628             for (var
   1cb30:	3d206520 203b3120 203c2065 73696874      e = 1; e < this
   1cb40:	7461642e 656c2e61 6874676e 2065203b     .data.length; e 
   1cb50:	31203d2b 0d7b2029 2020200a 20202020     += 1) {..       
   1cb60:	20202020 20202020 20202020 20202020                     
   1cb70:	72617620 3d207420 69687420 61642e73      var t = this.da
   1cb80:	655b6174 5d315b5d 200a0d3b 20202020     ta[e][1];..     
   1cb90:	20202020 20202020 20202020 20202020                     
   1cba0:	74202020 74203e20 2e736968 5678616d        t > this.maxV
   1cbb0:	65756c61 20262620 69687428 616d2e73     alue && (this.ma
   1cbc0:	6c615678 3d206575 2c297420 3c207420     xValue = t), t <
   1cbd0:	69687420 696d2e73 6c61566e 26206575      this.minValue &
   1cbe0:	74282026 2e736968 566e696d 65756c61     & (this.minValue
   1cbf0:	74203d20 200a0d29 20202020 20202020      = t)..         
   1cc00:	20202020 20202020 7d202020 20200a0d                }..  
   1cc10:	20202020 20202020 20202020 207d2020                   } 
   1cc20:	65736c65 69687420 616d2e73 6c615678     else this.maxVal
   1cc30:	3d206575 6d754e20 2e726562 2c4e614e     ue = Number.NaN,
   1cc40:	69687420 696d2e73 6c61566e 3d206575      this.minValue =
   1cc50:	6d754e20 2e726562 0d4e614e 2020200a      Number.NaN..   
   1cc60:	20202020 20202020 202c7d20 72702e69              }, i.pr
   1cc70:	746f746f 2e657079 65707061 3d20646e     ototype.append =
   1cc80:	6e756620 6f697463 2c65286e 202c7420      function(e, t, 
   1cc90:	7b202969 20200a0d 20202020 20202020     i) {..          
   1cca0:	20202020 6f662020 76282072 61207261           for (var a
   1ccb0:	74203d20 2e736968 61746164 6e656c2e      = this.data.len
   1ccc0:	20687467 3b31202d 3e206120 2030203d     gth - 1; a >= 0 
   1ccd0:	74202626 2e736968 61746164 5b5d615b     && this.data[a][
   1cce0:	3e205d30 293b6520 2d206120 3b31203d     0] > e;) a -= 1;
   1ccf0:	31202d20 3d3d3d20 3f206120 69687420      - 1 === a ? thi
   1cd00:	61642e73 732e6174 63696c70 2c302865     s.data.splice(0,
   1cd10:	202c3020 202c655b 20295d74 6874203a      0, [e, t]) : th
   1cd20:	642e7369 2e617461 676e656c 3e206874     is.data.length >
   1cd30:	26203020 68742026 642e7369 5b617461      0 && this.data[
   1cd40:	305b5d61 3d3d205d 2065203d 2069203f     a][0] === e ? i 
   1cd50:	7428203f 2e736968 61746164 5b5d615b     ? (this.data[a][
   1cd60:	2b205d31 2c74203d 3d207420 69687420     1] += t, t = thi
   1cd70:	61642e73 615b6174 5d315b5d 203a2029     s.data[a][1]) : 
   1cd80:	73696874 7461642e 5d615b61 205d315b     this.data[a][1] 
   1cd90:	2074203d 2061203a 6874203c 642e7369     = t : a < this.d
   1cda0:	2e617461 676e656c 2d206874 3f203120     ata.length - 1 ?
   1cdb0:	69687420 61642e73 732e6174 63696c70      this.data.splic
   1cdc0:	20612865 2c31202b 202c3020 202c655b     e(a + 1, 0, [e, 
   1cdd0:	20295d74 6874203a 642e7369 2e617461     t]) : this.data.
   1cde0:	68737570 2c655b28 295d7420 6874202c     push([e, t]), th
   1cdf0:	6d2e7369 61567861 2065756c 7369203d     is.maxValue = is
   1ce00:	284e614e 73696874 78616d2e 756c6156     NaN(this.maxValu
   1ce10:	3f202965 3a207420 74614d20 616d2e68     e) ? t : Math.ma
   1ce20:	68742878 6d2e7369 61567861 2c65756c     x(this.maxValue,
   1ce30:	2c297420 69687420 696d2e73 6c61566e      t), this.minVal
   1ce40:	3d206575 4e736920 74284e61 2e736968     ue = isNaN(this.
   1ce50:	566e696d 65756c61 203f2029 203a2074     minValue) ? t : 
   1ce60:	6874614d 6e696d2e 69687428 696d2e73     Math.min(this.mi
   1ce70:	6c61566e 202c6575 0a0d2974 20202020     nValue, t)..    
   1ce80:	20202020 20202020 69202c7d 6f72702e             }, i.pro
   1ce90:	79746f74 642e6570 4f706f72 6144646c     totype.dropOldDa
   1cea0:	3d206174 6e756620 6f697463 2c65286e     ta = function(e,
   1ceb0:	20297420 200a0d7b 20202020 20202020      t) {..         
   1cec0:	20202020 66202020 2820726f 20726176            for (var 
   1ced0:	203d2069 74203b30 2e736968 61746164     i = 0; this.data
   1cee0:	6e656c2e 20687467 2069202d 74203d3e     .length - i >= t
   1cef0:	20262620 73696874 7461642e 20695b61      && this.data[i 
   1cf00:	5d31202b 205d305b 3b65203c 20692029     + 1][0] < e;) i 
   1cf10:	31203d2b 200a0d3b 20202020 20202020     += 1;..         
   1cf20:	20202020 30202020 3d3d2120 26206920            0 !== i &
   1cf30:	68742026 642e7369 2e617461 696c7073     & this.data.spli
   1cf40:	30286563 2969202c 20200a0d 20202020     ce(0, i)..      
   1cf50:	20202020 2c7d2020 642e6120 75616665           }, a.defau
   1cf60:	6843746c 4f747261 6f697470 3d20736e     ltChartOptions =
   1cf70:	0a0d7b20 20202020 20202020 20202020      {..            
   1cf80:	20202020 6c6c696d 65507369 78695072         millisPerPix
   1cf90:	203a6c65 0d2c3032 2020200a 20202020     el: 20,..       
   1cfa0:	20202020 20202020 616e6520 44656c62              enableD
   1cfb0:	63536970 6e696c61 21203a67 0a0d2c30     piScaling: !0,..
   1cfc0:	20202020 20202020 20202020 20202020                     
   1cfd0:	6e694d79 6d726f46 65747461 66203a72     yMinFormatter: f
   1cfe0:	74636e75 286e6f69 74202c65 0d7b2029     unction(e, t) {.
   1cff0:	2020200a 20202020 20202020 20202020     .               
   1d000:	20202020 74657220 206e7275 73726170          return pars
   1d010:	6f6c4665 65287461 6f742e29 65786946     eFloat(e).toFixe
   1d020:	29742864 20200a0d 20202020 20202020     d(t)..          
   1d030:	20202020 2c7d2020 20200a0d 20202020           },..      
   1d040:	20202020 20202020 4d792020 6f467861               yMaxFo
   1d050:	74616d72 3a726574 6e756620 6f697463     rmatter: functio
   1d060:	2c65286e 20297420 200a0d7b 20202020     n(e, t) {..     
   1d070:	20202020 20202020 20202020 72202020                    r
   1d080:	72757465 6170206e 46657372 74616f6c     eturn parseFloat
   1d090:	2e296528 69466f74 28646578 0a0d2974     (e).toFixed(t)..
   1d0a0:	20202020 20202020 20202020 20202020                     
   1d0b0:	0a0d2c7d 20202020 20202020 20202020     },..            
   1d0c0:	20202020 5678616d 65756c61 6c616353         maxValueScal
   1d0d0:	31203a65 200a0d2c 20202020 20202020     e: 1,..         
   1d0e0:	20202020 6d202020 61566e69 5365756c            minValueS
   1d0f0:	656c6163 2c31203a 20200a0d 20202020     cale: 1,..      
   1d100:	20202020 20202020 6e692020 70726574               interp
   1d110:	74616c6f 3a6e6f69 65622220 7265697a     olation: "bezier
   1d120:	0a0d2c22 20202020 20202020 20202020     ",..            
   1d130:	20202020 6c616373 6f6d5365 6968746f         scaleSmoothi
   1d140:	203a676e 3532312e 200a0d2c 20202020     ng: .125,..     
   1d150:	20202020 20202020 6d202020 61447861                maxDa
   1d160:	65536174 6e654c74 3a687467 0d2c3220     taSetLength: 2,.
   1d170:	2020200a 20202020 20202020 20202020     .               
   1d180:	72637320 426c6c6f 776b6361 73647261      scrollBackwards
   1d190:	3121203a 200a0d2c 20202020 20202020     : !1,..         
   1d1a0:	20202020 67202020 3a646972 0a0d7b20            grid: {..
   1d1b0:	20202020 20202020 20202020 20202020                     
   1d1c0:	20202020 6c6c6966 6c797453 22203a65         fillStyle: "
   1d1d0:	30303023 22303030 200a0d2c 20202020     #000000",..     
   1d1e0:	20202020 20202020 20202020 73202020                    s
   1d1f0:	6b6f7274 79745365 203a656c 37372322     trokeStyle: "#77
   1d200:	37373737 0a0d2c22 20202020 20202020     7777",..        
   1d210:	20202020 20202020 20202020 656e696c                 line
   1d220:	74646957 31203a68 200a0d2c 20202020     Width: 1,..     
   1d230:	20202020 20202020 20202020 73202020                    s
   1d240:	70726168 656e694c 21203a73 0a0d2c31     harpLines: !1,..
   1d250:	20202020 20202020 20202020 20202020                     
   1d260:	20202020 6c6c696d 65507369 6e694c72         millisPerLin
   1d270:	31203a65 0d2c3365 2020200a 20202020     e: 1e3,..       
   1d280:	20202020 20202020 20202020 72657620                  ver
   1d290:	61636974 6365536c 6e6f6974 32203a73     ticalSections: 2
   1d2a0:	200a0d2c 20202020 20202020 20202020     ,..             
   1d2b0:	20202020 62202020 6564726f 73695672            borderVis
   1d2c0:	656c6269 3021203a 20200a0d 20202020     ible: !0..      
   1d2d0:	20202020 20202020 2c7d2020 20200a0d               },..  
   1d2e0:	20202020 20202020 20202020 616c2020                   la
   1d2f0:	736c6562 0d7b203a 2020200a 20202020     bels: {..       
   1d300:	20202020 20202020 20202020 6c696620                  fil
   1d310:	7974536c 203a656c 66662322 66666666     lStyle: "#ffffff
   1d320:	0a0d2c22 20202020 20202020 20202020     ",..            
   1d330:	20202020 20202020 61736964 64656c62             disabled
   1d340:	3121203a 200a0d2c 20202020 20202020     : !1,..         
   1d350:	20202020 20202020 66202020 53746e6f                fontS
   1d360:	3a657a69 2c303120 20200a0d 20202020     ize: 10,..      
   1d370:	20202020 20202020 20202020 6f662020                   fo
   1d380:	6146746e 796c696d 6d22203a 736f6e6f     ntFamily: "monos
   1d390:	65636170 0a0d2c22 20202020 20202020     pace",..        
   1d3a0:	20202020 20202020 20202020 63657270                 prec
   1d3b0:	6f697369 32203a6e 20200a0d 20202020     ision: 2..      
   1d3c0:	20202020 20202020 2c7d2020 20200a0d               },..  
   1d3d0:	20202020 20202020 20202020 6f682020                   ho
   1d3e0:	6f7a6972 6c61746e 656e694c 5b203a73     rizontalLines: [
   1d3f0:	200a0d5d 20202020 20202020 7d202020     ]..            }
   1d400:	2e61202c 6d696e41 43657461 61706d6f     , a.AnimateCompa
   1d410:	69626974 7974696c 7b203d20 20200a0d     tibility = {..  
   1d420:	20202020 20202020 20202020 65722020                   re
   1d430:	73657571 696e4174 6974616d 72466e6f     questAnimationFr
   1d440:	3a656d61 6e756620 6f697463 2c65286e     ame: function(e,
   1d450:	20297420 200a0d7b 20202020 20202020      t) {..         
   1d460:	20202020 20202020 72202020 72757465                retur
   1d470:	7728206e 6f646e69 65722e77 73657571     n (window.reques
   1d480:	696e4174 6974616d 72466e6f 20656d61     tAnimationFrame 
   1d490:	77207c7c 6f646e69 65772e77 74696b62     || window.webkit
   1d4a0:	75716552 41747365 616d696e 6e6f6974     RequestAnimation
   1d4b0:	6d617246 7c7c2065 6e697720 2e776f64     Frame || window.
   1d4c0:	527a6f6d 65757165 6e417473 74616d69     mozRequestAnimat
   1d4d0:	466e6f69 656d6172 207c7c20 646e6977     ionFrame || wind
   1d4e0:	6f2e776f 75716552 41747365 616d696e     ow.oRequestAnima
   1d4f0:	6e6f6974 6d617246 7c7c2065 6e697720     tionFrame || win
   1d500:	2e776f64 6552736d 73657571 696e4174     dow.msRequestAni
   1d510:	6974616d 72466e6f 20656d61 66207c7c     mationFrame || f
   1d520:	74636e75 286e6f69 7b202965 20200a0d     unction(e) {..  
   1d530:	20202020 20202020 20202020 20202020                     
   1d540:	20202020 65722020 6e727574 6e697720           return win
   1d550:	2e776f64 54746573 6f656d69 66287475     dow.setTimeout(f
   1d560:	74636e75 286e6f69 0d7b2029 2020200a     unction() {..   
   1d570:	20202020 20202020 20202020 20202020                     
   1d580:	20202020 20202020 28286520 2077656e              e((new 
   1d590:	65746144 65672e29 6d695474 29292865     Date).getTime())
   1d5a0:	20200a0d 20202020 20202020 20202020     ..              
   1d5b0:	20202020 20202020 2c7d2020 29363120               }, 16)
   1d5c0:	20200a0d 20202020 20202020 20202020     ..              
   1d5d0:	20202020 297d2020 6c61632e 6977286c           }).call(wi
   1d5e0:	776f646e 2c65202c 0d297420 2020200a     ndow, e, t)..   
   1d5f0:	20202020 20202020 20202020 0d2c7d20                  },.
   1d600:	2020200a 20202020 20202020 20202020     .               
   1d610:	6e616320 416c6563 616d696e 6e6f6974      cancelAnimation
   1d620:	6d617246 66203a65 74636e75 286e6f69     Frame: function(
   1d630:	7b202965 20200a0d 20202020 20202020     e) {..          
   1d640:	20202020 20202020 65722020 6e727574               return
   1d650:	69772820 776f646e 6e61632e 416c6563      (window.cancelA
   1d660:	616d696e 6e6f6974 6d617246 7c7c2065     nimationFrame ||
   1d670:	6e756620 6f697463 2965286e 0a0d7b20      function(e) {..
   1d680:	20202020 20202020 20202020 20202020                     
   1d690:	20202020 20202020 61656c63 6d695472             clearTim
   1d6a0:	74756f65 0d296528 2020200a 20202020     eout(e)..       
   1d6b0:	20202020 20202020 20202020 2e297d20                  }).
   1d6c0:	6c6c6163 6e697728 2c776f64 0d296520     call(window, e).
   1d6d0:	2020200a 20202020 20202020 20202020     .               
   1d6e0:	0a0d7d20 20202020 20202020 20202020      }..            
   1d6f0:	61202c7d 6665642e 746c7561 69726553     }, a.defaultSeri
   1d700:	72507365 6e657365 69746174 704f6e6f     esPresentationOp
   1d710:	6e6f6974 203d2073 200a0d7b 20202020     tions = {..     
   1d720:	20202020 20202020 6c202020 57656e69                lineW
   1d730:	68746469 2c31203a 20200a0d 20202020     idth: 1,..      
   1d740:	20202020 20202020 74732020 656b6f72               stroke
   1d750:	6c797453 22203a65 66666623 22666666     Style: "#ffffff"
   1d760:	20200a0d 20202020 20202020 2c7d2020     ..            },
   1d770:	702e6120 6f746f72 65707974 6464612e      a.prototype.add
   1d780:	656d6954 69726553 3d207365 6e756620     TimeSeries = fun
   1d790:	6f697463 2c65286e 20296920 200a0d7b     ction(e, i) {.. 
   1d7a0:	20202020 20202020 20202020 74202020                    t
   1d7b0:	2e736968 69726573 65537365 75702e74     his.seriesSet.pu
   1d7c0:	7b286873 20200a0d 20202020 20202020     sh({..          
   1d7d0:	20202020 20202020 69742020 6553656d               timeSe
   1d7e0:	73656972 2c65203a 20200a0d 20202020     ries: e,..      
   1d7f0:	20202020 20202020 20202020 706f2020                   op
   1d800:	6e6f6974 74203a73 7478652e 28646e65     tions: t.extend(
   1d810:	202c7d7b 65642e61 6c756166 72655374     {}, a.defaultSer
   1d820:	50736569 65736572 7461746e 4f6e6f69     iesPresentationO
   1d830:	6f697470 202c736e 0a0d2969 20202020     ptions, i)..    
   1d840:	20202020 20202020 20202020 202c297d                 }), 
   1d850:	706f2e65 6e6f6974 65722e73 42746573     e.options.resetB
   1d860:	646e756f 26262073 6f2e6520 6f697470     ounds && e.optio
   1d870:	722e736e 74657365 6e756f42 6e497364     ns.resetBoundsIn
   1d880:	76726574 3e206c61 26203020 65282026     terval > 0 && (e
   1d890:	7365722e 6f427465 73646e75 656d6954     .resetBoundsTime
   1d8a0:	20644972 6573203d 746e4974 61767265     rId = setInterva
   1d8b0:	7566286c 6974636e 29286e6f 0a0d7b20     l(function() {..
   1d8c0:	20202020 20202020 20202020 20202020                     
   1d8d0:	20202020 65722e65 42746573 646e756f         e.resetBound
   1d8e0:	0d292873 2020200a 20202020 20202020     s()..           
   1d8f0:	20202020 202c7d20 706f2e65 6e6f6974          }, e.option
   1d900:	65722e73 42746573 646e756f 746e4973     s.resetBoundsInt
   1d910:	61767265 0d29296c 2020200a 20202020     erval))..       
   1d920:	20202020 202c7d20 72702e61 746f746f          }, a.protot
   1d930:	2e657079 6f6d6572 69546576 6553656d     ype.removeTimeSe
   1d940:	73656972 66203d20 74636e75 286e6f69     ries = function(
   1d950:	7b202965 20200a0d 20202020 20202020     e) {..          
   1d960:	20202020 6f662020 76282072 74207261           for (var t
   1d970:	74203d20 2e736968 69726573 65537365      = this.seriesSe
   1d980:	656c2e74 6874676e 2069202c 3b30203d     t.length, i = 0;
   1d990:	3c206920 203b7420 3d2b2069 0d293120      i < t; i += 1).
   1d9a0:	2020200a 20202020 20202020 20202020     .               
   1d9b0:	20202020 20666920 69687428 65732e73          if (this.se
   1d9c0:	73656972 5b746553 742e5d69 53656d69     riesSet[i].timeS
   1d9d0:	65697265 3d3d2073 2965203d 0a0d7b20     eries === e) {..
   1d9e0:	20202020 20202020 20202020 20202020                     
   1d9f0:	20202020 20202020 73696874 7265732e             this.ser
   1da00:	53736569 732e7465 63696c70 2c692865     iesSet.splice(i,
   1da10:	3b293120 20200a0d 20202020 20202020      1);..          
   1da20:	20202020 20202020 20202020 72622020                   br
   1da30:	0d6b6165 2020200a 20202020 20202020     eak..           
   1da40:	20202020 20202020 0a0d7d20 20202020              }..    
   1da50:	20202020 20202020 20202020 65722e65                 e.re
   1da60:	42746573 646e756f 6d695473 64497265     setBoundsTimerId
   1da70:	20262620 61656c63 746e4972 61767265      && clearInterva
   1da80:	2e65286c 65736572 756f4274 5473646e     l(e.resetBoundsT
   1da90:	72656d69 0d296449 2020200a 20202020     imerId)..       
   1daa0:	20202020 202c7d20 72702e61 746f746f          }, a.protot
   1dab0:	2e657079 54746567 53656d69 65697265     ype.getTimeSerie
   1dac0:	74704f73 736e6f69 66203d20 74636e75     sOptions = funct
   1dad0:	286e6f69 7b202965 20200a0d 20202020     ion(e) {..      
   1dae0:	20202020 20202020 6f662020 76282072               for (v
   1daf0:	74207261 74203d20 2e736968 69726573     ar t = this.seri
   1db00:	65537365 656c2e74 6874676e 2069202c     esSet.length, i 
   1db10:	3b30203d 3c206920 203b7420 3d2b2069     = 0; i < t; i +=
   1db20:	0d293120 2020200a 20202020 20202020      1)..           
   1db30:	20202020 20202020 20666920 69687428              if (thi
   1db40:	65732e73 73656972 5b746553 742e5d69     s.seriesSet[i].t
   1db50:	53656d69 65697265 3d3d2073 2965203d     imeSeries === e)
   1db60:	74657220 206e7275 73696874 7265732e      return this.ser
   1db70:	53736569 695b7465 706f2e5d 6e6f6974     iesSet[i].option
   1db80:	200a0d73 20202020 20202020 7d202020     s..            }
   1db90:	2e61202c 746f7270 7079746f 72622e65     , a.prototype.br
   1dba0:	54676e69 6f72466f 3d20746e 6e756620     ingToFront = fun
   1dbb0:	6f697463 2965286e 0a0d7b20 20202020     ction(e) {..    
   1dbc0:	20202020 20202020 20202020 20726f66                 for 
   1dbd0:	72617628 3d207420 69687420 65732e73     (var t = this.se
   1dbe0:	73656972 2e746553 676e656c 202c6874     riesSet.length, 
   1dbf0:	203d2069 69203b30 74203c20 2069203b     i = 0; i < t; i 
   1dc00:	31203d2b 200a0d29 20202020 20202020     += 1)..         
   1dc10:	20202020 20202020 69202020 74282066                if (t
   1dc20:	2e736968 69726573 65537365 5d695b74     his.seriesSet[i]
   1dc30:	6d69742e 72655365 20736569 203d3d3d     .timeSeries === 
   1dc40:	7b202965 20200a0d 20202020 20202020     e) {..          
   1dc50:	20202020 20202020 20202020 61762020                   va
   1dc60:	20612072 6874203d 732e7369 65697265     r a = this.serie
   1dc70:	74655373 6c70732e 28656369 31202c69     sSet.splice(i, 1
   1dc80:	0a0d3b29 20202020 20202020 20202020     );..            
   1dc90:	20202020 20202020 20202020 73696874                 this
   1dca0:	7265732e 53736569 702e7465 28687375     .seriesSet.push(
   1dcb0:	5d305b61 0a0d3b29 20202020 20202020     a[0]);..        
   1dcc0:	20202020 20202020 20202020 20202020                     
   1dcd0:	61657262 200a0d6b 20202020 20202020     break..         
   1dce0:	20202020 20202020 7d202020 20200a0d                }..  
   1dcf0:	20202020 20202020 2c7d2020 702e6120               }, a.p
   1dd00:	6f746f72 65707974 7274732e 546d6165     rototype.streamT
   1dd10:	203d206f 636e7566 6e6f6974 202c6528     o = function(e, 
   1dd20:	7b202974 20200a0d 20202020 20202020     t) {..          
   1dd30:	20202020 68742020 632e7369 61766e61           this.canva
   1dd40:	203d2073 74202c65 2e736968 616c6564     s = e, this.dela
   1dd50:	203d2079 74202c74 2e736968 72617473     y = t, this.star
   1dd60:	0d292874 2020200a 20202020 20202020     t()..           
   1dd70:	202c7d20 72702e61 746f746f 2e657079      }, a.prototype.
   1dd80:	69736572 3d20657a 6e756620 6f697463     resize = functio
   1dd90:	2029286e 200a0d7b 20202020 20202020     n() {..         
   1dda0:	20202020 69202020 74282066 2e736968            if (this.
   1ddb0:	6974706f 2e736e6f 62616e65 7044656c     options.enableDp
   1ddc0:	61635369 676e696c 20262620 646e6977     iScaling && wind
   1ddd0:	2620776f 20312026 203d3d21 646e6977     ow && 1 !== wind
   1dde0:	642e776f 63697665 78695065 61526c65     ow.devicePixelRa
   1ddf0:	296f6974 0a0d7b20 20202020 20202020     tio) {..        
   1de00:	20202020 20202020 20202020 20726176                 var 
   1de10:	203d2065 646e6977 642e776f 63697665     e = window.devic
   1de20:	78695065 61526c65 2c6f6974 20200a0d     ePixelRatio,..  
   1de30:	20202020 20202020 20202020 20202020                     
   1de40:	20202020 20742020 6170203d 49657372           t = parseI
   1de50:	7428746e 2e736968 766e6163 672e7361     nt(this.canvas.g
   1de60:	74417465 62697274 28657475 64697722     etAttribute("wid
   1de70:	29226874 0a0d2c29 20202020 20202020     th")),..        
   1de80:	20202020 20202020 20202020 20202020                     
   1de90:	203d2069 73726170 746e4965 69687428     i = parseInt(thi
   1dea0:	61632e73 7361766e 7465672e 72747441     s.canvas.getAttr
   1deb0:	74756269 68222865 68676965 29292274     ibute("height"))
   1dec0:	200a0d3b 20202020 20202020 20202020     ;..             
   1ded0:	20202020 74202020 2e736968 6769726f            this.orig
   1dee0:	6c616e69 74646957 26262068 74614d20     inalWidth && Mat
   1def0:	6c662e68 28726f6f 73696874 69726f2e     h.floor(this.ori
   1df00:	616e6967 6469576c 2a206874 20296520     ginalWidth * e) 
   1df10:	203d3d3d 7c7c2074 68742820 6f2e7369     === t || (this.o
   1df20:	69676972 576c616e 68746469 74203d20     riginalWidth = t
   1df30:	6874202c 632e7369 61766e61 65732e73     , this.canvas.se
   1df40:	74744174 75626972 22286574 74646977     tAttribute("widt
   1df50:	202c2268 6874614d 6f6c662e 7428726f     h", Math.floor(t
   1df60:	65202a20 6f742e29 69727453 2928676e      * e).toString()
   1df70:	74202c29 2e736968 766e6163 732e7361     ), this.canvas.s
   1df80:	656c7974 6469772e 3d206874 2b207420     tyle.width = t +
   1df90:	78702220 74202c22 2e736968 766e6163      "px", this.canv
   1dfa0:	672e7361 6f437465 7865746e 32222874     as.getContext("2
   1dfb0:	2e292264 6c616373 2c652865 29296520     d").scale(e, e))
   1dfc0:	6874202c 6f2e7369 69676972 486c616e     , this.originalH
   1dfd0:	68676965 26262074 74614d20 6c662e68     eight && Math.fl
   1dfe0:	28726f6f 73696874 69726f2e 616e6967     oor(this.origina
   1dff0:	6965486c 20746867 2965202a 3d3d3d20     lHeight * e) ===
   1e000:	7c206920 7428207c 2e736968 6769726f      i || (this.orig
   1e010:	6c616e69 67696548 3d207468 202c6920     inalHeight = i, 
   1e020:	73696874 6e61632e 2e736176 41746573     this.canvas.setA
   1e030:	69727474 65747562 65682228 74686769     ttribute("height
   1e040:	4d202c22 2e687461 6f6f6c66 20692872     ", Math.floor(i 
   1e050:	2965202a 536f742e 6e697274 29292867     * e).toString())
   1e060:	6874202c 632e7369 61766e61 74732e73     , this.canvas.st
   1e070:	2e656c79 67696568 3d207468 2b206920     yle.height = i +
   1e080:	78702220 74202c22 2e736968 766e6163      "px", this.canv
   1e090:	672e7361 6f437465 7865746e 32222874     as.getContext("2
   1e0a0:	2e292264 6c616373 2c652865 29296520     d").scale(e, e))
   1e0b0:	20200a0d 20202020 20202020 20202020     ..              
   1e0c0:	0d7d2020 2020200a 20202020 20202020       }..           
   1e0d0:	202c7d20 72702e61 746f746f 2e657079      }, a.prototype.
   1e0e0:	72617473 203d2074 636e7566 6e6f6974     start = function
   1e0f0:	7b202928 20200a0d 20202020 20202020     () {..          
   1e100:	20202020 66692020 74212820 2e736968           if (!this.
   1e110:	6d617266 7b202965 20200a0d 20202020     frame) {..      
   1e120:	20202020 20202020 20202020 61762020                   va
   1e130:	20652072 7566203d 6974636e 29286e6f     r e = function()
   1e140:	0a0d7b20 20202020 20202020 20202020      {..            
   1e150:	20202020 20202020 20202020 73696874                 this
   1e160:	6172662e 3d20656d 412e6120 616d696e     .frame = a.Anima
   1e170:	6f436574 7461706d 6c696269 2e797469     teCompatibility.
   1e180:	75716572 41747365 616d696e 6e6f6974     requestAnimation
   1e190:	6d617246 75662865 6974636e 29286e6f     Frame(function()
   1e1a0:	0a0d7b20 20202020 20202020 20202020      {..            
   1e1b0:	20202020 20202020 20202020 20202020                     
   1e1c0:	73696874 6e65722e 28726564 65202c29     this.render(), e
   1e1d0:	0a0d2928 20202020 20202020 20202020     ()..            
   1e1e0:	20202020 20202020 20202020 69622e7d                 }.bi
   1e1f0:	7428646e 29736968 200a0d29 20202020     nd(this))..     
   1e200:	20202020 20202020 20202020 7d202020                    }
   1e210:	6e69622e 68742864 3b297369 20200a0d     .bind(this);..  
   1e220:	20202020 20202020 20202020 20202020                     
   1e230:	28652020 200a0d29 20202020 20202020       e()..         
   1e240:	20202020 7d202020 20200a0d 20202020            }..      
   1e250:	20202020 2c7d2020 702e6120 6f746f72           }, a.proto
   1e260:	65707974 6f74732e 203d2070 636e7566     type.stop = func
   1e270:	6e6f6974 7b202928 20200a0d 20202020     tion() {..      
   1e280:	20202020 20202020 68742020 662e7369               this.f
   1e290:	656d6172 20262620 412e6128 616d696e     rame && (a.Anima
   1e2a0:	6f436574 7461706d 6c696269 2e797469     teCompatibility.
   1e2b0:	636e6163 6e416c65 74616d69 466e6f69     cancelAnimationF
   1e2c0:	656d6172 69687428 72662e73 29656d61     rame(this.frame)
   1e2d0:	6564202c 6574656c 69687420 72662e73     , delete this.fr
   1e2e0:	29656d61 20200a0d 20202020 20202020     ame)..          
   1e2f0:	2c7d2020 702e6120 6f746f72 65707974       }, a.prototype
   1e300:	6470752e 56657461 65756c61 676e6152     .updateValueRang
   1e310:	203d2065 636e7566 6e6f6974 7b202928     e = function() {
   1e320:	20200a0d 20202020 20202020 20202020     ..              
   1e330:	6f662020 76282072 65207261 74203d20       for (var e = t
   1e340:	2e736968 6974706f 2c736e6f 3d207420     his.options, t =
   1e350:	6d754e20 2e726562 2c4e614e 3d206920      Number.NaN, i =
   1e360:	6d754e20 2e726562 2c4e614e 3d206120      Number.NaN, a =
   1e370:	203b3020 203c2061 73696874 7265732e      0; a < this.ser
   1e380:	53736569 6c2e7465 74676e65 61203b68     iesSet.length; a
   1e390:	203d2b20 7b202931 20200a0d 20202020      += 1) {..      
   1e3a0:	20202020 20202020 20202020 61762020                   va
   1e3b0:	20732072 6874203d 732e7369 65697265     r s = this.serie
   1e3c0:	74655373 2e5d615b 656d6974 69726553     sSet[a].timeSeri
   1e3d0:	0d3b7365 2020200a 20202020 20202020     es;..           
   1e3e0:	20202020 20202020 4e736920 73284e61              isNaN(s
   1e3f0:	78616d2e 756c6156 7c202965 7428207c     .maxValue) || (t
   1e400:	69203d20 4e614e73 20297428 2e73203f      = isNaN(t) ? s.
   1e410:	5678616d 65756c61 4d203a20 2e687461     maxValue : Math.
   1e420:	2878616d 73202c74 78616d2e 756c6156     max(t, s.maxValu
   1e430:	2c292965 4e736920 73284e61 6e696d2e     e)), isNaN(s.min
   1e440:	756c6156 7c202965 6928207c 69203d20     Value) || (i = i
   1e450:	4e614e73 20296928 2e73203f 566e696d     sNaN(i) ? s.minV
   1e460:	65756c61 4d203a20 2e687461 286e696d     alue : Math.min(
   1e470:	73202c69 6e696d2e 756c6156 0d292965     i, s.minValue)).
   1e480:	2020200a 20202020 20202020 20202020     .               
   1e490:	0a0d7d20 20202020 20202020 20202020      }..            
   1e4a0:	20202020 28206669 6c6c756e 203d2120         if (null != 
   1e4b0:	616d2e65 6c615678 3f206575 3d207420     e.maxValue ? t =
   1e4c0:	6d2e6520 61567861 2065756c 2074203a      e.maxValue : t 
   1e4d0:	65203d2a 78616d2e 756c6156 61635365     *= e.maxValueSca
   1e4e0:	202c656c 6c6c756e 203d2120 696d2e65     le, null != e.mi
   1e4f0:	6c61566e 3f206575 3d206920 6d2e6520     nValue ? i = e.m
   1e500:	61566e69 2065756c 2069203a 4d203d2d     inValue : i -= M
   1e510:	2e687461 28736261 202a2069 696d2e65     ath.abs(i * e.mi
   1e520:	6c61566e 63536575 20656c61 2969202d     nValueScale - i)
   1e530:	6874202c 6f2e7369 6f697470 792e736e     , this.options.y
   1e540:	676e6152 6e754665 6f697463 7b20296e     RangeFunction) {
   1e550:	20200a0d 20202020 20202020 20202020     ..              
   1e560:	20202020 61762020 206e2072 6874203d           var n = th
   1e570:	6f2e7369 6f697470 792e736e 676e6152     is.options.yRang
   1e580:	6e754665 6f697463 0d7b286e 2020200a     eFunction({..   
   1e590:	20202020 20202020 20202020 20202020                     
   1e5a0:	20202020 6e696d20 2c69203a 20200a0d          min: i,..  
   1e5b0:	20202020 20202020 20202020 20202020                     
   1e5c0:	20202020 616d2020 74203a78 20200a0d           max: t..  
   1e5d0:	20202020 20202020 20202020 20202020                     
   1e5e0:	297d2020 200a0d3b 20202020 20202020       });..         
   1e5f0:	20202020 20202020 69202020 6e203d20                i = n
   1e600:	6e696d2e 2074202c 2e6e203d 0d78616d     .min, t = n.max.
   1e610:	2020200a 20202020 20202020 20202020     .               
   1e620:	0a0d7d20 20202020 20202020 20202020      }..            
   1e630:	20202020 28206669 4e736921 74284e61         if (!isNaN(t
   1e640:	26262029 73692120 284e614e 20292969     ) && !isNaN(i)) 
   1e650:	200a0d7b 20202020 20202020 20202020     {..             
   1e660:	20202020 76202020 72207261 74203d20            var r = t
   1e670:	69202d20 74202d20 2e736968 72727563      - i - this.curr
   1e680:	56746e65 65756c61 676e6152 0a0d2c65     entValueRange,..
   1e690:	20202020 20202020 20202020 20202020                     
   1e6a0:	20202020 20202020 203d206c 202d2069             l = i - 
   1e6b0:	73696874 7275632e 746e6572 4d736956     this.currentVisM
   1e6c0:	61566e69 3b65756c 20200a0d 20202020     inValue;..      
   1e6d0:	20202020 20202020 20202020 68742020                   th
   1e6e0:	692e7369 696e4173 6974616d 6353676e     is.isAnimatingSc
   1e6f0:	20656c61 614d203d 612e6874 72287362     ale = Math.abs(r
   1e700:	203e2029 7c20312e 614d207c 612e6874     ) > .1 || Math.a
   1e710:	6c287362 203e2029 202c312e 73696874     bs(l) > .1, this
   1e720:	7275632e 746e6572 756c6156 6e615265     .currentValueRan
   1e730:	2b206567 2e65203d 6c616373 6f6d5365     ge += e.scaleSmo
   1e740:	6968746f 2a20676e 202c7220 73696874     othing * r, this
   1e750:	7275632e 746e6572 4d736956 61566e69     .currentVisMinVa
   1e760:	2065756c 65203d2b 6163732e 6d53656c     lue += e.scaleSm
   1e770:	68746f6f 20676e69 0d6c202a 2020200a     oothing * l..   
   1e780:	20202020 20202020 20202020 0a0d7d20                  }..
   1e790:	20202020 20202020 20202020 20202020                     
   1e7a0:	73696874 6c61762e 61526575 2065676e     this.valueRange 
   1e7b0:	0d7b203d 2020200a 20202020 20202020     = {..           
   1e7c0:	20202020 20202020 6e696d20 2c69203a              min: i,
   1e7d0:	20200a0d 20202020 20202020 20202020     ..              
   1e7e0:	20202020 616d2020 74203a78 20200a0d           max: t..  
   1e7f0:	20202020 20202020 20202020 0d7d2020                   }.
   1e800:	2020200a 20202020 20202020 202c7d20     .            }, 
   1e810:	72702e61 746f746f 2e657079 646e6572     a.prototype.rend
   1e820:	3d207265 6e756620 6f697463 2c65286e     er = function(e,
   1e830:	20297420 200a0d7b 20202020 20202020      t) {..         
   1e840:	20202020 76202020 69207261 28203d20            var i = (
   1e850:	2077656e 65746144 65672e29 6d695474     new Date).getTim
   1e860:	3b292865 20200a0d 20202020 20202020     e();..          
   1e870:	20202020 66692020 74212820 2e736968           if (!this.
   1e880:	6e417369 74616d69 53676e69 656c6163     isAnimatingScale
   1e890:	0d7b2029 2020200a 20202020 20202020     ) {..           
   1e8a0:	20202020 20202020 72617620 3d206120              var a =
   1e8b0:	74614d20 696d2e68 6531286e 202f2033      Math.min(1e3 / 
   1e8c0:	74202c36 2e736968 6974706f 2e736e6f     6, this.options.
   1e8d0:	6c6c696d 65507369 78695072 3b296c65     millisPerPixel);
   1e8e0:	20200a0d 20202020 20202020 20202020     ..              
   1e8f0:	20202020 66692020 20692820 6874202d           if (i - th
   1e900:	6c2e7369 52747361 65646e65 6d695472     is.lastRenderTim
   1e910:	6c694d65 2073696c 2961203c 74657220     eMillis < a) ret
   1e920:	0d6e7275 2020200a 20202020 20202020     urn..           
   1e930:	20202020 0a0d7d20 20202020 20202020          }..        
   1e940:	20202020 20202020 73696874 7365722e             this.res
   1e950:	28657a69 74202c29 2e736968 7473616c     ize(), this.last
   1e960:	646e6552 69547265 694d656d 73696c6c     RenderTimeMillis
   1e970:	69203d20 2065202c 2065203d 74207c7c      = i, e = e || t
   1e980:	2e736968 766e6163 202c7361 203d2074     his.canvas, t = 
   1e990:	7c7c2074 2d206920 68742820 642e7369     t || i - (this.d
   1e9a0:	79616c65 207c7c20 202c2930 3d2d2074     elay || 0), t -=
   1e9b0:	25207420 69687420 706f2e73 6e6f6974      t % this.option
   1e9c0:	696d2e73 73696c6c 50726550 6c657869     s.millisPerPixel
   1e9d0:	200a0d3b 20202020 20202020 20202020     ;..             
   1e9e0:	76202020 73207261 65203d20 7465672e        var s = e.get
   1e9f0:	746e6f43 28747865 22643222 0a0d2c29     Context("2d"),..
   1ea00:	20202020 20202020 20202020 20202020                     
   1ea10:	20202020 203d206e 73696874 74706f2e         n = this.opt
   1ea20:	736e6f69 200a0d2c 20202020 20202020     ions,..         
   1ea30:	20202020 20202020 72202020 7b203d20                r = {
   1ea40:	20200a0d 20202020 20202020 20202020     ..              
   1ea50:	20202020 20202020 6f742020 30203a70               top: 0
   1ea60:	200a0d2c 20202020 20202020 20202020     ,..             
   1ea70:	20202020 20202020 6c202020 3a746665                left:
   1ea80:	0d2c3020 2020200a 20202020 20202020      0,..           
   1ea90:	20202020 20202020 20202020 64697720                  wid
   1eaa0:	203a6874 6c632e65 746e6569 74646957     th: e.clientWidt
   1eab0:	0a0d2c68 20202020 20202020 20202020     h,..            
   1eac0:	20202020 20202020 20202020 67696568                 heig
   1ead0:	203a7468 6c632e65 746e6569 67696548     ht: e.clientHeig
   1eae0:	0a0d7468 20202020 20202020 20202020     ht..            
   1eaf0:	20202020 20202020 0a0d2c7d 20202020             },..    
   1eb00:	20202020 20202020 20202020 20202020                     
   1eb10:	203d206c 202d2074 69772e72 20687464     l = t - r.width 
   1eb20:	2e6e202a 6c6c696d 65507369 78695072     * n.millisPerPix
   1eb30:	0d2c6c65 2020200a 20202020 20202020     el,..           
   1eb40:	20202020 20202020 3d206f20 6e756620              o = fun
   1eb50:	6f697463 2965286e 0a0d7b20 20202020     ction(e) {..    
   1eb60:	20202020 20202020 20202020 20202020                     
   1eb70:	20202020 20726176 203d2074 202d2065         var t = e - 
   1eb80:	73696874 7275632e 746e6572 4d736956     this.currentVisM
   1eb90:	61566e69 3b65756c 20200a0d 20202020     inValue;..      
   1eba0:	20202020 20202020 20202020 20202020                     
   1ebb0:	65722020 6e727574 3d203020 74203d3d       return 0 === t
   1ebc0:	2e736968 72727563 56746e65 65756c61     his.currentValue
   1ebd0:	676e6152 203f2065 65682e72 74686769     Range ? r.height
   1ebe0:	72203a20 6965682e 20746867 614d202d      : r.height - Ma
   1ebf0:	722e6874 646e756f 2f207428 69687420     th.round(t / thi
   1ec00:	75632e73 6e657272 6c615674 61526575     s.currentValueRa
   1ec10:	2065676e 2e72202a 67696568 0d297468     nge * r.height).
   1ec20:	2020200a 20202020 20202020 20202020     .               
   1ec30:	20202020 622e7d20 28646e69 73696874          }.bind(this
   1ec40:	0a0d2c29 20202020 20202020 20202020     ),..            
   1ec50:	20202020 20202020 203d2068 636e7566             h = func
   1ec60:	6e6f6974 20296528 200a0d7b 20202020     tion(e) {..     
   1ec70:	20202020 20202020 20202020 20202020                     
   1ec80:	72202020 72757465 2e6e206e 6f726373        return n.scro
   1ec90:	61426c6c 61776b63 20736472 614d203f     llBackwards ? Ma
   1eca0:	722e6874 646e756f 20742828 2965202d     th.round((t - e)
   1ecb0:	6e202f20 6c696d2e 5073696c 69507265      / n.millisPerPi
   1ecc0:	296c6578 4d203a20 2e687461 6e756f72     xel) : Math.roun
   1ecd0:	2e722864 74646977 202d2068 2d207428     d(r.width - (t -
   1ece0:	20296520 2e6e202f 6c6c696d 65507369      e) / n.millisPe
   1ecf0:	78695072 0d296c65 2020200a 20202020     rPixel)..       
   1ed00:	20202020 20202020 20202020 0d3b7d20                  };.
   1ed10:	2020200a 20202020 20202020 20202020     .               
   1ed20:	20666920 69687428 70752e73 65746164      if (this.update
   1ed30:	756c6156 6e615265 29286567 2e73202c     ValueRange(), s.
   1ed40:	746e6f66 6e203d20 62616c2e 2e736c65     font = n.labels.
   1ed50:	746e6f66 657a6953 22202b20 22207870     fontSize + "px "
   1ed60:	6e202b20 62616c2e 2e736c65 746e6f66      + n.labels.font
   1ed70:	696d6146 202c796c 61732e73 29286576     Family, s.save()
   1ed80:	2e73202c 6e617274 74616c73 2e722865     , s.translate(r.
   1ed90:	7466656c 2e72202c 29706f74 2e73202c     left, r.top), s.
   1eda0:	69676562 7461506e 2c292868 722e7320     beginPath(), s.r
   1edb0:	28746365 30202c30 2e72202c 74646977     ect(0, 0, r.widt
   1edc0:	72202c68 6965682e 29746867 2e73202c     h, r.height), s.
   1edd0:	70696c63 202c2928 61732e73 29286576     clip(), s.save()
   1ede0:	2e73202c 6c6c6966 6c797453 203d2065     , s.fillStyle = 
   1edf0:	72672e6e 662e6469 536c6c69 656c7974     n.grid.fillStyle
   1ee00:	2e73202c 61656c63 63655272 2c302874     , s.clearRect(0,
   1ee10:	202c3020 69772e72 2c687464 682e7220      0, r.width, r.h
   1ee20:	68676965 202c2974 69662e73 65526c6c     eight), s.fillRe
   1ee30:	30287463 2c30202c 772e7220 68746469     ct(0, 0, r.width
   1ee40:	2e72202c 67696568 2c297468 722e7320     , r.height), s.r
   1ee50:	6f747365 29286572 2e73202c 65766173     estore(), s.save
   1ee60:	202c2928 696c2e73 6957656e 20687464     (), s.lineWidth 
   1ee70:	2e6e203d 64697267 6e696c2e 64695765     = n.grid.lineWid
   1ee80:	202c6874 74732e73 656b6f72 6c797453     th, s.strokeStyl
   1ee90:	203d2065 72672e6e 732e6469 6b6f7274     e = n.grid.strok
   1eea0:	79745365 202c656c 72672e6e 6d2e6469     eStyle, n.grid.m
   1eeb0:	696c6c69 72655073 656e694c 30203e20     illisPerLine > 0
   1eec0:	0d7b2029 2020200a 20202020 20202020     ) {..           
   1eed0:	20202020 20202020 622e7320 6e696765              s.begin
   1eee0:	68746150 0d3b2928 2020200a 20202020     Path();..       
   1eef0:	20202020 20202020 20202020 726f6620                  for
   1ef00:	61762820 20642072 2074203d 2074202d      (var d = t - t 
   1ef10:	2e6e2025 64697267 6c696d2e 5073696c     % n.grid.millisP
   1ef20:	694c7265 203b656e 3d3e2064 203b6c20     erLine; d >= l; 
   1ef30:	3d2d2064 672e6e20 2e646972 6c6c696d     d -= n.grid.mill
   1ef40:	65507369 6e694c72 7b202965 20200a0d     isPerLine) {..  
   1ef50:	20202020 20202020 20202020 20202020                     
   1ef60:	20202020 61762020 20752072 2868203d           var u = h(
   1ef70:	0d3b2964 2020200a 20202020 20202020     d);..           
   1ef80:	20202020 20202020 20202020 672e6e20                  n.g
   1ef90:	2e646972 72616873 6e694c70 26207365     rid.sharpLines &
   1efa0:	75282026 203d2d20 2c29352e 6d2e7320     & (u -= .5), s.m
   1efb0:	5465766f 2c75286f 2c293020 6c2e7320     oveTo(u, 0), s.l
   1efc0:	54656e69 2c75286f 682e7220 68676965     ineTo(u, r.heigh
   1efd0:	0a0d2974 20202020 20202020 20202020     t)..            
   1efe0:	20202020 20202020 200a0d7d 20202020             }..     
   1eff0:	20202020 20202020 20202020 73202020                    s
   1f000:	7274732e 28656b6f 73202c29 6f6c632e     .stroke(), s.clo
   1f010:	61506573 29286874 20200a0d 20202020     sePath()..      
   1f020:	20202020 20202020 0d7d2020 2020200a               }..   
   1f030:	20202020 20202020 20202020 726f6620                  for
   1f040:	61762820 206d2072 3b31203d 3c206d20      (var m = 1; m <
   1f050:	672e6e20 2e646972 74726576 6c616369      n.grid.vertical
   1f060:	74636553 736e6f69 206d203b 31203d2b     Sections; m += 1
   1f070:	0d7b2029 2020200a 20202020 20202020     ) {..           
   1f080:	20202020 20202020 72617620 3d206320              var c =
   1f090:	74614d20 6f722e68 28646e75 202a206d      Math.round(m * 
   1f0a0:	65682e72 74686769 6e202f20 6972672e     r.height / n.gri
   1f0b0:	65762e64 63697472 65536c61 6f697463     d.verticalSectio
   1f0c0:	3b29736e 20200a0d 20202020 20202020     ns);..          
   1f0d0:	20202020 20202020 2e6e2020 64697267               n.grid
   1f0e0:	6168732e 694c7072 2073656e 28202626     .sharpLines && (
   1f0f0:	3d2d2063 29352e20 2e73202c 69676562     c -= .5), s.begi
   1f100:	7461506e 2c292868 6d2e7320 5465766f     nPath(), s.moveT
   1f110:	2c30286f 2c296320 6c2e7320 54656e69     o(0, c), s.lineT
   1f120:	2e72286f 74646977 63202c68 73202c29     o(r.width, c), s
   1f130:	7274732e 28656b6f 73202c29 6f6c632e     .stroke(), s.clo
   1f140:	61506573 29286874 20200a0d 20202020     sePath()..      
   1f150:	20202020 20202020 0d7d2020 2020200a               }..   
   1f160:	20202020 20202020 20202020 20666920                  if 
   1f170:	672e6e28 2e646972 64726f62 69567265     (n.grid.borderVi
   1f180:	6c626973 26262065 2e732820 69676562     sible && (s.begi
   1f190:	7461506e 2c292868 732e7320 6b6f7274     nPath(), s.strok
   1f1a0:	63655265 2c302874 202c3020 69772e72     eRect(0, 0, r.wi
   1f1b0:	2c687464 682e7220 68676965 202c2974     dth, r.height), 
   1f1c0:	6c632e73 5065736f 28687461 202c2929     s.closePath()), 
   1f1d0:	65722e73 726f7473 2c292865 682e6e20     s.restore(), n.h
   1f1e0:	7a69726f 61746e6f 6e694c6c 26207365     orizontalLines &
   1f1f0:	2e6e2026 69726f68 746e6f7a 694c6c61     & n.horizontalLi
   1f200:	2e73656e 676e656c 0d296874 2020200a     nes.length)..   
   1f210:	20202020 20202020 20202020 20202020                     
   1f220:	726f6620 61762820 20662072 3b30203d      for (var f = 0;
   1f230:	3c206620 682e6e20 7a69726f 61746e6f      f < n.horizonta
   1f240:	6e694c6c 6c2e7365 74676e65 66203b68     lLines.length; f
   1f250:	203d2b20 7b202931 20200a0d 20202020      += 1) {..      
   1f260:	20202020 20202020 20202020 20202020                     
   1f270:	61762020 20672072 2e6e203d 69726f68       var g = n.hori
   1f280:	746e6f7a 694c6c61 5b73656e 0d2c5d66     zontalLines[f],.
   1f290:	2020200a 20202020 20202020 20202020     .               
   1f2a0:	20202020 20202020 20202020 3d207020                  p =
   1f2b0:	74614d20 6f722e68 28646e75 2e67286f      Math.round(o(g.
   1f2c0:	756c6176 20292965 352e202d 200a0d3b     value)) - .5;.. 
   1f2d0:	20202020 20202020 20202020 20202020                     
   1f2e0:	20202020 73202020 7274732e 53656b6f            s.strokeS
   1f2f0:	656c7974 67203d20 6c6f632e 7c20726f     tyle = g.color |
   1f300:	2322207c 66666666 2c226666 6c2e7320     | "#ffffff", s.l
   1f310:	57656e69 68746469 67203d20 6e696c2e     ineWidth = g.lin
   1f320:	64695765 7c206874 2c31207c 622e7320     eWidth || 1, s.b
   1f330:	6e696765 68746150 202c2928 6f6d2e73     eginPath(), s.mo
   1f340:	6f546576 202c3028 202c2970 696c2e73     veTo(0, p), s.li
   1f350:	6f54656e 772e7228 68746469 2970202c     neTo(r.width, p)
   1f360:	2e73202c 6f727473 2928656b 2e73202c     , s.stroke(), s.
   1f370:	736f6c63 74615065 0d292868 2020200a     closePath()..   
   1f380:	20202020 20202020 20202020 20202020                     
   1f390:	0a0d7d20 20202020 20202020 20202020      }..            
   1f3a0:	20202020 20726f66 72617628 3d205320         for (var S =
   1f3b0:	203b3020 203c2053 73696874 7265732e      0; S < this.ser
   1f3c0:	53736569 6c2e7465 74676e65 53203b68     iesSet.length; S
   1f3d0:	203d2b20 7b202931 20200a0d 20202020      += 1) {..      
   1f3e0:	20202020 20202020 20202020 2e732020                   s.
   1f3f0:	65766173 0d3b2928 2020200a 20202020     save();..       
   1f400:	20202020 20202020 20202020 72617620                  var
   1f410:	3d207620 69687420 65732e73 73656972      v = this.series
   1f420:	5b746553 742e5d53 53656d69 65697265     Set[S].timeSerie
   1f430:	0a0d2c73 20202020 20202020 20202020     s,..            
   1f440:	20202020 20202020 20202020 203d2077                 w = 
   1f450:	61642e76 0d2c6174 2020200a 20202020     v.data,..       
   1f460:	20202020 20202020 20202020 20202020                     
   1f470:	3d207820 69687420 65732e73 73656972      x = this.series
   1f480:	5b746553 6f2e5d53 6f697470 0d3b736e     Set[S].options;.
   1f490:	2020200a 20202020 20202020 20202020     .               
   1f4a0:	20202020 642e7620 4f706f72 6144646c          v.dropOldDa
   1f4b0:	6c286174 2e6e202c 4478616d 53617461     ta(l, n.maxDataS
   1f4c0:	654c7465 6874676e 73202c29 6e696c2e     etLength), s.lin
   1f4d0:	64695765 3d206874 6c2e7820 57656e69     eWidth = x.lineW
   1f4e0:	68746469 2e73202c 6f727473 7453656b     idth, s.strokeSt
   1f4f0:	20656c79 2e78203d 6f727473 7453656b     yle = x.strokeSt
   1f500:	2c656c79 622e7320 6e696765 68746150     yle, s.beginPath
   1f510:	0d3b2928 2020200a 20202020 20202020     ();..           
   1f520:	20202020 20202020 726f6620 61762820              for (va
   1f530:	20792072 2c30203d 3d206220 202c3020     r y = 0, b = 0, 
   1f540:	203d2056 54202c30 30203d20 2054203b     V = 0, T = 0; T 
   1f550:	2e77203c 676e656c 26206874 20312026     < w.length && 1 
   1f560:	203d3d21 656c2e77 6874676e 2054203b     !== w.length; T 
   1f570:	31203d2b 0d7b2029 2020200a 20202020     += 1) {..       
   1f580:	20202020 20202020 20202020 20202020                     
   1f590:	72617620 3d204e20 77286820 5b5d545b      var N = h(w[T][
   1f5a0:	2c295d30 20200a0d 20202020 20202020     0]),..          
   1f5b0:	20202020 20202020 20202020 20202020                     
   1f5c0:	20502020 286f203d 5d545b77 295d315b       P = o(w[T][1])
   1f5d0:	200a0d3b 20202020 20202020 20202020     ;..             
   1f5e0:	20202020 20202020 69202020 30282066                if (0
   1f5f0:	3d3d3d20 20295420 203d2079 73202c4e      === T) y = N, s
   1f600:	766f6d2e 286f5465 50202c4e 0a0d3b29     .moveTo(N, P);..
   1f610:	20202020 20202020 20202020 20202020                     
   1f620:	20202020 20202020 65736c65 69777320             else swi
   1f630:	20686374 692e6e28 7265746e 616c6f70     tch (n.interpola
   1f640:	6e6f6974 0d7b2029 2020200a 20202020     tion) {..       
   1f650:	20202020 20202020 20202020 20202020                     
   1f660:	20202020 73616320 6c222065 61656e69          case "linea
   1f670:	0d3a2272 2020200a 20202020 20202020     r":..           
   1f680:	20202020 20202020 20202020 20202020                     
   1f690:	73616320 6c222065 22656e69 200a0d3a      case "line":.. 
   1f6a0:	20202020 20202020 20202020 20202020                     
   1f6b0:	20202020 20202020 20202020 73202020                    s
   1f6c0:	6e696c2e 286f5465 50202c4e 0a0d3b29     .lineTo(N, P);..
   1f6d0:	20202020 20202020 20202020 20202020                     
   1f6e0:	20202020 20202020 20202020 20202020                     
   1f6f0:	61657262 0a0d3b6b 20202020 20202020     break;..        
   1f700:	20202020 20202020 20202020 20202020                     
   1f710:	20202020 65736163 65622220 7265697a         case "bezier
   1f720:	0a0d3a22 20202020 20202020 20202020     ":..            
   1f730:	20202020 20202020 20202020 20202020                     
   1f740:	61666564 3a746c75 20200a0d 20202020     default:..      
   1f750:	20202020 20202020 20202020 20202020                     
   1f760:	20202020 20202020 2e732020 697a6562               s.bezi
   1f770:	75437265 54657672 614d286f 722e6874     erCurveTo(Math.r
   1f780:	646e756f 20622828 294e202b 32202f20     ound((b + N) / 2
   1f790:	56202c29 614d202c 722e6874 646e756f     ), V, Math.round
   1f7a0:	2b206228 20294e20 2c32202f 202c5020     (b + N) / 2, P, 
   1f7b0:	50202c4e 0a0d3b29 20202020 20202020     N, P);..        
   1f7c0:	20202020 20202020 20202020 20202020                     
   1f7d0:	20202020 20202020 61657262 0a0d3b6b             break;..
   1f7e0:	20202020 20202020 20202020 20202020                     
   1f7f0:	20202020 20202020 20202020 65736163                 case
   1f800:	74732220 3a227065 20200a0d 20202020      "step":..      
   1f810:	20202020 20202020 20202020 20202020                     
   1f820:	20202020 20202020 2e732020 656e696c               s.line
   1f830:	4e286f54 2956202c 2e73202c 656e696c     To(N, V), s.line
   1f840:	4e286f54 2950202c 20200a0d 20202020     To(N, P)..      
   1f850:	20202020 20202020 20202020 20202020                     
   1f860:	0d7d2020 2020200a 20202020 20202020       }..           
   1f870:	20202020 20202020 20202020 3d206220                  b =
   1f880:	202c4e20 203d2056 200a0d50 20202020      N, V = P..     
   1f890:	20202020 20202020 20202020 7d202020                    }
   1f8a0:	20200a0d 20202020 20202020 20202020     ..              
   1f8b0:	20202020 2e772020 676e656c 3e206874           w.length >
   1f8c0:	26203120 78282026 6c69662e 7974536c      1 && (x.fillSty
   1f8d0:	2620656c 73282026 6e696c2e 286f5465     le && (s.lineTo(
   1f8e0:	69772e72 20687464 2e78202b 656e696c     r.width + x.line
   1f8f0:	74646957 202b2068 56202c31 73202c29     Width + 1, V), s
   1f900:	6e696c2e 286f5465 69772e72 20687464     .lineTo(r.width 
   1f910:	2e78202b 656e696c 74646957 202b2068     + x.lineWidth + 
   1f920:	72202c31 6965682e 20746867 2e78202b     1, r.height + x.
   1f930:	656e696c 74646957 202b2068 202c2931     lineWidth + 1), 
   1f940:	696c2e73 6f54656e 202c7928 65682e72     s.lineTo(y, r.he
   1f950:	74686769 78202b20 6e696c2e 64695765     ight + x.lineWid
   1f960:	2c296874 662e7320 536c6c69 656c7974     th), s.fillStyle
   1f970:	78203d20 6c69662e 7974536c 202c656c      = x.fillStyle, 
   1f980:	69662e73 29286c6c 78202c29 7274732e     s.fill()), x.str
   1f990:	53656b6f 656c7974 20262620 6e6f6e22     okeStyle && "non
   1f9a0:	21202265 78203d3d 7274732e 53656b6f     e" !== x.strokeS
   1f9b0:	656c7974 20262620 74732e73 656b6f72     tyle && s.stroke
   1f9c0:	202c2928 6c632e73 5065736f 28687461     (), s.closePath(
   1f9d0:	202c2929 65722e73 726f7473 0d292865     )), s.restore().
   1f9e0:	2020200a 20202020 20202020 20202020     .               
   1f9f0:	0a0d7d20 20202020 20202020 20202020      }..            
   1fa00:	20202020 28206669 6c2e6e21 6c656261         if (!n.label
   1fa10:	69642e73 6c626173 26206465 69212026     s.disabled && !i
   1fa20:	4e614e73 69687428 61762e73 5265756c     sNaN(this.valueR
   1fa30:	65676e61 6e696d2e 26262029 73692120     ange.min) && !is
   1fa40:	284e614e 73696874 6c61762e 61526575     NaN(this.valueRa
   1fa50:	2e65676e 2978616d 0d7b2029 2020200a     nge.max)) {..   
   1fa60:	20202020 20202020 20202020 20202020                     
   1fa70:	72617620 3d204d20 792e6e20 4678614d      var M = n.yMaxF
   1fa80:	616d726f 72657474 69687428 61762e73     ormatter(this.va
   1fa90:	5265756c 65676e61 78616d2e 2e6e202c     lueRange.max, n.
   1faa0:	6562616c 702e736c 69636572 6e6f6973     labels.precision
   1fab0:	0a0d2c29 20202020 20202020 20202020     ),..            
   1fac0:	20202020 20202020 20202020 203d206b                 k = 
   1fad0:	4d792e6e 6f466e69 74616d72 28726574     n.yMinFormatter(
   1fae0:	73696874 6c61762e 61526575 2e65676e     this.valueRange.
   1faf0:	2c6e696d 6c2e6e20 6c656261 72702e73     min, n.labels.pr
   1fb00:	73696365 296e6f69 200a0d2c 20202020     ecision),..     
   1fb10:	20202020 20202020 20202020 20202020                     
   1fb20:	46202020 6e203d20 7263732e 426c6c6f        F = n.scrollB
   1fb30:	776b6361 73647261 30203f20 72203a20     ackwards ? 0 : r
   1fb40:	6469772e 2d206874 6d2e7320 75736165     .width - s.measu
   1fb50:	65546572 4d287478 69772e29 20687464     reText(M).width 
   1fb60:	2c32202d 20200a0d 20202020 20202020     - 2,..          
   1fb70:	20202020 20202020 20202020 20522020                   R 
   1fb80:	2e6e203d 6f726373 61426c6c 61776b63     = n.scrollBackwa
   1fb90:	20736472 2030203f 2e72203a 74646977     rds ? 0 : r.widt
   1fba0:	202d2068 656d2e73 72757361 78655465     h - s.measureTex
   1fbb0:	296b2874 6469772e 2d206874 0d3b3220     t(k).width - 2;.
   1fbc0:	2020200a 20202020 20202020 20202020     .               
   1fbd0:	20202020 662e7320 536c6c69 656c7974          s.fillStyle
   1fbe0:	6e203d20 62616c2e 2e736c65 6c6c6966      = n.labels.fill
   1fbf0:	6c797453 73202c65 6c69662e 7865546c     Style, s.fillTex
   1fc00:	2c4d2874 202c4620 616c2e6e 736c6562     t(M, F, n.labels
   1fc10:	6e6f662e 7a695374 202c2965 69662e73     .fontSize), s.fi
   1fc20:	65546c6c 6b287478 2c52202c 682e7220     llText(k, R, r.h
   1fc30:	68676965 202d2074 0a0d2932 20202020     eight - 2)..    
   1fc40:	20202020 20202020 20202020 200a0d7d                 }.. 
   1fc50:	20202020 20202020 20202020 69202020                    i
   1fc60:	6e282066 6d69742e 61747365 6f46706d     f (n.timestampFo
   1fc70:	74616d72 20726574 6e202626 6972672e     rmatter && n.gri
   1fc80:	696d2e64 73696c6c 4c726550 20656e69     d.millisPerLine 
   1fc90:	2930203e 0a0d7b20 20202020 20202020     > 0) {..        
   1fca0:	20202020 20202020 20202020 20726176                 var 
   1fcb0:	203d2041 63732e6e 6c6c6f72 6b636142     A = n.scrollBack
   1fcc0:	64726177 203f2073 656d2e73 72757361     wards ? s.measur
   1fcd0:	78655465 296b2874 6469772e 3a206874     eText(k).width :
   1fce0:	772e7220 68746469 73202d20 61656d2e      r.width - s.mea
   1fcf0:	65727573 74786554 2e296b28 74646977     sureText(k).widt
   1fd00:	202b2068 0a0d3b34 20202020 20202020     h + 4;..        
   1fd10:	20202020 20202020 20202020 20726f66                 for 
   1fd20:	3d206428 2d207420 25207420 672e6e20     (d = t - t % n.g
   1fd30:	2e646972 6c6c696d 65507369 6e694c72     rid.millisPerLin
   1fd40:	64203b65 203d3e20 64203b6c 203d2d20     e; d >= l; d -= 
   1fd50:	72672e6e 6d2e6469 696c6c69 72655073     n.grid.millisPer
   1fd60:	656e694c 0d7b2029 2020200a 20202020     Line) {..       
   1fd70:	20202020 20202020 20202020 20202020                     
   1fd80:	3d207520 64286820 0a0d3b29 20202020      u = h(d);..    
   1fd90:	20202020 20202020 20202020 20202020                     
   1fda0:	20202020 28206669 732e6e21 6c6f7263         if (!n.scrol
   1fdb0:	6361426c 7261776b 26207364 20752026     lBackwards && u 
   1fdc0:	2041203c 6e207c7c 7263732e 426c6c6f     < A || n.scrollB
   1fdd0:	776b6361 73647261 20262620 203e2075     ackwards && u > 
   1fde0:	7b202941 20200a0d 20202020 20202020     A) {..          
   1fdf0:	20202020 20202020 20202020 20202020                     
   1fe00:	61762020 20422072 656e203d 61442077       var B = new Da
   1fe10:	64286574 0a0d2c29 20202020 20202020     te(d),..        
   1fe20:	20202020 20202020 20202020 20202020                     
   1fe30:	20202020 20202020 203d204c 69742e6e             L = n.ti
   1fe40:	7473656d 46706d61 616d726f 72657474     mestampFormatter
   1fe50:	2c294228 20200a0d 20202020 20202020     (B),..          
   1fe60:	20202020 20202020 20202020 20202020                     
   1fe70:	20202020 20572020 2e73203d 7361656d           W = s.meas
   1fe80:	54657275 28747865 772e294c 68746469     ureText(L).width
   1fe90:	200a0d3b 20202020 20202020 20202020     ;..             
   1fea0:	20202020 20202020 20202020 41202020                    A
   1feb0:	6e203d20 7263732e 426c6c6f 776b6361      = n.scrollBackw
   1fec0:	73647261 75203f20 57202b20 32202b20     ards ? u + W + 2
   1fed0:	75203a20 57202d20 32202d20 2e73202c      : u - W - 2, s.
   1fee0:	6c6c6966 6c797453 203d2065 616c2e6e     fillStyle = n.la
   1fef0:	736c6562 6c69662e 7974536c 202c656c     bels.fillStyle, 
   1ff00:	63732e6e 6c6c6f72 6b636142 64726177     n.scrollBackward
   1ff10:	203f2073 69662e73 65546c6c 4c287478     s ? s.fillText(L
   1ff20:	2c75202c 682e7220 68676965 202d2074     , u, r.height - 
   1ff30:	3a202932 662e7320 546c6c69 28747865     2) : s.fillText(
   1ff40:	75202c4c 57202d20 2e72202c 67696568     L, u - W, r.heig
   1ff50:	2d207468 0d293220 2020200a 20202020     ht - 2)..       
   1ff60:	20202020 20202020 20202020 20202020                     
   1ff70:	0a0d7d20 20202020 20202020 20202020      }..            
   1ff80:	20202020 20202020 200a0d7d 20202020             }..     
   1ff90:	20202020 20202020 7d202020 20200a0d                }..  
   1ffa0:	20202020 20202020 20202020 2e732020                   s.
   1ffb0:	74736572 2865726f 200a0d29 20202020     restore()..     
   1ffc0:	20202020 7d202020 2e61202c 656d6974            }, a.time
   1ffd0:	6d726f46 65747461 203d2072 636e7566     Formatter = func
   1ffe0:	6e6f6974 20296528 200a0d7b 20202020     tion(e) {..     
   1fff0:	20202020 20202020 66202020 74636e75                funct
   20000:	206e6f69 29652874 0a0d7b20 20202020     ion t(e) {..    
   20010:	20202020 20202020 20202020 20202020                     
   20020:	75746572 28206e72 203c2065 3f203031     return (e < 10 ?
   20030:	22302220 22203a20 2b202922 0a0d6520      "0" : "") + e..
   20040:	20202020 20202020 20202020 20202020                     
   20050:	200a0d7d 20202020 20202020 20202020     }..             
   20060:	72202020 72757465 2874206e 65672e65        return t(e.ge
   20070:	756f4874 29287372 202b2029 20223a22     tHours()) + ":" 
   20080:	2874202b 65672e65 6e694d74 73657475     + t(e.getMinutes
   20090:	20292928 3a22202b 202b2022 2e652874     ()) + ":" + t(e.
   200a0:	53746567 6e6f6365 29287364 200a0d29     getSeconds()).. 
   200b0:	20202020 20202020 7d202020 2e65202c                }, e.
   200c0:	656d6954 69726553 3d207365 202c6920     TimeSeries = i, 
   200d0:	6d532e65 68746f6f 68436569 20747261     e.SmoothieChart 
   200e0:	0d61203d 2020200a 20202020 22287d20     = a..        }("
   200f0:	65646e75 656e6966 3d202264 7974203d     undefined" == ty
   20100:	666f6570 70786520 7374726f 74203f20     peof exports ? t
   20110:	20736968 7865203a 74726f70 0d3b2973     his : exports);.
   20120:	200a0d0a 20202020 66202020 74636e75     ...        funct
   20130:	206e6f69 64616f6c 61746144 7b202928     ion loadData() {
   20140:	20200a0d 20202020 20202020 61762020     ..            va
   20150:	3b722072 20200a0d 20202020 20202020     r r;..          
   20160:	72742020 0d7b2079 2020200a 20202020       try {..       
   20170:	20202020 20202020 3d207220 77656e20              r = new
   20180:	4c4d5820 70747448 75716552 28747365      XMLHttpRequest(
   20190:	200a0d29 20202020 20202020 7d202020     )..            }
   201a0:	74616320 28206863 7b202965 20200a0d      catch (e) {..  
   201b0:	20202020 20202020 20202020 72742020                   tr
   201c0:	0d7b2079 2020200a 20202020 20202020     y {..           
   201d0:	20202020 20202020 3d207220 77656e20              r = new
   201e0:	74634120 58657669 656a624f 22287463      ActiveXObject("
   201f0:	6d78734d 582e326c 54484c4d 29225054     Msxml2.XMLHTTP")
   20200:	20200a0d 20202020 20202020 20202020     ..              
   20210:	207d2020 63746163 65282068 0d7b2029       } catch (e) {.
   20220:	2020200a 20202020 20202020 20202020     .               
   20230:	20202020 79727420 0a0d7b20 20202020          try {..    
   20240:	20202020 20202020 20202020 20202020                     
   20250:	20202020 203d2072 2077656e 69746341         r = new Acti
   20260:	4f586576 63656a62 4d222874 6f726369     veXObject("Micro
   20270:	74666f73 4c4d582e 50545448 0a0d2922     soft.XMLHTTP")..
   20280:	20202020 20202020 20202020 20202020                     
   20290:	20202020 6163207d 20686374 20296528         } catch (e) 
   202a0:	200a0d7b 20202020 20202020 20202020     {..             
   202b0:	20202020 20202020 61202020 7472656c                alert
   202c0:	6f592228 62207275 73776f72 64207265     ("Your browser d
   202d0:	2073656f 20746f6e 70707573 2074726f     oes not support 
   202e0:	58414a41 3b292221 20200a0d 20202020     AJAX!");..      
   202f0:	20202020 20202020 20202020 20202020                     
   20300:	65722020 6e727574 6c616620 0a0d6573       return false..
   20310:	20202020 20202020 20202020 20202020                     
   20320:	20202020 200a0d7d 20202020 20202020         }..         
   20330:	20202020 7d202020 20200a0d 20202020            }..      
   20340:	20202020 0d7d2020 2020200a 20202020           }..       
   20350:	20202020 6f2e7220 6165726e 74737964          r.onreadyst
   20360:	63657461 676e6168 203d2065 636e7566     atechange = func
   20370:	6e6f6974 7b202928 20200a0d 20202020     tion() {..      
   20380:	20202020 20202020 66692020 2e722820               if (r.
   20390:	64616572 61745379 3d206574 2934203d     readyState == 4)
   203a0:	0a0d7b20 20202020 20202020 20202020      {..            
   203b0:	20202020 20202020 72202f2f 3d207365             // res =
   203c0:	6f742720 27206b6f 28202b20 77656e28      'took ' + ((new
   203d0:	74614420 29292865 7465672e 656d6954      Date()).getTime
   203e0:	2d202928 61747320 672e7472 69547465     () - start.getTi
   203f0:	2928656d 202f2029 30303031 27202b20     me()) / 1000 + '
   20400:	63657320 73646e6f 0a0d3b27 20202020      seconds';..    
   20410:	20202020 20202020 20202020 20202020                     
   20420:	64202f2f 6d75636f 2e746e65 45746567     // document.getE
   20430:	656d656c 7942746e 22286449 6f6d6564     lementById("demo
   20440:	692e2922 72656e6e 4c4d5448 72203d20     ").innerHTML = r
   20450:	0d3b7365 2020200a 20202020 20202020     es;..           
   20460:	20202020 20202020 6e696c20 612e3165              line1.a
   20470:	6e657070 656e2864 61442077 29286574     ppend(new Date()
   20480:	7465672e 656d6954 202c2928 65722e72     .getTime(), r.re
   20490:	6e6f7073 65546573 3b297478 20200a0d     sponseText);..  
   204a0:	20202020 20202020 20202020 0d7d2020                   }.
   204b0:	2020200a 20202020 20202020 0d3b7d20     .            };.
   204c0:	2020200a 20202020 20202020 61747320     .            sta
   204d0:	3d207472 77656e20 74614420 3b292865     rt = new Date();
   204e0:	20200a0d 20202020 20202020 2e722020     ..            r.
   204f0:	6e65706f 45472228 202c2254 65732f22     open("GET", "/se
   20500:	726f736e 61746164 7468732e 2c226c6d     nsordata.shtml",
   20510:	75727420 0d3b2965 2020200a 20202020      true);..       
   20520:	20202020 732e7220 28646e65 6c6c756e          r.send(null
   20530:	200a0d29 20202020 7d202020 0a0d0a0d     )..        }....
   20540:	20200a0d 20202020 61762020 6d732072     ..        var sm
   20550:	68746f6f 3d206569 77656e20 6f6d5320     oothie = new Smo
   20560:	6968746f 61684365 29287472 200a0d3b     othieChart();.. 
   20570:	20202020 73202020 746f6f6d 2e656968            smoothie.
   20580:	65727473 6f546d61 636f6428 6e656d75     streamTo(documen
   20590:	65672e74 656c4574 746e656d 64497942     t.getElementById
   205a0:	68632228 43747261 61766e61 29292273     ("chartCanvas"))
   205b0:	200a0d3b 20202020 76202020 6c207261     ;..        var l
   205c0:	31656e69 6e203d20 54207765 53656d69     ine1 = new TimeS
   205d0:	65697265 3b292873 0a0d0a0d 20202020     eries();....    
   205e0:	20202020 55202f2f 65676173 6520203a         // Usage:  e
   205f0:	7275736e 6c652065 6e656d65 73692074     nsure element is
   20600:	73697620 656c6269 0a0d0a0d 0a0d0a0d      visible........
   20610:	20202020 20202020 49746573 7265746e             setInter
   20620:	286c6176 636e7566 6e6f6974 7b202928     val(function() {
   20630:	20200a0d 20202020 20202020 6f6c2020     ..            lo
   20640:	61446461 29286174 200a0d3b 20202020     adData();..     
   20650:	7d202020 2935202c 0d0a0d3b 200a0d0a        }, 5);...... 
   20660:	20202020 73202020 746f6f6d 2e656968            smoothie.
   20670:	54646461 53656d69 65697265 696c2873     addTimeSeries(li
   20680:	2931656e 200a0d3b 3c202020 7263732f     ne1);..    </scr
   20690:	3e747069 0a0d0a0d 0a0d0a0d 6f622f3c     ipt>........</bo
   206a0:	0d3e7964 3c0a0d0a 6d74682f 00003e6c     dy>....</html>..

000206b0 <data_runtime_shtml>:
   206b0:	6e75722f 656d6974 7468732e 3c006c6d     /runtime.shtml.<
   206c0:	434f4421 45505954 4d544820 5550204c     !DOCTYPE HTML PU
   206d0:	43494c42 2f2d2220 4333572f 54442f2f     BLIC "-//W3C//DT
   206e0:	54482044 34204c4d 2031302e 6e617254     D HTML 4.01 Tran
   206f0:	69746973 6c616e6f 4e452f2f 68222022     sitional//EN" "h
   20700:	3a707474 77772f2f 33772e77 67726f2e     ttp://www.w3.org
   20710:	2f52542f 6c6d7468 6f6c2f34 2e65736f     /TR/html4/loose.
   20720:	22647464 3c0a0d3e 6c6d7468 200a0d3e     dtd">..<html>.. 
   20730:	65683c20 0d3e6461 2020200a 69743c20      <head>..    <ti
   20740:	3e656c74 65657246 534f5452 67726f2e     tle>FreeRTOS.org
   20750:	50497520 42455720 72657320 20726576      uIP WEB server 
   20760:	6f6d6564 69742f3c 3e656c74 20200a0d     demo</title>..  
   20770:	65682f3c 0d3e6461 3c20200a 59444f42     </head>..  <BODY
   20780:	4c6e6f20 3d64616f 6e697722 2e776f64      onLoad="window.
   20790:	54746573 6f656d69 26287475 746f7571     setTimeout(&quot
   207a0:	636f6c3b 6f697461 72682e6e 273d6665     ;location.href='
   207b0:	746e7572 2e656d69 6d746873 7126276c     runtime.shtml'&q
   207c0:	3b746f75 3030322c 3e222930 663c0a0d     uot;,2000)">..<f
   207d0:	20746e6f 65636166 7261223d 226c6169     ont face="arial"
   207e0:	3c0a0d3e 72682061 223d6665 65646e69     >..<a href="inde
   207f0:	68732e78 226c6d74 7361543e 7453206b     x.shtml">Task St
   20800:	3c737461 203e612f 7c3e623c 3e622f3c     ats</a> <b>|</b>
   20810:	20613c20 66657268 7572223d 6d69746e      <a href="runtim
   20820:	68732e65 226c6d74 6e75523e 6d695420     e.shtml">Run Tim
   20830:	74532065 3c737461 203e612f 7c3e623c     e Stats</a> <b>|
   20840:	3e622f3c 20613c20 66657268 7473223d     </b> <a href="st
   20850:	2e737461 6d746873 543e226c 53205043     ats.shtml">TCP S
   20860:	73746174 3e612f3c 3e623c20 622f3c7c     tats</a> <b>|</b
   20870:	613c203e 65726820 74223d66 732e7063     > <a href="tcp.s
   20880:	6c6d7468 6f433e22 63656e6e 6e6f6974     html">Connection
   20890:	612f3c73 623c203e 2f3c7c3e 3c203e62     s</a> <b>|</b> <
   208a0:	72682061 223d6665 70747468 772f2f3a     a href="http://w
   208b0:	662e7777 72656572 2e736f74 2f67726f     ww.freertos.org/
   208c0:	72463e22 54526565 4820534f 70656d6f     ">FreeRTOS Homep
   208d0:	3c656761 203e612f 7c3e623c 3e622f3c     age</a> <b>|</b>
   208e0:	20613c20 66657268 6f69223d 7468732e      <a href="io.sht
   208f0:	3e226c6d 2f3c4f49 3c203e61 3c7c3e62     ml">IO</a> <b>|<
   20900:	203e622f 6820613c 3d666572 676f6c22     /b> <a href="log
   20910:	706a2e6f 333e2267 6a204b37 2f3c6770     o.jpg">37K jpg</
   20920:	0a0d3e61 3e72623c 0d3e703c 72683c0a     a>..<br><p>..<hr
   20930:	3c0a0d3e 3c3e7262 0a0d3e70 3e32683c     >..<br><p>..<h2>
   20940:	2d6e7552 656d6974 61747320 74736974     Run-time statist
   20950:	3c736369 3e32682f 61500a0d 77206567     ics</h2>..Page w
   20960:	206c6c69 72666572 20687365 72657665     ill refresh ever
   20970:	20322079 6f636573 2e73646e 0d3e703c     y 2 seconds.<p>.
   20980:	6f663c0a 6620746e 3d656361 756f6322     .<font face="cou
   20990:	72656972 703c3e22 543e6572 206b7361     rier"><pre>Task 
   209a0:	20202020 20202020 41202020 54207362                Abs T
   209b0:	20656d69 20202020 54202520 3c656d69     ime      % Time<
   209c0:	2a3e7262 2a2a2a2a 2a2a2a2a 2a2a2a2a     br>*************
   209d0:	2a2a2a2a 2a2a2a2a 2a2a2a2a 2a2a2a2a     ****************
   209e0:	2a2a2a2a 2a2a2a2a 3c2a2a2a 0d3e7262     ***********<br>.
   209f0:	2021250a 2d6e7572 656d6974 2f3c0a0d     .%! run-time..</
   20a00:	3e657270 6f662f3c 0d3e746e 662f3c0a     pre></font>..</f
   20a10:	3e746e6f 2f3c0a0d 79646f62 3c0a0d3e     ont>..</body>..<
   20a20:	6d74682f 0a0d3e6c 00000a0d              /html>......

00020a2c <data_sensordata_shtml>:
   20a2c:	6e65732f 64726f73 2e617461 6d746873     /sensordata.shtm
   20a3c:	2125006c 746f7020 6c6f762d 65676174     l.%! pot-voltage
   20a4c:	00000000                                ....

00020a50 <data_smoothie_min_js>:
   20a50:	6f6d732f 6968746f 696d5f65 736a2e6e     /smoothie_min.js
   20a60:	66202100 74636e75 286e6f69 7b202965     .! function(e) {
   20a70:	72617620 3d207420 65207b20 6e657478      var t = { exten
   20a80:	66203a64 74636e75 286e6f69 207b2029     d: function() { 
   20a90:	75677261 746e656d 5d305b73 61203d20     arguments[0] = a
   20aa0:	6d756772 73746e65 205d305b 7b207c7c     rguments[0] || {
   20ab0:	66203b7d 2820726f 20726176 203d2065     }; for (var e = 
   20ac0:	65203b31 61203c20 6d756772 73746e65     1; e < arguments
   20ad0:	6e656c2e 3b687467 2b206520 2931203d     .length; e += 1)
   20ae0:	20200a0d 20202020 20202020 20202020     ..              
   20af0:	6f662020 76282072 69207261 206e6920       for (var i in 
   20b00:	75677261 746e656d 5d655b73 72612029     arguments[e]) ar
   20b10:	656d7567 5b73746e 682e5d65 774f7361     guments[e].hasOw
   20b20:	6f72506e 74726570 29692879 20262620     nProperty(i) && 
   20b30:	626f2228 7463656a 3d3d2022 70797420     ("object" == typ
   20b40:	20666f65 75677261 746e656d 5d655b73     eof arguments[e]
   20b50:	205d695b 7261203f 656d7567 5b73746e     [i] ? arguments[
   20b60:	695b5d65 6e69205d 6e617473 666f6563     e][i] instanceof
   20b70:	72724120 3f207961 67726120 6e656d75      Array ? argumen
   20b80:	305b7374 5d695b5d 61203d20 6d756772     ts[0][i] = argum
   20b90:	73746e65 5b5d655b 3a205d69 67726120     ents[e][i] : arg
   20ba0:	6e656d75 305b7374 5d695b5d 74203d20     uments[0][i] = t
   20bb0:	7478652e 28646e65 75677261 746e656d     .extend(argument
   20bc0:	5d305b73 2c5d695b 67726120 6e656d75     s[0][i], argumen
   20bd0:	655b7374 5d695b5d 203a2029 75677261     ts[e][i]) : argu
   20be0:	746e656d 5d305b73 205d695b 7261203d     ments[0][i] = ar
   20bf0:	656d7567 5b73746e 695b5d65 203b295d     guments[e][i]); 
   20c00:	75746572 61206e72 6d756772 73746e65     return arguments
   20c10:	205d305b 3b7d207d 0a0d0a0d 20202020     [0] } };....    
   20c20:	636e7566 6e6f6974 65286920 207b2029     function i(e) { 
   20c30:	73696874 74706f2e 736e6f69 74203d20     this.options = t
   20c40:	7478652e 28646e65 202c7d7b 65642e69     .extend({}, i.de
   20c50:	6c756166 74704f74 736e6f69 2965202c     faultOptions, e)
   20c60:	6874202c 632e7369 7261656c 7d202928     , this.clear() }
   20c70:	0a0d0a0d 20202020 636e7566 6e6f6974     ....    function
   20c80:	65286120 207b2029 73696874 74706f2e      a(e) { this.opt
   20c90:	736e6f69 74203d20 7478652e 28646e65     ions = t.extend(
   20ca0:	202c7d7b 65642e61 6c756166 61684374     {}, a.defaultCha
   20cb0:	704f7472 6e6f6974 65202c73 74202c29     rtOptions, e), t
   20cc0:	2e736968 69726573 65537365 203d2074     his.seriesSet = 
   20cd0:	202c5d5b 73696874 7275632e 746e6572     [], this.current
   20ce0:	756c6156 6e615265 3d206567 202c3120     ValueRange = 1, 
   20cf0:	73696874 7275632e 746e6572 4d736956     this.currentVisM
   20d00:	61566e69 2065756c 2c30203d 69687420     inValue = 0, thi
   20d10:	616c2e73 65527473 7265646e 656d6954     s.lastRenderTime
   20d20:	6c6c694d 3d207369 7d203020 20200a0d     Millis = 0 }..  
   20d30:	2e692020 61666564 4f746c75 6f697470       i.defaultOptio
   20d40:	3d20736e 72207b20 74657365 6e756f42     ns = { resetBoun
   20d50:	6e497364 76726574 203a6c61 2c336533     dsInterval: 3e3,
   20d60:	73657220 6f427465 73646e75 3021203a      resetBounds: !0
   20d70:	202c7d20 72702e69 746f746f 2e657079      }, i.prototype.
   20d80:	61656c63 203d2072 636e7566 6e6f6974     clear = function
   20d90:	7b202928 69687420 61642e73 3d206174     () { this.data =
   20da0:	2c5d5b20 69687420 616d2e73 6c615678      [], this.maxVal
   20db0:	3d206575 6d754e20 2e726562 2c4e614e     ue = Number.NaN,
   20dc0:	69687420 696d2e73 6c61566e 3d206575      this.minValue =
   20dd0:	6d754e20 2e726562 204e614e 69202c7d      Number.NaN }, i
   20de0:	6f72702e 79746f74 722e6570 74657365     .prototype.reset
   20df0:	6e756f42 3d207364 6e756620 6f697463     Bounds = functio
   20e00:	2029286e 6669207b 68742820 642e7369     n() { if (this.d
   20e10:	2e617461 676e656c 20296874 6874207b     ata.length) { th
   20e20:	6d2e7369 61567861 2065756c 6874203d     is.maxValue = th
   20e30:	642e7369 5b617461 315b5d30 74202c5d     is.data[0][1], t
   20e40:	2e736968 566e696d 65756c61 74203d20     his.minValue = t
   20e50:	2e736968 61746164 5b5d305b 203b5d31     his.data[0][1]; 
   20e60:	20726f66 72617628 3d206520 203b3120     for (var e = 1; 
   20e70:	203c2065 73696874 7461642e 656c2e61     e < this.data.le
   20e80:	6874676e 2065203b 31203d2b 207b2029     ngth; e += 1) { 
   20e90:	20726176 203d2074 73696874 7461642e     var t = this.dat
   20ea0:	5d655b61 3b5d315b 20200a0d 20202020     a[e][1];..      
   20eb0:	20202020 20202020 20742020 6874203e               t > th
   20ec0:	6d2e7369 61567861 2065756c 28202626     is.maxValue && (
   20ed0:	73696874 78616d2e 756c6156 203d2065     this.maxValue = 
   20ee0:	202c2974 203c2074 73696874 6e696d2e     t), t < this.min
   20ef0:	756c6156 26262065 68742820 6d2e7369     Value && (this.m
   20f00:	61566e69 2065756c 2974203d 7d207d20     inValue = t) } }
   20f10:	736c6520 68742065 6d2e7369 61567861      else this.maxVa
   20f20:	2065756c 754e203d 7265626d 4e614e2e     lue = Number.NaN
   20f30:	6874202c 6d2e7369 61566e69 2065756c     , this.minValue 
   20f40:	754e203d 7265626d 4e614e2e 202c7d20     = Number.NaN }, 
   20f50:	72702e69 746f746f 2e657079 65707061     i.prototype.appe
   20f60:	3d20646e 6e756620 6f697463 2c65286e     nd = function(e,
   20f70:	202c7420 7b202969 726f6620 61762820      t, i) { for (va
   20f80:	20612072 6874203d 642e7369 2e617461     r a = this.data.
   20f90:	676e656c 2d206874 203b3120 3d3e2061     length - 1; a >=
   20fa0:	26203020 68742026 642e7369 5b617461      0 && this.data[
   20fb0:	305b5d61 203e205d 20293b65 3d2d2061     a][0] > e;) a -=
   20fc0:	203b3120 2031202d 203d3d3d 203f2061      1; - 1 === a ? 
   20fd0:	73696874 7461642e 70732e61 6563696c     this.data.splice
   20fe0:	202c3028 5b202c30 74202c65 3a20295d     (0, 0, [e, t]) :
   20ff0:	69687420 61642e73 6c2e6174 74676e65      this.data.lengt
   21000:	203e2068 26262030 69687420 61642e73     h > 0 && this.da
   21010:	615b6174 5d305b5d 3d3d3d20 3f206520     ta[a][0] === e ?
   21020:	3f206920 68742820 642e7369 5b617461      i ? (this.data[
   21030:	315b5d61 3d2b205d 202c7420 203d2074     a][1] += t, t = 
   21040:	73696874 7461642e 5d615b61 295d315b     this.data[a][1])
   21050:	74203a20 2e736968 61746164 5b5d615b      : this.data[a][
   21060:	3d205d31 3a207420 3c206120 69687420     1] = t : a < thi
   21070:	61642e73 6c2e6174 74676e65 202d2068     s.data.length - 
   21080:	203f2031 73696874 7461642e 70732e61     1 ? this.data.sp
   21090:	6563696c 2b206128 202c3120 5b202c30     lice(a + 1, 0, [
   210a0:	74202c65 3a20295d 69687420 61642e73     e, t]) : this.da
   210b0:	702e6174 28687375 202c655b 2c295d74     ta.push([e, t]),
   210c0:	69687420 616d2e73 6c615678 3d206575      this.maxValue =
   210d0:	4e736920 74284e61 2e736968 5678616d      isNaN(this.maxV
   210e0:	65756c61 203f2029 203a2074 6874614d     alue) ? t : Math
   210f0:	78616d2e 69687428 616d2e73 6c615678     .max(this.maxVal
   21100:	202c6575 202c2974 73696874 6e696d2e     ue, t), this.min
   21110:	756c6156 203d2065 614e7369 6874284e     Value = isNaN(th
   21120:	6d2e7369 61566e69 2965756c 74203f20     is.minValue) ? t
   21130:	4d203a20 2e687461 286e696d 73696874      : Math.min(this
   21140:	6e696d2e 756c6156 74202c65 2c7d2029     .minValue, t) },
   21150:	702e6920 6f746f72 65707974 6f72642e      i.prototype.dro
   21160:	646c4f70 61746144 66203d20 74636e75     pOldData = funct
   21170:	286e6f69 74202c65 207b2029 20726f66     ion(e, t) { for 
   21180:	72617628 3d206920 203b3020 73696874     (var i = 0; this
   21190:	7461642e 656c2e61 6874676e 69202d20     .data.length - i
   211a0:	203d3e20 26262074 69687420 61642e73      >= t && this.da
   211b0:	695b6174 31202b20 5d305b5d 65203c20     ta[i + 1][0] < e
   211c0:	6920293b 203d2b20 0a0d3b31 20202020     ;) i += 1;..    
   211d0:	20202020 3d212030 2069203d 74202626         0 !== i && t
   211e0:	2e736968 61746164 6c70732e 28656369     his.data.splice(
   211f0:	69202c30 2c7d2029 642e6120 75616665     0, i) }, a.defau
   21200:	6843746c 4f747261 6f697470 3d20736e     ltChartOptions =
   21210:	6d207b20 696c6c69 72655073 65786950      { millisPerPixe
   21220:	32203a6c 65202c30 6c62616e 69704465     l: 20, enableDpi
   21230:	6c616353 3a676e69 2c302120 694d7920     Scaling: !0, yMi
   21240:	726f466e 7474616d 203a7265 636e7566     nFormatter: func
   21250:	6e6f6974 202c6528 7b202974 74657220     tion(e, t) { ret
   21260:	206e7275 73726170 6f6c4665 65287461     urn parseFloat(e
   21270:	6f742e29 65786946 29742864 202c7d20     ).toFixed(t) }, 
   21280:	78614d79 6d726f46 65747461 66203a72     yMaxFormatter: f
   21290:	74636e75 286e6f69 74202c65 207b2029     unction(e, t) { 
   212a0:	75746572 70206e72 65737261 616f6c46     return parseFloa
   212b0:	29652874 466f742e 64657869 20297428     t(e).toFixed(t) 
   212c0:	6d202c7d 61567861 5365756c 656c6163     }, maxValueScale
   212d0:	2c31203a 6e696d20 756c6156 61635365     : 1, minValueSca
   212e0:	203a656c 69202c31 7265746e 616c6f70     le: 1, interpola
   212f0:	6e6f6974 6222203a 65697a65 202c2272     tion: "bezier", 
   21300:	6c616373 6f6d5365 6968746f 203a676e     scaleSmoothing: 
   21310:	3532312e 616d202c 74614478 74655361     .125, maxDataSet
   21320:	676e654c 203a6874 73202c32 6c6f7263     Length: 2, scrol
   21330:	6361426c 7261776b 203a7364 202c3121     lBackwards: !1, 
   21340:	64697267 207b203a 6c6c6966 6c797453     grid: { fillStyl
   21350:	22203a65 30303023 22303030 7473202c     e: "#000000", st
   21360:	656b6f72 6c797453 22203a65 37373723     rokeStyle: "#777
   21370:	22373737 696c202c 6957656e 3a687464     777", lineWidth:
   21380:	202c3120 72616873 6e694c70 203a7365      1, sharpLines: 
   21390:	202c3121 6c6c696d 65507369 6e694c72     !1, millisPerLin
   213a0:	31203a65 202c3365 74726576 6c616369     e: 1e3, vertical
   213b0:	74636553 736e6f69 2c32203a 726f6220     Sections: 2, bor
   213c0:	56726564 62697369 203a656c 7d203021     derVisible: !0 }
   213d0:	616c202c 736c6562 207b203a 6c6c6966     , labels: { fill
   213e0:	6c797453 22203a65 66666623 22666666     Style: "#ffffff"
   213f0:	6964202c 6c626173 203a6465 202c3121     , disabled: !1, 
   21400:	746e6f66 657a6953 3031203a 6f66202c     fontSize: 10, fo
   21410:	6146746e 796c696d 6d22203a 736f6e6f     ntFamily: "monos
   21420:	65636170 70202c22 69636572 6e6f6973     pace", precision
   21430:	2032203a 68202c7d 7a69726f 61746e6f     : 2 }, horizonta
   21440:	6e694c6c 203a7365 7d205d5b 2e61202c     lLines: [] }, a.
   21450:	6d696e41 43657461 61706d6f 69626974     AnimateCompatibi
   21460:	7974696c 7b203d20 71657220 74736575     lity = { request
   21470:	6d696e41 6f697461 6172466e 203a656d     AnimationFrame: 
   21480:	636e7566 6e6f6974 202c6528 7b202974     function(e, t) {
   21490:	74657220 206e7275 6e697728 2e776f64      return (window.
   214a0:	75716572 41747365 616d696e 6e6f6974     requestAnimation
   214b0:	6d617246 7c7c2065 6e697720 2e776f64     Frame || window.
   214c0:	6b626577 65527469 73657571 696e4174     webkitRequestAni
   214d0:	6974616d 72466e6f 20656d61 77207c7c     mationFrame || w
   214e0:	6f646e69 6f6d2e77 7165527a 74736575     indow.mozRequest
   214f0:	6d696e41 6f697461 6172466e 7c20656d     AnimationFrame |
   21500:	6977207c 776f646e 65526f2e 73657571     | window.oReques
   21510:	696e4174 6974616d 72466e6f 20656d61     tAnimationFrame 
   21520:	77207c7c 6f646e69 736d2e77 75716552     || window.msRequ
   21530:	41747365 616d696e 6e6f6974 6d617246     estAnimationFram
   21540:	7c7c2065 6e756620 6f697463 2965286e     e || function(e)
   21550:	72207b20 72757465 6977206e 776f646e      { return window
   21560:	7465732e 656d6954 2874756f 636e7566     .setTimeout(func
   21570:	6e6f6974 7b202928 28286520 2077656e     tion() { e((new 
   21580:	65746144 65672e29 6d695474 29292865     Date).getTime())
   21590:	202c7d20 20293631 632e297d 286c6c61      }, 16) }).call(
   215a0:	646e6977 202c776f 74202c65 2c7d2029     window, e, t) },
   215b0:	6e616320 416c6563 616d696e 6e6f6974      cancelAnimation
   215c0:	6d617246 66203a65 74636e75 286e6f69     Frame: function(
   215d0:	7b202965 74657220 206e7275 6e697728     e) { return (win
   215e0:	2e776f64 636e6163 6e416c65 74616d69     dow.cancelAnimat
   215f0:	466e6f69 656d6172 207c7c20 636e7566     ionFrame || func
   21600:	6e6f6974 20296528 6c63207b 54726165     tion(e) { clearT
   21610:	6f656d69 65287475 297d2029 6c61632e     imeout(e) }).cal
   21620:	6977286c 776f646e 2965202c 7d207d20     l(window, e) } }
   21630:	2e61202c 61666564 53746c75 65697265     , a.defaultSerie
   21640:	65725073 746e6573 6f697461 74704f6e     sPresentationOpt
   21650:	736e6f69 7b203d20 6e696c20 64695765     ions = { lineWid
   21660:	203a6874 73202c31 6b6f7274 79745365     th: 1, strokeSty
   21670:	203a656c 66662322 66666666 2c7d2022     le: "#ffffff" },
   21680:	702e6120 6f746f72 65707974 6464612e      a.prototype.add
   21690:	656d6954 69726553 3d207365 6e756620     TimeSeries = fun
   216a0:	6f697463 2c65286e 20296920 6874207b     ction(e, i) { th
   216b0:	732e7369 65697265 74655373 7375702e     is.seriesSet.pus
   216c0:	207b2868 656d6974 69726553 203a7365     h({ timeSeries: 
   216d0:	6f202c65 6f697470 203a736e 78652e74     e, options: t.ex
   216e0:	646e6574 2c7d7b28 642e6120 75616665     tend({}, a.defau
   216f0:	6553746c 73656972 73657250 61746e65     ltSeriesPresenta
   21700:	6e6f6974 6974704f 2c736e6f 20296920     tionOptions, i) 
   21710:	202c297d 706f2e65 6e6f6974 65722e73     }), e.options.re
   21720:	42746573 646e756f 26262073 6f2e6520     setBounds && e.o
   21730:	6f697470 722e736e 74657365 6e756f42     ptions.resetBoun
   21740:	6e497364 76726574 3e206c61 26203020     dsInterval > 0 &
   21750:	65282026 7365722e 6f427465 73646e75     & (e.resetBounds
   21760:	656d6954 20644972 6573203d 746e4974     TimerId = setInt
   21770:	61767265 7566286c 6974636e 29286e6f     erval(function()
   21780:	65207b20 7365722e 6f427465 73646e75      { e.resetBounds
   21790:	7d202928 2e65202c 6974706f 2e736e6f     () }, e.options.
   217a0:	65736572 756f4274 4973646e 7265746e     resetBoundsInter
   217b0:	296c6176 2c7d2029 702e6120 6f746f72     val)) }, a.proto
   217c0:	65707974 6d65722e 5465766f 53656d69     type.removeTimeS
   217d0:	65697265 203d2073 636e7566 6e6f6974     eries = function
   217e0:	20296528 6f66207b 76282072 74207261     (e) { for (var t
   217f0:	74203d20 2e736968 69726573 65537365      = this.seriesSe
   21800:	656c2e74 6874676e 2069202c 3b30203d     t.length, i = 0;
   21810:	3c206920 203b7420 3d2b2069 0d293120      i < t; i += 1).
   21820:	2020200a 20202020 20202020 20666920     .            if 
   21830:	69687428 65732e73 73656972 5b746553     (this.seriesSet[
   21840:	742e5d69 53656d69 65697265 3d3d2073     i].timeSeries ==
   21850:	2965203d 74207b20 2e736968 69726573     = e) { this.seri
   21860:	65537365 70732e74 6563696c 202c6928     esSet.splice(i, 
   21870:	203b2931 61657262 0d7d206b 2020200a     1); break }..   
   21880:	20202020 722e6520 74657365 6e756f42          e.resetBoun
   21890:	69547364 4972656d 26262064 656c6320     dsTimerId && cle
   218a0:	6e497261 76726574 65286c61 7365722e     arInterval(e.res
   218b0:	6f427465 73646e75 656d6954 29644972     etBoundsTimerId)
   218c0:	202c7d20 72702e61 746f746f 2e657079      }, a.prototype.
   218d0:	54746567 53656d69 65697265 74704f73     getTimeSeriesOpt
   218e0:	736e6f69 66203d20 74636e75 286e6f69     ions = function(
   218f0:	7b202965 726f6620 61762820 20742072     e) { for (var t 
   21900:	6874203d 732e7369 65697265 74655373     = this.seriesSet
   21910:	6e656c2e 2c687467 3d206920 203b3020     .length, i = 0; 
   21920:	203c2069 69203b74 203d2b20 0a0d2931     i < t; i += 1)..
   21930:	20202020 20202020 20202020 28206669                 if (
   21940:	73696874 7265732e 53736569 695b7465     this.seriesSet[i
   21950:	69742e5d 6553656d 73656972 3d3d3d20     ].timeSeries ===
   21960:	20296520 75746572 74206e72 2e736968      e) return this.
   21970:	69726573 65537365 5d695b74 74706f2e     seriesSet[i].opt
   21980:	736e6f69 202c7d20 72702e61 746f746f     ions }, a.protot
   21990:	2e657079 6e697262 466f5467 746e6f72     ype.bringToFront
   219a0:	66203d20 74636e75 286e6f69 7b202965      = function(e) {
   219b0:	726f6620 61762820 20742072 6874203d      for (var t = th
   219c0:	732e7369 65697265 74655373 6e656c2e     is.seriesSet.len
   219d0:	2c687467 3d206920 203b3020 203c2069     gth, i = 0; i < 
   219e0:	69203b74 203d2b20 0a0d2931 20202020     t; i += 1)..    
   219f0:	20202020 20202020 28206669 73696874             if (this
   21a00:	7265732e 53736569 695b7465 69742e5d     .seriesSet[i].ti
   21a10:	6553656d 73656972 3d3d3d20 20296520     meSeries === e) 
   21a20:	6176207b 20612072 6874203d 732e7369     { var a = this.s
   21a30:	65697265 74655373 6c70732e 28656369     eriesSet.splice(
   21a40:	31202c69 0a0d3b29 20202020 20202020     i, 1);..        
   21a50:	20202020 20202020 73696874 7265732e             this.ser
   21a60:	53736569 702e7465 28687375 5d305b61     iesSet.push(a[0]
   21a70:	62203b29 6b616572 7d207d20 2e61202c     ); break } }, a.
   21a80:	746f7270 7079746f 74732e65 6d616572     prototype.stream
   21a90:	3d206f54 6e756620 6f697463 2c65286e     To = function(e,
   21aa0:	20297420 6874207b 632e7369 61766e61      t) { this.canva
   21ab0:	203d2073 74202c65 2e736968 616c6564     s = e, this.dela
   21ac0:	203d2079 74202c74 2e736968 72617473     y = t, this.star
   21ad0:	20292874 61202c7d 6f72702e 79746f74     t() }, a.prototy
   21ae0:	722e6570 7a697365 203d2065 636e7566     pe.resize = func
   21af0:	6e6f6974 7b202928 20666920 69687428     tion() { if (thi
   21b00:	706f2e73 6e6f6974 6e652e73 656c6261     s.options.enable
   21b10:	53697044 696c6163 2620676e 69772026     DpiScaling && wi
   21b20:	776f646e 20262620 3d212031 6977203d     ndow && 1 !== wi
   21b30:	776f646e 7665642e 50656369 6c657869     ndow.devicePixel
   21b40:	69746152 7b20296f 72617620 3d206520     Ratio) { var e =
   21b50:	6e697720 2e776f64 69766564 69506563      window.devicePi
   21b60:	526c6578 6f697461 200a0d2c 20202020     xelRatio,..     
   21b70:	20202020 20202020 74202020 70203d20                t = p
   21b80:	65737261 28746e49 73696874 6e61632e     arseInt(this.can
   21b90:	2e736176 41746567 69727474 65747562     vas.getAttribute
   21ba0:	69772228 22687464 0d2c2929 2020200a     ("width")),..   
   21bb0:	20202020 20202020 20202020 3d206920                  i =
   21bc0:	72617020 6e496573 68742874 632e7369      parseInt(this.c
   21bd0:	61766e61 65672e73 74744174 75626972     anvas.getAttribu
   21be0:	22286574 67696568 29227468 0a0d3b29     te("height"));..
   21bf0:	20202020 20202020 20202020 73696874                 this
   21c00:	69726f2e 616e6967 6469576c 26206874     .originalWidth &
   21c10:	614d2026 662e6874 726f6f6c 69687428     & Math.floor(thi
   21c20:	726f2e73 6e696769 69576c61 20687464     s.originalWidth 
   21c30:	2965202a 3d3d3d20 7c207420 7428207c     * e) === t || (t
   21c40:	2e736968 6769726f 6c616e69 74646957     his.originalWidt
   21c50:	203d2068 74202c74 2e736968 766e6163     h = t, this.canv
   21c60:	732e7361 74417465 62697274 28657475     as.setAttribute(
   21c70:	64697722 2c226874 74614d20 6c662e68     "width", Math.fl
   21c80:	28726f6f 202a2074 742e2965 7274536f     oor(t * e).toStr
   21c90:	28676e69 202c2929 73696874 6e61632e     ing()), this.can
   21ca0:	2e736176 6c797473 69772e65 20687464     vas.style.width 
   21cb0:	2074203d 7022202b 202c2278 73696874     = t + "px", this
   21cc0:	6e61632e 2e736176 43746567 65746e6f     .canvas.getConte
   21cd0:	22287478 29226432 6163732e 6528656c     xt("2d").scale(e
   21ce0:	2965202c 74202c29 2e736968 6769726f     , e)), this.orig
   21cf0:	6c616e69 67696548 26207468 614d2026     inalHeight && Ma
   21d00:	662e6874 726f6f6c 69687428 726f2e73     th.floor(this.or
   21d10:	6e696769 65486c61 74686769 65202a20     iginalHeight * e
   21d20:	3d3d2029 2069203d 28207c7c 73696874     ) === i || (this
   21d30:	69726f2e 616e6967 6965486c 20746867     .originalHeight 
   21d40:	2c69203d 69687420 61632e73 7361766e     = i, this.canvas
   21d50:	7465732e 72747441 74756269 68222865     .setAttribute("h
   21d60:	68676965 202c2274 6874614d 6f6c662e     eight", Math.flo
   21d70:	6928726f 65202a20 6f742e29 69727453     or(i * e).toStri
   21d80:	2928676e 74202c29 2e736968 766e6163     ng()), this.canv
   21d90:	732e7361 656c7974 6965682e 20746867     as.style.height 
   21da0:	2069203d 7022202b 202c2278 73696874     = i + "px", this
   21db0:	6e61632e 2e736176 43746567 65746e6f     .canvas.getConte
   21dc0:	22287478 29226432 6163732e 6528656c     xt("2d").scale(e
   21dd0:	2965202c 207d2029 61202c7d 6f72702e     , e)) } }, a.pro
   21de0:	79746f74 732e6570 74726174 66203d20     totype.start = f
   21df0:	74636e75 286e6f69 207b2029 28206669     unction() { if (
   21e00:	69687421 72662e73 29656d61 76207b20     !this.frame) { v
   21e10:	65207261 66203d20 74636e75 286e6f69     ar e = function(
   21e20:	207b2029 73696874 6172662e 3d20656d     ) { this.frame =
   21e30:	412e6120 616d696e 6f436574 7461706d      a.AnimateCompat
   21e40:	6c696269 2e797469 75716572 41747365     ibility.requestA
   21e50:	616d696e 6e6f6974 6d617246 75662865     nimationFrame(fu
   21e60:	6974636e 29286e6f 74207b20 2e736968     nction() { this.
   21e70:	646e6572 29287265 2865202c 2e7d2029     render(), e() }.
   21e80:	646e6962 69687428 20292973 69622e7d     bind(this)) }.bi
   21e90:	7428646e 29736968 200a0d3b 20202020     nd(this);..     
   21ea0:	20202020 65202020 7d202928 202c7d20            e() } }, 
   21eb0:	72702e61 746f746f 2e657079 706f7473     a.prototype.stop
   21ec0:	66203d20 74636e75 286e6f69 207b2029      = function() { 
   21ed0:	73696874 6172662e 2620656d 61282026     this.frame && (a
   21ee0:	696e412e 6574616d 706d6f43 62697461     .AnimateCompatib
   21ef0:	74696c69 61632e79 6c65636e 6d696e41     ility.cancelAnim
   21f00:	6f697461 6172466e 7428656d 2e736968     ationFrame(this.
   21f10:	6d617266 202c2965 656c6564 74206574     frame), delete t
   21f20:	2e736968 6d617266 7d202965 2e61202c     his.frame) }, a.
   21f30:	746f7270 7079746f 70752e65 65746164     prototype.update
   21f40:	756c6156 6e615265 3d206567 6e756620     ValueRange = fun
   21f50:	6f697463 2029286e 6f66207b 76282072     ction() { for (v
   21f60:	65207261 74203d20 2e736968 6974706f     ar e = this.opti
   21f70:	2c736e6f 3d207420 6d754e20 2e726562     ons, t = Number.
   21f80:	2c4e614e 3d206920 6d754e20 2e726562     NaN, i = Number.
   21f90:	2c4e614e 3d206120 203b3020 203c2061     NaN, a = 0; a < 
   21fa0:	73696874 7265732e 53736569 6c2e7465     this.seriesSet.l
   21fb0:	74676e65 61203b68 203d2b20 7b202931     ength; a += 1) {
   21fc0:	72617620 3d207320 69687420 65732e73      var s = this.se
   21fd0:	73656972 5b746553 742e5d61 53656d69     riesSet[a].timeS
   21fe0:	65697265 0a0d3b73 20202020 20202020     eries;..        
   21ff0:	20202020 614e7369 2e73284e 5678616d         isNaN(s.maxV
   22000:	65756c61 7c7c2029 20742820 7369203d     alue) || (t = is
   22010:	284e614e 3f202974 6d2e7320 61567861     NaN(t) ? s.maxVa
   22020:	2065756c 614d203a 6d2e6874 74287861     lue : Math.max(t
   22030:	2e73202c 5678616d 65756c61 202c2929     , s.maxValue)), 
   22040:	614e7369 2e73284e 566e696d 65756c61     isNaN(s.minValue
   22050:	7c7c2029 20692820 7369203d 284e614e     ) || (i = isNaN(
   22060:	3f202969 6d2e7320 61566e69 2065756c     i) ? s.minValue 
   22070:	614d203a 6d2e6874 69286e69 2e73202c     : Math.min(i, s.
   22080:	566e696d 65756c61 7d202929 20666920     minValue)) } if 
   22090:	6c756e28 3d21206c 6d2e6520 61567861     (null != e.maxVa
   220a0:	2065756c 2074203f 2e65203d 5678616d     lue ? t = e.maxV
   220b0:	65756c61 74203a20 203d2a20 616d2e65     alue : t *= e.ma
   220c0:	6c615678 63536575 2c656c61 6c756e20     xValueScale, nul
   220d0:	3d21206c 6d2e6520 61566e69 2065756c     l != e.minValue 
   220e0:	2069203f 2e65203d 566e696d 65756c61     ? i = e.minValue
   220f0:	69203a20 203d2d20 6874614d 7362612e      : i -= Math.abs
   22100:	2a206928 6d2e6520 61566e69 5365756c     (i * e.minValueS
   22110:	656c6163 69202d20 74202c29 2e736968     cale - i), this.
   22120:	6974706f 2e736e6f 6e615279 75466567     options.yRangeFu
   22130:	6974636e 20296e6f 6176207b 206e2072     nction) { var n 
   22140:	6874203d 6f2e7369 6f697470 792e736e     = this.options.y
   22150:	676e6152 6e754665 6f697463 207b286e     RangeFunction({ 
   22160:	3a6e696d 202c6920 3a78616d 7d207420     min: i, max: t }
   22170:	0a0d3b29 20202020 20202020 20202020     );..            
   22180:	203d2069 696d2e6e 74202c6e 6e203d20     i = n.min, t = n
   22190:	78616d2e 69207d20 21282066 614e7369     .max } if (!isNa
   221a0:	2974284e 20262620 4e736921 69284e61     N(t) && !isNaN(i
   221b0:	7b202929 72617620 3d207220 2d207420     )) { var r = t -
   221c0:	2d206920 69687420 75632e73 6e657272      i - this.curren
   221d0:	6c615674 61526575 2c65676e 20200a0d     tValueRange,..  
   221e0:	20202020 20202020 20202020 206c2020                   l 
   221f0:	2069203d 6874202d 632e7369 65727275     = i - this.curre
   22200:	6956746e 6e694d73 756c6156 0a0d3b65     ntVisMinValue;..
   22210:	20202020 20202020 20202020 73696874                 this
   22220:	4173692e 616d696e 676e6974 6c616353     .isAnimatingScal
   22230:	203d2065 6874614d 7362612e 20297228     e = Math.abs(r) 
   22240:	312e203e 207c7c20 6874614d 7362612e     > .1 || Math.abs
   22250:	20296c28 312e203e 6874202c 632e7369     (l) > .1, this.c
   22260:	65727275 6156746e 5265756c 65676e61     urrentValueRange
   22270:	203d2b20 63732e65 53656c61 746f6f6d      += e.scaleSmoot
   22280:	676e6968 72202a20 6874202c 632e7369     hing * r, this.c
   22290:	65727275 6956746e 6e694d73 756c6156     urrentVisMinValu
   222a0:	3d2b2065 732e6520 656c6163 6f6f6d53     e += e.scaleSmoo
   222b0:	6e696874 202a2067 0d7d206c 2020200a     thing * l }..   
   222c0:	20202020 69687420 61762e73 5265756c          this.valueR
   222d0:	65676e61 7b203d20 6e696d20 2c69203a     ange = { min: i,
   222e0:	78616d20 2074203a 2c7d207d 702e6120      max: t } }, a.p
   222f0:	6f746f72 65707974 6e65722e 20726564     rototype.render 
   22300:	7566203d 6974636e 65286e6f 2974202c     = function(e, t)
   22310:	76207b20 69207261 28203d20 2077656e      { var i = (new 
   22320:	65746144 65672e29 6d695474 3b292865     Date).getTime();
   22330:	20666920 68742128 692e7369 696e4173      if (!this.isAni
   22340:	6974616d 6353676e 29656c61 76207b20     matingScale) { v
   22350:	61207261 4d203d20 2e687461 286e696d     ar a = Math.min(
   22360:	20336531 2c36202f 69687420 706f2e73     1e3 / 6, this.op
   22370:	6e6f6974 696d2e73 73696c6c 50726550     tions.millisPerP
   22380:	6c657869 69203b29 69282066 74202d20     ixel); if (i - t
   22390:	2e736968 7473616c 646e6552 69547265     his.lastRenderTi
   223a0:	694d656d 73696c6c 61203c20 65722029     meMillis < a) re
   223b0:	6e727574 0a0d7d20 20202020 20202020     turn }..        
   223c0:	73696874 7365722e 28657a69 74202c29     this.resize(), t
   223d0:	2e736968 7473616c 646e6552 69547265     his.lastRenderTi
   223e0:	694d656d 73696c6c 69203d20 2065202c     meMillis = i, e 
   223f0:	2065203d 74207c7c 2e736968 766e6163     = e || this.canv
   22400:	202c7361 203d2074 7c7c2074 2d206920     as, t = t || i -
   22410:	68742820 642e7369 79616c65 207c7c20      (this.delay || 
   22420:	202c2930 3d2d2074 25207420 69687420     0), t -= t % thi
   22430:	706f2e73 6e6f6974 696d2e73 73696c6c     s.options.millis
   22440:	50726550 6c657869 6176203b 20732072     PerPixel; var s 
   22450:	2e65203d 43746567 65746e6f 22287478     = e.getContext("
   22460:	29226432 200a0d2c 20202020 20202020     2d"),..         
   22470:	6e202020 74203d20 2e736968 6974706f        n = this.opti
   22480:	2c736e6f 20200a0d 20202020 20202020     ons,..          
   22490:	20722020 207b203d 3a706f74 202c3020       r = { top: 0, 
   224a0:	7466656c 2c30203a 64697720 203a6874     left: 0, width: 
   224b0:	6c632e65 746e6569 74646957 68202c68     e.clientWidth, h
   224c0:	68676965 65203a74 696c632e 48746e65     eight: e.clientH
   224d0:	68676965 2c7d2074 20200a0d 20202020     eight },..      
   224e0:	20202020 206c2020 2074203d 2e72202d           l = t - r.
   224f0:	74646977 202a2068 696d2e6e 73696c6c     width * n.millis
   22500:	50726550 6c657869 200a0d2c 20202020     PerPixel,..     
   22510:	20202020 6f202020 66203d20 74636e75            o = funct
   22520:	286e6f69 7b202965 72617620 3d207420     ion(e) { var t =
   22530:	2d206520 69687420 75632e73 6e657272      e - this.curren
   22540:	73695674 566e694d 65756c61 6572203b     tVisMinValue; re
   22550:	6e727574 3d203020 74203d3d 2e736968     turn 0 === this.
   22560:	72727563 56746e65 65756c61 676e6152     currentValueRang
   22570:	203f2065 65682e72 74686769 72203a20     e ? r.height : r
   22580:	6965682e 20746867 614d202d 722e6874     .height - Math.r
   22590:	646e756f 2f207428 69687420 75632e73     ound(t / this.cu
   225a0:	6e657272 6c615674 61526575 2065676e     rrentValueRange 
   225b0:	2e72202a 67696568 20297468 69622e7d     * r.height) }.bi
   225c0:	7428646e 29736968 200a0d2c 20202020     nd(this),..     
   225d0:	20202020 68202020 66203d20 74636e75            h = funct
   225e0:	286e6f69 7b202965 74657220 206e7275     ion(e) { return 
   225f0:	63732e6e 6c6c6f72 6b636142 64726177     n.scrollBackward
   22600:	203f2073 6874614d 756f722e 2828646e     s ? Math.round((
   22610:	202d2074 2f202965 6d2e6e20 696c6c69     t - e) / n.milli
   22620:	72655073 65786950 3a20296c 74614d20     sPerPixel) : Mat
   22630:	6f722e68 28646e75 69772e72 20687464     h.round(r.width 
   22640:	7428202d 65202d20 202f2029 696d2e6e     - (t - e) / n.mi
   22650:	73696c6c 50726550 6c657869 3b7d2029     llisPerPixel) };
   22660:	20666920 69687428 70752e73 65746164      if (this.update
   22670:	756c6156 6e615265 29286567 2e73202c     ValueRange(), s.
   22680:	746e6f66 6e203d20 62616c2e 2e736c65     font = n.labels.
   22690:	746e6f66 657a6953 22202b20 22207870     fontSize + "px "
   226a0:	6e202b20 62616c2e 2e736c65 746e6f66      + n.labels.font
   226b0:	696d6146 202c796c 61732e73 29286576     Family, s.save()
   226c0:	2e73202c 6e617274 74616c73 2e722865     , s.translate(r.
   226d0:	7466656c 2e72202c 29706f74 2e73202c     left, r.top), s.
   226e0:	69676562 7461506e 2c292868 722e7320     beginPath(), s.r
   226f0:	28746365 30202c30 2e72202c 74646977     ect(0, 0, r.widt
   22700:	72202c68 6965682e 29746867 2e73202c     h, r.height), s.
   22710:	70696c63 202c2928 61732e73 29286576     clip(), s.save()
   22720:	2e73202c 6c6c6966 6c797453 203d2065     , s.fillStyle = 
   22730:	72672e6e 662e6469 536c6c69 656c7974     n.grid.fillStyle
   22740:	2e73202c 61656c63 63655272 2c302874     , s.clearRect(0,
   22750:	202c3020 69772e72 2c687464 682e7220      0, r.width, r.h
   22760:	68676965 202c2974 69662e73 65526c6c     eight), s.fillRe
   22770:	30287463 2c30202c 772e7220 68746469     ct(0, 0, r.width
   22780:	2e72202c 67696568 2c297468 722e7320     , r.height), s.r
   22790:	6f747365 29286572 2e73202c 65766173     estore(), s.save
   227a0:	202c2928 696c2e73 6957656e 20687464     (), s.lineWidth 
   227b0:	2e6e203d 64697267 6e696c2e 64695765     = n.grid.lineWid
   227c0:	202c6874 74732e73 656b6f72 6c797453     th, s.strokeStyl
   227d0:	203d2065 72672e6e 732e6469 6b6f7274     e = n.grid.strok
   227e0:	79745365 202c656c 72672e6e 6d2e6469     eStyle, n.grid.m
   227f0:	696c6c69 72655073 656e694c 30203e20     illisPerLine > 0
   22800:	207b2029 65622e73 506e6967 28687461     ) { s.beginPath(
   22810:	66203b29 2820726f 20726176 203d2064     ); for (var d = 
   22820:	202d2074 20252074 72672e6e 6d2e6469     t - t % n.grid.m
   22830:	696c6c69 72655073 656e694c 2064203b     illisPerLine; d 
   22840:	6c203d3e 2064203b 6e203d2d 6972672e     >= l; d -= n.gri
   22850:	696d2e64 73696c6c 4c726550 29656e69     d.millisPerLine)
   22860:	76207b20 75207261 68203d20 3b296428      { var u = h(d);
   22870:	20200a0d 20202020 20202020 20202020     ..              
   22880:	2e6e2020 64697267 6168732e 694c7072       n.grid.sharpLi
   22890:	2073656e 28202626 3d2d2075 29352e20     nes && (u -= .5)
   228a0:	2e73202c 65766f6d 75286f54 2930202c     , s.moveTo(u, 0)
   228b0:	2e73202c 656e696c 75286f54 2e72202c     , s.lineTo(u, r.
   228c0:	67696568 20297468 200a0d7d 20202020     height) }..     
   228d0:	20202020 73202020 7274732e 28656b6f            s.stroke(
   228e0:	73202c29 6f6c632e 61506573 29286874     ), s.closePath()
   228f0:	66207d20 2820726f 20726176 203d206d      } for (var m = 
   22900:	6d203b31 6e203c20 6972672e 65762e64     1; m < n.grid.ve
   22910:	63697472 65536c61 6f697463 203b736e     rticalSections; 
   22920:	3d2b206d 20293120 6176207b 20632072     m += 1) { var c 
   22930:	614d203d 722e6874 646e756f 2a206d28     = Math.round(m *
   22940:	682e7220 68676965 202f2074 72672e6e      r.height / n.gr
   22950:	762e6469 69747265 536c6163 69746365     id.verticalSecti
   22960:	29736e6f 200a0d3b 20202020 20202020     ons);..         
   22970:	6e202020 6972672e 68732e64 4c707261        n.grid.sharpL
   22980:	73656e69 20262620 2d206328 352e203d     ines && (c -= .5
   22990:	73202c29 6765622e 61506e69 29286874     ), s.beginPath()
   229a0:	2e73202c 65766f6d 30286f54 2963202c     , s.moveTo(0, c)
   229b0:	2e73202c 656e696c 72286f54 6469772e     , s.lineTo(r.wid
   229c0:	202c6874 202c2963 74732e73 656b6f72     th, c), s.stroke
   229d0:	202c2928 6c632e73 5065736f 28687461     (), s.closePath(
   229e0:	207d2029 28206669 72672e6e 622e6469     ) } if (n.grid.b
   229f0:	6564726f 73695672 656c6269 20262620     orderVisible && 
   22a00:	622e7328 6e696765 68746150 202c2928     (s.beginPath(), 
   22a10:	74732e73 656b6f72 74636552 202c3028     s.strokeRect(0, 
   22a20:	72202c30 6469772e 202c6874 65682e72     0, r.width, r.he
   22a30:	74686769 73202c29 6f6c632e 61506573     ight), s.closePa
   22a40:	29286874 73202c29 7365722e 65726f74     th()), s.restore
   22a50:	202c2928 6f682e6e 6f7a6972 6c61746e     (), n.horizontal
   22a60:	656e694c 26262073 682e6e20 7a69726f     Lines && n.horiz
   22a70:	61746e6f 6e694c6c 6c2e7365 74676e65     ontalLines.lengt
   22a80:	0a0d2968 20202020 20202020 20202020     h)..            
   22a90:	20726f66 72617628 3d206620 203b3020     for (var f = 0; 
   22aa0:	203c2066 6f682e6e 6f7a6972 6c61746e     f < n.horizontal
   22ab0:	656e694c 656c2e73 6874676e 2066203b     Lines.length; f 
   22ac0:	31203d2b 207b2029 20726176 203d2067     += 1) { var g = 
   22ad0:	6f682e6e 6f7a6972 6c61746e 656e694c     n.horizontalLine
   22ae0:	5d665b73 200a0d2c 20202020 20202020     s[f],..         
   22af0:	20202020 20202020 70202020 4d203d20                p = M
   22b00:	2e687461 6e756f72 286f2864 61762e67     ath.round(o(g.va
   22b10:	2965756c 202d2029 0d3b352e 2020200a     lue)) - .5;..   
   22b20:	20202020 20202020 20202020 732e7320                  s.s
   22b30:	6b6f7274 79745365 3d20656c 632e6720     trokeStyle = g.c
   22b40:	726f6c6f 207c7c20 66662322 66666666     olor || "#ffffff
   22b50:	73202c22 6e696c2e 64695765 3d206874     ", s.lineWidth =
   22b60:	6c2e6720 57656e69 68746469 207c7c20      g.lineWidth || 
   22b70:	73202c31 6765622e 61506e69 29286874     1, s.beginPath()
   22b80:	2e73202c 65766f6d 30286f54 2970202c     , s.moveTo(0, p)
   22b90:	2e73202c 656e696c 72286f54 6469772e     , s.lineTo(r.wid
   22ba0:	202c6874 202c2970 74732e73 656b6f72     th, p), s.stroke
   22bb0:	202c2928 6c632e73 5065736f 28687461     (), s.closePath(
   22bc0:	0d7d2029 2020200a 20202020 726f6620     ) }..        for
   22bd0:	61762820 20532072 3b30203d 3c205320      (var S = 0; S <
   22be0:	69687420 65732e73 73656972 2e746553      this.seriesSet.
   22bf0:	676e656c 203b6874 3d2b2053 20293120     length; S += 1) 
   22c00:	2e73207b 65766173 203b2928 20726176     { s.save(); var 
   22c10:	203d2076 73696874 7265732e 53736569     v = this.seriesS
   22c20:	535b7465 69742e5d 6553656d 73656972     et[S].timeSeries
   22c30:	200a0d2c 20202020 20202020 20202020     ,..             
   22c40:	77202020 76203d20 7461642e 0a0d2c61        w = v.data,..
   22c50:	20202020 20202020 20202020 20202020                     
   22c60:	203d2078 73696874 7265732e 53736569     x = this.seriesS
   22c70:	535b7465 706f2e5d 6e6f6974 0a0d3b73     et[S].options;..
   22c80:	20202020 20202020 20202020 72642e76                 v.dr
   22c90:	6c4f706f 74614464 2c6c2861 6d2e6e20     opOldData(l, n.m
   22ca0:	61447861 65536174 6e654c74 29687467     axDataSetLength)
   22cb0:	2e73202c 656e696c 74646957 203d2068     , s.lineWidth = 
   22cc0:	696c2e78 6957656e 2c687464 732e7320     x.lineWidth, s.s
   22cd0:	6b6f7274 79745365 3d20656c 732e7820     trokeStyle = x.s
   22ce0:	6b6f7274 79745365 202c656c 65622e73     trokeStyle, s.be
   22cf0:	506e6967 28687461 66203b29 2820726f     ginPath(); for (
   22d00:	20726176 203d2079 62202c30 30203d20     var y = 0, b = 0
   22d10:	2056202c 2c30203d 3d205420 203b3020     , V = 0, T = 0; 
   22d20:	203c2054 656c2e77 6874676e 20262620     T < w.length && 
   22d30:	3d212031 2e77203d 676e656c 203b6874     1 !== w.length; 
   22d40:	3d2b2054 20293120 6176207b 204e2072     T += 1) { var N 
   22d50:	2868203d 5d545b77 295d305b 200a0d2c     = h(w[T][0]),.. 
   22d60:	20202020 20202020 20202020 20202020                     
   22d70:	50202020 6f203d20 545b7728 5d315b5d        P = o(w[T][1]
   22d80:	69203b29 30282066 3d3d3d20 20295420     ); if (0 === T) 
   22d90:	203d2079 73202c4e 766f6d2e 286f5465     y = N, s.moveTo(
   22da0:	50202c4e 0a0d3b29 20202020 20202020     N, P);..        
   22db0:	20202020 20202020 65736c65 69777320             else swi
   22dc0:	20686374 692e6e28 7265746e 616c6f70     tch (n.interpola
   22dd0:	6e6f6974 0d7b2029 2020200a 20202020     tion) {..       
   22de0:	20202020 20202020 20202020 73616320                  cas
   22df0:	6c222065 61656e69 0d3a2272 2020200a     e "linear":..   
   22e00:	20202020 20202020 20202020 20202020                     
   22e10:	73616320 6c222065 22656e69 200a0d3a      case "line":.. 
   22e20:	20202020 20202020 20202020 20202020                     
   22e30:	20202020 73202020 6e696c2e 286f5465            s.lineTo(
   22e40:	50202c4e 62203b29 6b616572 200a0d3b     N, P); break;.. 
   22e50:	20202020 20202020 20202020 20202020                     
   22e60:	63202020 20657361 7a656222 22726569        case "bezier"
   22e70:	200a0d3a 20202020 20202020 20202020     :..             
   22e80:	20202020 64202020 75616665 0d3a746c            default:.
   22e90:	2020200a 20202020 20202020 20202020     .               
   22ea0:	20202020 20202020 622e7320 65697a65              s.bezie
   22eb0:	72754372 6f546576 74614d28 6f722e68     rCurveTo(Math.ro
   22ec0:	28646e75 2b206228 20294e20 2932202f     und((b + N) / 2)
   22ed0:	2c56202c 74614d20 6f722e68 28646e75     , V, Math.round(
   22ee0:	202b2062 2f20294e 202c3220 4e202c50     b + N) / 2, P, N
   22ef0:	2950202c 7262203b 3b6b6165 20200a0d     , P); break;..  
   22f00:	20202020 20202020 20202020 20202020                     
   22f10:	61632020 22206573 70657473 0a0d3a22       case "step":..
   22f20:	20202020 20202020 20202020 20202020                     
   22f30:	20202020 20202020 696c2e73 6f54656e             s.lineTo
   22f40:	202c4e28 202c2956 696c2e73 6f54656e     (N, V), s.lineTo
   22f50:	202c4e28 7d202950 20200a0d 20202020     (N, P) }..      
   22f60:	20202020 20202020 20622020 2c4e203d               b = N,
   22f70:	3d205620 7d205020 20200a0d 20202020      V = P }..      
   22f80:	20202020 2e772020 676e656c 3e206874           w.length >
   22f90:	26203120 78282026 6c69662e 7974536c      1 && (x.fillSty
   22fa0:	2620656c 73282026 6e696c2e 286f5465     le && (s.lineTo(
   22fb0:	69772e72 20687464 2e78202b 656e696c     r.width + x.line
   22fc0:	74646957 202b2068 56202c31 73202c29     Width + 1, V), s
   22fd0:	6e696c2e 286f5465 69772e72 20687464     .lineTo(r.width 
   22fe0:	2e78202b 656e696c 74646957 202b2068     + x.lineWidth + 
   22ff0:	72202c31 6965682e 20746867 2e78202b     1, r.height + x.
   23000:	656e696c 74646957 202b2068 202c2931     lineWidth + 1), 
   23010:	696c2e73 6f54656e 202c7928 65682e72     s.lineTo(y, r.he
   23020:	74686769 78202b20 6e696c2e 64695765     ight + x.lineWid
   23030:	2c296874 662e7320 536c6c69 656c7974     th), s.fillStyle
   23040:	78203d20 6c69662e 7974536c 202c656c      = x.fillStyle, 
   23050:	69662e73 29286c6c 78202c29 7274732e     s.fill()), x.str
   23060:	53656b6f 656c7974 20262620 6e6f6e22     okeStyle && "non
   23070:	21202265 78203d3d 7274732e 53656b6f     e" !== x.strokeS
   23080:	656c7974 20262620 74732e73 656b6f72     tyle && s.stroke
   23090:	202c2928 6c632e73 5065736f 28687461     (), s.closePath(
   230a0:	202c2929 65722e73 726f7473 20292865     )), s.restore() 
   230b0:	6669207d 6e212820 62616c2e 2e736c65     } if (!n.labels.
   230c0:	61736964 64656c62 20262620 4e736921     disabled && !isN
   230d0:	74284e61 2e736968 756c6176 6e615265     aN(this.valueRan
   230e0:	6d2e6567 20296e69 21202626 614e7369     ge.min) && !isNa
   230f0:	6874284e 762e7369 65756c61 676e6152     N(this.valueRang
   23100:	616d2e65 20292978 6176207b 204d2072     e.max)) { var M 
   23110:	2e6e203d 78614d79 6d726f46 65747461     = n.yMaxFormatte
   23120:	68742872 762e7369 65756c61 676e6152     r(this.valueRang
   23130:	616d2e65 6e202c78 62616c2e 2e736c65     e.max, n.labels.
   23140:	63657270 6f697369 0d2c296e 2020200a     precision),..   
   23150:	20202020 20202020 20202020 3d206b20                  k =
   23160:	792e6e20 466e694d 616d726f 72657474      n.yMinFormatter
   23170:	69687428 61762e73 5265756c 65676e61     (this.valueRange
   23180:	6e696d2e 2e6e202c 6562616c 702e736c     .min, n.labels.p
   23190:	69636572 6e6f6973 0a0d2c29 20202020     recision),..    
   231a0:	20202020 20202020 20202020 203d2046                 F = 
   231b0:	63732e6e 6c6c6f72 6b636142 64726177     n.scrollBackward
   231c0:	203f2073 203a2030 69772e72 20687464     s ? 0 : r.width 
   231d0:	2e73202d 7361656d 54657275 28747865     - s.measureText(
   231e0:	772e294d 68746469 32202d20 200a0d2c     M).width - 2,.. 
   231f0:	20202020 20202020 20202020 52202020                    R
   23200:	6e203d20 7263732e 426c6c6f 776b6361      = n.scrollBackw
   23210:	73647261 30203f20 72203a20 6469772e     ards ? 0 : r.wid
   23220:	2d206874 6d2e7320 75736165 65546572     th - s.measureTe
   23230:	6b287478 69772e29 20687464 3b32202d     xt(k).width - 2;
   23240:	20200a0d 20202020 20202020 2e732020     ..            s.
   23250:	6c6c6966 6c797453 203d2065 616c2e6e     fillStyle = n.la
   23260:	736c6562 6c69662e 7974536c 202c656c     bels.fillStyle, 
   23270:	69662e73 65546c6c 4d287478 2c46202c     s.fillText(M, F,
   23280:	6c2e6e20 6c656261 6f662e73 6953746e      n.labels.fontSi
   23290:	2c29657a 662e7320 546c6c69 28747865     ze), s.fillText(
   232a0:	52202c6b 2e72202c 67696568 2d207468     k, R, r.height -
   232b0:	20293220 6669207d 2e6e2820 656d6974      2) } if (n.time
   232c0:	6d617473 726f4670 7474616d 26207265     stampFormatter &
   232d0:	2e6e2026 64697267 6c696d2e 5073696c     & n.grid.millisP
   232e0:	694c7265 3e20656e 20293020 6176207b     erLine > 0) { va
   232f0:	20412072 2e6e203d 6f726373 61426c6c     r A = n.scrollBa
   23300:	61776b63 20736472 2e73203f 7361656d     ckwards ? s.meas
   23310:	54657275 28747865 772e296b 68746469     ureText(k).width
   23320:	72203a20 6469772e 2d206874 6d2e7320      : r.width - s.m
   23330:	75736165 65546572 6b287478 69772e29     easureText(k).wi
   23340:	20687464 3b34202b 726f6620 20642820     dth + 4; for (d 
   23350:	2074203d 2074202d 2e6e2025 64697267     = t - t % n.grid
   23360:	6c696d2e 5073696c 694c7265 203b656e     .millisPerLine; 
   23370:	3d3e2064 203b6c20 3d2d2064 672e6e20     d >= l; d -= n.g
   23380:	2e646972 6c6c696d 65507369 6e694c72     rid.millisPerLin
   23390:	7b202965 3d207520 64286820 69203b29     e) { u = h(d); i
   233a0:	21282066 63732e6e 6c6c6f72 6b636142     f (!n.scrollBack
   233b0:	64726177 26262073 3c207520 7c204120     wards && u < A |
   233c0:	2e6e207c 6f726373 61426c6c 61776b63     | n.scrollBackwa
   233d0:	20736472 75202626 41203e20 207b2029     rds && u > A) { 
   233e0:	20726176 203d2042 2077656e 65746144     var B = new Date
   233f0:	2c296428 20200a0d 20202020 20202020     (d),..          
   23400:	20202020 20202020 20202020 204c2020                   L 
   23410:	2e6e203d 656d6974 6d617473 726f4670     = n.timestampFor
   23420:	7474616d 42287265 0a0d2c29 20202020     matter(B),..    
   23430:	20202020 20202020 20202020 20202020                     
   23440:	20202020 203d2057 656d2e73 72757361         W = s.measur
   23450:	78655465 294c2874 6469772e 0d3b6874     eText(L).width;.
   23460:	2020200a 20202020 20202020 20202020     .               
   23470:	20202020 3d204120 732e6e20 6c6f7263          A = n.scrol
   23480:	6361426c 7261776b 3f207364 2b207520     lBackwards ? u +
   23490:	2b205720 3a203220 2d207520 2d205720      W + 2 : u - W -
   234a0:	202c3220 69662e73 74536c6c 20656c79      2, s.fillStyle 
   234b0:	2e6e203d 6562616c 662e736c 536c6c69     = n.labels.fillS
   234c0:	656c7974 2e6e202c 6f726373 61426c6c     tyle, n.scrollBa
   234d0:	61776b63 20736472 2e73203f 6c6c6966     ckwards ? s.fill
   234e0:	74786554 202c4c28 72202c75 6965682e     Text(L, u, r.hei
   234f0:	20746867 2932202d 73203a20 6c69662e     ght - 2) : s.fil
   23500:	7865546c 2c4c2874 2d207520 202c5720     lText(L, u - W, 
   23510:	65682e72 74686769 32202d20 207d2029     r.height - 2) } 
   23520:	0d7d207d 2020200a 20202020 722e7320     } }..        s.r
   23530:	6f747365 29286572 202c7d20 69742e61     estore() }, a.ti
   23540:	6f46656d 74616d72 20726574 7566203d     meFormatter = fu
   23550:	6974636e 65286e6f 0d7b2029 2020200a     nction(e) {..   
   23560:	20202020 6e756620 6f697463 2874206e          function t(
   23570:	7b202965 74657220 206e7275 3c206528     e) { return (e <
   23580:	20303120 3022203f 203a2022 20292222      10 ? "0" : "") 
   23590:	2065202b 6572207d 6e727574 65287420     + e } return t(e
   235a0:	7465672e 72756f48 29292873 22202b20     .getHours()) + "
   235b0:	2b20223a 65287420 7465672e 756e694d     :" + t(e.getMinu
   235c0:	28736574 2b202929 223a2220 74202b20     tes()) + ":" + t
   235d0:	672e6528 65537465 646e6f63 29292873     (e.getSeconds())
   235e0:	202c7d20 69542e65 6553656d 73656972      }, e.TimeSeries
   235f0:	69203d20 2e65202c 6f6f6d53 65696874      = i, e.Smoothie
   23600:	72616843 203d2074 287d2061 646e7522     Chart = a }("und
   23610:	6e696665 20226465 74203d3d 6f657079     efined" == typeo
   23620:	78652066 74726f70 203f2073 73696874     f exports ? this
   23630:	65203a20 726f7078 3b297374 00000000      : exports);....

00023640 <data_stats_shtml>:
   23640:	6174732f 732e7374 6c6d7468 44213c00     /stats.shtml.<!D
   23650:	5954434f 48204550 204c4d54 4c425550     OCTYPE HTML PUBL
   23660:	22204349 572f2f2d 2f2f4333 20445444     IC "-//W3C//DTD 
   23670:	4c4d5448 302e3420 72542031 69736e61     HTML 4.01 Transi
   23680:	6e6f6974 2f2f6c61 20224e45 74746822     tional//EN" "htt
   23690:	2f2f3a70 2e777777 6f2e3377 542f6772     p://www.w3.org/T
   236a0:	74682f52 2f346c6d 736f6f6c 74642e65     R/html4/loose.dt
   236b0:	0d3e2264 74683c0a 0d3e6c6d 3c20200a     d">..<html>..  <
   236c0:	64616568 200a0d3e 3c202020 6c746974     head>..    <titl
   236d0:	72463e65 54526565 6f2e534f 75206772     e>FreeRTOS.org u
   236e0:	57205049 73204245 65767265 65642072     IP WEB server de
   236f0:	2f3c6f6d 6c746974 0a0d3e65 2f3c2020     mo</title>..  </
   23700:	64616568 200a0d3e 4f423c20 0d3e5944     head>..  <BODY>.
   23710:	6f663c0a 6620746e 3d656361 69726122     .<font face="ari
   23720:	3e226c61 613c0a0d 65726820 69223d66     al">..<a href="i
   23730:	7865646e 7468732e 3e226c6d 6b736154     ndex.shtml">Task
   23740:	61745320 2f3c7374 3c203e61 3c7c3e62      Stats</a> <b>|<
   23750:	203e622f 6820613c 3d666572 6e757222     /b> <a href="run
   23760:	656d6974 7468732e 3e226c6d 206e7552     time.shtml">Run 
   23770:	656d6954 61745320 2f3c7374 3c203e61     Time Stats</a> <
   23780:	3c7c3e62 203e622f 6820613c 3d666572     b>|</b> <a href=
   23790:	61747322 732e7374 6c6d7468 43543e22     "stats.shtml">TC
   237a0:	74532050 3c737461 203e612f 7c3e623c     P Stats</a> <b>|
   237b0:	3e622f3c 20613c20 66657268 6374223d     </b> <a href="tc
   237c0:	68732e70 226c6d74 6e6f433e 7463656e     p.shtml">Connect
   237d0:	736e6f69 3e612f3c 3e623c20 622f3c7c     ions</a> <b>|</b
   237e0:	613c203e 65726820 68223d66 3a707474     > <a href="http:
   237f0:	77772f2f 72662e77 74726565 6f2e736f     //www.freertos.o
   23800:	222f6772 6572463e 4f545265 6f482053     rg/">FreeRTOS Ho
   23810:	6170656d 2f3c6567 3c203e61 3c7c3e62     mepage</a> <b>|<
   23820:	203e622f 6820613c 3d666572 2e6f6922     /b> <a href="io.
   23830:	6d746873 493e226c 612f3c4f 623c203e     shtml">IO</a> <b
   23840:	2f3c7c3e 3c203e62 72682061 223d6665     >|</b> <a href="
   23850:	6f676f6c 67706a2e 37333e22 706a204b     logo.jpg">37K jp
   23860:	612f3c67 3c0a0d3e 3c3e7262 0a0d3e70     g</a>..<br><p>..
   23870:	3e72683c 623c0a0d 703c3e72 3c0a0d3e     <hr>..<br><p>..<
   23880:	4e3e3268 6f777465 73206b72 69746174     h2>Network stati
   23890:	63697473 682f3c73 0a0d3e32 6261743c     stics</h2>..<tab
   238a0:	7720656c 68746469 3033223d 62202230     le width="300" b
   238b0:	6564726f 30223d72 0a0d3e22 3e72743c     order="0">..<tr>
   238c0:	2064743c 67696c61 6c223d6e 22746665     <td align="left"
   238d0:	6f663c3e 6620746e 3d656361 756f6322     ><font face="cou
   238e0:	72656972 703c3e22 0d3e6572 2050490a     rier"><pre>..IP 
   238f0:	20202020 20202020 61502020 74656b63               Packet
   23900:	65722073 76696563 0a0d6465 20202020     s received..    
   23910:	20202020 20202020 63615020 7374656b              Packets
   23920:	6e657320 200a0d74 20202020 20202020      sent..         
   23930:	20202020 77726f46 64656461 20200a0d         Forwaded..  
   23940:	20202020 20202020 44202020 70706f72                Dropp
   23950:	0a0d6465 65205049 726f7272 20202073     ed..IP errors   
   23960:	20504920 73726576 2f6e6f69 64616568      IP version/head
   23970:	6c207265 74676e65 200a0d68 20202020     er length..     
   23980:	20202020 20202020 6c205049 74676e65             IP lengt
   23990:	68202c68 20686769 65747962 20200a0d     h, high byte..  
   239a0:	20202020 20202020 49202020 656c2050                IP le
   239b0:	6874676e 6f6c202c 79622077 0a0d6574     ngth, low byte..
   239c0:	20202020 20202020 20202020 20504920                  IP 
   239d0:	67617266 746e656d 200a0d73 20202020     fragments..     
   239e0:	20202020 20202020 64616548 63207265             Header c
   239f0:	6b636568 0d6d7573 2020200a 20202020     hecksum..       
   23a00:	20202020 72572020 20676e6f 746f7270           Wrong prot
   23a10:	6c6f636f 43490a0d 2009504d 20202020     ocol..ICMP.     
   23a20:	6b636150 20737465 65636572 64657669     Packets received
   23a30:	20200a0d 20202020 20202020 50202020     ..             P
   23a40:	656b6361 73207374 0d746e65 2020200a     ackets sent..   
   23a50:	20202020 20202020 61502020 74656b63               Packet
   23a60:	72642073 6570706f 200a0d64 20202020     s dropped..     
   23a70:	20202020 20202020 65707954 72726520             Type err
   23a80:	0d73726f 2020200a 20202020 20202020     ors..           
   23a90:	68432020 736b6365 65206d75 726f7272       Checksum error
   23aa0:	540a0d73 20205043 20202020 20202020     s..TCP          
   23ab0:	6b636150 20737465 65636572 64657669     Packets received
   23ac0:	20200a0d 20202020 20202020 50202020     ..             P
   23ad0:	656b6361 73207374 0d746e65 2020200a     ackets sent..   
   23ae0:	20202020 20202020 61502020 74656b63               Packet
   23af0:	72642073 6570706f 200a0d64 20202020     s dropped..     
   23b00:	20202020 20202020 63656843 6d75736b             Checksum
   23b10:	72726520 0d73726f 2020200a 20202020      errors..       
   23b20:	20202020 61442020 70206174 656b6361           Data packe
   23b30:	77207374 6f687469 41207475 0d734b43     ts without ACKs.
   23b40:	2020200a 20202020 20202020 65522020     .             Re
   23b50:	73746573 20200a0d 20202020 20202020     sets..          
   23b60:	52202020 61727465 696d736e 6f697373        Retransmissio
   23b70:	0d61736e 2020200a 20202020 20202020     nsa..           
   23b80:	79532020 6f74206e 6f6c6320 20646573       Syn to closed 
   23b90:	74726f70 44550a0d 20202050 20202020     port..UDP       
   23ba0:	50202020 656b6361 64207374 70706f72        Packets dropp
   23bb0:	0a0d6465 20202020 20202020 20202020     ed..            
   23bc0:	63615020 7374656b 63657220 65766965      Packets receive
   23bd0:	200a0d64 20202020 20202020 20202020     d..             
   23be0:	6b636150 20737465 746e6573 20200a0d     Packets sent..  
   23bf0:	20202020 20202020 50202020 656b6361                Packe
   23c00:	63207374 72656b68 090a0d72 20202020     ts chkerr...    
   23c10:	206f4e20 6e6e6f63 69746365 61206e6f      No connection a
   23c20:	696c6176 656c6261 2f3c0a0d 3e657270     valiable..</pre>
   23c30:	6f662f3c 3c3e746e 3e64742f 3e64743c     </font></td><td>
   23c40:	6e6f663c 61662074 223d6563 72756f63     <font face="cour
   23c50:	22726569 72703c3e 21253e65 74656e20     ier"><pre>%! net
   23c60:	6174732d 0a0d7374 72702f3c 2f3c3e65     -stats..</pre></
   23c70:	746e6f66 742f3c3e 2f3c3e64 6c626174     font></td></tabl
   23c80:	0a0d3e65 6f662f3c 0d3e746e 622f3c0a     e>..</font>..</b
   23c90:	3e79646f 2f3c0a0d 6c6d7468 000a0d3e     ody>..</html>...

00023ca0 <data_tcp_shtml>:
   23ca0:	7063742f 7468732e 3c006c6d 434f4421     /tcp.shtml.<!DOC
   23cb0:	45505954 4d544820 5550204c 43494c42     TYPE HTML PUBLIC
   23cc0:	2f2d2220 4333572f 54442f2f 54482044      "-//W3C//DTD HT
   23cd0:	34204c4d 2031302e 6e617254 69746973     ML 4.01 Transiti
   23ce0:	6c616e6f 4e452f2f 68222022 3a707474     onal//EN" "http:
   23cf0:	77772f2f 33772e77 67726f2e 2f52542f     //www.w3.org/TR/
   23d00:	6c6d7468 6f6c2f34 2e65736f 22647464     html4/loose.dtd"
   23d10:	3c0a0d3e 6c6d7468 200a0d3e 65683c20     >..<html>..  <he
   23d20:	0d3e6461 2020200a 69743c20 3e656c74     ad>..    <title>
   23d30:	65657246 534f5452 67726f2e 50497520     FreeRTOS.org uIP
   23d40:	42455720 72657320 20726576 6f6d6564      WEB server demo
   23d50:	69742f3c 3e656c74 20200a0d 65682f3c     </title>..  </he
   23d60:	0d3e6461 3c20200a 59444f42 3c0a0d3e     ad>..  <BODY>..<
   23d70:	746e6f66 63616620 61223d65 6c616972     font face="arial
   23d80:	0a0d3e22 6820613c 3d666572 646e6922     ">..<a href="ind
   23d90:	732e7865 6c6d7468 61543e22 53206b73     ex.shtml">Task S
   23da0:	73746174 3e612f3c 3e623c20 622f3c7c     tats</a> <b>|</b
   23db0:	613c203e 65726820 72223d66 69746e75     > <a href="runti
   23dc0:	732e656d 6c6d7468 75523e22 6954206e     me.shtml">Run Ti
   23dd0:	5320656d 73746174 3e612f3c 3e623c20     me Stats</a> <b>
   23de0:	622f3c7c 613c203e 65726820 73223d66     |</b> <a href="s
   23df0:	73746174 7468732e 3e226c6d 20504354     tats.shtml">TCP 
   23e00:	74617453 612f3c73 623c203e 2f3c7c3e     Stats</a> <b>|</
   23e10:	3c203e62 72682061 223d6665 2e706374     b> <a href="tcp.
   23e20:	6d746873 433e226c 656e6e6f 6f697463     shtml">Connectio
   23e30:	2f3c736e 3c203e61 3c7c3e62 203e622f     ns</a> <b>|</b> 
   23e40:	6820613c 3d666572 74746822 2f2f3a70     <a href="http://
   23e50:	2e777777 65657266 736f7472 67726f2e     www.freertos.org
   23e60:	463e222f 52656572 20534f54 656d6f48     /">FreeRTOS Home
   23e70:	65676170 3e612f3c 3e623c20 622f3c7c     page</a> <b>|</b
   23e80:	613c203e 65726820 69223d66 68732e6f     > <a href="io.sh
   23e90:	226c6d74 3c4f493e 203e612f 7c3e623c     tml">IO</a> <b>|
   23ea0:	3e622f3c 20613c20 66657268 6f6c223d     </b> <a href="lo
   23eb0:	6a2e6f67 3e226770 204b3733 3c67706a     go.jpg">37K jpg<
   23ec0:	0d3e612f 72623c0a 3e703c3e 683c0a0d     /a>..<br><p>..<h
   23ed0:	0a0d3e72 3e72623c 683c0a0d 654e3e32     r>..<br>..<h2>Ne
   23ee0:	726f7774 6f63206b 63656e6e 6e6f6974     twork connection
   23ef0:	682f3c73 0a0d3e32 0d3e703c 61743c0a     s</h2>..<p>..<ta
   23f00:	3e656c62 743c0a0d 743c3e72 6f4c3e68     ble>..<tr><th>Lo
   23f10:	3c6c6163 3e68742f 3e68743c 6f6d6552     cal</th><th>Remo
   23f20:	2f3c6574 3c3e6874 533e6874 65746174     te</th><th>State
   23f30:	68742f3c 68743c3e 7465523e 736e6172     </th><th>Retrans
   23f40:	7373696d 736e6f69 68742f3c 68743c3e     missions</th><th
   23f50:	6d69543e 2f3c7265 3c3e6874 463e6874     >Timer</th><th>F
   23f60:	7367616c 68742f3c 742f3c3e 0a0d3e72     lags</th></tr>..
   23f70:	74202125 632d7063 656e6e6f 6f697463     %! tcp-connectio
   23f80:	0a0d736e 72702f3c 2f3c3e65 746e6f66     ns..</pre></font
   23f90:	3c0a0d3e 6e6f662f 0a0d3e74 6f622f3c     >..</font>..</bo
   23fa0:	0d3e7964 682f3c0a 3e6c6d74 0a0d0a0d     dy>..</html>....
   23fb0:	00000000                                ....

00023fb4 <file_404_html>:
   23fb4:	00000000 0001ba70 0001ba7a 000000a8     ....p...z.......
   23fc4:	00000000                                ....

00023fc8 <file_index_html>:
   23fc8:	00023fb4 0001bb24 0001bb30 000005be     .?..$...0.......
   23fd8:	00000000                                ....

00023fdc <file_io_shtml>:
   23fdc:	00023fc8 0001c0f0 0001c0fa 000045b5     .?...........E..
   23fec:	00000000                                ....

00023ff0 <file_runtime_shtml>:
   23ff0:	00023fdc 000206b0 000206bf 0000036c     .?..........l...
   24000:	00000000                                ....

00024004 <file_sensordata_shtml>:
   24004:	00023ff0 00020a2c 00020a3e 0000000f     .?..,...>.......
   24014:	00000000                                ....

00024018 <file_smoothie_min_js>:
   24018:	00024004 00020a50 00020a61 00002bdc     .@..P...a....+..
   24028:	00000000                                ....

0002402c <file_stats_shtml>:
   2402c:	00024018 00023640 0002364d 00000653     .@..@6..M6..S...
   2403c:	00000000                                ....

00024040 <file_tcp_shtml>:
   24040:	0002402c 00023ca0 00023cab 00000306     ,@...<...<......
   24050:	00000000 454c4449 00000000 09632509     ....IDLE.....%c.
   24060:	25097525 75250975 00000a0d 09752509     %u.%u.%u.....%u.
   24070:	25752509 000a0d25 09752509 25313c09     .%u%%....%u..<1%
   24080:	000a0d25 20726d54 00637653              %...Tmr Svc.

0002408c <heapSTRUCT_SIZE>:
   2408c:	00000008                                ....

00024090 <pcInterruptPriorityRegisters>:
   24090:	e000e3f0                                ....

00024094 <_global_impure_ptr>:
   24094:	200000dc 00000043                       ... C...

0002409c <blanks.3595>:
   2409c:	20202020 20202020 20202020 20202020                     

000240ac <zeroes.3596>:
   240ac:	30303030 30303030 30303030 30303030     0000000000000000
   240bc:	33323130 37363534 42413938 46454443     0123456789ABCDEF
   240cc:	00000000 00464e49 00666e69 004e414e     ....INF.inf.NAN.
   240dc:	006e616e 33323130 37363534 62613938     nan.0123456789ab
   240ec:	66656463 00000000 6c756e28 0000296c     cdef....(null)..
   240fc:	00000030 69666e49 7974696e 00000000     0...Infinity....
   2410c:	004e614e                                NaN.

00024110 <charset>:
   24110:	00024148                                HA..

00024114 <lconv>:
   24114:	00024144 000240cc 000240cc 000240cc     DA...@...@...@..
   24124:	000240cc 000240cc 000240cc 000240cc     .@...@...@...@..
   24134:	000240cc 000240cc ffffffff ffffffff     .@...@..........
   24144:	0000002e 2d4f5349 39353838 0000312d     ....ISO-8859-1..
   24154:	00000000                                ....

00024158 <__mprec_tens>:
   24158:	00000000 3ff00000 00000000 40240000     .......?......$@
   24168:	00000000 40590000 00000000 408f4000     ......Y@.....@.@
   24178:	00000000 40c38800 00000000 40f86a00     .......@.....j.@
   24188:	00000000 412e8480 00000000 416312d0     .......A......cA
   24198:	00000000 4197d784 00000000 41cdcd65     .......A....e..A
   241a8:	20000000 4202a05f e8000000 42374876     ... _..B....vH7B
   241b8:	a2000000 426d1a94 e5400000 42a2309c     ......mB..@..0.B
   241c8:	1e900000 42d6bcc4 26340000 430c6bf5     .......B..4&.k.C
   241d8:	37e08000 4341c379 85d8a000 43763457     ...7y.AC....W4vC
   241e8:	674ec800 43abc16d 60913d00 43e158e4     ..Ngm..C.=.`.X.C
   241f8:	78b58c40 4415af1d d6e2ef50 444b1ae4     @..x...DP.....KD
   24208:	064dd592 4480f0cf c7e14af6 44b52d02     ..M....D.J...-.D
   24218:	79d99db4 44ea7843                       ...yCx.D

00024220 <p05.2463>:
   24220:	00000005 00000019 0000007d 00000000     ........}.......

00024230 <__mprec_bigtens>:
   24230:	37e08000 4341c379 b5056e17 4693b8b5     ...7y.AC.n.....F
   24240:	e93ff9f5 4d384f03 f9301d32 5a827748     ..?..O8M2.0.Hw.Z
   24250:	7f73bf3c 75154fdd                       <.s..O.u

00024258 <__mprec_tinytens>:
   24258:	97d889bc 3c9cd2b2 d5a8a733 3949f623     .......<3...#.I9
   24268:	44f4a73d 32a50ffd cf8c979d 255bba08     =..D...2......[%
   24278:	64ac6f43 0ac80628                       Co.d(...

00024280 <_init>:
   24280:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   24282:	bf00      	nop
   24284:	bcf8      	pop	{r3, r4, r5, r6, r7}
   24286:	bc08      	pop	{r3}
   24288:	469e      	mov	lr, r3
   2428a:	4770      	bx	lr

0002428c <_fini>:
   2428c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2428e:	bf00      	nop
   24290:	bcf8      	pop	{r3, r4, r5, r6, r7}
   24292:	bc08      	pop	{r3}
   24294:	469e      	mov	lr, r3
   24296:	4770      	bx	lr

00024298 <__frame_dummy_init_array_entry>:
   24298:	0485 0000                                   ....

0002429c <__do_global_dtors_aux_fini_array_entry>:
   2429c:	0471 0000                                   q...
