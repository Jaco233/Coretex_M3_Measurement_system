
Measurement_System:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .init         00000460  00000000  60000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0001bee8  00000460  60000460  00008460  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .data         000005e8  20000000  6001c348  00028000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          0000c608  200005e8  6001c930  000285e8  2**2
                  ALLOC
  4 .comment      000004df  00000000  00000000  000285e8  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000f48  00000000  00000000  00028ac7  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000020f5  00000000  00000000  00029a0f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00014a88  00000000  00000000  0002bb04  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00002e38  00000000  00000000  0004058c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000b464  00000000  00000000  000433c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00003654  00000000  00000000  0004e828  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00006f81  00000000  00000000  00051e7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000054df  00000000  00000000  00058dfd  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macinfo 000c098b  00000000  00000000  0005e2dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .ARM.attributes 00000025  00000000  00000000  0011ec67  2**0
                  CONTENTS, READONLY
 15 .debug_ranges 00000e88  00000000  00000000  0011ec8c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000460 <__do_global_dtors_aux>:
     460:	f240 53e8 	movw	r3, #1512	; 0x5e8
     464:	f2c2 0300 	movt	r3, #8192	; 0x2000
     468:	781a      	ldrb	r2, [r3, #0]
     46a:	b90a      	cbnz	r2, 470 <__do_global_dtors_aux+0x10>
     46c:	2001      	movs	r0, #1
     46e:	7018      	strb	r0, [r3, #0]
     470:	4770      	bx	lr
     472:	bf00      	nop

00000474 <frame_dummy>:
     474:	f240 0000 	movw	r0, #0
     478:	f2c2 0000 	movt	r0, #8192	; 0x2000
     47c:	b508      	push	{r3, lr}
     47e:	6803      	ldr	r3, [r0, #0]
     480:	b12b      	cbz	r3, 48e <frame_dummy+0x1a>
     482:	f240 0300 	movw	r3, #0
     486:	f2c0 0300 	movt	r3, #0
     48a:	b103      	cbz	r3, 48e <frame_dummy+0x1a>
     48c:	4798      	blx	r3
     48e:	bd08      	pop	{r3, pc}

00000490 <MSS_GPIO_set_outputs>:
static __INLINE void
MSS_GPIO_set_outputs
(
   uint32_t value
)
{
     490:	b480      	push	{r7}
     492:	b083      	sub	sp, #12
     494:	af00      	add	r7, sp, #0
     496:	6078      	str	r0, [r7, #4]
    GPIO->GPIO_OUT = value;
     498:	f243 0300 	movw	r3, #12288	; 0x3000
     49c:	f2c4 0301 	movt	r3, #16385	; 0x4001
     4a0:	687a      	ldr	r2, [r7, #4]
     4a2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
}
     4a6:	f107 070c 	add.w	r7, r7, #12
     4aa:	46bd      	mov	sp, r7
     4ac:	bc80      	pop	{r7}
     4ae:	4770      	bx	lr

000004b0 <vParTestInitialise>:
static volatile unsigned long ulGPIOState = 0UL;

/*-----------------------------------------------------------*/

void vParTestInitialise( void )
{
     4b0:	b580      	push	{r7, lr}
     4b2:	b082      	sub	sp, #8
     4b4:	af00      	add	r7, sp, #0
long x;

	/* Initialise the GPIO */
	MSS_GPIO_init();
     4b6:	f001 fd49 	bl	1f4c <MSS_GPIO_init>

	/* Set up GPIO for the LEDs. */
	for( x = 0; x < partstMAX_LEDS; x++ )
     4ba:	f04f 0300 	mov.w	r3, #0
     4be:	607b      	str	r3, [r7, #4]
     4c0:	e00a      	b.n	4d8 <vParTestInitialise+0x28>
	{
		MSS_GPIO_config( ( mss_gpio_id_t ) x , MSS_GPIO_OUTPUT_MODE );
     4c2:	687b      	ldr	r3, [r7, #4]
     4c4:	b2db      	uxtb	r3, r3
     4c6:	4618      	mov	r0, r3
     4c8:	f04f 0105 	mov.w	r1, #5
     4cc:	f001 fd74 	bl	1fb8 <MSS_GPIO_config>

	/* Initialise the GPIO */
	MSS_GPIO_init();

	/* Set up GPIO for the LEDs. */
	for( x = 0; x < partstMAX_LEDS; x++ )
     4d0:	687b      	ldr	r3, [r7, #4]
     4d2:	f103 0301 	add.w	r3, r3, #1
     4d6:	607b      	str	r3, [r7, #4]
     4d8:	687b      	ldr	r3, [r7, #4]
     4da:	2b07      	cmp	r3, #7
     4dc:	ddf1      	ble.n	4c2 <vParTestInitialise+0x12>
	{
		MSS_GPIO_config( ( mss_gpio_id_t ) x , MSS_GPIO_OUTPUT_MODE );
	}

	/* All LEDs start off. */
	ulGPIOState = 0xffffffffUL;
     4de:	f240 53ec 	movw	r3, #1516	; 0x5ec
     4e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
     4e6:	f04f 32ff 	mov.w	r2, #4294967295
     4ea:	601a      	str	r2, [r3, #0]
	MSS_GPIO_set_outputs( ulGPIOState );
     4ec:	f240 53ec 	movw	r3, #1516	; 0x5ec
     4f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
     4f4:	681b      	ldr	r3, [r3, #0]
     4f6:	4618      	mov	r0, r3
     4f8:	f7ff ffca 	bl	490 <MSS_GPIO_set_outputs>
}
     4fc:	f107 0708 	add.w	r7, r7, #8
     500:	46bd      	mov	sp, r7
     502:	bd80      	pop	{r7, pc}

00000504 <vParTestSetLED>:
/*-----------------------------------------------------------*/

void vParTestSetLED( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
{
     504:	b580      	push	{r7, lr}
     506:	b082      	sub	sp, #8
     508:	af00      	add	r7, sp, #0
     50a:	6078      	str	r0, [r7, #4]
     50c:	6039      	str	r1, [r7, #0]
	if( uxLED < partstMAX_LEDS )
     50e:	687b      	ldr	r3, [r7, #4]
     510:	2b07      	cmp	r3, #7
     512:	d833      	bhi.n	57c <vParTestSetLED+0x78>
	{
		/* A critical section is used as the LEDs are also accessed from an
		interrupt. */
		taskENTER_CRITICAL();
     514:	f011 f918 	bl	11748 <vPortEnterCritical>
		{
			if( xValue == pdTRUE )
     518:	683b      	ldr	r3, [r7, #0]
     51a:	2b01      	cmp	r3, #1
     51c:	d113      	bne.n	546 <vParTestSetLED+0x42>
			{
				ulGPIOState &= ~( 1UL << uxLED );
     51e:	687b      	ldr	r3, [r7, #4]
     520:	f04f 0201 	mov.w	r2, #1
     524:	fa02 f303 	lsl.w	r3, r2, r3
     528:	ea6f 0203 	mvn.w	r2, r3
     52c:	f240 53ec 	movw	r3, #1516	; 0x5ec
     530:	f2c2 0300 	movt	r3, #8192	; 0x2000
     534:	681b      	ldr	r3, [r3, #0]
     536:	ea02 0203 	and.w	r2, r2, r3
     53a:	f240 53ec 	movw	r3, #1516	; 0x5ec
     53e:	f2c2 0300 	movt	r3, #8192	; 0x2000
     542:	601a      	str	r2, [r3, #0]
     544:	e010      	b.n	568 <vParTestSetLED+0x64>
			}
			else
			{
				ulGPIOState |= ( 1UL << uxLED );
     546:	687b      	ldr	r3, [r7, #4]
     548:	f04f 0201 	mov.w	r2, #1
     54c:	fa02 f203 	lsl.w	r2, r2, r3
     550:	f240 53ec 	movw	r3, #1516	; 0x5ec
     554:	f2c2 0300 	movt	r3, #8192	; 0x2000
     558:	681b      	ldr	r3, [r3, #0]
     55a:	ea42 0203 	orr.w	r2, r2, r3
     55e:	f240 53ec 	movw	r3, #1516	; 0x5ec
     562:	f2c2 0300 	movt	r3, #8192	; 0x2000
     566:	601a      	str	r2, [r3, #0]
			}
			
			MSS_GPIO_set_outputs( ulGPIOState );
     568:	f240 53ec 	movw	r3, #1516	; 0x5ec
     56c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     570:	681b      	ldr	r3, [r3, #0]
     572:	4618      	mov	r0, r3
     574:	f7ff ff8c 	bl	490 <MSS_GPIO_set_outputs>
		}
		taskEXIT_CRITICAL();
     578:	f011 f91e 	bl	117b8 <vPortExitCritical>
	}
}
     57c:	f107 0708 	add.w	r7, r7, #8
     580:	46bd      	mov	sp, r7
     582:	bd80      	pop	{r7, pc}

00000584 <vParTestSetLEDFromISR>:
/*-----------------------------------------------------------*/

void vParTestSetLEDFromISR( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
{
     584:	b580      	push	{r7, lr}
     586:	b086      	sub	sp, #24
     588:	af00      	add	r7, sp, #0
     58a:	6078      	str	r0, [r7, #4]
     58c:	6039      	str	r1, [r7, #0]

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
     58e:	f3ef 8211 	mrs	r2, BASEPRI
     592:	f04f 0328 	mov.w	r3, #40	; 0x28
     596:	f383 8811 	msr	BASEPRI, r3
     59a:	f3bf 8f6f 	isb	sy
     59e:	f3bf 8f4f 	dsb	sy
     5a2:	613a      	str	r2, [r7, #16]
     5a4:	60fb      	str	r3, [r7, #12]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
     5a6:	693b      	ldr	r3, [r7, #16]
unsigned portBASE_TYPE uxInterruptFlags;

	uxInterruptFlags = portSET_INTERRUPT_MASK_FROM_ISR();
     5a8:	60bb      	str	r3, [r7, #8]
	{
		if( uxLED < partstMAX_LEDS )
     5aa:	687b      	ldr	r3, [r7, #4]
     5ac:	2b07      	cmp	r3, #7
     5ae:	d82f      	bhi.n	610 <vParTestSetLEDFromISR+0x8c>
		{
			if( xValue == pdTRUE )
     5b0:	683b      	ldr	r3, [r7, #0]
     5b2:	2b01      	cmp	r3, #1
     5b4:	d113      	bne.n	5de <vParTestSetLEDFromISR+0x5a>
			{
				ulGPIOState &= ~( 1UL << uxLED );
     5b6:	687b      	ldr	r3, [r7, #4]
     5b8:	f04f 0201 	mov.w	r2, #1
     5bc:	fa02 f303 	lsl.w	r3, r2, r3
     5c0:	ea6f 0203 	mvn.w	r2, r3
     5c4:	f240 53ec 	movw	r3, #1516	; 0x5ec
     5c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
     5cc:	681b      	ldr	r3, [r3, #0]
     5ce:	ea02 0203 	and.w	r2, r2, r3
     5d2:	f240 53ec 	movw	r3, #1516	; 0x5ec
     5d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
     5da:	601a      	str	r2, [r3, #0]
     5dc:	e010      	b.n	600 <vParTestSetLEDFromISR+0x7c>
			}
			else
			{
				ulGPIOState |= ( 1UL << uxLED );
     5de:	687b      	ldr	r3, [r7, #4]
     5e0:	f04f 0201 	mov.w	r2, #1
     5e4:	fa02 f203 	lsl.w	r2, r2, r3
     5e8:	f240 53ec 	movw	r3, #1516	; 0x5ec
     5ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
     5f0:	681b      	ldr	r3, [r3, #0]
     5f2:	ea42 0203 	orr.w	r2, r2, r3
     5f6:	f240 53ec 	movw	r3, #1516	; 0x5ec
     5fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
     5fe:	601a      	str	r2, [r3, #0]
			}

			MSS_GPIO_set_outputs( ulGPIOState );
     600:	f240 53ec 	movw	r3, #1516	; 0x5ec
     604:	f2c2 0300 	movt	r3, #8192	; 0x2000
     608:	681b      	ldr	r3, [r3, #0]
     60a:	4618      	mov	r0, r3
     60c:	f7ff ff40 	bl	490 <MSS_GPIO_set_outputs>
     610:	68bb      	ldr	r3, [r7, #8]
     612:	617b      	str	r3, [r7, #20]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
     614:	697b      	ldr	r3, [r7, #20]
     616:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxInterruptFlags );
}
     61a:	f107 0718 	add.w	r7, r7, #24
     61e:	46bd      	mov	sp, r7
     620:	bd80      	pop	{r7, pc}
     622:	bf00      	nop

00000624 <vParTestToggleLED>:
/*-----------------------------------------------------------*/

void vParTestToggleLED( unsigned portBASE_TYPE uxLED )
{
     624:	b580      	push	{r7, lr}
     626:	b082      	sub	sp, #8
     628:	af00      	add	r7, sp, #0
     62a:	6078      	str	r0, [r7, #4]
	if( uxLED < partstMAX_LEDS )
     62c:	687b      	ldr	r3, [r7, #4]
     62e:	2b07      	cmp	r3, #7
     630:	d83d      	bhi.n	6ae <vParTestToggleLED+0x8a>
	{
		/* A critical section is used as the LEDs are also accessed from an
		interrupt. */
		taskENTER_CRITICAL();
     632:	f011 f889 	bl	11748 <vPortEnterCritical>
		{
			if( ( ulGPIOState & ( 1UL << uxLED ) ) != 0UL )
     636:	f240 53ec 	movw	r3, #1516	; 0x5ec
     63a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     63e:	681a      	ldr	r2, [r3, #0]
     640:	687b      	ldr	r3, [r7, #4]
     642:	fa22 f303 	lsr.w	r3, r2, r3
     646:	f003 0301 	and.w	r3, r3, #1
     64a:	b2db      	uxtb	r3, r3
     64c:	2b00      	cmp	r3, #0
     64e:	d013      	beq.n	678 <vParTestToggleLED+0x54>
			{
				ulGPIOState &= ~( 1UL << uxLED );
     650:	687b      	ldr	r3, [r7, #4]
     652:	f04f 0201 	mov.w	r2, #1
     656:	fa02 f303 	lsl.w	r3, r2, r3
     65a:	ea6f 0203 	mvn.w	r2, r3
     65e:	f240 53ec 	movw	r3, #1516	; 0x5ec
     662:	f2c2 0300 	movt	r3, #8192	; 0x2000
     666:	681b      	ldr	r3, [r3, #0]
     668:	ea02 0203 	and.w	r2, r2, r3
     66c:	f240 53ec 	movw	r3, #1516	; 0x5ec
     670:	f2c2 0300 	movt	r3, #8192	; 0x2000
     674:	601a      	str	r2, [r3, #0]
     676:	e010      	b.n	69a <vParTestToggleLED+0x76>
			}
			else
			{
				ulGPIOState |= ( 1UL << uxLED );
     678:	687b      	ldr	r3, [r7, #4]
     67a:	f04f 0201 	mov.w	r2, #1
     67e:	fa02 f203 	lsl.w	r2, r2, r3
     682:	f240 53ec 	movw	r3, #1516	; 0x5ec
     686:	f2c2 0300 	movt	r3, #8192	; 0x2000
     68a:	681b      	ldr	r3, [r3, #0]
     68c:	ea42 0203 	orr.w	r2, r2, r3
     690:	f240 53ec 	movw	r3, #1516	; 0x5ec
     694:	f2c2 0300 	movt	r3, #8192	; 0x2000
     698:	601a      	str	r2, [r3, #0]
			}
			
			MSS_GPIO_set_outputs( ulGPIOState );
     69a:	f240 53ec 	movw	r3, #1516	; 0x5ec
     69e:	f2c2 0300 	movt	r3, #8192	; 0x2000
     6a2:	681b      	ldr	r3, [r3, #0]
     6a4:	4618      	mov	r0, r3
     6a6:	f7ff fef3 	bl	490 <MSS_GPIO_set_outputs>
		}
		taskEXIT_CRITICAL();
     6aa:	f011 f885 	bl	117b8 <vPortExitCritical>
	}
}
     6ae:	f107 0708 	add.w	r7, r7, #8
     6b2:	46bd      	mov	sp, r7
     6b4:	bd80      	pop	{r7, pc}
     6b6:	bf00      	nop

000006b8 <lParTestGetLEDState>:
/*-----------------------------------------------------------*/

long lParTestGetLEDState( unsigned long ulLED )
{
     6b8:	b580      	push	{r7, lr}
     6ba:	b084      	sub	sp, #16
     6bc:	af00      	add	r7, sp, #0
     6be:	6078      	str	r0, [r7, #4]
long lReturn = pdFALSE;
     6c0:	f04f 0300 	mov.w	r3, #0
     6c4:	60fb      	str	r3, [r7, #12]

	if( ulLED < partstMAX_LEDS )
     6c6:	687b      	ldr	r3, [r7, #4]
     6c8:	2b07      	cmp	r3, #7
     6ca:	d812      	bhi.n	6f2 <lParTestGetLEDState+0x3a>
	{
		taskENTER_CRITICAL();
     6cc:	f011 f83c 	bl	11748 <vPortEnterCritical>
		{
			if( ( ulGPIOState & ( 1UL << ulLED ) ) == 0UL )
     6d0:	f240 53ec 	movw	r3, #1516	; 0x5ec
     6d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     6d8:	681a      	ldr	r2, [r3, #0]
     6da:	687b      	ldr	r3, [r7, #4]
     6dc:	fa22 f303 	lsr.w	r3, r2, r3
     6e0:	f003 0301 	and.w	r3, r3, #1
     6e4:	2b00      	cmp	r3, #0
     6e6:	d102      	bne.n	6ee <lParTestGetLEDState+0x36>
			{
				lReturn = pdTRUE;
     6e8:	f04f 0301 	mov.w	r3, #1
     6ec:	60fb      	str	r3, [r7, #12]
			}
		}
		taskEXIT_CRITICAL();
     6ee:	f011 f863 	bl	117b8 <vPortExitCritical>
	}

	return lReturn;
     6f2:	68fb      	ldr	r3, [r7, #12]
}
     6f4:	4618      	mov	r0, r3
     6f6:	f107 0710 	add.w	r7, r7, #16
     6fa:	46bd      	mov	sp, r7
     6fc:	bd80      	pop	{r7, pc}
     6fe:	bf00      	nop

00000700 <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
     700:	b480      	push	{r7}
     702:	b083      	sub	sp, #12
     704:	af00      	add	r7, sp, #0
     706:	4603      	mov	r3, r0
     708:	80fb      	strh	r3, [r7, #6]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
     70a:	f24e 1300 	movw	r3, #57600	; 0xe100
     70e:	f2ce 0300 	movt	r3, #57344	; 0xe000
     712:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
     716:	ea4f 1252 	mov.w	r2, r2, lsr #5
     71a:	88f9      	ldrh	r1, [r7, #6]
     71c:	f001 011f 	and.w	r1, r1, #31
     720:	f04f 0001 	mov.w	r0, #1
     724:	fa00 f101 	lsl.w	r1, r0, r1
     728:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
     72c:	f107 070c 	add.w	r7, r7, #12
     730:	46bd      	mov	sp, r7
     732:	bc80      	pop	{r7}
     734:	4770      	bx	lr
     736:	bf00      	nop

00000738 <NVIC_DisableIRQ>:
 * 
 * Disable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
     738:	b480      	push	{r7}
     73a:	b083      	sub	sp, #12
     73c:	af00      	add	r7, sp, #0
     73e:	4603      	mov	r3, r0
     740:	80fb      	strh	r3, [r7, #6]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
     742:	f24e 1300 	movw	r3, #57600	; 0xe100
     746:	f2ce 0300 	movt	r3, #57344	; 0xe000
     74a:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
     74e:	ea4f 1252 	mov.w	r2, r2, lsr #5
     752:	88f9      	ldrh	r1, [r7, #6]
     754:	f001 011f 	and.w	r1, r1, #31
     758:	f04f 0001 	mov.w	r0, #1
     75c:	fa00 f101 	lsl.w	r1, r0, r1
     760:	f102 0220 	add.w	r2, r2, #32
     764:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
     768:	f107 070c 	add.w	r7, r7, #12
     76c:	46bd      	mov	sp, r7
     76e:	bc80      	pop	{r7}
     770:	4770      	bx	lr
     772:	bf00      	nop

00000774 <NVIC_ClearPendingIRQ>:
 *
 * Clear the pending bit for the specified interrupt. 
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
     774:	b480      	push	{r7}
     776:	b083      	sub	sp, #12
     778:	af00      	add	r7, sp, #0
     77a:	4603      	mov	r3, r0
     77c:	80fb      	strh	r3, [r7, #6]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
     77e:	f24e 1300 	movw	r3, #57600	; 0xe100
     782:	f2ce 0300 	movt	r3, #57344	; 0xe000
     786:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
     78a:	ea4f 1252 	mov.w	r2, r2, lsr #5
     78e:	88f9      	ldrh	r1, [r7, #6]
     790:	f001 011f 	and.w	r1, r1, #31
     794:	f04f 0001 	mov.w	r0, #1
     798:	fa00 f101 	lsl.w	r1, r0, r1
     79c:	f102 0260 	add.w	r2, r2, #96	; 0x60
     7a0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
     7a4:	f107 070c 	add.w	r7, r7, #12
     7a8:	46bd      	mov	sp, r7
     7aa:	bc80      	pop	{r7}
     7ac:	4770      	bx	lr
     7ae:	bf00      	nop

000007b0 <NVIC_SetPriority>:
 * interrupt, or negative to specify an internal (core) interrupt.
 *
 * Note: The priority cannot be set for every core interrupt.
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
     7b0:	b480      	push	{r7}
     7b2:	b083      	sub	sp, #12
     7b4:	af00      	add	r7, sp, #0
     7b6:	4603      	mov	r3, r0
     7b8:	6039      	str	r1, [r7, #0]
     7ba:	80fb      	strh	r3, [r7, #6]
  if(IRQn < 0) {
     7bc:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
     7c0:	2b00      	cmp	r3, #0
     7c2:	da10      	bge.n	7e6 <NVIC_SetPriority+0x36>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M3 System Interrupts */
     7c4:	f64e 5300 	movw	r3, #60672	; 0xed00
     7c8:	f2ce 0300 	movt	r3, #57344	; 0xe000
     7cc:	88fa      	ldrh	r2, [r7, #6]
     7ce:	f002 020f 	and.w	r2, r2, #15
     7d2:	f1a2 0104 	sub.w	r1, r2, #4
     7d6:	683a      	ldr	r2, [r7, #0]
     7d8:	b2d2      	uxtb	r2, r2
     7da:	ea4f 02c2 	mov.w	r2, r2, lsl #3
     7de:	b2d2      	uxtb	r2, r2
     7e0:	440b      	add	r3, r1
     7e2:	761a      	strb	r2, [r3, #24]
     7e4:	e00d      	b.n	802 <NVIC_SetPriority+0x52>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
     7e6:	f24e 1300 	movw	r3, #57600	; 0xe100
     7ea:	f2ce 0300 	movt	r3, #57344	; 0xe000
     7ee:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
     7f2:	683a      	ldr	r2, [r7, #0]
     7f4:	b2d2      	uxtb	r2, r2
     7f6:	ea4f 02c2 	mov.w	r2, r2, lsl #3
     7fa:	b2d2      	uxtb	r2, r2
     7fc:	440b      	add	r3, r1
     7fe:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
     802:	f107 070c 	add.w	r7, r7, #12
     806:	46bd      	mov	sp, r7
     808:	bc80      	pop	{r7}
     80a:	4770      	bx	lr

0000080c <MSS_TIM64_init>:
    one-shot mode. Allowed values for this parameter are:
        - MSS_TIMER_PERIODIC_MODE
        - MSS_TIMER_ONE_SHOT_MODE 
 */
static __INLINE void MSS_TIM64_init( mss_timer_mode_t mode )
{
     80c:	b580      	push	{r7, lr}
     80e:	b082      	sub	sp, #8
     810:	af00      	add	r7, sp, #0
     812:	4603      	mov	r3, r0
     814:	71fb      	strb	r3, [r7, #7]
    NVIC_DisableIRQ( Timer1_IRQn );         /* disable timer 1 interrupt within NVIC */
     816:	f04f 0014 	mov.w	r0, #20
     81a:	f7ff ff8d 	bl	738 <NVIC_DisableIRQ>
    NVIC_DisableIRQ( Timer2_IRQn );         /* disable timer 2 interrupt within NVIC */
     81e:	f04f 0015 	mov.w	r0, #21
     822:	f7ff ff89 	bl	738 <NVIC_DisableIRQ>
    
    SYSREG->SOFT_RST_CR &= ~SYSREG_TIMER_SOFTRESET_MASK; /* Take timer block out of reset */
     826:	f242 0300 	movw	r3, #8192	; 0x2000
     82a:	f2ce 0304 	movt	r3, #57348	; 0xe004
     82e:	f242 0200 	movw	r2, #8192	; 0x2000
     832:	f2ce 0204 	movt	r2, #57348	; 0xe004
     836:	6b12      	ldr	r2, [r2, #48]	; 0x30
     838:	f022 0240 	bic.w	r2, r2, #64	; 0x40
     83c:	631a      	str	r2, [r3, #48]	; 0x30
    
    TIMER->TIM64_MODE = 1U;                     /* switch to 64 bits mode */
     83e:	f245 0300 	movw	r3, #20480	; 0x5000
     842:	f2c4 0300 	movt	r3, #16384	; 0x4000
     846:	f04f 0201 	mov.w	r2, #1
     84a:	655a      	str	r2, [r3, #84]	; 0x54
    
    TIMER_BITBAND->TIM64ENABLE = 0U;            /* disable timer */
     84c:	f240 0300 	movw	r3, #0
     850:	f2c4 230a 	movt	r3, #16906	; 0x420a
     854:	f04f 0200 	mov.w	r2, #0
     858:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
    TIMER_BITBAND->TIM64INTEN = 0U;             /* disable interrupt */
     85c:	f240 0300 	movw	r3, #0
     860:	f2c4 230a 	movt	r3, #16906	; 0x420a
     864:	f04f 0200 	mov.w	r2, #0
     868:	f8c3 2908 	str.w	r2, [r3, #2312]	; 0x908
    TIMER_BITBAND->TIM64MODE = (uint32_t)mode;  /* set mode (continuous/one-shot) */
     86c:	f240 0300 	movw	r3, #0
     870:	f2c4 230a 	movt	r3, #16906	; 0x420a
     874:	79fa      	ldrb	r2, [r7, #7]
     876:	f8c3 2904 	str.w	r2, [r3, #2308]	; 0x904
    
    TIMER->TIM1_RIS = 1U;                   /* clear timer 1 interrupt */
     87a:	f245 0300 	movw	r3, #20480	; 0x5000
     87e:	f2c4 0300 	movt	r3, #16384	; 0x4000
     882:	f04f 0201 	mov.w	r2, #1
     886:	611a      	str	r2, [r3, #16]
    TIMER->TIM2_RIS = 1U;                   /* clear timer 2 interrupt */
     888:	f245 0300 	movw	r3, #20480	; 0x5000
     88c:	f2c4 0300 	movt	r3, #16384	; 0x4000
     890:	f04f 0201 	mov.w	r2, #1
     894:	629a      	str	r2, [r3, #40]	; 0x28
    NVIC_ClearPendingIRQ( Timer1_IRQn );    /* clear timer 1 interrupt within NVIC */
     896:	f04f 0014 	mov.w	r0, #20
     89a:	f7ff ff6b 	bl	774 <NVIC_ClearPendingIRQ>
    NVIC_ClearPendingIRQ( Timer2_IRQn );    /* clear timer 2 interrupt within NVIC */
     89e:	f04f 0015 	mov.w	r0, #21
     8a2:	f7ff ff67 	bl	774 <NVIC_ClearPendingIRQ>
}
     8a6:	f107 0708 	add.w	r7, r7, #8
     8aa:	46bd      	mov	sp, r7
     8ac:	bd80      	pop	{r7, pc}
     8ae:	bf00      	nop

000008b0 <MSS_TIM64_start>:
  The MSS_TIM64_start() function enables the 64-bit timer and starts its
  down-counter decrementing from the load_value specified in previous calls to
  the MSS_TIM64_load_immediate() or MSS_TIM64_load_background() functions.
 */
static __INLINE void MSS_TIM64_start( void )
{
     8b0:	b480      	push	{r7}
     8b2:	af00      	add	r7, sp, #0
    TIMER_BITBAND->TIM64ENABLE = 1U;    /* enable timer */
     8b4:	f240 0300 	movw	r3, #0
     8b8:	f2c4 230a 	movt	r3, #16906	; 0x420a
     8bc:	f04f 0201 	mov.w	r2, #1
     8c0:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
}
     8c4:	46bd      	mov	sp, r7
     8c6:	bc80      	pop	{r7}
     8c8:	4770      	bx	lr
     8ca:	bf00      	nop

000008cc <MSS_TIM64_get_current_value>:
static __INLINE void MSS_TIM64_get_current_value
(
    uint32_t * load_value_u,
    uint32_t * load_value_l
)
{
     8cc:	b480      	push	{r7}
     8ce:	b083      	sub	sp, #12
     8d0:	af00      	add	r7, sp, #0
     8d2:	6078      	str	r0, [r7, #4]
     8d4:	6039      	str	r1, [r7, #0]
    *load_value_l = TIMER->TIM64_VAL_L;
     8d6:	f245 0300 	movw	r3, #20480	; 0x5000
     8da:	f2c4 0300 	movt	r3, #16384	; 0x4000
     8de:	6b5a      	ldr	r2, [r3, #52]	; 0x34
     8e0:	683b      	ldr	r3, [r7, #0]
     8e2:	601a      	str	r2, [r3, #0]
    *load_value_u = TIMER->TIM64_VAL_U;
     8e4:	f245 0300 	movw	r3, #20480	; 0x5000
     8e8:	f2c4 0300 	movt	r3, #16384	; 0x4000
     8ec:	6b1a      	ldr	r2, [r3, #48]	; 0x30
     8ee:	687b      	ldr	r3, [r7, #4]
     8f0:	601a      	str	r2, [r3, #0]
}
     8f2:	f107 070c 	add.w	r7, r7, #12
     8f6:	46bd      	mov	sp, r7
     8f8:	bc80      	pop	{r7}
     8fa:	4770      	bx	lr

000008fc <MSS_TIM64_load_immediate>:
static __INLINE void MSS_TIM64_load_immediate
(
    uint32_t load_value_u,
    uint32_t load_value_l
)
{
     8fc:	b480      	push	{r7}
     8fe:	b083      	sub	sp, #12
     900:	af00      	add	r7, sp, #0
     902:	6078      	str	r0, [r7, #4]
     904:	6039      	str	r1, [r7, #0]
    TIMER->TIM64_LOADVAL_U = load_value_u;
     906:	f245 0300 	movw	r3, #20480	; 0x5000
     90a:	f2c4 0300 	movt	r3, #16384	; 0x4000
     90e:	687a      	ldr	r2, [r7, #4]
     910:	639a      	str	r2, [r3, #56]	; 0x38
    TIMER->TIM64_LOADVAL_L = load_value_l;
     912:	f245 0300 	movw	r3, #20480	; 0x5000
     916:	f2c4 0300 	movt	r3, #16384	; 0x4000
     91a:	683a      	ldr	r2, [r7, #0]
     91c:	63da      	str	r2, [r3, #60]	; 0x3c
}
     91e:	f107 070c 	add.w	r7, r7, #12
     922:	46bd      	mov	sp, r7
     924:	bc80      	pop	{r7}
     926:	4770      	bx	lr

00000928 <main>:
static const char *pcStatusMessage = NULL;

/*-----------------------------------------------------------*/

int main(void)
{
     928:	b580      	push	{r7, lr}
     92a:	b082      	sub	sp, #8
     92c:	af02      	add	r7, sp, #8
	/* Configure the NVIC, LED outputs and button inputs. */
	prvSetupHardware();
     92e:	f000 f93b 	bl	ba8 <prvSetupHardware>

	/* Create the queue. */
	xQueue = xQueueCreate( mainQUEUE_LENGTH, sizeof( unsigned long ) );
     932:	f04f 0001 	mov.w	r0, #1
     936:	f04f 0104 	mov.w	r1, #4
     93a:	f04f 0200 	mov.w	r2, #0
     93e:	f00b ff63 	bl	c808 <xQueueGenericCreate>
     942:	4602      	mov	r2, r0
     944:	f240 53f0 	movw	r3, #1520	; 0x5f0
     948:	f2c2 0300 	movt	r3, #8192	; 0x2000
     94c:	601a      	str	r2, [r3, #0]

	if( xQueue != NULL )
     94e:	f240 53f0 	movw	r3, #1520	; 0x5f0
     952:	f2c2 0300 	movt	r3, #8192	; 0x2000
     956:	681b      	ldr	r3, [r3, #0]
     958:	2b00      	cmp	r3, #0
     95a:	d06b      	beq.n	a34 <main+0x10c>
	{
		/* Start the three application specific demo tasks, as described in the
		comments at the top of this	file. */
		xTaskCreate( prvQueueReceiveTask, "Rx", configMINIMAL_STACK_SIZE, NULL, mainQUEUE_RECEIVE_TASK_PRIORITY, NULL );
     95c:	f04f 0302 	mov.w	r3, #2
     960:	9300      	str	r3, [sp, #0]
     962:	f04f 0300 	mov.w	r3, #0
     966:	9301      	str	r3, [sp, #4]
     968:	f640 3071 	movw	r0, #2929	; 0xb71
     96c:	f2c0 0000 	movt	r0, #0
     970:	f243 01ac 	movw	r1, #12460	; 0x30ac
     974:	f2c0 0101 	movt	r1, #1
     978:	f04f 025a 	mov.w	r2, #90	; 0x5a
     97c:	f04f 0300 	mov.w	r3, #0
     980:	f00d f91a 	bl	dbb8 <xTaskCreate>
		xTaskCreate( prvQueueSendTask, "TX", configMINIMAL_STACK_SIZE, NULL, mainQUEUE_SEND_TASK_PRIORITY, NULL );
     984:	f04f 0301 	mov.w	r3, #1
     988:	9300      	str	r3, [sp, #0]
     98a:	f04f 0300 	mov.w	r3, #0
     98e:	9301      	str	r3, [sp, #4]
     990:	f640 3005 	movw	r0, #2821	; 0xb05
     994:	f2c0 0000 	movt	r0, #0
     998:	f243 01b0 	movw	r1, #12464	; 0x30b0
     99c:	f2c0 0101 	movt	r1, #1
     9a0:	f04f 025a 	mov.w	r2, #90	; 0x5a
     9a4:	f04f 0300 	mov.w	r3, #0
     9a8:	f00d f906 	bl	dbb8 <xTaskCreate>


		/* Create the software timer that is responsible for turning off the LED
		if the button is not pushed within 5000ms, as described at the top of
		this file. */
		xLEDTimer = xTimerCreate( 	"LEDTimer", 					/* A text name, purely to help debugging. */
     9ac:	f640 2381 	movw	r3, #2689	; 0xa81
     9b0:	f2c0 0300 	movt	r3, #0
     9b4:	9300      	str	r3, [sp, #0]
     9b6:	f243 00b4 	movw	r0, #12468	; 0x30b4
     9ba:	f2c0 0001 	movt	r0, #1
     9be:	f241 3188 	movw	r1, #5000	; 0x1388
     9c2:	f04f 0200 	mov.w	r2, #0
     9c6:	f04f 0300 	mov.w	r3, #0
     9ca:	f00f ffe5 	bl	10998 <xTimerCreate>
     9ce:	4602      	mov	r2, r0
     9d0:	f240 53f4 	movw	r3, #1524	; 0x5f4
     9d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     9d8:	601a      	str	r2, [r3, #0]
									prvLEDTimerCallback				/* The callback function that switches the LED off. */
								);

		/* Create the software timer that performs the 'check' functionality,
		as described at the top of this file. */
		xCheckTimer = xTimerCreate( "CheckTimer",					/* A text name, purely to help debugging. */
     9da:	f640 2339 	movw	r3, #2617	; 0xa39
     9de:	f2c0 0300 	movt	r3, #0
     9e2:	9300      	str	r3, [sp, #0]
     9e4:	f243 00c0 	movw	r0, #12480	; 0x30c0
     9e8:	f2c0 0001 	movt	r0, #1
     9ec:	f640 31b8 	movw	r1, #3000	; 0xbb8
     9f0:	f04f 0201 	mov.w	r2, #1
     9f4:	f04f 0300 	mov.w	r3, #0
     9f8:	f00f ffce 	bl	10998 <xTimerCreate>
     9fc:	4602      	mov	r2, r0
     9fe:	f240 53f8 	movw	r3, #1528	; 0x5f8
     a02:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a06:	601a      	str	r2, [r3, #0]
									( void * ) 0,					/* The ID is not used, so can be set to anything. */
									prvCheckTimerCallback			/* The callback function that inspects the status of all the other tasks. */
								  );

		/* Create the web server task. */
		xTaskCreate( vuIP_Task, "uIP", mainuIP_STACK_SIZE, NULL, mainuIP_TASK_PRIORITY, NULL );
     a08:	f04f 0302 	mov.w	r3, #2
     a0c:	9300      	str	r3, [sp, #0]
     a0e:	f04f 0300 	mov.w	r3, #0
     a12:	9301      	str	r3, [sp, #4]
     a14:	f241 2049 	movw	r0, #4681	; 0x1249
     a18:	f2c0 0000 	movt	r0, #0
     a1c:	f243 01cc 	movw	r1, #12492	; 0x30cc
     a20:	f2c0 0101 	movt	r1, #1
     a24:	f44f 7287 	mov.w	r2, #270	; 0x10e
     a28:	f04f 0300 	mov.w	r3, #0
     a2c:	f00d f8c4 	bl	dbb8 <xTaskCreate>

		/* Start the tasks and timer running. */
		vTaskStartScheduler();
     a30:	f00d ff32 	bl	e898 <vTaskStartScheduler>
	/* If all is well, the scheduler will now be running, and the following line
	will never be reached.  If the following line does execute, then there was
	insufficient FreeRTOS heap memory available for the idle and/or timer tasks
	to be created.  See the memory management section on the FreeRTOS web site
	for more details. */
	for( ;; );
     a34:	e7fe      	b.n	a34 <main+0x10c>
     a36:	bf00      	nop

00000a38 <prvCheckTimerCallback>:
}
/*-----------------------------------------------------------*/

static void prvCheckTimerCallback( TimerHandle_t xTimer )
{
     a38:	b580      	push	{r7, lr}
     a3a:	b084      	sub	sp, #16
     a3c:	af02      	add	r7, sp, #8
     a3e:	6078      	str	r0, [r7, #4]
	latest reported error in the pcStatusMessage character pointer. */

	/* Toggle the check LED to give an indication of the system status.  If
	the LED toggles every mainCHECK_TIMER_PERIOD_MS milliseconds then
	everything is ok.  A faster toggle indicates an error. */
	vParTestToggleLED( mainCHECK_LED );
     a40:	f04f 0007 	mov.w	r0, #7
     a44:	f7ff fdee 	bl	624 <vParTestToggleLED>

	/* Have any errors been latch in pcStatusMessage?  If so, shorten the
	period of the check timer to mainERROR_CHECK_TIMER_PERIOD_MS milliseconds.
	This will result in an increase in the rate at which mainCHECK_LED
	toggles. */
	if( pcStatusMessage != NULL )
     a48:	f240 53fc 	movw	r3, #1532	; 0x5fc
     a4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a50:	681b      	ldr	r3, [r3, #0]
     a52:	2b00      	cmp	r3, #0
     a54:	d010      	beq.n	a78 <prvCheckTimerCallback+0x40>
	{
		/* This call to xTimerChangePeriod() uses a zero block time.  Functions
		called from inside of a timer callback function must *never* attempt
		to block. */
		xTimerChangePeriod( xCheckTimer, ( mainERROR_CHECK_TIMER_PERIOD_MS ), mainDONT_BLOCK );
     a56:	f240 53f8 	movw	r3, #1528	; 0x5f8
     a5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a5e:	681b      	ldr	r3, [r3, #0]
     a60:	f04f 0200 	mov.w	r2, #0
     a64:	9200      	str	r2, [sp, #0]
     a66:	4618      	mov	r0, r3
     a68:	f04f 0104 	mov.w	r1, #4
     a6c:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
     a70:	f04f 0300 	mov.w	r3, #0
     a74:	f00f ffe2 	bl	10a3c <xTimerGenericCommand>
	}
}
     a78:	f107 0708 	add.w	r7, r7, #8
     a7c:	46bd      	mov	sp, r7
     a7e:	bd80      	pop	{r7, pc}

00000a80 <prvLEDTimerCallback>:
/*-----------------------------------------------------------*/

static void prvLEDTimerCallback( TimerHandle_t xTimer )
{
     a80:	b580      	push	{r7, lr}
     a82:	b082      	sub	sp, #8
     a84:	af00      	add	r7, sp, #0
     a86:	6078      	str	r0, [r7, #4]
	/* The timer has expired - so no button pushes have occurred in the last
	five seconds - turn the LED off. */
	vParTestSetLED( mainTIMER_CONTROLLED_LED, pdFALSE );
     a88:	f04f 0006 	mov.w	r0, #6
     a8c:	f04f 0100 	mov.w	r1, #0
     a90:	f7ff fd38 	bl	504 <vParTestSetLED>
}
     a94:	f107 0708 	add.w	r7, r7, #8
     a98:	46bd      	mov	sp, r7
     a9a:	bd80      	pop	{r7, pc}

00000a9c <GPIO8_IRQHandler>:
/*-----------------------------------------------------------*/

/* The ISR executed when the user button is pushed. */
void GPIO8_IRQHandler( void )
{
     a9c:	b590      	push	{r4, r7, lr}
     a9e:	b085      	sub	sp, #20
     aa0:	af02      	add	r7, sp, #8
portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     aa2:	f04f 0300 	mov.w	r3, #0
     aa6:	607b      	str	r3, [r7, #4]

	/* The button was pushed, so ensure the LED is on before resetting the
	LED timer.  The LED timer will turn the LED off if the button is not
	pushed within 5000ms. */
	vParTestSetLEDFromISR( mainTIMER_CONTROLLED_LED, pdTRUE );
     aa8:	f04f 0006 	mov.w	r0, #6
     aac:	f04f 0101 	mov.w	r1, #1
     ab0:	f7ff fd68 	bl	584 <vParTestSetLEDFromISR>

	/* This interrupt safe FreeRTOS function can be called from this interrupt
	because the interrupt priority is below the
	configMAX_SYSCALL_INTERRUPT_PRIORITY setting in FreeRTOSConfig.h. */
	xTimerResetFromISR( xLEDTimer, &xHigherPriorityTaskWoken );
     ab4:	f240 53f4 	movw	r3, #1524	; 0x5f4
     ab8:	f2c2 0300 	movt	r3, #8192	; 0x2000
     abc:	681c      	ldr	r4, [r3, #0]
     abe:	f00e f851 	bl	eb64 <xTaskGetTickCountFromISR>
     ac2:	4602      	mov	r2, r0
     ac4:	f107 0304 	add.w	r3, r7, #4
     ac8:	f04f 0100 	mov.w	r1, #0
     acc:	9100      	str	r1, [sp, #0]
     ace:	4620      	mov	r0, r4
     ad0:	f04f 0107 	mov.w	r1, #7
     ad4:	f00f ffb2 	bl	10a3c <xTimerGenericCommand>

	/* Clear the interrupt before leaving. */
    MSS_GPIO_clear_irq( MSS_GPIO_8 );
     ad8:	f04f 0008 	mov.w	r0, #8
     adc:	f001 fb98 	bl	2210 <MSS_GPIO_clear_irq>
	/* If calling xTimerResetFromISR() caused a task (in this case the timer
	service/daemon task) to unblock, and the unblocked task has a priority
	higher than or equal to the task that was interrupted, then
	xHigherPriorityTaskWoken will now be set to pdTRUE, and calling
	portEND_SWITCHING_ISR() will ensure the unblocked task runs next. */
	portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );
     ae0:	687b      	ldr	r3, [r7, #4]
     ae2:	2b00      	cmp	r3, #0
     ae4:	d00a      	beq.n	afc <GPIO8_IRQHandler+0x60>
     ae6:	f64e 5304 	movw	r3, #60676	; 0xed04
     aea:	f2ce 0300 	movt	r3, #57344	; 0xe000
     aee:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
     af2:	601a      	str	r2, [r3, #0]
     af4:	f3bf 8f4f 	dsb	sy
     af8:	f3bf 8f6f 	isb	sy
}
     afc:	f107 070c 	add.w	r7, r7, #12
     b00:	46bd      	mov	sp, r7
     b02:	bd90      	pop	{r4, r7, pc}

00000b04 <prvQueueSendTask>:
/*-----------------------------------------------------------*/

static void prvQueueSendTask( void *pvParameters )
{
     b04:	b590      	push	{r4, r7, lr}
     b06:	b087      	sub	sp, #28
     b08:	af02      	add	r7, sp, #8
     b0a:	6078      	str	r0, [r7, #4]
TickType_t xNextWakeTime;
const unsigned long ulValueToSend = 100UL;
     b0c:	f04f 0364 	mov.w	r3, #100	; 0x64
     b10:	60bb      	str	r3, [r7, #8]
	/* The timer command queue will have been filled when the timer test tasks
	were created in main() (this is part of the test they perform).  Therefore,
	while the check timer can be created in main(), it cannot be started from
	main().  Once the scheduler has started, the timer service task will drain
	the command queue, and now the check timer can be started successfully. */
	xTimerStart( xCheckTimer, portMAX_DELAY );
     b12:	f240 53f8 	movw	r3, #1528	; 0x5f8
     b16:	f2c2 0300 	movt	r3, #8192	; 0x2000
     b1a:	681c      	ldr	r4, [r3, #0]
     b1c:	f00e f812 	bl	eb44 <xTaskGetTickCount>
     b20:	4603      	mov	r3, r0
     b22:	f04f 32ff 	mov.w	r2, #4294967295
     b26:	9200      	str	r2, [sp, #0]
     b28:	4620      	mov	r0, r4
     b2a:	f04f 0101 	mov.w	r1, #1
     b2e:	461a      	mov	r2, r3
     b30:	f04f 0300 	mov.w	r3, #0
     b34:	f00f ff82 	bl	10a3c <xTimerGenericCommand>

	/* Initialise xNextWakeTime - this only needs to be done once. */
	xNextWakeTime = xTaskGetTickCount();
     b38:	f00e f804 	bl	eb44 <xTaskGetTickCount>
     b3c:	4603      	mov	r3, r0
     b3e:	60fb      	str	r3, [r7, #12]
	{
		/* Place this task in the blocked state until it is time to run again.
		The block time is specified in ticks, the constant used converts ticks
		to ms.  While in the Blocked state this task will not consume any CPU
		time. */
		vTaskDelayUntil( &xNextWakeTime, mainQUEUE_SEND_FREQUENCY_MS );
     b40:	f107 030c 	add.w	r3, r7, #12
     b44:	4618      	mov	r0, r3
     b46:	f04f 01c8 	mov.w	r1, #200	; 0xc8
     b4a:	f00d fa77 	bl	e03c <vTaskDelayUntil>

		/* Send to the queue - causing the queue receive task to unblock and
		toggle an LED.  0 is used as the block time so the sending operation
		will not block - it shouldn't need to block as the queue should always
		be empty at this point in the code. */
		xQueueSend( xQueue, &ulValueToSend, mainDONT_BLOCK );
     b4e:	f240 53f0 	movw	r3, #1520	; 0x5f0
     b52:	f2c2 0300 	movt	r3, #8192	; 0x2000
     b56:	681a      	ldr	r2, [r3, #0]
     b58:	f107 0308 	add.w	r3, r7, #8
     b5c:	4610      	mov	r0, r2
     b5e:	4619      	mov	r1, r3
     b60:	f04f 0200 	mov.w	r2, #0
     b64:	f04f 0300 	mov.w	r3, #0
     b68:	f00b ff62 	bl	ca30 <xQueueGenericSend>
	}
     b6c:	e7e8      	b.n	b40 <prvQueueSendTask+0x3c>
     b6e:	bf00      	nop

00000b70 <prvQueueReceiveTask>:
}
/*-----------------------------------------------------------*/

static void prvQueueReceiveTask( void *pvParameters )
{
     b70:	b580      	push	{r7, lr}
     b72:	b084      	sub	sp, #16
     b74:	af00      	add	r7, sp, #0
     b76:	6078      	str	r0, [r7, #4]
     b78:	e000      	b.n	b7c <prvQueueReceiveTask+0xc>
		is it the expected value?  If it is, toggle the LED. */
		if( ulReceivedValue == 100UL )
		{
			vParTestToggleLED( mainTASK_CONTROLLED_LED );
		}
	}
     b7a:	bf00      	nop
	for( ;; )
	{
		/* Wait until something arrives in the queue - this task will block
		indefinitely provided INCLUDE_vTaskSuspend is set to 1 in
		FreeRTOSConfig.h. */
		xQueueReceive( xQueue, &ulReceivedValue, portMAX_DELAY );
     b7c:	f240 53f0 	movw	r3, #1520	; 0x5f0
     b80:	f2c2 0300 	movt	r3, #8192	; 0x2000
     b84:	681a      	ldr	r2, [r3, #0]
     b86:	f107 030c 	add.w	r3, r7, #12
     b8a:	4610      	mov	r0, r2
     b8c:	4619      	mov	r1, r3
     b8e:	f04f 32ff 	mov.w	r2, #4294967295
     b92:	f00c f99d 	bl	ced0 <xQueueReceive>

		/*  To get here something must have been received from the queue, but
		is it the expected value?  If it is, toggle the LED. */
		if( ulReceivedValue == 100UL )
     b96:	68fb      	ldr	r3, [r7, #12]
     b98:	2b64      	cmp	r3, #100	; 0x64
     b9a:	d1ee      	bne.n	b7a <prvQueueReceiveTask+0xa>
		{
			vParTestToggleLED( mainTASK_CONTROLLED_LED );
     b9c:	f04f 0005 	mov.w	r0, #5
     ba0:	f7ff fd40 	bl	624 <vParTestToggleLED>
		}
	}
     ba4:	e7ea      	b.n	b7c <prvQueueReceiveTask+0xc>
     ba6:	bf00      	nop

00000ba8 <prvSetupHardware>:


/*-----------------------------------------------------------*/

static void prvSetupHardware( void )
{
     ba8:	b580      	push	{r7, lr}
     baa:	af00      	add	r7, sp, #0
	SystemCoreClockUpdate();
     bac:	f006 fdb8 	bl	7720 <SystemCoreClockUpdate>


	/* Configure the GPIO for the LEDs. */
	vParTestInitialise();
     bb0:	f7ff fc7e 	bl	4b0 <vParTestInitialise>

	/* ACE Initialization */
	ACE_init();
     bb4:	f004 fe36 	bl	5824 <ACE_init>

	/* Setup the GPIO and the NVIC for the switch used in this simple demo. */
	NVIC_SetPriority( GPIO8_IRQn, configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY );
     bb8:	f04f 0028 	mov.w	r0, #40	; 0x28
     bbc:	f04f 0105 	mov.w	r1, #5
     bc0:	f7ff fdf6 	bl	7b0 <NVIC_SetPriority>
    NVIC_EnableIRQ( GPIO8_IRQn );
     bc4:	f04f 0028 	mov.w	r0, #40	; 0x28
     bc8:	f7ff fd9a 	bl	700 <NVIC_EnableIRQ>
    MSS_GPIO_config( MSS_GPIO_8, MSS_GPIO_INPUT_MODE | MSS_GPIO_IRQ_EDGE_NEGATIVE );
     bcc:	f04f 0008 	mov.w	r0, #8
     bd0:	f04f 0162 	mov.w	r1, #98	; 0x62
     bd4:	f001 f9f0 	bl	1fb8 <MSS_GPIO_config>
    MSS_GPIO_enable_irq( MSS_GPIO_8 );
     bd8:	f04f 0008 	mov.w	r0, #8
     bdc:	f001 fabe 	bl	215c <MSS_GPIO_enable_irq>
}
     be0:	bd80      	pop	{r7, pc}
     be2:	bf00      	nop

00000be4 <vApplicationMallocFailedHook>:
/*-----------------------------------------------------------*/

void vApplicationMallocFailedHook( void )
{
     be4:	b480      	push	{r7}
     be6:	af00      	add	r7, sp, #0
	/* Called if a call to pvPortMalloc() fails because there is insufficient
	free memory available in the FreeRTOS heap.  pvPortMalloc() is called
	internally by FreeRTOS API functions that create tasks, queues, software
	timers, and semaphores.  The size of the FreeRTOS heap is set by the
	configTOTAL_HEAP_SIZE configuration constant in FreeRTOSConfig.h. */
	for( ;; );
     be8:	e7fe      	b.n	be8 <vApplicationMallocFailedHook+0x4>
     bea:	bf00      	nop

00000bec <vApplicationStackOverflowHook>:
}
/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName )
{
     bec:	b480      	push	{r7}
     bee:	b085      	sub	sp, #20
     bf0:	af00      	add	r7, sp, #0
     bf2:	6078      	str	r0, [r7, #4]
     bf4:	6039      	str	r1, [r7, #0]

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
     bf6:	f04f 0328 	mov.w	r3, #40	; 0x28
     bfa:	f383 8811 	msr	BASEPRI, r3
     bfe:	f3bf 8f6f 	isb	sy
     c02:	f3bf 8f4f 	dsb	sy
     c06:	60fb      	str	r3, [r7, #12]

	/* Run time stack overflow checking is performed if
	configconfigCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected. */
	taskDISABLE_INTERRUPTS();
	for( ;; );
     c08:	e7fe      	b.n	c08 <vApplicationStackOverflowHook+0x1c>
     c0a:	bf00      	nop

00000c0c <vApplicationIdleHook>:
}
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
     c0c:	b580      	push	{r7, lr}
     c0e:	b082      	sub	sp, #8
     c10:	af00      	add	r7, sp, #0
volatile size_t xFreeStackSpace;

	/* This function is called on each cycle of the idle task.  In this case it
	does nothing useful, other than report the amount of FreeRTOS heap that
	remains unallocated. */
	xFreeStackSpace = xPortGetFreeHeapSize();
     c12:	f010 fc13 	bl	1143c <xPortGetFreeHeapSize>
     c16:	4603      	mov	r3, r0
     c18:	607b      	str	r3, [r7, #4]

	if( xFreeStackSpace > 100 )
     c1a:	687b      	ldr	r3, [r7, #4]
		/* By now, the kernel has allocated everything it is going to, so
		if there is a lot of heap remaining unallocated then
		the value of configTOTAL_HEAP_SIZE in FreeRTOSConfig.h can be
		reduced accordingly. */
	}
}
     c1c:	f107 0708 	add.w	r7, r7, #8
     c20:	46bd      	mov	sp, r7
     c22:	bd80      	pop	{r7, pc}

00000c24 <pcGetTaskStatusMessage>:
/*-----------------------------------------------------------*/

char *pcGetTaskStatusMessage( void )
{
     c24:	b480      	push	{r7}
     c26:	af00      	add	r7, sp, #0
	/* Not bothered about a critical section here although technically because
	of the task priorities the pointer could change it will be atomic if not
	near atomic and its not critical. */
	if( pcStatusMessage == NULL )
     c28:	f240 53fc 	movw	r3, #1532	; 0x5fc
     c2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     c30:	681b      	ldr	r3, [r3, #0]
     c32:	2b00      	cmp	r3, #0
     c34:	d104      	bne.n	c40 <pcGetTaskStatusMessage+0x1c>
	{
		return "All tasks running without error";
     c36:	f243 03d0 	movw	r3, #12496	; 0x30d0
     c3a:	f2c0 0301 	movt	r3, #1
     c3e:	e004      	b.n	c4a <pcGetTaskStatusMessage+0x26>
	}
	else
	{
		return ( char * ) pcStatusMessage;
     c40:	f240 53fc 	movw	r3, #1532	; 0x5fc
     c44:	f2c2 0300 	movt	r3, #8192	; 0x2000
     c48:	681b      	ldr	r3, [r3, #0]
	}
}
     c4a:	4618      	mov	r0, r3
     c4c:	46bd      	mov	sp, r7
     c4e:	bc80      	pop	{r7}
     c50:	4770      	bx	lr
     c52:	bf00      	nop

00000c54 <vMainConfigureTimerForRunTimeStats>:
/*-----------------------------------------------------------*/

void vMainConfigureTimerForRunTimeStats( void )
{
     c54:	b580      	push	{r7, lr}
     c56:	b082      	sub	sp, #8
     c58:	af00      	add	r7, sp, #0
const unsigned long ulMax32BitValue = 0xffffffffUL;
     c5a:	f04f 33ff 	mov.w	r3, #4294967295
     c5e:	607b      	str	r3, [r7, #4]

	MSS_TIM64_init( MSS_TIMER_PERIODIC_MODE );
     c60:	f04f 0000 	mov.w	r0, #0
     c64:	f7ff fdd2 	bl	80c <MSS_TIM64_init>
	MSS_TIM64_load_immediate( ulMax32BitValue, ulMax32BitValue );
     c68:	6878      	ldr	r0, [r7, #4]
     c6a:	6879      	ldr	r1, [r7, #4]
     c6c:	f7ff fe46 	bl	8fc <MSS_TIM64_load_immediate>
	MSS_TIM64_start();
     c70:	f7ff fe1e 	bl	8b0 <MSS_TIM64_start>
}
     c74:	f107 0708 	add.w	r7, r7, #8
     c78:	46bd      	mov	sp, r7
     c7a:	bd80      	pop	{r7, pc}

00000c7c <ulGetRunTimeCounterValue>:
/*-----------------------------------------------------------*/

unsigned long ulGetRunTimeCounterValue( void )
{
     c7c:	b5b0      	push	{r4, r5, r7, lr}
     c7e:	b086      	sub	sp, #24
     c80:	af00      	add	r7, sp, #0
unsigned long long ullCurrentValue;
const unsigned long long ulMax64BitValue = 0xffffffffffffffffULL;
     c82:	f04f 32ff 	mov.w	r2, #4294967295
     c86:	f04f 33ff 	mov.w	r3, #4294967295
     c8a:	e9c7 2302 	strd	r2, r3, [r7, #8]
unsigned long *pulHighWord, *pulLowWord;

	pulHighWord = ( unsigned long * ) &ullCurrentValue;
     c8e:	463b      	mov	r3, r7
     c90:	613b      	str	r3, [r7, #16]
	pulLowWord = pulHighWord++;
     c92:	693b      	ldr	r3, [r7, #16]
     c94:	617b      	str	r3, [r7, #20]
     c96:	693b      	ldr	r3, [r7, #16]
     c98:	f103 0304 	add.w	r3, r3, #4
     c9c:	613b      	str	r3, [r7, #16]

	MSS_TIM64_get_current_value( ( uint32_t * ) pulHighWord, ( uint32_t * ) pulLowWord );
     c9e:	6938      	ldr	r0, [r7, #16]
     ca0:	6979      	ldr	r1, [r7, #20]
     ca2:	f7ff fe13 	bl	8cc <MSS_TIM64_get_current_value>

	/* Convert the down count into an upcount. */
	ullCurrentValue = ulMax64BitValue - ullCurrentValue;
     ca6:	e9d7 2300 	ldrd	r2, r3, [r7]
     caa:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
     cae:	1a82      	subs	r2, r0, r2
     cb0:	eb61 0303 	sbc.w	r3, r1, r3
     cb4:	e9c7 2300 	strd	r2, r3, [r7]

	/* Scale to a 32bit number of suitable frequency. */
	ullCurrentValue >>= 13;
     cb8:	e9d7 2300 	ldrd	r2, r3, [r7]
     cbc:	ea4f 41c3 	mov.w	r1, r3, lsl #19
     cc0:	ea4f 3452 	mov.w	r4, r2, lsr #13
     cc4:	ea41 0404 	orr.w	r4, r1, r4
     cc8:	ea4f 3553 	mov.w	r5, r3, lsr #13
     ccc:	e9c7 4500 	strd	r4, r5, [r7]

	/* Just return 32 bits. */
	return ( unsigned long ) ullCurrentValue;
     cd0:	e9d7 2300 	ldrd	r2, r3, [r7]
     cd4:	4613      	mov	r3, r2
}
     cd6:	4618      	mov	r0, r3
     cd8:	f107 0718 	add.w	r7, r7, #24
     cdc:	46bd      	mov	sp, r7
     cde:	bdb0      	pop	{r4, r5, r7, pc}

00000ce0 <printchar>:
#define putchar(c) c

#include <stdarg.h>

static void printchar(char **str, int c)
{
     ce0:	b480      	push	{r7}
     ce2:	b083      	sub	sp, #12
     ce4:	af00      	add	r7, sp, #0
     ce6:	6078      	str	r0, [r7, #4]
     ce8:	6039      	str	r1, [r7, #0]
	//extern int putchar(int c);
	
	if (str) {
     cea:	687b      	ldr	r3, [r7, #4]
     cec:	2b00      	cmp	r3, #0
     cee:	d00a      	beq.n	d06 <printchar+0x26>
		**str = (char)c;
     cf0:	687b      	ldr	r3, [r7, #4]
     cf2:	681b      	ldr	r3, [r3, #0]
     cf4:	683a      	ldr	r2, [r7, #0]
     cf6:	b2d2      	uxtb	r2, r2
     cf8:	701a      	strb	r2, [r3, #0]
		++(*str);
     cfa:	687b      	ldr	r3, [r7, #4]
     cfc:	681b      	ldr	r3, [r3, #0]
     cfe:	f103 0201 	add.w	r2, r3, #1
     d02:	687b      	ldr	r3, [r7, #4]
     d04:	601a      	str	r2, [r3, #0]
	}
	else
	{ 
		(void)putchar(c);
	}
}
     d06:	f107 070c 	add.w	r7, r7, #12
     d0a:	46bd      	mov	sp, r7
     d0c:	bc80      	pop	{r7}
     d0e:	4770      	bx	lr

00000d10 <prints>:

#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
     d10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     d14:	b084      	sub	sp, #16
     d16:	af00      	add	r7, sp, #0
     d18:	60f8      	str	r0, [r7, #12]
     d1a:	60b9      	str	r1, [r7, #8]
     d1c:	607a      	str	r2, [r7, #4]
     d1e:	603b      	str	r3, [r7, #0]
	register int pc = 0, padchar = ' ';
     d20:	f04f 0400 	mov.w	r4, #0
     d24:	f04f 0620 	mov.w	r6, #32

	if (width > 0) {
     d28:	687b      	ldr	r3, [r7, #4]
     d2a:	2b00      	cmp	r3, #0
     d2c:	dd1e      	ble.n	d6c <prints+0x5c>
		register int len = 0;
     d2e:	f04f 0500 	mov.w	r5, #0
		register const char *ptr;
		for (ptr = string; *ptr; ++ptr) ++len;
     d32:	f8d7 8008 	ldr.w	r8, [r7, #8]
     d36:	e003      	b.n	d40 <prints+0x30>
     d38:	f105 0501 	add.w	r5, r5, #1
     d3c:	f108 0801 	add.w	r8, r8, #1
     d40:	f898 3000 	ldrb.w	r3, [r8]
     d44:	2b00      	cmp	r3, #0
     d46:	d1f7      	bne.n	d38 <prints+0x28>
		if (len >= width) width = 0;
     d48:	687b      	ldr	r3, [r7, #4]
     d4a:	429d      	cmp	r5, r3
     d4c:	db03      	blt.n	d56 <prints+0x46>
     d4e:	f04f 0300 	mov.w	r3, #0
     d52:	607b      	str	r3, [r7, #4]
     d54:	e003      	b.n	d5e <prints+0x4e>
		else width -= len;
     d56:	687b      	ldr	r3, [r7, #4]
     d58:	ebc5 0303 	rsb	r3, r5, r3
     d5c:	607b      	str	r3, [r7, #4]
		if (pad & PAD_ZERO) padchar = '0';
     d5e:	683b      	ldr	r3, [r7, #0]
     d60:	f003 0302 	and.w	r3, r3, #2
     d64:	2b00      	cmp	r3, #0
     d66:	d001      	beq.n	d6c <prints+0x5c>
     d68:	f04f 0630 	mov.w	r6, #48	; 0x30
	}
	if (!(pad & PAD_RIGHT)) {
     d6c:	683b      	ldr	r3, [r7, #0]
     d6e:	f003 0301 	and.w	r3, r3, #1
     d72:	2b00      	cmp	r3, #0
     d74:	d11b      	bne.n	dae <prints+0x9e>
		for ( ; width > 0; --width) {
     d76:	e009      	b.n	d8c <prints+0x7c>
			printchar (out, padchar);
     d78:	68f8      	ldr	r0, [r7, #12]
     d7a:	4631      	mov	r1, r6
     d7c:	f7ff ffb0 	bl	ce0 <printchar>
			++pc;
     d80:	f104 0401 	add.w	r4, r4, #1
		if (len >= width) width = 0;
		else width -= len;
		if (pad & PAD_ZERO) padchar = '0';
	}
	if (!(pad & PAD_RIGHT)) {
		for ( ; width > 0; --width) {
     d84:	687b      	ldr	r3, [r7, #4]
     d86:	f103 33ff 	add.w	r3, r3, #4294967295
     d8a:	607b      	str	r3, [r7, #4]
     d8c:	687b      	ldr	r3, [r7, #4]
     d8e:	2b00      	cmp	r3, #0
     d90:	dcf2      	bgt.n	d78 <prints+0x68>
			printchar (out, padchar);
			++pc;
		}
	}
	for ( ; *string ; ++string) {
     d92:	e00d      	b.n	db0 <prints+0xa0>
		printchar (out, *string);
     d94:	68bb      	ldr	r3, [r7, #8]
     d96:	781b      	ldrb	r3, [r3, #0]
     d98:	68f8      	ldr	r0, [r7, #12]
     d9a:	4619      	mov	r1, r3
     d9c:	f7ff ffa0 	bl	ce0 <printchar>
		++pc;
     da0:	f104 0401 	add.w	r4, r4, #1
		for ( ; width > 0; --width) {
			printchar (out, padchar);
			++pc;
		}
	}
	for ( ; *string ; ++string) {
     da4:	68bb      	ldr	r3, [r7, #8]
     da6:	f103 0301 	add.w	r3, r3, #1
     daa:	60bb      	str	r3, [r7, #8]
     dac:	e000      	b.n	db0 <prints+0xa0>
     dae:	bf00      	nop
     db0:	68bb      	ldr	r3, [r7, #8]
     db2:	781b      	ldrb	r3, [r3, #0]
     db4:	2b00      	cmp	r3, #0
     db6:	d1ed      	bne.n	d94 <prints+0x84>
		printchar (out, *string);
		++pc;
	}
	for ( ; width > 0; --width) {
     db8:	e009      	b.n	dce <prints+0xbe>
		printchar (out, padchar);
     dba:	68f8      	ldr	r0, [r7, #12]
     dbc:	4631      	mov	r1, r6
     dbe:	f7ff ff8f 	bl	ce0 <printchar>
		++pc;
     dc2:	f104 0401 	add.w	r4, r4, #1
	}
	for ( ; *string ; ++string) {
		printchar (out, *string);
		++pc;
	}
	for ( ; width > 0; --width) {
     dc6:	687b      	ldr	r3, [r7, #4]
     dc8:	f103 33ff 	add.w	r3, r3, #4294967295
     dcc:	607b      	str	r3, [r7, #4]
     dce:	687b      	ldr	r3, [r7, #4]
     dd0:	2b00      	cmp	r3, #0
     dd2:	dcf2      	bgt.n	dba <prints+0xaa>
		printchar (out, padchar);
		++pc;
	}

	return pc;
     dd4:	4623      	mov	r3, r4
}
     dd6:	4618      	mov	r0, r3
     dd8:	f107 0710 	add.w	r7, r7, #16
     ddc:	46bd      	mov	sp, r7
     dde:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     de2:	bf00      	nop

00000de4 <printi>:

/* the following should be enough for 32 bit int */
#define PRINT_BUF_LEN 12

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
     de4:	e92d 45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
     de8:	b089      	sub	sp, #36	; 0x24
     dea:	af00      	add	r7, sp, #0
     dec:	60f8      	str	r0, [r7, #12]
     dee:	60b9      	str	r1, [r7, #8]
     df0:	607a      	str	r2, [r7, #4]
     df2:	603b      	str	r3, [r7, #0]
	char print_buf[PRINT_BUF_LEN];
	register char *s;
	register int t, neg = 0, pc = 0;
     df4:	f04f 0a00 	mov.w	sl, #0
     df8:	f04f 0800 	mov.w	r8, #0
	register unsigned int u = (unsigned int)i;
     dfc:	68bd      	ldr	r5, [r7, #8]

	if (i == 0) {
     dfe:	68bb      	ldr	r3, [r7, #8]
     e00:	2b00      	cmp	r3, #0
     e02:	d10f      	bne.n	e24 <printi+0x40>
		print_buf[0] = '0';
     e04:	f04f 0330 	mov.w	r3, #48	; 0x30
     e08:	753b      	strb	r3, [r7, #20]
		print_buf[1] = '\0';
     e0a:	f04f 0300 	mov.w	r3, #0
     e0e:	757b      	strb	r3, [r7, #21]
		return prints (out, print_buf, width, pad);
     e10:	f107 0314 	add.w	r3, r7, #20
     e14:	68f8      	ldr	r0, [r7, #12]
     e16:	4619      	mov	r1, r3
     e18:	6c3a      	ldr	r2, [r7, #64]	; 0x40
     e1a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     e1c:	f7ff ff78 	bl	d10 <prints>
     e20:	4603      	mov	r3, r0
     e22:	e054      	b.n	ece <printi+0xea>
	}

	if (sg && b == 10 && i < 0) {
     e24:	683b      	ldr	r3, [r7, #0]
     e26:	2b00      	cmp	r3, #0
     e28:	d00b      	beq.n	e42 <printi+0x5e>
     e2a:	687b      	ldr	r3, [r7, #4]
     e2c:	2b0a      	cmp	r3, #10
     e2e:	d108      	bne.n	e42 <printi+0x5e>
     e30:	68bb      	ldr	r3, [r7, #8]
     e32:	2b00      	cmp	r3, #0
     e34:	da05      	bge.n	e42 <printi+0x5e>
		neg = 1;
     e36:	f04f 0a01 	mov.w	sl, #1
		u = (unsigned int)-i;
     e3a:	68bb      	ldr	r3, [r7, #8]
     e3c:	f1c3 0300 	rsb	r3, r3, #0
     e40:	461d      	mov	r5, r3
	}

	s = print_buf + PRINT_BUF_LEN-1;
     e42:	f107 0314 	add.w	r3, r7, #20
     e46:	f103 040b 	add.w	r4, r3, #11
	*s = '\0';
     e4a:	f04f 0300 	mov.w	r3, #0
     e4e:	7023      	strb	r3, [r4, #0]

	while (u) {
     e50:	e017      	b.n	e82 <printi+0x9e>
		t = (unsigned int)u % b;
     e52:	687b      	ldr	r3, [r7, #4]
     e54:	fbb5 f2f3 	udiv	r2, r5, r3
     e58:	fb03 f302 	mul.w	r3, r3, r2
     e5c:	ebc3 0305 	rsb	r3, r3, r5
     e60:	461e      	mov	r6, r3
		if( t >= 10 )
     e62:	2e09      	cmp	r6, #9
     e64:	dd03      	ble.n	e6e <printi+0x8a>
			t += letbase - '0' - 10;
     e66:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     e68:	f1a3 033a 	sub.w	r3, r3, #58	; 0x3a
     e6c:	441e      	add	r6, r3
		*--s = (char)(t + '0');
     e6e:	f104 34ff 	add.w	r4, r4, #4294967295
     e72:	b2f3      	uxtb	r3, r6
     e74:	f103 0330 	add.w	r3, r3, #48	; 0x30
     e78:	b2db      	uxtb	r3, r3
     e7a:	7023      	strb	r3, [r4, #0]
		u /= b;
     e7c:	687b      	ldr	r3, [r7, #4]
     e7e:	fbb5 f5f3 	udiv	r5, r5, r3
	}

	s = print_buf + PRINT_BUF_LEN-1;
	*s = '\0';

	while (u) {
     e82:	2d00      	cmp	r5, #0
     e84:	d1e5      	bne.n	e52 <printi+0x6e>
			t += letbase - '0' - 10;
		*--s = (char)(t + '0');
		u /= b;
	}

	if (neg) {
     e86:	f1ba 0f00 	cmp.w	sl, #0
     e8a:	d018      	beq.n	ebe <printi+0xda>
		if( width && (pad & PAD_ZERO) ) {
     e8c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
     e8e:	2b00      	cmp	r3, #0
     e90:	d010      	beq.n	eb4 <printi+0xd0>
     e92:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     e94:	f003 0302 	and.w	r3, r3, #2
     e98:	2b00      	cmp	r3, #0
     e9a:	d00b      	beq.n	eb4 <printi+0xd0>
			printchar (out, '-');
     e9c:	68f8      	ldr	r0, [r7, #12]
     e9e:	f04f 012d 	mov.w	r1, #45	; 0x2d
     ea2:	f7ff ff1d 	bl	ce0 <printchar>
			++pc;
     ea6:	f108 0801 	add.w	r8, r8, #1
			--width;
     eaa:	6c3b      	ldr	r3, [r7, #64]	; 0x40
     eac:	f103 33ff 	add.w	r3, r3, #4294967295
     eb0:	643b      	str	r3, [r7, #64]	; 0x40
		*--s = (char)(t + '0');
		u /= b;
	}

	if (neg) {
		if( width && (pad & PAD_ZERO) ) {
     eb2:	e004      	b.n	ebe <printi+0xda>
			printchar (out, '-');
			++pc;
			--width;
		}
		else {
			*--s = '-';
     eb4:	f104 34ff 	add.w	r4, r4, #4294967295
     eb8:	f04f 032d 	mov.w	r3, #45	; 0x2d
     ebc:	7023      	strb	r3, [r4, #0]
		}
	}

	return pc + prints (out, s, width, pad);
     ebe:	68f8      	ldr	r0, [r7, #12]
     ec0:	4621      	mov	r1, r4
     ec2:	6c3a      	ldr	r2, [r7, #64]	; 0x40
     ec4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     ec6:	f7ff ff23 	bl	d10 <prints>
     eca:	4603      	mov	r3, r0
     ecc:	4443      	add	r3, r8
}
     ece:	4618      	mov	r0, r3
     ed0:	f107 0724 	add.w	r7, r7, #36	; 0x24
     ed4:	46bd      	mov	sp, r7
     ed6:	e8bd 85f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, pc}
     eda:	bf00      	nop

00000edc <print>:

static int print( char **out, const char *format, va_list args )
{
     edc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     ee0:	b08a      	sub	sp, #40	; 0x28
     ee2:	af04      	add	r7, sp, #16
     ee4:	60f8      	str	r0, [r7, #12]
     ee6:	60b9      	str	r1, [r7, #8]
     ee8:	607a      	str	r2, [r7, #4]
	register int width, pad;
	register int pc = 0;
     eea:	f04f 0400 	mov.w	r4, #0
	char scr[2];

	for (; *format != 0; ++format) {
     eee:	e0ed      	b.n	10cc <PROCESS_STACK_SIZE+0xcc>
		if (*format == '%') {
     ef0:	68bb      	ldr	r3, [r7, #8]
     ef2:	781b      	ldrb	r3, [r3, #0]
     ef4:	2b25      	cmp	r3, #37	; 0x25
     ef6:	f040 80db 	bne.w	10b0 <PROCESS_STACK_SIZE+0xb0>
			++format;
     efa:	68bb      	ldr	r3, [r7, #8]
     efc:	f103 0301 	add.w	r3, r3, #1
     f00:	60bb      	str	r3, [r7, #8]
			width = pad = 0;
     f02:	f04f 0600 	mov.w	r6, #0
     f06:	4635      	mov	r5, r6
			if (*format == '\0') break;
     f08:	68bb      	ldr	r3, [r7, #8]
     f0a:	781b      	ldrb	r3, [r3, #0]
     f0c:	2b00      	cmp	r3, #0
     f0e:	f000 80e3 	beq.w	10d8 <PROCESS_STACK_SIZE+0xd8>
			if (*format == '%') goto out;
     f12:	68bb      	ldr	r3, [r7, #8]
     f14:	781b      	ldrb	r3, [r3, #0]
     f16:	2b25      	cmp	r3, #37	; 0x25
     f18:	f000 80c9 	beq.w	10ae <PROCESS_STACK_SIZE+0xae>
			if (*format == '-') {
     f1c:	68bb      	ldr	r3, [r7, #8]
     f1e:	781b      	ldrb	r3, [r3, #0]
     f20:	2b2d      	cmp	r3, #45	; 0x2d
     f22:	d10d      	bne.n	f40 <print+0x64>
				++format;
     f24:	68bb      	ldr	r3, [r7, #8]
     f26:	f103 0301 	add.w	r3, r3, #1
     f2a:	60bb      	str	r3, [r7, #8]
				pad = PAD_RIGHT;
     f2c:	f04f 0601 	mov.w	r6, #1
			}
			while (*format == '0') {
     f30:	e007      	b.n	f42 <print+0x66>
				++format;
     f32:	68bb      	ldr	r3, [r7, #8]
     f34:	f103 0301 	add.w	r3, r3, #1
     f38:	60bb      	str	r3, [r7, #8]
				pad |= PAD_ZERO;
     f3a:	f046 0602 	orr.w	r6, r6, #2
     f3e:	e000      	b.n	f42 <print+0x66>
			if (*format == '%') goto out;
			if (*format == '-') {
				++format;
				pad = PAD_RIGHT;
			}
			while (*format == '0') {
     f40:	bf00      	nop
     f42:	68bb      	ldr	r3, [r7, #8]
     f44:	781b      	ldrb	r3, [r3, #0]
     f46:	2b30      	cmp	r3, #48	; 0x30
     f48:	d0f3      	beq.n	f32 <print+0x56>
				++format;
				pad |= PAD_ZERO;
			}
			for ( ; *format >= '0' && *format <= '9'; ++format) {
     f4a:	e00f      	b.n	f6c <print+0x90>
				width *= 10;
     f4c:	462b      	mov	r3, r5
     f4e:	ea4f 0383 	mov.w	r3, r3, lsl #2
     f52:	442b      	add	r3, r5
     f54:	ea4f 0343 	mov.w	r3, r3, lsl #1
     f58:	461d      	mov	r5, r3
				width += *format - '0';
     f5a:	68bb      	ldr	r3, [r7, #8]
     f5c:	781b      	ldrb	r3, [r3, #0]
     f5e:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
     f62:	441d      	add	r5, r3
			}
			while (*format == '0') {
				++format;
				pad |= PAD_ZERO;
			}
			for ( ; *format >= '0' && *format <= '9'; ++format) {
     f64:	68bb      	ldr	r3, [r7, #8]
     f66:	f103 0301 	add.w	r3, r3, #1
     f6a:	60bb      	str	r3, [r7, #8]
     f6c:	68bb      	ldr	r3, [r7, #8]
     f6e:	781b      	ldrb	r3, [r3, #0]
     f70:	2b2f      	cmp	r3, #47	; 0x2f
     f72:	d903      	bls.n	f7c <print+0xa0>
     f74:	68bb      	ldr	r3, [r7, #8]
     f76:	781b      	ldrb	r3, [r3, #0]
     f78:	2b39      	cmp	r3, #57	; 0x39
     f7a:	d9e7      	bls.n	f4c <print+0x70>
				width *= 10;
				width += *format - '0';
			}
			if( *format == 's' ) {
     f7c:	68bb      	ldr	r3, [r7, #8]
     f7e:	781b      	ldrb	r3, [r3, #0]
     f80:	2b73      	cmp	r3, #115	; 0x73
     f82:	d117      	bne.n	fb4 <print+0xd8>
				register char *s = (char *)va_arg( args, int );
     f84:	687b      	ldr	r3, [r7, #4]
     f86:	f103 0204 	add.w	r2, r3, #4
     f8a:	607a      	str	r2, [r7, #4]
     f8c:	681b      	ldr	r3, [r3, #0]
     f8e:	4698      	mov	r8, r3
				pc += prints (out, s?s:"(null)", width, pad);
     f90:	f1b8 0f00 	cmp.w	r8, #0
     f94:	d001      	beq.n	f9a <print+0xbe>
     f96:	4643      	mov	r3, r8
     f98:	e003      	b.n	fa2 <print+0xc6>
     f9a:	f243 03f0 	movw	r3, #12528	; 0x30f0
     f9e:	f2c0 0301 	movt	r3, #1
     fa2:	68f8      	ldr	r0, [r7, #12]
     fa4:	4619      	mov	r1, r3
     fa6:	462a      	mov	r2, r5
     fa8:	4633      	mov	r3, r6
     faa:	f7ff feb1 	bl	d10 <prints>
     fae:	4603      	mov	r3, r0
     fb0:	441c      	add	r4, r3
				continue;
     fb2:	e087      	b.n	10c4 <PROCESS_STACK_SIZE+0xc4>
			}
			if( *format == 'd' ) {
     fb4:	68bb      	ldr	r3, [r7, #8]
     fb6:	781b      	ldrb	r3, [r3, #0]
     fb8:	2b64      	cmp	r3, #100	; 0x64
     fba:	d114      	bne.n	fe6 <print+0x10a>
				pc += printi (out, va_arg( args, int ), 10, 1, width, pad, 'a');
     fbc:	687b      	ldr	r3, [r7, #4]
     fbe:	f103 0204 	add.w	r2, r3, #4
     fc2:	607a      	str	r2, [r7, #4]
     fc4:	681b      	ldr	r3, [r3, #0]
     fc6:	9500      	str	r5, [sp, #0]
     fc8:	9601      	str	r6, [sp, #4]
     fca:	f04f 0261 	mov.w	r2, #97	; 0x61
     fce:	9202      	str	r2, [sp, #8]
     fd0:	68f8      	ldr	r0, [r7, #12]
     fd2:	4619      	mov	r1, r3
     fd4:	f04f 020a 	mov.w	r2, #10
     fd8:	f04f 0301 	mov.w	r3, #1
     fdc:	f7ff ff02 	bl	de4 <printi>
     fe0:	4603      	mov	r3, r0
     fe2:	441c      	add	r4, r3
				continue;
     fe4:	e06e      	b.n	10c4 <PROCESS_STACK_SIZE+0xc4>
			}
			if( *format == 'x' ) {
     fe6:	68bb      	ldr	r3, [r7, #8]
     fe8:	781b      	ldrb	r3, [r3, #0]
     fea:	2b78      	cmp	r3, #120	; 0x78
     fec:	d114      	bne.n	1018 <PROCESS_STACK_SIZE+0x18>
				pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'a');
     fee:	687b      	ldr	r3, [r7, #4]
     ff0:	f103 0204 	add.w	r2, r3, #4
     ff4:	607a      	str	r2, [r7, #4]
     ff6:	681b      	ldr	r3, [r3, #0]
     ff8:	9500      	str	r5, [sp, #0]
     ffa:	9601      	str	r6, [sp, #4]
     ffc:	f04f 0261 	mov.w	r2, #97	; 0x61
    1000:	9202      	str	r2, [sp, #8]
    1002:	68f8      	ldr	r0, [r7, #12]
    1004:	4619      	mov	r1, r3
    1006:	f04f 0210 	mov.w	r2, #16
    100a:	f04f 0300 	mov.w	r3, #0
    100e:	f7ff fee9 	bl	de4 <printi>
    1012:	4603      	mov	r3, r0
    1014:	441c      	add	r4, r3
				continue;
    1016:	e055      	b.n	10c4 <PROCESS_STACK_SIZE+0xc4>
			}
			if( *format == 'X' ) {
    1018:	68bb      	ldr	r3, [r7, #8]
    101a:	781b      	ldrb	r3, [r3, #0]
    101c:	2b58      	cmp	r3, #88	; 0x58
    101e:	d114      	bne.n	104a <PROCESS_STACK_SIZE+0x4a>
				pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'A');
    1020:	687b      	ldr	r3, [r7, #4]
    1022:	f103 0204 	add.w	r2, r3, #4
    1026:	607a      	str	r2, [r7, #4]
    1028:	681b      	ldr	r3, [r3, #0]
    102a:	9500      	str	r5, [sp, #0]
    102c:	9601      	str	r6, [sp, #4]
    102e:	f04f 0241 	mov.w	r2, #65	; 0x41
    1032:	9202      	str	r2, [sp, #8]
    1034:	68f8      	ldr	r0, [r7, #12]
    1036:	4619      	mov	r1, r3
    1038:	f04f 0210 	mov.w	r2, #16
    103c:	f04f 0300 	mov.w	r3, #0
    1040:	f7ff fed0 	bl	de4 <printi>
    1044:	4603      	mov	r3, r0
    1046:	441c      	add	r4, r3
				continue;
    1048:	e03c      	b.n	10c4 <PROCESS_STACK_SIZE+0xc4>
			}
			if( *format == 'u' ) {
    104a:	68bb      	ldr	r3, [r7, #8]
    104c:	781b      	ldrb	r3, [r3, #0]
    104e:	2b75      	cmp	r3, #117	; 0x75
    1050:	d114      	bne.n	107c <PROCESS_STACK_SIZE+0x7c>
				pc += printi (out, va_arg( args, int ), 10, 0, width, pad, 'a');
    1052:	687b      	ldr	r3, [r7, #4]
    1054:	f103 0204 	add.w	r2, r3, #4
    1058:	607a      	str	r2, [r7, #4]
    105a:	681b      	ldr	r3, [r3, #0]
    105c:	9500      	str	r5, [sp, #0]
    105e:	9601      	str	r6, [sp, #4]
    1060:	f04f 0261 	mov.w	r2, #97	; 0x61
    1064:	9202      	str	r2, [sp, #8]
    1066:	68f8      	ldr	r0, [r7, #12]
    1068:	4619      	mov	r1, r3
    106a:	f04f 020a 	mov.w	r2, #10
    106e:	f04f 0300 	mov.w	r3, #0
    1072:	f7ff feb7 	bl	de4 <printi>
    1076:	4603      	mov	r3, r0
    1078:	441c      	add	r4, r3
				continue;
    107a:	e023      	b.n	10c4 <PROCESS_STACK_SIZE+0xc4>
			}
			if( *format == 'c' ) {
    107c:	68bb      	ldr	r3, [r7, #8]
    107e:	781b      	ldrb	r3, [r3, #0]
    1080:	2b63      	cmp	r3, #99	; 0x63
    1082:	d11e      	bne.n	10c2 <PROCESS_STACK_SIZE+0xc2>
				/* char are converted to int then pushed on the stack */
				scr[0] = (char)va_arg( args, int );
    1084:	687b      	ldr	r3, [r7, #4]
    1086:	f103 0204 	add.w	r2, r3, #4
    108a:	607a      	str	r2, [r7, #4]
    108c:	681b      	ldr	r3, [r3, #0]
    108e:	b2db      	uxtb	r3, r3
    1090:	753b      	strb	r3, [r7, #20]
				scr[1] = '\0';
    1092:	f04f 0300 	mov.w	r3, #0
    1096:	757b      	strb	r3, [r7, #21]
				pc += prints (out, scr, width, pad);
    1098:	f107 0314 	add.w	r3, r7, #20
    109c:	68f8      	ldr	r0, [r7, #12]
    109e:	4619      	mov	r1, r3
    10a0:	462a      	mov	r2, r5
    10a2:	4633      	mov	r3, r6
    10a4:	f7ff fe34 	bl	d10 <prints>
    10a8:	4603      	mov	r3, r0
    10aa:	441c      	add	r4, r3
				continue;
    10ac:	e00a      	b.n	10c4 <PROCESS_STACK_SIZE+0xc4>
	for (; *format != 0; ++format) {
		if (*format == '%') {
			++format;
			width = pad = 0;
			if (*format == '\0') break;
			if (*format == '%') goto out;
    10ae:	bf00      	nop
				continue;
			}
		}
		else {
		out:
			printchar (out, *format);
    10b0:	68bb      	ldr	r3, [r7, #8]
    10b2:	781b      	ldrb	r3, [r3, #0]
    10b4:	68f8      	ldr	r0, [r7, #12]
    10b6:	4619      	mov	r1, r3
    10b8:	f7ff fe12 	bl	ce0 <printchar>
			++pc;
    10bc:	f104 0401 	add.w	r4, r4, #1
    10c0:	e000      	b.n	10c4 <PROCESS_STACK_SIZE+0xc4>
			if( *format == 'c' ) {
				/* char are converted to int then pushed on the stack */
				scr[0] = (char)va_arg( args, int );
				scr[1] = '\0';
				pc += prints (out, scr, width, pad);
				continue;
    10c2:	bf00      	nop
{
	register int width, pad;
	register int pc = 0;
	char scr[2];

	for (; *format != 0; ++format) {
    10c4:	68bb      	ldr	r3, [r7, #8]
    10c6:	f103 0301 	add.w	r3, r3, #1
    10ca:	60bb      	str	r3, [r7, #8]
    10cc:	68bb      	ldr	r3, [r7, #8]
    10ce:	781b      	ldrb	r3, [r3, #0]
    10d0:	2b00      	cmp	r3, #0
    10d2:	f47f af0d 	bne.w	ef0 <print+0x14>
    10d6:	e000      	b.n	10da <PROCESS_STACK_SIZE+0xda>
		if (*format == '%') {
			++format;
			width = pad = 0;
			if (*format == '\0') break;
    10d8:	bf00      	nop
		out:
			printchar (out, *format);
			++pc;
		}
	}
	if (out) **out = '\0';
    10da:	68fb      	ldr	r3, [r7, #12]
    10dc:	2b00      	cmp	r3, #0
    10de:	d004      	beq.n	10ea <PROCESS_STACK_SIZE+0xea>
    10e0:	68fb      	ldr	r3, [r7, #12]
    10e2:	681b      	ldr	r3, [r3, #0]
    10e4:	f04f 0200 	mov.w	r2, #0
    10e8:	701a      	strb	r2, [r3, #0]
	va_end( args );
	return pc;
    10ea:	4623      	mov	r3, r4
}
    10ec:	4618      	mov	r0, r3
    10ee:	f107 0718 	add.w	r7, r7, #24
    10f2:	46bd      	mov	sp, r7
    10f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000010f8 <printf>:

int printf(const char *format, ...)
{
        va_list args;
        
        va_start( args, format );
    10f8:	b40f      	push	{r0, r1, r2, r3}
    10fa:	b580      	push	{r7, lr}
    10fc:	b082      	sub	sp, #8
    10fe:	af00      	add	r7, sp, #0
    1100:	f107 0314 	add.w	r3, r7, #20
    1104:	607b      	str	r3, [r7, #4]
        return print( 0, format, args );
    1106:	f04f 0000 	mov.w	r0, #0
    110a:	6939      	ldr	r1, [r7, #16]
    110c:	687a      	ldr	r2, [r7, #4]
    110e:	f7ff fee5 	bl	edc <print>
    1112:	4603      	mov	r3, r0
}
    1114:	4618      	mov	r0, r3
    1116:	f107 0708 	add.w	r7, r7, #8
    111a:	46bd      	mov	sp, r7
    111c:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    1120:	b004      	add	sp, #16
    1122:	4770      	bx	lr

00001124 <sprintf>:

int sprintf(char *out, const char *format, ...)
{
        va_list args;
        
        va_start( args, format );
    1124:	b40e      	push	{r1, r2, r3}
    1126:	b580      	push	{r7, lr}
    1128:	b085      	sub	sp, #20
    112a:	af00      	add	r7, sp, #0
    112c:	6078      	str	r0, [r7, #4]
    112e:	f107 0320 	add.w	r3, r7, #32
    1132:	60fb      	str	r3, [r7, #12]
        return print( &out, format, args );
    1134:	f107 0304 	add.w	r3, r7, #4
    1138:	4618      	mov	r0, r3
    113a:	69f9      	ldr	r1, [r7, #28]
    113c:	68fa      	ldr	r2, [r7, #12]
    113e:	f7ff fecd 	bl	edc <print>
    1142:	4603      	mov	r3, r0
}
    1144:	4618      	mov	r0, r3
    1146:	f107 0714 	add.w	r7, r7, #20
    114a:	46bd      	mov	sp, r7
    114c:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    1150:	b003      	add	sp, #12
    1152:	4770      	bx	lr

00001154 <snprintf>:
{
        va_list args;
        
        ( void ) count;
        
        va_start( args, format );
    1154:	b40c      	push	{r2, r3}
    1156:	b580      	push	{r7, lr}
    1158:	b084      	sub	sp, #16
    115a:	af00      	add	r7, sp, #0
    115c:	6078      	str	r0, [r7, #4]
    115e:	6039      	str	r1, [r7, #0]
    1160:	f107 031c 	add.w	r3, r7, #28
    1164:	60fb      	str	r3, [r7, #12]
        return print( &buf, format, args );
    1166:	f107 0304 	add.w	r3, r7, #4
    116a:	4618      	mov	r0, r3
    116c:	69b9      	ldr	r1, [r7, #24]
    116e:	68fa      	ldr	r2, [r7, #12]
    1170:	f7ff feb4 	bl	edc <print>
    1174:	4603      	mov	r3, r0
}
    1176:	4618      	mov	r0, r3
    1178:	f107 0710 	add.w	r7, r7, #16
    117c:	46bd      	mov	sp, r7
    117e:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    1182:	b002      	add	sp, #8
    1184:	4770      	bx	lr
    1186:	bf00      	nop

00001188 <write>:
#endif


/* To keep linker happy. */
int	write( int i, char* c, int n)
{
    1188:	b480      	push	{r7}
    118a:	b085      	sub	sp, #20
    118c:	af00      	add	r7, sp, #0
    118e:	60f8      	str	r0, [r7, #12]
    1190:	60b9      	str	r1, [r7, #8]
    1192:	607a      	str	r2, [r7, #4]
	(void)i;
	(void)n;
	(void)c;
	return 0;
    1194:	f04f 0300 	mov.w	r3, #0
}
    1198:	4618      	mov	r0, r3
    119a:	f107 0714 	add.w	r7, r7, #20
    119e:	46bd      	mov	sp, r7
    11a0:	bc80      	pop	{r7}
    11a2:	4770      	bx	lr

000011a4 <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
    11a4:	b480      	push	{r7}
    11a6:	b083      	sub	sp, #12
    11a8:	af00      	add	r7, sp, #0
    11aa:	4603      	mov	r3, r0
    11ac:	80fb      	strh	r3, [r7, #6]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    11ae:	f24e 1300 	movw	r3, #57600	; 0xe100
    11b2:	f2ce 0300 	movt	r3, #57344	; 0xe000
    11b6:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    11ba:	ea4f 1252 	mov.w	r2, r2, lsr #5
    11be:	88f9      	ldrh	r1, [r7, #6]
    11c0:	f001 011f 	and.w	r1, r1, #31
    11c4:	f04f 0001 	mov.w	r0, #1
    11c8:	fa00 f101 	lsl.w	r1, r0, r1
    11cc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    11d0:	f107 070c 	add.w	r7, r7, #12
    11d4:	46bd      	mov	sp, r7
    11d6:	bc80      	pop	{r7}
    11d8:	4770      	bx	lr
    11da:	bf00      	nop

000011dc <NVIC_SetPriority>:
 * interrupt, or negative to specify an internal (core) interrupt.
 *
 * Note: The priority cannot be set for every core interrupt.
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
    11dc:	b480      	push	{r7}
    11de:	b083      	sub	sp, #12
    11e0:	af00      	add	r7, sp, #0
    11e2:	4603      	mov	r3, r0
    11e4:	6039      	str	r1, [r7, #0]
    11e6:	80fb      	strh	r3, [r7, #6]
  if(IRQn < 0) {
    11e8:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    11ec:	2b00      	cmp	r3, #0
    11ee:	da10      	bge.n	1212 <NVIC_SetPriority+0x36>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M3 System Interrupts */
    11f0:	f64e 5300 	movw	r3, #60672	; 0xed00
    11f4:	f2ce 0300 	movt	r3, #57344	; 0xe000
    11f8:	88fa      	ldrh	r2, [r7, #6]
    11fa:	f002 020f 	and.w	r2, r2, #15
    11fe:	f1a2 0104 	sub.w	r1, r2, #4
    1202:	683a      	ldr	r2, [r7, #0]
    1204:	b2d2      	uxtb	r2, r2
    1206:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    120a:	b2d2      	uxtb	r2, r2
    120c:	440b      	add	r3, r1
    120e:	761a      	strb	r2, [r3, #24]
    1210:	e00d      	b.n	122e <NVIC_SetPriority+0x52>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
    1212:	f24e 1300 	movw	r3, #57600	; 0xe100
    1216:	f2ce 0300 	movt	r3, #57344	; 0xe000
    121a:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
    121e:	683a      	ldr	r2, [r7, #0]
    1220:	b2d2      	uxtb	r2, r2
    1222:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    1226:	b2d2      	uxtb	r2, r2
    1228:	440b      	add	r3, r1
    122a:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
    122e:	f107 070c 	add.w	r7, r7, #12
    1232:	46bd      	mov	sp, r7
    1234:	bc80      	pop	{r7}
    1236:	4770      	bx	lr

00001238 <clock_time>:
QueueHandle_t xEMACEventQueue = NULL;

/*-----------------------------------------------------------*/

clock_time_t clock_time( void )
{
    1238:	b580      	push	{r7, lr}
    123a:	af00      	add	r7, sp, #0
	return xTaskGetTickCount();
    123c:	f00d fc82 	bl	eb44 <xTaskGetTickCount>
    1240:	4603      	mov	r3, r0
}
    1242:	4618      	mov	r0, r3
    1244:	bd80      	pop	{r7, pc}
    1246:	bf00      	nop

00001248 <vuIP_Task>:
/*-----------------------------------------------------------*/

void vuIP_Task( void *pvParameters )
{
    1248:	b590      	push	{r4, r7, lr}
    124a:	b087      	sub	sp, #28
    124c:	af00      	add	r7, sp, #0
    124e:	6078      	str	r0, [r7, #4]
portBASE_TYPE i;
unsigned long ulNewEvent = 0UL, ulUIP_Events = 0UL;
    1250:	f04f 0300 	mov.w	r3, #0
    1254:	60bb      	str	r3, [r7, #8]
    1256:	f04f 0300 	mov.w	r3, #0
    125a:	613b      	str	r3, [r7, #16]

	/* Just to prevent compiler warnings about the unused parameter. */
	( void ) pvParameters;

	/* Initialise the uIP stack, configuring for web server usage. */
	prvInitialise_uIP();
    125c:	f000 f8fe 	bl	145c <prvInitialise_uIP>

	/* Initialise the MAC and PHY. */
	prvInitEmac();
    1260:	f000 fa06 	bl	1670 <prvInitEmac>
    1264:	e000      	b.n	1268 <vuIP_Task+0x20>
		if( ulUIP_Events == pdFALSE )
		{
			xQueueReceive( xEMACEventQueue, &ulNewEvent, portMAX_DELAY );
			ulUIP_Events |= ulNewEvent;
		}
	}
    1266:	bf00      	nop
	prvInitEmac();

	for( ;; )
	{
		/* Is there received data ready to be processed? */
		lPacketLength = MSS_MAC_rx_packet();
    1268:	f001 fe8a 	bl	2f80 <MSS_MAC_rx_packet>
    126c:	4603      	mov	r3, r0
    126e:	617b      	str	r3, [r7, #20]

		/* Statements to be executed if data has been received on the Ethernet. */
		if( ( lPacketLength > 0 ) && ( uip_buf != NULL ) )
    1270:	697b      	ldr	r3, [r7, #20]
    1272:	2b00      	cmp	r3, #0
    1274:	dd4f      	ble.n	1316 <vuIP_Task+0xce>
    1276:	f240 6390 	movw	r3, #1680	; 0x690
    127a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    127e:	681b      	ldr	r3, [r3, #0]
    1280:	2b00      	cmp	r3, #0
    1282:	d048      	beq.n	1316 <vuIP_Task+0xce>
		{
			uip_len = ( u16_t ) lPacketLength;
    1284:	697b      	ldr	r3, [r7, #20]
    1286:	b29a      	uxth	r2, r3
    1288:	f64a 3358 	movw	r3, #43864	; 0xab58
    128c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1290:	801a      	strh	r2, [r3, #0]

			/* Standard uIP loop taken from the uIP manual. */
			if( xHeader->type == htons( UIP_ETHTYPE_IP ) )
    1292:	f240 6390 	movw	r3, #1680	; 0x690
    1296:	f2c2 0300 	movt	r3, #8192	; 0x2000
    129a:	681b      	ldr	r3, [r3, #0]
    129c:	7b1a      	ldrb	r2, [r3, #12]
    129e:	7b5b      	ldrb	r3, [r3, #13]
    12a0:	ea4f 2303 	mov.w	r3, r3, lsl #8
    12a4:	ea43 0302 	orr.w	r3, r3, r2
    12a8:	b29c      	uxth	r4, r3
    12aa:	f44f 6000 	mov.w	r0, #2048	; 0x800
    12ae:	f009 fcb7 	bl	ac20 <htons>
    12b2:	4603      	mov	r3, r0
    12b4:	429c      	cmp	r4, r3
    12b6:	d10f      	bne.n	12d8 <vuIP_Task+0x90>
			{
				uip_arp_ipin();
				uip_input();
    12b8:	f04f 0001 	mov.w	r0, #1
    12bc:	f007 fbd8 	bl	8a70 <uip_process>

				/* If the above function invocation resulted in data that
				should be sent out on the network, the global variable
				uip_len is set to a value > 0. */
				if( uip_len > 0 )
    12c0:	f64a 3358 	movw	r3, #43864	; 0xab58
    12c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    12c8:	881b      	ldrh	r3, [r3, #0]
    12ca:	2b00      	cmp	r3, #0
    12cc:	d028      	beq.n	1320 <vuIP_Task+0xd8>
				{
					uip_arp_out();
    12ce:	f00a f89d 	bl	b40c <uip_arp_out>
					vEMACWrite();
    12d2:	f000 f9eb 	bl	16ac <vEMACWrite>
	{
		/* Is there received data ready to be processed? */
		lPacketLength = MSS_MAC_rx_packet();

		/* Statements to be executed if data has been received on the Ethernet. */
		if( ( lPacketLength > 0 ) && ( uip_buf != NULL ) )
    12d6:	e028      	b.n	132a <vuIP_Task+0xe2>
				{
					uip_arp_out();
					vEMACWrite();
				}
			}
			else if( xHeader->type == htons( UIP_ETHTYPE_ARP ) )
    12d8:	f240 6390 	movw	r3, #1680	; 0x690
    12dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    12e0:	681b      	ldr	r3, [r3, #0]
    12e2:	7b1a      	ldrb	r2, [r3, #12]
    12e4:	7b5b      	ldrb	r3, [r3, #13]
    12e6:	ea4f 2303 	mov.w	r3, r3, lsl #8
    12ea:	ea43 0302 	orr.w	r3, r3, r2
    12ee:	b29c      	uxth	r4, r3
    12f0:	f640 0006 	movw	r0, #2054	; 0x806
    12f4:	f009 fc94 	bl	ac20 <htons>
    12f8:	4603      	mov	r3, r0
    12fa:	429c      	cmp	r4, r3
    12fc:	d112      	bne.n	1324 <vuIP_Task+0xdc>
			{
				uip_arp_arpin();
    12fe:	f009 ff01 	bl	b104 <uip_arp_arpin>

				/* If the above function invocation resulted in data that
				should be sent out on the network, the global variable
				uip_len is set to a value > 0. */
				if( uip_len > 0 )
    1302:	f64a 3358 	movw	r3, #43864	; 0xab58
    1306:	f2c2 0300 	movt	r3, #8192	; 0x2000
    130a:	881b      	ldrh	r3, [r3, #0]
    130c:	2b00      	cmp	r3, #0
    130e:	d00b      	beq.n	1328 <vuIP_Task+0xe0>
				{
					vEMACWrite();
    1310:	f000 f9cc 	bl	16ac <vEMACWrite>
	{
		/* Is there received data ready to be processed? */
		lPacketLength = MSS_MAC_rx_packet();

		/* Statements to be executed if data has been received on the Ethernet. */
		if( ( lPacketLength > 0 ) && ( uip_buf != NULL ) )
    1314:	e009      	b.n	132a <vuIP_Task+0xe2>
			}
		}
		else
		{
			/* Clear the RX event latched in ulUIP_Events - if one was latched. */
			ulUIP_Events &= ~uipETHERNET_RX_EVENT;
    1316:	693b      	ldr	r3, [r7, #16]
    1318:	f023 0301 	bic.w	r3, r3, #1
    131c:	613b      	str	r3, [r7, #16]
    131e:	e004      	b.n	132a <vuIP_Task+0xe2>
	{
		/* Is there received data ready to be processed? */
		lPacketLength = MSS_MAC_rx_packet();

		/* Statements to be executed if data has been received on the Ethernet. */
		if( ( lPacketLength > 0 ) && ( uip_buf != NULL ) )
    1320:	bf00      	nop
    1322:	e002      	b.n	132a <vuIP_Task+0xe2>
    1324:	bf00      	nop
    1326:	e000      	b.n	132a <vuIP_Task+0xe2>
    1328:	bf00      	nop
			/* Clear the RX event latched in ulUIP_Events - if one was latched. */
			ulUIP_Events &= ~uipETHERNET_RX_EVENT;
		}

		/* Statements to be executed if the TCP/IP period timer has expired. */
		if( ( ulUIP_Events & uipPERIODIC_TIMER_EVENT ) != 0UL )
    132a:	693b      	ldr	r3, [r7, #16]
    132c:	f003 0308 	and.w	r3, r3, #8
    1330:	2b00      	cmp	r3, #0
    1332:	d033      	beq.n	139c <vuIP_Task+0x154>
		{
			ulUIP_Events &= ~uipPERIODIC_TIMER_EVENT;
    1334:	693b      	ldr	r3, [r7, #16]
    1336:	f023 0308 	bic.w	r3, r3, #8
    133a:	613b      	str	r3, [r7, #16]

			if( uip_buf != NULL )
    133c:	f240 6390 	movw	r3, #1680	; 0x690
    1340:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1344:	681b      	ldr	r3, [r3, #0]
    1346:	2b00      	cmp	r3, #0
    1348:	d028      	beq.n	139c <vuIP_Task+0x154>
			{
				for( i = 0; i < UIP_CONNS; i++ )
    134a:	f04f 0300 	mov.w	r3, #0
    134e:	60fb      	str	r3, [r7, #12]
    1350:	e021      	b.n	1396 <vuIP_Task+0x14e>
				{
					uip_periodic( i );
    1352:	68fb      	ldr	r3, [r7, #12]
    1354:	f04f 02cc 	mov.w	r2, #204	; 0xcc
    1358:	fb02 f203 	mul.w	r2, r2, r3
    135c:	f64a 3370 	movw	r3, #43888	; 0xab70
    1360:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1364:	441a      	add	r2, r3
    1366:	f64a 336c 	movw	r3, #43884	; 0xab6c
    136a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    136e:	601a      	str	r2, [r3, #0]
    1370:	f04f 0002 	mov.w	r0, #2
    1374:	f007 fb7c 	bl	8a70 <uip_process>

					/* If the above function invocation resulted in data that
					should be sent out on the network, the global variable
					uip_len is set to a value > 0. */
					if( uip_len > 0 )
    1378:	f64a 3358 	movw	r3, #43864	; 0xab58
    137c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1380:	881b      	ldrh	r3, [r3, #0]
    1382:	2b00      	cmp	r3, #0
    1384:	d003      	beq.n	138e <vuIP_Task+0x146>
					{
						uip_arp_out();
    1386:	f00a f841 	bl	b40c <uip_arp_out>
						vEMACWrite();
    138a:	f000 f98f 	bl	16ac <vEMACWrite>
		{
			ulUIP_Events &= ~uipPERIODIC_TIMER_EVENT;

			if( uip_buf != NULL )
			{
				for( i = 0; i < UIP_CONNS; i++ )
    138e:	68fb      	ldr	r3, [r7, #12]
    1390:	f103 0301 	add.w	r3, r3, #1
    1394:	60fb      	str	r3, [r7, #12]
    1396:	68fb      	ldr	r3, [r7, #12]
    1398:	2b27      	cmp	r3, #39	; 0x27
    139a:	ddda      	ble.n	1352 <vuIP_Task+0x10a>
				}
			}
		}

		/* Statements to be executed if the ARP timer has expired. */
		if( ( ulUIP_Events & uipARP_TIMER_EVENT ) != 0 )
    139c:	693b      	ldr	r3, [r7, #16]
    139e:	f003 0304 	and.w	r3, r3, #4
    13a2:	2b00      	cmp	r3, #0
    13a4:	d005      	beq.n	13b2 <vuIP_Task+0x16a>
		{
			ulUIP_Events &= ~uipARP_TIMER_EVENT;
    13a6:	693b      	ldr	r3, [r7, #16]
    13a8:	f023 0304 	bic.w	r3, r3, #4
    13ac:	613b      	str	r3, [r7, #16]
			uip_arp_timer();
    13ae:	f009 fcf7 	bl	ada0 <uip_arp_timer>
		}

		/* If all latched events have been cleared - block until another event
		occurs. */
		if( ulUIP_Events == pdFALSE )
    13b2:	693b      	ldr	r3, [r7, #16]
    13b4:	2b00      	cmp	r3, #0
    13b6:	f47f af56 	bne.w	1266 <vuIP_Task+0x1e>
		{
			xQueueReceive( xEMACEventQueue, &ulNewEvent, portMAX_DELAY );
    13ba:	f240 6300 	movw	r3, #1536	; 0x600
    13be:	f2c2 0300 	movt	r3, #8192	; 0x2000
    13c2:	681a      	ldr	r2, [r3, #0]
    13c4:	f107 0308 	add.w	r3, r7, #8
    13c8:	4610      	mov	r0, r2
    13ca:	4619      	mov	r1, r3
    13cc:	f04f 32ff 	mov.w	r2, #4294967295
    13d0:	f00b fd7e 	bl	ced0 <xQueueReceive>
			ulUIP_Events |= ulNewEvent;
    13d4:	68bb      	ldr	r3, [r7, #8]
    13d6:	693a      	ldr	r2, [r7, #16]
    13d8:	ea42 0303 	orr.w	r3, r2, r3
    13dc:	613b      	str	r3, [r7, #16]
		}
	}
    13de:	e743      	b.n	1268 <vuIP_Task+0x20>

000013e0 <prvSetMACAddress>:
}
/*-----------------------------------------------------------*/

static void prvSetMACAddress( void )
{
    13e0:	b480      	push	{r7}
    13e2:	b083      	sub	sp, #12
    13e4:	af00      	add	r7, sp, #0
struct uip_eth_addr xAddr;

	/* Configure the MAC address in the uIP stack. */
	xAddr.addr[ 0 ] = configMAC_ADDR0;
    13e6:	f04f 0300 	mov.w	r3, #0
    13ea:	703b      	strb	r3, [r7, #0]
	xAddr.addr[ 1 ] = configMAC_ADDR1;
    13ec:	f04f 0312 	mov.w	r3, #18
    13f0:	707b      	strb	r3, [r7, #1]
	xAddr.addr[ 2 ] = configMAC_ADDR2;
    13f2:	f04f 0313 	mov.w	r3, #19
    13f6:	70bb      	strb	r3, [r7, #2]
	xAddr.addr[ 3 ] = configMAC_ADDR3;
    13f8:	f04f 0310 	mov.w	r3, #16
    13fc:	70fb      	strb	r3, [r7, #3]
	xAddr.addr[ 4 ] = configMAC_ADDR4;
    13fe:	f04f 0315 	mov.w	r3, #21
    1402:	713b      	strb	r3, [r7, #4]
	xAddr.addr[ 5 ] = configMAC_ADDR5;
    1404:	f04f 0311 	mov.w	r3, #17
    1408:	717b      	strb	r3, [r7, #5]
	uip_setethaddr( xAddr );
    140a:	783a      	ldrb	r2, [r7, #0]
    140c:	f642 7364 	movw	r3, #12132	; 0x2f64
    1410:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1414:	701a      	strb	r2, [r3, #0]
    1416:	787a      	ldrb	r2, [r7, #1]
    1418:	f642 7364 	movw	r3, #12132	; 0x2f64
    141c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1420:	705a      	strb	r2, [r3, #1]
    1422:	78ba      	ldrb	r2, [r7, #2]
    1424:	f642 7364 	movw	r3, #12132	; 0x2f64
    1428:	f2c2 0300 	movt	r3, #8192	; 0x2000
    142c:	709a      	strb	r2, [r3, #2]
    142e:	78fa      	ldrb	r2, [r7, #3]
    1430:	f642 7364 	movw	r3, #12132	; 0x2f64
    1434:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1438:	70da      	strb	r2, [r3, #3]
    143a:	793a      	ldrb	r2, [r7, #4]
    143c:	f642 7364 	movw	r3, #12132	; 0x2f64
    1440:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1444:	711a      	strb	r2, [r3, #4]
    1446:	797a      	ldrb	r2, [r7, #5]
    1448:	f642 7364 	movw	r3, #12132	; 0x2f64
    144c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1450:	715a      	strb	r2, [r3, #5]
}
    1452:	f107 070c 	add.w	r7, r7, #12
    1456:	46bd      	mov	sp, r7
    1458:	bc80      	pop	{r7}
    145a:	4770      	bx	lr

0000145c <prvInitialise_uIP>:
/*-----------------------------------------------------------*/

static void prvInitialise_uIP( void )
{
    145c:	b580      	push	{r7, lr}
    145e:	b088      	sub	sp, #32
    1460:	af02      	add	r7, sp, #8
uip_ipaddr_t xIPAddr;
TimerHandle_t xARPTimer, xPeriodicTimer;

	uip_init();
    1462:	f007 f8e7 	bl	8634 <uip_init>
	uip_ipaddr( &xIPAddr, configIP_ADDR0, configIP_ADDR1, configIP_ADDR2, configIP_ADDR3 );
    1466:	f06f 033f 	mvn.w	r3, #63	; 0x3f
    146a:	713b      	strb	r3, [r7, #4]
    146c:	f06f 0357 	mvn.w	r3, #87	; 0x57
    1470:	717b      	strb	r3, [r7, #5]
    1472:	f04f 0300 	mov.w	r3, #0
    1476:	71bb      	strb	r3, [r7, #6]
    1478:	f06f 0337 	mvn.w	r3, #55	; 0x37
    147c:	71fb      	strb	r3, [r7, #7]
	uip_sethostaddr( &xIPAddr );
    147e:	793a      	ldrb	r2, [r7, #4]
    1480:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    1484:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1488:	701a      	strb	r2, [r3, #0]
    148a:	797a      	ldrb	r2, [r7, #5]
    148c:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    1490:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1494:	705a      	strb	r2, [r3, #1]
    1496:	79ba      	ldrb	r2, [r7, #6]
    1498:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    149c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    14a0:	709a      	strb	r2, [r3, #2]
    14a2:	79fa      	ldrb	r2, [r7, #7]
    14a4:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    14a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    14ac:	70da      	strb	r2, [r3, #3]
	uip_ipaddr( &xIPAddr, configNET_MASK0, configNET_MASK1, configNET_MASK2, configNET_MASK3 );
    14ae:	f04f 33ff 	mov.w	r3, #4294967295
    14b2:	713b      	strb	r3, [r7, #4]
    14b4:	f04f 33ff 	mov.w	r3, #4294967295
    14b8:	717b      	strb	r3, [r7, #5]
    14ba:	f04f 33ff 	mov.w	r3, #4294967295
    14be:	71bb      	strb	r3, [r7, #6]
    14c0:	f04f 0300 	mov.w	r3, #0
    14c4:	71fb      	strb	r3, [r7, #7]
	uip_setnetmask( &xIPAddr );
    14c6:	793a      	ldrb	r2, [r7, #4]
    14c8:	f64c 33dc 	movw	r3, #52188	; 0xcbdc
    14cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    14d0:	701a      	strb	r2, [r3, #0]
    14d2:	797a      	ldrb	r2, [r7, #5]
    14d4:	f64c 33dc 	movw	r3, #52188	; 0xcbdc
    14d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    14dc:	705a      	strb	r2, [r3, #1]
    14de:	79ba      	ldrb	r2, [r7, #6]
    14e0:	f64c 33dc 	movw	r3, #52188	; 0xcbdc
    14e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    14e8:	709a      	strb	r2, [r3, #2]
    14ea:	79fa      	ldrb	r2, [r7, #7]
    14ec:	f64c 33dc 	movw	r3, #52188	; 0xcbdc
    14f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    14f4:	70da      	strb	r2, [r3, #3]
	prvSetMACAddress();
    14f6:	f7ff ff73 	bl	13e0 <prvSetMACAddress>
	httpd_init();
    14fa:	f00b f84b 	bl	c594 <httpd_init>

	/* Create the queue used to sent TCP/IP events to the uIP stack. */
	xEMACEventQueue = xQueueCreate( uipEVENT_QUEUE_LENGTH, sizeof( unsigned long ) );
    14fe:	f04f 000a 	mov.w	r0, #10
    1502:	f04f 0104 	mov.w	r1, #4
    1506:	f04f 0200 	mov.w	r2, #0
    150a:	f00b f97d 	bl	c808 <xQueueGenericCreate>
    150e:	4602      	mov	r2, r0
    1510:	f240 6300 	movw	r3, #1536	; 0x600
    1514:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1518:	601a      	str	r2, [r3, #0]

	/* Create and start the uIP timers. */
	xARPTimer = xTimerCreate( 	"ARPTimer", /* Just a name that is helpful for debugging, not used by the kernel. */
    151a:	f241 7301 	movw	r3, #5889	; 0x1701
    151e:	f2c0 0300 	movt	r3, #0
    1522:	9300      	str	r3, [sp, #0]
    1524:	f243 00f8 	movw	r0, #12536	; 0x30f8
    1528:	f2c0 0001 	movt	r0, #1
    152c:	f242 7110 	movw	r1, #10000	; 0x2710
    1530:	f04f 0201 	mov.w	r2, #1
    1534:	f04f 0300 	mov.w	r3, #0
    1538:	f00f fa2e 	bl	10998 <xTimerCreate>
    153c:	4603      	mov	r3, r0
    153e:	60bb      	str	r3, [r7, #8]
								pdTRUE, /* Autor-reload. */
								( void * ) uipARP_TIMER,
								prvUIPTimerCallback
							);

	xPeriodicTimer = xTimerCreate( 	"PeriodicTimer",
    1540:	f241 7301 	movw	r3, #5889	; 0x1701
    1544:	f2c0 0300 	movt	r3, #0
    1548:	9300      	str	r3, [sp, #0]
    154a:	f243 1004 	movw	r0, #12548	; 0x3104
    154e:	f2c0 0001 	movt	r0, #1
    1552:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
    1556:	f04f 0201 	mov.w	r2, #1
    155a:	f04f 0301 	mov.w	r3, #1
    155e:	f00f fa1b 	bl	10998 <xTimerCreate>
    1562:	4603      	mov	r3, r0
    1564:	60fb      	str	r3, [r7, #12]
									( void * ) uipPERIODIC_TIMER,
									prvUIPTimerCallback
								);

	/* Sanity check that the timers were indeed created. */
	configASSERT( xARPTimer );
    1566:	68bb      	ldr	r3, [r7, #8]
    1568:	2b00      	cmp	r3, #0
    156a:	d109      	bne.n	1580 <prvInitialise_uIP+0x124>
    156c:	f04f 0328 	mov.w	r3, #40	; 0x28
    1570:	f383 8811 	msr	BASEPRI, r3
    1574:	f3bf 8f6f 	isb	sy
    1578:	f3bf 8f4f 	dsb	sy
    157c:	613b      	str	r3, [r7, #16]
    157e:	e7fe      	b.n	157e <prvInitialise_uIP+0x122>
	configASSERT( xPeriodicTimer );
    1580:	68fb      	ldr	r3, [r7, #12]
    1582:	2b00      	cmp	r3, #0
    1584:	d109      	bne.n	159a <prvInitialise_uIP+0x13e>
    1586:	f04f 0328 	mov.w	r3, #40	; 0x28
    158a:	f383 8811 	msr	BASEPRI, r3
    158e:	f3bf 8f6f 	isb	sy
    1592:	f3bf 8f4f 	dsb	sy
    1596:	617b      	str	r3, [r7, #20]
    1598:	e7fe      	b.n	1598 <prvInitialise_uIP+0x13c>

	/* These commands will block indefinitely until they succeed, so there is
	no point in checking their return values. */
	xTimerStart( xARPTimer, portMAX_DELAY );
    159a:	f00d fad3 	bl	eb44 <xTaskGetTickCount>
    159e:	4603      	mov	r3, r0
    15a0:	f04f 32ff 	mov.w	r2, #4294967295
    15a4:	9200      	str	r2, [sp, #0]
    15a6:	68b8      	ldr	r0, [r7, #8]
    15a8:	f04f 0101 	mov.w	r1, #1
    15ac:	461a      	mov	r2, r3
    15ae:	f04f 0300 	mov.w	r3, #0
    15b2:	f00f fa43 	bl	10a3c <xTimerGenericCommand>
	xTimerStart( xPeriodicTimer, portMAX_DELAY );
    15b6:	f00d fac5 	bl	eb44 <xTaskGetTickCount>
    15ba:	4603      	mov	r3, r0
    15bc:	f04f 32ff 	mov.w	r2, #4294967295
    15c0:	9200      	str	r2, [sp, #0]
    15c2:	68f8      	ldr	r0, [r7, #12]
    15c4:	f04f 0101 	mov.w	r1, #1
    15c8:	461a      	mov	r2, r3
    15ca:	f04f 0300 	mov.w	r3, #0
    15ce:	f00f fa35 	bl	10a3c <xTimerGenericCommand>
}
    15d2:	f107 0718 	add.w	r7, r7, #24
    15d6:	46bd      	mov	sp, r7
    15d8:	bd80      	pop	{r7, pc}
    15da:	bf00      	nop

000015dc <prvEMACEventListener>:
/*-----------------------------------------------------------*/

static void prvEMACEventListener( unsigned long ulISREvents )
{
    15dc:	b580      	push	{r7, lr}
    15de:	b086      	sub	sp, #24
    15e0:	af00      	add	r7, sp, #0
    15e2:	6078      	str	r0, [r7, #4]
long lHigherPriorityTaskWoken = pdFALSE;
    15e4:	f04f 0300 	mov.w	r3, #0
    15e8:	613b      	str	r3, [r7, #16]
const unsigned long ulRxEvent = uipETHERNET_RX_EVENT;
    15ea:	f04f 0301 	mov.w	r3, #1
    15ee:	60fb      	str	r3, [r7, #12]

	/* Sanity check that the event queue was indeed created. */
	configASSERT( xEMACEventQueue );
    15f0:	f240 6300 	movw	r3, #1536	; 0x600
    15f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    15f8:	681b      	ldr	r3, [r3, #0]
    15fa:	2b00      	cmp	r3, #0
    15fc:	d109      	bne.n	1612 <prvEMACEventListener+0x36>
    15fe:	f04f 0328 	mov.w	r3, #40	; 0x28
    1602:	f383 8811 	msr	BASEPRI, r3
    1606:	f3bf 8f6f 	isb	sy
    160a:	f3bf 8f4f 	dsb	sy
    160e:	617b      	str	r3, [r7, #20]
    1610:	e7fe      	b.n	1610 <prvEMACEventListener+0x34>

	if( ( ulISREvents & MSS_MAC_EVENT_PACKET_SEND ) != 0UL )
    1612:	687b      	ldr	r3, [r7, #4]
    1614:	f003 0301 	and.w	r3, r3, #1
    1618:	b2db      	uxtb	r3, r3
    161a:	2b00      	cmp	r3, #0
    161c:	d001      	beq.n	1622 <prvEMACEventListener+0x46>
	{
		/* An Ethernet Tx event has occurred. */
		MSS_MAC_FreeTxBuffers();
    161e:	f003 f971 	bl	4904 <MSS_MAC_FreeTxBuffers>
	}

	if( ( ulISREvents & MSS_MAC_EVENT_PACKET_RECEIVED ) != 0UL )
    1622:	687b      	ldr	r3, [r7, #4]
    1624:	f003 0302 	and.w	r3, r3, #2
    1628:	2b00      	cmp	r3, #0
    162a:	d00f      	beq.n	164c <prvEMACEventListener+0x70>
	{
		/* An Ethernet Rx event has occurred. */
		xQueueSendFromISR( xEMACEventQueue, &ulRxEvent, &lHigherPriorityTaskWoken );
    162c:	f240 6300 	movw	r3, #1536	; 0x600
    1630:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1634:	6819      	ldr	r1, [r3, #0]
    1636:	f107 020c 	add.w	r2, r7, #12
    163a:	f107 0310 	add.w	r3, r7, #16
    163e:	4608      	mov	r0, r1
    1640:	4611      	mov	r1, r2
    1642:	461a      	mov	r2, r3
    1644:	f04f 0300 	mov.w	r3, #0
    1648:	f00b fb0a 	bl	cc60 <xQueueGenericSendFromISR>
	}

	portEND_SWITCHING_ISR( lHigherPriorityTaskWoken );
    164c:	693b      	ldr	r3, [r7, #16]
    164e:	2b00      	cmp	r3, #0
    1650:	d00a      	beq.n	1668 <prvEMACEventListener+0x8c>
    1652:	f64e 5304 	movw	r3, #60676	; 0xed04
    1656:	f2ce 0300 	movt	r3, #57344	; 0xe000
    165a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    165e:	601a      	str	r2, [r3, #0]
    1660:	f3bf 8f4f 	dsb	sy
    1664:	f3bf 8f6f 	isb	sy
}
    1668:	f107 0718 	add.w	r7, r7, #24
    166c:	46bd      	mov	sp, r7
    166e:	bd80      	pop	{r7, pc}

00001670 <prvInitEmac>:
/*-----------------------------------------------------------*/

static void prvInitEmac( void )
{
    1670:	b580      	push	{r7, lr}
    1672:	b082      	sub	sp, #8
    1674:	af00      	add	r7, sp, #0
const unsigned char ucPHYAddress = 1;
    1676:	f04f 0301 	mov.w	r3, #1
    167a:	71fb      	strb	r3, [r7, #7]

	/* Initialise the MAC and PHY hardware. */
	MSS_MAC_init( ucPHYAddress );
    167c:	79fb      	ldrb	r3, [r7, #7]
    167e:	4618      	mov	r0, r3
    1680:	f000 fe30 	bl	22e4 <MSS_MAC_init>

	/* Register the event listener.  The Ethernet interrupt handler will call
	this listener whenever an Rx or a Tx interrupt occurs. */
	MSS_MAC_set_callback( ( MSS_MAC_callback_t ) prvEMACEventListener );
    1684:	f241 50dd 	movw	r0, #5597	; 0x15dd
    1688:	f2c0 0000 	movt	r0, #0
    168c:	f001 ffe6 	bl	365c <MSS_MAC_set_callback>

    /* Setup the EMAC and the NVIC for MAC interrupts. */
    NVIC_SetPriority( EthernetMAC_IRQn, configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY );
    1690:	f04f 0005 	mov.w	r0, #5
    1694:	f04f 0105 	mov.w	r1, #5
    1698:	f7ff fda0 	bl	11dc <NVIC_SetPriority>
    NVIC_EnableIRQ( EthernetMAC_IRQn );
    169c:	f04f 0005 	mov.w	r0, #5
    16a0:	f7ff fd80 	bl	11a4 <NVIC_EnableIRQ>
}
    16a4:	f107 0708 	add.w	r7, r7, #8
    16a8:	46bd      	mov	sp, r7
    16aa:	bd80      	pop	{r7, pc}

000016ac <vEMACWrite>:
/*-----------------------------------------------------------*/

void vEMACWrite( void )
{
    16ac:	b580      	push	{r7, lr}
    16ae:	b084      	sub	sp, #16
    16b0:	af00      	add	r7, sp, #0
const long lMaxAttempts = 10;
    16b2:	f04f 030a 	mov.w	r3, #10
    16b6:	607b      	str	r3, [r7, #4]
long lAttempt;
const TickType_t xShortDelay = ( 5 / portTICK_PERIOD_MS );
    16b8:	f04f 0305 	mov.w	r3, #5
    16bc:	60fb      	str	r3, [r7, #12]

	/* Try to send data to the Ethernet.  Keep trying for a while if data cannot
	be sent immediately.  Note that this will actually cause the data to be sent
	twice to get around delayed ACK problems when communicating with non real-
	time TCP/IP stacks (such as a Windows machine). */
	for( lAttempt = 0; lAttempt < lMaxAttempts; lAttempt++ )
    16be:	f04f 0300 	mov.w	r3, #0
    16c2:	60bb      	str	r3, [r7, #8]
    16c4:	e011      	b.n	16ea <vEMACWrite+0x3e>
	{
		if( MSS_MAC_tx_packet( uip_len ) != 0 )
    16c6:	f64a 3358 	movw	r3, #43864	; 0xab58
    16ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    16ce:	881b      	ldrh	r3, [r3, #0]
    16d0:	4618      	mov	r0, r3
    16d2:	f001 f979 	bl	29c8 <MSS_MAC_tx_packet>
    16d6:	4603      	mov	r3, r0
    16d8:	2b00      	cmp	r3, #0
    16da:	d10b      	bne.n	16f4 <vEMACWrite+0x48>
		{
			break;
		}
		else
		{
			vTaskDelay( xShortDelay );
    16dc:	68f8      	ldr	r0, [r7, #12]
    16de:	f00c fd35 	bl	e14c <vTaskDelay>

	/* Try to send data to the Ethernet.  Keep trying for a while if data cannot
	be sent immediately.  Note that this will actually cause the data to be sent
	twice to get around delayed ACK problems when communicating with non real-
	time TCP/IP stacks (such as a Windows machine). */
	for( lAttempt = 0; lAttempt < lMaxAttempts; lAttempt++ )
    16e2:	68bb      	ldr	r3, [r7, #8]
    16e4:	f103 0301 	add.w	r3, r3, #1
    16e8:	60bb      	str	r3, [r7, #8]
    16ea:	68ba      	ldr	r2, [r7, #8]
    16ec:	687b      	ldr	r3, [r7, #4]
    16ee:	429a      	cmp	r2, r3
    16f0:	dbe9      	blt.n	16c6 <vEMACWrite+0x1a>
    16f2:	e000      	b.n	16f6 <vEMACWrite+0x4a>
	{
		if( MSS_MAC_tx_packet( uip_len ) != 0 )
		{
			break;
    16f4:	bf00      	nop
		else
		{
			vTaskDelay( xShortDelay );
		}
	}
}
    16f6:	f107 0710 	add.w	r7, r7, #16
    16fa:	46bd      	mov	sp, r7
    16fc:	bd80      	pop	{r7, pc}
    16fe:	bf00      	nop

00001700 <prvUIPTimerCallback>:
/*-----------------------------------------------------------*/

static void prvUIPTimerCallback( TimerHandle_t xTimer )
{
    1700:	b580      	push	{r7, lr}
    1702:	b082      	sub	sp, #8
    1704:	af00      	add	r7, sp, #0
    1706:	6078      	str	r0, [r7, #4]
static const unsigned long ulPeriodicTimerExpired = uipPERIODIC_TIMER_EVENT;

	/* This is a time callback, so calls to xQueueSend() must not attempt to
	block.  As this callback is assigned to both the ARP and Periodic timers, the
	first thing to do is ascertain which timer it was that actually expired. */
	switch( ( int ) pvTimerGetTimerID( xTimer ) )
    1708:	6878      	ldr	r0, [r7, #4]
    170a:	f00f fd43 	bl	11194 <pvTimerGetTimerID>
    170e:	4603      	mov	r3, r0
    1710:	2b00      	cmp	r3, #0
    1712:	d002      	beq.n	171a <prvUIPTimerCallback+0x1a>
    1714:	2b01      	cmp	r3, #1
    1716:	d011      	beq.n	173c <prvUIPTimerCallback+0x3c>
    1718:	e020      	b.n	175c <prvUIPTimerCallback+0x5c>
	{
		case uipARP_TIMER		:	xQueueSend( xEMACEventQueue, &ulARPTimerExpired, uipDONT_BLOCK );
    171a:	f240 6300 	movw	r3, #1536	; 0x600
    171e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1722:	681b      	ldr	r3, [r3, #0]
    1724:	4618      	mov	r0, r3
    1726:	f243 1128 	movw	r1, #12584	; 0x3128
    172a:	f2c0 0101 	movt	r1, #1
    172e:	f04f 0200 	mov.w	r2, #0
    1732:	f04f 0300 	mov.w	r3, #0
    1736:	f00b f97b 	bl	ca30 <xQueueGenericSend>
									break;
    173a:	e00f      	b.n	175c <prvUIPTimerCallback+0x5c>

		case uipPERIODIC_TIMER	:	xQueueSend( xEMACEventQueue, &ulPeriodicTimerExpired, uipDONT_BLOCK );
    173c:	f240 6300 	movw	r3, #1536	; 0x600
    1740:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1744:	681b      	ldr	r3, [r3, #0]
    1746:	4618      	mov	r0, r3
    1748:	f243 112c 	movw	r1, #12588	; 0x312c
    174c:	f2c0 0101 	movt	r1, #1
    1750:	f04f 0200 	mov.w	r2, #0
    1754:	f04f 0300 	mov.w	r3, #0
    1758:	f00b f96a 	bl	ca30 <xQueueGenericSend>
									break;

		default					:  	/* Should not get here. */
									break;
	}
}
    175c:	f107 0708 	add.w	r7, r7, #8
    1760:	46bd      	mov	sp, r7
    1762:	bd80      	pop	{r7, pc}

00001764 <vApplicationProcessFormInput>:
/*-----------------------------------------------------------*/

void vApplicationProcessFormInput( char *pcInputString )
{
    1764:	b580      	push	{r7, lr}
    1766:	b084      	sub	sp, #16
    1768:	af00      	add	r7, sp, #0
    176a:	6078      	str	r0, [r7, #4]
char *c;

	/* Only interested in processing form input if this is the IO page. */
	c = strstr( pcInputString, "io.shtml" );
    176c:	6878      	ldr	r0, [r7, #4]
    176e:	f243 1114 	movw	r1, #12564	; 0x3114
    1772:	f2c0 0101 	movt	r1, #1
    1776:	f010 fef9 	bl	1256c <strstr>
    177a:	4603      	mov	r3, r0
    177c:	60fb      	str	r3, [r7, #12]

	if( c )
    177e:	68fb      	ldr	r3, [r7, #12]
    1780:	2b00      	cmp	r3, #0
    1782:	d039      	beq.n	17f8 <vApplicationProcessFormInput+0x94>
	{
		/* Is there a command in the string? */
		c = strstr( pcInputString, "?" );
    1784:	6878      	ldr	r0, [r7, #4]
    1786:	f04f 013f 	mov.w	r1, #63	; 0x3f
    178a:	f010 fbcd 	bl	11f28 <strchr>
    178e:	4603      	mov	r3, r0
    1790:	60fb      	str	r3, [r7, #12]
	    if( c )
    1792:	68fb      	ldr	r3, [r7, #12]
    1794:	2b00      	cmp	r3, #0
    1796:	d023      	beq.n	17e0 <vApplicationProcessFormInput+0x7c>
	    {
			/* Turn the LED's on or off in accordance with the check box status. */
			if( strstr( c, "LED0=1" ) != NULL )
    1798:	68f8      	ldr	r0, [r7, #12]
    179a:	f243 1120 	movw	r1, #12576	; 0x3120
    179e:	f2c0 0101 	movt	r1, #1
    17a2:	f010 fee3 	bl	1256c <strstr>
    17a6:	4603      	mov	r3, r0
    17a8:	2b00      	cmp	r3, #0
    17aa:	d00c      	beq.n	17c6 <vApplicationProcessFormInput+0x62>
			{
				/* Turn the LEDs on. */
				vParTestSetLED( 3, 1 );
    17ac:	f04f 0003 	mov.w	r0, #3
    17b0:	f04f 0101 	mov.w	r1, #1
    17b4:	f7fe fea6 	bl	504 <vParTestSetLED>
				vParTestSetLED( 4, 1 );
    17b8:	f04f 0004 	mov.w	r0, #4
    17bc:	f04f 0101 	mov.w	r1, #1
    17c0:	f7fe fea0 	bl	504 <vParTestSetLED>
			}
			else
			{
				/* Turn the LEDs off. */
				vParTestSetLED( 3, 0 );
				vParTestSetLED( 4, 0 );
    17c4:	e018      	b.n	17f8 <vApplicationProcessFormInput+0x94>
				vParTestSetLED( 4, 1 );
			}
			else
			{
				/* Turn the LEDs off. */
				vParTestSetLED( 3, 0 );
    17c6:	f04f 0003 	mov.w	r0, #3
    17ca:	f04f 0100 	mov.w	r1, #0
    17ce:	f7fe fe99 	bl	504 <vParTestSetLED>
				vParTestSetLED( 4, 0 );
    17d2:	f04f 0004 	mov.w	r0, #4
    17d6:	f04f 0100 	mov.w	r1, #0
    17da:	f7fe fe93 	bl	504 <vParTestSetLED>
    17de:	e00b      	b.n	17f8 <vApplicationProcessFormInput+0x94>
			}
	    }
		else
		{
			/* Commands to turn LEDs off are not always explicit. */
			vParTestSetLED( 3, 0 );
    17e0:	f04f 0003 	mov.w	r0, #3
    17e4:	f04f 0100 	mov.w	r1, #0
    17e8:	f7fe fe8c 	bl	504 <vParTestSetLED>
			vParTestSetLED( 4, 0 );
    17ec:	f04f 0004 	mov.w	r0, #4
    17f0:	f04f 0100 	mov.w	r1, #0
    17f4:	f7fe fe86 	bl	504 <vParTestSetLED>
		}
	}
}
    17f8:	f107 0710 	add.w	r7, r7, #16
    17fc:	46bd      	mov	sp, r7
    17fe:	bd80      	pop	{r7, pc}

00001800 <nullfunction>:

static const struct httpd_cgi_call	*calls[] = { &file, &tcp, &net, &rtos, &run, &io, NULL };

/*---------------------------------------------------------------------------*/
static PT_THREAD( nullfunction ( struct httpd_state *s, char *ptr ) )
{
    1800:	b480      	push	{r7}
    1802:	b085      	sub	sp, #20
    1804:	af00      	add	r7, sp, #0
    1806:	6078      	str	r0, [r7, #4]
    1808:	6039      	str	r1, [r7, #0]
	PSOCK_BEGIN( &s->sout );
    180a:	f04f 0301 	mov.w	r3, #1
    180e:	73fb      	strb	r3, [r7, #15]
	( void ) ptr;
	( void ) PT_YIELD_FLAG;
	PSOCK_END( &s->sout );
    1810:	f04f 0300 	mov.w	r3, #0
    1814:	73fb      	strb	r3, [r7, #15]
    1816:	687b      	ldr	r3, [r7, #4]
    1818:	f04f 0200 	mov.w	r2, #0
    181c:	851a      	strh	r2, [r3, #40]	; 0x28
    181e:	f04f 0302 	mov.w	r3, #2
}
    1822:	4618      	mov	r0, r3
    1824:	f107 0714 	add.w	r7, r7, #20
    1828:	46bd      	mov	sp, r7
    182a:	bc80      	pop	{r7}
    182c:	4770      	bx	lr
    182e:	bf00      	nop

00001830 <httpd_cgi>:

/*---------------------------------------------------------------------------*/
httpd_cgifunction httpd_cgi( char *name )
{
    1830:	b590      	push	{r4, r7, lr}
    1832:	b085      	sub	sp, #20
    1834:	af00      	add	r7, sp, #0
    1836:	6078      	str	r0, [r7, #4]
	const struct httpd_cgi_call **f;

	/* Find the matching name in the table, return the function. */
	for( f = calls; *f != NULL; ++f )
    1838:	f240 0308 	movw	r3, #8
    183c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1840:	60fb      	str	r3, [r7, #12]
    1842:	e019      	b.n	1878 <httpd_cgi+0x48>
	{
		if( strncmp((*f)->name, name, strlen((*f)->name)) == 0 )
    1844:	68fb      	ldr	r3, [r7, #12]
    1846:	681b      	ldr	r3, [r3, #0]
    1848:	681c      	ldr	r4, [r3, #0]
    184a:	68fb      	ldr	r3, [r7, #12]
    184c:	681b      	ldr	r3, [r3, #0]
    184e:	681b      	ldr	r3, [r3, #0]
    1850:	4618      	mov	r0, r3
    1852:	f010 fc27 	bl	120a4 <strlen>
    1856:	4603      	mov	r3, r0
    1858:	4620      	mov	r0, r4
    185a:	6879      	ldr	r1, [r7, #4]
    185c:	461a      	mov	r2, r3
    185e:	f010 fc51 	bl	12104 <strncmp>
    1862:	4603      	mov	r3, r0
    1864:	2b00      	cmp	r3, #0
    1866:	d103      	bne.n	1870 <httpd_cgi+0x40>
		{
			return( *f )->function;
    1868:	68fb      	ldr	r3, [r7, #12]
    186a:	681b      	ldr	r3, [r3, #0]
    186c:	685b      	ldr	r3, [r3, #4]
    186e:	e00b      	b.n	1888 <httpd_cgi+0x58>
httpd_cgifunction httpd_cgi( char *name )
{
	const struct httpd_cgi_call **f;

	/* Find the matching name in the table, return the function. */
	for( f = calls; *f != NULL; ++f )
    1870:	68fb      	ldr	r3, [r7, #12]
    1872:	f103 0304 	add.w	r3, r3, #4
    1876:	60fb      	str	r3, [r7, #12]
    1878:	68fb      	ldr	r3, [r7, #12]
    187a:	681b      	ldr	r3, [r3, #0]
    187c:	2b00      	cmp	r3, #0
    187e:	d1e1      	bne.n	1844 <httpd_cgi+0x14>
		{
			return( *f )->function;
		}
	}

	return nullfunction;
    1880:	f641 0301 	movw	r3, #6145	; 0x1801
    1884:	f2c0 0300 	movt	r3, #0
}
    1888:	4618      	mov	r0, r3
    188a:	f107 0714 	add.w	r7, r7, #20
    188e:	46bd      	mov	sp, r7
    1890:	bd90      	pop	{r4, r7, pc}
    1892:	bf00      	nop

00001894 <generate_file_stats>:

/*---------------------------------------------------------------------------*/
static unsigned short generate_file_stats( void *arg )
{
    1894:	b590      	push	{r4, r7, lr}
    1896:	b085      	sub	sp, #20
    1898:	af00      	add	r7, sp, #0
    189a:	6078      	str	r0, [r7, #4]
	char	*f = ( char * ) arg;
    189c:	687b      	ldr	r3, [r7, #4]
    189e:	60fb      	str	r3, [r7, #12]
	return sprintf( ( char * ) uip_appdata, "%5u", httpd_fs_count(f) );
    18a0:	f64a 3368 	movw	r3, #43880	; 0xab68
    18a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    18a8:	681b      	ldr	r3, [r3, #0]
    18aa:	461c      	mov	r4, r3
    18ac:	68f8      	ldr	r0, [r7, #12]
    18ae:	f00a f887 	bl	b9c0 <httpd_fs_count>
    18b2:	4603      	mov	r3, r0
    18b4:	4620      	mov	r0, r4
    18b6:	f243 1178 	movw	r1, #12664	; 0x3178
    18ba:	f2c0 0101 	movt	r1, #1
    18be:	461a      	mov	r2, r3
    18c0:	f7ff fc30 	bl	1124 <sprintf>
    18c4:	4603      	mov	r3, r0
    18c6:	b29b      	uxth	r3, r3
}
    18c8:	4618      	mov	r0, r3
    18ca:	f107 0714 	add.w	r7, r7, #20
    18ce:	46bd      	mov	sp, r7
    18d0:	bd90      	pop	{r4, r7, pc}
    18d2:	bf00      	nop

000018d4 <file_stats>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( file_stats ( struct httpd_state *s, char *ptr ) )
{
    18d4:	b590      	push	{r4, r7, lr}
    18d6:	b085      	sub	sp, #20
    18d8:	af00      	add	r7, sp, #0
    18da:	6078      	str	r0, [r7, #4]
    18dc:	6039      	str	r1, [r7, #0]
	PSOCK_BEGIN( &s->sout );
    18de:	f04f 0301 	mov.w	r3, #1
    18e2:	73fb      	strb	r3, [r7, #15]
    18e4:	687b      	ldr	r3, [r7, #4]
    18e6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    18e8:	2b00      	cmp	r3, #0
    18ea:	d002      	beq.n	18f2 <file_stats+0x1e>
    18ec:	2b6d      	cmp	r3, #109	; 0x6d
    18ee:	d004      	beq.n	18fa <file_stats+0x26>
    18f0:	e01c      	b.n	192c <file_stats+0x58>

	( void ) PT_YIELD_FLAG;

	PSOCK_GENERATOR_SEND( &s->sout, generate_file_stats, strchr(ptr, ' ') + 1 );
    18f2:	687b      	ldr	r3, [r7, #4]
    18f4:	f04f 026d 	mov.w	r2, #109	; 0x6d
    18f8:	851a      	strh	r2, [r3, #40]	; 0x28
    18fa:	687b      	ldr	r3, [r7, #4]
    18fc:	f103 0428 	add.w	r4, r3, #40	; 0x28
    1900:	6838      	ldr	r0, [r7, #0]
    1902:	f04f 0120 	mov.w	r1, #32
    1906:	f010 fb0f 	bl	11f28 <strchr>
    190a:	4603      	mov	r3, r0
    190c:	f103 0301 	add.w	r3, r3, #1
    1910:	4620      	mov	r0, r4
    1912:	f641 0195 	movw	r1, #6293	; 0x1895
    1916:	f2c0 0100 	movt	r1, #0
    191a:	461a      	mov	r2, r3
    191c:	f006 fb06 	bl	7f2c <psock_generator_send>
    1920:	4603      	mov	r3, r0
    1922:	2b00      	cmp	r3, #0
    1924:	d102      	bne.n	192c <file_stats+0x58>
    1926:	f04f 0300 	mov.w	r3, #0
    192a:	e008      	b.n	193e <file_stats+0x6a>

	PSOCK_END( &s->sout );
    192c:	f04f 0300 	mov.w	r3, #0
    1930:	73fb      	strb	r3, [r7, #15]
    1932:	687b      	ldr	r3, [r7, #4]
    1934:	f04f 0200 	mov.w	r2, #0
    1938:	851a      	strh	r2, [r3, #40]	; 0x28
    193a:	f04f 0302 	mov.w	r3, #2
}
    193e:	4618      	mov	r0, r3
    1940:	f107 0714 	add.w	r7, r7, #20
    1944:	46bd      	mov	sp, r7
    1946:	bd90      	pop	{r4, r7, pc}

00001948 <generate_tcp_stats>:
static const char	last_ack[] = /*  "LAST-ACK"*/ { 0x4c, 0x41, 0x53, 0x54, 0x2d, 0x41, 0x43, 0x4b, 0 };

static const char	*states[] = { closed, syn_rcvd, syn_sent, established, fin_wait_1, fin_wait_2, closing, time_wait, last_ack };

static unsigned short generate_tcp_stats( void *arg )
{
    1948:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    194c:	b08e      	sub	sp, #56	; 0x38
    194e:	af0a      	add	r7, sp, #40	; 0x28
    1950:	6078      	str	r0, [r7, #4]
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;
    1952:	687b      	ldr	r3, [r7, #4]
    1954:	60fb      	str	r3, [r7, #12]

	conn = &uip_conns[s->count];
    1956:	68fb      	ldr	r3, [r7, #12]
    1958:	f8b3 30ac 	ldrh.w	r3, [r3, #172]	; 0xac
    195c:	f04f 02cc 	mov.w	r2, #204	; 0xcc
    1960:	fb02 f203 	mul.w	r2, r2, r3
    1964:	f64a 3370 	movw	r3, #43888	; 0xab70
    1968:	f2c2 0300 	movt	r3, #8192	; 0x2000
    196c:	4413      	add	r3, r2
    196e:	60bb      	str	r3, [r7, #8]
	return sprintf( ( char * ) uip_appdata,
    1970:	f64a 3368 	movw	r3, #43880	; 0xab68
    1974:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1978:	681b      	ldr	r3, [r3, #0]
    197a:	461e      	mov	r6, r3
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
    197c:	68bb      	ldr	r3, [r7, #8]
    197e:	889b      	ldrh	r3, [r3, #4]
    1980:	4618      	mov	r0, r3
    1982:	f009 f94d 	bl	ac20 <htons>
    1986:	4603      	mov	r3, r0
{
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;

	conn = &uip_conns[s->count];
	return sprintf( ( char * ) uip_appdata,
    1988:	461d      	mov	r5, r3
    198a:	68bb      	ldr	r3, [r7, #8]
    198c:	881b      	ldrh	r3, [r3, #0]
    198e:	4618      	mov	r0, r3
    1990:	f009 f946 	bl	ac20 <htons>
    1994:	4603      	mov	r3, r0
    1996:	ea4f 2313 	mov.w	r3, r3, lsr #8
    199a:	b29b      	uxth	r3, r3
    199c:	461c      	mov	r4, r3
    199e:	68bb      	ldr	r3, [r7, #8]
    19a0:	881b      	ldrh	r3, [r3, #0]
    19a2:	4618      	mov	r0, r3
    19a4:	f009 f93c 	bl	ac20 <htons>
    19a8:	4603      	mov	r3, r0
    19aa:	f003 09ff 	and.w	r9, r3, #255	; 0xff
    19ae:	68bb      	ldr	r3, [r7, #8]
    19b0:	885b      	ldrh	r3, [r3, #2]
    19b2:	4618      	mov	r0, r3
    19b4:	f009 f934 	bl	ac20 <htons>
    19b8:	4603      	mov	r3, r0
    19ba:	ea4f 2313 	mov.w	r3, r3, lsr #8
    19be:	b29b      	uxth	r3, r3
    19c0:	469a      	mov	sl, r3
    19c2:	68bb      	ldr	r3, [r7, #8]
    19c4:	885b      	ldrh	r3, [r3, #2]
    19c6:	4618      	mov	r0, r3
    19c8:	f009 f92a 	bl	ac20 <htons>
    19cc:	4603      	mov	r3, r0
    19ce:	f003 08ff 	and.w	r8, r3, #255	; 0xff
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
					 htons(conn->ripaddr.u16[0]) >> 8, htons(conn->ripaddr.u16[0]) & 0xff, htons(conn->ripaddr.u16[1]) >> 8,
					 htons(conn->ripaddr.u16[1]) & 0xff, htons(conn->rport), states[conn->tcpstateflags & UIP_TS_MASK], conn->nrtx, conn->timer,
    19d2:	68bb      	ldr	r3, [r7, #8]
    19d4:	88db      	ldrh	r3, [r3, #6]
    19d6:	4618      	mov	r0, r3
    19d8:	f009 f922 	bl	ac20 <htons>
    19dc:	4603      	mov	r3, r0
{
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;

	conn = &uip_conns[s->count];
	return sprintf( ( char * ) uip_appdata,
    19de:	469e      	mov	lr, r3
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
					 htons(conn->ripaddr.u16[0]) >> 8, htons(conn->ripaddr.u16[0]) & 0xff, htons(conn->ripaddr.u16[1]) >> 8,
					 htons(conn->ripaddr.u16[1]) & 0xff, htons(conn->rport), states[conn->tcpstateflags & UIP_TS_MASK], conn->nrtx, conn->timer,
    19e0:	68bb      	ldr	r3, [r7, #8]
    19e2:	7e5b      	ldrb	r3, [r3, #25]
    19e4:	f003 020f 	and.w	r2, r3, #15
{
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;

	conn = &uip_conns[s->count];
	return sprintf( ( char * ) uip_appdata,
    19e8:	f240 0324 	movw	r3, #36	; 0x24
    19ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    19f0:	f853 c022 	ldr.w	ip, [r3, r2, lsl #2]
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
					 htons(conn->ripaddr.u16[0]) >> 8, htons(conn->ripaddr.u16[0]) & 0xff, htons(conn->ripaddr.u16[1]) >> 8,
					 htons(conn->ripaddr.u16[1]) & 0xff, htons(conn->rport), states[conn->tcpstateflags & UIP_TS_MASK], conn->nrtx, conn->timer,
    19f4:	68bb      	ldr	r3, [r7, #8]
    19f6:	7edb      	ldrb	r3, [r3, #27]
{
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;

	conn = &uip_conns[s->count];
	return sprintf( ( char * ) uip_appdata,
    19f8:	4618      	mov	r0, r3
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
					 htons(conn->ripaddr.u16[0]) >> 8, htons(conn->ripaddr.u16[0]) & 0xff, htons(conn->ripaddr.u16[1]) >> 8,
					 htons(conn->ripaddr.u16[1]) & 0xff, htons(conn->rport), states[conn->tcpstateflags & UIP_TS_MASK], conn->nrtx, conn->timer,
    19fa:	68bb      	ldr	r3, [r7, #8]
    19fc:	7e9b      	ldrb	r3, [r3, #26]
{
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;

	conn = &uip_conns[s->count];
	return sprintf( ( char * ) uip_appdata,
    19fe:	4619      	mov	r1, r3
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
					 htons(conn->ripaddr.u16[0]) >> 8, htons(conn->ripaddr.u16[0]) & 0xff, htons(conn->ripaddr.u16[1]) >> 8,
					 htons(conn->ripaddr.u16[1]) & 0xff, htons(conn->rport), states[conn->tcpstateflags & UIP_TS_MASK], conn->nrtx, conn->timer,
					 (uip_outstanding(conn)) ? '*' : ' ', (uip_stopped(conn)) ? '!' : ' ' );
    1a00:	68bb      	ldr	r3, [r7, #8]
    1a02:	8a1b      	ldrh	r3, [r3, #16]
{
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;

	conn = &uip_conns[s->count];
	return sprintf( ( char * ) uip_appdata,
    1a04:	2b00      	cmp	r3, #0
    1a06:	d002      	beq.n	1a0e <generate_tcp_stats+0xc6>
    1a08:	f04f 022a 	mov.w	r2, #42	; 0x2a
    1a0c:	e001      	b.n	1a12 <generate_tcp_stats+0xca>
    1a0e:	f04f 0220 	mov.w	r2, #32
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
					 htons(conn->ripaddr.u16[0]) >> 8, htons(conn->ripaddr.u16[0]) & 0xff, htons(conn->ripaddr.u16[1]) >> 8,
					 htons(conn->ripaddr.u16[1]) & 0xff, htons(conn->rport), states[conn->tcpstateflags & UIP_TS_MASK], conn->nrtx, conn->timer,
					 (uip_outstanding(conn)) ? '*' : ' ', (uip_stopped(conn)) ? '!' : ' ' );
    1a12:	68bb      	ldr	r3, [r7, #8]
    1a14:	7e5b      	ldrb	r3, [r3, #25]
    1a16:	f003 0310 	and.w	r3, r3, #16
{
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;

	conn = &uip_conns[s->count];
	return sprintf( ( char * ) uip_appdata,
    1a1a:	2b00      	cmp	r3, #0
    1a1c:	d002      	beq.n	1a24 <generate_tcp_stats+0xdc>
    1a1e:	f04f 0321 	mov.w	r3, #33	; 0x21
    1a22:	e001      	b.n	1a28 <generate_tcp_stats+0xe0>
    1a24:	f04f 0320 	mov.w	r3, #32
    1a28:	f8cd 9000 	str.w	r9, [sp]
    1a2c:	f8cd a004 	str.w	sl, [sp, #4]
    1a30:	f8cd 8008 	str.w	r8, [sp, #8]
    1a34:	f8cd e00c 	str.w	lr, [sp, #12]
    1a38:	f8cd c010 	str.w	ip, [sp, #16]
    1a3c:	9005      	str	r0, [sp, #20]
    1a3e:	9106      	str	r1, [sp, #24]
    1a40:	9207      	str	r2, [sp, #28]
    1a42:	9308      	str	r3, [sp, #32]
    1a44:	4630      	mov	r0, r6
    1a46:	f243 117c 	movw	r1, #12668	; 0x317c
    1a4a:	f2c0 0101 	movt	r1, #1
    1a4e:	462a      	mov	r2, r5
    1a50:	4623      	mov	r3, r4
    1a52:	f7ff fb67 	bl	1124 <sprintf>
    1a56:	4603      	mov	r3, r0
    1a58:	b29b      	uxth	r3, r3
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
					 htons(conn->ripaddr.u16[0]) >> 8, htons(conn->ripaddr.u16[0]) & 0xff, htons(conn->ripaddr.u16[1]) >> 8,
					 htons(conn->ripaddr.u16[1]) & 0xff, htons(conn->rport), states[conn->tcpstateflags & UIP_TS_MASK], conn->nrtx, conn->timer,
					 (uip_outstanding(conn)) ? '*' : ' ', (uip_stopped(conn)) ? '!' : ' ' );
}
    1a5a:	4618      	mov	r0, r3
    1a5c:	f107 0710 	add.w	r7, r7, #16
    1a60:	46bd      	mov	sp, r7
    1a62:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1a66:	bf00      	nop

00001a68 <tcp_stats>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( tcp_stats ( struct httpd_state *s, char *ptr ) )
{
    1a68:	b580      	push	{r7, lr}
    1a6a:	b084      	sub	sp, #16
    1a6c:	af00      	add	r7, sp, #0
    1a6e:	6078      	str	r0, [r7, #4]
    1a70:	6039      	str	r1, [r7, #0]
	PSOCK_BEGIN( &s->sout );
    1a72:	f04f 0301 	mov.w	r3, #1
    1a76:	73fb      	strb	r3, [r7, #15]
    1a78:	687b      	ldr	r3, [r7, #4]
    1a7a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    1a7c:	2b00      	cmp	r3, #0
    1a7e:	d002      	beq.n	1a86 <tcp_stats+0x1e>
    1a80:	2b96      	cmp	r3, #150	; 0x96
    1a82:	d01e      	beq.n	1ac2 <tcp_stats+0x5a>
    1a84:	e03c      	b.n	1b00 <tcp_stats+0x98>
	( void ) ptr;
	( void ) PT_YIELD_FLAG;
	for( s->count = 0; s->count < UIP_CONNS; ++s->count )
    1a86:	687b      	ldr	r3, [r7, #4]
    1a88:	f04f 0200 	mov.w	r2, #0
    1a8c:	f8a3 20ac 	strh.w	r2, [r3, #172]	; 0xac
    1a90:	e031      	b.n	1af6 <tcp_stats+0x8e>
	{
		if( (uip_conns[s->count].tcpstateflags & UIP_TS_MASK) != UIP_CLOSED )
    1a92:	687b      	ldr	r3, [r7, #4]
    1a94:	f8b3 30ac 	ldrh.w	r3, [r3, #172]	; 0xac
    1a98:	461a      	mov	r2, r3
    1a9a:	f64a 3370 	movw	r3, #43888	; 0xab70
    1a9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1aa2:	f04f 01cc 	mov.w	r1, #204	; 0xcc
    1aa6:	fb01 f202 	mul.w	r2, r1, r2
    1aaa:	4413      	add	r3, r2
    1aac:	f103 0318 	add.w	r3, r3, #24
    1ab0:	785b      	ldrb	r3, [r3, #1]
    1ab2:	f003 030f 	and.w	r3, r3, #15
    1ab6:	2b00      	cmp	r3, #0
    1ab8:	d014      	beq.n	1ae4 <tcp_stats+0x7c>
		{
			PSOCK_GENERATOR_SEND( &s->sout, generate_tcp_stats, s );
    1aba:	687b      	ldr	r3, [r7, #4]
    1abc:	f04f 0296 	mov.w	r2, #150	; 0x96
    1ac0:	851a      	strh	r2, [r3, #40]	; 0x28
    1ac2:	687b      	ldr	r3, [r7, #4]
    1ac4:	f103 0328 	add.w	r3, r3, #40	; 0x28
    1ac8:	4618      	mov	r0, r3
    1aca:	f641 1149 	movw	r1, #6473	; 0x1949
    1ace:	f2c0 0100 	movt	r1, #0
    1ad2:	687a      	ldr	r2, [r7, #4]
    1ad4:	f006 fa2a 	bl	7f2c <psock_generator_send>
    1ad8:	4603      	mov	r3, r0
    1ada:	2b00      	cmp	r3, #0
    1adc:	d102      	bne.n	1ae4 <tcp_stats+0x7c>
    1ade:	f04f 0300 	mov.w	r3, #0
    1ae2:	e016      	b.n	1b12 <tcp_stats+0xaa>
static PT_THREAD( tcp_stats ( struct httpd_state *s, char *ptr ) )
{
	PSOCK_BEGIN( &s->sout );
	( void ) ptr;
	( void ) PT_YIELD_FLAG;
	for( s->count = 0; s->count < UIP_CONNS; ++s->count )
    1ae4:	687b      	ldr	r3, [r7, #4]
    1ae6:	f8b3 30ac 	ldrh.w	r3, [r3, #172]	; 0xac
    1aea:	f103 0301 	add.w	r3, r3, #1
    1aee:	b29a      	uxth	r2, r3
    1af0:	687b      	ldr	r3, [r7, #4]
    1af2:	f8a3 20ac 	strh.w	r2, [r3, #172]	; 0xac
    1af6:	687b      	ldr	r3, [r7, #4]
    1af8:	f8b3 30ac 	ldrh.w	r3, [r3, #172]	; 0xac
    1afc:	2b27      	cmp	r3, #39	; 0x27
    1afe:	d9c8      	bls.n	1a92 <tcp_stats+0x2a>
		{
			PSOCK_GENERATOR_SEND( &s->sout, generate_tcp_stats, s );
		}
	}

	PSOCK_END( &s->sout );
    1b00:	f04f 0300 	mov.w	r3, #0
    1b04:	73fb      	strb	r3, [r7, #15]
    1b06:	687b      	ldr	r3, [r7, #4]
    1b08:	f04f 0200 	mov.w	r2, #0
    1b0c:	851a      	strh	r2, [r3, #40]	; 0x28
    1b0e:	f04f 0302 	mov.w	r3, #2
}
    1b12:	4618      	mov	r0, r3
    1b14:	f107 0710 	add.w	r7, r7, #16
    1b18:	46bd      	mov	sp, r7
    1b1a:	bd80      	pop	{r7, pc}

00001b1c <generate_net_stats>:

/*---------------------------------------------------------------------------*/
static unsigned short generate_net_stats( void *arg )
{
    1b1c:	b580      	push	{r7, lr}
    1b1e:	b084      	sub	sp, #16
    1b20:	af00      	add	r7, sp, #0
    1b22:	6078      	str	r0, [r7, #4]
	struct httpd_state	*s = ( struct httpd_state * ) arg;
    1b24:	687b      	ldr	r3, [r7, #4]
    1b26:	60fb      	str	r3, [r7, #12]
	return sprintf( ( char * ) uip_appdata, "%5u\n", (( uip_stats_t * ) &uip_stat)[s->count] );
    1b28:	f64a 3368 	movw	r3, #43880	; 0xab68
    1b2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1b30:	681b      	ldr	r3, [r3, #0]
    1b32:	461a      	mov	r2, r3
    1b34:	68fb      	ldr	r3, [r7, #12]
    1b36:	f8b3 30ac 	ldrh.w	r3, [r3, #172]	; 0xac
    1b3a:	ea4f 0143 	mov.w	r1, r3, lsl #1
    1b3e:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    1b42:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1b46:	440b      	add	r3, r1
    1b48:	881b      	ldrh	r3, [r3, #0]
    1b4a:	4610      	mov	r0, r2
    1b4c:	f243 11dc 	movw	r1, #12764	; 0x31dc
    1b50:	f2c0 0101 	movt	r1, #1
    1b54:	461a      	mov	r2, r3
    1b56:	f7ff fae5 	bl	1124 <sprintf>
    1b5a:	4603      	mov	r3, r0
    1b5c:	b29b      	uxth	r3, r3
}
    1b5e:	4618      	mov	r0, r3
    1b60:	f107 0710 	add.w	r7, r7, #16
    1b64:	46bd      	mov	sp, r7
    1b66:	bd80      	pop	{r7, pc}

00001b68 <net_stats>:

static PT_THREAD( net_stats ( struct httpd_state *s, char *ptr ) )
{
    1b68:	b580      	push	{r7, lr}
    1b6a:	b084      	sub	sp, #16
    1b6c:	af00      	add	r7, sp, #0
    1b6e:	6078      	str	r0, [r7, #4]
    1b70:	6039      	str	r1, [r7, #0]
	PSOCK_BEGIN( &s->sout );
    1b72:	f04f 0301 	mov.w	r3, #1
    1b76:	73fb      	strb	r3, [r7, #15]
    1b78:	687b      	ldr	r3, [r7, #4]
    1b7a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    1b7c:	2b00      	cmp	r3, #0
    1b7e:	d002      	beq.n	1b86 <net_stats+0x1e>
    1b80:	2bac      	cmp	r3, #172	; 0xac
    1b82:	d00a      	beq.n	1b9a <net_stats+0x32>
    1b84:	e028      	b.n	1bd8 <net_stats+0x70>
	( void ) ptr;
	( void ) PT_YIELD_FLAG;
#if UIP_STATISTICS
	for( s->count = 0; s->count < sizeof(uip_stat) / sizeof(uip_stats_t); ++s->count )
    1b86:	687b      	ldr	r3, [r7, #4]
    1b88:	f04f 0200 	mov.w	r2, #0
    1b8c:	f8a3 20ac 	strh.w	r2, [r3, #172]	; 0xac
    1b90:	e01d      	b.n	1bce <net_stats+0x66>
	{
		PSOCK_GENERATOR_SEND( &s->sout, generate_net_stats, s );
    1b92:	687b      	ldr	r3, [r7, #4]
    1b94:	f04f 02ac 	mov.w	r2, #172	; 0xac
    1b98:	851a      	strh	r2, [r3, #40]	; 0x28
    1b9a:	687b      	ldr	r3, [r7, #4]
    1b9c:	f103 0328 	add.w	r3, r3, #40	; 0x28
    1ba0:	4618      	mov	r0, r3
    1ba2:	f641 311d 	movw	r1, #6941	; 0x1b1d
    1ba6:	f2c0 0100 	movt	r1, #0
    1baa:	687a      	ldr	r2, [r7, #4]
    1bac:	f006 f9be 	bl	7f2c <psock_generator_send>
    1bb0:	4603      	mov	r3, r0
    1bb2:	2b00      	cmp	r3, #0
    1bb4:	d102      	bne.n	1bbc <net_stats+0x54>
    1bb6:	f04f 0300 	mov.w	r3, #0
    1bba:	e016      	b.n	1bea <net_stats+0x82>
{
	PSOCK_BEGIN( &s->sout );
	( void ) ptr;
	( void ) PT_YIELD_FLAG;
#if UIP_STATISTICS
	for( s->count = 0; s->count < sizeof(uip_stat) / sizeof(uip_stats_t); ++s->count )
    1bbc:	687b      	ldr	r3, [r7, #4]
    1bbe:	f8b3 30ac 	ldrh.w	r3, [r3, #172]	; 0xac
    1bc2:	f103 0301 	add.w	r3, r3, #1
    1bc6:	b29a      	uxth	r2, r3
    1bc8:	687b      	ldr	r3, [r7, #4]
    1bca:	f8a3 20ac 	strh.w	r2, [r3, #172]	; 0xac
    1bce:	687b      	ldr	r3, [r7, #4]
    1bd0:	f8b3 30ac 	ldrh.w	r3, [r3, #172]	; 0xac
    1bd4:	2b1b      	cmp	r3, #27
    1bd6:	d9dc      	bls.n	1b92 <net_stats+0x2a>
		PSOCK_GENERATOR_SEND( &s->sout, generate_net_stats, s );
	}

#endif /* UIP_STATISTICS */

	PSOCK_END( &s->sout );
    1bd8:	f04f 0300 	mov.w	r3, #0
    1bdc:	73fb      	strb	r3, [r7, #15]
    1bde:	687b      	ldr	r3, [r7, #4]
    1be0:	f04f 0200 	mov.w	r2, #0
    1be4:	851a      	strh	r2, [r3, #40]	; 0x28
    1be6:	f04f 0302 	mov.w	r3, #2
}
    1bea:	4618      	mov	r0, r3
    1bec:	f107 0710 	add.w	r7, r7, #16
    1bf0:	46bd      	mov	sp, r7
    1bf2:	bd80      	pop	{r7, pc}

00001bf4 <generate_rtos_stats>:
extern void vTaskList( char *pcWriteBuffer );
extern char *pcGetTaskStatusMessage( void );
static char cCountBuf[128];
long		lRefreshCount = 0;
static unsigned short generate_rtos_stats( void *arg )
{
    1bf4:	b590      	push	{r4, r7, lr}
    1bf6:	b083      	sub	sp, #12
    1bf8:	af00      	add	r7, sp, #0
    1bfa:	6078      	str	r0, [r7, #4]
	( void ) arg;
	lRefreshCount++;
    1bfc:	f240 6384 	movw	r3, #1668	; 0x684
    1c00:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1c04:	681b      	ldr	r3, [r3, #0]
    1c06:	f103 0201 	add.w	r2, r3, #1
    1c0a:	f240 6384 	movw	r3, #1668	; 0x684
    1c0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1c12:	601a      	str	r2, [r3, #0]
	sprintf( cCountBuf, "<p><br>Refresh count = %d<p><br>%s", ( int ) lRefreshCount, pcGetTaskStatusMessage() );
    1c14:	f240 6384 	movw	r3, #1668	; 0x684
    1c18:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1c1c:	681c      	ldr	r4, [r3, #0]
    1c1e:	f7ff f801 	bl	c24 <pcGetTaskStatusMessage>
    1c22:	4603      	mov	r3, r0
    1c24:	f240 6004 	movw	r0, #1540	; 0x604
    1c28:	f2c2 0000 	movt	r0, #8192	; 0x2000
    1c2c:	f243 11e4 	movw	r1, #12772	; 0x31e4
    1c30:	f2c0 0101 	movt	r1, #1
    1c34:	4622      	mov	r2, r4
    1c36:	f7ff fa75 	bl	1124 <sprintf>
	vTaskList( ( char * ) uip_appdata );
    1c3a:	f64a 3368 	movw	r3, #43880	; 0xab68
    1c3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1c42:	681b      	ldr	r3, [r3, #0]
    1c44:	4618      	mov	r0, r3
    1c46:	f00e f8fb 	bl	fe40 <vTaskList>
	strcat( uip_appdata, cCountBuf );
    1c4a:	f64a 3368 	movw	r3, #43880	; 0xab68
    1c4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1c52:	681b      	ldr	r3, [r3, #0]
    1c54:	4618      	mov	r0, r3
    1c56:	f240 6104 	movw	r1, #1540	; 0x604
    1c5a:	f2c2 0100 	movt	r1, #8192	; 0x2000
    1c5e:	f010 f93f 	bl	11ee0 <strcat>

	return strlen( uip_appdata );
    1c62:	f64a 3368 	movw	r3, #43880	; 0xab68
    1c66:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1c6a:	681b      	ldr	r3, [r3, #0]
    1c6c:	4618      	mov	r0, r3
    1c6e:	f010 fa19 	bl	120a4 <strlen>
    1c72:	4603      	mov	r3, r0
    1c74:	b29b      	uxth	r3, r3
}
    1c76:	4618      	mov	r0, r3
    1c78:	f107 070c 	add.w	r7, r7, #12
    1c7c:	46bd      	mov	sp, r7
    1c7e:	bd90      	pop	{r4, r7, pc}

00001c80 <rtos_stats>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( rtos_stats ( struct httpd_state *s, char *ptr ) )
{
    1c80:	b580      	push	{r7, lr}
    1c82:	b084      	sub	sp, #16
    1c84:	af00      	add	r7, sp, #0
    1c86:	6078      	str	r0, [r7, #4]
    1c88:	6039      	str	r1, [r7, #0]
	PSOCK_BEGIN( &s->sout );
    1c8a:	f04f 0301 	mov.w	r3, #1
    1c8e:	73fb      	strb	r3, [r7, #15]
    1c90:	687b      	ldr	r3, [r7, #4]
    1c92:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    1c94:	2b00      	cmp	r3, #0
    1c96:	d002      	beq.n	1c9e <rtos_stats+0x1e>
    1c98:	2bca      	cmp	r3, #202	; 0xca
    1c9a:	d004      	beq.n	1ca6 <rtos_stats+0x26>
    1c9c:	e015      	b.n	1cca <rtos_stats+0x4a>
	( void ) ptr;
	( void ) PT_YIELD_FLAG;
	PSOCK_GENERATOR_SEND( &s->sout, generate_rtos_stats, NULL );
    1c9e:	687b      	ldr	r3, [r7, #4]
    1ca0:	f04f 02ca 	mov.w	r2, #202	; 0xca
    1ca4:	851a      	strh	r2, [r3, #40]	; 0x28
    1ca6:	687b      	ldr	r3, [r7, #4]
    1ca8:	f103 0328 	add.w	r3, r3, #40	; 0x28
    1cac:	4618      	mov	r0, r3
    1cae:	f641 31f5 	movw	r1, #7157	; 0x1bf5
    1cb2:	f2c0 0100 	movt	r1, #0
    1cb6:	f04f 0200 	mov.w	r2, #0
    1cba:	f006 f937 	bl	7f2c <psock_generator_send>
    1cbe:	4603      	mov	r3, r0
    1cc0:	2b00      	cmp	r3, #0
    1cc2:	d102      	bne.n	1cca <rtos_stats+0x4a>
    1cc4:	f04f 0300 	mov.w	r3, #0
    1cc8:	e008      	b.n	1cdc <rtos_stats+0x5c>
	PSOCK_END( &s->sout );
    1cca:	f04f 0300 	mov.w	r3, #0
    1cce:	73fb      	strb	r3, [r7, #15]
    1cd0:	687b      	ldr	r3, [r7, #4]
    1cd2:	f04f 0200 	mov.w	r2, #0
    1cd6:	851a      	strh	r2, [r3, #40]	; 0x28
    1cd8:	f04f 0302 	mov.w	r3, #2
}
    1cdc:	4618      	mov	r0, r3
    1cde:	f107 0710 	add.w	r7, r7, #16
    1ce2:	46bd      	mov	sp, r7
    1ce4:	bd80      	pop	{r7, pc}
    1ce6:	bf00      	nop

00001ce8 <generate_io_state>:
/*---------------------------------------------------------------------------*/
char			*pcStatus;
unsigned long	ulString;

static unsigned short generate_io_state( void *arg )
{
    1ce8:	b580      	push	{r7, lr}
    1cea:	b084      	sub	sp, #16
    1cec:	af00      	add	r7, sp, #0
    1cee:	6078      	str	r0, [r7, #4]
	extern long lParTestGetLEDState( unsigned long ulLED );
	unsigned short usRawVoltage;
	const ace_channel_handle_t xVoltageChannel = ( ace_channel_handle_t ) 0;
    1cf0:	f04f 0300 	mov.w	r3, #0
    1cf4:	73fb      	strb	r3, [r7, #15]

	( void ) arg;

	/* Are the dynamically setable LEDs currently on or off? */
	if( lParTestGetLEDState( 3 ) )
    1cf6:	f04f 0003 	mov.w	r0, #3
    1cfa:	f7fe fcdd 	bl	6b8 <lParTestGetLEDState>
    1cfe:	4603      	mov	r3, r0
    1d00:	2b00      	cmp	r3, #0
    1d02:	d009      	beq.n	1d18 <generate_io_state+0x30>
	{
		pcStatus = "checked";
    1d04:	f64a 1390 	movw	r3, #43408	; 0xa990
    1d08:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1d0c:	f243 2208 	movw	r2, #12808	; 0x3208
    1d10:	f2c0 0201 	movt	r2, #1
    1d14:	601a      	str	r2, [r3, #0]
    1d16:	e008      	b.n	1d2a <generate_io_state+0x42>
	}
	else
	{
		pcStatus = "";
    1d18:	f64a 1390 	movw	r3, #43408	; 0xa990
    1d1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1d20:	f243 2210 	movw	r2, #12816	; 0x3210
    1d24:	f2c0 0201 	movt	r2, #1
    1d28:	601a      	str	r2, [r3, #0]
	}

	usRawVoltage = ( unsigned short ) ACE_get_ppe_sample( xVoltageChannel );
    1d2a:	7bfb      	ldrb	r3, [r7, #15]
    1d2c:	4618      	mov	r0, r3
    1d2e:	f004 fb67 	bl	6400 <ACE_get_ppe_sample>
    1d32:	4603      	mov	r3, r0
    1d34:	81bb      	strh	r3, [r7, #12]
	sprintf( uip_appdata, "<input type=\"checkbox\" name=\"LED0\" value=\"1\" %s>LED<p><p><p>Raw voltage input is %d", pcStatus, usRawVoltage );
    1d36:	f64a 3368 	movw	r3, #43880	; 0xab68
    1d3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1d3e:	681b      	ldr	r3, [r3, #0]
    1d40:	4619      	mov	r1, r3
    1d42:	f64a 1390 	movw	r3, #43408	; 0xa990
    1d46:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1d4a:	681a      	ldr	r2, [r3, #0]
    1d4c:	89bb      	ldrh	r3, [r7, #12]
    1d4e:	4608      	mov	r0, r1
    1d50:	f243 2114 	movw	r1, #12820	; 0x3214
    1d54:	f2c0 0101 	movt	r1, #1
    1d58:	f7ff f9e4 	bl	1124 <sprintf>

	return strlen( uip_appdata );
    1d5c:	f64a 3368 	movw	r3, #43880	; 0xab68
    1d60:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1d64:	681b      	ldr	r3, [r3, #0]
    1d66:	4618      	mov	r0, r3
    1d68:	f010 f99c 	bl	120a4 <strlen>
    1d6c:	4603      	mov	r3, r0
    1d6e:	b29b      	uxth	r3, r3
}
    1d70:	4618      	mov	r0, r3
    1d72:	f107 0710 	add.w	r7, r7, #16
    1d76:	46bd      	mov	sp, r7
    1d78:	bd80      	pop	{r7, pc}
    1d7a:	bf00      	nop

00001d7c <generate_runtime_stats>:

/*---------------------------------------------------------------------------*/
extern void vTaskGetRunTimeStats( char *pcWriteBuffer );
extern unsigned short usMaxJitter;
static unsigned short generate_runtime_stats( void *arg )
{
    1d7c:	b580      	push	{r7, lr}
    1d7e:	b082      	sub	sp, #8
    1d80:	af00      	add	r7, sp, #0
    1d82:	6078      	str	r0, [r7, #4]
	( void ) arg;
	lRefreshCount++;
    1d84:	f240 6384 	movw	r3, #1668	; 0x684
    1d88:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1d8c:	681b      	ldr	r3, [r3, #0]
    1d8e:	f103 0201 	add.w	r2, r3, #1
    1d92:	f240 6384 	movw	r3, #1668	; 0x684
    1d96:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1d9a:	601a      	str	r2, [r3, #0]
	sprintf( cCountBuf, "<p><br>Refresh count = %d", ( int ) lRefreshCount );
    1d9c:	f240 6384 	movw	r3, #1668	; 0x684
    1da0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1da4:	681b      	ldr	r3, [r3, #0]
    1da6:	f240 6004 	movw	r0, #1540	; 0x604
    1daa:	f2c2 0000 	movt	r0, #8192	; 0x2000
    1dae:	f243 2168 	movw	r1, #12904	; 0x3268
    1db2:	f2c0 0101 	movt	r1, #1
    1db6:	461a      	mov	r2, r3
    1db8:	f7ff f9b4 	bl	1124 <sprintf>

	vTaskGetRunTimeStats( ( char * ) uip_appdata );
    1dbc:	f64a 3368 	movw	r3, #43880	; 0xab68
    1dc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1dc4:	681b      	ldr	r3, [r3, #0]
    1dc6:	4618      	mov	r0, r3
    1dc8:	f00e f8f2 	bl	ffb0 <vTaskGetRunTimeStats>
	strcat( uip_appdata, cCountBuf );
    1dcc:	f64a 3368 	movw	r3, #43880	; 0xab68
    1dd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1dd4:	681b      	ldr	r3, [r3, #0]
    1dd6:	4618      	mov	r0, r3
    1dd8:	f240 6104 	movw	r1, #1540	; 0x604
    1ddc:	f2c2 0100 	movt	r1, #8192	; 0x2000
    1de0:	f010 f87e 	bl	11ee0 <strcat>

	return strlen( uip_appdata );
    1de4:	f64a 3368 	movw	r3, #43880	; 0xab68
    1de8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1dec:	681b      	ldr	r3, [r3, #0]
    1dee:	4618      	mov	r0, r3
    1df0:	f010 f958 	bl	120a4 <strlen>
    1df4:	4603      	mov	r3, r0
    1df6:	b29b      	uxth	r3, r3
}
    1df8:	4618      	mov	r0, r3
    1dfa:	f107 0708 	add.w	r7, r7, #8
    1dfe:	46bd      	mov	sp, r7
    1e00:	bd80      	pop	{r7, pc}
    1e02:	bf00      	nop

00001e04 <run_time>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( run_time ( struct httpd_state *s, char *ptr ) )
{
    1e04:	b580      	push	{r7, lr}
    1e06:	b084      	sub	sp, #16
    1e08:	af00      	add	r7, sp, #0
    1e0a:	6078      	str	r0, [r7, #4]
    1e0c:	6039      	str	r1, [r7, #0]
	PSOCK_BEGIN( &s->sout );
    1e0e:	f04f 0301 	mov.w	r3, #1
    1e12:	73fb      	strb	r3, [r7, #15]
    1e14:	687b      	ldr	r3, [r7, #4]
    1e16:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    1e18:	2b00      	cmp	r3, #0
    1e1a:	d002      	beq.n	1e22 <run_time+0x1e>
    1e1c:	2bff      	cmp	r3, #255	; 0xff
    1e1e:	d004      	beq.n	1e2a <run_time+0x26>
    1e20:	e015      	b.n	1e4e <run_time+0x4a>
	( void ) ptr;
	( void ) PT_YIELD_FLAG;
	PSOCK_GENERATOR_SEND( &s->sout, generate_runtime_stats, NULL );
    1e22:	687b      	ldr	r3, [r7, #4]
    1e24:	f04f 02ff 	mov.w	r2, #255	; 0xff
    1e28:	851a      	strh	r2, [r3, #40]	; 0x28
    1e2a:	687b      	ldr	r3, [r7, #4]
    1e2c:	f103 0328 	add.w	r3, r3, #40	; 0x28
    1e30:	4618      	mov	r0, r3
    1e32:	f641 517d 	movw	r1, #7549	; 0x1d7d
    1e36:	f2c0 0100 	movt	r1, #0
    1e3a:	f04f 0200 	mov.w	r2, #0
    1e3e:	f006 f875 	bl	7f2c <psock_generator_send>
    1e42:	4603      	mov	r3, r0
    1e44:	2b00      	cmp	r3, #0
    1e46:	d102      	bne.n	1e4e <run_time+0x4a>
    1e48:	f04f 0300 	mov.w	r3, #0
    1e4c:	e008      	b.n	1e60 <run_time+0x5c>
	PSOCK_END( &s->sout );
    1e4e:	f04f 0300 	mov.w	r3, #0
    1e52:	73fb      	strb	r3, [r7, #15]
    1e54:	687b      	ldr	r3, [r7, #4]
    1e56:	f04f 0200 	mov.w	r2, #0
    1e5a:	851a      	strh	r2, [r3, #40]	; 0x28
    1e5c:	f04f 0302 	mov.w	r3, #2
}
    1e60:	4618      	mov	r0, r3
    1e62:	f107 0710 	add.w	r7, r7, #16
    1e66:	46bd      	mov	sp, r7
    1e68:	bd80      	pop	{r7, pc}
    1e6a:	bf00      	nop

00001e6c <led_io>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( led_io ( struct httpd_state *s, char *ptr ) )
{
    1e6c:	b580      	push	{r7, lr}
    1e6e:	b084      	sub	sp, #16
    1e70:	af00      	add	r7, sp, #0
    1e72:	6078      	str	r0, [r7, #4]
    1e74:	6039      	str	r1, [r7, #0]
	PSOCK_BEGIN( &s->sout );
    1e76:	f04f 0301 	mov.w	r3, #1
    1e7a:	73fb      	strb	r3, [r7, #15]
    1e7c:	687b      	ldr	r3, [r7, #4]
    1e7e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    1e80:	2b00      	cmp	r3, #0
    1e82:	d004      	beq.n	1e8e <led_io+0x22>
    1e84:	f240 1209 	movw	r2, #265	; 0x109
    1e88:	4293      	cmp	r3, r2
    1e8a:	d004      	beq.n	1e96 <led_io+0x2a>
    1e8c:	e015      	b.n	1eba <led_io+0x4e>
	( void ) ptr;
	( void ) PT_YIELD_FLAG;
	PSOCK_GENERATOR_SEND( &s->sout, generate_io_state, NULL );
    1e8e:	687b      	ldr	r3, [r7, #4]
    1e90:	f240 1209 	movw	r2, #265	; 0x109
    1e94:	851a      	strh	r2, [r3, #40]	; 0x28
    1e96:	687b      	ldr	r3, [r7, #4]
    1e98:	f103 0328 	add.w	r3, r3, #40	; 0x28
    1e9c:	4618      	mov	r0, r3
    1e9e:	f641 41e9 	movw	r1, #7401	; 0x1ce9
    1ea2:	f2c0 0100 	movt	r1, #0
    1ea6:	f04f 0200 	mov.w	r2, #0
    1eaa:	f006 f83f 	bl	7f2c <psock_generator_send>
    1eae:	4603      	mov	r3, r0
    1eb0:	2b00      	cmp	r3, #0
    1eb2:	d102      	bne.n	1eba <led_io+0x4e>
    1eb4:	f04f 0300 	mov.w	r3, #0
    1eb8:	e008      	b.n	1ecc <led_io+0x60>
	PSOCK_END( &s->sout );
    1eba:	f04f 0300 	mov.w	r3, #0
    1ebe:	73fb      	strb	r3, [r7, #15]
    1ec0:	687b      	ldr	r3, [r7, #4]
    1ec2:	f04f 0200 	mov.w	r2, #0
    1ec6:	851a      	strh	r2, [r3, #40]	; 0x28
    1ec8:	f04f 0302 	mov.w	r3, #2
}
    1ecc:	4618      	mov	r0, r3
    1ece:	f107 0710 	add.w	r7, r7, #16
    1ed2:	46bd      	mov	sp, r7
    1ed4:	bd80      	pop	{r7, pc}
    1ed6:	bf00      	nop

00001ed8 <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
    1ed8:	b480      	push	{r7}
    1eda:	b083      	sub	sp, #12
    1edc:	af00      	add	r7, sp, #0
    1ede:	4603      	mov	r3, r0
    1ee0:	80fb      	strh	r3, [r7, #6]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    1ee2:	f24e 1300 	movw	r3, #57600	; 0xe100
    1ee6:	f2ce 0300 	movt	r3, #57344	; 0xe000
    1eea:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    1eee:	ea4f 1252 	mov.w	r2, r2, lsr #5
    1ef2:	88f9      	ldrh	r1, [r7, #6]
    1ef4:	f001 011f 	and.w	r1, r1, #31
    1ef8:	f04f 0001 	mov.w	r0, #1
    1efc:	fa00 f101 	lsl.w	r1, r0, r1
    1f00:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    1f04:	f107 070c 	add.w	r7, r7, #12
    1f08:	46bd      	mov	sp, r7
    1f0a:	bc80      	pop	{r7}
    1f0c:	4770      	bx	lr
    1f0e:	bf00      	nop

00001f10 <NVIC_ClearPendingIRQ>:
 *
 * Clear the pending bit for the specified interrupt. 
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
    1f10:	b480      	push	{r7}
    1f12:	b083      	sub	sp, #12
    1f14:	af00      	add	r7, sp, #0
    1f16:	4603      	mov	r3, r0
    1f18:	80fb      	strh	r3, [r7, #6]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    1f1a:	f24e 1300 	movw	r3, #57600	; 0xe100
    1f1e:	f2ce 0300 	movt	r3, #57344	; 0xe000
    1f22:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    1f26:	ea4f 1252 	mov.w	r2, r2, lsr #5
    1f2a:	88f9      	ldrh	r1, [r7, #6]
    1f2c:	f001 011f 	and.w	r1, r1, #31
    1f30:	f04f 0001 	mov.w	r0, #1
    1f34:	fa00 f101 	lsl.w	r1, r0, r1
    1f38:	f102 0260 	add.w	r2, r2, #96	; 0x60
    1f3c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    1f40:	f107 070c 	add.w	r7, r7, #12
    1f44:	46bd      	mov	sp, r7
    1f46:	bc80      	pop	{r7}
    1f48:	4770      	bx	lr
    1f4a:	bf00      	nop

00001f4c <MSS_GPIO_init>:
/*-------------------------------------------------------------------------*//**
 * MSS_GPIO_init
 * See "mss_gpio.h" for details of how to use this function.
 */
void MSS_GPIO_init( void )
{
    1f4c:	b580      	push	{r7, lr}
    1f4e:	b082      	sub	sp, #8
    1f50:	af00      	add	r7, sp, #0
    uint32_t i;
    
    /* reset MSS GPIO hardware */
    SYSREG->SOFT_RST_CR |= SYSREG_GPIO_SOFTRESET_MASK;
    1f52:	f242 0300 	movw	r3, #8192	; 0x2000
    1f56:	f2ce 0304 	movt	r3, #57348	; 0xe004
    1f5a:	f242 0200 	movw	r2, #8192	; 0x2000
    1f5e:	f2ce 0204 	movt	r2, #57348	; 0xe004
    1f62:	6b12      	ldr	r2, [r2, #48]	; 0x30
    1f64:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    1f68:	631a      	str	r2, [r3, #48]	; 0x30
    /* Clear any previously pended MSS GPIO interrupt */
    for ( i = 0U; i < NB_OF_GPIO; ++i )
    1f6a:	f04f 0300 	mov.w	r3, #0
    1f6e:	607b      	str	r3, [r7, #4]
    1f70:	e00e      	b.n	1f90 <MSS_GPIO_init+0x44>
    {
        NVIC_ClearPendingIRQ( g_gpio_irqn_lut[i] );
    1f72:	687a      	ldr	r2, [r7, #4]
    1f74:	f243 434c 	movw	r3, #13388	; 0x344c
    1f78:	f2c0 0301 	movt	r3, #1
    1f7c:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    1f80:	b21b      	sxth	r3, r3
    1f82:	4618      	mov	r0, r3
    1f84:	f7ff ffc4 	bl	1f10 <NVIC_ClearPendingIRQ>
    uint32_t i;
    
    /* reset MSS GPIO hardware */
    SYSREG->SOFT_RST_CR |= SYSREG_GPIO_SOFTRESET_MASK;
    /* Clear any previously pended MSS GPIO interrupt */
    for ( i = 0U; i < NB_OF_GPIO; ++i )
    1f88:	687b      	ldr	r3, [r7, #4]
    1f8a:	f103 0301 	add.w	r3, r3, #1
    1f8e:	607b      	str	r3, [r7, #4]
    1f90:	687b      	ldr	r3, [r7, #4]
    1f92:	2b1f      	cmp	r3, #31
    1f94:	d9ed      	bls.n	1f72 <MSS_GPIO_init+0x26>
    {
        NVIC_ClearPendingIRQ( g_gpio_irqn_lut[i] );
    }
    /* Take MSS GPIO hardware out of reset. */
    SYSREG->SOFT_RST_CR &= ~SYSREG_GPIO_SOFTRESET_MASK;
    1f96:	f242 0300 	movw	r3, #8192	; 0x2000
    1f9a:	f2ce 0304 	movt	r3, #57348	; 0xe004
    1f9e:	f242 0200 	movw	r2, #8192	; 0x2000
    1fa2:	f2ce 0204 	movt	r2, #57348	; 0xe004
    1fa6:	6b12      	ldr	r2, [r2, #48]	; 0x30
    1fa8:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
    1fac:	631a      	str	r2, [r3, #48]	; 0x30
}
    1fae:	f107 0708 	add.w	r7, r7, #8
    1fb2:	46bd      	mov	sp, r7
    1fb4:	bd80      	pop	{r7, pc}
    1fb6:	bf00      	nop

00001fb8 <MSS_GPIO_config>:
void MSS_GPIO_config
(
    mss_gpio_id_t port_id,
    uint32_t config
)
{
    1fb8:	b480      	push	{r7}
    1fba:	b085      	sub	sp, #20
    1fbc:	af00      	add	r7, sp, #0
    1fbe:	4603      	mov	r3, r0
    1fc0:	6039      	str	r1, [r7, #0]
    1fc2:	71fb      	strb	r3, [r7, #7]
    uint32_t gpio_idx = (uint32_t)port_id;
    1fc4:	79fb      	ldrb	r3, [r7, #7]
    1fc6:	60fb      	str	r3, [r7, #12]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
    1fc8:	68fb      	ldr	r3, [r7, #12]
    1fca:	2b1f      	cmp	r3, #31
    1fcc:	d900      	bls.n	1fd0 <MSS_GPIO_config+0x18>
    1fce:	be00      	bkpt	0x0000

    if ( gpio_idx < NB_OF_GPIO )
    1fd0:	68fb      	ldr	r3, [r7, #12]
    1fd2:	2b1f      	cmp	r3, #31
    1fd4:	d808      	bhi.n	1fe8 <MSS_GPIO_config+0x30>
    {
        *(g_config_reg_lut[gpio_idx]) = config;
    1fd6:	68fa      	ldr	r2, [r7, #12]
    1fd8:	f243 33cc 	movw	r3, #13260	; 0x33cc
    1fdc:	f2c0 0301 	movt	r3, #1
    1fe0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    1fe4:	683a      	ldr	r2, [r7, #0]
    1fe6:	601a      	str	r2, [r3, #0]
    }
}
    1fe8:	f107 0714 	add.w	r7, r7, #20
    1fec:	46bd      	mov	sp, r7
    1fee:	bc80      	pop	{r7}
    1ff0:	4770      	bx	lr
    1ff2:	bf00      	nop

00001ff4 <MSS_GPIO_set_output>:
void MSS_GPIO_set_output
(
    mss_gpio_id_t       port_id,
    uint8_t             value
)
{
    1ff4:	b480      	push	{r7}
    1ff6:	b085      	sub	sp, #20
    1ff8:	af00      	add	r7, sp, #0
    1ffa:	4602      	mov	r2, r0
    1ffc:	460b      	mov	r3, r1
    1ffe:	71fa      	strb	r2, [r7, #7]
    2000:	71bb      	strb	r3, [r7, #6]
    uint32_t gpio_idx = (uint32_t)port_id;
    2002:	79fb      	ldrb	r3, [r7, #7]
    2004:	60fb      	str	r3, [r7, #12]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
    2006:	68fb      	ldr	r3, [r7, #12]
    2008:	2b1f      	cmp	r3, #31
    200a:	d900      	bls.n	200e <MAIN_STACK_SIZE+0xe>
    200c:	be00      	bkpt	0x0000
    
    if ( gpio_idx < NB_OF_GPIO )
    200e:	68fb      	ldr	r3, [r7, #12]
    2010:	2b1f      	cmp	r3, #31
    2012:	d809      	bhi.n	2028 <MAIN_STACK_SIZE+0x28>
    {
        GPIO_BITBAND->GPIO_OUT[gpio_idx] = (uint32_t)value;
    2014:	f240 0300 	movw	r3, #0
    2018:	f2c4 2326 	movt	r3, #16934	; 0x4226
    201c:	68fa      	ldr	r2, [r7, #12]
    201e:	79b9      	ldrb	r1, [r7, #6]
    2020:	f502 6288 	add.w	r2, r2, #1088	; 0x440
    2024:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }
}
    2028:	f107 0714 	add.w	r7, r7, #20
    202c:	46bd      	mov	sp, r7
    202e:	bc80      	pop	{r7}
    2030:	4770      	bx	lr
    2032:	bf00      	nop

00002034 <MSS_GPIO_drive_inout>:
void MSS_GPIO_drive_inout
(
    mss_gpio_id_t port_id,
    mss_gpio_inout_state_t inout_state
)
{
    2034:	b480      	push	{r7}
    2036:	b087      	sub	sp, #28
    2038:	af00      	add	r7, sp, #0
    203a:	4602      	mov	r2, r0
    203c:	460b      	mov	r3, r1
    203e:	71fa      	strb	r2, [r7, #7]
    2040:	71bb      	strb	r3, [r7, #6]
    uint32_t outputs_state;
    uint32_t config;
    uint32_t gpio_idx = (uint32_t)port_id;
    2042:	79fb      	ldrb	r3, [r7, #7]
    2044:	617b      	str	r3, [r7, #20]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
    2046:	697b      	ldr	r3, [r7, #20]
    2048:	2b1f      	cmp	r3, #31
    204a:	d900      	bls.n	204e <MSS_GPIO_drive_inout+0x1a>
    204c:	be00      	bkpt	0x0000
    
    if ( gpio_idx < NB_OF_GPIO )
    204e:	697b      	ldr	r3, [r7, #20]
    2050:	2b1f      	cmp	r3, #31
    2052:	d87d      	bhi.n	2150 <MSS_GPIO_drive_inout+0x11c>
    {
        switch( inout_state )
    2054:	79bb      	ldrb	r3, [r7, #6]
    2056:	2b01      	cmp	r3, #1
    2058:	d004      	beq.n	2064 <MSS_GPIO_drive_inout+0x30>
    205a:	2b02      	cmp	r3, #2
    205c:	d060      	beq.n	2120 <MSS_GPIO_drive_inout+0xec>
    205e:	2b00      	cmp	r3, #0
    2060:	d02e      	beq.n	20c0 <MSS_GPIO_drive_inout+0x8c>
    2062:	e074      	b.n	214e <MSS_GPIO_drive_inout+0x11a>
        {
        case MSS_GPIO_DRIVE_HIGH:
            /* Set output high */
            outputs_state = GPIO->GPIO_OUT;
    2064:	f243 0300 	movw	r3, #12288	; 0x3000
    2068:	f2c4 0301 	movt	r3, #16385	; 0x4001
    206c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    2070:	60fb      	str	r3, [r7, #12]
            outputs_state |= (uint32_t)1 << gpio_idx;
    2072:	697b      	ldr	r3, [r7, #20]
    2074:	f04f 0201 	mov.w	r2, #1
    2078:	fa02 f303 	lsl.w	r3, r2, r3
    207c:	68fa      	ldr	r2, [r7, #12]
    207e:	ea42 0303 	orr.w	r3, r2, r3
    2082:	60fb      	str	r3, [r7, #12]
            GPIO->GPIO_OUT = outputs_state;
    2084:	f243 0300 	movw	r3, #12288	; 0x3000
    2088:	f2c4 0301 	movt	r3, #16385	; 0x4001
    208c:	68fa      	ldr	r2, [r7, #12]
    208e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
            /* Enable output buffer */
            config = *(g_config_reg_lut[gpio_idx]);
    2092:	697a      	ldr	r2, [r7, #20]
    2094:	f243 33cc 	movw	r3, #13260	; 0x33cc
    2098:	f2c0 0301 	movt	r3, #1
    209c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    20a0:	681b      	ldr	r3, [r3, #0]
    20a2:	613b      	str	r3, [r7, #16]
            config |= OUTPUT_BUFFER_ENABLE_MASK;
    20a4:	693b      	ldr	r3, [r7, #16]
    20a6:	f043 0304 	orr.w	r3, r3, #4
    20aa:	613b      	str	r3, [r7, #16]
            *(g_config_reg_lut[gpio_idx]) = config;
    20ac:	697a      	ldr	r2, [r7, #20]
    20ae:	f243 33cc 	movw	r3, #13260	; 0x33cc
    20b2:	f2c0 0301 	movt	r3, #1
    20b6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    20ba:	693a      	ldr	r2, [r7, #16]
    20bc:	601a      	str	r2, [r3, #0]
            break;
    20be:	e047      	b.n	2150 <MSS_GPIO_drive_inout+0x11c>
            
        case MSS_GPIO_DRIVE_LOW:
            /* Set output low */
            outputs_state = GPIO->GPIO_OUT;
    20c0:	f243 0300 	movw	r3, #12288	; 0x3000
    20c4:	f2c4 0301 	movt	r3, #16385	; 0x4001
    20c8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    20cc:	60fb      	str	r3, [r7, #12]
            outputs_state &= ~((uint32_t)((uint32_t)1 << gpio_idx));
    20ce:	697b      	ldr	r3, [r7, #20]
    20d0:	f04f 0201 	mov.w	r2, #1
    20d4:	fa02 f303 	lsl.w	r3, r2, r3
    20d8:	ea6f 0303 	mvn.w	r3, r3
    20dc:	68fa      	ldr	r2, [r7, #12]
    20de:	ea02 0303 	and.w	r3, r2, r3
    20e2:	60fb      	str	r3, [r7, #12]
            GPIO->GPIO_OUT = outputs_state;
    20e4:	f243 0300 	movw	r3, #12288	; 0x3000
    20e8:	f2c4 0301 	movt	r3, #16385	; 0x4001
    20ec:	68fa      	ldr	r2, [r7, #12]
    20ee:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
            /* Enable output buffer */
            config = *(g_config_reg_lut[gpio_idx]);
    20f2:	697a      	ldr	r2, [r7, #20]
    20f4:	f243 33cc 	movw	r3, #13260	; 0x33cc
    20f8:	f2c0 0301 	movt	r3, #1
    20fc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    2100:	681b      	ldr	r3, [r3, #0]
    2102:	613b      	str	r3, [r7, #16]
            config |= OUTPUT_BUFFER_ENABLE_MASK;
    2104:	693b      	ldr	r3, [r7, #16]
    2106:	f043 0304 	orr.w	r3, r3, #4
    210a:	613b      	str	r3, [r7, #16]
            *(g_config_reg_lut[gpio_idx]) = config;
    210c:	697a      	ldr	r2, [r7, #20]
    210e:	f243 33cc 	movw	r3, #13260	; 0x33cc
    2112:	f2c0 0301 	movt	r3, #1
    2116:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    211a:	693a      	ldr	r2, [r7, #16]
    211c:	601a      	str	r2, [r3, #0]
            break;
    211e:	e017      	b.n	2150 <MSS_GPIO_drive_inout+0x11c>
            
        case MSS_GPIO_HIGH_Z:
            /* Disable output buffer */
            config = *(g_config_reg_lut[gpio_idx]);
    2120:	697a      	ldr	r2, [r7, #20]
    2122:	f243 33cc 	movw	r3, #13260	; 0x33cc
    2126:	f2c0 0301 	movt	r3, #1
    212a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    212e:	681b      	ldr	r3, [r3, #0]
    2130:	613b      	str	r3, [r7, #16]
            config &= ~OUTPUT_BUFFER_ENABLE_MASK;
    2132:	693b      	ldr	r3, [r7, #16]
    2134:	f023 0304 	bic.w	r3, r3, #4
    2138:	613b      	str	r3, [r7, #16]
            *(g_config_reg_lut[gpio_idx]) = config;
    213a:	697a      	ldr	r2, [r7, #20]
    213c:	f243 33cc 	movw	r3, #13260	; 0x33cc
    2140:	f2c0 0301 	movt	r3, #1
    2144:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    2148:	693a      	ldr	r2, [r7, #16]
    214a:	601a      	str	r2, [r3, #0]
            break;
    214c:	e000      	b.n	2150 <MSS_GPIO_drive_inout+0x11c>
            
        default:
            ASSERT(0);
    214e:	be00      	bkpt	0x0000
            break;
        }
    }
}
    2150:	f107 071c 	add.w	r7, r7, #28
    2154:	46bd      	mov	sp, r7
    2156:	bc80      	pop	{r7}
    2158:	4770      	bx	lr
    215a:	bf00      	nop

0000215c <MSS_GPIO_enable_irq>:
 */
void MSS_GPIO_enable_irq
(
    mss_gpio_id_t port_id
)
{
    215c:	b580      	push	{r7, lr}
    215e:	b084      	sub	sp, #16
    2160:	af00      	add	r7, sp, #0
    2162:	4603      	mov	r3, r0
    2164:	71fb      	strb	r3, [r7, #7]
    uint32_t cfg_value;
    uint32_t gpio_idx = (uint32_t)port_id;
    2166:	79fb      	ldrb	r3, [r7, #7]
    2168:	60fb      	str	r3, [r7, #12]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
    216a:	68fb      	ldr	r3, [r7, #12]
    216c:	2b1f      	cmp	r3, #31
    216e:	d900      	bls.n	2172 <MSS_GPIO_enable_irq+0x16>
    2170:	be00      	bkpt	0x0000
    
    if ( gpio_idx < NB_OF_GPIO )
    2172:	68fb      	ldr	r3, [r7, #12]
    2174:	2b1f      	cmp	r3, #31
    2176:	d81e      	bhi.n	21b6 <MSS_GPIO_enable_irq+0x5a>
    {
        cfg_value = *(g_config_reg_lut[gpio_idx]);
    2178:	68fa      	ldr	r2, [r7, #12]
    217a:	f243 33cc 	movw	r3, #13260	; 0x33cc
    217e:	f2c0 0301 	movt	r3, #1
    2182:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    2186:	681b      	ldr	r3, [r3, #0]
    2188:	60bb      	str	r3, [r7, #8]
        *(g_config_reg_lut[gpio_idx]) = (cfg_value | GPIO_INT_ENABLE_MASK);
    218a:	68fa      	ldr	r2, [r7, #12]
    218c:	f243 33cc 	movw	r3, #13260	; 0x33cc
    2190:	f2c0 0301 	movt	r3, #1
    2194:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    2198:	68ba      	ldr	r2, [r7, #8]
    219a:	f042 0208 	orr.w	r2, r2, #8
    219e:	601a      	str	r2, [r3, #0]
        NVIC_EnableIRQ( g_gpio_irqn_lut[gpio_idx] );
    21a0:	68fa      	ldr	r2, [r7, #12]
    21a2:	f243 434c 	movw	r3, #13388	; 0x344c
    21a6:	f2c0 0301 	movt	r3, #1
    21aa:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    21ae:	b21b      	sxth	r3, r3
    21b0:	4618      	mov	r0, r3
    21b2:	f7ff fe91 	bl	1ed8 <NVIC_EnableIRQ>
    }
}
    21b6:	f107 0710 	add.w	r7, r7, #16
    21ba:	46bd      	mov	sp, r7
    21bc:	bd80      	pop	{r7, pc}
    21be:	bf00      	nop

000021c0 <MSS_GPIO_disable_irq>:
 */
void MSS_GPIO_disable_irq
(
    mss_gpio_id_t port_id
)
{
    21c0:	b480      	push	{r7}
    21c2:	b085      	sub	sp, #20
    21c4:	af00      	add	r7, sp, #0
    21c6:	4603      	mov	r3, r0
    21c8:	71fb      	strb	r3, [r7, #7]
    uint32_t cfg_value;
    uint32_t gpio_idx = (uint32_t)port_id;
    21ca:	79fb      	ldrb	r3, [r7, #7]
    21cc:	60fb      	str	r3, [r7, #12]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
    21ce:	68fb      	ldr	r3, [r7, #12]
    21d0:	2b1f      	cmp	r3, #31
    21d2:	d900      	bls.n	21d6 <MSS_GPIO_disable_irq+0x16>
    21d4:	be00      	bkpt	0x0000

    if ( gpio_idx < NB_OF_GPIO )
    21d6:	68fb      	ldr	r3, [r7, #12]
    21d8:	2b1f      	cmp	r3, #31
    21da:	d813      	bhi.n	2204 <MSS_GPIO_disable_irq+0x44>
    {
        cfg_value = *(g_config_reg_lut[gpio_idx]);
    21dc:	68fa      	ldr	r2, [r7, #12]
    21de:	f243 33cc 	movw	r3, #13260	; 0x33cc
    21e2:	f2c0 0301 	movt	r3, #1
    21e6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    21ea:	681b      	ldr	r3, [r3, #0]
    21ec:	60bb      	str	r3, [r7, #8]
        *(g_config_reg_lut[gpio_idx]) = (cfg_value & ~GPIO_INT_ENABLE_MASK);
    21ee:	68fa      	ldr	r2, [r7, #12]
    21f0:	f243 33cc 	movw	r3, #13260	; 0x33cc
    21f4:	f2c0 0301 	movt	r3, #1
    21f8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    21fc:	68ba      	ldr	r2, [r7, #8]
    21fe:	f022 0208 	bic.w	r2, r2, #8
    2202:	601a      	str	r2, [r3, #0]
    }
}
    2204:	f107 0714 	add.w	r7, r7, #20
    2208:	46bd      	mov	sp, r7
    220a:	bc80      	pop	{r7}
    220c:	4770      	bx	lr
    220e:	bf00      	nop

00002210 <MSS_GPIO_clear_irq>:
 */
void MSS_GPIO_clear_irq
(
    mss_gpio_id_t port_id
)
{
    2210:	b580      	push	{r7, lr}
    2212:	b084      	sub	sp, #16
    2214:	af00      	add	r7, sp, #0
    2216:	4603      	mov	r3, r0
    2218:	71fb      	strb	r3, [r7, #7]
    uint32_t gpio_idx = (uint32_t)port_id;
    221a:	79fb      	ldrb	r3, [r7, #7]
    221c:	60fb      	str	r3, [r7, #12]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
    221e:	68fb      	ldr	r3, [r7, #12]
    2220:	2b1f      	cmp	r3, #31
    2222:	d900      	bls.n	2226 <MSS_GPIO_clear_irq+0x16>
    2224:	be00      	bkpt	0x0000
    
    if ( gpio_idx < NB_OF_GPIO )
    2226:	68fb      	ldr	r3, [r7, #12]
    2228:	2b1f      	cmp	r3, #31
    222a:	d815      	bhi.n	2258 <MSS_GPIO_clear_irq+0x48>
    {
        GPIO->GPIO_IRQ = ((uint32_t)1) << gpio_idx;
    222c:	f243 0300 	movw	r3, #12288	; 0x3000
    2230:	f2c4 0301 	movt	r3, #16385	; 0x4001
    2234:	68fa      	ldr	r2, [r7, #12]
    2236:	f04f 0101 	mov.w	r1, #1
    223a:	fa01 f202 	lsl.w	r2, r1, r2
    223e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
        NVIC_ClearPendingIRQ( g_gpio_irqn_lut[gpio_idx] );
    2242:	68fa      	ldr	r2, [r7, #12]
    2244:	f243 434c 	movw	r3, #13388	; 0x344c
    2248:	f2c0 0301 	movt	r3, #1
    224c:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    2250:	b21b      	sxth	r3, r3
    2252:	4618      	mov	r0, r3
    2254:	f7ff fe5c 	bl	1f10 <NVIC_ClearPendingIRQ>
    }
}
    2258:	f107 0710 	add.w	r7, r7, #16
    225c:	46bd      	mov	sp, r7
    225e:	bd80      	pop	{r7, pc}

00002260 <mss_mac_crc32>:
(
    uint32_t value,
    const uint8_t *data,
    uint32_t data_length
)
{
    2260:	b480      	push	{r7}
    2262:	b087      	sub	sp, #28
    2264:	af00      	add	r7, sp, #0
    2266:	60f8      	str	r0, [r7, #12]
    2268:	60b9      	str	r1, [r7, #8]
    226a:	607a      	str	r2, [r7, #4]
  uint32_t a;
  
  for(a=0; a<data_length; a++) {
    226c:	f04f 0300 	mov.w	r3, #0
    2270:	617b      	str	r3, [r7, #20]
    2272:	e019      	b.n	22a8 <mss_mac_crc32+0x48>
	value = crc32_table[(value ^ data[a]) & 0xff] ^ (value >> 8);
    2274:	68ba      	ldr	r2, [r7, #8]
    2276:	697b      	ldr	r3, [r7, #20]
    2278:	4413      	add	r3, r2
    227a:	781b      	ldrb	r3, [r3, #0]
    227c:	461a      	mov	r2, r3
    227e:	68fb      	ldr	r3, [r7, #12]
    2280:	ea82 0303 	eor.w	r3, r2, r3
    2284:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    2288:	f243 438c 	movw	r3, #13452	; 0x348c
    228c:	f2c0 0301 	movt	r3, #1
    2290:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    2294:	68fb      	ldr	r3, [r7, #12]
    2296:	ea4f 2313 	mov.w	r3, r3, lsr #8
    229a:	ea82 0303 	eor.w	r3, r2, r3
    229e:	60fb      	str	r3, [r7, #12]
    uint32_t data_length
)
{
  uint32_t a;
  
  for(a=0; a<data_length; a++) {
    22a0:	697b      	ldr	r3, [r7, #20]
    22a2:	f103 0301 	add.w	r3, r3, #1
    22a6:	617b      	str	r3, [r7, #20]
    22a8:	697a      	ldr	r2, [r7, #20]
    22aa:	687b      	ldr	r3, [r7, #4]
    22ac:	429a      	cmp	r2, r3
    22ae:	d3e1      	bcc.n	2274 <mss_mac_crc32+0x14>
	value = crc32_table[(value ^ data[a]) & 0xff] ^ (value >> 8);
  }
  
  return value;
    22b0:	68fb      	ldr	r3, [r7, #12]
}
    22b2:	4618      	mov	r0, r3
    22b4:	f107 071c 	add.w	r7, r7, #28
    22b8:	46bd      	mov	sp, r7
    22ba:	bc80      	pop	{r7}
    22bc:	4770      	bx	lr
    22be:	bf00      	nop

000022c0 <mss_ethernet_crc>:
mss_ethernet_crc
(
    const uint8_t *data,
    uint32_t data_length
)
{
    22c0:	b580      	push	{r7, lr}
    22c2:	b082      	sub	sp, #8
    22c4:	af00      	add	r7, sp, #0
    22c6:	6078      	str	r0, [r7, #4]
    22c8:	6039      	str	r1, [r7, #0]
	return mss_mac_crc32( 0xffffffffUL, data, data_length );
    22ca:	f04f 30ff 	mov.w	r0, #4294967295
    22ce:	6879      	ldr	r1, [r7, #4]
    22d0:	683a      	ldr	r2, [r7, #0]
    22d2:	f7ff ffc5 	bl	2260 <mss_mac_crc32>
    22d6:	4603      	mov	r3, r0
}
    22d8:	4618      	mov	r0, r3
    22da:	f107 0708 	add.w	r7, r7, #8
    22de:	46bd      	mov	sp, r7
    22e0:	bd80      	pop	{r7, pc}
    22e2:	bf00      	nop

000022e4 <MSS_MAC_init>:
void
MSS_MAC_init
(
	uint8_t phy_address
)
{
    22e4:	b580      	push	{r7, lr}
    22e6:	b08a      	sub	sp, #40	; 0x28
    22e8:	af00      	add	r7, sp, #0
    22ea:	4603      	mov	r3, r0
    22ec:	71fb      	strb	r3, [r7, #7]
    const uint8_t mac_address[6] = { DEFAULT_MAC_ADDRESS };
    22ee:	f643 12dc 	movw	r2, #14812	; 0x39dc
    22f2:	f2c0 0201 	movt	r2, #1
    22f6:	f107 030c 	add.w	r3, r7, #12
    22fa:	e892 0003 	ldmia.w	r2, {r0, r1}
    22fe:	6018      	str	r0, [r3, #0]
    2300:	f103 0304 	add.w	r3, r3, #4
    2304:	8019      	strh	r1, [r3, #0]
    int32_t a;

	/* To start with all buffers are free. */
	for( a = 0; a < macNUM_BUFFERS; a++ )
    2306:	f04f 0300 	mov.w	r3, #0
    230a:	617b      	str	r3, [r7, #20]
    230c:	e00b      	b.n	2326 <MSS_MAC_init+0x42>
	{
		ucMACBufferInUse[ a ] = pdFALSE;
    230e:	697a      	ldr	r2, [r7, #20]
    2310:	f642 7344 	movw	r3, #12100	; 0x2f44
    2314:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2318:	f04f 0100 	mov.w	r1, #0
    231c:	5499      	strb	r1, [r3, r2]
{
    const uint8_t mac_address[6] = { DEFAULT_MAC_ADDRESS };
    int32_t a;

	/* To start with all buffers are free. */
	for( a = 0; a < macNUM_BUFFERS; a++ )
    231e:	697b      	ldr	r3, [r7, #20]
    2320:	f103 0301 	add.w	r3, r3, #1
    2324:	617b      	str	r3, [r7, #20]
    2326:	697b      	ldr	r3, [r7, #20]
    2328:	2b06      	cmp	r3, #6
    232a:	ddf0      	ble.n	230e <MSS_MAC_init+0x2a>
	{
		ucMACBufferInUse[ a ] = pdFALSE;
	}
	
    /* Try to reset chip */
    MAC_BITBAND->CSR0_SWR = 1u;
    232c:	f240 0300 	movw	r3, #0
    2330:	f2c4 2306 	movt	r3, #16902	; 0x4206
    2334:	f04f 0201 	mov.w	r2, #1
    2338:	601a      	str	r2, [r3, #0]

    do
    {
    	vTaskDelay( 10 );
    233a:	f04f 000a 	mov.w	r0, #10
    233e:	f00b ff05 	bl	e14c <vTaskDelay>
    } while ( 1u == MAC_BITBAND->CSR0_SWR );
    2342:	f240 0300 	movw	r3, #0
    2346:	f2c4 2306 	movt	r3, #16902	; 0x4206
    234a:	681b      	ldr	r3, [r3, #0]
    234c:	2b01      	cmp	r3, #1
    234e:	d0f4      	beq.n	233a <MSS_MAC_init+0x56>

    /* Check reset values of some registers to constrol
     * base address validity */
    configASSERT( MAC->CSR0 == 0xFE000000uL );
    2350:	f243 0300 	movw	r3, #12288	; 0x3000
    2354:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2358:	681b      	ldr	r3, [r3, #0]
    235a:	f1b3 4f7e 	cmp.w	r3, #4261412864	; 0xfe000000
    235e:	d009      	beq.n	2374 <MSS_MAC_init+0x90>
    2360:	f04f 0328 	mov.w	r3, #40	; 0x28
    2364:	f383 8811 	msr	BASEPRI, r3
    2368:	f3bf 8f6f 	isb	sy
    236c:	f3bf 8f4f 	dsb	sy
    2370:	61bb      	str	r3, [r7, #24]
    2372:	e7fe      	b.n	2372 <MSS_MAC_init+0x8e>
    configASSERT( MAC->CSR5 == 0xF0000000uL );
    2374:	f243 0300 	movw	r3, #12288	; 0x3000
    2378:	f2c4 0300 	movt	r3, #16384	; 0x4000
    237c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    237e:	f1b3 4f70 	cmp.w	r3, #4026531840	; 0xf0000000
    2382:	d009      	beq.n	2398 <MSS_MAC_init+0xb4>
    2384:	f04f 0328 	mov.w	r3, #40	; 0x28
    2388:	f383 8811 	msr	BASEPRI, r3
    238c:	f3bf 8f6f 	isb	sy
    2390:	f3bf 8f4f 	dsb	sy
    2394:	61fb      	str	r3, [r7, #28]
    2396:	e7fe      	b.n	2396 <MSS_MAC_init+0xb2>
    configASSERT( MAC->CSR6 == 0x32000040uL );
    2398:	f243 0300 	movw	r3, #12288	; 0x3000
    239c:	f2c4 0300 	movt	r3, #16384	; 0x4000
    23a0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    23a2:	f240 0340 	movw	r3, #64	; 0x40
    23a6:	f2c3 2300 	movt	r3, #12800	; 0x3200
    23aa:	429a      	cmp	r2, r3
    23ac:	d009      	beq.n	23c2 <MSS_MAC_init+0xde>
    23ae:	f04f 0328 	mov.w	r3, #40	; 0x28
    23b2:	f383 8811 	msr	BASEPRI, r3
    23b6:	f3bf 8f6f 	isb	sy
    23ba:	f3bf 8f4f 	dsb	sy
    23be:	623b      	str	r3, [r7, #32]
    23c0:	e7fe      	b.n	23c0 <MSS_MAC_init+0xdc>

    /* Instance setup */
    MAC_memset_All( &g_mss_mac, 0u );
    23c2:	f64a 1094 	movw	r0, #43412	; 0xa994
    23c6:	f2c2 0000 	movt	r0, #8192	; 0x2000
    23ca:	f04f 0100 	mov.w	r1, #0
    23ce:	f002 f857 	bl	4480 <MAC_memset_All>

    g_mss_mac.base_address = MAC_BASE;
    23d2:	f64a 1394 	movw	r3, #43412	; 0xa994
    23d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    23da:	f243 0200 	movw	r2, #12288	; 0x3000
    23de:	f2c4 0200 	movt	r2, #16384	; 0x4000
    23e2:	601a      	str	r2, [r3, #0]
    g_mss_mac.phy_address = phy_address;
    23e4:	f64a 1394 	movw	r3, #43412	; 0xa994
    23e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    23ec:	79fa      	ldrb	r2, [r7, #7]
    23ee:	f883 20e8 	strb.w	r2, [r3, #232]	; 0xe8

    for( a=0; a<RX_RING_SIZE; a++ )
    23f2:	f04f 0300 	mov.w	r3, #0
    23f6:	617b      	str	r3, [r7, #20]
    23f8:	e03b      	b.n	2472 <MSS_MAC_init+0x18e>
    {
        /* Give the ownership to the MAC */
        g_mss_mac.rx_descriptors[a].descriptor_0 = RDES0_OWN;
    23fa:	697a      	ldr	r2, [r7, #20]
    23fc:	f64a 1394 	movw	r3, #43412	; 0xa994
    2400:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2404:	ea4f 1202 	mov.w	r2, r2, lsl #4
    2408:	4413      	add	r3, r2
    240a:	f103 0398 	add.w	r3, r3, #152	; 0x98
    240e:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    2412:	601a      	str	r2, [r3, #0]
        g_mss_mac.rx_descriptors[a].descriptor_1 = (MSS_RX_BUFF_SIZE << RDES1_RBS1_OFFSET);
    2414:	697a      	ldr	r2, [r7, #20]
    2416:	f64a 1394 	movw	r3, #43412	; 0xa994
    241a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    241e:	ea4f 1202 	mov.w	r2, r2, lsl #4
    2422:	4413      	add	r3, r2
    2424:	f103 039c 	add.w	r3, r3, #156	; 0x9c
    2428:	f44f 62be 	mov.w	r2, #1520	; 0x5f0
    242c:	601a      	str	r2, [r3, #0]
		
		/* Allocate a buffer to the descriptor, then mark the buffer as in use
		(not free). */
        g_mss_mac.rx_descriptors[a].buffer_1 = ( unsigned long ) &( xMACBuffers.ucBuffer[ a ][ 0 ] );
    242e:	6979      	ldr	r1, [r7, #20]
    2430:	f240 6394 	movw	r3, #1684	; 0x694
    2434:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2438:	697a      	ldr	r2, [r7, #20]
    243a:	f44f 60ba 	mov.w	r0, #1488	; 0x5d0
    243e:	fb00 f202 	mul.w	r2, r0, r2
    2442:	4413      	add	r3, r2
    2444:	461a      	mov	r2, r3
    2446:	f64a 1394 	movw	r3, #43412	; 0xa994
    244a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    244e:	f101 010a 	add.w	r1, r1, #10
    2452:	ea4f 1101 	mov.w	r1, r1, lsl #4
    2456:	440b      	add	r3, r1
    2458:	601a      	str	r2, [r3, #0]
		ucMACBufferInUse[ a ] = pdTRUE;
    245a:	697a      	ldr	r2, [r7, #20]
    245c:	f642 7344 	movw	r3, #12100	; 0x2f44
    2460:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2464:	f04f 0101 	mov.w	r1, #1
    2468:	5499      	strb	r1, [r3, r2]
    MAC_memset_All( &g_mss_mac, 0u );

    g_mss_mac.base_address = MAC_BASE;
    g_mss_mac.phy_address = phy_address;

    for( a=0; a<RX_RING_SIZE; a++ )
    246a:	697b      	ldr	r3, [r7, #20]
    246c:	f103 0301 	add.w	r3, r3, #1
    2470:	617b      	str	r3, [r7, #20]
    2472:	697b      	ldr	r3, [r7, #20]
    2474:	2b04      	cmp	r3, #4
    2476:	ddc0      	ble.n	23fa <MSS_MAC_init+0x116>
		/* Allocate a buffer to the descriptor, then mark the buffer as in use
		(not free). */
        g_mss_mac.rx_descriptors[a].buffer_1 = ( unsigned long ) &( xMACBuffers.ucBuffer[ a ][ 0 ] );
		ucMACBufferInUse[ a ] = pdTRUE;
    }
    g_mss_mac.rx_descriptors[RX_RING_SIZE-1].descriptor_1 |= RDES1_RER;
    2478:	f64a 1394 	movw	r3, #43412	; 0xa994
    247c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2480:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
    2484:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
    2488:	f64a 1394 	movw	r3, #43412	; 0xa994
    248c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2490:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc

    for( a = 0; a < TX_RING_SIZE; a++ )
    2494:	f04f 0300 	mov.w	r3, #0
    2498:	617b      	str	r3, [r7, #20]
    249a:	e010      	b.n	24be <MSS_MAC_init+0x1da>
    {
		/* Buffers only get allocated to the Tx buffers when something is
		actually tranmitted. */
        g_mss_mac.tx_descriptors[a].buffer_1 = ( unsigned long ) NULL;
    249c:	697a      	ldr	r2, [r7, #20]
    249e:	f64a 1394 	movw	r3, #43412	; 0xa994
    24a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    24a6:	ea4f 1202 	mov.w	r2, r2, lsl #4
    24aa:	4413      	add	r3, r2
    24ac:	f103 037c 	add.w	r3, r3, #124	; 0x7c
    24b0:	f04f 0200 	mov.w	r2, #0
    24b4:	601a      	str	r2, [r3, #0]
        g_mss_mac.rx_descriptors[a].buffer_1 = ( unsigned long ) &( xMACBuffers.ucBuffer[ a ][ 0 ] );
		ucMACBufferInUse[ a ] = pdTRUE;
    }
    g_mss_mac.rx_descriptors[RX_RING_SIZE-1].descriptor_1 |= RDES1_RER;

    for( a = 0; a < TX_RING_SIZE; a++ )
    24b6:	697b      	ldr	r3, [r7, #20]
    24b8:	f103 0301 	add.w	r3, r3, #1
    24bc:	617b      	str	r3, [r7, #20]
    24be:	697b      	ldr	r3, [r7, #20]
    24c0:	2b01      	cmp	r3, #1
    24c2:	ddeb      	ble.n	249c <MSS_MAC_init+0x1b8>
    {
		/* Buffers only get allocated to the Tx buffers when something is
		actually tranmitted. */
        g_mss_mac.tx_descriptors[a].buffer_1 = ( unsigned long ) NULL;
    }
    g_mss_mac.tx_descriptors[TX_RING_SIZE - 1].descriptor_1 |= TDES1_TER;
    24c4:	f64a 1394 	movw	r3, #43412	; 0xa994
    24c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    24cc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    24d0:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
    24d4:	f64a 1394 	movw	r3, #43412	; 0xa994
    24d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    24dc:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

    /* Configurable settings */
    MAC_BITBAND->CSR0_DBO = DESCRIPTOR_BYTE_ORDERING_MODE;
    24e0:	f240 0300 	movw	r3, #0
    24e4:	f2c4 2306 	movt	r3, #16902	; 0x4206
    24e8:	f04f 0200 	mov.w	r2, #0
    24ec:	651a      	str	r2, [r3, #80]	; 0x50
    MAC->CSR0 = (MAC->CSR0 & ~CSR0_PBL_MASK) | ((uint32_t)PROGRAMMABLE_BURST_LENGTH << CSR0_PBL_SHIFT);
    24ee:	f243 0300 	movw	r3, #12288	; 0x3000
    24f2:	f2c4 0300 	movt	r3, #16384	; 0x4000
    24f6:	f243 0200 	movw	r2, #12288	; 0x3000
    24fa:	f2c4 0200 	movt	r2, #16384	; 0x4000
    24fe:	6812      	ldr	r2, [r2, #0]
    2500:	f422 527c 	bic.w	r2, r2, #16128	; 0x3f00
    2504:	601a      	str	r2, [r3, #0]
    MAC_BITBAND->CSR0_BLE = BUFFER_BYTE_ORDERING_MODE;
    2506:	f240 0300 	movw	r3, #0
    250a:	f2c4 2306 	movt	r3, #16902	; 0x4206
    250e:	f04f 0200 	mov.w	r2, #0
    2512:	61da      	str	r2, [r3, #28]
    MAC_BITBAND->CSR0_BAR = (uint32_t)BUS_ARBITRATION_SCHEME;
    2514:	f240 0300 	movw	r3, #0
    2518:	f2c4 2306 	movt	r3, #16902	; 0x4206
    251c:	f04f 0200 	mov.w	r2, #0
    2520:	605a      	str	r2, [r3, #4]

    /* Fixed settings */
    /* No space between descriptors */
    MAC->CSR0 = MAC->CSR0 &~ CSR0_DSL_MASK;
    2522:	f243 0300 	movw	r3, #12288	; 0x3000
    2526:	f2c4 0300 	movt	r3, #16384	; 0x4000
    252a:	f243 0200 	movw	r2, #12288	; 0x3000
    252e:	f2c4 0200 	movt	r2, #16384	; 0x4000
    2532:	6812      	ldr	r2, [r2, #0]
    2534:	f022 027c 	bic.w	r2, r2, #124	; 0x7c
    2538:	601a      	str	r2, [r3, #0]
    /* General-purpose timer works in continuous mode */
    MAC_BITBAND->CSR11_CON = 1u;
    253a:	f240 0300 	movw	r3, #0
    253e:	f2c4 2306 	movt	r3, #16902	; 0x4206
    2542:	f04f 0201 	mov.w	r2, #1
    2546:	f8c3 2b40 	str.w	r2, [r3, #2880]	; 0xb40
    /* Start general-purpose */
    MAC->CSR11 =  (MAC->CSR11 & ~CSR11_TIM_MASK) | (0x0000FFFFuL << CSR11_TIM_SHIFT);
    254a:	f243 0300 	movw	r3, #12288	; 0x3000
    254e:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2552:	f243 0200 	movw	r2, #12288	; 0x3000
    2556:	f2c4 0200 	movt	r2, #16384	; 0x4000
    255a:	6d92      	ldr	r2, [r2, #88]	; 0x58
    255c:	ea6f 4212 	mvn.w	r2, r2, lsr #16
    2560:	ea6f 4202 	mvn.w	r2, r2, lsl #16
    2564:	659a      	str	r2, [r3, #88]	; 0x58

	/* Ensure promiscous mode is off (it should be by default anyway). */
	MAC_BITBAND->CSR6_PR = 0;
    2566:	f240 0300 	movw	r3, #0
    256a:	f2c4 2306 	movt	r3, #16902	; 0x4206
    256e:	f04f 0200 	mov.w	r2, #0
    2572:	f8c3 2618 	str.w	r2, [r3, #1560]	; 0x618
	
	/* Perfect filter. */
	MAC_BITBAND->CSR6_HP = 1;
    2576:	f240 0300 	movw	r3, #0
    257a:	f2c4 2306 	movt	r3, #16902	; 0x4206
    257e:	f04f 0201 	mov.w	r2, #1
    2582:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
	
	/* Pass multcast. */
	MAC_BITBAND->CSR6_PM = 1;
    2586:	f240 0300 	movw	r3, #0
    258a:	f2c4 2306 	movt	r3, #16902	; 0x4206
    258e:	f04f 0201 	mov.w	r2, #1
    2592:	f8c3 261c 	str.w	r2, [r3, #1564]	; 0x61c
	
    /* Set descriptors */
    MAC->CSR3 = (uint32_t)&(g_mss_mac.rx_descriptors[0].descriptor_0);
    2596:	f243 0300 	movw	r3, #12288	; 0x3000
    259a:	f2c4 0300 	movt	r3, #16384	; 0x4000
    259e:	4a24      	ldr	r2, [pc, #144]	; (2630 <MSS_MAC_init+0x34c>)
    25a0:	619a      	str	r2, [r3, #24]
    MAC->CSR4 = (uint32_t)&(g_mss_mac.tx_descriptors[0].descriptor_0);
    25a2:	f243 0300 	movw	r3, #12288	; 0x3000
    25a6:	f2c4 0300 	movt	r3, #16384	; 0x4000
    25aa:	4a22      	ldr	r2, [pc, #136]	; (2634 <MSS_MAC_init+0x350>)
    25ac:	621a      	str	r2, [r3, #32]

	/* enable normal interrupts */
    MAC_BITBAND->CSR7_NIE = 1u;
    25ae:	f240 0300 	movw	r3, #0
    25b2:	f2c4 2306 	movt	r3, #16902	; 0x4206
    25b6:	f04f 0201 	mov.w	r2, #1
    25ba:	f8c3 2740 	str.w	r2, [r3, #1856]	; 0x740

    /* Set default MAC address and reset mac filters */
   	MAC_memcpy( g_mss_mac.mac_address, mac_address, 6u );
    25be:	f107 030c 	add.w	r3, r7, #12
    25c2:	481d      	ldr	r0, [pc, #116]	; (2638 <MSS_MAC_init+0x354>)
    25c4:	4619      	mov	r1, r3
    25c6:	f04f 0206 	mov.w	r2, #6
    25ca:	f002 f97d 	bl	48c8 <MAC_memcpy>
 	MSS_MAC_set_mac_address((uint8_t *)mac_address);
    25ce:	f107 030c 	add.w	r3, r7, #12
    25d2:	4618      	mov	r0, r3
    25d4:	f000 fe66 	bl	32a4 <MSS_MAC_set_mac_address>
	
    /* Detect PHY */
    if( g_mss_mac.phy_address > MSS_PHY_ADDRESS_MAX )
    25d8:	f64a 1394 	movw	r3, #43412	; 0xa994
    25dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    25e0:	f893 30e8 	ldrb.w	r3, [r3, #232]	; 0xe8
    25e4:	2b1f      	cmp	r3, #31
    25e6:	d913      	bls.n	2610 <MSS_MAC_init+0x32c>
    {
    	PHY_probe();
    25e8:	f002 fbd2 	bl	4d90 <PHY_probe>
    	configASSERT( g_mss_mac.phy_address <= MSS_PHY_ADDRESS_MAX );
    25ec:	f64a 1394 	movw	r3, #43412	; 0xa994
    25f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    25f4:	f893 30e8 	ldrb.w	r3, [r3, #232]	; 0xe8
    25f8:	2b1f      	cmp	r3, #31
    25fa:	d909      	bls.n	2610 <MSS_MAC_init+0x32c>
    25fc:	f04f 0328 	mov.w	r3, #40	; 0x28
    2600:	f383 8811 	msr	BASEPRI, r3
    2604:	f3bf 8f6f 	isb	sy
    2608:	f3bf 8f4f 	dsb	sy
    260c:	627b      	str	r3, [r7, #36]	; 0x24
    260e:	e7fe      	b.n	260e <MSS_MAC_init+0x32a>
    }

    /* Reset PHY */
    PHY_reset();
    2610:	f002 fc00 	bl	4e14 <PHY_reset>

	/* Configure chip according to PHY status */
    MSS_MAC_auto_setup_link();
    2614:	f000 fdde 	bl	31d4 <MSS_MAC_auto_setup_link>
	
	/* Ensure uip_buf starts by pointing somewhere. */
	uip_buf = MAC_obtain_buffer();	
    2618:	f002 f9b8 	bl	498c <MAC_obtain_buffer>
    261c:	4602      	mov	r2, r0
    261e:	f240 6390 	movw	r3, #1680	; 0x690
    2622:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2626:	601a      	str	r2, [r3, #0]
}
    2628:	f107 0728 	add.w	r7, r7, #40	; 0x28
    262c:	46bd      	mov	sp, r7
    262e:	bd80      	pop	{r7, pc}
    2630:	2000aa2c 	.word	0x2000aa2c
    2634:	2000aa08 	.word	0x2000aa08
    2638:	2000a99a 	.word	0x2000a99a

0000263c <MSS_MAC_configure>:
void
MSS_MAC_configure
(
    uint32_t configuration
)
{
    263c:	b580      	push	{r7, lr}
    263e:	b086      	sub	sp, #24
    2640:	af00      	add	r7, sp, #0
    2642:	6078      	str	r0, [r7, #4]
    int32_t ret;

    ret = MAC_stop_transmission();
    2644:	f001 fd90 	bl	4168 <MAC_stop_transmission>
    2648:	4603      	mov	r3, r0
    264a:	60fb      	str	r3, [r7, #12]
    configASSERT( ret == MAC_OK );
    264c:	68fb      	ldr	r3, [r7, #12]
    264e:	2b00      	cmp	r3, #0
    2650:	d009      	beq.n	2666 <MSS_MAC_configure+0x2a>
    2652:	f04f 0328 	mov.w	r3, #40	; 0x28
    2656:	f383 8811 	msr	BASEPRI, r3
    265a:	f3bf 8f6f 	isb	sy
    265e:	f3bf 8f4f 	dsb	sy
    2662:	613b      	str	r3, [r7, #16]
    2664:	e7fe      	b.n	2664 <MSS_MAC_configure+0x28>

    ret = MAC_stop_receiving();
    2666:	f001 fdbd 	bl	41e4 <MAC_stop_receiving>
    266a:	4603      	mov	r3, r0
    266c:	60fb      	str	r3, [r7, #12]
    configASSERT( ret == MAC_OK );
    266e:	68fb      	ldr	r3, [r7, #12]
    2670:	2b00      	cmp	r3, #0
    2672:	d009      	beq.n	2688 <MSS_MAC_configure+0x4c>
    2674:	f04f 0328 	mov.w	r3, #40	; 0x28
    2678:	f383 8811 	msr	BASEPRI, r3
    267c:	f3bf 8f6f 	isb	sy
    2680:	f3bf 8f4f 	dsb	sy
    2684:	617b      	str	r3, [r7, #20]
    2686:	e7fe      	b.n	2686 <MSS_MAC_configure+0x4a>

    MAC_BITBAND->CSR6_RA = (uint32_t)(((configuration & MSS_MAC_CFG_RECEIVE_ALL) != 0u) ? 1u : 0u );
    2688:	f240 0300 	movw	r3, #0
    268c:	f2c4 2306 	movt	r3, #16902	; 0x4206
    2690:	687a      	ldr	r2, [r7, #4]
    2692:	f002 0201 	and.w	r2, r2, #1
    2696:	b2d2      	uxtb	r2, r2
    2698:	2a00      	cmp	r2, #0
    269a:	d002      	beq.n	26a2 <MSS_MAC_configure+0x66>
    269c:	f04f 0201 	mov.w	r2, #1
    26a0:	e001      	b.n	26a6 <MSS_MAC_configure+0x6a>
    26a2:	f04f 0200 	mov.w	r2, #0
    26a6:	f8c3 2678 	str.w	r2, [r3, #1656]	; 0x678
    MAC_BITBAND->CSR6_TTM = (((configuration & MSS_MAC_CFG_TRANSMIT_THRESHOLD_MODE) != 0u) ? 1u : 0u );
    26aa:	f240 0300 	movw	r3, #0
    26ae:	f2c4 2306 	movt	r3, #16902	; 0x4206
    26b2:	687a      	ldr	r2, [r7, #4]
    26b4:	f002 0202 	and.w	r2, r2, #2
    26b8:	2a00      	cmp	r2, #0
    26ba:	d002      	beq.n	26c2 <MSS_MAC_configure+0x86>
    26bc:	f04f 0201 	mov.w	r2, #1
    26c0:	e001      	b.n	26c6 <MSS_MAC_configure+0x8a>
    26c2:	f04f 0200 	mov.w	r2, #0
    26c6:	f8c3 2658 	str.w	r2, [r3, #1624]	; 0x658
    MAC_BITBAND->CSR6_SF = (uint32_t)(((configuration & MSS_MAC_CFG_STORE_AND_FORWARD) != 0u) ? 1u : 0u );
    26ca:	f240 0300 	movw	r3, #0
    26ce:	f2c4 2306 	movt	r3, #16902	; 0x4206
    26d2:	687a      	ldr	r2, [r7, #4]
    26d4:	f002 0204 	and.w	r2, r2, #4
    26d8:	2a00      	cmp	r2, #0
    26da:	d002      	beq.n	26e2 <MSS_MAC_configure+0xa6>
    26dc:	f04f 0201 	mov.w	r2, #1
    26e0:	e001      	b.n	26e6 <MSS_MAC_configure+0xaa>
    26e2:	f04f 0200 	mov.w	r2, #0
    26e6:	f8c3 2654 	str.w	r2, [r3, #1620]	; 0x654

    switch( configuration & MSS_MAC_CFG_THRESHOLD_CONTROL_11 ) {
    26ea:	687b      	ldr	r3, [r7, #4]
    26ec:	f003 0318 	and.w	r3, r3, #24
    26f0:	2b18      	cmp	r3, #24
    26f2:	d86c      	bhi.n	27ce <MSS_MAC_configure+0x192>
    26f4:	a201      	add	r2, pc, #4	; (adr r2, 26fc <MSS_MAC_configure+0xc0>)
    26f6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    26fa:	bf00      	nop
    26fc:	00002761 	.word	0x00002761
    2700:	000027cf 	.word	0x000027cf
    2704:	000027cf 	.word	0x000027cf
    2708:	000027cf 	.word	0x000027cf
    270c:	000027cf 	.word	0x000027cf
    2710:	000027cf 	.word	0x000027cf
    2714:	000027cf 	.word	0x000027cf
    2718:	000027cf 	.word	0x000027cf
    271c:	0000277b 	.word	0x0000277b
    2720:	000027cf 	.word	0x000027cf
    2724:	000027cf 	.word	0x000027cf
    2728:	000027cf 	.word	0x000027cf
    272c:	000027cf 	.word	0x000027cf
    2730:	000027cf 	.word	0x000027cf
    2734:	000027cf 	.word	0x000027cf
    2738:	000027cf 	.word	0x000027cf
    273c:	00002799 	.word	0x00002799
    2740:	000027cf 	.word	0x000027cf
    2744:	000027cf 	.word	0x000027cf
    2748:	000027cf 	.word	0x000027cf
    274c:	000027cf 	.word	0x000027cf
    2750:	000027cf 	.word	0x000027cf
    2754:	000027cf 	.word	0x000027cf
    2758:	000027cf 	.word	0x000027cf
    275c:	000027b7 	.word	0x000027b7
    case MSS_MAC_CFG_THRESHOLD_CONTROL_00:
        MAC->CSR6 = MAC->CSR6 & ~CSR6_TR_MASK;
    2760:	f243 0300 	movw	r3, #12288	; 0x3000
    2764:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2768:	f243 0200 	movw	r2, #12288	; 0x3000
    276c:	f2c4 0200 	movt	r2, #16384	; 0x4000
    2770:	6b12      	ldr	r2, [r2, #48]	; 0x30
    2772:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
    2776:	631a      	str	r2, [r3, #48]	; 0x30
        break;
    2778:	e029      	b.n	27ce <MSS_MAC_configure+0x192>
    case MSS_MAC_CFG_THRESHOLD_CONTROL_01:
        MAC->CSR6 = (MAC->CSR6 & ~CSR6_TR_MASK) | ((uint32_t)1 << CSR6_TR_SHIFT );
    277a:	f243 0300 	movw	r3, #12288	; 0x3000
    277e:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2782:	f243 0200 	movw	r2, #12288	; 0x3000
    2786:	f2c4 0200 	movt	r2, #16384	; 0x4000
    278a:	6b12      	ldr	r2, [r2, #48]	; 0x30
    278c:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
    2790:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    2794:	631a      	str	r2, [r3, #48]	; 0x30
        break;
    2796:	e01a      	b.n	27ce <MSS_MAC_configure+0x192>
    case MSS_MAC_CFG_THRESHOLD_CONTROL_10:
        MAC->CSR6 = (MAC->CSR6 & ~CSR6_TR_MASK) | ((uint32_t)2 << CSR6_TR_SHIFT );
    2798:	f243 0300 	movw	r3, #12288	; 0x3000
    279c:	f2c4 0300 	movt	r3, #16384	; 0x4000
    27a0:	f243 0200 	movw	r2, #12288	; 0x3000
    27a4:	f2c4 0200 	movt	r2, #16384	; 0x4000
    27a8:	6b12      	ldr	r2, [r2, #48]	; 0x30
    27aa:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
    27ae:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    27b2:	631a      	str	r2, [r3, #48]	; 0x30
        break;
    27b4:	e00b      	b.n	27ce <MSS_MAC_configure+0x192>
    case MSS_MAC_CFG_THRESHOLD_CONTROL_11:
        MAC->CSR6 = (MAC->CSR6 & ~CSR6_TR_MASK) | ((uint32_t)3 << CSR6_TR_SHIFT );
    27b6:	f243 0300 	movw	r3, #12288	; 0x3000
    27ba:	f2c4 0300 	movt	r3, #16384	; 0x4000
    27be:	f243 0200 	movw	r2, #12288	; 0x3000
    27c2:	f2c4 0200 	movt	r2, #16384	; 0x4000
    27c6:	6b12      	ldr	r2, [r2, #48]	; 0x30
    27c8:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
    27cc:	631a      	str	r2, [r3, #48]	; 0x30
        break;
    default:
        break;
    }
    MAC_BITBAND->CSR6_FD = (uint32_t)(((configuration & MSS_MAC_CFG_FULL_DUPLEX_MODE) != 0u) ? 1u : 0u );
    27ce:	f240 0300 	movw	r3, #0
    27d2:	f2c4 2306 	movt	r3, #16902	; 0x4206
    27d6:	687a      	ldr	r2, [r7, #4]
    27d8:	f002 0220 	and.w	r2, r2, #32
    27dc:	2a00      	cmp	r2, #0
    27de:	d002      	beq.n	27e6 <MSS_MAC_configure+0x1aa>
    27e0:	f04f 0201 	mov.w	r2, #1
    27e4:	e001      	b.n	27ea <MSS_MAC_configure+0x1ae>
    27e6:	f04f 0200 	mov.w	r2, #0
    27ea:	f8c3 2624 	str.w	r2, [r3, #1572]	; 0x624
    MAC_BITBAND->CSR6_PM = (uint32_t)(((configuration & MSS_MAC_CFG_PASS_ALL_MULTICAST) != 0u) ? 1u : 0u );
    27ee:	f240 0300 	movw	r3, #0
    27f2:	f2c4 2306 	movt	r3, #16902	; 0x4206
    27f6:	687a      	ldr	r2, [r7, #4]
    27f8:	f002 0240 	and.w	r2, r2, #64	; 0x40
    27fc:	2a00      	cmp	r2, #0
    27fe:	d002      	beq.n	2806 <MSS_MAC_configure+0x1ca>
    2800:	f04f 0201 	mov.w	r2, #1
    2804:	e001      	b.n	280a <MSS_MAC_configure+0x1ce>
    2806:	f04f 0200 	mov.w	r2, #0
    280a:	f8c3 261c 	str.w	r2, [r3, #1564]	; 0x61c
    MAC_BITBAND->CSR6_PR = (uint32_t)(((configuration & MSS_MAC_CFG_PROMISCUOUS_MODE) != 0u) ? 1u : 0u );
    280e:	f240 0300 	movw	r3, #0
    2812:	f2c4 2306 	movt	r3, #16902	; 0x4206
    2816:	687a      	ldr	r2, [r7, #4]
    2818:	f002 0280 	and.w	r2, r2, #128	; 0x80
    281c:	2a00      	cmp	r2, #0
    281e:	d002      	beq.n	2826 <MSS_MAC_configure+0x1ea>
    2820:	f04f 0201 	mov.w	r2, #1
    2824:	e001      	b.n	282a <MSS_MAC_configure+0x1ee>
    2826:	f04f 0200 	mov.w	r2, #0
    282a:	f8c3 2618 	str.w	r2, [r3, #1560]	; 0x618
    MAC_BITBAND->CSR6_PB = (uint32_t)(((configuration & MSS_MAC_CFG_PASS_BAD_FRAMES) != 0u) ? 1u : 0u );
    282e:	f240 0300 	movw	r3, #0
    2832:	f2c4 2306 	movt	r3, #16902	; 0x4206
    2836:	687a      	ldr	r2, [r7, #4]
    2838:	f402 7200 	and.w	r2, r2, #512	; 0x200
    283c:	2a00      	cmp	r2, #0
    283e:	d002      	beq.n	2846 <MSS_MAC_configure+0x20a>
    2840:	f04f 0201 	mov.w	r2, #1
    2844:	e001      	b.n	284a <MSS_MAC_configure+0x20e>
    2846:	f04f 0200 	mov.w	r2, #0
    284a:	f8c3 260c 	str.w	r2, [r3, #1548]	; 0x60c
    PHY_set_link_type( (uint8_t)
    284e:	687b      	ldr	r3, [r7, #4]
    2850:	b2db      	uxtb	r3, r3
    2852:	f003 0302 	and.w	r3, r3, #2
        ((((configuration & MSS_MAC_CFG_TRANSMIT_THRESHOLD_MODE) != 0u) ? MSS_MAC_LINK_STATUS_100MB : 0u ) |
        (((configuration & MSS_MAC_CFG_FULL_DUPLEX_MODE) != 0u) ? MSS_MAC_LINK_STATUS_FDX : 0u )) );
    2856:	687a      	ldr	r2, [r7, #4]
    2858:	f002 0220 	and.w	r2, r2, #32
    }
    MAC_BITBAND->CSR6_FD = (uint32_t)(((configuration & MSS_MAC_CFG_FULL_DUPLEX_MODE) != 0u) ? 1u : 0u );
    MAC_BITBAND->CSR6_PM = (uint32_t)(((configuration & MSS_MAC_CFG_PASS_ALL_MULTICAST) != 0u) ? 1u : 0u );
    MAC_BITBAND->CSR6_PR = (uint32_t)(((configuration & MSS_MAC_CFG_PROMISCUOUS_MODE) != 0u) ? 1u : 0u );
    MAC_BITBAND->CSR6_PB = (uint32_t)(((configuration & MSS_MAC_CFG_PASS_BAD_FRAMES) != 0u) ? 1u : 0u );
    PHY_set_link_type( (uint8_t)
    285c:	2a00      	cmp	r2, #0
    285e:	d002      	beq.n	2866 <MSS_MAC_configure+0x22a>
    2860:	f04f 0204 	mov.w	r2, #4
    2864:	e001      	b.n	286a <MSS_MAC_configure+0x22e>
    2866:	f04f 0200 	mov.w	r2, #0
    286a:	ea43 0302 	orr.w	r3, r3, r2
    286e:	b2db      	uxtb	r3, r3
    2870:	4618      	mov	r0, r3
    2872:	f002 fb43 	bl	4efc <PHY_set_link_type>
        ((((configuration & MSS_MAC_CFG_TRANSMIT_THRESHOLD_MODE) != 0u) ? MSS_MAC_LINK_STATUS_100MB : 0u ) |
        (((configuration & MSS_MAC_CFG_FULL_DUPLEX_MODE) != 0u) ? MSS_MAC_LINK_STATUS_FDX : 0u )) );

    MSS_MAC_auto_setup_link();
    2876:	f000 fcad 	bl	31d4 <MSS_MAC_auto_setup_link>
}
    287a:	f107 0718 	add.w	r7, r7, #24
    287e:	46bd      	mov	sp, r7
    2880:	bd80      	pop	{r7, pc}
    2882:	bf00      	nop

00002884 <MSS_MAC_get_configuration>:
 *    - #MSS_MAC_CFG_HASH_PERFECT_RECEIVE_FILTERING_MODE
 * @see   MAC_configure()
 */
int32_t
MSS_MAC_get_configuration( void )
{
    2884:	b480      	push	{r7}
    2886:	b083      	sub	sp, #12
    2888:	af00      	add	r7, sp, #0
    uint32_t configuration;

    configuration = 0u;
    288a:	f04f 0300 	mov.w	r3, #0
    288e:	607b      	str	r3, [r7, #4]
    if( MAC_BITBAND->CSR6_RA != 0u ) {
    2890:	f240 0300 	movw	r3, #0
    2894:	f2c4 2306 	movt	r3, #16902	; 0x4206
    2898:	f8d3 3678 	ldr.w	r3, [r3, #1656]	; 0x678
    289c:	2b00      	cmp	r3, #0
    289e:	d003      	beq.n	28a8 <MSS_MAC_get_configuration+0x24>
        configuration |= MSS_MAC_CFG_RECEIVE_ALL;
    28a0:	687b      	ldr	r3, [r7, #4]
    28a2:	f043 0301 	orr.w	r3, r3, #1
    28a6:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_TTM != 0u ) {
    28a8:	f240 0300 	movw	r3, #0
    28ac:	f2c4 2306 	movt	r3, #16902	; 0x4206
    28b0:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
    28b4:	2b00      	cmp	r3, #0
    28b6:	d003      	beq.n	28c0 <MSS_MAC_get_configuration+0x3c>
        configuration |= MSS_MAC_CFG_TRANSMIT_THRESHOLD_MODE;
    28b8:	687b      	ldr	r3, [r7, #4]
    28ba:	f043 0302 	orr.w	r3, r3, #2
    28be:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_SF != 0u ) {
    28c0:	f240 0300 	movw	r3, #0
    28c4:	f2c4 2306 	movt	r3, #16902	; 0x4206
    28c8:	f8d3 3654 	ldr.w	r3, [r3, #1620]	; 0x654
    28cc:	2b00      	cmp	r3, #0
    28ce:	d003      	beq.n	28d8 <MSS_MAC_get_configuration+0x54>
        configuration |= MSS_MAC_CFG_STORE_AND_FORWARD;
    28d0:	687b      	ldr	r3, [r7, #4]
    28d2:	f043 0304 	orr.w	r3, r3, #4
    28d6:	607b      	str	r3, [r7, #4]
    }

    switch( (MAC->CSR6 & CSR6_TR_MASK) >> CSR6_TR_SHIFT ) {
    28d8:	f243 0300 	movw	r3, #12288	; 0x3000
    28dc:	f2c4 0300 	movt	r3, #16384	; 0x4000
    28e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    28e2:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
    28e6:	ea4f 3393 	mov.w	r3, r3, lsr #14
    28ea:	2b02      	cmp	r3, #2
    28ec:	d008      	beq.n	2900 <MSS_MAC_get_configuration+0x7c>
    28ee:	2b03      	cmp	r3, #3
    28f0:	d00b      	beq.n	290a <MSS_MAC_get_configuration+0x86>
    28f2:	2b01      	cmp	r3, #1
    28f4:	d10d      	bne.n	2912 <MSS_MAC_get_configuration+0x8e>
    case 1: configuration |= MSS_MAC_CFG_THRESHOLD_CONTROL_01; break;
    28f6:	687b      	ldr	r3, [r7, #4]
    28f8:	f043 0308 	orr.w	r3, r3, #8
    28fc:	607b      	str	r3, [r7, #4]
    28fe:	e008      	b.n	2912 <MSS_MAC_get_configuration+0x8e>
    case 2: configuration |= MSS_MAC_CFG_THRESHOLD_CONTROL_10; break;
    2900:	687b      	ldr	r3, [r7, #4]
    2902:	f043 0310 	orr.w	r3, r3, #16
    2906:	607b      	str	r3, [r7, #4]
    2908:	e003      	b.n	2912 <MSS_MAC_get_configuration+0x8e>
    case 3: configuration |= MSS_MAC_CFG_THRESHOLD_CONTROL_11; break;
    290a:	687b      	ldr	r3, [r7, #4]
    290c:	f043 0318 	orr.w	r3, r3, #24
    2910:	607b      	str	r3, [r7, #4]
    default: break;
    }
    if( MAC_BITBAND->CSR6_FD != 0u ) {
    2912:	f240 0300 	movw	r3, #0
    2916:	f2c4 2306 	movt	r3, #16902	; 0x4206
    291a:	f8d3 3624 	ldr.w	r3, [r3, #1572]	; 0x624
    291e:	2b00      	cmp	r3, #0
    2920:	d003      	beq.n	292a <MSS_MAC_get_configuration+0xa6>
        configuration |= MSS_MAC_CFG_FULL_DUPLEX_MODE;
    2922:	687b      	ldr	r3, [r7, #4]
    2924:	f043 0320 	orr.w	r3, r3, #32
    2928:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_PM != 0u ) {
    292a:	f240 0300 	movw	r3, #0
    292e:	f2c4 2306 	movt	r3, #16902	; 0x4206
    2932:	f8d3 361c 	ldr.w	r3, [r3, #1564]	; 0x61c
    2936:	2b00      	cmp	r3, #0
    2938:	d003      	beq.n	2942 <MSS_MAC_get_configuration+0xbe>
        configuration |= MSS_MAC_CFG_PASS_ALL_MULTICAST;
    293a:	687b      	ldr	r3, [r7, #4]
    293c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    2940:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_PR != 0u ) {
    2942:	f240 0300 	movw	r3, #0
    2946:	f2c4 2306 	movt	r3, #16902	; 0x4206
    294a:	f8d3 3618 	ldr.w	r3, [r3, #1560]	; 0x618
    294e:	2b00      	cmp	r3, #0
    2950:	d003      	beq.n	295a <MSS_MAC_get_configuration+0xd6>
        configuration |= MSS_MAC_CFG_PROMISCUOUS_MODE;
    2952:	687b      	ldr	r3, [r7, #4]
    2954:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    2958:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_IF != 0u ) {
    295a:	f240 0300 	movw	r3, #0
    295e:	f2c4 2306 	movt	r3, #16902	; 0x4206
    2962:	f8d3 3610 	ldr.w	r3, [r3, #1552]	; 0x610
    2966:	2b00      	cmp	r3, #0
    2968:	d003      	beq.n	2972 <MSS_MAC_get_configuration+0xee>
        configuration |= MSS_MAC_CFG_INVERSE_FILTERING;
    296a:	687b      	ldr	r3, [r7, #4]
    296c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    2970:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_PB != 0u ) {
    2972:	f240 0300 	movw	r3, #0
    2976:	f2c4 2306 	movt	r3, #16902	; 0x4206
    297a:	f8d3 360c 	ldr.w	r3, [r3, #1548]	; 0x60c
    297e:	2b00      	cmp	r3, #0
    2980:	d003      	beq.n	298a <MSS_MAC_get_configuration+0x106>
        configuration |= MSS_MAC_CFG_PASS_BAD_FRAMES;
    2982:	687b      	ldr	r3, [r7, #4]
    2984:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    2988:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_HO != 0u ) {
    298a:	f240 0300 	movw	r3, #0
    298e:	f2c4 2306 	movt	r3, #16902	; 0x4206
    2992:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    2996:	2b00      	cmp	r3, #0
    2998:	d003      	beq.n	29a2 <MSS_MAC_get_configuration+0x11e>
        configuration |= MSS_MAC_CFG_HASH_ONLY_FILTERING_MODE;
    299a:	687b      	ldr	r3, [r7, #4]
    299c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    29a0:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_HP != 0u ) {
    29a2:	f240 0300 	movw	r3, #0
    29a6:	f2c4 2306 	movt	r3, #16902	; 0x4206
    29aa:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    29ae:	2b00      	cmp	r3, #0
    29b0:	d003      	beq.n	29ba <MSS_MAC_get_configuration+0x136>
        configuration |= MSS_MAC_CFG_HASH_PERFECT_RECEIVE_FILTERING_MODE;
    29b2:	687b      	ldr	r3, [r7, #4]
    29b4:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
    29b8:	607b      	str	r3, [r7, #4]
    }

    return (int32_t)configuration;
    29ba:	687b      	ldr	r3, [r7, #4]
}
    29bc:	4618      	mov	r0, r3
    29be:	f107 070c 	add.w	r7, r7, #12
    29c2:	46bd      	mov	sp, r7
    29c4:	bc80      	pop	{r7}
    29c6:	4770      	bx	lr

000029c8 <MSS_MAC_tx_packet>:
int32_t
MSS_MAC_tx_packet
(
    unsigned short usLength
)
{
    29c8:	b580      	push	{r7, lr}
    29ca:	b08a      	sub	sp, #40	; 0x28
    29cc:	af00      	add	r7, sp, #0
    29ce:	4603      	mov	r3, r0
    29d0:	80fb      	strh	r3, [r7, #6]
	uint32_t desc;
	unsigned long ulDescriptor;
    int32_t error = MAC_OK;
    29d2:	f04f 0300 	mov.w	r3, #0
    29d6:	617b      	str	r3, [r7, #20]

    configASSERT( uip_buf != NULL_buffer );
    29d8:	f240 6390 	movw	r3, #1680	; 0x690
    29dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    29e0:	681a      	ldr	r2, [r3, #0]
    29e2:	f240 6388 	movw	r3, #1672	; 0x688
    29e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    29ea:	681b      	ldr	r3, [r3, #0]
    29ec:	429a      	cmp	r2, r3
    29ee:	d109      	bne.n	2a04 <MSS_MAC_tx_packet+0x3c>
    29f0:	f04f 0328 	mov.w	r3, #40	; 0x28
    29f4:	f383 8811 	msr	BASEPRI, r3
    29f8:	f3bf 8f6f 	isb	sy
    29fc:	f3bf 8f4f 	dsb	sy
    2a00:	61bb      	str	r3, [r7, #24]
    2a02:	e7fe      	b.n	2a02 <MSS_MAC_tx_packet+0x3a>

	configASSERT( usLength >= 12 );
    2a04:	88fb      	ldrh	r3, [r7, #6]
    2a06:	2b0b      	cmp	r3, #11
    2a08:	d809      	bhi.n	2a1e <MSS_MAC_tx_packet+0x56>
    2a0a:	f04f 0328 	mov.w	r3, #40	; 0x28
    2a0e:	f383 8811 	msr	BASEPRI, r3
    2a12:	f3bf 8f6f 	isb	sy
    2a16:	f3bf 8f4f 	dsb	sy
    2a1a:	61fb      	str	r3, [r7, #28]
    2a1c:	e7fe      	b.n	2a1c <MSS_MAC_tx_packet+0x54>

    if( (g_mss_mac.flags & FLAG_EXCEED_LIMIT) == 0u )
    2a1e:	f64a 1394 	movw	r3, #43412	; 0xa994
    2a22:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a26:	791b      	ldrb	r3, [r3, #4]
    2a28:	f003 0308 	and.w	r3, r3, #8
    2a2c:	2b00      	cmp	r3, #0
    2a2e:	d10e      	bne.n	2a4e <MSS_MAC_tx_packet+0x86>
    {
		configASSERT( usLength <= MSS_MAX_PACKET_SIZE );
    2a30:	88fa      	ldrh	r2, [r7, #6]
    2a32:	f240 53ea 	movw	r3, #1514	; 0x5ea
    2a36:	429a      	cmp	r2, r3
    2a38:	d909      	bls.n	2a4e <MSS_MAC_tx_packet+0x86>
    2a3a:	f04f 0328 	mov.w	r3, #40	; 0x28
    2a3e:	f383 8811 	msr	BASEPRI, r3
    2a42:	f3bf 8f6f 	isb	sy
    2a46:	f3bf 8f4f 	dsb	sy
    2a4a:	623b      	str	r3, [r7, #32]
    2a4c:	e7fe      	b.n	2a4c <MSS_MAC_tx_packet+0x84>
	}

	taskENTER_CRITICAL();
    2a4e:	f00e fe7b 	bl	11748 <vPortEnterCritical>
	{
		/* Check both Tx descriptors are free, meaning the double send has completed. */
		if( ( ( (g_mss_mac.tx_descriptors[ 0 ].descriptor_0) & TDES0_OWN) == TDES0_OWN ) || ( ( (g_mss_mac.tx_descriptors[ 1 ].descriptor_0) & TDES0_OWN) == TDES0_OWN ) )
    2a52:	f64a 1394 	movw	r3, #43412	; 0xa994
    2a56:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a5a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    2a5c:	2b00      	cmp	r3, #0
    2a5e:	db07      	blt.n	2a70 <MSS_MAC_tx_packet+0xa8>
    2a60:	f64a 1394 	movw	r3, #43412	; 0xa994
    2a64:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a68:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
    2a6c:	2b00      	cmp	r3, #0
    2a6e:	da02      	bge.n	2a76 <MSS_MAC_tx_packet+0xae>
		{
			error = MAC_BUFFER_IS_FULL;
    2a70:	f06f 0303 	mvn.w	r3, #3
    2a74:	617b      	str	r3, [r7, #20]
		}
	}
	taskEXIT_CRITICAL();
    2a76:	f00e fe9f 	bl	117b8 <vPortExitCritical>

	configASSERT( ( g_mss_mac.tx_desc_index == 0 ) );
    2a7a:	f64a 1394 	movw	r3, #43412	; 0xa994
    2a7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a82:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    2a84:	2b00      	cmp	r3, #0
    2a86:	d009      	beq.n	2a9c <MSS_MAC_tx_packet+0xd4>
    2a88:	f04f 0328 	mov.w	r3, #40	; 0x28
    2a8c:	f383 8811 	msr	BASEPRI, r3
    2a90:	f3bf 8f6f 	isb	sy
    2a94:	f3bf 8f4f 	dsb	sy
    2a98:	627b      	str	r3, [r7, #36]	; 0x24
    2a9a:	e7fe      	b.n	2a9a <MSS_MAC_tx_packet+0xd2>
	
	if( error == MAC_OK )
    2a9c:	697b      	ldr	r3, [r7, #20]
    2a9e:	2b00      	cmp	r3, #0
    2aa0:	f040 820d 	bne.w	2ebe <MSS_MAC_tx_packet+0x4f6>
	{
		/* Ensure nothing is going to get sent until both descriptors are ready.
		This is done to	prevent a Tx end occurring prior to the second descriptor
		being ready. */
		MAC_BITBAND->CSR6_ST = 0u;
    2aa4:	f240 0300 	movw	r3, #0
    2aa8:	f2c4 2306 	movt	r3, #16902	; 0x4206
    2aac:	f04f 0200 	mov.w	r2, #0
    2ab0:	f8c3 2634 	str.w	r2, [r3, #1588]	; 0x634

		/* Assumed TX_RING_SIZE == 2.  A #error directive checks this is the
		case. */
		taskENTER_CRITICAL();
    2ab4:	f00e fe48 	bl	11748 <vPortEnterCritical>
		{
			for( ulDescriptor = 0; ulDescriptor < TX_RING_SIZE; ulDescriptor++ )
    2ab8:	f04f 0300 	mov.w	r3, #0
    2abc:	613b      	str	r3, [r7, #16]
    2abe:	e1f8      	b.n	2eb2 <MSS_MAC_tx_packet+0x4ea>
			{
				g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_1 = 0u;
    2ac0:	f64a 1394 	movw	r3, #43412	; 0xa994
    2ac4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2ac8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    2aca:	f64a 1394 	movw	r3, #43412	; 0xa994
    2ace:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2ad2:	f102 0207 	add.w	r2, r2, #7
    2ad6:	ea4f 1202 	mov.w	r2, r2, lsl #4
    2ada:	4413      	add	r3, r2
    2adc:	f103 0308 	add.w	r3, r3, #8
    2ae0:	f04f 0200 	mov.w	r2, #0
    2ae4:	601a      	str	r2, [r3, #0]
	
				if( (g_mss_mac.flags & FLAG_CRC_DISABLE) != 0u ) {
    2ae6:	f64a 1394 	movw	r3, #43412	; 0xa994
    2aea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2aee:	791b      	ldrb	r3, [r3, #4]
    2af0:	f003 0304 	and.w	r3, r3, #4
    2af4:	2b00      	cmp	r3, #0
    2af6:	d023      	beq.n	2b40 <MSS_MAC_tx_packet+0x178>
					g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_1 |= TDES1_AC;
    2af8:	f64a 1394 	movw	r3, #43412	; 0xa994
    2afc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2b00:	6f19      	ldr	r1, [r3, #112]	; 0x70
    2b02:	f64a 1394 	movw	r3, #43412	; 0xa994
    2b06:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2b0a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    2b0c:	f64a 1394 	movw	r3, #43412	; 0xa994
    2b10:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2b14:	f102 0207 	add.w	r2, r2, #7
    2b18:	ea4f 1202 	mov.w	r2, r2, lsl #4
    2b1c:	4413      	add	r3, r2
    2b1e:	f103 0308 	add.w	r3, r3, #8
    2b22:	681b      	ldr	r3, [r3, #0]
    2b24:	f043 6280 	orr.w	r2, r3, #67108864	; 0x4000000
    2b28:	f64a 1394 	movw	r3, #43412	; 0xa994
    2b2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2b30:	f101 0107 	add.w	r1, r1, #7
    2b34:	ea4f 1101 	mov.w	r1, r1, lsl #4
    2b38:	440b      	add	r3, r1
    2b3a:	f103 0308 	add.w	r3, r3, #8
    2b3e:	601a      	str	r2, [r3, #0]
				}
	
				/* Every buffer can hold a full frame so they are always first and last
				   descriptor */
				g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_1 |= TDES1_LS | TDES1_FS;
    2b40:	f64a 1394 	movw	r3, #43412	; 0xa994
    2b44:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2b48:	6f19      	ldr	r1, [r3, #112]	; 0x70
    2b4a:	f64a 1394 	movw	r3, #43412	; 0xa994
    2b4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2b52:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    2b54:	f64a 1394 	movw	r3, #43412	; 0xa994
    2b58:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2b5c:	f102 0207 	add.w	r2, r2, #7
    2b60:	ea4f 1202 	mov.w	r2, r2, lsl #4
    2b64:	4413      	add	r3, r2
    2b66:	f103 0308 	add.w	r3, r3, #8
    2b6a:	681b      	ldr	r3, [r3, #0]
    2b6c:	f043 42c0 	orr.w	r2, r3, #1610612736	; 0x60000000
    2b70:	f64a 1394 	movw	r3, #43412	; 0xa994
    2b74:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2b78:	f101 0107 	add.w	r1, r1, #7
    2b7c:	ea4f 1101 	mov.w	r1, r1, lsl #4
    2b80:	440b      	add	r3, r1
    2b82:	f103 0308 	add.w	r3, r3, #8
    2b86:	601a      	str	r2, [r3, #0]
	
				/* set data size */
				g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_1 |= usLength;
    2b88:	f64a 1394 	movw	r3, #43412	; 0xa994
    2b8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2b90:	6f19      	ldr	r1, [r3, #112]	; 0x70
    2b92:	f64a 1394 	movw	r3, #43412	; 0xa994
    2b96:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2b9a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    2b9c:	f64a 1394 	movw	r3, #43412	; 0xa994
    2ba0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2ba4:	f102 0207 	add.w	r2, r2, #7
    2ba8:	ea4f 1202 	mov.w	r2, r2, lsl #4
    2bac:	4413      	add	r3, r2
    2bae:	f103 0308 	add.w	r3, r3, #8
    2bb2:	681a      	ldr	r2, [r3, #0]
    2bb4:	88fb      	ldrh	r3, [r7, #6]
    2bb6:	ea42 0203 	orr.w	r2, r2, r3
    2bba:	f64a 1394 	movw	r3, #43412	; 0xa994
    2bbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2bc2:	f101 0107 	add.w	r1, r1, #7
    2bc6:	ea4f 1101 	mov.w	r1, r1, lsl #4
    2bca:	440b      	add	r3, r1
    2bcc:	f103 0308 	add.w	r3, r3, #8
    2bd0:	601a      	str	r2, [r3, #0]
	
				/* reset end of ring */
				g_mss_mac.tx_descriptors[TX_RING_SIZE-1].descriptor_1 |= TDES1_TER;
    2bd2:	f64a 1394 	movw	r3, #43412	; 0xa994
    2bd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2bda:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    2bde:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
    2be2:	f64a 1394 	movw	r3, #43412	; 0xa994
    2be6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2bea:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	
				if( usLength > MSS_TX_BUFF_SIZE ) /* FLAG_EXCEED_LIMIT */
    2bee:	88fa      	ldrh	r2, [r7, #6]
    2bf0:	f240 53ec 	movw	r3, #1516	; 0x5ec
    2bf4:	429a      	cmp	r2, r3
    2bf6:	d902      	bls.n	2bfe <MSS_MAC_tx_packet+0x236>
				{
					usLength = (uint16_t)MSS_TX_BUFF_SIZE;
    2bf8:	f240 53ec 	movw	r3, #1516	; 0x5ec
    2bfc:	80fb      	strh	r3, [r7, #6]
				}
	
				/* The data buffer is assigned to the Tx descriptor. */
				g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].buffer_1 = ( unsigned long ) uip_buf;
    2bfe:	f64a 1394 	movw	r3, #43412	; 0xa994
    2c02:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2c06:	6f19      	ldr	r1, [r3, #112]	; 0x70
    2c08:	f240 6390 	movw	r3, #1680	; 0x690
    2c0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2c10:	681b      	ldr	r3, [r3, #0]
    2c12:	461a      	mov	r2, r3
    2c14:	f64a 1394 	movw	r3, #43412	; 0xa994
    2c18:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2c1c:	ea4f 1101 	mov.w	r1, r1, lsl #4
    2c20:	440b      	add	r3, r1
    2c22:	f103 037c 	add.w	r3, r3, #124	; 0x7c
    2c26:	601a      	str	r2, [r3, #0]
	
				/* update counters */
				desc = g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_0;
    2c28:	f64a 1394 	movw	r3, #43412	; 0xa994
    2c2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2c30:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    2c32:	f64a 1394 	movw	r3, #43412	; 0xa994
    2c36:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2c3a:	f102 0207 	add.w	r2, r2, #7
    2c3e:	ea4f 1202 	mov.w	r2, r2, lsl #4
    2c42:	4413      	add	r3, r2
    2c44:	f103 0304 	add.w	r3, r3, #4
    2c48:	681b      	ldr	r3, [r3, #0]
    2c4a:	60fb      	str	r3, [r7, #12]
				if( (desc & TDES0_LO) != 0u ) {
    2c4c:	68fb      	ldr	r3, [r7, #12]
    2c4e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    2c52:	2b00      	cmp	r3, #0
    2c54:	d027      	beq.n	2ca6 <MSS_MAC_tx_packet+0x2de>
					g_mss_mac.statistics.tx_loss_of_carrier++;
    2c56:	f64a 1394 	movw	r3, #43412	; 0xa994
    2c5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2c5e:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    2c62:	ea4f 2212 	mov.w	r2, r2, lsr #8
    2c66:	f893 311c 	ldrb.w	r3, [r3, #284]	; 0x11c
    2c6a:	ea4f 6303 	mov.w	r3, r3, lsl #24
    2c6e:	ea43 0302 	orr.w	r3, r3, r2
    2c72:	f103 0201 	add.w	r2, r3, #1
    2c76:	f64a 1394 	movw	r3, #43412	; 0xa994
    2c7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2c7e:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    2c82:	ea4f 2101 	mov.w	r1, r1, lsl #8
    2c86:	f8d3 0118 	ldr.w	r0, [r3, #280]	; 0x118
    2c8a:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    2c8e:	ea40 0101 	orr.w	r1, r0, r1
    2c92:	f8c3 1118 	str.w	r1, [r3, #280]	; 0x118
    2c96:	ea4f 6212 	mov.w	r2, r2, lsr #24
    2c9a:	f04f 0100 	mov.w	r1, #0
    2c9e:	ea41 0202 	orr.w	r2, r1, r2
    2ca2:	f883 211c 	strb.w	r2, [r3, #284]	; 0x11c
				}
				if( (desc & TDES0_NC) != 0u ) {
    2ca6:	68fb      	ldr	r3, [r7, #12]
    2ca8:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    2cac:	2b00      	cmp	r3, #0
    2cae:	d027      	beq.n	2d00 <MSS_MAC_tx_packet+0x338>
					g_mss_mac.statistics.tx_no_carrier++;
    2cb0:	f64a 1394 	movw	r3, #43412	; 0xa994
    2cb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2cb8:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
    2cbc:	ea4f 2212 	mov.w	r2, r2, lsr #8
    2cc0:	f893 3120 	ldrb.w	r3, [r3, #288]	; 0x120
    2cc4:	ea4f 6303 	mov.w	r3, r3, lsl #24
    2cc8:	ea43 0302 	orr.w	r3, r3, r2
    2ccc:	f103 0201 	add.w	r2, r3, #1
    2cd0:	f64a 1394 	movw	r3, #43412	; 0xa994
    2cd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2cd8:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    2cdc:	ea4f 2101 	mov.w	r1, r1, lsl #8
    2ce0:	f8d3 011c 	ldr.w	r0, [r3, #284]	; 0x11c
    2ce4:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    2ce8:	ea40 0101 	orr.w	r1, r0, r1
    2cec:	f8c3 111c 	str.w	r1, [r3, #284]	; 0x11c
    2cf0:	ea4f 6212 	mov.w	r2, r2, lsr #24
    2cf4:	f04f 0100 	mov.w	r1, #0
    2cf8:	ea41 0202 	orr.w	r2, r1, r2
    2cfc:	f883 2120 	strb.w	r2, [r3, #288]	; 0x120
				}
				if( (desc & TDES0_LC) != 0u ) {
    2d00:	68fb      	ldr	r3, [r7, #12]
    2d02:	f403 7300 	and.w	r3, r3, #512	; 0x200
    2d06:	2b00      	cmp	r3, #0
    2d08:	d027      	beq.n	2d5a <MSS_MAC_tx_packet+0x392>
					g_mss_mac.statistics.tx_late_collision++;
    2d0a:	f64a 1394 	movw	r3, #43412	; 0xa994
    2d0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2d12:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    2d16:	ea4f 2212 	mov.w	r2, r2, lsr #8
    2d1a:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
    2d1e:	ea4f 6303 	mov.w	r3, r3, lsl #24
    2d22:	ea43 0302 	orr.w	r3, r3, r2
    2d26:	f103 0201 	add.w	r2, r3, #1
    2d2a:	f64a 1394 	movw	r3, #43412	; 0xa994
    2d2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2d32:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    2d36:	ea4f 2101 	mov.w	r1, r1, lsl #8
    2d3a:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
    2d3e:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    2d42:	ea40 0101 	orr.w	r1, r0, r1
    2d46:	f8c3 1120 	str.w	r1, [r3, #288]	; 0x120
    2d4a:	ea4f 6212 	mov.w	r2, r2, lsr #24
    2d4e:	f04f 0100 	mov.w	r1, #0
    2d52:	ea41 0202 	orr.w	r2, r1, r2
    2d56:	f883 2124 	strb.w	r2, [r3, #292]	; 0x124
				}
				if( (desc & TDES0_EC) != 0u ) {
    2d5a:	68fb      	ldr	r3, [r7, #12]
    2d5c:	f403 7380 	and.w	r3, r3, #256	; 0x100
    2d60:	2b00      	cmp	r3, #0
    2d62:	d027      	beq.n	2db4 <MSS_MAC_tx_packet+0x3ec>
					g_mss_mac.statistics.tx_excessive_collision++;
    2d64:	f64a 1394 	movw	r3, #43412	; 0xa994
    2d68:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2d6c:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    2d70:	ea4f 2212 	mov.w	r2, r2, lsr #8
    2d74:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
    2d78:	ea4f 6303 	mov.w	r3, r3, lsl #24
    2d7c:	ea43 0302 	orr.w	r3, r3, r2
    2d80:	f103 0201 	add.w	r2, r3, #1
    2d84:	f64a 1394 	movw	r3, #43412	; 0xa994
    2d88:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2d8c:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    2d90:	ea4f 2101 	mov.w	r1, r1, lsl #8
    2d94:	f8d3 0124 	ldr.w	r0, [r3, #292]	; 0x124
    2d98:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    2d9c:	ea40 0101 	orr.w	r1, r0, r1
    2da0:	f8c3 1124 	str.w	r1, [r3, #292]	; 0x124
    2da4:	ea4f 6212 	mov.w	r2, r2, lsr #24
    2da8:	f04f 0100 	mov.w	r1, #0
    2dac:	ea41 0202 	orr.w	r2, r1, r2
    2db0:	f883 2128 	strb.w	r2, [r3, #296]	; 0x128
				}
				if( (desc & TDES0_UF) != 0u ) {
    2db4:	68fb      	ldr	r3, [r7, #12]
    2db6:	f003 0302 	and.w	r3, r3, #2
    2dba:	2b00      	cmp	r3, #0
    2dbc:	d027      	beq.n	2e0e <MSS_MAC_tx_packet+0x446>
					g_mss_mac.statistics.tx_underflow_error++;
    2dbe:	f64a 1394 	movw	r3, #43412	; 0xa994
    2dc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2dc6:	f8d3 212c 	ldr.w	r2, [r3, #300]	; 0x12c
    2dca:	ea4f 2212 	mov.w	r2, r2, lsr #8
    2dce:	f893 3130 	ldrb.w	r3, [r3, #304]	; 0x130
    2dd2:	ea4f 6303 	mov.w	r3, r3, lsl #24
    2dd6:	ea43 0302 	orr.w	r3, r3, r2
    2dda:	f103 0201 	add.w	r2, r3, #1
    2dde:	f64a 1394 	movw	r3, #43412	; 0xa994
    2de2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2de6:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    2dea:	ea4f 2101 	mov.w	r1, r1, lsl #8
    2dee:	f8d3 012c 	ldr.w	r0, [r3, #300]	; 0x12c
    2df2:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    2df6:	ea40 0101 	orr.w	r1, r0, r1
    2dfa:	f8c3 112c 	str.w	r1, [r3, #300]	; 0x12c
    2dfe:	ea4f 6212 	mov.w	r2, r2, lsr #24
    2e02:	f04f 0100 	mov.w	r1, #0
    2e06:	ea41 0202 	orr.w	r2, r1, r2
    2e0a:	f883 2130 	strb.w	r2, [r3, #304]	; 0x130
				}
				g_mss_mac.statistics.tx_collision_count +=
    2e0e:	f64a 1394 	movw	r3, #43412	; 0xa994
    2e12:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2e16:	f8d3 2128 	ldr.w	r2, [r3, #296]	; 0x128
    2e1a:	ea4f 2212 	mov.w	r2, r2, lsr #8
    2e1e:	f893 312c 	ldrb.w	r3, [r3, #300]	; 0x12c
    2e22:	ea4f 6303 	mov.w	r3, r3, lsl #24
    2e26:	ea43 0302 	orr.w	r3, r3, r2
    2e2a:	461a      	mov	r2, r3
					(desc >> TDES0_CC_OFFSET) & TDES0_CC_MASK;
    2e2c:	68fb      	ldr	r3, [r7, #12]
    2e2e:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    2e32:	f003 030f 	and.w	r3, r3, #15
					g_mss_mac.statistics.tx_excessive_collision++;
				}
				if( (desc & TDES0_UF) != 0u ) {
					g_mss_mac.statistics.tx_underflow_error++;
				}
				g_mss_mac.statistics.tx_collision_count +=
    2e36:	441a      	add	r2, r3
    2e38:	f64a 1394 	movw	r3, #43412	; 0xa994
    2e3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2e40:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    2e44:	ea4f 2101 	mov.w	r1, r1, lsl #8
    2e48:	f8d3 0128 	ldr.w	r0, [r3, #296]	; 0x128
    2e4c:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    2e50:	ea40 0101 	orr.w	r1, r0, r1
    2e54:	f8c3 1128 	str.w	r1, [r3, #296]	; 0x128
    2e58:	ea4f 6212 	mov.w	r2, r2, lsr #24
    2e5c:	f04f 0100 	mov.w	r1, #0
    2e60:	ea41 0202 	orr.w	r2, r1, r2
    2e64:	f883 212c 	strb.w	r2, [r3, #300]	; 0x12c
					(desc >> TDES0_CC_OFFSET) & TDES0_CC_MASK;
	
				/* Give ownership of descriptor to the MAC */
				g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_0 = TDES0_OWN;
    2e68:	f64a 1394 	movw	r3, #43412	; 0xa994
    2e6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2e70:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    2e72:	f64a 1394 	movw	r3, #43412	; 0xa994
    2e76:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2e7a:	f102 0207 	add.w	r2, r2, #7
    2e7e:	ea4f 1202 	mov.w	r2, r2, lsl #4
    2e82:	4413      	add	r3, r2
    2e84:	f103 0304 	add.w	r3, r3, #4
    2e88:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    2e8c:	601a      	str	r2, [r3, #0]
				
				g_mss_mac.tx_desc_index = (g_mss_mac.tx_desc_index + 1u) % (uint32_t)TX_RING_SIZE;
    2e8e:	f64a 1394 	movw	r3, #43412	; 0xa994
    2e92:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2e96:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    2e98:	f103 0301 	add.w	r3, r3, #1
    2e9c:	f003 0201 	and.w	r2, r3, #1
    2ea0:	f64a 1394 	movw	r3, #43412	; 0xa994
    2ea4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2ea8:	671a      	str	r2, [r3, #112]	; 0x70

		/* Assumed TX_RING_SIZE == 2.  A #error directive checks this is the
		case. */
		taskENTER_CRITICAL();
		{
			for( ulDescriptor = 0; ulDescriptor < TX_RING_SIZE; ulDescriptor++ )
    2eaa:	693b      	ldr	r3, [r7, #16]
    2eac:	f103 0301 	add.w	r3, r3, #1
    2eb0:	613b      	str	r3, [r7, #16]
    2eb2:	693b      	ldr	r3, [r7, #16]
    2eb4:	2b01      	cmp	r3, #1
    2eb6:	f67f ae03 	bls.w	2ac0 <MSS_MAC_tx_packet+0xf8>
				g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_0 = TDES0_OWN;
				
				g_mss_mac.tx_desc_index = (g_mss_mac.tx_desc_index + 1u) % (uint32_t)TX_RING_SIZE;
			}		
		}
		taskEXIT_CRITICAL();
    2eba:	f00e fc7d 	bl	117b8 <vPortExitCritical>
    }
	
    if (error == MAC_OK)
    2ebe:	697b      	ldr	r3, [r7, #20]
    2ec0:	2b00      	cmp	r3, #0
    2ec2:	d119      	bne.n	2ef8 <MSS_MAC_tx_packet+0x530>
    {
        error = (int32_t)usLength;
    2ec4:	88fb      	ldrh	r3, [r7, #6]
    2ec6:	617b      	str	r3, [r7, #20]
		
		/* Start sending now both descriptors are set up.  This is done to
		prevent a Tx end occurring prior to the second descriptor being
		ready. */
		MAC_BITBAND->CSR6_ST = 1u;
    2ec8:	f240 0300 	movw	r3, #0
    2ecc:	f2c4 2306 	movt	r3, #16902	; 0x4206
    2ed0:	f04f 0201 	mov.w	r2, #1
    2ed4:	f8c3 2634 	str.w	r2, [r3, #1588]	; 0x634
		MAC->CSR1 = 1u;
    2ed8:	f243 0300 	movw	r3, #12288	; 0x3000
    2edc:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2ee0:	f04f 0201 	mov.w	r2, #1
    2ee4:	609a      	str	r2, [r3, #8]
		
		/* The buffer pointed to by uip_buf is now assigned to a Tx descriptor.
		Find anothere free buffer for uip_buf. */
		uip_buf = MAC_obtain_buffer();
    2ee6:	f001 fd51 	bl	498c <MAC_obtain_buffer>
    2eea:	4602      	mov	r2, r0
    2eec:	f240 6390 	movw	r3, #1680	; 0x690
    2ef0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2ef4:	601a      	str	r2, [r3, #0]
    2ef6:	e002      	b.n	2efe <MSS_MAC_tx_packet+0x536>
    }
    else
    {
        error = 0;
    2ef8:	f04f 0300 	mov.w	r3, #0
    2efc:	617b      	str	r3, [r7, #20]
    }
    return ( error );
    2efe:	697b      	ldr	r3, [r7, #20]
}
    2f00:	4618      	mov	r0, r3
    2f02:	f107 0728 	add.w	r7, r7, #40	; 0x28
    2f06:	46bd      	mov	sp, r7
    2f08:	bd80      	pop	{r7, pc}
    2f0a:	bf00      	nop

00002f0c <MSS_MAC_rx_pckt_size>:
int32_t
MSS_MAC_rx_pckt_size
(
    void
)
{
    2f0c:	b580      	push	{r7, lr}
    2f0e:	b082      	sub	sp, #8
    2f10:	af00      	add	r7, sp, #0
    int32_t retval;
    MAC_dismiss_bad_frames();
    2f12:	f001 f9a5 	bl	4260 <MAC_dismiss_bad_frames>

    if( (g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &	RDES0_OWN) != 0u )
    2f16:	f64a 1394 	movw	r3, #43412	; 0xa994
    2f1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2f1e:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    2f22:	f64a 1394 	movw	r3, #43412	; 0xa994
    2f26:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2f2a:	ea4f 1202 	mov.w	r2, r2, lsl #4
    2f2e:	4413      	add	r3, r2
    2f30:	f103 0398 	add.w	r3, r3, #152	; 0x98
    2f34:	681b      	ldr	r3, [r3, #0]
    2f36:	2b00      	cmp	r3, #0
    2f38:	da03      	bge.n	2f42 <MSS_MAC_rx_pckt_size+0x36>
    {
    	/* Current descriptor is empty */
    	retval = 0;
    2f3a:	f04f 0300 	mov.w	r3, #0
    2f3e:	603b      	str	r3, [r7, #0]
    2f40:	e018      	b.n	2f74 <MSS_MAC_rx_pckt_size+0x68>
    }
    else
    {
        uint32_t frame_length;
        frame_length = ( g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 >> RDES0_FL_OFFSET ) & RDES0_FL_MASK;
    2f42:	f64a 1394 	movw	r3, #43412	; 0xa994
    2f46:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2f4a:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    2f4e:	f64a 1394 	movw	r3, #43412	; 0xa994
    2f52:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2f56:	ea4f 1202 	mov.w	r2, r2, lsl #4
    2f5a:	4413      	add	r3, r2
    2f5c:	f103 0398 	add.w	r3, r3, #152	; 0x98
    2f60:	681b      	ldr	r3, [r3, #0]
    2f62:	ea4f 4313 	mov.w	r3, r3, lsr #16
    2f66:	ea4f 4383 	mov.w	r3, r3, lsl #18
    2f6a:	ea4f 4393 	mov.w	r3, r3, lsr #18
    2f6e:	607b      	str	r3, [r7, #4]
        retval = (int32_t)( frame_length );
    2f70:	687b      	ldr	r3, [r7, #4]
    2f72:	603b      	str	r3, [r7, #0]
    }
    return retval;
    2f74:	683b      	ldr	r3, [r7, #0]
}
    2f76:	4618      	mov	r0, r3
    2f78:	f107 0708 	add.w	r7, r7, #8
    2f7c:	46bd      	mov	sp, r7
    2f7e:	bd80      	pop	{r7, pc}

00002f80 <MSS_MAC_rx_packet>:
int32_t
MSS_MAC_rx_packet
(
	void
)
{
    2f80:	b590      	push	{r4, r7, lr}
    2f82:	b083      	sub	sp, #12
    2f84:	af00      	add	r7, sp, #0
	uint16_t frame_length=0u;
    2f86:	f04f 0300 	mov.w	r3, #0
    2f8a:	80fb      	strh	r3, [r7, #6]

    MAC_dismiss_bad_frames();
    2f8c:	f001 f968 	bl	4260 <MAC_dismiss_bad_frames>

    if( (g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 & RDES0_OWN) == 0u )
    2f90:	f64a 1394 	movw	r3, #43412	; 0xa994
    2f94:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2f98:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    2f9c:	f64a 1394 	movw	r3, #43412	; 0xa994
    2fa0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2fa4:	ea4f 1202 	mov.w	r2, r2, lsl #4
    2fa8:	4413      	add	r3, r2
    2faa:	f103 0398 	add.w	r3, r3, #152	; 0x98
    2fae:	681b      	ldr	r3, [r3, #0]
    2fb0:	2b00      	cmp	r3, #0
    2fb2:	db56      	blt.n	3062 <MSS_MAC_rx_packet+0xe2>
    {
        frame_length = ( (
    	    g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 >>
    2fb4:	f64a 1394 	movw	r3, #43412	; 0xa994
    2fb8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2fbc:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    2fc0:	f64a 1394 	movw	r3, #43412	; 0xa994
    2fc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2fc8:	ea4f 1202 	mov.w	r2, r2, lsl #4
    2fcc:	4413      	add	r3, r2
    2fce:	f103 0398 	add.w	r3, r3, #152	; 0x98
    2fd2:	681b      	ldr	r3, [r3, #0]
    2fd4:	ea4f 4313 	mov.w	r3, r3, lsr #16

    MAC_dismiss_bad_frames();

    if( (g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 & RDES0_OWN) == 0u )
    {
        frame_length = ( (
    2fd8:	b29b      	uxth	r3, r3
    2fda:	ea4f 4383 	mov.w	r3, r3, lsl #18
    2fde:	ea4f 4393 	mov.w	r3, r3, lsr #18
    2fe2:	80fb      	strh	r3, [r7, #6]
    	    g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 >>
    	    RDES0_FL_OFFSET ) & RDES0_FL_MASK );

        /* strip crc */
        frame_length -= 4u;
    2fe4:	88fb      	ldrh	r3, [r7, #6]
    2fe6:	f1a3 0304 	sub.w	r3, r3, #4
    2fea:	80fb      	strh	r3, [r7, #6]

        if( frame_length > macBUFFER_SIZE ) {
    2fec:	88fb      	ldrh	r3, [r7, #6]
    2fee:	f5b3 6fba 	cmp.w	r3, #1488	; 0x5d0
    2ff2:	d902      	bls.n	2ffa <MSS_MAC_rx_packet+0x7a>
        	return MAC_NOT_ENOUGH_SPACE;
    2ff4:	f06f 0304 	mvn.w	r3, #4
    2ff8:	e034      	b.n	3064 <MSS_MAC_rx_packet+0xe4>
        }

		/* uip_buf is about to point to the buffer that contains the received
		data, mark the buffer that uip_buf is currently pointing to as free
		again. */
		MAC_release_buffer( uip_buf );
    2ffa:	f240 6390 	movw	r3, #1680	; 0x690
    2ffe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3002:	681b      	ldr	r3, [r3, #0]
    3004:	4618      	mov	r0, r3
    3006:	f001 fd7d 	bl	4b04 <MAC_release_buffer>
        uip_buf = ( unsigned char * ) g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].buffer_1;
    300a:	f64a 1394 	movw	r3, #43412	; 0xa994
    300e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3012:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    3016:	f64a 1394 	movw	r3, #43412	; 0xa994
    301a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    301e:	f102 020a 	add.w	r2, r2, #10
    3022:	ea4f 1202 	mov.w	r2, r2, lsl #4
    3026:	4413      	add	r3, r2
    3028:	681b      	ldr	r3, [r3, #0]
    302a:	461a      	mov	r2, r3
    302c:	f240 6390 	movw	r3, #1680	; 0x690
    3030:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3034:	601a      	str	r2, [r3, #0]
		
		/* The buffer the Rx descriptor was pointing to is now in use by the
		uIP stack - allocate a new buffer to the Rx descriptor. */
		g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].buffer_1 = ( unsigned long ) MAC_obtain_buffer();
    3036:	f64a 1394 	movw	r3, #43412	; 0xa994
    303a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    303e:	f8d3 4094 	ldr.w	r4, [r3, #148]	; 0x94
    3042:	f001 fca3 	bl	498c <MAC_obtain_buffer>
    3046:	4603      	mov	r3, r0
    3048:	461a      	mov	r2, r3
    304a:	f64a 1394 	movw	r3, #43412	; 0xa994
    304e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3052:	f104 010a 	add.w	r1, r4, #10
    3056:	ea4f 1101 	mov.w	r1, r1, lsl #4
    305a:	440b      	add	r3, r1
    305c:	601a      	str	r2, [r3, #0]

        MSS_MAC_prepare_rx_descriptor();
    305e:	f000 fcb9 	bl	39d4 <MSS_MAC_prepare_rx_descriptor>
    }
    return ((int32_t)frame_length);
    3062:	88fb      	ldrh	r3, [r7, #6]
}
    3064:	4618      	mov	r0, r3
    3066:	f107 070c 	add.w	r7, r7, #12
    306a:	46bd      	mov	sp, r7
    306c:	bd90      	pop	{r4, r7, pc}
    306e:	bf00      	nop

00003070 <MSS_MAC_rx_packet_ptrset>:
MSS_MAC_rx_packet_ptrset
(
    uint8_t **pacData,
    uint32_t time_out
)
{
    3070:	b580      	push	{r7, lr}
    3072:	b084      	sub	sp, #16
    3074:	af00      	add	r7, sp, #0
    3076:	6078      	str	r0, [r7, #4]
    3078:	6039      	str	r1, [r7, #0]
	uint16_t frame_length = 0u;
    307a:	f04f 0300 	mov.w	r3, #0
    307e:	813b      	strh	r3, [r7, #8]
    int8_t exit = 0;
    3080:	f04f 0300 	mov.w	r3, #0
    3084:	72fb      	strb	r3, [r7, #11]

    configASSERT(  (time_out == MSS_MAC_BLOCKING) ||
    3086:	683b      	ldr	r3, [r7, #0]
    3088:	f1b3 3fff 	cmp.w	r3, #4294967295
    308c:	d009      	beq.n	30a2 <MSS_MAC_rx_packet_ptrset+0x32>
    308e:	683b      	ldr	r3, [r7, #0]
    3090:	2b00      	cmp	r3, #0
    3092:	d006      	beq.n	30a2 <MSS_MAC_rx_packet_ptrset+0x32>
    3094:	683b      	ldr	r3, [r7, #0]
    3096:	2b00      	cmp	r3, #0
    3098:	d006      	beq.n	30a8 <MSS_MAC_rx_packet_ptrset+0x38>
    309a:	683b      	ldr	r3, [r7, #0]
    309c:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
    30a0:	d802      	bhi.n	30a8 <MSS_MAC_rx_packet_ptrset+0x38>
    30a2:	f04f 0301 	mov.w	r3, #1
    30a6:	e001      	b.n	30ac <MSS_MAC_rx_packet_ptrset+0x3c>
    30a8:	f04f 0300 	mov.w	r3, #0
    30ac:	2b00      	cmp	r3, #0
    30ae:	d109      	bne.n	30c4 <MSS_MAC_rx_packet_ptrset+0x54>
    30b0:	f04f 0328 	mov.w	r3, #40	; 0x28
    30b4:	f383 8811 	msr	BASEPRI, r3
    30b8:	f3bf 8f6f 	isb	sy
    30bc:	f3bf 8f4f 	dsb	sy
    30c0:	60fb      	str	r3, [r7, #12]
    30c2:	e7fe      	b.n	30c2 <MSS_MAC_rx_packet_ptrset+0x52>
    			(time_out == MSS_MAC_NONBLOCKING) ||
    			((time_out >= 1) && (time_out <= 0x01000000UL)) );

    MAC_dismiss_bad_frames();
    30c4:	f001 f8cc 	bl	4260 <MAC_dismiss_bad_frames>

    /* wait for a packet */
	if( time_out != MSS_MAC_BLOCKING ) {
    30c8:	683b      	ldr	r3, [r7, #0]
    30ca:	f1b3 3fff 	cmp.w	r3, #4294967295
    30ce:	d018      	beq.n	3102 <MSS_MAC_rx_packet_ptrset+0x92>
		if( time_out == MSS_MAC_NONBLOCKING ) {
    30d0:	683b      	ldr	r3, [r7, #0]
    30d2:	2b00      	cmp	r3, #0
    30d4:	d104      	bne.n	30e0 <MSS_MAC_rx_packet_ptrset+0x70>
    		MAC_set_time_out( 0u );
    30d6:	f04f 0000 	mov.w	r0, #0
    30da:	f001 f913 	bl	4304 <MAC_set_time_out>
		} else {
    		MAC_set_time_out( time_out );
		}
	}

    while( ((g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    30de:	e011      	b.n	3104 <MSS_MAC_rx_packet_ptrset+0x94>
    /* wait for a packet */
	if( time_out != MSS_MAC_BLOCKING ) {
		if( time_out == MSS_MAC_NONBLOCKING ) {
    		MAC_set_time_out( 0u );
		} else {
    		MAC_set_time_out( time_out );
    30e0:	6838      	ldr	r0, [r7, #0]
    30e2:	f001 f90f 	bl	4304 <MAC_set_time_out>
		}
	}

    while( ((g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    30e6:	e00d      	b.n	3104 <MSS_MAC_rx_packet_ptrset+0x94>
    	RDES0_OWN) != 0u) && (exit == 0) )
    {
    	if( time_out != MSS_MAC_BLOCKING )
    30e8:	683b      	ldr	r3, [r7, #0]
    30ea:	f1b3 3fff 	cmp.w	r3, #4294967295
    30ee:	d009      	beq.n	3104 <MSS_MAC_rx_packet_ptrset+0x94>
    	{
    		if( MAC_get_time_out() == 0u ) {
    30f0:	f001 f930 	bl	4354 <MAC_get_time_out>
    30f4:	4603      	mov	r3, r0
    30f6:	2b00      	cmp	r3, #0
    30f8:	d104      	bne.n	3104 <MSS_MAC_rx_packet_ptrset+0x94>
    			exit = 1;
    30fa:	f04f 0301 	mov.w	r3, #1
    30fe:	72fb      	strb	r3, [r7, #11]
    3100:	e000      	b.n	3104 <MSS_MAC_rx_packet_ptrset+0x94>
		} else {
    		MAC_set_time_out( time_out );
		}
	}

    while( ((g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    3102:	bf00      	nop
    3104:	f64a 1394 	movw	r3, #43412	; 0xa994
    3108:	f2c2 0300 	movt	r3, #8192	; 0x2000
    310c:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    3110:	f64a 1394 	movw	r3, #43412	; 0xa994
    3114:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3118:	ea4f 1202 	mov.w	r2, r2, lsl #4
    311c:	4413      	add	r3, r2
    311e:	f103 0398 	add.w	r3, r3, #152	; 0x98
    3122:	681b      	ldr	r3, [r3, #0]
    3124:	2b00      	cmp	r3, #0
    3126:	da03      	bge.n	3130 <MSS_MAC_rx_packet_ptrset+0xc0>
    3128:	f997 300b 	ldrsb.w	r3, [r7, #11]
    312c:	2b00      	cmp	r3, #0
    312e:	d0db      	beq.n	30e8 <MSS_MAC_rx_packet_ptrset+0x78>
    			exit = 1;
    		}
    	}
    }

    if(exit == 0)
    3130:	f997 300b 	ldrsb.w	r3, [r7, #11]
    3134:	2b00      	cmp	r3, #0
    3136:	d12e      	bne.n	3196 <MSS_MAC_rx_packet_ptrset+0x126>
    {
        frame_length = ( (
    	    g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 >>
    3138:	f64a 1394 	movw	r3, #43412	; 0xa994
    313c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3140:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    3144:	f64a 1394 	movw	r3, #43412	; 0xa994
    3148:	f2c2 0300 	movt	r3, #8192	; 0x2000
    314c:	ea4f 1202 	mov.w	r2, r2, lsl #4
    3150:	4413      	add	r3, r2
    3152:	f103 0398 	add.w	r3, r3, #152	; 0x98
    3156:	681b      	ldr	r3, [r3, #0]
    3158:	ea4f 4313 	mov.w	r3, r3, lsr #16
    	}
    }

    if(exit == 0)
    {
        frame_length = ( (
    315c:	b29b      	uxth	r3, r3
    315e:	ea4f 4383 	mov.w	r3, r3, lsl #18
    3162:	ea4f 4393 	mov.w	r3, r3, lsr #18
    3166:	813b      	strh	r3, [r7, #8]
    	    g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 >>
    	    RDES0_FL_OFFSET ) & RDES0_FL_MASK );

        /* strip crc */
        frame_length -= 4u;
    3168:	893b      	ldrh	r3, [r7, #8]
    316a:	f1a3 0304 	sub.w	r3, r3, #4
    316e:	813b      	strh	r3, [r7, #8]
       /* Here we are setting the buffer 'pacData' address to the address
          RX descriptor address. After this is called, the following function
          must be called 'MAC_prepare_rx_descriptor'
          to prepare the current rx descriptor for receiving the next packet.
       */
    	*pacData = (uint8_t *)g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].buffer_1 ;
    3170:	f64a 1394 	movw	r3, #43412	; 0xa994
    3174:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3178:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    317c:	f64a 1394 	movw	r3, #43412	; 0xa994
    3180:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3184:	f102 020a 	add.w	r2, r2, #10
    3188:	ea4f 1202 	mov.w	r2, r2, lsl #4
    318c:	4413      	add	r3, r2
    318e:	681b      	ldr	r3, [r3, #0]
    3190:	461a      	mov	r2, r3
    3192:	687b      	ldr	r3, [r7, #4]
    3194:	601a      	str	r2, [r3, #0]

    }
    return ((int32_t)frame_length);
    3196:	893b      	ldrh	r3, [r7, #8]
}
    3198:	4618      	mov	r0, r3
    319a:	f107 0710 	add.w	r7, r7, #16
    319e:	46bd      	mov	sp, r7
    31a0:	bd80      	pop	{r7, pc}
    31a2:	bf00      	nop

000031a4 <MSS_MAC_link_status>:
int32_t
MSS_MAC_link_status
(
    void
)
{
    31a4:	b580      	push	{r7, lr}
    31a6:	b082      	sub	sp, #8
    31a8:	af00      	add	r7, sp, #0
	uint32_t link;

    link = PHY_link_status();
    31aa:	f001 fe6b 	bl	4e84 <PHY_link_status>
    31ae:	4603      	mov	r3, r0
    31b0:	607b      	str	r3, [r7, #4]
    if( link == MSS_MAC_LINK_STATUS_LINK ) {
    31b2:	687b      	ldr	r3, [r7, #4]
    31b4:	2b01      	cmp	r3, #1
    31b6:	d106      	bne.n	31c6 <MSS_MAC_link_status+0x22>
    	link |= PHY_link_type();
    31b8:	f001 fe7c 	bl	4eb4 <PHY_link_type>
    31bc:	4603      	mov	r3, r0
    31be:	687a      	ldr	r2, [r7, #4]
    31c0:	ea42 0303 	orr.w	r3, r2, r3
    31c4:	607b      	str	r3, [r7, #4]
    }

    return ((int32_t)link);
    31c6:	687b      	ldr	r3, [r7, #4]
}
    31c8:	4618      	mov	r0, r3
    31ca:	f107 0708 	add.w	r7, r7, #8
    31ce:	46bd      	mov	sp, r7
    31d0:	bd80      	pop	{r7, pc}
    31d2:	bf00      	nop

000031d4 <MSS_MAC_auto_setup_link>:
int32_t
MSS_MAC_auto_setup_link
(
    void
)
{
    31d4:	b580      	push	{r7, lr}
    31d6:	b084      	sub	sp, #16
    31d8:	af00      	add	r7, sp, #0
	int32_t link;

    PHY_auto_negotiate();
    31da:	f001 fe2b 	bl	4e34 <PHY_auto_negotiate>

    link = MSS_MAC_link_status();
    31de:	f7ff ffe1 	bl	31a4 <MSS_MAC_link_status>
    31e2:	4603      	mov	r3, r0
    31e4:	603b      	str	r3, [r7, #0]

    if( (link & MSS_MAC_LINK_STATUS_LINK) != 0u ) {
    31e6:	683b      	ldr	r3, [r7, #0]
    31e8:	f003 0301 	and.w	r3, r3, #1
    31ec:	b2db      	uxtb	r3, r3
    31ee:	2b00      	cmp	r3, #0
    31f0:	d051      	beq.n	3296 <MSS_MAC_auto_setup_link+0xc2>
    	int32_t ret;
	    ret = MAC_stop_transmission();
    31f2:	f000 ffb9 	bl	4168 <MAC_stop_transmission>
    31f6:	4603      	mov	r3, r0
    31f8:	607b      	str	r3, [r7, #4]
	    MAC_CHECK( ret == MAC_OK, ret );
    31fa:	687b      	ldr	r3, [r7, #4]
    31fc:	2b00      	cmp	r3, #0
    31fe:	d013      	beq.n	3228 <MSS_MAC_auto_setup_link+0x54>
    3200:	687b      	ldr	r3, [r7, #4]
    3202:	b2da      	uxtb	r2, r3
    3204:	f64a 1394 	movw	r3, #43412	; 0xa994
    3208:	f2c2 0300 	movt	r3, #8192	; 0x2000
    320c:	715a      	strb	r2, [r3, #5]
    320e:	687b      	ldr	r3, [r7, #4]
    3210:	2b00      	cmp	r3, #0
    3212:	d009      	beq.n	3228 <MSS_MAC_auto_setup_link+0x54>
    3214:	f04f 0328 	mov.w	r3, #40	; 0x28
    3218:	f383 8811 	msr	BASEPRI, r3
    321c:	f3bf 8f6f 	isb	sy
    3220:	f3bf 8f4f 	dsb	sy
    3224:	60bb      	str	r3, [r7, #8]
    3226:	e7fe      	b.n	3226 <MSS_MAC_auto_setup_link+0x52>

	    ret = MAC_stop_receiving();
    3228:	f000 ffdc 	bl	41e4 <MAC_stop_receiving>
    322c:	4603      	mov	r3, r0
    322e:	607b      	str	r3, [r7, #4]
	    MAC_CHECK( ret == MAC_OK, ret );
    3230:	687b      	ldr	r3, [r7, #4]
    3232:	2b00      	cmp	r3, #0
    3234:	d013      	beq.n	325e <MSS_MAC_auto_setup_link+0x8a>
    3236:	687b      	ldr	r3, [r7, #4]
    3238:	b2da      	uxtb	r2, r3
    323a:	f64a 1394 	movw	r3, #43412	; 0xa994
    323e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3242:	715a      	strb	r2, [r3, #5]
    3244:	687b      	ldr	r3, [r7, #4]
    3246:	2b00      	cmp	r3, #0
    3248:	d009      	beq.n	325e <MSS_MAC_auto_setup_link+0x8a>
    324a:	f04f 0328 	mov.w	r3, #40	; 0x28
    324e:	f383 8811 	msr	BASEPRI, r3
    3252:	f3bf 8f6f 	isb	sy
    3256:	f3bf 8f4f 	dsb	sy
    325a:	60fb      	str	r3, [r7, #12]
    325c:	e7fe      	b.n	325c <MSS_MAC_auto_setup_link+0x88>
        MAC_BITBAND->CSR6_TTM = (uint32_t)((((uint32_t)link & MSS_MAC_LINK_STATUS_100MB) != 0u) ? 1u : 0u );
    325e:	f240 0300 	movw	r3, #0
    3262:	f2c4 2306 	movt	r3, #16902	; 0x4206
    3266:	683a      	ldr	r2, [r7, #0]
    3268:	f002 0202 	and.w	r2, r2, #2
    326c:	2a00      	cmp	r2, #0
    326e:	d002      	beq.n	3276 <MSS_MAC_auto_setup_link+0xa2>
    3270:	f04f 0201 	mov.w	r2, #1
    3274:	e001      	b.n	327a <MSS_MAC_auto_setup_link+0xa6>
    3276:	f04f 0200 	mov.w	r2, #0
    327a:	f8c3 2658 	str.w	r2, [r3, #1624]	; 0x658
        MAC_BITBAND->CSR6_FD = (uint32_t)((((uint32_t)link & MSS_MAC_LINK_STATUS_FDX) != 0u) ? 1u : 1u );
    327e:	f240 0300 	movw	r3, #0
    3282:	f2c4 2306 	movt	r3, #16902	; 0x4206
    3286:	f04f 0201 	mov.w	r2, #1
    328a:	f8c3 2624 	str.w	r2, [r3, #1572]	; 0x624
	    MAC_start_transmission();
    328e:	f000 ff9b 	bl	41c8 <MAC_start_transmission>
	    MAC_start_receiving();
    3292:	f000 ffd7 	bl	4244 <MAC_start_receiving>
    }

    return link;
    3296:	683b      	ldr	r3, [r7, #0]
}
    3298:	4618      	mov	r0, r3
    329a:	f107 0710 	add.w	r7, r7, #16
    329e:	46bd      	mov	sp, r7
    32a0:	bd80      	pop	{r7, pc}
    32a2:	bf00      	nop

000032a4 <MSS_MAC_set_mac_address>:
void
MSS_MAC_set_mac_address
(
    const uint8_t *new_address
)
{
    32a4:	b580      	push	{r7, lr}
    32a6:	b084      	sub	sp, #16
    32a8:	af00      	add	r7, sp, #0
    32aa:	6078      	str	r0, [r7, #4]
    /* Check if the new address is unicast */
    configASSERT( (new_address[0]&1) == 0 );
    32ac:	687b      	ldr	r3, [r7, #4]
    32ae:	781b      	ldrb	r3, [r3, #0]
    32b0:	f003 0301 	and.w	r3, r3, #1
    32b4:	2b00      	cmp	r3, #0
    32b6:	d009      	beq.n	32cc <MSS_MAC_set_mac_address+0x28>
    32b8:	f04f 0328 	mov.w	r3, #40	; 0x28
    32bc:	f383 8811 	msr	BASEPRI, r3
    32c0:	f3bf 8f6f 	isb	sy
    32c4:	f3bf 8f4f 	dsb	sy
    32c8:	60fb      	str	r3, [r7, #12]
    32ca:	e7fe      	b.n	32ca <MSS_MAC_set_mac_address+0x26>

   	MAC_memcpy( g_mss_mac.mac_address, new_address, 6u );
    32cc:	481c      	ldr	r0, [pc, #112]	; (3340 <MSS_MAC_set_mac_address+0x9c>)
    32ce:	6879      	ldr	r1, [r7, #4]
    32d0:	f04f 0206 	mov.w	r2, #6
    32d4:	f001 faf8 	bl	48c8 <MAC_memcpy>

   	if((g_mss_mac.flags & FLAG_PERFECT_FILTERING) != 0u ) {
    32d8:	f64a 1394 	movw	r3, #43412	; 0xa994
    32dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    32e0:	791b      	ldrb	r3, [r3, #4]
    32e2:	f003 0302 	and.w	r3, r3, #2
    32e6:	2b00      	cmp	r3, #0
    32e8:	d023      	beq.n	3332 <MSS_MAC_set_mac_address+0x8e>
		int32_t a;
	   	/* set unused filters to the new mac address */
		for( a=14*6; a>=0; a-=6 ) {
    32ea:	f04f 0354 	mov.w	r3, #84	; 0x54
    32ee:	60bb      	str	r3, [r7, #8]
    32f0:	e01c      	b.n	332c <MSS_MAC_set_mac_address+0x88>
			if( (g_mss_mac.mac_filter_data[a] & 1u) != 0u ) {
    32f2:	68ba      	ldr	r2, [r7, #8]
    32f4:	f64a 1394 	movw	r3, #43412	; 0xa994
    32f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    32fc:	4413      	add	r3, r2
    32fe:	7b1b      	ldrb	r3, [r3, #12]
    3300:	f003 0301 	and.w	r3, r3, #1
    3304:	b2db      	uxtb	r3, r3
    3306:	2b00      	cmp	r3, #0
    3308:	d003      	beq.n	3312 <MSS_MAC_set_mac_address+0x6e>
				/* Filters with multicast addresses are used */
				a = -1;
    330a:	f04f 33ff 	mov.w	r3, #4294967295
    330e:	60bb      	str	r3, [r7, #8]
    3310:	e008      	b.n	3324 <MSS_MAC_set_mac_address+0x80>
			} else {
				MAC_memcpy( &(g_mss_mac.mac_filter_data[a]),
    3312:	68ba      	ldr	r2, [r7, #8]
    3314:	4b0b      	ldr	r3, [pc, #44]	; (3344 <MSS_MAC_set_mac_address+0xa0>)
    3316:	4413      	add	r3, r2
    3318:	4618      	mov	r0, r3
    331a:	4909      	ldr	r1, [pc, #36]	; (3340 <MSS_MAC_set_mac_address+0x9c>)
    331c:	f04f 0206 	mov.w	r2, #6
    3320:	f001 fad2 	bl	48c8 <MAC_memcpy>
   	MAC_memcpy( g_mss_mac.mac_address, new_address, 6u );

   	if((g_mss_mac.flags & FLAG_PERFECT_FILTERING) != 0u ) {
		int32_t a;
	   	/* set unused filters to the new mac address */
		for( a=14*6; a>=0; a-=6 ) {
    3324:	68bb      	ldr	r3, [r7, #8]
    3326:	f1a3 0306 	sub.w	r3, r3, #6
    332a:	60bb      	str	r3, [r7, #8]
    332c:	68bb      	ldr	r3, [r7, #8]
    332e:	2b00      	cmp	r3, #0
    3330:	dadf      	bge.n	32f2 <MSS_MAC_set_mac_address+0x4e>
					g_mss_mac.mac_address, 6u );
			}
		}
   	}

   	MAC_send_setup_frame();
    3332:	f000 fd63 	bl	3dfc <MAC_send_setup_frame>
}
    3336:	f107 0710 	add.w	r7, r7, #16
    333a:	46bd      	mov	sp, r7
    333c:	bd80      	pop	{r7, pc}
    333e:	bf00      	nop
    3340:	2000a99a 	.word	0x2000a99a
    3344:	2000a9a0 	.word	0x2000a9a0

00003348 <MSS_MAC_get_mac_address>:
void
MSS_MAC_get_mac_address
(
    uint8_t *address
)
{
    3348:	b580      	push	{r7, lr}
    334a:	b082      	sub	sp, #8
    334c:	af00      	add	r7, sp, #0
    334e:	6078      	str	r0, [r7, #4]
   	MAC_memcpy( address, g_mss_mac.mac_address, 6u );
    3350:	6878      	ldr	r0, [r7, #4]
    3352:	4904      	ldr	r1, [pc, #16]	; (3364 <MSS_MAC_get_mac_address+0x1c>)
    3354:	f04f 0206 	mov.w	r2, #6
    3358:	f001 fab6 	bl	48c8 <MAC_memcpy>
}
    335c:	f107 0708 	add.w	r7, r7, #8
    3360:	46bd      	mov	sp, r7
    3362:	bd80      	pop	{r7, pc}
    3364:	2000a99a 	.word	0x2000a99a

00003368 <MSS_MAC_set_mac_filters>:
MSS_MAC_set_mac_filters
(
	uint16_t filter_count,
	const uint8_t *filters
)
{
    3368:	b580      	push	{r7, lr}
    336a:	b08a      	sub	sp, #40	; 0x28
    336c:	af00      	add	r7, sp, #0
    336e:	4603      	mov	r3, r0
    3370:	6039      	str	r1, [r7, #0]
    3372:	80fb      	strh	r3, [r7, #6]
    configASSERT( (filter_count==0) || (filters != NULL_buffer) );
    3374:	88fb      	ldrh	r3, [r7, #6]
    3376:	2b00      	cmp	r3, #0
    3378:	d007      	beq.n	338a <MSS_MAC_set_mac_filters+0x22>
    337a:	f240 6388 	movw	r3, #1672	; 0x688
    337e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3382:	681b      	ldr	r3, [r3, #0]
    3384:	683a      	ldr	r2, [r7, #0]
    3386:	429a      	cmp	r2, r3
    3388:	d002      	beq.n	3390 <MSS_MAC_set_mac_filters+0x28>
    338a:	f04f 0301 	mov.w	r3, #1
    338e:	e001      	b.n	3394 <MSS_MAC_set_mac_filters+0x2c>
    3390:	f04f 0300 	mov.w	r3, #0
    3394:	2b00      	cmp	r3, #0
    3396:	d109      	bne.n	33ac <MSS_MAC_set_mac_filters+0x44>
    3398:	f04f 0328 	mov.w	r3, #40	; 0x28
    339c:	f383 8811 	msr	BASEPRI, r3
    33a0:	f3bf 8f6f 	isb	sy
    33a4:	f3bf 8f4f 	dsb	sy
    33a8:	623b      	str	r3, [r7, #32]
    33aa:	e7fe      	b.n	33aa <MSS_MAC_set_mac_filters+0x42>
    /* Check if the mac addresses is multicast */
    {
    	int32_t a;
    	for( a = 0u; a < filter_count; a++ ) {
    33ac:	f04f 0300 	mov.w	r3, #0
    33b0:	60fb      	str	r3, [r7, #12]
    33b2:	e01c      	b.n	33ee <MSS_MAC_set_mac_filters+0x86>
    		configASSERT( (filters[a*6]&1) == 1 );
    33b4:	68fa      	ldr	r2, [r7, #12]
    33b6:	4613      	mov	r3, r2
    33b8:	ea4f 0343 	mov.w	r3, r3, lsl #1
    33bc:	4413      	add	r3, r2
    33be:	ea4f 0343 	mov.w	r3, r3, lsl #1
    33c2:	461a      	mov	r2, r3
    33c4:	683b      	ldr	r3, [r7, #0]
    33c6:	4413      	add	r3, r2
    33c8:	781b      	ldrb	r3, [r3, #0]
    33ca:	f003 0301 	and.w	r3, r3, #1
    33ce:	2b00      	cmp	r3, #0
    33d0:	d109      	bne.n	33e6 <MSS_MAC_set_mac_filters+0x7e>
    33d2:	f04f 0328 	mov.w	r3, #40	; 0x28
    33d6:	f383 8811 	msr	BASEPRI, r3
    33da:	f3bf 8f6f 	isb	sy
    33de:	f3bf 8f4f 	dsb	sy
    33e2:	627b      	str	r3, [r7, #36]	; 0x24
    33e4:	e7fe      	b.n	33e4 <MSS_MAC_set_mac_filters+0x7c>
{
    configASSERT( (filter_count==0) || (filters != NULL_buffer) );
    /* Check if the mac addresses is multicast */
    {
    	int32_t a;
    	for( a = 0u; a < filter_count; a++ ) {
    33e6:	68fb      	ldr	r3, [r7, #12]
    33e8:	f103 0301 	add.w	r3, r3, #1
    33ec:	60fb      	str	r3, [r7, #12]
    33ee:	88fa      	ldrh	r2, [r7, #6]
    33f0:	68fb      	ldr	r3, [r7, #12]
    33f2:	429a      	cmp	r2, r3
    33f4:	dcde      	bgt.n	33b4 <MSS_MAC_set_mac_filters+0x4c>
    		configASSERT( (filters[a*6]&1) == 1 );
    	}
    }

    if( filter_count <= 15 ){
    33f6:	88fb      	ldrh	r3, [r7, #6]
    33f8:	2b0f      	cmp	r3, #15
    33fa:	d833      	bhi.n	3464 <MSS_MAC_set_mac_filters+0xfc>
    	int32_t a;
    	g_mss_mac.flags |= FLAG_PERFECT_FILTERING;
    33fc:	f64a 1394 	movw	r3, #43412	; 0xa994
    3400:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3404:	791b      	ldrb	r3, [r3, #4]
    3406:	f043 0302 	orr.w	r3, r3, #2
    340a:	b2da      	uxtb	r2, r3
    340c:	f64a 1394 	movw	r3, #43412	; 0xa994
    3410:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3414:	711a      	strb	r2, [r3, #4]

    	/* copy new filters */
    	MAC_memcpy( g_mss_mac.mac_filter_data, filters, (uint32_t)(filter_count*6));
    3416:	88fa      	ldrh	r2, [r7, #6]
    3418:	4613      	mov	r3, r2
    341a:	ea4f 0343 	mov.w	r3, r3, lsl #1
    341e:	4413      	add	r3, r2
    3420:	ea4f 0343 	mov.w	r3, r3, lsl #1
    3424:	483c      	ldr	r0, [pc, #240]	; (3518 <MSS_MAC_set_mac_filters+0x1b0>)
    3426:	6839      	ldr	r1, [r7, #0]
    3428:	461a      	mov	r2, r3
    342a:	f001 fa4d 	bl	48c8 <MAC_memcpy>

    	/* set unused filters to our mac address */
    	for( a=filter_count; a<15; a++ ) {
    342e:	88fb      	ldrh	r3, [r7, #6]
    3430:	613b      	str	r3, [r7, #16]
    3432:	e013      	b.n	345c <MSS_MAC_set_mac_filters+0xf4>
   			MAC_memcpy( &(g_mss_mac.mac_filter_data[a*6]),
    3434:	693a      	ldr	r2, [r7, #16]
    3436:	4613      	mov	r3, r2
    3438:	ea4f 0343 	mov.w	r3, r3, lsl #1
    343c:	4413      	add	r3, r2
    343e:	ea4f 0343 	mov.w	r3, r3, lsl #1
    3442:	461a      	mov	r2, r3
    3444:	4b34      	ldr	r3, [pc, #208]	; (3518 <MSS_MAC_set_mac_filters+0x1b0>)
    3446:	4413      	add	r3, r2
    3448:	4618      	mov	r0, r3
    344a:	4934      	ldr	r1, [pc, #208]	; (351c <MSS_MAC_set_mac_filters+0x1b4>)
    344c:	f04f 0206 	mov.w	r2, #6
    3450:	f001 fa3a 	bl	48c8 <MAC_memcpy>

    	/* copy new filters */
    	MAC_memcpy( g_mss_mac.mac_filter_data, filters, (uint32_t)(filter_count*6));

    	/* set unused filters to our mac address */
    	for( a=filter_count; a<15; a++ ) {
    3454:	693b      	ldr	r3, [r7, #16]
    3456:	f103 0301 	add.w	r3, r3, #1
    345a:	613b      	str	r3, [r7, #16]
    345c:	693b      	ldr	r3, [r7, #16]
    345e:	2b0e      	cmp	r3, #14
    3460:	dde8      	ble.n	3434 <MSS_MAC_set_mac_filters+0xcc>
    3462:	e052      	b.n	350a <MSS_MAC_set_mac_filters+0x1a2>
    	}
    } else {
    	int32_t a,b;
    	uint32_t hash;

    	g_mss_mac.flags &= ~FLAG_PERFECT_FILTERING;
    3464:	f64a 1394 	movw	r3, #43412	; 0xa994
    3468:	f2c2 0300 	movt	r3, #8192	; 0x2000
    346c:	791b      	ldrb	r3, [r3, #4]
    346e:	461a      	mov	r2, r3
    3470:	f002 02fd 	and.w	r2, r2, #253	; 0xfd
    3474:	f64a 1394 	movw	r3, #43412	; 0xa994
    3478:	f2c2 0300 	movt	r3, #8192	; 0x2000
    347c:	711a      	strb	r2, [r3, #4]

    	/* reset hash table */
    	MAC_memset( g_mss_mac.mac_filter_data, 0u, 64u );
    347e:	4826      	ldr	r0, [pc, #152]	; (3518 <MSS_MAC_set_mac_filters+0x1b0>)
    3480:	f04f 0100 	mov.w	r1, #0
    3484:	f04f 0240 	mov.w	r2, #64	; 0x40
    3488:	f000 ffde 	bl	4448 <MAC_memset>

    	for( a=0, b=0; a<filter_count; a++, b+=6 ) {
    348c:	f04f 0300 	mov.w	r3, #0
    3490:	617b      	str	r3, [r7, #20]
    3492:	f04f 0300 	mov.w	r3, #0
    3496:	61bb      	str	r3, [r7, #24]
    3498:	e033      	b.n	3502 <MSS_MAC_set_mac_filters+0x19a>
    		hash = mss_ethernet_crc( &(filters[b]), 6 ) & 0x1FF;
    349a:	69ba      	ldr	r2, [r7, #24]
    349c:	683b      	ldr	r3, [r7, #0]
    349e:	4413      	add	r3, r2
    34a0:	4618      	mov	r0, r3
    34a2:	f04f 0106 	mov.w	r1, #6
    34a6:	f7fe ff0b 	bl	22c0 <mss_ethernet_crc>
    34aa:	4603      	mov	r3, r0
    34ac:	ea4f 53c3 	mov.w	r3, r3, lsl #23
    34b0:	ea4f 53d3 	mov.w	r3, r3, lsr #23
    34b4:	61fb      	str	r3, [r7, #28]
    		g_mss_mac.mac_filter_data[ hash / 8 ] |= 1 << (hash & 0x7);
    34b6:	69fb      	ldr	r3, [r7, #28]
    34b8:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    34bc:	4619      	mov	r1, r3
    34be:	461a      	mov	r2, r3
    34c0:	f64a 1394 	movw	r3, #43412	; 0xa994
    34c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    34c8:	4413      	add	r3, r2
    34ca:	7b1b      	ldrb	r3, [r3, #12]
    34cc:	461a      	mov	r2, r3
    34ce:	69fb      	ldr	r3, [r7, #28]
    34d0:	f003 0307 	and.w	r3, r3, #7
    34d4:	f04f 0001 	mov.w	r0, #1
    34d8:	fa00 f303 	lsl.w	r3, r0, r3
    34dc:	b2db      	uxtb	r3, r3
    34de:	ea42 0303 	orr.w	r3, r2, r3
    34e2:	b2db      	uxtb	r3, r3
    34e4:	b2da      	uxtb	r2, r3
    34e6:	f64a 1394 	movw	r3, #43412	; 0xa994
    34ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    34ee:	440b      	add	r3, r1
    34f0:	731a      	strb	r2, [r3, #12]
    	g_mss_mac.flags &= ~FLAG_PERFECT_FILTERING;

    	/* reset hash table */
    	MAC_memset( g_mss_mac.mac_filter_data, 0u, 64u );

    	for( a=0, b=0; a<filter_count; a++, b+=6 ) {
    34f2:	697b      	ldr	r3, [r7, #20]
    34f4:	f103 0301 	add.w	r3, r3, #1
    34f8:	617b      	str	r3, [r7, #20]
    34fa:	69bb      	ldr	r3, [r7, #24]
    34fc:	f103 0306 	add.w	r3, r3, #6
    3500:	61bb      	str	r3, [r7, #24]
    3502:	88fa      	ldrh	r2, [r7, #6]
    3504:	697b      	ldr	r3, [r7, #20]
    3506:	429a      	cmp	r2, r3
    3508:	dcc7      	bgt.n	349a <MSS_MAC_set_mac_filters+0x132>
    		hash = mss_ethernet_crc( &(filters[b]), 6 ) & 0x1FF;
    		g_mss_mac.mac_filter_data[ hash / 8 ] |= 1 << (hash & 0x7);
    	}
    }

    MAC_send_setup_frame();
    350a:	f000 fc77 	bl	3dfc <MAC_send_setup_frame>
}
    350e:	f107 0728 	add.w	r7, r7, #40	; 0x28
    3512:	46bd      	mov	sp, r7
    3514:	bd80      	pop	{r7, pc}
    3516:	bf00      	nop
    3518:	2000a9a0 	.word	0x2000a9a0
    351c:	2000a99a 	.word	0x2000a99a

00003520 <EthernetMAC_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void EthernetMAC_IRQHandler( void )
#else
void EthernetMAC_IRQHandler( void )
#endif
{
    3520:	4668      	mov	r0, sp
    3522:	f020 0107 	bic.w	r1, r0, #7
    3526:	468d      	mov	sp, r1
    3528:	b581      	push	{r0, r7, lr}
    352a:	b083      	sub	sp, #12
    352c:	af00      	add	r7, sp, #0
    uint32_t events;
    uint32_t intr_status;

    events = 0u;
    352e:	f04f 0300 	mov.w	r3, #0
    3532:	603b      	str	r3, [r7, #0]
    intr_status = MAC->CSR5;
    3534:	f243 0300 	movw	r3, #12288	; 0x3000
    3538:	f2c4 0300 	movt	r3, #16384	; 0x4000
    353c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    353e:	607b      	str	r3, [r7, #4]

    if( (intr_status & CSR5_NIS_MASK) != 0u ) {
    3540:	687b      	ldr	r3, [r7, #4]
    3542:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
    3546:	2b00      	cmp	r3, #0
    3548:	d062      	beq.n	3610 <EthernetMAC_IRQHandler+0xf0>
    	if( (intr_status & CSR5_TI_MASK) != 0u ) { /* Transmit */
    354a:	687b      	ldr	r3, [r7, #4]
    354c:	f003 0301 	and.w	r3, r3, #1
    3550:	b2db      	uxtb	r3, r3
    3552:	2b00      	cmp	r3, #0
    3554:	d02b      	beq.n	35ae <EthernetMAC_IRQHandler+0x8e>
    		g_mss_mac.statistics.tx_interrupts++;
    3556:	f64a 1394 	movw	r3, #43412	; 0xa994
    355a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    355e:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
    3562:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3566:	f893 3118 	ldrb.w	r3, [r3, #280]	; 0x118
    356a:	ea4f 6303 	mov.w	r3, r3, lsl #24
    356e:	ea43 0302 	orr.w	r3, r3, r2
    3572:	f103 0201 	add.w	r2, r3, #1
    3576:	f64a 1394 	movw	r3, #43412	; 0xa994
    357a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    357e:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    3582:	ea4f 2101 	mov.w	r1, r1, lsl #8
    3586:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
    358a:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    358e:	ea40 0101 	orr.w	r1, r0, r1
    3592:	f8c3 1114 	str.w	r1, [r3, #276]	; 0x114
    3596:	ea4f 6212 	mov.w	r2, r2, lsr #24
    359a:	f04f 0100 	mov.w	r1, #0
    359e:	ea41 0202 	orr.w	r2, r1, r2
    35a2:	f883 2118 	strb.w	r2, [r3, #280]	; 0x118
    		events |= MSS_MAC_EVENT_PACKET_SEND;
    35a6:	683b      	ldr	r3, [r7, #0]
    35a8:	f043 0301 	orr.w	r3, r3, #1
    35ac:	603b      	str	r3, [r7, #0]
    	}

    	if( (intr_status & CSR5_RI_MASK) != 0u ) { /* Receive */
    35ae:	687b      	ldr	r3, [r7, #4]
    35b0:	f003 0340 	and.w	r3, r3, #64	; 0x40
    35b4:	2b00      	cmp	r3, #0
    35b6:	d02b      	beq.n	3610 <EthernetMAC_IRQHandler+0xf0>
    		g_mss_mac.statistics.rx_interrupts++;
    35b8:	f64a 1394 	movw	r3, #43412	; 0xa994
    35bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    35c0:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
    35c4:	ea4f 2212 	mov.w	r2, r2, lsr #8
    35c8:	f893 30ec 	ldrb.w	r3, [r3, #236]	; 0xec
    35cc:	ea4f 6303 	mov.w	r3, r3, lsl #24
    35d0:	ea43 0302 	orr.w	r3, r3, r2
    35d4:	f103 0201 	add.w	r2, r3, #1
    35d8:	f64a 1394 	movw	r3, #43412	; 0xa994
    35dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    35e0:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    35e4:	ea4f 2101 	mov.w	r1, r1, lsl #8
    35e8:	f8d3 00e8 	ldr.w	r0, [r3, #232]	; 0xe8
    35ec:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    35f0:	ea40 0101 	orr.w	r1, r0, r1
    35f4:	f8c3 10e8 	str.w	r1, [r3, #232]	; 0xe8
    35f8:	ea4f 6212 	mov.w	r2, r2, lsr #24
    35fc:	f04f 0100 	mov.w	r1, #0
    3600:	ea41 0202 	orr.w	r2, r1, r2
    3604:	f883 20ec 	strb.w	r2, [r3, #236]	; 0xec
    		events |= MSS_MAC_EVENT_PACKET_RECEIVED;
    3608:	683b      	ldr	r3, [r7, #0]
    360a:	f043 0302 	orr.w	r3, r3, #2
    360e:	603b      	str	r3, [r7, #0]
    	}
    }

    /* Clear interrupts */
    MAC->CSR5 = CSR5_INT_BITS;
    3610:	f243 0300 	movw	r3, #12288	; 0x3000
    3614:	f2c4 0300 	movt	r3, #16384	; 0x4000
    3618:	f64c 52e7 	movw	r2, #52711	; 0xcde7
    361c:	f2c0 0201 	movt	r2, #1
    3620:	629a      	str	r2, [r3, #40]	; 0x28

    if( (events != 0u) && (g_mss_mac.listener != NULL_callback) ) {
    3622:	683b      	ldr	r3, [r7, #0]
    3624:	2b00      	cmp	r3, #0
    3626:	d012      	beq.n	364e <EthernetMAC_IRQHandler+0x12e>
    3628:	f64a 1394 	movw	r3, #43412	; 0xa994
    362c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3630:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    3632:	f240 638c 	movw	r3, #1676	; 0x68c
    3636:	f2c2 0300 	movt	r3, #8192	; 0x2000
    363a:	681b      	ldr	r3, [r3, #0]
    363c:	429a      	cmp	r2, r3
    363e:	d006      	beq.n	364e <EthernetMAC_IRQHandler+0x12e>
        g_mss_mac.listener( events );
    3640:	f64a 1394 	movw	r3, #43412	; 0xa994
    3644:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3648:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    364a:	6838      	ldr	r0, [r7, #0]
    364c:	4798      	blx	r3
    }
}
    364e:	f107 070c 	add.w	r7, r7, #12
    3652:	46bd      	mov	sp, r7
    3654:	e8bd 4081 	ldmia.w	sp!, {r0, r7, lr}
    3658:	4685      	mov	sp, r0
    365a:	4770      	bx	lr

0000365c <MSS_MAC_set_callback>:
void
MSS_MAC_set_callback
(
    MSS_MAC_callback_t listener
)
{
    365c:	b480      	push	{r7}
    365e:	b083      	sub	sp, #12
    3660:	af00      	add	r7, sp, #0
    3662:	6078      	str	r0, [r7, #4]
	/* disable tx and rx interrupts */
    MAC_BITBAND->CSR7_RIE = 0u;
    3664:	f240 0300 	movw	r3, #0
    3668:	f2c4 2306 	movt	r3, #16902	; 0x4206
    366c:	f04f 0200 	mov.w	r2, #0
    3670:	f8c3 2718 	str.w	r2, [r3, #1816]	; 0x718
    MAC_BITBAND->CSR7_TIE = 0u;
    3674:	f240 0300 	movw	r3, #0
    3678:	f2c4 2306 	movt	r3, #16902	; 0x4206
    367c:	f04f 0200 	mov.w	r2, #0
    3680:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700

    g_mss_mac.listener = listener;
    3684:	f64a 1394 	movw	r3, #43412	; 0xa994
    3688:	f2c2 0300 	movt	r3, #8192	; 0x2000
    368c:	687a      	ldr	r2, [r7, #4]
    368e:	66da      	str	r2, [r3, #108]	; 0x6c

	if( listener != NULL_callback ) {
    3690:	f240 638c 	movw	r3, #1676	; 0x68c
    3694:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3698:	681b      	ldr	r3, [r3, #0]
    369a:	687a      	ldr	r2, [r7, #4]
    369c:	429a      	cmp	r2, r3
    369e:	d00f      	beq.n	36c0 <MSS_MAC_set_callback+0x64>
		/* enable tx and rx interrupts */
        MAC_BITBAND->CSR7_RIE = 1u;
    36a0:	f240 0300 	movw	r3, #0
    36a4:	f2c4 2306 	movt	r3, #16902	; 0x4206
    36a8:	f04f 0201 	mov.w	r2, #1
    36ac:	f8c3 2718 	str.w	r2, [r3, #1816]	; 0x718
        MAC_BITBAND->CSR7_TIE = 1u;
    36b0:	f240 0300 	movw	r3, #0
    36b4:	f2c4 2306 	movt	r3, #16902	; 0x4206
    36b8:	f04f 0201 	mov.w	r2, #1
    36bc:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700
	}
}
    36c0:	f107 070c 	add.w	r7, r7, #12
    36c4:	46bd      	mov	sp, r7
    36c6:	bc80      	pop	{r7}
    36c8:	4770      	bx	lr
    36ca:	bf00      	nop

000036cc <MSS_MAC_last_error>:
const int8_t*
MSS_MAC_last_error
(
    void
)
{
    36cc:	b480      	push	{r7}
    36ce:	b083      	sub	sp, #12
    36d0:	af00      	add	r7, sp, #0
	int8_t error_msg_nb;
    const int8_t* returnvalue;

	error_msg_nb = -(g_mss_mac.last_error);
    36d2:	f64a 1394 	movw	r3, #43412	; 0xa994
    36d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    36da:	795b      	ldrb	r3, [r3, #5]
    36dc:	f1c3 0300 	rsb	r3, r3, #0
    36e0:	70fb      	strb	r3, [r7, #3]
	if( error_msg_nb >= ERROR_MESSAGE_COUNT ) {
    36e2:	f997 3003 	ldrsb.w	r3, [r7, #3]
    36e6:	2b07      	cmp	r3, #7
    36e8:	dd05      	ble.n	36f6 <MSS_MAC_last_error+0x2a>
		returnvalue = unknown_error;
    36ea:	f643 038c 	movw	r3, #14476	; 0x388c
    36ee:	f2c0 0301 	movt	r3, #1
    36f2:	607b      	str	r3, [r7, #4]
    36f4:	e00d      	b.n	3712 <MSS_MAC_last_error+0x46>
	} else {
		returnvalue = ErrorMessages[error_msg_nb];
    36f6:	f643 029c 	movw	r2, #14492	; 0x389c
    36fa:	f2c0 0201 	movt	r2, #1
    36fe:	f997 1003 	ldrsb.w	r1, [r7, #3]
    3702:	460b      	mov	r3, r1
    3704:	ea4f 0383 	mov.w	r3, r3, lsl #2
    3708:	440b      	add	r3, r1
    370a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    370e:	4413      	add	r3, r2
    3710:	607b      	str	r3, [r7, #4]
	}
	return returnvalue;
    3712:	687b      	ldr	r3, [r7, #4]
}
    3714:	4618      	mov	r0, r3
    3716:	f107 070c 	add.w	r7, r7, #12
    371a:	46bd      	mov	sp, r7
    371c:	bc80      	pop	{r7}
    371e:	4770      	bx	lr

00003720 <MSS_MAC_get_statistics>:
uint32_t
MSS_MAC_get_statistics
(
    mss_mac_statistics_id_t stat_id
)
{
    3720:	b480      	push	{r7}
    3722:	b085      	sub	sp, #20
    3724:	af00      	add	r7, sp, #0
    3726:	4603      	mov	r3, r0
    3728:	71fb      	strb	r3, [r7, #7]
    uint32_t returnval = 0u;
    372a:	f04f 0300 	mov.w	r3, #0
    372e:	60fb      	str	r3, [r7, #12]

	switch( stat_id ) {
    3730:	79fb      	ldrb	r3, [r7, #7]
    3732:	2b11      	cmp	r3, #17
    3734:	f200 8147 	bhi.w	39c6 <MSS_MAC_get_statistics+0x2a6>
    3738:	a201      	add	r2, pc, #4	; (adr r2, 3740 <MSS_MAC_get_statistics+0x20>)
    373a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    373e:	bf00      	nop
    3740:	00003789 	.word	0x00003789
    3744:	000037a9 	.word	0x000037a9
    3748:	000037c9 	.word	0x000037c9
    374c:	000037e9 	.word	0x000037e9
    3750:	00003809 	.word	0x00003809
    3754:	00003829 	.word	0x00003829
    3758:	00003849 	.word	0x00003849
    375c:	00003869 	.word	0x00003869
    3760:	00003889 	.word	0x00003889
    3764:	000038a9 	.word	0x000038a9
    3768:	000038c9 	.word	0x000038c9
    376c:	000038e9 	.word	0x000038e9
    3770:	00003909 	.word	0x00003909
    3774:	00003929 	.word	0x00003929
    3778:	00003949 	.word	0x00003949
    377c:	00003969 	.word	0x00003969
    3780:	00003989 	.word	0x00003989
    3784:	000039a9 	.word	0x000039a9
	case MSS_MAC_RX_INTERRUPTS:
		returnval = g_mss_mac.statistics.rx_interrupts;
    3788:	f64a 1394 	movw	r3, #43412	; 0xa994
    378c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3790:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
    3794:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3798:	f893 30ec 	ldrb.w	r3, [r3, #236]	; 0xec
    379c:	ea4f 6303 	mov.w	r3, r3, lsl #24
    37a0:	ea43 0302 	orr.w	r3, r3, r2
    37a4:	60fb      	str	r3, [r7, #12]
        break;
    37a6:	e10e      	b.n	39c6 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_FILTERING_FAIL:
		returnval = g_mss_mac.statistics.rx_filtering_fail;
    37a8:	f64a 1394 	movw	r3, #43412	; 0xa994
    37ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    37b0:	f8d3 20ec 	ldr.w	r2, [r3, #236]	; 0xec
    37b4:	ea4f 2212 	mov.w	r2, r2, lsr #8
    37b8:	f893 30f0 	ldrb.w	r3, [r3, #240]	; 0xf0
    37bc:	ea4f 6303 	mov.w	r3, r3, lsl #24
    37c0:	ea43 0302 	orr.w	r3, r3, r2
    37c4:	60fb      	str	r3, [r7, #12]
        break;
    37c6:	e0fe      	b.n	39c6 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_DESCRIPTOR_ERROR:
		returnval = g_mss_mac.statistics.rx_descriptor_error;
    37c8:	f64a 1394 	movw	r3, #43412	; 0xa994
    37cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    37d0:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
    37d4:	ea4f 2212 	mov.w	r2, r2, lsr #8
    37d8:	f893 30f4 	ldrb.w	r3, [r3, #244]	; 0xf4
    37dc:	ea4f 6303 	mov.w	r3, r3, lsl #24
    37e0:	ea43 0302 	orr.w	r3, r3, r2
    37e4:	60fb      	str	r3, [r7, #12]
        break;
    37e6:	e0ee      	b.n	39c6 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_RUNT_FRAME:
		returnval = g_mss_mac.statistics.rx_runt_frame;
    37e8:	f64a 1394 	movw	r3, #43412	; 0xa994
    37ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    37f0:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
    37f4:	ea4f 2212 	mov.w	r2, r2, lsr #8
    37f8:	f893 30f8 	ldrb.w	r3, [r3, #248]	; 0xf8
    37fc:	ea4f 6303 	mov.w	r3, r3, lsl #24
    3800:	ea43 0302 	orr.w	r3, r3, r2
    3804:	60fb      	str	r3, [r7, #12]
        break;
    3806:	e0de      	b.n	39c6 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_NOT_FIRST:
		returnval = g_mss_mac.statistics.rx_not_first;
    3808:	f64a 1394 	movw	r3, #43412	; 0xa994
    380c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3810:	f8d3 20f8 	ldr.w	r2, [r3, #248]	; 0xf8
    3814:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3818:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
    381c:	ea4f 6303 	mov.w	r3, r3, lsl #24
    3820:	ea43 0302 	orr.w	r3, r3, r2
    3824:	60fb      	str	r3, [r7, #12]
        break;
    3826:	e0ce      	b.n	39c6 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_NOT_LAST:
		returnval = g_mss_mac.statistics.rx_not_last;
    3828:	f64a 1394 	movw	r3, #43412	; 0xa994
    382c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3830:	f8d3 20fc 	ldr.w	r2, [r3, #252]	; 0xfc
    3834:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3838:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
    383c:	ea4f 6303 	mov.w	r3, r3, lsl #24
    3840:	ea43 0302 	orr.w	r3, r3, r2
    3844:	60fb      	str	r3, [r7, #12]
        break;
    3846:	e0be      	b.n	39c6 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_FRAME_TOO_LONG:
		returnval = g_mss_mac.statistics.rx_frame_too_long;
    3848:	f64a 1394 	movw	r3, #43412	; 0xa994
    384c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3850:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    3854:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3858:	f893 3104 	ldrb.w	r3, [r3, #260]	; 0x104
    385c:	ea4f 6303 	mov.w	r3, r3, lsl #24
    3860:	ea43 0302 	orr.w	r3, r3, r2
    3864:	60fb      	str	r3, [r7, #12]
        break;
    3866:	e0ae      	b.n	39c6 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_COLLISION_SEEN:
		returnval = g_mss_mac.statistics.rx_collision_seen;
    3868:	f64a 1394 	movw	r3, #43412	; 0xa994
    386c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3870:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    3874:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3878:	f893 3108 	ldrb.w	r3, [r3, #264]	; 0x108
    387c:	ea4f 6303 	mov.w	r3, r3, lsl #24
    3880:	ea43 0302 	orr.w	r3, r3, r2
    3884:	60fb      	str	r3, [r7, #12]
        break;
    3886:	e09e      	b.n	39c6 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_CRC_ERROR:
		returnval = g_mss_mac.statistics.rx_crc_error;
    3888:	f64a 1394 	movw	r3, #43412	; 0xa994
    388c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3890:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
    3894:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3898:	f893 310c 	ldrb.w	r3, [r3, #268]	; 0x10c
    389c:	ea4f 6303 	mov.w	r3, r3, lsl #24
    38a0:	ea43 0302 	orr.w	r3, r3, r2
    38a4:	60fb      	str	r3, [r7, #12]
        break;
    38a6:	e08e      	b.n	39c6 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_FIFO_OVERFLOW:
		returnval = g_mss_mac.statistics.rx_fifo_overflow;
    38a8:	f64a 1394 	movw	r3, #43412	; 0xa994
    38ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    38b0:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    38b4:	ea4f 2212 	mov.w	r2, r2, lsr #8
    38b8:	f893 3110 	ldrb.w	r3, [r3, #272]	; 0x110
    38bc:	ea4f 6303 	mov.w	r3, r3, lsl #24
    38c0:	ea43 0302 	orr.w	r3, r3, r2
    38c4:	60fb      	str	r3, [r7, #12]
        break;
    38c6:	e07e      	b.n	39c6 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_MISSED_FRAME:
		returnval = g_mss_mac.statistics.rx_missed_frame;
    38c8:	f64a 1394 	movw	r3, #43412	; 0xa994
    38cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    38d0:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    38d4:	ea4f 2212 	mov.w	r2, r2, lsr #8
    38d8:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
    38dc:	ea4f 6303 	mov.w	r3, r3, lsl #24
    38e0:	ea43 0302 	orr.w	r3, r3, r2
    38e4:	60fb      	str	r3, [r7, #12]
        break;
    38e6:	e06e      	b.n	39c6 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_TX_INTERRUPTS:
		returnval = g_mss_mac.statistics.tx_interrupts;
    38e8:	f64a 1394 	movw	r3, #43412	; 0xa994
    38ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    38f0:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
    38f4:	ea4f 2212 	mov.w	r2, r2, lsr #8
    38f8:	f893 3118 	ldrb.w	r3, [r3, #280]	; 0x118
    38fc:	ea4f 6303 	mov.w	r3, r3, lsl #24
    3900:	ea43 0302 	orr.w	r3, r3, r2
    3904:	60fb      	str	r3, [r7, #12]
        break;
    3906:	e05e      	b.n	39c6 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_TX_LOSS_OF_CARRIER:
		returnval = g_mss_mac.statistics.tx_loss_of_carrier;
    3908:	f64a 1394 	movw	r3, #43412	; 0xa994
    390c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3910:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    3914:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3918:	f893 311c 	ldrb.w	r3, [r3, #284]	; 0x11c
    391c:	ea4f 6303 	mov.w	r3, r3, lsl #24
    3920:	ea43 0302 	orr.w	r3, r3, r2
    3924:	60fb      	str	r3, [r7, #12]
        break;
    3926:	e04e      	b.n	39c6 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_TX_NO_CARRIER:
		returnval = g_mss_mac.statistics.tx_no_carrier;
    3928:	f64a 1394 	movw	r3, #43412	; 0xa994
    392c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3930:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
    3934:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3938:	f893 3120 	ldrb.w	r3, [r3, #288]	; 0x120
    393c:	ea4f 6303 	mov.w	r3, r3, lsl #24
    3940:	ea43 0302 	orr.w	r3, r3, r2
    3944:	60fb      	str	r3, [r7, #12]
        break;
    3946:	e03e      	b.n	39c6 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_TX_LATE_COLLISION:
		returnval = g_mss_mac.statistics.tx_late_collision;
    3948:	f64a 1394 	movw	r3, #43412	; 0xa994
    394c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3950:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    3954:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3958:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
    395c:	ea4f 6303 	mov.w	r3, r3, lsl #24
    3960:	ea43 0302 	orr.w	r3, r3, r2
    3964:	60fb      	str	r3, [r7, #12]
        break;
    3966:	e02e      	b.n	39c6 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_TX_EXCESSIVE_COLLISION:
		returnval = g_mss_mac.statistics.tx_excessive_collision;
    3968:	f64a 1394 	movw	r3, #43412	; 0xa994
    396c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3970:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    3974:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3978:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
    397c:	ea4f 6303 	mov.w	r3, r3, lsl #24
    3980:	ea43 0302 	orr.w	r3, r3, r2
    3984:	60fb      	str	r3, [r7, #12]
        break;
    3986:	e01e      	b.n	39c6 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_TX_COLLISION_COUNT:
		returnval = g_mss_mac.statistics.tx_collision_count;
    3988:	f64a 1394 	movw	r3, #43412	; 0xa994
    398c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3990:	f8d3 2128 	ldr.w	r2, [r3, #296]	; 0x128
    3994:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3998:	f893 312c 	ldrb.w	r3, [r3, #300]	; 0x12c
    399c:	ea4f 6303 	mov.w	r3, r3, lsl #24
    39a0:	ea43 0302 	orr.w	r3, r3, r2
    39a4:	60fb      	str	r3, [r7, #12]
        break;
    39a6:	e00e      	b.n	39c6 <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_TX_UNDERFLOW_ERROR:
		returnval = g_mss_mac.statistics.tx_underflow_error;
    39a8:	f64a 1394 	movw	r3, #43412	; 0xa994
    39ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    39b0:	f8d3 212c 	ldr.w	r2, [r3, #300]	; 0x12c
    39b4:	ea4f 2212 	mov.w	r2, r2, lsr #8
    39b8:	f893 3130 	ldrb.w	r3, [r3, #304]	; 0x130
    39bc:	ea4f 6303 	mov.w	r3, r3, lsl #24
    39c0:	ea43 0302 	orr.w	r3, r3, r2
    39c4:	60fb      	str	r3, [r7, #12]
        break;
    default:
        break;
	}

	return returnval;
    39c6:	68fb      	ldr	r3, [r7, #12]
}
    39c8:	4618      	mov	r0, r3
    39ca:	f107 0714 	add.w	r7, r7, #20
    39ce:	46bd      	mov	sp, r7
    39d0:	bc80      	pop	{r7}
    39d2:	4770      	bx	lr

000039d4 <MSS_MAC_prepare_rx_descriptor>:
void
MSS_MAC_prepare_rx_descriptor
(
    void
)
{
    39d4:	b580      	push	{r7, lr}
    39d6:	b082      	sub	sp, #8
    39d8:	af00      	add	r7, sp, #0
	uint32_t desc;

	/* update counters */
	desc = g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0;
    39da:	f64a 1394 	movw	r3, #43412	; 0xa994
    39de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    39e2:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    39e6:	f64a 1394 	movw	r3, #43412	; 0xa994
    39ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    39ee:	ea4f 1202 	mov.w	r2, r2, lsl #4
    39f2:	4413      	add	r3, r2
    39f4:	f103 0398 	add.w	r3, r3, #152	; 0x98
    39f8:	681b      	ldr	r3, [r3, #0]
    39fa:	607b      	str	r3, [r7, #4]
	if( (desc & RDES0_FF) != 0u ) {
    39fc:	687b      	ldr	r3, [r7, #4]
    39fe:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
    3a02:	2b00      	cmp	r3, #0
    3a04:	d027      	beq.n	3a56 <MSS_MAC_prepare_rx_descriptor+0x82>
		g_mss_mac.statistics.rx_filtering_fail++;
    3a06:	f64a 1394 	movw	r3, #43412	; 0xa994
    3a0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3a0e:	f8d3 20ec 	ldr.w	r2, [r3, #236]	; 0xec
    3a12:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3a16:	f893 30f0 	ldrb.w	r3, [r3, #240]	; 0xf0
    3a1a:	ea4f 6303 	mov.w	r3, r3, lsl #24
    3a1e:	ea43 0302 	orr.w	r3, r3, r2
    3a22:	f103 0201 	add.w	r2, r3, #1
    3a26:	f64a 1394 	movw	r3, #43412	; 0xa994
    3a2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3a2e:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    3a32:	ea4f 2101 	mov.w	r1, r1, lsl #8
    3a36:	f8d3 00ec 	ldr.w	r0, [r3, #236]	; 0xec
    3a3a:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    3a3e:	ea40 0101 	orr.w	r1, r0, r1
    3a42:	f8c3 10ec 	str.w	r1, [r3, #236]	; 0xec
    3a46:	ea4f 6212 	mov.w	r2, r2, lsr #24
    3a4a:	f04f 0100 	mov.w	r1, #0
    3a4e:	ea41 0202 	orr.w	r2, r1, r2
    3a52:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
	}
	if( (desc & RDES0_DE) != 0u ) {
    3a56:	687b      	ldr	r3, [r7, #4]
    3a58:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    3a5c:	2b00      	cmp	r3, #0
    3a5e:	d027      	beq.n	3ab0 <MSS_MAC_prepare_rx_descriptor+0xdc>
		g_mss_mac.statistics.rx_descriptor_error++;
    3a60:	f64a 1394 	movw	r3, #43412	; 0xa994
    3a64:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3a68:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
    3a6c:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3a70:	f893 30f4 	ldrb.w	r3, [r3, #244]	; 0xf4
    3a74:	ea4f 6303 	mov.w	r3, r3, lsl #24
    3a78:	ea43 0302 	orr.w	r3, r3, r2
    3a7c:	f103 0201 	add.w	r2, r3, #1
    3a80:	f64a 1394 	movw	r3, #43412	; 0xa994
    3a84:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3a88:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    3a8c:	ea4f 2101 	mov.w	r1, r1, lsl #8
    3a90:	f8d3 00f0 	ldr.w	r0, [r3, #240]	; 0xf0
    3a94:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    3a98:	ea40 0101 	orr.w	r1, r0, r1
    3a9c:	f8c3 10f0 	str.w	r1, [r3, #240]	; 0xf0
    3aa0:	ea4f 6212 	mov.w	r2, r2, lsr #24
    3aa4:	f04f 0100 	mov.w	r1, #0
    3aa8:	ea41 0202 	orr.w	r2, r1, r2
    3aac:	f883 20f4 	strb.w	r2, [r3, #244]	; 0xf4
	}
	if( (desc & RDES0_RF) != 0u ) {
    3ab0:	687b      	ldr	r3, [r7, #4]
    3ab2:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    3ab6:	2b00      	cmp	r3, #0
    3ab8:	d027      	beq.n	3b0a <MSS_MAC_prepare_rx_descriptor+0x136>
		g_mss_mac.statistics.rx_runt_frame++;
    3aba:	f64a 1394 	movw	r3, #43412	; 0xa994
    3abe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3ac2:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
    3ac6:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3aca:	f893 30f8 	ldrb.w	r3, [r3, #248]	; 0xf8
    3ace:	ea4f 6303 	mov.w	r3, r3, lsl #24
    3ad2:	ea43 0302 	orr.w	r3, r3, r2
    3ad6:	f103 0201 	add.w	r2, r3, #1
    3ada:	f64a 1394 	movw	r3, #43412	; 0xa994
    3ade:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3ae2:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    3ae6:	ea4f 2101 	mov.w	r1, r1, lsl #8
    3aea:	f8d3 00f4 	ldr.w	r0, [r3, #244]	; 0xf4
    3aee:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    3af2:	ea40 0101 	orr.w	r1, r0, r1
    3af6:	f8c3 10f4 	str.w	r1, [r3, #244]	; 0xf4
    3afa:	ea4f 6212 	mov.w	r2, r2, lsr #24
    3afe:	f04f 0100 	mov.w	r1, #0
    3b02:	ea41 0202 	orr.w	r2, r1, r2
    3b06:	f883 20f8 	strb.w	r2, [r3, #248]	; 0xf8
	}
	if( (desc & RDES0_FS) == 0u ) {
    3b0a:	687b      	ldr	r3, [r7, #4]
    3b0c:	f403 7300 	and.w	r3, r3, #512	; 0x200
    3b10:	2b00      	cmp	r3, #0
    3b12:	d127      	bne.n	3b64 <MSS_MAC_prepare_rx_descriptor+0x190>
		g_mss_mac.statistics.rx_not_first++;
    3b14:	f64a 1394 	movw	r3, #43412	; 0xa994
    3b18:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3b1c:	f8d3 20f8 	ldr.w	r2, [r3, #248]	; 0xf8
    3b20:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3b24:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
    3b28:	ea4f 6303 	mov.w	r3, r3, lsl #24
    3b2c:	ea43 0302 	orr.w	r3, r3, r2
    3b30:	f103 0201 	add.w	r2, r3, #1
    3b34:	f64a 1394 	movw	r3, #43412	; 0xa994
    3b38:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3b3c:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    3b40:	ea4f 2101 	mov.w	r1, r1, lsl #8
    3b44:	f8d3 00f8 	ldr.w	r0, [r3, #248]	; 0xf8
    3b48:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    3b4c:	ea40 0101 	orr.w	r1, r0, r1
    3b50:	f8c3 10f8 	str.w	r1, [r3, #248]	; 0xf8
    3b54:	ea4f 6212 	mov.w	r2, r2, lsr #24
    3b58:	f04f 0100 	mov.w	r1, #0
    3b5c:	ea41 0202 	orr.w	r2, r1, r2
    3b60:	f883 20fc 	strb.w	r2, [r3, #252]	; 0xfc
	}
	if( (desc & RDES0_LS) == 0u ) {
    3b64:	687b      	ldr	r3, [r7, #4]
    3b66:	f403 7380 	and.w	r3, r3, #256	; 0x100
    3b6a:	2b00      	cmp	r3, #0
    3b6c:	d127      	bne.n	3bbe <MSS_MAC_prepare_rx_descriptor+0x1ea>
		g_mss_mac.statistics.rx_not_last++;
    3b6e:	f64a 1394 	movw	r3, #43412	; 0xa994
    3b72:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3b76:	f8d3 20fc 	ldr.w	r2, [r3, #252]	; 0xfc
    3b7a:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3b7e:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
    3b82:	ea4f 6303 	mov.w	r3, r3, lsl #24
    3b86:	ea43 0302 	orr.w	r3, r3, r2
    3b8a:	f103 0201 	add.w	r2, r3, #1
    3b8e:	f64a 1394 	movw	r3, #43412	; 0xa994
    3b92:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3b96:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    3b9a:	ea4f 2101 	mov.w	r1, r1, lsl #8
    3b9e:	f8d3 00fc 	ldr.w	r0, [r3, #252]	; 0xfc
    3ba2:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    3ba6:	ea40 0101 	orr.w	r1, r0, r1
    3baa:	f8c3 10fc 	str.w	r1, [r3, #252]	; 0xfc
    3bae:	ea4f 6212 	mov.w	r2, r2, lsr #24
    3bb2:	f04f 0100 	mov.w	r1, #0
    3bb6:	ea41 0202 	orr.w	r2, r1, r2
    3bba:	f883 2100 	strb.w	r2, [r3, #256]	; 0x100
	}
	if( (desc & RDES0_TL) != 0u ) {
    3bbe:	687b      	ldr	r3, [r7, #4]
    3bc0:	f003 0380 	and.w	r3, r3, #128	; 0x80
    3bc4:	2b00      	cmp	r3, #0
    3bc6:	d027      	beq.n	3c18 <MSS_MAC_prepare_rx_descriptor+0x244>
		g_mss_mac.statistics.rx_frame_too_long++;
    3bc8:	f64a 1394 	movw	r3, #43412	; 0xa994
    3bcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3bd0:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    3bd4:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3bd8:	f893 3104 	ldrb.w	r3, [r3, #260]	; 0x104
    3bdc:	ea4f 6303 	mov.w	r3, r3, lsl #24
    3be0:	ea43 0302 	orr.w	r3, r3, r2
    3be4:	f103 0201 	add.w	r2, r3, #1
    3be8:	f64a 1394 	movw	r3, #43412	; 0xa994
    3bec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3bf0:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    3bf4:	ea4f 2101 	mov.w	r1, r1, lsl #8
    3bf8:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
    3bfc:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    3c00:	ea40 0101 	orr.w	r1, r0, r1
    3c04:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
    3c08:	ea4f 6212 	mov.w	r2, r2, lsr #24
    3c0c:	f04f 0100 	mov.w	r1, #0
    3c10:	ea41 0202 	orr.w	r2, r1, r2
    3c14:	f883 2104 	strb.w	r2, [r3, #260]	; 0x104
	}
	if( (desc & RDES0_CS) != 0u ) {
    3c18:	687b      	ldr	r3, [r7, #4]
    3c1a:	f003 0340 	and.w	r3, r3, #64	; 0x40
    3c1e:	2b00      	cmp	r3, #0
    3c20:	d027      	beq.n	3c72 <MSS_MAC_prepare_rx_descriptor+0x29e>
		g_mss_mac.statistics.rx_collision_seen++;
    3c22:	f64a 1394 	movw	r3, #43412	; 0xa994
    3c26:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3c2a:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    3c2e:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3c32:	f893 3108 	ldrb.w	r3, [r3, #264]	; 0x108
    3c36:	ea4f 6303 	mov.w	r3, r3, lsl #24
    3c3a:	ea43 0302 	orr.w	r3, r3, r2
    3c3e:	f103 0201 	add.w	r2, r3, #1
    3c42:	f64a 1394 	movw	r3, #43412	; 0xa994
    3c46:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3c4a:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    3c4e:	ea4f 2101 	mov.w	r1, r1, lsl #8
    3c52:	f8d3 0104 	ldr.w	r0, [r3, #260]	; 0x104
    3c56:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    3c5a:	ea40 0101 	orr.w	r1, r0, r1
    3c5e:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
    3c62:	ea4f 6212 	mov.w	r2, r2, lsr #24
    3c66:	f04f 0100 	mov.w	r1, #0
    3c6a:	ea41 0202 	orr.w	r2, r1, r2
    3c6e:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
	}
	if( (desc & RDES0_CE) != 0u ) {
    3c72:	687b      	ldr	r3, [r7, #4]
    3c74:	f003 0302 	and.w	r3, r3, #2
    3c78:	2b00      	cmp	r3, #0
    3c7a:	d027      	beq.n	3ccc <MSS_MAC_prepare_rx_descriptor+0x2f8>
		g_mss_mac.statistics.rx_crc_error++;
    3c7c:	f64a 1394 	movw	r3, #43412	; 0xa994
    3c80:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3c84:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
    3c88:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3c8c:	f893 310c 	ldrb.w	r3, [r3, #268]	; 0x10c
    3c90:	ea4f 6303 	mov.w	r3, r3, lsl #24
    3c94:	ea43 0302 	orr.w	r3, r3, r2
    3c98:	f103 0201 	add.w	r2, r3, #1
    3c9c:	f64a 1394 	movw	r3, #43412	; 0xa994
    3ca0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3ca4:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    3ca8:	ea4f 2101 	mov.w	r1, r1, lsl #8
    3cac:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
    3cb0:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    3cb4:	ea40 0101 	orr.w	r1, r0, r1
    3cb8:	f8c3 1108 	str.w	r1, [r3, #264]	; 0x108
    3cbc:	ea4f 6212 	mov.w	r2, r2, lsr #24
    3cc0:	f04f 0100 	mov.w	r1, #0
    3cc4:	ea41 0202 	orr.w	r2, r1, r2
    3cc8:	f883 210c 	strb.w	r2, [r3, #268]	; 0x10c
	}

	desc = MAC->CSR8;
    3ccc:	f243 0300 	movw	r3, #12288	; 0x3000
    3cd0:	f2c4 0300 	movt	r3, #16384	; 0x4000
    3cd4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3cd6:	607b      	str	r3, [r7, #4]
	g_mss_mac.statistics.rx_fifo_overflow +=
    3cd8:	f64a 1394 	movw	r3, #43412	; 0xa994
    3cdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3ce0:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    3ce4:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3ce8:	f893 3110 	ldrb.w	r3, [r3, #272]	; 0x110
    3cec:	ea4f 6303 	mov.w	r3, r3, lsl #24
    3cf0:	ea43 0302 	orr.w	r3, r3, r2
    3cf4:	461a      	mov	r2, r3
		(desc & (CSR8_OCO_MASK|CSR8_FOC_MASK)) >> CSR8_FOC_SHIFT;
    3cf6:	6879      	ldr	r1, [r7, #4]
    3cf8:	f240 0300 	movw	r3, #0
    3cfc:	f6c1 73fe 	movt	r3, #8190	; 0x1ffe
    3d00:	ea01 0303 	and.w	r3, r1, r3
    3d04:	ea4f 4353 	mov.w	r3, r3, lsr #17
	if( (desc & RDES0_CE) != 0u ) {
		g_mss_mac.statistics.rx_crc_error++;
	}

	desc = MAC->CSR8;
	g_mss_mac.statistics.rx_fifo_overflow +=
    3d08:	441a      	add	r2, r3
    3d0a:	f64a 1394 	movw	r3, #43412	; 0xa994
    3d0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3d12:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    3d16:	ea4f 2101 	mov.w	r1, r1, lsl #8
    3d1a:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
    3d1e:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    3d22:	ea40 0101 	orr.w	r1, r0, r1
    3d26:	f8c3 110c 	str.w	r1, [r3, #268]	; 0x10c
    3d2a:	ea4f 6212 	mov.w	r2, r2, lsr #24
    3d2e:	f04f 0100 	mov.w	r1, #0
    3d32:	ea41 0202 	orr.w	r2, r1, r2
    3d36:	f883 2110 	strb.w	r2, [r3, #272]	; 0x110
		(desc & (CSR8_OCO_MASK|CSR8_FOC_MASK)) >> CSR8_FOC_SHIFT;
	g_mss_mac.statistics.rx_missed_frame +=
    3d3a:	f64a 1394 	movw	r3, #43412	; 0xa994
    3d3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3d42:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    3d46:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3d4a:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
    3d4e:	ea4f 6303 	mov.w	r3, r3, lsl #24
    3d52:	ea43 0302 	orr.w	r3, r3, r2
    3d56:	461a      	mov	r2, r3
		(desc & (CSR8_MFO_MASK|CSR8_MFC_MASK));
    3d58:	687b      	ldr	r3, [r7, #4]
    3d5a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    3d5e:	f423 037e 	bic.w	r3, r3, #16646144	; 0xfe0000
	}

	desc = MAC->CSR8;
	g_mss_mac.statistics.rx_fifo_overflow +=
		(desc & (CSR8_OCO_MASK|CSR8_FOC_MASK)) >> CSR8_FOC_SHIFT;
	g_mss_mac.statistics.rx_missed_frame +=
    3d62:	441a      	add	r2, r3
    3d64:	f64a 1394 	movw	r3, #43412	; 0xa994
    3d68:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3d6c:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    3d70:	ea4f 2101 	mov.w	r1, r1, lsl #8
    3d74:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
    3d78:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    3d7c:	ea40 0101 	orr.w	r1, r0, r1
    3d80:	f8c3 1110 	str.w	r1, [r3, #272]	; 0x110
    3d84:	ea4f 6212 	mov.w	r2, r2, lsr #24
    3d88:	f04f 0100 	mov.w	r1, #0
    3d8c:	ea41 0202 	orr.w	r2, r1, r2
    3d90:	f883 2114 	strb.w	r2, [r3, #276]	; 0x114
		(desc & (CSR8_MFO_MASK|CSR8_MFC_MASK));

	/* Give ownership of descriptor to the MAC */
	g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 = RDES0_OWN;
    3d94:	f64a 1394 	movw	r3, #43412	; 0xa994
    3d98:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3d9c:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    3da0:	f64a 1394 	movw	r3, #43412	; 0xa994
    3da4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3da8:	ea4f 1202 	mov.w	r2, r2, lsl #4
    3dac:	4413      	add	r3, r2
    3dae:	f103 0398 	add.w	r3, r3, #152	; 0x98
    3db2:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    3db6:	601a      	str	r2, [r3, #0]
	g_mss_mac.rx_desc_index = (g_mss_mac.rx_desc_index + 1u) % RX_RING_SIZE;
    3db8:	f64a 1394 	movw	r3, #43412	; 0xa994
    3dbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3dc0:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    3dc4:	f103 0101 	add.w	r1, r3, #1
    3dc8:	f64c 43cd 	movw	r3, #52429	; 0xcccd
    3dcc:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
    3dd0:	fba3 2301 	umull	r2, r3, r3, r1
    3dd4:	ea4f 0293 	mov.w	r2, r3, lsr #2
    3dd8:	4613      	mov	r3, r2
    3dda:	ea4f 0383 	mov.w	r3, r3, lsl #2
    3dde:	4413      	add	r3, r2
    3de0:	ebc3 0201 	rsb	r2, r3, r1
    3de4:	f64a 1394 	movw	r3, #43412	; 0xa994
    3de8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3dec:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

	/* Start receive */
    MAC_start_receiving();
    3df0:	f000 fa28 	bl	4244 <MAC_start_receiving>
}
    3df4:	f107 0708 	add.w	r7, r7, #8
    3df8:	46bd      	mov	sp, r7
    3dfa:	bd80      	pop	{r7, pc}

00003dfc <MAC_send_setup_frame>:
static int32_t
MAC_send_setup_frame
(
    void
)
{
    3dfc:	b580      	push	{r7, lr}
    3dfe:	b0be      	sub	sp, #248	; 0xf8
    3e00:	af00      	add	r7, sp, #0
	uint8_t *data;
	int32_t a,b,c,d;
	int32_t ret;

    /* prepare descriptor */
	descriptor.descriptor_0 = TDES0_OWN;
    3e02:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    3e06:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
	descriptor.descriptor_1 = TDES1_SET | TDES1_TER |
    3e0a:	f240 03c0 	movw	r3, #192	; 0xc0
    3e0e:	f6c0 2300 	movt	r3, #2560	; 0xa00
    3e12:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
		(sizeof(frame_data) << TDES1_TBS1_OFFSET);

	if( (g_mss_mac.flags & FLAG_PERFECT_FILTERING) == 0u ) {
    3e16:	f64a 1394 	movw	r3, #43412	; 0xa994
    3e1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3e1e:	791b      	ldrb	r3, [r3, #4]
    3e20:	f003 0302 	and.w	r3, r3, #2
    3e24:	2b00      	cmp	r3, #0
    3e26:	d105      	bne.n	3e34 <MAC_send_setup_frame+0x38>
		descriptor.descriptor_1 |= TDES1_FT0;
    3e28:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
    3e2c:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
    3e30:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	}

	descriptor.buffer_1 = (uint32_t)frame_data;
    3e34:	f107 0304 	add.w	r3, r7, #4
    3e38:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
	descriptor.buffer_2 = 0u;
    3e3c:	f04f 0300 	mov.w	r3, #0
    3e40:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0

    /* prepare frame */
    if( (g_mss_mac.flags & FLAG_PERFECT_FILTERING) != 0u ) {
    3e44:	f64a 1394 	movw	r3, #43412	; 0xa994
    3e48:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3e4c:	791b      	ldrb	r3, [r3, #4]
    3e4e:	f003 0302 	and.w	r3, r3, #2
    3e52:	2b00      	cmp	r3, #0
    3e54:	d00c      	beq.n	3e70 <MAC_send_setup_frame+0x74>
    	b = 0;
    3e56:	f04f 0300 	mov.w	r3, #0
    3e5a:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    	d = 12;
    3e5e:	f04f 030c 	mov.w	r3, #12
    3e62:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    	c = 90;
    3e66:	f04f 035a 	mov.w	r3, #90	; 0x5a
    3e6a:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    3e6e:	e00b      	b.n	3e88 <MAC_send_setup_frame+0x8c>
    } else {
    	b = 156;
    3e70:	f04f 039c 	mov.w	r3, #156	; 0x9c
    3e74:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    	d = 0;
    3e78:	f04f 0300 	mov.w	r3, #0
    3e7c:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    	c = 64;
    3e80:	f04f 0340 	mov.w	r3, #64	; 0x40
    3e84:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    }

   	data = g_mss_mac.mac_address;
    3e88:	4bb4      	ldr	r3, [pc, #720]	; (415c <MAC_send_setup_frame+0x360>)
    3e8a:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
   	frame_data[b] = data[0];
    3e8e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
    3e92:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    3e96:	7812      	ldrb	r2, [r2, #0]
    3e98:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    3e9c:	440b      	add	r3, r1
    3e9e:	f803 2cf4 	strb.w	r2, [r3, #-244]
   	frame_data[b+1] = data[1];
    3ea2:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
    3ea6:	f103 0301 	add.w	r3, r3, #1
    3eaa:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    3eae:	f102 0201 	add.w	r2, r2, #1
    3eb2:	7812      	ldrb	r2, [r2, #0]
    3eb4:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    3eb8:	440b      	add	r3, r1
    3eba:	f803 2cf4 	strb.w	r2, [r3, #-244]
   	frame_data[b+4] = data[2];
    3ebe:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
    3ec2:	f103 0304 	add.w	r3, r3, #4
    3ec6:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    3eca:	f102 0202 	add.w	r2, r2, #2
    3ece:	7812      	ldrb	r2, [r2, #0]
    3ed0:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    3ed4:	440b      	add	r3, r1
    3ed6:	f803 2cf4 	strb.w	r2, [r3, #-244]
   	frame_data[b+5] = data[3];
    3eda:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
    3ede:	f103 0305 	add.w	r3, r3, #5
    3ee2:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    3ee6:	f102 0203 	add.w	r2, r2, #3
    3eea:	7812      	ldrb	r2, [r2, #0]
    3eec:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    3ef0:	440b      	add	r3, r1
    3ef2:	f803 2cf4 	strb.w	r2, [r3, #-244]
   	frame_data[b+8] = data[4];
    3ef6:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
    3efa:	f103 0308 	add.w	r3, r3, #8
    3efe:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    3f02:	f102 0204 	add.w	r2, r2, #4
    3f06:	7812      	ldrb	r2, [r2, #0]
    3f08:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    3f0c:	440b      	add	r3, r1
    3f0e:	f803 2cf4 	strb.w	r2, [r3, #-244]
   	frame_data[b+9] = data[5];
    3f12:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
    3f16:	f103 0309 	add.w	r3, r3, #9
    3f1a:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    3f1e:	f102 0205 	add.w	r2, r2, #5
    3f22:	7812      	ldrb	r2, [r2, #0]
    3f24:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    3f28:	440b      	add	r3, r1
    3f2a:	f803 2cf4 	strb.w	r2, [r3, #-244]

   	data = g_mss_mac.mac_filter_data;
    3f2e:	4b8c      	ldr	r3, [pc, #560]	; (4160 <MAC_send_setup_frame+0x364>)
    3f30:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
    for( a = 0; a < c; ) {
    3f34:	f04f 0300 	mov.w	r3, #0
    3f38:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    3f3c:	e081      	b.n	4042 <MAC_send_setup_frame+0x246>
		frame_data[d] = data[a++];
    3f3e:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    3f42:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
    3f46:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    3f4a:	440a      	add	r2, r1
    3f4c:	7812      	ldrb	r2, [r2, #0]
    3f4e:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    3f52:	440b      	add	r3, r1
    3f54:	f803 2cf4 	strb.w	r2, [r3, #-244]
    3f58:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    3f5c:	f103 0301 	add.w	r3, r3, #1
    3f60:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
	   	frame_data[d+1] = data[a++];
    3f64:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    3f68:	f103 0301 	add.w	r3, r3, #1
    3f6c:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
    3f70:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    3f74:	440a      	add	r2, r1
    3f76:	7812      	ldrb	r2, [r2, #0]
    3f78:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    3f7c:	440b      	add	r3, r1
    3f7e:	f803 2cf4 	strb.w	r2, [r3, #-244]
    3f82:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    3f86:	f103 0301 	add.w	r3, r3, #1
    3f8a:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
	   	frame_data[d+4] = data[a++];
    3f8e:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    3f92:	f103 0304 	add.w	r3, r3, #4
    3f96:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
    3f9a:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    3f9e:	440a      	add	r2, r1
    3fa0:	7812      	ldrb	r2, [r2, #0]
    3fa2:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    3fa6:	440b      	add	r3, r1
    3fa8:	f803 2cf4 	strb.w	r2, [r3, #-244]
    3fac:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    3fb0:	f103 0301 	add.w	r3, r3, #1
    3fb4:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
	   	frame_data[d+5] = data[a++];
    3fb8:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    3fbc:	f103 0305 	add.w	r3, r3, #5
    3fc0:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
    3fc4:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    3fc8:	440a      	add	r2, r1
    3fca:	7812      	ldrb	r2, [r2, #0]
    3fcc:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    3fd0:	440b      	add	r3, r1
    3fd2:	f803 2cf4 	strb.w	r2, [r3, #-244]
    3fd6:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    3fda:	f103 0301 	add.w	r3, r3, #1
    3fde:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
	   	frame_data[d+8] = data[a++];
    3fe2:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    3fe6:	f103 0308 	add.w	r3, r3, #8
    3fea:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
    3fee:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    3ff2:	440a      	add	r2, r1
    3ff4:	7812      	ldrb	r2, [r2, #0]
    3ff6:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    3ffa:	440b      	add	r3, r1
    3ffc:	f803 2cf4 	strb.w	r2, [r3, #-244]
    4000:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    4004:	f103 0301 	add.w	r3, r3, #1
    4008:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
	   	frame_data[d+9] = data[a++];
    400c:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    4010:	f103 0309 	add.w	r3, r3, #9
    4014:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
    4018:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    401c:	440a      	add	r2, r1
    401e:	7812      	ldrb	r2, [r2, #0]
    4020:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    4024:	440b      	add	r3, r1
    4026:	f803 2cf4 	strb.w	r2, [r3, #-244]
    402a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    402e:	f103 0301 	add.w	r3, r3, #1
    4032:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
	   	d += 12;
    4036:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    403a:	f103 030c 	add.w	r3, r3, #12
    403e:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
   	frame_data[b+5] = data[3];
   	frame_data[b+8] = data[4];
   	frame_data[b+9] = data[5];

   	data = g_mss_mac.mac_filter_data;
    for( a = 0; a < c; ) {
    4042:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
    4046:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
    404a:	429a      	cmp	r2, r3
    404c:	f6ff af77 	blt.w	3f3e <MAC_send_setup_frame+0x142>
	   	frame_data[d+9] = data[a++];
	   	d += 12;
	}

	/* Stop transmission */
    ret = MAC_stop_transmission();
    4050:	f000 f88a 	bl	4168 <MAC_stop_transmission>
    4054:	4603      	mov	r3, r0
    4056:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    configASSERT( ret == MAC_OK );
    405a:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
    405e:	2b00      	cmp	r3, #0
    4060:	d00a      	beq.n	4078 <MAC_send_setup_frame+0x27c>
    4062:	f04f 0328 	mov.w	r3, #40	; 0x28
    4066:	f383 8811 	msr	BASEPRI, r3
    406a:	f3bf 8f6f 	isb	sy
    406e:	f3bf 8f4f 	dsb	sy
    4072:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
    4076:	e7fe      	b.n	4076 <MAC_send_setup_frame+0x27a>

    ret = MAC_stop_receiving();
    4078:	f000 f8b4 	bl	41e4 <MAC_stop_receiving>
    407c:	4603      	mov	r3, r0
    407e:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    configASSERT( ret == MAC_OK );
    4082:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
    4086:	2b00      	cmp	r3, #0
    4088:	d00a      	beq.n	40a0 <MAC_send_setup_frame+0x2a4>
    408a:	f04f 0328 	mov.w	r3, #40	; 0x28
    408e:	f383 8811 	msr	BASEPRI, r3
    4092:	f3bf 8f6f 	isb	sy
    4096:	f3bf 8f4f 	dsb	sy
    409a:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
    409e:	e7fe      	b.n	409e <MAC_send_setup_frame+0x2a2>

    /* Set descriptor */
    MAC->CSR4 = (uint32_t)&descriptor;
    40a0:	f243 0300 	movw	r3, #12288	; 0x3000
    40a4:	f2c4 0300 	movt	r3, #16384	; 0x4000
    40a8:	f107 02c4 	add.w	r2, r7, #196	; 0xc4
    40ac:	621a      	str	r2, [r3, #32]

	/* Start transmission */
    MAC_start_transmission();
    40ae:	f000 f88b 	bl	41c8 <MAC_start_transmission>

    /* Wait until transmission over */
    ret = MAC_OK;
    40b2:	f04f 0300 	mov.w	r3, #0
    40b6:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    MAC_set_time_out( (uint32_t)SETUP_FRAME_TIME_OUT );
    40ba:	f242 7010 	movw	r0, #10000	; 0x2710
    40be:	f000 f921 	bl	4304 <MAC_set_time_out>

    while( (((MAC->CSR5 & CSR5_TS_MASK) >> CSR5_TS_SHIFT) !=
    40c2:	e00f      	b.n	40e4 <MAC_send_setup_frame+0x2e8>
    	CSR5_TS_SUSPENDED) && (MAC_OK == ret) )
    {
    	/* transmit poll demand */
    	MAC->CSR1 = 1u;
    40c4:	f243 0300 	movw	r3, #12288	; 0x3000
    40c8:	f2c4 0300 	movt	r3, #16384	; 0x4000
    40cc:	f04f 0201 	mov.w	r2, #1
    40d0:	609a      	str	r2, [r3, #8]
    	if( MAC_get_time_out() == 0u ) {
    40d2:	f000 f93f 	bl	4354 <MAC_get_time_out>
    40d6:	4603      	mov	r3, r0
    40d8:	2b00      	cmp	r3, #0
    40da:	d103      	bne.n	40e4 <MAC_send_setup_frame+0x2e8>
    		ret = MAC_TIME_OUT;
    40dc:	f06f 0305 	mvn.w	r3, #5
    40e0:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8

    /* Wait until transmission over */
    ret = MAC_OK;
    MAC_set_time_out( (uint32_t)SETUP_FRAME_TIME_OUT );

    while( (((MAC->CSR5 & CSR5_TS_MASK) >> CSR5_TS_SHIFT) !=
    40e4:	f243 0300 	movw	r3, #12288	; 0x3000
    40e8:	f2c4 0300 	movt	r3, #16384	; 0x4000
    40ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    40ee:	f403 03e0 	and.w	r3, r3, #7340032	; 0x700000
    40f2:	ea4f 5313 	mov.w	r3, r3, lsr #20
    40f6:	2b06      	cmp	r3, #6
    40f8:	d003      	beq.n	4102 <MAC_send_setup_frame+0x306>
    40fa:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
    40fe:	2b00      	cmp	r3, #0
    4100:	d0e0      	beq.n	40c4 <MAC_send_setup_frame+0x2c8>
    	if( MAC_get_time_out() == 0u ) {
    		ret = MAC_TIME_OUT;
    	}
    }

	MAC_CHECK( MAC_stop_transmission() == MAC_OK, MAC_FAIL );
    4102:	f000 f831 	bl	4168 <MAC_stop_transmission>
    4106:	4603      	mov	r3, r0
    4108:	2b00      	cmp	r3, #0
    410a:	d016      	beq.n	413a <MAC_send_setup_frame+0x33e>
    410c:	f64a 1394 	movw	r3, #43412	; 0xa994
    4110:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4114:	f04f 32ff 	mov.w	r2, #4294967295
    4118:	715a      	strb	r2, [r3, #5]
    411a:	f000 f825 	bl	4168 <MAC_stop_transmission>
    411e:	4603      	mov	r3, r0
    4120:	2b00      	cmp	r3, #0
    4122:	d00a      	beq.n	413a <MAC_send_setup_frame+0x33e>
    4124:	f04f 0328 	mov.w	r3, #40	; 0x28
    4128:	f383 8811 	msr	BASEPRI, r3
    412c:	f3bf 8f6f 	isb	sy
    4130:	f3bf 8f4f 	dsb	sy
    4134:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
    4138:	e7fe      	b.n	4138 <MAC_send_setup_frame+0x33c>

    /* Set tx descriptor */
    MAC->CSR4 = (uint32_t)g_mss_mac.tx_descriptors;
    413a:	f243 0300 	movw	r3, #12288	; 0x3000
    413e:	f2c4 0300 	movt	r3, #16384	; 0x4000
    4142:	4a08      	ldr	r2, [pc, #32]	; (4164 <MAC_send_setup_frame+0x368>)
    4144:	621a      	str	r2, [r3, #32]

    /* Start receiving and transmission */
    MAC_start_receiving();
    4146:	f000 f87d 	bl	4244 <MAC_start_receiving>
    MAC_start_transmission();
    414a:	f000 f83d 	bl	41c8 <MAC_start_transmission>

    return ret;
    414e:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
}
    4152:	4618      	mov	r0, r3
    4154:	f107 07f8 	add.w	r7, r7, #248	; 0xf8
    4158:	46bd      	mov	sp, r7
    415a:	bd80      	pop	{r7, pc}
    415c:	2000a99a 	.word	0x2000a99a
    4160:	2000a9a0 	.word	0x2000a9a0
    4164:	2000aa08 	.word	0x2000aa08

00004168 <MAC_stop_transmission>:
static int32_t
MAC_stop_transmission
(
    void
)
{
    4168:	b580      	push	{r7, lr}
    416a:	b082      	sub	sp, #8
    416c:	af00      	add	r7, sp, #0
    int32_t retval = MAC_OK;
    416e:	f04f 0300 	mov.w	r3, #0
    4172:	607b      	str	r3, [r7, #4]
    MAC_set_time_out( (uint16_t)STATE_CHANGE_TIME_OUT );
    4174:	f242 7010 	movw	r0, #10000	; 0x2710
    4178:	f000 f8c4 	bl	4304 <MAC_set_time_out>

	while( (((MAC->CSR5 & CSR5_TS_MASK) >> CSR5_TS_SHIFT) !=
    417c:	e00f      	b.n	419e <MAC_stop_transmission+0x36>
		CSR5_TS_STOPPED) && (retval == MAC_OK) )
	{
    	MAC_BITBAND->CSR6_ST = 0u;
    417e:	f240 0300 	movw	r3, #0
    4182:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4186:	f04f 0200 	mov.w	r2, #0
    418a:	f8c3 2634 	str.w	r2, [r3, #1588]	; 0x634
    	if( MAC_get_time_out() == 0u ) {
    418e:	f000 f8e1 	bl	4354 <MAC_get_time_out>
    4192:	4603      	mov	r3, r0
    4194:	2b00      	cmp	r3, #0
    4196:	d102      	bne.n	419e <MAC_stop_transmission+0x36>
    		retval = MAC_TIME_OUT;
    4198:	f06f 0305 	mvn.w	r3, #5
    419c:	607b      	str	r3, [r7, #4]
)
{
    int32_t retval = MAC_OK;
    MAC_set_time_out( (uint16_t)STATE_CHANGE_TIME_OUT );

	while( (((MAC->CSR5 & CSR5_TS_MASK) >> CSR5_TS_SHIFT) !=
    419e:	f243 0300 	movw	r3, #12288	; 0x3000
    41a2:	f2c4 0300 	movt	r3, #16384	; 0x4000
    41a6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    41a8:	f403 03e0 	and.w	r3, r3, #7340032	; 0x700000
    41ac:	ea4f 5313 	mov.w	r3, r3, lsr #20
    41b0:	2b00      	cmp	r3, #0
    41b2:	d002      	beq.n	41ba <MAC_stop_transmission+0x52>
    41b4:	687b      	ldr	r3, [r7, #4]
    41b6:	2b00      	cmp	r3, #0
    41b8:	d0e1      	beq.n	417e <MAC_stop_transmission+0x16>
    	MAC_BITBAND->CSR6_ST = 0u;
    	if( MAC_get_time_out() == 0u ) {
    		retval = MAC_TIME_OUT;
    	}
	}
	return retval;
    41ba:	687b      	ldr	r3, [r7, #4]
}
    41bc:	4618      	mov	r0, r3
    41be:	f107 0708 	add.w	r7, r7, #8
    41c2:	46bd      	mov	sp, r7
    41c4:	bd80      	pop	{r7, pc}
    41c6:	bf00      	nop

000041c8 <MAC_start_transmission>:
static void
MAC_start_transmission
(
    void
)
{
    41c8:	b480      	push	{r7}
    41ca:	af00      	add	r7, sp, #0
    MAC_BITBAND->CSR6_ST = 1u;
    41cc:	f240 0300 	movw	r3, #0
    41d0:	f2c4 2306 	movt	r3, #16902	; 0x4206
    41d4:	f04f 0201 	mov.w	r2, #1
    41d8:	f8c3 2634 	str.w	r2, [r3, #1588]	; 0x634
}
    41dc:	46bd      	mov	sp, r7
    41de:	bc80      	pop	{r7}
    41e0:	4770      	bx	lr
    41e2:	bf00      	nop

000041e4 <MAC_stop_receiving>:
static int32_t
MAC_stop_receiving
(
    void
)
{
    41e4:	b580      	push	{r7, lr}
    41e6:	b082      	sub	sp, #8
    41e8:	af00      	add	r7, sp, #0
    int32_t retval = MAC_OK;
    41ea:	f04f 0300 	mov.w	r3, #0
    41ee:	607b      	str	r3, [r7, #4]
    MAC_set_time_out( (uint16_t)STATE_CHANGE_TIME_OUT );
    41f0:	f242 7010 	movw	r0, #10000	; 0x2710
    41f4:	f000 f886 	bl	4304 <MAC_set_time_out>

	while( (((MAC->CSR5 & CSR5_RS_MASK) >> CSR5_RS_SHIFT) != CSR5_RS_STOPPED)
    41f8:	e00f      	b.n	421a <MAC_stop_receiving+0x36>
            && (retval == MAC_OK) )
	{
    	MAC_BITBAND->CSR6_SR = 0u;
    41fa:	f240 0300 	movw	r3, #0
    41fe:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4202:	f04f 0200 	mov.w	r2, #0
    4206:	f8c3 2604 	str.w	r2, [r3, #1540]	; 0x604
    	if( MAC_get_time_out() == 0u ) {
    420a:	f000 f8a3 	bl	4354 <MAC_get_time_out>
    420e:	4603      	mov	r3, r0
    4210:	2b00      	cmp	r3, #0
    4212:	d102      	bne.n	421a <MAC_stop_receiving+0x36>
    		retval = MAC_TIME_OUT;
    4214:	f06f 0305 	mvn.w	r3, #5
    4218:	607b      	str	r3, [r7, #4]
)
{
    int32_t retval = MAC_OK;
    MAC_set_time_out( (uint16_t)STATE_CHANGE_TIME_OUT );

	while( (((MAC->CSR5 & CSR5_RS_MASK) >> CSR5_RS_SHIFT) != CSR5_RS_STOPPED)
    421a:	f243 0300 	movw	r3, #12288	; 0x3000
    421e:	f2c4 0300 	movt	r3, #16384	; 0x4000
    4222:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4224:	f403 23c0 	and.w	r3, r3, #393216	; 0x60000
    4228:	ea4f 4353 	mov.w	r3, r3, lsr #17
    422c:	2b00      	cmp	r3, #0
    422e:	d002      	beq.n	4236 <MAC_stop_receiving+0x52>
    4230:	687b      	ldr	r3, [r7, #4]
    4232:	2b00      	cmp	r3, #0
    4234:	d0e1      	beq.n	41fa <MAC_stop_receiving+0x16>
    	if( MAC_get_time_out() == 0u ) {
    		retval = MAC_TIME_OUT;
    	}
	}

	return retval;
    4236:	687b      	ldr	r3, [r7, #4]
}
    4238:	4618      	mov	r0, r3
    423a:	f107 0708 	add.w	r7, r7, #8
    423e:	46bd      	mov	sp, r7
    4240:	bd80      	pop	{r7, pc}
    4242:	bf00      	nop

00004244 <MAC_start_receiving>:
static void
MAC_start_receiving
(
    void
)
{
    4244:	b480      	push	{r7}
    4246:	af00      	add	r7, sp, #0
    MAC_BITBAND->CSR6_SR = 1u;
    4248:	f240 0300 	movw	r3, #0
    424c:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4250:	f04f 0201 	mov.w	r2, #1
    4254:	f8c3 2604 	str.w	r2, [r3, #1540]	; 0x604
}
    4258:	46bd      	mov	sp, r7
    425a:	bc80      	pop	{r7}
    425c:	4770      	bx	lr
    425e:	bf00      	nop

00004260 <MAC_dismiss_bad_frames>:
static int32_t
MAC_dismiss_bad_frames
(
    void
)
{
    4260:	b580      	push	{r7, lr}
    4262:	b082      	sub	sp, #8
    4264:	af00      	add	r7, sp, #0
	int32_t dc = 0;
    4266:	f04f 0300 	mov.w	r3, #0
    426a:	603b      	str	r3, [r7, #0]
	int8_t cont = 1;
    426c:	f04f 0301 	mov.w	r3, #1
    4270:	71fb      	strb	r3, [r7, #7]

	if( MAC_BITBAND->CSR6_PB != 0u ) {
    4272:	f240 0300 	movw	r3, #0
    4276:	f2c4 2306 	movt	r3, #16902	; 0x4206
    427a:	f8d3 360c 	ldr.w	r3, [r3, #1548]	; 0x60c
    427e:	2b00      	cmp	r3, #0
    4280:	d023      	beq.n	42ca <MAC_dismiss_bad_frames+0x6a>
		/* User wants bad frames too, don't dismiss anything */
		cont = 0;
    4282:	f04f 0300 	mov.w	r3, #0
    4286:	71fb      	strb	r3, [r7, #7]
	}

	while( ( (g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    4288:	e020      	b.n	42cc <MAC_dismiss_bad_frames+0x6c>
            RDES0_OWN) == 0u) && (cont == 1) ) /* Host owns this descriptor */
    {
    	/* check error summary */
    	if( (g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    428a:	f64a 1394 	movw	r3, #43412	; 0xa994
    428e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4292:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    4296:	f64a 1394 	movw	r3, #43412	; 0xa994
    429a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    429e:	ea4f 1202 	mov.w	r2, r2, lsl #4
    42a2:	4413      	add	r3, r2
    42a4:	f103 0398 	add.w	r3, r3, #152	; 0x98
    42a8:	681b      	ldr	r3, [r3, #0]
    42aa:	f403 4303 	and.w	r3, r3, #33536	; 0x8300
    42ae:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    42b2:	d006      	beq.n	42c2 <MAC_dismiss_bad_frames+0x62>
    		(RDES0_ES | RDES0_LS | RDES0_FS)) != (RDES0_LS | RDES0_FS) )
    	{
    		MSS_MAC_prepare_rx_descriptor();
    42b4:	f7ff fb8e 	bl	39d4 <MSS_MAC_prepare_rx_descriptor>
    		dc++;
    42b8:	683b      	ldr	r3, [r7, #0]
    42ba:	f103 0301 	add.w	r3, r3, #1
    42be:	603b      	str	r3, [r7, #0]
    42c0:	e004      	b.n	42cc <MAC_dismiss_bad_frames+0x6c>
    	}
        else
        {
    		cont = 0;
    42c2:	f04f 0300 	mov.w	r3, #0
    42c6:	71fb      	strb	r3, [r7, #7]
    42c8:	e000      	b.n	42cc <MAC_dismiss_bad_frames+0x6c>
	if( MAC_BITBAND->CSR6_PB != 0u ) {
		/* User wants bad frames too, don't dismiss anything */
		cont = 0;
	}

	while( ( (g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    42ca:	bf00      	nop
    42cc:	f64a 1394 	movw	r3, #43412	; 0xa994
    42d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    42d4:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    42d8:	f64a 1394 	movw	r3, #43412	; 0xa994
    42dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    42e0:	ea4f 1202 	mov.w	r2, r2, lsl #4
    42e4:	4413      	add	r3, r2
    42e6:	f103 0398 	add.w	r3, r3, #152	; 0x98
    42ea:	681b      	ldr	r3, [r3, #0]
    42ec:	2b00      	cmp	r3, #0
    42ee:	db03      	blt.n	42f8 <MAC_dismiss_bad_frames+0x98>
    42f0:	f997 3007 	ldrsb.w	r3, [r7, #7]
    42f4:	2b01      	cmp	r3, #1
    42f6:	d0c8      	beq.n	428a <MAC_dismiss_bad_frames+0x2a>
        {
    		cont = 0;
    	}
    }

	return dc;
    42f8:	683b      	ldr	r3, [r7, #0]
}
    42fa:	4618      	mov	r0, r3
    42fc:	f107 0708 	add.w	r7, r7, #8
    4300:	46bd      	mov	sp, r7
    4302:	bd80      	pop	{r7, pc}

00004304 <MAC_set_time_out>:
static void
MAC_set_time_out
(
    uint32_t time_out
)
{
    4304:	b480      	push	{r7}
    4306:	b083      	sub	sp, #12
    4308:	af00      	add	r7, sp, #0
    430a:	6078      	str	r0, [r7, #4]
	g_mss_mac.time_out_value = (time_out * 122u) / 10u;
    430c:	687b      	ldr	r3, [r7, #4]
    430e:	f04f 027a 	mov.w	r2, #122	; 0x7a
    4312:	fb02 f203 	mul.w	r2, r2, r3
    4316:	f64c 43cd 	movw	r3, #52429	; 0xcccd
    431a:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
    431e:	fba3 1302 	umull	r1, r3, r3, r2
    4322:	ea4f 02d3 	mov.w	r2, r3, lsr #3
    4326:	f64a 1394 	movw	r3, #43412	; 0xa994
    432a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    432e:	669a      	str	r2, [r3, #104]	; 0x68

	g_mss_mac.last_timer_value = (uint16_t)( MAC->CSR11 & CSR11_TIM_MASK );
    4330:	f243 0300 	movw	r3, #12288	; 0x3000
    4334:	f2c4 0300 	movt	r3, #16384	; 0x4000
    4338:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    433a:	b29a      	uxth	r2, r3
    433c:	f64a 1394 	movw	r3, #43412	; 0xa994
    4340:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4344:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
}
    4348:	f107 070c 	add.w	r7, r7, #12
    434c:	46bd      	mov	sp, r7
    434e:	bc80      	pop	{r7}
    4350:	4770      	bx	lr
    4352:	bf00      	nop

00004354 <MAC_get_time_out>:
static uint32_t
MAC_get_time_out
(
    void
)
{
    4354:	b480      	push	{r7}
    4356:	b083      	sub	sp, #12
    4358:	af00      	add	r7, sp, #0
	uint32_t timer;
	uint32_t time = 0u;
    435a:	f04f 0300 	mov.w	r3, #0
    435e:	607b      	str	r3, [r7, #4]

	timer = ( MAC->CSR11 & CSR11_TIM_MASK );
    4360:	f243 0300 	movw	r3, #12288	; 0x3000
    4364:	f2c4 0300 	movt	r3, #16384	; 0x4000
    4368:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    436a:	ea4f 4303 	mov.w	r3, r3, lsl #16
    436e:	ea4f 4313 	mov.w	r3, r3, lsr #16
    4372:	603b      	str	r3, [r7, #0]

	if( timer > g_mss_mac.last_timer_value ) {
    4374:	f64a 1394 	movw	r3, #43412	; 0xa994
    4378:	f2c2 0300 	movt	r3, #8192	; 0x2000
    437c:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
    4380:	461a      	mov	r2, r3
    4382:	683b      	ldr	r3, [r7, #0]
    4384:	429a      	cmp	r2, r3
    4386:	d202      	bcs.n	438e <MAC_get_time_out+0x3a>
		time = 0x0000ffffUL;
    4388:	f64f 73ff 	movw	r3, #65535	; 0xffff
    438c:	607b      	str	r3, [r7, #4]
	}
	time += g_mss_mac.last_timer_value - timer;
    438e:	f64a 1394 	movw	r3, #43412	; 0xa994
    4392:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4396:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
    439a:	461a      	mov	r2, r3
    439c:	683b      	ldr	r3, [r7, #0]
    439e:	ebc3 0302 	rsb	r3, r3, r2
    43a2:	687a      	ldr	r2, [r7, #4]
    43a4:	4413      	add	r3, r2
    43a6:	607b      	str	r3, [r7, #4]

	if( MAC_BITBAND->CSR6_TTM == 0u ) {
    43a8:	f240 0300 	movw	r3, #0
    43ac:	f2c4 2306 	movt	r3, #16902	; 0x4206
    43b0:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
    43b4:	2b00      	cmp	r3, #0
    43b6:	d107      	bne.n	43c8 <MAC_get_time_out+0x74>
		time *= 10u;
    43b8:	687a      	ldr	r2, [r7, #4]
    43ba:	4613      	mov	r3, r2
    43bc:	ea4f 0383 	mov.w	r3, r3, lsl #2
    43c0:	4413      	add	r3, r2
    43c2:	ea4f 0343 	mov.w	r3, r3, lsl #1
    43c6:	607b      	str	r3, [r7, #4]
	}
	if( g_mss_mac.time_out_value <= time ){
    43c8:	f64a 1394 	movw	r3, #43412	; 0xa994
    43cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    43d0:	6e9a      	ldr	r2, [r3, #104]	; 0x68
    43d2:	687b      	ldr	r3, [r7, #4]
    43d4:	429a      	cmp	r2, r3
    43d6:	d807      	bhi.n	43e8 <MAC_get_time_out+0x94>
		g_mss_mac.time_out_value = 0u;
    43d8:	f64a 1394 	movw	r3, #43412	; 0xa994
    43dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    43e0:	f04f 0200 	mov.w	r2, #0
    43e4:	669a      	str	r2, [r3, #104]	; 0x68
    43e6:	e00c      	b.n	4402 <MAC_get_time_out+0xae>
	} else {
		g_mss_mac.time_out_value -= time;
    43e8:	f64a 1394 	movw	r3, #43412	; 0xa994
    43ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    43f0:	6e9a      	ldr	r2, [r3, #104]	; 0x68
    43f2:	687b      	ldr	r3, [r7, #4]
    43f4:	ebc3 0202 	rsb	r2, r3, r2
    43f8:	f64a 1394 	movw	r3, #43412	; 0xa994
    43fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4400:	669a      	str	r2, [r3, #104]	; 0x68
	}

	g_mss_mac.last_timer_value = (uint16_t)timer;
    4402:	683b      	ldr	r3, [r7, #0]
    4404:	b29a      	uxth	r2, r3
    4406:	f64a 1394 	movw	r3, #43412	; 0xa994
    440a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    440e:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66

	return ((g_mss_mac.time_out_value * 10u) / 122u);
    4412:	f64a 1394 	movw	r3, #43412	; 0xa994
    4416:	f2c2 0300 	movt	r3, #8192	; 0x2000
    441a:	6e9a      	ldr	r2, [r3, #104]	; 0x68
    441c:	4613      	mov	r3, r2
    441e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    4422:	4413      	add	r3, r2
    4424:	ea4f 0343 	mov.w	r3, r3, lsl #1
    4428:	461a      	mov	r2, r3
    442a:	f24c 533f 	movw	r3, #50495	; 0xc53f
    442e:	f2c4 3325 	movt	r3, #17189	; 0x4325
    4432:	fba3 1302 	umull	r1, r3, r3, r2
    4436:	ea4f 1353 	mov.w	r3, r3, lsr #5
}
    443a:	4618      	mov	r0, r3
    443c:	f107 070c 	add.w	r7, r7, #12
    4440:	46bd      	mov	sp, r7
    4442:	bc80      	pop	{r7}
    4444:	4770      	bx	lr
    4446:	bf00      	nop

00004448 <MAC_memset>:
/***************************************************************************//**
 * Fills the first n bytes of the memory area pointed to by s with the constant
 * byte c.
 */
static void MAC_memset(uint8_t *s, uint8_t c, uint32_t n)
{
    4448:	b480      	push	{r7}
    444a:	b087      	sub	sp, #28
    444c:	af00      	add	r7, sp, #0
    444e:	60f8      	str	r0, [r7, #12]
    4450:	460b      	mov	r3, r1
    4452:	607a      	str	r2, [r7, #4]
    4454:	72fb      	strb	r3, [r7, #11]
    uint8_t *sb = s;
    4456:	68fb      	ldr	r3, [r7, #12]
    4458:	617b      	str	r3, [r7, #20]

    while( n > 0u ) {
    445a:	e008      	b.n	446e <MAC_memset+0x26>
    	n--;
    445c:	687b      	ldr	r3, [r7, #4]
    445e:	f103 33ff 	add.w	r3, r3, #4294967295
    4462:	607b      	str	r3, [r7, #4]
        sb[n] = c;
    4464:	697a      	ldr	r2, [r7, #20]
    4466:	687b      	ldr	r3, [r7, #4]
    4468:	4413      	add	r3, r2
    446a:	7afa      	ldrb	r2, [r7, #11]
    446c:	701a      	strb	r2, [r3, #0]
 */
static void MAC_memset(uint8_t *s, uint8_t c, uint32_t n)
{
    uint8_t *sb = s;

    while( n > 0u ) {
    446e:	687b      	ldr	r3, [r7, #4]
    4470:	2b00      	cmp	r3, #0
    4472:	d1f3      	bne.n	445c <MAC_memset+0x14>
    	n--;
        sb[n] = c;
    }
}
    4474:	f107 071c 	add.w	r7, r7, #28
    4478:	46bd      	mov	sp, r7
    447a:	bc80      	pop	{r7}
    447c:	4770      	bx	lr
    447e:	bf00      	nop

00004480 <MAC_memset_All>:
 * Fills all fields of MAC_instance_t with c.
 *
 * @return          a pointer to the given MAC_instance_t s.
 */
static void MAC_memset_All(MAC_instance_t *s, uint32_t c)
{
    4480:	b580      	push	{r7, lr}
    4482:	b084      	sub	sp, #16
    4484:	af00      	add	r7, sp, #0
    4486:	6078      	str	r0, [r7, #4]
    4488:	6039      	str	r1, [r7, #0]
    int32_t count;
    s->base_address = (addr_t)c;
    448a:	687b      	ldr	r3, [r7, #4]
    448c:	683a      	ldr	r2, [r7, #0]
    448e:	601a      	str	r2, [r3, #0]
    s->flags = (uint8_t)c;
    4490:	683b      	ldr	r3, [r7, #0]
    4492:	b2da      	uxtb	r2, r3
    4494:	687b      	ldr	r3, [r7, #4]
    4496:	711a      	strb	r2, [r3, #4]
    s->last_error = (int8_t)c;
    4498:	683b      	ldr	r3, [r7, #0]
    449a:	b2da      	uxtb	r2, r3
    449c:	687b      	ldr	r3, [r7, #4]
    449e:	715a      	strb	r2, [r3, #5]
    s->last_timer_value = (uint16_t)c;
    44a0:	683b      	ldr	r3, [r7, #0]
    44a2:	b29a      	uxth	r2, r3
    44a4:	687b      	ldr	r3, [r7, #4]
    44a6:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
    s->listener = NULL_callback;
    44aa:	f240 638c 	movw	r3, #1676	; 0x68c
    44ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    44b2:	681a      	ldr	r2, [r3, #0]
    44b4:	687b      	ldr	r3, [r7, #4]
    44b6:	66da      	str	r2, [r3, #108]	; 0x6c
   	MAC_memset( s->mac_address, (uint8_t)c, 6u );
    44b8:	687b      	ldr	r3, [r7, #4]
    44ba:	f103 0206 	add.w	r2, r3, #6
    44be:	683b      	ldr	r3, [r7, #0]
    44c0:	b2db      	uxtb	r3, r3
    44c2:	4610      	mov	r0, r2
    44c4:	4619      	mov	r1, r3
    44c6:	f04f 0206 	mov.w	r2, #6
    44ca:	f7ff ffbd 	bl	4448 <MAC_memset>
   	MAC_memset( s->mac_filter_data, (uint8_t)c, 90u );
    44ce:	687b      	ldr	r3, [r7, #4]
    44d0:	f103 020c 	add.w	r2, r3, #12
    44d4:	683b      	ldr	r3, [r7, #0]
    44d6:	b2db      	uxtb	r3, r3
    44d8:	4610      	mov	r0, r2
    44da:	4619      	mov	r1, r3
    44dc:	f04f 025a 	mov.w	r2, #90	; 0x5a
    44e0:	f7ff ffb2 	bl	4448 <MAC_memset>
    s->phy_address = (uint8_t)c;
    44e4:	683b      	ldr	r3, [r7, #0]
    44e6:	b2da      	uxtb	r2, r3
    44e8:	687b      	ldr	r3, [r7, #4]
    44ea:	f883 20e8 	strb.w	r2, [r3, #232]	; 0xe8
    s->rx_desc_index =c;
    44ee:	687b      	ldr	r3, [r7, #4]
    44f0:	683a      	ldr	r2, [r7, #0]
    44f2:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    for(count = 0; count<RX_RING_SIZE ;count++)
    44f6:	f04f 0300 	mov.w	r3, #0
    44fa:	60fb      	str	r3, [r7, #12]
    44fc:	e029      	b.n	4552 <MAC_memset_All+0xd2>
    {
        s->rx_descriptors[count].buffer_1 = c;
    44fe:	68fa      	ldr	r2, [r7, #12]
    4500:	687b      	ldr	r3, [r7, #4]
    4502:	f102 020a 	add.w	r2, r2, #10
    4506:	ea4f 1202 	mov.w	r2, r2, lsl #4
    450a:	4413      	add	r3, r2
    450c:	683a      	ldr	r2, [r7, #0]
    450e:	601a      	str	r2, [r3, #0]
        s->rx_descriptors[count].buffer_2 = c;
    4510:	68fa      	ldr	r2, [r7, #12]
    4512:	687b      	ldr	r3, [r7, #4]
    4514:	f102 020a 	add.w	r2, r2, #10
    4518:	ea4f 1202 	mov.w	r2, r2, lsl #4
    451c:	4413      	add	r3, r2
    451e:	f103 0304 	add.w	r3, r3, #4
    4522:	683a      	ldr	r2, [r7, #0]
    4524:	601a      	str	r2, [r3, #0]
        s->rx_descriptors[count].descriptor_0 = c;
    4526:	68fa      	ldr	r2, [r7, #12]
    4528:	687b      	ldr	r3, [r7, #4]
    452a:	ea4f 1202 	mov.w	r2, r2, lsl #4
    452e:	4413      	add	r3, r2
    4530:	f103 0398 	add.w	r3, r3, #152	; 0x98
    4534:	683a      	ldr	r2, [r7, #0]
    4536:	601a      	str	r2, [r3, #0]
        s->rx_descriptors[count].descriptor_1 = c;
    4538:	68fa      	ldr	r2, [r7, #12]
    453a:	687b      	ldr	r3, [r7, #4]
    453c:	ea4f 1202 	mov.w	r2, r2, lsl #4
    4540:	4413      	add	r3, r2
    4542:	f103 039c 	add.w	r3, r3, #156	; 0x9c
    4546:	683a      	ldr	r2, [r7, #0]
    4548:	601a      	str	r2, [r3, #0]
    s->listener = NULL_callback;
   	MAC_memset( s->mac_address, (uint8_t)c, 6u );
   	MAC_memset( s->mac_filter_data, (uint8_t)c, 90u );
    s->phy_address = (uint8_t)c;
    s->rx_desc_index =c;
    for(count = 0; count<RX_RING_SIZE ;count++)
    454a:	68fb      	ldr	r3, [r7, #12]
    454c:	f103 0301 	add.w	r3, r3, #1
    4550:	60fb      	str	r3, [r7, #12]
    4552:	68fb      	ldr	r3, [r7, #12]
    4554:	2b04      	cmp	r3, #4
    4556:	ddd2      	ble.n	44fe <MAC_memset_All+0x7e>
        s->rx_descriptors[count].buffer_1 = c;
        s->rx_descriptors[count].buffer_2 = c;
        s->rx_descriptors[count].descriptor_0 = c;
        s->rx_descriptors[count].descriptor_1 = c;
    }
    s->statistics.rx_collision_seen =c;
    4558:	687b      	ldr	r3, [r7, #4]
    455a:	683a      	ldr	r2, [r7, #0]
    455c:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    4560:	ea4f 2202 	mov.w	r2, r2, lsl #8
    4564:	f8d3 1104 	ldr.w	r1, [r3, #260]	; 0x104
    4568:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    456c:	ea41 0202 	orr.w	r2, r1, r2
    4570:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    4574:	78fa      	ldrb	r2, [r7, #3]
    4576:	f04f 0100 	mov.w	r1, #0
    457a:	ea41 0202 	orr.w	r2, r1, r2
    457e:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
    s->statistics.rx_crc_error = c;
    4582:	687b      	ldr	r3, [r7, #4]
    4584:	683a      	ldr	r2, [r7, #0]
    4586:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    458a:	ea4f 2202 	mov.w	r2, r2, lsl #8
    458e:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
    4592:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    4596:	ea41 0202 	orr.w	r2, r1, r2
    459a:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
    459e:	78fa      	ldrb	r2, [r7, #3]
    45a0:	f04f 0100 	mov.w	r1, #0
    45a4:	ea41 0202 	orr.w	r2, r1, r2
    45a8:	f883 210c 	strb.w	r2, [r3, #268]	; 0x10c
    s->statistics.rx_descriptor_error = c;
    45ac:	687b      	ldr	r3, [r7, #4]
    45ae:	683a      	ldr	r2, [r7, #0]
    45b0:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    45b4:	ea4f 2202 	mov.w	r2, r2, lsl #8
    45b8:	f8d3 10f0 	ldr.w	r1, [r3, #240]	; 0xf0
    45bc:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    45c0:	ea41 0202 	orr.w	r2, r1, r2
    45c4:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
    45c8:	78fa      	ldrb	r2, [r7, #3]
    45ca:	f04f 0100 	mov.w	r1, #0
    45ce:	ea41 0202 	orr.w	r2, r1, r2
    45d2:	f883 20f4 	strb.w	r2, [r3, #244]	; 0xf4
    s->statistics.rx_fifo_overflow = c;
    45d6:	687b      	ldr	r3, [r7, #4]
    45d8:	683a      	ldr	r2, [r7, #0]
    45da:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    45de:	ea4f 2202 	mov.w	r2, r2, lsl #8
    45e2:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
    45e6:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    45ea:	ea41 0202 	orr.w	r2, r1, r2
    45ee:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    45f2:	78fa      	ldrb	r2, [r7, #3]
    45f4:	f04f 0100 	mov.w	r1, #0
    45f8:	ea41 0202 	orr.w	r2, r1, r2
    45fc:	f883 2110 	strb.w	r2, [r3, #272]	; 0x110
    s->statistics.rx_filtering_fail = c;
    4600:	687b      	ldr	r3, [r7, #4]
    4602:	683a      	ldr	r2, [r7, #0]
    4604:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    4608:	ea4f 2202 	mov.w	r2, r2, lsl #8
    460c:	f8d3 10ec 	ldr.w	r1, [r3, #236]	; 0xec
    4610:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    4614:	ea41 0202 	orr.w	r2, r1, r2
    4618:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
    461c:	78fa      	ldrb	r2, [r7, #3]
    461e:	f04f 0100 	mov.w	r1, #0
    4622:	ea41 0202 	orr.w	r2, r1, r2
    4626:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
    s->statistics.rx_frame_too_long = c;
    462a:	687b      	ldr	r3, [r7, #4]
    462c:	683a      	ldr	r2, [r7, #0]
    462e:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    4632:	ea4f 2202 	mov.w	r2, r2, lsl #8
    4636:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
    463a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    463e:	ea41 0202 	orr.w	r2, r1, r2
    4642:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    4646:	78fa      	ldrb	r2, [r7, #3]
    4648:	f04f 0100 	mov.w	r1, #0
    464c:	ea41 0202 	orr.w	r2, r1, r2
    4650:	f883 2104 	strb.w	r2, [r3, #260]	; 0x104
    s->statistics.rx_interrupts = c;
    4654:	687b      	ldr	r3, [r7, #4]
    4656:	683a      	ldr	r2, [r7, #0]
    4658:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    465c:	ea4f 2202 	mov.w	r2, r2, lsl #8
    4660:	f8d3 10e8 	ldr.w	r1, [r3, #232]	; 0xe8
    4664:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    4668:	ea41 0202 	orr.w	r2, r1, r2
    466c:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
    4670:	78fa      	ldrb	r2, [r7, #3]
    4672:	f04f 0100 	mov.w	r1, #0
    4676:	ea41 0202 	orr.w	r2, r1, r2
    467a:	f883 20ec 	strb.w	r2, [r3, #236]	; 0xec
    s->statistics.rx_missed_frame = c;
    467e:	687b      	ldr	r3, [r7, #4]
    4680:	683a      	ldr	r2, [r7, #0]
    4682:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    4686:	ea4f 2202 	mov.w	r2, r2, lsl #8
    468a:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
    468e:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    4692:	ea41 0202 	orr.w	r2, r1, r2
    4696:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
    469a:	78fa      	ldrb	r2, [r7, #3]
    469c:	f04f 0100 	mov.w	r1, #0
    46a0:	ea41 0202 	orr.w	r2, r1, r2
    46a4:	f883 2114 	strb.w	r2, [r3, #276]	; 0x114
    s->statistics.rx_not_first = c;
    46a8:	687b      	ldr	r3, [r7, #4]
    46aa:	683a      	ldr	r2, [r7, #0]
    46ac:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    46b0:	ea4f 2202 	mov.w	r2, r2, lsl #8
    46b4:	f8d3 10f8 	ldr.w	r1, [r3, #248]	; 0xf8
    46b8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    46bc:	ea41 0202 	orr.w	r2, r1, r2
    46c0:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
    46c4:	78fa      	ldrb	r2, [r7, #3]
    46c6:	f04f 0100 	mov.w	r1, #0
    46ca:	ea41 0202 	orr.w	r2, r1, r2
    46ce:	f883 20fc 	strb.w	r2, [r3, #252]	; 0xfc
    s->statistics.rx_not_last = c;
    46d2:	687b      	ldr	r3, [r7, #4]
    46d4:	683a      	ldr	r2, [r7, #0]
    46d6:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    46da:	ea4f 2202 	mov.w	r2, r2, lsl #8
    46de:	f8d3 10fc 	ldr.w	r1, [r3, #252]	; 0xfc
    46e2:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    46e6:	ea41 0202 	orr.w	r2, r1, r2
    46ea:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
    46ee:	78fa      	ldrb	r2, [r7, #3]
    46f0:	f04f 0100 	mov.w	r1, #0
    46f4:	ea41 0202 	orr.w	r2, r1, r2
    46f8:	f883 2100 	strb.w	r2, [r3, #256]	; 0x100
    s->statistics.rx_runt_frame = c;
    46fc:	687b      	ldr	r3, [r7, #4]
    46fe:	683a      	ldr	r2, [r7, #0]
    4700:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    4704:	ea4f 2202 	mov.w	r2, r2, lsl #8
    4708:	f8d3 10f4 	ldr.w	r1, [r3, #244]	; 0xf4
    470c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    4710:	ea41 0202 	orr.w	r2, r1, r2
    4714:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
    4718:	78fa      	ldrb	r2, [r7, #3]
    471a:	f04f 0100 	mov.w	r1, #0
    471e:	ea41 0202 	orr.w	r2, r1, r2
    4722:	f883 20f8 	strb.w	r2, [r3, #248]	; 0xf8
    s->statistics.tx_collision_count = c;
    4726:	687b      	ldr	r3, [r7, #4]
    4728:	683a      	ldr	r2, [r7, #0]
    472a:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    472e:	ea4f 2202 	mov.w	r2, r2, lsl #8
    4732:	f8d3 1128 	ldr.w	r1, [r3, #296]	; 0x128
    4736:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    473a:	ea41 0202 	orr.w	r2, r1, r2
    473e:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
    4742:	78fa      	ldrb	r2, [r7, #3]
    4744:	f04f 0100 	mov.w	r1, #0
    4748:	ea41 0202 	orr.w	r2, r1, r2
    474c:	f883 212c 	strb.w	r2, [r3, #300]	; 0x12c
    s->statistics.tx_excessive_collision = c;
    4750:	687b      	ldr	r3, [r7, #4]
    4752:	683a      	ldr	r2, [r7, #0]
    4754:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    4758:	ea4f 2202 	mov.w	r2, r2, lsl #8
    475c:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
    4760:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    4764:	ea41 0202 	orr.w	r2, r1, r2
    4768:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
    476c:	78fa      	ldrb	r2, [r7, #3]
    476e:	f04f 0100 	mov.w	r1, #0
    4772:	ea41 0202 	orr.w	r2, r1, r2
    4776:	f883 2128 	strb.w	r2, [r3, #296]	; 0x128
    s->statistics.tx_interrupts = c;
    477a:	687b      	ldr	r3, [r7, #4]
    477c:	683a      	ldr	r2, [r7, #0]
    477e:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    4782:	ea4f 2202 	mov.w	r2, r2, lsl #8
    4786:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
    478a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    478e:	ea41 0202 	orr.w	r2, r1, r2
    4792:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    4796:	78fa      	ldrb	r2, [r7, #3]
    4798:	f04f 0100 	mov.w	r1, #0
    479c:	ea41 0202 	orr.w	r2, r1, r2
    47a0:	f883 2118 	strb.w	r2, [r3, #280]	; 0x118
    s->statistics.tx_late_collision = c;
    47a4:	687b      	ldr	r3, [r7, #4]
    47a6:	683a      	ldr	r2, [r7, #0]
    47a8:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    47ac:	ea4f 2202 	mov.w	r2, r2, lsl #8
    47b0:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
    47b4:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    47b8:	ea41 0202 	orr.w	r2, r1, r2
    47bc:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
    47c0:	78fa      	ldrb	r2, [r7, #3]
    47c2:	f04f 0100 	mov.w	r1, #0
    47c6:	ea41 0202 	orr.w	r2, r1, r2
    47ca:	f883 2124 	strb.w	r2, [r3, #292]	; 0x124
    s->statistics.tx_loss_of_carrier = c;
    47ce:	687b      	ldr	r3, [r7, #4]
    47d0:	683a      	ldr	r2, [r7, #0]
    47d2:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    47d6:	ea4f 2202 	mov.w	r2, r2, lsl #8
    47da:	f8d3 1118 	ldr.w	r1, [r3, #280]	; 0x118
    47de:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    47e2:	ea41 0202 	orr.w	r2, r1, r2
    47e6:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
    47ea:	78fa      	ldrb	r2, [r7, #3]
    47ec:	f04f 0100 	mov.w	r1, #0
    47f0:	ea41 0202 	orr.w	r2, r1, r2
    47f4:	f883 211c 	strb.w	r2, [r3, #284]	; 0x11c
    s->statistics.tx_no_carrier = c;
    47f8:	687b      	ldr	r3, [r7, #4]
    47fa:	683a      	ldr	r2, [r7, #0]
    47fc:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    4800:	ea4f 2202 	mov.w	r2, r2, lsl #8
    4804:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
    4808:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    480c:	ea41 0202 	orr.w	r2, r1, r2
    4810:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
    4814:	78fa      	ldrb	r2, [r7, #3]
    4816:	f04f 0100 	mov.w	r1, #0
    481a:	ea41 0202 	orr.w	r2, r1, r2
    481e:	f883 2120 	strb.w	r2, [r3, #288]	; 0x120
    s->statistics.tx_underflow_error = c;
    4822:	687b      	ldr	r3, [r7, #4]
    4824:	683a      	ldr	r2, [r7, #0]
    4826:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    482a:	ea4f 2202 	mov.w	r2, r2, lsl #8
    482e:	f8d3 112c 	ldr.w	r1, [r3, #300]	; 0x12c
    4832:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    4836:	ea41 0202 	orr.w	r2, r1, r2
    483a:	f8c3 212c 	str.w	r2, [r3, #300]	; 0x12c
    483e:	78fa      	ldrb	r2, [r7, #3]
    4840:	f04f 0100 	mov.w	r1, #0
    4844:	ea41 0202 	orr.w	r2, r1, r2
    4848:	f883 2130 	strb.w	r2, [r3, #304]	; 0x130
    s->time_out_value = c;
    484c:	687b      	ldr	r3, [r7, #4]
    484e:	683a      	ldr	r2, [r7, #0]
    4850:	669a      	str	r2, [r3, #104]	; 0x68
    s->tx_desc_index = c;
    4852:	687b      	ldr	r3, [r7, #4]
    4854:	683a      	ldr	r2, [r7, #0]
    4856:	671a      	str	r2, [r3, #112]	; 0x70
    for(count = 0; count < TX_RING_SIZE ;count++)
    4858:	f04f 0300 	mov.w	r3, #0
    485c:	60fb      	str	r3, [r7, #12]
    485e:	e02b      	b.n	48b8 <MAC_memset_All+0x438>
    {
        s->tx_descriptors[count].buffer_1 = c;
    4860:	68fa      	ldr	r2, [r7, #12]
    4862:	687b      	ldr	r3, [r7, #4]
    4864:	ea4f 1202 	mov.w	r2, r2, lsl #4
    4868:	4413      	add	r3, r2
    486a:	f103 037c 	add.w	r3, r3, #124	; 0x7c
    486e:	683a      	ldr	r2, [r7, #0]
    4870:	601a      	str	r2, [r3, #0]
        s->tx_descriptors[count].buffer_2 = c;
    4872:	68fa      	ldr	r2, [r7, #12]
    4874:	687b      	ldr	r3, [r7, #4]
    4876:	ea4f 1202 	mov.w	r2, r2, lsl #4
    487a:	4413      	add	r3, r2
    487c:	f103 0380 	add.w	r3, r3, #128	; 0x80
    4880:	683a      	ldr	r2, [r7, #0]
    4882:	601a      	str	r2, [r3, #0]
        s->tx_descriptors[count].descriptor_0 = c;
    4884:	68fa      	ldr	r2, [r7, #12]
    4886:	687b      	ldr	r3, [r7, #4]
    4888:	f102 0207 	add.w	r2, r2, #7
    488c:	ea4f 1202 	mov.w	r2, r2, lsl #4
    4890:	4413      	add	r3, r2
    4892:	f103 0304 	add.w	r3, r3, #4
    4896:	683a      	ldr	r2, [r7, #0]
    4898:	601a      	str	r2, [r3, #0]
        s->tx_descriptors[count].descriptor_1 = c;
    489a:	68fa      	ldr	r2, [r7, #12]
    489c:	687b      	ldr	r3, [r7, #4]
    489e:	f102 0207 	add.w	r2, r2, #7
    48a2:	ea4f 1202 	mov.w	r2, r2, lsl #4
    48a6:	4413      	add	r3, r2
    48a8:	f103 0308 	add.w	r3, r3, #8
    48ac:	683a      	ldr	r2, [r7, #0]
    48ae:	601a      	str	r2, [r3, #0]
    s->statistics.tx_loss_of_carrier = c;
    s->statistics.tx_no_carrier = c;
    s->statistics.tx_underflow_error = c;
    s->time_out_value = c;
    s->tx_desc_index = c;
    for(count = 0; count < TX_RING_SIZE ;count++)
    48b0:	68fb      	ldr	r3, [r7, #12]
    48b2:	f103 0301 	add.w	r3, r3, #1
    48b6:	60fb      	str	r3, [r7, #12]
    48b8:	68fb      	ldr	r3, [r7, #12]
    48ba:	2b01      	cmp	r3, #1
    48bc:	ddd0      	ble.n	4860 <MAC_memset_All+0x3e0>
        s->tx_descriptors[count].buffer_1 = c;
        s->tx_descriptors[count].buffer_2 = c;
        s->tx_descriptors[count].descriptor_0 = c;
        s->tx_descriptors[count].descriptor_1 = c;
    }
}
    48be:	f107 0710 	add.w	r7, r7, #16
    48c2:	46bd      	mov	sp, r7
    48c4:	bd80      	pop	{r7, pc}
    48c6:	bf00      	nop

000048c8 <MAC_memcpy>:
 * The memory areas should not overlap.
 *
 * @return          a pointer to the memory area dest.
 */
static void MAC_memcpy(uint8_t *dest, const uint8_t *src, uint32_t n)
{
    48c8:	b480      	push	{r7}
    48ca:	b087      	sub	sp, #28
    48cc:	af00      	add	r7, sp, #0
    48ce:	60f8      	str	r0, [r7, #12]
    48d0:	60b9      	str	r1, [r7, #8]
    48d2:	607a      	str	r2, [r7, #4]
    uint8_t *d = dest;
    48d4:	68fb      	ldr	r3, [r7, #12]
    48d6:	617b      	str	r3, [r7, #20]

    while( n > 0u ) {
    48d8:	e00b      	b.n	48f2 <MAC_memcpy+0x2a>
    	n--;
    48da:	687b      	ldr	r3, [r7, #4]
    48dc:	f103 33ff 	add.w	r3, r3, #4294967295
    48e0:	607b      	str	r3, [r7, #4]
        d[n] = src[n];
    48e2:	697a      	ldr	r2, [r7, #20]
    48e4:	687b      	ldr	r3, [r7, #4]
    48e6:	4413      	add	r3, r2
    48e8:	68b9      	ldr	r1, [r7, #8]
    48ea:	687a      	ldr	r2, [r7, #4]
    48ec:	440a      	add	r2, r1
    48ee:	7812      	ldrb	r2, [r2, #0]
    48f0:	701a      	strb	r2, [r3, #0]
 */
static void MAC_memcpy(uint8_t *dest, const uint8_t *src, uint32_t n)
{
    uint8_t *d = dest;

    while( n > 0u ) {
    48f2:	687b      	ldr	r3, [r7, #4]
    48f4:	2b00      	cmp	r3, #0
    48f6:	d1f0      	bne.n	48da <MAC_memcpy+0x12>
    	n--;
        d[n] = src[n];
    }
}
    48f8:	f107 071c 	add.w	r7, r7, #28
    48fc:	46bd      	mov	sp, r7
    48fe:	bc80      	pop	{r7}
    4900:	4770      	bx	lr
    4902:	bf00      	nop

00004904 <MSS_MAC_FreeTxBuffers>:
 * Tx has completed, mark the buffers that were assigned to the Tx descriptors
 * as free again.
 *
 */
void MSS_MAC_FreeTxBuffers( void )
{
    4904:	b580      	push	{r7, lr}
    4906:	b082      	sub	sp, #8
    4908:	af00      	add	r7, sp, #0
	/* Check the buffers have not already been freed in the first of the
	two Tx interrupts - which could potentially happen if the second Tx completed
	during the interrupt for the first Tx. */
	if( g_mss_mac.tx_descriptors[ 0 ].buffer_1 != ( uint32_t ) NULL )
    490a:	f64a 1394 	movw	r3, #43412	; 0xa994
    490e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4912:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
    4914:	2b00      	cmp	r3, #0
    4916:	d034      	beq.n	4982 <MSS_MAC_FreeTxBuffers+0x7e>
	{
		if( ( ( (g_mss_mac.tx_descriptors[ 0 ].descriptor_0) & TDES0_OWN) == 0 ) && ( ( (g_mss_mac.tx_descriptors[ 1 ].descriptor_0) & TDES0_OWN) == 0 ) )
    4918:	f64a 1394 	movw	r3, #43412	; 0xa994
    491c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4920:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    4922:	2b00      	cmp	r3, #0
    4924:	db2d      	blt.n	4982 <MSS_MAC_FreeTxBuffers+0x7e>
    4926:	f64a 1394 	movw	r3, #43412	; 0xa994
    492a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    492e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
    4932:	2b00      	cmp	r3, #0
    4934:	db25      	blt.n	4982 <MSS_MAC_FreeTxBuffers+0x7e>
		{
			configASSERT( g_mss_mac.tx_descriptors[ 0 ].buffer_1 == g_mss_mac.tx_descriptors[ 1 ].buffer_1 );
    4936:	f64a 1394 	movw	r3, #43412	; 0xa994
    493a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    493e:	6fda      	ldr	r2, [r3, #124]	; 0x7c
    4940:	f64a 1394 	movw	r3, #43412	; 0xa994
    4944:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4948:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
    494c:	429a      	cmp	r2, r3
    494e:	d009      	beq.n	4964 <MSS_MAC_FreeTxBuffers+0x60>
    4950:	f04f 0328 	mov.w	r3, #40	; 0x28
    4954:	f383 8811 	msr	BASEPRI, r3
    4958:	f3bf 8f6f 	isb	sy
    495c:	f3bf 8f4f 	dsb	sy
    4960:	607b      	str	r3, [r7, #4]
    4962:	e7fe      	b.n	4962 <MSS_MAC_FreeTxBuffers+0x5e>
			MAC_release_buffer( ( unsigned char * ) g_mss_mac.tx_descriptors[ 0 ].buffer_1 );
    4964:	f64a 1394 	movw	r3, #43412	; 0xa994
    4968:	f2c2 0300 	movt	r3, #8192	; 0x2000
    496c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
    496e:	4618      	mov	r0, r3
    4970:	f000 f8c8 	bl	4b04 <MAC_release_buffer>
			
			/* Just to mark the fact that the buffer has already been released. */
			g_mss_mac.tx_descriptors[ 0 ].buffer_1 = ( uint32_t ) NULL;
    4974:	f64a 1394 	movw	r3, #43412	; 0xa994
    4978:	f2c2 0300 	movt	r3, #8192	; 0x2000
    497c:	f04f 0200 	mov.w	r2, #0
    4980:	67da      	str	r2, [r3, #124]	; 0x7c
		}
	}
}
    4982:	f107 0708 	add.w	r7, r7, #8
    4986:	46bd      	mov	sp, r7
    4988:	bd80      	pop	{r7, pc}
    498a:	bf00      	nop

0000498c <MAC_obtain_buffer>:
 * as in use, then return its address.
 *
 * @return          a pointer to a free buffer.
 */
unsigned char *MAC_obtain_buffer( void )
{
    498c:	b480      	push	{r7}
    498e:	b089      	sub	sp, #36	; 0x24
    4990:	af00      	add	r7, sp, #0
long lIndex, lAttempt = 0, lDescriptor, lBufferIsInUse;
    4992:	f04f 0300 	mov.w	r3, #0
    4996:	60bb      	str	r3, [r7, #8]
unsigned char *pcReturn = NULL;
    4998:	f04f 0300 	mov.w	r3, #0
    499c:	617b      	str	r3, [r7, #20]
unsigned char *pcBufferAddress;

	/* Find and return the address of a buffer that is not being used.  Mark
	the buffer as now in use. */
	while( ( lAttempt <= 1 ) && ( pcReturn == NULL ) )
    499e:	e096      	b.n	4ace <MAC_obtain_buffer+0x142>
	{
		for( lIndex = 0; lIndex < macNUM_BUFFERS; lIndex++ )
    49a0:	f04f 0300 	mov.w	r3, #0
    49a4:	607b      	str	r3, [r7, #4]
    49a6:	e01f      	b.n	49e8 <MAC_obtain_buffer+0x5c>
		{
			if( ucMACBufferInUse[ lIndex ] == pdFALSE )
    49a8:	687a      	ldr	r2, [r7, #4]
    49aa:	f642 7344 	movw	r3, #12100	; 0x2f44
    49ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    49b2:	5c9b      	ldrb	r3, [r3, r2]
    49b4:	2b00      	cmp	r3, #0
    49b6:	d113      	bne.n	49e0 <MAC_obtain_buffer+0x54>
			{
				pcReturn = &( xMACBuffers.ucBuffer[ lIndex ][ 0 ] );
    49b8:	f240 6394 	movw	r3, #1684	; 0x694
    49bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    49c0:	687a      	ldr	r2, [r7, #4]
    49c2:	f44f 61ba 	mov.w	r1, #1488	; 0x5d0
    49c6:	fb01 f202 	mul.w	r2, r1, r2
    49ca:	4413      	add	r3, r2
    49cc:	617b      	str	r3, [r7, #20]
				ucMACBufferInUse[ lIndex ] = pdTRUE;
    49ce:	687a      	ldr	r2, [r7, #4]
    49d0:	f642 7344 	movw	r3, #12100	; 0x2f44
    49d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    49d8:	f04f 0101 	mov.w	r1, #1
    49dc:	5499      	strb	r1, [r3, r2]
				break;
    49de:	e006      	b.n	49ee <MAC_obtain_buffer+0x62>

	/* Find and return the address of a buffer that is not being used.  Mark
	the buffer as now in use. */
	while( ( lAttempt <= 1 ) && ( pcReturn == NULL ) )
	{
		for( lIndex = 0; lIndex < macNUM_BUFFERS; lIndex++ )
    49e0:	687b      	ldr	r3, [r7, #4]
    49e2:	f103 0301 	add.w	r3, r3, #1
    49e6:	607b      	str	r3, [r7, #4]
    49e8:	687b      	ldr	r3, [r7, #4]
    49ea:	2b06      	cmp	r3, #6
    49ec:	dddc      	ble.n	49a8 <MAC_obtain_buffer+0x1c>
				ucMACBufferInUse[ lIndex ] = pdTRUE;
				break;
			}
		}
		
		if( pcReturn == NULL )
    49ee:	697b      	ldr	r3, [r7, #20]
    49f0:	2b00      	cmp	r3, #0
    49f2:	d168      	bne.n	4ac6 <MAC_obtain_buffer+0x13a>
		{
			/* Did not find a buffer.  That should not really happen, but could if
			an interrupt was missed.  See if any buffers are marked as in use, but
			are not actually in use. */
			for( lIndex = 0; lIndex < macNUM_BUFFERS; lIndex++ )
    49f4:	f04f 0300 	mov.w	r3, #0
    49f8:	607b      	str	r3, [r7, #4]
    49fa:	e061      	b.n	4ac0 <MAC_obtain_buffer+0x134>
			{
				pcBufferAddress = &( xMACBuffers.ucBuffer[ lIndex ][ 0 ] );
    49fc:	f240 6394 	movw	r3, #1684	; 0x694
    4a00:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4a04:	687a      	ldr	r2, [r7, #4]
    4a06:	f44f 61ba 	mov.w	r1, #1488	; 0x5d0
    4a0a:	fb01 f202 	mul.w	r2, r1, r2
    4a0e:	4413      	add	r3, r2
    4a10:	61bb      	str	r3, [r7, #24]
				lBufferIsInUse = pdFALSE;
    4a12:	f04f 0300 	mov.w	r3, #0
    4a16:	613b      	str	r3, [r7, #16]
				
				/* Is the buffer used by an Rx descriptor? */
				for( lDescriptor = 0; lDescriptor < RX_RING_SIZE; lDescriptor++ )
    4a18:	f04f 0300 	mov.w	r3, #0
    4a1c:	60fb      	str	r3, [r7, #12]
    4a1e:	e015      	b.n	4a4c <MAC_obtain_buffer+0xc0>
				{
					if( g_mss_mac.rx_descriptors[ lDescriptor ].buffer_1 == ( uint32_t ) pcBufferAddress )
    4a20:	68fa      	ldr	r2, [r7, #12]
    4a22:	f64a 1394 	movw	r3, #43412	; 0xa994
    4a26:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4a2a:	f102 020a 	add.w	r2, r2, #10
    4a2e:	ea4f 1202 	mov.w	r2, r2, lsl #4
    4a32:	4413      	add	r3, r2
    4a34:	681a      	ldr	r2, [r3, #0]
    4a36:	69bb      	ldr	r3, [r7, #24]
    4a38:	429a      	cmp	r2, r3
    4a3a:	d103      	bne.n	4a44 <MAC_obtain_buffer+0xb8>
					{
						/* The buffer is in use by an Rx descriptor. */
						lBufferIsInUse = pdTRUE;
    4a3c:	f04f 0301 	mov.w	r3, #1
    4a40:	613b      	str	r3, [r7, #16]
						break;
    4a42:	e006      	b.n	4a52 <MAC_obtain_buffer+0xc6>
			{
				pcBufferAddress = &( xMACBuffers.ucBuffer[ lIndex ][ 0 ] );
				lBufferIsInUse = pdFALSE;
				
				/* Is the buffer used by an Rx descriptor? */
				for( lDescriptor = 0; lDescriptor < RX_RING_SIZE; lDescriptor++ )
    4a44:	68fb      	ldr	r3, [r7, #12]
    4a46:	f103 0301 	add.w	r3, r3, #1
    4a4a:	60fb      	str	r3, [r7, #12]
    4a4c:	68fb      	ldr	r3, [r7, #12]
    4a4e:	2b04      	cmp	r3, #4
    4a50:	dde6      	ble.n	4a20 <MAC_obtain_buffer+0x94>
						lBufferIsInUse = pdTRUE;
						break;
					}
				}
				
				if( lBufferIsInUse != pdTRUE )
    4a52:	693b      	ldr	r3, [r7, #16]
    4a54:	2b01      	cmp	r3, #1
    4a56:	d01c      	beq.n	4a92 <MAC_obtain_buffer+0x106>
				{
					/* Is the buffer used by an Tx descriptor? */
					for( lDescriptor = 0; lDescriptor < TX_RING_SIZE; lDescriptor++ )
    4a58:	f04f 0300 	mov.w	r3, #0
    4a5c:	60fb      	str	r3, [r7, #12]
    4a5e:	e015      	b.n	4a8c <MAC_obtain_buffer+0x100>
					{
						if( g_mss_mac.tx_descriptors[ lDescriptor ].buffer_1 == ( uint32_t ) pcBufferAddress )
    4a60:	68fa      	ldr	r2, [r7, #12]
    4a62:	f64a 1394 	movw	r3, #43412	; 0xa994
    4a66:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4a6a:	ea4f 1202 	mov.w	r2, r2, lsl #4
    4a6e:	4413      	add	r3, r2
    4a70:	f103 037c 	add.w	r3, r3, #124	; 0x7c
    4a74:	681a      	ldr	r2, [r3, #0]
    4a76:	69bb      	ldr	r3, [r7, #24]
    4a78:	429a      	cmp	r2, r3
    4a7a:	d103      	bne.n	4a84 <MAC_obtain_buffer+0xf8>
						{
							/* The buffer is in use by an Tx descriptor. */
							lBufferIsInUse = pdTRUE;
    4a7c:	f04f 0301 	mov.w	r3, #1
    4a80:	613b      	str	r3, [r7, #16]
							break;
    4a82:	e006      	b.n	4a92 <MAC_obtain_buffer+0x106>
				}
				
				if( lBufferIsInUse != pdTRUE )
				{
					/* Is the buffer used by an Tx descriptor? */
					for( lDescriptor = 0; lDescriptor < TX_RING_SIZE; lDescriptor++ )
    4a84:	68fb      	ldr	r3, [r7, #12]
    4a86:	f103 0301 	add.w	r3, r3, #1
    4a8a:	60fb      	str	r3, [r7, #12]
    4a8c:	68fb      	ldr	r3, [r7, #12]
    4a8e:	2b01      	cmp	r3, #1
    4a90:	dde6      	ble.n	4a60 <MAC_obtain_buffer+0xd4>
				}
				
				/* If the buffer was not found to be in use by either a Tx or an
				Rx descriptor, but the buffer is marked as in use, then mark the
				buffer to be in it's correct state of "not in use". */
				if( ( lBufferIsInUse == pdFALSE ) && ( ucMACBufferInUse[ lIndex ] == pdTRUE ) )
    4a92:	693b      	ldr	r3, [r7, #16]
    4a94:	2b00      	cmp	r3, #0
    4a96:	d10f      	bne.n	4ab8 <MAC_obtain_buffer+0x12c>
    4a98:	687a      	ldr	r2, [r7, #4]
    4a9a:	f642 7344 	movw	r3, #12100	; 0x2f44
    4a9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4aa2:	5c9b      	ldrb	r3, [r3, r2]
    4aa4:	2b01      	cmp	r3, #1
    4aa6:	d107      	bne.n	4ab8 <MAC_obtain_buffer+0x12c>
				{
					ucMACBufferInUse[ lIndex ] = pdFALSE;
    4aa8:	687a      	ldr	r2, [r7, #4]
    4aaa:	f642 7344 	movw	r3, #12100	; 0x2f44
    4aae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4ab2:	f04f 0100 	mov.w	r1, #0
    4ab6:	5499      	strb	r1, [r3, r2]
		if( pcReturn == NULL )
		{
			/* Did not find a buffer.  That should not really happen, but could if
			an interrupt was missed.  See if any buffers are marked as in use, but
			are not actually in use. */
			for( lIndex = 0; lIndex < macNUM_BUFFERS; lIndex++ )
    4ab8:	687b      	ldr	r3, [r7, #4]
    4aba:	f103 0301 	add.w	r3, r3, #1
    4abe:	607b      	str	r3, [r7, #4]
    4ac0:	687b      	ldr	r3, [r7, #4]
    4ac2:	2b06      	cmp	r3, #6
    4ac4:	dd9a      	ble.n	49fc <MAC_obtain_buffer+0x70>
			}
		}
																	
		/* If any buffer states were changed it might be that a buffer can now
		be obtained.  Try again, but only one more time. */
		lAttempt++;
    4ac6:	68bb      	ldr	r3, [r7, #8]
    4ac8:	f103 0301 	add.w	r3, r3, #1
    4acc:	60bb      	str	r3, [r7, #8]
unsigned char *pcReturn = NULL;
unsigned char *pcBufferAddress;

	/* Find and return the address of a buffer that is not being used.  Mark
	the buffer as now in use. */
	while( ( lAttempt <= 1 ) && ( pcReturn == NULL ) )
    4ace:	68bb      	ldr	r3, [r7, #8]
    4ad0:	2b01      	cmp	r3, #1
    4ad2:	dc03      	bgt.n	4adc <MAC_obtain_buffer+0x150>
    4ad4:	697b      	ldr	r3, [r7, #20]
    4ad6:	2b00      	cmp	r3, #0
    4ad8:	f43f af62 	beq.w	49a0 <MAC_obtain_buffer+0x14>
		/* If any buffer states were changed it might be that a buffer can now
		be obtained.  Try again, but only one more time. */
		lAttempt++;
	}
	
	configASSERT( pcReturn );
    4adc:	697b      	ldr	r3, [r7, #20]
    4ade:	2b00      	cmp	r3, #0
    4ae0:	d109      	bne.n	4af6 <MAC_obtain_buffer+0x16a>
    4ae2:	f04f 0328 	mov.w	r3, #40	; 0x28
    4ae6:	f383 8811 	msr	BASEPRI, r3
    4aea:	f3bf 8f6f 	isb	sy
    4aee:	f3bf 8f4f 	dsb	sy
    4af2:	61fb      	str	r3, [r7, #28]
    4af4:	e7fe      	b.n	4af4 <MAC_obtain_buffer+0x168>
	return pcReturn;
    4af6:	697b      	ldr	r3, [r7, #20]
}
    4af8:	4618      	mov	r0, r3
    4afa:	f107 0724 	add.w	r7, r7, #36	; 0x24
    4afe:	46bd      	mov	sp, r7
    4b00:	bc80      	pop	{r7}
    4b02:	4770      	bx	lr

00004b04 <MAC_release_buffer>:
/***************************************************************************//**
 * Return a buffer to the list of free buffers, it was in use, but is not now.
 *
 */
void MAC_release_buffer( unsigned char *pucBufferToRelease )
{
    4b04:	b480      	push	{r7}
    4b06:	b085      	sub	sp, #20
    4b08:	af00      	add	r7, sp, #0
    4b0a:	6078      	str	r0, [r7, #4]
long lIndex;

	/* uip_buf is going to point to a different buffer - first ensure the buffer
	it is currently pointing to is marked as being free again. */
	for( lIndex = 0; lIndex < macNUM_BUFFERS; lIndex++ )
    4b0c:	f04f 0300 	mov.w	r3, #0
    4b10:	60bb      	str	r3, [r7, #8]
    4b12:	e019      	b.n	4b48 <MAC_release_buffer+0x44>
	{
		if( pucBufferToRelease == &( xMACBuffers.ucBuffer[ lIndex ][ 0 ] ) )
    4b14:	f240 6394 	movw	r3, #1684	; 0x694
    4b18:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4b1c:	68ba      	ldr	r2, [r7, #8]
    4b1e:	f44f 61ba 	mov.w	r1, #1488	; 0x5d0
    4b22:	fb01 f202 	mul.w	r2, r1, r2
    4b26:	441a      	add	r2, r3
    4b28:	687b      	ldr	r3, [r7, #4]
    4b2a:	429a      	cmp	r2, r3
    4b2c:	d108      	bne.n	4b40 <MAC_release_buffer+0x3c>
		{
			/* This is the buffer in use, mark it as being free. */
			ucMACBufferInUse[ lIndex ] = pdFALSE;
    4b2e:	68ba      	ldr	r2, [r7, #8]
    4b30:	f642 7344 	movw	r3, #12100	; 0x2f44
    4b34:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4b38:	f04f 0100 	mov.w	r1, #0
    4b3c:	5499      	strb	r1, [r3, r2]
			break;
    4b3e:	e006      	b.n	4b4e <MAC_release_buffer+0x4a>
{
long lIndex;

	/* uip_buf is going to point to a different buffer - first ensure the buffer
	it is currently pointing to is marked as being free again. */
	for( lIndex = 0; lIndex < macNUM_BUFFERS; lIndex++ )
    4b40:	68bb      	ldr	r3, [r7, #8]
    4b42:	f103 0301 	add.w	r3, r3, #1
    4b46:	60bb      	str	r3, [r7, #8]
    4b48:	68bb      	ldr	r3, [r7, #8]
    4b4a:	2b06      	cmp	r3, #6
    4b4c:	dde2      	ble.n	4b14 <MAC_release_buffer+0x10>
			ucMACBufferInUse[ lIndex ] = pdFALSE;
			break;
		}
	}
	
	configASSERT( lIndex < macNUM_BUFFERS );
    4b4e:	68bb      	ldr	r3, [r7, #8]
    4b50:	2b06      	cmp	r3, #6
    4b52:	dd09      	ble.n	4b68 <MAC_release_buffer+0x64>
    4b54:	f04f 0328 	mov.w	r3, #40	; 0x28
    4b58:	f383 8811 	msr	BASEPRI, r3
    4b5c:	f3bf 8f6f 	isb	sy
    4b60:	f3bf 8f4f 	dsb	sy
    4b64:	60fb      	str	r3, [r7, #12]
    4b66:	e7fe      	b.n	4b66 <MAC_release_buffer+0x62>
}
    4b68:	f107 0714 	add.w	r7, r7, #20
    4b6c:	46bd      	mov	sp, r7
    4b6e:	bc80      	pop	{r7}
    4b70:	4770      	bx	lr
    4b72:	bf00      	nop

00004b74 <MDIO_management_clock>:
static void
MDIO_management_clock
(
    int32_t clock
)
{
    4b74:	b480      	push	{r7}
    4b76:	b085      	sub	sp, #20
    4b78:	af00      	add	r7, sp, #0
    4b7a:	6078      	str	r0, [r7, #4]
	int32_t volatile a;
    
    MAC_BITBAND->CSR9_MDC = (uint32_t)clock;
    4b7c:	f240 0300 	movw	r3, #0
    4b80:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4b84:	687a      	ldr	r2, [r7, #4]
    4b86:	f8c3 2940 	str.w	r2, [r3, #2368]	; 0x940
    
	/* delay for 1us */
	for( a = 0; a < ONEMICROSECOND; a++ ){}
    4b8a:	f04f 0300 	mov.w	r3, #0
    4b8e:	60fb      	str	r3, [r7, #12]
    4b90:	e003      	b.n	4b9a <MDIO_management_clock+0x26>
    4b92:	68fb      	ldr	r3, [r7, #12]
    4b94:	f103 0301 	add.w	r3, r3, #1
    4b98:	60fb      	str	r3, [r7, #12]
    4b9a:	68fb      	ldr	r3, [r7, #12]
    4b9c:	2b13      	cmp	r3, #19
    4b9e:	d9f8      	bls.n	4b92 <MDIO_management_clock+0x1e>
}
    4ba0:	f107 0714 	add.w	r7, r7, #20
    4ba4:	46bd      	mov	sp, r7
    4ba6:	bc80      	pop	{r7}
    4ba8:	4770      	bx	lr
    4baa:	bf00      	nop

00004bac <MDIO_send_cmd>:
MDIO_send_cmd
(
    uint8_t regad,
    mdio_cmd_t mdio_cmd
)
{
    4bac:	b580      	push	{r7, lr}
    4bae:	b084      	sub	sp, #16
    4bb0:	af00      	add	r7, sp, #0
    4bb2:	4602      	mov	r2, r0
    4bb4:	460b      	mov	r3, r1
    4bb6:	71fa      	strb	r2, [r7, #7]
    4bb8:	71bb      	strb	r3, [r7, #6]
    int32_t i;
    uint16_t mask, data;

    /* enable MII output */
    MAC_BITBAND->CSR9_MDEN = 1;
    4bba:	f240 0300 	movw	r3, #0
    4bbe:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4bc2:	f04f 0201 	mov.w	r2, #1
    4bc6:	f8c3 2948 	str.w	r2, [r3, #2376]	; 0x948

    /* send 32 1's preamble */
    MAC_BITBAND->CSR9_MDO = 1;
    4bca:	f240 0300 	movw	r3, #0
    4bce:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4bd2:	f04f 0201 	mov.w	r2, #1
    4bd6:	f8c3 2944 	str.w	r2, [r3, #2372]	; 0x944
    for (i = 0; i < PREAMBLECOUNT; i++) {
    4bda:	f04f 0300 	mov.w	r3, #0
    4bde:	60bb      	str	r3, [r7, #8]
    4be0:	e00b      	b.n	4bfa <MDIO_send_cmd+0x4e>
    	MDIO_management_clock( 0 );
    4be2:	f04f 0000 	mov.w	r0, #0
    4be6:	f7ff ffc5 	bl	4b74 <MDIO_management_clock>
    	MDIO_management_clock( 1 );
    4bea:	f04f 0001 	mov.w	r0, #1
    4bee:	f7ff ffc1 	bl	4b74 <MDIO_management_clock>
    /* enable MII output */
    MAC_BITBAND->CSR9_MDEN = 1;

    /* send 32 1's preamble */
    MAC_BITBAND->CSR9_MDO = 1;
    for (i = 0; i < PREAMBLECOUNT; i++) {
    4bf2:	68bb      	ldr	r3, [r7, #8]
    4bf4:	f103 0301 	add.w	r3, r3, #1
    4bf8:	60bb      	str	r3, [r7, #8]
    4bfa:	68bb      	ldr	r3, [r7, #8]
    4bfc:	2b1f      	cmp	r3, #31
    4bfe:	d9f0      	bls.n	4be2 <MDIO_send_cmd+0x36>
    	MDIO_management_clock( 0 );
    	MDIO_management_clock( 1 );
    }

    /* calculate data bits */
    data = MDIO_START |
    4c00:	79bb      	ldrb	r3, [r7, #6]
    4c02:	2b00      	cmp	r3, #0
    4c04:	d102      	bne.n	4c0c <MDIO_send_cmd+0x60>
    4c06:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    4c0a:	e001      	b.n	4c10 <MDIO_send_cmd+0x64>
    4c0c:	f245 0202 	movw	r2, #20482	; 0x5002
    4c10:	f64a 1394 	movw	r3, #43412	; 0xa994
    4c14:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4c18:	f893 30e8 	ldrb.w	r3, [r3, #232]	; 0xe8
    4c1c:	ea4f 13c3 	mov.w	r3, r3, lsl #7
    4c20:	b29b      	uxth	r3, r3
    4c22:	f403 6378 	and.w	r3, r3, #3968	; 0xf80
    4c26:	ea42 0303 	orr.w	r3, r2, r3
    4c2a:	b29a      	uxth	r2, r3
    4c2c:	79fb      	ldrb	r3, [r7, #7]
    4c2e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    4c32:	b29b      	uxth	r3, r3
    4c34:	f003 037c 	and.w	r3, r3, #124	; 0x7c
    4c38:	ea42 0303 	orr.w	r3, r2, r3
    4c3c:	81fb      	strh	r3, [r7, #14]
    	(( mdio_cmd == MDIO_CMD_READ ) ? MDIO_READ : MDIO_WRITE ) |
    	((g_mss_mac.phy_address << MDIO_ADDR_OFFSET) & MDIO_ADDR_MASK) |
    	((regad << MDIO_REG_ADDR_OFFSET) & MDIO_REG_ADDR_MASK);

    /* sent out */
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    4c3e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    4c42:	81bb      	strh	r3, [r7, #12]
    4c44:	e02b      	b.n	4c9e <MDIO_send_cmd+0xf2>
    {
        if ((mask == 0x2) && (mdio_cmd == MDIO_CMD_READ)) {
    4c46:	89bb      	ldrh	r3, [r7, #12]
    4c48:	2b02      	cmp	r3, #2
    4c4a:	d10a      	bne.n	4c62 <MDIO_send_cmd+0xb6>
    4c4c:	79bb      	ldrb	r3, [r7, #6]
    4c4e:	2b00      	cmp	r3, #0
    4c50:	d107      	bne.n	4c62 <MDIO_send_cmd+0xb6>
    		/* enable MII input */
            MAC_BITBAND->CSR9_MDEN = 0;
    4c52:	f240 0300 	movw	r3, #0
    4c56:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4c5a:	f04f 0200 	mov.w	r2, #0
    4c5e:	f8c3 2948 	str.w	r2, [r3, #2376]	; 0x948
        }

    	MDIO_management_clock( 0 );
    4c62:	f04f 0000 	mov.w	r0, #0
    4c66:	f7ff ff85 	bl	4b74 <MDIO_management_clock>

        /* prepare MDO */
        MAC_BITBAND->CSR9_MDO = (uint32_t)((mask & data) != 0 ? 1UL : 0UL);
    4c6a:	f240 0300 	movw	r3, #0
    4c6e:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4c72:	89b9      	ldrh	r1, [r7, #12]
    4c74:	89fa      	ldrh	r2, [r7, #14]
    4c76:	ea01 0202 	and.w	r2, r1, r2
    4c7a:	b292      	uxth	r2, r2
    4c7c:	2a00      	cmp	r2, #0
    4c7e:	d002      	beq.n	4c86 <MDIO_send_cmd+0xda>
    4c80:	f04f 0201 	mov.w	r2, #1
    4c84:	e001      	b.n	4c8a <MDIO_send_cmd+0xde>
    4c86:	f04f 0200 	mov.w	r2, #0
    4c8a:	f8c3 2944 	str.w	r2, [r3, #2372]	; 0x944
        
    	MDIO_management_clock( 1 );
    4c8e:	f04f 0001 	mov.w	r0, #1
    4c92:	f7ff ff6f 	bl	4b74 <MDIO_management_clock>
    	(( mdio_cmd == MDIO_CMD_READ ) ? MDIO_READ : MDIO_WRITE ) |
    	((g_mss_mac.phy_address << MDIO_ADDR_OFFSET) & MDIO_ADDR_MASK) |
    	((regad << MDIO_REG_ADDR_OFFSET) & MDIO_REG_ADDR_MASK);

    /* sent out */
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    4c96:	89bb      	ldrh	r3, [r7, #12]
    4c98:	ea4f 0353 	mov.w	r3, r3, lsr #1
    4c9c:	81bb      	strh	r3, [r7, #12]
    4c9e:	89bb      	ldrh	r3, [r7, #12]
    4ca0:	2b00      	cmp	r3, #0
    4ca2:	d1d0      	bne.n	4c46 <MDIO_send_cmd+0x9a>
        /* prepare MDO */
        MAC_BITBAND->CSR9_MDO = (uint32_t)((mask & data) != 0 ? 1UL : 0UL);
        
    	MDIO_management_clock( 1 );
    }
}
    4ca4:	f107 0710 	add.w	r7, r7, #16
    4ca8:	46bd      	mov	sp, r7
    4caa:	bd80      	pop	{r7, pc}

00004cac <MDIO_read>:
static uint16_t
MDIO_read
(
    uint8_t regad
)
{
    4cac:	b580      	push	{r7, lr}
    4cae:	b084      	sub	sp, #16
    4cb0:	af00      	add	r7, sp, #0
    4cb2:	4603      	mov	r3, r0
    4cb4:	71fb      	strb	r3, [r7, #7]
    uint16_t mask;
    uint16_t data;

    MDIO_send_cmd( regad, MDIO_CMD_READ);
    4cb6:	79fb      	ldrb	r3, [r7, #7]
    4cb8:	4618      	mov	r0, r3
    4cba:	f04f 0100 	mov.w	r1, #0
    4cbe:	f7ff ff75 	bl	4bac <MDIO_send_cmd>

    /* read data */
    data = 0;
    4cc2:	f04f 0300 	mov.w	r3, #0
    4cc6:	81fb      	strh	r3, [r7, #14]
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    4cc8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    4ccc:	81bb      	strh	r3, [r7, #12]
    4cce:	e018      	b.n	4d02 <MDIO_read+0x56>
    {
    	MDIO_management_clock( 0 );
    4cd0:	f04f 0000 	mov.w	r0, #0
    4cd4:	f7ff ff4e 	bl	4b74 <MDIO_management_clock>

        /* read MDI */
        if(MAC_BITBAND-> CSR9_MDI != 0){
    4cd8:	f240 0300 	movw	r3, #0
    4cdc:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4ce0:	f8d3 394c 	ldr.w	r3, [r3, #2380]	; 0x94c
    4ce4:	2b00      	cmp	r3, #0
    4ce6:	d004      	beq.n	4cf2 <MDIO_read+0x46>
            data |= mask;
    4ce8:	89fa      	ldrh	r2, [r7, #14]
    4cea:	89bb      	ldrh	r3, [r7, #12]
    4cec:	ea42 0303 	orr.w	r3, r2, r3
    4cf0:	81fb      	strh	r3, [r7, #14]
        }

    	MDIO_management_clock( 1 );
    4cf2:	f04f 0001 	mov.w	r0, #1
    4cf6:	f7ff ff3d 	bl	4b74 <MDIO_management_clock>

    MDIO_send_cmd( regad, MDIO_CMD_READ);

    /* read data */
    data = 0;
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    4cfa:	89bb      	ldrh	r3, [r7, #12]
    4cfc:	ea4f 0353 	mov.w	r3, r3, lsr #1
    4d00:	81bb      	strh	r3, [r7, #12]
    4d02:	89bb      	ldrh	r3, [r7, #12]
    4d04:	2b00      	cmp	r3, #0
    4d06:	d1e3      	bne.n	4cd0 <MDIO_read+0x24>
        }

    	MDIO_management_clock( 1 );
    }

    MDIO_management_clock( 0 );
    4d08:	f04f 0000 	mov.w	r0, #0
    4d0c:	f7ff ff32 	bl	4b74 <MDIO_management_clock>

    return data;
    4d10:	89fb      	ldrh	r3, [r7, #14]
}
    4d12:	4618      	mov	r0, r3
    4d14:	f107 0710 	add.w	r7, r7, #16
    4d18:	46bd      	mov	sp, r7
    4d1a:	bd80      	pop	{r7, pc}

00004d1c <MDIO_write>:
MDIO_write
(
    uint8_t regad,
    uint16_t data
)
{
    4d1c:	b580      	push	{r7, lr}
    4d1e:	b084      	sub	sp, #16
    4d20:	af00      	add	r7, sp, #0
    4d22:	4602      	mov	r2, r0
    4d24:	460b      	mov	r3, r1
    4d26:	71fa      	strb	r2, [r7, #7]
    4d28:	80bb      	strh	r3, [r7, #4]
    uint16_t mask;

    MDIO_send_cmd(regad, MDIO_CMD_WRITE);
    4d2a:	79fb      	ldrb	r3, [r7, #7]
    4d2c:	4618      	mov	r0, r3
    4d2e:	f04f 0101 	mov.w	r1, #1
    4d32:	f7ff ff3b 	bl	4bac <MDIO_send_cmd>

    /* write data */
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    4d36:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    4d3a:	81fb      	strh	r3, [r7, #14]
    4d3c:	e01d      	b.n	4d7a <MDIO_write+0x5e>
    {
    	MDIO_management_clock( 0 );
    4d3e:	f04f 0000 	mov.w	r0, #0
    4d42:	f7ff ff17 	bl	4b74 <MDIO_management_clock>

        /* prepare MDO */
    	MAC_BITBAND->CSR9_MDO = (uint32_t)((mask & data) != 0 ? 1UL : 0UL);
    4d46:	f240 0300 	movw	r3, #0
    4d4a:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4d4e:	89f9      	ldrh	r1, [r7, #14]
    4d50:	88ba      	ldrh	r2, [r7, #4]
    4d52:	ea01 0202 	and.w	r2, r1, r2
    4d56:	b292      	uxth	r2, r2
    4d58:	2a00      	cmp	r2, #0
    4d5a:	d002      	beq.n	4d62 <MDIO_write+0x46>
    4d5c:	f04f 0201 	mov.w	r2, #1
    4d60:	e001      	b.n	4d66 <MDIO_write+0x4a>
    4d62:	f04f 0200 	mov.w	r2, #0
    4d66:	f8c3 2944 	str.w	r2, [r3, #2372]	; 0x944

    	MDIO_management_clock( 1 );
    4d6a:	f04f 0001 	mov.w	r0, #1
    4d6e:	f7ff ff01 	bl	4b74 <MDIO_management_clock>
    uint16_t mask;

    MDIO_send_cmd(regad, MDIO_CMD_WRITE);

    /* write data */
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    4d72:	89fb      	ldrh	r3, [r7, #14]
    4d74:	ea4f 0353 	mov.w	r3, r3, lsr #1
    4d78:	81fb      	strh	r3, [r7, #14]
    4d7a:	89fb      	ldrh	r3, [r7, #14]
    4d7c:	2b00      	cmp	r3, #0
    4d7e:	d1de      	bne.n	4d3e <MDIO_write+0x22>
    	MAC_BITBAND->CSR9_MDO = (uint32_t)((mask & data) != 0 ? 1UL : 0UL);

    	MDIO_management_clock( 1 );
    }

    MDIO_management_clock( 0 );
    4d80:	f04f 0000 	mov.w	r0, #0
    4d84:	f7ff fef6 	bl	4b74 <MDIO_management_clock>
}
    4d88:	f107 0710 	add.w	r7, r7, #16
    4d8c:	46bd      	mov	sp, r7
    4d8e:	bd80      	pop	{r7, pc}

00004d90 <PHY_probe>:
 * Probe used PHY.
 *
 * return	PHY address. If PHY don't fount, returns 255.
 */
uint8_t PHY_probe( void )
{
    4d90:	b580      	push	{r7, lr}
    4d92:	b082      	sub	sp, #8
    4d94:	af00      	add	r7, sp, #0
	uint8_t phy;
	uint8_t phy_found;
	uint16_t reg;

	phy_found = 0;
    4d96:	f04f 0300 	mov.w	r3, #0
    4d9a:	717b      	strb	r3, [r7, #5]
	for (phy = MSS_PHY_ADDRESS_MIN; phy <= MSS_PHY_ADDRESS_MAX; phy++) {
    4d9c:	f04f 0300 	mov.w	r3, #0
    4da0:	713b      	strb	r3, [r7, #4]
    4da2:	e01e      	b.n	4de2 <PHY_probe+0x52>
		g_mss_mac.phy_address = phy;
    4da4:	f64a 1394 	movw	r3, #43412	; 0xa994
    4da8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4dac:	793a      	ldrb	r2, [r7, #4]
    4dae:	f883 20e8 	strb.w	r2, [r3, #232]	; 0xe8

        reg = MDIO_read( PHYREG_PHYID1R );
    4db2:	f04f 0002 	mov.w	r0, #2
    4db6:	f7ff ff79 	bl	4cac <MDIO_read>
    4dba:	4603      	mov	r3, r0
    4dbc:	80fb      	strh	r3, [r7, #6]

        if ((reg != 0x0000ffffUL) && (reg != 0x00000000UL)) {
    4dbe:	88fa      	ldrh	r2, [r7, #6]
    4dc0:	f64f 73ff 	movw	r3, #65535	; 0xffff
    4dc4:	429a      	cmp	r2, r3
    4dc6:	d008      	beq.n	4dda <PHY_probe+0x4a>
    4dc8:	88fb      	ldrh	r3, [r7, #6]
    4dca:	2b00      	cmp	r3, #0
    4dcc:	d005      	beq.n	4dda <PHY_probe+0x4a>
        	phy_found = 1;
    4dce:	f04f 0301 	mov.w	r3, #1
    4dd2:	717b      	strb	r3, [r7, #5]
        	phy = MSS_PHY_ADDRESS_MAX + 1;
    4dd4:	f04f 0320 	mov.w	r3, #32
    4dd8:	713b      	strb	r3, [r7, #4]
	uint8_t phy;
	uint8_t phy_found;
	uint16_t reg;

	phy_found = 0;
	for (phy = MSS_PHY_ADDRESS_MIN; phy <= MSS_PHY_ADDRESS_MAX; phy++) {
    4dda:	793b      	ldrb	r3, [r7, #4]
    4ddc:	f103 0301 	add.w	r3, r3, #1
    4de0:	713b      	strb	r3, [r7, #4]
    4de2:	793b      	ldrb	r3, [r7, #4]
    4de4:	2b1f      	cmp	r3, #31
    4de6:	d9dd      	bls.n	4da4 <PHY_probe+0x14>
        	phy_found = 1;
        	phy = MSS_PHY_ADDRESS_MAX + 1;
        }
    }

    if( phy_found == 0 ) {
    4de8:	797b      	ldrb	r3, [r7, #5]
    4dea:	2b00      	cmp	r3, #0
    4dec:	d107      	bne.n	4dfe <PHY_probe+0x6e>
    	g_mss_mac.phy_address = MSS_PHY_ADDRESS_AUTO_DETECT;
    4dee:	f64a 1394 	movw	r3, #43412	; 0xa994
    4df2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4df6:	f04f 32ff 	mov.w	r2, #4294967295
    4dfa:	f883 20e8 	strb.w	r2, [r3, #232]	; 0xe8
    }
    return g_mss_mac.phy_address;
    4dfe:	f64a 1394 	movw	r3, #43412	; 0xa994
    4e02:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4e06:	f893 30e8 	ldrb.w	r3, [r3, #232]	; 0xe8
}
    4e0a:	4618      	mov	r0, r3
    4e0c:	f107 0708 	add.w	r7, r7, #8
    4e10:	46bd      	mov	sp, r7
    4e12:	bd80      	pop	{r7, pc}

00004e14 <PHY_reset>:

/***************************************************************************//**
 * Resets the PHY.
 */
void PHY_reset( void )
{
    4e14:	b580      	push	{r7, lr}
    4e16:	af00      	add	r7, sp, #0
	MDIO_write( PHYREG_MIIMCR, MIIMCR_RESET );
    4e18:	f04f 0000 	mov.w	r0, #0
    4e1c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    4e20:	f7ff ff7c 	bl	4d1c <MDIO_write>
	MDIO_write( PHYREG_MIIMCR,
    4e24:	f04f 0000 	mov.w	r0, #0
    4e28:	f44f 5194 	mov.w	r1, #4736	; 0x1280
    4e2c:	f7ff ff76 	bl	4d1c <MDIO_write>
		MIIMCR_ENABLE_AUTONEGOTIATION |
		MIIMCR_RESTART_AUTONEGOTIATION |
		MIIMCR_COLLISION_TEST );
}
    4e30:	bd80      	pop	{r7, pc}
    4e32:	bf00      	nop

00004e34 <PHY_auto_negotiate>:

/***************************************************************************//**
 * Restarts PHY auto-negotiation and wait until it's over.
 */
void PHY_auto_negotiate( void )
{
    4e34:	b580      	push	{r7, lr}
    4e36:	b082      	sub	sp, #8
    4e38:	af00      	add	r7, sp, #0
	uint16_t reg;

	reg = MDIO_read( PHYREG_MIIMCR );
    4e3a:	f04f 0000 	mov.w	r0, #0
    4e3e:	f7ff ff35 	bl	4cac <MDIO_read>
    4e42:	4603      	mov	r3, r0
    4e44:	80fb      	strh	r3, [r7, #6]
	MDIO_write( PHYREG_MIIMCR,
    4e46:	88fb      	ldrh	r3, [r7, #6]
    4e48:	f443 5390 	orr.w	r3, r3, #4608	; 0x1200
    4e4c:	b29b      	uxth	r3, r3
    4e4e:	f04f 0000 	mov.w	r0, #0
    4e52:	4619      	mov	r1, r3
    4e54:	f7ff ff62 	bl	4d1c <MDIO_write>
		(uint16_t)( MIIMCR_ENABLE_AUTONEGOTIATION |
		MIIMCR_RESTART_AUTONEGOTIATION |
		reg) );

	for( ;; ) {
		reg = MDIO_read( PHYREG_MIIMSR );
    4e58:	f04f 0001 	mov.w	r0, #1
    4e5c:	f7ff ff26 	bl	4cac <MDIO_read>
    4e60:	4603      	mov	r3, r0
    4e62:	80fb      	strh	r3, [r7, #6]
		if( (reg & MIIMSR_ANC) != 0 ) {
    4e64:	88fb      	ldrh	r3, [r7, #6]
    4e66:	f003 0320 	and.w	r3, r3, #32
    4e6a:	2b00      	cmp	r3, #0
    4e6c:	d104      	bne.n	4e78 <PHY_auto_negotiate+0x44>
			break;
		} else {
			vTaskDelay( 200 );
    4e6e:	f04f 00c8 	mov.w	r0, #200	; 0xc8
    4e72:	f009 f96b 	bl	e14c <vTaskDelay>
		}
	}
    4e76:	e7ef      	b.n	4e58 <PHY_auto_negotiate+0x24>
}
    4e78:	bf00      	nop
    4e7a:	f107 0708 	add.w	r7, r7, #8
    4e7e:	46bd      	mov	sp, r7
    4e80:	bd80      	pop	{r7, pc}
    4e82:	bf00      	nop

00004e84 <PHY_link_status>:
 * Returns link status.
 *
 * @return          #MAC_LINK_STATUS_LINK if link is up.
 */
uint8_t PHY_link_status( void )
{
    4e84:	b580      	push	{r7, lr}
    4e86:	b082      	sub	sp, #8
    4e88:	af00      	add	r7, sp, #0
	uint8_t retval = 0;
    4e8a:	f04f 0300 	mov.w	r3, #0
    4e8e:	71fb      	strb	r3, [r7, #7]
	if(( MDIO_read( PHYREG_MIIMSR ) & MIIMSR_LINK ) != 0 ){
    4e90:	f04f 0001 	mov.w	r0, #1
    4e94:	f7ff ff0a 	bl	4cac <MDIO_read>
    4e98:	4603      	mov	r3, r0
    4e9a:	f003 0304 	and.w	r3, r3, #4
    4e9e:	2b00      	cmp	r3, #0
    4ea0:	d002      	beq.n	4ea8 <PHY_link_status+0x24>
		retval = MSS_MAC_LINK_STATUS_LINK;
    4ea2:	f04f 0301 	mov.w	r3, #1
    4ea6:	71fb      	strb	r3, [r7, #7]
	}
	return retval;
    4ea8:	79fb      	ldrb	r3, [r7, #7]
}
    4eaa:	4618      	mov	r0, r3
    4eac:	f107 0708 	add.w	r7, r7, #8
    4eb0:	46bd      	mov	sp, r7
    4eb2:	bd80      	pop	{r7, pc}

00004eb4 <PHY_link_type>:
 * @return          the logical OR of the following values:
 *      #MAC_LINK_STATUS_100MB   - Connection is 100Mb
 *      #MAC_LINK_STATUS_FDX     - Connection is full duplex
 */
uint8_t PHY_link_type( void )
{
    4eb4:	b580      	push	{r7, lr}
    4eb6:	b082      	sub	sp, #8
    4eb8:	af00      	add	r7, sp, #0
	uint16_t diagnostic;
	uint8_t type = 0;
    4eba:	f04f 0300 	mov.w	r3, #0
    4ebe:	71fb      	strb	r3, [r7, #7]

	diagnostic = MDIO_read( PHYREG_DR );
    4ec0:	f04f 0012 	mov.w	r0, #18
    4ec4:	f7ff fef2 	bl	4cac <MDIO_read>
    4ec8:	4603      	mov	r3, r0
    4eca:	80bb      	strh	r3, [r7, #4]

    if( (diagnostic & DR_DPLX) != 0 ) {
    4ecc:	88bb      	ldrh	r3, [r7, #4]
    4ece:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    4ed2:	2b00      	cmp	r3, #0
    4ed4:	d002      	beq.n	4edc <PHY_link_type+0x28>
    	type = MSS_MAC_LINK_STATUS_FDX;
    4ed6:	f04f 0304 	mov.w	r3, #4
    4eda:	71fb      	strb	r3, [r7, #7]
    }

    if( (diagnostic & DR_DATA_RATE) != 0 ) {
    4edc:	88bb      	ldrh	r3, [r7, #4]
    4ede:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    4ee2:	2b00      	cmp	r3, #0
    4ee4:	d003      	beq.n	4eee <PHY_link_type+0x3a>
    	type |= MSS_MAC_LINK_STATUS_100MB;
    4ee6:	79fb      	ldrb	r3, [r7, #7]
    4ee8:	f043 0302 	orr.w	r3, r3, #2
    4eec:	71fb      	strb	r3, [r7, #7]
    }

    return type;
    4eee:	79fb      	ldrb	r3, [r7, #7]
}
    4ef0:	4618      	mov	r0, r3
    4ef2:	f107 0708 	add.w	r7, r7, #8
    4ef6:	46bd      	mov	sp, r7
    4ef8:	bd80      	pop	{r7, pc}
    4efa:	bf00      	nop

00004efc <PHY_set_link_type>:
void
PHY_set_link_type
(
    uint8_t type
)
{
    4efc:	b580      	push	{r7, lr}
    4efe:	b084      	sub	sp, #16
    4f00:	af00      	add	r7, sp, #0
    4f02:	4603      	mov	r3, r0
    4f04:	71fb      	strb	r3, [r7, #7]
	uint16_t reg;

	reg = MDIO_read( PHYREG_ANAR );
    4f06:	f04f 0004 	mov.w	r0, #4
    4f0a:	f7ff fecf 	bl	4cac <MDIO_read>
    4f0e:	4603      	mov	r3, r0
    4f10:	81fb      	strh	r3, [r7, #14]
	reg |= ANAR_100FD | ANAR_100HD | ANAR_10FD | ANAR_10HD;
    4f12:	89fb      	ldrh	r3, [r7, #14]
    4f14:	f443 73f0 	orr.w	r3, r3, #480	; 0x1e0
    4f18:	81fb      	strh	r3, [r7, #14]

	if( (type & MSS_MAC_LINK_STATUS_100MB) == 0 ) {
    4f1a:	79fb      	ldrb	r3, [r7, #7]
    4f1c:	f003 0302 	and.w	r3, r3, #2
    4f20:	2b00      	cmp	r3, #0
    4f22:	d103      	bne.n	4f2c <PHY_set_link_type+0x30>
		reg &= ~(ANAR_100FD | ANAR_100HD);
    4f24:	89fb      	ldrh	r3, [r7, #14]
    4f26:	f423 73c0 	bic.w	r3, r3, #384	; 0x180
    4f2a:	81fb      	strh	r3, [r7, #14]
	}

	if( (type & MSS_MAC_LINK_STATUS_FDX) == 0 ) {
    4f2c:	79fb      	ldrb	r3, [r7, #7]
    4f2e:	f003 0304 	and.w	r3, r3, #4
    4f32:	2b00      	cmp	r3, #0
    4f34:	d103      	bne.n	4f3e <PHY_set_link_type+0x42>
		reg &= ~(ANAR_100FD | ANAR_10FD);
    4f36:	89fb      	ldrh	r3, [r7, #14]
    4f38:	f423 73a0 	bic.w	r3, r3, #320	; 0x140
    4f3c:	81fb      	strh	r3, [r7, #14]
	}

	MDIO_write( PHYREG_ANAR, reg );
    4f3e:	89fb      	ldrh	r3, [r7, #14]
    4f40:	f04f 0004 	mov.w	r0, #4
    4f44:	4619      	mov	r1, r3
    4f46:	f7ff fee9 	bl	4d1c <MDIO_write>
}
    4f4a:	f107 0710 	add.w	r7, r7, #16
    4f4e:	46bd      	mov	sp, r7
    4f50:	bd80      	pop	{r7, pc}
    4f52:	bf00      	nop

00004f54 <PHY_set_loopback>:
uint16_t
PHY_set_loopback
(
   uint8_t enable
)
{
    4f54:	b580      	push	{r7, lr}
    4f56:	b084      	sub	sp, #16
    4f58:	af00      	add	r7, sp, #0
    4f5a:	4603      	mov	r3, r0
    4f5c:	71fb      	strb	r3, [r7, #7]

	uint16_t reg = 0;   
    4f5e:	f04f 0300 	mov.w	r3, #0
    4f62:	81fb      	strh	r3, [r7, #14]
	

	reg = MDIO_read( PHYREG_MIIMCR );
    4f64:	f04f 0000 	mov.w	r0, #0
    4f68:	f7ff fea0 	bl	4cac <MDIO_read>
    4f6c:	4603      	mov	r3, r0
    4f6e:	81fb      	strh	r3, [r7, #14]
	// If set to one we need to set the LOCAL Phy loopback
	if(enable == 1)
    4f70:	79fb      	ldrb	r3, [r7, #7]
    4f72:	2b01      	cmp	r3, #1
    4f74:	d104      	bne.n	4f80 <PHY_set_loopback+0x2c>
		reg |= MIIMCR_LOOPBACK;
    4f76:	89fb      	ldrh	r3, [r7, #14]
    4f78:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    4f7c:	81fb      	strh	r3, [r7, #14]
    4f7e:	e003      	b.n	4f88 <PHY_set_loopback+0x34>
	else // else we want to clear the bit..
		reg ^= MIIMCR_LOOPBACK;
    4f80:	89fb      	ldrh	r3, [r7, #14]
    4f82:	f483 4380 	eor.w	r3, r3, #16384	; 0x4000
    4f86:	81fb      	strh	r3, [r7, #14]
	
	
	MDIO_write( PHYREG_MIIMCR,reg );
    4f88:	89fb      	ldrh	r3, [r7, #14]
    4f8a:	f04f 0000 	mov.w	r0, #0
    4f8e:	4619      	mov	r1, r3
    4f90:	f7ff fec4 	bl	4d1c <MDIO_write>
	reg = MDIO_read( PHYREG_MIIMCR );
    4f94:	f04f 0000 	mov.w	r0, #0
    4f98:	f7ff fe88 	bl	4cac <MDIO_read>
    4f9c:	4603      	mov	r3, r0
    4f9e:	81fb      	strh	r3, [r7, #14]
	
	return reg;
    4fa0:	89fb      	ldrh	r3, [r7, #14]
	
}
    4fa2:	4618      	mov	r0, r3
    4fa4:	f107 0710 	add.w	r7, r7, #16
    4fa8:	46bd      	mov	sp, r7
    4faa:	bd80      	pop	{r7, pc}

00004fac <ACE_get_channel_type>:
channel_type_t
ACE_get_channel_type
(
    ace_channel_handle_t    channel_handle
)
{
    4fac:	b480      	push	{r7}
    4fae:	b085      	sub	sp, #20
    4fb0:	af00      	add	r7, sp, #0
    4fb2:	4603      	mov	r3, r0
    4fb4:	71fb      	strb	r3, [r7, #7]
    channel_type_t channel_type = VOLTAGE;
    4fb6:	f04f 0300 	mov.w	r3, #0
    4fba:	73fb      	strb	r3, [r7, #15]
    
    ASSERT(channel_handle < ACE_NB_OF_INPUT_CHANNELS);
    4fbc:	79fb      	ldrb	r3, [r7, #7]
    4fbe:	2b02      	cmp	r3, #2
    4fc0:	d900      	bls.n	4fc4 <ACE_get_channel_type+0x18>
    4fc2:	be00      	bkpt	0x0000
    
    if((int32_t)channel_handle < ACE_NB_OF_INPUT_CHANNELS)
    4fc4:	79fb      	ldrb	r3, [r7, #7]
    4fc6:	2b02      	cmp	r3, #2
    4fc8:	d807      	bhi.n	4fda <ACE_get_channel_type+0x2e>
    {
        channel_type = channel_type_lut_h[channel_handle];
    4fca:	79fa      	ldrb	r2, [r7, #7]
    4fcc:	f642 7358 	movw	r3, #12120	; 0x2f58
    4fd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4fd4:	5c9b      	ldrb	r3, [r3, r2]
    4fd6:	73fb      	strb	r3, [r7, #15]
    4fd8:	e002      	b.n	4fe0 <ACE_get_channel_type+0x34>
    }
    else
    {
        channel_type = VOLTAGE;
    4fda:	f04f 0300 	mov.w	r3, #0
    4fde:	73fb      	strb	r3, [r7, #15]
    }
    
    return channel_type;
    4fe0:	7bfb      	ldrb	r3, [r7, #15]
}
    4fe2:	4618      	mov	r0, r3
    4fe4:	f107 0714 	add.w	r7, r7, #20
    4fe8:	46bd      	mov	sp, r7
    4fea:	bc80      	pop	{r7}
    4fec:	4770      	bx	lr
    4fee:	bf00      	nop

00004ff0 <ACE_convert_adc_input_to_mV>:
uint32_t ACE_convert_adc_input_to_mV
(
    ace_channel_handle_t    channel_handle,
    uint16_t                sample_value
)
{
    4ff0:	b480      	push	{r7}
    4ff2:	b085      	sub	sp, #20
    4ff4:	af00      	add	r7, sp, #0
    4ff6:	4602      	mov	r2, r0
    4ff8:	460b      	mov	r3, r1
    4ffa:	71fa      	strb	r2, [r7, #7]
    4ffc:	80bb      	strh	r3, [r7, #4]
    uint32_t voltage;
    adc_channel_id_t channel_id;
    uint8_t adc_id;
    
    channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    4ffe:	79fa      	ldrb	r2, [r7, #7]
    5000:	f240 0354 	movw	r3, #84	; 0x54
    5004:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5008:	ea4f 1202 	mov.w	r2, r2, lsl #4
    500c:	4413      	add	r3, r2
    500e:	791b      	ldrb	r3, [r3, #4]
    5010:	73bb      	strb	r3, [r7, #14]
    adc_id = (uint8_t)channel_id >> 4u;
    5012:	7bbb      	ldrb	r3, [r7, #14]
    5014:	ea4f 1313 	mov.w	r3, r3, lsr #4
    5018:	73fb      	strb	r3, [r7, #15]
    voltage = ( g_ace_adc_config[adc_id].va_ref * (uint32_t)sample_value ) / g_ace_adc_config[adc_id].adc_resolution;
    501a:	7bfb      	ldrb	r3, [r7, #15]
    501c:	f240 0248 	movw	r2, #72	; 0x48
    5020:	f2c2 0200 	movt	r2, #8192	; 0x2000
    5024:	ea4f 0383 	mov.w	r3, r3, lsl #2
    5028:	4413      	add	r3, r2
    502a:	885b      	ldrh	r3, [r3, #2]
    502c:	88ba      	ldrh	r2, [r7, #4]
    502e:	fb02 f203 	mul.w	r2, r2, r3
    5032:	7bf9      	ldrb	r1, [r7, #15]
    5034:	f240 0348 	movw	r3, #72	; 0x48
    5038:	f2c2 0300 	movt	r3, #8192	; 0x2000
    503c:	f833 3021 	ldrh.w	r3, [r3, r1, lsl #2]
    5040:	fbb2 f3f3 	udiv	r3, r2, r3
    5044:	60bb      	str	r3, [r7, #8]
    
    return voltage;
    5046:	68bb      	ldr	r3, [r7, #8]
}
    5048:	4618      	mov	r0, r3
    504a:	f107 0714 	add.w	r7, r7, #20
    504e:	46bd      	mov	sp, r7
    5050:	bc80      	pop	{r7}
    5052:	4770      	bx	lr

00005054 <ace_init_convert>:

/*-------------------------------------------------------------------------*//**
 *
 */
void ace_init_convert(void)
{
    5054:	b480      	push	{r7}
    5056:	b087      	sub	sp, #28
    5058:	af00      	add	r7, sp, #0
    uint8_t abps_idx;
    int32_t channel;
    uint32_t saved_pc2_ctrl;
    
    /* Pause the SSE PC2 while accesses to ACB from APB3 are taking place. */
    saved_pc2_ctrl = ACE->PC2_CTRL;
    505a:	f240 0300 	movw	r3, #0
    505e:	f2c4 0302 	movt	r3, #16386	; 0x4002
    5062:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
    5066:	60bb      	str	r3, [r7, #8]
    ACE->PC2_CTRL = 0u;
    5068:	f240 0300 	movw	r3, #0
    506c:	f2c4 0302 	movt	r3, #16386	; 0x4002
    5070:	f04f 0200 	mov.w	r2, #0
    5074:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    
    /* Populate the g_gdec_lut look-up table. */
    for(abps_idx = 0u; abps_idx < MAX_NB_OF_APBS; ++abps_idx)
    5078:	f04f 0300 	mov.w	r3, #0
    507c:	70fb      	strb	r3, [r7, #3]
    507e:	e039      	b.n	50f4 <ace_init_convert+0xa0>
    {
        uint8_t quad_id;
        uint8_t acb_config_byte;
        uint32_t channel_is_abps2;
        
        quad_id = abps_idx / 2u;
    5080:	78fb      	ldrb	r3, [r7, #3]
    5082:	ea4f 0353 	mov.w	r3, r3, lsr #1
    5086:	73bb      	strb	r3, [r7, #14]
        acb_config_byte = ACE->ACB_DATA[quad_id].b8;
    5088:	f240 0200 	movw	r2, #0
    508c:	f2c4 0202 	movt	r2, #16386	; 0x4002
    5090:	7bb9      	ldrb	r1, [r7, #14]
    5092:	460b      	mov	r3, r1
    5094:	ea4f 0343 	mov.w	r3, r3, lsl #1
    5098:	440b      	add	r3, r1
    509a:	ea4f 1303 	mov.w	r3, r3, lsl #4
    509e:	4413      	add	r3, r2
    50a0:	f503 7308 	add.w	r3, r3, #544	; 0x220
    50a4:	791b      	ldrb	r3, [r3, #4]
    50a6:	73fb      	strb	r3, [r7, #15]
        channel_is_abps2 = abps_idx & 0x01uL;
    50a8:	78fb      	ldrb	r3, [r7, #3]
    50aa:	f003 0301 	and.w	r3, r3, #1
    50ae:	613b      	str	r3, [r7, #16]
        if(channel_is_abps2)
    50b0:	693b      	ldr	r3, [r7, #16]
    50b2:	2b00      	cmp	r3, #0
    50b4:	d00d      	beq.n	50d2 <ace_init_convert+0x7e>
        {
            /* ABPS2 */
            g_gdec_lut[abps_idx] = (acb_config_byte >> 5u) & 0x03u;
    50b6:	78f9      	ldrb	r1, [r7, #3]
    50b8:	7bfb      	ldrb	r3, [r7, #15]
    50ba:	ea4f 1353 	mov.w	r3, r3, lsr #5
    50be:	b2db      	uxtb	r3, r3
    50c0:	461a      	mov	r2, r3
    50c2:	f002 0203 	and.w	r2, r2, #3
    50c6:	f642 734c 	movw	r3, #12108	; 0x2f4c
    50ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    50ce:	545a      	strb	r2, [r3, r1]
    50d0:	e00c      	b.n	50ec <ace_init_convert+0x98>
        }
        else
        {
            /* ABPS1 */
            g_gdec_lut[abps_idx] = (acb_config_byte >> 1u) & 0x03u;
    50d2:	78f9      	ldrb	r1, [r7, #3]
    50d4:	7bfb      	ldrb	r3, [r7, #15]
    50d6:	ea4f 0353 	mov.w	r3, r3, lsr #1
    50da:	b2db      	uxtb	r3, r3
    50dc:	461a      	mov	r2, r3
    50de:	f002 0203 	and.w	r2, r2, #3
    50e2:	f642 734c 	movw	r3, #12108	; 0x2f4c
    50e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    50ea:	545a      	strb	r2, [r3, r1]
    /* Pause the SSE PC2 while accesses to ACB from APB3 are taking place. */
    saved_pc2_ctrl = ACE->PC2_CTRL;
    ACE->PC2_CTRL = 0u;
    
    /* Populate the g_gdec_lut look-up table. */
    for(abps_idx = 0u; abps_idx < MAX_NB_OF_APBS; ++abps_idx)
    50ec:	78fb      	ldrb	r3, [r7, #3]
    50ee:	f103 0301 	add.w	r3, r3, #1
    50f2:	70fb      	strb	r3, [r7, #3]
    50f4:	78fb      	ldrb	r3, [r7, #3]
    50f6:	2b0b      	cmp	r3, #11
    50f8:	d9c2      	bls.n	5080 <ace_init_convert+0x2c>
            g_gdec_lut[abps_idx] = (acb_config_byte >> 1u) & 0x03u;
        }
    }
    
    /* Populate the channel_type_lut_h look-up table. */
    for(channel = 0; channel < ACE_NB_OF_INPUT_CHANNELS; ++channel)
    50fa:	f04f 0300 	mov.w	r3, #0
    50fe:	607b      	str	r3, [r7, #4]
    5100:	e073      	b.n	51ea <ace_init_convert+0x196>
        uint8_t quad_id;
        uint8_t acb_config_byte;
        adc_channel_id_t channel_id;
        channel_type_t channel_type;
    
        channel_id = g_ace_channel_desc_table[channel].signal_id;
    5102:	687a      	ldr	r2, [r7, #4]
    5104:	f240 0354 	movw	r3, #84	; 0x54
    5108:	f2c2 0300 	movt	r3, #8192	; 0x2000
    510c:	ea4f 1202 	mov.w	r2, r2, lsl #4
    5110:	4413      	add	r3, r2
    5112:	791b      	ldrb	r3, [r3, #4]
    5114:	75bb      	strb	r3, [r7, #22]
        quad_id = channel_quad_lut[channel_id];
    5116:	7dba      	ldrb	r2, [r7, #22]
    5118:	f643 2314 	movw	r3, #14868	; 0x3a14
    511c:	f2c0 0301 	movt	r3, #1
    5120:	5c9b      	ldrb	r3, [r3, r2]
    5122:	753b      	strb	r3, [r7, #20]
        
        switch (channel_type_lut[channel_id])
    5124:	7dba      	ldrb	r2, [r7, #22]
    5126:	f643 13e4 	movw	r3, #14820	; 0x39e4
    512a:	f2c0 0301 	movt	r3, #1
    512e:	5c9b      	ldrb	r3, [r3, r2]
    5130:	2b01      	cmp	r3, #1
    5132:	d007      	beq.n	5144 <ace_init_convert+0xf0>
    5134:	2b02      	cmp	r3, #2
    5136:	d027      	beq.n	5188 <ace_init_convert+0x134>
    5138:	2b00      	cmp	r3, #0
    513a:	d147      	bne.n	51cc <ace_init_convert+0x178>
        {
            case VOLTAGE_CHANNEL:
                channel_type = VOLTAGE;
    513c:	f04f 0300 	mov.w	r3, #0
    5140:	75fb      	strb	r3, [r7, #23]
                break;
    5142:	e047      	b.n	51d4 <ace_init_convert+0x180>
                
            case CURRENT_CHANNEL:
                ASSERT( quad_id != 0xFFu );
    5144:	7d3b      	ldrb	r3, [r7, #20]
    5146:	2bff      	cmp	r3, #255	; 0xff
    5148:	d100      	bne.n	514c <ace_init_convert+0xf8>
    514a:	be00      	bkpt	0x0000
                acb_config_byte = ACE->ACB_DATA[quad_id].b9;
    514c:	f240 0200 	movw	r2, #0
    5150:	f2c4 0202 	movt	r2, #16386	; 0x4002
    5154:	7d39      	ldrb	r1, [r7, #20]
    5156:	460b      	mov	r3, r1
    5158:	ea4f 0343 	mov.w	r3, r3, lsl #1
    515c:	440b      	add	r3, r1
    515e:	ea4f 1303 	mov.w	r3, r3, lsl #4
    5162:	4413      	add	r3, r2
    5164:	f503 7308 	add.w	r3, r3, #544	; 0x220
    5168:	7a1b      	ldrb	r3, [r3, #8]
    516a:	757b      	strb	r3, [r7, #21]
                if ( acb_config_byte & 0x01u )
    516c:	7d7b      	ldrb	r3, [r7, #21]
    516e:	f003 0301 	and.w	r3, r3, #1
    5172:	b2db      	uxtb	r3, r3
    5174:	2b00      	cmp	r3, #0
    5176:	d003      	beq.n	5180 <ace_init_convert+0x12c>
                {
                    channel_type = VOLTAGE;
    5178:	f04f 0300 	mov.w	r3, #0
    517c:	75fb      	strb	r3, [r7, #23]
                }
                else
                {
                    channel_type = CURRENT;
                }
                break;
    517e:	e029      	b.n	51d4 <ace_init_convert+0x180>
                {
                    channel_type = VOLTAGE;
                }
                else
                {
                    channel_type = CURRENT;
    5180:	f04f 0301 	mov.w	r3, #1
    5184:	75fb      	strb	r3, [r7, #23]
                }
                break;
    5186:	e025      	b.n	51d4 <ace_init_convert+0x180>
            
            case TEMPERATURE_CHANNEL:
                ASSERT( quad_id != 0xFFu );
    5188:	7d3b      	ldrb	r3, [r7, #20]
    518a:	2bff      	cmp	r3, #255	; 0xff
    518c:	d100      	bne.n	5190 <ace_init_convert+0x13c>
    518e:	be00      	bkpt	0x0000
                acb_config_byte = ACE->ACB_DATA[quad_id].b10;
    5190:	f240 0200 	movw	r2, #0
    5194:	f2c4 0202 	movt	r2, #16386	; 0x4002
    5198:	7d39      	ldrb	r1, [r7, #20]
    519a:	460b      	mov	r3, r1
    519c:	ea4f 0343 	mov.w	r3, r3, lsl #1
    51a0:	440b      	add	r3, r1
    51a2:	ea4f 1303 	mov.w	r3, r3, lsl #4
    51a6:	4413      	add	r3, r2
    51a8:	f503 730a 	add.w	r3, r3, #552	; 0x228
    51ac:	791b      	ldrb	r3, [r3, #4]
    51ae:	757b      	strb	r3, [r7, #21]
                if ( acb_config_byte & 0x01u )
    51b0:	7d7b      	ldrb	r3, [r7, #21]
    51b2:	f003 0301 	and.w	r3, r3, #1
    51b6:	b2db      	uxtb	r3, r3
    51b8:	2b00      	cmp	r3, #0
    51ba:	d003      	beq.n	51c4 <ace_init_convert+0x170>
                {
                    channel_type = VOLTAGE;
    51bc:	f04f 0300 	mov.w	r3, #0
    51c0:	75fb      	strb	r3, [r7, #23]
                }
                else
                {
                    channel_type = TEMPERATURE;
                }
                break;
    51c2:	e007      	b.n	51d4 <ace_init_convert+0x180>
                {
                    channel_type = VOLTAGE;
                }
                else
                {
                    channel_type = TEMPERATURE;
    51c4:	f04f 0302 	mov.w	r3, #2
    51c8:	75fb      	strb	r3, [r7, #23]
                }
                break;
    51ca:	e003      	b.n	51d4 <ace_init_convert+0x180>
                
            default:
                ASSERT(0);
    51cc:	be00      	bkpt	0x0000
                channel_type = VOLTAGE;
    51ce:	f04f 0300 	mov.w	r3, #0
    51d2:	75fb      	strb	r3, [r7, #23]
                break;
        }
        
        channel_type_lut_h[channel] = channel_type;
    51d4:	687a      	ldr	r2, [r7, #4]
    51d6:	f642 7358 	movw	r3, #12120	; 0x2f58
    51da:	f2c2 0300 	movt	r3, #8192	; 0x2000
    51de:	7df9      	ldrb	r1, [r7, #23]
    51e0:	5499      	strb	r1, [r3, r2]
            g_gdec_lut[abps_idx] = (acb_config_byte >> 1u) & 0x03u;
        }
    }
    
    /* Populate the channel_type_lut_h look-up table. */
    for(channel = 0; channel < ACE_NB_OF_INPUT_CHANNELS; ++channel)
    51e2:	687b      	ldr	r3, [r7, #4]
    51e4:	f103 0301 	add.w	r3, r3, #1
    51e8:	607b      	str	r3, [r7, #4]
    51ea:	687b      	ldr	r3, [r7, #4]
    51ec:	2b02      	cmp	r3, #2
    51ee:	dd88      	ble.n	5102 <ace_init_convert+0xae>
        
        channel_type_lut_h[channel] = channel_type;
    }
    
    /* Restore SSE PC2 operations. */
    ACE->PC2_CTRL = saved_pc2_ctrl;
    51f0:	f240 0300 	movw	r3, #0
    51f4:	f2c4 0302 	movt	r3, #16386	; 0x4002
    51f8:	68ba      	ldr	r2, [r7, #8]
    51fa:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
}
    51fe:	f107 071c 	add.w	r7, r7, #28
    5202:	46bd      	mov	sp, r7
    5204:	bc80      	pop	{r7}
    5206:	4770      	bx	lr

00005208 <ACE_convert_to_mV>:
int32_t ACE_convert_to_mV
(
    ace_channel_handle_t    channel_handle,
    uint16_t                sample_value
)
{
    5208:	b480      	push	{r7}
    520a:	b087      	sub	sp, #28
    520c:	af00      	add	r7, sp, #0
    520e:	4602      	mov	r2, r0
    5210:	460b      	mov	r3, r1
    5212:	71fa      	strb	r2, [r7, #7]
    5214:	80bb      	strh	r3, [r7, #4]
    int32_t voltage;
    adc_channel_id_t channel_id;
    uint8_t adc_id;
    uint8_t apbs_idx;
    
    channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    5216:	79fa      	ldrb	r2, [r7, #7]
    5218:	f240 0354 	movw	r3, #84	; 0x54
    521c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5220:	ea4f 1202 	mov.w	r2, r2, lsl #4
    5224:	4413      	add	r3, r2
    5226:	791b      	ldrb	r3, [r3, #4]
    5228:	753b      	strb	r3, [r7, #20]
    adc_id = (uint8_t)channel_id >> 4u;
    522a:	7d3b      	ldrb	r3, [r7, #20]
    522c:	ea4f 1313 	mov.w	r3, r3, lsr #4
    5230:	757b      	strb	r3, [r7, #21]
    adc_voltage = ( g_ace_adc_config[adc_id].va_ref * (uint32_t)sample_value ) / PPE_SAMPLES_RESOLUTION;
    5232:	7d7b      	ldrb	r3, [r7, #21]
    5234:	f240 0248 	movw	r2, #72	; 0x48
    5238:	f2c2 0200 	movt	r2, #8192	; 0x2000
    523c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    5240:	4413      	add	r3, r2
    5242:	885b      	ldrh	r3, [r3, #2]
    5244:	88ba      	ldrh	r2, [r7, #4]
    5246:	fb02 f203 	mul.w	r2, r2, r3
    524a:	f240 1301 	movw	r3, #257	; 0x101
    524e:	f2c0 0310 	movt	r3, #16
    5252:	fba3 1302 	umull	r1, r3, r3, r2
    5256:	ebc3 0202 	rsb	r2, r3, r2
    525a:	ea4f 0252 	mov.w	r2, r2, lsr #1
    525e:	4413      	add	r3, r2
    5260:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    5264:	60fb      	str	r3, [r7, #12]
    voltage = (int32_t)adc_voltage;
    5266:	68fb      	ldr	r3, [r7, #12]
    5268:	613b      	str	r3, [r7, #16]

    apbs_idx = abps_idx_lut[channel_id];
    526a:	7d3a      	ldrb	r2, [r7, #20]
    526c:	f643 2374 	movw	r3, #14964	; 0x3a74
    5270:	f2c0 0301 	movt	r3, #1
    5274:	5c9b      	ldrb	r3, [r3, r2]
    5276:	75bb      	strb	r3, [r7, #22]
    if ( abps_channel_lut[channel_id] != NON_ABPS_CHANNEL )
    5278:	7d3a      	ldrb	r2, [r7, #20]
    527a:	f643 2344 	movw	r3, #14916	; 0x3a44
    527e:	f2c0 0301 	movt	r3, #1
    5282:	5c9b      	ldrb	r3, [r3, r2]
    5284:	2bff      	cmp	r3, #255	; 0xff
    5286:	d01b      	beq.n	52c0 <ACE_convert_to_mV+0xb8>
    {
        uint8_t gdec;
        gdec = g_gdec_lut[apbs_idx];
    5288:	7dba      	ldrb	r2, [r7, #22]
    528a:	f642 734c 	movw	r3, #12108	; 0x2f4c
    528e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5292:	5c9b      	ldrb	r3, [r3, r2]
    5294:	75fb      	strb	r3, [r7, #23]
        voltage = (voltage * apbs_gain_lut[gdec]) - apbs_range[gdec];
    5296:	7dfa      	ldrb	r2, [r7, #23]
    5298:	f643 23a4 	movw	r3, #15012	; 0x3aa4
    529c:	f2c0 0301 	movt	r3, #1
    52a0:	5c9b      	ldrb	r3, [r3, r2]
    52a2:	b25b      	sxtb	r3, r3
    52a4:	693a      	ldr	r2, [r7, #16]
    52a6:	fb02 f203 	mul.w	r2, r2, r3
    52aa:	7df9      	ldrb	r1, [r7, #23]
    52ac:	f643 23a8 	movw	r3, #15016	; 0x3aa8
    52b0:	f2c0 0301 	movt	r3, #1
    52b4:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
    52b8:	b21b      	sxth	r3, r3
    52ba:	ebc3 0302 	rsb	r3, r3, r2
    52be:	613b      	str	r3, [r7, #16]
    }
    return voltage;
    52c0:	693b      	ldr	r3, [r7, #16]
}
    52c2:	4618      	mov	r0, r3
    52c4:	f107 071c 	add.w	r7, r7, #28
    52c8:	46bd      	mov	sp, r7
    52ca:	bc80      	pop	{r7}
    52cc:	4770      	bx	lr
    52ce:	bf00      	nop

000052d0 <ACE_convert_to_mA>:
uint32_t ACE_convert_to_mA
(
    ace_channel_handle_t    channel_handle,
    uint16_t                sample_value
)
{
    52d0:	b580      	push	{r7, lr}
    52d2:	b086      	sub	sp, #24
    52d4:	af00      	add	r7, sp, #0
    52d6:	4602      	mov	r2, r0
    52d8:	460b      	mov	r3, r1
    52da:	71fa      	strb	r2, [r7, #7]
    52dc:	80bb      	strh	r3, [r7, #4]
    uint32_t current = 0u;
    52de:	f04f 0300 	mov.w	r3, #0
    52e2:	60bb      	str	r3, [r7, #8]
    
    ASSERT(channel_handle < ACE_NB_OF_INPUT_CHANNELS);
    52e4:	79fb      	ldrb	r3, [r7, #7]
    52e6:	2b02      	cmp	r3, #2
    52e8:	d900      	bls.n	52ec <ACE_convert_to_mA+0x1c>
    52ea:	be00      	bkpt	0x0000
    
    if((int32_t)channel_handle < ACE_NB_OF_INPUT_CHANNELS)
    52ec:	79fb      	ldrb	r3, [r7, #7]
    52ee:	2b02      	cmp	r3, #2
    52f0:	d842      	bhi.n	5378 <ACE_convert_to_mA+0xa8>
    {
        adc_channel_id_t channel_id;
        uint8_t current_monitor_idx;
        
        channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    52f2:	79fa      	ldrb	r2, [r7, #7]
    52f4:	f240 0354 	movw	r3, #84	; 0x54
    52f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    52fc:	ea4f 1202 	mov.w	r2, r2, lsl #4
    5300:	4413      	add	r3, r2
    5302:	791b      	ldrb	r3, [r3, #4]
    5304:	73bb      	strb	r3, [r7, #14]
        ASSERT(channel_id < sizeof(channel_type_lut));
    5306:	7bbb      	ldrb	r3, [r7, #14]
    5308:	2b2f      	cmp	r3, #47	; 0x2f
    530a:	d900      	bls.n	530e <ACE_convert_to_mA+0x3e>
    530c:	be00      	bkpt	0x0000
        if(CURRENT_CHANNEL == channel_type_lut[channel_id])
    530e:	7bba      	ldrb	r2, [r7, #14]
    5310:	f643 13e4 	movw	r3, #14820	; 0x39e4
    5314:	f2c0 0301 	movt	r3, #1
    5318:	5c9b      	ldrb	r3, [r3, r2]
    531a:	2b01      	cmp	r3, #1
    531c:	d12c      	bne.n	5378 <ACE_convert_to_mA+0xa8>
             *       CM3     :       0x17     :   3
             *       CM4     :       0x23     :   4
             *       CM5     :       0x27     :   5
             */
            current_monitor_idx
                = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
    531e:	7bbb      	ldrb	r3, [r7, #14]
    5320:	f003 0304 	and.w	r3, r3, #4
    5324:	ea4f 0393 	mov.w	r3, r3, lsr #2
             *       CM2     :       0x13     :   2
             *       CM3     :       0x17     :   3
             *       CM4     :       0x23     :   4
             *       CM5     :       0x27     :   5
             */
            current_monitor_idx
    5328:	b2da      	uxtb	r2, r3
                = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
    532a:	7bbb      	ldrb	r3, [r7, #14]
    532c:	f003 0330 	and.w	r3, r3, #48	; 0x30
    5330:	ea4f 03d3 	mov.w	r3, r3, lsr #3
             *       CM2     :       0x13     :   2
             *       CM3     :       0x17     :   3
             *       CM4     :       0x23     :   4
             *       CM5     :       0x27     :   5
             */
            current_monitor_idx
    5334:	b2db      	uxtb	r3, r3
    5336:	4413      	add	r3, r2
    5338:	73fb      	strb	r3, [r7, #15]
                = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
            
            if(current_monitor_idx < (uint8_t)ACE_NB_OF_CURRENT_MONITORS)
    533a:	7bfb      	ldrb	r3, [r7, #15]
    533c:	2b04      	cmp	r3, #4
    533e:	d81b      	bhi.n	5378 <ACE_convert_to_mA+0xa8>
            {
                /* Retrieve the current sensing external resistor value from 
                 * the ACE configuration data generated by the ACE configurator. */
                resistor = g_ace_current_resistors[current_monitor_idx];
    5340:	7bfa      	ldrb	r2, [r7, #15]
    5342:	f243 3318 	movw	r3, #13080	; 0x3318
    5346:	f2c0 0301 	movt	r3, #1
    534a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    534e:	613b      	str	r3, [r7, #16]
                
                /* Compute mA current value taking into account the amplication
                 * factor of 50 used within the current monitor hardware. */
                voltage = ACE_convert_adc_input_to_mV(channel_handle, sample_value);
    5350:	79fa      	ldrb	r2, [r7, #7]
    5352:	88bb      	ldrh	r3, [r7, #4]
    5354:	4610      	mov	r0, r2
    5356:	4619      	mov	r1, r3
    5358:	f7ff fe4a 	bl	4ff0 <ACE_convert_adc_input_to_mV>
    535c:	4603      	mov	r3, r0
    535e:	617b      	str	r3, [r7, #20]
                current = (voltage * (1000u / 50u)) / resistor;
    5360:	697a      	ldr	r2, [r7, #20]
    5362:	4613      	mov	r3, r2
    5364:	ea4f 0383 	mov.w	r3, r3, lsl #2
    5368:	4413      	add	r3, r2
    536a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    536e:	461a      	mov	r2, r3
    5370:	693b      	ldr	r3, [r7, #16]
    5372:	fbb2 f3f3 	udiv	r3, r2, r3
    5376:	60bb      	str	r3, [r7, #8]
;
            }
        }
    }
    
    return current;
    5378:	68bb      	ldr	r3, [r7, #8]
}
    537a:	4618      	mov	r0, r3
    537c:	f107 0718 	add.w	r7, r7, #24
    5380:	46bd      	mov	sp, r7
    5382:	bd80      	pop	{r7, pc}

00005384 <ACE_convert_to_Kelvin>:
uint32_t ACE_convert_to_Kelvin
(
    ace_channel_handle_t    channel_handle,
    uint16_t                sample_value
)
{
    5384:	b580      	push	{r7, lr}
    5386:	b084      	sub	sp, #16
    5388:	af00      	add	r7, sp, #0
    538a:	4602      	mov	r2, r0
    538c:	460b      	mov	r3, r1
    538e:	71fa      	strb	r2, [r7, #7]
    5390:	80bb      	strh	r3, [r7, #4]
    uint32_t temperature;
    uint32_t voltage;
    
    voltage = ACE_convert_adc_input_to_mV( channel_handle, sample_value );
    5392:	79fa      	ldrb	r2, [r7, #7]
    5394:	88bb      	ldrh	r3, [r7, #4]
    5396:	4610      	mov	r0, r2
    5398:	4619      	mov	r1, r3
    539a:	f7ff fe29 	bl	4ff0 <ACE_convert_adc_input_to_mV>
    539e:	4603      	mov	r3, r0
    53a0:	60fb      	str	r3, [r7, #12]
    
    /* Tk = (V * 10^3) / 2.5  */
    temperature = (voltage * 10u) / 25u;
    53a2:	68fa      	ldr	r2, [r7, #12]
    53a4:	4613      	mov	r3, r2
    53a6:	ea4f 0383 	mov.w	r3, r3, lsl #2
    53aa:	4413      	add	r3, r2
    53ac:	ea4f 0343 	mov.w	r3, r3, lsl #1
    53b0:	461a      	mov	r2, r3
    53b2:	f248 531f 	movw	r3, #34079	; 0x851f
    53b6:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
    53ba:	fba3 1302 	umull	r1, r3, r3, r2
    53be:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    53c2:	60bb      	str	r3, [r7, #8]
    
    return temperature;
    53c4:	68bb      	ldr	r3, [r7, #8]
}
    53c6:	4618      	mov	r0, r3
    53c8:	f107 0710 	add.w	r7, r7, #16
    53cc:	46bd      	mov	sp, r7
    53ce:	bd80      	pop	{r7, pc}

000053d0 <ACE_convert_to_Celsius>:
int32_t ACE_convert_to_Celsius
(
    ace_channel_handle_t    channel_handle,
    uint16_t                sample_value
)
{
    53d0:	b580      	push	{r7, lr}
    53d2:	b084      	sub	sp, #16
    53d4:	af00      	add	r7, sp, #0
    53d6:	4602      	mov	r2, r0
    53d8:	460b      	mov	r3, r1
    53da:	71fa      	strb	r2, [r7, #7]
    53dc:	80bb      	strh	r3, [r7, #4]
    int32_t temperature;
    int32_t voltage;
    
    voltage = (int32_t)ACE_convert_adc_input_to_mV( channel_handle, sample_value );
    53de:	79fa      	ldrb	r2, [r7, #7]
    53e0:	88bb      	ldrh	r3, [r7, #4]
    53e2:	4610      	mov	r0, r2
    53e4:	4619      	mov	r1, r3
    53e6:	f7ff fe03 	bl	4ff0 <ACE_convert_adc_input_to_mV>
    53ea:	4603      	mov	r3, r0
    53ec:	60fb      	str	r3, [r7, #12]
    
    /* Tk = (V * 10^3) / 2.5  */
    /* Tc = Tk - 273.15 */
    temperature = (voltage * 4) - 2731;
    53ee:	68fb      	ldr	r3, [r7, #12]
    53f0:	ea4f 0383 	mov.w	r3, r3, lsl #2
    53f4:	f5a3 632a 	sub.w	r3, r3, #2720	; 0xaa0
    53f8:	f1a3 030b 	sub.w	r3, r3, #11
    53fc:	60bb      	str	r3, [r7, #8]
    
    return temperature;
    53fe:	68bb      	ldr	r3, [r7, #8]
}
    5400:	4618      	mov	r0, r3
    5402:	f107 0710 	add.w	r7, r7, #16
    5406:	46bd      	mov	sp, r7
    5408:	bd80      	pop	{r7, pc}
    540a:	bf00      	nop

0000540c <ACE_convert_to_Fahrenheit>:
int32_t ACE_convert_to_Fahrenheit
(
    ace_channel_handle_t    channel_handle,
    uint16_t                sample_value
)
{
    540c:	b580      	push	{r7, lr}
    540e:	b084      	sub	sp, #16
    5410:	af00      	add	r7, sp, #0
    5412:	4602      	mov	r2, r0
    5414:	460b      	mov	r3, r1
    5416:	71fa      	strb	r2, [r7, #7]
    5418:	80bb      	strh	r3, [r7, #4]
    int32_t temperature;
    
    temperature = (int32_t)ACE_convert_to_Kelvin( channel_handle, sample_value );
    541a:	79fa      	ldrb	r2, [r7, #7]
    541c:	88bb      	ldrh	r3, [r7, #4]
    541e:	4610      	mov	r0, r2
    5420:	4619      	mov	r1, r3
    5422:	f7ff ffaf 	bl	5384 <ACE_convert_to_Kelvin>
    5426:	4603      	mov	r3, r0
    5428:	60fb      	str	r3, [r7, #12]
    
    /* F = (K * 9/5) - 459.67 */
    temperature = ((temperature * 9) / 5) - 459;
    542a:	68fa      	ldr	r2, [r7, #12]
    542c:	4613      	mov	r3, r2
    542e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    5432:	441a      	add	r2, r3
    5434:	f246 6367 	movw	r3, #26215	; 0x6667
    5438:	f2c6 6366 	movt	r3, #26214	; 0x6666
    543c:	fb83 1302 	smull	r1, r3, r3, r2
    5440:	ea4f 0163 	mov.w	r1, r3, asr #1
    5444:	ea4f 73e2 	mov.w	r3, r2, asr #31
    5448:	ebc3 0301 	rsb	r3, r3, r1
    544c:	f5a3 73e4 	sub.w	r3, r3, #456	; 0x1c8
    5450:	f1a3 0303 	sub.w	r3, r3, #3
    5454:	60fb      	str	r3, [r7, #12]
    
    return temperature;
    5456:	68fb      	ldr	r3, [r7, #12]
}
    5458:	4618      	mov	r0, r3
    545a:	f107 0710 	add.w	r7, r7, #16
    545e:	46bd      	mov	sp, r7
    5460:	bd80      	pop	{r7, pc}
    5462:	bf00      	nop

00005464 <ACE_get_channel_name>:
 */
const uint8_t * ACE_get_channel_name
(
    ace_channel_handle_t    channel_handle
)
{
    5464:	b480      	push	{r7}
    5466:	b085      	sub	sp, #20
    5468:	af00      	add	r7, sp, #0
    546a:	4603      	mov	r3, r0
    546c:	71fb      	strb	r3, [r7, #7]
    const uint8_t * p_channel_name = 0;
    546e:	f04f 0300 	mov.w	r3, #0
    5472:	60fb      	str	r3, [r7, #12]
    
    if ( channel_handle < NB_OF_ACE_CHANNEL_HANDLES)
    5474:	79fb      	ldrb	r3, [r7, #7]
    5476:	2b02      	cmp	r3, #2
    5478:	d809      	bhi.n	548e <ACE_get_channel_name+0x2a>
    {
        p_channel_name = g_ace_channel_desc_table[channel_handle].p_sz_channel_name;
    547a:	79fa      	ldrb	r2, [r7, #7]
    547c:	f240 0354 	movw	r3, #84	; 0x54
    5480:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5484:	ea4f 1202 	mov.w	r2, r2, lsl #4
    5488:	4413      	add	r3, r2
    548a:	681b      	ldr	r3, [r3, #0]
    548c:	60fb      	str	r3, [r7, #12]
    }
    
    return p_channel_name;
    548e:	68fb      	ldr	r3, [r7, #12]
}
    5490:	4618      	mov	r0, r3
    5492:	f107 0714 	add.w	r7, r7, #20
    5496:	46bd      	mov	sp, r7
    5498:	bc80      	pop	{r7}
    549a:	4770      	bx	lr

0000549c <ACE_convert_mV_to_adc_value>:
uint16_t ACE_convert_mV_to_adc_value
(
    ace_channel_handle_t    channel_handle,
    uint32_t                voltage
)
{
    549c:	b480      	push	{r7}
    549e:	b085      	sub	sp, #20
    54a0:	af00      	add	r7, sp, #0
    54a2:	4603      	mov	r3, r0
    54a4:	6039      	str	r1, [r7, #0]
    54a6:	71fb      	strb	r3, [r7, #7]
    uint16_t sample_value;
    adc_channel_id_t channel_id;
    uint8_t adc_id;
    
    channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    54a8:	79fa      	ldrb	r2, [r7, #7]
    54aa:	f240 0354 	movw	r3, #84	; 0x54
    54ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    54b2:	ea4f 1202 	mov.w	r2, r2, lsl #4
    54b6:	4413      	add	r3, r2
    54b8:	791b      	ldrb	r3, [r3, #4]
    54ba:	73bb      	strb	r3, [r7, #14]
    adc_id = (uint8_t)channel_id >> 4u;
    54bc:	7bbb      	ldrb	r3, [r7, #14]
    54be:	ea4f 1313 	mov.w	r3, r3, lsr #4
    54c2:	73fb      	strb	r3, [r7, #15]
    
    if (voltage > g_ace_adc_config[adc_id].va_ref)
    54c4:	7bfb      	ldrb	r3, [r7, #15]
    54c6:	f240 0248 	movw	r2, #72	; 0x48
    54ca:	f2c2 0200 	movt	r2, #8192	; 0x2000
    54ce:	ea4f 0383 	mov.w	r3, r3, lsl #2
    54d2:	4413      	add	r3, r2
    54d4:	885b      	ldrh	r3, [r3, #2]
    54d6:	461a      	mov	r2, r3
    54d8:	683b      	ldr	r3, [r7, #0]
    54da:	429a      	cmp	r2, r3
    54dc:	d20a      	bcs.n	54f4 <ACE_convert_mV_to_adc_value+0x58>
    {
        sample_value = g_ace_adc_config[adc_id].adc_resolution - 1u;
    54de:	7bfa      	ldrb	r2, [r7, #15]
    54e0:	f240 0348 	movw	r3, #72	; 0x48
    54e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    54e8:	f833 3022 	ldrh.w	r3, [r3, r2, lsl #2]
    54ec:	f103 33ff 	add.w	r3, r3, #4294967295
    54f0:	81bb      	strh	r3, [r7, #12]
    54f2:	e017      	b.n	5524 <ACE_convert_mV_to_adc_value+0x88>
    }
    else
    {
        sample_value = (uint16_t)((voltage * (g_ace_adc_config[adc_id].adc_resolution - 1)) / g_ace_adc_config[adc_id].va_ref);
    54f4:	7bfa      	ldrb	r2, [r7, #15]
    54f6:	f240 0348 	movw	r3, #72	; 0x48
    54fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    54fe:	f833 3022 	ldrh.w	r3, [r3, r2, lsl #2]
    5502:	f103 33ff 	add.w	r3, r3, #4294967295
    5506:	683a      	ldr	r2, [r7, #0]
    5508:	fb02 f103 	mul.w	r1, r2, r3
    550c:	7bfb      	ldrb	r3, [r7, #15]
    550e:	f240 0248 	movw	r2, #72	; 0x48
    5512:	f2c2 0200 	movt	r2, #8192	; 0x2000
    5516:	ea4f 0383 	mov.w	r3, r3, lsl #2
    551a:	4413      	add	r3, r2
    551c:	885b      	ldrh	r3, [r3, #2]
    551e:	fbb1 f3f3 	udiv	r3, r1, r3
    5522:	81bb      	strh	r3, [r7, #12]
    }
    
    return sample_value;
    5524:	89bb      	ldrh	r3, [r7, #12]
}
    5526:	4618      	mov	r0, r3
    5528:	f107 0714 	add.w	r7, r7, #20
    552c:	46bd      	mov	sp, r7
    552e:	bc80      	pop	{r7}
    5530:	4770      	bx	lr
    5532:	bf00      	nop

00005534 <convert_mV_to_ppe_value>:
static uint16_t convert_mV_to_ppe_value
(
    ace_channel_handle_t    channel_handle,
    uint32_t                voltage
)
{
    5534:	b480      	push	{r7}
    5536:	b085      	sub	sp, #20
    5538:	af00      	add	r7, sp, #0
    553a:	4603      	mov	r3, r0
    553c:	6039      	str	r1, [r7, #0]
    553e:	71fb      	strb	r3, [r7, #7]
    uint16_t sample_value;
    adc_channel_id_t channel_id;
    uint8_t adc_id;
    
    channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    5540:	79fa      	ldrb	r2, [r7, #7]
    5542:	f240 0354 	movw	r3, #84	; 0x54
    5546:	f2c2 0300 	movt	r3, #8192	; 0x2000
    554a:	ea4f 1202 	mov.w	r2, r2, lsl #4
    554e:	4413      	add	r3, r2
    5550:	791b      	ldrb	r3, [r3, #4]
    5552:	73bb      	strb	r3, [r7, #14]
    adc_id = (uint8_t)channel_id >> 4u;
    5554:	7bbb      	ldrb	r3, [r7, #14]
    5556:	ea4f 1313 	mov.w	r3, r3, lsr #4
    555a:	73fb      	strb	r3, [r7, #15]
    
    if (voltage > g_ace_adc_config[adc_id].va_ref)
    555c:	7bfb      	ldrb	r3, [r7, #15]
    555e:	f240 0248 	movw	r2, #72	; 0x48
    5562:	f2c2 0200 	movt	r2, #8192	; 0x2000
    5566:	ea4f 0383 	mov.w	r3, r3, lsl #2
    556a:	4413      	add	r3, r2
    556c:	885b      	ldrh	r3, [r3, #2]
    556e:	461a      	mov	r2, r3
    5570:	683b      	ldr	r3, [r7, #0]
    5572:	429a      	cmp	r2, r3
    5574:	d203      	bcs.n	557e <convert_mV_to_ppe_value+0x4a>
    {
        sample_value = PPE_SAMPLES_RESOLUTION;
    5576:	f640 73ff 	movw	r3, #4095	; 0xfff
    557a:	81bb      	strh	r3, [r7, #12]
    557c:	e011      	b.n	55a2 <convert_mV_to_ppe_value+0x6e>
    }
    else
    {
        sample_value = (uint16_t)((voltage * PPE_SAMPLES_RESOLUTION) / g_ace_adc_config[adc_id].va_ref);
    557e:	683a      	ldr	r2, [r7, #0]
    5580:	4613      	mov	r3, r2
    5582:	ea4f 3303 	mov.w	r3, r3, lsl #12
    5586:	ebc2 0103 	rsb	r1, r2, r3
    558a:	7bfb      	ldrb	r3, [r7, #15]
    558c:	f240 0248 	movw	r2, #72	; 0x48
    5590:	f2c2 0200 	movt	r2, #8192	; 0x2000
    5594:	ea4f 0383 	mov.w	r3, r3, lsl #2
    5598:	4413      	add	r3, r2
    559a:	885b      	ldrh	r3, [r3, #2]
    559c:	fbb1 f3f3 	udiv	r3, r1, r3
    55a0:	81bb      	strh	r3, [r7, #12]
    }
    
    return sample_value;
    55a2:	89bb      	ldrh	r3, [r7, #12]
}
    55a4:	4618      	mov	r0, r3
    55a6:	f107 0714 	add.w	r7, r7, #20
    55aa:	46bd      	mov	sp, r7
    55ac:	bc80      	pop	{r7}
    55ae:	4770      	bx	lr

000055b0 <ACE_convert_from_mV>:
uint16_t ACE_convert_from_mV
(
    ace_channel_handle_t    channel_handle,
    int32_t                 voltage
)
{
    55b0:	b480      	push	{r7}
    55b2:	b087      	sub	sp, #28
    55b4:	af00      	add	r7, sp, #0
    55b6:	4603      	mov	r3, r0
    55b8:	6039      	str	r1, [r7, #0]
    55ba:	71fb      	strb	r3, [r7, #7]
    uint16_t sample_value;
    adc_channel_id_t channel_id;
    uint8_t adc_id;
    uint32_t adc_voltage;
    
    channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    55bc:	79fa      	ldrb	r2, [r7, #7]
    55be:	f240 0354 	movw	r3, #84	; 0x54
    55c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    55c6:	ea4f 1202 	mov.w	r2, r2, lsl #4
    55ca:	4413      	add	r3, r2
    55cc:	791b      	ldrb	r3, [r3, #4]
    55ce:	73bb      	strb	r3, [r7, #14]
    adc_id = (uint8_t)channel_id >> 4u;
    55d0:	7bbb      	ldrb	r3, [r7, #14]
    55d2:	ea4f 1313 	mov.w	r3, r3, lsr #4
    55d6:	73fb      	strb	r3, [r7, #15]
    
    if ( abps_channel_lut[channel_id] == NON_ABPS_CHANNEL )
    55d8:	7bba      	ldrb	r2, [r7, #14]
    55da:	f643 2344 	movw	r3, #14916	; 0x3a44
    55de:	f2c0 0301 	movt	r3, #1
    55e2:	5c9b      	ldrb	r3, [r3, r2]
    55e4:	2bff      	cmp	r3, #255	; 0xff
    55e6:	d109      	bne.n	55fc <ACE_convert_from_mV+0x4c>
    {
        if (voltage > 0)
    55e8:	683b      	ldr	r3, [r7, #0]
    55ea:	2b00      	cmp	r3, #0
    55ec:	dd02      	ble.n	55f4 <ACE_convert_from_mV+0x44>
        {
            adc_voltage = (uint32_t)voltage;
    55ee:	683b      	ldr	r3, [r7, #0]
    55f0:	613b      	str	r3, [r7, #16]
        }
        else
        {
            adc_voltage = 0u;
    55f2:	e030      	b.n	5656 <ACE_convert_from_mV+0xa6>
    55f4:	f04f 0300 	mov.w	r3, #0
    55f8:	613b      	str	r3, [r7, #16]
    55fa:	e02c      	b.n	5656 <ACE_convert_from_mV+0xa6>
    else
    {
        uint8_t apbs_idx;
        uint8_t gdec;
        
        apbs_idx = abps_idx_lut[channel_id];
    55fc:	7bba      	ldrb	r2, [r7, #14]
    55fe:	f643 2374 	movw	r3, #14964	; 0x3a74
    5602:	f2c0 0301 	movt	r3, #1
    5606:	5c9b      	ldrb	r3, [r3, r2]
    5608:	75bb      	strb	r3, [r7, #22]
        gdec = g_gdec_lut[apbs_idx];
    560a:	7dba      	ldrb	r2, [r7, #22]
    560c:	f642 734c 	movw	r3, #12108	; 0x2f4c
    5610:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5614:	5c9b      	ldrb	r3, [r3, r2]
    5616:	75fb      	strb	r3, [r7, #23]
        voltage = voltage + apbs_range[gdec];
    5618:	7dfa      	ldrb	r2, [r7, #23]
    561a:	f643 23a8 	movw	r3, #15016	; 0x3aa8
    561e:	f2c0 0301 	movt	r3, #1
    5622:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    5626:	b21b      	sxth	r3, r3
    5628:	683a      	ldr	r2, [r7, #0]
    562a:	4413      	add	r3, r2
    562c:	603b      	str	r3, [r7, #0]
        if (voltage > 0)
    562e:	683b      	ldr	r3, [r7, #0]
    5630:	2b00      	cmp	r3, #0
    5632:	dd0d      	ble.n	5650 <ACE_convert_from_mV+0xa0>
        {
	        adc_voltage = (uint32_t)voltage;
    5634:	683b      	ldr	r3, [r7, #0]
    5636:	613b      	str	r3, [r7, #16]
	        adc_voltage = adc_voltage / (uint8_t)apbs_gain_lut[gdec];
    5638:	7dfa      	ldrb	r2, [r7, #23]
    563a:	f643 23a4 	movw	r3, #15012	; 0x3aa4
    563e:	f2c0 0301 	movt	r3, #1
    5642:	5c9b      	ldrb	r3, [r3, r2]
    5644:	b2db      	uxtb	r3, r3
    5646:	693a      	ldr	r2, [r7, #16]
    5648:	fbb2 f3f3 	udiv	r3, r2, r3
    564c:	613b      	str	r3, [r7, #16]
    564e:	e002      	b.n	5656 <ACE_convert_from_mV+0xa6>
        }
        else
        {
        	adc_voltage = 0;
    5650:	f04f 0300 	mov.w	r3, #0
    5654:	613b      	str	r3, [r7, #16]
        }
    }
    
    sample_value = (uint16_t)((adc_voltage * PPE_SAMPLES_RESOLUTION) / g_ace_adc_config[adc_id].va_ref);
    5656:	693a      	ldr	r2, [r7, #16]
    5658:	4613      	mov	r3, r2
    565a:	ea4f 3303 	mov.w	r3, r3, lsl #12
    565e:	ebc2 0103 	rsb	r1, r2, r3
    5662:	7bfb      	ldrb	r3, [r7, #15]
    5664:	f240 0248 	movw	r2, #72	; 0x48
    5668:	f2c2 0200 	movt	r2, #8192	; 0x2000
    566c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    5670:	4413      	add	r3, r2
    5672:	885b      	ldrh	r3, [r3, #2]
    5674:	fbb1 f3f3 	udiv	r3, r1, r3
    5678:	81bb      	strh	r3, [r7, #12]
    
    if (sample_value > MAX_PPE_SAMPLE_VALUE)
    567a:	89ba      	ldrh	r2, [r7, #12]
    567c:	f640 73ff 	movw	r3, #4095	; 0xfff
    5680:	429a      	cmp	r2, r3
    5682:	d902      	bls.n	568a <ACE_convert_from_mV+0xda>
    {
        sample_value = MAX_PPE_SAMPLE_VALUE;
    5684:	f640 73ff 	movw	r3, #4095	; 0xfff
    5688:	81bb      	strh	r3, [r7, #12]
    }
    return sample_value;
    568a:	89bb      	ldrh	r3, [r7, #12]
}
    568c:	4618      	mov	r0, r3
    568e:	f107 071c 	add.w	r7, r7, #28
    5692:	46bd      	mov	sp, r7
    5694:	bc80      	pop	{r7}
    5696:	4770      	bx	lr

00005698 <ACE_convert_from_mA>:
uint16_t ACE_convert_from_mA
(
    ace_channel_handle_t    channel_handle,
    uint32_t                current
)
{
    5698:	b580      	push	{r7, lr}
    569a:	b086      	sub	sp, #24
    569c:	af00      	add	r7, sp, #0
    569e:	4603      	mov	r3, r0
    56a0:	6039      	str	r1, [r7, #0]
    56a2:	71fb      	strb	r3, [r7, #7]
    uint16_t sample_value;
    uint32_t voltage;
    uint32_t resistor = 1u;
    56a4:	f04f 0301 	mov.w	r3, #1
    56a8:	617b      	str	r3, [r7, #20]
    
    voltage = current * 50u * resistor;
    56aa:	683b      	ldr	r3, [r7, #0]
    56ac:	697a      	ldr	r2, [r7, #20]
    56ae:	fb02 f303 	mul.w	r3, r2, r3
    56b2:	f04f 0232 	mov.w	r2, #50	; 0x32
    56b6:	fb02 f303 	mul.w	r3, r2, r3
    56ba:	613b      	str	r3, [r7, #16]
    sample_value = convert_mV_to_ppe_value( channel_handle, voltage );
    56bc:	79fb      	ldrb	r3, [r7, #7]
    56be:	4618      	mov	r0, r3
    56c0:	6939      	ldr	r1, [r7, #16]
    56c2:	f7ff ff37 	bl	5534 <convert_mV_to_ppe_value>
    56c6:	4603      	mov	r3, r0
    56c8:	81fb      	strh	r3, [r7, #14]
    
    if (sample_value > MAX_PPE_SAMPLE_VALUE)
    56ca:	89fa      	ldrh	r2, [r7, #14]
    56cc:	f640 73ff 	movw	r3, #4095	; 0xfff
    56d0:	429a      	cmp	r2, r3
    56d2:	d902      	bls.n	56da <ACE_convert_from_mA+0x42>
    {
        sample_value = MAX_PPE_SAMPLE_VALUE;
    56d4:	f640 73ff 	movw	r3, #4095	; 0xfff
    56d8:	81fb      	strh	r3, [r7, #14]
    }
    return sample_value;
    56da:	89fb      	ldrh	r3, [r7, #14]
}
    56dc:	4618      	mov	r0, r3
    56de:	f107 0718 	add.w	r7, r7, #24
    56e2:	46bd      	mov	sp, r7
    56e4:	bd80      	pop	{r7, pc}
    56e6:	bf00      	nop

000056e8 <ACE_convert_from_Kelvin>:
uint16_t ACE_convert_from_Kelvin
(
    ace_channel_handle_t    channel_handle,
    uint32_t                temperature
)
{
    56e8:	b580      	push	{r7, lr}
    56ea:	b084      	sub	sp, #16
    56ec:	af00      	add	r7, sp, #0
    56ee:	4603      	mov	r3, r0
    56f0:	6039      	str	r1, [r7, #0]
    56f2:	71fb      	strb	r3, [r7, #7]
    uint16_t sample_value;
    uint32_t voltage;
    
    voltage = (temperature * 25u) / 10u;
    56f4:	683a      	ldr	r2, [r7, #0]
    56f6:	4613      	mov	r3, r2
    56f8:	ea4f 0383 	mov.w	r3, r3, lsl #2
    56fc:	4413      	add	r3, r2
    56fe:	ea4f 0283 	mov.w	r2, r3, lsl #2
    5702:	441a      	add	r2, r3
    5704:	f64c 43cd 	movw	r3, #52429	; 0xcccd
    5708:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
    570c:	fba3 1302 	umull	r1, r3, r3, r2
    5710:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    5714:	60fb      	str	r3, [r7, #12]
    sample_value = convert_mV_to_ppe_value( channel_handle, voltage );
    5716:	79fb      	ldrb	r3, [r7, #7]
    5718:	4618      	mov	r0, r3
    571a:	68f9      	ldr	r1, [r7, #12]
    571c:	f7ff ff0a 	bl	5534 <convert_mV_to_ppe_value>
    5720:	4603      	mov	r3, r0
    5722:	817b      	strh	r3, [r7, #10]
    
    if (sample_value > MAX_PPE_SAMPLE_VALUE)
    5724:	897a      	ldrh	r2, [r7, #10]
    5726:	f640 73ff 	movw	r3, #4095	; 0xfff
    572a:	429a      	cmp	r2, r3
    572c:	d902      	bls.n	5734 <ACE_convert_from_Kelvin+0x4c>
    {
        sample_value = MAX_PPE_SAMPLE_VALUE;
    572e:	f640 73ff 	movw	r3, #4095	; 0xfff
    5732:	817b      	strh	r3, [r7, #10]
    }
    return sample_value;
    5734:	897b      	ldrh	r3, [r7, #10]
}
    5736:	4618      	mov	r0, r3
    5738:	f107 0710 	add.w	r7, r7, #16
    573c:	46bd      	mov	sp, r7
    573e:	bd80      	pop	{r7, pc}

00005740 <ACE_convert_from_Celsius>:
uint16_t ACE_convert_from_Celsius
(
    ace_channel_handle_t    channel_handle,
    int32_t                 temperature
)
{
    5740:	b580      	push	{r7, lr}
    5742:	b084      	sub	sp, #16
    5744:	af00      	add	r7, sp, #0
    5746:	4603      	mov	r3, r0
    5748:	6039      	str	r1, [r7, #0]
    574a:	71fb      	strb	r3, [r7, #7]
    uint16_t sample_value;
    uint32_t voltage;
    
    temperature = temperature + 2731;
    574c:	683b      	ldr	r3, [r7, #0]
    574e:	f503 632a 	add.w	r3, r3, #2720	; 0xaa0
    5752:	f103 030b 	add.w	r3, r3, #11
    5756:	603b      	str	r3, [r7, #0]
    voltage = (uint32_t)temperature / 4u;
    5758:	683b      	ldr	r3, [r7, #0]
    575a:	ea4f 0393 	mov.w	r3, r3, lsr #2
    575e:	60fb      	str	r3, [r7, #12]
    sample_value = convert_mV_to_ppe_value( channel_handle, voltage );
    5760:	79fb      	ldrb	r3, [r7, #7]
    5762:	4618      	mov	r0, r3
    5764:	68f9      	ldr	r1, [r7, #12]
    5766:	f7ff fee5 	bl	5534 <convert_mV_to_ppe_value>
    576a:	4603      	mov	r3, r0
    576c:	817b      	strh	r3, [r7, #10]
    
    if (sample_value > MAX_PPE_SAMPLE_VALUE)
    576e:	897a      	ldrh	r2, [r7, #10]
    5770:	f640 73ff 	movw	r3, #4095	; 0xfff
    5774:	429a      	cmp	r2, r3
    5776:	d902      	bls.n	577e <ACE_convert_from_Celsius+0x3e>
    {
        sample_value = MAX_PPE_SAMPLE_VALUE;
    5778:	f640 73ff 	movw	r3, #4095	; 0xfff
    577c:	817b      	strh	r3, [r7, #10]
    }
    return sample_value;
    577e:	897b      	ldrh	r3, [r7, #10]
}
    5780:	4618      	mov	r0, r3
    5782:	f107 0710 	add.w	r7, r7, #16
    5786:	46bd      	mov	sp, r7
    5788:	bd80      	pop	{r7, pc}
    578a:	bf00      	nop

0000578c <ACE_convert_from_Fahrenheit>:
uint16_t ACE_convert_from_Fahrenheit
(
    ace_channel_handle_t    channel_handle,
    int32_t                 temperature
)
{
    578c:	b580      	push	{r7, lr}
    578e:	b084      	sub	sp, #16
    5790:	af00      	add	r7, sp, #0
    5792:	4603      	mov	r3, r0
    5794:	6039      	str	r1, [r7, #0]
    5796:	71fb      	strb	r3, [r7, #7]
    uint16_t sample_value;
    uint32_t kelvin;
    
    temperature = temperature + 459;
    5798:	683b      	ldr	r3, [r7, #0]
    579a:	f503 73e4 	add.w	r3, r3, #456	; 0x1c8
    579e:	f103 0303 	add.w	r3, r3, #3
    57a2:	603b      	str	r3, [r7, #0]
    kelvin = (uint32_t)temperature;
    57a4:	683b      	ldr	r3, [r7, #0]
    57a6:	60fb      	str	r3, [r7, #12]
    kelvin = (kelvin * 5u) / 9u;
    57a8:	68fa      	ldr	r2, [r7, #12]
    57aa:	4613      	mov	r3, r2
    57ac:	ea4f 0383 	mov.w	r3, r3, lsl #2
    57b0:	441a      	add	r2, r3
    57b2:	f648 6339 	movw	r3, #36409	; 0x8e39
    57b6:	f6c3 03e3 	movt	r3, #14563	; 0x38e3
    57ba:	fba3 1302 	umull	r1, r3, r3, r2
    57be:	ea4f 0353 	mov.w	r3, r3, lsr #1
    57c2:	60fb      	str	r3, [r7, #12]
    
    sample_value = ACE_convert_from_Kelvin( channel_handle, kelvin );
    57c4:	79fb      	ldrb	r3, [r7, #7]
    57c6:	4618      	mov	r0, r3
    57c8:	68f9      	ldr	r1, [r7, #12]
    57ca:	f7ff ff8d 	bl	56e8 <ACE_convert_from_Kelvin>
    57ce:	4603      	mov	r3, r0
    57d0:	817b      	strh	r3, [r7, #10]
    
    if (sample_value > MAX_PPE_SAMPLE_VALUE)
    57d2:	897a      	ldrh	r2, [r7, #10]
    57d4:	f640 73ff 	movw	r3, #4095	; 0xfff
    57d8:	429a      	cmp	r2, r3
    57da:	d902      	bls.n	57e2 <ACE_convert_from_Fahrenheit+0x56>
    {
        sample_value = MAX_PPE_SAMPLE_VALUE;
    57dc:	f640 73ff 	movw	r3, #4095	; 0xfff
    57e0:	817b      	strh	r3, [r7, #10]
    }
    return sample_value;
    57e2:	897b      	ldrh	r3, [r7, #10]
}
    57e4:	4618      	mov	r0, r3
    57e6:	f107 0710 	add.w	r7, r7, #16
    57ea:	46bd      	mov	sp, r7
    57ec:	bd80      	pop	{r7, pc}
    57ee:	bf00      	nop

000057f0 <ACE_translate_pdma_value>:
uint16_t ACE_translate_pdma_value
(
    uint32_t            pdma_value,
    adc_channel_id_t *  channel_id
)
{
    57f0:	b480      	push	{r7}
    57f2:	b085      	sub	sp, #20
    57f4:	af00      	add	r7, sp, #0
    57f6:	6078      	str	r0, [r7, #4]
    57f8:	6039      	str	r1, [r7, #0]
    uint16_t ppe_value;
      
    ppe_value = (pdma_value >> 8u) & 0xFFFFu;
    57fa:	687b      	ldr	r3, [r7, #4]
    57fc:	ea4f 2313 	mov.w	r3, r3, lsr #8
    5800:	81fb      	strh	r3, [r7, #14]
    if ( channel_id != 0 )
    5802:	683b      	ldr	r3, [r7, #0]
    5804:	2b00      	cmp	r3, #0
    5806:	d005      	beq.n	5814 <ACE_translate_pdma_value+0x24>
    {
        *channel_id = (adc_channel_id_t)((pdma_value >> 24u) & 0xFFu);
    5808:	687b      	ldr	r3, [r7, #4]
    580a:	ea4f 6313 	mov.w	r3, r3, lsr #24
    580e:	b2da      	uxtb	r2, r3
    5810:	683b      	ldr	r3, [r7, #0]
    5812:	701a      	strb	r2, [r3, #0]
    }
    
    return ppe_value;
    5814:	89fb      	ldrh	r3, [r7, #14]
}
    5816:	4618      	mov	r0, r3
    5818:	f107 0714 	add.w	r7, r7, #20
    581c:	46bd      	mov	sp, r7
    581e:	bc80      	pop	{r7}
    5820:	4770      	bx	lr
    5822:	bf00      	nop

00005824 <ACE_init>:

/*-------------------------------------------------------------------------*//**
  See "mss_ace.h" for details of how to use this function.
 */
void ACE_init( void )
{
    5824:	b580      	push	{r7, lr}
    5826:	af00      	add	r7, sp, #0
	#if (ACE_NB_OF_PPE_FLAGS > 0)
	    ace_init_flags();
	#endif

    /* Initialize the data structures used by conversion functions. */
    ace_init_convert();
    5828:	f7ff fc14 	bl	5054 <ace_init_convert>
}
    582c:	bd80      	pop	{r7, pc}
    582e:	bf00      	nop

00005830 <ACE_start_adc>:
 */
void ACE_start_adc
(
	adc_channel_id_t channel_id
)
{
    5830:	b480      	push	{r7}
    5832:	b083      	sub	sp, #12
    5834:	af00      	add	r7, sp, #0
    5836:	4603      	mov	r3, r0
    5838:	71fb      	strb	r3, [r7, #7]
    ACE->ADC0_CONV_CTRL = (uint32_t)channel_id | START_ADC_CONVERSION;
    583a:	f240 0300 	movw	r3, #0
    583e:	f2c4 0302 	movt	r3, #16386	; 0x4002
    5842:	79fa      	ldrb	r2, [r7, #7]
    5844:	ea6f 6242 	mvn.w	r2, r2, lsl #25
    5848:	ea6f 6252 	mvn.w	r2, r2, lsr #25
    584c:	b2d2      	uxtb	r2, r2
    584e:	651a      	str	r2, [r3, #80]	; 0x50
}
    5850:	f107 070c 	add.w	r7, r7, #12
    5854:	46bd      	mov	sp, r7
    5856:	bc80      	pop	{r7}
    5858:	4770      	bx	lr
    585a:	bf00      	nop

0000585c <ACE_get_adc_result>:

uint16_t ACE_get_adc_result
(
    uint8_t adc_id
)
{
    585c:	b480      	push	{r7}
    585e:	b085      	sub	sp, #20
    5860:	af00      	add	r7, sp, #0
    5862:	4603      	mov	r3, r0
    5864:	71fb      	strb	r3, [r7, #7]
    uint16_t result = 0u;
    5866:	f04f 0300 	mov.w	r3, #0
    586a:	817b      	strh	r3, [r7, #10]
    uint32_t data_valid;

    ASSERT( adc_id < NB_OF_ANALOG_MODULES );
    586c:	79fb      	ldrb	r3, [r7, #7]
    586e:	2b02      	cmp	r3, #2
    5870:	d900      	bls.n	5874 <ACE_get_adc_result+0x18>
    5872:	be00      	bkpt	0x0000

    if ( adc_id < (uint8_t)NB_OF_ANALOG_MODULES )
    5874:	79fb      	ldrb	r3, [r7, #7]
    5876:	2b02      	cmp	r3, #2
    5878:	d81b      	bhi.n	58b2 <ACE_get_adc_result+0x56>
    {
        do {
            data_valid = *adc_status_reg_lut[adc_id] & ADC_DATAVALID_MASK;
    587a:	79fa      	ldrb	r2, [r7, #7]
    587c:	f643 23b0 	movw	r3, #15024	; 0x3ab0
    5880:	f2c0 0301 	movt	r3, #1
    5884:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5888:	681b      	ldr	r3, [r3, #0]
    588a:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    588e:	60fb      	str	r3, [r7, #12]
        } while ( !data_valid );
    5890:	68fb      	ldr	r3, [r7, #12]
    5892:	2b00      	cmp	r3, #0
    5894:	d0f1      	beq.n	587a <ACE_get_adc_result+0x1e>

        result = (uint16_t)(*adc_status_reg_lut[adc_id] & ADC_RESULT_MASK);
    5896:	79fa      	ldrb	r2, [r7, #7]
    5898:	f643 23b0 	movw	r3, #15024	; 0x3ab0
    589c:	f2c0 0301 	movt	r3, #1
    58a0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    58a4:	681b      	ldr	r3, [r3, #0]
    58a6:	b29b      	uxth	r3, r3
    58a8:	ea4f 5303 	mov.w	r3, r3, lsl #20
    58ac:	ea4f 5313 	mov.w	r3, r3, lsr #20
    58b0:	817b      	strh	r3, [r7, #10]
    }
    return result;
    58b2:	897b      	ldrh	r3, [r7, #10]
}
    58b4:	4618      	mov	r0, r3
    58b6:	f107 0714 	add.w	r7, r7, #20
    58ba:	46bd      	mov	sp, r7
    58bc:	bc80      	pop	{r7}
    58be:	4770      	bx	lr

000058c0 <ACE_configure_sdd>:
	sdd_id_t            sdd_id,
	sdd_resolution_t    resolution,
    uint8_t             mode,
    sdd_update_method_t sync_update
)
{
    58c0:	b490      	push	{r4, r7}
    58c2:	b086      	sub	sp, #24
    58c4:	af00      	add	r7, sp, #0
    58c6:	71f8      	strb	r0, [r7, #7]
    58c8:	71b9      	strb	r1, [r7, #6]
    58ca:	717a      	strb	r2, [r7, #5]
    58cc:	713b      	strb	r3, [r7, #4]
    ASSERT( sdd_id < NB_OF_SDD );
    58ce:	79fb      	ldrb	r3, [r7, #7]
    58d0:	2b02      	cmp	r3, #2
    58d2:	d900      	bls.n	58d6 <ACE_configure_sdd+0x16>
    58d4:	be00      	bkpt	0x0000

    if ( sdd_id < NB_OF_SDD )
    58d6:	79fb      	ldrb	r3, [r7, #7]
    58d8:	2b02      	cmp	r3, #2
    58da:	f200 80bc 	bhi.w	5a56 <ACE_configure_sdd+0x196>
    {
        const uint8_t sdd_2_quad_lut[NB_OF_SDD] = {0u, 2u, 4u};
    58de:	f643 22fc 	movw	r2, #15100	; 0x3afc
    58e2:	f2c0 0201 	movt	r2, #1
    58e6:	f107 030c 	add.w	r3, r7, #12
    58ea:	6812      	ldr	r2, [r2, #0]
    58ec:	4611      	mov	r1, r2
    58ee:	8019      	strh	r1, [r3, #0]
    58f0:	f103 0302 	add.w	r3, r3, #2
    58f4:	ea4f 4212 	mov.w	r2, r2, lsr #16
    58f8:	701a      	strb	r2, [r3, #0]
        uint8_t quad_id;
        uint8_t obd_mode_idx = 1u;
    58fa:	f04f 0301 	mov.w	r3, #1
    58fe:	74bb      	strb	r3, [r7, #18]
        uint8_t chopping_mode_idx = 0u;
    5900:	f04f 0300 	mov.w	r3, #0
    5904:	74fb      	strb	r3, [r7, #19]
        uint32_t saved_pc2_ctrl;

        quad_id = sdd_2_quad_lut[sdd_id];
    5906:	79fb      	ldrb	r3, [r7, #7]
    5908:	f107 0218 	add.w	r2, r7, #24
    590c:	4413      	add	r3, r2
    590e:	f813 3c0c 	ldrb.w	r3, [r3, #-12]
    5912:	747b      	strb	r3, [r7, #17]

        /* Pause the SSE PC2 while accesses to ACB from APB3 are taking place. */
        saved_pc2_ctrl = ACE->PC2_CTRL;
    5914:	f240 0300 	movw	r3, #0
    5918:	f2c4 0302 	movt	r3, #16386	; 0x4002
    591c:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
    5920:	617b      	str	r3, [r7, #20]
        ACE->PC2_CTRL = 0u;
    5922:	f240 0300 	movw	r3, #0
    5926:	f2c4 0302 	movt	r3, #16386	; 0x4002
    592a:	f04f 0200 	mov.w	r2, #0
    592e:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8

        /* Select between voltage/current and RTZ modes.*/
        ACE->ACB_DATA[quad_id].b6 = mode;
    5932:	f240 0200 	movw	r2, #0
    5936:	f2c4 0202 	movt	r2, #16386	; 0x4002
    593a:	7c79      	ldrb	r1, [r7, #17]
    593c:	460b      	mov	r3, r1
    593e:	ea4f 0343 	mov.w	r3, r3, lsl #1
    5942:	440b      	add	r3, r1
    5944:	ea4f 1303 	mov.w	r3, r3, lsl #4
    5948:	4413      	add	r3, r2
    594a:	f503 7306 	add.w	r3, r3, #536	; 0x218
    594e:	797a      	ldrb	r2, [r7, #5]
    5950:	711a      	strb	r2, [r3, #4]

        /* Load manufacturing generated trim value. */
        if ( (mode & OBD_MODE_MASK) > 0u )
    5952:	797b      	ldrb	r3, [r7, #5]
    5954:	f003 0301 	and.w	r3, r3, #1
    5958:	b2db      	uxtb	r3, r3
    595a:	2b00      	cmp	r3, #0
    595c:	d002      	beq.n	5964 <ACE_configure_sdd+0xa4>
        {
            obd_mode_idx = 0u;
    595e:	f04f 0300 	mov.w	r3, #0
    5962:	74bb      	strb	r3, [r7, #18]
        }
        if ( (mode & OBD_CHOPPING_MASK) > 0u )
    5964:	797b      	ldrb	r3, [r7, #5]
    5966:	f003 0302 	and.w	r3, r3, #2
    596a:	2b00      	cmp	r3, #0
    596c:	d002      	beq.n	5974 <ACE_configure_sdd+0xb4>
        {
            chopping_mode_idx = 1u;
    596e:	f04f 0301 	mov.w	r3, #1
    5972:	74fb      	strb	r3, [r7, #19]
        }
        ACE->ACB_DATA[quad_id].b4
    5974:	f240 0200 	movw	r2, #0
    5978:	f2c4 0202 	movt	r2, #16386	; 0x4002
    597c:	7c79      	ldrb	r1, [r7, #17]
            = p_mtd_data->odb_trimming[sdd_id][obd_mode_idx][chopping_mode_idx];
    597e:	f643 23ec 	movw	r3, #15084	; 0x3aec
    5982:	f2c0 0301 	movt	r3, #1
    5986:	681b      	ldr	r3, [r3, #0]
    5988:	79fc      	ldrb	r4, [r7, #7]
    598a:	f897 c012 	ldrb.w	ip, [r7, #18]
    598e:	7cf8      	ldrb	r0, [r7, #19]
    5990:	ea4f 0444 	mov.w	r4, r4, lsl #1
    5994:	44a4      	add	ip, r4
    5996:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
    599a:	4460      	add	r0, ip
    599c:	4403      	add	r3, r0
    599e:	f103 0380 	add.w	r3, r3, #128	; 0x80
    59a2:	7918      	ldrb	r0, [r3, #4]
        }
        if ( (mode & OBD_CHOPPING_MASK) > 0u )
        {
            chopping_mode_idx = 1u;
        }
        ACE->ACB_DATA[quad_id].b4
    59a4:	460b      	mov	r3, r1
    59a6:	ea4f 0343 	mov.w	r3, r3, lsl #1
    59aa:	440b      	add	r3, r1
    59ac:	ea4f 1303 	mov.w	r3, r3, lsl #4
    59b0:	4413      	add	r3, r2
    59b2:	f503 7304 	add.w	r3, r3, #528	; 0x210
    59b6:	4602      	mov	r2, r0
    59b8:	711a      	strb	r2, [r3, #4]
            = p_mtd_data->odb_trimming[sdd_id][obd_mode_idx][chopping_mode_idx];

        /* Restore SSE PC2 operations since no ACB accesses should take place
         * beyond this point. */
        ACE->PC2_CTRL = saved_pc2_ctrl;
    59ba:	f240 0300 	movw	r3, #0
    59be:	f2c4 0302 	movt	r3, #16386	; 0x4002
    59c2:	697a      	ldr	r2, [r7, #20]
    59c4:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8

        /* Set SDD resolution. */
        *dac_ctrl_reg_lut[sdd_id] = (uint32_t)resolution;
    59c8:	79fa      	ldrb	r2, [r7, #7]
    59ca:	f643 23bc 	movw	r3, #15036	; 0x3abc
    59ce:	f2c0 0301 	movt	r3, #1
    59d2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    59d6:	79ba      	ldrb	r2, [r7, #6]
    59d8:	601a      	str	r2, [r3, #0]

        /* Update SDD value through SSE_DACn_BYTES01. */
        *dac_ctrl_reg_lut[sdd_id] |= SDD_REG_SEL_MASK;
    59da:	79fa      	ldrb	r2, [r7, #7]
    59dc:	f643 23bc 	movw	r3, #15036	; 0x3abc
    59e0:	f2c0 0301 	movt	r3, #1
    59e4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    59e8:	79f9      	ldrb	r1, [r7, #7]
    59ea:	f643 23bc 	movw	r3, #15036	; 0x3abc
    59ee:	f2c0 0301 	movt	r3, #1
    59f2:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    59f6:	681b      	ldr	r3, [r3, #0]
    59f8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    59fc:	6013      	str	r3, [r2, #0]

        /* Synchronous or individual SDD update. */
        if ( INDIVIDUAL_UPDATE == sync_update )
    59fe:	793b      	ldrb	r3, [r7, #4]
    5a00:	2b00      	cmp	r3, #0
    5a02:	d115      	bne.n	5a30 <ACE_configure_sdd+0x170>
        {
            ACE->DAC_SYNC_CTRL &= ~dac_enable_masks_lut[sdd_id];
    5a04:	f240 0300 	movw	r3, #0
    5a08:	f2c4 0302 	movt	r3, #16386	; 0x4002
    5a0c:	f240 0200 	movw	r2, #0
    5a10:	f2c4 0202 	movt	r2, #16386	; 0x4002
    5a14:	6911      	ldr	r1, [r2, #16]
    5a16:	79f8      	ldrb	r0, [r7, #7]
    5a18:	f643 22c8 	movw	r2, #15048	; 0x3ac8
    5a1c:	f2c0 0201 	movt	r2, #1
    5a20:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
    5a24:	ea6f 0202 	mvn.w	r2, r2
    5a28:	ea01 0202 	and.w	r2, r1, r2
    5a2c:	611a      	str	r2, [r3, #16]
    5a2e:	e012      	b.n	5a56 <ACE_configure_sdd+0x196>
        }
        else
        {
            ACE->DAC_SYNC_CTRL |= dac_enable_masks_lut[sdd_id];
    5a30:	f240 0300 	movw	r3, #0
    5a34:	f2c4 0302 	movt	r3, #16386	; 0x4002
    5a38:	f240 0200 	movw	r2, #0
    5a3c:	f2c4 0202 	movt	r2, #16386	; 0x4002
    5a40:	6911      	ldr	r1, [r2, #16]
    5a42:	79f8      	ldrb	r0, [r7, #7]
    5a44:	f643 22c8 	movw	r2, #15048	; 0x3ac8
    5a48:	f2c0 0201 	movt	r2, #1
    5a4c:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
    5a50:	ea41 0202 	orr.w	r2, r1, r2
    5a54:	611a      	str	r2, [r3, #16]
        }
    }
}
    5a56:	f107 0718 	add.w	r7, r7, #24
    5a5a:	46bd      	mov	sp, r7
    5a5c:	bc90      	pop	{r4, r7}
    5a5e:	4770      	bx	lr

00005a60 <ACE_enable_sdd>:
 */
void ACE_enable_sdd
(
	sdd_id_t    sdd_id
)
{
    5a60:	b480      	push	{r7}
    5a62:	b083      	sub	sp, #12
    5a64:	af00      	add	r7, sp, #0
    5a66:	4603      	mov	r3, r0
    5a68:	71fb      	strb	r3, [r7, #7]
    ASSERT( sdd_id < NB_OF_SDD );
    5a6a:	79fb      	ldrb	r3, [r7, #7]
    5a6c:	2b02      	cmp	r3, #2
    5a6e:	d900      	bls.n	5a72 <ACE_enable_sdd+0x12>
    5a70:	be00      	bkpt	0x0000

    if ( sdd_id < NB_OF_SDD )
    5a72:	79fb      	ldrb	r3, [r7, #7]
    5a74:	2b02      	cmp	r3, #2
    5a76:	d811      	bhi.n	5a9c <ACE_enable_sdd+0x3c>
    {
        *dac_ctrl_reg_lut[sdd_id] |= SDD_ENABLE_MASK;
    5a78:	79fa      	ldrb	r2, [r7, #7]
    5a7a:	f643 23bc 	movw	r3, #15036	; 0x3abc
    5a7e:	f2c0 0301 	movt	r3, #1
    5a82:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    5a86:	79f9      	ldrb	r1, [r7, #7]
    5a88:	f643 23bc 	movw	r3, #15036	; 0x3abc
    5a8c:	f2c0 0301 	movt	r3, #1
    5a90:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    5a94:	681b      	ldr	r3, [r3, #0]
    5a96:	f043 0320 	orr.w	r3, r3, #32
    5a9a:	6013      	str	r3, [r2, #0]
    }
}
    5a9c:	f107 070c 	add.w	r7, r7, #12
    5aa0:	46bd      	mov	sp, r7
    5aa2:	bc80      	pop	{r7}
    5aa4:	4770      	bx	lr
    5aa6:	bf00      	nop

00005aa8 <ACE_disable_sdd>:
 */
void ACE_disable_sdd
(
	sdd_id_t    sdd_id
)
{
    5aa8:	b480      	push	{r7}
    5aaa:	b083      	sub	sp, #12
    5aac:	af00      	add	r7, sp, #0
    5aae:	4603      	mov	r3, r0
    5ab0:	71fb      	strb	r3, [r7, #7]
    ASSERT( sdd_id < NB_OF_SDD );
    5ab2:	79fb      	ldrb	r3, [r7, #7]
    5ab4:	2b02      	cmp	r3, #2
    5ab6:	d900      	bls.n	5aba <ACE_disable_sdd+0x12>
    5ab8:	be00      	bkpt	0x0000

    if ( sdd_id < NB_OF_SDD )
    5aba:	79fb      	ldrb	r3, [r7, #7]
    5abc:	2b02      	cmp	r3, #2
    5abe:	d811      	bhi.n	5ae4 <ACE_disable_sdd+0x3c>
    {
        *dac_ctrl_reg_lut[sdd_id] &= ~SDD_ENABLE_MASK;
    5ac0:	79fa      	ldrb	r2, [r7, #7]
    5ac2:	f643 23bc 	movw	r3, #15036	; 0x3abc
    5ac6:	f2c0 0301 	movt	r3, #1
    5aca:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    5ace:	79f9      	ldrb	r1, [r7, #7]
    5ad0:	f643 23bc 	movw	r3, #15036	; 0x3abc
    5ad4:	f2c0 0301 	movt	r3, #1
    5ad8:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    5adc:	681b      	ldr	r3, [r3, #0]
    5ade:	f023 0320 	bic.w	r3, r3, #32
    5ae2:	6013      	str	r3, [r2, #0]
    }
}
    5ae4:	f107 070c 	add.w	r7, r7, #12
    5ae8:	46bd      	mov	sp, r7
    5aea:	bc80      	pop	{r7}
    5aec:	4770      	bx	lr
    5aee:	bf00      	nop

00005af0 <ACE_set_sdd_value>:
void ACE_set_sdd_value
(
	sdd_id_t    sdd_id,
	uint32_t    sdd_value
)
{
    5af0:	b480      	push	{r7}
    5af2:	b083      	sub	sp, #12
    5af4:	af00      	add	r7, sp, #0
    5af6:	4603      	mov	r3, r0
    5af8:	6039      	str	r1, [r7, #0]
    5afa:	71fb      	strb	r3, [r7, #7]
    ASSERT( sdd_id < NB_OF_SDD );
    5afc:	79fb      	ldrb	r3, [r7, #7]
    5afe:	2b02      	cmp	r3, #2
    5b00:	d900      	bls.n	5b04 <ACE_set_sdd_value+0x14>
    5b02:	be00      	bkpt	0x0000

    if ( sdd_id < NB_OF_SDD )
    5b04:	79fb      	ldrb	r3, [r7, #7]
    5b06:	2b02      	cmp	r3, #2
    5b08:	d813      	bhi.n	5b32 <ACE_set_sdd_value+0x42>
    {
        *dac_byte2_reg_lut[sdd_id] = sdd_value >> 16;
    5b0a:	79fa      	ldrb	r2, [r7, #7]
    5b0c:	f643 23e0 	movw	r3, #15072	; 0x3ae0
    5b10:	f2c0 0301 	movt	r3, #1
    5b14:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5b18:	683a      	ldr	r2, [r7, #0]
    5b1a:	ea4f 4212 	mov.w	r2, r2, lsr #16
    5b1e:	601a      	str	r2, [r3, #0]
        *dac_byte01_reg_lut[sdd_id] = sdd_value;
    5b20:	79fa      	ldrb	r2, [r7, #7]
    5b22:	f643 23d4 	movw	r3, #15060	; 0x3ad4
    5b26:	f2c0 0301 	movt	r3, #1
    5b2a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5b2e:	683a      	ldr	r2, [r7, #0]
    5b30:	601a      	str	r2, [r3, #0]
    }
}
    5b32:	f107 070c 	add.w	r7, r7, #12
    5b36:	46bd      	mov	sp, r7
    5b38:	bc80      	pop	{r7}
    5b3a:	4770      	bx	lr

00005b3c <ACE_set_sdd_value_sync>:
(
    uint32_t sdd0_value,
    uint32_t sdd1_value,
    uint32_t sdd2_value
)
{
    5b3c:	b480      	push	{r7}
    5b3e:	b087      	sub	sp, #28
    5b40:	af00      	add	r7, sp, #0
    5b42:	60f8      	str	r0, [r7, #12]
    5b44:	60b9      	str	r1, [r7, #8]
    5b46:	607a      	str	r2, [r7, #4]
    uint32_t dac_sync_ctrl;

    dac_sync_ctrl = ACE->DAC_SYNC_CTRL;
    5b48:	f240 0300 	movw	r3, #0
    5b4c:	f2c4 0302 	movt	r3, #16386	; 0x4002
    5b50:	691b      	ldr	r3, [r3, #16]
    5b52:	617b      	str	r3, [r7, #20]

    if ( SDD_NO_UPDATE != sdd0_value )
    5b54:	68fb      	ldr	r3, [r7, #12]
    5b56:	f1b3 3fff 	cmp.w	r3, #4294967295
    5b5a:	d012      	beq.n	5b82 <ACE_set_sdd_value_sync+0x46>
    {
        ACE->DAC0_BYTE2 = sdd0_value >> 16;
    5b5c:	f240 0300 	movw	r3, #0
    5b60:	f2c4 0302 	movt	r3, #16386	; 0x4002
    5b64:	68fa      	ldr	r2, [r7, #12]
    5b66:	ea4f 4212 	mov.w	r2, r2, lsr #16
    5b6a:	66da      	str	r2, [r3, #108]	; 0x6c
        ACE->SSE_DAC0_BYTES01 = sdd0_value;
    5b6c:	f240 0300 	movw	r3, #0
    5b70:	f2c4 0302 	movt	r3, #16386	; 0x4002
    5b74:	68fa      	ldr	r2, [r7, #12]
    5b76:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
        dac_sync_ctrl |= DAC0_SYNC_UPDATE;
    5b7a:	697b      	ldr	r3, [r7, #20]
    5b7c:	f043 0301 	orr.w	r3, r3, #1
    5b80:	617b      	str	r3, [r7, #20]
    }

    if ( SDD_NO_UPDATE != sdd1_value )
    5b82:	68bb      	ldr	r3, [r7, #8]
    5b84:	f1b3 3fff 	cmp.w	r3, #4294967295
    5b88:	d013      	beq.n	5bb2 <ACE_set_sdd_value_sync+0x76>
    {
        ACE->DAC1_BYTE2 = sdd1_value >> 16;
    5b8a:	f240 0300 	movw	r3, #0
    5b8e:	f2c4 0302 	movt	r3, #16386	; 0x4002
    5b92:	68ba      	ldr	r2, [r7, #8]
    5b94:	ea4f 4212 	mov.w	r2, r2, lsr #16
    5b98:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
        ACE->SSE_DAC1_BYTES01 = sdd1_value;
    5b9c:	f240 0300 	movw	r3, #0
    5ba0:	f2c4 0302 	movt	r3, #16386	; 0x4002
    5ba4:	68ba      	ldr	r2, [r7, #8]
    5ba6:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
        dac_sync_ctrl |= DAC1_SYNC_UPDATE;
    5baa:	697b      	ldr	r3, [r7, #20]
    5bac:	f043 0302 	orr.w	r3, r3, #2
    5bb0:	617b      	str	r3, [r7, #20]
    }

    if ( SDD_NO_UPDATE != sdd2_value )
    5bb2:	687b      	ldr	r3, [r7, #4]
    5bb4:	f1b3 3fff 	cmp.w	r3, #4294967295
    5bb8:	d01c      	beq.n	5bf4 <ACE_set_sdd_value_sync+0xb8>
    {
        ACE->DAC2_BYTE2 = sdd2_value >> 16;
    5bba:	f240 0300 	movw	r3, #0
    5bbe:	f2c4 0302 	movt	r3, #16386	; 0x4002
    5bc2:	687a      	ldr	r2, [r7, #4]
    5bc4:	ea4f 4212 	mov.w	r2, r2, lsr #16
    5bc8:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
        ACE->DAC2_BYTE1 = sdd2_value >> 8;
    5bcc:	f240 0300 	movw	r3, #0
    5bd0:	f2c4 0302 	movt	r3, #16386	; 0x4002
    5bd4:	687a      	ldr	r2, [r7, #4]
    5bd6:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5bda:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
        ACE->SSE_DAC2_BYTES01 = sdd2_value;
    5bde:	f240 0300 	movw	r3, #0
    5be2:	f2c4 0302 	movt	r3, #16386	; 0x4002
    5be6:	687a      	ldr	r2, [r7, #4]
    5be8:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
        dac_sync_ctrl |= DAC2_SYNC_UPDATE;
    5bec:	697b      	ldr	r3, [r7, #20]
    5bee:	f043 0304 	orr.w	r3, r3, #4
    5bf2:	617b      	str	r3, [r7, #20]
    }

    ACE->DAC_SYNC_CTRL = dac_sync_ctrl;
    5bf4:	f240 0300 	movw	r3, #0
    5bf8:	f2c4 0302 	movt	r3, #16386	; 0x4002
    5bfc:	697a      	ldr	r2, [r7, #20]
    5bfe:	611a      	str	r2, [r3, #16]
}
    5c00:	f107 071c 	add.w	r7, r7, #28
    5c04:	46bd      	mov	sp, r7
    5c06:	bc80      	pop	{r7}
    5c08:	4770      	bx	lr
    5c0a:	bf00      	nop

00005c0c <ACE_set_comp_reference>:
void ACE_set_comp_reference
(
    comparator_id_t     comp_id,
    comp_reference_t    reference
)
{
    5c0c:	b480      	push	{r7}
    5c0e:	b087      	sub	sp, #28
    5c10:	af00      	add	r7, sp, #0
    5c12:	4602      	mov	r2, r0
    5c14:	460b      	mov	r3, r1
    5c16:	71fa      	strb	r2, [r7, #7]
    5c18:	71bb      	strb	r3, [r7, #6]
    uint8_t scb_id;
    uint32_t odd;

    odd = (uint32_t)comp_id & 0x01uL;
    5c1a:	79fb      	ldrb	r3, [r7, #7]
    5c1c:	f003 0301 	and.w	r3, r3, #1
    5c20:	613b      	str	r3, [r7, #16]

    ASSERT( comp_id < NB_OF_COMPARATORS );
    5c22:	79fb      	ldrb	r3, [r7, #7]
    5c24:	2b0b      	cmp	r3, #11
    5c26:	d900      	bls.n	5c2a <ACE_set_comp_reference+0x1e>
    5c28:	be00      	bkpt	0x0000
    ASSERT( reference < NB_OF_COMP_REF );
    5c2a:	79bb      	ldrb	r3, [r7, #6]
    5c2c:	2b03      	cmp	r3, #3
    5c2e:	d900      	bls.n	5c32 <ACE_set_comp_reference+0x26>
    5c30:	be00      	bkpt	0x0000
    ASSERT( odd );    /* Only Temperature block comparators have configurable reference input. */
    5c32:	693b      	ldr	r3, [r7, #16]
    5c34:	2b00      	cmp	r3, #0
    5c36:	d100      	bne.n	5c3a <ACE_set_comp_reference+0x2e>
    5c38:	be00      	bkpt	0x0000

    if ( (comp_id < NB_OF_COMPARATORS) && (reference < NB_OF_COMP_REF) && (odd) )
    5c3a:	79fb      	ldrb	r3, [r7, #7]
    5c3c:	2b0b      	cmp	r3, #11
    5c3e:	f200 80b8 	bhi.w	5db2 <ACE_set_comp_reference+0x1a6>
    5c42:	79bb      	ldrb	r3, [r7, #6]
    5c44:	2b03      	cmp	r3, #3
    5c46:	f200 80b4 	bhi.w	5db2 <ACE_set_comp_reference+0x1a6>
    5c4a:	693b      	ldr	r3, [r7, #16]
    5c4c:	2b00      	cmp	r3, #0
    5c4e:	f000 80b0 	beq.w	5db2 <ACE_set_comp_reference+0x1a6>
    {
        uint32_t saved_pc2_ctrl;

        scb_id = comp_id_2_scb_lut[comp_id];
    5c52:	79fa      	ldrb	r2, [r7, #7]
    5c54:	f643 23f0 	movw	r3, #15088	; 0x3af0
    5c58:	f2c0 0301 	movt	r3, #1
    5c5c:	5c9b      	ldrb	r3, [r3, r2]
    5c5e:	73fb      	strb	r3, [r7, #15]

        /* Pause the SSE PC2 while accesses to ACB from APB3 are taking place. */
        saved_pc2_ctrl = ACE->PC2_CTRL;
    5c60:	f240 0300 	movw	r3, #0
    5c64:	f2c4 0302 	movt	r3, #16386	; 0x4002
    5c68:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
    5c6c:	617b      	str	r3, [r7, #20]
        ACE->PC2_CTRL = 0u;
    5c6e:	f240 0300 	movw	r3, #0
    5c72:	f2c4 0302 	movt	r3, #16386	; 0x4002
    5c76:	f04f 0200 	mov.w	r2, #0
    5c7a:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8

        if ( ADC_IN_COMP_REF == reference )
    5c7e:	79bb      	ldrb	r3, [r7, #6]
    5c80:	2b03      	cmp	r3, #3
    5c82:	d146      	bne.n	5d12 <ACE_set_comp_reference+0x106>
        {
            ACE->ACB_DATA[scb_id].b10 &= (uint8_t)~B10_COMP_VREF_SW_MASK;
    5c84:	f240 0100 	movw	r1, #0
    5c88:	f2c4 0102 	movt	r1, #16386	; 0x4002
    5c8c:	7bf8      	ldrb	r0, [r7, #15]
    5c8e:	f240 0200 	movw	r2, #0
    5c92:	f2c4 0202 	movt	r2, #16386	; 0x4002
    5c96:	f897 c00f 	ldrb.w	ip, [r7, #15]
    5c9a:	4663      	mov	r3, ip
    5c9c:	ea4f 0343 	mov.w	r3, r3, lsl #1
    5ca0:	4463      	add	r3, ip
    5ca2:	ea4f 1303 	mov.w	r3, r3, lsl #4
    5ca6:	4413      	add	r3, r2
    5ca8:	f503 730a 	add.w	r3, r3, #552	; 0x228
    5cac:	791b      	ldrb	r3, [r3, #4]
    5cae:	b2db      	uxtb	r3, r3
    5cb0:	461a      	mov	r2, r3
    5cb2:	f002 02df 	and.w	r2, r2, #223	; 0xdf
    5cb6:	4603      	mov	r3, r0
    5cb8:	ea4f 0343 	mov.w	r3, r3, lsl #1
    5cbc:	4403      	add	r3, r0
    5cbe:	ea4f 1303 	mov.w	r3, r3, lsl #4
    5cc2:	440b      	add	r3, r1
    5cc4:	f503 730a 	add.w	r3, r3, #552	; 0x228
    5cc8:	711a      	strb	r2, [r3, #4]
            ACE->ACB_DATA[scb_id].b11 &= (uint8_t)~B11_DAC_MUXSEL_MASK;
    5cca:	f240 0100 	movw	r1, #0
    5cce:	f2c4 0102 	movt	r1, #16386	; 0x4002
    5cd2:	7bf8      	ldrb	r0, [r7, #15]
    5cd4:	f240 0200 	movw	r2, #0
    5cd8:	f2c4 0202 	movt	r2, #16386	; 0x4002
    5cdc:	f897 c00f 	ldrb.w	ip, [r7, #15]
    5ce0:	4663      	mov	r3, ip
    5ce2:	ea4f 0343 	mov.w	r3, r3, lsl #1
    5ce6:	4463      	add	r3, ip
    5ce8:	ea4f 1303 	mov.w	r3, r3, lsl #4
    5cec:	4413      	add	r3, r2
    5cee:	f503 730a 	add.w	r3, r3, #552	; 0x228
    5cf2:	7a1b      	ldrb	r3, [r3, #8]
    5cf4:	b2db      	uxtb	r3, r3
    5cf6:	461a      	mov	r2, r3
    5cf8:	f002 02fc 	and.w	r2, r2, #252	; 0xfc
    5cfc:	4603      	mov	r3, r0
    5cfe:	ea4f 0343 	mov.w	r3, r3, lsl #1
    5d02:	4403      	add	r3, r0
    5d04:	ea4f 1303 	mov.w	r3, r3, lsl #4
    5d08:	440b      	add	r3, r1
    5d0a:	f503 730a 	add.w	r3, r3, #552	; 0x228
    5d0e:	721a      	strb	r2, [r3, #8]
    5d10:	e048      	b.n	5da4 <ACE_set_comp_reference+0x198>
        }
        else
        {
            ACE->ACB_DATA[scb_id].b10 &= (uint8_t)~B10_COMP_VREF_SW_MASK;
    5d12:	f240 0100 	movw	r1, #0
    5d16:	f2c4 0102 	movt	r1, #16386	; 0x4002
    5d1a:	7bf8      	ldrb	r0, [r7, #15]
    5d1c:	f240 0200 	movw	r2, #0
    5d20:	f2c4 0202 	movt	r2, #16386	; 0x4002
    5d24:	f897 c00f 	ldrb.w	ip, [r7, #15]
    5d28:	4663      	mov	r3, ip
    5d2a:	ea4f 0343 	mov.w	r3, r3, lsl #1
    5d2e:	4463      	add	r3, ip
    5d30:	ea4f 1303 	mov.w	r3, r3, lsl #4
    5d34:	4413      	add	r3, r2
    5d36:	f503 730a 	add.w	r3, r3, #552	; 0x228
    5d3a:	791b      	ldrb	r3, [r3, #4]
    5d3c:	b2db      	uxtb	r3, r3
    5d3e:	461a      	mov	r2, r3
    5d40:	f002 02df 	and.w	r2, r2, #223	; 0xdf
    5d44:	4603      	mov	r3, r0
    5d46:	ea4f 0343 	mov.w	r3, r3, lsl #1
    5d4a:	4403      	add	r3, r0
    5d4c:	ea4f 1303 	mov.w	r3, r3, lsl #4
    5d50:	440b      	add	r3, r1
    5d52:	f503 730a 	add.w	r3, r3, #552	; 0x228
    5d56:	711a      	strb	r2, [r3, #4]
            ACE->ACB_DATA[scb_id].b11 = (ACE->ACB_DATA[scb_id].b11 & (uint8_t)~B11_DAC_MUXSEL_MASK) + (uint8_t)reference;
    5d58:	f240 0200 	movw	r2, #0
    5d5c:	f2c4 0202 	movt	r2, #16386	; 0x4002
    5d60:	7bf8      	ldrb	r0, [r7, #15]
    5d62:	f240 0100 	movw	r1, #0
    5d66:	f2c4 0102 	movt	r1, #16386	; 0x4002
    5d6a:	f897 c00f 	ldrb.w	ip, [r7, #15]
    5d6e:	4663      	mov	r3, ip
    5d70:	ea4f 0343 	mov.w	r3, r3, lsl #1
    5d74:	4463      	add	r3, ip
    5d76:	ea4f 1303 	mov.w	r3, r3, lsl #4
    5d7a:	440b      	add	r3, r1
    5d7c:	f503 730a 	add.w	r3, r3, #552	; 0x228
    5d80:	7a1b      	ldrb	r3, [r3, #8]
    5d82:	b2db      	uxtb	r3, r3
    5d84:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
    5d88:	79b9      	ldrb	r1, [r7, #6]
    5d8a:	440b      	add	r3, r1
    5d8c:	b2d9      	uxtb	r1, r3
    5d8e:	4603      	mov	r3, r0
    5d90:	ea4f 0343 	mov.w	r3, r3, lsl #1
    5d94:	4403      	add	r3, r0
    5d96:	ea4f 1303 	mov.w	r3, r3, lsl #4
    5d9a:	4413      	add	r3, r2
    5d9c:	f503 730a 	add.w	r3, r3, #552	; 0x228
    5da0:	460a      	mov	r2, r1
    5da2:	721a      	strb	r2, [r3, #8]
        }

        /* Restore SSE PC2 operations since no ACB accesses should take place
         * beyond this point. */
        ACE->PC2_CTRL = saved_pc2_ctrl;
    5da4:	f240 0300 	movw	r3, #0
    5da8:	f2c4 0302 	movt	r3, #16386	; 0x4002
    5dac:	697a      	ldr	r2, [r7, #20]
    5dae:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    }
}
    5db2:	f107 071c 	add.w	r7, r7, #28
    5db6:	46bd      	mov	sp, r7
    5db8:	bc80      	pop	{r7}
    5dba:	4770      	bx	lr

00005dbc <ACE_set_comp_hysteresis>:
void ACE_set_comp_hysteresis
(
	comparator_id_t     comp_id,
    comp_hysteresis_t   hysteresis
)
{
    5dbc:	b480      	push	{r7}
    5dbe:	b087      	sub	sp, #28
    5dc0:	af00      	add	r7, sp, #0
    5dc2:	4602      	mov	r2, r0
    5dc4:	460b      	mov	r3, r1
    5dc6:	71fa      	strb	r2, [r7, #7]
    5dc8:	71bb      	strb	r3, [r7, #6]
    uint8_t scb_id;

    ASSERT( comp_id < NB_OF_COMPARATORS );
    5dca:	79fb      	ldrb	r3, [r7, #7]
    5dcc:	2b0b      	cmp	r3, #11
    5dce:	d900      	bls.n	5dd2 <ACE_set_comp_hysteresis+0x16>
    5dd0:	be00      	bkpt	0x0000
    ASSERT( hysteresis < NB_OF_HYSTERESIS );
    5dd2:	79bb      	ldrb	r3, [r7, #6]
    5dd4:	2b03      	cmp	r3, #3
    5dd6:	d900      	bls.n	5dda <ACE_set_comp_hysteresis+0x1e>
    5dd8:	be00      	bkpt	0x0000

    if ( (comp_id < NB_OF_COMPARATORS) && (hysteresis < NB_OF_HYSTERESIS) )
    5dda:	79fb      	ldrb	r3, [r7, #7]
    5ddc:	2b0b      	cmp	r3, #11
    5dde:	d87b      	bhi.n	5ed8 <ACE_set_comp_hysteresis+0x11c>
    5de0:	79bb      	ldrb	r3, [r7, #6]
    5de2:	2b03      	cmp	r3, #3
    5de4:	d878      	bhi.n	5ed8 <ACE_set_comp_hysteresis+0x11c>
    {
        uint32_t odd;
        uint32_t saved_pc2_ctrl;

        scb_id = comp_id_2_scb_lut[comp_id];
    5de6:	79fa      	ldrb	r2, [r7, #7]
    5de8:	f643 23f0 	movw	r3, #15088	; 0x3af0
    5dec:	f2c0 0301 	movt	r3, #1
    5df0:	5c9b      	ldrb	r3, [r3, r2]
    5df2:	73fb      	strb	r3, [r7, #15]
        odd = (uint32_t)comp_id & 0x01uL;
    5df4:	79fb      	ldrb	r3, [r7, #7]
    5df6:	f003 0301 	and.w	r3, r3, #1
    5dfa:	613b      	str	r3, [r7, #16]

        /* Pause the SSE PC2 while accesses to ACB from APB3 are taking place. */
        saved_pc2_ctrl = ACE->PC2_CTRL;
    5dfc:	f240 0300 	movw	r3, #0
    5e00:	f2c4 0302 	movt	r3, #16386	; 0x4002
    5e04:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
    5e08:	617b      	str	r3, [r7, #20]
        ACE->PC2_CTRL = 0u;
    5e0a:	f240 0300 	movw	r3, #0
    5e0e:	f2c4 0302 	movt	r3, #16386	; 0x4002
    5e12:	f04f 0200 	mov.w	r2, #0
    5e16:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8

        if ( odd )
    5e1a:	693b      	ldr	r3, [r7, #16]
    5e1c:	2b00      	cmp	r3, #0
    5e1e:	d02a      	beq.n	5e76 <ACE_set_comp_hysteresis+0xba>
        {
            /* Temperature monitor block comparator. */
            ACE->ACB_DATA[scb_id].b10 = (ACE->ACB_DATA[scb_id].b10 & HYSTERESIS_MASK) | (uint8_t)((uint8_t)hysteresis << HYSTERESIS_SHIFT);
    5e20:	f240 0200 	movw	r2, #0
    5e24:	f2c4 0202 	movt	r2, #16386	; 0x4002
    5e28:	7bf8      	ldrb	r0, [r7, #15]
    5e2a:	f240 0100 	movw	r1, #0
    5e2e:	f2c4 0102 	movt	r1, #16386	; 0x4002
    5e32:	f897 c00f 	ldrb.w	ip, [r7, #15]
    5e36:	4663      	mov	r3, ip
    5e38:	ea4f 0343 	mov.w	r3, r3, lsl #1
    5e3c:	4463      	add	r3, ip
    5e3e:	ea4f 1303 	mov.w	r3, r3, lsl #4
    5e42:	440b      	add	r3, r1
    5e44:	f503 730a 	add.w	r3, r3, #552	; 0x228
    5e48:	791b      	ldrb	r3, [r3, #4]
    5e4a:	b2db      	uxtb	r3, r3
    5e4c:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    5e50:	79b9      	ldrb	r1, [r7, #6]
    5e52:	ea4f 1181 	mov.w	r1, r1, lsl #6
    5e56:	b2c9      	uxtb	r1, r1
    5e58:	ea43 0301 	orr.w	r3, r3, r1
    5e5c:	b2d9      	uxtb	r1, r3
    5e5e:	4603      	mov	r3, r0
    5e60:	ea4f 0343 	mov.w	r3, r3, lsl #1
    5e64:	4403      	add	r3, r0
    5e66:	ea4f 1303 	mov.w	r3, r3, lsl #4
    5e6a:	4413      	add	r3, r2
    5e6c:	f503 730a 	add.w	r3, r3, #552	; 0x228
    5e70:	460a      	mov	r2, r1
    5e72:	711a      	strb	r2, [r3, #4]
    5e74:	e029      	b.n	5eca <ACE_set_comp_hysteresis+0x10e>
        }
        else
        {
            /* Current monitor block comparator. */
            ACE->ACB_DATA[scb_id].b9 = (ACE->ACB_DATA[scb_id].b9 & HYSTERESIS_MASK) | (uint8_t)((uint8_t)hysteresis << HYSTERESIS_SHIFT);
    5e76:	f240 0200 	movw	r2, #0
    5e7a:	f2c4 0202 	movt	r2, #16386	; 0x4002
    5e7e:	7bf8      	ldrb	r0, [r7, #15]
    5e80:	f240 0100 	movw	r1, #0
    5e84:	f2c4 0102 	movt	r1, #16386	; 0x4002
    5e88:	f897 c00f 	ldrb.w	ip, [r7, #15]
    5e8c:	4663      	mov	r3, ip
    5e8e:	ea4f 0343 	mov.w	r3, r3, lsl #1
    5e92:	4463      	add	r3, ip
    5e94:	ea4f 1303 	mov.w	r3, r3, lsl #4
    5e98:	440b      	add	r3, r1
    5e9a:	f503 7308 	add.w	r3, r3, #544	; 0x220
    5e9e:	7a1b      	ldrb	r3, [r3, #8]
    5ea0:	b2db      	uxtb	r3, r3
    5ea2:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    5ea6:	79b9      	ldrb	r1, [r7, #6]
    5ea8:	ea4f 1181 	mov.w	r1, r1, lsl #6
    5eac:	b2c9      	uxtb	r1, r1
    5eae:	ea43 0301 	orr.w	r3, r3, r1
    5eb2:	b2d9      	uxtb	r1, r3
    5eb4:	4603      	mov	r3, r0
    5eb6:	ea4f 0343 	mov.w	r3, r3, lsl #1
    5eba:	4403      	add	r3, r0
    5ebc:	ea4f 1303 	mov.w	r3, r3, lsl #4
    5ec0:	4413      	add	r3, r2
    5ec2:	f503 7308 	add.w	r3, r3, #544	; 0x220
    5ec6:	460a      	mov	r2, r1
    5ec8:	721a      	strb	r2, [r3, #8]
        }

        /* Restore SSE PC2 operations since no ACB accesses should take place
         * beyond this point. */
        ACE->PC2_CTRL = saved_pc2_ctrl;
    5eca:	f240 0300 	movw	r3, #0
    5ece:	f2c4 0302 	movt	r3, #16386	; 0x4002
    5ed2:	697a      	ldr	r2, [r7, #20]
    5ed4:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    }
}
    5ed8:	f107 071c 	add.w	r7, r7, #28
    5edc:	46bd      	mov	sp, r7
    5ede:	bc80      	pop	{r7}
    5ee0:	4770      	bx	lr
    5ee2:	bf00      	nop

00005ee4 <ACE_enable_comp>:
 */
void ACE_enable_comp
(
	comparator_id_t comp_id
)
{
    5ee4:	b480      	push	{r7}
    5ee6:	b087      	sub	sp, #28
    5ee8:	af00      	add	r7, sp, #0
    5eea:	4603      	mov	r3, r0
    5eec:	71fb      	strb	r3, [r7, #7]
    uint8_t scb_id;

    ASSERT( comp_id < NB_OF_COMPARATORS );
    5eee:	79fb      	ldrb	r3, [r7, #7]
    5ef0:	2b0b      	cmp	r3, #11
    5ef2:	d900      	bls.n	5ef6 <ACE_enable_comp+0x12>
    5ef4:	be00      	bkpt	0x0000

    if ( comp_id < NB_OF_COMPARATORS )
    5ef6:	79fb      	ldrb	r3, [r7, #7]
    5ef8:	2b0b      	cmp	r3, #11
    5efa:	d86c      	bhi.n	5fd6 <ACE_enable_comp+0xf2>
    {
        uint32_t odd;
        uint32_t saved_pc2_ctrl;

        scb_id = comp_id_2_scb_lut[comp_id];
    5efc:	79fa      	ldrb	r2, [r7, #7]
    5efe:	f643 23f0 	movw	r3, #15088	; 0x3af0
    5f02:	f2c0 0301 	movt	r3, #1
    5f06:	5c9b      	ldrb	r3, [r3, r2]
    5f08:	73fb      	strb	r3, [r7, #15]
        odd = (uint32_t)comp_id & 0x01uL;
    5f0a:	79fb      	ldrb	r3, [r7, #7]
    5f0c:	f003 0301 	and.w	r3, r3, #1
    5f10:	613b      	str	r3, [r7, #16]

        /* Pause the SSE PC2 while accesses to ACB from APB3 are taking place. */
        saved_pc2_ctrl = ACE->PC2_CTRL;
    5f12:	f240 0300 	movw	r3, #0
    5f16:	f2c4 0302 	movt	r3, #16386	; 0x4002
    5f1a:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
    5f1e:	617b      	str	r3, [r7, #20]
        ACE->PC2_CTRL = 0u;
    5f20:	f240 0300 	movw	r3, #0
    5f24:	f2c4 0302 	movt	r3, #16386	; 0x4002
    5f28:	f04f 0200 	mov.w	r2, #0
    5f2c:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8

        if ( odd )
    5f30:	693b      	ldr	r3, [r7, #16]
    5f32:	2b00      	cmp	r3, #0
    5f34:	d024      	beq.n	5f80 <ACE_enable_comp+0x9c>
        {
            /* Temperature monitor block comparator. */
            ACE->ACB_DATA[scb_id].b10 |= COMPARATOR_ENABLE_MASK;
    5f36:	f240 0200 	movw	r2, #0
    5f3a:	f2c4 0202 	movt	r2, #16386	; 0x4002
    5f3e:	7bf8      	ldrb	r0, [r7, #15]
    5f40:	f240 0100 	movw	r1, #0
    5f44:	f2c4 0102 	movt	r1, #16386	; 0x4002
    5f48:	f897 c00f 	ldrb.w	ip, [r7, #15]
    5f4c:	4663      	mov	r3, ip
    5f4e:	ea4f 0343 	mov.w	r3, r3, lsl #1
    5f52:	4463      	add	r3, ip
    5f54:	ea4f 1303 	mov.w	r3, r3, lsl #4
    5f58:	440b      	add	r3, r1
    5f5a:	f503 730a 	add.w	r3, r3, #552	; 0x228
    5f5e:	791b      	ldrb	r3, [r3, #4]
    5f60:	b2db      	uxtb	r3, r3
    5f62:	f043 0310 	orr.w	r3, r3, #16
    5f66:	b2d9      	uxtb	r1, r3
    5f68:	4603      	mov	r3, r0
    5f6a:	ea4f 0343 	mov.w	r3, r3, lsl #1
    5f6e:	4403      	add	r3, r0
    5f70:	ea4f 1303 	mov.w	r3, r3, lsl #4
    5f74:	4413      	add	r3, r2
    5f76:	f503 730a 	add.w	r3, r3, #552	; 0x228
    5f7a:	460a      	mov	r2, r1
    5f7c:	711a      	strb	r2, [r3, #4]
    5f7e:	e023      	b.n	5fc8 <ACE_enable_comp+0xe4>
        }
        else
        {
            /* Current monitor block comparator. */
            ACE->ACB_DATA[scb_id].b9 |= COMPARATOR_ENABLE_MASK;
    5f80:	f240 0200 	movw	r2, #0
    5f84:	f2c4 0202 	movt	r2, #16386	; 0x4002
    5f88:	7bf8      	ldrb	r0, [r7, #15]
    5f8a:	f240 0100 	movw	r1, #0
    5f8e:	f2c4 0102 	movt	r1, #16386	; 0x4002
    5f92:	f897 c00f 	ldrb.w	ip, [r7, #15]
    5f96:	4663      	mov	r3, ip
    5f98:	ea4f 0343 	mov.w	r3, r3, lsl #1
    5f9c:	4463      	add	r3, ip
    5f9e:	ea4f 1303 	mov.w	r3, r3, lsl #4
    5fa2:	440b      	add	r3, r1
    5fa4:	f503 7308 	add.w	r3, r3, #544	; 0x220
    5fa8:	7a1b      	ldrb	r3, [r3, #8]
    5faa:	b2db      	uxtb	r3, r3
    5fac:	f043 0310 	orr.w	r3, r3, #16
    5fb0:	b2d9      	uxtb	r1, r3
    5fb2:	4603      	mov	r3, r0
    5fb4:	ea4f 0343 	mov.w	r3, r3, lsl #1
    5fb8:	4403      	add	r3, r0
    5fba:	ea4f 1303 	mov.w	r3, r3, lsl #4
    5fbe:	4413      	add	r3, r2
    5fc0:	f503 7308 	add.w	r3, r3, #544	; 0x220
    5fc4:	460a      	mov	r2, r1
    5fc6:	721a      	strb	r2, [r3, #8]
        }

        /* Restore SSE PC2 operations since no ACB accesses should take place
         * beyond this point. */
        ACE->PC2_CTRL = saved_pc2_ctrl;
    5fc8:	f240 0300 	movw	r3, #0
    5fcc:	f2c4 0302 	movt	r3, #16386	; 0x4002
    5fd0:	697a      	ldr	r2, [r7, #20]
    5fd2:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    }
}
    5fd6:	f107 071c 	add.w	r7, r7, #28
    5fda:	46bd      	mov	sp, r7
    5fdc:	bc80      	pop	{r7}
    5fde:	4770      	bx	lr

00005fe0 <ACE_disable_comp>:
 */
void ACE_disable_comp
(
	comparator_id_t comp_id
)
{
    5fe0:	b480      	push	{r7}
    5fe2:	b087      	sub	sp, #28
    5fe4:	af00      	add	r7, sp, #0
    5fe6:	4603      	mov	r3, r0
    5fe8:	71fb      	strb	r3, [r7, #7]
    uint8_t scb_id;

    ASSERT( comp_id < NB_OF_COMPARATORS );
    5fea:	79fb      	ldrb	r3, [r7, #7]
    5fec:	2b0b      	cmp	r3, #11
    5fee:	d900      	bls.n	5ff2 <ACE_disable_comp+0x12>
    5ff0:	be00      	bkpt	0x0000

    if ( comp_id < NB_OF_COMPARATORS )
    5ff2:	79fb      	ldrb	r3, [r7, #7]
    5ff4:	2b0b      	cmp	r3, #11
    5ff6:	d86a      	bhi.n	60ce <ACE_disable_comp+0xee>
    {
        uint32_t odd;
        uint32_t saved_pc2_ctrl;

        scb_id = comp_id_2_scb_lut[comp_id];
    5ff8:	79fa      	ldrb	r2, [r7, #7]
    5ffa:	f643 23f0 	movw	r3, #15088	; 0x3af0
    5ffe:	f2c0 0301 	movt	r3, #1
    6002:	5c9b      	ldrb	r3, [r3, r2]
    6004:	73fb      	strb	r3, [r7, #15]
        odd = (uint32_t)comp_id & 0x01uL;
    6006:	79fb      	ldrb	r3, [r7, #7]
    6008:	f003 0301 	and.w	r3, r3, #1
    600c:	613b      	str	r3, [r7, #16]

        /* Pause the SSE PC2 while accesses to ACB from APB3 are taking place. */
        saved_pc2_ctrl = ACE->PC2_CTRL;
    600e:	f240 0300 	movw	r3, #0
    6012:	f2c4 0302 	movt	r3, #16386	; 0x4002
    6016:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
    601a:	617b      	str	r3, [r7, #20]
        ACE->PC2_CTRL = 0u;
    601c:	f240 0300 	movw	r3, #0
    6020:	f2c4 0302 	movt	r3, #16386	; 0x4002
    6024:	f04f 0200 	mov.w	r2, #0
    6028:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8

        if ( odd )
    602c:	693b      	ldr	r3, [r7, #16]
    602e:	2b00      	cmp	r3, #0
    6030:	d023      	beq.n	607a <ACE_disable_comp+0x9a>
        {
            /* Temperature monitor block comparator. */
            ACE->ACB_DATA[scb_id].b10 &= (uint8_t)~COMPARATOR_ENABLE_MASK;
    6032:	f240 0100 	movw	r1, #0
    6036:	f2c4 0102 	movt	r1, #16386	; 0x4002
    603a:	7bf8      	ldrb	r0, [r7, #15]
    603c:	f240 0200 	movw	r2, #0
    6040:	f2c4 0202 	movt	r2, #16386	; 0x4002
    6044:	f897 c00f 	ldrb.w	ip, [r7, #15]
    6048:	4663      	mov	r3, ip
    604a:	ea4f 0343 	mov.w	r3, r3, lsl #1
    604e:	4463      	add	r3, ip
    6050:	ea4f 1303 	mov.w	r3, r3, lsl #4
    6054:	4413      	add	r3, r2
    6056:	f503 730a 	add.w	r3, r3, #552	; 0x228
    605a:	791b      	ldrb	r3, [r3, #4]
    605c:	b2db      	uxtb	r3, r3
    605e:	461a      	mov	r2, r3
    6060:	f002 02ef 	and.w	r2, r2, #239	; 0xef
    6064:	4603      	mov	r3, r0
    6066:	ea4f 0343 	mov.w	r3, r3, lsl #1
    606a:	4403      	add	r3, r0
    606c:	ea4f 1303 	mov.w	r3, r3, lsl #4
    6070:	440b      	add	r3, r1
    6072:	f503 730a 	add.w	r3, r3, #552	; 0x228
    6076:	711a      	strb	r2, [r3, #4]
    6078:	e022      	b.n	60c0 <ACE_disable_comp+0xe0>
        }
        else
        {
            /* Current monitor block comparator. */
            ACE->ACB_DATA[scb_id].b9 &= (uint8_t)~COMPARATOR_ENABLE_MASK;
    607a:	f240 0100 	movw	r1, #0
    607e:	f2c4 0102 	movt	r1, #16386	; 0x4002
    6082:	7bf8      	ldrb	r0, [r7, #15]
    6084:	f240 0200 	movw	r2, #0
    6088:	f2c4 0202 	movt	r2, #16386	; 0x4002
    608c:	f897 c00f 	ldrb.w	ip, [r7, #15]
    6090:	4663      	mov	r3, ip
    6092:	ea4f 0343 	mov.w	r3, r3, lsl #1
    6096:	4463      	add	r3, ip
    6098:	ea4f 1303 	mov.w	r3, r3, lsl #4
    609c:	4413      	add	r3, r2
    609e:	f503 7308 	add.w	r3, r3, #544	; 0x220
    60a2:	7a1b      	ldrb	r3, [r3, #8]
    60a4:	b2db      	uxtb	r3, r3
    60a6:	461a      	mov	r2, r3
    60a8:	f002 02ef 	and.w	r2, r2, #239	; 0xef
    60ac:	4603      	mov	r3, r0
    60ae:	ea4f 0343 	mov.w	r3, r3, lsl #1
    60b2:	4403      	add	r3, r0
    60b4:	ea4f 1303 	mov.w	r3, r3, lsl #4
    60b8:	440b      	add	r3, r1
    60ba:	f503 7308 	add.w	r3, r3, #544	; 0x220
    60be:	721a      	strb	r2, [r3, #8]
        }

        /* Restore SSE PC2 operations since no ACB accesses should take place
         * beyond this point. */
        ACE->PC2_CTRL = saved_pc2_ctrl;
    60c0:	f240 0300 	movw	r3, #0
    60c4:	f2c4 0302 	movt	r3, #16386	; 0x4002
    60c8:	697a      	ldr	r2, [r7, #20]
    60ca:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    }
}
    60ce:	f107 071c 	add.w	r7, r7, #28
    60d2:	46bd      	mov	sp, r7
    60d4:	bc80      	pop	{r7}
    60d6:	4770      	bx	lr

000060d8 <ACE_enable_comp_rise_irq>:
 */
void ACE_enable_comp_rise_irq
(
	comparator_id_t comp_id
)
{
    60d8:	b480      	push	{r7}
    60da:	b083      	sub	sp, #12
    60dc:	af00      	add	r7, sp, #0
    60de:	4603      	mov	r3, r0
    60e0:	71fb      	strb	r3, [r7, #7]
    ASSERT( comp_id < NB_OF_COMPARATORS );
    60e2:	79fb      	ldrb	r3, [r7, #7]
    60e4:	2b0b      	cmp	r3, #11
    60e6:	d900      	bls.n	60ea <ACE_enable_comp_rise_irq+0x12>
    60e8:	be00      	bkpt	0x0000

    ACE->COMP_IRQ_EN |= (FIRST_RISE_IRQ_MASK << (uint32_t)comp_id);
    60ea:	f240 0300 	movw	r3, #0
    60ee:	f2c4 0302 	movt	r3, #16386	; 0x4002
    60f2:	f240 0200 	movw	r2, #0
    60f6:	f2c4 0202 	movt	r2, #16386	; 0x4002
    60fa:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    60fe:	f102 020c 	add.w	r2, r2, #12
    6102:	6811      	ldr	r1, [r2, #0]
    6104:	79fa      	ldrb	r2, [r7, #7]
    6106:	f44f 6000 	mov.w	r0, #2048	; 0x800
    610a:	fa00 f202 	lsl.w	r2, r0, r2
    610e:	ea41 0202 	orr.w	r2, r1, r2
    6112:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    6116:	f103 030c 	add.w	r3, r3, #12
    611a:	601a      	str	r2, [r3, #0]
}
    611c:	f107 070c 	add.w	r7, r7, #12
    6120:	46bd      	mov	sp, r7
    6122:	bc80      	pop	{r7}
    6124:	4770      	bx	lr
    6126:	bf00      	nop

00006128 <ACE_disable_comp_rise_irq>:
 */
void ACE_disable_comp_rise_irq
(
	comparator_id_t comp_id
)
{
    6128:	b480      	push	{r7}
    612a:	b083      	sub	sp, #12
    612c:	af00      	add	r7, sp, #0
    612e:	4603      	mov	r3, r0
    6130:	71fb      	strb	r3, [r7, #7]
    ASSERT( comp_id < NB_OF_COMPARATORS );
    6132:	79fb      	ldrb	r3, [r7, #7]
    6134:	2b0b      	cmp	r3, #11
    6136:	d900      	bls.n	613a <ACE_disable_comp_rise_irq+0x12>
    6138:	be00      	bkpt	0x0000

    ACE->COMP_IRQ_EN &= ~(FIRST_RISE_IRQ_MASK << (uint32_t)comp_id);
    613a:	f240 0300 	movw	r3, #0
    613e:	f2c4 0302 	movt	r3, #16386	; 0x4002
    6142:	f240 0200 	movw	r2, #0
    6146:	f2c4 0202 	movt	r2, #16386	; 0x4002
    614a:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    614e:	f102 020c 	add.w	r2, r2, #12
    6152:	6811      	ldr	r1, [r2, #0]
    6154:	79fa      	ldrb	r2, [r7, #7]
    6156:	f44f 6000 	mov.w	r0, #2048	; 0x800
    615a:	fa00 f202 	lsl.w	r2, r0, r2
    615e:	ea6f 0202 	mvn.w	r2, r2
    6162:	ea01 0202 	and.w	r2, r1, r2
    6166:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    616a:	f103 030c 	add.w	r3, r3, #12
    616e:	601a      	str	r2, [r3, #0]
}
    6170:	f107 070c 	add.w	r7, r7, #12
    6174:	46bd      	mov	sp, r7
    6176:	bc80      	pop	{r7}
    6178:	4770      	bx	lr
    617a:	bf00      	nop

0000617c <ACE_clear_comp_rise_irq>:
 */
void ACE_clear_comp_rise_irq
(
	comparator_id_t comp_id
)
{
    617c:	b480      	push	{r7}
    617e:	b083      	sub	sp, #12
    6180:	af00      	add	r7, sp, #0
    6182:	4603      	mov	r3, r0
    6184:	71fb      	strb	r3, [r7, #7]
    ASSERT( comp_id < NB_OF_COMPARATORS );
    6186:	79fb      	ldrb	r3, [r7, #7]
    6188:	2b0b      	cmp	r3, #11
    618a:	d900      	bls.n	618e <ACE_clear_comp_rise_irq+0x12>
    618c:	be00      	bkpt	0x0000

    ACE->COMP_IRQ_CLR |= (FIRST_RISE_IRQ_MASK << (uint32_t)comp_id);
    618e:	f240 0300 	movw	r3, #0
    6192:	f2c4 0302 	movt	r3, #16386	; 0x4002
    6196:	f240 0200 	movw	r2, #0
    619a:	f2c4 0202 	movt	r2, #16386	; 0x4002
    619e:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    61a2:	f102 0214 	add.w	r2, r2, #20
    61a6:	6811      	ldr	r1, [r2, #0]
    61a8:	79fa      	ldrb	r2, [r7, #7]
    61aa:	f44f 6000 	mov.w	r0, #2048	; 0x800
    61ae:	fa00 f202 	lsl.w	r2, r0, r2
    61b2:	ea41 0202 	orr.w	r2, r1, r2
    61b6:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    61ba:	f103 0314 	add.w	r3, r3, #20
    61be:	601a      	str	r2, [r3, #0]
}
    61c0:	f107 070c 	add.w	r7, r7, #12
    61c4:	46bd      	mov	sp, r7
    61c6:	bc80      	pop	{r7}
    61c8:	4770      	bx	lr
    61ca:	bf00      	nop

000061cc <ACE_enable_comp_fall_irq>:
 */
void ACE_enable_comp_fall_irq
(
	comparator_id_t comp_id
)
{
    61cc:	b480      	push	{r7}
    61ce:	b083      	sub	sp, #12
    61d0:	af00      	add	r7, sp, #0
    61d2:	4603      	mov	r3, r0
    61d4:	71fb      	strb	r3, [r7, #7]
    ASSERT( comp_id < NB_OF_COMPARATORS );
    61d6:	79fb      	ldrb	r3, [r7, #7]
    61d8:	2b0b      	cmp	r3, #11
    61da:	d900      	bls.n	61de <ACE_enable_comp_fall_irq+0x12>
    61dc:	be00      	bkpt	0x0000

    ACE->COMP_IRQ_EN |= (FIRST_FALL_IRQ_MASK << (uint32_t)comp_id);
    61de:	f240 0300 	movw	r3, #0
    61e2:	f2c4 0302 	movt	r3, #16386	; 0x4002
    61e6:	f240 0200 	movw	r2, #0
    61ea:	f2c4 0202 	movt	r2, #16386	; 0x4002
    61ee:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    61f2:	f102 020c 	add.w	r2, r2, #12
    61f6:	6811      	ldr	r1, [r2, #0]
    61f8:	79fa      	ldrb	r2, [r7, #7]
    61fa:	f04f 0001 	mov.w	r0, #1
    61fe:	fa00 f202 	lsl.w	r2, r0, r2
    6202:	ea41 0202 	orr.w	r2, r1, r2
    6206:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    620a:	f103 030c 	add.w	r3, r3, #12
    620e:	601a      	str	r2, [r3, #0]
}
    6210:	f107 070c 	add.w	r7, r7, #12
    6214:	46bd      	mov	sp, r7
    6216:	bc80      	pop	{r7}
    6218:	4770      	bx	lr
    621a:	bf00      	nop

0000621c <ACE_disable_comp_fall_irq>:
 */
void ACE_disable_comp_fall_irq
(
	comparator_id_t comp_id
)
{
    621c:	b480      	push	{r7}
    621e:	b083      	sub	sp, #12
    6220:	af00      	add	r7, sp, #0
    6222:	4603      	mov	r3, r0
    6224:	71fb      	strb	r3, [r7, #7]
    ASSERT( comp_id < NB_OF_COMPARATORS );
    6226:	79fb      	ldrb	r3, [r7, #7]
    6228:	2b0b      	cmp	r3, #11
    622a:	d900      	bls.n	622e <ACE_disable_comp_fall_irq+0x12>
    622c:	be00      	bkpt	0x0000

    ACE->COMP_IRQ_EN &= ~(FIRST_FALL_IRQ_MASK << (uint32_t)comp_id);
    622e:	f240 0300 	movw	r3, #0
    6232:	f2c4 0302 	movt	r3, #16386	; 0x4002
    6236:	f240 0200 	movw	r2, #0
    623a:	f2c4 0202 	movt	r2, #16386	; 0x4002
    623e:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    6242:	f102 020c 	add.w	r2, r2, #12
    6246:	6811      	ldr	r1, [r2, #0]
    6248:	79fa      	ldrb	r2, [r7, #7]
    624a:	f04f 0001 	mov.w	r0, #1
    624e:	fa00 f202 	lsl.w	r2, r0, r2
    6252:	ea6f 0202 	mvn.w	r2, r2
    6256:	ea01 0202 	and.w	r2, r1, r2
    625a:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    625e:	f103 030c 	add.w	r3, r3, #12
    6262:	601a      	str	r2, [r3, #0]
}
    6264:	f107 070c 	add.w	r7, r7, #12
    6268:	46bd      	mov	sp, r7
    626a:	bc80      	pop	{r7}
    626c:	4770      	bx	lr
    626e:	bf00      	nop

00006270 <ACE_clear_comp_fall_irq>:
 */
void ACE_clear_comp_fall_irq
(
	comparator_id_t comp_id
)
{
    6270:	b480      	push	{r7}
    6272:	b083      	sub	sp, #12
    6274:	af00      	add	r7, sp, #0
    6276:	4603      	mov	r3, r0
    6278:	71fb      	strb	r3, [r7, #7]
    ASSERT( comp_id < NB_OF_COMPARATORS );
    627a:	79fb      	ldrb	r3, [r7, #7]
    627c:	2b0b      	cmp	r3, #11
    627e:	d900      	bls.n	6282 <ACE_clear_comp_fall_irq+0x12>
    6280:	be00      	bkpt	0x0000

    ACE->COMP_IRQ_CLR |= (FIRST_FALL_IRQ_MASK << (uint32_t)comp_id);
    6282:	f240 0300 	movw	r3, #0
    6286:	f2c4 0302 	movt	r3, #16386	; 0x4002
    628a:	f240 0200 	movw	r2, #0
    628e:	f2c4 0202 	movt	r2, #16386	; 0x4002
    6292:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    6296:	f102 0214 	add.w	r2, r2, #20
    629a:	6811      	ldr	r1, [r2, #0]
    629c:	79fa      	ldrb	r2, [r7, #7]
    629e:	f04f 0001 	mov.w	r0, #1
    62a2:	fa00 f202 	lsl.w	r2, r0, r2
    62a6:	ea41 0202 	orr.w	r2, r1, r2
    62aa:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    62ae:	f103 0314 	add.w	r3, r3, #20
    62b2:	601a      	str	r2, [r3, #0]
}
    62b4:	f107 070c 	add.w	r7, r7, #12
    62b8:	46bd      	mov	sp, r7
    62ba:	bc80      	pop	{r7}
    62bc:	4770      	bx	lr
    62be:	bf00      	nop

000062c0 <ACE_get_comp_status>:

/*-------------------------------------------------------------------------*//**
 * Returns the raw analog quad comparator status.
 */
uint32_t ACE_get_comp_status( void )
{
    62c0:	b480      	push	{r7}
    62c2:	af00      	add	r7, sp, #0
    return ACE->COMP_IRQ;
    62c4:	f240 0300 	movw	r3, #0
    62c8:	f2c4 0302 	movt	r3, #16386	; 0x4002
    62cc:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    62d0:	f103 0310 	add.w	r3, r3, #16
    62d4:	681b      	ldr	r3, [r3, #0]
}
    62d6:	4618      	mov	r0, r3
    62d8:	46bd      	mov	sp, r7
    62da:	bc80      	pop	{r7}
    62dc:	4770      	bx	lr
    62de:	bf00      	nop

000062e0 <ACE_get_channel_count>:
uint32_t
ACE_get_channel_count
(
    void
)
{
    62e0:	b480      	push	{r7}
    62e2:	af00      	add	r7, sp, #0
    return (uint32_t)ACE_NB_OF_INPUT_CHANNELS;
    62e4:	f04f 0303 	mov.w	r3, #3
}
    62e8:	4618      	mov	r0, r3
    62ea:	46bd      	mov	sp, r7
    62ec:	bc80      	pop	{r7}
    62ee:	4770      	bx	lr

000062f0 <ACE_get_first_channel>:
ace_channel_handle_t
ACE_get_first_channel
(
    void
)
{
    62f0:	b480      	push	{r7}
    62f2:	b083      	sub	sp, #12
    62f4:	af00      	add	r7, sp, #0
    ace_channel_handle_t channel_handle;

    channel_handle = (ace_channel_handle_t)0;
    62f6:	f04f 0300 	mov.w	r3, #0
    62fa:	71fb      	strb	r3, [r7, #7]

    return channel_handle;
    62fc:	79fb      	ldrb	r3, [r7, #7]
}
    62fe:	4618      	mov	r0, r3
    6300:	f107 070c 	add.w	r7, r7, #12
    6304:	46bd      	mov	sp, r7
    6306:	bc80      	pop	{r7}
    6308:	4770      	bx	lr
    630a:	bf00      	nop

0000630c <ACE_get_next_channel>:
ace_channel_handle_t
ACE_get_next_channel
(
    ace_channel_handle_t channel_handle
)
{
    630c:	b480      	push	{r7}
    630e:	b083      	sub	sp, #12
    6310:	af00      	add	r7, sp, #0
    6312:	4603      	mov	r3, r0
    6314:	71fb      	strb	r3, [r7, #7]
    ++channel_handle;
    6316:	79fb      	ldrb	r3, [r7, #7]
    6318:	f103 0301 	add.w	r3, r3, #1
    631c:	71fb      	strb	r3, [r7, #7]

    if ( channel_handle >= NB_OF_ACE_CHANNEL_HANDLES )
    631e:	79fb      	ldrb	r3, [r7, #7]
    6320:	2b02      	cmp	r3, #2
    6322:	d902      	bls.n	632a <ACE_get_next_channel+0x1e>
    {
         channel_handle = (ace_channel_handle_t)0;
    6324:	f04f 0300 	mov.w	r3, #0
    6328:	71fb      	strb	r3, [r7, #7]
    }

    return channel_handle;
    632a:	79fb      	ldrb	r3, [r7, #7]
}
    632c:	4618      	mov	r0, r3
    632e:	f107 070c 	add.w	r7, r7, #12
    6332:	46bd      	mov	sp, r7
    6334:	bc80      	pop	{r7}
    6336:	4770      	bx	lr

00006338 <ACE_get_channel_handle>:
ace_channel_handle_t
ACE_get_channel_handle
(
    const uint8_t * p_sz_channel_name
)
{
    6338:	b580      	push	{r7, lr}
    633a:	b084      	sub	sp, #16
    633c:	af00      	add	r7, sp, #0
    633e:	6078      	str	r0, [r7, #4]
    uint16_t channel_idx;
    ace_channel_handle_t channel_handle = INVALID_CHANNEL_HANDLE;
    6340:	f04f 0303 	mov.w	r3, #3
    6344:	72fb      	strb	r3, [r7, #11]

    for ( channel_idx = 0u;  channel_idx < (uint16_t)ACE_NB_OF_INPUT_CHANNELS; ++channel_idx )
    6346:	f04f 0300 	mov.w	r3, #0
    634a:	813b      	strh	r3, [r7, #8]
    634c:	e025      	b.n	639a <ACE_get_channel_handle+0x62>
    {
        if ( g_ace_channel_desc_table[channel_idx].p_sz_channel_name != 0 )
    634e:	893a      	ldrh	r2, [r7, #8]
    6350:	f240 0354 	movw	r3, #84	; 0x54
    6354:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6358:	ea4f 1202 	mov.w	r2, r2, lsl #4
    635c:	4413      	add	r3, r2
    635e:	681b      	ldr	r3, [r3, #0]
    6360:	2b00      	cmp	r3, #0
    6362:	d016      	beq.n	6392 <ACE_get_channel_handle+0x5a>
        {
            int32_t diff;
            diff = strncmp( (const char*)p_sz_channel_name, (const char*)g_ace_channel_desc_table[channel_idx].p_sz_channel_name, MAX_CHANNEL_NAME_LENGTH );
    6364:	893a      	ldrh	r2, [r7, #8]
    6366:	f240 0354 	movw	r3, #84	; 0x54
    636a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    636e:	ea4f 1202 	mov.w	r2, r2, lsl #4
    6372:	4413      	add	r3, r2
    6374:	681b      	ldr	r3, [r3, #0]
    6376:	6878      	ldr	r0, [r7, #4]
    6378:	4619      	mov	r1, r3
    637a:	f04f 0214 	mov.w	r2, #20
    637e:	f00b fec1 	bl	12104 <strncmp>
    6382:	4603      	mov	r3, r0
    6384:	60fb      	str	r3, [r7, #12]
            if ( 0 == diff )
    6386:	68fb      	ldr	r3, [r7, #12]
    6388:	2b00      	cmp	r3, #0
    638a:	d102      	bne.n	6392 <ACE_get_channel_handle+0x5a>
            {
                /* channel name found. */
                channel_handle = (ace_channel_handle_t)channel_idx;
    638c:	893b      	ldrh	r3, [r7, #8]
    638e:	72fb      	strb	r3, [r7, #11]
                break;
    6390:	e006      	b.n	63a0 <ACE_get_channel_handle+0x68>
)
{
    uint16_t channel_idx;
    ace_channel_handle_t channel_handle = INVALID_CHANNEL_HANDLE;

    for ( channel_idx = 0u;  channel_idx < (uint16_t)ACE_NB_OF_INPUT_CHANNELS; ++channel_idx )
    6392:	893b      	ldrh	r3, [r7, #8]
    6394:	f103 0301 	add.w	r3, r3, #1
    6398:	813b      	strh	r3, [r7, #8]
    639a:	893b      	ldrh	r3, [r7, #8]
    639c:	2b02      	cmp	r3, #2
    639e:	d9d6      	bls.n	634e <ACE_get_channel_handle+0x16>
                channel_handle = (ace_channel_handle_t)channel_idx;
                break;
            }
        }
    }
    return channel_handle;
    63a0:	7afb      	ldrb	r3, [r7, #11]
}
    63a2:	4618      	mov	r0, r3
    63a4:	f107 0710 	add.w	r7, r7, #16
    63a8:	46bd      	mov	sp, r7
    63aa:	bd80      	pop	{r7, pc}

000063ac <ACE_get_input_channel_handle>:
ace_channel_handle_t
ACE_get_input_channel_handle
(
    adc_channel_id_t    channel_id
)
{
    63ac:	b480      	push	{r7}
    63ae:	b085      	sub	sp, #20
    63b0:	af00      	add	r7, sp, #0
    63b2:	4603      	mov	r3, r0
    63b4:	71fb      	strb	r3, [r7, #7]
    uint16_t channel_idx;
    ace_channel_handle_t channel_handle = INVALID_CHANNEL_HANDLE;
    63b6:	f04f 0303 	mov.w	r3, #3
    63ba:	73fb      	strb	r3, [r7, #15]

    for ( channel_idx = 0u;  channel_idx < (uint16_t)ACE_NB_OF_INPUT_CHANNELS; ++channel_idx )
    63bc:	f04f 0300 	mov.w	r3, #0
    63c0:	81bb      	strh	r3, [r7, #12]
    63c2:	e012      	b.n	63ea <ACE_get_input_channel_handle+0x3e>
    {
        if ( g_ace_channel_desc_table[channel_idx].signal_id == channel_id )
    63c4:	89ba      	ldrh	r2, [r7, #12]
    63c6:	f240 0354 	movw	r3, #84	; 0x54
    63ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    63ce:	ea4f 1202 	mov.w	r2, r2, lsl #4
    63d2:	4413      	add	r3, r2
    63d4:	791b      	ldrb	r3, [r3, #4]
    63d6:	79fa      	ldrb	r2, [r7, #7]
    63d8:	429a      	cmp	r2, r3
    63da:	d102      	bne.n	63e2 <ACE_get_input_channel_handle+0x36>
        {
            /* channel ID found. */
            channel_handle = (ace_channel_handle_t)channel_idx;
    63dc:	89bb      	ldrh	r3, [r7, #12]
    63de:	73fb      	strb	r3, [r7, #15]
            break;
    63e0:	e006      	b.n	63f0 <ACE_get_input_channel_handle+0x44>
)
{
    uint16_t channel_idx;
    ace_channel_handle_t channel_handle = INVALID_CHANNEL_HANDLE;

    for ( channel_idx = 0u;  channel_idx < (uint16_t)ACE_NB_OF_INPUT_CHANNELS; ++channel_idx )
    63e2:	89bb      	ldrh	r3, [r7, #12]
    63e4:	f103 0301 	add.w	r3, r3, #1
    63e8:	81bb      	strh	r3, [r7, #12]
    63ea:	89bb      	ldrh	r3, [r7, #12]
    63ec:	2b02      	cmp	r3, #2
    63ee:	d9e9      	bls.n	63c4 <ACE_get_input_channel_handle+0x18>
            /* channel ID found. */
            channel_handle = (ace_channel_handle_t)channel_idx;
            break;
        }
    }
    return channel_handle;
    63f0:	7bfb      	ldrb	r3, [r7, #15]
}
    63f2:	4618      	mov	r0, r3
    63f4:	f107 0714 	add.w	r7, r7, #20
    63f8:	46bd      	mov	sp, r7
    63fa:	bc80      	pop	{r7}
    63fc:	4770      	bx	lr
    63fe:	bf00      	nop

00006400 <ACE_get_ppe_sample>:
uint16_t
ACE_get_ppe_sample
(
    ace_channel_handle_t channel_handle
)
{
    6400:	b480      	push	{r7}
    6402:	b085      	sub	sp, #20
    6404:	af00      	add	r7, sp, #0
    6406:	4603      	mov	r3, r0
    6408:	71fb      	strb	r3, [r7, #7]
    uint16_t sample;
    uint16_t ppe_offset;

    ppe_offset = g_ace_channel_desc_table[channel_handle].signal_ppe_offset;
    640a:	79fa      	ldrb	r2, [r7, #7]
    640c:	f240 0354 	movw	r3, #84	; 0x54
    6410:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6414:	ea4f 1202 	mov.w	r2, r2, lsl #4
    6418:	4413      	add	r3, r2
    641a:	88db      	ldrh	r3, [r3, #6]
    641c:	81fb      	strh	r3, [r7, #14]
    sample = (uint16_t)(ACE->PPE_RAM_DATA[ppe_offset] >> 16u);
    641e:	f240 0300 	movw	r3, #0
    6422:	f2c4 0302 	movt	r3, #16386	; 0x4002
    6426:	89fa      	ldrh	r2, [r7, #14]
    6428:	f502 62c0 	add.w	r2, r2, #1536	; 0x600
    642c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6430:	ea4f 4313 	mov.w	r3, r3, lsr #16
    6434:	81bb      	strh	r3, [r7, #12]

    return sample;
    6436:	89bb      	ldrh	r3, [r7, #12]
}
    6438:	4618      	mov	r0, r3
    643a:	f107 0714 	add.w	r7, r7, #20
    643e:	46bd      	mov	sp, r7
    6440:	bc80      	pop	{r7}
    6442:	4770      	bx	lr

00006444 <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
    6444:	b480      	push	{r7}
    6446:	b083      	sub	sp, #12
    6448:	af00      	add	r7, sp, #0
    644a:	4603      	mov	r3, r0
    644c:	80fb      	strh	r3, [r7, #6]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    644e:	f24e 1300 	movw	r3, #57600	; 0xe100
    6452:	f2ce 0300 	movt	r3, #57344	; 0xe000
    6456:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    645a:	ea4f 1252 	mov.w	r2, r2, lsr #5
    645e:	88f9      	ldrh	r1, [r7, #6]
    6460:	f001 011f 	and.w	r1, r1, #31
    6464:	f04f 0001 	mov.w	r0, #1
    6468:	fa00 f101 	lsl.w	r1, r0, r1
    646c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    6470:	f107 070c 	add.w	r7, r7, #12
    6474:	46bd      	mov	sp, r7
    6476:	bc80      	pop	{r7}
    6478:	4770      	bx	lr
    647a:	bf00      	nop

0000647c <NVIC_DisableIRQ>:
 * 
 * Disable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
    647c:	b480      	push	{r7}
    647e:	b083      	sub	sp, #12
    6480:	af00      	add	r7, sp, #0
    6482:	4603      	mov	r3, r0
    6484:	80fb      	strh	r3, [r7, #6]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
    6486:	f24e 1300 	movw	r3, #57600	; 0xe100
    648a:	f2ce 0300 	movt	r3, #57344	; 0xe000
    648e:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    6492:	ea4f 1252 	mov.w	r2, r2, lsr #5
    6496:	88f9      	ldrh	r1, [r7, #6]
    6498:	f001 011f 	and.w	r1, r1, #31
    649c:	f04f 0001 	mov.w	r0, #1
    64a0:	fa00 f101 	lsl.w	r1, r0, r1
    64a4:	f102 0220 	add.w	r2, r2, #32
    64a8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    64ac:	f107 070c 	add.w	r7, r7, #12
    64b0:	46bd      	mov	sp, r7
    64b2:	bc80      	pop	{r7}
    64b4:	4770      	bx	lr
    64b6:	bf00      	nop

000064b8 <NVIC_ClearPendingIRQ>:
 *
 * Clear the pending bit for the specified interrupt. 
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
    64b8:	b480      	push	{r7}
    64ba:	b083      	sub	sp, #12
    64bc:	af00      	add	r7, sp, #0
    64be:	4603      	mov	r3, r0
    64c0:	80fb      	strh	r3, [r7, #6]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    64c2:	f24e 1300 	movw	r3, #57600	; 0xe100
    64c6:	f2ce 0300 	movt	r3, #57344	; 0xe000
    64ca:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    64ce:	ea4f 1252 	mov.w	r2, r2, lsr #5
    64d2:	88f9      	ldrh	r1, [r7, #6]
    64d4:	f001 011f 	and.w	r1, r1, #31
    64d8:	f04f 0001 	mov.w	r0, #1
    64dc:	fa00 f101 	lsl.w	r1, r0, r1
    64e0:	f102 0260 	add.w	r2, r2, #96	; 0x60
    64e4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    64e8:	f107 070c 	add.w	r7, r7, #12
    64ec:	46bd      	mov	sp, r7
    64ee:	bc80      	pop	{r7}
    64f0:	4770      	bx	lr
    64f2:	bf00      	nop

000064f4 <NVIC_SetPriority>:
 * interrupt, or negative to specify an internal (core) interrupt.
 *
 * Note: The priority cannot be set for every core interrupt.
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
    64f4:	b480      	push	{r7}
    64f6:	b083      	sub	sp, #12
    64f8:	af00      	add	r7, sp, #0
    64fa:	4603      	mov	r3, r0
    64fc:	6039      	str	r1, [r7, #0]
    64fe:	80fb      	strh	r3, [r7, #6]
  if(IRQn < 0) {
    6500:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    6504:	2b00      	cmp	r3, #0
    6506:	da10      	bge.n	652a <NVIC_SetPriority+0x36>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M3 System Interrupts */
    6508:	f64e 5300 	movw	r3, #60672	; 0xed00
    650c:	f2ce 0300 	movt	r3, #57344	; 0xe000
    6510:	88fa      	ldrh	r2, [r7, #6]
    6512:	f002 020f 	and.w	r2, r2, #15
    6516:	f1a2 0104 	sub.w	r1, r2, #4
    651a:	683a      	ldr	r2, [r7, #0]
    651c:	b2d2      	uxtb	r2, r2
    651e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    6522:	b2d2      	uxtb	r2, r2
    6524:	440b      	add	r3, r1
    6526:	761a      	strb	r2, [r3, #24]
    6528:	e00d      	b.n	6546 <NVIC_SetPriority+0x52>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
    652a:	f24e 1300 	movw	r3, #57600	; 0xe100
    652e:	f2ce 0300 	movt	r3, #57344	; 0xe000
    6532:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
    6536:	683a      	ldr	r2, [r7, #0]
    6538:	b2d2      	uxtb	r2, r2
    653a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    653e:	b2d2      	uxtb	r2, r2
    6540:	440b      	add	r3, r1
    6542:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
    6546:	f107 070c 	add.w	r7, r7, #12
    654a:	46bd      	mov	sp, r7
    654c:	bc80      	pop	{r7}
    654e:	4770      	bx	lr

00006550 <MSS_I2C_init>:
(
	mss_i2c_instance_t * this_i2c,
	uint8_t ser_address,
	mss_i2c_clock_divider_t ser_clock_speed
)
{
    6550:	b580      	push	{r7, lr}
    6552:	b084      	sub	sp, #16
    6554:	af00      	add	r7, sp, #0
    6556:	6078      	str	r0, [r7, #4]
    6558:	4613      	mov	r3, r2
    655a:	460a      	mov	r2, r1
    655c:	70fa      	strb	r2, [r7, #3]
    655e:	70bb      	strb	r3, [r7, #2]
    uint_fast16_t clock_speed = ser_clock_speed;
    6560:	78bb      	ldrb	r3, [r7, #2]
    6562:	60bb      	str	r3, [r7, #8]

    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    6564:	687a      	ldr	r2, [r7, #4]
    6566:	f64a 23c8 	movw	r3, #43720	; 0xaac8
    656a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    656e:	429a      	cmp	r2, r3
    6570:	d007      	beq.n	6582 <MSS_I2C_init+0x32>
    6572:	687a      	ldr	r2, [r7, #4]
    6574:	f64a 3310 	movw	r3, #43792	; 0xab10
    6578:	f2c2 0300 	movt	r3, #8192	; 0x2000
    657c:	429a      	cmp	r2, r3
    657e:	d000      	beq.n	6582 <MSS_I2C_init+0x32>
    6580:	be00      	bkpt	0x0000

    if ( this_i2c == &g_mss_i2c0 )
    6582:	687a      	ldr	r2, [r7, #4]
    6584:	f64a 23c8 	movw	r3, #43720	; 0xaac8
    6588:	f2c2 0300 	movt	r3, #8192	; 0x2000
    658c:	429a      	cmp	r2, r3
    658e:	d12c      	bne.n	65ea <MSS_I2C_init+0x9a>
    {
        this_i2c->irqn = I2C0_IRQn;
    6590:	687b      	ldr	r3, [r7, #4]
    6592:	f04f 020e 	mov.w	r2, #14
    6596:	825a      	strh	r2, [r3, #18]
        this_i2c->hw_reg = I2C0;
    6598:	687a      	ldr	r2, [r7, #4]
    659a:	f242 0300 	movw	r3, #8192	; 0x2000
    659e:	f2c4 0300 	movt	r3, #16384	; 0x4000
    65a2:	6153      	str	r3, [r2, #20]
        this_i2c->hw_reg_bit = I2C0_BITBAND;
    65a4:	687a      	ldr	r2, [r7, #4]
    65a6:	f240 0300 	movw	r3, #0
    65aa:	f2c4 2304 	movt	r3, #16900	; 0x4204
    65ae:	6193      	str	r3, [r2, #24]

        /* reset I2C0 */
        SYSREG->SOFT_RST_CR |= SYSREG_I2C0_SOFTRESET_MASK;
    65b0:	f242 0300 	movw	r3, #8192	; 0x2000
    65b4:	f2ce 0304 	movt	r3, #57348	; 0xe004
    65b8:	f242 0200 	movw	r2, #8192	; 0x2000
    65bc:	f2ce 0204 	movt	r2, #57348	; 0xe004
    65c0:	6b12      	ldr	r2, [r2, #48]	; 0x30
    65c2:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
    65c6:	631a      	str	r2, [r3, #48]	; 0x30
        /* Clear any previously pended I2C0 interrupt */
        NVIC_ClearPendingIRQ( I2C0_IRQn );
    65c8:	f04f 000e 	mov.w	r0, #14
    65cc:	f7ff ff74 	bl	64b8 <NVIC_ClearPendingIRQ>
        /* Take I2C0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_I2C0_SOFTRESET_MASK;
    65d0:	f242 0300 	movw	r3, #8192	; 0x2000
    65d4:	f2ce 0304 	movt	r3, #57348	; 0xe004
    65d8:	f242 0200 	movw	r2, #8192	; 0x2000
    65dc:	f2ce 0204 	movt	r2, #57348	; 0xe004
    65e0:	6b12      	ldr	r2, [r2, #48]	; 0x30
    65e2:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
    65e6:	631a      	str	r2, [r3, #48]	; 0x30
    65e8:	e02b      	b.n	6642 <MSS_I2C_init+0xf2>
    }
    else
    {
        this_i2c->irqn = I2C1_IRQn;
    65ea:	687b      	ldr	r3, [r7, #4]
    65ec:	f04f 0211 	mov.w	r2, #17
    65f0:	825a      	strh	r2, [r3, #18]
        this_i2c->hw_reg = I2C1;
    65f2:	687a      	ldr	r2, [r7, #4]
    65f4:	f242 0300 	movw	r3, #8192	; 0x2000
    65f8:	f2c4 0301 	movt	r3, #16385	; 0x4001
    65fc:	6153      	str	r3, [r2, #20]
        this_i2c->hw_reg_bit = I2C1_BITBAND;
    65fe:	687a      	ldr	r2, [r7, #4]
    6600:	f240 0300 	movw	r3, #0
    6604:	f2c4 2324 	movt	r3, #16932	; 0x4224
    6608:	6193      	str	r3, [r2, #24]

        /* reset I2C1 */
        SYSREG->SOFT_RST_CR |= SYSREG_I2C1_SOFTRESET_MASK;
    660a:	f242 0300 	movw	r3, #8192	; 0x2000
    660e:	f2ce 0304 	movt	r3, #57348	; 0xe004
    6612:	f242 0200 	movw	r2, #8192	; 0x2000
    6616:	f2ce 0204 	movt	r2, #57348	; 0xe004
    661a:	6b12      	ldr	r2, [r2, #48]	; 0x30
    661c:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
    6620:	631a      	str	r2, [r3, #48]	; 0x30
        /* Clear any previously pended I2C1 interrupt */
        NVIC_ClearPendingIRQ( I2C1_IRQn );
    6622:	f04f 0011 	mov.w	r0, #17
    6626:	f7ff ff47 	bl	64b8 <NVIC_ClearPendingIRQ>
        /* Take I2C1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_I2C1_SOFTRESET_MASK;
    662a:	f242 0300 	movw	r3, #8192	; 0x2000
    662e:	f2ce 0304 	movt	r3, #57348	; 0xe004
    6632:	f242 0200 	movw	r2, #8192	; 0x2000
    6636:	f2ce 0204 	movt	r2, #57348	; 0xe004
    663a:	6b12      	ldr	r2, [r2, #48]	; 0x30
    663c:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
    6640:	631a      	str	r2, [r3, #48]	; 0x30
    }

	this_i2c->transaction = NO_TRANSACTION;
    6642:	687b      	ldr	r3, [r7, #4]
    6644:	f04f 0200 	mov.w	r2, #0
    6648:	721a      	strb	r2, [r3, #8]

	this_i2c->ser_address = ser_address;
    664a:	78fa      	ldrb	r2, [r7, #3]
    664c:	687b      	ldr	r3, [r7, #4]
    664e:	601a      	str	r2, [r3, #0]

	this_i2c->tx_buffer = 0;
    6650:	687b      	ldr	r3, [r7, #4]
    6652:	f04f 0200 	mov.w	r2, #0
    6656:	61da      	str	r2, [r3, #28]
	this_i2c->tx_size = 0;
    6658:	687b      	ldr	r3, [r7, #4]
    665a:	f04f 0200 	mov.w	r2, #0
    665e:	621a      	str	r2, [r3, #32]
	this_i2c->tx_idx = 0;
    6660:	687b      	ldr	r3, [r7, #4]
    6662:	f04f 0200 	mov.w	r2, #0
    6666:	625a      	str	r2, [r3, #36]	; 0x24

	this_i2c->rx_buffer = 0;
    6668:	687b      	ldr	r3, [r7, #4]
    666a:	f04f 0200 	mov.w	r2, #0
    666e:	62da      	str	r2, [r3, #44]	; 0x2c
	this_i2c->rx_size = 0;
    6670:	687b      	ldr	r3, [r7, #4]
    6672:	f04f 0200 	mov.w	r2, #0
    6676:	631a      	str	r2, [r3, #48]	; 0x30
	this_i2c->rx_idx = 0;
    6678:	687b      	ldr	r3, [r7, #4]
    667a:	f04f 0200 	mov.w	r2, #0
    667e:	635a      	str	r2, [r3, #52]	; 0x34

    this_i2c->status = MSS_I2C_SUCCESS;
    6680:	687b      	ldr	r3, [r7, #4]
    6682:	f04f 0200 	mov.w	r2, #0
    6686:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

	this_i2c->random_read_addr = 0;
    668a:	687b      	ldr	r3, [r7, #4]
    668c:	f04f 0200 	mov.w	r2, #0
    6690:	60da      	str	r2, [r3, #12]

	this_i2c->slave_write_handler = 0;
    6692:	687b      	ldr	r3, [r7, #4]
    6694:	f04f 0200 	mov.w	r2, #0
    6698:	641a      	str	r2, [r3, #64]	; 0x40
	this_i2c->slave_mem_offset_length = 0;
    669a:	687b      	ldr	r3, [r7, #4]
    669c:	f04f 0200 	mov.w	r2, #0
    66a0:	63da      	str	r2, [r3, #60]	; 0x3c

    this_i2c->hw_reg_bit->CTRL_ENS1 = 0x01; /* set enable bit */
    66a2:	687b      	ldr	r3, [r7, #4]
    66a4:	699b      	ldr	r3, [r3, #24]
    66a6:	f04f 0201 	mov.w	r2, #1
    66aa:	619a      	str	r2, [r3, #24]
    this_i2c->hw_reg_bit->CTRL_CR2 = (clock_speed >> 2) & 0x01;
    66ac:	687b      	ldr	r3, [r7, #4]
    66ae:	699b      	ldr	r3, [r3, #24]
    66b0:	68ba      	ldr	r2, [r7, #8]
    66b2:	ea4f 0292 	mov.w	r2, r2, lsr #2
    66b6:	f002 0201 	and.w	r2, r2, #1
    66ba:	61da      	str	r2, [r3, #28]
    this_i2c->hw_reg_bit->CTRL_CR1 = (clock_speed >> 1) & 0x01;
    66bc:	687b      	ldr	r3, [r7, #4]
    66be:	699b      	ldr	r3, [r3, #24]
    66c0:	68ba      	ldr	r2, [r7, #8]
    66c2:	ea4f 0252 	mov.w	r2, r2, lsr #1
    66c6:	f002 0201 	and.w	r2, r2, #1
    66ca:	605a      	str	r2, [r3, #4]
    this_i2c->hw_reg_bit->CTRL_CR0 = clock_speed & 0x01;
    66cc:	687b      	ldr	r3, [r7, #4]
    66ce:	699b      	ldr	r3, [r3, #24]
    66d0:	68ba      	ldr	r2, [r7, #8]
    66d2:	f002 0201 	and.w	r2, r2, #1
    66d6:	601a      	str	r2, [r3, #0]
    this_i2c->hw_reg->ADDR = this_i2c->ser_address;
    66d8:	687b      	ldr	r3, [r7, #4]
    66da:	695b      	ldr	r3, [r3, #20]
    66dc:	687a      	ldr	r2, [r7, #4]
    66de:	6812      	ldr	r2, [r2, #0]
    66e0:	b2d2      	uxtb	r2, r2
    66e2:	731a      	strb	r2, [r3, #12]
	
	/* The interrupt can cause a context switch, so ensure its priority is
	between configKERNEL_INTERRUPT_PRIORITY and configMAX_SYSCALL_INTERRUPT_PRIORITY. */
	NVIC_SetPriority( this_i2c->irqn, configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY );
    66e4:	687b      	ldr	r3, [r7, #4]
    66e6:	8a5b      	ldrh	r3, [r3, #18]
    66e8:	b21b      	sxth	r3, r3
    66ea:	4618      	mov	r0, r3
    66ec:	f04f 0105 	mov.w	r1, #5
    66f0:	f7ff ff00 	bl	64f4 <NVIC_SetPriority>
	
	vSemaphoreCreateBinary( ( this_i2c->xI2CCompleteSemaphore ) );
    66f4:	f04f 0001 	mov.w	r0, #1
    66f8:	f04f 0100 	mov.w	r1, #0
    66fc:	f04f 0203 	mov.w	r2, #3
    6700:	f006 f882 	bl	c808 <xQueueGenericCreate>
    6704:	4602      	mov	r2, r0
    6706:	687b      	ldr	r3, [r7, #4]
    6708:	645a      	str	r2, [r3, #68]	; 0x44
    670a:	687b      	ldr	r3, [r7, #4]
    670c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    670e:	2b00      	cmp	r3, #0
    6710:	d00a      	beq.n	6728 <MSS_I2C_init+0x1d8>
    6712:	687b      	ldr	r3, [r7, #4]
    6714:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    6716:	4618      	mov	r0, r3
    6718:	f04f 0100 	mov.w	r1, #0
    671c:	f04f 0200 	mov.w	r2, #0
    6720:	f04f 0300 	mov.w	r3, #0
    6724:	f006 f984 	bl	ca30 <xQueueGenericSend>
	xSemaphoreTake( ( this_i2c->xI2CCompleteSemaphore ), 0 );
    6728:	687b      	ldr	r3, [r7, #4]
    672a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    672c:	4618      	mov	r0, r3
    672e:	f04f 0100 	mov.w	r1, #0
    6732:	f006 fcc3 	bl	d0bc <xQueueSemaphoreTake>
	configASSERT( ( this_i2c->xI2CCompleteSemaphore ) );
    6736:	687b      	ldr	r3, [r7, #4]
    6738:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    673a:	2b00      	cmp	r3, #0
    673c:	d109      	bne.n	6752 <MSS_I2C_init+0x202>
    673e:	f04f 0328 	mov.w	r3, #40	; 0x28
    6742:	f383 8811 	msr	BASEPRI, r3
    6746:	f3bf 8f6f 	isb	sy
    674a:	f3bf 8f4f 	dsb	sy
    674e:	60fb      	str	r3, [r7, #12]
    6750:	e7fe      	b.n	6750 <MSS_I2C_init+0x200>
}
    6752:	f107 0710 	add.w	r7, r7, #16
    6756:	46bd      	mov	sp, r7
    6758:	bd80      	pop	{r7, pc}
    675a:	bf00      	nop

0000675c <MSS_I2C_set_slave_mem_offset_length>:
void MSS_I2C_set_slave_mem_offset_length
(
	mss_i2c_instance_t * this_i2c,
	uint8_t offset_length
)
{
    675c:	b480      	push	{r7}
    675e:	b083      	sub	sp, #12
    6760:	af00      	add	r7, sp, #0
    6762:	6078      	str	r0, [r7, #4]
    6764:	460b      	mov	r3, r1
    6766:	70fb      	strb	r3, [r7, #3]
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    6768:	687a      	ldr	r2, [r7, #4]
    676a:	f64a 23c8 	movw	r3, #43720	; 0xaac8
    676e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6772:	429a      	cmp	r2, r3
    6774:	d007      	beq.n	6786 <MSS_I2C_set_slave_mem_offset_length+0x2a>
    6776:	687a      	ldr	r2, [r7, #4]
    6778:	f64a 3310 	movw	r3, #43792	; 0xab10
    677c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6780:	429a      	cmp	r2, r3
    6782:	d000      	beq.n	6786 <MSS_I2C_set_slave_mem_offset_length+0x2a>
    6784:	be00      	bkpt	0x0000

	this_i2c->slave_mem_offset_length = offset_length;
    6786:	78fa      	ldrb	r2, [r7, #3]
    6788:	687b      	ldr	r3, [r7, #4]
    678a:	63da      	str	r2, [r3, #60]	; 0x3c
}
    678c:	f107 070c 	add.w	r7, r7, #12
    6790:	46bd      	mov	sp, r7
    6792:	bc80      	pop	{r7}
    6794:	4770      	bx	lr
    6796:	bf00      	nop

00006798 <MSS_I2C_register_write_handler>:
void MSS_I2C_register_write_handler
(
	mss_i2c_instance_t * this_i2c,
	mss_i2c_slave_wr_handler_t handler
)
{
    6798:	b480      	push	{r7}
    679a:	b083      	sub	sp, #12
    679c:	af00      	add	r7, sp, #0
    679e:	6078      	str	r0, [r7, #4]
    67a0:	6039      	str	r1, [r7, #0]
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    67a2:	687a      	ldr	r2, [r7, #4]
    67a4:	f64a 23c8 	movw	r3, #43720	; 0xaac8
    67a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    67ac:	429a      	cmp	r2, r3
    67ae:	d007      	beq.n	67c0 <MSS_I2C_register_write_handler+0x28>
    67b0:	687a      	ldr	r2, [r7, #4]
    67b2:	f64a 3310 	movw	r3, #43792	; 0xab10
    67b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    67ba:	429a      	cmp	r2, r3
    67bc:	d000      	beq.n	67c0 <MSS_I2C_register_write_handler+0x28>
    67be:	be00      	bkpt	0x0000

	this_i2c->slave_write_handler = handler;
    67c0:	687b      	ldr	r3, [r7, #4]
    67c2:	683a      	ldr	r2, [r7, #0]
    67c4:	641a      	str	r2, [r3, #64]	; 0x40
}
    67c6:	f107 070c 	add.w	r7, r7, #12
    67ca:	46bd      	mov	sp, r7
    67cc:	bc80      	pop	{r7}
    67ce:	4770      	bx	lr

000067d0 <MSS_I2C_write>:
	uint8_t serial_addr,
	const uint8_t * write_buffer,
	uint16_t write_size,
    uint8_t options
)
{
    67d0:	b580      	push	{r7, lr}
    67d2:	b088      	sub	sp, #32
    67d4:	af00      	add	r7, sp, #0
    67d6:	60f8      	str	r0, [r7, #12]
    67d8:	607a      	str	r2, [r7, #4]
    67da:	460a      	mov	r2, r1
    67dc:	72fa      	strb	r2, [r7, #11]
    67de:	807b      	strh	r3, [r7, #2]
    volatile uint8_t stat_ctrl;
    uint8_t serial_interrupt;

	uint32_t primask;

    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    67e0:	68fa      	ldr	r2, [r7, #12]
    67e2:	f64a 23c8 	movw	r3, #43720	; 0xaac8
    67e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    67ea:	429a      	cmp	r2, r3
    67ec:	d007      	beq.n	67fe <MSS_I2C_write+0x2e>
    67ee:	68fa      	ldr	r2, [r7, #12]
    67f0:	f64a 3310 	movw	r3, #43792	; 0xab10
    67f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    67f8:	429a      	cmp	r2, r3
    67fa:	d000      	beq.n	67fe <MSS_I2C_write+0x2e>
    67fc:	be00      	bkpt	0x0000
	configASSERT( ( this_i2c->xI2CCompleteSemaphore ) );
    67fe:	68fb      	ldr	r3, [r7, #12]
    6800:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    6802:	2b00      	cmp	r3, #0
    6804:	d109      	bne.n	681a <MSS_I2C_write+0x4a>
    6806:	f04f 0328 	mov.w	r3, #40	; 0x28
    680a:	f383 8811 	msr	BASEPRI, r3
    680e:	f3bf 8f6f 	isb	sy
    6812:	f3bf 8f4f 	dsb	sy
    6816:	61fb      	str	r3, [r7, #28]
    6818:	e7fe      	b.n	6818 <MSS_I2C_write+0x48>

	primask = disable_interrupts();
    681a:	f000 fdef 	bl	73fc <disable_interrupts>
    681e:	4603      	mov	r3, r0
    6820:	61bb      	str	r3, [r7, #24]

	this_i2c->transaction = MASTER_WRITE_TRANSACTION;
    6822:	68fb      	ldr	r3, [r7, #12]
    6824:	f04f 0201 	mov.w	r2, #1
    6828:	721a      	strb	r2, [r3, #8]

	this_i2c->target_addr = serial_addr;
    682a:	7afa      	ldrb	r2, [r7, #11]
    682c:	68fb      	ldr	r3, [r7, #12]
    682e:	605a      	str	r2, [r3, #4]
	this_i2c->dir = WRITE_DIR;
    6830:	68fb      	ldr	r3, [r7, #12]
    6832:	f04f 0200 	mov.w	r2, #0
    6836:	629a      	str	r2, [r3, #40]	; 0x28
	this_i2c->tx_buffer = write_buffer;
    6838:	68fb      	ldr	r3, [r7, #12]
    683a:	687a      	ldr	r2, [r7, #4]
    683c:	61da      	str	r2, [r3, #28]
	this_i2c->tx_size = write_size;
    683e:	887a      	ldrh	r2, [r7, #2]
    6840:	68fb      	ldr	r3, [r7, #12]
    6842:	621a      	str	r2, [r3, #32]
	this_i2c->tx_idx = 0;
    6844:	68fb      	ldr	r3, [r7, #12]
    6846:	f04f 0200 	mov.w	r2, #0
    684a:	625a      	str	r2, [r3, #36]	; 0x24

    this_i2c->status = MSS_I2C_IN_PROGRESS;
    684c:	68fb      	ldr	r3, [r7, #12]
    684e:	f04f 0201 	mov.w	r2, #1
    6852:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    this_i2c->options = options;
    6856:	68fb      	ldr	r3, [r7, #12]
    6858:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
    685c:	741a      	strb	r2, [r3, #16]

    /* Clear interrupts if required (depends on repeated starts).*/
    serial_interrupt = this_i2c->hw_reg_bit->CTRL_SI;
    685e:	68fb      	ldr	r3, [r7, #12]
    6860:	699b      	ldr	r3, [r3, #24]
    6862:	68db      	ldr	r3, [r3, #12]
    6864:	75fb      	strb	r3, [r7, #23]
    this_i2c->hw_reg_bit->CTRL_STA = 0x01;
    6866:	68fb      	ldr	r3, [r7, #12]
    6868:	699b      	ldr	r3, [r3, #24]
    686a:	f04f 0201 	mov.w	r2, #1
    686e:	615a      	str	r2, [r3, #20]

    if ( serial_interrupt != 0 )
    6870:	7dfb      	ldrb	r3, [r7, #23]
    6872:	2b00      	cmp	r3, #0
    6874:	d00a      	beq.n	688c <MSS_I2C_write+0xbc>
    {
        this_i2c->hw_reg_bit->CTRL_SI = 0x00;
    6876:	68fb      	ldr	r3, [r7, #12]
    6878:	699b      	ldr	r3, [r3, #24]
    687a:	f04f 0200 	mov.w	r2, #0
    687e:	60da      	str	r2, [r3, #12]
        NVIC_ClearPendingIRQ( this_i2c->irqn );
    6880:	68fb      	ldr	r3, [r7, #12]
    6882:	8a5b      	ldrh	r3, [r3, #18]
    6884:	b21b      	sxth	r3, r3
    6886:	4618      	mov	r0, r3
    6888:	f7ff fe16 	bl	64b8 <NVIC_ClearPendingIRQ>
    }

    stat_ctrl = this_i2c->hw_reg->STATUS;
    688c:	68fb      	ldr	r3, [r7, #12]
    688e:	695b      	ldr	r3, [r3, #20]
    6890:	791b      	ldrb	r3, [r3, #4]
    6892:	75bb      	strb	r3, [r7, #22]

    NVIC_EnableIRQ( this_i2c->irqn );
    6894:	68fb      	ldr	r3, [r7, #12]
    6896:	8a5b      	ldrh	r3, [r3, #18]
    6898:	b21b      	sxth	r3, r3
    689a:	4618      	mov	r0, r3
    689c:	f7ff fdd2 	bl	6444 <NVIC_EnableIRQ>

    restore_interrupts( primask );
    68a0:	69b8      	ldr	r0, [r7, #24]
    68a2:	f000 fdb9 	bl	7418 <restore_interrupts>
}
    68a6:	f107 0720 	add.w	r7, r7, #32
    68aa:	46bd      	mov	sp, r7
    68ac:	bd80      	pop	{r7, pc}
    68ae:	bf00      	nop

000068b0 <MSS_I2C_read>:
	uint8_t serial_addr,
	uint8_t * read_buffer,
	uint16_t read_size,
    uint8_t options
)
{
    68b0:	b580      	push	{r7, lr}
    68b2:	b088      	sub	sp, #32
    68b4:	af00      	add	r7, sp, #0
    68b6:	60f8      	str	r0, [r7, #12]
    68b8:	607a      	str	r2, [r7, #4]
    68ba:	460a      	mov	r2, r1
    68bc:	72fa      	strb	r2, [r7, #11]
    68be:	807b      	strh	r3, [r7, #2]
	uint32_t primask;

    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    68c0:	68fa      	ldr	r2, [r7, #12]
    68c2:	f64a 23c8 	movw	r3, #43720	; 0xaac8
    68c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    68ca:	429a      	cmp	r2, r3
    68cc:	d007      	beq.n	68de <MSS_I2C_read+0x2e>
    68ce:	68fa      	ldr	r2, [r7, #12]
    68d0:	f64a 3310 	movw	r3, #43792	; 0xab10
    68d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    68d8:	429a      	cmp	r2, r3
    68da:	d000      	beq.n	68de <MSS_I2C_read+0x2e>
    68dc:	be00      	bkpt	0x0000

	if ( read_size > 0 )
    68de:	887b      	ldrh	r3, [r7, #2]
    68e0:	2b00      	cmp	r3, #0
    68e2:	d045      	beq.n	6970 <MSS_I2C_read+0xc0>
	{
        volatile uint8_t stat_ctrl;
        uint8_t serial_interrupt;

		primask = disable_interrupts();
    68e4:	f000 fd8a 	bl	73fc <disable_interrupts>
    68e8:	4603      	mov	r3, r0
    68ea:	61bb      	str	r3, [r7, #24]

		this_i2c->transaction = MASTER_READ_TRANSACTION;
    68ec:	68fb      	ldr	r3, [r7, #12]
    68ee:	f04f 0202 	mov.w	r2, #2
    68f2:	721a      	strb	r2, [r3, #8]

		this_i2c->target_addr = serial_addr;
    68f4:	7afa      	ldrb	r2, [r7, #11]
    68f6:	68fb      	ldr	r3, [r7, #12]
    68f8:	605a      	str	r2, [r3, #4]
		this_i2c->dir = READ_DIR;
    68fa:	68fb      	ldr	r3, [r7, #12]
    68fc:	f04f 0201 	mov.w	r2, #1
    6900:	629a      	str	r2, [r3, #40]	; 0x28
		this_i2c->rx_buffer = read_buffer;
    6902:	68fb      	ldr	r3, [r7, #12]
    6904:	687a      	ldr	r2, [r7, #4]
    6906:	62da      	str	r2, [r3, #44]	; 0x2c
		this_i2c->rx_size = read_size;
    6908:	887a      	ldrh	r2, [r7, #2]
    690a:	68fb      	ldr	r3, [r7, #12]
    690c:	631a      	str	r2, [r3, #48]	; 0x30
		this_i2c->rx_idx = 0;
    690e:	68fb      	ldr	r3, [r7, #12]
    6910:	f04f 0200 	mov.w	r2, #0
    6914:	635a      	str	r2, [r3, #52]	; 0x34

        this_i2c->status = MSS_I2C_IN_PROGRESS;
    6916:	68fb      	ldr	r3, [r7, #12]
    6918:	f04f 0201 	mov.w	r2, #1
    691c:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

        this_i2c->options = options;
    6920:	68fb      	ldr	r3, [r7, #12]
    6922:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
    6926:	741a      	strb	r2, [r3, #16]

        /* Clear interrupts if required (depends on repeated starts).*/
        serial_interrupt = this_i2c->hw_reg_bit->CTRL_SI;
    6928:	68fb      	ldr	r3, [r7, #12]
    692a:	699b      	ldr	r3, [r3, #24]
    692c:	68db      	ldr	r3, [r3, #12]
    692e:	77fb      	strb	r3, [r7, #31]
        this_i2c->hw_reg_bit->CTRL_STA = 0x01;
    6930:	68fb      	ldr	r3, [r7, #12]
    6932:	699b      	ldr	r3, [r3, #24]
    6934:	f04f 0201 	mov.w	r2, #1
    6938:	615a      	str	r2, [r3, #20]

        if ( serial_interrupt != 0 )
    693a:	7ffb      	ldrb	r3, [r7, #31]
    693c:	2b00      	cmp	r3, #0
    693e:	d00a      	beq.n	6956 <MSS_I2C_read+0xa6>
        {
            this_i2c->hw_reg_bit->CTRL_SI = 0x00;
    6940:	68fb      	ldr	r3, [r7, #12]
    6942:	699b      	ldr	r3, [r3, #24]
    6944:	f04f 0200 	mov.w	r2, #0
    6948:	60da      	str	r2, [r3, #12]
            NVIC_ClearPendingIRQ( this_i2c->irqn );
    694a:	68fb      	ldr	r3, [r7, #12]
    694c:	8a5b      	ldrh	r3, [r3, #18]
    694e:	b21b      	sxth	r3, r3
    6950:	4618      	mov	r0, r3
    6952:	f7ff fdb1 	bl	64b8 <NVIC_ClearPendingIRQ>
        }

        stat_ctrl = this_i2c->hw_reg->STATUS;
    6956:	68fb      	ldr	r3, [r7, #12]
    6958:	695b      	ldr	r3, [r3, #20]
    695a:	791b      	ldrb	r3, [r3, #4]
    695c:	75fb      	strb	r3, [r7, #23]

        NVIC_EnableIRQ( this_i2c->irqn );
    695e:	68fb      	ldr	r3, [r7, #12]
    6960:	8a5b      	ldrh	r3, [r3, #18]
    6962:	b21b      	sxth	r3, r3
    6964:	4618      	mov	r0, r3
    6966:	f7ff fd6d 	bl	6444 <NVIC_EnableIRQ>

        restore_interrupts( primask );
    696a:	69b8      	ldr	r0, [r7, #24]
    696c:	f000 fd54 	bl	7418 <restore_interrupts>
	}
}
    6970:	f107 0720 	add.w	r7, r7, #32
    6974:	46bd      	mov	sp, r7
    6976:	bd80      	pop	{r7, pc}

00006978 <MSS_I2C_write_read>:
	uint16_t offset_size,
	uint8_t * read_buffer,
	uint16_t read_size,
    uint8_t options
)
{
    6978:	b580      	push	{r7, lr}
    697a:	b086      	sub	sp, #24
    697c:	af00      	add	r7, sp, #0
    697e:	60f8      	str	r0, [r7, #12]
    6980:	607a      	str	r2, [r7, #4]
    6982:	460a      	mov	r2, r1
    6984:	72fa      	strb	r2, [r7, #11]
    6986:	807b      	strh	r3, [r7, #2]
    volatile uint8_t stat_ctrl;
    uint8_t serial_interrupt;
	uint32_t primask;

    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    6988:	68fa      	ldr	r2, [r7, #12]
    698a:	f64a 23c8 	movw	r3, #43720	; 0xaac8
    698e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6992:	429a      	cmp	r2, r3
    6994:	d007      	beq.n	69a6 <MSS_I2C_write_read+0x2e>
    6996:	68fa      	ldr	r2, [r7, #12]
    6998:	f64a 3310 	movw	r3, #43792	; 0xab10
    699c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    69a0:	429a      	cmp	r2, r3
    69a2:	d000      	beq.n	69a6 <MSS_I2C_write_read+0x2e>
    69a4:	be00      	bkpt	0x0000

	primask = disable_interrupts();
    69a6:	f000 fd29 	bl	73fc <disable_interrupts>
    69aa:	4603      	mov	r3, r0
    69ac:	617b      	str	r3, [r7, #20]

	this_i2c->transaction = MASTER_RANDOM_READ_TRANSACTION;
    69ae:	68fb      	ldr	r3, [r7, #12]
    69b0:	f04f 0203 	mov.w	r2, #3
    69b4:	721a      	strb	r2, [r3, #8]
	this_i2c->target_addr = serial_addr;
    69b6:	7afa      	ldrb	r2, [r7, #11]
    69b8:	68fb      	ldr	r3, [r7, #12]
    69ba:	605a      	str	r2, [r3, #4]
	this_i2c->dir = WRITE_DIR;
    69bc:	68fb      	ldr	r3, [r7, #12]
    69be:	f04f 0200 	mov.w	r2, #0
    69c2:	629a      	str	r2, [r3, #40]	; 0x28
	this_i2c->tx_buffer = addr_offset;
    69c4:	68fb      	ldr	r3, [r7, #12]
    69c6:	687a      	ldr	r2, [r7, #4]
    69c8:	61da      	str	r2, [r3, #28]
	this_i2c->tx_size = offset_size;
    69ca:	887a      	ldrh	r2, [r7, #2]
    69cc:	68fb      	ldr	r3, [r7, #12]
    69ce:	621a      	str	r2, [r3, #32]
	this_i2c->tx_idx = 0;
    69d0:	68fb      	ldr	r3, [r7, #12]
    69d2:	f04f 0200 	mov.w	r2, #0
    69d6:	625a      	str	r2, [r3, #36]	; 0x24

	this_i2c->rx_buffer = read_buffer;
    69d8:	68fb      	ldr	r3, [r7, #12]
    69da:	6a3a      	ldr	r2, [r7, #32]
    69dc:	62da      	str	r2, [r3, #44]	; 0x2c
	this_i2c->rx_size = read_size;
    69de:	8cba      	ldrh	r2, [r7, #36]	; 0x24
    69e0:	68fb      	ldr	r3, [r7, #12]
    69e2:	631a      	str	r2, [r3, #48]	; 0x30
	this_i2c->rx_idx = 0;
    69e4:	68fb      	ldr	r3, [r7, #12]
    69e6:	f04f 0200 	mov.w	r2, #0
    69ea:	635a      	str	r2, [r3, #52]	; 0x34

    this_i2c->status = MSS_I2C_IN_PROGRESS;
    69ec:	68fb      	ldr	r3, [r7, #12]
    69ee:	f04f 0201 	mov.w	r2, #1
    69f2:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    this_i2c->options = options;
    69f6:	68fb      	ldr	r3, [r7, #12]
    69f8:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
    69fc:	741a      	strb	r2, [r3, #16]

    /* Clear interrupts if required (depends on repeated starts).*/
    serial_interrupt = this_i2c->hw_reg_bit->CTRL_SI;
    69fe:	68fb      	ldr	r3, [r7, #12]
    6a00:	699b      	ldr	r3, [r3, #24]
    6a02:	68db      	ldr	r3, [r3, #12]
    6a04:	74fb      	strb	r3, [r7, #19]
    this_i2c->hw_reg_bit->CTRL_STA = 0x01;
    6a06:	68fb      	ldr	r3, [r7, #12]
    6a08:	699b      	ldr	r3, [r3, #24]
    6a0a:	f04f 0201 	mov.w	r2, #1
    6a0e:	615a      	str	r2, [r3, #20]

    if ( serial_interrupt != 0 )
    6a10:	7cfb      	ldrb	r3, [r7, #19]
    6a12:	2b00      	cmp	r3, #0
    6a14:	d00a      	beq.n	6a2c <MSS_I2C_write_read+0xb4>
    {
        this_i2c->hw_reg_bit->CTRL_SI = 0x00;
    6a16:	68fb      	ldr	r3, [r7, #12]
    6a18:	699b      	ldr	r3, [r3, #24]
    6a1a:	f04f 0200 	mov.w	r2, #0
    6a1e:	60da      	str	r2, [r3, #12]
        NVIC_ClearPendingIRQ( this_i2c->irqn );
    6a20:	68fb      	ldr	r3, [r7, #12]
    6a22:	8a5b      	ldrh	r3, [r3, #18]
    6a24:	b21b      	sxth	r3, r3
    6a26:	4618      	mov	r0, r3
    6a28:	f7ff fd46 	bl	64b8 <NVIC_ClearPendingIRQ>
    }

    stat_ctrl = this_i2c->hw_reg->STATUS;
    6a2c:	68fb      	ldr	r3, [r7, #12]
    6a2e:	695b      	ldr	r3, [r3, #20]
    6a30:	791b      	ldrb	r3, [r3, #4]
    6a32:	74bb      	strb	r3, [r7, #18]

    NVIC_EnableIRQ( this_i2c->irqn );
    6a34:	68fb      	ldr	r3, [r7, #12]
    6a36:	8a5b      	ldrh	r3, [r3, #18]
    6a38:	b21b      	sxth	r3, r3
    6a3a:	4618      	mov	r0, r3
    6a3c:	f7ff fd02 	bl	6444 <NVIC_EnableIRQ>

    restore_interrupts( primask );
    6a40:	6978      	ldr	r0, [r7, #20]
    6a42:	f000 fce9 	bl	7418 <restore_interrupts>
}
    6a46:	f107 0718 	add.w	r7, r7, #24
    6a4a:	46bd      	mov	sp, r7
    6a4c:	bd80      	pop	{r7, pc}
    6a4e:	bf00      	nop

00006a50 <MSS_I2C_set_slave_rx_buffer>:
(
	mss_i2c_instance_t * this_i2c,
	uint8_t * rx_buffer,
	uint16_t rx_size
)
{
    6a50:	b580      	push	{r7, lr}
    6a52:	b086      	sub	sp, #24
    6a54:	af00      	add	r7, sp, #0
    6a56:	60f8      	str	r0, [r7, #12]
    6a58:	60b9      	str	r1, [r7, #8]
    6a5a:	4613      	mov	r3, r2
    6a5c:	80fb      	strh	r3, [r7, #6]
	uint32_t primask;

    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    6a5e:	68fa      	ldr	r2, [r7, #12]
    6a60:	f64a 23c8 	movw	r3, #43720	; 0xaac8
    6a64:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6a68:	429a      	cmp	r2, r3
    6a6a:	d007      	beq.n	6a7c <MSS_I2C_set_slave_rx_buffer+0x2c>
    6a6c:	68fa      	ldr	r2, [r7, #12]
    6a6e:	f64a 3310 	movw	r3, #43792	; 0xab10
    6a72:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6a76:	429a      	cmp	r2, r3
    6a78:	d000      	beq.n	6a7c <MSS_I2C_set_slave_rx_buffer+0x2c>
    6a7a:	be00      	bkpt	0x0000

	primask = disable_interrupts();
    6a7c:	f000 fcbe 	bl	73fc <disable_interrupts>
    6a80:	4603      	mov	r3, r0
    6a82:	617b      	str	r3, [r7, #20]

	this_i2c->rx_buffer = rx_buffer;
    6a84:	68fb      	ldr	r3, [r7, #12]
    6a86:	68ba      	ldr	r2, [r7, #8]
    6a88:	62da      	str	r2, [r3, #44]	; 0x2c
	this_i2c->rx_size = rx_size;
    6a8a:	88fa      	ldrh	r2, [r7, #6]
    6a8c:	68fb      	ldr	r3, [r7, #12]
    6a8e:	631a      	str	r2, [r3, #48]	; 0x30
	this_i2c->rx_idx = 0;
    6a90:	68fb      	ldr	r3, [r7, #12]
    6a92:	f04f 0200 	mov.w	r2, #0
    6a96:	635a      	str	r2, [r3, #52]	; 0x34

	restore_interrupts( primask );
    6a98:	6978      	ldr	r0, [r7, #20]
    6a9a:	f000 fcbd 	bl	7418 <restore_interrupts>
}
    6a9e:	f107 0718 	add.w	r7, r7, #24
    6aa2:	46bd      	mov	sp, r7
    6aa4:	bd80      	pop	{r7, pc}
    6aa6:	bf00      	nop

00006aa8 <MSS_I2C_get_status>:
 */
mss_i2c_status_t MSS_I2C_get_status
(
    mss_i2c_instance_t * this_i2c
)
{
    6aa8:	b480      	push	{r7}
    6aaa:	b083      	sub	sp, #12
    6aac:	af00      	add	r7, sp, #0
    6aae:	6078      	str	r0, [r7, #4]
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    6ab0:	687a      	ldr	r2, [r7, #4]
    6ab2:	f64a 23c8 	movw	r3, #43720	; 0xaac8
    6ab6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6aba:	429a      	cmp	r2, r3
    6abc:	d007      	beq.n	6ace <MSS_I2C_get_status+0x26>
    6abe:	687a      	ldr	r2, [r7, #4]
    6ac0:	f64a 3310 	movw	r3, #43792	; 0xab10
    6ac4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6ac8:	429a      	cmp	r2, r3
    6aca:	d000      	beq.n	6ace <MSS_I2C_get_status+0x26>
    6acc:	be00      	bkpt	0x0000

    return this_i2c->status;
    6ace:	687b      	ldr	r3, [r7, #4]
    6ad0:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
    6ad4:	b2db      	uxtb	r3, r3
}
    6ad6:	4618      	mov	r0, r3
    6ad8:	f107 070c 	add.w	r7, r7, #12
    6adc:	46bd      	mov	sp, r7
    6ade:	bc80      	pop	{r7}
    6ae0:	4770      	bx	lr
    6ae2:	bf00      	nop

00006ae4 <MSS_I2C_set_slave_tx_buffer>:
(
	mss_i2c_instance_t * this_i2c,
	uint8_t * tx_buffer,
	uint16_t tx_size
)
{
    6ae4:	b580      	push	{r7, lr}
    6ae6:	b086      	sub	sp, #24
    6ae8:	af00      	add	r7, sp, #0
    6aea:	60f8      	str	r0, [r7, #12]
    6aec:	60b9      	str	r1, [r7, #8]
    6aee:	4613      	mov	r3, r2
    6af0:	80fb      	strh	r3, [r7, #6]
	uint32_t primask;

    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    6af2:	68fa      	ldr	r2, [r7, #12]
    6af4:	f64a 23c8 	movw	r3, #43720	; 0xaac8
    6af8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6afc:	429a      	cmp	r2, r3
    6afe:	d007      	beq.n	6b10 <MSS_I2C_set_slave_tx_buffer+0x2c>
    6b00:	68fa      	ldr	r2, [r7, #12]
    6b02:	f64a 3310 	movw	r3, #43792	; 0xab10
    6b06:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6b0a:	429a      	cmp	r2, r3
    6b0c:	d000      	beq.n	6b10 <MSS_I2C_set_slave_tx_buffer+0x2c>
    6b0e:	be00      	bkpt	0x0000

	primask = disable_interrupts();
    6b10:	f000 fc74 	bl	73fc <disable_interrupts>
    6b14:	4603      	mov	r3, r0
    6b16:	617b      	str	r3, [r7, #20]

	this_i2c->tx_buffer = tx_buffer;
    6b18:	68fb      	ldr	r3, [r7, #12]
    6b1a:	68ba      	ldr	r2, [r7, #8]
    6b1c:	61da      	str	r2, [r3, #28]
	this_i2c->tx_size = tx_size;
    6b1e:	88fa      	ldrh	r2, [r7, #6]
    6b20:	68fb      	ldr	r3, [r7, #12]
    6b22:	621a      	str	r2, [r3, #32]
	this_i2c->tx_idx = 0;
    6b24:	68fb      	ldr	r3, [r7, #12]
    6b26:	f04f 0200 	mov.w	r2, #0
    6b2a:	625a      	str	r2, [r3, #36]	; 0x24

	restore_interrupts( primask );
    6b2c:	6978      	ldr	r0, [r7, #20]
    6b2e:	f000 fc73 	bl	7418 <restore_interrupts>

	/* Set the assert acknowledge bit. */
    this_i2c->hw_reg_bit->CTRL_AA = 0x01;
    6b32:	68fb      	ldr	r3, [r7, #12]
    6b34:	699b      	ldr	r3, [r3, #24]
    6b36:	f04f 0201 	mov.w	r2, #1
    6b3a:	609a      	str	r2, [r3, #8]
}
    6b3c:	f107 0718 	add.w	r7, r7, #24
    6b40:	46bd      	mov	sp, r7
    6b42:	bd80      	pop	{r7, pc}

00006b44 <MSS_I2C_enable_slave_rx>:
 */
void MSS_I2C_enable_slave_rx
(
	mss_i2c_instance_t * this_i2c
)
{
    6b44:	b580      	push	{r7, lr}
    6b46:	b082      	sub	sp, #8
    6b48:	af00      	add	r7, sp, #0
    6b4a:	6078      	str	r0, [r7, #4]
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    6b4c:	687a      	ldr	r2, [r7, #4]
    6b4e:	f64a 23c8 	movw	r3, #43720	; 0xaac8
    6b52:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6b56:	429a      	cmp	r2, r3
    6b58:	d007      	beq.n	6b6a <MSS_I2C_enable_slave_rx+0x26>
    6b5a:	687a      	ldr	r2, [r7, #4]
    6b5c:	f64a 3310 	movw	r3, #43792	; 0xab10
    6b60:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6b64:	429a      	cmp	r2, r3
    6b66:	d000      	beq.n	6b6a <MSS_I2C_enable_slave_rx+0x26>
    6b68:	be00      	bkpt	0x0000

	/* Set the assert acknowledge bit. */
    this_i2c->hw_reg_bit->CTRL_AA = 0x01;
    6b6a:	687b      	ldr	r3, [r7, #4]
    6b6c:	699b      	ldr	r3, [r3, #24]
    6b6e:	f04f 0201 	mov.w	r2, #1
    6b72:	609a      	str	r2, [r3, #8]
	/* accept GC addressing. */
    this_i2c->hw_reg_bit->ADDR_GC = 0x01;
    6b74:	687b      	ldr	r3, [r7, #4]
    6b76:	699b      	ldr	r3, [r3, #24]
    6b78:	f04f 0201 	mov.w	r2, #1
    6b7c:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180

    NVIC_EnableIRQ( this_i2c->irqn );
    6b80:	687b      	ldr	r3, [r7, #4]
    6b82:	8a5b      	ldrh	r3, [r3, #18]
    6b84:	b21b      	sxth	r3, r3
    6b86:	4618      	mov	r0, r3
    6b88:	f7ff fc5c 	bl	6444 <NVIC_EnableIRQ>
}
    6b8c:	f107 0708 	add.w	r7, r7, #8
    6b90:	46bd      	mov	sp, r7
    6b92:	bd80      	pop	{r7, pc}

00006b94 <MSS_I2C_wait_complete>:
 */
mss_i2c_status_t MSS_I2C_wait_complete
(
    mss_i2c_instance_t * this_i2c
)
{
    6b94:	b580      	push	{r7, lr}
    6b96:	b084      	sub	sp, #16
    6b98:	af00      	add	r7, sp, #0
    6b9a:	6078      	str	r0, [r7, #4]
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    6b9c:	687a      	ldr	r2, [r7, #4]
    6b9e:	f64a 23c8 	movw	r3, #43720	; 0xaac8
    6ba2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6ba6:	429a      	cmp	r2, r3
    6ba8:	d007      	beq.n	6bba <MSS_I2C_wait_complete+0x26>
    6baa:	687a      	ldr	r2, [r7, #4]
    6bac:	f64a 3310 	movw	r3, #43792	; 0xab10
    6bb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6bb4:	429a      	cmp	r2, r3
    6bb6:	d000      	beq.n	6bba <MSS_I2C_wait_complete+0x26>
    6bb8:	be00      	bkpt	0x0000
    {
        /* Wait for transaction to compltete.*/
        ;
    }
#else
	configASSERT( ( this_i2c->xI2CCompleteSemaphore ) );
    6bba:	687b      	ldr	r3, [r7, #4]
    6bbc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    6bbe:	2b00      	cmp	r3, #0
    6bc0:	d109      	bne.n	6bd6 <MSS_I2C_wait_complete+0x42>
    6bc2:	f04f 0328 	mov.w	r3, #40	; 0x28
    6bc6:	f383 8811 	msr	BASEPRI, r3
    6bca:	f3bf 8f6f 	isb	sy
    6bce:	f3bf 8f4f 	dsb	sy
    6bd2:	60fb      	str	r3, [r7, #12]
    6bd4:	e7fe      	b.n	6bd4 <MSS_I2C_wait_complete+0x40>
	if( xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED )
    6bd6:	f008 fecb 	bl	f970 <xTaskGetSchedulerState>
    6bda:	4603      	mov	r3, r0
    6bdc:	2b01      	cmp	r3, #1
    6bde:	d106      	bne.n	6bee <MSS_I2C_wait_complete+0x5a>
	{
		while ( this_i2c->status == MSS_I2C_IN_PROGRESS )
    6be0:	687b      	ldr	r3, [r7, #4]
    6be2:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
    6be6:	b2db      	uxtb	r3, r3
    6be8:	2b01      	cmp	r3, #1
    6bea:	d0f9      	beq.n	6be0 <MSS_I2C_wait_complete+0x4c>
    6bec:	e006      	b.n	6bfc <MSS_I2C_wait_complete+0x68>
			;
		}
	}
	else
	{
		xSemaphoreTake( this_i2c->xI2CCompleteSemaphore, portMAX_DELAY );
    6bee:	687b      	ldr	r3, [r7, #4]
    6bf0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    6bf2:	4618      	mov	r0, r3
    6bf4:	f04f 31ff 	mov.w	r1, #4294967295
    6bf8:	f006 fa60 	bl	d0bc <xQueueSemaphoreTake>
	}
#endif

    return this_i2c->status;
    6bfc:	687b      	ldr	r3, [r7, #4]
    6bfe:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
    6c02:	b2db      	uxtb	r3, r3
}
    6c04:	4618      	mov	r0, r3
    6c06:	f107 0710 	add.w	r7, r7, #16
    6c0a:	46bd      	mov	sp, r7
    6c0c:	bd80      	pop	{r7, pc}
    6c0e:	bf00      	nop

00006c10 <mss_i2c_isr>:
 */
static void mss_i2c_isr
(
	mss_i2c_instance_t * this_i2c
		)
{
    6c10:	b580      	push	{r7, lr}
    6c12:	b086      	sub	sp, #24
    6c14:	af00      	add	r7, sp, #0
    6c16:	6078      	str	r0, [r7, #4]
	volatile uint8_t status;
	uint8_t data;
    uint8_t hold_bus;
    uint8_t clear_irq = 1;
    6c18:	f04f 0301 	mov.w	r3, #1
    6c1c:	74bb      	strb	r3, [r7, #18]
	long lHigherPriorityTaskWoken = pdFALSE;
    6c1e:	f04f 0300 	mov.w	r3, #0
    6c22:	60bb      	str	r3, [r7, #8]
	configASSERT( ( this_i2c->xI2CCompleteSemaphore ) );
    6c24:	687b      	ldr	r3, [r7, #4]
    6c26:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    6c28:	2b00      	cmp	r3, #0
    6c2a:	d109      	bne.n	6c40 <mss_i2c_isr+0x30>
    6c2c:	f04f 0328 	mov.w	r3, #40	; 0x28
    6c30:	f383 8811 	msr	BASEPRI, r3
    6c34:	f3bf 8f6f 	isb	sy
    6c38:	f3bf 8f4f 	dsb	sy
    6c3c:	617b      	str	r3, [r7, #20]
    6c3e:	e7fe      	b.n	6c3e <mss_i2c_isr+0x2e>

    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    6c40:	687a      	ldr	r2, [r7, #4]
    6c42:	f64a 23c8 	movw	r3, #43720	; 0xaac8
    6c46:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6c4a:	429a      	cmp	r2, r3
    6c4c:	d007      	beq.n	6c5e <mss_i2c_isr+0x4e>
    6c4e:	687a      	ldr	r2, [r7, #4]
    6c50:	f64a 3310 	movw	r3, #43792	; 0xab10
    6c54:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6c58:	429a      	cmp	r2, r3
    6c5a:	d000      	beq.n	6c5e <mss_i2c_isr+0x4e>
    6c5c:	be00      	bkpt	0x0000

    status = this_i2c->hw_reg->STATUS;
    6c5e:	687b      	ldr	r3, [r7, #4]
    6c60:	695b      	ldr	r3, [r3, #20]
    6c62:	791b      	ldrb	r3, [r3, #4]
    6c64:	73fb      	strb	r3, [r7, #15]

	switch( status )
    6c66:	7bfb      	ldrb	r3, [r7, #15]
    6c68:	b2db      	uxtb	r3, r3
    6c6a:	f1a3 0308 	sub.w	r3, r3, #8
    6c6e:	2bd0      	cmp	r3, #208	; 0xd0
    6c70:	f200 83a5 	bhi.w	73be <mss_i2c_isr+0x7ae>
    6c74:	a201      	add	r2, pc, #4	; (adr r2, 6c7c <mss_i2c_isr+0x6c>)
    6c76:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    6c7a:	bf00      	nop
    6c7c:	00006fc1 	.word	0x00006fc1
    6c80:	000073bf 	.word	0x000073bf
    6c84:	000073bf 	.word	0x000073bf
    6c88:	000073bf 	.word	0x000073bf
    6c8c:	000073bf 	.word	0x000073bf
    6c90:	000073bf 	.word	0x000073bf
    6c94:	000073bf 	.word	0x000073bf
    6c98:	000073bf 	.word	0x000073bf
    6c9c:	00006fc1 	.word	0x00006fc1
    6ca0:	000073bf 	.word	0x000073bf
    6ca4:	000073bf 	.word	0x000073bf
    6ca8:	000073bf 	.word	0x000073bf
    6cac:	000073bf 	.word	0x000073bf
    6cb0:	000073bf 	.word	0x000073bf
    6cb4:	000073bf 	.word	0x000073bf
    6cb8:	000073bf 	.word	0x000073bf
    6cbc:	00007001 	.word	0x00007001
    6cc0:	000073bf 	.word	0x000073bf
    6cc4:	000073bf 	.word	0x000073bf
    6cc8:	000073bf 	.word	0x000073bf
    6ccc:	000073bf 	.word	0x000073bf
    6cd0:	000073bf 	.word	0x000073bf
    6cd4:	000073bf 	.word	0x000073bf
    6cd8:	000073bf 	.word	0x000073bf
    6cdc:	00007037 	.word	0x00007037
    6ce0:	000073bf 	.word	0x000073bf
    6ce4:	000073bf 	.word	0x000073bf
    6ce8:	000073bf 	.word	0x000073bf
    6cec:	000073bf 	.word	0x000073bf
    6cf0:	000073bf 	.word	0x000073bf
    6cf4:	000073bf 	.word	0x000073bf
    6cf8:	000073bf 	.word	0x000073bf
    6cfc:	0000706d 	.word	0x0000706d
    6d00:	000073bf 	.word	0x000073bf
    6d04:	000073bf 	.word	0x000073bf
    6d08:	000073bf 	.word	0x000073bf
    6d0c:	000073bf 	.word	0x000073bf
    6d10:	000073bf 	.word	0x000073bf
    6d14:	000073bf 	.word	0x000073bf
    6d18:	000073bf 	.word	0x000073bf
    6d1c:	000070fb 	.word	0x000070fb
    6d20:	000073bf 	.word	0x000073bf
    6d24:	000073bf 	.word	0x000073bf
    6d28:	000073bf 	.word	0x000073bf
    6d2c:	000073bf 	.word	0x000073bf
    6d30:	000073bf 	.word	0x000073bf
    6d34:	000073bf 	.word	0x000073bf
    6d38:	000073bf 	.word	0x000073bf
    6d3c:	00006ff5 	.word	0x00006ff5
    6d40:	000073bf 	.word	0x000073bf
    6d44:	000073bf 	.word	0x000073bf
    6d48:	000073bf 	.word	0x000073bf
    6d4c:	000073bf 	.word	0x000073bf
    6d50:	000073bf 	.word	0x000073bf
    6d54:	000073bf 	.word	0x000073bf
    6d58:	000073bf 	.word	0x000073bf
    6d5c:	00007189 	.word	0x00007189
    6d60:	000073bf 	.word	0x000073bf
    6d64:	000073bf 	.word	0x000073bf
    6d68:	000073bf 	.word	0x000073bf
    6d6c:	000073bf 	.word	0x000073bf
    6d70:	000073bf 	.word	0x000073bf
    6d74:	000073bf 	.word	0x000073bf
    6d78:	000073bf 	.word	0x000073bf
    6d7c:	000071a9 	.word	0x000071a9
    6d80:	000073bf 	.word	0x000073bf
    6d84:	000073bf 	.word	0x000073bf
    6d88:	000073bf 	.word	0x000073bf
    6d8c:	000073bf 	.word	0x000073bf
    6d90:	000073bf 	.word	0x000073bf
    6d94:	000073bf 	.word	0x000073bf
    6d98:	000073bf 	.word	0x000073bf
    6d9c:	000071cf 	.word	0x000071cf
    6da0:	000073bf 	.word	0x000073bf
    6da4:	000073bf 	.word	0x000073bf
    6da8:	000073bf 	.word	0x000073bf
    6dac:	000073bf 	.word	0x000073bf
    6db0:	000073bf 	.word	0x000073bf
    6db4:	000073bf 	.word	0x000073bf
    6db8:	000073bf 	.word	0x000073bf
    6dbc:	00007209 	.word	0x00007209
    6dc0:	000073bf 	.word	0x000073bf
    6dc4:	000073bf 	.word	0x000073bf
    6dc8:	000073bf 	.word	0x000073bf
    6dcc:	000073bf 	.word	0x000073bf
    6dd0:	000073bf 	.word	0x000073bf
    6dd4:	000073bf 	.word	0x000073bf
    6dd8:	000073bf 	.word	0x000073bf
    6ddc:	00007287 	.word	0x00007287
    6de0:	000073bf 	.word	0x000073bf
    6de4:	000073bf 	.word	0x000073bf
    6de8:	000073bf 	.word	0x000073bf
    6dec:	000073bf 	.word	0x000073bf
    6df0:	000073bf 	.word	0x000073bf
    6df4:	000073bf 	.word	0x000073bf
    6df8:	000073bf 	.word	0x000073bf
    6dfc:	000073bf 	.word	0x000073bf
    6e00:	000073bf 	.word	0x000073bf
    6e04:	000073bf 	.word	0x000073bf
    6e08:	000073bf 	.word	0x000073bf
    6e0c:	000073bf 	.word	0x000073bf
    6e10:	000073bf 	.word	0x000073bf
    6e14:	000073bf 	.word	0x000073bf
    6e18:	000073bf 	.word	0x000073bf
    6e1c:	000073bf 	.word	0x000073bf
    6e20:	000073bf 	.word	0x000073bf
    6e24:	000073bf 	.word	0x000073bf
    6e28:	000073bf 	.word	0x000073bf
    6e2c:	000073bf 	.word	0x000073bf
    6e30:	000073bf 	.word	0x000073bf
    6e34:	000073bf 	.word	0x000073bf
    6e38:	000073bf 	.word	0x000073bf
    6e3c:	000073bf 	.word	0x000073bf
    6e40:	000073bf 	.word	0x000073bf
    6e44:	000073bf 	.word	0x000073bf
    6e48:	000073bf 	.word	0x000073bf
    6e4c:	000073bf 	.word	0x000073bf
    6e50:	000073bf 	.word	0x000073bf
    6e54:	000073bf 	.word	0x000073bf
    6e58:	000073bf 	.word	0x000073bf
    6e5c:	000072a1 	.word	0x000072a1
    6e60:	000073bf 	.word	0x000073bf
    6e64:	000073bf 	.word	0x000073bf
    6e68:	000073bf 	.word	0x000073bf
    6e6c:	000073bf 	.word	0x000073bf
    6e70:	000073bf 	.word	0x000073bf
    6e74:	000073bf 	.word	0x000073bf
    6e78:	000073bf 	.word	0x000073bf
    6e7c:	0000725f 	.word	0x0000725f
    6e80:	000073bf 	.word	0x000073bf
    6e84:	000073bf 	.word	0x000073bf
    6e88:	000073bf 	.word	0x000073bf
    6e8c:	000073bf 	.word	0x000073bf
    6e90:	000073bf 	.word	0x000073bf
    6e94:	000073bf 	.word	0x000073bf
    6e98:	000073bf 	.word	0x000073bf
    6e9c:	000072a1 	.word	0x000072a1
    6ea0:	000073bf 	.word	0x000073bf
    6ea4:	000073bf 	.word	0x000073bf
    6ea8:	000073bf 	.word	0x000073bf
    6eac:	000073bf 	.word	0x000073bf
    6eb0:	000073bf 	.word	0x000073bf
    6eb4:	000073bf 	.word	0x000073bf
    6eb8:	000073bf 	.word	0x000073bf
    6ebc:	0000725f 	.word	0x0000725f
    6ec0:	000073bf 	.word	0x000073bf
    6ec4:	000073bf 	.word	0x000073bf
    6ec8:	000073bf 	.word	0x000073bf
    6ecc:	000073bf 	.word	0x000073bf
    6ed0:	000073bf 	.word	0x000073bf
    6ed4:	000073bf 	.word	0x000073bf
    6ed8:	000073bf 	.word	0x000073bf
    6edc:	000072eb 	.word	0x000072eb
    6ee0:	000073bf 	.word	0x000073bf
    6ee4:	000073bf 	.word	0x000073bf
    6ee8:	000073bf 	.word	0x000073bf
    6eec:	000073bf 	.word	0x000073bf
    6ef0:	000073bf 	.word	0x000073bf
    6ef4:	000073bf 	.word	0x000073bf
    6ef8:	000073bf 	.word	0x000073bf
    6efc:	00007359 	.word	0x00007359
    6f00:	000073bf 	.word	0x000073bf
    6f04:	000073bf 	.word	0x000073bf
    6f08:	000073bf 	.word	0x000073bf
    6f0c:	000073bf 	.word	0x000073bf
    6f10:	000073bf 	.word	0x000073bf
    6f14:	000073bf 	.word	0x000073bf
    6f18:	000073bf 	.word	0x000073bf
    6f1c:	00007359 	.word	0x00007359
    6f20:	000073bf 	.word	0x000073bf
    6f24:	000073bf 	.word	0x000073bf
    6f28:	000073bf 	.word	0x000073bf
    6f2c:	000073bf 	.word	0x000073bf
    6f30:	000073bf 	.word	0x000073bf
    6f34:	000073bf 	.word	0x000073bf
    6f38:	000073bf 	.word	0x000073bf
    6f3c:	00007359 	.word	0x00007359
    6f40:	000073bf 	.word	0x000073bf
    6f44:	000073bf 	.word	0x000073bf
    6f48:	000073bf 	.word	0x000073bf
    6f4c:	000073bf 	.word	0x000073bf
    6f50:	000073bf 	.word	0x000073bf
    6f54:	000073bf 	.word	0x000073bf
    6f58:	000073bf 	.word	0x000073bf
    6f5c:	000073af 	.word	0x000073af
    6f60:	000073bf 	.word	0x000073bf
    6f64:	000073bf 	.word	0x000073bf
    6f68:	000073bf 	.word	0x000073bf
    6f6c:	000073bf 	.word	0x000073bf
    6f70:	000073bf 	.word	0x000073bf
    6f74:	000073bf 	.word	0x000073bf
    6f78:	000073bf 	.word	0x000073bf
    6f7c:	000073bf 	.word	0x000073bf
    6f80:	000073bf 	.word	0x000073bf
    6f84:	000073bf 	.word	0x000073bf
    6f88:	000073bf 	.word	0x000073bf
    6f8c:	000073bf 	.word	0x000073bf
    6f90:	000073bf 	.word	0x000073bf
    6f94:	000073bf 	.word	0x000073bf
    6f98:	000073bf 	.word	0x000073bf
    6f9c:	000073bf 	.word	0x000073bf
    6fa0:	000073bf 	.word	0x000073bf
    6fa4:	000073bf 	.word	0x000073bf
    6fa8:	000073bf 	.word	0x000073bf
    6fac:	000073bf 	.word	0x000073bf
    6fb0:	000073bf 	.word	0x000073bf
    6fb4:	000073bf 	.word	0x000073bf
    6fb8:	000073bf 	.word	0x000073bf
    6fbc:	000073bf 	.word	0x000073bf
	{
	    /************** MASTER TRANSMITTER / RECEIVER *******************/

	    case ST_START: /* start has been xmt'd */
	    case ST_RESTART: /* repeated start has been xmt'd */
            this_i2c->hw_reg_bit->CTRL_STA = 0x0;
    6fc0:	687b      	ldr	r3, [r7, #4]
    6fc2:	699b      	ldr	r3, [r3, #24]
    6fc4:	f04f 0200 	mov.w	r2, #0
    6fc8:	615a      	str	r2, [r3, #20]
            this_i2c->hw_reg->DATA = this_i2c->target_addr;
    6fca:	687b      	ldr	r3, [r7, #4]
    6fcc:	695b      	ldr	r3, [r3, #20]
    6fce:	687a      	ldr	r2, [r7, #4]
    6fd0:	6852      	ldr	r2, [r2, #4]
    6fd2:	b2d2      	uxtb	r2, r2
    6fd4:	721a      	strb	r2, [r3, #8]
            this_i2c->hw_reg_bit->DATA_DIR = this_i2c->dir;
    6fd6:	687b      	ldr	r3, [r7, #4]
    6fd8:	699b      	ldr	r3, [r3, #24]
    6fda:	687a      	ldr	r2, [r7, #4]
    6fdc:	6a92      	ldr	r2, [r2, #40]	; 0x28
    6fde:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100

	    	this_i2c->tx_idx = 0;
    6fe2:	687b      	ldr	r3, [r7, #4]
    6fe4:	f04f 0200 	mov.w	r2, #0
    6fe8:	625a      	str	r2, [r3, #36]	; 0x24
	    	this_i2c->rx_idx = 0;
    6fea:	687b      	ldr	r3, [r7, #4]
    6fec:	f04f 0200 	mov.w	r2, #0
    6ff0:	635a      	str	r2, [r3, #52]	; 0x34
	    	break;
    6ff2:	e1e4      	b.n	73be <mss_i2c_isr+0x7ae>

	    case ST_LOST_ARB:
			/* Set start bit.  Let's keep trying!  Don't give up! */
            this_i2c->hw_reg_bit->CTRL_STA = 0x01;
    6ff4:	687b      	ldr	r3, [r7, #4]
    6ff6:	699b      	ldr	r3, [r3, #24]
    6ff8:	f04f 0201 	mov.w	r2, #1
    6ffc:	615a      	str	r2, [r3, #20]
			break;
    6ffe:	e1de      	b.n	73be <mss_i2c_isr+0x7ae>

	    /******************* MASTER TRANSMITTER *************************/
	    case ST_SLAW_ACK:
	    	/* call address has been xmt'd with ACK, time to send data byte and increment index. */
            if ( this_i2c->tx_idx < this_i2c->tx_size )
    7000:	687b      	ldr	r3, [r7, #4]
    7002:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    7004:	687b      	ldr	r3, [r7, #4]
    7006:	6a1b      	ldr	r3, [r3, #32]
    7008:	429a      	cmp	r2, r3
    700a:	d20d      	bcs.n	7028 <mss_i2c_isr+0x418>
            {
                /* load data byte */
                this_i2c->hw_reg->DATA = this_i2c->tx_buffer[this_i2c->tx_idx++];
    700c:	687b      	ldr	r3, [r7, #4]
    700e:	695a      	ldr	r2, [r3, #20]
    7010:	687b      	ldr	r3, [r7, #4]
    7012:	69d9      	ldr	r1, [r3, #28]
    7014:	687b      	ldr	r3, [r7, #4]
    7016:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    7018:	4419      	add	r1, r3
    701a:	7809      	ldrb	r1, [r1, #0]
    701c:	7211      	strb	r1, [r2, #8]
    701e:	f103 0201 	add.w	r2, r3, #1
    7022:	687b      	ldr	r3, [r7, #4]
    7024:	625a      	str	r2, [r3, #36]	; 0x24
            }
            else
            {
                NVIC_DisableIRQ( this_i2c->irqn );
            }
	    	break;
    7026:	e1ca      	b.n	73be <mss_i2c_isr+0x7ae>
                /* load data byte */
                this_i2c->hw_reg->DATA = this_i2c->tx_buffer[this_i2c->tx_idx++];
            }
            else
            {
                NVIC_DisableIRQ( this_i2c->irqn );
    7028:	687b      	ldr	r3, [r7, #4]
    702a:	8a5b      	ldrh	r3, [r3, #18]
    702c:	b21b      	sxth	r3, r3
    702e:	4618      	mov	r0, r3
    7030:	f7ff fa24 	bl	647c <NVIC_DisableIRQ>
            }
	    	break;
    7034:	e1c3      	b.n	73be <mss_i2c_isr+0x7ae>
	    	/* SLA+W has been transmitted; not ACK has been received - let's stop. */
            this_i2c->hw_reg_bit->CTRL_STO = 0x01;
            this_i2c->status = MSS_I2C_FAILED;
#endif
	    	/* call address has been xmt'd with ACK, time to send data byte and increment index. */
            if ( this_i2c->tx_idx < this_i2c->tx_size )
    7036:	687b      	ldr	r3, [r7, #4]
    7038:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    703a:	687b      	ldr	r3, [r7, #4]
    703c:	6a1b      	ldr	r3, [r3, #32]
    703e:	429a      	cmp	r2, r3
    7040:	d20d      	bcs.n	705e <mss_i2c_isr+0x44e>
            {
                /* load data byte */
                this_i2c->hw_reg->DATA = this_i2c->tx_buffer[this_i2c->tx_idx++];
    7042:	687b      	ldr	r3, [r7, #4]
    7044:	695a      	ldr	r2, [r3, #20]
    7046:	687b      	ldr	r3, [r7, #4]
    7048:	69d9      	ldr	r1, [r3, #28]
    704a:	687b      	ldr	r3, [r7, #4]
    704c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    704e:	4419      	add	r1, r3
    7050:	7809      	ldrb	r1, [r1, #0]
    7052:	7211      	strb	r1, [r2, #8]
    7054:	f103 0201 	add.w	r2, r3, #1
    7058:	687b      	ldr	r3, [r7, #4]
    705a:	625a      	str	r2, [r3, #36]	; 0x24
            }
            else
            {
                NVIC_DisableIRQ( this_i2c->irqn );
            }
			break;
    705c:	e1af      	b.n	73be <mss_i2c_isr+0x7ae>
                /* load data byte */
                this_i2c->hw_reg->DATA = this_i2c->tx_buffer[this_i2c->tx_idx++];
            }
            else
            {
                NVIC_DisableIRQ( this_i2c->irqn );
    705e:	687b      	ldr	r3, [r7, #4]
    7060:	8a5b      	ldrh	r3, [r3, #18]
    7062:	b21b      	sxth	r3, r3
    7064:	4618      	mov	r0, r3
    7066:	f7ff fa09 	bl	647c <NVIC_DisableIRQ>
            }
			break;
    706a:	e1a8      	b.n	73be <mss_i2c_isr+0x7ae>

	    case ST_TX_DATA_ACK:
			/* data byte has been xmt'd with ACK, time to send stop bit or repeated start. */
			if (this_i2c->tx_idx < this_i2c->tx_size)
    706c:	687b      	ldr	r3, [r7, #4]
    706e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    7070:	687b      	ldr	r3, [r7, #4]
    7072:	6a1b      	ldr	r3, [r3, #32]
    7074:	429a      	cmp	r2, r3
    7076:	d20d      	bcs.n	7094 <mss_i2c_isr+0x484>
			{
                this_i2c->hw_reg->DATA = this_i2c->tx_buffer[this_i2c->tx_idx++];
    7078:	687b      	ldr	r3, [r7, #4]
    707a:	695a      	ldr	r2, [r3, #20]
    707c:	687b      	ldr	r3, [r7, #4]
    707e:	69d9      	ldr	r1, [r3, #28]
    7080:	687b      	ldr	r3, [r7, #4]
    7082:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    7084:	4419      	add	r1, r3
    7086:	7809      	ldrb	r1, [r1, #0]
    7088:	7211      	strb	r1, [r2, #8]
    708a:	f103 0201 	add.w	r2, r3, #1
    708e:	687b      	ldr	r3, [r7, #4]
    7090:	625a      	str	r2, [r3, #36]	; 0x24
                    clear_irq = 0;
                }
                this_i2c->status = MSS_I2C_SUCCESS;
				xSemaphoreGiveFromISR( this_i2c->xI2CCompleteSemaphore, &lHigherPriorityTaskWoken );
			}
			break;
    7092:	e194      	b.n	73be <mss_i2c_isr+0x7ae>
			/* data byte has been xmt'd with ACK, time to send stop bit or repeated start. */
			if (this_i2c->tx_idx < this_i2c->tx_size)
			{
                this_i2c->hw_reg->DATA = this_i2c->tx_buffer[this_i2c->tx_idx++];
			}
			else if ( this_i2c->transaction == MASTER_RANDOM_READ_TRANSACTION )
    7094:	687b      	ldr	r3, [r7, #4]
    7096:	7a1b      	ldrb	r3, [r3, #8]
    7098:	2b03      	cmp	r3, #3
    709a:	d109      	bne.n	70b0 <mss_i2c_isr+0x4a0>
			{
				/* We are finished sending the address offset part of a random read transaction.
				 * It is is time to send a restart in order to change direction. */
				 this_i2c->dir = READ_DIR;
    709c:	687b      	ldr	r3, [r7, #4]
    709e:	f04f 0201 	mov.w	r2, #1
    70a2:	629a      	str	r2, [r3, #40]	; 0x28
                 this_i2c->hw_reg_bit->CTRL_STA = 0x01;
    70a4:	687b      	ldr	r3, [r7, #4]
    70a6:	699b      	ldr	r3, [r3, #24]
    70a8:	f04f 0201 	mov.w	r2, #1
    70ac:	615a      	str	r2, [r3, #20]
                    clear_irq = 0;
                }
                this_i2c->status = MSS_I2C_SUCCESS;
				xSemaphoreGiveFromISR( this_i2c->xI2CCompleteSemaphore, &lHigherPriorityTaskWoken );
			}
			break;
    70ae:	e186      	b.n	73be <mss_i2c_isr+0x7ae>
				 this_i2c->dir = READ_DIR;
                 this_i2c->hw_reg_bit->CTRL_STA = 0x01;
			}
			else /* done sending. let's stop */
			{
                hold_bus = this_i2c->options & MSS_I2C_HOLD_BUS;
    70b0:	687b      	ldr	r3, [r7, #4]
    70b2:	7c1b      	ldrb	r3, [r3, #16]
    70b4:	f003 0301 	and.w	r3, r3, #1
    70b8:	747b      	strb	r3, [r7, #17]
                if ( hold_bus == 0 )
    70ba:	7c7b      	ldrb	r3, [r7, #17]
    70bc:	2b00      	cmp	r3, #0
    70be:	d105      	bne.n	70cc <mss_i2c_isr+0x4bc>
                {
                    this_i2c->hw_reg_bit->CTRL_STO = 0x01; /*xmt stop condition */
    70c0:	687b      	ldr	r3, [r7, #4]
    70c2:	699b      	ldr	r3, [r3, #24]
    70c4:	f04f 0201 	mov.w	r2, #1
    70c8:	611a      	str	r2, [r3, #16]
    70ca:	e008      	b.n	70de <mss_i2c_isr+0x4ce>
                }
                else
                {
                    NVIC_DisableIRQ( this_i2c->irqn );
    70cc:	687b      	ldr	r3, [r7, #4]
    70ce:	8a5b      	ldrh	r3, [r3, #18]
    70d0:	b21b      	sxth	r3, r3
    70d2:	4618      	mov	r0, r3
    70d4:	f7ff f9d2 	bl	647c <NVIC_DisableIRQ>
                    clear_irq = 0;
    70d8:	f04f 0300 	mov.w	r3, #0
    70dc:	74bb      	strb	r3, [r7, #18]
                }
                this_i2c->status = MSS_I2C_SUCCESS;
    70de:	687b      	ldr	r3, [r7, #4]
    70e0:	f04f 0200 	mov.w	r2, #0
    70e4:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
				xSemaphoreGiveFromISR( this_i2c->xI2CCompleteSemaphore, &lHigherPriorityTaskWoken );
    70e8:	687b      	ldr	r3, [r7, #4]
    70ea:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    70ec:	f107 0308 	add.w	r3, r7, #8
    70f0:	4610      	mov	r0, r2
    70f2:	4619      	mov	r1, r3
    70f4:	f005 fe56 	bl	cda4 <xQueueGiveFromISR>
			}
			break;
    70f8:	e161      	b.n	73be <mss_i2c_isr+0x7ae>
             */
            this_i2c->hw_reg_bit->CTRL_STO = 0x01;
            this_i2c->status = MSS_I2C_FAILED;
#endif
			/* data byte has been xmt'd with ACK, time to send stop bit or repeated start. */
			if (this_i2c->tx_idx < this_i2c->tx_size)
    70fa:	687b      	ldr	r3, [r7, #4]
    70fc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    70fe:	687b      	ldr	r3, [r7, #4]
    7100:	6a1b      	ldr	r3, [r3, #32]
    7102:	429a      	cmp	r2, r3
    7104:	d20d      	bcs.n	7122 <mss_i2c_isr+0x512>
			{
                this_i2c->hw_reg->DATA = this_i2c->tx_buffer[this_i2c->tx_idx++];
    7106:	687b      	ldr	r3, [r7, #4]
    7108:	695a      	ldr	r2, [r3, #20]
    710a:	687b      	ldr	r3, [r7, #4]
    710c:	69d9      	ldr	r1, [r3, #28]
    710e:	687b      	ldr	r3, [r7, #4]
    7110:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    7112:	4419      	add	r1, r3
    7114:	7809      	ldrb	r1, [r1, #0]
    7116:	7211      	strb	r1, [r2, #8]
    7118:	f103 0201 	add.w	r2, r3, #1
    711c:	687b      	ldr	r3, [r7, #4]
    711e:	625a      	str	r2, [r3, #36]	; 0x24
                    clear_irq = 0;
                }
                this_i2c->status = MSS_I2C_SUCCESS;
				xSemaphoreGiveFromISR( this_i2c->xI2CCompleteSemaphore, &lHigherPriorityTaskWoken );
			}
            break;
    7120:	e14d      	b.n	73be <mss_i2c_isr+0x7ae>
			/* data byte has been xmt'd with ACK, time to send stop bit or repeated start. */
			if (this_i2c->tx_idx < this_i2c->tx_size)
			{
                this_i2c->hw_reg->DATA = this_i2c->tx_buffer[this_i2c->tx_idx++];
			}
			else if ( this_i2c->transaction == MASTER_RANDOM_READ_TRANSACTION )
    7122:	687b      	ldr	r3, [r7, #4]
    7124:	7a1b      	ldrb	r3, [r3, #8]
    7126:	2b03      	cmp	r3, #3
    7128:	d109      	bne.n	713e <mss_i2c_isr+0x52e>
			{
				/* We are finished sending the address offset part of a random read transaction.
				 * It is is time to send a restart in order to change direction. */
				 this_i2c->dir = READ_DIR;
    712a:	687b      	ldr	r3, [r7, #4]
    712c:	f04f 0201 	mov.w	r2, #1
    7130:	629a      	str	r2, [r3, #40]	; 0x28
                 this_i2c->hw_reg_bit->CTRL_STA = 0x01;
    7132:	687b      	ldr	r3, [r7, #4]
    7134:	699b      	ldr	r3, [r3, #24]
    7136:	f04f 0201 	mov.w	r2, #1
    713a:	615a      	str	r2, [r3, #20]
                    clear_irq = 0;
                }
                this_i2c->status = MSS_I2C_SUCCESS;
				xSemaphoreGiveFromISR( this_i2c->xI2CCompleteSemaphore, &lHigherPriorityTaskWoken );
			}
            break;
    713c:	e13f      	b.n	73be <mss_i2c_isr+0x7ae>
				 this_i2c->dir = READ_DIR;
                 this_i2c->hw_reg_bit->CTRL_STA = 0x01;
			}
			else /* done sending. let's stop */
			{
                hold_bus = this_i2c->options & MSS_I2C_HOLD_BUS;
    713e:	687b      	ldr	r3, [r7, #4]
    7140:	7c1b      	ldrb	r3, [r3, #16]
    7142:	f003 0301 	and.w	r3, r3, #1
    7146:	747b      	strb	r3, [r7, #17]
                if ( hold_bus == 0 )
    7148:	7c7b      	ldrb	r3, [r7, #17]
    714a:	2b00      	cmp	r3, #0
    714c:	d105      	bne.n	715a <mss_i2c_isr+0x54a>
                {
                    this_i2c->hw_reg_bit->CTRL_STO = 0x01; /*xmt stop condition */
    714e:	687b      	ldr	r3, [r7, #4]
    7150:	699b      	ldr	r3, [r3, #24]
    7152:	f04f 0201 	mov.w	r2, #1
    7156:	611a      	str	r2, [r3, #16]
    7158:	e008      	b.n	716c <mss_i2c_isr+0x55c>
                }
                else
                {
                    NVIC_DisableIRQ( this_i2c->irqn );
    715a:	687b      	ldr	r3, [r7, #4]
    715c:	8a5b      	ldrh	r3, [r3, #18]
    715e:	b21b      	sxth	r3, r3
    7160:	4618      	mov	r0, r3
    7162:	f7ff f98b 	bl	647c <NVIC_DisableIRQ>
                    clear_irq = 0;
    7166:	f04f 0300 	mov.w	r3, #0
    716a:	74bb      	strb	r3, [r7, #18]
                }
                this_i2c->status = MSS_I2C_SUCCESS;
    716c:	687b      	ldr	r3, [r7, #4]
    716e:	f04f 0200 	mov.w	r2, #0
    7172:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
				xSemaphoreGiveFromISR( this_i2c->xI2CCompleteSemaphore, &lHigherPriorityTaskWoken );
    7176:	687b      	ldr	r3, [r7, #4]
    7178:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    717a:	f107 0308 	add.w	r3, r7, #8
    717e:	4610      	mov	r0, r2
    7180:	4619      	mov	r1, r3
    7182:	f005 fe0f 	bl	cda4 <xQueueGiveFromISR>
			}
            break;
    7186:	e11a      	b.n	73be <mss_i2c_isr+0x7ae>
	  /* STATUS codes 08H, 10H, 38H are all covered in MTX mode */
		case ST_SLAR_ACK: /* SLA+R tx'ed. */
			/* Let's make sure we ACK the first data byte received (set AA bit in CTRL) unless
			 * the next byte is the last byte of the read transaction.
             */
			if( this_i2c->rx_size > 1 )
    7188:	687b      	ldr	r3, [r7, #4]
    718a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    718c:	2b01      	cmp	r3, #1
    718e:	d905      	bls.n	719c <mss_i2c_isr+0x58c>
			{
                this_i2c->hw_reg_bit->CTRL_AA = 0x01;
    7190:	687b      	ldr	r3, [r7, #4]
    7192:	699b      	ldr	r3, [r3, #24]
    7194:	f04f 0201 	mov.w	r2, #1
    7198:	609a      	str	r2, [r3, #8]
			}
			else
			{
                this_i2c->hw_reg_bit->CTRL_AA = 0x00;
			}
			break;
    719a:	e110      	b.n	73be <mss_i2c_isr+0x7ae>
			{
                this_i2c->hw_reg_bit->CTRL_AA = 0x01;
			}
			else
			{
                this_i2c->hw_reg_bit->CTRL_AA = 0x00;
    719c:	687b      	ldr	r3, [r7, #4]
    719e:	699b      	ldr	r3, [r3, #24]
    71a0:	f04f 0200 	mov.w	r2, #0
    71a4:	609a      	str	r2, [r3, #8]
			}
			break;
    71a6:	e10a      	b.n	73be <mss_i2c_isr+0x7ae>

		case ST_SLAR_NACK: /* SLA+R tx'ed; let's release the bus (send a stop condition) */
            this_i2c->hw_reg_bit->CTRL_STO = 0x01;
    71a8:	687b      	ldr	r3, [r7, #4]
    71aa:	699b      	ldr	r3, [r3, #24]
    71ac:	f04f 0201 	mov.w	r2, #1
    71b0:	611a      	str	r2, [r3, #16]
            this_i2c->status = MSS_I2C_FAILED;
    71b2:	687b      	ldr	r3, [r7, #4]
    71b4:	f04f 0202 	mov.w	r2, #2
    71b8:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
			xSemaphoreGiveFromISR( this_i2c->xI2CCompleteSemaphore, &lHigherPriorityTaskWoken );
    71bc:	687b      	ldr	r3, [r7, #4]
    71be:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    71c0:	f107 0308 	add.w	r3, r7, #8
    71c4:	4610      	mov	r0, r2
    71c6:	4619      	mov	r1, r3
    71c8:	f005 fdec 	bl	cda4 <xQueueGiveFromISR>
			break;
    71cc:	e0f7      	b.n	73be <mss_i2c_isr+0x7ae>

		case ST_RX_DATA_ACK: /* Data byte received, ACK returned */
			/* First, get the data */
            this_i2c->rx_buffer[this_i2c->rx_idx++] = this_i2c->hw_reg->DATA;
    71ce:	687b      	ldr	r3, [r7, #4]
    71d0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    71d2:	687b      	ldr	r3, [r7, #4]
    71d4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    71d6:	441a      	add	r2, r3
    71d8:	6879      	ldr	r1, [r7, #4]
    71da:	6949      	ldr	r1, [r1, #20]
    71dc:	7a09      	ldrb	r1, [r1, #8]
    71de:	b2c9      	uxtb	r1, r1
    71e0:	7011      	strb	r1, [r2, #0]
    71e2:	f103 0201 	add.w	r2, r3, #1
    71e6:	687b      	ldr	r3, [r7, #4]
    71e8:	635a      	str	r2, [r3, #52]	; 0x34

			if( this_i2c->rx_idx >= this_i2c->rx_size - 1)
    71ea:	687b      	ldr	r3, [r7, #4]
    71ec:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    71ee:	687b      	ldr	r3, [r7, #4]
    71f0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    71f2:	f103 33ff 	add.w	r3, r3, #4294967295
    71f6:	429a      	cmp	r2, r3
    71f8:	f0c0 80de 	bcc.w	73b8 <mss_i2c_isr+0x7a8>
			{
				/* If we're at the second last byte, let's set AA to 0 so
				 * we return a NACK at the last byte. */
                this_i2c->hw_reg_bit->CTRL_AA = 0x00;
    71fc:	687b      	ldr	r3, [r7, #4]
    71fe:	699b      	ldr	r3, [r3, #24]
    7200:	f04f 0200 	mov.w	r2, #0
    7204:	609a      	str	r2, [r3, #8]
			}
			break;
    7206:	e0da      	b.n	73be <mss_i2c_isr+0x7ae>

	    case ST_RX_DATA_NACK: /* Data byte received, NACK returned */
            /* Get the data, then send a stop condition */
            this_i2c->rx_buffer[this_i2c->rx_idx++] = this_i2c->hw_reg->DATA;
    7208:	687b      	ldr	r3, [r7, #4]
    720a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    720c:	687b      	ldr	r3, [r7, #4]
    720e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    7210:	441a      	add	r2, r3
    7212:	6879      	ldr	r1, [r7, #4]
    7214:	6949      	ldr	r1, [r1, #20]
    7216:	7a09      	ldrb	r1, [r1, #8]
    7218:	b2c9      	uxtb	r1, r1
    721a:	7011      	strb	r1, [r2, #0]
    721c:	f103 0201 	add.w	r2, r3, #1
    7220:	687b      	ldr	r3, [r7, #4]
    7222:	635a      	str	r2, [r3, #52]	; 0x34

            hold_bus = this_i2c->options &  MSS_I2C_HOLD_BUS;
    7224:	687b      	ldr	r3, [r7, #4]
    7226:	7c1b      	ldrb	r3, [r3, #16]
    7228:	f003 0301 	and.w	r3, r3, #1
    722c:	747b      	strb	r3, [r7, #17]
            if ( hold_bus == 0 )
    722e:	7c7b      	ldrb	r3, [r7, #17]
    7230:	2b00      	cmp	r3, #0
    7232:	d105      	bne.n	7240 <mss_i2c_isr+0x630>
            {
                this_i2c->hw_reg_bit->CTRL_STO = 0x01;  /*xmt stop condition */
    7234:	687b      	ldr	r3, [r7, #4]
    7236:	699b      	ldr	r3, [r3, #24]
    7238:	f04f 0201 	mov.w	r2, #1
    723c:	611a      	str	r2, [r3, #16]
    723e:	e008      	b.n	7252 <mss_i2c_isr+0x642>
            }
            else
            {
                NVIC_DisableIRQ( this_i2c->irqn );
    7240:	687b      	ldr	r3, [r7, #4]
    7242:	8a5b      	ldrh	r3, [r3, #18]
    7244:	b21b      	sxth	r3, r3
    7246:	4618      	mov	r0, r3
    7248:	f7ff f918 	bl	647c <NVIC_DisableIRQ>
                clear_irq = 0;
    724c:	f04f 0300 	mov.w	r3, #0
    7250:	74bb      	strb	r3, [r7, #18]
            }

            this_i2c->status = MSS_I2C_SUCCESS;
    7252:	687b      	ldr	r3, [r7, #4]
    7254:	f04f 0200 	mov.w	r2, #0
    7258:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
//			xSemaphoreGiveFromISR( this_i2c->xI2CCompleteSemaphore, &lHigherPriorityTaskWoken );
            break;
    725c:	e0af      	b.n	73be <mss_i2c_isr+0x7ae>

		/******************** SLAVE RECEIVER **************************/
		case ST_GCA_NACK: /* NACK after, GCA addressing */
		case ST_SLA_NACK: /* Get Data, but also re-enable AA (assert ack) bit for future transmissions */
			if ( this_i2c->rx_buffer != 0 )
    725e:	687b      	ldr	r3, [r7, #4]
    7260:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    7262:	2b00      	cmp	r3, #0
    7264:	d009      	beq.n	727a <mss_i2c_isr+0x66a>
			{
                this_i2c->rx_buffer[this_i2c->rx_idx] = this_i2c->hw_reg->DATA;
    7266:	687b      	ldr	r3, [r7, #4]
    7268:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    726a:	687b      	ldr	r3, [r7, #4]
    726c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    726e:	4413      	add	r3, r2
    7270:	687a      	ldr	r2, [r7, #4]
    7272:	6952      	ldr	r2, [r2, #20]
    7274:	7a12      	ldrb	r2, [r2, #8]
    7276:	b2d2      	uxtb	r2, r2
    7278:	701a      	strb	r2, [r3, #0]
			}
            this_i2c->hw_reg_bit->CTRL_AA = 0x01;
    727a:	687b      	ldr	r3, [r7, #4]
    727c:	699b      	ldr	r3, [r3, #24]
    727e:	f04f 0201 	mov.w	r2, #1
    7282:	609a      	str	r2, [r3, #8]
			break;
    7284:	e09b      	b.n	73be <mss_i2c_isr+0x7ae>

		case ST_SLAVE_SLAW: /* SLA+W received, ACK returned */
			this_i2c->transaction = WRITE_SLAVE_TRANSACTION;
    7286:	687b      	ldr	r3, [r7, #4]
    7288:	f04f 0204 	mov.w	r2, #4
    728c:	721a      	strb	r2, [r3, #8]
			this_i2c->rx_idx = 0;
    728e:	687b      	ldr	r3, [r7, #4]
    7290:	f04f 0200 	mov.w	r2, #0
    7294:	635a      	str	r2, [r3, #52]	; 0x34
			this_i2c->random_read_addr = 0;
    7296:	687b      	ldr	r3, [r7, #4]
    7298:	f04f 0200 	mov.w	r2, #0
    729c:	60da      	str	r2, [r3, #12]
#ifndef INCLUDE_SLA_IN_RX_PAYLOAD
			/* Only break from this case if the slave address must NOT be included at the
			 * beginning of the received write data. */
			break;
    729e:	e08e      	b.n	73be <mss_i2c_isr+0x7ae>
#endif
		case ST_GCA_ACK: /* DATA received; ACK sent after GCA */
		case ST_RDATA: /* DATA received; must clear DATA register */
			if (this_i2c->rx_idx >= this_i2c->rx_size - 2)
    72a0:	687b      	ldr	r3, [r7, #4]
    72a2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    72a4:	687b      	ldr	r3, [r7, #4]
    72a6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    72a8:	f1a3 0302 	sub.w	r3, r3, #2
    72ac:	429a      	cmp	r2, r3
    72ae:	d304      	bcc.n	72ba <mss_i2c_isr+0x6aa>
			{
                this_i2c->hw_reg_bit->CTRL_AA = 0x00;   /* send a NACK when done (next reception) */
    72b0:	687b      	ldr	r3, [r7, #4]
    72b2:	699b      	ldr	r3, [r3, #24]
    72b4:	f04f 0200 	mov.w	r2, #0
    72b8:	609a      	str	r2, [r3, #8]
			}
            data = this_i2c->hw_reg->DATA;
    72ba:	687b      	ldr	r3, [r7, #4]
    72bc:	695b      	ldr	r3, [r3, #20]
    72be:	7a1b      	ldrb	r3, [r3, #8]
    72c0:	743b      	strb	r3, [r7, #16]
			this_i2c->rx_buffer[this_i2c->rx_idx++] = data;
    72c2:	687b      	ldr	r3, [r7, #4]
    72c4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    72c6:	687b      	ldr	r3, [r7, #4]
    72c8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    72ca:	441a      	add	r2, r3
    72cc:	7c39      	ldrb	r1, [r7, #16]
    72ce:	7011      	strb	r1, [r2, #0]
    72d0:	f103 0201 	add.w	r2, r3, #1
    72d4:	687b      	ldr	r3, [r7, #4]
    72d6:	635a      	str	r2, [r3, #52]	; 0x34
			this_i2c->random_read_addr = (this_i2c->random_read_addr << 8) + data;
    72d8:	687b      	ldr	r3, [r7, #4]
    72da:	68db      	ldr	r3, [r3, #12]
    72dc:	ea4f 2203 	mov.w	r2, r3, lsl #8
    72e0:	7c3b      	ldrb	r3, [r7, #16]
    72e2:	441a      	add	r2, r3
    72e4:	687b      	ldr	r3, [r7, #4]
    72e6:	60da      	str	r2, [r3, #12]

			break;
    72e8:	e069      	b.n	73be <mss_i2c_isr+0x7ae>
			/* STOP or repeated START occured. */
			/* We cannot be sure if the transaction has actually completed as
			 * this hardware state reports that either a STOP or repeated START
			 * condition has occured. We assume that this is a repeated START
			 * if the transaction was a write from the master to this point.*/
			if ( this_i2c->transaction == WRITE_SLAVE_TRANSACTION )
    72ea:	687b      	ldr	r3, [r7, #4]
    72ec:	7a1b      	ldrb	r3, [r3, #8]
    72ee:	2b04      	cmp	r3, #4
    72f0:	d12c      	bne.n	734c <mss_i2c_isr+0x73c>
			{
				if ( this_i2c->rx_idx == this_i2c->slave_mem_offset_length )
    72f2:	687b      	ldr	r3, [r7, #4]
    72f4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    72f6:	687b      	ldr	r3, [r7, #4]
    72f8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    72fa:	429a      	cmp	r2, r3
    72fc:	d108      	bne.n	7310 <mss_i2c_isr+0x700>
				{
					this_i2c->transaction = RANDOM_READ_SLAVE_TRANSACTION;
    72fe:	687b      	ldr	r3, [r7, #4]
    7300:	f04f 0206 	mov.w	r2, #6
    7304:	721a      	strb	r2, [r3, #8]
					this_i2c->tx_idx = this_i2c->random_read_addr;
    7306:	687b      	ldr	r3, [r7, #4]
    7308:	68da      	ldr	r2, [r3, #12]
    730a:	687b      	ldr	r3, [r7, #4]
    730c:	625a      	str	r2, [r3, #36]	; 0x24
    730e:	e01d      	b.n	734c <mss_i2c_isr+0x73c>
				}
				else
				{
					/* Call the slave's write transaction handler if it exists. */
					if ( this_i2c->slave_write_handler != 0 )
    7310:	687b      	ldr	r3, [r7, #4]
    7312:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    7314:	2b00      	cmp	r3, #0
    7316:	d019      	beq.n	734c <mss_i2c_isr+0x73c>
					{
						mss_i2c_slave_handler_ret_t h_ret;
						h_ret = this_i2c->slave_write_handler( this_i2c->rx_buffer, (uint16_t)this_i2c->rx_idx );
    7318:	687b      	ldr	r3, [r7, #4]
    731a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    731c:	687a      	ldr	r2, [r7, #4]
    731e:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
    7320:	687a      	ldr	r2, [r7, #4]
    7322:	6b52      	ldr	r2, [r2, #52]	; 0x34
    7324:	b292      	uxth	r2, r2
    7326:	4608      	mov	r0, r1
    7328:	4611      	mov	r1, r2
    732a:	4798      	blx	r3
    732c:	4603      	mov	r3, r0
    732e:	74fb      	strb	r3, [r7, #19]
						if ( MSS_I2C_REENABLE_SLAVE_RX == h_ret )
    7330:	7cfb      	ldrb	r3, [r7, #19]
    7332:	2b00      	cmp	r3, #0
    7334:	d105      	bne.n	7342 <mss_i2c_isr+0x732>
						{
                            this_i2c->hw_reg_bit->CTRL_AA = 0x01;
    7336:	687b      	ldr	r3, [r7, #4]
    7338:	699b      	ldr	r3, [r3, #24]
    733a:	f04f 0201 	mov.w	r2, #1
    733e:	609a      	str	r2, [r3, #8]
    7340:	e004      	b.n	734c <mss_i2c_isr+0x73c>
						}
						else
						{
                            this_i2c->hw_reg_bit->CTRL_AA = 0x00;
    7342:	687b      	ldr	r3, [r7, #4]
    7344:	699b      	ldr	r3, [r3, #24]
    7346:	f04f 0200 	mov.w	r2, #0
    734a:	609a      	str	r2, [r3, #8]
						}
					}
				}
			}
			/* Mark any previous master write transaction as complete. */
            this_i2c->status = MSS_I2C_SUCCESS;
    734c:	687b      	ldr	r3, [r7, #4]
    734e:	f04f 0200 	mov.w	r2, #0
    7352:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
//			xSemaphoreGiveFromISR( this_i2c->xI2CCompleteSemaphore, &lHigherPriorityTaskWoken );
			break;
    7356:	e032      	b.n	73be <mss_i2c_isr+0x7ae>

		/****************** SLAVE TRANSMITTER **************************/
		case ST_SLAVE_SLAR_ACK: /* SLA+R received, ACK returned */
		case ST_SLARW_LA: /* Arbitration lost, and: */
		case ST_RACK: /* Data tx'ed, ACK received */
            if ( status == ST_SLAVE_SLAR_ACK )
    7358:	7bfb      	ldrb	r3, [r7, #15]
    735a:	b2db      	uxtb	r3, r3
    735c:	2ba8      	cmp	r3, #168	; 0xa8
    735e:	d107      	bne.n	7370 <mss_i2c_isr+0x760>
            {
                this_i2c->transaction = READ_SLAVE_TRANSACTION;
    7360:	687b      	ldr	r3, [r7, #4]
    7362:	f04f 0205 	mov.w	r2, #5
    7366:	721a      	strb	r2, [r3, #8]
                this_i2c->random_read_addr = 0;
    7368:	687b      	ldr	r3, [r7, #4]
    736a:	f04f 0200 	mov.w	r2, #0
    736e:	60da      	str	r2, [r3, #12]
            }
			/* Load the data, and determine if it is the last one */
            this_i2c->hw_reg->DATA = this_i2c->tx_buffer[this_i2c->tx_idx++];
    7370:	687b      	ldr	r3, [r7, #4]
    7372:	695a      	ldr	r2, [r3, #20]
    7374:	687b      	ldr	r3, [r7, #4]
    7376:	69d9      	ldr	r1, [r3, #28]
    7378:	687b      	ldr	r3, [r7, #4]
    737a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    737c:	4419      	add	r1, r3
    737e:	7809      	ldrb	r1, [r1, #0]
    7380:	7211      	strb	r1, [r2, #8]
    7382:	f103 0201 	add.w	r2, r3, #1
    7386:	687b      	ldr	r3, [r7, #4]
    7388:	625a      	str	r2, [r3, #36]	; 0x24
			if (this_i2c->tx_idx >= this_i2c->tx_size - 1) /* last byte? */
    738a:	687b      	ldr	r3, [r7, #4]
    738c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    738e:	687b      	ldr	r3, [r7, #4]
    7390:	6a1b      	ldr	r3, [r3, #32]
    7392:	f103 33ff 	add.w	r3, r3, #4294967295
    7396:	429a      	cmp	r2, r3
    7398:	d310      	bcc.n	73bc <mss_i2c_isr+0x7ac>
			{
                this_i2c->hw_reg_bit->CTRL_AA = 0x00;
    739a:	687b      	ldr	r3, [r7, #4]
    739c:	699b      	ldr	r3, [r3, #24]
    739e:	f04f 0200 	mov.w	r2, #0
    73a2:	609a      	str	r2, [r3, #8]
				/* Next read transaction will result in slave's transmit buffer
				 * being sent from the first byte. */
				this_i2c->tx_idx = 0;
    73a4:	687b      	ldr	r3, [r7, #4]
    73a6:	f04f 0200 	mov.w	r2, #0
    73aa:	625a      	str	r2, [r3, #36]	; 0x24
			}
			break;
    73ac:	e007      	b.n	73be <mss_i2c_isr+0x7ae>

		case ST_SLAVE_RNACK:	/* Data byte has been transmitted; not-ACK has been received. */
			/* We assume that the transaction will be stopped by the master.
			 * Reset tx_idx so that a subsequent read will result in the slave's
			 * transmit buffer being sent from the first byte. */
			this_i2c->tx_idx = 0;
    73ae:	687b      	ldr	r3, [r7, #4]
    73b0:	f04f 0200 	mov.w	r2, #0
    73b4:	625a      	str	r2, [r3, #36]	; 0x24
    73b6:	e002      	b.n	73be <mss_i2c_isr+0x7ae>
			{
				/* If we're at the second last byte, let's set AA to 0 so
				 * we return a NACK at the last byte. */
                this_i2c->hw_reg_bit->CTRL_AA = 0x00;
			}
			break;
    73b8:	bf00      	nop
    73ba:	e000      	b.n	73be <mss_i2c_isr+0x7ae>
                this_i2c->hw_reg_bit->CTRL_AA = 0x00;
				/* Next read transaction will result in slave's transmit buffer
				 * being sent from the first byte. */
				this_i2c->tx_idx = 0;
			}
			break;
    73bc:	bf00      	nop
		default:
			/* do nothing */
			break;
	}

    if ( clear_irq )
    73be:	7cbb      	ldrb	r3, [r7, #18]
    73c0:	2b00      	cmp	r3, #0
    73c2:	d004      	beq.n	73ce <mss_i2c_isr+0x7be>
    {
    	/* clear interrupt. */
        this_i2c->hw_reg_bit->CTRL_SI = 0x00;
    73c4:	687b      	ldr	r3, [r7, #4]
    73c6:	699b      	ldr	r3, [r3, #24]
    73c8:	f04f 0200 	mov.w	r2, #0
    73cc:	60da      	str	r2, [r3, #12]
    }

    /* Read the status register to ensure the last I2C registers write took place
     * in a system built around a bus making use of posted writes. */
    status = this_i2c->hw_reg->STATUS;
    73ce:	687b      	ldr	r3, [r7, #4]
    73d0:	695b      	ldr	r3, [r3, #20]
    73d2:	791b      	ldrb	r3, [r3, #4]
    73d4:	73fb      	strb	r3, [r7, #15]
	
	portEND_SWITCHING_ISR( lHigherPriorityTaskWoken );
    73d6:	68bb      	ldr	r3, [r7, #8]
    73d8:	2b00      	cmp	r3, #0
    73da:	d00a      	beq.n	73f2 <mss_i2c_isr+0x7e2>
    73dc:	f64e 5304 	movw	r3, #60676	; 0xed04
    73e0:	f2ce 0300 	movt	r3, #57344	; 0xe000
    73e4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    73e8:	601a      	str	r2, [r3, #0]
    73ea:	f3bf 8f4f 	dsb	sy
    73ee:	f3bf 8f6f 	isb	sy
}
    73f2:	f107 0718 	add.w	r7, r7, #24
    73f6:	46bd      	mov	sp, r7
    73f8:	bd80      	pop	{r7, pc}
    73fa:	bf00      	nop

000073fc <disable_interrupts>:

/*------------------------------------------------------------------------------
 *
 */
uint32_t disable_interrupts( void )
{
    73fc:	b580      	push	{r7, lr}
    73fe:	b082      	sub	sp, #8
    7400:	af00      	add	r7, sp, #0
    uint32_t primask;
    primask = __get_PRIMASK();
    7402:	f000 f875 	bl	74f0 <__get_PRIMASK>
    7406:	4603      	mov	r3, r0
    7408:	607b      	str	r3, [r7, #4]
    return primask;
    740a:	687b      	ldr	r3, [r7, #4]
}
    740c:	4618      	mov	r0, r3
    740e:	f107 0708 	add.w	r7, r7, #8
    7412:	46bd      	mov	sp, r7
    7414:	bd80      	pop	{r7, pc}
    7416:	bf00      	nop

00007418 <restore_interrupts>:

/*------------------------------------------------------------------------------
 *
 */
void restore_interrupts( uint32_t primask )
{
    7418:	b580      	push	{r7, lr}
    741a:	b082      	sub	sp, #8
    741c:	af00      	add	r7, sp, #0
    741e:	6078      	str	r0, [r7, #4]
    __set_PRIMASK( primask );
    7420:	6878      	ldr	r0, [r7, #4]
    7422:	f000 f875 	bl	7510 <__set_PRIMASK>
}
    7426:	f107 0708 	add.w	r7, r7, #8
    742a:	46bd      	mov	sp, r7
    742c:	bd80      	pop	{r7, pc}
    742e:	bf00      	nop

00007430 <I2C0_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void I2C0_IRQHandler( void )
#else
void I2C0_IRQHandler( void )
#endif
{
    7430:	4668      	mov	r0, sp
    7432:	f020 0107 	bic.w	r1, r0, #7
    7436:	468d      	mov	sp, r1
    7438:	b589      	push	{r0, r3, r7, lr}
    743a:	af00      	add	r7, sp, #0
	mss_i2c_isr( &g_mss_i2c0 );
    743c:	f64a 20c8 	movw	r0, #43720	; 0xaac8
    7440:	f2c2 0000 	movt	r0, #8192	; 0x2000
    7444:	f7ff fbe4 	bl	6c10 <mss_i2c_isr>
    NVIC_ClearPendingIRQ( I2C0_IRQn );
    7448:	f04f 000e 	mov.w	r0, #14
    744c:	f7ff f834 	bl	64b8 <NVIC_ClearPendingIRQ>
}
    7450:	46bd      	mov	sp, r7
    7452:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    7456:	4685      	mov	sp, r0
    7458:	4770      	bx	lr
    745a:	bf00      	nop

0000745c <I2C1_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void I2C1_IRQHandler( void )
#else
void I2C1_IRQHandler( void )
#endif
{
    745c:	4668      	mov	r0, sp
    745e:	f020 0107 	bic.w	r1, r0, #7
    7462:	468d      	mov	sp, r1
    7464:	b589      	push	{r0, r3, r7, lr}
    7466:	af00      	add	r7, sp, #0
	mss_i2c_isr( &g_mss_i2c1 );
    7468:	f64a 3010 	movw	r0, #43792	; 0xab10
    746c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    7470:	f7ff fbce 	bl	6c10 <mss_i2c_isr>
    NVIC_ClearPendingIRQ( I2C1_IRQn );
    7474:	f04f 0011 	mov.w	r0, #17
    7478:	f7ff f81e 	bl	64b8 <NVIC_ClearPendingIRQ>
}
    747c:	46bd      	mov	sp, r7
    747e:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    7482:	4685      	mov	sp, r0
    7484:	4770      	bx	lr
    7486:	bf00      	nop

00007488 <__get_PSP>:
 * Return the actual process stack pointer
 */
uint32_t __get_PSP(void) __attribute__( ( naked ) );
uint32_t __get_PSP(void)
{
  uint32_t result=0;
    7488:	f04f 0400 	mov.w	r4, #0

  __ASM volatile ("MRS %0, psp\n\t" 
    748c:	f3ef 8409 	mrs	r4, PSP
    7490:	4620      	mov	r0, r4
    7492:	4770      	bx	lr
                  "MOV r0, %0 \n\t"
                  "BX  lr     \n\t"  : "=r" (result) );
  return(result);
    7494:	4623      	mov	r3, r4
}
    7496:	4618      	mov	r0, r3

00007498 <__set_PSP>:
 * Assign the value ProcessStackPointer to the MSP 
 * (process stack pointer) Cortex processor register
 */
void __set_PSP(uint32_t topOfProcStack) __attribute__( ( naked ) );
void __set_PSP(uint32_t topOfProcStack)
{
    7498:	4603      	mov	r3, r0
  __ASM volatile ("MSR psp, %0\n\t"
    749a:	f383 8809 	msr	PSP, r3
    749e:	4770      	bx	lr

000074a0 <__get_MSP>:
 * Cortex processor register
 */
uint32_t __get_MSP(void) __attribute__( ( naked ) );
uint32_t __get_MSP(void)
{
  uint32_t result=0;
    74a0:	f04f 0400 	mov.w	r4, #0

  __ASM volatile ("MRS %0, msp\n\t" 
    74a4:	f3ef 8408 	mrs	r4, MSP
    74a8:	4620      	mov	r0, r4
    74aa:	4770      	bx	lr
                  "MOV r0, %0 \n\t"
                  "BX  lr     \n\t"  : "=r" (result) );
  return(result);
    74ac:	4623      	mov	r3, r4
}
    74ae:	4618      	mov	r0, r3

000074b0 <__set_MSP>:
 * Assign the value mainStackPointer to the MSP 
 * (main stack pointer) Cortex processor register
 */
void __set_MSP(uint32_t topOfMainStack) __attribute__( ( naked ) );
void __set_MSP(uint32_t topOfMainStack)
{
    74b0:	4603      	mov	r3, r0
  __ASM volatile ("MSR msp, %0\n\t"
    74b2:	f383 8808 	msr	MSP, r3
    74b6:	4770      	bx	lr

000074b8 <__get_BASEPRI>:
 * @return BasePriority
 *
 * Return the content of the base priority register
 */
uint32_t __get_BASEPRI(void)
{
    74b8:	b480      	push	{r7}
    74ba:	b083      	sub	sp, #12
    74bc:	af00      	add	r7, sp, #0
  uint32_t result=0;
    74be:	f04f 0300 	mov.w	r3, #0
    74c2:	607b      	str	r3, [r7, #4]
  
  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
    74c4:	f3ef 8312 	mrs	r3, BASEPRI_MASK
    74c8:	607b      	str	r3, [r7, #4]
  return(result);
    74ca:	687b      	ldr	r3, [r7, #4]
}
    74cc:	4618      	mov	r0, r3
    74ce:	f107 070c 	add.w	r7, r7, #12
    74d2:	46bd      	mov	sp, r7
    74d4:	bc80      	pop	{r7}
    74d6:	4770      	bx	lr

000074d8 <__set_BASEPRI>:
 * @param  basePri  BasePriority
 *
 * Set the base priority register
 */
void __set_BASEPRI(uint32_t value)
{
    74d8:	b480      	push	{r7}
    74da:	b083      	sub	sp, #12
    74dc:	af00      	add	r7, sp, #0
    74de:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
    74e0:	687b      	ldr	r3, [r7, #4]
    74e2:	f383 8811 	msr	BASEPRI, r3
}
    74e6:	f107 070c 	add.w	r7, r7, #12
    74ea:	46bd      	mov	sp, r7
    74ec:	bc80      	pop	{r7}
    74ee:	4770      	bx	lr

000074f0 <__get_PRIMASK>:
 * @return PriMask
 *
 * Return state of the priority mask bit from the priority mask register
 */
uint32_t __get_PRIMASK(void)
{
    74f0:	b480      	push	{r7}
    74f2:	b083      	sub	sp, #12
    74f4:	af00      	add	r7, sp, #0
  uint32_t result=0;
    74f6:	f04f 0300 	mov.w	r3, #0
    74fa:	607b      	str	r3, [r7, #4]

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    74fc:	f3ef 8310 	mrs	r3, PRIMASK
    7500:	607b      	str	r3, [r7, #4]
  return(result);
    7502:	687b      	ldr	r3, [r7, #4]
}
    7504:	4618      	mov	r0, r3
    7506:	f107 070c 	add.w	r7, r7, #12
    750a:	46bd      	mov	sp, r7
    750c:	bc80      	pop	{r7}
    750e:	4770      	bx	lr

00007510 <__set_PRIMASK>:
 * @param  priMask  PriMask
 *
 * Set the priority mask bit in the priority mask register
 */
void __set_PRIMASK(uint32_t priMask)
{
    7510:	b480      	push	{r7}
    7512:	b083      	sub	sp, #12
    7514:	af00      	add	r7, sp, #0
    7516:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
    7518:	687b      	ldr	r3, [r7, #4]
    751a:	f383 8810 	msr	PRIMASK, r3
}
    751e:	f107 070c 	add.w	r7, r7, #12
    7522:	46bd      	mov	sp, r7
    7524:	bc80      	pop	{r7}
    7526:	4770      	bx	lr

00007528 <__get_FAULTMASK>:
 * @return FaultMask
 *
 * Return the content of the fault mask register
 */
uint32_t __get_FAULTMASK(void)
{
    7528:	b480      	push	{r7}
    752a:	b083      	sub	sp, #12
    752c:	af00      	add	r7, sp, #0
  uint32_t result=0;
    752e:	f04f 0300 	mov.w	r3, #0
    7532:	607b      	str	r3, [r7, #4]
  
  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
    7534:	f3ef 8313 	mrs	r3, FAULTMASK
    7538:	607b      	str	r3, [r7, #4]
  return(result);
    753a:	687b      	ldr	r3, [r7, #4]
}
    753c:	4618      	mov	r0, r3
    753e:	f107 070c 	add.w	r7, r7, #12
    7542:	46bd      	mov	sp, r7
    7544:	bc80      	pop	{r7}
    7546:	4770      	bx	lr

00007548 <__set_FAULTMASK>:
 * @param  faultMask  faultMask value
 *
 * Set the fault mask register
 */
void __set_FAULTMASK(uint32_t faultMask)
{
    7548:	b480      	push	{r7}
    754a:	b083      	sub	sp, #12
    754c:	af00      	add	r7, sp, #0
    754e:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
    7550:	687b      	ldr	r3, [r7, #4]
    7552:	f383 8813 	msr	FAULTMASK, r3
}
    7556:	f107 070c 	add.w	r7, r7, #12
    755a:	46bd      	mov	sp, r7
    755c:	bc80      	pop	{r7}
    755e:	4770      	bx	lr

00007560 <__get_CONTROL>:
*  @return Control value
 *
 * Return the content of the control register
 */
uint32_t __get_CONTROL(void)
{
    7560:	b480      	push	{r7}
    7562:	b083      	sub	sp, #12
    7564:	af00      	add	r7, sp, #0
  uint32_t result=0;
    7566:	f04f 0300 	mov.w	r3, #0
    756a:	607b      	str	r3, [r7, #4]

  __ASM volatile ("MRS %0, control" : "=r" (result) );
    756c:	f3ef 8314 	mrs	r3, CONTROL
    7570:	607b      	str	r3, [r7, #4]
  return(result);
    7572:	687b      	ldr	r3, [r7, #4]
}
    7574:	4618      	mov	r0, r3
    7576:	f107 070c 	add.w	r7, r7, #12
    757a:	46bd      	mov	sp, r7
    757c:	bc80      	pop	{r7}
    757e:	4770      	bx	lr

00007580 <__set_CONTROL>:
 * @param  control  Control value
 *
 * Set the control register
 */
void __set_CONTROL(uint32_t control)
{
    7580:	b480      	push	{r7}
    7582:	b083      	sub	sp, #12
    7584:	af00      	add	r7, sp, #0
    7586:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR control, %0" : : "r" (control) );
    7588:	687b      	ldr	r3, [r7, #4]
    758a:	f383 8814 	msr	CONTROL, r3
}
    758e:	f107 070c 	add.w	r7, r7, #12
    7592:	46bd      	mov	sp, r7
    7594:	bc80      	pop	{r7}
    7596:	4770      	bx	lr

00007598 <__REV>:
 * @return        reversed value
 *
 * Reverse byte order in integer value
 */
uint32_t __REV(uint32_t value)
{
    7598:	b480      	push	{r7}
    759a:	b085      	sub	sp, #20
    759c:	af00      	add	r7, sp, #0
    759e:	6078      	str	r0, [r7, #4]
  uint32_t result=0;
    75a0:	f04f 0300 	mov.w	r3, #0
    75a4:	60fb      	str	r3, [r7, #12]
  
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
    75a6:	687b      	ldr	r3, [r7, #4]
    75a8:	ba1b      	rev	r3, r3
    75aa:	60fb      	str	r3, [r7, #12]
  return(result);
    75ac:	68fb      	ldr	r3, [r7, #12]
}
    75ae:	4618      	mov	r0, r3
    75b0:	f107 0714 	add.w	r7, r7, #20
    75b4:	46bd      	mov	sp, r7
    75b6:	bc80      	pop	{r7}
    75b8:	4770      	bx	lr
    75ba:	bf00      	nop

000075bc <__REV16>:
 * @return        reversed value
 *
 * Reverse byte order in unsigned short value
 */
uint32_t __REV16(uint16_t value)
{
    75bc:	b480      	push	{r7}
    75be:	b085      	sub	sp, #20
    75c0:	af00      	add	r7, sp, #0
    75c2:	4603      	mov	r3, r0
    75c4:	80fb      	strh	r3, [r7, #6]
  uint32_t result=0;
    75c6:	f04f 0300 	mov.w	r3, #0
    75ca:	60fb      	str	r3, [r7, #12]
  
  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
    75cc:	88fb      	ldrh	r3, [r7, #6]
    75ce:	ba5b      	rev16	r3, r3
    75d0:	60fb      	str	r3, [r7, #12]
  return(result);
    75d2:	68fb      	ldr	r3, [r7, #12]
}
    75d4:	4618      	mov	r0, r3
    75d6:	f107 0714 	add.w	r7, r7, #20
    75da:	46bd      	mov	sp, r7
    75dc:	bc80      	pop	{r7}
    75de:	4770      	bx	lr

000075e0 <__REVSH>:
 * @return        reversed value
 *
 * Reverse byte order in signed short value with sign extension to integer
 */
int32_t __REVSH(int16_t value)
{
    75e0:	b480      	push	{r7}
    75e2:	b085      	sub	sp, #20
    75e4:	af00      	add	r7, sp, #0
    75e6:	4603      	mov	r3, r0
    75e8:	80fb      	strh	r3, [r7, #6]
  uint32_t result=0;
    75ea:	f04f 0300 	mov.w	r3, #0
    75ee:	60fb      	str	r3, [r7, #12]
  
  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
    75f0:	88fb      	ldrh	r3, [r7, #6]
    75f2:	badb      	revsh	r3, r3
    75f4:	60fb      	str	r3, [r7, #12]
  return(result);
    75f6:	68fb      	ldr	r3, [r7, #12]
}
    75f8:	4618      	mov	r0, r3
    75fa:	f107 0714 	add.w	r7, r7, #20
    75fe:	46bd      	mov	sp, r7
    7600:	bc80      	pop	{r7}
    7602:	4770      	bx	lr

00007604 <__RBIT>:
 * @return        reversed value
 *
 * Reverse bit order of value
 */
uint32_t __RBIT(uint32_t value)
{
    7604:	b480      	push	{r7}
    7606:	b085      	sub	sp, #20
    7608:	af00      	add	r7, sp, #0
    760a:	6078      	str	r0, [r7, #4]
  uint32_t result=0;
    760c:	f04f 0300 	mov.w	r3, #0
    7610:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
    7612:	687b      	ldr	r3, [r7, #4]
    7614:	fa93 f3a3 	rbit	r3, r3
    7618:	60fb      	str	r3, [r7, #12]
   return(result);
    761a:	68fb      	ldr	r3, [r7, #12]
}
    761c:	4618      	mov	r0, r3
    761e:	f107 0714 	add.w	r7, r7, #20
    7622:	46bd      	mov	sp, r7
    7624:	bc80      	pop	{r7}
    7626:	4770      	bx	lr

00007628 <__LDREXB>:
 * @return        value of (*address)
 *
 * Exclusive LDR command for 8 bit value
 */
uint8_t __LDREXB(uint8_t *addr)
{
    7628:	b480      	push	{r7}
    762a:	b085      	sub	sp, #20
    762c:	af00      	add	r7, sp, #0
    762e:	6078      	str	r0, [r7, #4]
    uint8_t result=0;
    7630:	f04f 0300 	mov.w	r3, #0
    7634:	73fb      	strb	r3, [r7, #15]
  
   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
    7636:	687b      	ldr	r3, [r7, #4]
    7638:	e8d3 3f4f 	ldrexb	r3, [r3]
    763c:	73fb      	strb	r3, [r7, #15]
   return(result);
    763e:	7bfb      	ldrb	r3, [r7, #15]
}
    7640:	4618      	mov	r0, r3
    7642:	f107 0714 	add.w	r7, r7, #20
    7646:	46bd      	mov	sp, r7
    7648:	bc80      	pop	{r7}
    764a:	4770      	bx	lr

0000764c <__LDREXH>:
 * @return        value of (*address)
 *
 * Exclusive LDR command for 16 bit values
 */
uint16_t __LDREXH(uint16_t *addr)
{
    764c:	b480      	push	{r7}
    764e:	b085      	sub	sp, #20
    7650:	af00      	add	r7, sp, #0
    7652:	6078      	str	r0, [r7, #4]
    uint16_t result=0;
    7654:	f04f 0300 	mov.w	r3, #0
    7658:	81fb      	strh	r3, [r7, #14]
  
   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
    765a:	687b      	ldr	r3, [r7, #4]
    765c:	e8d3 3f5f 	ldrexh	r3, [r3]
    7660:	81fb      	strh	r3, [r7, #14]
   return(result);
    7662:	89fb      	ldrh	r3, [r7, #14]
}
    7664:	4618      	mov	r0, r3
    7666:	f107 0714 	add.w	r7, r7, #20
    766a:	46bd      	mov	sp, r7
    766c:	bc80      	pop	{r7}
    766e:	4770      	bx	lr

00007670 <__LDREXW>:
 * @return        value of (*address)
 *
 * Exclusive LDR command for 32 bit values
 */
uint32_t __LDREXW(uint32_t *addr)
{
    7670:	b480      	push	{r7}
    7672:	b085      	sub	sp, #20
    7674:	af00      	add	r7, sp, #0
    7676:	6078      	str	r0, [r7, #4]
    uint32_t result=0;
    7678:	f04f 0300 	mov.w	r3, #0
    767c:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    767e:	687b      	ldr	r3, [r7, #4]
    7680:	e853 3f00 	ldrex	r3, [r3]
    7684:	60fb      	str	r3, [r7, #12]
   return(result);
    7686:	68fb      	ldr	r3, [r7, #12]
}
    7688:	4618      	mov	r0, r3
    768a:	f107 0714 	add.w	r7, r7, #20
    768e:	46bd      	mov	sp, r7
    7690:	bc80      	pop	{r7}
    7692:	4770      	bx	lr

00007694 <__STREXB>:
 * @return        successful / failed
 *
 * Exclusive STR command for 8 bit values
 */
uint32_t __STREXB(uint8_t value, uint8_t *addr)
{
    7694:	b480      	push	{r7}
    7696:	b085      	sub	sp, #20
    7698:	af00      	add	r7, sp, #0
    769a:	4603      	mov	r3, r0
    769c:	6039      	str	r1, [r7, #0]
    769e:	71fb      	strb	r3, [r7, #7]
   uint32_t result=0;
    76a0:	f04f 0300 	mov.w	r3, #0
    76a4:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("strexb %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
    76a6:	683b      	ldr	r3, [r7, #0]
    76a8:	79fa      	ldrb	r2, [r7, #7]
    76aa:	e8c3 2f43 	strexb	r3, r2, [r3]
    76ae:	60fb      	str	r3, [r7, #12]
   return(result);
    76b0:	68fb      	ldr	r3, [r7, #12]
}
    76b2:	4618      	mov	r0, r3
    76b4:	f107 0714 	add.w	r7, r7, #20
    76b8:	46bd      	mov	sp, r7
    76ba:	bc80      	pop	{r7}
    76bc:	4770      	bx	lr
    76be:	bf00      	nop

000076c0 <__STREXH>:
 * @return        successful / failed
 *
 * Exclusive STR command for 16 bit values
 */
uint32_t __STREXH(uint16_t value, uint16_t *addr)
{
    76c0:	b480      	push	{r7}
    76c2:	b085      	sub	sp, #20
    76c4:	af00      	add	r7, sp, #0
    76c6:	4603      	mov	r3, r0
    76c8:	6039      	str	r1, [r7, #0]
    76ca:	80fb      	strh	r3, [r7, #6]
   uint32_t result=0;
    76cc:	f04f 0300 	mov.w	r3, #0
    76d0:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("strexh %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
    76d2:	683b      	ldr	r3, [r7, #0]
    76d4:	88fa      	ldrh	r2, [r7, #6]
    76d6:	e8c3 2f53 	strexh	r3, r2, [r3]
    76da:	60fb      	str	r3, [r7, #12]
   return(result);
    76dc:	68fb      	ldr	r3, [r7, #12]
}
    76de:	4618      	mov	r0, r3
    76e0:	f107 0714 	add.w	r7, r7, #20
    76e4:	46bd      	mov	sp, r7
    76e6:	bc80      	pop	{r7}
    76e8:	4770      	bx	lr
    76ea:	bf00      	nop

000076ec <__STREXW>:
 * @return        successful / failed
 *
 * Exclusive STR command for 32 bit values
 */
uint32_t __STREXW(uint32_t value, uint32_t *addr)
{
    76ec:	b480      	push	{r7}
    76ee:	b085      	sub	sp, #20
    76f0:	af00      	add	r7, sp, #0
    76f2:	6078      	str	r0, [r7, #4]
    76f4:	6039      	str	r1, [r7, #0]
   uint32_t result=0;
    76f6:	f04f 0300 	mov.w	r3, #0
    76fa:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("strex %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
    76fc:	683b      	ldr	r3, [r7, #0]
    76fe:	687a      	ldr	r2, [r7, #4]
    7700:	e843 2300 	strex	r3, r2, [r3]
    7704:	60fb      	str	r3, [r7, #12]
   return(result);
    7706:	68fb      	ldr	r3, [r7, #12]
}
    7708:	4618      	mov	r0, r3
    770a:	f107 0714 	add.w	r7, r7, #20
    770e:	46bd      	mov	sp, r7
    7710:	bc80      	pop	{r7}
    7712:	4770      	bx	lr

00007714 <SystemInit>:

/***************************************************************************//**
 * See system_a2fm3fxxx.h for details.
 */
void SystemInit(void)
{
    7714:	b480      	push	{r7}
    7716:	af00      	add	r7, sp, #0
}
    7718:	46bd      	mov	sp, r7
    771a:	bc80      	pop	{r7}
    771c:	4770      	bx	lr
    771e:	bf00      	nop

00007720 <SystemCoreClockUpdate>:

/***************************************************************************//**
 *
 */
void SystemCoreClockUpdate (void)
{
    7720:	b580      	push	{r7, lr}
    7722:	b08a      	sub	sp, #40	; 0x28
    7724:	af00      	add	r7, sp, #0
    uint32_t PclkDiv0;
    uint32_t PclkDiv1;
    uint32_t AceDiv;
    uint32_t FabDiv;

    const uint32_t pclk_div_lut[4] = { 1uL, 2uL, 4uL, 1uL };
    7726:	f643 3300 	movw	r3, #15104	; 0x3b00
    772a:	f2c0 0301 	movt	r3, #1
    772e:	46bc      	mov	ip, r7
    7730:	cb0f      	ldmia	r3!, {r0, r1, r2, r3}
    7732:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}

    /* Read PCLK dividers from system registers. Multiply the value read from
     * system register by two to get actual divider value. */
    PclkDiv0 = pclk_div_lut[((SYSREG->MSS_CLK_CR >> PCLK0_DIV_SHIFT) & PCLK_DIV_MASK)];
    7736:	f242 0300 	movw	r3, #8192	; 0x2000
    773a:	f2ce 0304 	movt	r3, #57348	; 0xe004
    773e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    7740:	ea4f 0393 	mov.w	r3, r3, lsr #2
    7744:	f003 0303 	and.w	r3, r3, #3
    7748:	ea4f 0383 	mov.w	r3, r3, lsl #2
    774c:	f107 0228 	add.w	r2, r7, #40	; 0x28
    7750:	4413      	add	r3, r2
    7752:	f853 3c28 	ldr.w	r3, [r3, #-40]
    7756:	613b      	str	r3, [r7, #16]
    PclkDiv1 = pclk_div_lut[((SYSREG->MSS_CLK_CR >> PCLK1_DIV_SHIFT) & PCLK_DIV_MASK)];
    7758:	f242 0300 	movw	r3, #8192	; 0x2000
    775c:	f2ce 0304 	movt	r3, #57348	; 0xe004
    7760:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    7762:	ea4f 1313 	mov.w	r3, r3, lsr #4
    7766:	f003 0303 	and.w	r3, r3, #3
    776a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    776e:	f107 0228 	add.w	r2, r7, #40	; 0x28
    7772:	4413      	add	r3, r2
    7774:	f853 3c28 	ldr.w	r3, [r3, #-40]
    7778:	617b      	str	r3, [r7, #20]
    AceDiv = pclk_div_lut[((SYSREG->MSS_CLK_CR >> ACE_DIV_SHIFT) & PCLK_DIV_MASK)];
    777a:	f242 0300 	movw	r3, #8192	; 0x2000
    777e:	f2ce 0304 	movt	r3, #57348	; 0xe004
    7782:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    7784:	ea4f 1393 	mov.w	r3, r3, lsr #6
    7788:	f003 0303 	and.w	r3, r3, #3
    778c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    7790:	f107 0228 	add.w	r2, r7, #40	; 0x28
    7794:	4413      	add	r3, r2
    7796:	f853 3c28 	ldr.w	r3, [r3, #-40]
    779a:	61bb      	str	r3, [r7, #24]
    {
        /* Compute the FPGA fabric frequency divider. */
        uint32_t obdiv;
        uint32_t obdivhalf;
        
        obdiv = (SYSREG->MSS_CCC_DIV_CR >> OBDIV_SHIFT) & OBDIV_MASK;
    779c:	f242 0300 	movw	r3, #8192	; 0x2000
    77a0:	f2ce 0304 	movt	r3, #57348	; 0xe004
    77a4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    77a6:	ea4f 2313 	mov.w	r3, r3, lsr #8
    77aa:	f003 031f 	and.w	r3, r3, #31
    77ae:	623b      	str	r3, [r7, #32]
        obdivhalf = (SYSREG->MSS_CCC_DIV_CR >> OBDIVHALF_SHIFT) & OBDIVHALF_MASK;
    77b0:	f242 0300 	movw	r3, #8192	; 0x2000
    77b4:	f2ce 0304 	movt	r3, #57348	; 0xe004
    77b8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    77ba:	ea4f 3353 	mov.w	r3, r3, lsr #13
    77be:	f003 0301 	and.w	r3, r3, #1
    77c2:	627b      	str	r3, [r7, #36]	; 0x24
        FabDiv = obdiv + 1uL;
    77c4:	6a3b      	ldr	r3, [r7, #32]
    77c6:	f103 0301 	add.w	r3, r3, #1
    77ca:	61fb      	str	r3, [r7, #28]
        if ( obdivhalf != 0uL )
    77cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    77ce:	2b00      	cmp	r3, #0
    77d0:	d003      	beq.n	77da <SystemCoreClockUpdate+0xba>
        {
            FabDiv = FabDiv * 2uL;
    77d2:	69fb      	ldr	r3, [r7, #28]
    77d4:	ea4f 0343 	mov.w	r3, r3, lsl #1
    77d8:	61fb      	str	r3, [r7, #28]
    }
    
    /* Retrieve FCLK from eNVM spare pages if Actel system boot programmed as part of the system. */
    
    /* Read system clock from eNVM spare pages. */
    SystemCoreClock = GetSystemClock();
    77da:	f000 f849 	bl	7870 <GetSystemClock>
    77de:	4602      	mov	r2, r0
    77e0:	f240 03c4 	movw	r3, #196	; 0xc4
    77e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    77e8:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK0 = SystemCoreClock / PclkDiv0;
    77ea:	f240 03c4 	movw	r3, #196	; 0xc4
    77ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    77f2:	681a      	ldr	r2, [r3, #0]
    77f4:	693b      	ldr	r3, [r7, #16]
    77f6:	fbb2 f2f3 	udiv	r2, r2, r3
    77fa:	f240 03c8 	movw	r3, #200	; 0xc8
    77fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7802:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK1 = SystemCoreClock / PclkDiv1;
    7804:	f240 03c4 	movw	r3, #196	; 0xc4
    7808:	f2c2 0300 	movt	r3, #8192	; 0x2000
    780c:	681a      	ldr	r2, [r3, #0]
    780e:	697b      	ldr	r3, [r7, #20]
    7810:	fbb2 f2f3 	udiv	r2, r2, r3
    7814:	f240 03cc 	movw	r3, #204	; 0xcc
    7818:	f2c2 0300 	movt	r3, #8192	; 0x2000
    781c:	601a      	str	r2, [r3, #0]
    g_FrequencyACE = SystemCoreClock / AceDiv;
    781e:	f240 03c4 	movw	r3, #196	; 0xc4
    7822:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7826:	681a      	ldr	r2, [r3, #0]
    7828:	69bb      	ldr	r3, [r7, #24]
    782a:	fbb2 f2f3 	udiv	r2, r2, r3
    782e:	f240 03d0 	movw	r3, #208	; 0xd0
    7832:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7836:	601a      	str	r2, [r3, #0]
    g_FrequencyFPGA = SystemCoreClock / FabDiv;
    7838:	f240 03c4 	movw	r3, #196	; 0xc4
    783c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7840:	681a      	ldr	r2, [r3, #0]
    7842:	69fb      	ldr	r3, [r7, #28]
    7844:	fbb2 f2f3 	udiv	r2, r2, r3
    7848:	f240 03d4 	movw	r3, #212	; 0xd4
    784c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7850:	601a      	str	r2, [r3, #0]
    
    /* Keep SystemFrequency as well as SystemCoreClock for legacy reasons. */
    SystemFrequency = SystemCoreClock;
    7852:	f240 03c4 	movw	r3, #196	; 0xc4
    7856:	f2c2 0300 	movt	r3, #8192	; 0x2000
    785a:	681a      	ldr	r2, [r3, #0]
    785c:	f240 03c0 	movw	r3, #192	; 0xc0
    7860:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7864:	601a      	str	r2, [r3, #0]
}
    7866:	f107 0728 	add.w	r7, r7, #40	; 0x28
    786a:	46bd      	mov	sp, r7
    786c:	bd80      	pop	{r7, pc}
    786e:	bf00      	nop

00007870 <GetSystemClock>:
 * retrieved from eNVM spare pages.
 * The FCLK frequency value selected in the MSS Configurator software tool is
 * stored in eNVM spare pages as part of the Actel system boot configuration data.
 */
uint32_t GetSystemClock( void )
{
    7870:	b480      	push	{r7}
    7872:	b087      	sub	sp, #28
    7874:	af00      	add	r7, sp, #0
    uint32_t fclk = 0uL;
    7876:	f04f 0300 	mov.w	r3, #0
    787a:	603b      	str	r3, [r7, #0]
    
    uint32_t * p_sysboot_key = SYSBOOT_KEY_ADDR;
    787c:	f640 031c 	movw	r3, #2076	; 0x81c
    7880:	f2c6 0308 	movt	r3, #24584	; 0x6008
    7884:	607b      	str	r3, [r7, #4]
    
    if ( SYSBOOT_KEY_VALUE == *p_sysboot_key )
    7886:	687b      	ldr	r3, [r7, #4]
    7888:	681a      	ldr	r2, [r3, #0]
    788a:	f244 3341 	movw	r3, #17217	; 0x4341
    788e:	f6c4 4354 	movt	r3, #19540	; 0x4c54
    7892:	429a      	cmp	r2, r3
    7894:	d135      	bne.n	7902 <GetSystemClock+0x92>
    {
        /* Actel system boot programmed, check if it has the FCLK value stored. */
        uint32_t *p_sysboot_version = SYSBOOT_VERSION_ADDR;
    7896:	f640 0340 	movw	r3, #2112	; 0x840
    789a:	f2c6 0308 	movt	r3, #24584	; 0x6008
    789e:	60bb      	str	r3, [r7, #8]
        uint32_t sysboot_version = *p_sysboot_version;
    78a0:	68bb      	ldr	r3, [r7, #8]
    78a2:	681b      	ldr	r3, [r3, #0]
    78a4:	60fb      	str	r3, [r7, #12]
        
        sysboot_version &= SYSBOOT_VERSION_MASK;
    78a6:	68fb      	ldr	r3, [r7, #12]
    78a8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    78ac:	60fb      	str	r3, [r7, #12]
        
        if ( sysboot_version >= MIN_SYSBOOT_VERSION )
    78ae:	68fa      	ldr	r2, [r7, #12]
    78b0:	f240 3300 	movw	r3, #768	; 0x300
    78b4:	f2c0 0301 	movt	r3, #1
    78b8:	429a      	cmp	r2, r3
    78ba:	d922      	bls.n	7902 <GetSystemClock+0x92>
        {
            /* Handle change of eNVM location of FCLK between 1.3.x and 2.x.x versions of the system boot. */
            if ( sysboot_version < SYSBOOT_VERSION_2_X )
    78bc:	68fa      	ldr	r2, [r7, #12]
    78be:	f64f 73ff 	movw	r3, #65535	; 0xffff
    78c2:	f2c0 0301 	movt	r3, #1
    78c6:	429a      	cmp	r2, r3
    78c8:	d808      	bhi.n	78dc <GetSystemClock+0x6c>
            {
                /* Read FCLK value from MSS configurator generated configuration
                 * data stored in eNVM spare pages as part of system boot version 1.3.x
                 * configuration tables. */
                uint32_t *p_fclk = SYSBOOT_1_3_FCLK_ADDR;
    78ca:	f241 632c 	movw	r3, #5676	; 0x162c
    78ce:	f2c6 0308 	movt	r3, #24584	; 0x6008
    78d2:	613b      	str	r3, [r7, #16]
                fclk = *p_fclk;
    78d4:	693b      	ldr	r3, [r7, #16]
    78d6:	681b      	ldr	r3, [r3, #0]
    78d8:	603b      	str	r3, [r7, #0]
    78da:	e012      	b.n	7902 <GetSystemClock+0x92>
            }
            else if ( sysboot_version < MAX_SYSBOOT_VERSION )
    78dc:	68fa      	ldr	r2, [r7, #12]
    78de:	f64f 73ff 	movw	r3, #65535	; 0xffff
    78e2:	f2c0 0302 	movt	r3, #2
    78e6:	429a      	cmp	r2, r3
    78e8:	d808      	bhi.n	78fc <GetSystemClock+0x8c>
            {
                /* Read FCLK value from MSS configurator generated configuration
                 * data stored in eNVM spare pages as part of system boot version 2.x.x
                 * configuration tables. */
                uint32_t *p_fclk = SYSBOOT_2_x_FCLK_ADDR;
    78ea:	f641 63ac 	movw	r3, #7852	; 0x1eac
    78ee:	f2c6 0308 	movt	r3, #24584	; 0x6008
    78f2:	617b      	str	r3, [r7, #20]
                fclk = *p_fclk;
    78f4:	697b      	ldr	r3, [r7, #20]
    78f6:	681b      	ldr	r3, [r3, #0]
    78f8:	603b      	str	r3, [r7, #0]
    78fa:	e002      	b.n	7902 <GetSystemClock+0x92>
            }
            else
            {
                fclk = 0uL;
    78fc:	f04f 0300 	mov.w	r3, #0
    7900:	603b      	str	r3, [r7, #0]
            }
        }
    }
    
    if ( 0uL == fclk )
    7902:	683b      	ldr	r3, [r7, #0]
    7904:	2b00      	cmp	r3, #0
    7906:	d105      	bne.n	7914 <GetSystemClock+0xa4>
        /* 
         * Could not retrieve FCLK from system boot configuration data. Fall back
         * to using SMARTFUSION_FCLK_FREQ which must then be defined as part of
         * project settings.
         */
        ASSERT( SMARTFUSION_FCLK_FREQ_DEFINED );
    7908:	be00      	bkpt	0x0000
        fclk = SMARTFUSION_FCLK_FREQ;
    790a:	f647 0340 	movw	r3, #30784	; 0x7840
    790e:	f2c0 137d 	movt	r3, #381	; 0x17d
    7912:	603b      	str	r3, [r7, #0]
    }
    
    return fclk;
    7914:	683b      	ldr	r3, [r7, #0]
}
    7916:	4618      	mov	r0, r3
    7918:	f107 071c 	add.w	r7, r7, #28
    791c:	46bd      	mov	sp, r7
    791e:	bc80      	pop	{r7}
    7920:	4770      	bx	lr
    7922:	bf00      	nop

00007924 <_close>:

/*==============================================================================
 * Close a file.
 */
int _close(int file)
{
    7924:	b480      	push	{r7}
    7926:	b083      	sub	sp, #12
    7928:	af00      	add	r7, sp, #0
    792a:	6078      	str	r0, [r7, #4]
    return -1;
    792c:	f04f 33ff 	mov.w	r3, #4294967295
}
    7930:	4618      	mov	r0, r3
    7932:	f107 070c 	add.w	r7, r7, #12
    7936:	46bd      	mov	sp, r7
    7938:	bc80      	pop	{r7}
    793a:	4770      	bx	lr

0000793c <_execve>:

/*==============================================================================
 * Transfer control to a new process.
 */
int _execve(char *name, char **argv, char **env)
{
    793c:	b480      	push	{r7}
    793e:	b085      	sub	sp, #20
    7940:	af00      	add	r7, sp, #0
    7942:	60f8      	str	r0, [r7, #12]
    7944:	60b9      	str	r1, [r7, #8]
    7946:	607a      	str	r2, [r7, #4]
    errno = ENOMEM;
    7948:	f64c 33e8 	movw	r3, #52200	; 0xcbe8
    794c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7950:	f04f 020c 	mov.w	r2, #12
    7954:	601a      	str	r2, [r3, #0]
    return -1;
    7956:	f04f 33ff 	mov.w	r3, #4294967295
}
    795a:	4618      	mov	r0, r3
    795c:	f107 0714 	add.w	r7, r7, #20
    7960:	46bd      	mov	sp, r7
    7962:	bc80      	pop	{r7}
    7964:	4770      	bx	lr
    7966:	bf00      	nop

00007968 <_exit>:
{
	/* Should we force a system reset? */
	while( 1 )
	{
		;
	}
    7968:	b480      	push	{r7}
    796a:	b083      	sub	sp, #12
    796c:	af00      	add	r7, sp, #0
    796e:	6078      	str	r0, [r7, #4]
    7970:	e7fe      	b.n	7970 <_exit+0x8>
    7972:	bf00      	nop

00007974 <_fork>:

/*==============================================================================
 * Create a new process.
 */
int _fork(void)
{
    7974:	b480      	push	{r7}
    7976:	af00      	add	r7, sp, #0
    errno = EAGAIN;
    7978:	f64c 33e8 	movw	r3, #52200	; 0xcbe8
    797c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7980:	f04f 020b 	mov.w	r2, #11
    7984:	601a      	str	r2, [r3, #0]
    return -1;
    7986:	f04f 33ff 	mov.w	r3, #4294967295
}
    798a:	4618      	mov	r0, r3
    798c:	46bd      	mov	sp, r7
    798e:	bc80      	pop	{r7}
    7990:	4770      	bx	lr
    7992:	bf00      	nop

00007994 <_fstat>:

/*==============================================================================
 * Status of an open file.
 */
int _fstat(int file, struct stat *st)
{
    7994:	b480      	push	{r7}
    7996:	b083      	sub	sp, #12
    7998:	af00      	add	r7, sp, #0
    799a:	6078      	str	r0, [r7, #4]
    799c:	6039      	str	r1, [r7, #0]
    st->st_mode = S_IFCHR;
    799e:	683b      	ldr	r3, [r7, #0]
    79a0:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    79a4:	605a      	str	r2, [r3, #4]
    return 0;
    79a6:	f04f 0300 	mov.w	r3, #0
}
    79aa:	4618      	mov	r0, r3
    79ac:	f107 070c 	add.w	r7, r7, #12
    79b0:	46bd      	mov	sp, r7
    79b2:	bc80      	pop	{r7}
    79b4:	4770      	bx	lr
    79b6:	bf00      	nop

000079b8 <_getpid>:

/*==============================================================================
 * Process-ID
 */
int _getpid(void)
{
    79b8:	b480      	push	{r7}
    79ba:	af00      	add	r7, sp, #0
    return 1;
    79bc:	f04f 0301 	mov.w	r3, #1
}
    79c0:	4618      	mov	r0, r3
    79c2:	46bd      	mov	sp, r7
    79c4:	bc80      	pop	{r7}
    79c6:	4770      	bx	lr

000079c8 <_isatty>:

/*==============================================================================
 * Query whether output stream is a terminal.
 */
int _isatty(int file)
{
    79c8:	b480      	push	{r7}
    79ca:	b083      	sub	sp, #12
    79cc:	af00      	add	r7, sp, #0
    79ce:	6078      	str	r0, [r7, #4]
    return 1;
    79d0:	f04f 0301 	mov.w	r3, #1
}
    79d4:	4618      	mov	r0, r3
    79d6:	f107 070c 	add.w	r7, r7, #12
    79da:	46bd      	mov	sp, r7
    79dc:	bc80      	pop	{r7}
    79de:	4770      	bx	lr

000079e0 <_kill>:

/*==============================================================================
 * Send a signal.
 */
int _kill(int pid, int sig)
{
    79e0:	b480      	push	{r7}
    79e2:	b083      	sub	sp, #12
    79e4:	af00      	add	r7, sp, #0
    79e6:	6078      	str	r0, [r7, #4]
    79e8:	6039      	str	r1, [r7, #0]
    errno = EINVAL;
    79ea:	f64c 33e8 	movw	r3, #52200	; 0xcbe8
    79ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    79f2:	f04f 0216 	mov.w	r2, #22
    79f6:	601a      	str	r2, [r3, #0]
    return -1;
    79f8:	f04f 33ff 	mov.w	r3, #4294967295
}
    79fc:	4618      	mov	r0, r3
    79fe:	f107 070c 	add.w	r7, r7, #12
    7a02:	46bd      	mov	sp, r7
    7a04:	bc80      	pop	{r7}
    7a06:	4770      	bx	lr

00007a08 <_link>:

/*==============================================================================
 * Establish a new name for an existing file.
 */
int _link(char *old, char *new)
{
    7a08:	b480      	push	{r7}
    7a0a:	b083      	sub	sp, #12
    7a0c:	af00      	add	r7, sp, #0
    7a0e:	6078      	str	r0, [r7, #4]
    7a10:	6039      	str	r1, [r7, #0]
    errno = EMLINK;
    7a12:	f64c 33e8 	movw	r3, #52200	; 0xcbe8
    7a16:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7a1a:	f04f 021f 	mov.w	r2, #31
    7a1e:	601a      	str	r2, [r3, #0]
    return -1;
    7a20:	f04f 33ff 	mov.w	r3, #4294967295
}
    7a24:	4618      	mov	r0, r3
    7a26:	f107 070c 	add.w	r7, r7, #12
    7a2a:	46bd      	mov	sp, r7
    7a2c:	bc80      	pop	{r7}
    7a2e:	4770      	bx	lr

00007a30 <_lseek>:

/*==============================================================================
 * Set position in a file.
 */
int _lseek(int file, int ptr, int dir)
{
    7a30:	b480      	push	{r7}
    7a32:	b085      	sub	sp, #20
    7a34:	af00      	add	r7, sp, #0
    7a36:	60f8      	str	r0, [r7, #12]
    7a38:	60b9      	str	r1, [r7, #8]
    7a3a:	607a      	str	r2, [r7, #4]
    return 0;
    7a3c:	f04f 0300 	mov.w	r3, #0
}
    7a40:	4618      	mov	r0, r3
    7a42:	f107 0714 	add.w	r7, r7, #20
    7a46:	46bd      	mov	sp, r7
    7a48:	bc80      	pop	{r7}
    7a4a:	4770      	bx	lr

00007a4c <_open>:

/*==============================================================================
 * Open a file.
 */
int _open(const char *name, int flags, int mode)
{
    7a4c:	b480      	push	{r7}
    7a4e:	b085      	sub	sp, #20
    7a50:	af00      	add	r7, sp, #0
    7a52:	60f8      	str	r0, [r7, #12]
    7a54:	60b9      	str	r1, [r7, #8]
    7a56:	607a      	str	r2, [r7, #4]
    return -1;
    7a58:	f04f 33ff 	mov.w	r3, #4294967295
}
    7a5c:	4618      	mov	r0, r3
    7a5e:	f107 0714 	add.w	r7, r7, #20
    7a62:	46bd      	mov	sp, r7
    7a64:	bc80      	pop	{r7}
    7a66:	4770      	bx	lr

00007a68 <_read>:

/*==============================================================================
 * Read from a file.
 */
int _read(int file, char *ptr, int len)
{
    7a68:	b480      	push	{r7}
    7a6a:	b085      	sub	sp, #20
    7a6c:	af00      	add	r7, sp, #0
    7a6e:	60f8      	str	r0, [r7, #12]
    7a70:	60b9      	str	r1, [r7, #8]
    7a72:	607a      	str	r2, [r7, #4]
    return 0;
    7a74:	f04f 0300 	mov.w	r3, #0
}
    7a78:	4618      	mov	r0, r3
    7a7a:	f107 0714 	add.w	r7, r7, #20
    7a7e:	46bd      	mov	sp, r7
    7a80:	bc80      	pop	{r7}
    7a82:	4770      	bx	lr

00007a84 <_sbrk>:
 * it is useful to have a working implementation. The following suffices for a
 * standalone system; it exploits the symbol _end automatically defined by the
 * GNU linker. 
 */
caddr_t _sbrk(int incr)
{
    7a84:	b580      	push	{r7, lr}
    7a86:	b084      	sub	sp, #16
    7a88:	af00      	add	r7, sp, #0
    7a8a:	6078      	str	r0, [r7, #4]
    extern char _end;		/* Defined by the linker */
    static char *heap_end;
    char *prev_heap_end;
    char * stack_ptr;
    
    if (heap_end == 0)
    7a8c:	f642 7360 	movw	r3, #12128	; 0x2f60
    7a90:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7a94:	681b      	ldr	r3, [r3, #0]
    7a96:	2b00      	cmp	r3, #0
    7a98:	d108      	bne.n	7aac <_sbrk+0x28>
    {
      heap_end = &_end;
    7a9a:	f642 7360 	movw	r3, #12128	; 0x2f60
    7a9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7aa2:	f64c 32f0 	movw	r2, #52208	; 0xcbf0
    7aa6:	f2c2 0200 	movt	r2, #8192	; 0x2000
    7aaa:	601a      	str	r2, [r3, #0]
    }
    
    prev_heap_end = heap_end;
    7aac:	f642 7360 	movw	r3, #12128	; 0x2f60
    7ab0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7ab4:	681b      	ldr	r3, [r3, #0]
    7ab6:	60bb      	str	r3, [r7, #8]
    asm volatile ("MRS %0, msp" : "=r" (stack_ptr) );
    7ab8:	f3ef 8308 	mrs	r3, MSP
    7abc:	60fb      	str	r3, [r7, #12]
    if (heap_end + incr > stack_ptr)
    7abe:	f642 7360 	movw	r3, #12128	; 0x2f60
    7ac2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7ac6:	681a      	ldr	r2, [r3, #0]
    7ac8:	687b      	ldr	r3, [r7, #4]
    7aca:	441a      	add	r2, r3
    7acc:	68fb      	ldr	r3, [r7, #12]
    7ace:	429a      	cmp	r2, r3
    7ad0:	d90b      	bls.n	7aea <_sbrk+0x66>
    {
      write (1, "Heap and stack collision\n", 25);
    7ad2:	f04f 0001 	mov.w	r0, #1
    7ad6:	f643 3110 	movw	r1, #15120	; 0x3b10
    7ada:	f2c0 0101 	movt	r1, #1
    7ade:	f04f 0219 	mov.w	r2, #25
    7ae2:	f7f9 fb51 	bl	1188 <write>
      abort ();
    7ae6:	f009 ff55 	bl	11994 <abort>
    }
  
    heap_end += incr;
    7aea:	f642 7360 	movw	r3, #12128	; 0x2f60
    7aee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7af2:	681a      	ldr	r2, [r3, #0]
    7af4:	687b      	ldr	r3, [r7, #4]
    7af6:	441a      	add	r2, r3
    7af8:	f642 7360 	movw	r3, #12128	; 0x2f60
    7afc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7b00:	601a      	str	r2, [r3, #0]
    return (caddr_t) prev_heap_end;
    7b02:	68bb      	ldr	r3, [r7, #8]
}
    7b04:	4618      	mov	r0, r3
    7b06:	f107 0710 	add.w	r7, r7, #16
    7b0a:	46bd      	mov	sp, r7
    7b0c:	bd80      	pop	{r7, pc}
    7b0e:	bf00      	nop

00007b10 <_stat>:

/*==============================================================================
 * Status of a file (by name).
 */
int _stat(char *file, struct stat *st)
{
    7b10:	b480      	push	{r7}
    7b12:	b083      	sub	sp, #12
    7b14:	af00      	add	r7, sp, #0
    7b16:	6078      	str	r0, [r7, #4]
    7b18:	6039      	str	r1, [r7, #0]
    st->st_mode = S_IFCHR;
    7b1a:	683b      	ldr	r3, [r7, #0]
    7b1c:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    7b20:	605a      	str	r2, [r3, #4]
    return 0;
    7b22:	f04f 0300 	mov.w	r3, #0
}
    7b26:	4618      	mov	r0, r3
    7b28:	f107 070c 	add.w	r7, r7, #12
    7b2c:	46bd      	mov	sp, r7
    7b2e:	bc80      	pop	{r7}
    7b30:	4770      	bx	lr
    7b32:	bf00      	nop

00007b34 <_times>:

/*==============================================================================
 * Timing information for current process.
 */
int _times(struct tms *buf)
{
    7b34:	b480      	push	{r7}
    7b36:	b083      	sub	sp, #12
    7b38:	af00      	add	r7, sp, #0
    7b3a:	6078      	str	r0, [r7, #4]
    return -1;
    7b3c:	f04f 33ff 	mov.w	r3, #4294967295
}
    7b40:	4618      	mov	r0, r3
    7b42:	f107 070c 	add.w	r7, r7, #12
    7b46:	46bd      	mov	sp, r7
    7b48:	bc80      	pop	{r7}
    7b4a:	4770      	bx	lr

00007b4c <_unlink>:

/*==============================================================================
 * Remove a file's directory entry.
 */
int _unlink(char *name)
{
    7b4c:	b480      	push	{r7}
    7b4e:	b083      	sub	sp, #12
    7b50:	af00      	add	r7, sp, #0
    7b52:	6078      	str	r0, [r7, #4]
    errno = ENOENT;
    7b54:	f64c 33e8 	movw	r3, #52200	; 0xcbe8
    7b58:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7b5c:	f04f 0202 	mov.w	r2, #2
    7b60:	601a      	str	r2, [r3, #0]
    return -1;
    7b62:	f04f 33ff 	mov.w	r3, #4294967295
}
    7b66:	4618      	mov	r0, r3
    7b68:	f107 070c 	add.w	r7, r7, #12
    7b6c:	46bd      	mov	sp, r7
    7b6e:	bc80      	pop	{r7}
    7b70:	4770      	bx	lr
    7b72:	bf00      	nop

00007b74 <_wait>:

/*==============================================================================
 * Wait for a child process.
 */
int _wait(int *status)
{
    7b74:	b480      	push	{r7}
    7b76:	b083      	sub	sp, #12
    7b78:	af00      	add	r7, sp, #0
    7b7a:	6078      	str	r0, [r7, #4]
    errno = ECHILD;
    7b7c:	f64c 33e8 	movw	r3, #52200	; 0xcbe8
    7b80:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7b84:	f04f 020a 	mov.w	r2, #10
    7b88:	601a      	str	r2, [r3, #0]
    return -1;
    7b8a:	f04f 33ff 	mov.w	r3, #4294967295
}
    7b8e:	4618      	mov	r0, r3
    7b90:	f107 070c 	add.w	r7, r7, #12
    7b94:	46bd      	mov	sp, r7
    7b96:	bc80      	pop	{r7}
    7b98:	4770      	bx	lr
    7b9a:	bf00      	nop

00007b9c <_write_r>:
 * all files, including stdoutso if you need to generate any output, for
 * example to a serial port for debugging, you should make your minimal write
 * capable of doing this.
 */
int _write_r( void * reent, int file, char * ptr, int len )
{
    7b9c:	b480      	push	{r7}
    7b9e:	b085      	sub	sp, #20
    7ba0:	af00      	add	r7, sp, #0
    7ba2:	60f8      	str	r0, [r7, #12]
    7ba4:	60b9      	str	r1, [r7, #8]
    7ba6:	607a      	str	r2, [r7, #4]
    7ba8:	603b      	str	r3, [r7, #0]
	 */
	MSS_UART_polled_tx( &g_mss_uart0, (uint8_t *)ptr, len );
	
	return len;
#else	/* ACTEL_STDIO_THRU_UART */
	return 0;
    7baa:	f04f 0300 	mov.w	r3, #0
#endif	/* ACTEL_STDIO_THRU_UART */
}
    7bae:	4618      	mov	r0, r3
    7bb0:	f107 0714 	add.w	r7, r7, #20
    7bb4:	46bd      	mov	sp, r7
    7bb6:	bc80      	pop	{r7}
    7bb8:	4770      	bx	lr
    7bba:	bf00      	nop

00007bbc <buf_setup>:

/*---------------------------------------------------------------------------*/
static void
buf_setup(struct psock_buf *buf,
	  u8_t *bufptr, u16_t bufsize)
{
    7bbc:	b480      	push	{r7}
    7bbe:	b085      	sub	sp, #20
    7bc0:	af00      	add	r7, sp, #0
    7bc2:	60f8      	str	r0, [r7, #12]
    7bc4:	60b9      	str	r1, [r7, #8]
    7bc6:	4613      	mov	r3, r2
    7bc8:	80fb      	strh	r3, [r7, #6]
  buf->ptr = bufptr;
    7bca:	68fb      	ldr	r3, [r7, #12]
    7bcc:	68ba      	ldr	r2, [r7, #8]
    7bce:	601a      	str	r2, [r3, #0]
  buf->left = bufsize;
    7bd0:	68fb      	ldr	r3, [r7, #12]
    7bd2:	88fa      	ldrh	r2, [r7, #6]
    7bd4:	809a      	strh	r2, [r3, #4]
}
    7bd6:	f107 0714 	add.w	r7, r7, #20
    7bda:	46bd      	mov	sp, r7
    7bdc:	bc80      	pop	{r7}
    7bde:	4770      	bx	lr

00007be0 <buf_bufdata>:
/*---------------------------------------------------------------------------*/
static u8_t
buf_bufdata(struct psock_buf *buf, u16_t len,
	    u8_t **dataptr, u16_t *datalen)
{
    7be0:	b580      	push	{r7, lr}
    7be2:	b084      	sub	sp, #16
    7be4:	af00      	add	r7, sp, #0
    7be6:	60f8      	str	r0, [r7, #12]
    7be8:	607a      	str	r2, [r7, #4]
    7bea:	603b      	str	r3, [r7, #0]
    7bec:	460b      	mov	r3, r1
    7bee:	817b      	strh	r3, [r7, #10]
  ( void ) len;
  if(*datalen < buf->left) {
    7bf0:	683b      	ldr	r3, [r7, #0]
    7bf2:	881a      	ldrh	r2, [r3, #0]
    7bf4:	68fb      	ldr	r3, [r7, #12]
    7bf6:	889b      	ldrh	r3, [r3, #4]
    7bf8:	429a      	cmp	r2, r3
    7bfa:	d228      	bcs.n	7c4e <buf_bufdata+0x6e>
    memcpy(buf->ptr, *dataptr, *datalen);
    7bfc:	68fb      	ldr	r3, [r7, #12]
    7bfe:	6819      	ldr	r1, [r3, #0]
    7c00:	687b      	ldr	r3, [r7, #4]
    7c02:	681a      	ldr	r2, [r3, #0]
    7c04:	683b      	ldr	r3, [r7, #0]
    7c06:	881b      	ldrh	r3, [r3, #0]
    7c08:	4608      	mov	r0, r1
    7c0a:	4611      	mov	r1, r2
    7c0c:	461a      	mov	r2, r3
    7c0e:	f009 fef1 	bl	119f4 <memcpy>
    buf->ptr += *datalen;
    7c12:	68fb      	ldr	r3, [r7, #12]
    7c14:	681a      	ldr	r2, [r3, #0]
    7c16:	683b      	ldr	r3, [r7, #0]
    7c18:	881b      	ldrh	r3, [r3, #0]
    7c1a:	441a      	add	r2, r3
    7c1c:	68fb      	ldr	r3, [r7, #12]
    7c1e:	601a      	str	r2, [r3, #0]
    buf->left -= *datalen;
    7c20:	68fb      	ldr	r3, [r7, #12]
    7c22:	889a      	ldrh	r2, [r3, #4]
    7c24:	683b      	ldr	r3, [r7, #0]
    7c26:	881b      	ldrh	r3, [r3, #0]
    7c28:	ebc3 0302 	rsb	r3, r3, r2
    7c2c:	b29a      	uxth	r2, r3
    7c2e:	68fb      	ldr	r3, [r7, #12]
    7c30:	809a      	strh	r2, [r3, #4]
    *dataptr += *datalen;
    7c32:	687b      	ldr	r3, [r7, #4]
    7c34:	681a      	ldr	r2, [r3, #0]
    7c36:	683b      	ldr	r3, [r7, #0]
    7c38:	881b      	ldrh	r3, [r3, #0]
    7c3a:	441a      	add	r2, r3
    7c3c:	687b      	ldr	r3, [r7, #4]
    7c3e:	601a      	str	r2, [r3, #0]
    *datalen = 0;
    7c40:	683b      	ldr	r3, [r7, #0]
    7c42:	f04f 0200 	mov.w	r2, #0
    7c46:	801a      	strh	r2, [r3, #0]
    return BUF_NOT_FULL;
    7c48:	f04f 0300 	mov.w	r3, #0
    7c4c:	e051      	b.n	7cf2 <buf_bufdata+0x112>
  } else if(*datalen == buf->left) {
    7c4e:	683b      	ldr	r3, [r7, #0]
    7c50:	881a      	ldrh	r2, [r3, #0]
    7c52:	68fb      	ldr	r3, [r7, #12]
    7c54:	889b      	ldrh	r3, [r3, #4]
    7c56:	429a      	cmp	r2, r3
    7c58:	d123      	bne.n	7ca2 <buf_bufdata+0xc2>
    memcpy(buf->ptr, *dataptr, *datalen);
    7c5a:	68fb      	ldr	r3, [r7, #12]
    7c5c:	6819      	ldr	r1, [r3, #0]
    7c5e:	687b      	ldr	r3, [r7, #4]
    7c60:	681a      	ldr	r2, [r3, #0]
    7c62:	683b      	ldr	r3, [r7, #0]
    7c64:	881b      	ldrh	r3, [r3, #0]
    7c66:	4608      	mov	r0, r1
    7c68:	4611      	mov	r1, r2
    7c6a:	461a      	mov	r2, r3
    7c6c:	f009 fec2 	bl	119f4 <memcpy>
    buf->ptr += *datalen;
    7c70:	68fb      	ldr	r3, [r7, #12]
    7c72:	681a      	ldr	r2, [r3, #0]
    7c74:	683b      	ldr	r3, [r7, #0]
    7c76:	881b      	ldrh	r3, [r3, #0]
    7c78:	441a      	add	r2, r3
    7c7a:	68fb      	ldr	r3, [r7, #12]
    7c7c:	601a      	str	r2, [r3, #0]
    buf->left = 0;
    7c7e:	68fb      	ldr	r3, [r7, #12]
    7c80:	f04f 0200 	mov.w	r2, #0
    7c84:	809a      	strh	r2, [r3, #4]
    *dataptr += *datalen;
    7c86:	687b      	ldr	r3, [r7, #4]
    7c88:	681a      	ldr	r2, [r3, #0]
    7c8a:	683b      	ldr	r3, [r7, #0]
    7c8c:	881b      	ldrh	r3, [r3, #0]
    7c8e:	441a      	add	r2, r3
    7c90:	687b      	ldr	r3, [r7, #4]
    7c92:	601a      	str	r2, [r3, #0]
    *datalen = 0;
    7c94:	683b      	ldr	r3, [r7, #0]
    7c96:	f04f 0200 	mov.w	r2, #0
    7c9a:	801a      	strh	r2, [r3, #0]
    return BUF_FULL;
    7c9c:	f04f 0301 	mov.w	r3, #1
    7ca0:	e027      	b.n	7cf2 <buf_bufdata+0x112>
  } else {
    memcpy(buf->ptr, *dataptr, buf->left);
    7ca2:	68fb      	ldr	r3, [r7, #12]
    7ca4:	6819      	ldr	r1, [r3, #0]
    7ca6:	687b      	ldr	r3, [r7, #4]
    7ca8:	681a      	ldr	r2, [r3, #0]
    7caa:	68fb      	ldr	r3, [r7, #12]
    7cac:	889b      	ldrh	r3, [r3, #4]
    7cae:	4608      	mov	r0, r1
    7cb0:	4611      	mov	r1, r2
    7cb2:	461a      	mov	r2, r3
    7cb4:	f009 fe9e 	bl	119f4 <memcpy>
    buf->ptr += buf->left;
    7cb8:	68fb      	ldr	r3, [r7, #12]
    7cba:	681a      	ldr	r2, [r3, #0]
    7cbc:	68fb      	ldr	r3, [r7, #12]
    7cbe:	889b      	ldrh	r3, [r3, #4]
    7cc0:	441a      	add	r2, r3
    7cc2:	68fb      	ldr	r3, [r7, #12]
    7cc4:	601a      	str	r2, [r3, #0]
    *datalen -= buf->left;
    7cc6:	683b      	ldr	r3, [r7, #0]
    7cc8:	881a      	ldrh	r2, [r3, #0]
    7cca:	68fb      	ldr	r3, [r7, #12]
    7ccc:	889b      	ldrh	r3, [r3, #4]
    7cce:	ebc3 0302 	rsb	r3, r3, r2
    7cd2:	b29a      	uxth	r2, r3
    7cd4:	683b      	ldr	r3, [r7, #0]
    7cd6:	801a      	strh	r2, [r3, #0]
    *dataptr += buf->left;
    7cd8:	687b      	ldr	r3, [r7, #4]
    7cda:	681a      	ldr	r2, [r3, #0]
    7cdc:	68fb      	ldr	r3, [r7, #12]
    7cde:	889b      	ldrh	r3, [r3, #4]
    7ce0:	441a      	add	r2, r3
    7ce2:	687b      	ldr	r3, [r7, #4]
    7ce4:	601a      	str	r2, [r3, #0]
    buf->left = 0;
    7ce6:	68fb      	ldr	r3, [r7, #12]
    7ce8:	f04f 0200 	mov.w	r2, #0
    7cec:	809a      	strh	r2, [r3, #4]
    return BUF_FULL;
    7cee:	f04f 0301 	mov.w	r3, #1
  }
}
    7cf2:	4618      	mov	r0, r3
    7cf4:	f107 0710 	add.w	r7, r7, #16
    7cf8:	46bd      	mov	sp, r7
    7cfa:	bd80      	pop	{r7, pc}

00007cfc <buf_bufto>:
/*---------------------------------------------------------------------------*/
static u8_t
buf_bufto(register struct psock_buf *buf, u8_t endmarker,
	  register u8_t **dataptr, register u16_t *datalen)
{
    7cfc:	b480      	push	{r7}
    7cfe:	b085      	sub	sp, #20
    7d00:	af00      	add	r7, sp, #0
    7d02:	71f9      	strb	r1, [r7, #7]
  u8_t c;
  while(buf->left > 0 && *datalen > 0) {
    7d04:	e022      	b.n	7d4c <buf_bufto+0x50>
    c = *buf->ptr = **dataptr;
    7d06:	6801      	ldr	r1, [r0, #0]
    7d08:	f8d2 c000 	ldr.w	ip, [r2]
    7d0c:	f89c c000 	ldrb.w	ip, [ip]
    7d10:	f881 c000 	strb.w	ip, [r1]
    7d14:	7809      	ldrb	r1, [r1, #0]
    7d16:	73f9      	strb	r1, [r7, #15]
    ++*dataptr;
    7d18:	6811      	ldr	r1, [r2, #0]
    7d1a:	f101 0101 	add.w	r1, r1, #1
    7d1e:	6011      	str	r1, [r2, #0]
    ++buf->ptr;
    7d20:	6801      	ldr	r1, [r0, #0]
    7d22:	f101 0101 	add.w	r1, r1, #1
    7d26:	6001      	str	r1, [r0, #0]
    --*datalen;
    7d28:	8819      	ldrh	r1, [r3, #0]
    7d2a:	f101 31ff 	add.w	r1, r1, #4294967295
    7d2e:	b289      	uxth	r1, r1
    7d30:	8019      	strh	r1, [r3, #0]
    --buf->left;
    7d32:	8881      	ldrh	r1, [r0, #4]
    7d34:	f101 31ff 	add.w	r1, r1, #4294967295
    7d38:	b289      	uxth	r1, r1
    7d3a:	8081      	strh	r1, [r0, #4]

    if(c == endmarker) {
    7d3c:	f897 c00f 	ldrb.w	ip, [r7, #15]
    7d40:	79f9      	ldrb	r1, [r7, #7]
    7d42:	458c      	cmp	ip, r1
    7d44:	d102      	bne.n	7d4c <buf_bufto+0x50>
      return BUF_FOUND;
    7d46:	f04f 0302 	mov.w	r3, #2
    7d4a:	e024      	b.n	7d96 <buf_bufto+0x9a>
static u8_t
buf_bufto(register struct psock_buf *buf, u8_t endmarker,
	  register u8_t **dataptr, register u16_t *datalen)
{
  u8_t c;
  while(buf->left > 0 && *datalen > 0) {
    7d4c:	8881      	ldrh	r1, [r0, #4]
    7d4e:	2900      	cmp	r1, #0
    7d50:	d002      	beq.n	7d58 <buf_bufto+0x5c>
    7d52:	8819      	ldrh	r1, [r3, #0]
    7d54:	2900      	cmp	r1, #0
    7d56:	d1d6      	bne.n	7d06 <buf_bufto+0xa>
    if(c == endmarker) {
      return BUF_FOUND;
    }
  }

  if(*datalen == 0) {
    7d58:	8819      	ldrh	r1, [r3, #0]
    7d5a:	2900      	cmp	r1, #0
    7d5c:	d115      	bne.n	7d8a <buf_bufto+0x8e>
    return BUF_NOT_FOUND;
    7d5e:	f04f 0300 	mov.w	r3, #0
    7d62:	e018      	b.n	7d96 <buf_bufto+0x9a>
  }

  while(*datalen > 0) {
    c = **dataptr;
    7d64:	6811      	ldr	r1, [r2, #0]
    7d66:	7809      	ldrb	r1, [r1, #0]
    7d68:	73f9      	strb	r1, [r7, #15]
    --*datalen;
    7d6a:	8819      	ldrh	r1, [r3, #0]
    7d6c:	f101 31ff 	add.w	r1, r1, #4294967295
    7d70:	b289      	uxth	r1, r1
    7d72:	8019      	strh	r1, [r3, #0]
    ++*dataptr;
    7d74:	6811      	ldr	r1, [r2, #0]
    7d76:	f101 0101 	add.w	r1, r1, #1
    7d7a:	6011      	str	r1, [r2, #0]

    if(c == endmarker) {
    7d7c:	7bf8      	ldrb	r0, [r7, #15]
    7d7e:	79f9      	ldrb	r1, [r7, #7]
    7d80:	4288      	cmp	r0, r1
    7d82:	d103      	bne.n	7d8c <buf_bufto+0x90>
      return BUF_FOUND | BUF_FULL;
    7d84:	f04f 0303 	mov.w	r3, #3
    7d88:	e005      	b.n	7d96 <buf_bufto+0x9a>

  if(*datalen == 0) {
    return BUF_NOT_FOUND;
  }

  while(*datalen > 0) {
    7d8a:	bf00      	nop
    7d8c:	8819      	ldrh	r1, [r3, #0]
    7d8e:	2900      	cmp	r1, #0
    7d90:	d1e8      	bne.n	7d64 <buf_bufto+0x68>
    if(c == endmarker) {
      return BUF_FOUND | BUF_FULL;
    }
  }

  return BUF_FULL;
    7d92:	f04f 0301 	mov.w	r3, #1
}
    7d96:	4618      	mov	r0, r3
    7d98:	f107 0714 	add.w	r7, r7, #20
    7d9c:	46bd      	mov	sp, r7
    7d9e:	bc80      	pop	{r7}
    7da0:	4770      	bx	lr
    7da2:	bf00      	nop

00007da4 <send_data>:
/*---------------------------------------------------------------------------*/
static char
send_data(register struct psock *s)
{
    7da4:	b598      	push	{r3, r4, r7, lr}
    7da6:	af00      	add	r7, sp, #0
    7da8:	4604      	mov	r4, r0
  if(s->state != STATE_DATA_SENT || uip_rexmit()) {
    7daa:	f894 3020 	ldrb.w	r3, [r4, #32]
    7dae:	2b06      	cmp	r3, #6
    7db0:	d108      	bne.n	7dc4 <send_data+0x20>
    7db2:	f64a 3364 	movw	r3, #43876	; 0xab64
    7db6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7dba:	781b      	ldrb	r3, [r3, #0]
    7dbc:	f003 0304 	and.w	r3, r3, #4
    7dc0:	2b00      	cmp	r3, #0
    7dc2:	d021      	beq.n	7e08 <send_data+0x64>
    if(s->sendlen > uip_mss()) {
    7dc4:	8a22      	ldrh	r2, [r4, #16]
    7dc6:	f64a 336c 	movw	r3, #43884	; 0xab6c
    7dca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7dce:	681b      	ldr	r3, [r3, #0]
    7dd0:	8a5b      	ldrh	r3, [r3, #18]
    7dd2:	429a      	cmp	r2, r3
    7dd4:	d90b      	bls.n	7dee <send_data+0x4a>
      uip_send(s->sendptr, uip_mss());
    7dd6:	6862      	ldr	r2, [r4, #4]
    7dd8:	f64a 336c 	movw	r3, #43884	; 0xab6c
    7ddc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7de0:	681b      	ldr	r3, [r3, #0]
    7de2:	8a5b      	ldrh	r3, [r3, #18]
    7de4:	4610      	mov	r0, r2
    7de6:	4619      	mov	r1, r3
    7de8:	f002 ff60 	bl	acac <uip_send>
    7dec:	e005      	b.n	7dfa <send_data+0x56>
    } else {
      uip_send(s->sendptr, s->sendlen);
    7dee:	6862      	ldr	r2, [r4, #4]
    7df0:	8a23      	ldrh	r3, [r4, #16]
    7df2:	4610      	mov	r0, r2
    7df4:	4619      	mov	r1, r3
    7df6:	f002 ff59 	bl	acac <uip_send>
    }
    s->state = STATE_DATA_SENT;
    7dfa:	f04f 0306 	mov.w	r3, #6
    7dfe:	f884 3020 	strb.w	r3, [r4, #32]
    return 1;
    7e02:	f04f 0301 	mov.w	r3, #1
    7e06:	e001      	b.n	7e0c <send_data+0x68>
  }
  return 0;
    7e08:	f04f 0300 	mov.w	r3, #0
}
    7e0c:	4618      	mov	r0, r3
    7e0e:	bd98      	pop	{r3, r4, r7, pc}

00007e10 <data_acked>:
/*---------------------------------------------------------------------------*/
static char
data_acked(register struct psock *s)
{
    7e10:	b480      	push	{r7}
    7e12:	af00      	add	r7, sp, #0
    7e14:	4603      	mov	r3, r0
  if(s->state == STATE_DATA_SENT && uip_acked()) {
    7e16:	f893 2020 	ldrb.w	r2, [r3, #32]
    7e1a:	2a06      	cmp	r2, #6
    7e1c:	d135      	bne.n	7e8a <data_acked+0x7a>
    7e1e:	f64a 3264 	movw	r2, #43876	; 0xab64
    7e22:	f2c2 0200 	movt	r2, #8192	; 0x2000
    7e26:	7812      	ldrb	r2, [r2, #0]
    7e28:	f002 0201 	and.w	r2, r2, #1
    7e2c:	b2d2      	uxtb	r2, r2
    7e2e:	2a00      	cmp	r2, #0
    7e30:	d02b      	beq.n	7e8a <data_acked+0x7a>
    if(s->sendlen > uip_mss()) {
    7e32:	8a19      	ldrh	r1, [r3, #16]
    7e34:	f64a 326c 	movw	r2, #43884	; 0xab6c
    7e38:	f2c2 0200 	movt	r2, #8192	; 0x2000
    7e3c:	6812      	ldr	r2, [r2, #0]
    7e3e:	8a52      	ldrh	r2, [r2, #18]
    7e40:	4291      	cmp	r1, r2
    7e42:	d914      	bls.n	7e6e <data_acked+0x5e>
      s->sendlen -= uip_mss();
    7e44:	8a19      	ldrh	r1, [r3, #16]
    7e46:	f64a 326c 	movw	r2, #43884	; 0xab6c
    7e4a:	f2c2 0200 	movt	r2, #8192	; 0x2000
    7e4e:	6812      	ldr	r2, [r2, #0]
    7e50:	8a52      	ldrh	r2, [r2, #18]
    7e52:	ebc2 0201 	rsb	r2, r2, r1
    7e56:	b292      	uxth	r2, r2
    7e58:	821a      	strh	r2, [r3, #16]
      s->sendptr += uip_mss();
    7e5a:	6859      	ldr	r1, [r3, #4]
    7e5c:	f64a 326c 	movw	r2, #43884	; 0xab6c
    7e60:	f2c2 0200 	movt	r2, #8192	; 0x2000
    7e64:	6812      	ldr	r2, [r2, #0]
    7e66:	8a52      	ldrh	r2, [r2, #18]
    7e68:	440a      	add	r2, r1
    7e6a:	605a      	str	r2, [r3, #4]
    7e6c:	e006      	b.n	7e7c <data_acked+0x6c>
    } else {
      s->sendptr += s->sendlen;
    7e6e:	6859      	ldr	r1, [r3, #4]
    7e70:	8a1a      	ldrh	r2, [r3, #16]
    7e72:	440a      	add	r2, r1
    7e74:	605a      	str	r2, [r3, #4]
      s->sendlen = 0;
    7e76:	f04f 0200 	mov.w	r2, #0
    7e7a:	821a      	strh	r2, [r3, #16]
    }
    s->state = STATE_ACKED;
    7e7c:	f04f 0201 	mov.w	r2, #1
    7e80:	f883 2020 	strb.w	r2, [r3, #32]
    return 1;
    7e84:	f04f 0301 	mov.w	r3, #1
    7e88:	e001      	b.n	7e8e <data_acked+0x7e>
  }
  return 0;
    7e8a:	f04f 0300 	mov.w	r3, #0
}
    7e8e:	4618      	mov	r0, r3
    7e90:	46bd      	mov	sp, r7
    7e92:	bc80      	pop	{r7}
    7e94:	4770      	bx	lr
    7e96:	bf00      	nop

00007e98 <psock_send>:
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_send(register struct psock *s, const char *buf,
		     unsigned int len))
{
    7e98:	b5b0      	push	{r4, r5, r7, lr}
    7e9a:	b084      	sub	sp, #16
    7e9c:	af00      	add	r7, sp, #0
    7e9e:	4604      	mov	r4, r0
    7ea0:	6079      	str	r1, [r7, #4]
    7ea2:	603a      	str	r2, [r7, #0]
  PT_BEGIN(&s->psockpt);
    7ea4:	f04f 0301 	mov.w	r3, #1
    7ea8:	73fb      	strb	r3, [r7, #15]
    7eaa:	8863      	ldrh	r3, [r4, #2]
    7eac:	2b00      	cmp	r3, #0
    7eae:	d002      	beq.n	7eb6 <psock_send+0x1e>
    7eb0:	2bd0      	cmp	r3, #208	; 0xd0
    7eb2:	d016      	beq.n	7ee2 <psock_send+0x4a>
    7eb4:	e02d      	b.n	7f12 <psock_send+0x7a>
  ( void ) PT_YIELD_FLAG;
  /* If there is no data to send, we exit immediately. */
  if(len == 0) {
    7eb6:	683b      	ldr	r3, [r7, #0]
    7eb8:	2b00      	cmp	r3, #0
    7eba:	d105      	bne.n	7ec8 <psock_send+0x30>
    PT_EXIT(&s->psockpt);
    7ebc:	f04f 0300 	mov.w	r3, #0
    7ec0:	8063      	strh	r3, [r4, #2]
    7ec2:	f04f 0301 	mov.w	r3, #1
    7ec6:	e02c      	b.n	7f22 <psock_send+0x8a>
  }

  /* Save the length of and a pointer to the data that is to be
     sent. */
  s->sendptr = (unsigned char*)buf;
    7ec8:	687b      	ldr	r3, [r7, #4]
    7eca:	6063      	str	r3, [r4, #4]
  s->sendlen = (unsigned short)len;
    7ecc:	683b      	ldr	r3, [r7, #0]
    7ece:	b29b      	uxth	r3, r3
    7ed0:	8223      	strh	r3, [r4, #16]

  s->state = STATE_NONE;
    7ed2:	f04f 0300 	mov.w	r3, #0
    7ed6:	f884 3020 	strb.w	r3, [r4, #32]

  /* We loop here until all data is sent. The s->sendlen variable is
     updated by the data_sent() function. */
  while(s->sendlen > 0) {
    7eda:	e013      	b.n	7f04 <psock_send+0x6c>
     * send_data() must be called in succession to ensure that all
     * data is sent. Therefore the & operator is used instead of the
     * && operator, which would cause only the data_acked() function
     * to be called when it returns false.
     */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
    7edc:	f04f 03d0 	mov.w	r3, #208	; 0xd0
    7ee0:	8063      	strh	r3, [r4, #2]
    7ee2:	4620      	mov	r0, r4
    7ee4:	f7ff ff94 	bl	7e10 <data_acked>
    7ee8:	4603      	mov	r3, r0
    7eea:	461d      	mov	r5, r3
    7eec:	4620      	mov	r0, r4
    7eee:	f7ff ff59 	bl	7da4 <send_data>
    7ef2:	4603      	mov	r3, r0
    7ef4:	ea05 0303 	and.w	r3, r5, r3
    7ef8:	b2db      	uxtb	r3, r3
    7efa:	2b00      	cmp	r3, #0
    7efc:	d102      	bne.n	7f04 <psock_send+0x6c>
    7efe:	f04f 0300 	mov.w	r3, #0
    7f02:	e00e      	b.n	7f22 <psock_send+0x8a>

  s->state = STATE_NONE;

  /* We loop here until all data is sent. The s->sendlen variable is
     updated by the data_sent() function. */
  while(s->sendlen > 0) {
    7f04:	8a23      	ldrh	r3, [r4, #16]
    7f06:	2b00      	cmp	r3, #0
    7f08:	d1e8      	bne.n	7edc <psock_send+0x44>
     * to be called when it returns false.
     */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
  }

  s->state = STATE_NONE;
    7f0a:	f04f 0300 	mov.w	r3, #0
    7f0e:	f884 3020 	strb.w	r3, [r4, #32]

  PT_END(&s->psockpt);
    7f12:	f04f 0300 	mov.w	r3, #0
    7f16:	73fb      	strb	r3, [r7, #15]
    7f18:	f04f 0300 	mov.w	r3, #0
    7f1c:	8063      	strh	r3, [r4, #2]
    7f1e:	f04f 0302 	mov.w	r3, #2
}
    7f22:	4618      	mov	r0, r3
    7f24:	f107 0710 	add.w	r7, r7, #16
    7f28:	46bd      	mov	sp, r7
    7f2a:	bdb0      	pop	{r4, r5, r7, pc}

00007f2c <psock_generator_send>:
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_generator_send(register struct psock *s,
			       unsigned short (*generate)(void *), void *arg))
{
    7f2c:	b5b0      	push	{r4, r5, r7, lr}
    7f2e:	b084      	sub	sp, #16
    7f30:	af00      	add	r7, sp, #0
    7f32:	4604      	mov	r4, r0
    7f34:	6079      	str	r1, [r7, #4]
    7f36:	603a      	str	r2, [r7, #0]
  PT_BEGIN(&s->psockpt);
    7f38:	f04f 0301 	mov.w	r3, #1
    7f3c:	73fb      	strb	r3, [r7, #15]
    7f3e:	8863      	ldrh	r3, [r4, #2]
    7f40:	2b00      	cmp	r3, #0
    7f42:	d002      	beq.n	7f4a <psock_generator_send+0x1e>
    7f44:	2bef      	cmp	r3, #239	; 0xef
    7f46:	d027      	beq.n	7f98 <psock_generator_send+0x6c>
    7f48:	e03e      	b.n	7fc8 <psock_generator_send+0x9c>
  ( void ) PT_YIELD_FLAG;
  /* Ensure that there is a generator function to call. */
  if(generate == NULL) {
    7f4a:	687b      	ldr	r3, [r7, #4]
    7f4c:	2b00      	cmp	r3, #0
    7f4e:	d105      	bne.n	7f5c <psock_generator_send+0x30>
    PT_EXIT(&s->psockpt);
    7f50:	f04f 0300 	mov.w	r3, #0
    7f54:	8063      	strh	r3, [r4, #2]
    7f56:	f04f 0301 	mov.w	r3, #1
    7f5a:	e03d      	b.n	7fd8 <psock_generator_send+0xac>
  }

  /* Call the generator function to generate the data in the
     uip_appdata buffer. */
  s->sendlen = generate(arg);
    7f5c:	687b      	ldr	r3, [r7, #4]
    7f5e:	6838      	ldr	r0, [r7, #0]
    7f60:	4798      	blx	r3
    7f62:	4603      	mov	r3, r0
    7f64:	8223      	strh	r3, [r4, #16]
  s->sendptr = uip_appdata;
    7f66:	f64a 3368 	movw	r3, #43880	; 0xab68
    7f6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7f6e:	681b      	ldr	r3, [r3, #0]
    7f70:	6063      	str	r3, [r4, #4]

  s->state = STATE_NONE;
    7f72:	f04f 0300 	mov.w	r3, #0
    7f76:	f884 3020 	strb.w	r3, [r4, #32]
  do {
    /* Call the generator function again if we are called to perform a
       retransmission. */
    if(uip_rexmit()) {
    7f7a:	f64a 3364 	movw	r3, #43876	; 0xab64
    7f7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7f82:	781b      	ldrb	r3, [r3, #0]
    7f84:	f003 0304 	and.w	r3, r3, #4
    7f88:	2b00      	cmp	r3, #0
    7f8a:	d002      	beq.n	7f92 <psock_generator_send+0x66>
      generate(arg);
    7f8c:	687b      	ldr	r3, [r7, #4]
    7f8e:	6838      	ldr	r0, [r7, #0]
    7f90:	4798      	blx	r3
    }
    /* Wait until all data is sent and acknowledged. */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
    7f92:	f04f 03ef 	mov.w	r3, #239	; 0xef
    7f96:	8063      	strh	r3, [r4, #2]
    7f98:	4620      	mov	r0, r4
    7f9a:	f7ff ff39 	bl	7e10 <data_acked>
    7f9e:	4603      	mov	r3, r0
    7fa0:	461d      	mov	r5, r3
    7fa2:	4620      	mov	r0, r4
    7fa4:	f7ff fefe 	bl	7da4 <send_data>
    7fa8:	4603      	mov	r3, r0
    7faa:	ea05 0303 	and.w	r3, r5, r3
    7fae:	b2db      	uxtb	r3, r3
    7fb0:	2b00      	cmp	r3, #0
    7fb2:	d102      	bne.n	7fba <psock_generator_send+0x8e>
    7fb4:	f04f 0300 	mov.w	r3, #0
    7fb8:	e00e      	b.n	7fd8 <psock_generator_send+0xac>
  } while(s->sendlen > 0);
    7fba:	8a23      	ldrh	r3, [r4, #16]
    7fbc:	2b00      	cmp	r3, #0
    7fbe:	d1dc      	bne.n	7f7a <psock_generator_send+0x4e>

  s->state = STATE_NONE;
    7fc0:	f04f 0300 	mov.w	r3, #0
    7fc4:	f884 3020 	strb.w	r3, [r4, #32]

  PT_END(&s->psockpt);
    7fc8:	f04f 0300 	mov.w	r3, #0
    7fcc:	73fb      	strb	r3, [r7, #15]
    7fce:	f04f 0300 	mov.w	r3, #0
    7fd2:	8063      	strh	r3, [r4, #2]
    7fd4:	f04f 0302 	mov.w	r3, #2
}
    7fd8:	4618      	mov	r0, r3
    7fda:	f107 0710 	add.w	r7, r7, #16
    7fde:	46bd      	mov	sp, r7
    7fe0:	bdb0      	pop	{r4, r5, r7, pc}
    7fe2:	bf00      	nop

00007fe4 <psock_datalen>:
/*---------------------------------------------------------------------------*/
u16_t
psock_datalen(struct psock *psock)
{
    7fe4:	b480      	push	{r7}
    7fe6:	b083      	sub	sp, #12
    7fe8:	af00      	add	r7, sp, #0
    7fea:	6078      	str	r0, [r7, #4]
  return psock->bufsize - psock->buf.left;
    7fec:	687b      	ldr	r3, [r7, #4]
    7fee:	69db      	ldr	r3, [r3, #28]
    7ff0:	b29a      	uxth	r2, r3
    7ff2:	687b      	ldr	r3, [r7, #4]
    7ff4:	8b1b      	ldrh	r3, [r3, #24]
    7ff6:	ebc3 0302 	rsb	r3, r3, r2
    7ffa:	b29b      	uxth	r3, r3
}
    7ffc:	4618      	mov	r0, r3
    7ffe:	f107 070c 	add.w	r7, r7, #12
    8002:	46bd      	mov	sp, r7
    8004:	bc80      	pop	{r7}
    8006:	4770      	bx	lr

00008008 <psock_newdata>:
/*---------------------------------------------------------------------------*/
char
psock_newdata(struct psock *s)
{
    8008:	b480      	push	{r7}
    800a:	b083      	sub	sp, #12
    800c:	af00      	add	r7, sp, #0
    800e:	6078      	str	r0, [r7, #4]
  if(s->readlen > 0) {
    8010:	687b      	ldr	r3, [r7, #4]
    8012:	8a5b      	ldrh	r3, [r3, #18]
    8014:	2b00      	cmp	r3, #0
    8016:	d002      	beq.n	801e <psock_newdata+0x16>
    /* There is data in the uip_appdata buffer that has not yet been
       read with the PSOCK_READ functions. */
    return 1;
    8018:	f04f 0301 	mov.w	r3, #1
    801c:	e01a      	b.n	8054 <psock_newdata+0x4c>
  } else if(s->state == STATE_READ) {
    801e:	687b      	ldr	r3, [r7, #4]
    8020:	f893 3020 	ldrb.w	r3, [r3, #32]
    8024:	2b02      	cmp	r3, #2
    8026:	d107      	bne.n	8038 <psock_newdata+0x30>
    /* All data in uip_appdata buffer already consumed. */
    s->state = STATE_BLOCKED_NEWDATA;
    8028:	687b      	ldr	r3, [r7, #4]
    802a:	f04f 0203 	mov.w	r2, #3
    802e:	f883 2020 	strb.w	r2, [r3, #32]
    return 0;
    8032:	f04f 0300 	mov.w	r3, #0
    8036:	e00d      	b.n	8054 <psock_newdata+0x4c>
  } else if(uip_newdata()) {
    8038:	f64a 3364 	movw	r3, #43876	; 0xab64
    803c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8040:	781b      	ldrb	r3, [r3, #0]
    8042:	f003 0302 	and.w	r3, r3, #2
    8046:	2b00      	cmp	r3, #0
    8048:	d002      	beq.n	8050 <psock_newdata+0x48>
    /* There is new data that has not been consumed. */
    return 1;
    804a:	f04f 0301 	mov.w	r3, #1
    804e:	e001      	b.n	8054 <psock_newdata+0x4c>
  } else {
    /* There is no new data. */
    return 0;
    8050:	f04f 0300 	mov.w	r3, #0
  }
}
    8054:	4618      	mov	r0, r3
    8056:	f107 070c 	add.w	r7, r7, #12
    805a:	46bd      	mov	sp, r7
    805c:	bc80      	pop	{r7}
    805e:	4770      	bx	lr

00008060 <psock_readto>:
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_readto(register struct psock *psock, unsigned char c))
{
    8060:	b590      	push	{r4, r7, lr}
    8062:	b085      	sub	sp, #20
    8064:	af00      	add	r7, sp, #0
    8066:	4604      	mov	r4, r0
    8068:	460b      	mov	r3, r1
    806a:	71fb      	strb	r3, [r7, #7]
  PT_BEGIN(&psock->psockpt);
    806c:	f04f 0301 	mov.w	r3, #1
    8070:	73fb      	strb	r3, [r7, #15]
    8072:	8863      	ldrh	r3, [r4, #2]
    8074:	2b00      	cmp	r3, #0
    8076:	d003      	beq.n	8080 <psock_readto+0x20>
    8078:	f5b3 7f8e 	cmp.w	r3, #284	; 0x11c
    807c:	d010      	beq.n	80a0 <psock_readto+0x40>
    807e:	e046      	b.n	810e <psock_readto+0xae>
  ( void ) PT_YIELD_FLAG;
  buf_setup(&psock->buf, (unsigned char*)psock->bufptr, psock->bufsize);
    8080:	f104 0114 	add.w	r1, r4, #20
    8084:	68e2      	ldr	r2, [r4, #12]
    8086:	69e3      	ldr	r3, [r4, #28]
    8088:	b29b      	uxth	r3, r3
    808a:	4608      	mov	r0, r1
    808c:	4611      	mov	r1, r2
    808e:	461a      	mov	r2, r3
    8090:	f7ff fd94 	bl	7bbc <buf_setup>

  /* XXX: Should add buf_checkmarker() before do{} loop, if
     incoming data has been handled while waiting for a write. */

  do {
    if(psock->readlen == 0) {
    8094:	8a63      	ldrh	r3, [r4, #18]
    8096:	2b00      	cmp	r3, #0
    8098:	d11b      	bne.n	80d2 <psock_readto+0x72>
      PT_WAIT_UNTIL(&psock->psockpt, psock_newdata(psock));
    809a:	f44f 738e 	mov.w	r3, #284	; 0x11c
    809e:	8063      	strh	r3, [r4, #2]
    80a0:	4620      	mov	r0, r4
    80a2:	f7ff ffb1 	bl	8008 <psock_newdata>
    80a6:	4603      	mov	r3, r0
    80a8:	2b00      	cmp	r3, #0
    80aa:	d102      	bne.n	80b2 <psock_readto+0x52>
    80ac:	f04f 0300 	mov.w	r3, #0
    80b0:	e035      	b.n	811e <psock_readto+0xbe>
      psock->state = STATE_READ;
    80b2:	f04f 0302 	mov.w	r3, #2
    80b6:	f884 3020 	strb.w	r3, [r4, #32]
      psock->readptr = (u8_t *)uip_appdata;
    80ba:	f64a 3368 	movw	r3, #43880	; 0xab68
    80be:	f2c2 0300 	movt	r3, #8192	; 0x2000
    80c2:	681b      	ldr	r3, [r3, #0]
    80c4:	60a3      	str	r3, [r4, #8]
      psock->readlen = uip_datalen();
    80c6:	f64a 3358 	movw	r3, #43864	; 0xab58
    80ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    80ce:	881b      	ldrh	r3, [r3, #0]
    80d0:	8263      	strh	r3, [r4, #18]
    }
  } while((buf_bufto(&psock->buf, c,
    80d2:	f104 0014 	add.w	r0, r4, #20
    80d6:	f104 0208 	add.w	r2, r4, #8
    80da:	f104 0312 	add.w	r3, r4, #18
    80de:	79f9      	ldrb	r1, [r7, #7]
    80e0:	f7ff fe0c 	bl	7cfc <buf_bufto>
    80e4:	4603      	mov	r3, r0
    80e6:	f003 0302 	and.w	r3, r3, #2
		     &psock->readptr,
		     &psock->readlen) & BUF_FOUND) == 0);
    80ea:	2b00      	cmp	r3, #0
    80ec:	d0d2      	beq.n	8094 <psock_readto+0x34>

  if(psock_datalen(psock) == 0) {
    80ee:	4620      	mov	r0, r4
    80f0:	f7ff ff78 	bl	7fe4 <psock_datalen>
    80f4:	4603      	mov	r3, r0
    80f6:	2b00      	cmp	r3, #0
    80f8:	d109      	bne.n	810e <psock_readto+0xae>
    psock->state = STATE_NONE;
    80fa:	f04f 0300 	mov.w	r3, #0
    80fe:	f884 3020 	strb.w	r3, [r4, #32]
    PT_RESTART(&psock->psockpt);
    8102:	f04f 0300 	mov.w	r3, #0
    8106:	8063      	strh	r3, [r4, #2]
    8108:	f04f 0300 	mov.w	r3, #0
    810c:	e007      	b.n	811e <psock_readto+0xbe>
  }
  PT_END(&psock->psockpt);
    810e:	f04f 0300 	mov.w	r3, #0
    8112:	73fb      	strb	r3, [r7, #15]
    8114:	f04f 0300 	mov.w	r3, #0
    8118:	8063      	strh	r3, [r4, #2]
    811a:	f04f 0302 	mov.w	r3, #2
}
    811e:	4618      	mov	r0, r3
    8120:	f107 0714 	add.w	r7, r7, #20
    8124:	46bd      	mov	sp, r7
    8126:	bd90      	pop	{r4, r7, pc}

00008128 <psock_readbuf>:
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_readbuf(register struct psock *psock))
{
    8128:	b590      	push	{r4, r7, lr}
    812a:	b083      	sub	sp, #12
    812c:	af00      	add	r7, sp, #0
    812e:	4604      	mov	r4, r0
  PT_BEGIN(&psock->psockpt);
    8130:	f04f 0301 	mov.w	r3, #1
    8134:	71fb      	strb	r3, [r7, #7]
    8136:	8863      	ldrh	r3, [r4, #2]
    8138:	2b00      	cmp	r3, #0
    813a:	d004      	beq.n	8146 <psock_readbuf+0x1e>
    813c:	f240 1237 	movw	r2, #311	; 0x137
    8140:	4293      	cmp	r3, r2
    8142:	d010      	beq.n	8166 <psock_readbuf+0x3e>
    8144:	e045      	b.n	81d2 <psock_readbuf+0xaa>
  ( void ) PT_YIELD_FLAG;
  buf_setup(&psock->buf, (unsigned char * ) psock->bufptr, psock->bufsize);
    8146:	f104 0114 	add.w	r1, r4, #20
    814a:	68e2      	ldr	r2, [r4, #12]
    814c:	69e3      	ldr	r3, [r4, #28]
    814e:	b29b      	uxth	r3, r3
    8150:	4608      	mov	r0, r1
    8152:	4611      	mov	r1, r2
    8154:	461a      	mov	r2, r3
    8156:	f7ff fd31 	bl	7bbc <buf_setup>

  /* XXX: Should add buf_checkmarker() before do{} loop, if
     incoming data has been handled while waiting for a write. */

  do {
    if(psock->readlen == 0) {
    815a:	8a63      	ldrh	r3, [r4, #18]
    815c:	2b00      	cmp	r3, #0
    815e:	d11b      	bne.n	8198 <psock_readbuf+0x70>
      PT_WAIT_UNTIL(&psock->psockpt, psock_newdata(psock));
    8160:	f240 1337 	movw	r3, #311	; 0x137
    8164:	8063      	strh	r3, [r4, #2]
    8166:	4620      	mov	r0, r4
    8168:	f7ff ff4e 	bl	8008 <psock_newdata>
    816c:	4603      	mov	r3, r0
    816e:	2b00      	cmp	r3, #0
    8170:	d102      	bne.n	8178 <psock_readbuf+0x50>
    8172:	f04f 0300 	mov.w	r3, #0
    8176:	e034      	b.n	81e2 <psock_readbuf+0xba>
      psock->state = STATE_READ;
    8178:	f04f 0302 	mov.w	r3, #2
    817c:	f884 3020 	strb.w	r3, [r4, #32]
      psock->readptr = (u8_t *)uip_appdata;
    8180:	f64a 3368 	movw	r3, #43880	; 0xab68
    8184:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8188:	681b      	ldr	r3, [r3, #0]
    818a:	60a3      	str	r3, [r4, #8]
      psock->readlen = uip_datalen();
    818c:	f64a 3358 	movw	r3, #43864	; 0xab58
    8190:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8194:	881b      	ldrh	r3, [r3, #0]
    8196:	8263      	strh	r3, [r4, #18]
    }
  } while(buf_bufdata(&psock->buf, psock->bufsize,
    8198:	f104 0014 	add.w	r0, r4, #20
    819c:	69e3      	ldr	r3, [r4, #28]
    819e:	b299      	uxth	r1, r3
    81a0:	f104 0208 	add.w	r2, r4, #8
    81a4:	f104 0312 	add.w	r3, r4, #18
    81a8:	f7ff fd1a 	bl	7be0 <buf_bufdata>
    81ac:	4603      	mov	r3, r0
			 &psock->readptr,
			 &psock->readlen) != BUF_FULL);
    81ae:	2b01      	cmp	r3, #1
    81b0:	d1d3      	bne.n	815a <psock_readbuf+0x32>

  if(psock_datalen(psock) == 0) {
    81b2:	4620      	mov	r0, r4
    81b4:	f7ff ff16 	bl	7fe4 <psock_datalen>
    81b8:	4603      	mov	r3, r0
    81ba:	2b00      	cmp	r3, #0
    81bc:	d109      	bne.n	81d2 <psock_readbuf+0xaa>
    psock->state = STATE_NONE;
    81be:	f04f 0300 	mov.w	r3, #0
    81c2:	f884 3020 	strb.w	r3, [r4, #32]
    PT_RESTART(&psock->psockpt);
    81c6:	f04f 0300 	mov.w	r3, #0
    81ca:	8063      	strh	r3, [r4, #2]
    81cc:	f04f 0300 	mov.w	r3, #0
    81d0:	e007      	b.n	81e2 <psock_readbuf+0xba>
  }
  PT_END(&psock->psockpt);
    81d2:	f04f 0300 	mov.w	r3, #0
    81d6:	71fb      	strb	r3, [r7, #7]
    81d8:	f04f 0300 	mov.w	r3, #0
    81dc:	8063      	strh	r3, [r4, #2]
    81de:	f04f 0302 	mov.w	r3, #2
}
    81e2:	4618      	mov	r0, r3
    81e4:	f107 070c 	add.w	r7, r7, #12
    81e8:	46bd      	mov	sp, r7
    81ea:	bd90      	pop	{r4, r7, pc}

000081ec <psock_init>:
/*---------------------------------------------------------------------------*/
void
psock_init(register struct psock *psock, char *buffer, unsigned int buffersize)
{
    81ec:	b590      	push	{r4, r7, lr}
    81ee:	b083      	sub	sp, #12
    81f0:	af00      	add	r7, sp, #0
    81f2:	4604      	mov	r4, r0
    81f4:	6079      	str	r1, [r7, #4]
    81f6:	603a      	str	r2, [r7, #0]
  psock->state = STATE_NONE;
    81f8:	f04f 0300 	mov.w	r3, #0
    81fc:	f884 3020 	strb.w	r3, [r4, #32]
  psock->readlen = 0;
    8200:	f04f 0300 	mov.w	r3, #0
    8204:	8263      	strh	r3, [r4, #18]
  psock->bufptr = buffer;
    8206:	687b      	ldr	r3, [r7, #4]
    8208:	60e3      	str	r3, [r4, #12]
  psock->bufsize = buffersize;
    820a:	683b      	ldr	r3, [r7, #0]
    820c:	61e3      	str	r3, [r4, #28]
  buf_setup(&psock->buf, (unsigned char*) buffer, buffersize);
    820e:	f104 0214 	add.w	r2, r4, #20
    8212:	683b      	ldr	r3, [r7, #0]
    8214:	b29b      	uxth	r3, r3
    8216:	4610      	mov	r0, r2
    8218:	6879      	ldr	r1, [r7, #4]
    821a:	461a      	mov	r2, r3
    821c:	f7ff fcce 	bl	7bbc <buf_setup>
  PT_INIT(&psock->pt);
    8220:	f04f 0300 	mov.w	r3, #0
    8224:	8023      	strh	r3, [r4, #0]
  PT_INIT(&psock->psockpt);
    8226:	f04f 0300 	mov.w	r3, #0
    822a:	8063      	strh	r3, [r4, #2]
}
    822c:	f107 070c 	add.w	r7, r7, #12
    8230:	46bd      	mov	sp, r7
    8232:	bd90      	pop	{r4, r7, pc}

00008234 <timer_set>:
 * \param t A pointer to the timer
 * \param interval The interval before the timer expires.
 *
 */
void timer_set( struct timer *t, clock_time_t interval )
{
    8234:	b580      	push	{r7, lr}
    8236:	b082      	sub	sp, #8
    8238:	af00      	add	r7, sp, #0
    823a:	6078      	str	r0, [r7, #4]
    823c:	6039      	str	r1, [r7, #0]
	t->interval = interval;
    823e:	687b      	ldr	r3, [r7, #4]
    8240:	683a      	ldr	r2, [r7, #0]
    8242:	605a      	str	r2, [r3, #4]
	t->start = clock_time();
    8244:	f7f8 fff8 	bl	1238 <clock_time>
    8248:	4602      	mov	r2, r0
    824a:	687b      	ldr	r3, [r7, #4]
    824c:	601a      	str	r2, [r3, #0]
}
    824e:	f107 0708 	add.w	r7, r7, #8
    8252:	46bd      	mov	sp, r7
    8254:	bd80      	pop	{r7, pc}
    8256:	bf00      	nop

00008258 <timer_reset>:
 * \param t A pointer to the timer.
 *
 * \sa timer_restart()
 */
void timer_reset( struct timer *t )
{
    8258:	b480      	push	{r7}
    825a:	b083      	sub	sp, #12
    825c:	af00      	add	r7, sp, #0
    825e:	6078      	str	r0, [r7, #4]
	t->start += t->interval;
    8260:	687b      	ldr	r3, [r7, #4]
    8262:	681a      	ldr	r2, [r3, #0]
    8264:	687b      	ldr	r3, [r7, #4]
    8266:	685b      	ldr	r3, [r3, #4]
    8268:	441a      	add	r2, r3
    826a:	687b      	ldr	r3, [r7, #4]
    826c:	601a      	str	r2, [r3, #0]
}
    826e:	f107 070c 	add.w	r7, r7, #12
    8272:	46bd      	mov	sp, r7
    8274:	bc80      	pop	{r7}
    8276:	4770      	bx	lr

00008278 <timer_restart>:
 * \param t A pointer to the timer.
 *
 * \sa timer_reset()
 */
void timer_restart( struct timer *t )
{
    8278:	b580      	push	{r7, lr}
    827a:	b082      	sub	sp, #8
    827c:	af00      	add	r7, sp, #0
    827e:	6078      	str	r0, [r7, #4]
	t->start = clock_time();
    8280:	f7f8 ffda 	bl	1238 <clock_time>
    8284:	4602      	mov	r2, r0
    8286:	687b      	ldr	r3, [r7, #4]
    8288:	601a      	str	r2, [r3, #0]
}
    828a:	f107 0708 	add.w	r7, r7, #8
    828e:	46bd      	mov	sp, r7
    8290:	bd80      	pop	{r7, pc}
    8292:	bf00      	nop

00008294 <timer_expired>:
 *
 * \return Non-zero if the timer has expired, zero otherwise.
 *
 */
int timer_expired( struct timer *t )
{
    8294:	b580      	push	{r7, lr}
    8296:	b082      	sub	sp, #8
    8298:	af00      	add	r7, sp, #0
    829a:	6078      	str	r0, [r7, #4]
	return( clock_time_t ) ( clock_time() - t->start ) >= ( clock_time_t ) t->interval;
    829c:	f7f8 ffcc 	bl	1238 <clock_time>
    82a0:	4602      	mov	r2, r0
    82a2:	687b      	ldr	r3, [r7, #4]
    82a4:	681b      	ldr	r3, [r3, #0]
    82a6:	ebc3 0202 	rsb	r2, r3, r2
    82aa:	687b      	ldr	r3, [r7, #4]
    82ac:	685b      	ldr	r3, [r3, #4]
    82ae:	429a      	cmp	r2, r3
    82b0:	bf34      	ite	cc
    82b2:	2300      	movcc	r3, #0
    82b4:	2301      	movcs	r3, #1
}
    82b6:	4618      	mov	r0, r3
    82b8:	f107 0708 	add.w	r7, r7, #8
    82bc:	46bd      	mov	sp, r7
    82be:	bd80      	pop	{r7, pc}

000082c0 <timer_remaining>:
 *
 * \return The time until the timer expires
 *
 */
clock_time_t timer_remaining( struct timer *t )
{
    82c0:	b590      	push	{r4, r7, lr}
    82c2:	b083      	sub	sp, #12
    82c4:	af00      	add	r7, sp, #0
    82c6:	6078      	str	r0, [r7, #4]
	return t->start + t->interval - clock_time();
    82c8:	687b      	ldr	r3, [r7, #4]
    82ca:	681a      	ldr	r2, [r3, #0]
    82cc:	687b      	ldr	r3, [r7, #4]
    82ce:	685b      	ldr	r3, [r3, #4]
    82d0:	eb02 0403 	add.w	r4, r2, r3
    82d4:	f7f8 ffb0 	bl	1238 <clock_time>
    82d8:	4603      	mov	r3, r0
    82da:	ebc3 0304 	rsb	r3, r3, r4
}
    82de:	4618      	mov	r0, r3
    82e0:	f107 070c 	add.w	r7, r7, #12
    82e4:	46bd      	mov	sp, r7
    82e6:	bd90      	pop	{r4, r7, pc}

000082e8 <uip_setipid>:

/* Ths ipid variable is an increasing number that is used for the IP ID	field. */
static u16_t ipid;

void uip_setipid( u16_t id )
{
    82e8:	b480      	push	{r7}
    82ea:	b083      	sub	sp, #12
    82ec:	af00      	add	r7, sp, #0
    82ee:	4603      	mov	r3, r0
    82f0:	80fb      	strh	r3, [r7, #6]
	ipid = id;
    82f2:	f642 736c 	movw	r3, #12140	; 0x2f6c
    82f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    82fa:	88fa      	ldrh	r2, [r7, #6]
    82fc:	801a      	strh	r2, [r3, #0]
}
    82fe:	f107 070c 	add.w	r7, r7, #12
    8302:	46bd      	mov	sp, r7
    8304:	bc80      	pop	{r7}
    8306:	4770      	bx	lr

00008308 <uip_add32>:
	#define UIP_LOG( m )
#endif /* UIP_LOGGING == 1 */

#if !UIP_ARCH_ADD32
	void uip_add32( u8_t *op32, u16_t op16 )
	{
    8308:	b480      	push	{r7}
    830a:	b083      	sub	sp, #12
    830c:	af00      	add	r7, sp, #0
    830e:	6078      	str	r0, [r7, #4]
    8310:	460b      	mov	r3, r1
    8312:	807b      	strh	r3, [r7, #2]
		uip_acc32[3] = op32[3] + ( op16 & 0xff );
    8314:	687b      	ldr	r3, [r7, #4]
    8316:	f103 0303 	add.w	r3, r3, #3
    831a:	781a      	ldrb	r2, [r3, #0]
    831c:	887b      	ldrh	r3, [r7, #2]
    831e:	b2db      	uxtb	r3, r3
    8320:	4413      	add	r3, r2
    8322:	b2da      	uxtb	r2, r3
    8324:	f64a 3360 	movw	r3, #43872	; 0xab60
    8328:	f2c2 0300 	movt	r3, #8192	; 0x2000
    832c:	70da      	strb	r2, [r3, #3]
		uip_acc32[2] = op32[2] + ( op16 >> 8 );
    832e:	687b      	ldr	r3, [r7, #4]
    8330:	f103 0302 	add.w	r3, r3, #2
    8334:	781a      	ldrb	r2, [r3, #0]
    8336:	887b      	ldrh	r3, [r7, #2]
    8338:	ea4f 2313 	mov.w	r3, r3, lsr #8
    833c:	b29b      	uxth	r3, r3
    833e:	b2db      	uxtb	r3, r3
    8340:	4413      	add	r3, r2
    8342:	b2da      	uxtb	r2, r3
    8344:	f64a 3360 	movw	r3, #43872	; 0xab60
    8348:	f2c2 0300 	movt	r3, #8192	; 0x2000
    834c:	709a      	strb	r2, [r3, #2]
		uip_acc32[1] = op32[1];
    834e:	687b      	ldr	r3, [r7, #4]
    8350:	f103 0301 	add.w	r3, r3, #1
    8354:	781a      	ldrb	r2, [r3, #0]
    8356:	f64a 3360 	movw	r3, #43872	; 0xab60
    835a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    835e:	705a      	strb	r2, [r3, #1]
		uip_acc32[0] = op32[0];
    8360:	687b      	ldr	r3, [r7, #4]
    8362:	781a      	ldrb	r2, [r3, #0]
    8364:	f64a 3360 	movw	r3, #43872	; 0xab60
    8368:	f2c2 0300 	movt	r3, #8192	; 0x2000
    836c:	701a      	strb	r2, [r3, #0]

		if( uip_acc32[2] < (op16 >> 8) )
    836e:	f64a 3360 	movw	r3, #43872	; 0xab60
    8372:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8376:	789b      	ldrb	r3, [r3, #2]
    8378:	461a      	mov	r2, r3
    837a:	887b      	ldrh	r3, [r7, #2]
    837c:	ea4f 2313 	mov.w	r3, r3, lsr #8
    8380:	b29b      	uxth	r3, r3
    8382:	429a      	cmp	r2, r3
    8384:	d220      	bcs.n	83c8 <uip_add32+0xc0>
		{
			++uip_acc32[1];
    8386:	f64a 3360 	movw	r3, #43872	; 0xab60
    838a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    838e:	785b      	ldrb	r3, [r3, #1]
    8390:	f103 0301 	add.w	r3, r3, #1
    8394:	b2da      	uxtb	r2, r3
    8396:	f64a 3360 	movw	r3, #43872	; 0xab60
    839a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    839e:	705a      	strb	r2, [r3, #1]
			if( uip_acc32[1] == 0 )
    83a0:	f64a 3360 	movw	r3, #43872	; 0xab60
    83a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    83a8:	785b      	ldrb	r3, [r3, #1]
    83aa:	2b00      	cmp	r3, #0
    83ac:	d10c      	bne.n	83c8 <uip_add32+0xc0>
			{
				++uip_acc32[0];
    83ae:	f64a 3360 	movw	r3, #43872	; 0xab60
    83b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    83b6:	781b      	ldrb	r3, [r3, #0]
    83b8:	f103 0301 	add.w	r3, r3, #1
    83bc:	b2da      	uxtb	r2, r3
    83be:	f64a 3360 	movw	r3, #43872	; 0xab60
    83c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    83c6:	701a      	strb	r2, [r3, #0]
			}
		}

		if( uip_acc32[3] < (op16 & 0xff) )
    83c8:	f64a 3360 	movw	r3, #43872	; 0xab60
    83cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    83d0:	78db      	ldrb	r3, [r3, #3]
    83d2:	461a      	mov	r2, r3
    83d4:	887b      	ldrh	r3, [r7, #2]
    83d6:	f003 03ff 	and.w	r3, r3, #255	; 0xff
    83da:	429a      	cmp	r2, r3
    83dc:	da34      	bge.n	8448 <uip_add32+0x140>
		{
			++uip_acc32[2];
    83de:	f64a 3360 	movw	r3, #43872	; 0xab60
    83e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    83e6:	789b      	ldrb	r3, [r3, #2]
    83e8:	f103 0301 	add.w	r3, r3, #1
    83ec:	b2da      	uxtb	r2, r3
    83ee:	f64a 3360 	movw	r3, #43872	; 0xab60
    83f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    83f6:	709a      	strb	r2, [r3, #2]
			if( uip_acc32[2] == 0 )
    83f8:	f64a 3360 	movw	r3, #43872	; 0xab60
    83fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8400:	789b      	ldrb	r3, [r3, #2]
    8402:	2b00      	cmp	r3, #0
    8404:	d120      	bne.n	8448 <uip_add32+0x140>
			{
				++uip_acc32[1];
    8406:	f64a 3360 	movw	r3, #43872	; 0xab60
    840a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    840e:	785b      	ldrb	r3, [r3, #1]
    8410:	f103 0301 	add.w	r3, r3, #1
    8414:	b2da      	uxtb	r2, r3
    8416:	f64a 3360 	movw	r3, #43872	; 0xab60
    841a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    841e:	705a      	strb	r2, [r3, #1]
				if( uip_acc32[1] == 0 )
    8420:	f64a 3360 	movw	r3, #43872	; 0xab60
    8424:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8428:	785b      	ldrb	r3, [r3, #1]
    842a:	2b00      	cmp	r3, #0
    842c:	d10c      	bne.n	8448 <uip_add32+0x140>
				{
					++uip_acc32[0];
    842e:	f64a 3360 	movw	r3, #43872	; 0xab60
    8432:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8436:	781b      	ldrb	r3, [r3, #0]
    8438:	f103 0301 	add.w	r3, r3, #1
    843c:	b2da      	uxtb	r2, r3
    843e:	f64a 3360 	movw	r3, #43872	; 0xab60
    8442:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8446:	701a      	strb	r2, [r3, #0]
				}
			}
		}
	}
    8448:	f107 070c 	add.w	r7, r7, #12
    844c:	46bd      	mov	sp, r7
    844e:	bc80      	pop	{r7}
    8450:	4770      	bx	lr
    8452:	bf00      	nop

00008454 <chksum>:
#endif /* UIP_ARCH_ADD32 */

#if !UIP_ARCH_CHKSUM

	static u16_t chksum( u16_t sum, const u8_t *data, u16_t len )
	{
    8454:	b480      	push	{r7}
    8456:	b089      	sub	sp, #36	; 0x24
    8458:	af00      	add	r7, sp, #0
    845a:	60b9      	str	r1, [r7, #8]
    845c:	4613      	mov	r3, r2
    845e:	4602      	mov	r2, r0
    8460:	81fa      	strh	r2, [r7, #14]
    8462:	80fb      	strh	r3, [r7, #6]
		u16_t		t;
		const u8_t	*dataptr;
		const u8_t	*last_byte;

		dataptr = data;
    8464:	68bb      	ldr	r3, [r7, #8]
    8466:	61bb      	str	r3, [r7, #24]
		last_byte = data + len - 1;
    8468:	88fb      	ldrh	r3, [r7, #6]
    846a:	f103 33ff 	add.w	r3, r3, #4294967295
    846e:	68ba      	ldr	r2, [r7, #8]
    8470:	4413      	add	r3, r2
    8472:	61fb      	str	r3, [r7, #28]

		while( dataptr < last_byte )
    8474:	e01a      	b.n	84ac <chksum+0x58>
		{
			/* At least two more bytes */
			t = ( dataptr[ 0 ] << 8 ) + dataptr[ 1 ];
    8476:	69bb      	ldr	r3, [r7, #24]
    8478:	781b      	ldrb	r3, [r3, #0]
    847a:	ea4f 2303 	mov.w	r3, r3, lsl #8
    847e:	b29a      	uxth	r2, r3
    8480:	69bb      	ldr	r3, [r7, #24]
    8482:	f103 0301 	add.w	r3, r3, #1
    8486:	781b      	ldrb	r3, [r3, #0]
    8488:	4413      	add	r3, r2
    848a:	82fb      	strh	r3, [r7, #22]
			sum += t;
    848c:	89fa      	ldrh	r2, [r7, #14]
    848e:	8afb      	ldrh	r3, [r7, #22]
    8490:	4413      	add	r3, r2
    8492:	81fb      	strh	r3, [r7, #14]
			if( sum < t )
    8494:	89fa      	ldrh	r2, [r7, #14]
    8496:	8afb      	ldrh	r3, [r7, #22]
    8498:	429a      	cmp	r2, r3
    849a:	d203      	bcs.n	84a4 <chksum+0x50>
			{
				sum++;	/* carry */
    849c:	89fb      	ldrh	r3, [r7, #14]
    849e:	f103 0301 	add.w	r3, r3, #1
    84a2:	81fb      	strh	r3, [r7, #14]
			}

			dataptr += 2;
    84a4:	69bb      	ldr	r3, [r7, #24]
    84a6:	f103 0302 	add.w	r3, r3, #2
    84aa:	61bb      	str	r3, [r7, #24]
		const u8_t	*last_byte;

		dataptr = data;
		last_byte = data + len - 1;

		while( dataptr < last_byte )
    84ac:	69ba      	ldr	r2, [r7, #24]
    84ae:	69fb      	ldr	r3, [r7, #28]
    84b0:	429a      	cmp	r2, r3
    84b2:	d3e0      	bcc.n	8476 <chksum+0x22>
			}

			dataptr += 2;
		}

		if( dataptr == last_byte )
    84b4:	69ba      	ldr	r2, [r7, #24]
    84b6:	69fb      	ldr	r3, [r7, #28]
    84b8:	429a      	cmp	r2, r3
    84ba:	d110      	bne.n	84de <chksum+0x8a>
		{
			t = ( dataptr[ 0 ] << 8 ) + 0;
    84bc:	69bb      	ldr	r3, [r7, #24]
    84be:	781b      	ldrb	r3, [r3, #0]
    84c0:	ea4f 2303 	mov.w	r3, r3, lsl #8
    84c4:	82fb      	strh	r3, [r7, #22]
			sum += t;
    84c6:	89fa      	ldrh	r2, [r7, #14]
    84c8:	8afb      	ldrh	r3, [r7, #22]
    84ca:	4413      	add	r3, r2
    84cc:	81fb      	strh	r3, [r7, #14]
			if( sum < t )
    84ce:	89fa      	ldrh	r2, [r7, #14]
    84d0:	8afb      	ldrh	r3, [r7, #22]
    84d2:	429a      	cmp	r2, r3
    84d4:	d203      	bcs.n	84de <chksum+0x8a>
			{
				sum++;	/* carry */
    84d6:	89fb      	ldrh	r3, [r7, #14]
    84d8:	f103 0301 	add.w	r3, r3, #1
    84dc:	81fb      	strh	r3, [r7, #14]
			}
		}

		/* Return sum in host byte order. */
		return sum;
    84de:	89fb      	ldrh	r3, [r7, #14]
	}
    84e0:	4618      	mov	r0, r3
    84e2:	f107 0724 	add.w	r7, r7, #36	; 0x24
    84e6:	46bd      	mov	sp, r7
    84e8:	bc80      	pop	{r7}
    84ea:	4770      	bx	lr

000084ec <uip_chksum>:
	/*---------------------------------------------------------------------------*/

	u16_t uip_chksum( u16_t *data, u16_t len )
	{
    84ec:	b580      	push	{r7, lr}
    84ee:	b082      	sub	sp, #8
    84f0:	af00      	add	r7, sp, #0
    84f2:	6078      	str	r0, [r7, #4]
    84f4:	460b      	mov	r3, r1
    84f6:	807b      	strh	r3, [r7, #2]
		return htons( chksum( 0, ( u8_t * ) data, len ) );
    84f8:	687a      	ldr	r2, [r7, #4]
    84fa:	887b      	ldrh	r3, [r7, #2]
    84fc:	f04f 0000 	mov.w	r0, #0
    8500:	4611      	mov	r1, r2
    8502:	461a      	mov	r2, r3
    8504:	f7ff ffa6 	bl	8454 <chksum>
    8508:	4603      	mov	r3, r0
    850a:	4618      	mov	r0, r3
    850c:	f002 fb88 	bl	ac20 <htons>
    8510:	4603      	mov	r3, r0
	}
    8512:	4618      	mov	r0, r3
    8514:	f107 0708 	add.w	r7, r7, #8
    8518:	46bd      	mov	sp, r7
    851a:	bd80      	pop	{r7, pc}

0000851c <uip_ipchksum>:
	/*---------------------------------------------------------------------------*/

	#ifndef UIP_ARCH_IPCHKSUM
		u16_t uip_ipchksum( void )
		{
    851c:	b580      	push	{r7, lr}
    851e:	b082      	sub	sp, #8
    8520:	af00      	add	r7, sp, #0
			u16_t	sum;

			sum = chksum( 0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN );
    8522:	f240 6390 	movw	r3, #1680	; 0x690
    8526:	f2c2 0300 	movt	r3, #8192	; 0x2000
    852a:	681b      	ldr	r3, [r3, #0]
    852c:	f103 030e 	add.w	r3, r3, #14
    8530:	f04f 0000 	mov.w	r0, #0
    8534:	4619      	mov	r1, r3
    8536:	f04f 0214 	mov.w	r2, #20
    853a:	f7ff ff8b 	bl	8454 <chksum>
    853e:	4603      	mov	r3, r0
    8540:	80fb      	strh	r3, [r7, #6]

			//DEBUG_PRINTF( "uip_ipchksum: sum 0x%04x\n", sum );
			return( sum == 0 ) ? 0xffff : htons( sum );
    8542:	88fb      	ldrh	r3, [r7, #6]
    8544:	2b00      	cmp	r3, #0
    8546:	d005      	beq.n	8554 <uip_ipchksum+0x38>
    8548:	88fb      	ldrh	r3, [r7, #6]
    854a:	4618      	mov	r0, r3
    854c:	f002 fb68 	bl	ac20 <htons>
    8550:	4603      	mov	r3, r0
    8552:	e001      	b.n	8558 <uip_ipchksum+0x3c>
    8554:	f64f 73ff 	movw	r3, #65535	; 0xffff
		}
    8558:	4618      	mov	r0, r3
    855a:	f107 0708 	add.w	r7, r7, #8
    855e:	46bd      	mov	sp, r7
    8560:	bd80      	pop	{r7, pc}
    8562:	bf00      	nop

00008564 <upper_layer_chksum>:
	#endif
	/*---------------------------------------------------------------------------*/

	static u16_t upper_layer_chksum( u8_t proto )
	{
    8564:	b580      	push	{r7, lr}
    8566:	b084      	sub	sp, #16
    8568:	af00      	add	r7, sp, #0
    856a:	4603      	mov	r3, r0
    856c:	71fb      	strb	r3, [r7, #7]
		u16_t	sum;

		#if UIP_CONF_IPV6
			upper_layer_len = ( ((u16_t) (BUF->len[ 0 ]) << 8) + BUF->len[ 1 ] );
		#else /* UIP_CONF_IPV6 */
			upper_layer_len = ( ((u16_t) (BUF->len[ 0 ]) << 8) + BUF->len[ 1 ] ) - UIP_IPH_LEN;
    856e:	f240 6390 	movw	r3, #1680	; 0x690
    8572:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8576:	681b      	ldr	r3, [r3, #0]
    8578:	f103 030e 	add.w	r3, r3, #14
    857c:	789b      	ldrb	r3, [r3, #2]
    857e:	ea4f 2303 	mov.w	r3, r3, lsl #8
    8582:	b29a      	uxth	r2, r3
    8584:	f240 6390 	movw	r3, #1680	; 0x690
    8588:	f2c2 0300 	movt	r3, #8192	; 0x2000
    858c:	681b      	ldr	r3, [r3, #0]
    858e:	f103 030e 	add.w	r3, r3, #14
    8592:	78db      	ldrb	r3, [r3, #3]
    8594:	4413      	add	r3, r2
    8596:	b29b      	uxth	r3, r3
    8598:	f1a3 0314 	sub.w	r3, r3, #20
    859c:	81bb      	strh	r3, [r7, #12]
		#endif /* UIP_CONF_IPV6 */

		/* First sum pseudoheader. */

		/* IP protocol and length fields. This addition cannot carry. */
		sum = upper_layer_len + proto;
    859e:	79fa      	ldrb	r2, [r7, #7]
    85a0:	89bb      	ldrh	r3, [r7, #12]
    85a2:	4413      	add	r3, r2
    85a4:	81fb      	strh	r3, [r7, #14]

		/* Sum IP source and destination addresses. */
		sum = chksum( sum, ( u8_t * ) &BUF->srcipaddr, 2 * sizeof(uip_ipaddr_t) );
    85a6:	f240 6390 	movw	r3, #1680	; 0x690
    85aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    85ae:	681b      	ldr	r3, [r3, #0]
    85b0:	f103 030e 	add.w	r3, r3, #14
    85b4:	f103 030c 	add.w	r3, r3, #12
    85b8:	89fa      	ldrh	r2, [r7, #14]
    85ba:	4610      	mov	r0, r2
    85bc:	4619      	mov	r1, r3
    85be:	f04f 0208 	mov.w	r2, #8
    85c2:	f7ff ff47 	bl	8454 <chksum>
    85c6:	4603      	mov	r3, r0
    85c8:	81fb      	strh	r3, [r7, #14]

		/* Sum TCP header and data. */
		sum = chksum( sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN], upper_layer_len );
    85ca:	f240 6390 	movw	r3, #1680	; 0x690
    85ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    85d2:	681b      	ldr	r3, [r3, #0]
    85d4:	f103 0222 	add.w	r2, r3, #34	; 0x22
    85d8:	89f9      	ldrh	r1, [r7, #14]
    85da:	89bb      	ldrh	r3, [r7, #12]
    85dc:	4608      	mov	r0, r1
    85de:	4611      	mov	r1, r2
    85e0:	461a      	mov	r2, r3
    85e2:	f7ff ff37 	bl	8454 <chksum>
    85e6:	4603      	mov	r3, r0
    85e8:	81fb      	strh	r3, [r7, #14]

		return( sum == 0 ) ? 0xffff : htons( sum );
    85ea:	89fb      	ldrh	r3, [r7, #14]
    85ec:	2b00      	cmp	r3, #0
    85ee:	d005      	beq.n	85fc <upper_layer_chksum+0x98>
    85f0:	89fb      	ldrh	r3, [r7, #14]
    85f2:	4618      	mov	r0, r3
    85f4:	f002 fb14 	bl	ac20 <htons>
    85f8:	4603      	mov	r3, r0
    85fa:	e001      	b.n	8600 <upper_layer_chksum+0x9c>
    85fc:	f64f 73ff 	movw	r3, #65535	; 0xffff
	}
    8600:	4618      	mov	r0, r3
    8602:	f107 0710 	add.w	r7, r7, #16
    8606:	46bd      	mov	sp, r7
    8608:	bd80      	pop	{r7, pc}
    860a:	bf00      	nop

0000860c <uip_tcpchksum>:
		}
	#endif /* UIP_CONF_IPV6 */
	/*---------------------------------------------------------------------------*/

	u16_t uip_tcpchksum( void )
	{
    860c:	b580      	push	{r7, lr}
    860e:	af00      	add	r7, sp, #0
		return upper_layer_chksum( UIP_PROTO_TCP );
    8610:	f04f 0006 	mov.w	r0, #6
    8614:	f7ff ffa6 	bl	8564 <upper_layer_chksum>
    8618:	4603      	mov	r3, r0
	}
    861a:	4618      	mov	r0, r3
    861c:	bd80      	pop	{r7, pc}
    861e:	bf00      	nop

00008620 <uip_udpchksum>:
	/*---------------------------------------------------------------------------*/

	#if UIP_UDP_CHECKSUMS
		u16_t uip_udpchksum( void )
		{
    8620:	b580      	push	{r7, lr}
    8622:	af00      	add	r7, sp, #0
			return upper_layer_chksum( UIP_PROTO_UDP );
    8624:	f04f 0011 	mov.w	r0, #17
    8628:	f7ff ff9c 	bl	8564 <upper_layer_chksum>
    862c:	4603      	mov	r3, r0
		}
    862e:	4618      	mov	r0, r3
    8630:	bd80      	pop	{r7, pc}
    8632:	bf00      	nop

00008634 <uip_init>:

#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/

void uip_init( void )
{
    8634:	b480      	push	{r7}
    8636:	af00      	add	r7, sp, #0
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    8638:	f642 7376 	movw	r3, #12150	; 0x2f76
    863c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8640:	f04f 0200 	mov.w	r2, #0
    8644:	701a      	strb	r2, [r3, #0]
    8646:	e01a      	b.n	867e <uip_init+0x4a>
	{
		uip_listenports[ c ] = 0;
    8648:	f642 7376 	movw	r3, #12150	; 0x2f76
    864c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8650:	781b      	ldrb	r3, [r3, #0]
    8652:	461a      	mov	r2, r3
    8654:	f64c 3350 	movw	r3, #52048	; 0xcb50
    8658:	f2c2 0300 	movt	r3, #8192	; 0x2000
    865c:	f04f 0100 	mov.w	r1, #0
    8660:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/

void uip_init( void )
{
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    8664:	f642 7376 	movw	r3, #12150	; 0x2f76
    8668:	f2c2 0300 	movt	r3, #8192	; 0x2000
    866c:	781b      	ldrb	r3, [r3, #0]
    866e:	f103 0301 	add.w	r3, r3, #1
    8672:	b2da      	uxtb	r2, r3
    8674:	f642 7376 	movw	r3, #12150	; 0x2f76
    8678:	f2c2 0300 	movt	r3, #8192	; 0x2000
    867c:	701a      	strb	r2, [r3, #0]
    867e:	f642 7376 	movw	r3, #12150	; 0x2f76
    8682:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8686:	781b      	ldrb	r3, [r3, #0]
    8688:	2b27      	cmp	r3, #39	; 0x27
    868a:	d9dd      	bls.n	8648 <uip_init+0x14>
	{
		uip_listenports[ c ] = 0;
	}

	for( c = 0; c < UIP_CONNS; ++c )
    868c:	f642 7376 	movw	r3, #12150	; 0x2f76
    8690:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8694:	f04f 0200 	mov.w	r2, #0
    8698:	701a      	strb	r2, [r3, #0]
    869a:	e020      	b.n	86de <uip_init+0xaa>
	{
		uip_conns[ c ].tcpstateflags = UIP_CLOSED;
    869c:	f642 7376 	movw	r3, #12150	; 0x2f76
    86a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    86a4:	781b      	ldrb	r3, [r3, #0]
    86a6:	461a      	mov	r2, r3
    86a8:	f64a 3370 	movw	r3, #43888	; 0xab70
    86ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    86b0:	f04f 01cc 	mov.w	r1, #204	; 0xcc
    86b4:	fb01 f202 	mul.w	r2, r1, r2
    86b8:	4413      	add	r3, r2
    86ba:	f103 0318 	add.w	r3, r3, #24
    86be:	f04f 0200 	mov.w	r2, #0
    86c2:	705a      	strb	r2, [r3, #1]
	for( c = 0; c < UIP_LISTENPORTS; ++c )
	{
		uip_listenports[ c ] = 0;
	}

	for( c = 0; c < UIP_CONNS; ++c )
    86c4:	f642 7376 	movw	r3, #12150	; 0x2f76
    86c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    86cc:	781b      	ldrb	r3, [r3, #0]
    86ce:	f103 0301 	add.w	r3, r3, #1
    86d2:	b2da      	uxtb	r2, r3
    86d4:	f642 7376 	movw	r3, #12150	; 0x2f76
    86d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    86dc:	701a      	strb	r2, [r3, #0]
    86de:	f642 7376 	movw	r3, #12150	; 0x2f76
    86e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    86e6:	781b      	ldrb	r3, [r3, #0]
    86e8:	2b27      	cmp	r3, #39	; 0x27
    86ea:	d9d7      	bls.n	869c <uip_init+0x68>
	{
		uip_conns[ c ].tcpstateflags = UIP_CLOSED;
	}

	#if UIP_ACTIVE_OPEN
		lastport = 1024;
    86ec:	f642 7374 	movw	r3, #12148	; 0x2f74
    86f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    86f4:	f44f 6280 	mov.w	r2, #1024	; 0x400
    86f8:	801a      	strh	r2, [r3, #0]

	/* IPv4 initialization. */
	#if UIP_FIXEDADDR == 0
		/*  uip_hostaddr[ 0 ] = uip_hostaddr[ 1 ] = 0;*/
	#endif /* UIP_FIXEDADDR */
}
    86fa:	46bd      	mov	sp, r7
    86fc:	bc80      	pop	{r7}
    86fe:	4770      	bx	lr

00008700 <uip_connect>:
/*---------------------------------------------------------------------------*/

#if UIP_ACTIVE_OPEN
	struct uip_conn *uip_connect( uip_ipaddr_t *ripaddr, u16_t rport )
	{
    8700:	b5b0      	push	{r4, r5, r7, lr}
    8702:	b082      	sub	sp, #8
    8704:	af00      	add	r7, sp, #0
    8706:	6078      	str	r0, [r7, #4]
    8708:	460b      	mov	r3, r1
    870a:	807b      	strh	r3, [r7, #2]
    870c:	e000      	b.n	8710 <uip_connect+0x10>
		for( c = 0; c < UIP_CONNS; ++c )
		{
			conn = &uip_conns[ c ];
			if( conn->tcpstateflags != UIP_CLOSED && conn->lport == htons(lastport) )
			{
				goto again;
    870e:	bf00      	nop
	{
		register struct uip_conn	*conn, *cconn;

		/* Find an unused local port. */
	again:
		++lastport;
    8710:	f642 7374 	movw	r3, #12148	; 0x2f74
    8714:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8718:	881b      	ldrh	r3, [r3, #0]
    871a:	f103 0301 	add.w	r3, r3, #1
    871e:	b29a      	uxth	r2, r3
    8720:	f642 7374 	movw	r3, #12148	; 0x2f74
    8724:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8728:	801a      	strh	r2, [r3, #0]

		if( lastport >= 32000 )
    872a:	f642 7374 	movw	r3, #12148	; 0x2f74
    872e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8732:	881a      	ldrh	r2, [r3, #0]
    8734:	f647 43ff 	movw	r3, #31999	; 0x7cff
    8738:	429a      	cmp	r2, r3
    873a:	d906      	bls.n	874a <uip_connect+0x4a>
		{
			lastport = 4096;
    873c:	f642 7374 	movw	r3, #12148	; 0x2f74
    8740:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8744:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    8748:	801a      	strh	r2, [r3, #0]
		}

		/* Check if this port is already in use, and if so try to find
		 another one. */
		for( c = 0; c < UIP_CONNS; ++c )
    874a:	f642 7376 	movw	r3, #12150	; 0x2f76
    874e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8752:	f04f 0200 	mov.w	r2, #0
    8756:	701a      	strb	r2, [r3, #0]
    8758:	e02a      	b.n	87b0 <uip_connect+0xb0>
		{
			conn = &uip_conns[ c ];
    875a:	f642 7376 	movw	r3, #12150	; 0x2f76
    875e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8762:	781b      	ldrb	r3, [r3, #0]
    8764:	f04f 02cc 	mov.w	r2, #204	; 0xcc
    8768:	fb02 f203 	mul.w	r2, r2, r3
    876c:	f64a 3370 	movw	r3, #43888	; 0xab70
    8770:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8774:	eb02 0403 	add.w	r4, r2, r3
			if( conn->tcpstateflags != UIP_CLOSED && conn->lport == htons(lastport) )
    8778:	7e63      	ldrb	r3, [r4, #25]
    877a:	2b00      	cmp	r3, #0
    877c:	d00b      	beq.n	8796 <uip_connect+0x96>
    877e:	88a4      	ldrh	r4, [r4, #4]
    8780:	f642 7374 	movw	r3, #12148	; 0x2f74
    8784:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8788:	881b      	ldrh	r3, [r3, #0]
    878a:	4618      	mov	r0, r3
    878c:	f002 fa48 	bl	ac20 <htons>
    8790:	4603      	mov	r3, r0
    8792:	429c      	cmp	r4, r3
    8794:	d0bb      	beq.n	870e <uip_connect+0xe>
			lastport = 4096;
		}

		/* Check if this port is already in use, and if so try to find
		 another one. */
		for( c = 0; c < UIP_CONNS; ++c )
    8796:	f642 7376 	movw	r3, #12150	; 0x2f76
    879a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    879e:	781b      	ldrb	r3, [r3, #0]
    87a0:	f103 0301 	add.w	r3, r3, #1
    87a4:	b2da      	uxtb	r2, r3
    87a6:	f642 7376 	movw	r3, #12150	; 0x2f76
    87aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    87ae:	701a      	strb	r2, [r3, #0]
    87b0:	f642 7376 	movw	r3, #12150	; 0x2f76
    87b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    87b8:	781b      	ldrb	r3, [r3, #0]
    87ba:	2b27      	cmp	r3, #39	; 0x27
    87bc:	d9cd      	bls.n	875a <uip_connect+0x5a>
			{
				goto again;
			}
		}

		conn = 0;
    87be:	f04f 0400 	mov.w	r4, #0
		for( c = 0; c < UIP_CONNS; ++c )
    87c2:	f642 7376 	movw	r3, #12150	; 0x2f76
    87c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    87ca:	f04f 0200 	mov.w	r2, #0
    87ce:	701a      	strb	r2, [r3, #0]
    87d0:	e02a      	b.n	8828 <uip_connect+0x128>
		{
			cconn = &uip_conns[ c ];
    87d2:	f642 7376 	movw	r3, #12150	; 0x2f76
    87d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    87da:	781b      	ldrb	r3, [r3, #0]
    87dc:	f04f 02cc 	mov.w	r2, #204	; 0xcc
    87e0:	fb02 f203 	mul.w	r2, r2, r3
    87e4:	f64a 3370 	movw	r3, #43888	; 0xab70
    87e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    87ec:	eb02 0503 	add.w	r5, r2, r3
			if( cconn->tcpstateflags == UIP_CLOSED )
    87f0:	7e6b      	ldrb	r3, [r5, #25]
    87f2:	2b00      	cmp	r3, #0
    87f4:	d101      	bne.n	87fa <uip_connect+0xfa>
			{
				conn = cconn;
    87f6:	462c      	mov	r4, r5
				break;
    87f8:	e01d      	b.n	8836 <uip_connect+0x136>
			}

			if( cconn->tcpstateflags == UIP_TIME_WAIT )
    87fa:	7e6b      	ldrb	r3, [r5, #25]
    87fc:	2b07      	cmp	r3, #7
    87fe:	d106      	bne.n	880e <uip_connect+0x10e>
			{
				if( conn == 0 || cconn->timer > conn->timer )
    8800:	2c00      	cmp	r4, #0
    8802:	d003      	beq.n	880c <uip_connect+0x10c>
    8804:	7eaa      	ldrb	r2, [r5, #26]
    8806:	7ea3      	ldrb	r3, [r4, #26]
    8808:	429a      	cmp	r2, r3
    880a:	d900      	bls.n	880e <uip_connect+0x10e>
				{
					conn = cconn;
    880c:	462c      	mov	r4, r5
				goto again;
			}
		}

		conn = 0;
		for( c = 0; c < UIP_CONNS; ++c )
    880e:	f642 7376 	movw	r3, #12150	; 0x2f76
    8812:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8816:	781b      	ldrb	r3, [r3, #0]
    8818:	f103 0301 	add.w	r3, r3, #1
    881c:	b2da      	uxtb	r2, r3
    881e:	f642 7376 	movw	r3, #12150	; 0x2f76
    8822:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8826:	701a      	strb	r2, [r3, #0]
    8828:	f642 7376 	movw	r3, #12150	; 0x2f76
    882c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8830:	781b      	ldrb	r3, [r3, #0]
    8832:	2b27      	cmp	r3, #39	; 0x27
    8834:	d9cd      	bls.n	87d2 <uip_connect+0xd2>
					conn = cconn;
				}
			}
		}

		if( conn == 0 )
    8836:	2c00      	cmp	r4, #0
    8838:	d102      	bne.n	8840 <uip_connect+0x140>
		{
			return 0;
    883a:	f04f 0300 	mov.w	r3, #0
    883e:	e04a      	b.n	88d6 <uip_connect+0x1d6>
		}

		conn->tcpstateflags = UIP_SYN_SENT;
    8840:	f04f 0302 	mov.w	r3, #2
    8844:	7663      	strb	r3, [r4, #25]

		conn->snd_nxt[ 0 ] = iss[ 0 ];
    8846:	f642 7370 	movw	r3, #12144	; 0x2f70
    884a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    884e:	781b      	ldrb	r3, [r3, #0]
    8850:	7323      	strb	r3, [r4, #12]
		conn->snd_nxt[ 1 ] = iss[ 1 ];
    8852:	f642 7370 	movw	r3, #12144	; 0x2f70
    8856:	f2c2 0300 	movt	r3, #8192	; 0x2000
    885a:	785b      	ldrb	r3, [r3, #1]
    885c:	7363      	strb	r3, [r4, #13]
		conn->snd_nxt[ 2 ] = iss[ 2 ];
    885e:	f642 7370 	movw	r3, #12144	; 0x2f70
    8862:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8866:	789b      	ldrb	r3, [r3, #2]
    8868:	73a3      	strb	r3, [r4, #14]
		conn->snd_nxt[ 3 ] = iss[ 3 ];
    886a:	f642 7370 	movw	r3, #12144	; 0x2f70
    886e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8872:	78db      	ldrb	r3, [r3, #3]
    8874:	73e3      	strb	r3, [r4, #15]

		conn->initialmss = conn->mss = UIP_TCP_MSS;
    8876:	f240 5392 	movw	r3, #1426	; 0x592
    887a:	8263      	strh	r3, [r4, #18]
    887c:	8a63      	ldrh	r3, [r4, #18]
    887e:	82a3      	strh	r3, [r4, #20]

		conn->len = 1;		/* TCP length of the SYN is one. */
    8880:	f04f 0301 	mov.w	r3, #1
    8884:	8223      	strh	r3, [r4, #16]
		conn->nrtx = 0;
    8886:	f04f 0300 	mov.w	r3, #0
    888a:	76e3      	strb	r3, [r4, #27]
		conn->timer = 1;	/* Send the SYN next time around. */
    888c:	f04f 0301 	mov.w	r3, #1
    8890:	76a3      	strb	r3, [r4, #26]
		conn->rto = UIP_RTO;
    8892:	f04f 0303 	mov.w	r3, #3
    8896:	7623      	strb	r3, [r4, #24]
		conn->sa = 0;
    8898:	f04f 0300 	mov.w	r3, #0
    889c:	75a3      	strb	r3, [r4, #22]
		conn->sv = 16;		/* Initial value of the RTT variance. */
    889e:	f04f 0310 	mov.w	r3, #16
    88a2:	75e3      	strb	r3, [r4, #23]
		conn->lport = htons( lastport );
    88a4:	f642 7374 	movw	r3, #12148	; 0x2f74
    88a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    88ac:	881b      	ldrh	r3, [r3, #0]
    88ae:	4618      	mov	r0, r3
    88b0:	f002 f9b6 	bl	ac20 <htons>
    88b4:	4603      	mov	r3, r0
    88b6:	80a3      	strh	r3, [r4, #4]
		conn->rport = rport;
    88b8:	887b      	ldrh	r3, [r7, #2]
    88ba:	80e3      	strh	r3, [r4, #6]
		uip_ipaddr_copy( &conn->ripaddr, ripaddr );
    88bc:	687b      	ldr	r3, [r7, #4]
    88be:	781b      	ldrb	r3, [r3, #0]
    88c0:	7023      	strb	r3, [r4, #0]
    88c2:	687b      	ldr	r3, [r7, #4]
    88c4:	785b      	ldrb	r3, [r3, #1]
    88c6:	7063      	strb	r3, [r4, #1]
    88c8:	687b      	ldr	r3, [r7, #4]
    88ca:	789b      	ldrb	r3, [r3, #2]
    88cc:	70a3      	strb	r3, [r4, #2]
    88ce:	687b      	ldr	r3, [r7, #4]
    88d0:	78db      	ldrb	r3, [r3, #3]
    88d2:	70e3      	strb	r3, [r4, #3]

		return conn;
    88d4:	4623      	mov	r3, r4
	}
    88d6:	4618      	mov	r0, r3
    88d8:	f107 0708 	add.w	r7, r7, #8
    88dc:	46bd      	mov	sp, r7
    88de:	bdb0      	pop	{r4, r5, r7, pc}

000088e0 <uip_unlisten>:
	}
/*---------------------------------------------------------------------------*/
#endif /* UIP_UDP */

void uip_unlisten( u16_t port )
{
    88e0:	b480      	push	{r7}
    88e2:	b083      	sub	sp, #12
    88e4:	af00      	add	r7, sp, #0
    88e6:	4603      	mov	r3, r0
    88e8:	80fb      	strh	r3, [r7, #6]
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    88ea:	f642 7376 	movw	r3, #12150	; 0x2f76
    88ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    88f2:	f04f 0200 	mov.w	r2, #0
    88f6:	701a      	strb	r2, [r3, #0]
    88f8:	e02a      	b.n	8950 <uip_unlisten+0x70>
	{
		if( uip_listenports[ c ] == port )
    88fa:	f642 7376 	movw	r3, #12150	; 0x2f76
    88fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8902:	781b      	ldrb	r3, [r3, #0]
    8904:	461a      	mov	r2, r3
    8906:	f64c 3350 	movw	r3, #52048	; 0xcb50
    890a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    890e:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    8912:	88fa      	ldrh	r2, [r7, #6]
    8914:	429a      	cmp	r2, r3
    8916:	d10e      	bne.n	8936 <uip_unlisten+0x56>
		{
			uip_listenports[ c ] = 0;
    8918:	f642 7376 	movw	r3, #12150	; 0x2f76
    891c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8920:	781b      	ldrb	r3, [r3, #0]
    8922:	461a      	mov	r2, r3
    8924:	f64c 3350 	movw	r3, #52048	; 0xcb50
    8928:	f2c2 0300 	movt	r3, #8192	; 0x2000
    892c:	f04f 0100 	mov.w	r1, #0
    8930:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
			return;
    8934:	e013      	b.n	895e <uip_unlisten+0x7e>
/*---------------------------------------------------------------------------*/
#endif /* UIP_UDP */

void uip_unlisten( u16_t port )
{
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    8936:	f642 7376 	movw	r3, #12150	; 0x2f76
    893a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    893e:	781b      	ldrb	r3, [r3, #0]
    8940:	f103 0301 	add.w	r3, r3, #1
    8944:	b2da      	uxtb	r2, r3
    8946:	f642 7376 	movw	r3, #12150	; 0x2f76
    894a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    894e:	701a      	strb	r2, [r3, #0]
    8950:	f642 7376 	movw	r3, #12150	; 0x2f76
    8954:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8958:	781b      	ldrb	r3, [r3, #0]
    895a:	2b27      	cmp	r3, #39	; 0x27
    895c:	d9cd      	bls.n	88fa <uip_unlisten+0x1a>
		{
			uip_listenports[ c ] = 0;
			return;
		}
	}
}
    895e:	f107 070c 	add.w	r7, r7, #12
    8962:	46bd      	mov	sp, r7
    8964:	bc80      	pop	{r7}
    8966:	4770      	bx	lr

00008968 <uip_listen>:
/*---------------------------------------------------------------------------*/

void uip_listen( u16_t port )
{
    8968:	b480      	push	{r7}
    896a:	b083      	sub	sp, #12
    896c:	af00      	add	r7, sp, #0
    896e:	4603      	mov	r3, r0
    8970:	80fb      	strh	r3, [r7, #6]
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    8972:	f642 7376 	movw	r3, #12150	; 0x2f76
    8976:	f2c2 0300 	movt	r3, #8192	; 0x2000
    897a:	f04f 0200 	mov.w	r2, #0
    897e:	701a      	strb	r2, [r3, #0]
    8980:	e028      	b.n	89d4 <uip_listen+0x6c>
	{
		if( uip_listenports[ c ] == 0 )
    8982:	f642 7376 	movw	r3, #12150	; 0x2f76
    8986:	f2c2 0300 	movt	r3, #8192	; 0x2000
    898a:	781b      	ldrb	r3, [r3, #0]
    898c:	461a      	mov	r2, r3
    898e:	f64c 3350 	movw	r3, #52048	; 0xcb50
    8992:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8996:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    899a:	2b00      	cmp	r3, #0
    899c:	d10d      	bne.n	89ba <uip_listen+0x52>
		{
			uip_listenports[ c ] = port;
    899e:	f642 7376 	movw	r3, #12150	; 0x2f76
    89a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    89a6:	781b      	ldrb	r3, [r3, #0]
    89a8:	461a      	mov	r2, r3
    89aa:	f64c 3350 	movw	r3, #52048	; 0xcb50
    89ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    89b2:	88f9      	ldrh	r1, [r7, #6]
    89b4:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
			return;
    89b8:	e013      	b.n	89e2 <uip_listen+0x7a>
}
/*---------------------------------------------------------------------------*/

void uip_listen( u16_t port )
{
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    89ba:	f642 7376 	movw	r3, #12150	; 0x2f76
    89be:	f2c2 0300 	movt	r3, #8192	; 0x2000
    89c2:	781b      	ldrb	r3, [r3, #0]
    89c4:	f103 0301 	add.w	r3, r3, #1
    89c8:	b2da      	uxtb	r2, r3
    89ca:	f642 7376 	movw	r3, #12150	; 0x2f76
    89ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    89d2:	701a      	strb	r2, [r3, #0]
    89d4:	f642 7376 	movw	r3, #12150	; 0x2f76
    89d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    89dc:	781b      	ldrb	r3, [r3, #0]
    89de:	2b27      	cmp	r3, #39	; 0x27
    89e0:	d9cf      	bls.n	8982 <uip_listen+0x1a>
		{
			uip_listenports[ c ] = port;
			return;
		}
	}
}
    89e2:	f107 070c 	add.w	r7, r7, #12
    89e6:	46bd      	mov	sp, r7
    89e8:	bc80      	pop	{r7}
    89ea:	4770      	bx	lr

000089ec <uip_add_rcv_nxt>:
/*---------------------------------------------------------------------------*/
#endif /* UIP_REASSEMBLY */


static void uip_add_rcv_nxt( u16_t n )
{
    89ec:	b580      	push	{r7, lr}
    89ee:	b082      	sub	sp, #8
    89f0:	af00      	add	r7, sp, #0
    89f2:	4603      	mov	r3, r0
    89f4:	80fb      	strh	r3, [r7, #6]
	uip_add32( uip_conn->rcv_nxt, n );
    89f6:	f64a 336c 	movw	r3, #43884	; 0xab6c
    89fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    89fe:	681b      	ldr	r3, [r3, #0]
    8a00:	f103 0208 	add.w	r2, r3, #8
    8a04:	88fb      	ldrh	r3, [r7, #6]
    8a06:	4610      	mov	r0, r2
    8a08:	4619      	mov	r1, r3
    8a0a:	f7ff fc7d 	bl	8308 <uip_add32>
	uip_conn->rcv_nxt[ 0 ] = uip_acc32[ 0 ];
    8a0e:	f64a 336c 	movw	r3, #43884	; 0xab6c
    8a12:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8a16:	681a      	ldr	r2, [r3, #0]
    8a18:	f64a 3360 	movw	r3, #43872	; 0xab60
    8a1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8a20:	781b      	ldrb	r3, [r3, #0]
    8a22:	7213      	strb	r3, [r2, #8]
	uip_conn->rcv_nxt[ 1 ] = uip_acc32[ 1 ];
    8a24:	f64a 336c 	movw	r3, #43884	; 0xab6c
    8a28:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8a2c:	681a      	ldr	r2, [r3, #0]
    8a2e:	f64a 3360 	movw	r3, #43872	; 0xab60
    8a32:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8a36:	785b      	ldrb	r3, [r3, #1]
    8a38:	7253      	strb	r3, [r2, #9]
	uip_conn->rcv_nxt[ 2 ] = uip_acc32[ 2 ];
    8a3a:	f64a 336c 	movw	r3, #43884	; 0xab6c
    8a3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8a42:	681a      	ldr	r2, [r3, #0]
    8a44:	f64a 3360 	movw	r3, #43872	; 0xab60
    8a48:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8a4c:	789b      	ldrb	r3, [r3, #2]
    8a4e:	7293      	strb	r3, [r2, #10]
	uip_conn->rcv_nxt[ 3 ] = uip_acc32[ 3 ];
    8a50:	f64a 336c 	movw	r3, #43884	; 0xab6c
    8a54:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8a58:	681a      	ldr	r2, [r3, #0]
    8a5a:	f64a 3360 	movw	r3, #43872	; 0xab60
    8a5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8a62:	78db      	ldrb	r3, [r3, #3]
    8a64:	72d3      	strb	r3, [r2, #11]
}
    8a66:	f107 0708 	add.w	r7, r7, #8
    8a6a:	46bd      	mov	sp, r7
    8a6c:	bd80      	pop	{r7, pc}
    8a6e:	bf00      	nop

00008a70 <uip_process>:
/*---------------------------------------------------------------------------*/

void uip_process( u8_t flag )
{
    8a70:	b590      	push	{r4, r7, lr}
    8a72:	b085      	sub	sp, #20
    8a74:	af00      	add	r7, sp, #0
    8a76:	4603      	mov	r3, r0
    8a78:	71fb      	strb	r3, [r7, #7]
	register struct uip_conn	*uip_connr = uip_conn;
    8a7a:	f64a 336c 	movw	r3, #43884	; 0xab6c
    8a7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8a82:	681c      	ldr	r4, [r3, #0]
		{
			goto udp_send;
		}
	#endif /* UIP_UDP */

	uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
    8a84:	f240 6390 	movw	r3, #1680	; 0x690
    8a88:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8a8c:	681b      	ldr	r3, [r3, #0]
    8a8e:	f103 0236 	add.w	r2, r3, #54	; 0x36
    8a92:	f64a 3368 	movw	r3, #43880	; 0xab68
    8a96:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8a9a:	601a      	str	r2, [r3, #0]
    8a9c:	f64a 3368 	movw	r3, #43880	; 0xab68
    8aa0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8aa4:	681a      	ldr	r2, [r3, #0]
    8aa6:	f64a 335c 	movw	r3, #43868	; 0xab5c
    8aaa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8aae:	601a      	str	r2, [r3, #0]

	/* Check if we were invoked because of a poll request for a
	 particular connection. */
	if( flag == UIP_POLL_REQUEST )
    8ab0:	79fb      	ldrb	r3, [r7, #7]
    8ab2:	2b03      	cmp	r3, #3
    8ab4:	d114      	bne.n	8ae0 <uip_process+0x70>
	{
		if( (uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED && !uip_outstanding(uip_connr) )
    8ab6:	7e63      	ldrb	r3, [r4, #25]
    8ab8:	f003 030f 	and.w	r3, r3, #15
    8abc:	2b03      	cmp	r3, #3
    8abe:	f042 807c 	bne.w	abba <uip_process+0x214a>
    8ac2:	8a23      	ldrh	r3, [r4, #16]
    8ac4:	2b00      	cmp	r3, #0
    8ac6:	f042 807a 	bne.w	abbe <uip_process+0x214e>
		{
			uip_flags = UIP_POLL;
    8aca:	f64a 3364 	movw	r3, #43876	; 0xab64
    8ace:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8ad2:	f04f 0208 	mov.w	r2, #8
    8ad6:	701a      	strb	r2, [r3, #0]
			UIP_APPCALL();
    8ad8:	f003 fcd0 	bl	c47c <httpd_appcall>
			goto appsend;
    8adc:	f001 bcbc 	b.w	a458 <uip_process+0x19e8>

		goto drop;

		/* Check if we were invoked because of the perodic timer fireing. */
	}
	else if( flag == UIP_TIMER )
    8ae0:	79fb      	ldrb	r3, [r7, #7]
    8ae2:	2b02      	cmp	r3, #2
    8ae4:	f040 8109 	bne.w	8cfa <uip_process+0x28a>
				--uip_reasstmr;
			}
		#endif /* UIP_REASSEMBLY */

		/* Increase the initial sequence number. */
		if( ++iss[ 3 ] == 0 )
    8ae8:	f642 7370 	movw	r3, #12144	; 0x2f70
    8aec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8af0:	78db      	ldrb	r3, [r3, #3]
    8af2:	f103 0301 	add.w	r3, r3, #1
    8af6:	b2da      	uxtb	r2, r3
    8af8:	f642 7370 	movw	r3, #12144	; 0x2f70
    8afc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8b00:	70da      	strb	r2, [r3, #3]
    8b02:	f642 7370 	movw	r3, #12144	; 0x2f70
    8b06:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8b0a:	78db      	ldrb	r3, [r3, #3]
    8b0c:	2b00      	cmp	r3, #0
    8b0e:	d134      	bne.n	8b7a <uip_process+0x10a>
		{
			if( ++iss[ 2 ] == 0 )
    8b10:	f642 7370 	movw	r3, #12144	; 0x2f70
    8b14:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8b18:	789b      	ldrb	r3, [r3, #2]
    8b1a:	f103 0301 	add.w	r3, r3, #1
    8b1e:	b2da      	uxtb	r2, r3
    8b20:	f642 7370 	movw	r3, #12144	; 0x2f70
    8b24:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8b28:	709a      	strb	r2, [r3, #2]
    8b2a:	f642 7370 	movw	r3, #12144	; 0x2f70
    8b2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8b32:	789b      	ldrb	r3, [r3, #2]
    8b34:	2b00      	cmp	r3, #0
    8b36:	d120      	bne.n	8b7a <uip_process+0x10a>
			{
				if( ++iss[ 1 ] == 0 )
    8b38:	f642 7370 	movw	r3, #12144	; 0x2f70
    8b3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8b40:	785b      	ldrb	r3, [r3, #1]
    8b42:	f103 0301 	add.w	r3, r3, #1
    8b46:	b2da      	uxtb	r2, r3
    8b48:	f642 7370 	movw	r3, #12144	; 0x2f70
    8b4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8b50:	705a      	strb	r2, [r3, #1]
    8b52:	f642 7370 	movw	r3, #12144	; 0x2f70
    8b56:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8b5a:	785b      	ldrb	r3, [r3, #1]
    8b5c:	2b00      	cmp	r3, #0
    8b5e:	d10c      	bne.n	8b7a <uip_process+0x10a>
				{
					++iss[ 0 ];
    8b60:	f642 7370 	movw	r3, #12144	; 0x2f70
    8b64:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8b68:	781b      	ldrb	r3, [r3, #0]
    8b6a:	f103 0301 	add.w	r3, r3, #1
    8b6e:	b2da      	uxtb	r2, r3
    8b70:	f642 7370 	movw	r3, #12144	; 0x2f70
    8b74:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8b78:	701a      	strb	r2, [r3, #0]
				}
			}
		}

		/* Reset the length variables. */
		uip_len = 0;
    8b7a:	f64a 3358 	movw	r3, #43864	; 0xab58
    8b7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8b82:	f04f 0200 	mov.w	r2, #0
    8b86:	801a      	strh	r2, [r3, #0]
		uip_slen = 0;
    8b88:	f64c 33e4 	movw	r3, #52196	; 0xcbe4
    8b8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8b90:	f04f 0200 	mov.w	r2, #0
    8b94:	801a      	strh	r2, [r3, #0]

		/* Check if the connection is in a state in which we simply wait
		for the connection to time out. If so, we increase the
		connection's timer and remove the connection if it times
		out. */
		if( uip_connr->tcpstateflags == UIP_TIME_WAIT || uip_connr->tcpstateflags == UIP_FIN_WAIT_2 )
    8b96:	7e63      	ldrb	r3, [r4, #25]
    8b98:	2b07      	cmp	r3, #7
    8b9a:	d002      	beq.n	8ba2 <uip_process+0x132>
    8b9c:	7e63      	ldrb	r3, [r4, #25]
    8b9e:	2b05      	cmp	r3, #5
    8ba0:	d10d      	bne.n	8bbe <uip_process+0x14e>
		{
			++( uip_connr->timer );
    8ba2:	7ea3      	ldrb	r3, [r4, #26]
    8ba4:	f103 0301 	add.w	r3, r3, #1
    8ba8:	b2db      	uxtb	r3, r3
    8baa:	76a3      	strb	r3, [r4, #26]
			if( uip_connr->timer == UIP_TIME_WAIT_TIMEOUT )
    8bac:	7ea3      	ldrb	r3, [r4, #26]
    8bae:	2b78      	cmp	r3, #120	; 0x78
    8bb0:	d102      	bne.n	8bb8 <uip_process+0x148>
			{
				uip_connr->tcpstateflags = UIP_CLOSED;
    8bb2:	f04f 0300 	mov.w	r3, #0
    8bb6:	7663      	strb	r3, [r4, #25]

		/* Check if the connection is in a state in which we simply wait
		for the connection to time out. If so, we increase the
		connection's timer and remove the connection if it times
		out. */
		if( uip_connr->tcpstateflags == UIP_TIME_WAIT || uip_connr->tcpstateflags == UIP_FIN_WAIT_2 )
    8bb8:	bf00      	nop
				UIP_APPCALL();
				goto appsend;
			}
		}

		goto drop;
    8bba:	f002 b81d 	b.w	abf8 <uip_process+0x2188>
			if( uip_connr->timer == UIP_TIME_WAIT_TIMEOUT )
			{
				uip_connr->tcpstateflags = UIP_CLOSED;
			}
		}
		else if( uip_connr->tcpstateflags != UIP_CLOSED )
    8bbe:	7e63      	ldrb	r3, [r4, #25]
    8bc0:	2b00      	cmp	r3, #0
    8bc2:	f001 87fe 	beq.w	abc2 <uip_process+0x2152>
		{
			/* If the connection has outstanding data, we increase the
			connection's timer and see if it has reached the RTO value
			in which case we retransmit. */
			if( uip_outstanding(uip_connr) )
    8bc6:	8a23      	ldrh	r3, [r4, #16]
    8bc8:	2b00      	cmp	r3, #0
    8bca:	f000 8085 	beq.w	8cd8 <uip_process+0x268>
			{
				if( uip_connr->timer-- == 0 )
    8bce:	7ea3      	ldrb	r3, [r4, #26]
    8bd0:	2b00      	cmp	r3, #0
    8bd2:	bf14      	ite	ne
    8bd4:	2200      	movne	r2, #0
    8bd6:	2201      	moveq	r2, #1
    8bd8:	b2d2      	uxtb	r2, r2
    8bda:	f103 33ff 	add.w	r3, r3, #4294967295
    8bde:	b2db      	uxtb	r3, r3
    8be0:	76a3      	strb	r3, [r4, #26]
    8be2:	2a00      	cmp	r2, #0
    8be4:	f001 87ef 	beq.w	abc6 <uip_process+0x2156>
				{
					if
					(
						uip_connr->nrtx == UIP_MAXRTX ||
    8be8:	7ee3      	ldrb	r3, [r4, #27]
			if( uip_outstanding(uip_connr) )
			{
				if( uip_connr->timer-- == 0 )
				{
					if
					(
    8bea:	2b08      	cmp	r3, #8
    8bec:	d008      	beq.n	8c00 <uip_process+0x190>
						uip_connr->nrtx == UIP_MAXRTX ||
						(
							(uip_connr->tcpstateflags == UIP_SYN_SENT || uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
    8bee:	7e63      	ldrb	r3, [r4, #25]
			if( uip_outstanding(uip_connr) )
			{
				if( uip_connr->timer-- == 0 )
				{
					if
					(
    8bf0:	2b02      	cmp	r3, #2
    8bf2:	d002      	beq.n	8bfa <uip_process+0x18a>
						uip_connr->nrtx == UIP_MAXRTX ||
						(
							(uip_connr->tcpstateflags == UIP_SYN_SENT || uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
    8bf4:	7e63      	ldrb	r3, [r4, #25]
			if( uip_outstanding(uip_connr) )
			{
				if( uip_connr->timer-- == 0 )
				{
					if
					(
    8bf6:	2b01      	cmp	r3, #1
    8bf8:	d11b      	bne.n	8c32 <uip_process+0x1c2>
						uip_connr->nrtx == UIP_MAXRTX ||
						(
							(uip_connr->tcpstateflags == UIP_SYN_SENT || uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
							uip_connr->nrtx == UIP_MAXSYNRTX
    8bfa:	7ee3      	ldrb	r3, [r4, #27]
			if( uip_outstanding(uip_connr) )
			{
				if( uip_connr->timer-- == 0 )
				{
					if
					(
    8bfc:	2b05      	cmp	r3, #5
    8bfe:	d118      	bne.n	8c32 <uip_process+0x1c2>
							(uip_connr->tcpstateflags == UIP_SYN_SENT || uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
							uip_connr->nrtx == UIP_MAXSYNRTX
						)
					)
					{
						uip_connr->tcpstateflags = UIP_CLOSED;
    8c00:	f04f 0300 	mov.w	r3, #0
    8c04:	7663      	strb	r3, [r4, #25]

						/* We call UIP_APPCALL() with uip_flags set to
						UIP_TIMEDOUT to inform the application that the
						connection has timed out. */
						uip_flags = UIP_TIMEDOUT;
    8c06:	f64a 3364 	movw	r3, #43876	; 0xab64
    8c0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8c0e:	f06f 027f 	mvn.w	r2, #127	; 0x7f
    8c12:	701a      	strb	r2, [r3, #0]
						UIP_APPCALL();
    8c14:	f003 fc32 	bl	c47c <httpd_appcall>

						/* We also send a reset packet to the remote host. */
						BUF->flags = TCP_RST | TCP_ACK;
    8c18:	f240 6390 	movw	r3, #1680	; 0x690
    8c1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8c20:	681b      	ldr	r3, [r3, #0]
    8c22:	f103 030e 	add.w	r3, r3, #14
    8c26:	f04f 0214 	mov.w	r2, #20
    8c2a:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
						goto tcp_send_nodata;
    8c2e:	f001 bd9e 	b.w	a76e <uip_process+0x1cfe>
					}

					/* Exponential backoff. */
					uip_connr->timer = UIP_RTO << ( uip_connr->nrtx > 4 ? 4 : uip_connr->nrtx );
    8c32:	7ee3      	ldrb	r3, [r4, #27]
    8c34:	2b04      	cmp	r3, #4
    8c36:	d806      	bhi.n	8c46 <uip_process+0x1d6>
    8c38:	7ee3      	ldrb	r3, [r4, #27]
    8c3a:	f04f 0203 	mov.w	r2, #3
    8c3e:	fa02 f303 	lsl.w	r3, r2, r3
    8c42:	b2db      	uxtb	r3, r3
    8c44:	e001      	b.n	8c4a <uip_process+0x1da>
    8c46:	f04f 0330 	mov.w	r3, #48	; 0x30
    8c4a:	76a3      	strb	r3, [r4, #26]
					++( uip_connr->nrtx );
    8c4c:	7ee3      	ldrb	r3, [r4, #27]
    8c4e:	f103 0301 	add.w	r3, r3, #1
    8c52:	b2db      	uxtb	r3, r3
    8c54:	76e3      	strb	r3, [r4, #27]
					depending on which state we are in. In ESTABLISHED, we
					call upon the application so that it may prepare the
					data for the retransmit. In SYN_RCVD, we resend the
					SYNACK that we sent earlier and in LAST_ACK we have to
					retransmit our FINACK. */
							UIP_STAT( ++uip_stat.tcp.rexmit );
    8c56:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8c5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8c5e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    8c60:	f103 0301 	add.w	r3, r3, #1
    8c64:	b29a      	uxth	r2, r3
    8c66:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8c6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8c6e:	855a      	strh	r2, [r3, #42]	; 0x2a
					switch( uip_connr->tcpstateflags & UIP_TS_MASK )
    8c70:	7e63      	ldrb	r3, [r4, #25]
    8c72:	f003 030f 	and.w	r3, r3, #15
    8c76:	f103 33ff 	add.w	r3, r3, #4294967295
    8c7a:	2b07      	cmp	r3, #7
    8c7c:	f201 87a5 	bhi.w	abca <uip_process+0x215a>
    8c80:	a201      	add	r2, pc, #4	; (adr r2, 8c88 <uip_process+0x218>)
    8c82:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    8c86:	bf00      	nop
    8c88:	00009b5f 	.word	0x00009b5f
    8c8c:	00008ca9 	.word	0x00008ca9
    8c90:	00008cc3 	.word	0x00008cc3
    8c94:	0000a2c1 	.word	0x0000a2c1
    8c98:	0000abcb 	.word	0x0000abcb
    8c9c:	0000a2c1 	.word	0x0000a2c1
    8ca0:	0000abcb 	.word	0x0000abcb
    8ca4:	0000a2c1 	.word	0x0000a2c1
							goto tcp_send_synack;

						#if UIP_ACTIVE_OPEN
							case UIP_SYN_SENT:
								/* In the SYN_SENT state, we retransmit out SYN. */
								BUF->flags = 0;
    8ca8:	f240 6390 	movw	r3, #1680	; 0x690
    8cac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8cb0:	681b      	ldr	r3, [r3, #0]
    8cb2:	f103 030e 	add.w	r3, r3, #14
    8cb6:	f04f 0200 	mov.w	r2, #0
    8cba:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
								goto tcp_send_syn;
    8cbe:	f000 bf5e 	b.w	9b7e <uip_process+0x110e>
						case UIP_ESTABLISHED:
							/* In the ESTABLISHED state, we call upon the application
							to do the actual retransmit after which we jump into
							the code for sending out the packet (the apprexmit
							label). */
							uip_flags = UIP_REXMIT;
    8cc2:	f64a 3364 	movw	r3, #43876	; 0xab64
    8cc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8cca:	f04f 0204 	mov.w	r2, #4
    8cce:	701a      	strb	r2, [r3, #0]
							UIP_APPCALL();
    8cd0:	f003 fbd4 	bl	c47c <httpd_appcall>
							goto apprexmit;
    8cd4:	f001 bc39 	b.w	a54a <uip_process+0x1ada>
							/* In all these states we should retransmit a FINACK. */
							goto tcp_send_finack;
					}
				}
			}
			else if( (uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED )
    8cd8:	7e63      	ldrb	r3, [r4, #25]
    8cda:	f003 030f 	and.w	r3, r3, #15
    8cde:	2b03      	cmp	r3, #3
    8ce0:	f041 8775 	bne.w	abce <uip_process+0x215e>
			{
				/* If there was no need for a retransmission, we poll the
				application for new data. */
				uip_flags = UIP_POLL;
    8ce4:	f64a 3364 	movw	r3, #43876	; 0xab64
    8ce8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8cec:	f04f 0208 	mov.w	r2, #8
    8cf0:	701a      	strb	r2, [r3, #0]
				UIP_APPCALL();
    8cf2:	f003 fbc3 	bl	c47c <httpd_appcall>
				goto appsend;
    8cf6:	f001 bbaf 	b.w	a458 <uip_process+0x19e8>
			}
		}
	#endif

	/* This is where the input processing starts. */
	UIP_STAT( ++uip_stat.ip.recv );
    8cfa:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8cfe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8d02:	881b      	ldrh	r3, [r3, #0]
    8d04:	f103 0301 	add.w	r3, r3, #1
    8d08:	b29a      	uxth	r2, r3
    8d0a:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8d0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8d12:	801a      	strh	r2, [r3, #0]
			goto drop;
		}

	#else /* UIP_CONF_IPV6 */
		/* Check validity of the IP header. */
		if( BUF->vhl != 0x45 )
    8d14:	f240 6390 	movw	r3, #1680	; 0x690
    8d18:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8d1c:	681b      	ldr	r3, [r3, #0]
    8d1e:	f103 030e 	add.w	r3, r3, #14
    8d22:	781b      	ldrb	r3, [r3, #0]
    8d24:	2b45      	cmp	r3, #69	; 0x45
    8d26:	d01b      	beq.n	8d60 <uip_process+0x2f0>
		{					/* IP version and header length. */
			UIP_STAT( ++uip_stat.ip.drop );
    8d28:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8d2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8d30:	88db      	ldrh	r3, [r3, #6]
    8d32:	f103 0301 	add.w	r3, r3, #1
    8d36:	b29a      	uxth	r2, r3
    8d38:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8d3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8d40:	80da      	strh	r2, [r3, #6]
			UIP_STAT( ++uip_stat.ip.vhlerr );
    8d42:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8d46:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8d4a:	891b      	ldrh	r3, [r3, #8]
    8d4c:	f103 0301 	add.w	r3, r3, #1
    8d50:	b29a      	uxth	r2, r3
    8d52:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8d56:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8d5a:	811a      	strh	r2, [r3, #8]
			UIP_LOG( "ip: invalid version or header length." );
			goto drop;
    8d5c:	f001 bf4c 	b.w	abf8 <uip_process+0x2188>
	uip_len is smaller the size reported in the IP header, we assume
	that the packet has been corrupted in transit. If the size of
	uip_len is larger than the size reported in the IP packet header,
	the packet has been padded and we set uip_len to the correct
	value.. */
	if( (BUF->len[ 0 ] << 8) + BUF->len[ 1 ] <= uip_len )
    8d60:	f240 6390 	movw	r3, #1680	; 0x690
    8d64:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8d68:	681b      	ldr	r3, [r3, #0]
    8d6a:	f103 030e 	add.w	r3, r3, #14
    8d6e:	789b      	ldrb	r3, [r3, #2]
    8d70:	ea4f 2203 	mov.w	r2, r3, lsl #8
    8d74:	f240 6390 	movw	r3, #1680	; 0x690
    8d78:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8d7c:	681b      	ldr	r3, [r3, #0]
    8d7e:	f103 030e 	add.w	r3, r3, #14
    8d82:	78db      	ldrb	r3, [r3, #3]
    8d84:	441a      	add	r2, r3
    8d86:	f64a 3358 	movw	r3, #43864	; 0xab58
    8d8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8d8e:	881b      	ldrh	r3, [r3, #0]
    8d90:	429a      	cmp	r2, r3
    8d92:	f301 871e 	bgt.w	abd2 <uip_process+0x2162>
	{
		uip_len = ( BUF->len[ 0 ] << 8 ) + BUF->len[ 1 ];
    8d96:	f240 6390 	movw	r3, #1680	; 0x690
    8d9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8d9e:	681b      	ldr	r3, [r3, #0]
    8da0:	f103 030e 	add.w	r3, r3, #14
    8da4:	789b      	ldrb	r3, [r3, #2]
    8da6:	ea4f 2303 	mov.w	r3, r3, lsl #8
    8daa:	b29a      	uxth	r2, r3
    8dac:	f240 6390 	movw	r3, #1680	; 0x690
    8db0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8db4:	681b      	ldr	r3, [r3, #0]
    8db6:	f103 030e 	add.w	r3, r3, #14
    8dba:	78db      	ldrb	r3, [r3, #3]
    8dbc:	4413      	add	r3, r2
    8dbe:	b29a      	uxth	r2, r3
    8dc0:	f64a 3358 	movw	r3, #43864	; 0xab58
    8dc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8dc8:	801a      	strh	r2, [r3, #0]
		goto drop;
	}

	#if !UIP_CONF_IPV6
		/* Check the fragment flag. */
		if( (BUF->ipoffset[ 0 ] & 0x3f) != 0 || BUF->ipoffset[ 1 ] != 0 )
    8dca:	f240 6390 	movw	r3, #1680	; 0x690
    8dce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8dd2:	681b      	ldr	r3, [r3, #0]
    8dd4:	f103 030e 	add.w	r3, r3, #14
    8dd8:	799b      	ldrb	r3, [r3, #6]
    8dda:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    8dde:	2b00      	cmp	r3, #0
    8de0:	d109      	bne.n	8df6 <uip_process+0x386>
    8de2:	f240 6390 	movw	r3, #1680	; 0x690
    8de6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8dea:	681b      	ldr	r3, [r3, #0]
    8dec:	f103 030e 	add.w	r3, r3, #14
    8df0:	79db      	ldrb	r3, [r3, #7]
    8df2:	2b00      	cmp	r3, #0
    8df4:	d01b      	beq.n	8e2e <uip_process+0x3be>
				if( uip_len == 0 )
				{
					goto drop;
				}
			#else /* UIP_REASSEMBLY */
				UIP_STAT( ++uip_stat.ip.drop );
    8df6:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8dfa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8dfe:	88db      	ldrh	r3, [r3, #6]
    8e00:	f103 0301 	add.w	r3, r3, #1
    8e04:	b29a      	uxth	r2, r3
    8e06:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8e0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8e0e:	80da      	strh	r2, [r3, #6]
				UIP_STAT( ++uip_stat.ip.fragerr );
    8e10:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8e14:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8e18:	89db      	ldrh	r3, [r3, #14]
    8e1a:	f103 0301 	add.w	r3, r3, #1
    8e1e:	b29a      	uxth	r2, r3
    8e20:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8e24:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8e28:	81da      	strh	r2, [r3, #14]
				UIP_LOG( "ip: fragment dropped." );
				goto drop;
    8e2a:	f001 bee5 	b.w	abf8 <uip_process+0x2188>
			#endif /* UIP_REASSEMBLY */
		}
	#endif /* UIP_CONF_IPV6 */

	if( uip_ipaddr_cmp(&uip_hostaddr, &uip_all_zeroes_addr) )
    8e2e:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    8e32:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8e36:	881a      	ldrh	r2, [r3, #0]
    8e38:	f643 3330 	movw	r3, #15152	; 0x3b30
    8e3c:	f2c0 0301 	movt	r3, #1
    8e40:	881b      	ldrh	r3, [r3, #0]
    8e42:	429a      	cmp	r2, r3
    8e44:	d10b      	bne.n	8e5e <uip_process+0x3ee>
    8e46:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    8e4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8e4e:	885a      	ldrh	r2, [r3, #2]
    8e50:	f643 3330 	movw	r3, #15152	; 0x3b30
    8e54:	f2c0 0301 	movt	r3, #1
    8e58:	885b      	ldrh	r3, [r3, #2]
    8e5a:	429a      	cmp	r2, r3
    8e5c:	d038      	beq.n	8ed0 <uip_process+0x460>
			}
		#endif /* UIP_BROADCAST */

		/* Check if the packet is destined for our IP address. */
		#if !UIP_CONF_IPV6
			if( !uip_ipaddr_cmp(&BUF->destipaddr, &uip_hostaddr) )
    8e5e:	f240 6390 	movw	r3, #1680	; 0x690
    8e62:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8e66:	681b      	ldr	r3, [r3, #0]
    8e68:	f103 030e 	add.w	r3, r3, #14
    8e6c:	7c1a      	ldrb	r2, [r3, #16]
    8e6e:	7c5b      	ldrb	r3, [r3, #17]
    8e70:	ea4f 2303 	mov.w	r3, r3, lsl #8
    8e74:	ea43 0302 	orr.w	r3, r3, r2
    8e78:	b29a      	uxth	r2, r3
    8e7a:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    8e7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8e82:	881b      	ldrh	r3, [r3, #0]
    8e84:	429a      	cmp	r2, r3
    8e86:	d114      	bne.n	8eb2 <uip_process+0x442>
    8e88:	f240 6390 	movw	r3, #1680	; 0x690
    8e8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8e90:	681b      	ldr	r3, [r3, #0]
    8e92:	f103 030e 	add.w	r3, r3, #14
    8e96:	7c9a      	ldrb	r2, [r3, #18]
    8e98:	7cdb      	ldrb	r3, [r3, #19]
    8e9a:	ea4f 2303 	mov.w	r3, r3, lsl #8
    8e9e:	ea43 0302 	orr.w	r3, r3, r2
    8ea2:	b29a      	uxth	r2, r3
    8ea4:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    8ea8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8eac:	885b      	ldrh	r3, [r3, #2]
    8eae:	429a      	cmp	r2, r3
    8eb0:	d00e      	beq.n	8ed0 <uip_process+0x460>
			{
				UIP_STAT( ++uip_stat.ip.drop );
    8eb2:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8eb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8eba:	88db      	ldrh	r3, [r3, #6]
    8ebc:	f103 0301 	add.w	r3, r3, #1
    8ec0:	b29a      	uxth	r2, r3
    8ec2:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8ec6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8eca:	80da      	strh	r2, [r3, #6]
				goto drop;
    8ecc:	f001 be94 	b.w	abf8 <uip_process+0x2188>
			}
		#endif /* UIP_CONF_IPV6 */
	}

	#if !UIP_CONF_IPV6
		if( uip_ipchksum() != 0xffff )
    8ed0:	f7ff fb24 	bl	851c <uip_ipchksum>
    8ed4:	4603      	mov	r3, r0
    8ed6:	461a      	mov	r2, r3
    8ed8:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8edc:	429a      	cmp	r2, r3
    8ede:	d01b      	beq.n	8f18 <uip_process+0x4a8>
		{
			/* Compute and check the IP header checksum. */
			UIP_STAT( ++uip_stat.ip.drop );
    8ee0:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8ee4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8ee8:	88db      	ldrh	r3, [r3, #6]
    8eea:	f103 0301 	add.w	r3, r3, #1
    8eee:	b29a      	uxth	r2, r3
    8ef0:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8ef4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8ef8:	80da      	strh	r2, [r3, #6]
			UIP_STAT( ++uip_stat.ip.chkerr );
    8efa:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8efe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8f02:	8a1b      	ldrh	r3, [r3, #16]
    8f04:	f103 0301 	add.w	r3, r3, #1
    8f08:	b29a      	uxth	r2, r3
    8f0a:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8f0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8f12:	821a      	strh	r2, [r3, #16]
			UIP_LOG( "ip: bad checksum." );
			goto drop;
    8f14:	f001 be70 	b.w	abf8 <uip_process+0x2188>
		}
	#endif /* UIP_CONF_IPV6 */

	if( BUF->proto == UIP_PROTO_TCP )
    8f18:	f240 6390 	movw	r3, #1680	; 0x690
    8f1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8f20:	681b      	ldr	r3, [r3, #0]
    8f22:	f103 030e 	add.w	r3, r3, #14
    8f26:	7a5b      	ldrb	r3, [r3, #9]
    8f28:	2b06      	cmp	r3, #6
    8f2a:	f000 8151 	beq.w	91d0 <uip_process+0x760>
		}
	#endif /* UIP_UDP */

	#if !UIP_CONF_IPV6
		/* ICMPv4 processing code follows. */
		if( BUF->proto != UIP_PROTO_ICMP )
    8f2e:	f240 6390 	movw	r3, #1680	; 0x690
    8f32:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8f36:	681b      	ldr	r3, [r3, #0]
    8f38:	f103 030e 	add.w	r3, r3, #14
    8f3c:	7a5b      	ldrb	r3, [r3, #9]
    8f3e:	2b01      	cmp	r3, #1
    8f40:	d01b      	beq.n	8f7a <uip_process+0x50a>
		{
			/* We only allow ICMP packets from here. */
			UIP_STAT( ++uip_stat.ip.drop );
    8f42:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8f46:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8f4a:	88db      	ldrh	r3, [r3, #6]
    8f4c:	f103 0301 	add.w	r3, r3, #1
    8f50:	b29a      	uxth	r2, r3
    8f52:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8f56:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8f5a:	80da      	strh	r2, [r3, #6]
			UIP_STAT( ++uip_stat.ip.protoerr );
    8f5c:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8f60:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8f64:	8a5b      	ldrh	r3, [r3, #18]
    8f66:	f103 0301 	add.w	r3, r3, #1
    8f6a:	b29a      	uxth	r2, r3
    8f6c:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8f70:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8f74:	825a      	strh	r2, [r3, #18]
			UIP_LOG( "ip: neither tcp nor icmp." );
			goto drop;
    8f76:	f001 be3f 	b.w	abf8 <uip_process+0x2188>

		#if UIP_PINGADDRCONF
			icmp_input :
		#endif /* UIP_PINGADDRCONF */

		UIP_STAT( ++uip_stat.icmp.recv );
    8f7a:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8f7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8f82:	8a9b      	ldrh	r3, [r3, #20]
    8f84:	f103 0301 	add.w	r3, r3, #1
    8f88:	b29a      	uxth	r2, r3
    8f8a:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8f8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8f92:	829a      	strh	r2, [r3, #20]

		/* ICMP echo (i.e., ping) processing. This is simple, we only change
		 the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
		 checksum before we return the packet. */
		if( ICMPBUF->type != ICMP_ECHO )
    8f94:	f240 6390 	movw	r3, #1680	; 0x690
    8f98:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8f9c:	681b      	ldr	r3, [r3, #0]
    8f9e:	f103 030e 	add.w	r3, r3, #14
    8fa2:	7d1b      	ldrb	r3, [r3, #20]
    8fa4:	2b08      	cmp	r3, #8
    8fa6:	d01b      	beq.n	8fe0 <uip_process+0x570>
		{
			UIP_STAT( ++uip_stat.icmp.drop );
    8fa8:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8fac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8fb0:	8b1b      	ldrh	r3, [r3, #24]
    8fb2:	f103 0301 	add.w	r3, r3, #1
    8fb6:	b29a      	uxth	r2, r3
    8fb8:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8fbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8fc0:	831a      	strh	r2, [r3, #24]
			UIP_STAT( ++uip_stat.icmp.typeerr );
    8fc2:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8fc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8fca:	8b5b      	ldrh	r3, [r3, #26]
    8fcc:	f103 0301 	add.w	r3, r3, #1
    8fd0:	b29a      	uxth	r2, r3
    8fd2:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    8fd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8fda:	835a      	strh	r2, [r3, #26]
			UIP_LOG( "icmp: not icmp echo." );
			goto drop;
    8fdc:	f001 be0c 	b.w	abf8 <uip_process+0x2188>
			{
				uip_hostaddr = BUF->destipaddr;
			}
		#endif /* UIP_PINGADDRCONF */

		ICMPBUF->type = ICMP_ECHO_REPLY;
    8fe0:	f240 6390 	movw	r3, #1680	; 0x690
    8fe4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8fe8:	681b      	ldr	r3, [r3, #0]
    8fea:	f103 030e 	add.w	r3, r3, #14
    8fee:	f04f 0200 	mov.w	r2, #0
    8ff2:	751a      	strb	r2, [r3, #20]

		if( ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8)) )
    8ff4:	f240 6390 	movw	r3, #1680	; 0x690
    8ff8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8ffc:	681b      	ldr	r3, [r3, #0]
    8ffe:	f103 030e 	add.w	r3, r3, #14
    9002:	7d9a      	ldrb	r2, [r3, #22]
    9004:	7ddb      	ldrb	r3, [r3, #23]
    9006:	ea4f 2303 	mov.w	r3, r3, lsl #8
    900a:	ea43 0302 	orr.w	r3, r3, r2
    900e:	b29a      	uxth	r2, r3
    9010:	f64f 73f6 	movw	r3, #65526	; 0xfff6
    9014:	429a      	cmp	r2, r3
    9016:	d927      	bls.n	9068 <uip_process+0x5f8>
		{
			ICMPBUF->icmpchksum += HTONS( ICMP_ECHO << 8 ) + 1;
    9018:	f240 6390 	movw	r3, #1680	; 0x690
    901c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9020:	681b      	ldr	r3, [r3, #0]
    9022:	f103 020e 	add.w	r2, r3, #14
    9026:	f240 6390 	movw	r3, #1680	; 0x690
    902a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    902e:	681b      	ldr	r3, [r3, #0]
    9030:	f103 030e 	add.w	r3, r3, #14
    9034:	7d99      	ldrb	r1, [r3, #22]
    9036:	7ddb      	ldrb	r3, [r3, #23]
    9038:	ea4f 2303 	mov.w	r3, r3, lsl #8
    903c:	ea43 0301 	orr.w	r3, r3, r1
    9040:	b29b      	uxth	r3, r3
    9042:	f103 0309 	add.w	r3, r3, #9
    9046:	b29b      	uxth	r3, r3
    9048:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    904c:	f04f 0000 	mov.w	r0, #0
    9050:	ea40 0101 	orr.w	r1, r0, r1
    9054:	7591      	strb	r1, [r2, #22]
    9056:	ea4f 2313 	mov.w	r3, r3, lsr #8
    905a:	b29b      	uxth	r3, r3
    905c:	f04f 0100 	mov.w	r1, #0
    9060:	ea41 0303 	orr.w	r3, r1, r3
    9064:	75d3      	strb	r3, [r2, #23]
    9066:	e026      	b.n	90b6 <uip_process+0x646>
		}
		else
		{
			ICMPBUF->icmpchksum += HTONS( ICMP_ECHO << 8 );
    9068:	f240 6390 	movw	r3, #1680	; 0x690
    906c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9070:	681b      	ldr	r3, [r3, #0]
    9072:	f103 020e 	add.w	r2, r3, #14
    9076:	f240 6390 	movw	r3, #1680	; 0x690
    907a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    907e:	681b      	ldr	r3, [r3, #0]
    9080:	f103 030e 	add.w	r3, r3, #14
    9084:	7d99      	ldrb	r1, [r3, #22]
    9086:	7ddb      	ldrb	r3, [r3, #23]
    9088:	ea4f 2303 	mov.w	r3, r3, lsl #8
    908c:	ea43 0301 	orr.w	r3, r3, r1
    9090:	b29b      	uxth	r3, r3
    9092:	f103 0308 	add.w	r3, r3, #8
    9096:	b29b      	uxth	r3, r3
    9098:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    909c:	f04f 0000 	mov.w	r0, #0
    90a0:	ea40 0101 	orr.w	r1, r0, r1
    90a4:	7591      	strb	r1, [r2, #22]
    90a6:	ea4f 2313 	mov.w	r3, r3, lsr #8
    90aa:	b29b      	uxth	r3, r3
    90ac:	f04f 0100 	mov.w	r1, #0
    90b0:	ea41 0303 	orr.w	r3, r1, r3
    90b4:	75d3      	strb	r3, [r2, #23]
		}

		/* Swap IP addresses. */
		uip_ipaddr_copy( &BUF->destipaddr, &BUF->srcipaddr );
    90b6:	f240 6390 	movw	r3, #1680	; 0x690
    90ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    90be:	681b      	ldr	r3, [r3, #0]
    90c0:	f103 020e 	add.w	r2, r3, #14
    90c4:	f240 6390 	movw	r3, #1680	; 0x690
    90c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    90cc:	681b      	ldr	r3, [r3, #0]
    90ce:	f103 030e 	add.w	r3, r3, #14
    90d2:	7b1b      	ldrb	r3, [r3, #12]
    90d4:	7413      	strb	r3, [r2, #16]
    90d6:	f240 6390 	movw	r3, #1680	; 0x690
    90da:	f2c2 0300 	movt	r3, #8192	; 0x2000
    90de:	681b      	ldr	r3, [r3, #0]
    90e0:	f103 020e 	add.w	r2, r3, #14
    90e4:	f240 6390 	movw	r3, #1680	; 0x690
    90e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    90ec:	681b      	ldr	r3, [r3, #0]
    90ee:	f103 030e 	add.w	r3, r3, #14
    90f2:	7b5b      	ldrb	r3, [r3, #13]
    90f4:	7453      	strb	r3, [r2, #17]
    90f6:	f240 6390 	movw	r3, #1680	; 0x690
    90fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    90fe:	681b      	ldr	r3, [r3, #0]
    9100:	f103 020e 	add.w	r2, r3, #14
    9104:	f240 6390 	movw	r3, #1680	; 0x690
    9108:	f2c2 0300 	movt	r3, #8192	; 0x2000
    910c:	681b      	ldr	r3, [r3, #0]
    910e:	f103 030e 	add.w	r3, r3, #14
    9112:	7b9b      	ldrb	r3, [r3, #14]
    9114:	7493      	strb	r3, [r2, #18]
    9116:	f240 6390 	movw	r3, #1680	; 0x690
    911a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    911e:	681b      	ldr	r3, [r3, #0]
    9120:	f103 020e 	add.w	r2, r3, #14
    9124:	f240 6390 	movw	r3, #1680	; 0x690
    9128:	f2c2 0300 	movt	r3, #8192	; 0x2000
    912c:	681b      	ldr	r3, [r3, #0]
    912e:	f103 030e 	add.w	r3, r3, #14
    9132:	7bdb      	ldrb	r3, [r3, #15]
    9134:	74d3      	strb	r3, [r2, #19]
		uip_ipaddr_copy( &BUF->srcipaddr, &uip_hostaddr );
    9136:	f240 6390 	movw	r3, #1680	; 0x690
    913a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    913e:	681b      	ldr	r3, [r3, #0]
    9140:	f103 020e 	add.w	r2, r3, #14
    9144:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    9148:	f2c2 0300 	movt	r3, #8192	; 0x2000
    914c:	781b      	ldrb	r3, [r3, #0]
    914e:	7313      	strb	r3, [r2, #12]
    9150:	f240 6390 	movw	r3, #1680	; 0x690
    9154:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9158:	681b      	ldr	r3, [r3, #0]
    915a:	f103 020e 	add.w	r2, r3, #14
    915e:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    9162:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9166:	785b      	ldrb	r3, [r3, #1]
    9168:	7353      	strb	r3, [r2, #13]
    916a:	f240 6390 	movw	r3, #1680	; 0x690
    916e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9172:	681b      	ldr	r3, [r3, #0]
    9174:	f103 020e 	add.w	r2, r3, #14
    9178:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    917c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9180:	789b      	ldrb	r3, [r3, #2]
    9182:	7393      	strb	r3, [r2, #14]
    9184:	f240 6390 	movw	r3, #1680	; 0x690
    9188:	f2c2 0300 	movt	r3, #8192	; 0x2000
    918c:	681b      	ldr	r3, [r3, #0]
    918e:	f103 020e 	add.w	r2, r3, #14
    9192:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    9196:	f2c2 0300 	movt	r3, #8192	; 0x2000
    919a:	78db      	ldrb	r3, [r3, #3]
    919c:	73d3      	strb	r3, [r2, #15]

		UIP_STAT( ++uip_stat.icmp.sent );
    919e:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    91a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    91a6:	8adb      	ldrh	r3, [r3, #22]
    91a8:	f103 0301 	add.w	r3, r3, #1
    91ac:	b29a      	uxth	r2, r3
    91ae:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    91b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    91b6:	82da      	strh	r2, [r3, #22]
		BUF->ttl = UIP_TTL;
    91b8:	f240 6390 	movw	r3, #1680	; 0x690
    91bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    91c0:	681b      	ldr	r3, [r3, #0]
    91c2:	f103 030e 	add.w	r3, r3, #14
    91c6:	f04f 0240 	mov.w	r2, #64	; 0x40
    91ca:	721a      	strb	r2, [r3, #8]
		goto ip_send_nolen;
    91cc:	f001 bc57 	b.w	aa7e <uip_process+0x200e>
	#endif /* UIP_CONF_IPV6 */

	if( BUF->proto == UIP_PROTO_TCP )
	{
		/* Check for TCP packet. If so, proceed with TCP input processing. */
		goto tcp_input;
    91d0:	bf00      	nop
	#endif /* UIP_UDP_CHECKSUMS */
		goto ip_send_nolen;
	#endif /* UIP_UDP */

	/* TCP input processing. */
	tcp_input : UIP_STAT( ++uip_stat.tcp.recv );
    91d2:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    91d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    91da:	8bdb      	ldrh	r3, [r3, #30]
    91dc:	f103 0301 	add.w	r3, r3, #1
    91e0:	b29a      	uxth	r2, r3
    91e2:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    91e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    91ea:	83da      	strh	r2, [r3, #30]

	/* Start of TCP input header processing code. */
	if( uip_tcpchksum() != 0xffff )
    91ec:	f7ff fa0e 	bl	860c <uip_tcpchksum>
    91f0:	4603      	mov	r3, r0
    91f2:	461a      	mov	r2, r3
    91f4:	f64f 73ff 	movw	r3, #65535	; 0xffff
    91f8:	429a      	cmp	r2, r3
    91fa:	d01b      	beq.n	9234 <uip_process+0x7c4>
	{
		/* Compute and check the TCP checksum. */
		UIP_STAT( ++uip_stat.tcp.drop );
    91fc:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    9200:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9204:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
    9206:	f103 0301 	add.w	r3, r3, #1
    920a:	b29a      	uxth	r2, r3
    920c:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    9210:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9214:	845a      	strh	r2, [r3, #34]	; 0x22
		UIP_STAT( ++uip_stat.tcp.chkerr );
    9216:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    921a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    921e:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    9220:	f103 0301 	add.w	r3, r3, #1
    9224:	b29a      	uxth	r2, r3
    9226:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    922a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    922e:	849a      	strh	r2, [r3, #36]	; 0x24
		UIP_LOG( "tcp: bad checksum." );
		goto drop;
    9230:	f001 bce2 	b.w	abf8 <uip_process+0x2188>
	}

	/* Demultiplex this segment. */

	/* First check any active connections. */
	for( uip_connr = &uip_conns[ 0 ]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr )
    9234:	f64a 3470 	movw	r4, #43888	; 0xab70
    9238:	f2c2 0400 	movt	r4, #8192	; 0x2000
    923c:	e049      	b.n	92d2 <uip_process+0x862>
	{
		if
		(
			uip_connr->tcpstateflags != UIP_CLOSED &&
    923e:	7e63      	ldrb	r3, [r4, #25]

	/* First check any active connections. */
	for( uip_connr = &uip_conns[ 0 ]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr )
	{
		if
		(
    9240:	2b00      	cmp	r3, #0
    9242:	d044      	beq.n	92ce <uip_process+0x85e>
			uip_connr->tcpstateflags != UIP_CLOSED &&
			BUF->destport == uip_connr->lport &&
    9244:	f240 6390 	movw	r3, #1680	; 0x690
    9248:	f2c2 0300 	movt	r3, #8192	; 0x2000
    924c:	681b      	ldr	r3, [r3, #0]
    924e:	f103 030e 	add.w	r3, r3, #14
    9252:	7d9a      	ldrb	r2, [r3, #22]
    9254:	7ddb      	ldrb	r3, [r3, #23]
    9256:	ea4f 2303 	mov.w	r3, r3, lsl #8
    925a:	ea43 0302 	orr.w	r3, r3, r2
    925e:	b29a      	uxth	r2, r3
    9260:	88a3      	ldrh	r3, [r4, #4]

	/* First check any active connections. */
	for( uip_connr = &uip_conns[ 0 ]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr )
	{
		if
		(
    9262:	429a      	cmp	r2, r3
    9264:	d133      	bne.n	92ce <uip_process+0x85e>
			uip_connr->tcpstateflags != UIP_CLOSED &&
			BUF->destport == uip_connr->lport &&
			BUF->srcport == uip_connr->rport &&
    9266:	f240 6390 	movw	r3, #1680	; 0x690
    926a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    926e:	681b      	ldr	r3, [r3, #0]
    9270:	f103 030e 	add.w	r3, r3, #14
    9274:	7d1a      	ldrb	r2, [r3, #20]
    9276:	7d5b      	ldrb	r3, [r3, #21]
    9278:	ea4f 2303 	mov.w	r3, r3, lsl #8
    927c:	ea43 0302 	orr.w	r3, r3, r2
    9280:	b29a      	uxth	r2, r3
    9282:	88e3      	ldrh	r3, [r4, #6]

	/* First check any active connections. */
	for( uip_connr = &uip_conns[ 0 ]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr )
	{
		if
		(
    9284:	429a      	cmp	r2, r3
    9286:	d122      	bne.n	92ce <uip_process+0x85e>
			uip_connr->tcpstateflags != UIP_CLOSED &&
			BUF->destport == uip_connr->lport &&
			BUF->srcport == uip_connr->rport &&
			uip_ipaddr_cmp(&BUF->srcipaddr, &uip_connr->ripaddr)
    9288:	f240 6390 	movw	r3, #1680	; 0x690
    928c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9290:	681b      	ldr	r3, [r3, #0]
    9292:	f103 030e 	add.w	r3, r3, #14
    9296:	7b1a      	ldrb	r2, [r3, #12]
    9298:	7b5b      	ldrb	r3, [r3, #13]
    929a:	ea4f 2303 	mov.w	r3, r3, lsl #8
    929e:	ea43 0302 	orr.w	r3, r3, r2
    92a2:	b29a      	uxth	r2, r3
    92a4:	8823      	ldrh	r3, [r4, #0]

	/* First check any active connections. */
	for( uip_connr = &uip_conns[ 0 ]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr )
	{
		if
		(
    92a6:	429a      	cmp	r2, r3
    92a8:	d111      	bne.n	92ce <uip_process+0x85e>
			uip_connr->tcpstateflags != UIP_CLOSED &&
			BUF->destport == uip_connr->lport &&
			BUF->srcport == uip_connr->rport &&
			uip_ipaddr_cmp(&BUF->srcipaddr, &uip_connr->ripaddr)
    92aa:	f240 6390 	movw	r3, #1680	; 0x690
    92ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    92b2:	681b      	ldr	r3, [r3, #0]
    92b4:	f103 030e 	add.w	r3, r3, #14
    92b8:	7b9a      	ldrb	r2, [r3, #14]
    92ba:	7bdb      	ldrb	r3, [r3, #15]
    92bc:	ea4f 2303 	mov.w	r3, r3, lsl #8
    92c0:	ea43 0302 	orr.w	r3, r3, r2
    92c4:	b29a      	uxth	r2, r3
    92c6:	8863      	ldrh	r3, [r4, #2]

	/* First check any active connections. */
	for( uip_connr = &uip_conns[ 0 ]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr )
	{
		if
		(
    92c8:	429a      	cmp	r2, r3
    92ca:	f000 84ad 	beq.w	9c28 <uip_process+0x11b8>
	}

	/* Demultiplex this segment. */

	/* First check any active connections. */
	for( uip_connr = &uip_conns[ 0 ]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr )
    92ce:	f104 04cc 	add.w	r4, r4, #204	; 0xcc
    92d2:	4b30      	ldr	r3, [pc, #192]	; (9394 <uip_process+0x924>)
    92d4:	429c      	cmp	r4, r3
    92d6:	d9b2      	bls.n	923e <uip_process+0x7ce>

	/* If we didn't find and active connection that expected the packet,
	either this packet is an old duplicate, or this is a SYN packet
	destined for a connection in LISTEN. If the SYN flag isn't set,
	it is an old packet and we send a RST. */
	if( (BUF->flags & TCP_CTL) != TCP_SYN )
    92d8:	f240 6390 	movw	r3, #1680	; 0x690
    92dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    92e0:	681b      	ldr	r3, [r3, #0]
    92e2:	f103 030e 	add.w	r3, r3, #14
    92e6:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    92ea:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    92ee:	2b02      	cmp	r3, #2
    92f0:	d152      	bne.n	9398 <uip_process+0x928>
	{
		goto reset;
	}

	tmp16 = BUF->destport;
    92f2:	f240 6390 	movw	r3, #1680	; 0x690
    92f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    92fa:	681b      	ldr	r3, [r3, #0]
    92fc:	f103 030e 	add.w	r3, r3, #14
    9300:	7d9a      	ldrb	r2, [r3, #22]
    9302:	7ddb      	ldrb	r3, [r3, #23]
    9304:	ea4f 2303 	mov.w	r3, r3, lsl #8
    9308:	ea43 0302 	orr.w	r3, r3, r2
    930c:	b29a      	uxth	r2, r3
    930e:	f642 7378 	movw	r3, #12152	; 0x2f78
    9312:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9316:	801a      	strh	r2, [r3, #0]

	/* Next, check listening connections. */
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    9318:	f642 7376 	movw	r3, #12150	; 0x2f76
    931c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9320:	f04f 0200 	mov.w	r2, #0
    9324:	701a      	strb	r2, [r3, #0]
    9326:	e020      	b.n	936a <uip_process+0x8fa>
	{
		if( tmp16 == uip_listenports[ c ] )
    9328:	f642 7376 	movw	r3, #12150	; 0x2f76
    932c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9330:	781b      	ldrb	r3, [r3, #0]
    9332:	461a      	mov	r2, r3
    9334:	f64c 3350 	movw	r3, #52048	; 0xcb50
    9338:	f2c2 0300 	movt	r3, #8192	; 0x2000
    933c:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
    9340:	f642 7378 	movw	r3, #12152	; 0x2f78
    9344:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9348:	881b      	ldrh	r3, [r3, #0]
    934a:	429a      	cmp	r2, r3
    934c:	f000 8206 	beq.w	975c <uip_process+0xcec>
	}

	tmp16 = BUF->destport;

	/* Next, check listening connections. */
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    9350:	f642 7376 	movw	r3, #12150	; 0x2f76
    9354:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9358:	781b      	ldrb	r3, [r3, #0]
    935a:	f103 0301 	add.w	r3, r3, #1
    935e:	b2da      	uxtb	r2, r3
    9360:	f642 7376 	movw	r3, #12150	; 0x2f76
    9364:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9368:	701a      	strb	r2, [r3, #0]
    936a:	f642 7376 	movw	r3, #12150	; 0x2f76
    936e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9372:	781b      	ldrb	r3, [r3, #0]
    9374:	2b27      	cmp	r3, #39	; 0x27
    9376:	d9d7      	bls.n	9328 <uip_process+0x8b8>
			goto found_listen;
		}
	}

	/* No matching connection found, so we send a RST packet. */
	UIP_STAT( ++uip_stat.tcp.synrst );
    9378:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    937c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9380:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
    9382:	f103 0301 	add.w	r3, r3, #1
    9386:	b29a      	uxth	r2, r3
    9388:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    938c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9390:	85da      	strh	r2, [r3, #46]	; 0x2e
    9392:	e002      	b.n	939a <uip_process+0x92a>
    9394:	2000ca84 	.word	0x2000ca84
	either this packet is an old duplicate, or this is a SYN packet
	destined for a connection in LISTEN. If the SYN flag isn't set,
	it is an old packet and we send a RST. */
	if( (BUF->flags & TCP_CTL) != TCP_SYN )
	{
		goto reset;
    9398:	bf00      	nop
	/* No matching connection found, so we send a RST packet. */
	UIP_STAT( ++uip_stat.tcp.synrst );

reset:
	/* We do not send resets in response to resets. */
	if( BUF->flags & TCP_RST )
    939a:	f240 6390 	movw	r3, #1680	; 0x690
    939e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    93a2:	681b      	ldr	r3, [r3, #0]
    93a4:	f103 030e 	add.w	r3, r3, #14
    93a8:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    93ac:	f003 0304 	and.w	r3, r3, #4
    93b0:	2b00      	cmp	r3, #0
    93b2:	f041 8410 	bne.w	abd6 <uip_process+0x2166>
	{
		goto drop;
	}

	UIP_STAT( ++uip_stat.tcp.rst );
    93b6:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    93ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    93be:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    93c0:	f103 0301 	add.w	r3, r3, #1
    93c4:	b29a      	uxth	r2, r3
    93c6:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    93ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    93ce:	851a      	strh	r2, [r3, #40]	; 0x28

	BUF->flags = TCP_RST | TCP_ACK;
    93d0:	f240 6390 	movw	r3, #1680	; 0x690
    93d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    93d8:	681b      	ldr	r3, [r3, #0]
    93da:	f103 030e 	add.w	r3, r3, #14
    93de:	f04f 0214 	mov.w	r2, #20
    93e2:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
	uip_len = UIP_IPTCPH_LEN;
    93e6:	f64a 3358 	movw	r3, #43864	; 0xab58
    93ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    93ee:	f04f 0228 	mov.w	r2, #40	; 0x28
    93f2:	801a      	strh	r2, [r3, #0]
	BUF->tcpoffset = 5 << 4;
    93f4:	f240 6390 	movw	r3, #1680	; 0x690
    93f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    93fc:	681b      	ldr	r3, [r3, #0]
    93fe:	f103 030e 	add.w	r3, r3, #14
    9402:	f04f 0250 	mov.w	r2, #80	; 0x50
    9406:	f883 2020 	strb.w	r2, [r3, #32]

	/* Flip the seqno and ackno fields in the TCP header. */
	c = BUF->seqno[ 3 ];
    940a:	f240 6390 	movw	r3, #1680	; 0x690
    940e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9412:	681b      	ldr	r3, [r3, #0]
    9414:	f103 030e 	add.w	r3, r3, #14
    9418:	7eda      	ldrb	r2, [r3, #27]
    941a:	f642 7376 	movw	r3, #12150	; 0x2f76
    941e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9422:	701a      	strb	r2, [r3, #0]
	BUF->seqno[ 3 ] = BUF->ackno[ 3 ];
    9424:	f240 6390 	movw	r3, #1680	; 0x690
    9428:	f2c2 0300 	movt	r3, #8192	; 0x2000
    942c:	681b      	ldr	r3, [r3, #0]
    942e:	f103 020e 	add.w	r2, r3, #14
    9432:	f240 6390 	movw	r3, #1680	; 0x690
    9436:	f2c2 0300 	movt	r3, #8192	; 0x2000
    943a:	681b      	ldr	r3, [r3, #0]
    943c:	f103 030e 	add.w	r3, r3, #14
    9440:	7fdb      	ldrb	r3, [r3, #31]
    9442:	76d3      	strb	r3, [r2, #27]
	BUF->ackno[ 3 ] = c;
    9444:	f240 6390 	movw	r3, #1680	; 0x690
    9448:	f2c2 0300 	movt	r3, #8192	; 0x2000
    944c:	681b      	ldr	r3, [r3, #0]
    944e:	f103 020e 	add.w	r2, r3, #14
    9452:	f642 7376 	movw	r3, #12150	; 0x2f76
    9456:	f2c2 0300 	movt	r3, #8192	; 0x2000
    945a:	781b      	ldrb	r3, [r3, #0]
    945c:	77d3      	strb	r3, [r2, #31]

	c = BUF->seqno[ 2 ];
    945e:	f240 6390 	movw	r3, #1680	; 0x690
    9462:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9466:	681b      	ldr	r3, [r3, #0]
    9468:	f103 030e 	add.w	r3, r3, #14
    946c:	7e9a      	ldrb	r2, [r3, #26]
    946e:	f642 7376 	movw	r3, #12150	; 0x2f76
    9472:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9476:	701a      	strb	r2, [r3, #0]
	BUF->seqno[ 2 ] = BUF->ackno[ 2 ];
    9478:	f240 6390 	movw	r3, #1680	; 0x690
    947c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9480:	681b      	ldr	r3, [r3, #0]
    9482:	f103 020e 	add.w	r2, r3, #14
    9486:	f240 6390 	movw	r3, #1680	; 0x690
    948a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    948e:	681b      	ldr	r3, [r3, #0]
    9490:	f103 030e 	add.w	r3, r3, #14
    9494:	7f9b      	ldrb	r3, [r3, #30]
    9496:	7693      	strb	r3, [r2, #26]
	BUF->ackno[ 2 ] = c;
    9498:	f240 6390 	movw	r3, #1680	; 0x690
    949c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    94a0:	681b      	ldr	r3, [r3, #0]
    94a2:	f103 020e 	add.w	r2, r3, #14
    94a6:	f642 7376 	movw	r3, #12150	; 0x2f76
    94aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    94ae:	781b      	ldrb	r3, [r3, #0]
    94b0:	7793      	strb	r3, [r2, #30]

	c = BUF->seqno[ 1 ];
    94b2:	f240 6390 	movw	r3, #1680	; 0x690
    94b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    94ba:	681b      	ldr	r3, [r3, #0]
    94bc:	f103 030e 	add.w	r3, r3, #14
    94c0:	7e5a      	ldrb	r2, [r3, #25]
    94c2:	f642 7376 	movw	r3, #12150	; 0x2f76
    94c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    94ca:	701a      	strb	r2, [r3, #0]
	BUF->seqno[ 1 ] = BUF->ackno[ 1 ];
    94cc:	f240 6390 	movw	r3, #1680	; 0x690
    94d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    94d4:	681b      	ldr	r3, [r3, #0]
    94d6:	f103 020e 	add.w	r2, r3, #14
    94da:	f240 6390 	movw	r3, #1680	; 0x690
    94de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    94e2:	681b      	ldr	r3, [r3, #0]
    94e4:	f103 030e 	add.w	r3, r3, #14
    94e8:	7f5b      	ldrb	r3, [r3, #29]
    94ea:	7653      	strb	r3, [r2, #25]
	BUF->ackno[ 1 ] = c;
    94ec:	f240 6390 	movw	r3, #1680	; 0x690
    94f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    94f4:	681b      	ldr	r3, [r3, #0]
    94f6:	f103 020e 	add.w	r2, r3, #14
    94fa:	f642 7376 	movw	r3, #12150	; 0x2f76
    94fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9502:	781b      	ldrb	r3, [r3, #0]
    9504:	7753      	strb	r3, [r2, #29]

	c = BUF->seqno[ 0 ];
    9506:	f240 6390 	movw	r3, #1680	; 0x690
    950a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    950e:	681b      	ldr	r3, [r3, #0]
    9510:	f103 030e 	add.w	r3, r3, #14
    9514:	7e1a      	ldrb	r2, [r3, #24]
    9516:	f642 7376 	movw	r3, #12150	; 0x2f76
    951a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    951e:	701a      	strb	r2, [r3, #0]
	BUF->seqno[ 0 ] = BUF->ackno[ 0 ];
    9520:	f240 6390 	movw	r3, #1680	; 0x690
    9524:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9528:	681b      	ldr	r3, [r3, #0]
    952a:	f103 020e 	add.w	r2, r3, #14
    952e:	f240 6390 	movw	r3, #1680	; 0x690
    9532:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9536:	681b      	ldr	r3, [r3, #0]
    9538:	f103 030e 	add.w	r3, r3, #14
    953c:	7f1b      	ldrb	r3, [r3, #28]
    953e:	7613      	strb	r3, [r2, #24]
	BUF->ackno[ 0 ] = c;
    9540:	f240 6390 	movw	r3, #1680	; 0x690
    9544:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9548:	681b      	ldr	r3, [r3, #0]
    954a:	f103 020e 	add.w	r2, r3, #14
    954e:	f642 7376 	movw	r3, #12150	; 0x2f76
    9552:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9556:	781b      	ldrb	r3, [r3, #0]
    9558:	7713      	strb	r3, [r2, #28]

	/* We also have to increase the sequence number we are
	acknowledging. If the least significant byte overflowed, we need
	to propagate the carry to the other bytes as well. */
	if( ++BUF->ackno[ 3 ] == 0 )
    955a:	f240 6390 	movw	r3, #1680	; 0x690
    955e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9562:	681b      	ldr	r3, [r3, #0]
    9564:	f103 030e 	add.w	r3, r3, #14
    9568:	7fda      	ldrb	r2, [r3, #31]
    956a:	f102 0201 	add.w	r2, r2, #1
    956e:	b2d2      	uxtb	r2, r2
    9570:	77da      	strb	r2, [r3, #31]
    9572:	7fdb      	ldrb	r3, [r3, #31]
    9574:	2b00      	cmp	r3, #0
    9576:	d129      	bne.n	95cc <uip_process+0xb5c>
	{
		if( ++BUF->ackno[ 2 ] == 0 )
    9578:	f240 6390 	movw	r3, #1680	; 0x690
    957c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9580:	681b      	ldr	r3, [r3, #0]
    9582:	f103 030e 	add.w	r3, r3, #14
    9586:	7f9a      	ldrb	r2, [r3, #30]
    9588:	f102 0201 	add.w	r2, r2, #1
    958c:	b2d2      	uxtb	r2, r2
    958e:	779a      	strb	r2, [r3, #30]
    9590:	7f9b      	ldrb	r3, [r3, #30]
    9592:	2b00      	cmp	r3, #0
    9594:	d11a      	bne.n	95cc <uip_process+0xb5c>
		{
			if( ++BUF->ackno[ 1 ] == 0 )
    9596:	f240 6390 	movw	r3, #1680	; 0x690
    959a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    959e:	681b      	ldr	r3, [r3, #0]
    95a0:	f103 030e 	add.w	r3, r3, #14
    95a4:	7f5a      	ldrb	r2, [r3, #29]
    95a6:	f102 0201 	add.w	r2, r2, #1
    95aa:	b2d2      	uxtb	r2, r2
    95ac:	775a      	strb	r2, [r3, #29]
    95ae:	7f5b      	ldrb	r3, [r3, #29]
    95b0:	2b00      	cmp	r3, #0
    95b2:	d10b      	bne.n	95cc <uip_process+0xb5c>
			{
				++BUF->ackno[ 0 ];
    95b4:	f240 6390 	movw	r3, #1680	; 0x690
    95b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    95bc:	681b      	ldr	r3, [r3, #0]
    95be:	f103 030e 	add.w	r3, r3, #14
    95c2:	7f1a      	ldrb	r2, [r3, #28]
    95c4:	f102 0201 	add.w	r2, r2, #1
    95c8:	b2d2      	uxtb	r2, r2
    95ca:	771a      	strb	r2, [r3, #28]
			}
		}
	}

	/* Swap port numbers. */
	tmp16 = BUF->srcport;
    95cc:	f240 6390 	movw	r3, #1680	; 0x690
    95d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    95d4:	681b      	ldr	r3, [r3, #0]
    95d6:	f103 030e 	add.w	r3, r3, #14
    95da:	7d1a      	ldrb	r2, [r3, #20]
    95dc:	7d5b      	ldrb	r3, [r3, #21]
    95de:	ea4f 2303 	mov.w	r3, r3, lsl #8
    95e2:	ea43 0302 	orr.w	r3, r3, r2
    95e6:	b29a      	uxth	r2, r3
    95e8:	f642 7378 	movw	r3, #12152	; 0x2f78
    95ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    95f0:	801a      	strh	r2, [r3, #0]
	BUF->srcport = BUF->destport;
    95f2:	f240 6390 	movw	r3, #1680	; 0x690
    95f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    95fa:	681b      	ldr	r3, [r3, #0]
    95fc:	f103 020e 	add.w	r2, r3, #14
    9600:	f240 6390 	movw	r3, #1680	; 0x690
    9604:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9608:	681b      	ldr	r3, [r3, #0]
    960a:	f103 030e 	add.w	r3, r3, #14
    960e:	7d99      	ldrb	r1, [r3, #22]
    9610:	7ddb      	ldrb	r3, [r3, #23]
    9612:	ea4f 2303 	mov.w	r3, r3, lsl #8
    9616:	ea43 0301 	orr.w	r3, r3, r1
    961a:	b29b      	uxth	r3, r3
    961c:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    9620:	f04f 0000 	mov.w	r0, #0
    9624:	ea40 0101 	orr.w	r1, r0, r1
    9628:	7511      	strb	r1, [r2, #20]
    962a:	ea4f 2313 	mov.w	r3, r3, lsr #8
    962e:	b29b      	uxth	r3, r3
    9630:	f04f 0100 	mov.w	r1, #0
    9634:	ea41 0303 	orr.w	r3, r1, r3
    9638:	7553      	strb	r3, [r2, #21]
	BUF->destport = tmp16;
    963a:	f240 6390 	movw	r3, #1680	; 0x690
    963e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9642:	681b      	ldr	r3, [r3, #0]
    9644:	f103 020e 	add.w	r2, r3, #14
    9648:	f642 7378 	movw	r3, #12152	; 0x2f78
    964c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9650:	881b      	ldrh	r3, [r3, #0]
    9652:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    9656:	f04f 0000 	mov.w	r0, #0
    965a:	ea40 0101 	orr.w	r1, r0, r1
    965e:	7591      	strb	r1, [r2, #22]
    9660:	ea4f 2313 	mov.w	r3, r3, lsr #8
    9664:	b29b      	uxth	r3, r3
    9666:	f04f 0100 	mov.w	r1, #0
    966a:	ea41 0303 	orr.w	r3, r1, r3
    966e:	75d3      	strb	r3, [r2, #23]

	/* Swap IP addresses. */
	uip_ipaddr_copy( &BUF->destipaddr, &BUF->srcipaddr );
    9670:	f240 6390 	movw	r3, #1680	; 0x690
    9674:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9678:	681b      	ldr	r3, [r3, #0]
    967a:	f103 020e 	add.w	r2, r3, #14
    967e:	f240 6390 	movw	r3, #1680	; 0x690
    9682:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9686:	681b      	ldr	r3, [r3, #0]
    9688:	f103 030e 	add.w	r3, r3, #14
    968c:	7b1b      	ldrb	r3, [r3, #12]
    968e:	7413      	strb	r3, [r2, #16]
    9690:	f240 6390 	movw	r3, #1680	; 0x690
    9694:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9698:	681b      	ldr	r3, [r3, #0]
    969a:	f103 020e 	add.w	r2, r3, #14
    969e:	f240 6390 	movw	r3, #1680	; 0x690
    96a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    96a6:	681b      	ldr	r3, [r3, #0]
    96a8:	f103 030e 	add.w	r3, r3, #14
    96ac:	7b5b      	ldrb	r3, [r3, #13]
    96ae:	7453      	strb	r3, [r2, #17]
    96b0:	f240 6390 	movw	r3, #1680	; 0x690
    96b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    96b8:	681b      	ldr	r3, [r3, #0]
    96ba:	f103 020e 	add.w	r2, r3, #14
    96be:	f240 6390 	movw	r3, #1680	; 0x690
    96c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    96c6:	681b      	ldr	r3, [r3, #0]
    96c8:	f103 030e 	add.w	r3, r3, #14
    96cc:	7b9b      	ldrb	r3, [r3, #14]
    96ce:	7493      	strb	r3, [r2, #18]
    96d0:	f240 6390 	movw	r3, #1680	; 0x690
    96d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    96d8:	681b      	ldr	r3, [r3, #0]
    96da:	f103 020e 	add.w	r2, r3, #14
    96de:	f240 6390 	movw	r3, #1680	; 0x690
    96e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    96e6:	681b      	ldr	r3, [r3, #0]
    96e8:	f103 030e 	add.w	r3, r3, #14
    96ec:	7bdb      	ldrb	r3, [r3, #15]
    96ee:	74d3      	strb	r3, [r2, #19]
	uip_ipaddr_copy( &BUF->srcipaddr, &uip_hostaddr );
    96f0:	f240 6390 	movw	r3, #1680	; 0x690
    96f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    96f8:	681b      	ldr	r3, [r3, #0]
    96fa:	f103 020e 	add.w	r2, r3, #14
    96fe:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    9702:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9706:	781b      	ldrb	r3, [r3, #0]
    9708:	7313      	strb	r3, [r2, #12]
    970a:	f240 6390 	movw	r3, #1680	; 0x690
    970e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9712:	681b      	ldr	r3, [r3, #0]
    9714:	f103 020e 	add.w	r2, r3, #14
    9718:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    971c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9720:	785b      	ldrb	r3, [r3, #1]
    9722:	7353      	strb	r3, [r2, #13]
    9724:	f240 6390 	movw	r3, #1680	; 0x690
    9728:	f2c2 0300 	movt	r3, #8192	; 0x2000
    972c:	681b      	ldr	r3, [r3, #0]
    972e:	f103 020e 	add.w	r2, r3, #14
    9732:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    9736:	f2c2 0300 	movt	r3, #8192	; 0x2000
    973a:	789b      	ldrb	r3, [r3, #2]
    973c:	7393      	strb	r3, [r2, #14]
    973e:	f240 6390 	movw	r3, #1680	; 0x690
    9742:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9746:	681b      	ldr	r3, [r3, #0]
    9748:	f103 020e 	add.w	r2, r3, #14
    974c:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    9750:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9754:	78db      	ldrb	r3, [r3, #3]
    9756:	73d3      	strb	r3, [r2, #15]

	/* And send out the RST packet! */
	goto tcp_send_noconn;
    9758:	f001 b925 	b.w	a9a6 <uip_process+0x1f36>
	/* Next, check listening connections. */
	for( c = 0; c < UIP_LISTENPORTS; ++c )
	{
		if( tmp16 == uip_listenports[ c ] )
		{
			goto found_listen;
    975c:	bf00      	nop
	connections are kept in the same table as used connections, but
	unused ones have the tcpstate set to CLOSED. Also, connections in
	TIME_WAIT are kept track of and we'll use the oldest one if no
	CLOSED connections are found. Thanks to Eddie C. Dost for a very
	nice algorithm for the TIME_WAIT search. */
	uip_connr = 0;
    975e:	f04f 0400 	mov.w	r4, #0
	for( c = 0; c < UIP_CONNS; ++c )
    9762:	f642 7376 	movw	r3, #12150	; 0x2f76
    9766:	f2c2 0300 	movt	r3, #8192	; 0x2000
    976a:	f04f 0200 	mov.w	r2, #0
    976e:	701a      	strb	r2, [r3, #0]
    9770:	e06a      	b.n	9848 <uip_process+0xdd8>
	{
		if( uip_conns[ c ].tcpstateflags == UIP_CLOSED )
    9772:	f642 7376 	movw	r3, #12150	; 0x2f76
    9776:	f2c2 0300 	movt	r3, #8192	; 0x2000
    977a:	781b      	ldrb	r3, [r3, #0]
    977c:	461a      	mov	r2, r3
    977e:	f64a 3370 	movw	r3, #43888	; 0xab70
    9782:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9786:	f04f 01cc 	mov.w	r1, #204	; 0xcc
    978a:	fb01 f202 	mul.w	r2, r1, r2
    978e:	4413      	add	r3, r2
    9790:	f103 0318 	add.w	r3, r3, #24
    9794:	785b      	ldrb	r3, [r3, #1]
    9796:	2b00      	cmp	r3, #0
    9798:	d10f      	bne.n	97ba <uip_process+0xd4a>
		{
			uip_connr = &uip_conns[ c ];
    979a:	f642 7376 	movw	r3, #12150	; 0x2f76
    979e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    97a2:	781b      	ldrb	r3, [r3, #0]
    97a4:	f04f 02cc 	mov.w	r2, #204	; 0xcc
    97a8:	fb02 f203 	mul.w	r2, r2, r3
    97ac:	f64a 3370 	movw	r3, #43888	; 0xab70
    97b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    97b4:	eb02 0403 	add.w	r4, r2, r3
			break;
    97b8:	e04d      	b.n	9856 <uip_process+0xde6>
		}

		if( uip_conns[ c ].tcpstateflags == UIP_TIME_WAIT )
    97ba:	f642 7376 	movw	r3, #12150	; 0x2f76
    97be:	f2c2 0300 	movt	r3, #8192	; 0x2000
    97c2:	781b      	ldrb	r3, [r3, #0]
    97c4:	461a      	mov	r2, r3
    97c6:	f64a 3370 	movw	r3, #43888	; 0xab70
    97ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    97ce:	f04f 01cc 	mov.w	r1, #204	; 0xcc
    97d2:	fb01 f202 	mul.w	r2, r1, r2
    97d6:	4413      	add	r3, r2
    97d8:	f103 0318 	add.w	r3, r3, #24
    97dc:	785b      	ldrb	r3, [r3, #1]
    97de:	2b07      	cmp	r3, #7
    97e0:	d125      	bne.n	982e <uip_process+0xdbe>
		{
			if( uip_connr == 0 || uip_conns[ c ].timer > uip_connr->timer )
    97e2:	2c00      	cmp	r4, #0
    97e4:	d014      	beq.n	9810 <uip_process+0xda0>
    97e6:	f642 7376 	movw	r3, #12150	; 0x2f76
    97ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    97ee:	781b      	ldrb	r3, [r3, #0]
    97f0:	461a      	mov	r2, r3
    97f2:	f64a 3370 	movw	r3, #43888	; 0xab70
    97f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    97fa:	f04f 01cc 	mov.w	r1, #204	; 0xcc
    97fe:	fb01 f202 	mul.w	r2, r1, r2
    9802:	4413      	add	r3, r2
    9804:	f103 0318 	add.w	r3, r3, #24
    9808:	789a      	ldrb	r2, [r3, #2]
    980a:	7ea3      	ldrb	r3, [r4, #26]
    980c:	429a      	cmp	r2, r3
    980e:	d90e      	bls.n	982e <uip_process+0xdbe>
			{
				uip_connr = &uip_conns[ c ];
    9810:	f642 7376 	movw	r3, #12150	; 0x2f76
    9814:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9818:	781b      	ldrb	r3, [r3, #0]
    981a:	f04f 02cc 	mov.w	r2, #204	; 0xcc
    981e:	fb02 f203 	mul.w	r2, r2, r3
    9822:	f64a 3370 	movw	r3, #43888	; 0xab70
    9826:	f2c2 0300 	movt	r3, #8192	; 0x2000
    982a:	eb02 0403 	add.w	r4, r2, r3
	unused ones have the tcpstate set to CLOSED. Also, connections in
	TIME_WAIT are kept track of and we'll use the oldest one if no
	CLOSED connections are found. Thanks to Eddie C. Dost for a very
	nice algorithm for the TIME_WAIT search. */
	uip_connr = 0;
	for( c = 0; c < UIP_CONNS; ++c )
    982e:	f642 7376 	movw	r3, #12150	; 0x2f76
    9832:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9836:	781b      	ldrb	r3, [r3, #0]
    9838:	f103 0301 	add.w	r3, r3, #1
    983c:	b2da      	uxtb	r2, r3
    983e:	f642 7376 	movw	r3, #12150	; 0x2f76
    9842:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9846:	701a      	strb	r2, [r3, #0]
    9848:	f642 7376 	movw	r3, #12150	; 0x2f76
    984c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9850:	781b      	ldrb	r3, [r3, #0]
    9852:	2b27      	cmp	r3, #39	; 0x27
    9854:	d98d      	bls.n	9772 <uip_process+0xd02>
				uip_connr = &uip_conns[ c ];
			}
		}
	}

	if( uip_connr == 0 )
    9856:	2c00      	cmp	r4, #0
    9858:	d10e      	bne.n	9878 <uip_process+0xe08>
	{
		/* All connections are used already, we drop packet and hope that
		the remote end will retransmit the packet at a time when we
		have more spare connections. */
		UIP_STAT( ++uip_stat.tcp.syndrop );
    985a:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    985e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9862:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
    9864:	f103 0301 	add.w	r3, r3, #1
    9868:	b29a      	uxth	r2, r3
    986a:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    986e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9872:	859a      	strh	r2, [r3, #44]	; 0x2c
		UIP_LOG( "tcp: found no unused connections." );
		goto drop;
    9874:	f001 b9c0 	b.w	abf8 <uip_process+0x2188>
	}

	uip_conn = uip_connr;
    9878:	f64a 336c 	movw	r3, #43884	; 0xab6c
    987c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9880:	601c      	str	r4, [r3, #0]

	/* Fill in the necessary fields for the new connection. */
	uip_connr->rto = uip_connr->timer = UIP_RTO;
    9882:	f04f 0303 	mov.w	r3, #3
    9886:	76a3      	strb	r3, [r4, #26]
    9888:	7ea3      	ldrb	r3, [r4, #26]
    988a:	7623      	strb	r3, [r4, #24]
	uip_connr->sa = 0;
    988c:	f04f 0300 	mov.w	r3, #0
    9890:	75a3      	strb	r3, [r4, #22]
	uip_connr->sv = 4;
    9892:	f04f 0304 	mov.w	r3, #4
    9896:	75e3      	strb	r3, [r4, #23]
	uip_connr->nrtx = 0;
    9898:	f04f 0300 	mov.w	r3, #0
    989c:	76e3      	strb	r3, [r4, #27]
	uip_connr->lport = BUF->destport;
    989e:	f240 6390 	movw	r3, #1680	; 0x690
    98a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    98a6:	681b      	ldr	r3, [r3, #0]
    98a8:	f103 030e 	add.w	r3, r3, #14
    98ac:	7d9a      	ldrb	r2, [r3, #22]
    98ae:	7ddb      	ldrb	r3, [r3, #23]
    98b0:	ea4f 2303 	mov.w	r3, r3, lsl #8
    98b4:	ea43 0302 	orr.w	r3, r3, r2
    98b8:	b29b      	uxth	r3, r3
    98ba:	80a3      	strh	r3, [r4, #4]
	uip_connr->rport = BUF->srcport;
    98bc:	f240 6390 	movw	r3, #1680	; 0x690
    98c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    98c4:	681b      	ldr	r3, [r3, #0]
    98c6:	f103 030e 	add.w	r3, r3, #14
    98ca:	7d1a      	ldrb	r2, [r3, #20]
    98cc:	7d5b      	ldrb	r3, [r3, #21]
    98ce:	ea4f 2303 	mov.w	r3, r3, lsl #8
    98d2:	ea43 0302 	orr.w	r3, r3, r2
    98d6:	b29b      	uxth	r3, r3
    98d8:	80e3      	strh	r3, [r4, #6]
	uip_ipaddr_copy( &uip_connr->ripaddr, &BUF->srcipaddr );
    98da:	f240 6390 	movw	r3, #1680	; 0x690
    98de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    98e2:	681b      	ldr	r3, [r3, #0]
    98e4:	f103 030e 	add.w	r3, r3, #14
    98e8:	7b1b      	ldrb	r3, [r3, #12]
    98ea:	7023      	strb	r3, [r4, #0]
    98ec:	f240 6390 	movw	r3, #1680	; 0x690
    98f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    98f4:	681b      	ldr	r3, [r3, #0]
    98f6:	f103 030e 	add.w	r3, r3, #14
    98fa:	7b5b      	ldrb	r3, [r3, #13]
    98fc:	7063      	strb	r3, [r4, #1]
    98fe:	f240 6390 	movw	r3, #1680	; 0x690
    9902:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9906:	681b      	ldr	r3, [r3, #0]
    9908:	f103 030e 	add.w	r3, r3, #14
    990c:	7b9b      	ldrb	r3, [r3, #14]
    990e:	70a3      	strb	r3, [r4, #2]
    9910:	f240 6390 	movw	r3, #1680	; 0x690
    9914:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9918:	681b      	ldr	r3, [r3, #0]
    991a:	f103 030e 	add.w	r3, r3, #14
    991e:	7bdb      	ldrb	r3, [r3, #15]
    9920:	70e3      	strb	r3, [r4, #3]
	uip_connr->tcpstateflags = UIP_SYN_RCVD;
    9922:	f04f 0301 	mov.w	r3, #1
    9926:	7663      	strb	r3, [r4, #25]

	uip_connr->snd_nxt[ 0 ] = iss[ 0 ];
    9928:	f642 7370 	movw	r3, #12144	; 0x2f70
    992c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9930:	781b      	ldrb	r3, [r3, #0]
    9932:	7323      	strb	r3, [r4, #12]
	uip_connr->snd_nxt[ 1 ] = iss[ 1 ];
    9934:	f642 7370 	movw	r3, #12144	; 0x2f70
    9938:	f2c2 0300 	movt	r3, #8192	; 0x2000
    993c:	785b      	ldrb	r3, [r3, #1]
    993e:	7363      	strb	r3, [r4, #13]
	uip_connr->snd_nxt[ 2 ] = iss[ 2 ];
    9940:	f642 7370 	movw	r3, #12144	; 0x2f70
    9944:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9948:	789b      	ldrb	r3, [r3, #2]
    994a:	73a3      	strb	r3, [r4, #14]
	uip_connr->snd_nxt[ 3 ] = iss[ 3 ];
    994c:	f642 7370 	movw	r3, #12144	; 0x2f70
    9950:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9954:	78db      	ldrb	r3, [r3, #3]
    9956:	73e3      	strb	r3, [r4, #15]
	uip_connr->len = 1;
    9958:	f04f 0301 	mov.w	r3, #1
    995c:	8223      	strh	r3, [r4, #16]

	/* rcv_nxt should be the seqno from the incoming packet + 1. */
	uip_connr->rcv_nxt[ 3 ] = BUF->seqno[ 3 ];
    995e:	f240 6390 	movw	r3, #1680	; 0x690
    9962:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9966:	681b      	ldr	r3, [r3, #0]
    9968:	f103 030e 	add.w	r3, r3, #14
    996c:	7edb      	ldrb	r3, [r3, #27]
    996e:	72e3      	strb	r3, [r4, #11]
	uip_connr->rcv_nxt[ 2 ] = BUF->seqno[ 2 ];
    9970:	f240 6390 	movw	r3, #1680	; 0x690
    9974:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9978:	681b      	ldr	r3, [r3, #0]
    997a:	f103 030e 	add.w	r3, r3, #14
    997e:	7e9b      	ldrb	r3, [r3, #26]
    9980:	72a3      	strb	r3, [r4, #10]
	uip_connr->rcv_nxt[ 1 ] = BUF->seqno[ 1 ];
    9982:	f240 6390 	movw	r3, #1680	; 0x690
    9986:	f2c2 0300 	movt	r3, #8192	; 0x2000
    998a:	681b      	ldr	r3, [r3, #0]
    998c:	f103 030e 	add.w	r3, r3, #14
    9990:	7e5b      	ldrb	r3, [r3, #25]
    9992:	7263      	strb	r3, [r4, #9]
	uip_connr->rcv_nxt[ 0 ] = BUF->seqno[ 0 ];
    9994:	f240 6390 	movw	r3, #1680	; 0x690
    9998:	f2c2 0300 	movt	r3, #8192	; 0x2000
    999c:	681b      	ldr	r3, [r3, #0]
    999e:	f103 030e 	add.w	r3, r3, #14
    99a2:	7e1b      	ldrb	r3, [r3, #24]
    99a4:	7223      	strb	r3, [r4, #8]
	uip_add_rcv_nxt( 1 );
    99a6:	f04f 0001 	mov.w	r0, #1
    99aa:	f7ff f81f 	bl	89ec <uip_add_rcv_nxt>

	/* Parse the TCP MSS option, if present. */
	if( (BUF->tcpoffset & 0xf0) > 0x50 )
    99ae:	f240 6390 	movw	r3, #1680	; 0x690
    99b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    99b6:	681b      	ldr	r3, [r3, #0]
    99b8:	f103 030e 	add.w	r3, r3, #14
    99bc:	f893 3020 	ldrb.w	r3, [r3, #32]
    99c0:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    99c4:	2b50      	cmp	r3, #80	; 0x50
    99c6:	f340 80cf 	ble.w	9b68 <uip_process+0x10f8>
	{
		for( c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2; )
    99ca:	f642 7376 	movw	r3, #12150	; 0x2f76
    99ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    99d2:	f04f 0200 	mov.w	r2, #0
    99d6:	701a      	strb	r2, [r3, #0]
    99d8:	e0a7      	b.n	9b2a <uip_process+0x10ba>
		{
			opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
    99da:	f240 6390 	movw	r3, #1680	; 0x690
    99de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    99e2:	681a      	ldr	r2, [r3, #0]
    99e4:	f642 7376 	movw	r3, #12150	; 0x2f76
    99e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    99ec:	781b      	ldrb	r3, [r3, #0]
    99ee:	f103 0336 	add.w	r3, r3, #54	; 0x36
    99f2:	4413      	add	r3, r2
    99f4:	781a      	ldrb	r2, [r3, #0]
    99f6:	f642 7377 	movw	r3, #12151	; 0x2f77
    99fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    99fe:	701a      	strb	r2, [r3, #0]
			if( opt == TCP_OPT_END )
    9a00:	f642 7377 	movw	r3, #12151	; 0x2f77
    9a04:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9a08:	781b      	ldrb	r3, [r3, #0]
    9a0a:	2b00      	cmp	r3, #0
    9a0c:	f000 80a9 	beq.w	9b62 <uip_process+0x10f2>
			{
				/* End of options. */
				break;
			}
			else if( opt == TCP_OPT_NOOP )
    9a10:	f642 7377 	movw	r3, #12151	; 0x2f77
    9a14:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9a18:	781b      	ldrb	r3, [r3, #0]
    9a1a:	2b01      	cmp	r3, #1
    9a1c:	d10d      	bne.n	9a3a <uip_process+0xfca>
			{
				++c;
    9a1e:	f642 7376 	movw	r3, #12150	; 0x2f76
    9a22:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9a26:	781b      	ldrb	r3, [r3, #0]
    9a28:	f103 0301 	add.w	r3, r3, #1
    9a2c:	b2da      	uxtb	r2, r3
    9a2e:	f642 7376 	movw	r3, #12150	; 0x2f76
    9a32:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9a36:	701a      	strb	r2, [r3, #0]
    9a38:	e077      	b.n	9b2a <uip_process+0x10ba>

				/* NOP option. */
			}
			else if( opt == TCP_OPT_MSS && uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN )
    9a3a:	f642 7377 	movw	r3, #12151	; 0x2f77
    9a3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9a42:	781b      	ldrb	r3, [r3, #0]
    9a44:	2b02      	cmp	r3, #2
    9a46:	d146      	bne.n	9ad6 <uip_process+0x1066>
    9a48:	f240 6390 	movw	r3, #1680	; 0x690
    9a4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9a50:	681a      	ldr	r2, [r3, #0]
    9a52:	f642 7376 	movw	r3, #12150	; 0x2f76
    9a56:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9a5a:	781b      	ldrb	r3, [r3, #0]
    9a5c:	f103 0337 	add.w	r3, r3, #55	; 0x37
    9a60:	4413      	add	r3, r2
    9a62:	781b      	ldrb	r3, [r3, #0]
    9a64:	2b04      	cmp	r3, #4
    9a66:	d136      	bne.n	9ad6 <uip_process+0x1066>
			{
				/* An MSS option with the right option length. */
				tmp16 = ( (u16_t) uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8 ) | ( u16_t ) uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
    9a68:	f240 6390 	movw	r3, #1680	; 0x690
    9a6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9a70:	681a      	ldr	r2, [r3, #0]
    9a72:	f642 7376 	movw	r3, #12150	; 0x2f76
    9a76:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9a7a:	781b      	ldrb	r3, [r3, #0]
    9a7c:	f103 0338 	add.w	r3, r3, #56	; 0x38
    9a80:	4413      	add	r3, r2
    9a82:	781b      	ldrb	r3, [r3, #0]
    9a84:	ea4f 2303 	mov.w	r3, r3, lsl #8
    9a88:	b29a      	uxth	r2, r3
    9a8a:	f240 6390 	movw	r3, #1680	; 0x690
    9a8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9a92:	6819      	ldr	r1, [r3, #0]
    9a94:	f642 7376 	movw	r3, #12150	; 0x2f76
    9a98:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9a9c:	781b      	ldrb	r3, [r3, #0]
    9a9e:	f103 0339 	add.w	r3, r3, #57	; 0x39
    9aa2:	440b      	add	r3, r1
    9aa4:	781b      	ldrb	r3, [r3, #0]
    9aa6:	ea42 0303 	orr.w	r3, r2, r3
    9aaa:	b29b      	uxth	r3, r3
    9aac:	b29a      	uxth	r2, r3
    9aae:	f642 7378 	movw	r3, #12152	; 0x2f78
    9ab2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9ab6:	801a      	strh	r2, [r3, #0]
				uip_connr->initialmss = uip_connr->mss = tmp16 > UIP_TCP_MSS ? UIP_TCP_MSS : tmp16;
    9ab8:	f642 7378 	movw	r3, #12152	; 0x2f78
    9abc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9ac0:	881a      	ldrh	r2, [r3, #0]
    9ac2:	f240 5392 	movw	r3, #1426	; 0x592
    9ac6:	429a      	cmp	r2, r3
    9ac8:	bf38      	it	cc
    9aca:	4613      	movcc	r3, r2
    9acc:	b29b      	uxth	r3, r3
    9ace:	8263      	strh	r3, [r4, #18]
    9ad0:	8a63      	ldrh	r3, [r4, #18]
    9ad2:	82a3      	strh	r3, [r4, #20]

				/* And we are done processing options. */
				break;
    9ad4:	e048      	b.n	9b68 <uip_process+0x10f8>
			}
			else
			{
				/* All other options have a length field, so that we easily
				can skip past them. */
				if( uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0 )
    9ad6:	f240 6390 	movw	r3, #1680	; 0x690
    9ada:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9ade:	681a      	ldr	r2, [r3, #0]
    9ae0:	f642 7376 	movw	r3, #12150	; 0x2f76
    9ae4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9ae8:	781b      	ldrb	r3, [r3, #0]
    9aea:	f103 0337 	add.w	r3, r3, #55	; 0x37
    9aee:	4413      	add	r3, r2
    9af0:	781b      	ldrb	r3, [r3, #0]
    9af2:	2b00      	cmp	r3, #0
    9af4:	d037      	beq.n	9b66 <uip_process+0x10f6>
					/* If the length field is zero, the options are malformed
					and we don't process them further. */
					break;
				}

				c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    9af6:	f240 6390 	movw	r3, #1680	; 0x690
    9afa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9afe:	681a      	ldr	r2, [r3, #0]
    9b00:	f642 7376 	movw	r3, #12150	; 0x2f76
    9b04:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9b08:	781b      	ldrb	r3, [r3, #0]
    9b0a:	f103 0337 	add.w	r3, r3, #55	; 0x37
    9b0e:	4413      	add	r3, r2
    9b10:	781a      	ldrb	r2, [r3, #0]
    9b12:	f642 7376 	movw	r3, #12150	; 0x2f76
    9b16:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9b1a:	781b      	ldrb	r3, [r3, #0]
    9b1c:	4413      	add	r3, r2
    9b1e:	b2da      	uxtb	r2, r3
    9b20:	f642 7376 	movw	r3, #12150	; 0x2f76
    9b24:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9b28:	701a      	strb	r2, [r3, #0]
	uip_add_rcv_nxt( 1 );

	/* Parse the TCP MSS option, if present. */
	if( (BUF->tcpoffset & 0xf0) > 0x50 )
	{
		for( c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2; )
    9b2a:	f642 7376 	movw	r3, #12150	; 0x2f76
    9b2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9b32:	781b      	ldrb	r3, [r3, #0]
    9b34:	461a      	mov	r2, r3
    9b36:	f240 6390 	movw	r3, #1680	; 0x690
    9b3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9b3e:	681b      	ldr	r3, [r3, #0]
    9b40:	f103 030e 	add.w	r3, r3, #14
    9b44:	f893 3020 	ldrb.w	r3, [r3, #32]
    9b48:	ea4f 1313 	mov.w	r3, r3, lsr #4
    9b4c:	b2db      	uxtb	r3, r3
    9b4e:	f1a3 0305 	sub.w	r3, r3, #5
    9b52:	ea4f 0383 	mov.w	r3, r3, lsl #2
    9b56:	429a      	cmp	r2, r3
    9b58:	f6ff af3f 	blt.w	99da <uip_process+0xf6a>
    9b5c:	e004      	b.n	9b68 <uip_process+0x10f8>
					switch( uip_connr->tcpstateflags & UIP_TS_MASK )
					{
						case UIP_SYN_RCVD:
							/* In the SYN_RCVD state, we should retransmit our
			   				SYNACK. */
							goto tcp_send_synack;
    9b5e:	bf00      	nop
    9b60:	e002      	b.n	9b68 <uip_process+0x10f8>
		{
			opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
			if( opt == TCP_OPT_END )
			{
				/* End of options. */
				break;
    9b62:	bf00      	nop
    9b64:	e000      	b.n	9b68 <uip_process+0x10f8>
				can skip past them. */
				if( uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0 )
				{
					/* If the length field is zero, the options are malformed
					and we don't process them further. */
					break;
    9b66:	bf00      	nop
		}
	}

	/* Our response will be a SYNACK. */
	#if UIP_ACTIVE_OPEN
		tcp_send_synack : BUF->flags = TCP_ACK;
    9b68:	f240 6390 	movw	r3, #1680	; 0x690
    9b6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9b70:	681b      	ldr	r3, [r3, #0]
    9b72:	f103 030e 	add.w	r3, r3, #14
    9b76:	f04f 0210 	mov.w	r2, #16
    9b7a:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
tcp_send_syn:
		BUF->flags |= TCP_SYN;
    9b7e:	f240 6390 	movw	r3, #1680	; 0x690
    9b82:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9b86:	681b      	ldr	r3, [r3, #0]
    9b88:	f103 020e 	add.w	r2, r3, #14
    9b8c:	f240 6390 	movw	r3, #1680	; 0x690
    9b90:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9b94:	681b      	ldr	r3, [r3, #0]
    9b96:	f103 030e 	add.w	r3, r3, #14
    9b9a:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    9b9e:	f043 0302 	orr.w	r3, r3, #2
    9ba2:	b2db      	uxtb	r3, r3
    9ba4:	f882 3021 	strb.w	r3, [r2, #33]	; 0x21
		tcp_send_synack : BUF->flags = TCP_SYN | TCP_ACK;
	#endif /* UIP_ACTIVE_OPEN */

	/* We send out the TCP Maximum Segment Size option with our
	SYNACK. */
	BUF->optdata[ 0 ] = TCP_OPT_MSS;
    9ba8:	f240 6390 	movw	r3, #1680	; 0x690
    9bac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9bb0:	681b      	ldr	r3, [r3, #0]
    9bb2:	f103 030e 	add.w	r3, r3, #14
    9bb6:	f04f 0202 	mov.w	r2, #2
    9bba:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
	BUF->optdata[ 1 ] = TCP_OPT_MSS_LEN;
    9bbe:	f240 6390 	movw	r3, #1680	; 0x690
    9bc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9bc6:	681b      	ldr	r3, [r3, #0]
    9bc8:	f103 030e 	add.w	r3, r3, #14
    9bcc:	f04f 0204 	mov.w	r2, #4
    9bd0:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
	BUF->optdata[ 2 ] = ( UIP_TCP_MSS ) / 256;
    9bd4:	f240 6390 	movw	r3, #1680	; 0x690
    9bd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9bdc:	681b      	ldr	r3, [r3, #0]
    9bde:	f103 030e 	add.w	r3, r3, #14
    9be2:	f04f 0205 	mov.w	r2, #5
    9be6:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
	BUF->optdata[ 3 ] = ( UIP_TCP_MSS ) & 255;
    9bea:	f240 6390 	movw	r3, #1680	; 0x690
    9bee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9bf2:	681b      	ldr	r3, [r3, #0]
    9bf4:	f103 030e 	add.w	r3, r3, #14
    9bf8:	f06f 026d 	mvn.w	r2, #109	; 0x6d
    9bfc:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
	uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
    9c00:	f64a 3358 	movw	r3, #43864	; 0xab58
    9c04:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9c08:	f04f 022c 	mov.w	r2, #44	; 0x2c
    9c0c:	801a      	strh	r2, [r3, #0]
	BUF->tcpoffset = ( (UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4 ) << 4;
    9c0e:	f240 6390 	movw	r3, #1680	; 0x690
    9c12:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9c16:	681b      	ldr	r3, [r3, #0]
    9c18:	f103 030e 	add.w	r3, r3, #14
    9c1c:	f04f 0260 	mov.w	r2, #96	; 0x60
    9c20:	f883 2020 	strb.w	r2, [r3, #32]
	goto tcp_send;
    9c24:	f000 bdb5 	b.w	a792 <uip_process+0x1d22>
			BUF->destport == uip_connr->lport &&
			BUF->srcport == uip_connr->rport &&
			uip_ipaddr_cmp(&BUF->srcipaddr, &uip_connr->ripaddr)
		)
		{
			goto found;
    9c28:	bf00      	nop
	BUF->tcpoffset = ( (UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4 ) << 4;
	goto tcp_send;

	/* This label will be jumped to if we found an active connection. */
found:
	uip_conn = uip_connr;
    9c2a:	f64a 336c 	movw	r3, #43884	; 0xab6c
    9c2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9c32:	601c      	str	r4, [r3, #0]
	uip_flags = 0;
    9c34:	f64a 3364 	movw	r3, #43876	; 0xab64
    9c38:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9c3c:	f04f 0200 	mov.w	r2, #0
    9c40:	701a      	strb	r2, [r3, #0]

	/* We do a very naive form of TCP reset processing; we just accept
	any RST and kill our connection. We should in fact check if the
	sequence number of this reset is wihtin our advertised window
	before we accept the reset. */
	if( BUF->flags & TCP_RST )
    9c42:	f240 6390 	movw	r3, #1680	; 0x690
    9c46:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9c4a:	681b      	ldr	r3, [r3, #0]
    9c4c:	f103 030e 	add.w	r3, r3, #14
    9c50:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    9c54:	f003 0304 	and.w	r3, r3, #4
    9c58:	2b00      	cmp	r3, #0
    9c5a:	d00d      	beq.n	9c78 <uip_process+0x1208>
	{
		uip_connr->tcpstateflags = UIP_CLOSED;
    9c5c:	f04f 0300 	mov.w	r3, #0
    9c60:	7663      	strb	r3, [r4, #25]
		UIP_LOG( "tcp: got reset, aborting connection." );
		uip_flags = UIP_ABORT;
    9c62:	f64a 3364 	movw	r3, #43876	; 0xab64
    9c66:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9c6a:	f04f 0220 	mov.w	r2, #32
    9c6e:	701a      	strb	r2, [r3, #0]
		UIP_APPCALL();
    9c70:	f002 fc04 	bl	c47c <httpd_appcall>
		goto drop;
    9c74:	f000 bfc0 	b.w	abf8 <uip_process+0x2188>
	}

	/* Calculate the length of the data, if the application has sent
	any data to us. */
	c = ( BUF->tcpoffset >> 4 ) << 2;
    9c78:	f240 6390 	movw	r3, #1680	; 0x690
    9c7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9c80:	681b      	ldr	r3, [r3, #0]
    9c82:	f103 030e 	add.w	r3, r3, #14
    9c86:	f893 3020 	ldrb.w	r3, [r3, #32]
    9c8a:	ea4f 1313 	mov.w	r3, r3, lsr #4
    9c8e:	b2db      	uxtb	r3, r3
    9c90:	ea4f 0383 	mov.w	r3, r3, lsl #2
    9c94:	b2da      	uxtb	r2, r3
    9c96:	f642 7376 	movw	r3, #12150	; 0x2f76
    9c9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9c9e:	701a      	strb	r2, [r3, #0]

	/* uip_len will contain the length of the actual TCP data. This is
	calculated by subtracing the length of the TCP header (in
	c) and the length of the IP header (20 bytes). */
	uip_len = uip_len - c - UIP_IPH_LEN;
    9ca0:	f64a 3358 	movw	r3, #43864	; 0xab58
    9ca4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9ca8:	881a      	ldrh	r2, [r3, #0]
    9caa:	f642 7376 	movw	r3, #12150	; 0x2f76
    9cae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9cb2:	781b      	ldrb	r3, [r3, #0]
    9cb4:	ebc3 0302 	rsb	r3, r3, r2
    9cb8:	b29b      	uxth	r3, r3
    9cba:	f1a3 0314 	sub.w	r3, r3, #20
    9cbe:	b29a      	uxth	r2, r3
    9cc0:	f64a 3358 	movw	r3, #43864	; 0xab58
    9cc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9cc8:	801a      	strh	r2, [r3, #0]

	/* First, check if the sequence number of the incoming packet is
	what we're expecting next. If not, we send out an ACK with the
	correct numbers in. */
	if( !(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) )
    9cca:	7e63      	ldrb	r3, [r4, #25]
    9ccc:	f003 030f 	and.w	r3, r3, #15
    9cd0:	2b02      	cmp	r3, #2
    9cd2:	d10c      	bne.n	9cee <uip_process+0x127e>
    9cd4:	f240 6390 	movw	r3, #1680	; 0x690
    9cd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9cdc:	681b      	ldr	r3, [r3, #0]
    9cde:	f103 030e 	add.w	r3, r3, #14
    9ce2:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    9ce6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    9cea:	2b12      	cmp	r3, #18
    9cec:	d043      	beq.n	9d76 <uip_process+0x1306>
	{
		if
		(
			(uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
    9cee:	f64a 3358 	movw	r3, #43864	; 0xab58
    9cf2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9cf6:	881b      	ldrh	r3, [r3, #0]
	what we're expecting next. If not, we send out an ACK with the
	correct numbers in. */
	if( !(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) )
	{
		if
		(
    9cf8:	2b00      	cmp	r3, #0
    9cfa:	d10c      	bne.n	9d16 <uip_process+0x12a6>
			(uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
    9cfc:	f240 6390 	movw	r3, #1680	; 0x690
    9d00:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9d04:	681b      	ldr	r3, [r3, #0]
    9d06:	f103 030e 	add.w	r3, r3, #14
    9d0a:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    9d0e:	f003 0303 	and.w	r3, r3, #3
	what we're expecting next. If not, we send out an ACK with the
	correct numbers in. */
	if( !(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) )
	{
		if
		(
    9d12:	2b00      	cmp	r3, #0
    9d14:	d02f      	beq.n	9d76 <uip_process+0x1306>
			(uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
			(
				BUF->seqno[ 0 ] != uip_connr->rcv_nxt[ 0 ] ||
    9d16:	f240 6390 	movw	r3, #1680	; 0x690
    9d1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9d1e:	681b      	ldr	r3, [r3, #0]
    9d20:	f103 030e 	add.w	r3, r3, #14
    9d24:	7e1a      	ldrb	r2, [r3, #24]
    9d26:	7a23      	ldrb	r3, [r4, #8]
	what we're expecting next. If not, we send out an ACK with the
	correct numbers in. */
	if( !(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) )
	{
		if
		(
    9d28:	429a      	cmp	r2, r3
    9d2a:	f040 8515 	bne.w	a758 <uip_process+0x1ce8>
			(uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
			(
				BUF->seqno[ 0 ] != uip_connr->rcv_nxt[ 0 ] ||
				BUF->seqno[ 1 ] != uip_connr->rcv_nxt[ 1 ] ||
    9d2e:	f240 6390 	movw	r3, #1680	; 0x690
    9d32:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9d36:	681b      	ldr	r3, [r3, #0]
    9d38:	f103 030e 	add.w	r3, r3, #14
    9d3c:	7e5a      	ldrb	r2, [r3, #25]
    9d3e:	7a63      	ldrb	r3, [r4, #9]
	what we're expecting next. If not, we send out an ACK with the
	correct numbers in. */
	if( !(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) )
	{
		if
		(
    9d40:	429a      	cmp	r2, r3
    9d42:	f040 8509 	bne.w	a758 <uip_process+0x1ce8>
			(uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
			(
				BUF->seqno[ 0 ] != uip_connr->rcv_nxt[ 0 ] ||
				BUF->seqno[ 1 ] != uip_connr->rcv_nxt[ 1 ] ||
				BUF->seqno[ 2 ] != uip_connr->rcv_nxt[ 2 ] ||
    9d46:	f240 6390 	movw	r3, #1680	; 0x690
    9d4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9d4e:	681b      	ldr	r3, [r3, #0]
    9d50:	f103 030e 	add.w	r3, r3, #14
    9d54:	7e9a      	ldrb	r2, [r3, #26]
    9d56:	7aa3      	ldrb	r3, [r4, #10]
	what we're expecting next. If not, we send out an ACK with the
	correct numbers in. */
	if( !(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) )
	{
		if
		(
    9d58:	429a      	cmp	r2, r3
    9d5a:	f040 84fd 	bne.w	a758 <uip_process+0x1ce8>
			(uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
			(
				BUF->seqno[ 0 ] != uip_connr->rcv_nxt[ 0 ] ||
				BUF->seqno[ 1 ] != uip_connr->rcv_nxt[ 1 ] ||
				BUF->seqno[ 2 ] != uip_connr->rcv_nxt[ 2 ] ||
				BUF->seqno[ 3 ] != uip_connr->rcv_nxt[ 3 ]
    9d5e:	f240 6390 	movw	r3, #1680	; 0x690
    9d62:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9d66:	681b      	ldr	r3, [r3, #0]
    9d68:	f103 030e 	add.w	r3, r3, #14
    9d6c:	7eda      	ldrb	r2, [r3, #27]
    9d6e:	7ae3      	ldrb	r3, [r4, #11]
	what we're expecting next. If not, we send out an ACK with the
	correct numbers in. */
	if( !(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) )
	{
		if
		(
    9d70:	429a      	cmp	r2, r3
    9d72:	f040 84f1 	bne.w	a758 <uip_process+0x1ce8>

	/* Next, check if the incoming segment acknowledges any outstanding
	data. If so, we update the sequence number, reset the length of
	the outstanding data, calculate RTT estimations, and reset the
	retransmission timer. */
	if( (BUF->flags & TCP_ACK) && uip_outstanding(uip_connr) )
    9d76:	f240 6390 	movw	r3, #1680	; 0x690
    9d7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9d7e:	681b      	ldr	r3, [r3, #0]
    9d80:	f103 030e 	add.w	r3, r3, #14
    9d84:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    9d88:	f003 0310 	and.w	r3, r3, #16
    9d8c:	2b00      	cmp	r3, #0
    9d8e:	f000 80a1 	beq.w	9ed4 <uip_process+0x1464>
    9d92:	8a23      	ldrh	r3, [r4, #16]
    9d94:	2b00      	cmp	r3, #0
    9d96:	f000 809d 	beq.w	9ed4 <uip_process+0x1464>
	{
		uip_add32( uip_connr->snd_nxt, uip_connr->len );
    9d9a:	f104 020c 	add.w	r2, r4, #12
    9d9e:	8a23      	ldrh	r3, [r4, #16]
    9da0:	4610      	mov	r0, r2
    9da2:	4619      	mov	r1, r3
    9da4:	f7fe fab0 	bl	8308 <uip_add32>

		if
		(
			BUF->ackno[ 0 ] == uip_acc32[ 0 ] &&
    9da8:	f240 6390 	movw	r3, #1680	; 0x690
    9dac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9db0:	681b      	ldr	r3, [r3, #0]
    9db2:	f103 030e 	add.w	r3, r3, #14
    9db6:	7f1a      	ldrb	r2, [r3, #28]
    9db8:	f64a 3360 	movw	r3, #43872	; 0xab60
    9dbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9dc0:	781b      	ldrb	r3, [r3, #0]
	if( (BUF->flags & TCP_ACK) && uip_outstanding(uip_connr) )
	{
		uip_add32( uip_connr->snd_nxt, uip_connr->len );

		if
		(
    9dc2:	429a      	cmp	r2, r3
    9dc4:	f040 8086 	bne.w	9ed4 <uip_process+0x1464>
			BUF->ackno[ 0 ] == uip_acc32[ 0 ] &&
			BUF->ackno[ 1 ] == uip_acc32[ 1 ] &&
    9dc8:	f240 6390 	movw	r3, #1680	; 0x690
    9dcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9dd0:	681b      	ldr	r3, [r3, #0]
    9dd2:	f103 030e 	add.w	r3, r3, #14
    9dd6:	7f5a      	ldrb	r2, [r3, #29]
    9dd8:	f64a 3360 	movw	r3, #43872	; 0xab60
    9ddc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9de0:	785b      	ldrb	r3, [r3, #1]
	if( (BUF->flags & TCP_ACK) && uip_outstanding(uip_connr) )
	{
		uip_add32( uip_connr->snd_nxt, uip_connr->len );

		if
		(
    9de2:	429a      	cmp	r2, r3
    9de4:	d176      	bne.n	9ed4 <uip_process+0x1464>
			BUF->ackno[ 0 ] == uip_acc32[ 0 ] &&
			BUF->ackno[ 1 ] == uip_acc32[ 1 ] &&
			BUF->ackno[ 2 ] == uip_acc32[ 2 ] &&
    9de6:	f240 6390 	movw	r3, #1680	; 0x690
    9dea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9dee:	681b      	ldr	r3, [r3, #0]
    9df0:	f103 030e 	add.w	r3, r3, #14
    9df4:	7f9a      	ldrb	r2, [r3, #30]
    9df6:	f64a 3360 	movw	r3, #43872	; 0xab60
    9dfa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9dfe:	789b      	ldrb	r3, [r3, #2]
	if( (BUF->flags & TCP_ACK) && uip_outstanding(uip_connr) )
	{
		uip_add32( uip_connr->snd_nxt, uip_connr->len );

		if
		(
    9e00:	429a      	cmp	r2, r3
    9e02:	d167      	bne.n	9ed4 <uip_process+0x1464>
			BUF->ackno[ 0 ] == uip_acc32[ 0 ] &&
			BUF->ackno[ 1 ] == uip_acc32[ 1 ] &&
			BUF->ackno[ 2 ] == uip_acc32[ 2 ] &&
			BUF->ackno[ 3 ] == uip_acc32[ 3 ]
    9e04:	f240 6390 	movw	r3, #1680	; 0x690
    9e08:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9e0c:	681b      	ldr	r3, [r3, #0]
    9e0e:	f103 030e 	add.w	r3, r3, #14
    9e12:	7fda      	ldrb	r2, [r3, #31]
    9e14:	f64a 3360 	movw	r3, #43872	; 0xab60
    9e18:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9e1c:	78db      	ldrb	r3, [r3, #3]
	if( (BUF->flags & TCP_ACK) && uip_outstanding(uip_connr) )
	{
		uip_add32( uip_connr->snd_nxt, uip_connr->len );

		if
		(
    9e1e:	429a      	cmp	r2, r3
    9e20:	d158      	bne.n	9ed4 <uip_process+0x1464>
			BUF->ackno[ 2 ] == uip_acc32[ 2 ] &&
			BUF->ackno[ 3 ] == uip_acc32[ 3 ]
		)
		{
			/* Update sequence number. */
			uip_connr->snd_nxt[ 0 ] = uip_acc32[ 0 ];
    9e22:	f64a 3360 	movw	r3, #43872	; 0xab60
    9e26:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9e2a:	781b      	ldrb	r3, [r3, #0]
    9e2c:	7323      	strb	r3, [r4, #12]
			uip_connr->snd_nxt[ 1 ] = uip_acc32[ 1 ];
    9e2e:	f64a 3360 	movw	r3, #43872	; 0xab60
    9e32:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9e36:	785b      	ldrb	r3, [r3, #1]
    9e38:	7363      	strb	r3, [r4, #13]
			uip_connr->snd_nxt[ 2 ] = uip_acc32[ 2 ];
    9e3a:	f64a 3360 	movw	r3, #43872	; 0xab60
    9e3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9e42:	789b      	ldrb	r3, [r3, #2]
    9e44:	73a3      	strb	r3, [r4, #14]
			uip_connr->snd_nxt[ 3 ] = uip_acc32[ 3 ];
    9e46:	f64a 3360 	movw	r3, #43872	; 0xab60
    9e4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9e4e:	78db      	ldrb	r3, [r3, #3]
    9e50:	73e3      	strb	r3, [r4, #15]

			/* Do RTT estimation, unless we have done retransmissions. */
			if( uip_connr->nrtx == 0 )
    9e52:	7ee3      	ldrb	r3, [r4, #27]
    9e54:	2b00      	cmp	r3, #0
    9e56:	d131      	bne.n	9ebc <uip_process+0x144c>
			{
				signed char m;
				m = uip_connr->rto - uip_connr->timer;
    9e58:	7e22      	ldrb	r2, [r4, #24]
    9e5a:	7ea3      	ldrb	r3, [r4, #26]
    9e5c:	ebc3 0302 	rsb	r3, r3, r2
    9e60:	b2db      	uxtb	r3, r3
    9e62:	73fb      	strb	r3, [r7, #15]

				/* This is taken directly from VJs original code in his paper */
				m = m - ( uip_connr->sa >> 3 );
    9e64:	7bfa      	ldrb	r2, [r7, #15]
    9e66:	7da3      	ldrb	r3, [r4, #22]
    9e68:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    9e6c:	b2db      	uxtb	r3, r3
    9e6e:	ebc3 0302 	rsb	r3, r3, r2
    9e72:	b2db      	uxtb	r3, r3
    9e74:	73fb      	strb	r3, [r7, #15]
				uip_connr->sa += m;
    9e76:	7da2      	ldrb	r2, [r4, #22]
    9e78:	7bfb      	ldrb	r3, [r7, #15]
    9e7a:	4413      	add	r3, r2
    9e7c:	b2db      	uxtb	r3, r3
    9e7e:	75a3      	strb	r3, [r4, #22]
				if( m < 0 )
    9e80:	f997 300f 	ldrsb.w	r3, [r7, #15]
    9e84:	2b00      	cmp	r3, #0
    9e86:	da03      	bge.n	9e90 <uip_process+0x1420>
				{
					m = -m;
    9e88:	7bfb      	ldrb	r3, [r7, #15]
    9e8a:	f1c3 0300 	rsb	r3, r3, #0
    9e8e:	73fb      	strb	r3, [r7, #15]
				}

				m = m - ( uip_connr->sv >> 2 );
    9e90:	7bfa      	ldrb	r2, [r7, #15]
    9e92:	7de3      	ldrb	r3, [r4, #23]
    9e94:	ea4f 0393 	mov.w	r3, r3, lsr #2
    9e98:	b2db      	uxtb	r3, r3
    9e9a:	ebc3 0302 	rsb	r3, r3, r2
    9e9e:	b2db      	uxtb	r3, r3
    9ea0:	73fb      	strb	r3, [r7, #15]
				uip_connr->sv += m;
    9ea2:	7de2      	ldrb	r2, [r4, #23]
    9ea4:	7bfb      	ldrb	r3, [r7, #15]
    9ea6:	4413      	add	r3, r2
    9ea8:	b2db      	uxtb	r3, r3
    9eaa:	75e3      	strb	r3, [r4, #23]
				uip_connr->rto = ( uip_connr->sa >> 3 ) + uip_connr->sv;
    9eac:	7da3      	ldrb	r3, [r4, #22]
    9eae:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    9eb2:	b2da      	uxtb	r2, r3
    9eb4:	7de3      	ldrb	r3, [r4, #23]
    9eb6:	4413      	add	r3, r2
    9eb8:	b2db      	uxtb	r3, r3
    9eba:	7623      	strb	r3, [r4, #24]
			}

			/* Set the acknowledged flag. */
			uip_flags = UIP_ACKDATA;
    9ebc:	f64a 3364 	movw	r3, #43876	; 0xab64
    9ec0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9ec4:	f04f 0201 	mov.w	r2, #1
    9ec8:	701a      	strb	r2, [r3, #0]

			/* Reset the retransmission timer. */
			uip_connr->timer = uip_connr->rto;
    9eca:	7e23      	ldrb	r3, [r4, #24]
    9ecc:	76a3      	strb	r3, [r4, #26]

			/* Reset length of outstanding data. */
			uip_connr->len = 0;
    9ece:	f04f 0300 	mov.w	r3, #0
    9ed2:	8223      	strh	r3, [r4, #16]
		}
	}

	/* Do different things depending on in what state the connection is. */
	switch( uip_connr->tcpstateflags & UIP_TS_MASK )
    9ed4:	7e63      	ldrb	r3, [r4, #25]
    9ed6:	f003 030f 	and.w	r3, r3, #15
    9eda:	f103 33ff 	add.w	r3, r3, #4294967295
    9ede:	2b07      	cmp	r3, #7
    9ee0:	f200 867b 	bhi.w	abda <uip_process+0x216a>
    9ee4:	a201      	add	r2, pc, #4	; (adr r2, 9eec <uip_process+0x147c>)
    9ee6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    9eea:	bf00      	nop
    9eec:	00009f0d 	.word	0x00009f0d
    9ef0:	00009f89 	.word	0x00009f89
    9ef4:	0000a223 	.word	0x0000a223
    9ef8:	0000a607 	.word	0x0000a607
    9efc:	0000a6bf 	.word	0x0000a6bf
    9f00:	0000a733 	.word	0x0000a733
    9f04:	0000a757 	.word	0x0000a757
    9f08:	0000a5d7 	.word	0x0000a5d7
		case UIP_SYN_RCVD:
			/* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
	   		we are waiting for an ACK that acknowledges the data we sent
	   		out the last time. Therefore, we want to have the UIP_ACKDATA
	   		flag set. If so, we enter the ESTABLISHED state. */
			if( uip_flags & UIP_ACKDATA )
    9f0c:	f64a 3364 	movw	r3, #43876	; 0xab64
    9f10:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9f14:	781b      	ldrb	r3, [r3, #0]
    9f16:	f003 0301 	and.w	r3, r3, #1
    9f1a:	b2db      	uxtb	r3, r3
    9f1c:	2b00      	cmp	r3, #0
    9f1e:	f000 865e 	beq.w	abde <uip_process+0x216e>
			{
				uip_connr->tcpstateflags = UIP_ESTABLISHED;
    9f22:	f04f 0303 	mov.w	r3, #3
    9f26:	7663      	strb	r3, [r4, #25]
				uip_flags = UIP_CONNECTED;
    9f28:	f64a 3364 	movw	r3, #43876	; 0xab64
    9f2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9f30:	f04f 0240 	mov.w	r2, #64	; 0x40
    9f34:	701a      	strb	r2, [r3, #0]
				uip_connr->len = 0;
    9f36:	f04f 0300 	mov.w	r3, #0
    9f3a:	8223      	strh	r3, [r4, #16]
				if( uip_len > 0 )
    9f3c:	f64a 3358 	movw	r3, #43864	; 0xab58
    9f40:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9f44:	881b      	ldrh	r3, [r3, #0]
    9f46:	2b00      	cmp	r3, #0
    9f48:	d014      	beq.n	9f74 <uip_process+0x1504>
				{
					uip_flags |= UIP_NEWDATA;
    9f4a:	f64a 3364 	movw	r3, #43876	; 0xab64
    9f4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9f52:	781b      	ldrb	r3, [r3, #0]
    9f54:	f043 0302 	orr.w	r3, r3, #2
    9f58:	b2da      	uxtb	r2, r3
    9f5a:	f64a 3364 	movw	r3, #43876	; 0xab64
    9f5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9f62:	701a      	strb	r2, [r3, #0]
					uip_add_rcv_nxt( uip_len );
    9f64:	f64a 3358 	movw	r3, #43864	; 0xab58
    9f68:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9f6c:	881b      	ldrh	r3, [r3, #0]
    9f6e:	4618      	mov	r0, r3
    9f70:	f7fe fd3c 	bl	89ec <uip_add_rcv_nxt>
				}

				uip_slen = 0;
    9f74:	f64c 33e4 	movw	r3, #52196	; 0xcbe4
    9f78:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9f7c:	f04f 0200 	mov.w	r2, #0
    9f80:	801a      	strh	r2, [r3, #0]
				UIP_APPCALL();
    9f82:	f002 fa7b 	bl	c47c <httpd_appcall>
				goto appsend;
    9f86:	e267      	b.n	a458 <uip_process+0x19e8>
			case UIP_SYN_SENT:
				/* In SYN_SENT, we wait for a SYNACK that is sent in response to
				our SYN. The rcv_nxt is set to sequence number in the SYNACK
				plus one, and we send an ACK. We move into the ESTABLISHED
				state. */
				if( (uip_flags & UIP_ACKDATA) && (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK) )
    9f88:	f64a 3364 	movw	r3, #43876	; 0xab64
    9f8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9f90:	781b      	ldrb	r3, [r3, #0]
    9f92:	f003 0301 	and.w	r3, r3, #1
    9f96:	b2db      	uxtb	r3, r3
    9f98:	2b00      	cmp	r3, #0
    9f9a:	f000 812f 	beq.w	a1fc <uip_process+0x178c>
    9f9e:	f240 6390 	movw	r3, #1680	; 0x690
    9fa2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9fa6:	681b      	ldr	r3, [r3, #0]
    9fa8:	f103 030e 	add.w	r3, r3, #14
    9fac:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    9fb0:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    9fb4:	2b12      	cmp	r3, #18
    9fb6:	f040 8121 	bne.w	a1fc <uip_process+0x178c>
				{
					/* Parse the TCP MSS option, if present. */
					if( (BUF->tcpoffset & 0xf0) > 0x50 )
    9fba:	f240 6390 	movw	r3, #1680	; 0x690
    9fbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9fc2:	681b      	ldr	r3, [r3, #0]
    9fc4:	f103 030e 	add.w	r3, r3, #14
    9fc8:	f893 3020 	ldrb.w	r3, [r3, #32]
    9fcc:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    9fd0:	2b50      	cmp	r3, #80	; 0x50
    9fd2:	f340 80cd 	ble.w	a170 <uip_process+0x1700>
					{
						for( c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2; )
    9fd6:	f642 7376 	movw	r3, #12150	; 0x2f76
    9fda:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9fde:	f04f 0200 	mov.w	r2, #0
    9fe2:	701a      	strb	r2, [r3, #0]
    9fe4:	e0a7      	b.n	a136 <uip_process+0x16c6>
						{
							opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
    9fe6:	f240 6390 	movw	r3, #1680	; 0x690
    9fea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9fee:	681a      	ldr	r2, [r3, #0]
    9ff0:	f642 7376 	movw	r3, #12150	; 0x2f76
    9ff4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9ff8:	781b      	ldrb	r3, [r3, #0]
    9ffa:	f103 0336 	add.w	r3, r3, #54	; 0x36
    9ffe:	4413      	add	r3, r2
    a000:	781a      	ldrb	r2, [r3, #0]
    a002:	f642 7377 	movw	r3, #12151	; 0x2f77
    a006:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a00a:	701a      	strb	r2, [r3, #0]
							if( opt == TCP_OPT_END )
    a00c:	f642 7377 	movw	r3, #12151	; 0x2f77
    a010:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a014:	781b      	ldrb	r3, [r3, #0]
    a016:	2b00      	cmp	r3, #0
    a018:	f000 80a7 	beq.w	a16a <uip_process+0x16fa>
							{
								/* End of options. */
								break;
							}
							else if( opt == TCP_OPT_NOOP )
    a01c:	f642 7377 	movw	r3, #12151	; 0x2f77
    a020:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a024:	781b      	ldrb	r3, [r3, #0]
    a026:	2b01      	cmp	r3, #1
    a028:	d10d      	bne.n	a046 <uip_process+0x15d6>
							{
								++c;
    a02a:	f642 7376 	movw	r3, #12150	; 0x2f76
    a02e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a032:	781b      	ldrb	r3, [r3, #0]
    a034:	f103 0301 	add.w	r3, r3, #1
    a038:	b2da      	uxtb	r2, r3
    a03a:	f642 7376 	movw	r3, #12150	; 0x2f76
    a03e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a042:	701a      	strb	r2, [r3, #0]
    a044:	e077      	b.n	a136 <uip_process+0x16c6>

								/* NOP option. */
							}
							else if( opt == TCP_OPT_MSS && uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN )
    a046:	f642 7377 	movw	r3, #12151	; 0x2f77
    a04a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a04e:	781b      	ldrb	r3, [r3, #0]
    a050:	2b02      	cmp	r3, #2
    a052:	d146      	bne.n	a0e2 <uip_process+0x1672>
    a054:	f240 6390 	movw	r3, #1680	; 0x690
    a058:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a05c:	681a      	ldr	r2, [r3, #0]
    a05e:	f642 7376 	movw	r3, #12150	; 0x2f76
    a062:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a066:	781b      	ldrb	r3, [r3, #0]
    a068:	f103 0337 	add.w	r3, r3, #55	; 0x37
    a06c:	4413      	add	r3, r2
    a06e:	781b      	ldrb	r3, [r3, #0]
    a070:	2b04      	cmp	r3, #4
    a072:	d136      	bne.n	a0e2 <uip_process+0x1672>
							{
								/* An MSS option with the right option length. */
								tmp16 = ( uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8 ) | uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
    a074:	f240 6390 	movw	r3, #1680	; 0x690
    a078:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a07c:	681a      	ldr	r2, [r3, #0]
    a07e:	f642 7376 	movw	r3, #12150	; 0x2f76
    a082:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a086:	781b      	ldrb	r3, [r3, #0]
    a088:	f103 0338 	add.w	r3, r3, #56	; 0x38
    a08c:	4413      	add	r3, r2
    a08e:	781b      	ldrb	r3, [r3, #0]
    a090:	ea4f 2303 	mov.w	r3, r3, lsl #8
    a094:	b29a      	uxth	r2, r3
    a096:	f240 6390 	movw	r3, #1680	; 0x690
    a09a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a09e:	6819      	ldr	r1, [r3, #0]
    a0a0:	f642 7376 	movw	r3, #12150	; 0x2f76
    a0a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a0a8:	781b      	ldrb	r3, [r3, #0]
    a0aa:	f103 0339 	add.w	r3, r3, #57	; 0x39
    a0ae:	440b      	add	r3, r1
    a0b0:	781b      	ldrb	r3, [r3, #0]
    a0b2:	ea42 0303 	orr.w	r3, r2, r3
    a0b6:	b29b      	uxth	r3, r3
    a0b8:	b29a      	uxth	r2, r3
    a0ba:	f642 7378 	movw	r3, #12152	; 0x2f78
    a0be:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a0c2:	801a      	strh	r2, [r3, #0]
								uip_connr->initialmss = uip_connr->mss = tmp16 > UIP_TCP_MSS ? UIP_TCP_MSS : tmp16;
    a0c4:	f642 7378 	movw	r3, #12152	; 0x2f78
    a0c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a0cc:	881a      	ldrh	r2, [r3, #0]
    a0ce:	f240 5392 	movw	r3, #1426	; 0x592
    a0d2:	429a      	cmp	r2, r3
    a0d4:	bf38      	it	cc
    a0d6:	4613      	movcc	r3, r2
    a0d8:	b29b      	uxth	r3, r3
    a0da:	8263      	strh	r3, [r4, #18]
    a0dc:	8a63      	ldrh	r3, [r4, #18]
    a0de:	82a3      	strh	r3, [r4, #20]

								/* And we are done processing options. */
								break;
    a0e0:	e046      	b.n	a170 <uip_process+0x1700>
							}
							else
							{
								/* All other options have a length field, so that we easily
								can skip past them. */
								if( uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0 )
    a0e2:	f240 6390 	movw	r3, #1680	; 0x690
    a0e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a0ea:	681a      	ldr	r2, [r3, #0]
    a0ec:	f642 7376 	movw	r3, #12150	; 0x2f76
    a0f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a0f4:	781b      	ldrb	r3, [r3, #0]
    a0f6:	f103 0337 	add.w	r3, r3, #55	; 0x37
    a0fa:	4413      	add	r3, r2
    a0fc:	781b      	ldrb	r3, [r3, #0]
    a0fe:	2b00      	cmp	r3, #0
    a100:	d035      	beq.n	a16e <uip_process+0x16fe>
									/* If the length field is zero, the options are malformed
									and we don't process them further. */
									break;
								}

								c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    a102:	f240 6390 	movw	r3, #1680	; 0x690
    a106:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a10a:	681a      	ldr	r2, [r3, #0]
    a10c:	f642 7376 	movw	r3, #12150	; 0x2f76
    a110:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a114:	781b      	ldrb	r3, [r3, #0]
    a116:	f103 0337 	add.w	r3, r3, #55	; 0x37
    a11a:	4413      	add	r3, r2
    a11c:	781a      	ldrb	r2, [r3, #0]
    a11e:	f642 7376 	movw	r3, #12150	; 0x2f76
    a122:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a126:	781b      	ldrb	r3, [r3, #0]
    a128:	4413      	add	r3, r2
    a12a:	b2da      	uxtb	r2, r3
    a12c:	f642 7376 	movw	r3, #12150	; 0x2f76
    a130:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a134:	701a      	strb	r2, [r3, #0]
				if( (uip_flags & UIP_ACKDATA) && (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK) )
				{
					/* Parse the TCP MSS option, if present. */
					if( (BUF->tcpoffset & 0xf0) > 0x50 )
					{
						for( c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2; )
    a136:	f642 7376 	movw	r3, #12150	; 0x2f76
    a13a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a13e:	781b      	ldrb	r3, [r3, #0]
    a140:	461a      	mov	r2, r3
    a142:	f240 6390 	movw	r3, #1680	; 0x690
    a146:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a14a:	681b      	ldr	r3, [r3, #0]
    a14c:	f103 030e 	add.w	r3, r3, #14
    a150:	f893 3020 	ldrb.w	r3, [r3, #32]
    a154:	ea4f 1313 	mov.w	r3, r3, lsr #4
    a158:	b2db      	uxtb	r3, r3
    a15a:	f1a3 0305 	sub.w	r3, r3, #5
    a15e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    a162:	429a      	cmp	r2, r3
    a164:	f6ff af3f 	blt.w	9fe6 <uip_process+0x1576>
    a168:	e002      	b.n	a170 <uip_process+0x1700>
						{
							opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
							if( opt == TCP_OPT_END )
							{
								/* End of options. */
								break;
    a16a:	bf00      	nop
    a16c:	e000      	b.n	a170 <uip_process+0x1700>
								can skip past them. */
								if( uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0 )
								{
									/* If the length field is zero, the options are malformed
									and we don't process them further. */
									break;
    a16e:	bf00      	nop
								c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
							}
						}
					}

					uip_connr->tcpstateflags = UIP_ESTABLISHED;
    a170:	f04f 0303 	mov.w	r3, #3
    a174:	7663      	strb	r3, [r4, #25]
					uip_connr->rcv_nxt[ 0 ] = BUF->seqno[ 0 ];
    a176:	f240 6390 	movw	r3, #1680	; 0x690
    a17a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a17e:	681b      	ldr	r3, [r3, #0]
    a180:	f103 030e 	add.w	r3, r3, #14
    a184:	7e1b      	ldrb	r3, [r3, #24]
    a186:	7223      	strb	r3, [r4, #8]
					uip_connr->rcv_nxt[ 1 ] = BUF->seqno[ 1 ];
    a188:	f240 6390 	movw	r3, #1680	; 0x690
    a18c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a190:	681b      	ldr	r3, [r3, #0]
    a192:	f103 030e 	add.w	r3, r3, #14
    a196:	7e5b      	ldrb	r3, [r3, #25]
    a198:	7263      	strb	r3, [r4, #9]
					uip_connr->rcv_nxt[ 2 ] = BUF->seqno[ 2 ];
    a19a:	f240 6390 	movw	r3, #1680	; 0x690
    a19e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a1a2:	681b      	ldr	r3, [r3, #0]
    a1a4:	f103 030e 	add.w	r3, r3, #14
    a1a8:	7e9b      	ldrb	r3, [r3, #26]
    a1aa:	72a3      	strb	r3, [r4, #10]
					uip_connr->rcv_nxt[ 3 ] = BUF->seqno[ 3 ];
    a1ac:	f240 6390 	movw	r3, #1680	; 0x690
    a1b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a1b4:	681b      	ldr	r3, [r3, #0]
    a1b6:	f103 030e 	add.w	r3, r3, #14
    a1ba:	7edb      	ldrb	r3, [r3, #27]
    a1bc:	72e3      	strb	r3, [r4, #11]
					uip_add_rcv_nxt( 1 );
    a1be:	f04f 0001 	mov.w	r0, #1
    a1c2:	f7fe fc13 	bl	89ec <uip_add_rcv_nxt>
					uip_flags = UIP_CONNECTED | UIP_NEWDATA;
    a1c6:	f64a 3364 	movw	r3, #43876	; 0xab64
    a1ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a1ce:	f04f 0242 	mov.w	r2, #66	; 0x42
    a1d2:	701a      	strb	r2, [r3, #0]
					uip_connr->len = 0;
    a1d4:	f04f 0300 	mov.w	r3, #0
    a1d8:	8223      	strh	r3, [r4, #16]
					uip_len = 0;
    a1da:	f64a 3358 	movw	r3, #43864	; 0xab58
    a1de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a1e2:	f04f 0200 	mov.w	r2, #0
    a1e6:	801a      	strh	r2, [r3, #0]
					uip_slen = 0;
    a1e8:	f64c 33e4 	movw	r3, #52196	; 0xcbe4
    a1ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a1f0:	f04f 0200 	mov.w	r2, #0
    a1f4:	801a      	strh	r2, [r3, #0]
					UIP_APPCALL();
    a1f6:	f002 f941 	bl	c47c <httpd_appcall>
					goto appsend;
    a1fa:	e12d      	b.n	a458 <uip_process+0x19e8>
				}

				/* Inform the application that the connection failed */
				uip_flags = UIP_ABORT;
    a1fc:	f64a 3364 	movw	r3, #43876	; 0xab64
    a200:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a204:	f04f 0220 	mov.w	r2, #32
    a208:	701a      	strb	r2, [r3, #0]
				UIP_APPCALL();
    a20a:	f002 f937 	bl	c47c <httpd_appcall>

				/* The connection is closed after we send the RST */
				uip_conn->tcpstateflags = UIP_CLOSED;
    a20e:	f64a 336c 	movw	r3, #43884	; 0xab6c
    a212:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a216:	681b      	ldr	r3, [r3, #0]
    a218:	f04f 0200 	mov.w	r2, #0
    a21c:	765a      	strb	r2, [r3, #25]
				goto reset;
    a21e:	f7ff b8bc 	b.w	939a <uip_process+0x92a>

			If the incoming packet is a FIN, we should close the connection on
			this side as well, and we send out a FIN and enter the LAST_ACK
			state. We require that there is no outstanding data; otherwise the
			sequence numbers will be screwed up. */
			if( BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED) )
    a222:	f240 6390 	movw	r3, #1680	; 0x690
    a226:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a22a:	681b      	ldr	r3, [r3, #0]
    a22c:	f103 030e 	add.w	r3, r3, #14
    a230:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    a234:	f003 0301 	and.w	r3, r3, #1
    a238:	b2db      	uxtb	r3, r3
    a23a:	2b00      	cmp	r3, #0
    a23c:	d04d      	beq.n	a2da <uip_process+0x186a>
    a23e:	7e63      	ldrb	r3, [r4, #25]
    a240:	f003 0310 	and.w	r3, r3, #16
    a244:	2b00      	cmp	r3, #0
    a246:	d148      	bne.n	a2da <uip_process+0x186a>
			{
				if( uip_outstanding(uip_connr) )
    a248:	8a23      	ldrh	r3, [r4, #16]
    a24a:	2b00      	cmp	r3, #0
    a24c:	f040 84c9 	bne.w	abe2 <uip_process+0x2172>
				{
					goto drop;
				}

				uip_add_rcv_nxt( 1 + uip_len );
    a250:	f64a 3358 	movw	r3, #43864	; 0xab58
    a254:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a258:	881b      	ldrh	r3, [r3, #0]
    a25a:	f103 0301 	add.w	r3, r3, #1
    a25e:	b29b      	uxth	r3, r3
    a260:	4618      	mov	r0, r3
    a262:	f7fe fbc3 	bl	89ec <uip_add_rcv_nxt>
				uip_flags |= UIP_CLOSE;
    a266:	f64a 3364 	movw	r3, #43876	; 0xab64
    a26a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a26e:	781b      	ldrb	r3, [r3, #0]
    a270:	f043 0310 	orr.w	r3, r3, #16
    a274:	b2da      	uxtb	r2, r3
    a276:	f64a 3364 	movw	r3, #43876	; 0xab64
    a27a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a27e:	701a      	strb	r2, [r3, #0]
				if( uip_len > 0 )
    a280:	f64a 3358 	movw	r3, #43864	; 0xab58
    a284:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a288:	881b      	ldrh	r3, [r3, #0]
    a28a:	2b00      	cmp	r3, #0
    a28c:	d00c      	beq.n	a2a8 <uip_process+0x1838>
				{
					uip_flags |= UIP_NEWDATA;
    a28e:	f64a 3364 	movw	r3, #43876	; 0xab64
    a292:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a296:	781b      	ldrb	r3, [r3, #0]
    a298:	f043 0302 	orr.w	r3, r3, #2
    a29c:	b2da      	uxtb	r2, r3
    a29e:	f64a 3364 	movw	r3, #43876	; 0xab64
    a2a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a2a6:	701a      	strb	r2, [r3, #0]
				}

				UIP_APPCALL();
    a2a8:	f002 f8e8 	bl	c47c <httpd_appcall>
				uip_connr->len = 1;
    a2ac:	f04f 0301 	mov.w	r3, #1
    a2b0:	8223      	strh	r3, [r4, #16]
				uip_connr->tcpstateflags = UIP_LAST_ACK;
    a2b2:	f04f 0308 	mov.w	r3, #8
    a2b6:	7663      	strb	r3, [r4, #25]
				uip_connr->nrtx = 0;
    a2b8:	f04f 0300 	mov.w	r3, #0
    a2bc:	76e3      	strb	r3, [r4, #27]
    a2be:	e000      	b.n	a2c2 <uip_process+0x1852>

						case UIP_FIN_WAIT_1:
						case UIP_CLOSING:
						case UIP_LAST_ACK:
							/* In all these states we should retransmit a FINACK. */
							goto tcp_send_finack;
    a2c0:	bf00      	nop
				UIP_APPCALL();
				uip_connr->len = 1;
				uip_connr->tcpstateflags = UIP_LAST_ACK;
				uip_connr->nrtx = 0;
	tcp_send_finack:
				BUF->flags = TCP_FIN | TCP_ACK;
    a2c2:	f240 6390 	movw	r3, #1680	; 0x690
    a2c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a2ca:	681b      	ldr	r3, [r3, #0]
    a2cc:	f103 030e 	add.w	r3, r3, #14
    a2d0:	f04f 0211 	mov.w	r2, #17
    a2d4:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
				goto tcp_send_nodata;
    a2d8:	e249      	b.n	a76e <uip_process+0x1cfe>
			}

			/* Check the URG flag. If this is set, the segment carries urgent
			data that we must pass to the application. */
			if( (BUF->flags & TCP_URG) != 0 )
    a2da:	f240 6390 	movw	r3, #1680	; 0x690
    a2de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a2e2:	681b      	ldr	r3, [r3, #0]
    a2e4:	f103 030e 	add.w	r3, r3, #14
    a2e8:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    a2ec:	f003 0320 	and.w	r3, r3, #32
    a2f0:	2b00      	cmp	r3, #0
    a2f2:	d046      	beq.n	a382 <uip_process+0x1912>
					}
					else
					{
					uip_urglen = 0;
				#else /* UIP_URGDATA > 0 */
					uip_appdata = ( ( char * ) uip_appdata ) + ( (BUF->urgp[ 0 ] << 8) | BUF->urgp[ 1 ] );
    a2f4:	f64a 3368 	movw	r3, #43880	; 0xab68
    a2f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a2fc:	681a      	ldr	r2, [r3, #0]
    a2fe:	f240 6390 	movw	r3, #1680	; 0x690
    a302:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a306:	681b      	ldr	r3, [r3, #0]
    a308:	f103 030e 	add.w	r3, r3, #14
    a30c:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
    a310:	ea4f 2103 	mov.w	r1, r3, lsl #8
    a314:	f240 6390 	movw	r3, #1680	; 0x690
    a318:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a31c:	681b      	ldr	r3, [r3, #0]
    a31e:	f103 030e 	add.w	r3, r3, #14
    a322:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
    a326:	ea41 0303 	orr.w	r3, r1, r3
    a32a:	441a      	add	r2, r3
    a32c:	f64a 3368 	movw	r3, #43880	; 0xab68
    a330:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a334:	601a      	str	r2, [r3, #0]
					uip_len -= ( BUF->urgp[ 0 ] << 8 ) | BUF->urgp[ 1 ];
    a336:	f64a 3358 	movw	r3, #43864	; 0xab58
    a33a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a33e:	881a      	ldrh	r2, [r3, #0]
    a340:	f240 6390 	movw	r3, #1680	; 0x690
    a344:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a348:	681b      	ldr	r3, [r3, #0]
    a34a:	f103 030e 	add.w	r3, r3, #14
    a34e:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
    a352:	ea4f 2303 	mov.w	r3, r3, lsl #8
    a356:	b299      	uxth	r1, r3
    a358:	f240 6390 	movw	r3, #1680	; 0x690
    a35c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a360:	681b      	ldr	r3, [r3, #0]
    a362:	f103 030e 	add.w	r3, r3, #14
    a366:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
    a36a:	ea41 0303 	orr.w	r3, r1, r3
    a36e:	b29b      	uxth	r3, r3
    a370:	b29b      	uxth	r3, r3
    a372:	ebc3 0302 	rsb	r3, r3, r2
    a376:	b29a      	uxth	r2, r3
    a378:	f64a 3358 	movw	r3, #43864	; 0xab58
    a37c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a380:	801a      	strh	r2, [r3, #0]
			/* If uip_len > 0 we have TCP data in the packet, and we flag this
			by setting the UIP_NEWDATA flag and update the sequence number
			we acknowledge. If the application has stopped the dataflow
			using uip_stop(), we must not accept any data packets from the
			remote host. */
			if( uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED) )
    a382:	f64a 3358 	movw	r3, #43864	; 0xab58
    a386:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a38a:	881b      	ldrh	r3, [r3, #0]
    a38c:	2b00      	cmp	r3, #0
    a38e:	d019      	beq.n	a3c4 <uip_process+0x1954>
    a390:	7e63      	ldrb	r3, [r4, #25]
    a392:	f003 0310 	and.w	r3, r3, #16
    a396:	2b00      	cmp	r3, #0
    a398:	d114      	bne.n	a3c4 <uip_process+0x1954>
			{
				uip_flags |= UIP_NEWDATA;
    a39a:	f64a 3364 	movw	r3, #43876	; 0xab64
    a39e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a3a2:	781b      	ldrb	r3, [r3, #0]
    a3a4:	f043 0302 	orr.w	r3, r3, #2
    a3a8:	b2da      	uxtb	r2, r3
    a3aa:	f64a 3364 	movw	r3, #43876	; 0xab64
    a3ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a3b2:	701a      	strb	r2, [r3, #0]
				uip_add_rcv_nxt( uip_len );
    a3b4:	f64a 3358 	movw	r3, #43864	; 0xab58
    a3b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a3bc:	881b      	ldrh	r3, [r3, #0]
    a3be:	4618      	mov	r0, r3
    a3c0:	f7fe fb14 	bl	89ec <uip_add_rcv_nxt>
			the initial MSS so that the application will send an entire MSS
			of data. This data will not be acknowledged by the receiver,
			and the application will retransmit it. This is called the
			"persistent timer" and uses the retransmission mechanim.
			*/
			tmp16 = ( (u16_t) BUF->wnd[ 0 ] << 8 ) + ( u16_t ) BUF->wnd[ 1 ];
    a3c4:	f240 6390 	movw	r3, #1680	; 0x690
    a3c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a3cc:	681b      	ldr	r3, [r3, #0]
    a3ce:	f103 030e 	add.w	r3, r3, #14
    a3d2:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
    a3d6:	ea4f 2303 	mov.w	r3, r3, lsl #8
    a3da:	b29a      	uxth	r2, r3
    a3dc:	f240 6390 	movw	r3, #1680	; 0x690
    a3e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a3e4:	681b      	ldr	r3, [r3, #0]
    a3e6:	f103 030e 	add.w	r3, r3, #14
    a3ea:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
    a3ee:	4413      	add	r3, r2
    a3f0:	b29a      	uxth	r2, r3
    a3f2:	f642 7378 	movw	r3, #12152	; 0x2f78
    a3f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a3fa:	801a      	strh	r2, [r3, #0]
			if( tmp16 > uip_connr->initialmss || tmp16 == 0 )
    a3fc:	8aa2      	ldrh	r2, [r4, #20]
    a3fe:	f642 7378 	movw	r3, #12152	; 0x2f78
    a402:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a406:	881b      	ldrh	r3, [r3, #0]
    a408:	429a      	cmp	r2, r3
    a40a:	d306      	bcc.n	a41a <uip_process+0x19aa>
    a40c:	f642 7378 	movw	r3, #12152	; 0x2f78
    a410:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a414:	881b      	ldrh	r3, [r3, #0]
    a416:	2b00      	cmp	r3, #0
    a418:	d105      	bne.n	a426 <uip_process+0x19b6>
			{
				tmp16 = uip_connr->initialmss;
    a41a:	8aa2      	ldrh	r2, [r4, #20]
    a41c:	f642 7378 	movw	r3, #12152	; 0x2f78
    a420:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a424:	801a      	strh	r2, [r3, #0]
			}

			uip_connr->mss = tmp16;
    a426:	f642 7378 	movw	r3, #12152	; 0x2f78
    a42a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a42e:	881b      	ldrh	r3, [r3, #0]
    a430:	8263      	strh	r3, [r4, #18]

			If the application wishes to send any data, this data should be
			put into the uip_appdata and the length of the data should be
			put into uip_len. If the application don't have any data to
			send, uip_len must be set to 0. */
			if( uip_flags & (UIP_NEWDATA | UIP_ACKDATA) )
    a432:	f64a 3364 	movw	r3, #43876	; 0xab64
    a436:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a43a:	781b      	ldrb	r3, [r3, #0]
    a43c:	f003 0303 	and.w	r3, r3, #3
    a440:	2b00      	cmp	r3, #0
    a442:	f000 83d0 	beq.w	abe6 <uip_process+0x2176>
			{
				uip_slen = 0;
    a446:	f64c 33e4 	movw	r3, #52196	; 0xcbe4
    a44a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a44e:	f04f 0200 	mov.w	r2, #0
    a452:	801a      	strh	r2, [r3, #0]
				UIP_APPCALL();
    a454:	f002 f812 	bl	c47c <httpd_appcall>

appsend:
				if( uip_flags & UIP_ABORT )
    a458:	f64a 3364 	movw	r3, #43876	; 0xab64
    a45c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a460:	781b      	ldrb	r3, [r3, #0]
    a462:	f003 0320 	and.w	r3, r3, #32
    a466:	2b00      	cmp	r3, #0
    a468:	d015      	beq.n	a496 <uip_process+0x1a26>
				{
					uip_slen = 0;
    a46a:	f64c 33e4 	movw	r3, #52196	; 0xcbe4
    a46e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a472:	f04f 0200 	mov.w	r2, #0
    a476:	801a      	strh	r2, [r3, #0]
					uip_connr->tcpstateflags = UIP_CLOSED;
    a478:	f04f 0300 	mov.w	r3, #0
    a47c:	7663      	strb	r3, [r4, #25]
					BUF->flags = TCP_RST | TCP_ACK;
    a47e:	f240 6390 	movw	r3, #1680	; 0x690
    a482:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a486:	681b      	ldr	r3, [r3, #0]
    a488:	f103 030e 	add.w	r3, r3, #14
    a48c:	f04f 0214 	mov.w	r2, #20
    a490:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
					goto tcp_send_nodata;
    a494:	e16b      	b.n	a76e <uip_process+0x1cfe>
				}

				if( uip_flags & UIP_CLOSE )
    a496:	f64a 3364 	movw	r3, #43876	; 0xab64
    a49a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a49e:	781b      	ldrb	r3, [r3, #0]
    a4a0:	f003 0310 	and.w	r3, r3, #16
    a4a4:	2b00      	cmp	r3, #0
    a4a6:	d01b      	beq.n	a4e0 <uip_process+0x1a70>
				{
					uip_slen = 0;
    a4a8:	f64c 33e4 	movw	r3, #52196	; 0xcbe4
    a4ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a4b0:	f04f 0200 	mov.w	r2, #0
    a4b4:	801a      	strh	r2, [r3, #0]
					uip_connr->len = 1;
    a4b6:	f04f 0301 	mov.w	r3, #1
    a4ba:	8223      	strh	r3, [r4, #16]
					uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
    a4bc:	f04f 0304 	mov.w	r3, #4
    a4c0:	7663      	strb	r3, [r4, #25]
					uip_connr->nrtx = 0;
    a4c2:	f04f 0300 	mov.w	r3, #0
    a4c6:	76e3      	strb	r3, [r4, #27]
					BUF->flags = TCP_FIN | TCP_ACK;
    a4c8:	f240 6390 	movw	r3, #1680	; 0x690
    a4cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a4d0:	681b      	ldr	r3, [r3, #0]
    a4d2:	f103 030e 	add.w	r3, r3, #14
    a4d6:	f04f 0211 	mov.w	r2, #17
    a4da:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
					goto tcp_send_nodata;
    a4de:	e146      	b.n	a76e <uip_process+0x1cfe>
				}

				/* If uip_slen > 0, the application has data to be sent. */
				if( uip_slen > 0 )
    a4e0:	f64c 33e4 	movw	r3, #52196	; 0xcbe4
    a4e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a4e8:	881b      	ldrh	r3, [r3, #0]
    a4ea:	2b00      	cmp	r3, #0
    a4ec:	d02a      	beq.n	a544 <uip_process+0x1ad4>
				{
					/* If the connection has acknowledged data, the contents of
	   				the ->len variable should be discarded. */
					if( (uip_flags & UIP_ACKDATA) != 0 )
    a4ee:	f64a 3364 	movw	r3, #43876	; 0xab64
    a4f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a4f6:	781b      	ldrb	r3, [r3, #0]
    a4f8:	f003 0301 	and.w	r3, r3, #1
    a4fc:	b2db      	uxtb	r3, r3
    a4fe:	2b00      	cmp	r3, #0
    a500:	d002      	beq.n	a508 <uip_process+0x1a98>
					{
						uip_connr->len = 0;
    a502:	f04f 0300 	mov.w	r3, #0
    a506:	8223      	strh	r3, [r4, #16]
					}

					/* If the ->len variable is non-zero the connection has
	   				already data in transit and cannot send anymore right
	   				now. */
					if( uip_connr->len == 0 )
    a508:	8a23      	ldrh	r3, [r4, #16]
    a50a:	2b00      	cmp	r3, #0
    a50c:	d114      	bne.n	a538 <uip_process+0x1ac8>
					{
						/* The application cannot send more than what is allowed by
		 				the mss (the minumum of the MSS and the available
		 				window). */
						if( uip_slen > uip_connr->mss )
    a50e:	8a62      	ldrh	r2, [r4, #18]
    a510:	f64c 33e4 	movw	r3, #52196	; 0xcbe4
    a514:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a518:	881b      	ldrh	r3, [r3, #0]
    a51a:	429a      	cmp	r2, r3
    a51c:	d205      	bcs.n	a52a <uip_process+0x1aba>
						{
							uip_slen = uip_connr->mss;
    a51e:	8a62      	ldrh	r2, [r4, #18]
    a520:	f64c 33e4 	movw	r3, #52196	; 0xcbe4
    a524:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a528:	801a      	strh	r2, [r3, #0]
						}

						/* Remember how much data we send out now so that we know
		 				when everything has been acknowledged. */
						uip_connr->len = uip_slen;
    a52a:	f64c 33e4 	movw	r3, #52196	; 0xcbe4
    a52e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a532:	881b      	ldrh	r3, [r3, #0]
    a534:	8223      	strh	r3, [r4, #16]
    a536:	e005      	b.n	a544 <uip_process+0x1ad4>
					else
					{
						/* If the application already had unacknowledged data, we
		 				make sure that the application does not send (i.e.,
		 				retransmit) out more than it previously sent out. */
						uip_slen = uip_connr->len;
    a538:	8a22      	ldrh	r2, [r4, #16]
    a53a:	f64c 33e4 	movw	r3, #52196	; 0xcbe4
    a53e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a542:	801a      	strh	r2, [r3, #0]
					}
				}

				uip_connr->nrtx = 0;
    a544:	f04f 0300 	mov.w	r3, #0
    a548:	76e3      	strb	r3, [r4, #27]
apprexmit:
				uip_appdata = uip_sappdata;
    a54a:	f64a 335c 	movw	r3, #43868	; 0xab5c
    a54e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a552:	681a      	ldr	r2, [r3, #0]
    a554:	f64a 3368 	movw	r3, #43880	; 0xab68
    a558:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a55c:	601a      	str	r2, [r3, #0]

				/* If the application has data to be sent, or if the incoming
		 		packet had new data in it, we must send out a packet. */
				if( uip_slen > 0 && uip_connr->len > 0 )
    a55e:	f64c 33e4 	movw	r3, #52196	; 0xcbe4
    a562:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a566:	881b      	ldrh	r3, [r3, #0]
    a568:	2b00      	cmp	r3, #0
    a56a:	d017      	beq.n	a59c <uip_process+0x1b2c>
    a56c:	8a23      	ldrh	r3, [r4, #16]
    a56e:	2b00      	cmp	r3, #0
    a570:	d014      	beq.n	a59c <uip_process+0x1b2c>
				{
					/* Add the length of the IP and TCP headers. */
					uip_len = uip_connr->len + UIP_TCPIP_HLEN;
    a572:	8a23      	ldrh	r3, [r4, #16]
    a574:	f103 0328 	add.w	r3, r3, #40	; 0x28
    a578:	b29a      	uxth	r2, r3
    a57a:	f64a 3358 	movw	r3, #43864	; 0xab58
    a57e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a582:	801a      	strh	r2, [r3, #0]

					/* We always set the ACK flag in response packets. */
					BUF->flags = TCP_ACK | TCP_PSH;
    a584:	f240 6390 	movw	r3, #1680	; 0x690
    a588:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a58c:	681b      	ldr	r3, [r3, #0]
    a58e:	f103 030e 	add.w	r3, r3, #14
    a592:	f04f 0218 	mov.w	r2, #24
    a596:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

					/* Send the packet. */
					goto tcp_send_noopts;
    a59a:	e0ef      	b.n	a77c <uip_process+0x1d0c>
				}

				/* If there is no data to send, just send out a pure ACK if
				there is newdata. */
				if( uip_flags & UIP_NEWDATA )
    a59c:	f64a 3364 	movw	r3, #43876	; 0xab64
    a5a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a5a4:	781b      	ldrb	r3, [r3, #0]
    a5a6:	f003 0302 	and.w	r3, r3, #2
    a5aa:	2b00      	cmp	r3, #0
    a5ac:	f000 831d 	beq.w	abea <uip_process+0x217a>
				{
					uip_len = UIP_TCPIP_HLEN;
    a5b0:	f64a 3358 	movw	r3, #43864	; 0xab58
    a5b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a5b8:	f04f 0228 	mov.w	r2, #40	; 0x28
    a5bc:	801a      	strh	r2, [r3, #0]
					BUF->flags = TCP_ACK;
    a5be:	f240 6390 	movw	r3, #1680	; 0x690
    a5c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a5c6:	681b      	ldr	r3, [r3, #0]
    a5c8:	f103 030e 	add.w	r3, r3, #14
    a5cc:	f04f 0210 	mov.w	r2, #16
    a5d0:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
					goto tcp_send_noopts;
    a5d4:	e0d2      	b.n	a77c <uip_process+0x1d0c>
			goto drop;

		case UIP_LAST_ACK:
			/* We can close this connection if the peer has acknowledged our
			FIN. This is indicated by the UIP_ACKDATA flag. */
			if( uip_flags & UIP_ACKDATA )
    a5d6:	f64a 3364 	movw	r3, #43876	; 0xab64
    a5da:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a5de:	781b      	ldrb	r3, [r3, #0]
    a5e0:	f003 0301 	and.w	r3, r3, #1
    a5e4:	b2db      	uxtb	r3, r3
    a5e6:	2b00      	cmp	r3, #0
    a5e8:	d00b      	beq.n	a602 <uip_process+0x1b92>
			{
				uip_connr->tcpstateflags = UIP_CLOSED;
    a5ea:	f04f 0300 	mov.w	r3, #0
    a5ee:	7663      	strb	r3, [r4, #25]
				uip_flags = UIP_CLOSE;
    a5f0:	f64a 3364 	movw	r3, #43876	; 0xab64
    a5f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a5f8:	f04f 0210 	mov.w	r2, #16
    a5fc:	701a      	strb	r2, [r3, #0]
				UIP_APPCALL();
    a5fe:	f001 ff3d 	bl	c47c <httpd_appcall>
			}

			break;
    a602:	bf00      	nop
				uip_connr->tcpstateflags = UIP_TIME_WAIT;
				uip_connr->timer = 0;
			}
	}

	goto drop;
    a604:	e2f8      	b.n	abf8 <uip_process+0x2188>

		case UIP_FIN_WAIT_1:
			/* The application has closed the connection, but the remote host
			hasn't closed its end yet. Thus we do nothing but wait for a
			FIN from the other side. */
			if( uip_len > 0 )
    a606:	f64a 3358 	movw	r3, #43864	; 0xab58
    a60a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a60e:	881b      	ldrh	r3, [r3, #0]
    a610:	2b00      	cmp	r3, #0
    a612:	d007      	beq.n	a624 <uip_process+0x1bb4>
			{
				uip_add_rcv_nxt( uip_len );
    a614:	f64a 3358 	movw	r3, #43864	; 0xab58
    a618:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a61c:	881b      	ldrh	r3, [r3, #0]
    a61e:	4618      	mov	r0, r3
    a620:	f7fe f9e4 	bl	89ec <uip_add_rcv_nxt>
			}

			if( BUF->flags & TCP_FIN )
    a624:	f240 6390 	movw	r3, #1680	; 0x690
    a628:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a62c:	681b      	ldr	r3, [r3, #0]
    a62e:	f103 030e 	add.w	r3, r3, #14
    a632:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    a636:	f003 0301 	and.w	r3, r3, #1
    a63a:	b2db      	uxtb	r3, r3
    a63c:	2b00      	cmp	r3, #0
    a63e:	d024      	beq.n	a68a <uip_process+0x1c1a>
			{
				if( uip_flags & UIP_ACKDATA )
    a640:	f64a 3364 	movw	r3, #43876	; 0xab64
    a644:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a648:	781b      	ldrb	r3, [r3, #0]
    a64a:	f003 0301 	and.w	r3, r3, #1
    a64e:	b2db      	uxtb	r3, r3
    a650:	2b00      	cmp	r3, #0
    a652:	d009      	beq.n	a668 <uip_process+0x1bf8>
				{
					uip_connr->tcpstateflags = UIP_TIME_WAIT;
    a654:	f04f 0307 	mov.w	r3, #7
    a658:	7663      	strb	r3, [r4, #25]
					uip_connr->timer = 0;
    a65a:	f04f 0300 	mov.w	r3, #0
    a65e:	76a3      	strb	r3, [r4, #26]
					uip_connr->len = 0;
    a660:	f04f 0300 	mov.w	r3, #0
    a664:	8223      	strh	r3, [r4, #16]
    a666:	e002      	b.n	a66e <uip_process+0x1bfe>
				}
				else
				{
					uip_connr->tcpstateflags = UIP_CLOSING;
    a668:	f04f 0306 	mov.w	r3, #6
    a66c:	7663      	strb	r3, [r4, #25]
				}

				uip_add_rcv_nxt( 1 );
    a66e:	f04f 0001 	mov.w	r0, #1
    a672:	f7fe f9bb 	bl	89ec <uip_add_rcv_nxt>
				uip_flags = UIP_CLOSE;
    a676:	f64a 3364 	movw	r3, #43876	; 0xab64
    a67a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a67e:	f04f 0210 	mov.w	r2, #16
    a682:	701a      	strb	r2, [r3, #0]
				UIP_APPCALL();
    a684:	f001 fefa 	bl	c47c <httpd_appcall>
				goto tcp_send_ack;
    a688:	e066      	b.n	a758 <uip_process+0x1ce8>
			}
			else if( uip_flags & UIP_ACKDATA )
    a68a:	f64a 3364 	movw	r3, #43876	; 0xab64
    a68e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a692:	781b      	ldrb	r3, [r3, #0]
    a694:	f003 0301 	and.w	r3, r3, #1
    a698:	b2db      	uxtb	r3, r3
    a69a:	2b00      	cmp	r3, #0
    a69c:	d006      	beq.n	a6ac <uip_process+0x1c3c>
			{
				uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
    a69e:	f04f 0305 	mov.w	r3, #5
    a6a2:	7663      	strb	r3, [r4, #25]
				uip_connr->len = 0;
    a6a4:	f04f 0300 	mov.w	r3, #0
    a6a8:	8223      	strh	r3, [r4, #16]
				goto drop;
    a6aa:	e2a5      	b.n	abf8 <uip_process+0x2188>
			}

			if( uip_len > 0 )
    a6ac:	f64a 3358 	movw	r3, #43864	; 0xab58
    a6b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a6b4:	881b      	ldrh	r3, [r3, #0]
    a6b6:	2b00      	cmp	r3, #0
    a6b8:	f000 8299 	beq.w	abee <uip_process+0x217e>
			{
				goto tcp_send_ack;
    a6bc:	e04c      	b.n	a758 <uip_process+0x1ce8>
			}

			goto drop;

		case UIP_FIN_WAIT_2:
			if( uip_len > 0 )
    a6be:	f64a 3358 	movw	r3, #43864	; 0xab58
    a6c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a6c6:	881b      	ldrh	r3, [r3, #0]
    a6c8:	2b00      	cmp	r3, #0
    a6ca:	d007      	beq.n	a6dc <uip_process+0x1c6c>
			{
				uip_add_rcv_nxt( uip_len );
    a6cc:	f64a 3358 	movw	r3, #43864	; 0xab58
    a6d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a6d4:	881b      	ldrh	r3, [r3, #0]
    a6d6:	4618      	mov	r0, r3
    a6d8:	f7fe f988 	bl	89ec <uip_add_rcv_nxt>
			}

			if( BUF->flags & TCP_FIN )
    a6dc:	f240 6390 	movw	r3, #1680	; 0x690
    a6e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a6e4:	681b      	ldr	r3, [r3, #0]
    a6e6:	f103 030e 	add.w	r3, r3, #14
    a6ea:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    a6ee:	f003 0301 	and.w	r3, r3, #1
    a6f2:	b2db      	uxtb	r3, r3
    a6f4:	2b00      	cmp	r3, #0
    a6f6:	d013      	beq.n	a720 <uip_process+0x1cb0>
			{
				uip_connr->tcpstateflags = UIP_TIME_WAIT;
    a6f8:	f04f 0307 	mov.w	r3, #7
    a6fc:	7663      	strb	r3, [r4, #25]
				uip_connr->timer = 0;
    a6fe:	f04f 0300 	mov.w	r3, #0
    a702:	76a3      	strb	r3, [r4, #26]
				uip_add_rcv_nxt( 1 );
    a704:	f04f 0001 	mov.w	r0, #1
    a708:	f7fe f970 	bl	89ec <uip_add_rcv_nxt>
				uip_flags = UIP_CLOSE;
    a70c:	f64a 3364 	movw	r3, #43876	; 0xab64
    a710:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a714:	f04f 0210 	mov.w	r2, #16
    a718:	701a      	strb	r2, [r3, #0]
				UIP_APPCALL();
    a71a:	f001 feaf 	bl	c47c <httpd_appcall>
				goto tcp_send_ack;
    a71e:	e01b      	b.n	a758 <uip_process+0x1ce8>
			}

			if( uip_len > 0 )
    a720:	f64a 3358 	movw	r3, #43864	; 0xab58
    a724:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a728:	881b      	ldrh	r3, [r3, #0]
    a72a:	2b00      	cmp	r3, #0
    a72c:	f000 8261 	beq.w	abf2 <uip_process+0x2182>
			{
				goto tcp_send_ack;
    a730:	e012      	b.n	a758 <uip_process+0x1ce8>

		case UIP_TIME_WAIT:
			goto tcp_send_ack;

		case UIP_CLOSING:
			if( uip_flags & UIP_ACKDATA )
    a732:	f64a 3364 	movw	r3, #43876	; 0xab64
    a736:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a73a:	781b      	ldrb	r3, [r3, #0]
    a73c:	f003 0301 	and.w	r3, r3, #1
    a740:	b2db      	uxtb	r3, r3
    a742:	2b00      	cmp	r3, #0
    a744:	f000 8257 	beq.w	abf6 <uip_process+0x2186>
			{
				uip_connr->tcpstateflags = UIP_TIME_WAIT;
    a748:	f04f 0307 	mov.w	r3, #7
    a74c:	7663      	strb	r3, [r4, #25]
				uip_connr->timer = 0;
    a74e:	f04f 0300 	mov.w	r3, #0
    a752:	76a3      	strb	r3, [r4, #26]
			}
	}

	goto drop;
    a754:	e250      	b.n	abf8 <uip_process+0x2188>
			}

			goto drop;

		case UIP_TIME_WAIT:
			goto tcp_send_ack;
    a756:	bf00      	nop
	goto drop;

	/* We jump here when we are ready to send the packet, and just want
	 to set the appropriate TCP sequence numbers in the TCP header. */
tcp_send_ack:
	BUF->flags = TCP_ACK;
    a758:	f240 6390 	movw	r3, #1680	; 0x690
    a75c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a760:	681b      	ldr	r3, [r3, #0]
    a762:	f103 030e 	add.w	r3, r3, #14
    a766:	f04f 0210 	mov.w	r2, #16
    a76a:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

tcp_send_nodata:
	uip_len = UIP_IPTCPH_LEN;
    a76e:	f64a 3358 	movw	r3, #43864	; 0xab58
    a772:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a776:	f04f 0228 	mov.w	r2, #40	; 0x28
    a77a:	801a      	strh	r2, [r3, #0]

tcp_send_noopts:
	BUF->tcpoffset = ( UIP_TCPH_LEN / 4 ) << 4;
    a77c:	f240 6390 	movw	r3, #1680	; 0x690
    a780:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a784:	681b      	ldr	r3, [r3, #0]
    a786:	f103 030e 	add.w	r3, r3, #14
    a78a:	f04f 0250 	mov.w	r2, #80	; 0x50
    a78e:	f883 2020 	strb.w	r2, [r3, #32]
	/* We're done with the input processing. We are now ready to send a
	reply. Our job is to fill in all the fields of the TCP and IP
	headers before calculating the checksum and finally send the
	packet. */
tcp_send:
	BUF->ackno[ 0 ] = uip_connr->rcv_nxt[ 0 ];
    a792:	f240 6390 	movw	r3, #1680	; 0x690
    a796:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a79a:	681b      	ldr	r3, [r3, #0]
    a79c:	f103 030e 	add.w	r3, r3, #14
    a7a0:	7a22      	ldrb	r2, [r4, #8]
    a7a2:	771a      	strb	r2, [r3, #28]
	BUF->ackno[ 1 ] = uip_connr->rcv_nxt[ 1 ];
    a7a4:	f240 6390 	movw	r3, #1680	; 0x690
    a7a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a7ac:	681b      	ldr	r3, [r3, #0]
    a7ae:	f103 030e 	add.w	r3, r3, #14
    a7b2:	7a62      	ldrb	r2, [r4, #9]
    a7b4:	775a      	strb	r2, [r3, #29]
	BUF->ackno[ 2 ] = uip_connr->rcv_nxt[ 2 ];
    a7b6:	f240 6390 	movw	r3, #1680	; 0x690
    a7ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a7be:	681b      	ldr	r3, [r3, #0]
    a7c0:	f103 030e 	add.w	r3, r3, #14
    a7c4:	7aa2      	ldrb	r2, [r4, #10]
    a7c6:	779a      	strb	r2, [r3, #30]
	BUF->ackno[ 3 ] = uip_connr->rcv_nxt[ 3 ];
    a7c8:	f240 6390 	movw	r3, #1680	; 0x690
    a7cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a7d0:	681b      	ldr	r3, [r3, #0]
    a7d2:	f103 030e 	add.w	r3, r3, #14
    a7d6:	7ae2      	ldrb	r2, [r4, #11]
    a7d8:	77da      	strb	r2, [r3, #31]

	BUF->seqno[ 0 ] = uip_connr->snd_nxt[ 0 ];
    a7da:	f240 6390 	movw	r3, #1680	; 0x690
    a7de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a7e2:	681b      	ldr	r3, [r3, #0]
    a7e4:	f103 030e 	add.w	r3, r3, #14
    a7e8:	7b22      	ldrb	r2, [r4, #12]
    a7ea:	761a      	strb	r2, [r3, #24]
	BUF->seqno[ 1 ] = uip_connr->snd_nxt[ 1 ];
    a7ec:	f240 6390 	movw	r3, #1680	; 0x690
    a7f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a7f4:	681b      	ldr	r3, [r3, #0]
    a7f6:	f103 030e 	add.w	r3, r3, #14
    a7fa:	7b62      	ldrb	r2, [r4, #13]
    a7fc:	765a      	strb	r2, [r3, #25]
	BUF->seqno[ 2 ] = uip_connr->snd_nxt[ 2 ];
    a7fe:	f240 6390 	movw	r3, #1680	; 0x690
    a802:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a806:	681b      	ldr	r3, [r3, #0]
    a808:	f103 030e 	add.w	r3, r3, #14
    a80c:	7ba2      	ldrb	r2, [r4, #14]
    a80e:	769a      	strb	r2, [r3, #26]
	BUF->seqno[ 3 ] = uip_connr->snd_nxt[ 3 ];
    a810:	f240 6390 	movw	r3, #1680	; 0x690
    a814:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a818:	681b      	ldr	r3, [r3, #0]
    a81a:	f103 030e 	add.w	r3, r3, #14
    a81e:	7be2      	ldrb	r2, [r4, #15]
    a820:	76da      	strb	r2, [r3, #27]

	BUF->proto = UIP_PROTO_TCP;
    a822:	f240 6390 	movw	r3, #1680	; 0x690
    a826:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a82a:	681b      	ldr	r3, [r3, #0]
    a82c:	f103 030e 	add.w	r3, r3, #14
    a830:	f04f 0206 	mov.w	r2, #6
    a834:	725a      	strb	r2, [r3, #9]

	BUF->srcport = uip_connr->lport;
    a836:	f240 6390 	movw	r3, #1680	; 0x690
    a83a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a83e:	681b      	ldr	r3, [r3, #0]
    a840:	f103 030e 	add.w	r3, r3, #14
    a844:	88a2      	ldrh	r2, [r4, #4]
    a846:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    a84a:	f04f 0000 	mov.w	r0, #0
    a84e:	ea40 0101 	orr.w	r1, r0, r1
    a852:	7519      	strb	r1, [r3, #20]
    a854:	ea4f 2212 	mov.w	r2, r2, lsr #8
    a858:	b292      	uxth	r2, r2
    a85a:	f04f 0100 	mov.w	r1, #0
    a85e:	ea41 0202 	orr.w	r2, r1, r2
    a862:	755a      	strb	r2, [r3, #21]
	BUF->destport = uip_connr->rport;
    a864:	f240 6390 	movw	r3, #1680	; 0x690
    a868:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a86c:	681b      	ldr	r3, [r3, #0]
    a86e:	f103 030e 	add.w	r3, r3, #14
    a872:	88e2      	ldrh	r2, [r4, #6]
    a874:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    a878:	f04f 0000 	mov.w	r0, #0
    a87c:	ea40 0101 	orr.w	r1, r0, r1
    a880:	7599      	strb	r1, [r3, #22]
    a882:	ea4f 2212 	mov.w	r2, r2, lsr #8
    a886:	b292      	uxth	r2, r2
    a888:	f04f 0100 	mov.w	r1, #0
    a88c:	ea41 0202 	orr.w	r2, r1, r2
    a890:	75da      	strb	r2, [r3, #23]

	uip_ipaddr_copy( &BUF->srcipaddr, &uip_hostaddr );
    a892:	f240 6390 	movw	r3, #1680	; 0x690
    a896:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a89a:	681b      	ldr	r3, [r3, #0]
    a89c:	f103 020e 	add.w	r2, r3, #14
    a8a0:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    a8a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a8a8:	781b      	ldrb	r3, [r3, #0]
    a8aa:	7313      	strb	r3, [r2, #12]
    a8ac:	f240 6390 	movw	r3, #1680	; 0x690
    a8b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a8b4:	681b      	ldr	r3, [r3, #0]
    a8b6:	f103 020e 	add.w	r2, r3, #14
    a8ba:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    a8be:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a8c2:	785b      	ldrb	r3, [r3, #1]
    a8c4:	7353      	strb	r3, [r2, #13]
    a8c6:	f240 6390 	movw	r3, #1680	; 0x690
    a8ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a8ce:	681b      	ldr	r3, [r3, #0]
    a8d0:	f103 020e 	add.w	r2, r3, #14
    a8d4:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    a8d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a8dc:	789b      	ldrb	r3, [r3, #2]
    a8de:	7393      	strb	r3, [r2, #14]
    a8e0:	f240 6390 	movw	r3, #1680	; 0x690
    a8e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a8e8:	681b      	ldr	r3, [r3, #0]
    a8ea:	f103 020e 	add.w	r2, r3, #14
    a8ee:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    a8f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a8f6:	78db      	ldrb	r3, [r3, #3]
    a8f8:	73d3      	strb	r3, [r2, #15]
	uip_ipaddr_copy( &BUF->destipaddr, &uip_connr->ripaddr );
    a8fa:	f240 6390 	movw	r3, #1680	; 0x690
    a8fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a902:	681b      	ldr	r3, [r3, #0]
    a904:	f103 030e 	add.w	r3, r3, #14
    a908:	7822      	ldrb	r2, [r4, #0]
    a90a:	741a      	strb	r2, [r3, #16]
    a90c:	f240 6390 	movw	r3, #1680	; 0x690
    a910:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a914:	681b      	ldr	r3, [r3, #0]
    a916:	f103 030e 	add.w	r3, r3, #14
    a91a:	7862      	ldrb	r2, [r4, #1]
    a91c:	745a      	strb	r2, [r3, #17]
    a91e:	f240 6390 	movw	r3, #1680	; 0x690
    a922:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a926:	681b      	ldr	r3, [r3, #0]
    a928:	f103 030e 	add.w	r3, r3, #14
    a92c:	78a2      	ldrb	r2, [r4, #2]
    a92e:	749a      	strb	r2, [r3, #18]
    a930:	f240 6390 	movw	r3, #1680	; 0x690
    a934:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a938:	681b      	ldr	r3, [r3, #0]
    a93a:	f103 030e 	add.w	r3, r3, #14
    a93e:	78e2      	ldrb	r2, [r4, #3]
    a940:	74da      	strb	r2, [r3, #19]

	if( uip_connr->tcpstateflags & UIP_STOPPED )
    a942:	7e63      	ldrb	r3, [r4, #25]
    a944:	f003 0310 	and.w	r3, r3, #16
    a948:	2b00      	cmp	r3, #0
    a94a:	d016      	beq.n	a97a <uip_process+0x1f0a>
	{
		/* If the connection has issued uip_stop(), we advertise a zero
		window so that the remote host will stop sending data. */
		BUF->wnd[ 0 ] = BUF->wnd[ 1 ] = 0;
    a94c:	f240 6390 	movw	r3, #1680	; 0x690
    a950:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a954:	681b      	ldr	r3, [r3, #0]
    a956:	f103 020e 	add.w	r2, r3, #14
    a95a:	f240 6390 	movw	r3, #1680	; 0x690
    a95e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a962:	681b      	ldr	r3, [r3, #0]
    a964:	f103 030e 	add.w	r3, r3, #14
    a968:	f04f 0100 	mov.w	r1, #0
    a96c:	f883 1023 	strb.w	r1, [r3, #35]	; 0x23
    a970:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
    a974:	f882 3022 	strb.w	r3, [r2, #34]	; 0x22
    a978:	e015      	b.n	a9a6 <uip_process+0x1f36>
	}
	else
	{
		BUF->wnd[ 0 ] = ( (UIP_RECEIVE_WINDOW) >> 8 );
    a97a:	f240 6390 	movw	r3, #1680	; 0x690
    a97e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a982:	681b      	ldr	r3, [r3, #0]
    a984:	f103 030e 	add.w	r3, r3, #14
    a988:	f04f 0205 	mov.w	r2, #5
    a98c:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
		BUF->wnd[ 1 ] = ( (UIP_RECEIVE_WINDOW) & 0xff );
    a990:	f240 6390 	movw	r3, #1680	; 0x690
    a994:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a998:	681b      	ldr	r3, [r3, #0]
    a99a:	f103 030e 	add.w	r3, r3, #14
    a99e:	f06f 026d 	mvn.w	r2, #109	; 0x6d
    a9a2:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
	}

tcp_send_noconn:

	BUF->ttl = UIP_TTL;
    a9a6:	f240 6390 	movw	r3, #1680	; 0x690
    a9aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a9ae:	681b      	ldr	r3, [r3, #0]
    a9b0:	f103 030e 	add.w	r3, r3, #14
    a9b4:	f04f 0240 	mov.w	r2, #64	; 0x40
    a9b8:	721a      	strb	r2, [r3, #8]
		/* For IPv6, the IP length field does not include the IPv6 IP header
		 length. */
		BUF->len[ 0 ] = ( (uip_len - UIP_IPH_LEN) >> 8 );
		BUF->len[ 1 ] = ( (uip_len - UIP_IPH_LEN) & 0xff );
	#else /* UIP_CONF_IPV6 */
		BUF->len[ 0 ] = ( uip_len >> 8 );
    a9ba:	f240 6390 	movw	r3, #1680	; 0x690
    a9be:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a9c2:	681b      	ldr	r3, [r3, #0]
    a9c4:	f103 020e 	add.w	r2, r3, #14
    a9c8:	f64a 3358 	movw	r3, #43864	; 0xab58
    a9cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a9d0:	881b      	ldrh	r3, [r3, #0]
    a9d2:	ea4f 2313 	mov.w	r3, r3, lsr #8
    a9d6:	b29b      	uxth	r3, r3
    a9d8:	b2db      	uxtb	r3, r3
    a9da:	7093      	strb	r3, [r2, #2]
		BUF->len[ 1 ] = ( uip_len & 0xff );
    a9dc:	f240 6390 	movw	r3, #1680	; 0x690
    a9e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a9e4:	681b      	ldr	r3, [r3, #0]
    a9e6:	f103 020e 	add.w	r2, r3, #14
    a9ea:	f64a 3358 	movw	r3, #43864	; 0xab58
    a9ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a9f2:	881b      	ldrh	r3, [r3, #0]
    a9f4:	b2db      	uxtb	r3, r3
    a9f6:	70d3      	strb	r3, [r2, #3]
	#endif /* UIP_CONF_IPV6 */

	BUF->urgp[ 0 ] = BUF->urgp[ 1 ] = 0;
    a9f8:	f240 6390 	movw	r3, #1680	; 0x690
    a9fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aa00:	681b      	ldr	r3, [r3, #0]
    aa02:	f103 020e 	add.w	r2, r3, #14
    aa06:	f240 6390 	movw	r3, #1680	; 0x690
    aa0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aa0e:	681b      	ldr	r3, [r3, #0]
    aa10:	f103 030e 	add.w	r3, r3, #14
    aa14:	f04f 0100 	mov.w	r1, #0
    aa18:	f883 1027 	strb.w	r1, [r3, #39]	; 0x27
    aa1c:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
    aa20:	f882 3026 	strb.w	r3, [r2, #38]	; 0x26

	/* Calculate TCP checksum. */
	BUF->tcpchksum = 0;
    aa24:	f240 6390 	movw	r3, #1680	; 0x690
    aa28:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aa2c:	681b      	ldr	r3, [r3, #0]
    aa2e:	f103 030e 	add.w	r3, r3, #14
    aa32:	f04f 0200 	mov.w	r2, #0
    aa36:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
    aa3a:	f04f 0200 	mov.w	r2, #0
    aa3e:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
	BUF->tcpchksum = ~( uip_tcpchksum() );
    aa42:	f240 6390 	movw	r3, #1680	; 0x690
    aa46:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aa4a:	681b      	ldr	r3, [r3, #0]
    aa4c:	f103 040e 	add.w	r4, r3, #14
    aa50:	f7fd fddc 	bl	860c <uip_tcpchksum>
    aa54:	4603      	mov	r3, r0
    aa56:	ea6f 0303 	mvn.w	r3, r3
    aa5a:	b29b      	uxth	r3, r3
    aa5c:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    aa60:	f04f 0100 	mov.w	r1, #0
    aa64:	ea41 0202 	orr.w	r2, r1, r2
    aa68:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
    aa6c:	ea4f 2313 	mov.w	r3, r3, lsr #8
    aa70:	b29b      	uxth	r3, r3
    aa72:	f04f 0200 	mov.w	r2, #0
    aa76:	ea42 0303 	orr.w	r3, r2, r3
    aa7a:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
	#if UIP_CONF_IPV6
		BUF->vtc = 0x60;
		BUF->tcflow = 0x00;
		BUF->flow = 0x00;
	#else /* UIP_CONF_IPV6 */
		BUF->vhl = 0x45;
    aa7e:	f240 6390 	movw	r3, #1680	; 0x690
    aa82:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aa86:	681b      	ldr	r3, [r3, #0]
    aa88:	f103 030e 	add.w	r3, r3, #14
    aa8c:	f04f 0245 	mov.w	r2, #69	; 0x45
    aa90:	701a      	strb	r2, [r3, #0]
		BUF->tos = 0;
    aa92:	f240 6390 	movw	r3, #1680	; 0x690
    aa96:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aa9a:	681b      	ldr	r3, [r3, #0]
    aa9c:	f103 030e 	add.w	r3, r3, #14
    aaa0:	f04f 0200 	mov.w	r2, #0
    aaa4:	705a      	strb	r2, [r3, #1]
		BUF->ipoffset[ 0 ] = BUF->ipoffset[ 1 ] = 0;
    aaa6:	f240 6390 	movw	r3, #1680	; 0x690
    aaaa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aaae:	681b      	ldr	r3, [r3, #0]
    aab0:	f103 020e 	add.w	r2, r3, #14
    aab4:	f240 6390 	movw	r3, #1680	; 0x690
    aab8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aabc:	681b      	ldr	r3, [r3, #0]
    aabe:	f103 030e 	add.w	r3, r3, #14
    aac2:	f04f 0100 	mov.w	r1, #0
    aac6:	71d9      	strb	r1, [r3, #7]
    aac8:	79db      	ldrb	r3, [r3, #7]
    aaca:	7193      	strb	r3, [r2, #6]
		++ipid;
    aacc:	f642 736c 	movw	r3, #12140	; 0x2f6c
    aad0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aad4:	881b      	ldrh	r3, [r3, #0]
    aad6:	f103 0301 	add.w	r3, r3, #1
    aada:	b29a      	uxth	r2, r3
    aadc:	f642 736c 	movw	r3, #12140	; 0x2f6c
    aae0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aae4:	801a      	strh	r2, [r3, #0]
		BUF->ipid[ 0 ] = ipid >> 8;
    aae6:	f240 6390 	movw	r3, #1680	; 0x690
    aaea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aaee:	681b      	ldr	r3, [r3, #0]
    aaf0:	f103 020e 	add.w	r2, r3, #14
    aaf4:	f642 736c 	movw	r3, #12140	; 0x2f6c
    aaf8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aafc:	881b      	ldrh	r3, [r3, #0]
    aafe:	ea4f 2313 	mov.w	r3, r3, lsr #8
    ab02:	b29b      	uxth	r3, r3
    ab04:	b2db      	uxtb	r3, r3
    ab06:	7113      	strb	r3, [r2, #4]
		BUF->ipid[ 1 ] = ipid & 0xff;
    ab08:	f240 6390 	movw	r3, #1680	; 0x690
    ab0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ab10:	681b      	ldr	r3, [r3, #0]
    ab12:	f103 020e 	add.w	r2, r3, #14
    ab16:	f642 736c 	movw	r3, #12140	; 0x2f6c
    ab1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ab1e:	881b      	ldrh	r3, [r3, #0]
    ab20:	b2db      	uxtb	r3, r3
    ab22:	7153      	strb	r3, [r2, #5]

		/* Calculate IP checksum. */
		BUF->ipchksum = 0;
    ab24:	f240 6390 	movw	r3, #1680	; 0x690
    ab28:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ab2c:	681b      	ldr	r3, [r3, #0]
    ab2e:	f103 030e 	add.w	r3, r3, #14
    ab32:	f04f 0200 	mov.w	r2, #0
    ab36:	729a      	strb	r2, [r3, #10]
    ab38:	f04f 0200 	mov.w	r2, #0
    ab3c:	72da      	strb	r2, [r3, #11]
		BUF->ipchksum = ~( uip_ipchksum() );
    ab3e:	f240 6390 	movw	r3, #1680	; 0x690
    ab42:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ab46:	681b      	ldr	r3, [r3, #0]
    ab48:	f103 040e 	add.w	r4, r3, #14
    ab4c:	f7fd fce6 	bl	851c <uip_ipchksum>
    ab50:	4603      	mov	r3, r0
    ab52:	ea6f 0303 	mvn.w	r3, r3
    ab56:	b29b      	uxth	r3, r3
    ab58:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    ab5c:	f04f 0100 	mov.w	r1, #0
    ab60:	ea41 0202 	orr.w	r2, r1, r2
    ab64:	72a2      	strb	r2, [r4, #10]
    ab66:	ea4f 2313 	mov.w	r3, r3, lsr #8
    ab6a:	b29b      	uxth	r3, r3
    ab6c:	f04f 0200 	mov.w	r2, #0
    ab70:	ea42 0303 	orr.w	r3, r2, r3
    ab74:	72e3      	strb	r3, [r4, #11]

		//DEBUG_PRINTF( "uip ip_send_nolen: chkecum 0x%04x\n", uip_ipchksum() );
	#endif /* UIP_CONF_IPV6 */

	UIP_STAT( ++uip_stat.tcp.sent );
    ab76:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    ab7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ab7e:	8c1b      	ldrh	r3, [r3, #32]
    ab80:	f103 0301 	add.w	r3, r3, #1
    ab84:	b29a      	uxth	r2, r3
    ab86:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    ab8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ab8e:	841a      	strh	r2, [r3, #32]
	#if UIP_CONF_IPV6
send :
	#endif /* UIP_CONF_IPV6 */

	//DEBUG_PRINTF( "Sending packet with length %d (%d)\n", uip_len, (BUF->len[ 0 ] << 8) | BUF->len[ 1 ] );
	UIP_STAT( ++uip_stat.ip.sent );
    ab90:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    ab94:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ab98:	885b      	ldrh	r3, [r3, #2]
    ab9a:	f103 0301 	add.w	r3, r3, #1
    ab9e:	b29a      	uxth	r2, r3
    aba0:	f64c 33a4 	movw	r3, #52132	; 0xcba4
    aba4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aba8:	805a      	strh	r2, [r3, #2]

	/* Return and let the caller do the actual transmission. */
	uip_flags = 0;
    abaa:	f64a 3364 	movw	r3, #43876	; 0xab64
    abae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    abb2:	f04f 0200 	mov.w	r2, #0
    abb6:	701a      	strb	r2, [r3, #0]
	return;
    abb8:	e02d      	b.n	ac16 <uip_process+0x21a6>
			uip_flags = UIP_POLL;
			UIP_APPCALL();
			goto appsend;
		}

		goto drop;
    abba:	bf00      	nop
    abbc:	e01c      	b.n	abf8 <uip_process+0x2188>
    abbe:	bf00      	nop
    abc0:	e01a      	b.n	abf8 <uip_process+0x2188>
				UIP_APPCALL();
				goto appsend;
			}
		}

		goto drop;
    abc2:	bf00      	nop
    abc4:	e018      	b.n	abf8 <uip_process+0x2188>
    abc6:	bf00      	nop
    abc8:	e016      	b.n	abf8 <uip_process+0x2188>
    abca:	bf00      	nop
    abcc:	e014      	b.n	abf8 <uip_process+0x2188>
    abce:	bf00      	nop
    abd0:	e012      	b.n	abf8 <uip_process+0x2188>
		#endif /* UIP_CONF_IPV6 */
	}
	else
	{
		UIP_LOG( "ip: packet shorter than reported in IP header." );
		goto drop;
    abd2:	bf00      	nop
    abd4:	e010      	b.n	abf8 <uip_process+0x2188>

reset:
	/* We do not send resets in response to resets. */
	if( BUF->flags & TCP_RST )
	{
		goto drop;
    abd6:	bf00      	nop
    abd8:	e00e      	b.n	abf8 <uip_process+0x2188>
				uip_connr->tcpstateflags = UIP_TIME_WAIT;
				uip_connr->timer = 0;
			}
	}

	goto drop;
    abda:	bf00      	nop
    abdc:	e00c      	b.n	abf8 <uip_process+0x2188>
				uip_slen = 0;
				UIP_APPCALL();
				goto appsend;
			}

			goto drop;
    abde:	bf00      	nop
    abe0:	e00a      	b.n	abf8 <uip_process+0x2188>
			sequence numbers will be screwed up. */
			if( BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED) )
			{
				if( uip_outstanding(uip_connr) )
				{
					goto drop;
    abe2:	bf00      	nop
    abe4:	e008      	b.n	abf8 <uip_process+0x2188>
					BUF->flags = TCP_ACK;
					goto tcp_send_noopts;
				}
			}

			goto drop;
    abe6:	bf00      	nop
    abe8:	e006      	b.n	abf8 <uip_process+0x2188>
    abea:	bf00      	nop
    abec:	e004      	b.n	abf8 <uip_process+0x2188>
			if( uip_len > 0 )
			{
				goto tcp_send_ack;
			}

			goto drop;
    abee:	bf00      	nop
    abf0:	e002      	b.n	abf8 <uip_process+0x2188>
			if( uip_len > 0 )
			{
				goto tcp_send_ack;
			}

			goto drop;
    abf2:	bf00      	nop
    abf4:	e000      	b.n	abf8 <uip_process+0x2188>
				uip_connr->tcpstateflags = UIP_TIME_WAIT;
				uip_connr->timer = 0;
			}
	}

	goto drop;
    abf6:	bf00      	nop
	/* Return and let the caller do the actual transmission. */
	uip_flags = 0;
	return;

drop:
	uip_len = 0;
    abf8:	f64a 3358 	movw	r3, #43864	; 0xab58
    abfc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ac00:	f04f 0200 	mov.w	r2, #0
    ac04:	801a      	strh	r2, [r3, #0]
	uip_flags = 0;
    ac06:	f64a 3364 	movw	r3, #43876	; 0xab64
    ac0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ac0e:	f04f 0200 	mov.w	r2, #0
    ac12:	701a      	strb	r2, [r3, #0]
	return;
    ac14:	bf00      	nop
}
    ac16:	f107 0714 	add.w	r7, r7, #20
    ac1a:	46bd      	mov	sp, r7
    ac1c:	bd90      	pop	{r4, r7, pc}
    ac1e:	bf00      	nop

0000ac20 <htons>:
/*---------------------------------------------------------------------------*/

u16_t htons( u16_t val )
{
    ac20:	b480      	push	{r7}
    ac22:	b083      	sub	sp, #12
    ac24:	af00      	add	r7, sp, #0
    ac26:	4603      	mov	r3, r0
    ac28:	80fb      	strh	r3, [r7, #6]
	return HTONS( val );
    ac2a:	88fb      	ldrh	r3, [r7, #6]
    ac2c:	ea4f 2303 	mov.w	r3, r3, lsl #8
    ac30:	b29a      	uxth	r2, r3
    ac32:	88fb      	ldrh	r3, [r7, #6]
    ac34:	ea4f 2313 	mov.w	r3, r3, lsr #8
    ac38:	b29b      	uxth	r3, r3
    ac3a:	ea42 0303 	orr.w	r3, r2, r3
    ac3e:	b29b      	uxth	r3, r3
    ac40:	b29b      	uxth	r3, r3
}
    ac42:	4618      	mov	r0, r3
    ac44:	f107 070c 	add.w	r7, r7, #12
    ac48:	46bd      	mov	sp, r7
    ac4a:	bc80      	pop	{r7}
    ac4c:	4770      	bx	lr
    ac4e:	bf00      	nop

0000ac50 <htonl>:

u32_t htonl( u32_t val )
{
    ac50:	b480      	push	{r7}
    ac52:	b083      	sub	sp, #12
    ac54:	af00      	add	r7, sp, #0
    ac56:	6078      	str	r0, [r7, #4]
	return HTONL( val );
    ac58:	687b      	ldr	r3, [r7, #4]
    ac5a:	b29b      	uxth	r3, r3
    ac5c:	ea4f 2303 	mov.w	r3, r3, lsl #8
    ac60:	b29a      	uxth	r2, r3
    ac62:	687b      	ldr	r3, [r7, #4]
    ac64:	b29b      	uxth	r3, r3
    ac66:	ea4f 2313 	mov.w	r3, r3, lsr #8
    ac6a:	b29b      	uxth	r3, r3
    ac6c:	ea42 0303 	orr.w	r3, r2, r3
    ac70:	b29b      	uxth	r3, r3
    ac72:	b29b      	uxth	r3, r3
    ac74:	ea4f 4203 	mov.w	r2, r3, lsl #16
    ac78:	687b      	ldr	r3, [r7, #4]
    ac7a:	ea4f 4313 	mov.w	r3, r3, lsr #16
    ac7e:	b29b      	uxth	r3, r3
    ac80:	ea4f 2303 	mov.w	r3, r3, lsl #8
    ac84:	b299      	uxth	r1, r3
    ac86:	687b      	ldr	r3, [r7, #4]
    ac88:	ea4f 4313 	mov.w	r3, r3, lsr #16
    ac8c:	b29b      	uxth	r3, r3
    ac8e:	ea4f 2313 	mov.w	r3, r3, lsr #8
    ac92:	b29b      	uxth	r3, r3
    ac94:	ea41 0303 	orr.w	r3, r1, r3
    ac98:	b29b      	uxth	r3, r3
    ac9a:	b29b      	uxth	r3, r3
    ac9c:	ea42 0303 	orr.w	r3, r2, r3
}
    aca0:	4618      	mov	r0, r3
    aca2:	f107 070c 	add.w	r7, r7, #12
    aca6:	46bd      	mov	sp, r7
    aca8:	bc80      	pop	{r7}
    acaa:	4770      	bx	lr

0000acac <uip_send>:
/*---------------------------------------------------------------------------*/

void uip_send( const void *data, int len )
{
    acac:	b580      	push	{r7, lr}
    acae:	b084      	sub	sp, #16
    acb0:	af00      	add	r7, sp, #0
    acb2:	6078      	str	r0, [r7, #4]
    acb4:	6039      	str	r1, [r7, #0]
	int copylen;

	#define MIN( a, b ) ( (a) < (b) ? (a) : (b) )

	copylen = MIN( len, UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN - ( int )
    acb6:	f240 6390 	movw	r3, #1680	; 0x690
    acba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    acbe:	681b      	ldr	r3, [r3, #0]
    acc0:	f103 0336 	add.w	r3, r3, #54	; 0x36
    acc4:	461a      	mov	r2, r3
    acc6:	f64a 335c 	movw	r3, #43868	; 0xab5c
    acca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    acce:	681b      	ldr	r3, [r3, #0]
    acd0:	ebc3 0302 	rsb	r3, r3, r2
    acd4:	f503 63b2 	add.w	r3, r3, #1424	; 0x590
    acd8:	f103 0302 	add.w	r3, r3, #2
    acdc:	683a      	ldr	r2, [r7, #0]
    acde:	4293      	cmp	r3, r2
    ace0:	bfa8      	it	ge
    ace2:	4613      	movge	r3, r2
    ace4:	60fb      	str	r3, [r7, #12]
					   (( char * ) uip_sappdata - ( char * ) &uip_buf[UIP_LLH_LEN + UIP_TCPIP_HLEN]) );
	if( copylen > 0 )
    ace6:	68fb      	ldr	r3, [r7, #12]
    ace8:	2b00      	cmp	r3, #0
    acea:	dd1d      	ble.n	ad28 <uip_send+0x7c>
	{
		uip_slen = copylen;
    acec:	68fb      	ldr	r3, [r7, #12]
    acee:	b29a      	uxth	r2, r3
    acf0:	f64c 33e4 	movw	r3, #52196	; 0xcbe4
    acf4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    acf8:	801a      	strh	r2, [r3, #0]
		if( data != uip_sappdata )
    acfa:	f64a 335c 	movw	r3, #43868	; 0xab5c
    acfe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ad02:	681b      	ldr	r3, [r3, #0]
    ad04:	687a      	ldr	r2, [r7, #4]
    ad06:	429a      	cmp	r2, r3
    ad08:	d00e      	beq.n	ad28 <uip_send+0x7c>
		{
			memcpy( uip_sappdata, (data), uip_slen );
    ad0a:	f64a 335c 	movw	r3, #43868	; 0xab5c
    ad0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ad12:	681a      	ldr	r2, [r3, #0]
    ad14:	f64c 33e4 	movw	r3, #52196	; 0xcbe4
    ad18:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ad1c:	881b      	ldrh	r3, [r3, #0]
    ad1e:	4610      	mov	r0, r2
    ad20:	6879      	ldr	r1, [r7, #4]
    ad22:	461a      	mov	r2, r3
    ad24:	f006 fe66 	bl	119f4 <memcpy>
		}
	}
}
    ad28:	f107 0710 	add.w	r7, r7, #16
    ad2c:	46bd      	mov	sp, r7
    ad2e:	bd80      	pop	{r7, pc}

0000ad30 <uip_arp_init>:
 *
 */

/*-----------------------------------------------------------------------------------*/
void uip_arp_init( void )
{
    ad30:	b580      	push	{r7, lr}
    ad32:	af00      	add	r7, sp, #0
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    ad34:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    ad38:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ad3c:	f04f 0200 	mov.w	r2, #0
    ad40:	701a      	strb	r2, [r3, #0]
    ad42:	e024      	b.n	ad8e <uip_arp_init+0x5e>
	{
		memset( &arp_table[i].ipaddr, 0, 4 );
    ad44:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    ad48:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ad4c:	781b      	ldrb	r3, [r3, #0]
    ad4e:	461a      	mov	r2, r3
    ad50:	4613      	mov	r3, r2
    ad52:	ea4f 0343 	mov.w	r3, r3, lsl #1
    ad56:	4413      	add	r3, r2
    ad58:	ea4f 0283 	mov.w	r2, r3, lsl #2
    ad5c:	f642 737c 	movw	r3, #12156	; 0x2f7c
    ad60:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ad64:	4413      	add	r3, r2
    ad66:	4618      	mov	r0, r3
    ad68:	f04f 0100 	mov.w	r1, #0
    ad6c:	f04f 0204 	mov.w	r2, #4
    ad70:	f006 ff08 	bl	11b84 <memset>
 */

/*-----------------------------------------------------------------------------------*/
void uip_arp_init( void )
{
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    ad74:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    ad78:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ad7c:	781b      	ldrb	r3, [r3, #0]
    ad7e:	f103 0301 	add.w	r3, r3, #1
    ad82:	b2da      	uxtb	r2, r3
    ad84:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    ad88:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ad8c:	701a      	strb	r2, [r3, #0]
    ad8e:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    ad92:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ad96:	781b      	ldrb	r3, [r3, #0]
    ad98:	2b07      	cmp	r3, #7
    ad9a:	d9d3      	bls.n	ad44 <uip_arp_init+0x14>
	{
		memset( &arp_table[i].ipaddr, 0, 4 );
	}
}
    ad9c:	bd80      	pop	{r7, pc}
    ad9e:	bf00      	nop

0000ada0 <uip_arp_timer>:
 *
 */

/*-----------------------------------------------------------------------------------*/
void uip_arp_timer( void )
{
    ada0:	b580      	push	{r7, lr}
    ada2:	b082      	sub	sp, #8
    ada4:	af00      	add	r7, sp, #0
	struct arp_entry	*tabptr;

	++arptime;
    ada6:	f642 73e2 	movw	r3, #12258	; 0x2fe2
    adaa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    adae:	781b      	ldrb	r3, [r3, #0]
    adb0:	f103 0301 	add.w	r3, r3, #1
    adb4:	b2da      	uxtb	r2, r3
    adb6:	f642 73e2 	movw	r3, #12258	; 0x2fe2
    adba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    adbe:	701a      	strb	r2, [r3, #0]
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    adc0:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    adc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    adc8:	f04f 0200 	mov.w	r2, #0
    adcc:	701a      	strb	r2, [r3, #0]
    adce:	e045      	b.n	ae5c <uip_arp_timer+0xbc>
	{
		tabptr = &arp_table[i];
    add0:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    add4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    add8:	781b      	ldrb	r3, [r3, #0]
    adda:	461a      	mov	r2, r3
    addc:	4613      	mov	r3, r2
    adde:	ea4f 0343 	mov.w	r3, r3, lsl #1
    ade2:	4413      	add	r3, r2
    ade4:	ea4f 0383 	mov.w	r3, r3, lsl #2
    ade8:	461a      	mov	r2, r3
    adea:	f642 737c 	movw	r3, #12156	; 0x2f7c
    adee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    adf2:	4413      	add	r3, r2
    adf4:	607b      	str	r3, [r7, #4]
		if( uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) && arptime - tabptr->time >= UIP_ARP_MAXAGE )
    adf6:	687b      	ldr	r3, [r7, #4]
    adf8:	881a      	ldrh	r2, [r3, #0]
    adfa:	f643 3330 	movw	r3, #15152	; 0x3b30
    adfe:	f2c0 0301 	movt	r3, #1
    ae02:	881b      	ldrh	r3, [r3, #0]
    ae04:	429a      	cmp	r2, r3
    ae06:	d11c      	bne.n	ae42 <uip_arp_timer+0xa2>
    ae08:	687b      	ldr	r3, [r7, #4]
    ae0a:	885a      	ldrh	r2, [r3, #2]
    ae0c:	f643 3330 	movw	r3, #15152	; 0x3b30
    ae10:	f2c0 0301 	movt	r3, #1
    ae14:	885b      	ldrh	r3, [r3, #2]
    ae16:	429a      	cmp	r2, r3
    ae18:	d113      	bne.n	ae42 <uip_arp_timer+0xa2>
    ae1a:	f642 73e2 	movw	r3, #12258	; 0x2fe2
    ae1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ae22:	781b      	ldrb	r3, [r3, #0]
    ae24:	461a      	mov	r2, r3
    ae26:	687b      	ldr	r3, [r7, #4]
    ae28:	7a9b      	ldrb	r3, [r3, #10]
    ae2a:	ebc3 0302 	rsb	r3, r3, r2
    ae2e:	2b77      	cmp	r3, #119	; 0x77
    ae30:	dd07      	ble.n	ae42 <uip_arp_timer+0xa2>
		{
			memset( &tabptr->ipaddr, 0, 4 );
    ae32:	687b      	ldr	r3, [r7, #4]
    ae34:	4618      	mov	r0, r3
    ae36:	f04f 0100 	mov.w	r1, #0
    ae3a:	f04f 0204 	mov.w	r2, #4
    ae3e:	f006 fea1 	bl	11b84 <memset>
void uip_arp_timer( void )
{
	struct arp_entry	*tabptr;

	++arptime;
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    ae42:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    ae46:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ae4a:	781b      	ldrb	r3, [r3, #0]
    ae4c:	f103 0301 	add.w	r3, r3, #1
    ae50:	b2da      	uxtb	r2, r3
    ae52:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    ae56:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ae5a:	701a      	strb	r2, [r3, #0]
    ae5c:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    ae60:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ae64:	781b      	ldrb	r3, [r3, #0]
    ae66:	2b07      	cmp	r3, #7
    ae68:	d9b2      	bls.n	add0 <uip_arp_timer+0x30>
		if( uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) && arptime - tabptr->time >= UIP_ARP_MAXAGE )
		{
			memset( &tabptr->ipaddr, 0, 4 );
		}
	}
}
    ae6a:	f107 0708 	add.w	r7, r7, #8
    ae6e:	46bd      	mov	sp, r7
    ae70:	bd80      	pop	{r7, pc}
    ae72:	bf00      	nop

0000ae74 <uip_arp_update>:

/*-----------------------------------------------------------------------------------*/
static void uip_arp_update( uip_ipaddr_t *ipaddr, struct uip_eth_addr *ethaddr )
{
    ae74:	b590      	push	{r4, r7, lr}
    ae76:	b083      	sub	sp, #12
    ae78:	af00      	add	r7, sp, #0
    ae7a:	6078      	str	r0, [r7, #4]
    ae7c:	6039      	str	r1, [r7, #0]
	register struct arp_entry	*tabptr;

	/* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    ae7e:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    ae82:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ae86:	f04f 0200 	mov.w	r2, #0
    ae8a:	701a      	strb	r2, [r3, #0]
    ae8c:	e049      	b.n	af22 <uip_arp_update+0xae>
	{
		tabptr = &arp_table[i];
    ae8e:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    ae92:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ae96:	781b      	ldrb	r3, [r3, #0]
    ae98:	461a      	mov	r2, r3
    ae9a:	4613      	mov	r3, r2
    ae9c:	ea4f 0343 	mov.w	r3, r3, lsl #1
    aea0:	4413      	add	r3, r2
    aea2:	ea4f 0383 	mov.w	r3, r3, lsl #2
    aea6:	461a      	mov	r2, r3
    aea8:	f642 737c 	movw	r3, #12156	; 0x2f7c
    aeac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aeb0:	eb02 0403 	add.w	r4, r2, r3

		/* Only check those entries that are actually in use. */
		if( !uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) )
    aeb4:	8822      	ldrh	r2, [r4, #0]
    aeb6:	f643 3330 	movw	r3, #15152	; 0x3b30
    aeba:	f2c0 0301 	movt	r3, #1
    aebe:	881b      	ldrh	r3, [r3, #0]
    aec0:	429a      	cmp	r2, r3
    aec2:	d107      	bne.n	aed4 <uip_arp_update+0x60>
    aec4:	8862      	ldrh	r2, [r4, #2]
    aec6:	f643 3330 	movw	r3, #15152	; 0x3b30
    aeca:	f2c0 0301 	movt	r3, #1
    aece:	885b      	ldrh	r3, [r3, #2]
    aed0:	429a      	cmp	r2, r3
    aed2:	d019      	beq.n	af08 <uip_arp_update+0x94>
		{
			/* Check if the source IP address of the incoming packet matches
         the IP address in this ARP table entry. */
			if( uip_ipaddr_cmp(ipaddr, &tabptr->ipaddr) )
    aed4:	687b      	ldr	r3, [r7, #4]
    aed6:	881a      	ldrh	r2, [r3, #0]
    aed8:	8823      	ldrh	r3, [r4, #0]
    aeda:	429a      	cmp	r2, r3
    aedc:	d114      	bne.n	af08 <uip_arp_update+0x94>
    aede:	687b      	ldr	r3, [r7, #4]
    aee0:	885a      	ldrh	r2, [r3, #2]
    aee2:	8863      	ldrh	r3, [r4, #2]
    aee4:	429a      	cmp	r2, r3
    aee6:	d10f      	bne.n	af08 <uip_arp_update+0x94>
			{
				/* An old entry found, update this and return. */
				memcpy( tabptr->ethaddr.addr, ethaddr->addr, 6 );
    aee8:	f104 0204 	add.w	r2, r4, #4
    aeec:	683b      	ldr	r3, [r7, #0]
    aeee:	4610      	mov	r0, r2
    aef0:	4619      	mov	r1, r3
    aef2:	f04f 0206 	mov.w	r2, #6
    aef6:	f006 fd7d 	bl	119f4 <memcpy>
				tabptr->time = arptime;
    aefa:	f642 73e2 	movw	r3, #12258	; 0x2fe2
    aefe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af02:	781b      	ldrb	r3, [r3, #0]
    af04:	72a3      	strb	r3, [r4, #10]

				return;
    af06:	e0f9      	b.n	b0fc <uip_arp_update+0x288>
	register struct arp_entry	*tabptr;

	/* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    af08:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    af0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af10:	781b      	ldrb	r3, [r3, #0]
    af12:	f103 0301 	add.w	r3, r3, #1
    af16:	b2da      	uxtb	r2, r3
    af18:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    af1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af20:	701a      	strb	r2, [r3, #0]
    af22:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    af26:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af2a:	781b      	ldrb	r3, [r3, #0]
    af2c:	2b07      	cmp	r3, #7
    af2e:	d9ae      	bls.n	ae8e <uip_arp_update+0x1a>

	/* If we get here, no existing ARP table entry was found, so we
     create one. */

	/* First, we try to find an unused entry in the ARP table. */
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    af30:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    af34:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af38:	f04f 0200 	mov.w	r2, #0
    af3c:	701a      	strb	r2, [r3, #0]
    af3e:	e02f      	b.n	afa0 <uip_arp_update+0x12c>
	{
		tabptr = &arp_table[i];
    af40:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    af44:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af48:	781b      	ldrb	r3, [r3, #0]
    af4a:	461a      	mov	r2, r3
    af4c:	4613      	mov	r3, r2
    af4e:	ea4f 0343 	mov.w	r3, r3, lsl #1
    af52:	4413      	add	r3, r2
    af54:	ea4f 0383 	mov.w	r3, r3, lsl #2
    af58:	461a      	mov	r2, r3
    af5a:	f642 737c 	movw	r3, #12156	; 0x2f7c
    af5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af62:	eb02 0403 	add.w	r4, r2, r3
		if( uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) )
    af66:	8822      	ldrh	r2, [r4, #0]
    af68:	f643 3330 	movw	r3, #15152	; 0x3b30
    af6c:	f2c0 0301 	movt	r3, #1
    af70:	881b      	ldrh	r3, [r3, #0]
    af72:	429a      	cmp	r2, r3
    af74:	d107      	bne.n	af86 <uip_arp_update+0x112>
    af76:	8862      	ldrh	r2, [r4, #2]
    af78:	f643 3330 	movw	r3, #15152	; 0x3b30
    af7c:	f2c0 0301 	movt	r3, #1
    af80:	885b      	ldrh	r3, [r3, #2]
    af82:	429a      	cmp	r2, r3
    af84:	d014      	beq.n	afb0 <uip_arp_update+0x13c>

	/* If we get here, no existing ARP table entry was found, so we
     create one. */

	/* First, we try to find an unused entry in the ARP table. */
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    af86:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    af8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af8e:	781b      	ldrb	r3, [r3, #0]
    af90:	f103 0301 	add.w	r3, r3, #1
    af94:	b2da      	uxtb	r2, r3
    af96:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    af9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af9e:	701a      	strb	r2, [r3, #0]
    afa0:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    afa4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    afa8:	781b      	ldrb	r3, [r3, #0]
    afaa:	2b07      	cmp	r3, #7
    afac:	d9c8      	bls.n	af40 <uip_arp_update+0xcc>
    afae:	e000      	b.n	afb2 <uip_arp_update+0x13e>
	{
		tabptr = &arp_table[i];
		if( uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) )
		{
			break;
    afb0:	bf00      	nop
		}
	}

	/* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
	if( i == UIP_ARPTAB_SIZE )
    afb2:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    afb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    afba:	781b      	ldrb	r3, [r3, #0]
    afbc:	2b08      	cmp	r3, #8
    afbe:	f040 8082 	bne.w	b0c6 <uip_arp_update+0x252>
	{
		tmpage = 0;
    afc2:	f642 73e3 	movw	r3, #12259	; 0x2fe3
    afc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    afca:	f04f 0200 	mov.w	r2, #0
    afce:	701a      	strb	r2, [r3, #0]
		c = 0;
    afd0:	f642 73e1 	movw	r3, #12257	; 0x2fe1
    afd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    afd8:	f04f 0200 	mov.w	r2, #0
    afdc:	701a      	strb	r2, [r3, #0]
		for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    afde:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    afe2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    afe6:	f04f 0200 	mov.w	r2, #0
    afea:	701a      	strb	r2, [r3, #0]
    afec:	e047      	b.n	b07e <uip_arp_update+0x20a>
		{
			tabptr = &arp_table[i];
    afee:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    aff2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aff6:	781b      	ldrb	r3, [r3, #0]
    aff8:	461a      	mov	r2, r3
    affa:	4613      	mov	r3, r2
    affc:	ea4f 0343 	mov.w	r3, r3, lsl #1
    b000:	4413      	add	r3, r2
    b002:	ea4f 0383 	mov.w	r3, r3, lsl #2
    b006:	461a      	mov	r2, r3
    b008:	f642 737c 	movw	r3, #12156	; 0x2f7c
    b00c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b010:	eb02 0403 	add.w	r4, r2, r3
			if( arptime - tabptr->time > tmpage )
    b014:	f642 73e2 	movw	r3, #12258	; 0x2fe2
    b018:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b01c:	781b      	ldrb	r3, [r3, #0]
    b01e:	461a      	mov	r2, r3
    b020:	7aa3      	ldrb	r3, [r4, #10]
    b022:	ebc3 0202 	rsb	r2, r3, r2
    b026:	f642 73e3 	movw	r3, #12259	; 0x2fe3
    b02a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b02e:	781b      	ldrb	r3, [r3, #0]
    b030:	429a      	cmp	r2, r3
    b032:	dd17      	ble.n	b064 <uip_arp_update+0x1f0>
			{
				tmpage = arptime - tabptr->time;
    b034:	f642 73e2 	movw	r3, #12258	; 0x2fe2
    b038:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b03c:	781a      	ldrb	r2, [r3, #0]
    b03e:	7aa3      	ldrb	r3, [r4, #10]
    b040:	ebc3 0302 	rsb	r3, r3, r2
    b044:	b2da      	uxtb	r2, r3
    b046:	f642 73e3 	movw	r3, #12259	; 0x2fe3
    b04a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b04e:	701a      	strb	r2, [r3, #0]
				c = i;
    b050:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    b054:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b058:	781a      	ldrb	r2, [r3, #0]
    b05a:	f642 73e1 	movw	r3, #12257	; 0x2fe1
    b05e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b062:	701a      	strb	r2, [r3, #0]
     throw it away. */
	if( i == UIP_ARPTAB_SIZE )
	{
		tmpage = 0;
		c = 0;
		for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    b064:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    b068:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b06c:	781b      	ldrb	r3, [r3, #0]
    b06e:	f103 0301 	add.w	r3, r3, #1
    b072:	b2da      	uxtb	r2, r3
    b074:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    b078:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b07c:	701a      	strb	r2, [r3, #0]
    b07e:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    b082:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b086:	781b      	ldrb	r3, [r3, #0]
    b088:	2b07      	cmp	r3, #7
    b08a:	d9b0      	bls.n	afee <uip_arp_update+0x17a>
				tmpage = arptime - tabptr->time;
				c = i;
			}
		}

		i = c;
    b08c:	f642 73e1 	movw	r3, #12257	; 0x2fe1
    b090:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b094:	781a      	ldrb	r2, [r3, #0]
    b096:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    b09a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b09e:	701a      	strb	r2, [r3, #0]
		tabptr = &arp_table[i];
    b0a0:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    b0a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b0a8:	781b      	ldrb	r3, [r3, #0]
    b0aa:	461a      	mov	r2, r3
    b0ac:	4613      	mov	r3, r2
    b0ae:	ea4f 0343 	mov.w	r3, r3, lsl #1
    b0b2:	4413      	add	r3, r2
    b0b4:	ea4f 0383 	mov.w	r3, r3, lsl #2
    b0b8:	461a      	mov	r2, r3
    b0ba:	f642 737c 	movw	r3, #12156	; 0x2f7c
    b0be:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b0c2:	eb02 0403 	add.w	r4, r2, r3
	}

	/* Now, i is the ARP table entry which we will fill with the new
     information. */
	uip_ipaddr_copy( &tabptr->ipaddr, ipaddr );
    b0c6:	687b      	ldr	r3, [r7, #4]
    b0c8:	781b      	ldrb	r3, [r3, #0]
    b0ca:	7023      	strb	r3, [r4, #0]
    b0cc:	687b      	ldr	r3, [r7, #4]
    b0ce:	785b      	ldrb	r3, [r3, #1]
    b0d0:	7063      	strb	r3, [r4, #1]
    b0d2:	687b      	ldr	r3, [r7, #4]
    b0d4:	789b      	ldrb	r3, [r3, #2]
    b0d6:	70a3      	strb	r3, [r4, #2]
    b0d8:	687b      	ldr	r3, [r7, #4]
    b0da:	78db      	ldrb	r3, [r3, #3]
    b0dc:	70e3      	strb	r3, [r4, #3]
	memcpy( tabptr->ethaddr.addr, ethaddr->addr, 6 );
    b0de:	f104 0204 	add.w	r2, r4, #4
    b0e2:	683b      	ldr	r3, [r7, #0]
    b0e4:	4610      	mov	r0, r2
    b0e6:	4619      	mov	r1, r3
    b0e8:	f04f 0206 	mov.w	r2, #6
    b0ec:	f006 fc82 	bl	119f4 <memcpy>
	tabptr->time = arptime;
    b0f0:	f642 73e2 	movw	r3, #12258	; 0x2fe2
    b0f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b0f8:	781b      	ldrb	r3, [r3, #0]
    b0fa:	72a3      	strb	r3, [r4, #10]
}
    b0fc:	f107 070c 	add.w	r7, r7, #12
    b100:	46bd      	mov	sp, r7
    b102:	bd90      	pop	{r4, r7, pc}

0000b104 <uip_arp_arpin>:
 * global variable uip_len.
 */

/*-----------------------------------------------------------------------------------*/
void uip_arp_arpin( void )
{
    b104:	b580      	push	{r7, lr}
    b106:	af00      	add	r7, sp, #0
	if( uip_len < sizeof(struct arp_hdr) )
    b108:	f64a 3358 	movw	r3, #43864	; 0xab58
    b10c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b110:	881b      	ldrh	r3, [r3, #0]
    b112:	2b29      	cmp	r3, #41	; 0x29
    b114:	d807      	bhi.n	b126 <uip_arp_arpin+0x22>
	{
		uip_len = 0;
    b116:	f64a 3358 	movw	r3, #43864	; 0xab58
    b11a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b11e:	f04f 0200 	mov.w	r2, #0
    b122:	801a      	strh	r2, [r3, #0]
		return;
    b124:	e170      	b.n	b408 <uip_arp_arpin+0x304>
	}

	uip_len = 0;
    b126:	f64a 3358 	movw	r3, #43864	; 0xab58
    b12a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b12e:	f04f 0200 	mov.w	r2, #0
    b132:	801a      	strh	r2, [r3, #0]

	switch( BUF->opcode )
    b134:	f240 6390 	movw	r3, #1680	; 0x690
    b138:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b13c:	681b      	ldr	r3, [r3, #0]
    b13e:	7d1a      	ldrb	r2, [r3, #20]
    b140:	7d5b      	ldrb	r3, [r3, #21]
    b142:	ea4f 2303 	mov.w	r3, r3, lsl #8
    b146:	ea43 0302 	orr.w	r3, r3, r2
    b14a:	b29b      	uxth	r3, r3
    b14c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    b150:	d004      	beq.n	b15c <uip_arp_arpin+0x58>
    b152:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    b156:	f000 8112 	beq.w	b37e <uip_arp_arpin+0x27a>
			}

			break;
	}

	return;
    b15a:	e155      	b.n	b408 <uip_arp_arpin+0x304>
			/*    if(BUF->dipaddr[0] == uip_hostaddr[0] &&
	  		BUF->dipaddr[1] == uip_hostaddr[1]) {*/

			//PRINTF( "uip_arp_arpin: request for %d.%d.%d.%d (we are %d.%d.%d.%d)\n", BUF->dipaddr.u8[0], BUF->dipaddr.u8[1], BUF->dipaddr.u8[2],			
			//BUF->dipaddr.u8[3], uip_hostaddr.u8[0], uip_hostaddr.u8[1], uip_hostaddr.u8[2], uip_hostaddr.u8[3] );
			if( uip_ipaddr_cmp(&BUF->dipaddr, &uip_hostaddr) )
    b15c:	f240 6390 	movw	r3, #1680	; 0x690
    b160:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b164:	681b      	ldr	r3, [r3, #0]
    b166:	f893 2026 	ldrb.w	r2, [r3, #38]	; 0x26
    b16a:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
    b16e:	ea4f 2303 	mov.w	r3, r3, lsl #8
    b172:	ea43 0302 	orr.w	r3, r3, r2
    b176:	b29a      	uxth	r2, r3
    b178:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    b17c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b180:	881b      	ldrh	r3, [r3, #0]
    b182:	429a      	cmp	r2, r3
    b184:	f040 8138 	bne.w	b3f8 <uip_arp_arpin+0x2f4>
    b188:	f240 6390 	movw	r3, #1680	; 0x690
    b18c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b190:	681b      	ldr	r3, [r3, #0]
    b192:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
    b196:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
    b19a:	ea4f 2303 	mov.w	r3, r3, lsl #8
    b19e:	ea43 0302 	orr.w	r3, r3, r2
    b1a2:	b29a      	uxth	r2, r3
    b1a4:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    b1a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b1ac:	885b      	ldrh	r3, [r3, #2]
    b1ae:	429a      	cmp	r2, r3
    b1b0:	f040 8124 	bne.w	b3fc <uip_arp_arpin+0x2f8>
			{
				/* First, we register the one who made the request in our ARP
				table, since it is likely that we will do more communication
				with this host in the future. */
				uip_arp_update( &BUF->sipaddr, &BUF->shwaddr );
    b1b4:	f240 6390 	movw	r3, #1680	; 0x690
    b1b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b1bc:	681b      	ldr	r3, [r3, #0]
    b1be:	f103 021c 	add.w	r2, r3, #28
    b1c2:	f240 6390 	movw	r3, #1680	; 0x690
    b1c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b1ca:	681b      	ldr	r3, [r3, #0]
    b1cc:	f103 0316 	add.w	r3, r3, #22
    b1d0:	4610      	mov	r0, r2
    b1d2:	4619      	mov	r1, r3
    b1d4:	f7ff fe4e 	bl	ae74 <uip_arp_update>

				BUF->opcode = HTONS( ARP_REPLY );
    b1d8:	f240 6390 	movw	r3, #1680	; 0x690
    b1dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b1e0:	681b      	ldr	r3, [r3, #0]
    b1e2:	f04f 0200 	mov.w	r2, #0
    b1e6:	751a      	strb	r2, [r3, #20]
    b1e8:	f04f 0200 	mov.w	r2, #0
    b1ec:	f042 0202 	orr.w	r2, r2, #2
    b1f0:	755a      	strb	r2, [r3, #21]

				memcpy( BUF->dhwaddr.addr, BUF->shwaddr.addr, 6 );
    b1f2:	f240 6390 	movw	r3, #1680	; 0x690
    b1f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b1fa:	681b      	ldr	r3, [r3, #0]
    b1fc:	f103 0220 	add.w	r2, r3, #32
    b200:	f240 6390 	movw	r3, #1680	; 0x690
    b204:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b208:	681b      	ldr	r3, [r3, #0]
    b20a:	f103 0316 	add.w	r3, r3, #22
    b20e:	4610      	mov	r0, r2
    b210:	4619      	mov	r1, r3
    b212:	f04f 0206 	mov.w	r2, #6
    b216:	f006 fbed 	bl	119f4 <memcpy>
				memcpy( BUF->shwaddr.addr, uip_ethaddr.addr, 6 );
    b21a:	f240 6390 	movw	r3, #1680	; 0x690
    b21e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b222:	681b      	ldr	r3, [r3, #0]
    b224:	f103 0316 	add.w	r3, r3, #22
    b228:	4618      	mov	r0, r3
    b22a:	f642 7164 	movw	r1, #12132	; 0x2f64
    b22e:	f2c2 0100 	movt	r1, #8192	; 0x2000
    b232:	f04f 0206 	mov.w	r2, #6
    b236:	f006 fbdd 	bl	119f4 <memcpy>
				memcpy( BUF->ethhdr.src.addr, uip_ethaddr.addr, 6 );
    b23a:	f240 6390 	movw	r3, #1680	; 0x690
    b23e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b242:	681b      	ldr	r3, [r3, #0]
    b244:	f103 0306 	add.w	r3, r3, #6
    b248:	4618      	mov	r0, r3
    b24a:	f642 7164 	movw	r1, #12132	; 0x2f64
    b24e:	f2c2 0100 	movt	r1, #8192	; 0x2000
    b252:	f04f 0206 	mov.w	r2, #6
    b256:	f006 fbcd 	bl	119f4 <memcpy>
				memcpy( BUF->ethhdr.dest.addr, BUF->dhwaddr.addr, 6 );
    b25a:	f240 6390 	movw	r3, #1680	; 0x690
    b25e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b262:	681b      	ldr	r3, [r3, #0]
    b264:	461a      	mov	r2, r3
    b266:	f240 6390 	movw	r3, #1680	; 0x690
    b26a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b26e:	681b      	ldr	r3, [r3, #0]
    b270:	f103 0320 	add.w	r3, r3, #32
    b274:	4610      	mov	r0, r2
    b276:	4619      	mov	r1, r3
    b278:	f04f 0206 	mov.w	r2, #6
    b27c:	f006 fbba 	bl	119f4 <memcpy>

				uip_ipaddr_copy( &BUF->dipaddr, &BUF->sipaddr );
    b280:	f240 6390 	movw	r3, #1680	; 0x690
    b284:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b288:	681b      	ldr	r3, [r3, #0]
    b28a:	461a      	mov	r2, r3
    b28c:	f240 6390 	movw	r3, #1680	; 0x690
    b290:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b294:	681b      	ldr	r3, [r3, #0]
    b296:	7f1b      	ldrb	r3, [r3, #28]
    b298:	f882 3026 	strb.w	r3, [r2, #38]	; 0x26
    b29c:	f240 6390 	movw	r3, #1680	; 0x690
    b2a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b2a4:	681b      	ldr	r3, [r3, #0]
    b2a6:	461a      	mov	r2, r3
    b2a8:	f240 6390 	movw	r3, #1680	; 0x690
    b2ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b2b0:	681b      	ldr	r3, [r3, #0]
    b2b2:	7f5b      	ldrb	r3, [r3, #29]
    b2b4:	f882 3027 	strb.w	r3, [r2, #39]	; 0x27
    b2b8:	f240 6390 	movw	r3, #1680	; 0x690
    b2bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b2c0:	681b      	ldr	r3, [r3, #0]
    b2c2:	461a      	mov	r2, r3
    b2c4:	f240 6390 	movw	r3, #1680	; 0x690
    b2c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b2cc:	681b      	ldr	r3, [r3, #0]
    b2ce:	7f9b      	ldrb	r3, [r3, #30]
    b2d0:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
    b2d4:	f240 6390 	movw	r3, #1680	; 0x690
    b2d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b2dc:	681b      	ldr	r3, [r3, #0]
    b2de:	461a      	mov	r2, r3
    b2e0:	f240 6390 	movw	r3, #1680	; 0x690
    b2e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b2e8:	681b      	ldr	r3, [r3, #0]
    b2ea:	7fdb      	ldrb	r3, [r3, #31]
    b2ec:	f882 3029 	strb.w	r3, [r2, #41]	; 0x29
				uip_ipaddr_copy( &BUF->sipaddr, &uip_hostaddr );
    b2f0:	f240 6390 	movw	r3, #1680	; 0x690
    b2f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b2f8:	681b      	ldr	r3, [r3, #0]
    b2fa:	461a      	mov	r2, r3
    b2fc:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    b300:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b304:	781b      	ldrb	r3, [r3, #0]
    b306:	7713      	strb	r3, [r2, #28]
    b308:	f240 6390 	movw	r3, #1680	; 0x690
    b30c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b310:	681b      	ldr	r3, [r3, #0]
    b312:	461a      	mov	r2, r3
    b314:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    b318:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b31c:	785b      	ldrb	r3, [r3, #1]
    b31e:	7753      	strb	r3, [r2, #29]
    b320:	f240 6390 	movw	r3, #1680	; 0x690
    b324:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b328:	681b      	ldr	r3, [r3, #0]
    b32a:	461a      	mov	r2, r3
    b32c:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    b330:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b334:	789b      	ldrb	r3, [r3, #2]
    b336:	7793      	strb	r3, [r2, #30]
    b338:	f240 6390 	movw	r3, #1680	; 0x690
    b33c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b340:	681b      	ldr	r3, [r3, #0]
    b342:	461a      	mov	r2, r3
    b344:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    b348:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b34c:	78db      	ldrb	r3, [r3, #3]
    b34e:	77d3      	strb	r3, [r2, #31]

				BUF->ethhdr.type = HTONS( UIP_ETHTYPE_ARP );
    b350:	f240 6390 	movw	r3, #1680	; 0x690
    b354:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b358:	681b      	ldr	r3, [r3, #0]
    b35a:	f04f 0200 	mov.w	r2, #0
    b35e:	f042 0208 	orr.w	r2, r2, #8
    b362:	731a      	strb	r2, [r3, #12]
    b364:	f04f 0200 	mov.w	r2, #0
    b368:	f042 0206 	orr.w	r2, r2, #6
    b36c:	735a      	strb	r2, [r3, #13]
				uip_len = sizeof( struct arp_hdr );
    b36e:	f64a 3358 	movw	r3, #43864	; 0xab58
    b372:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b376:	f04f 022a 	mov.w	r2, #42	; 0x2a
    b37a:	801a      	strh	r2, [r3, #0]
			}

			break;
    b37c:	e03f      	b.n	b3fe <uip_arp_arpin+0x2fa>

		case HTONS( ARP_REPLY ):
			/* ARP reply. We insert or update the ARP table if it was meant
			for us. */
			if( uip_ipaddr_cmp(&BUF->dipaddr, &uip_hostaddr) )
    b37e:	f240 6390 	movw	r3, #1680	; 0x690
    b382:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b386:	681b      	ldr	r3, [r3, #0]
    b388:	f893 2026 	ldrb.w	r2, [r3, #38]	; 0x26
    b38c:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
    b390:	ea4f 2303 	mov.w	r3, r3, lsl #8
    b394:	ea43 0302 	orr.w	r3, r3, r2
    b398:	b29a      	uxth	r2, r3
    b39a:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    b39e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b3a2:	881b      	ldrh	r3, [r3, #0]
    b3a4:	429a      	cmp	r2, r3
    b3a6:	d12c      	bne.n	b402 <uip_arp_arpin+0x2fe>
    b3a8:	f240 6390 	movw	r3, #1680	; 0x690
    b3ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b3b0:	681b      	ldr	r3, [r3, #0]
    b3b2:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
    b3b6:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
    b3ba:	ea4f 2303 	mov.w	r3, r3, lsl #8
    b3be:	ea43 0302 	orr.w	r3, r3, r2
    b3c2:	b29a      	uxth	r2, r3
    b3c4:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    b3c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b3cc:	885b      	ldrh	r3, [r3, #2]
    b3ce:	429a      	cmp	r2, r3
    b3d0:	d119      	bne.n	b406 <uip_arp_arpin+0x302>
			{
				uip_arp_update( &BUF->sipaddr, &BUF->shwaddr );
    b3d2:	f240 6390 	movw	r3, #1680	; 0x690
    b3d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b3da:	681b      	ldr	r3, [r3, #0]
    b3dc:	f103 021c 	add.w	r2, r3, #28
    b3e0:	f240 6390 	movw	r3, #1680	; 0x690
    b3e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b3e8:	681b      	ldr	r3, [r3, #0]
    b3ea:	f103 0316 	add.w	r3, r3, #22
    b3ee:	4610      	mov	r0, r2
    b3f0:	4619      	mov	r1, r3
    b3f2:	f7ff fd3f 	bl	ae74 <uip_arp_update>
			}

			break;
	}

	return;
    b3f6:	e007      	b.n	b408 <uip_arp_arpin+0x304>

				BUF->ethhdr.type = HTONS( UIP_ETHTYPE_ARP );
				uip_len = sizeof( struct arp_hdr );
			}

			break;
    b3f8:	bf00      	nop
    b3fa:	e000      	b.n	b3fe <uip_arp_arpin+0x2fa>
    b3fc:	bf00      	nop
			}

			break;
	}

	return;
    b3fe:	bf00      	nop
    b400:	e002      	b.n	b408 <uip_arp_arpin+0x304>
    b402:	bf00      	nop
    b404:	e000      	b.n	b408 <uip_arp_arpin+0x304>
    b406:	bf00      	nop
}
    b408:	bd80      	pop	{r7, pc}
    b40a:	bf00      	nop

0000b40c <uip_arp_out>:
 * uip_len.
 */

/*-----------------------------------------------------------------------------------*/
void uip_arp_out( void )
{
    b40c:	b580      	push	{r7, lr}
    b40e:	b082      	sub	sp, #8
    b410:	af00      	add	r7, sp, #0

     If not ARP table entry is found, we overwrite the original IP
     packet with an ARP request for the IP address. */

	/* First check if destination is a local broadcast. */
	if( uip_ipaddr_cmp(&IPBUF->destipaddr, &uip_broadcast_addr) )
    b412:	f240 6390 	movw	r3, #1680	; 0x690
    b416:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b41a:	681b      	ldr	r3, [r3, #0]
    b41c:	7f9a      	ldrb	r2, [r3, #30]
    b41e:	7fdb      	ldrb	r3, [r3, #31]
    b420:	ea4f 2303 	mov.w	r3, r3, lsl #8
    b424:	ea43 0302 	orr.w	r3, r3, r2
    b428:	b29a      	uxth	r2, r3
    b42a:	f643 332c 	movw	r3, #15148	; 0x3b2c
    b42e:	f2c0 0301 	movt	r3, #1
    b432:	881b      	ldrh	r3, [r3, #0]
    b434:	429a      	cmp	r2, r3
    b436:	d123      	bne.n	b480 <uip_arp_out+0x74>
    b438:	f240 6390 	movw	r3, #1680	; 0x690
    b43c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b440:	681b      	ldr	r3, [r3, #0]
    b442:	f893 2020 	ldrb.w	r2, [r3, #32]
    b446:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    b44a:	ea4f 2303 	mov.w	r3, r3, lsl #8
    b44e:	ea43 0302 	orr.w	r3, r3, r2
    b452:	b29a      	uxth	r2, r3
    b454:	f643 332c 	movw	r3, #15148	; 0x3b2c
    b458:	f2c0 0301 	movt	r3, #1
    b45c:	885b      	ldrh	r3, [r3, #2]
    b45e:	429a      	cmp	r2, r3
    b460:	d10e      	bne.n	b480 <uip_arp_out+0x74>
	{
		memcpy( IPBUF->ethhdr.dest.addr, broadcast_ethaddr.addr, 6 );
    b462:	f240 6390 	movw	r3, #1680	; 0x690
    b466:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b46a:	681b      	ldr	r3, [r3, #0]
    b46c:	4618      	mov	r0, r3
    b46e:	f643 3134 	movw	r1, #15156	; 0x3b34
    b472:	f2c0 0101 	movt	r1, #1
    b476:	f04f 0206 	mov.w	r2, #6
    b47a:	f006 fabb 	bl	119f4 <memcpy>

     If not ARP table entry is found, we overwrite the original IP
     packet with an ARP request for the IP address. */

	/* First check if destination is a local broadcast. */
	if( uip_ipaddr_cmp(&IPBUF->destipaddr, &uip_broadcast_addr) )
    b47e:	e1db      	b.n	b838 <uip_arp_out+0x42c>
		memcpy( IPBUF->ethhdr.dest.addr, broadcast_ethaddr.addr, 6 );
	}
	else
	{
		/* Check if the destination address is on the local network. */
		if( !uip_ipaddr_maskcmp(&IPBUF->destipaddr, &uip_hostaddr, &uip_netmask) )
    b480:	f240 6390 	movw	r3, #1680	; 0x690
    b484:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b488:	681b      	ldr	r3, [r3, #0]
    b48a:	f103 031e 	add.w	r3, r3, #30
    b48e:	881a      	ldrh	r2, [r3, #0]
    b490:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    b494:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b498:	881b      	ldrh	r3, [r3, #0]
    b49a:	ea82 0303 	eor.w	r3, r2, r3
    b49e:	b29a      	uxth	r2, r3
    b4a0:	f64c 33dc 	movw	r3, #52188	; 0xcbdc
    b4a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b4a8:	881b      	ldrh	r3, [r3, #0]
    b4aa:	ea02 0303 	and.w	r3, r2, r3
    b4ae:	b29b      	uxth	r3, r3
    b4b0:	2b00      	cmp	r3, #0
    b4b2:	d113      	bne.n	b4dc <uip_arp_out+0xd0>
    b4b4:	f240 6390 	movw	r3, #1680	; 0x690
    b4b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b4bc:	681b      	ldr	r3, [r3, #0]
    b4be:	f103 0320 	add.w	r3, r3, #32
    b4c2:	881a      	ldrh	r2, [r3, #0]
    b4c4:	4b52      	ldr	r3, [pc, #328]	; (b610 <uip_arp_out+0x204>)
    b4c6:	881b      	ldrh	r3, [r3, #0]
    b4c8:	ea82 0303 	eor.w	r3, r2, r3
    b4cc:	b29a      	uxth	r2, r3
    b4ce:	4b51      	ldr	r3, [pc, #324]	; (b614 <uip_arp_out+0x208>)
    b4d0:	881b      	ldrh	r3, [r3, #0]
    b4d2:	ea02 0303 	and.w	r3, r2, r3
    b4d6:	b29b      	uxth	r3, r3
    b4d8:	2b00      	cmp	r3, #0
    b4da:	d028      	beq.n	b52e <uip_arp_out+0x122>
		{
			/* Destination address was not on the local network, so we need to
	 use the default router's IP address instead of the destination
	 address when determining the MAC address. */
			uip_ipaddr_copy( &ipaddr, &uip_draddr );
    b4dc:	f64c 33a0 	movw	r3, #52128	; 0xcba0
    b4e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b4e4:	781a      	ldrb	r2, [r3, #0]
    b4e6:	f642 73dc 	movw	r3, #12252	; 0x2fdc
    b4ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b4ee:	701a      	strb	r2, [r3, #0]
    b4f0:	f64c 33a0 	movw	r3, #52128	; 0xcba0
    b4f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b4f8:	785a      	ldrb	r2, [r3, #1]
    b4fa:	f642 73dc 	movw	r3, #12252	; 0x2fdc
    b4fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b502:	705a      	strb	r2, [r3, #1]
    b504:	f64c 33a0 	movw	r3, #52128	; 0xcba0
    b508:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b50c:	789a      	ldrb	r2, [r3, #2]
    b50e:	f642 73dc 	movw	r3, #12252	; 0x2fdc
    b512:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b516:	709a      	strb	r2, [r3, #2]
    b518:	f64c 33a0 	movw	r3, #52128	; 0xcba0
    b51c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b520:	78da      	ldrb	r2, [r3, #3]
    b522:	f642 73dc 	movw	r3, #12252	; 0x2fdc
    b526:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b52a:	70da      	strb	r2, [r3, #3]
		memcpy( IPBUF->ethhdr.dest.addr, broadcast_ethaddr.addr, 6 );
	}
	else
	{
		/* Check if the destination address is on the local network. */
		if( !uip_ipaddr_maskcmp(&IPBUF->destipaddr, &uip_hostaddr, &uip_netmask) )
    b52c:	e02d      	b.n	b58a <uip_arp_out+0x17e>
			uip_ipaddr_copy( &ipaddr, &uip_draddr );
		}
		else
		{
			/* Else, we use the destination IP address. */
			uip_ipaddr_copy( &ipaddr, &IPBUF->destipaddr );
    b52e:	f240 6390 	movw	r3, #1680	; 0x690
    b532:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b536:	681b      	ldr	r3, [r3, #0]
    b538:	7f9a      	ldrb	r2, [r3, #30]
    b53a:	f642 73dc 	movw	r3, #12252	; 0x2fdc
    b53e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b542:	701a      	strb	r2, [r3, #0]
    b544:	f240 6390 	movw	r3, #1680	; 0x690
    b548:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b54c:	681b      	ldr	r3, [r3, #0]
    b54e:	7fda      	ldrb	r2, [r3, #31]
    b550:	f642 73dc 	movw	r3, #12252	; 0x2fdc
    b554:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b558:	705a      	strb	r2, [r3, #1]
    b55a:	f240 6390 	movw	r3, #1680	; 0x690
    b55e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b562:	681b      	ldr	r3, [r3, #0]
    b564:	f893 2020 	ldrb.w	r2, [r3, #32]
    b568:	f642 73dc 	movw	r3, #12252	; 0x2fdc
    b56c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b570:	709a      	strb	r2, [r3, #2]
    b572:	f240 6390 	movw	r3, #1680	; 0x690
    b576:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b57a:	681b      	ldr	r3, [r3, #0]
    b57c:	f893 2021 	ldrb.w	r2, [r3, #33]	; 0x21
    b580:	f642 73dc 	movw	r3, #12252	; 0x2fdc
    b584:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b588:	70da      	strb	r2, [r3, #3]
		}

		for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    b58a:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    b58e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b592:	f04f 0200 	mov.w	r2, #0
    b596:	701a      	strb	r2, [r3, #0]
    b598:	e031      	b.n	b5fe <uip_arp_out+0x1f2>
		{
			tabptr = &arp_table[i];
    b59a:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    b59e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b5a2:	781b      	ldrb	r3, [r3, #0]
    b5a4:	461a      	mov	r2, r3
    b5a6:	4613      	mov	r3, r2
    b5a8:	ea4f 0343 	mov.w	r3, r3, lsl #1
    b5ac:	4413      	add	r3, r2
    b5ae:	ea4f 0383 	mov.w	r3, r3, lsl #2
    b5b2:	461a      	mov	r2, r3
    b5b4:	f642 737c 	movw	r3, #12156	; 0x2f7c
    b5b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b5bc:	4413      	add	r3, r2
    b5be:	607b      	str	r3, [r7, #4]
			if( uip_ipaddr_cmp(&ipaddr, &tabptr->ipaddr) )
    b5c0:	f642 73dc 	movw	r3, #12252	; 0x2fdc
    b5c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b5c8:	881a      	ldrh	r2, [r3, #0]
    b5ca:	687b      	ldr	r3, [r7, #4]
    b5cc:	881b      	ldrh	r3, [r3, #0]
    b5ce:	429a      	cmp	r2, r3
    b5d0:	d108      	bne.n	b5e4 <uip_arp_out+0x1d8>
    b5d2:	f642 73dc 	movw	r3, #12252	; 0x2fdc
    b5d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b5da:	885a      	ldrh	r2, [r3, #2]
    b5dc:	687b      	ldr	r3, [r7, #4]
    b5de:	885b      	ldrh	r3, [r3, #2]
    b5e0:	429a      	cmp	r2, r3
    b5e2:	d019      	beq.n	b618 <uip_arp_out+0x20c>
		{
			/* Else, we use the destination IP address. */
			uip_ipaddr_copy( &ipaddr, &IPBUF->destipaddr );
		}

		for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    b5e4:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    b5e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b5ec:	781b      	ldrb	r3, [r3, #0]
    b5ee:	f103 0301 	add.w	r3, r3, #1
    b5f2:	b2da      	uxtb	r2, r3
    b5f4:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    b5f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b5fc:	701a      	strb	r2, [r3, #0]
    b5fe:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    b602:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b606:	781b      	ldrb	r3, [r3, #0]
    b608:	2b07      	cmp	r3, #7
    b60a:	d9c6      	bls.n	b59a <uip_arp_out+0x18e>
    b60c:	e005      	b.n	b61a <uip_arp_out+0x20e>
    b60e:	bf00      	nop
    b610:	2000cbe2 	.word	0x2000cbe2
    b614:	2000cbde 	.word	0x2000cbde
		{
			tabptr = &arp_table[i];
			if( uip_ipaddr_cmp(&ipaddr, &tabptr->ipaddr) )
			{
				break;
    b618:	bf00      	nop
			}
		}

		if( i == UIP_ARPTAB_SIZE )
    b61a:	f642 73e0 	movw	r3, #12256	; 0x2fe0
    b61e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b622:	781b      	ldrb	r3, [r3, #0]
    b624:	2b08      	cmp	r3, #8
    b626:	f040 80f8 	bne.w	b81a <uip_arp_out+0x40e>
		{
			/* The destination address was not in our ARP table, so we
	 overwrite the IP packet with an ARP request. */
			memset( BUF->ethhdr.dest.addr, 0xff, 6 );
    b62a:	f240 6390 	movw	r3, #1680	; 0x690
    b62e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b632:	681b      	ldr	r3, [r3, #0]
    b634:	4618      	mov	r0, r3
    b636:	f04f 01ff 	mov.w	r1, #255	; 0xff
    b63a:	f04f 0206 	mov.w	r2, #6
    b63e:	f006 faa1 	bl	11b84 <memset>
			memset( BUF->dhwaddr.addr, 0x00, 6 );
    b642:	f240 6390 	movw	r3, #1680	; 0x690
    b646:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b64a:	681b      	ldr	r3, [r3, #0]
    b64c:	f103 0320 	add.w	r3, r3, #32
    b650:	4618      	mov	r0, r3
    b652:	f04f 0100 	mov.w	r1, #0
    b656:	f04f 0206 	mov.w	r2, #6
    b65a:	f006 fa93 	bl	11b84 <memset>
			memcpy( BUF->ethhdr.src.addr, uip_ethaddr.addr, 6 );
    b65e:	f240 6390 	movw	r3, #1680	; 0x690
    b662:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b666:	681b      	ldr	r3, [r3, #0]
    b668:	f103 0306 	add.w	r3, r3, #6
    b66c:	4618      	mov	r0, r3
    b66e:	f642 7164 	movw	r1, #12132	; 0x2f64
    b672:	f2c2 0100 	movt	r1, #8192	; 0x2000
    b676:	f04f 0206 	mov.w	r2, #6
    b67a:	f006 f9bb 	bl	119f4 <memcpy>
			memcpy( BUF->shwaddr.addr, uip_ethaddr.addr, 6 );
    b67e:	f240 6390 	movw	r3, #1680	; 0x690
    b682:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b686:	681b      	ldr	r3, [r3, #0]
    b688:	f103 0316 	add.w	r3, r3, #22
    b68c:	4618      	mov	r0, r3
    b68e:	f642 7164 	movw	r1, #12132	; 0x2f64
    b692:	f2c2 0100 	movt	r1, #8192	; 0x2000
    b696:	f04f 0206 	mov.w	r2, #6
    b69a:	f006 f9ab 	bl	119f4 <memcpy>

			uip_ipaddr_copy( &BUF->dipaddr, &ipaddr );
    b69e:	f240 6390 	movw	r3, #1680	; 0x690
    b6a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b6a6:	681b      	ldr	r3, [r3, #0]
    b6a8:	461a      	mov	r2, r3
    b6aa:	f642 73dc 	movw	r3, #12252	; 0x2fdc
    b6ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b6b2:	781b      	ldrb	r3, [r3, #0]
    b6b4:	f882 3026 	strb.w	r3, [r2, #38]	; 0x26
    b6b8:	f240 6390 	movw	r3, #1680	; 0x690
    b6bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b6c0:	681b      	ldr	r3, [r3, #0]
    b6c2:	461a      	mov	r2, r3
    b6c4:	f642 73dc 	movw	r3, #12252	; 0x2fdc
    b6c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b6cc:	785b      	ldrb	r3, [r3, #1]
    b6ce:	f882 3027 	strb.w	r3, [r2, #39]	; 0x27
    b6d2:	f240 6390 	movw	r3, #1680	; 0x690
    b6d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b6da:	681b      	ldr	r3, [r3, #0]
    b6dc:	461a      	mov	r2, r3
    b6de:	f642 73dc 	movw	r3, #12252	; 0x2fdc
    b6e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b6e6:	789b      	ldrb	r3, [r3, #2]
    b6e8:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
    b6ec:	f240 6390 	movw	r3, #1680	; 0x690
    b6f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b6f4:	681b      	ldr	r3, [r3, #0]
    b6f6:	461a      	mov	r2, r3
    b6f8:	f642 73dc 	movw	r3, #12252	; 0x2fdc
    b6fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b700:	78db      	ldrb	r3, [r3, #3]
    b702:	f882 3029 	strb.w	r3, [r2, #41]	; 0x29
			uip_ipaddr_copy( &BUF->sipaddr, &uip_hostaddr );
    b706:	f240 6390 	movw	r3, #1680	; 0x690
    b70a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b70e:	681b      	ldr	r3, [r3, #0]
    b710:	461a      	mov	r2, r3
    b712:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    b716:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b71a:	781b      	ldrb	r3, [r3, #0]
    b71c:	7713      	strb	r3, [r2, #28]
    b71e:	f240 6390 	movw	r3, #1680	; 0x690
    b722:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b726:	681b      	ldr	r3, [r3, #0]
    b728:	461a      	mov	r2, r3
    b72a:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    b72e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b732:	785b      	ldrb	r3, [r3, #1]
    b734:	7753      	strb	r3, [r2, #29]
    b736:	f240 6390 	movw	r3, #1680	; 0x690
    b73a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b73e:	681b      	ldr	r3, [r3, #0]
    b740:	461a      	mov	r2, r3
    b742:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    b746:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b74a:	789b      	ldrb	r3, [r3, #2]
    b74c:	7793      	strb	r3, [r2, #30]
    b74e:	f240 6390 	movw	r3, #1680	; 0x690
    b752:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b756:	681b      	ldr	r3, [r3, #0]
    b758:	461a      	mov	r2, r3
    b75a:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
    b75e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b762:	78db      	ldrb	r3, [r3, #3]
    b764:	77d3      	strb	r3, [r2, #31]
			BUF->opcode = HTONS( ARP_REQUEST ); /* ARP request. */
    b766:	f240 6390 	movw	r3, #1680	; 0x690
    b76a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b76e:	681b      	ldr	r3, [r3, #0]
    b770:	f04f 0200 	mov.w	r2, #0
    b774:	751a      	strb	r2, [r3, #20]
    b776:	f04f 0200 	mov.w	r2, #0
    b77a:	f042 0201 	orr.w	r2, r2, #1
    b77e:	755a      	strb	r2, [r3, #21]
			BUF->hwtype = HTONS( ARP_HWTYPE_ETH );
    b780:	f240 6390 	movw	r3, #1680	; 0x690
    b784:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b788:	681b      	ldr	r3, [r3, #0]
    b78a:	f04f 0200 	mov.w	r2, #0
    b78e:	739a      	strb	r2, [r3, #14]
    b790:	f04f 0200 	mov.w	r2, #0
    b794:	f042 0201 	orr.w	r2, r2, #1
    b798:	73da      	strb	r2, [r3, #15]
			BUF->protocol = HTONS( UIP_ETHTYPE_IP );
    b79a:	f240 6390 	movw	r3, #1680	; 0x690
    b79e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b7a2:	681b      	ldr	r3, [r3, #0]
    b7a4:	f04f 0200 	mov.w	r2, #0
    b7a8:	f042 0208 	orr.w	r2, r2, #8
    b7ac:	741a      	strb	r2, [r3, #16]
    b7ae:	f04f 0200 	mov.w	r2, #0
    b7b2:	745a      	strb	r2, [r3, #17]
			BUF->hwlen = 6;
    b7b4:	f240 6390 	movw	r3, #1680	; 0x690
    b7b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b7bc:	681b      	ldr	r3, [r3, #0]
    b7be:	f04f 0206 	mov.w	r2, #6
    b7c2:	749a      	strb	r2, [r3, #18]
			BUF->protolen = 4;
    b7c4:	f240 6390 	movw	r3, #1680	; 0x690
    b7c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b7cc:	681b      	ldr	r3, [r3, #0]
    b7ce:	f04f 0204 	mov.w	r2, #4
    b7d2:	74da      	strb	r2, [r3, #19]
			BUF->ethhdr.type = HTONS( UIP_ETHTYPE_ARP );
    b7d4:	f240 6390 	movw	r3, #1680	; 0x690
    b7d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b7dc:	681b      	ldr	r3, [r3, #0]
    b7de:	f04f 0200 	mov.w	r2, #0
    b7e2:	f042 0208 	orr.w	r2, r2, #8
    b7e6:	731a      	strb	r2, [r3, #12]
    b7e8:	f04f 0200 	mov.w	r2, #0
    b7ec:	f042 0206 	orr.w	r2, r2, #6
    b7f0:	735a      	strb	r2, [r3, #13]

			uip_appdata = &uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN];
    b7f2:	f240 6390 	movw	r3, #1680	; 0x690
    b7f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b7fa:	681b      	ldr	r3, [r3, #0]
    b7fc:	f103 0236 	add.w	r2, r3, #54	; 0x36
    b800:	f64a 3368 	movw	r3, #43880	; 0xab68
    b804:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b808:	601a      	str	r2, [r3, #0]

			uip_len = sizeof( struct arp_hdr );
    b80a:	f64a 3358 	movw	r3, #43864	; 0xab58
    b80e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b812:	f04f 022a 	mov.w	r2, #42	; 0x2a
    b816:	801a      	strh	r2, [r3, #0]
			return;
    b818:	e038      	b.n	b88c <uip_arp_out+0x480>
		}

		/* Build an ethernet header. */
		memcpy( IPBUF->ethhdr.dest.addr, tabptr->ethaddr.addr, 6 );
    b81a:	f240 6390 	movw	r3, #1680	; 0x690
    b81e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b822:	681b      	ldr	r3, [r3, #0]
    b824:	461a      	mov	r2, r3
    b826:	687b      	ldr	r3, [r7, #4]
    b828:	f103 0304 	add.w	r3, r3, #4
    b82c:	4610      	mov	r0, r2
    b82e:	4619      	mov	r1, r3
    b830:	f04f 0206 	mov.w	r2, #6
    b834:	f006 f8de 	bl	119f4 <memcpy>
	}

	memcpy( IPBUF->ethhdr.src.addr, uip_ethaddr.addr, 6 );
    b838:	f240 6390 	movw	r3, #1680	; 0x690
    b83c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b840:	681b      	ldr	r3, [r3, #0]
    b842:	f103 0306 	add.w	r3, r3, #6
    b846:	4618      	mov	r0, r3
    b848:	f642 7164 	movw	r1, #12132	; 0x2f64
    b84c:	f2c2 0100 	movt	r1, #8192	; 0x2000
    b850:	f04f 0206 	mov.w	r2, #6
    b854:	f006 f8ce 	bl	119f4 <memcpy>

	IPBUF->ethhdr.type = HTONS( UIP_ETHTYPE_IP );
    b858:	f240 6390 	movw	r3, #1680	; 0x690
    b85c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b860:	681b      	ldr	r3, [r3, #0]
    b862:	f04f 0200 	mov.w	r2, #0
    b866:	f042 0208 	orr.w	r2, r2, #8
    b86a:	731a      	strb	r2, [r3, #12]
    b86c:	f04f 0200 	mov.w	r2, #0
    b870:	735a      	strb	r2, [r3, #13]

	uip_len += sizeof( struct uip_eth_hdr );
    b872:	f64a 3358 	movw	r3, #43864	; 0xab58
    b876:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b87a:	881b      	ldrh	r3, [r3, #0]
    b87c:	f103 030e 	add.w	r3, r3, #14
    b880:	b29a      	uxth	r2, r3
    b882:	f64a 3358 	movw	r3, #43864	; 0xab58
    b886:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b88a:	801a      	strh	r2, [r3, #0]
}
    b88c:	f107 0708 	add.w	r7, r7, #8
    b890:	46bd      	mov	sp, r7
    b892:	bd80      	pop	{r7, pc}

0000b894 <httpd_fs_strcmp>:
static u16_t	count[HTTPD_FS_NUMFILES];
#endif /* HTTPD_FS_STATISTICS */

/*-----------------------------------------------------------------------------------*/
static u8_t httpd_fs_strcmp( const char *str1, const char *str2 )
{
    b894:	b480      	push	{r7}
    b896:	b085      	sub	sp, #20
    b898:	af00      	add	r7, sp, #0
    b89a:	6078      	str	r0, [r7, #4]
    b89c:	6039      	str	r1, [r7, #0]
	u8_t	i;
	i = 0;
    b89e:	f04f 0300 	mov.w	r3, #0
    b8a2:	73fb      	strb	r3, [r7, #15]
loop:
	if( str2[i] == 0 || str1[i] == '\r' || str1[i] == '\n' )
    b8a4:	7bfa      	ldrb	r2, [r7, #15]
    b8a6:	683b      	ldr	r3, [r7, #0]
    b8a8:	4413      	add	r3, r2
    b8aa:	781b      	ldrb	r3, [r3, #0]
    b8ac:	2b00      	cmp	r3, #0
    b8ae:	d00b      	beq.n	b8c8 <httpd_fs_strcmp+0x34>
    b8b0:	7bfa      	ldrb	r2, [r7, #15]
    b8b2:	687b      	ldr	r3, [r7, #4]
    b8b4:	4413      	add	r3, r2
    b8b6:	781b      	ldrb	r3, [r3, #0]
    b8b8:	2b0d      	cmp	r3, #13
    b8ba:	d005      	beq.n	b8c8 <httpd_fs_strcmp+0x34>
    b8bc:	7bfa      	ldrb	r2, [r7, #15]
    b8be:	687b      	ldr	r3, [r7, #4]
    b8c0:	4413      	add	r3, r2
    b8c2:	781b      	ldrb	r3, [r3, #0]
    b8c4:	2b0a      	cmp	r3, #10
    b8c6:	d102      	bne.n	b8ce <httpd_fs_strcmp+0x3a>
	{
		return 0;
    b8c8:	f04f 0300 	mov.w	r3, #0
    b8cc:	e011      	b.n	b8f2 <httpd_fs_strcmp+0x5e>
	}

	if( str1[i] != str2[i] )
    b8ce:	7bfa      	ldrb	r2, [r7, #15]
    b8d0:	687b      	ldr	r3, [r7, #4]
    b8d2:	4413      	add	r3, r2
    b8d4:	781a      	ldrb	r2, [r3, #0]
    b8d6:	7bf9      	ldrb	r1, [r7, #15]
    b8d8:	683b      	ldr	r3, [r7, #0]
    b8da:	440b      	add	r3, r1
    b8dc:	781b      	ldrb	r3, [r3, #0]
    b8de:	429a      	cmp	r2, r3
    b8e0:	d002      	beq.n	b8e8 <httpd_fs_strcmp+0x54>
	{
		return 1;
    b8e2:	f04f 0301 	mov.w	r3, #1
    b8e6:	e004      	b.n	b8f2 <httpd_fs_strcmp+0x5e>
	}

	++i;
    b8e8:	7bfb      	ldrb	r3, [r7, #15]
    b8ea:	f103 0301 	add.w	r3, r3, #1
    b8ee:	73fb      	strb	r3, [r7, #15]
	goto loop;
    b8f0:	e7d8      	b.n	b8a4 <httpd_fs_strcmp+0x10>
}
    b8f2:	4618      	mov	r0, r3
    b8f4:	f107 0714 	add.w	r7, r7, #20
    b8f8:	46bd      	mov	sp, r7
    b8fa:	bc80      	pop	{r7}
    b8fc:	4770      	bx	lr
    b8fe:	bf00      	nop

0000b900 <httpd_fs_open>:

/*-----------------------------------------------------------------------------------*/
int httpd_fs_open( const char *name, struct httpd_fs_file *file )
{
    b900:	b580      	push	{r7, lr}
    b902:	b084      	sub	sp, #16
    b904:	af00      	add	r7, sp, #0
    b906:	6078      	str	r0, [r7, #4]
    b908:	6039      	str	r1, [r7, #0]
#if HTTPD_FS_STATISTICS
	u16_t								i = 0;
    b90a:	f04f 0300 	mov.w	r3, #0
    b90e:	817b      	strh	r3, [r7, #10]
#endif /* HTTPD_FS_STATISTICS */
	struct httpd_fsdata_file_noconst	*f;

	for( f = ( struct httpd_fsdata_file_noconst * ) HTTPD_FS_ROOT; f != NULL; f = ( struct httpd_fsdata_file_noconst * ) f->next )
    b910:	f24c 23cc 	movw	r3, #49868	; 0xc2cc
    b914:	f2c0 0301 	movt	r3, #1
    b918:	60fb      	str	r3, [r7, #12]
    b91a:	e02a      	b.n	b972 <httpd_fs_open+0x72>
	{
		if( httpd_fs_strcmp(name, f->name) == 0 )
    b91c:	68fb      	ldr	r3, [r7, #12]
    b91e:	685b      	ldr	r3, [r3, #4]
    b920:	6878      	ldr	r0, [r7, #4]
    b922:	4619      	mov	r1, r3
    b924:	f7ff ffb6 	bl	b894 <httpd_fs_strcmp>
    b928:	4603      	mov	r3, r0
    b92a:	2b00      	cmp	r3, #0
    b92c:	d11a      	bne.n	b964 <httpd_fs_open+0x64>
		{
			file->data = f->data;
    b92e:	68fb      	ldr	r3, [r7, #12]
    b930:	689a      	ldr	r2, [r3, #8]
    b932:	683b      	ldr	r3, [r7, #0]
    b934:	601a      	str	r2, [r3, #0]
			file->len = f->len;
    b936:	68fb      	ldr	r3, [r7, #12]
    b938:	68da      	ldr	r2, [r3, #12]
    b93a:	683b      	ldr	r3, [r7, #0]
    b93c:	605a      	str	r2, [r3, #4]
#if HTTPD_FS_STATISTICS
			++count[i];
    b93e:	897a      	ldrh	r2, [r7, #10]
    b940:	f642 73e4 	movw	r3, #12260	; 0x2fe4
    b944:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b948:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    b94c:	f103 0301 	add.w	r3, r3, #1
    b950:	b299      	uxth	r1, r3
    b952:	f642 73e4 	movw	r3, #12260	; 0x2fe4
    b956:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b95a:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
#endif /* HTTPD_FS_STATISTICS */
			return 1;
    b95e:	f04f 0301 	mov.w	r3, #1
    b962:	e00b      	b.n	b97c <httpd_fs_open+0x7c>
		}

#if HTTPD_FS_STATISTICS
		++i;
    b964:	897b      	ldrh	r3, [r7, #10]
    b966:	f103 0301 	add.w	r3, r3, #1
    b96a:	817b      	strh	r3, [r7, #10]
#if HTTPD_FS_STATISTICS
	u16_t								i = 0;
#endif /* HTTPD_FS_STATISTICS */
	struct httpd_fsdata_file_noconst	*f;

	for( f = ( struct httpd_fsdata_file_noconst * ) HTTPD_FS_ROOT; f != NULL; f = ( struct httpd_fsdata_file_noconst * ) f->next )
    b96c:	68fb      	ldr	r3, [r7, #12]
    b96e:	681b      	ldr	r3, [r3, #0]
    b970:	60fb      	str	r3, [r7, #12]
    b972:	68fb      	ldr	r3, [r7, #12]
    b974:	2b00      	cmp	r3, #0
    b976:	d1d1      	bne.n	b91c <httpd_fs_open+0x1c>
#if HTTPD_FS_STATISTICS
		++i;
#endif /* HTTPD_FS_STATISTICS */
	}

	return 0;
    b978:	f04f 0300 	mov.w	r3, #0
}
    b97c:	4618      	mov	r0, r3
    b97e:	f107 0710 	add.w	r7, r7, #16
    b982:	46bd      	mov	sp, r7
    b984:	bd80      	pop	{r7, pc}
    b986:	bf00      	nop

0000b988 <httpd_fs_init>:

/*-----------------------------------------------------------------------------------*/
void httpd_fs_init( void )
{
    b988:	b480      	push	{r7}
    b98a:	b083      	sub	sp, #12
    b98c:	af00      	add	r7, sp, #0
#if HTTPD_FS_STATISTICS
	u16_t	i;
	for( i = 0; i < HTTPD_FS_NUMFILES; i++ )
    b98e:	f04f 0300 	mov.w	r3, #0
    b992:	80fb      	strh	r3, [r7, #6]
    b994:	e00c      	b.n	b9b0 <httpd_fs_init+0x28>
	{
		count[i] = 0;
    b996:	88fa      	ldrh	r2, [r7, #6]
    b998:	f642 73e4 	movw	r3, #12260	; 0x2fe4
    b99c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b9a0:	f04f 0100 	mov.w	r1, #0
    b9a4:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
/*-----------------------------------------------------------------------------------*/
void httpd_fs_init( void )
{
#if HTTPD_FS_STATISTICS
	u16_t	i;
	for( i = 0; i < HTTPD_FS_NUMFILES; i++ )
    b9a8:	88fb      	ldrh	r3, [r7, #6]
    b9aa:	f103 0301 	add.w	r3, r3, #1
    b9ae:	80fb      	strh	r3, [r7, #6]
    b9b0:	88fb      	ldrh	r3, [r7, #6]
    b9b2:	2b06      	cmp	r3, #6
    b9b4:	d9ef      	bls.n	b996 <httpd_fs_init+0xe>
	{
		count[i] = 0;
	}

#endif /* HTTPD_FS_STATISTICS */
}
    b9b6:	f107 070c 	add.w	r7, r7, #12
    b9ba:	46bd      	mov	sp, r7
    b9bc:	bc80      	pop	{r7}
    b9be:	4770      	bx	lr

0000b9c0 <httpd_fs_count>:

/*-----------------------------------------------------------------------------------*/
#if HTTPD_FS_STATISTICS
u16_t httpd_fs_count( char *name )
{
    b9c0:	b580      	push	{r7, lr}
    b9c2:	b084      	sub	sp, #16
    b9c4:	af00      	add	r7, sp, #0
    b9c6:	6078      	str	r0, [r7, #4]
	struct httpd_fsdata_file_noconst	*f;
	u16_t								i;

	i = 0;
    b9c8:	f04f 0300 	mov.w	r3, #0
    b9cc:	81fb      	strh	r3, [r7, #14]
	for( f = ( struct httpd_fsdata_file_noconst * ) HTTPD_FS_ROOT; f != NULL; f = ( struct httpd_fsdata_file_noconst * ) f->next )
    b9ce:	f24c 23cc 	movw	r3, #49868	; 0xc2cc
    b9d2:	f2c0 0301 	movt	r3, #1
    b9d6:	60bb      	str	r3, [r7, #8]
    b9d8:	e017      	b.n	ba0a <httpd_fs_count+0x4a>
	{
		if( httpd_fs_strcmp(name, f->name) == 0 )
    b9da:	68bb      	ldr	r3, [r7, #8]
    b9dc:	685b      	ldr	r3, [r3, #4]
    b9de:	6878      	ldr	r0, [r7, #4]
    b9e0:	4619      	mov	r1, r3
    b9e2:	f7ff ff57 	bl	b894 <httpd_fs_strcmp>
    b9e6:	4603      	mov	r3, r0
    b9e8:	2b00      	cmp	r3, #0
    b9ea:	d107      	bne.n	b9fc <httpd_fs_count+0x3c>
		{
			return count[i];
    b9ec:	89fa      	ldrh	r2, [r7, #14]
    b9ee:	f642 73e4 	movw	r3, #12260	; 0x2fe4
    b9f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b9f6:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    b9fa:	e00b      	b.n	ba14 <httpd_fs_count+0x54>
		}

		++i;
    b9fc:	89fb      	ldrh	r3, [r7, #14]
    b9fe:	f103 0301 	add.w	r3, r3, #1
    ba02:	81fb      	strh	r3, [r7, #14]
{
	struct httpd_fsdata_file_noconst	*f;
	u16_t								i;

	i = 0;
	for( f = ( struct httpd_fsdata_file_noconst * ) HTTPD_FS_ROOT; f != NULL; f = ( struct httpd_fsdata_file_noconst * ) f->next )
    ba04:	68bb      	ldr	r3, [r7, #8]
    ba06:	681b      	ldr	r3, [r3, #0]
    ba08:	60bb      	str	r3, [r7, #8]
    ba0a:	68bb      	ldr	r3, [r7, #8]
    ba0c:	2b00      	cmp	r3, #0
    ba0e:	d1e4      	bne.n	b9da <httpd_fs_count+0x1a>
		}

		++i;
	}

	return 0;
    ba10:	f04f 0300 	mov.w	r3, #0
}
    ba14:	4618      	mov	r0, r3
    ba16:	f107 0710 	add.w	r7, r7, #16
    ba1a:	46bd      	mov	sp, r7
    ba1c:	bd80      	pop	{r7, pc}
    ba1e:	bf00      	nop

0000ba20 <generate_part_of_file>:
#define ISO_slash		0x2f
#define ISO_colon		0x3a

/*---------------------------------------------------------------------------*/
static unsigned short generate_part_of_file( void *state )
{
    ba20:	b580      	push	{r7, lr}
    ba22:	b084      	sub	sp, #16
    ba24:	af00      	add	r7, sp, #0
    ba26:	6078      	str	r0, [r7, #4]
	struct httpd_state	*s = ( struct httpd_state * ) state;
    ba28:	687b      	ldr	r3, [r7, #4]
    ba2a:	60fb      	str	r3, [r7, #12]

	if( s->file.len > uip_mss() )
    ba2c:	68fb      	ldr	r3, [r7, #12]
    ba2e:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
    ba32:	f64a 336c 	movw	r3, #43884	; 0xab6c
    ba36:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ba3a:	681b      	ldr	r3, [r3, #0]
    ba3c:	8a5b      	ldrh	r3, [r3, #18]
    ba3e:	429a      	cmp	r2, r3
    ba40:	dd0a      	ble.n	ba58 <generate_part_of_file+0x38>
	{
		s->len = uip_mss();
    ba42:	f64a 336c 	movw	r3, #43884	; 0xab6c
    ba46:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ba4a:	681b      	ldr	r3, [r3, #0]
    ba4c:	8a5b      	ldrh	r3, [r3, #18]
    ba4e:	461a      	mov	r2, r3
    ba50:	68fb      	ldr	r3, [r7, #12]
    ba52:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    ba56:	e005      	b.n	ba64 <generate_part_of_file+0x44>
	}
	else
	{
		s->len = s->file.len;
    ba58:	68fb      	ldr	r3, [r7, #12]
    ba5a:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
    ba5e:	68fb      	ldr	r3, [r7, #12]
    ba60:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	}

	memcpy( uip_appdata, s->file.data, s->len );
    ba64:	f64a 3368 	movw	r3, #43880	; 0xab68
    ba68:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ba6c:	6819      	ldr	r1, [r3, #0]
    ba6e:	68fb      	ldr	r3, [r7, #12]
    ba70:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
    ba74:	68fb      	ldr	r3, [r7, #12]
    ba76:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    ba7a:	4608      	mov	r0, r1
    ba7c:	4611      	mov	r1, r2
    ba7e:	461a      	mov	r2, r3
    ba80:	f005 ffb8 	bl	119f4 <memcpy>

	return s->len;
    ba84:	68fb      	ldr	r3, [r7, #12]
    ba86:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    ba8a:	b29b      	uxth	r3, r3
}
    ba8c:	4618      	mov	r0, r3
    ba8e:	f107 0710 	add.w	r7, r7, #16
    ba92:	46bd      	mov	sp, r7
    ba94:	bd80      	pop	{r7, pc}
    ba96:	bf00      	nop

0000ba98 <send_file>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( send_file ( struct httpd_state *s ) )
{
    ba98:	b580      	push	{r7, lr}
    ba9a:	b084      	sub	sp, #16
    ba9c:	af00      	add	r7, sp, #0
    ba9e:	6078      	str	r0, [r7, #4]
	PSOCK_BEGIN( &s->sout );
    baa0:	f04f 0301 	mov.w	r3, #1
    baa4:	73fb      	strb	r3, [r7, #15]
    baa6:	687b      	ldr	r3, [r7, #4]
    baa8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    baaa:	2b00      	cmp	r3, #0
    baac:	d002      	beq.n	bab4 <send_file+0x1c>
    baae:	2b67      	cmp	r3, #103	; 0x67
    bab0:	d004      	beq.n	babc <send_file+0x24>
    bab2:	e02e      	b.n	bb12 <send_file+0x7a>

	( void ) PT_YIELD_FLAG;
	
	do
	{
		PSOCK_GENERATOR_SEND( &s->sout, generate_part_of_file, s );
    bab4:	687b      	ldr	r3, [r7, #4]
    bab6:	f04f 0267 	mov.w	r2, #103	; 0x67
    baba:	851a      	strh	r2, [r3, #40]	; 0x28
    babc:	687b      	ldr	r3, [r7, #4]
    babe:	f103 0328 	add.w	r3, r3, #40	; 0x28
    bac2:	4618      	mov	r0, r3
    bac4:	f64b 2121 	movw	r1, #47649	; 0xba21
    bac8:	f2c0 0100 	movt	r1, #0
    bacc:	687a      	ldr	r2, [r7, #4]
    bace:	f7fc fa2d 	bl	7f2c <psock_generator_send>
    bad2:	4603      	mov	r3, r0
    bad4:	2b00      	cmp	r3, #0
    bad6:	d102      	bne.n	bade <send_file+0x46>
    bad8:	f04f 0300 	mov.w	r3, #0
    badc:	e022      	b.n	bb24 <send_file+0x8c>
		s->file.len -= s->len;
    bade:	687b      	ldr	r3, [r7, #4]
    bae0:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
    bae4:	687b      	ldr	r3, [r7, #4]
    bae6:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    baea:	ebc3 0202 	rsb	r2, r3, r2
    baee:	687b      	ldr	r3, [r7, #4]
    baf0:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
		s->file.data += s->len;
    baf4:	687b      	ldr	r3, [r7, #4]
    baf6:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
    bafa:	687b      	ldr	r3, [r7, #4]
    bafc:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    bb00:	441a      	add	r2, r3
    bb02:	687b      	ldr	r3, [r7, #4]
    bb04:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
	} while( s->file.len > 0 );
    bb08:	687b      	ldr	r3, [r7, #4]
    bb0a:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
    bb0e:	2b00      	cmp	r3, #0
    bb10:	dcd0      	bgt.n	bab4 <send_file+0x1c>

	PSOCK_END( &s->sout );
    bb12:	f04f 0300 	mov.w	r3, #0
    bb16:	73fb      	strb	r3, [r7, #15]
    bb18:	687b      	ldr	r3, [r7, #4]
    bb1a:	f04f 0200 	mov.w	r2, #0
    bb1e:	851a      	strh	r2, [r3, #40]	; 0x28
    bb20:	f04f 0302 	mov.w	r3, #2
}
    bb24:	4618      	mov	r0, r3
    bb26:	f107 0710 	add.w	r7, r7, #16
    bb2a:	46bd      	mov	sp, r7
    bb2c:	bd80      	pop	{r7, pc}
    bb2e:	bf00      	nop

0000bb30 <send_part_of_file>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( send_part_of_file ( struct httpd_state *s ) )
{
    bb30:	b580      	push	{r7, lr}
    bb32:	b084      	sub	sp, #16
    bb34:	af00      	add	r7, sp, #0
    bb36:	6078      	str	r0, [r7, #4]
	PSOCK_BEGIN( &s->sout );
    bb38:	f04f 0301 	mov.w	r3, #1
    bb3c:	73fb      	strb	r3, [r7, #15]
    bb3e:	687b      	ldr	r3, [r7, #4]
    bb40:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    bb42:	2b00      	cmp	r3, #0
    bb44:	d002      	beq.n	bb4c <send_part_of_file+0x1c>
    bb46:	2b75      	cmp	r3, #117	; 0x75
    bb48:	d004      	beq.n	bb54 <send_part_of_file+0x24>
    bb4a:	e017      	b.n	bb7c <send_part_of_file+0x4c>
	( void ) PT_YIELD_FLAG;
	
	PSOCK_SEND( &s->sout, s->file.data, s->len );
    bb4c:	687b      	ldr	r3, [r7, #4]
    bb4e:	f04f 0275 	mov.w	r2, #117	; 0x75
    bb52:	851a      	strh	r2, [r3, #40]	; 0x28
    bb54:	687b      	ldr	r3, [r7, #4]
    bb56:	f103 0128 	add.w	r1, r3, #40	; 0x28
    bb5a:	687b      	ldr	r3, [r7, #4]
    bb5c:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
    bb60:	687b      	ldr	r3, [r7, #4]
    bb62:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    bb66:	4608      	mov	r0, r1
    bb68:	4611      	mov	r1, r2
    bb6a:	461a      	mov	r2, r3
    bb6c:	f7fc f994 	bl	7e98 <psock_send>
    bb70:	4603      	mov	r3, r0
    bb72:	2b00      	cmp	r3, #0
    bb74:	d102      	bne.n	bb7c <send_part_of_file+0x4c>
    bb76:	f04f 0300 	mov.w	r3, #0
    bb7a:	e008      	b.n	bb8e <send_part_of_file+0x5e>

	PSOCK_END( &s->sout );
    bb7c:	f04f 0300 	mov.w	r3, #0
    bb80:	73fb      	strb	r3, [r7, #15]
    bb82:	687b      	ldr	r3, [r7, #4]
    bb84:	f04f 0200 	mov.w	r2, #0
    bb88:	851a      	strh	r2, [r3, #40]	; 0x28
    bb8a:	f04f 0302 	mov.w	r3, #2
}
    bb8e:	4618      	mov	r0, r3
    bb90:	f107 0710 	add.w	r7, r7, #16
    bb94:	46bd      	mov	sp, r7
    bb96:	bd80      	pop	{r7, pc}

0000bb98 <next_scriptstate>:

/*---------------------------------------------------------------------------*/
static void next_scriptstate( struct httpd_state *s )
{
    bb98:	b580      	push	{r7, lr}
    bb9a:	b084      	sub	sp, #16
    bb9c:	af00      	add	r7, sp, #0
    bb9e:	6078      	str	r0, [r7, #4]
	char	*p;
	p = strchr( s->scriptptr, ISO_nl ) + 1;
    bba0:	687b      	ldr	r3, [r7, #4]
    bba2:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
    bba6:	4618      	mov	r0, r3
    bba8:	f04f 010a 	mov.w	r1, #10
    bbac:	f006 f9bc 	bl	11f28 <strchr>
    bbb0:	4603      	mov	r3, r0
    bbb2:	f103 0301 	add.w	r3, r3, #1
    bbb6:	60fb      	str	r3, [r7, #12]
	s->scriptlen -= ( unsigned short ) ( p - s->scriptptr );
    bbb8:	687b      	ldr	r3, [r7, #4]
    bbba:	f8d3 20a8 	ldr.w	r2, [r3, #168]	; 0xa8
    bbbe:	68fb      	ldr	r3, [r7, #12]
    bbc0:	b299      	uxth	r1, r3
    bbc2:	687b      	ldr	r3, [r7, #4]
    bbc4:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
    bbc8:	b29b      	uxth	r3, r3
    bbca:	ebc3 0301 	rsb	r3, r3, r1
    bbce:	b29b      	uxth	r3, r3
    bbd0:	ebc3 0202 	rsb	r2, r3, r2
    bbd4:	687b      	ldr	r3, [r7, #4]
    bbd6:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	s->scriptptr = p;
    bbda:	687b      	ldr	r3, [r7, #4]
    bbdc:	68fa      	ldr	r2, [r7, #12]
    bbde:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
}
    bbe2:	f107 0710 	add.w	r7, r7, #16
    bbe6:	46bd      	mov	sp, r7
    bbe8:	bd80      	pop	{r7, pc}
    bbea:	bf00      	nop

0000bbec <handle_script>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( handle_script ( struct httpd_state *s ) )
{
    bbec:	b580      	push	{r7, lr}
    bbee:	b084      	sub	sp, #16
    bbf0:	af00      	add	r7, sp, #0
    bbf2:	6078      	str	r0, [r7, #4]
	char	*ptr;

	PT_BEGIN( &s->scriptpt );
    bbf4:	f04f 0301 	mov.w	r3, #1
    bbf8:	73fb      	strb	r3, [r7, #15]
    bbfa:	687b      	ldr	r3, [r7, #4]
    bbfc:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
    bc00:	2b94      	cmp	r3, #148	; 0x94
    bc02:	d042      	beq.n	bc8a <handle_script+0x9e>
    bc04:	2b94      	cmp	r3, #148	; 0x94
    bc06:	dc03      	bgt.n	bc10 <handle_script+0x24>
    bc08:	2b00      	cmp	r3, #0
    bc0a:	f000 80f3 	beq.w	bdf4 <handle_script+0x208>
    bc0e:	e0f8      	b.n	be02 <handle_script+0x216>
    bc10:	2b98      	cmp	r3, #152	; 0x98
    bc12:	d048      	beq.n	bca6 <handle_script+0xba>
    bc14:	2bc1      	cmp	r3, #193	; 0xc1
    bc16:	f000 80ce 	beq.w	bdb6 <handle_script+0x1ca>
    bc1a:	e0f2      	b.n	be02 <handle_script+0x216>
	( void ) PT_YIELD_FLAG;
	while( s->file.len > 0 )
	{
		/* Check if we should start executing a script. */
		if( *s->file.data == ISO_percent && *(s->file.data + 1) == ISO_bang )
    bc1c:	687b      	ldr	r3, [r7, #4]
    bc1e:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    bc22:	781b      	ldrb	r3, [r3, #0]
    bc24:	2b25      	cmp	r3, #37	; 0x25
    bc26:	d161      	bne.n	bcec <handle_script+0x100>
    bc28:	687b      	ldr	r3, [r7, #4]
    bc2a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    bc2e:	f103 0301 	add.w	r3, r3, #1
    bc32:	781b      	ldrb	r3, [r3, #0]
    bc34:	2b21      	cmp	r3, #33	; 0x21
    bc36:	d159      	bne.n	bcec <handle_script+0x100>
		{
			s->scriptptr = s->file.data + 3;
    bc38:	687b      	ldr	r3, [r7, #4]
    bc3a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    bc3e:	f103 0203 	add.w	r2, r3, #3
    bc42:	687b      	ldr	r3, [r7, #4]
    bc44:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
			s->scriptlen = s->file.len - 3;
    bc48:	687b      	ldr	r3, [r7, #4]
    bc4a:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
    bc4e:	f1a3 0203 	sub.w	r2, r3, #3
    bc52:	687b      	ldr	r3, [r7, #4]
    bc54:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
			if( *(s->scriptptr - 1) == ISO_colon )
    bc58:	687b      	ldr	r3, [r7, #4]
    bc5a:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
    bc5e:	f103 33ff 	add.w	r3, r3, #4294967295
    bc62:	781b      	ldrb	r3, [r3, #0]
    bc64:	2b3a      	cmp	r3, #58	; 0x3a
    bc66:	d119      	bne.n	bc9c <handle_script+0xb0>
			{
				httpd_fs_open( s->scriptptr + 1, &s->file );
    bc68:	687b      	ldr	r3, [r7, #4]
    bc6a:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
    bc6e:	f103 0201 	add.w	r2, r3, #1
    bc72:	687b      	ldr	r3, [r7, #4]
    bc74:	f103 0398 	add.w	r3, r3, #152	; 0x98
    bc78:	4610      	mov	r0, r2
    bc7a:	4619      	mov	r1, r3
    bc7c:	f7ff fe40 	bl	b900 <httpd_fs_open>
				PT_WAIT_THREAD( &s->scriptpt, send_file(s) );
    bc80:	687b      	ldr	r3, [r7, #4]
    bc82:	f04f 0294 	mov.w	r2, #148	; 0x94
    bc86:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    bc8a:	6878      	ldr	r0, [r7, #4]
    bc8c:	f7ff ff04 	bl	ba98 <send_file>
    bc90:	4603      	mov	r3, r0
    bc92:	2b00      	cmp	r3, #0
    bc94:	d11a      	bne.n	bccc <handle_script+0xe0>
    bc96:	f04f 0300 	mov.w	r3, #0
    bc9a:	e0bc      	b.n	be16 <handle_script+0x22a>
			}
			else
			{
				PT_WAIT_THREAD( &s->scriptpt, httpd_cgi(s->scriptptr) (s, s->scriptptr) );
    bc9c:	687b      	ldr	r3, [r7, #4]
    bc9e:	f04f 0298 	mov.w	r2, #152	; 0x98
    bca2:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    bca6:	687b      	ldr	r3, [r7, #4]
    bca8:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
    bcac:	4618      	mov	r0, r3
    bcae:	f7f5 fdbf 	bl	1830 <httpd_cgi>
    bcb2:	4603      	mov	r3, r0
    bcb4:	687a      	ldr	r2, [r7, #4]
    bcb6:	f8d2 20a4 	ldr.w	r2, [r2, #164]	; 0xa4
    bcba:	6878      	ldr	r0, [r7, #4]
    bcbc:	4611      	mov	r1, r2
    bcbe:	4798      	blx	r3
    bcc0:	4603      	mov	r3, r0
    bcc2:	2b00      	cmp	r3, #0
    bcc4:	d102      	bne.n	bccc <handle_script+0xe0>
    bcc6:	f04f 0300 	mov.w	r3, #0
    bcca:	e0a4      	b.n	be16 <handle_script+0x22a>
			}

			next_scriptstate( s );
    bccc:	6878      	ldr	r0, [r7, #4]
    bcce:	f7ff ff63 	bl	bb98 <next_scriptstate>

			/* The script is over, so we reset the pointers and continue
	 		sending the rest of the file. */
			s->file.data = s->scriptptr;
    bcd2:	687b      	ldr	r3, [r7, #4]
    bcd4:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
    bcd8:	687b      	ldr	r3, [r7, #4]
    bcda:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
			s->file.len = s->scriptlen;
    bcde:	687b      	ldr	r3, [r7, #4]
    bce0:	f8d3 20a8 	ldr.w	r2, [r3, #168]	; 0xa8
    bce4:	687b      	ldr	r3, [r7, #4]
    bce6:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
	PT_BEGIN( &s->scriptpt );
	( void ) PT_YIELD_FLAG;
	while( s->file.len > 0 )
	{
		/* Check if we should start executing a script. */
		if( *s->file.data == ISO_percent && *(s->file.data + 1) == ISO_bang )
    bcea:	e084      	b.n	bdf6 <handle_script+0x20a>
		}
		else
		{
			/* See if we find the start of script marker in the block of HTML
	 to be sent. */
			if( s->file.len > uip_mss() )
    bcec:	687b      	ldr	r3, [r7, #4]
    bcee:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
    bcf2:	f64a 336c 	movw	r3, #43884	; 0xab6c
    bcf6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bcfa:	681b      	ldr	r3, [r3, #0]
    bcfc:	8a5b      	ldrh	r3, [r3, #18]
    bcfe:	429a      	cmp	r2, r3
    bd00:	dd0a      	ble.n	bd18 <handle_script+0x12c>
			{
				s->len = uip_mss();
    bd02:	f64a 336c 	movw	r3, #43884	; 0xab6c
    bd06:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bd0a:	681b      	ldr	r3, [r3, #0]
    bd0c:	8a5b      	ldrh	r3, [r3, #18]
    bd0e:	461a      	mov	r2, r3
    bd10:	687b      	ldr	r3, [r7, #4]
    bd12:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    bd16:	e005      	b.n	bd24 <handle_script+0x138>
			}
			else
			{
				s->len = s->file.len;
    bd18:	687b      	ldr	r3, [r7, #4]
    bd1a:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
    bd1e:	687b      	ldr	r3, [r7, #4]
    bd20:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
			}

			if( *s->file.data == ISO_percent )
    bd24:	687b      	ldr	r3, [r7, #4]
    bd26:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    bd2a:	781b      	ldrb	r3, [r3, #0]
    bd2c:	2b25      	cmp	r3, #37	; 0x25
    bd2e:	d10c      	bne.n	bd4a <handle_script+0x15e>
			{
				ptr = strchr( s->file.data + 1, ISO_percent );
    bd30:	687b      	ldr	r3, [r7, #4]
    bd32:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    bd36:	f103 0301 	add.w	r3, r3, #1
    bd3a:	4618      	mov	r0, r3
    bd3c:	f04f 0125 	mov.w	r1, #37	; 0x25
    bd40:	f006 f8f2 	bl	11f28 <strchr>
    bd44:	4603      	mov	r3, r0
    bd46:	60bb      	str	r3, [r7, #8]
    bd48:	e009      	b.n	bd5e <handle_script+0x172>
			}
			else
			{
				ptr = strchr( s->file.data, ISO_percent );
    bd4a:	687b      	ldr	r3, [r7, #4]
    bd4c:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    bd50:	4618      	mov	r0, r3
    bd52:	f04f 0125 	mov.w	r1, #37	; 0x25
    bd56:	f006 f8e7 	bl	11f28 <strchr>
    bd5a:	4603      	mov	r3, r0
    bd5c:	60bb      	str	r3, [r7, #8]
			}

			if( ptr != NULL && ptr != s->file.data )
    bd5e:	68bb      	ldr	r3, [r7, #8]
    bd60:	2b00      	cmp	r3, #0
    bd62:	d023      	beq.n	bdac <handle_script+0x1c0>
    bd64:	687b      	ldr	r3, [r7, #4]
    bd66:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
    bd6a:	68bb      	ldr	r3, [r7, #8]
    bd6c:	429a      	cmp	r2, r3
    bd6e:	d01d      	beq.n	bdac <handle_script+0x1c0>
			{
				s->len = ( int ) ( ptr - s->file.data );
    bd70:	68ba      	ldr	r2, [r7, #8]
    bd72:	687b      	ldr	r3, [r7, #4]
    bd74:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    bd78:	ebc3 0202 	rsb	r2, r3, r2
    bd7c:	687b      	ldr	r3, [r7, #4]
    bd7e:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
				if( s->len >= uip_mss() )
    bd82:	687b      	ldr	r3, [r7, #4]
    bd84:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
    bd88:	f64a 336c 	movw	r3, #43884	; 0xab6c
    bd8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bd90:	681b      	ldr	r3, [r3, #0]
    bd92:	8a5b      	ldrh	r3, [r3, #18]
    bd94:	429a      	cmp	r2, r3
    bd96:	db09      	blt.n	bdac <handle_script+0x1c0>
				{
					s->len = uip_mss();
    bd98:	f64a 336c 	movw	r3, #43884	; 0xab6c
    bd9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bda0:	681b      	ldr	r3, [r3, #0]
    bda2:	8a5b      	ldrh	r3, [r3, #18]
    bda4:	461a      	mov	r2, r3
    bda6:	687b      	ldr	r3, [r7, #4]
    bda8:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
				}
			}

			PT_WAIT_THREAD( &s->scriptpt, send_part_of_file(s) );
    bdac:	687b      	ldr	r3, [r7, #4]
    bdae:	f04f 02c1 	mov.w	r2, #193	; 0xc1
    bdb2:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    bdb6:	6878      	ldr	r0, [r7, #4]
    bdb8:	f7ff feba 	bl	bb30 <send_part_of_file>
    bdbc:	4603      	mov	r3, r0
    bdbe:	2b00      	cmp	r3, #0
    bdc0:	d102      	bne.n	bdc8 <handle_script+0x1dc>
    bdc2:	f04f 0300 	mov.w	r3, #0
    bdc6:	e026      	b.n	be16 <handle_script+0x22a>
			s->file.data += s->len;
    bdc8:	687b      	ldr	r3, [r7, #4]
    bdca:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
    bdce:	687b      	ldr	r3, [r7, #4]
    bdd0:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    bdd4:	441a      	add	r2, r3
    bdd6:	687b      	ldr	r3, [r7, #4]
    bdd8:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
			s->file.len -= s->len;
    bddc:	687b      	ldr	r3, [r7, #4]
    bdde:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
    bde2:	687b      	ldr	r3, [r7, #4]
    bde4:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    bde8:	ebc3 0202 	rsb	r2, r3, r2
    bdec:	687b      	ldr	r3, [r7, #4]
    bdee:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
    bdf2:	e000      	b.n	bdf6 <handle_script+0x20a>
{
	char	*ptr;

	PT_BEGIN( &s->scriptpt );
	( void ) PT_YIELD_FLAG;
	while( s->file.len > 0 )
    bdf4:	bf00      	nop
    bdf6:	687b      	ldr	r3, [r7, #4]
    bdf8:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
    bdfc:	2b00      	cmp	r3, #0
    bdfe:	f73f af0d 	bgt.w	bc1c <handle_script+0x30>
			s->file.data += s->len;
			s->file.len -= s->len;
		}
	}

	PT_END( &s->scriptpt );
    be02:	f04f 0300 	mov.w	r3, #0
    be06:	73fb      	strb	r3, [r7, #15]
    be08:	687b      	ldr	r3, [r7, #4]
    be0a:	f04f 0200 	mov.w	r2, #0
    be0e:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    be12:	f04f 0302 	mov.w	r3, #2
}
    be16:	4618      	mov	r0, r3
    be18:	f107 0710 	add.w	r7, r7, #16
    be1c:	46bd      	mov	sp, r7
    be1e:	bd80      	pop	{r7, pc}

0000be20 <send_headers>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( send_headers ( struct httpd_state *s, const char *statushdr ) )
{
    be20:	b590      	push	{r4, r7, lr}
    be22:	b085      	sub	sp, #20
    be24:	af00      	add	r7, sp, #0
    be26:	6078      	str	r0, [r7, #4]
    be28:	6039      	str	r1, [r7, #0]
	char	*ptr;

	PSOCK_BEGIN( &s->sout );
    be2a:	f04f 0301 	mov.w	r3, #1
    be2e:	73fb      	strb	r3, [r7, #15]
    be30:	687b      	ldr	r3, [r7, #4]
    be32:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    be34:	2bde      	cmp	r3, #222	; 0xde
    be36:	f000 80a3 	beq.w	bf80 <send_headers+0x160>
    be3a:	2bde      	cmp	r3, #222	; 0xde
    be3c:	dc0b      	bgt.n	be56 <send_headers+0x36>
    be3e:	2bd1      	cmp	r3, #209	; 0xd1
    be40:	d01d      	beq.n	be7e <send_headers+0x5e>
    be42:	2bd1      	cmp	r3, #209	; 0xd1
    be44:	dc02      	bgt.n	be4c <send_headers+0x2c>
    be46:	2b00      	cmp	r3, #0
    be48:	d015      	beq.n	be76 <send_headers+0x56>
    be4a:	e147      	b.n	c0dc <send_headers+0x2bc>
    be4c:	2bd6      	cmp	r3, #214	; 0xd6
    be4e:	d039      	beq.n	bec4 <send_headers+0xa4>
    be50:	2bda      	cmp	r3, #218	; 0xda
    be52:	d06c      	beq.n	bf2e <send_headers+0x10e>
    be54:	e142      	b.n	c0dc <send_headers+0x2bc>
    be56:	2be6      	cmp	r3, #230	; 0xe6
    be58:	f000 80e3 	beq.w	c022 <send_headers+0x202>
    be5c:	2be6      	cmp	r3, #230	; 0xe6
    be5e:	dc03      	bgt.n	be68 <send_headers+0x48>
    be60:	2be2      	cmp	r3, #226	; 0xe2
    be62:	f000 80b6 	beq.w	bfd2 <send_headers+0x1b2>
    be66:	e139      	b.n	c0dc <send_headers+0x2bc>
    be68:	2bea      	cmp	r3, #234	; 0xea
    be6a:	f000 8102 	beq.w	c072 <send_headers+0x252>
    be6e:	2bee      	cmp	r3, #238	; 0xee
    be70:	f000 811b 	beq.w	c0aa <send_headers+0x28a>
    be74:	e132      	b.n	c0dc <send_headers+0x2bc>
	( void ) PT_YIELD_FLAG;
	PSOCK_SEND_STR( &s->sout, statushdr );
    be76:	687b      	ldr	r3, [r7, #4]
    be78:	f04f 02d1 	mov.w	r2, #209	; 0xd1
    be7c:	851a      	strh	r2, [r3, #40]	; 0x28
    be7e:	687b      	ldr	r3, [r7, #4]
    be80:	f103 0428 	add.w	r4, r3, #40	; 0x28
    be84:	6838      	ldr	r0, [r7, #0]
    be86:	f006 f90d 	bl	120a4 <strlen>
    be8a:	4603      	mov	r3, r0
    be8c:	4620      	mov	r0, r4
    be8e:	6839      	ldr	r1, [r7, #0]
    be90:	461a      	mov	r2, r3
    be92:	f7fc f801 	bl	7e98 <psock_send>
    be96:	4603      	mov	r3, r0
    be98:	2b00      	cmp	r3, #0
    be9a:	d102      	bne.n	bea2 <send_headers+0x82>
    be9c:	f04f 0300 	mov.w	r3, #0
    bea0:	e125      	b.n	c0ee <send_headers+0x2ce>

	ptr = strrchr( s->filename, ISO_period );
    bea2:	687b      	ldr	r3, [r7, #4]
    bea4:	f103 0382 	add.w	r3, r3, #130	; 0x82
    bea8:	4618      	mov	r0, r3
    beaa:	f04f 012e 	mov.w	r1, #46	; 0x2e
    beae:	f006 f9b9 	bl	12224 <strrchr>
    beb2:	4603      	mov	r3, r0
    beb4:	60bb      	str	r3, [r7, #8]
	if( ptr == NULL )
    beb6:	68bb      	ldr	r3, [r7, #8]
    beb8:	2b00      	cmp	r3, #0
    beba:	d11c      	bne.n	bef6 <send_headers+0xd6>
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_binary );
    bebc:	687b      	ldr	r3, [r7, #4]
    bebe:	f04f 02d6 	mov.w	r2, #214	; 0xd6
    bec2:	851a      	strh	r2, [r3, #40]	; 0x28
    bec4:	687b      	ldr	r3, [r7, #4]
    bec6:	f103 0428 	add.w	r4, r3, #40	; 0x28
    beca:	f643 5050 	movw	r0, #15696	; 0x3d50
    bece:	f2c0 0001 	movt	r0, #1
    bed2:	f006 f8e7 	bl	120a4 <strlen>
    bed6:	4603      	mov	r3, r0
    bed8:	4620      	mov	r0, r4
    beda:	f643 5150 	movw	r1, #15696	; 0x3d50
    bede:	f2c0 0101 	movt	r1, #1
    bee2:	461a      	mov	r2, r3
    bee4:	f7fb ffd8 	bl	7e98 <psock_send>
    bee8:	4603      	mov	r3, r0
    beea:	2b00      	cmp	r3, #0
    beec:	f040 80f6 	bne.w	c0dc <send_headers+0x2bc>
    bef0:	f04f 0300 	mov.w	r3, #0
    bef4:	e0fb      	b.n	c0ee <send_headers+0x2ce>
	}
	else if( strncmp(http_html, ptr, 5) == 0 || strncmp(http_shtml, ptr, 6) == 0 )
    bef6:	f643 507c 	movw	r0, #15740	; 0x3d7c
    befa:	f2c0 0001 	movt	r0, #1
    befe:	68b9      	ldr	r1, [r7, #8]
    bf00:	f04f 0205 	mov.w	r2, #5
    bf04:	f006 f8fe 	bl	12104 <strncmp>
    bf08:	4603      	mov	r3, r0
    bf0a:	2b00      	cmp	r3, #0
    bf0c:	d00b      	beq.n	bf26 <send_headers+0x106>
    bf0e:	f643 5084 	movw	r0, #15748	; 0x3d84
    bf12:	f2c0 0001 	movt	r0, #1
    bf16:	68b9      	ldr	r1, [r7, #8]
    bf18:	f04f 0206 	mov.w	r2, #6
    bf1c:	f006 f8f2 	bl	12104 <strncmp>
    bf20:	4603      	mov	r3, r0
    bf22:	2b00      	cmp	r3, #0
    bf24:	d11c      	bne.n	bf60 <send_headers+0x140>
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_html );
    bf26:	687b      	ldr	r3, [r7, #4]
    bf28:	f04f 02da 	mov.w	r2, #218	; 0xda
    bf2c:	851a      	strh	r2, [r3, #40]	; 0x28
    bf2e:	687b      	ldr	r3, [r7, #4]
    bf30:	f103 0428 	add.w	r4, r3, #40	; 0x28
    bf34:	f643 40a4 	movw	r0, #15524	; 0x3ca4
    bf38:	f2c0 0001 	movt	r0, #1
    bf3c:	f006 f8b2 	bl	120a4 <strlen>
    bf40:	4603      	mov	r3, r0
    bf42:	4620      	mov	r0, r4
    bf44:	f643 41a4 	movw	r1, #15524	; 0x3ca4
    bf48:	f2c0 0101 	movt	r1, #1
    bf4c:	461a      	mov	r2, r3
    bf4e:	f7fb ffa3 	bl	7e98 <psock_send>
    bf52:	4603      	mov	r3, r0
    bf54:	2b00      	cmp	r3, #0
    bf56:	f040 80c0 	bne.w	c0da <send_headers+0x2ba>
    bf5a:	f04f 0300 	mov.w	r3, #0
    bf5e:	e0c6      	b.n	c0ee <send_headers+0x2ce>
	}
	else if( strncmp(http_css, ptr, 4) == 0 )
    bf60:	f643 5094 	movw	r0, #15764	; 0x3d94
    bf64:	f2c0 0001 	movt	r0, #1
    bf68:	68b9      	ldr	r1, [r7, #8]
    bf6a:	f04f 0204 	mov.w	r2, #4
    bf6e:	f006 f8c9 	bl	12104 <strncmp>
    bf72:	4603      	mov	r3, r0
    bf74:	2b00      	cmp	r3, #0
    bf76:	d11c      	bne.n	bfb2 <send_headers+0x192>
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_css );
    bf78:	687b      	ldr	r3, [r7, #4]
    bf7a:	f04f 02de 	mov.w	r2, #222	; 0xde
    bf7e:	851a      	strh	r2, [r3, #40]	; 0x28
    bf80:	687b      	ldr	r3, [r7, #4]
    bf82:	f103 0428 	add.w	r4, r3, #40	; 0x28
    bf86:	f643 40c0 	movw	r0, #15552	; 0x3cc0
    bf8a:	f2c0 0001 	movt	r0, #1
    bf8e:	f006 f889 	bl	120a4 <strlen>
    bf92:	4603      	mov	r3, r0
    bf94:	4620      	mov	r0, r4
    bf96:	f643 41c0 	movw	r1, #15552	; 0x3cc0
    bf9a:	f2c0 0101 	movt	r1, #1
    bf9e:	461a      	mov	r2, r3
    bfa0:	f7fb ff7a 	bl	7e98 <psock_send>
    bfa4:	4603      	mov	r3, r0
    bfa6:	2b00      	cmp	r3, #0
    bfa8:	f040 8098 	bne.w	c0dc <send_headers+0x2bc>
    bfac:	f04f 0300 	mov.w	r3, #0
    bfb0:	e09d      	b.n	c0ee <send_headers+0x2ce>
	}
	else if( strncmp(http_png, ptr, 4) == 0 )
    bfb2:	f643 509c 	movw	r0, #15772	; 0x3d9c
    bfb6:	f2c0 0001 	movt	r0, #1
    bfba:	68b9      	ldr	r1, [r7, #8]
    bfbc:	f04f 0204 	mov.w	r2, #4
    bfc0:	f006 f8a0 	bl	12104 <strncmp>
    bfc4:	4603      	mov	r3, r0
    bfc6:	2b00      	cmp	r3, #0
    bfc8:	d11b      	bne.n	c002 <send_headers+0x1e2>
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_png );
    bfca:	687b      	ldr	r3, [r7, #4]
    bfcc:	f04f 02e2 	mov.w	r2, #226	; 0xe2
    bfd0:	851a      	strh	r2, [r3, #40]	; 0x28
    bfd2:	687b      	ldr	r3, [r7, #4]
    bfd4:	f103 0428 	add.w	r4, r3, #40	; 0x28
    bfd8:	f643 40f8 	movw	r0, #15608	; 0x3cf8
    bfdc:	f2c0 0001 	movt	r0, #1
    bfe0:	f006 f860 	bl	120a4 <strlen>
    bfe4:	4603      	mov	r3, r0
    bfe6:	4620      	mov	r0, r4
    bfe8:	f643 41f8 	movw	r1, #15608	; 0x3cf8
    bfec:	f2c0 0101 	movt	r1, #1
    bff0:	461a      	mov	r2, r3
    bff2:	f7fb ff51 	bl	7e98 <psock_send>
    bff6:	4603      	mov	r3, r0
    bff8:	2b00      	cmp	r3, #0
    bffa:	d16f      	bne.n	c0dc <send_headers+0x2bc>
    bffc:	f04f 0300 	mov.w	r3, #0
    c000:	e075      	b.n	c0ee <send_headers+0x2ce>
	}
	else if( strncmp(http_gif, ptr, 4) == 0 )
    c002:	f643 50a4 	movw	r0, #15780	; 0x3da4
    c006:	f2c0 0001 	movt	r0, #1
    c00a:	68b9      	ldr	r1, [r7, #8]
    c00c:	f04f 0204 	mov.w	r2, #4
    c010:	f006 f878 	bl	12104 <strncmp>
    c014:	4603      	mov	r3, r0
    c016:	2b00      	cmp	r3, #0
    c018:	d11b      	bne.n	c052 <send_headers+0x232>
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_gif );
    c01a:	687b      	ldr	r3, [r7, #4]
    c01c:	f04f 02e6 	mov.w	r2, #230	; 0xe6
    c020:	851a      	strh	r2, [r3, #40]	; 0x28
    c022:	687b      	ldr	r3, [r7, #4]
    c024:	f103 0428 	add.w	r4, r3, #40	; 0x28
    c028:	f643 5014 	movw	r0, #15636	; 0x3d14
    c02c:	f2c0 0001 	movt	r0, #1
    c030:	f006 f838 	bl	120a4 <strlen>
    c034:	4603      	mov	r3, r0
    c036:	4620      	mov	r0, r4
    c038:	f643 5114 	movw	r1, #15636	; 0x3d14
    c03c:	f2c0 0101 	movt	r1, #1
    c040:	461a      	mov	r2, r3
    c042:	f7fb ff29 	bl	7e98 <psock_send>
    c046:	4603      	mov	r3, r0
    c048:	2b00      	cmp	r3, #0
    c04a:	d147      	bne.n	c0dc <send_headers+0x2bc>
    c04c:	f04f 0300 	mov.w	r3, #0
    c050:	e04d      	b.n	c0ee <send_headers+0x2ce>
	}
	else if( strncmp(http_jpg, ptr, 4) == 0 )
    c052:	f643 50ac 	movw	r0, #15788	; 0x3dac
    c056:	f2c0 0001 	movt	r0, #1
    c05a:	68b9      	ldr	r1, [r7, #8]
    c05c:	f04f 0204 	mov.w	r2, #4
    c060:	f006 f850 	bl	12104 <strncmp>
    c064:	4603      	mov	r3, r0
    c066:	2b00      	cmp	r3, #0
    c068:	d11b      	bne.n	c0a2 <send_headers+0x282>
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_jpg );
    c06a:	687b      	ldr	r3, [r7, #4]
    c06c:	f04f 02ea 	mov.w	r2, #234	; 0xea
    c070:	851a      	strh	r2, [r3, #40]	; 0x28
    c072:	687b      	ldr	r3, [r7, #4]
    c074:	f103 0428 	add.w	r4, r3, #40	; 0x28
    c078:	f643 5030 	movw	r0, #15664	; 0x3d30
    c07c:	f2c0 0001 	movt	r0, #1
    c080:	f006 f810 	bl	120a4 <strlen>
    c084:	4603      	mov	r3, r0
    c086:	4620      	mov	r0, r4
    c088:	f643 5130 	movw	r1, #15664	; 0x3d30
    c08c:	f2c0 0101 	movt	r1, #1
    c090:	461a      	mov	r2, r3
    c092:	f7fb ff01 	bl	7e98 <psock_send>
    c096:	4603      	mov	r3, r0
    c098:	2b00      	cmp	r3, #0
    c09a:	d11f      	bne.n	c0dc <send_headers+0x2bc>
    c09c:	f04f 0300 	mov.w	r3, #0
    c0a0:	e025      	b.n	c0ee <send_headers+0x2ce>
	}
	else
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_plain );
    c0a2:	687b      	ldr	r3, [r7, #4]
    c0a4:	f04f 02ee 	mov.w	r2, #238	; 0xee
    c0a8:	851a      	strh	r2, [r3, #40]	; 0x28
    c0aa:	687b      	ldr	r3, [r7, #4]
    c0ac:	f103 0428 	add.w	r4, r3, #40	; 0x28
    c0b0:	f643 4084 	movw	r0, #15492	; 0x3c84
    c0b4:	f2c0 0001 	movt	r0, #1
    c0b8:	f005 fff4 	bl	120a4 <strlen>
    c0bc:	4603      	mov	r3, r0
    c0be:	4620      	mov	r0, r4
    c0c0:	f643 4184 	movw	r1, #15492	; 0x3c84
    c0c4:	f2c0 0101 	movt	r1, #1
    c0c8:	461a      	mov	r2, r3
    c0ca:	f7fb fee5 	bl	7e98 <psock_send>
    c0ce:	4603      	mov	r3, r0
    c0d0:	2b00      	cmp	r3, #0
    c0d2:	d103      	bne.n	c0dc <send_headers+0x2bc>
    c0d4:	f04f 0300 	mov.w	r3, #0
    c0d8:	e009      	b.n	c0ee <send_headers+0x2ce>
	ptr = strrchr( s->filename, ISO_period );
	if( ptr == NULL )
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_binary );
	}
	else if( strncmp(http_html, ptr, 5) == 0 || strncmp(http_shtml, ptr, 6) == 0 )
    c0da:	bf00      	nop
	else
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_plain );
	}

	PSOCK_END( &s->sout );
    c0dc:	f04f 0300 	mov.w	r3, #0
    c0e0:	73fb      	strb	r3, [r7, #15]
    c0e2:	687b      	ldr	r3, [r7, #4]
    c0e4:	f04f 0200 	mov.w	r2, #0
    c0e8:	851a      	strh	r2, [r3, #40]	; 0x28
    c0ea:	f04f 0302 	mov.w	r3, #2
}
    c0ee:	4618      	mov	r0, r3
    c0f0:	f107 0714 	add.w	r7, r7, #20
    c0f4:	46bd      	mov	sp, r7
    c0f6:	bd90      	pop	{r4, r7, pc}

0000c0f8 <handle_output>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( handle_output ( struct httpd_state *s ) )
{
    c0f8:	b580      	push	{r7, lr}
    c0fa:	b084      	sub	sp, #16
    c0fc:	af00      	add	r7, sp, #0
    c0fe:	6078      	str	r0, [r7, #4]
	char	*ptr;

	PT_BEGIN( &s->outputpt );
    c100:	f04f 0301 	mov.w	r3, #1
    c104:	73fb      	strb	r3, [r7, #15]
    c106:	687b      	ldr	r3, [r7, #4]
    c108:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
    c10c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    c110:	d04c      	beq.n	c1ac <handle_output+0xb4>
    c112:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    c116:	dc04      	bgt.n	c122 <handle_output+0x2a>
    c118:	2b00      	cmp	r3, #0
    c11a:	d00f      	beq.n	c13c <handle_output+0x44>
    c11c:	2bff      	cmp	r3, #255	; 0xff
    c11e:	d033      	beq.n	c188 <handle_output+0x90>
    c120:	e0a1      	b.n	c266 <handle_output+0x16e>
    c122:	f240 1209 	movw	r2, #265	; 0x109
    c126:	4293      	cmp	r3, r2
    c128:	d07e      	beq.n	c228 <handle_output+0x130>
    c12a:	f240 120d 	movw	r2, #269	; 0x10d
    c12e:	4293      	cmp	r3, r2
    c130:	f000 8088 	beq.w	c244 <handle_output+0x14c>
    c134:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
    c138:	d046      	beq.n	c1c8 <handle_output+0xd0>
    c13a:	e094      	b.n	c266 <handle_output+0x16e>
	( void ) PT_YIELD_FLAG;
	if( !httpd_fs_open(s->filename, &s->file) )
    c13c:	687b      	ldr	r3, [r7, #4]
    c13e:	f103 0282 	add.w	r2, r3, #130	; 0x82
    c142:	687b      	ldr	r3, [r7, #4]
    c144:	f103 0398 	add.w	r3, r3, #152	; 0x98
    c148:	4610      	mov	r0, r2
    c14a:	4619      	mov	r1, r3
    c14c:	f7ff fbd8 	bl	b900 <httpd_fs_open>
    c150:	4603      	mov	r3, r0
    c152:	2b00      	cmp	r3, #0
    c154:	d133      	bne.n	c1be <handle_output+0xc6>
	{
		httpd_fs_open( http_404_html, &s->file );
    c156:	687b      	ldr	r3, [r7, #4]
    c158:	f103 0398 	add.w	r3, r3, #152	; 0x98
    c15c:	f643 30bc 	movw	r0, #15292	; 0x3bbc
    c160:	f2c0 0001 	movt	r0, #1
    c164:	4619      	mov	r1, r3
    c166:	f7ff fbcb 	bl	b900 <httpd_fs_open>
		strcpy( s->filename, http_404_html );
    c16a:	687b      	ldr	r3, [r7, #4]
    c16c:	f103 0382 	add.w	r3, r3, #130	; 0x82
    c170:	4618      	mov	r0, r3
    c172:	f643 31bc 	movw	r1, #15292	; 0x3bbc
    c176:	f2c0 0101 	movt	r1, #1
    c17a:	f005 ff35 	bl	11fe8 <strcpy>
		PT_WAIT_THREAD( &s->outputpt, send_headers(s, http_header_404) );
    c17e:	687b      	ldr	r3, [r7, #4]
    c180:	f04f 02ff 	mov.w	r2, #255	; 0xff
    c184:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    c188:	6878      	ldr	r0, [r7, #4]
    c18a:	f643 4128 	movw	r1, #15400	; 0x3c28
    c18e:	f2c0 0101 	movt	r1, #1
    c192:	f7ff fe45 	bl	be20 <send_headers>
    c196:	4603      	mov	r3, r0
    c198:	2b00      	cmp	r3, #0
    c19a:	d102      	bne.n	c1a2 <handle_output+0xaa>
    c19c:	f04f 0300 	mov.w	r3, #0
    c1a0:	e06b      	b.n	c27a <handle_output+0x182>
		PT_WAIT_THREAD( &s->outputpt, send_file(s) );
    c1a2:	687b      	ldr	r3, [r7, #4]
    c1a4:	f44f 7280 	mov.w	r2, #256	; 0x100
    c1a8:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    c1ac:	6878      	ldr	r0, [r7, #4]
    c1ae:	f7ff fc73 	bl	ba98 <send_file>
    c1b2:	4603      	mov	r3, r0
    c1b4:	2b00      	cmp	r3, #0
    c1b6:	d14f      	bne.n	c258 <handle_output+0x160>
    c1b8:	f04f 0300 	mov.w	r3, #0
    c1bc:	e05d      	b.n	c27a <handle_output+0x182>
	}
	else
	{
		PT_WAIT_THREAD( &s->outputpt, send_headers(s, http_header_200) );
    c1be:	687b      	ldr	r3, [r7, #4]
    c1c0:	f44f 7282 	mov.w	r2, #260	; 0x104
    c1c4:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    c1c8:	6878      	ldr	r0, [r7, #4]
    c1ca:	f643 31d4 	movw	r1, #15316	; 0x3bd4
    c1ce:	f2c0 0101 	movt	r1, #1
    c1d2:	f7ff fe25 	bl	be20 <send_headers>
    c1d6:	4603      	mov	r3, r0
    c1d8:	2b00      	cmp	r3, #0
    c1da:	d102      	bne.n	c1e2 <handle_output+0xea>
    c1dc:	f04f 0300 	mov.w	r3, #0
    c1e0:	e04b      	b.n	c27a <handle_output+0x182>
		ptr = strchr( s->filename, ISO_period );
    c1e2:	687b      	ldr	r3, [r7, #4]
    c1e4:	f103 0382 	add.w	r3, r3, #130	; 0x82
    c1e8:	4618      	mov	r0, r3
    c1ea:	f04f 012e 	mov.w	r1, #46	; 0x2e
    c1ee:	f005 fe9b 	bl	11f28 <strchr>
    c1f2:	4603      	mov	r3, r0
    c1f4:	60bb      	str	r3, [r7, #8]
		if( ptr != NULL && strncmp(ptr, http_shtml, 6) == 0 )
    c1f6:	68bb      	ldr	r3, [r7, #8]
    c1f8:	2b00      	cmp	r3, #0
    c1fa:	d01e      	beq.n	c23a <handle_output+0x142>
    c1fc:	68b8      	ldr	r0, [r7, #8]
    c1fe:	f643 5184 	movw	r1, #15748	; 0x3d84
    c202:	f2c0 0101 	movt	r1, #1
    c206:	f04f 0206 	mov.w	r2, #6
    c20a:	f005 ff7b 	bl	12104 <strncmp>
    c20e:	4603      	mov	r3, r0
    c210:	2b00      	cmp	r3, #0
    c212:	d112      	bne.n	c23a <handle_output+0x142>
		{
			PT_INIT( &s->scriptpt );
    c214:	687b      	ldr	r3, [r7, #4]
    c216:	f04f 0200 	mov.w	r2, #0
    c21a:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
			PT_WAIT_THREAD( &s->outputpt, handle_script(s) );
    c21e:	687b      	ldr	r3, [r7, #4]
    c220:	f240 1209 	movw	r2, #265	; 0x109
    c224:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    c228:	6878      	ldr	r0, [r7, #4]
    c22a:	f7ff fcdf 	bl	bbec <handle_script>
    c22e:	4603      	mov	r3, r0
    c230:	2b00      	cmp	r3, #0
    c232:	d110      	bne.n	c256 <handle_output+0x15e>
    c234:	f04f 0300 	mov.w	r3, #0
    c238:	e01f      	b.n	c27a <handle_output+0x182>
		}
		else
		{
			PT_WAIT_THREAD( &s->outputpt, send_file(s) );
    c23a:	687b      	ldr	r3, [r7, #4]
    c23c:	f240 120d 	movw	r2, #269	; 0x10d
    c240:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    c244:	6878      	ldr	r0, [r7, #4]
    c246:	f7ff fc27 	bl	ba98 <send_file>
    c24a:	4603      	mov	r3, r0
    c24c:	2b00      	cmp	r3, #0
    c24e:	d103      	bne.n	c258 <handle_output+0x160>
    c250:	f04f 0300 	mov.w	r3, #0
    c254:	e011      	b.n	c27a <handle_output+0x182>
	}
	else
	{
		PT_WAIT_THREAD( &s->outputpt, send_headers(s, http_header_200) );
		ptr = strchr( s->filename, ISO_period );
		if( ptr != NULL && strncmp(ptr, http_shtml, 6) == 0 )
    c256:	bf00      	nop
		{
			PT_WAIT_THREAD( &s->outputpt, send_file(s) );
		}
	}

	PSOCK_CLOSE( &s->sout );
    c258:	f64a 3364 	movw	r3, #43876	; 0xab64
    c25c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c260:	f04f 0210 	mov.w	r2, #16
    c264:	701a      	strb	r2, [r3, #0]
	PT_END( &s->outputpt );
    c266:	f04f 0300 	mov.w	r3, #0
    c26a:	73fb      	strb	r3, [r7, #15]
    c26c:	687b      	ldr	r3, [r7, #4]
    c26e:	f04f 0200 	mov.w	r2, #0
    c272:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    c276:	f04f 0302 	mov.w	r3, #2
}
    c27a:	4618      	mov	r0, r3
    c27c:	f107 0710 	add.w	r7, r7, #16
    c280:	46bd      	mov	sp, r7
    c282:	bd80      	pop	{r7, pc}

0000c284 <handle_input>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( handle_input ( struct httpd_state *s ) )
{
    c284:	b580      	push	{r7, lr}
    c286:	b084      	sub	sp, #16
    c288:	af00      	add	r7, sp, #0
    c28a:	6078      	str	r0, [r7, #4]
	PSOCK_BEGIN( &s->sin );
    c28c:	f04f 0301 	mov.w	r3, #1
    c290:	73fb      	strb	r3, [r7, #15]
    c292:	687b      	ldr	r3, [r7, #4]
    c294:	889b      	ldrh	r3, [r3, #4]
    c296:	f5b3 7f8d 	cmp.w	r3, #282	; 0x11a
    c29a:	d012      	beq.n	c2c2 <handle_input+0x3e>
    c29c:	f5b3 7f8d 	cmp.w	r3, #282	; 0x11a
    c2a0:	dc02      	bgt.n	c2a8 <handle_input+0x24>
    c2a2:	2b00      	cmp	r3, #0
    c2a4:	d009      	beq.n	c2ba <handle_input+0x36>
    c2a6:	e0c7      	b.n	c438 <handle_input+0x1b4>
    c2a8:	f240 1221 	movw	r2, #289	; 0x121
    c2ac:	4293      	cmp	r3, r2
    c2ae:	d037      	beq.n	c320 <handle_input+0x9c>
    c2b0:	f5b3 7fa0 	cmp.w	r3, #320	; 0x140
    c2b4:	f000 8093 	beq.w	c3de <handle_input+0x15a>
    c2b8:	e0be      	b.n	c438 <handle_input+0x1b4>
	( void ) PT_YIELD_FLAG;
	PSOCK_READTO( &s->sin, ISO_space );
    c2ba:	687b      	ldr	r3, [r7, #4]
    c2bc:	f44f 728d 	mov.w	r2, #282	; 0x11a
    c2c0:	809a      	strh	r2, [r3, #4]
    c2c2:	687b      	ldr	r3, [r7, #4]
    c2c4:	f103 0304 	add.w	r3, r3, #4
    c2c8:	4618      	mov	r0, r3
    c2ca:	f04f 0120 	mov.w	r1, #32
    c2ce:	f7fb fec7 	bl	8060 <psock_readto>
    c2d2:	4603      	mov	r3, r0
    c2d4:	2b00      	cmp	r3, #0
    c2d6:	d102      	bne.n	c2de <handle_input+0x5a>
    c2d8:	f04f 0300 	mov.w	r3, #0
    c2dc:	e0b5      	b.n	c44a <handle_input+0x1c6>

	if( strncmp(s->inputbuf, http_get, 4) != 0 )
    c2de:	687b      	ldr	r3, [r7, #4]
    c2e0:	f103 0350 	add.w	r3, r3, #80	; 0x50
    c2e4:	4618      	mov	r0, r3
    c2e6:	f643 315c 	movw	r1, #15196	; 0x3b5c
    c2ea:	f2c0 0101 	movt	r1, #1
    c2ee:	f04f 0204 	mov.w	r2, #4
    c2f2:	f005 ff07 	bl	12104 <strncmp>
    c2f6:	4603      	mov	r3, r0
    c2f8:	2b00      	cmp	r3, #0
    c2fa:	d00d      	beq.n	c318 <handle_input+0x94>
	{
		PSOCK_CLOSE_EXIT( &s->sin );
    c2fc:	f64a 3364 	movw	r3, #43876	; 0xab64
    c300:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c304:	f04f 0210 	mov.w	r2, #16
    c308:	701a      	strb	r2, [r3, #0]
    c30a:	687b      	ldr	r3, [r7, #4]
    c30c:	f04f 0200 	mov.w	r2, #0
    c310:	809a      	strh	r2, [r3, #4]
    c312:	f04f 0301 	mov.w	r3, #1
    c316:	e098      	b.n	c44a <handle_input+0x1c6>
	}

	PSOCK_READTO( &s->sin, ISO_space );
    c318:	687b      	ldr	r3, [r7, #4]
    c31a:	f240 1221 	movw	r2, #289	; 0x121
    c31e:	809a      	strh	r2, [r3, #4]
    c320:	687b      	ldr	r3, [r7, #4]
    c322:	f103 0304 	add.w	r3, r3, #4
    c326:	4618      	mov	r0, r3
    c328:	f04f 0120 	mov.w	r1, #32
    c32c:	f7fb fe98 	bl	8060 <psock_readto>
    c330:	4603      	mov	r3, r0
    c332:	2b00      	cmp	r3, #0
    c334:	d102      	bne.n	c33c <handle_input+0xb8>
    c336:	f04f 0300 	mov.w	r3, #0
    c33a:	e086      	b.n	c44a <handle_input+0x1c6>

	if( s->inputbuf[0] != ISO_slash )
    c33c:	687b      	ldr	r3, [r7, #4]
    c33e:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
    c342:	2b2f      	cmp	r3, #47	; 0x2f
    c344:	d00d      	beq.n	c362 <handle_input+0xde>
	{
		PSOCK_CLOSE_EXIT( &s->sin );
    c346:	f64a 3364 	movw	r3, #43876	; 0xab64
    c34a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c34e:	f04f 0210 	mov.w	r2, #16
    c352:	701a      	strb	r2, [r3, #0]
    c354:	687b      	ldr	r3, [r7, #4]
    c356:	f04f 0200 	mov.w	r2, #0
    c35a:	809a      	strh	r2, [r3, #4]
    c35c:	f04f 0301 	mov.w	r3, #1
    c360:	e073      	b.n	c44a <handle_input+0x1c6>
	}

	if( s->inputbuf[1] == ISO_space )
    c362:	687b      	ldr	r3, [r7, #4]
    c364:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
    c368:	2b20      	cmp	r3, #32
    c36a:	d10c      	bne.n	c386 <handle_input+0x102>
	{
		strncpy( s->filename, http_index_html, sizeof(s->filename) );
    c36c:	687b      	ldr	r3, [r7, #4]
    c36e:	f103 0382 	add.w	r3, r3, #130	; 0x82
    c372:	4618      	mov	r0, r3
    c374:	f643 31b0 	movw	r1, #15280	; 0x3bb0
    c378:	f2c0 0101 	movt	r1, #1
    c37c:	f04f 0214 	mov.w	r2, #20
    c380:	f005 ff14 	bl	121ac <strncpy>
    c384:	e020      	b.n	c3c8 <handle_input+0x144>
	}
	else
	{
		s->inputbuf[PSOCK_DATALEN( &s->sin ) - 1] = 0;
    c386:	687b      	ldr	r3, [r7, #4]
    c388:	f103 0304 	add.w	r3, r3, #4
    c38c:	4618      	mov	r0, r3
    c38e:	f7fb fe29 	bl	7fe4 <psock_datalen>
    c392:	4603      	mov	r3, r0
    c394:	f103 32ff 	add.w	r2, r3, #4294967295
    c398:	687b      	ldr	r3, [r7, #4]
    c39a:	4413      	add	r3, r2
    c39c:	f04f 0200 	mov.w	r2, #0
    c3a0:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
		
		/* Process any form input being sent to the server. */
		#if UIP_CONF_PROCESS_HTTPD_FORMS == 1
		{
			extern void vApplicationProcessFormInput( char *pcInputString );
			vApplicationProcessFormInput( s->inputbuf );
    c3a4:	687b      	ldr	r3, [r7, #4]
    c3a6:	f103 0350 	add.w	r3, r3, #80	; 0x50
    c3aa:	4618      	mov	r0, r3
    c3ac:	f7f5 f9da 	bl	1764 <vApplicationProcessFormInput>
		}
		#endif
		
		strncpy( s->filename, &s->inputbuf[0], sizeof(s->filename) );
    c3b0:	687b      	ldr	r3, [r7, #4]
    c3b2:	f103 0282 	add.w	r2, r3, #130	; 0x82
    c3b6:	687b      	ldr	r3, [r7, #4]
    c3b8:	f103 0350 	add.w	r3, r3, #80	; 0x50
    c3bc:	4610      	mov	r0, r2
    c3be:	4619      	mov	r1, r3
    c3c0:	f04f 0214 	mov.w	r2, #20
    c3c4:	f005 fef2 	bl	121ac <strncpy>
	}

	/*  httpd_log_file(uip_conn->ripaddr, s->filename);*/
	s->state = STATE_OUTPUT;
    c3c8:	687b      	ldr	r3, [r7, #4]
    c3ca:	f04f 0201 	mov.w	r2, #1
    c3ce:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
    c3d2:	e000      	b.n	c3d6 <handle_input+0x152>
		{
			s->inputbuf[PSOCK_DATALEN( &s->sin ) - 2] = 0;

			/*      httpd_log(&s->inputbuf[9]);*/
		}
	}
    c3d4:	bf00      	nop
	/*  httpd_log_file(uip_conn->ripaddr, s->filename);*/
	s->state = STATE_OUTPUT;

	while( 1 )
	{
		PSOCK_READTO( &s->sin, ISO_nl );
    c3d6:	687b      	ldr	r3, [r7, #4]
    c3d8:	f44f 72a0 	mov.w	r2, #320	; 0x140
    c3dc:	809a      	strh	r2, [r3, #4]
    c3de:	687b      	ldr	r3, [r7, #4]
    c3e0:	f103 0304 	add.w	r3, r3, #4
    c3e4:	4618      	mov	r0, r3
    c3e6:	f04f 010a 	mov.w	r1, #10
    c3ea:	f7fb fe39 	bl	8060 <psock_readto>
    c3ee:	4603      	mov	r3, r0
    c3f0:	2b00      	cmp	r3, #0
    c3f2:	d102      	bne.n	c3fa <handle_input+0x176>
    c3f4:	f04f 0300 	mov.w	r3, #0
    c3f8:	e027      	b.n	c44a <handle_input+0x1c6>

		if( strncmp(s->inputbuf, http_referer, 8) == 0 )
    c3fa:	687b      	ldr	r3, [r7, #4]
    c3fc:	f103 0350 	add.w	r3, r3, #80	; 0x50
    c400:	4618      	mov	r0, r3
    c402:	f643 31c8 	movw	r1, #15304	; 0x3bc8
    c406:	f2c0 0101 	movt	r1, #1
    c40a:	f04f 0208 	mov.w	r2, #8
    c40e:	f005 fe79 	bl	12104 <strncmp>
    c412:	4603      	mov	r3, r0
    c414:	2b00      	cmp	r3, #0
    c416:	d1dd      	bne.n	c3d4 <handle_input+0x150>
		{
			s->inputbuf[PSOCK_DATALEN( &s->sin ) - 2] = 0;
    c418:	687b      	ldr	r3, [r7, #4]
    c41a:	f103 0304 	add.w	r3, r3, #4
    c41e:	4618      	mov	r0, r3
    c420:	f7fb fde0 	bl	7fe4 <psock_datalen>
    c424:	4603      	mov	r3, r0
    c426:	f1a3 0202 	sub.w	r2, r3, #2
    c42a:	687b      	ldr	r3, [r7, #4]
    c42c:	4413      	add	r3, r2
    c42e:	f04f 0200 	mov.w	r2, #0
    c432:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

			/*      httpd_log(&s->inputbuf[9]);*/
		}
	}
    c436:	e7ce      	b.n	c3d6 <handle_input+0x152>

	PSOCK_END( &s->sin );
    c438:	f04f 0300 	mov.w	r3, #0
    c43c:	73fb      	strb	r3, [r7, #15]
    c43e:	687b      	ldr	r3, [r7, #4]
    c440:	f04f 0200 	mov.w	r2, #0
    c444:	809a      	strh	r2, [r3, #4]
    c446:	f04f 0302 	mov.w	r3, #2
}
    c44a:	4618      	mov	r0, r3
    c44c:	f107 0710 	add.w	r7, r7, #16
    c450:	46bd      	mov	sp, r7
    c452:	bd80      	pop	{r7, pc}

0000c454 <handle_connection>:

/*---------------------------------------------------------------------------*/
static void handle_connection( struct httpd_state *s )
{
    c454:	b580      	push	{r7, lr}
    c456:	b082      	sub	sp, #8
    c458:	af00      	add	r7, sp, #0
    c45a:	6078      	str	r0, [r7, #4]
	handle_input( s );
    c45c:	6878      	ldr	r0, [r7, #4]
    c45e:	f7ff ff11 	bl	c284 <handle_input>
	if( s->state == STATE_OUTPUT )
    c462:	687b      	ldr	r3, [r7, #4]
    c464:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
    c468:	2b01      	cmp	r3, #1
    c46a:	d102      	bne.n	c472 <handle_connection+0x1e>
	{
		handle_output( s );
    c46c:	6878      	ldr	r0, [r7, #4]
    c46e:	f7ff fe43 	bl	c0f8 <handle_output>
	}
}
    c472:	f107 0708 	add.w	r7, r7, #8
    c476:	46bd      	mov	sp, r7
    c478:	bd80      	pop	{r7, pc}
    c47a:	bf00      	nop

0000c47c <httpd_appcall>:

/*---------------------------------------------------------------------------*/
void httpd_appcall( void )
{
    c47c:	b580      	push	{r7, lr}
    c47e:	b082      	sub	sp, #8
    c480:	af00      	add	r7, sp, #0
	struct httpd_state	*s = ( struct httpd_state * ) &( uip_conn->appstate );
    c482:	f64a 336c 	movw	r3, #43884	; 0xab6c
    c486:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c48a:	681b      	ldr	r3, [r3, #0]
    c48c:	f103 031c 	add.w	r3, r3, #28
    c490:	607b      	str	r3, [r7, #4]

	if( uip_closed() || uip_aborted() || uip_timedout() )
    c492:	f64a 3364 	movw	r3, #43876	; 0xab64
    c496:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c49a:	781b      	ldrb	r3, [r3, #0]
    c49c:	f003 0310 	and.w	r3, r3, #16
    c4a0:	2b00      	cmp	r3, #0
    c4a2:	d173      	bne.n	c58c <httpd_appcall+0x110>
    c4a4:	f64a 3364 	movw	r3, #43876	; 0xab64
    c4a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c4ac:	781b      	ldrb	r3, [r3, #0]
    c4ae:	f003 0320 	and.w	r3, r3, #32
    c4b2:	2b00      	cmp	r3, #0
    c4b4:	d16a      	bne.n	c58c <httpd_appcall+0x110>
    c4b6:	f64a 3364 	movw	r3, #43876	; 0xab64
    c4ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c4be:	781b      	ldrb	r3, [r3, #0]
    c4c0:	b25b      	sxtb	r3, r3
    c4c2:	2b00      	cmp	r3, #0
    c4c4:	db62      	blt.n	c58c <httpd_appcall+0x110>
	{
	}
	else if( uip_connected() )
    c4c6:	f64a 3364 	movw	r3, #43876	; 0xab64
    c4ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c4ce:	781b      	ldrb	r3, [r3, #0]
    c4d0:	f003 0340 	and.w	r3, r3, #64	; 0x40
    c4d4:	2b00      	cmp	r3, #0
    c4d6:	d029      	beq.n	c52c <httpd_appcall+0xb0>
	{
		PSOCK_INIT( &s->sin, s->inputbuf, sizeof(s->inputbuf) - 1 );
    c4d8:	687b      	ldr	r3, [r7, #4]
    c4da:	f103 0204 	add.w	r2, r3, #4
    c4de:	687b      	ldr	r3, [r7, #4]
    c4e0:	f103 0350 	add.w	r3, r3, #80	; 0x50
    c4e4:	4610      	mov	r0, r2
    c4e6:	4619      	mov	r1, r3
    c4e8:	f04f 0231 	mov.w	r2, #49	; 0x31
    c4ec:	f7fb fe7e 	bl	81ec <psock_init>
		PSOCK_INIT( &s->sout, s->inputbuf, sizeof(s->inputbuf) - 1 );
    c4f0:	687b      	ldr	r3, [r7, #4]
    c4f2:	f103 0228 	add.w	r2, r3, #40	; 0x28
    c4f6:	687b      	ldr	r3, [r7, #4]
    c4f8:	f103 0350 	add.w	r3, r3, #80	; 0x50
    c4fc:	4610      	mov	r0, r2
    c4fe:	4619      	mov	r1, r3
    c500:	f04f 0231 	mov.w	r2, #49	; 0x31
    c504:	f7fb fe72 	bl	81ec <psock_init>
		PT_INIT( &s->outputpt );
    c508:	687b      	ldr	r3, [r7, #4]
    c50a:	f04f 0200 	mov.w	r2, #0
    c50e:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
		s->state = STATE_WAITING;
    c512:	687b      	ldr	r3, [r7, #4]
    c514:	f04f 0200 	mov.w	r2, #0
    c518:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96

		/*    timer_set(&s->timer, CLOCK_SECOND * 100);*/
		s->timer = 0;
    c51c:	687b      	ldr	r3, [r7, #4]
    c51e:	f04f 0200 	mov.w	r2, #0
    c522:	701a      	strb	r2, [r3, #0]
		handle_connection( s );
    c524:	6878      	ldr	r0, [r7, #4]
    c526:	f7ff ff95 	bl	c454 <handle_connection>
    c52a:	e02f      	b.n	c58c <httpd_appcall+0x110>
	}
	else if( s != NULL )
    c52c:	687b      	ldr	r3, [r7, #4]
    c52e:	2b00      	cmp	r3, #0
    c530:	d025      	beq.n	c57e <httpd_appcall+0x102>
	{
		if( uip_poll() )
    c532:	f64a 3364 	movw	r3, #43876	; 0xab64
    c536:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c53a:	781b      	ldrb	r3, [r3, #0]
    c53c:	f003 0308 	and.w	r3, r3, #8
    c540:	2b00      	cmp	r3, #0
    c542:	d012      	beq.n	c56a <httpd_appcall+0xee>
		{
			++s->timer;
    c544:	687b      	ldr	r3, [r7, #4]
    c546:	781b      	ldrb	r3, [r3, #0]
    c548:	f103 0301 	add.w	r3, r3, #1
    c54c:	b2da      	uxtb	r2, r3
    c54e:	687b      	ldr	r3, [r7, #4]
    c550:	701a      	strb	r2, [r3, #0]
			if( s->timer >= 20 )
    c552:	687b      	ldr	r3, [r7, #4]
    c554:	781b      	ldrb	r3, [r3, #0]
    c556:	2b13      	cmp	r3, #19
    c558:	d90c      	bls.n	c574 <httpd_appcall+0xf8>
			{
				uip_abort();
    c55a:	f64a 3364 	movw	r3, #43876	; 0xab64
    c55e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c562:	f04f 0220 	mov.w	r2, #32
    c566:	701a      	strb	r2, [r3, #0]
    c568:	e005      	b.n	c576 <httpd_appcall+0xfa>
			}
		}
		else
		{
			s->timer = 0;
    c56a:	687b      	ldr	r3, [r7, #4]
    c56c:	f04f 0200 	mov.w	r2, #0
    c570:	701a      	strb	r2, [r3, #0]
    c572:	e000      	b.n	c576 <httpd_appcall+0xfa>
		if( uip_poll() )
		{
			++s->timer;
			if( s->timer >= 20 )
			{
				uip_abort();
    c574:	bf00      	nop
		else
		{
			s->timer = 0;
		}

		handle_connection( s );
    c576:	6878      	ldr	r0, [r7, #4]
    c578:	f7ff ff6c 	bl	c454 <handle_connection>
    c57c:	e006      	b.n	c58c <httpd_appcall+0x110>
	}
	else
	{
		uip_abort();
    c57e:	f64a 3364 	movw	r3, #43876	; 0xab64
    c582:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c586:	f04f 0220 	mov.w	r2, #32
    c58a:	701a      	strb	r2, [r3, #0]
	}
}
    c58c:	f107 0708 	add.w	r7, r7, #8
    c590:	46bd      	mov	sp, r7
    c592:	bd80      	pop	{r7, pc}

0000c594 <httpd_init>:
 *
 *             This function initializes the web server and should be
 *             called at system boot-up.
 */
void httpd_init( void )
{
    c594:	b580      	push	{r7, lr}
    c596:	af00      	add	r7, sp, #0
	uip_listen( HTONS(80) );
    c598:	f44f 40a0 	mov.w	r0, #20480	; 0x5000
    c59c:	f7fc f9e4 	bl	8968 <uip_listen>
}
    c5a0:	bd80      	pop	{r7, pc}
    c5a2:	bf00      	nop

0000c5a4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    c5a4:	b480      	push	{r7}
    c5a6:	b083      	sub	sp, #12
    c5a8:	af00      	add	r7, sp, #0
    c5aa:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    c5ac:	687b      	ldr	r3, [r7, #4]
    c5ae:	f103 0308 	add.w	r3, r3, #8
    c5b2:	461a      	mov	r2, r3
    c5b4:	687b      	ldr	r3, [r7, #4]
    c5b6:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    c5b8:	687b      	ldr	r3, [r7, #4]
    c5ba:	f04f 32ff 	mov.w	r2, #4294967295
    c5be:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    c5c0:	687b      	ldr	r3, [r7, #4]
    c5c2:	f103 0308 	add.w	r3, r3, #8
    c5c6:	461a      	mov	r2, r3
    c5c8:	687b      	ldr	r3, [r7, #4]
    c5ca:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    c5cc:	687b      	ldr	r3, [r7, #4]
    c5ce:	f103 0308 	add.w	r3, r3, #8
    c5d2:	461a      	mov	r2, r3
    c5d4:	687b      	ldr	r3, [r7, #4]
    c5d6:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    c5d8:	687b      	ldr	r3, [r7, #4]
    c5da:	f04f 0200 	mov.w	r2, #0
    c5de:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    c5e0:	f107 070c 	add.w	r7, r7, #12
    c5e4:	46bd      	mov	sp, r7
    c5e6:	bc80      	pop	{r7}
    c5e8:	4770      	bx	lr
    c5ea:	bf00      	nop

0000c5ec <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    c5ec:	b480      	push	{r7}
    c5ee:	b083      	sub	sp, #12
    c5f0:	af00      	add	r7, sp, #0
    c5f2:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    c5f4:	687b      	ldr	r3, [r7, #4]
    c5f6:	f04f 0200 	mov.w	r2, #0
    c5fa:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    c5fc:	f107 070c 	add.w	r7, r7, #12
    c600:	46bd      	mov	sp, r7
    c602:	bc80      	pop	{r7}
    c604:	4770      	bx	lr
    c606:	bf00      	nop

0000c608 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    c608:	b480      	push	{r7}
    c60a:	b085      	sub	sp, #20
    c60c:	af00      	add	r7, sp, #0
    c60e:	6078      	str	r0, [r7, #4]
    c610:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
    c612:	687b      	ldr	r3, [r7, #4]
    c614:	685b      	ldr	r3, [r3, #4]
    c616:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    c618:	683b      	ldr	r3, [r7, #0]
    c61a:	68fa      	ldr	r2, [r7, #12]
    c61c:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    c61e:	68fb      	ldr	r3, [r7, #12]
    c620:	689a      	ldr	r2, [r3, #8]
    c622:	683b      	ldr	r3, [r7, #0]
    c624:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    c626:	68fb      	ldr	r3, [r7, #12]
    c628:	689b      	ldr	r3, [r3, #8]
    c62a:	683a      	ldr	r2, [r7, #0]
    c62c:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
    c62e:	68fb      	ldr	r3, [r7, #12]
    c630:	683a      	ldr	r2, [r7, #0]
    c632:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    c634:	683b      	ldr	r3, [r7, #0]
    c636:	687a      	ldr	r2, [r7, #4]
    c638:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
    c63a:	687b      	ldr	r3, [r7, #4]
    c63c:	681b      	ldr	r3, [r3, #0]
    c63e:	f103 0201 	add.w	r2, r3, #1
    c642:	687b      	ldr	r3, [r7, #4]
    c644:	601a      	str	r2, [r3, #0]
}
    c646:	f107 0714 	add.w	r7, r7, #20
    c64a:	46bd      	mov	sp, r7
    c64c:	bc80      	pop	{r7}
    c64e:	4770      	bx	lr

0000c650 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    c650:	b480      	push	{r7}
    c652:	b085      	sub	sp, #20
    c654:	af00      	add	r7, sp, #0
    c656:	6078      	str	r0, [r7, #4]
    c658:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    c65a:	683b      	ldr	r3, [r7, #0]
    c65c:	681b      	ldr	r3, [r3, #0]
    c65e:	60fb      	str	r3, [r7, #12]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    c660:	68fb      	ldr	r3, [r7, #12]
    c662:	f1b3 3fff 	cmp.w	r3, #4294967295
    c666:	d103      	bne.n	c670 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    c668:	687b      	ldr	r3, [r7, #4]
    c66a:	691b      	ldr	r3, [r3, #16]
    c66c:	60bb      	str	r3, [r7, #8]
    c66e:	e00d      	b.n	c68c <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    c670:	687b      	ldr	r3, [r7, #4]
    c672:	f103 0308 	add.w	r3, r3, #8
    c676:	60bb      	str	r3, [r7, #8]
    c678:	e002      	b.n	c680 <vListInsert+0x30>
    c67a:	68bb      	ldr	r3, [r7, #8]
    c67c:	685b      	ldr	r3, [r3, #4]
    c67e:	60bb      	str	r3, [r7, #8]
    c680:	68bb      	ldr	r3, [r7, #8]
    c682:	685b      	ldr	r3, [r3, #4]
    c684:	681a      	ldr	r2, [r3, #0]
    c686:	68fb      	ldr	r3, [r7, #12]
    c688:	429a      	cmp	r2, r3
    c68a:	d9f6      	bls.n	c67a <vListInsert+0x2a>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    c68c:	68bb      	ldr	r3, [r7, #8]
    c68e:	685a      	ldr	r2, [r3, #4]
    c690:	683b      	ldr	r3, [r7, #0]
    c692:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    c694:	683b      	ldr	r3, [r7, #0]
    c696:	685b      	ldr	r3, [r3, #4]
    c698:	683a      	ldr	r2, [r7, #0]
    c69a:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
    c69c:	683b      	ldr	r3, [r7, #0]
    c69e:	68ba      	ldr	r2, [r7, #8]
    c6a0:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
    c6a2:	68bb      	ldr	r3, [r7, #8]
    c6a4:	683a      	ldr	r2, [r7, #0]
    c6a6:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    c6a8:	683b      	ldr	r3, [r7, #0]
    c6aa:	687a      	ldr	r2, [r7, #4]
    c6ac:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
    c6ae:	687b      	ldr	r3, [r7, #4]
    c6b0:	681b      	ldr	r3, [r3, #0]
    c6b2:	f103 0201 	add.w	r2, r3, #1
    c6b6:	687b      	ldr	r3, [r7, #4]
    c6b8:	601a      	str	r2, [r3, #0]
}
    c6ba:	f107 0714 	add.w	r7, r7, #20
    c6be:	46bd      	mov	sp, r7
    c6c0:	bc80      	pop	{r7}
    c6c2:	4770      	bx	lr

0000c6c4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    c6c4:	b480      	push	{r7}
    c6c6:	b085      	sub	sp, #20
    c6c8:	af00      	add	r7, sp, #0
    c6ca:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    c6cc:	687b      	ldr	r3, [r7, #4]
    c6ce:	691b      	ldr	r3, [r3, #16]
    c6d0:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    c6d2:	687b      	ldr	r3, [r7, #4]
    c6d4:	685b      	ldr	r3, [r3, #4]
    c6d6:	687a      	ldr	r2, [r7, #4]
    c6d8:	6892      	ldr	r2, [r2, #8]
    c6da:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    c6dc:	687b      	ldr	r3, [r7, #4]
    c6de:	689b      	ldr	r3, [r3, #8]
    c6e0:	687a      	ldr	r2, [r7, #4]
    c6e2:	6852      	ldr	r2, [r2, #4]
    c6e4:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    c6e6:	68fb      	ldr	r3, [r7, #12]
    c6e8:	685a      	ldr	r2, [r3, #4]
    c6ea:	687b      	ldr	r3, [r7, #4]
    c6ec:	429a      	cmp	r2, r3
    c6ee:	d103      	bne.n	c6f8 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    c6f0:	687b      	ldr	r3, [r7, #4]
    c6f2:	689a      	ldr	r2, [r3, #8]
    c6f4:	68fb      	ldr	r3, [r7, #12]
    c6f6:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    c6f8:	687b      	ldr	r3, [r7, #4]
    c6fa:	f04f 0200 	mov.w	r2, #0
    c6fe:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
    c700:	68fb      	ldr	r3, [r7, #12]
    c702:	681b      	ldr	r3, [r3, #0]
    c704:	f103 32ff 	add.w	r2, r3, #4294967295
    c708:	68fb      	ldr	r3, [r7, #12]
    c70a:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
    c70c:	68fb      	ldr	r3, [r7, #12]
    c70e:	681b      	ldr	r3, [r3, #0]
}
    c710:	4618      	mov	r0, r3
    c712:	f107 0714 	add.w	r7, r7, #20
    c716:	46bd      	mov	sp, r7
    c718:	bc80      	pop	{r7}
    c71a:	4770      	bx	lr

0000c71c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    c71c:	b580      	push	{r7, lr}
    c71e:	b084      	sub	sp, #16
    c720:	af00      	add	r7, sp, #0
    c722:	6078      	str	r0, [r7, #4]
    c724:	6039      	str	r1, [r7, #0]
Queue_t * const pxQueue = xQueue;
    c726:	687b      	ldr	r3, [r7, #4]
    c728:	60bb      	str	r3, [r7, #8]

	configASSERT( pxQueue );
    c72a:	68bb      	ldr	r3, [r7, #8]
    c72c:	2b00      	cmp	r3, #0
    c72e:	d109      	bne.n	c744 <xQueueGenericReset+0x28>
    c730:	f04f 0328 	mov.w	r3, #40	; 0x28
    c734:	f383 8811 	msr	BASEPRI, r3
    c738:	f3bf 8f6f 	isb	sy
    c73c:	f3bf 8f4f 	dsb	sy
    c740:	60fb      	str	r3, [r7, #12]
    c742:	e7fe      	b.n	c742 <xQueueGenericReset+0x26>

	taskENTER_CRITICAL();
    c744:	f005 f800 	bl	11748 <vPortEnterCritical>
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    c748:	68bb      	ldr	r3, [r7, #8]
    c74a:	681a      	ldr	r2, [r3, #0]
    c74c:	68bb      	ldr	r3, [r7, #8]
    c74e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    c750:	68b9      	ldr	r1, [r7, #8]
    c752:	6c09      	ldr	r1, [r1, #64]	; 0x40
    c754:	fb01 f303 	mul.w	r3, r1, r3
    c758:	441a      	add	r2, r3
    c75a:	68bb      	ldr	r3, [r7, #8]
    c75c:	609a      	str	r2, [r3, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    c75e:	68bb      	ldr	r3, [r7, #8]
    c760:	f04f 0200 	mov.w	r2, #0
    c764:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
    c766:	68bb      	ldr	r3, [r7, #8]
    c768:	681a      	ldr	r2, [r3, #0]
    c76a:	68bb      	ldr	r3, [r7, #8]
    c76c:	605a      	str	r2, [r3, #4]
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    c76e:	68bb      	ldr	r3, [r7, #8]
    c770:	681a      	ldr	r2, [r3, #0]
    c772:	68bb      	ldr	r3, [r7, #8]
    c774:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    c776:	f103 33ff 	add.w	r3, r3, #4294967295
    c77a:	68b9      	ldr	r1, [r7, #8]
    c77c:	6c09      	ldr	r1, [r1, #64]	; 0x40
    c77e:	fb01 f303 	mul.w	r3, r1, r3
    c782:	441a      	add	r2, r3
    c784:	68bb      	ldr	r3, [r7, #8]
    c786:	60da      	str	r2, [r3, #12]
		pxQueue->cRxLock = queueUNLOCKED;
    c788:	68bb      	ldr	r3, [r7, #8]
    c78a:	f04f 32ff 	mov.w	r2, #4294967295
    c78e:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
    c792:	68bb      	ldr	r3, [r7, #8]
    c794:	f04f 32ff 	mov.w	r2, #4294967295
    c798:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

		if( xNewQueue == pdFALSE )
    c79c:	683b      	ldr	r3, [r7, #0]
    c79e:	2b00      	cmp	r3, #0
    c7a0:	d118      	bne.n	c7d4 <xQueueGenericReset+0xb8>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    c7a2:	68bb      	ldr	r3, [r7, #8]
    c7a4:	691b      	ldr	r3, [r3, #16]
    c7a6:	2b00      	cmp	r3, #0
    c7a8:	d021      	beq.n	c7ee <xQueueGenericReset+0xd2>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    c7aa:	68bb      	ldr	r3, [r7, #8]
    c7ac:	f103 0310 	add.w	r3, r3, #16
    c7b0:	4618      	mov	r0, r3
    c7b2:	f002 fd37 	bl	f224 <xTaskRemoveFromEventList>
    c7b6:	4603      	mov	r3, r0
    c7b8:	2b00      	cmp	r3, #0
    c7ba:	d01a      	beq.n	c7f2 <xQueueGenericReset+0xd6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    c7bc:	f64e 5304 	movw	r3, #60676	; 0xed04
    c7c0:	f2ce 0300 	movt	r3, #57344	; 0xe000
    c7c4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    c7c8:	601a      	str	r2, [r3, #0]
    c7ca:	f3bf 8f4f 	dsb	sy
    c7ce:	f3bf 8f6f 	isb	sy
    c7d2:	e00f      	b.n	c7f4 <xQueueGenericReset+0xd8>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    c7d4:	68bb      	ldr	r3, [r7, #8]
    c7d6:	f103 0310 	add.w	r3, r3, #16
    c7da:	4618      	mov	r0, r3
    c7dc:	f7ff fee2 	bl	c5a4 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    c7e0:	68bb      	ldr	r3, [r7, #8]
    c7e2:	f103 0324 	add.w	r3, r3, #36	; 0x24
    c7e6:	4618      	mov	r0, r3
    c7e8:	f7ff fedc 	bl	c5a4 <vListInitialise>
    c7ec:	e002      	b.n	c7f4 <xQueueGenericReset+0xd8>
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
				{
					queueYIELD_IF_USING_PREEMPTION();
    c7ee:	bf00      	nop
    c7f0:	e000      	b.n	c7f4 <xQueueGenericReset+0xd8>
    c7f2:	bf00      	nop
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
		}
	}
	taskEXIT_CRITICAL();
    c7f4:	f004 ffe0 	bl	117b8 <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    c7f8:	f04f 0301 	mov.w	r3, #1
}
    c7fc:	4618      	mov	r0, r3
    c7fe:	f107 0710 	add.w	r7, r7, #16
    c802:	46bd      	mov	sp, r7
    c804:	bd80      	pop	{r7, pc}
    c806:	bf00      	nop

0000c808 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    c808:	b580      	push	{r7, lr}
    c80a:	b08a      	sub	sp, #40	; 0x28
    c80c:	af02      	add	r7, sp, #8
    c80e:	60f8      	str	r0, [r7, #12]
    c810:	60b9      	str	r1, [r7, #8]
    c812:	4613      	mov	r3, r2
    c814:	71fb      	strb	r3, [r7, #7]
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
    c816:	68fb      	ldr	r3, [r7, #12]
    c818:	2b00      	cmp	r3, #0
    c81a:	d109      	bne.n	c830 <xQueueGenericCreate+0x28>
    c81c:	f04f 0328 	mov.w	r3, #40	; 0x28
    c820:	f383 8811 	msr	BASEPRI, r3
    c824:	f3bf 8f6f 	isb	sy
    c828:	f3bf 8f4f 	dsb	sy
    c82c:	61fb      	str	r3, [r7, #28]
    c82e:	e7fe      	b.n	c82e <xQueueGenericCreate+0x26>

		if( uxItemSize == ( UBaseType_t ) 0 )
    c830:	68bb      	ldr	r3, [r7, #8]
    c832:	2b00      	cmp	r3, #0
    c834:	d103      	bne.n	c83e <xQueueGenericCreate+0x36>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    c836:	f04f 0300 	mov.w	r3, #0
    c83a:	617b      	str	r3, [r7, #20]
    c83c:	e004      	b.n	c848 <xQueueGenericCreate+0x40>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    c83e:	68fb      	ldr	r3, [r7, #12]
    c840:	68ba      	ldr	r2, [r7, #8]
    c842:	fb02 f303 	mul.w	r3, r2, r3
    c846:	617b      	str	r3, [r7, #20]
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    c848:	697b      	ldr	r3, [r7, #20]
    c84a:	f103 0350 	add.w	r3, r3, #80	; 0x50
    c84e:	4618      	mov	r0, r3
    c850:	f004 fcfa 	bl	11248 <pvPortMalloc>
    c854:	4603      	mov	r3, r0
    c856:	613b      	str	r3, [r7, #16]

		if( pxNewQueue != NULL )
    c858:	693b      	ldr	r3, [r7, #16]
    c85a:	2b00      	cmp	r3, #0
    c85c:	d00d      	beq.n	c87a <xQueueGenericCreate+0x72>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    c85e:	693b      	ldr	r3, [r7, #16]
    c860:	61bb      	str	r3, [r7, #24]
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    c862:	69bb      	ldr	r3, [r7, #24]
    c864:	f103 0350 	add.w	r3, r3, #80	; 0x50
    c868:	61bb      	str	r3, [r7, #24]
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    c86a:	79fb      	ldrb	r3, [r7, #7]
    c86c:	693a      	ldr	r2, [r7, #16]
    c86e:	9200      	str	r2, [sp, #0]
    c870:	68f8      	ldr	r0, [r7, #12]
    c872:	68b9      	ldr	r1, [r7, #8]
    c874:	69ba      	ldr	r2, [r7, #24]
    c876:	f000 f807 	bl	c888 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    c87a:	693b      	ldr	r3, [r7, #16]
	}
    c87c:	4618      	mov	r0, r3
    c87e:	f107 0720 	add.w	r7, r7, #32
    c882:	46bd      	mov	sp, r7
    c884:	bd80      	pop	{r7, pc}
    c886:	bf00      	nop

0000c888 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    c888:	b580      	push	{r7, lr}
    c88a:	b084      	sub	sp, #16
    c88c:	af00      	add	r7, sp, #0
    c88e:	60f8      	str	r0, [r7, #12]
    c890:	60b9      	str	r1, [r7, #8]
    c892:	607a      	str	r2, [r7, #4]
    c894:	70fb      	strb	r3, [r7, #3]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    c896:	68bb      	ldr	r3, [r7, #8]
    c898:	2b00      	cmp	r3, #0
    c89a:	d103      	bne.n	c8a4 <prvInitialiseNewQueue+0x1c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    c89c:	69ba      	ldr	r2, [r7, #24]
    c89e:	69bb      	ldr	r3, [r7, #24]
    c8a0:	601a      	str	r2, [r3, #0]
    c8a2:	e002      	b.n	c8aa <prvInitialiseNewQueue+0x22>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    c8a4:	687a      	ldr	r2, [r7, #4]
    c8a6:	69bb      	ldr	r3, [r7, #24]
    c8a8:	601a      	str	r2, [r3, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    c8aa:	69bb      	ldr	r3, [r7, #24]
    c8ac:	68fa      	ldr	r2, [r7, #12]
    c8ae:	63da      	str	r2, [r3, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
    c8b0:	69bb      	ldr	r3, [r7, #24]
    c8b2:	68ba      	ldr	r2, [r7, #8]
    c8b4:	641a      	str	r2, [r3, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    c8b6:	69b8      	ldr	r0, [r7, #24]
    c8b8:	f04f 0101 	mov.w	r1, #1
    c8bc:	f7ff ff2e 	bl	c71c <xQueueGenericReset>

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
    c8c0:	69bb      	ldr	r3, [r7, #24]
    c8c2:	78fa      	ldrb	r2, [r7, #3]
    c8c4:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    c8c8:	f107 0710 	add.w	r7, r7, #16
    c8cc:	46bd      	mov	sp, r7
    c8ce:	bd80      	pop	{r7, pc}

0000c8d0 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
    c8d0:	b580      	push	{r7, lr}
    c8d2:	b082      	sub	sp, #8
    c8d4:	af00      	add	r7, sp, #0
    c8d6:	6078      	str	r0, [r7, #4]
		if( pxNewQueue != NULL )
    c8d8:	687b      	ldr	r3, [r7, #4]
    c8da:	2b00      	cmp	r3, #0
    c8dc:	d014      	beq.n	c908 <prvInitialiseMutex+0x38>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
    c8de:	687b      	ldr	r3, [r7, #4]
    c8e0:	f04f 0200 	mov.w	r2, #0
    c8e4:	609a      	str	r2, [r3, #8]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    c8e6:	687b      	ldr	r3, [r7, #4]
    c8e8:	f04f 0200 	mov.w	r2, #0
    c8ec:	601a      	str	r2, [r3, #0]

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
    c8ee:	687b      	ldr	r3, [r7, #4]
    c8f0:	f04f 0200 	mov.w	r2, #0
    c8f4:	60da      	str	r2, [r3, #12]

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    c8f6:	6878      	ldr	r0, [r7, #4]
    c8f8:	f04f 0100 	mov.w	r1, #0
    c8fc:	f04f 0200 	mov.w	r2, #0
    c900:	f04f 0300 	mov.w	r3, #0
    c904:	f000 f894 	bl	ca30 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
    c908:	f107 0708 	add.w	r7, r7, #8
    c90c:	46bd      	mov	sp, r7
    c90e:	bd80      	pop	{r7, pc}

0000c910 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    c910:	b580      	push	{r7, lr}
    c912:	b086      	sub	sp, #24
    c914:	af00      	add	r7, sp, #0
    c916:	4603      	mov	r3, r0
    c918:	71fb      	strb	r3, [r7, #7]
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    c91a:	f04f 0301 	mov.w	r3, #1
    c91e:	613b      	str	r3, [r7, #16]
    c920:	f04f 0300 	mov.w	r3, #0
    c924:	617b      	str	r3, [r7, #20]

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    c926:	79fb      	ldrb	r3, [r7, #7]
    c928:	6938      	ldr	r0, [r7, #16]
    c92a:	6979      	ldr	r1, [r7, #20]
    c92c:	461a      	mov	r2, r3
    c92e:	f7ff ff6b 	bl	c808 <xQueueGenericCreate>
    c932:	4603      	mov	r3, r0
    c934:	60fb      	str	r3, [r7, #12]
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
    c936:	68f8      	ldr	r0, [r7, #12]
    c938:	f7ff ffca 	bl	c8d0 <prvInitialiseMutex>

		return xNewQueue;
    c93c:	68fb      	ldr	r3, [r7, #12]
	}
    c93e:	4618      	mov	r0, r3
    c940:	f107 0718 	add.w	r7, r7, #24
    c944:	46bd      	mov	sp, r7
    c946:	bd80      	pop	{r7, pc}

0000c948 <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
	{
    c948:	b590      	push	{r4, r7, lr}
    c94a:	b087      	sub	sp, #28
    c94c:	af00      	add	r7, sp, #0
    c94e:	6078      	str	r0, [r7, #4]
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
    c950:	687b      	ldr	r3, [r7, #4]
    c952:	613b      	str	r3, [r7, #16]

		configASSERT( pxMutex );
    c954:	693b      	ldr	r3, [r7, #16]
    c956:	2b00      	cmp	r3, #0
    c958:	d109      	bne.n	c96e <xQueueGiveMutexRecursive+0x26>
    c95a:	f04f 0328 	mov.w	r3, #40	; 0x28
    c95e:	f383 8811 	msr	BASEPRI, r3
    c962:	f3bf 8f6f 	isb	sy
    c966:	f3bf 8f4f 	dsb	sy
    c96a:	617b      	str	r3, [r7, #20]
    c96c:	e7fe      	b.n	c96c <xQueueGiveMutexRecursive+0x24>
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
    c96e:	693b      	ldr	r3, [r7, #16]
    c970:	689c      	ldr	r4, [r3, #8]
    c972:	f002 ffed 	bl	f950 <xTaskGetCurrentTaskHandle>
    c976:	4603      	mov	r3, r0
    c978:	429c      	cmp	r4, r3
    c97a:	d116      	bne.n	c9aa <xQueueGiveMutexRecursive+0x62>
			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
    c97c:	693b      	ldr	r3, [r7, #16]
    c97e:	68db      	ldr	r3, [r3, #12]
    c980:	f103 32ff 	add.w	r2, r3, #4294967295
    c984:	693b      	ldr	r3, [r7, #16]
    c986:	60da      	str	r2, [r3, #12]

			/* Has the recursive call count unwound to 0? */
			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
    c988:	693b      	ldr	r3, [r7, #16]
    c98a:	68db      	ldr	r3, [r3, #12]
    c98c:	2b00      	cmp	r3, #0
    c98e:	d108      	bne.n	c9a2 <xQueueGiveMutexRecursive+0x5a>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
    c990:	6938      	ldr	r0, [r7, #16]
    c992:	f04f 0100 	mov.w	r1, #0
    c996:	f04f 0200 	mov.w	r2, #0
    c99a:	f04f 0300 	mov.w	r3, #0
    c99e:	f000 f847 	bl	ca30 <xQueueGenericSend>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    c9a2:	f04f 0301 	mov.w	r3, #1
    c9a6:	60fb      	str	r3, [r7, #12]
    c9a8:	e002      	b.n	c9b0 <xQueueGiveMutexRecursive+0x68>
		}
		else
		{
			/* The mutex cannot be given because the calling task is not the
			holder. */
			xReturn = pdFAIL;
    c9aa:	f04f 0300 	mov.w	r3, #0
    c9ae:	60fb      	str	r3, [r7, #12]

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
    c9b0:	68fb      	ldr	r3, [r7, #12]
	}
    c9b2:	4618      	mov	r0, r3
    c9b4:	f107 071c 	add.w	r7, r7, #28
    c9b8:	46bd      	mov	sp, r7
    c9ba:	bd90      	pop	{r4, r7, pc}

0000c9bc <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
	{
    c9bc:	b590      	push	{r4, r7, lr}
    c9be:	b087      	sub	sp, #28
    c9c0:	af00      	add	r7, sp, #0
    c9c2:	6078      	str	r0, [r7, #4]
    c9c4:	6039      	str	r1, [r7, #0]
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
    c9c6:	687b      	ldr	r3, [r7, #4]
    c9c8:	613b      	str	r3, [r7, #16]

		configASSERT( pxMutex );
    c9ca:	693b      	ldr	r3, [r7, #16]
    c9cc:	2b00      	cmp	r3, #0
    c9ce:	d109      	bne.n	c9e4 <xQueueTakeMutexRecursive+0x28>
    c9d0:	f04f 0328 	mov.w	r3, #40	; 0x28
    c9d4:	f383 8811 	msr	BASEPRI, r3
    c9d8:	f3bf 8f6f 	isb	sy
    c9dc:	f3bf 8f4f 	dsb	sy
    c9e0:	617b      	str	r3, [r7, #20]
    c9e2:	e7fe      	b.n	c9e2 <xQueueTakeMutexRecursive+0x26>
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
    c9e4:	693b      	ldr	r3, [r7, #16]
    c9e6:	689c      	ldr	r4, [r3, #8]
    c9e8:	f002 ffb2 	bl	f950 <xTaskGetCurrentTaskHandle>
    c9ec:	4603      	mov	r3, r0
    c9ee:	429c      	cmp	r4, r3
    c9f0:	d109      	bne.n	ca06 <xQueueTakeMutexRecursive+0x4a>
		{
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
    c9f2:	693b      	ldr	r3, [r7, #16]
    c9f4:	68db      	ldr	r3, [r3, #12]
    c9f6:	f103 0201 	add.w	r2, r3, #1
    c9fa:	693b      	ldr	r3, [r7, #16]
    c9fc:	60da      	str	r2, [r3, #12]
			xReturn = pdPASS;
    c9fe:	f04f 0301 	mov.w	r3, #1
    ca02:	60fb      	str	r3, [r7, #12]
    ca04:	e00e      	b.n	ca24 <xQueueTakeMutexRecursive+0x68>
		}
		else
		{
			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
    ca06:	6938      	ldr	r0, [r7, #16]
    ca08:	6839      	ldr	r1, [r7, #0]
    ca0a:	f000 fb57 	bl	d0bc <xQueueSemaphoreTake>
    ca0e:	4603      	mov	r3, r0
    ca10:	60fb      	str	r3, [r7, #12]

			/* pdPASS will only be returned if the mutex was successfully
			obtained.  The calling task may have entered the Blocked state
			before reaching here. */
			if( xReturn != pdFAIL )
    ca12:	68fb      	ldr	r3, [r7, #12]
    ca14:	2b00      	cmp	r3, #0
    ca16:	d005      	beq.n	ca24 <xQueueTakeMutexRecursive+0x68>
			{
				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
    ca18:	693b      	ldr	r3, [r7, #16]
    ca1a:	68db      	ldr	r3, [r3, #12]
    ca1c:	f103 0201 	add.w	r2, r3, #1
    ca20:	693b      	ldr	r3, [r7, #16]
    ca22:	60da      	str	r2, [r3, #12]
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
    ca24:	68fb      	ldr	r3, [r7, #12]
	}
    ca26:	4618      	mov	r0, r3
    ca28:	f107 071c 	add.w	r7, r7, #28
    ca2c:	46bd      	mov	sp, r7
    ca2e:	bd90      	pop	{r4, r7, pc}

0000ca30 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    ca30:	b580      	push	{r7, lr}
    ca32:	b08e      	sub	sp, #56	; 0x38
    ca34:	af00      	add	r7, sp, #0
    ca36:	60f8      	str	r0, [r7, #12]
    ca38:	60b9      	str	r1, [r7, #8]
    ca3a:	607a      	str	r2, [r7, #4]
    ca3c:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    ca3e:	f04f 0300 	mov.w	r3, #0
    ca42:	61fb      	str	r3, [r7, #28]
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    ca44:	68fb      	ldr	r3, [r7, #12]
    ca46:	627b      	str	r3, [r7, #36]	; 0x24

	configASSERT( pxQueue );
    ca48:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    ca4a:	2b00      	cmp	r3, #0
    ca4c:	d109      	bne.n	ca62 <xQueueGenericSend+0x32>
    ca4e:	f04f 0328 	mov.w	r3, #40	; 0x28
    ca52:	f383 8811 	msr	BASEPRI, r3
    ca56:	f3bf 8f6f 	isb	sy
    ca5a:	f3bf 8f4f 	dsb	sy
    ca5e:	62bb      	str	r3, [r7, #40]	; 0x28
    ca60:	e7fe      	b.n	ca60 <xQueueGenericSend+0x30>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    ca62:	68bb      	ldr	r3, [r7, #8]
    ca64:	2b00      	cmp	r3, #0
    ca66:	d103      	bne.n	ca70 <xQueueGenericSend+0x40>
    ca68:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    ca6a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    ca6c:	2b00      	cmp	r3, #0
    ca6e:	d102      	bne.n	ca76 <xQueueGenericSend+0x46>
    ca70:	f04f 0301 	mov.w	r3, #1
    ca74:	e001      	b.n	ca7a <xQueueGenericSend+0x4a>
    ca76:	f04f 0300 	mov.w	r3, #0
    ca7a:	2b00      	cmp	r3, #0
    ca7c:	d109      	bne.n	ca92 <xQueueGenericSend+0x62>
    ca7e:	f04f 0328 	mov.w	r3, #40	; 0x28
    ca82:	f383 8811 	msr	BASEPRI, r3
    ca86:	f3bf 8f6f 	isb	sy
    ca8a:	f3bf 8f4f 	dsb	sy
    ca8e:	62fb      	str	r3, [r7, #44]	; 0x2c
    ca90:	e7fe      	b.n	ca90 <xQueueGenericSend+0x60>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    ca92:	683b      	ldr	r3, [r7, #0]
    ca94:	2b02      	cmp	r3, #2
    ca96:	d103      	bne.n	caa0 <xQueueGenericSend+0x70>
    ca98:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    ca9a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    ca9c:	2b01      	cmp	r3, #1
    ca9e:	d102      	bne.n	caa6 <xQueueGenericSend+0x76>
    caa0:	f04f 0301 	mov.w	r3, #1
    caa4:	e001      	b.n	caaa <xQueueGenericSend+0x7a>
    caa6:	f04f 0300 	mov.w	r3, #0
    caaa:	2b00      	cmp	r3, #0
    caac:	d109      	bne.n	cac2 <xQueueGenericSend+0x92>
    caae:	f04f 0328 	mov.w	r3, #40	; 0x28
    cab2:	f383 8811 	msr	BASEPRI, r3
    cab6:	f3bf 8f6f 	isb	sy
    caba:	f3bf 8f4f 	dsb	sy
    cabe:	633b      	str	r3, [r7, #48]	; 0x30
    cac0:	e7fe      	b.n	cac0 <xQueueGenericSend+0x90>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    cac2:	f002 ff55 	bl	f970 <xTaskGetSchedulerState>
    cac6:	4603      	mov	r3, r0
    cac8:	2b00      	cmp	r3, #0
    caca:	d102      	bne.n	cad2 <xQueueGenericSend+0xa2>
    cacc:	687b      	ldr	r3, [r7, #4]
    cace:	2b00      	cmp	r3, #0
    cad0:	d102      	bne.n	cad8 <xQueueGenericSend+0xa8>
    cad2:	f04f 0301 	mov.w	r3, #1
    cad6:	e001      	b.n	cadc <xQueueGenericSend+0xac>
    cad8:	f04f 0300 	mov.w	r3, #0
    cadc:	2b00      	cmp	r3, #0
    cade:	d10a      	bne.n	caf6 <xQueueGenericSend+0xc6>
    cae0:	f04f 0328 	mov.w	r3, #40	; 0x28
    cae4:	f383 8811 	msr	BASEPRI, r3
    cae8:	f3bf 8f6f 	isb	sy
    caec:	f3bf 8f4f 	dsb	sy
    caf0:	637b      	str	r3, [r7, #52]	; 0x34
    caf2:	e7fe      	b.n	caf2 <xQueueGenericSend+0xc2>
			( void ) xTaskResumeAll();

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	} /*lint -restore */
    caf4:	bf00      	nop
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    caf6:	f004 fe27 	bl	11748 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    cafa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    cafc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    cafe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    cb00:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    cb02:	429a      	cmp	r2, r3
    cb04:	d302      	bcc.n	cb0c <xQueueGenericSend+0xdc>
    cb06:	683b      	ldr	r3, [r7, #0]
    cb08:	2b02      	cmp	r3, #2
    cb0a:	d134      	bne.n	cb76 <xQueueGenericSend+0x146>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    cb0c:	6a78      	ldr	r0, [r7, #36]	; 0x24
    cb0e:	68b9      	ldr	r1, [r7, #8]
    cb10:	683a      	ldr	r2, [r7, #0]
    cb12:	f000 fe9d 	bl	d850 <prvCopyDataToQueue>
    cb16:	4603      	mov	r3, r0
    cb18:	623b      	str	r3, [r7, #32]

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    cb1a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    cb1c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    cb1e:	2b00      	cmp	r3, #0
    cb20:	d014      	beq.n	cb4c <xQueueGenericSend+0x11c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    cb22:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    cb24:	f103 0324 	add.w	r3, r3, #36	; 0x24
    cb28:	4618      	mov	r0, r3
    cb2a:	f002 fb7b 	bl	f224 <xTaskRemoveFromEventList>
    cb2e:	4603      	mov	r3, r0
    cb30:	2b00      	cmp	r3, #0
    cb32:	d01a      	beq.n	cb6a <xQueueGenericSend+0x13a>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    cb34:	f64e 5304 	movw	r3, #60676	; 0xed04
    cb38:	f2ce 0300 	movt	r3, #57344	; 0xe000
    cb3c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    cb40:	601a      	str	r2, [r3, #0]
    cb42:	f3bf 8f4f 	dsb	sy
    cb46:	f3bf 8f6f 	isb	sy
    cb4a:	e00f      	b.n	cb6c <xQueueGenericSend+0x13c>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    cb4c:	6a3b      	ldr	r3, [r7, #32]
    cb4e:	2b00      	cmp	r3, #0
    cb50:	d00c      	beq.n	cb6c <xQueueGenericSend+0x13c>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    cb52:	f64e 5304 	movw	r3, #60676	; 0xed04
    cb56:	f2ce 0300 	movt	r3, #57344	; 0xe000
    cb5a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    cb5e:	601a      	str	r2, [r3, #0]
    cb60:	f3bf 8f4f 	dsb	sy
    cb64:	f3bf 8f6f 	isb	sy
    cb68:	e000      	b.n	cb6c <xQueueGenericSend+0x13c>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    cb6a:	bf00      	nop
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    cb6c:	f004 fe24 	bl	117b8 <vPortExitCritical>
				return pdPASS;
    cb70:	f04f 0301 	mov.w	r3, #1
    cb74:	e06f      	b.n	cc56 <xQueueGenericSend+0x226>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    cb76:	687b      	ldr	r3, [r7, #4]
    cb78:	2b00      	cmp	r3, #0
    cb7a:	d104      	bne.n	cb86 <xQueueGenericSend+0x156>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    cb7c:	f004 fe1c 	bl	117b8 <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    cb80:	f04f 0300 	mov.w	r3, #0
    cb84:	e067      	b.n	cc56 <xQueueGenericSend+0x226>
				}
				else if( xEntryTimeSet == pdFALSE )
    cb86:	69fb      	ldr	r3, [r7, #28]
    cb88:	2b00      	cmp	r3, #0
    cb8a:	d107      	bne.n	cb9c <xQueueGenericSend+0x16c>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    cb8c:	f107 0314 	add.w	r3, r7, #20
    cb90:	4618      	mov	r0, r3
    cb92:	f002 fc57 	bl	f444 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    cb96:	f04f 0301 	mov.w	r3, #1
    cb9a:	61fb      	str	r3, [r7, #28]
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    cb9c:	f004 fe0c 	bl	117b8 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    cba0:	f001 feee 	bl	e980 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    cba4:	f004 fdd0 	bl	11748 <vPortEnterCritical>
    cba8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    cbaa:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
    cbae:	b2db      	uxtb	r3, r3
    cbb0:	b25b      	sxtb	r3, r3
    cbb2:	f1b3 3fff 	cmp.w	r3, #4294967295
    cbb6:	d104      	bne.n	cbc2 <xQueueGenericSend+0x192>
    cbb8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    cbba:	f04f 0200 	mov.w	r2, #0
    cbbe:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    cbc2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    cbc4:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
    cbc8:	b2db      	uxtb	r3, r3
    cbca:	b25b      	sxtb	r3, r3
    cbcc:	f1b3 3fff 	cmp.w	r3, #4294967295
    cbd0:	d104      	bne.n	cbdc <xQueueGenericSend+0x1ac>
    cbd2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    cbd4:	f04f 0200 	mov.w	r2, #0
    cbd8:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
    cbdc:	f004 fdec 	bl	117b8 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    cbe0:	f107 0214 	add.w	r2, r7, #20
    cbe4:	f107 0304 	add.w	r3, r7, #4
    cbe8:	4610      	mov	r0, r2
    cbea:	4619      	mov	r1, r3
    cbec:	f002 fc42 	bl	f474 <xTaskCheckForTimeOut>
    cbf0:	4603      	mov	r3, r0
    cbf2:	2b00      	cmp	r3, #0
    cbf4:	d128      	bne.n	cc48 <xQueueGenericSend+0x218>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    cbf6:	6a78      	ldr	r0, [r7, #36]	; 0x24
    cbf8:	f000 ff60 	bl	dabc <prvIsQueueFull>
    cbfc:	4603      	mov	r3, r0
    cbfe:	2b00      	cmp	r3, #0
    cc00:	d01c      	beq.n	cc3c <xQueueGenericSend+0x20c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    cc02:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    cc04:	f103 0210 	add.w	r2, r3, #16
    cc08:	687b      	ldr	r3, [r7, #4]
    cc0a:	4610      	mov	r0, r2
    cc0c:	4619      	mov	r1, r3
    cc0e:	f002 fa75 	bl	f0fc <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    cc12:	6a78      	ldr	r0, [r7, #36]	; 0x24
    cc14:	f000 febc 	bl	d990 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    cc18:	f001 fec4 	bl	e9a4 <xTaskResumeAll>
    cc1c:	4603      	mov	r3, r0
    cc1e:	2b00      	cmp	r3, #0
    cc20:	f47f af68 	bne.w	caf4 <xQueueGenericSend+0xc4>
				{
					portYIELD_WITHIN_API();
    cc24:	f64e 5304 	movw	r3, #60676	; 0xed04
    cc28:	f2ce 0300 	movt	r3, #57344	; 0xe000
    cc2c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    cc30:	601a      	str	r2, [r3, #0]
    cc32:	f3bf 8f4f 	dsb	sy
    cc36:	f3bf 8f6f 	isb	sy
			( void ) xTaskResumeAll();

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	} /*lint -restore */
    cc3a:	e75c      	b.n	caf6 <xQueueGenericSend+0xc6>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    cc3c:	6a78      	ldr	r0, [r7, #36]	; 0x24
    cc3e:	f000 fea7 	bl	d990 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    cc42:	f001 feaf 	bl	e9a4 <xTaskResumeAll>
			( void ) xTaskResumeAll();

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	} /*lint -restore */
    cc46:	e756      	b.n	caf6 <xQueueGenericSend+0xc6>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    cc48:	6a78      	ldr	r0, [r7, #36]	; 0x24
    cc4a:	f000 fea1 	bl	d990 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    cc4e:	f001 fea9 	bl	e9a4 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    cc52:	f04f 0300 	mov.w	r3, #0
		}
	} /*lint -restore */
}
    cc56:	4618      	mov	r0, r3
    cc58:	f107 0738 	add.w	r7, r7, #56	; 0x38
    cc5c:	46bd      	mov	sp, r7
    cc5e:	bd80      	pop	{r7, pc}

0000cc60 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    cc60:	b580      	push	{r7, lr}
    cc62:	b08e      	sub	sp, #56	; 0x38
    cc64:	af00      	add	r7, sp, #0
    cc66:	60f8      	str	r0, [r7, #12]
    cc68:	60b9      	str	r1, [r7, #8]
    cc6a:	607a      	str	r2, [r7, #4]
    cc6c:	603b      	str	r3, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    cc6e:	68fb      	ldr	r3, [r7, #12]
    cc70:	61bb      	str	r3, [r7, #24]

	configASSERT( pxQueue );
    cc72:	69bb      	ldr	r3, [r7, #24]
    cc74:	2b00      	cmp	r3, #0
    cc76:	d109      	bne.n	cc8c <xQueueGenericSendFromISR+0x2c>
    cc78:	f04f 0328 	mov.w	r3, #40	; 0x28
    cc7c:	f383 8811 	msr	BASEPRI, r3
    cc80:	f3bf 8f6f 	isb	sy
    cc84:	f3bf 8f4f 	dsb	sy
    cc88:	623b      	str	r3, [r7, #32]
    cc8a:	e7fe      	b.n	cc8a <xQueueGenericSendFromISR+0x2a>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    cc8c:	68bb      	ldr	r3, [r7, #8]
    cc8e:	2b00      	cmp	r3, #0
    cc90:	d103      	bne.n	cc9a <xQueueGenericSendFromISR+0x3a>
    cc92:	69bb      	ldr	r3, [r7, #24]
    cc94:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    cc96:	2b00      	cmp	r3, #0
    cc98:	d102      	bne.n	cca0 <xQueueGenericSendFromISR+0x40>
    cc9a:	f04f 0301 	mov.w	r3, #1
    cc9e:	e001      	b.n	cca4 <xQueueGenericSendFromISR+0x44>
    cca0:	f04f 0300 	mov.w	r3, #0
    cca4:	2b00      	cmp	r3, #0
    cca6:	d109      	bne.n	ccbc <xQueueGenericSendFromISR+0x5c>
    cca8:	f04f 0328 	mov.w	r3, #40	; 0x28
    ccac:	f383 8811 	msr	BASEPRI, r3
    ccb0:	f3bf 8f6f 	isb	sy
    ccb4:	f3bf 8f4f 	dsb	sy
    ccb8:	627b      	str	r3, [r7, #36]	; 0x24
    ccba:	e7fe      	b.n	ccba <xQueueGenericSendFromISR+0x5a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    ccbc:	683b      	ldr	r3, [r7, #0]
    ccbe:	2b02      	cmp	r3, #2
    ccc0:	d103      	bne.n	ccca <xQueueGenericSendFromISR+0x6a>
    ccc2:	69bb      	ldr	r3, [r7, #24]
    ccc4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    ccc6:	2b01      	cmp	r3, #1
    ccc8:	d102      	bne.n	ccd0 <xQueueGenericSendFromISR+0x70>
    ccca:	f04f 0301 	mov.w	r3, #1
    ccce:	e001      	b.n	ccd4 <xQueueGenericSendFromISR+0x74>
    ccd0:	f04f 0300 	mov.w	r3, #0
    ccd4:	2b00      	cmp	r3, #0
    ccd6:	d109      	bne.n	ccec <xQueueGenericSendFromISR+0x8c>
    ccd8:	f04f 0328 	mov.w	r3, #40	; 0x28
    ccdc:	f383 8811 	msr	BASEPRI, r3
    cce0:	f3bf 8f6f 	isb	sy
    cce4:	f3bf 8f4f 	dsb	sy
    cce8:	62bb      	str	r3, [r7, #40]	; 0x28
    ccea:	e7fe      	b.n	ccea <xQueueGenericSendFromISR+0x8a>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    ccec:	f004 fe10 	bl	11910 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
    ccf0:	f3ef 8211 	mrs	r2, BASEPRI
    ccf4:	f04f 0328 	mov.w	r3, #40	; 0x28
    ccf8:	f383 8811 	msr	BASEPRI, r3
    ccfc:	f3bf 8f6f 	isb	sy
    cd00:	f3bf 8f4f 	dsb	sy
    cd04:	633a      	str	r2, [r7, #48]	; 0x30
    cd06:	62fb      	str	r3, [r7, #44]	; 0x2c
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
    cd08:	6b3b      	ldr	r3, [r7, #48]	; 0x30
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    cd0a:	617b      	str	r3, [r7, #20]
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    cd0c:	69bb      	ldr	r3, [r7, #24]
    cd0e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    cd10:	69bb      	ldr	r3, [r7, #24]
    cd12:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    cd14:	429a      	cmp	r2, r3
    cd16:	d302      	bcc.n	cd1e <xQueueGenericSendFromISR+0xbe>
    cd18:	683b      	ldr	r3, [r7, #0]
    cd1a:	2b02      	cmp	r3, #2
    cd1c:	d134      	bne.n	cd88 <xQueueGenericSendFromISR+0x128>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    cd1e:	69bb      	ldr	r3, [r7, #24]
    cd20:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
    cd24:	77fb      	strb	r3, [r7, #31]
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    cd26:	69b8      	ldr	r0, [r7, #24]
    cd28:	68b9      	ldr	r1, [r7, #8]
    cd2a:	683a      	ldr	r2, [r7, #0]
    cd2c:	f000 fd90 	bl	d850 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    cd30:	f997 301f 	ldrsb.w	r3, [r7, #31]
    cd34:	f1b3 3fff 	cmp.w	r3, #4294967295
    cd38:	d114      	bne.n	cd64 <xQueueGenericSendFromISR+0x104>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    cd3a:	69bb      	ldr	r3, [r7, #24]
    cd3c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    cd3e:	2b00      	cmp	r3, #0
    cd40:	d019      	beq.n	cd76 <xQueueGenericSendFromISR+0x116>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    cd42:	69bb      	ldr	r3, [r7, #24]
    cd44:	f103 0324 	add.w	r3, r3, #36	; 0x24
    cd48:	4618      	mov	r0, r3
    cd4a:	f002 fa6b 	bl	f224 <xTaskRemoveFromEventList>
    cd4e:	4603      	mov	r3, r0
    cd50:	2b00      	cmp	r3, #0
    cd52:	d012      	beq.n	cd7a <xQueueGenericSendFromISR+0x11a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    cd54:	687b      	ldr	r3, [r7, #4]
    cd56:	2b00      	cmp	r3, #0
    cd58:	d011      	beq.n	cd7e <xQueueGenericSendFromISR+0x11e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    cd5a:	687b      	ldr	r3, [r7, #4]
    cd5c:	f04f 0201 	mov.w	r2, #1
    cd60:	601a      	str	r2, [r3, #0]
    cd62:	e00d      	b.n	cd80 <xQueueGenericSendFromISR+0x120>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    cd64:	7ffb      	ldrb	r3, [r7, #31]
    cd66:	f103 0301 	add.w	r3, r3, #1
    cd6a:	b2db      	uxtb	r3, r3
    cd6c:	461a      	mov	r2, r3
    cd6e:	69bb      	ldr	r3, [r7, #24]
    cd70:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
    cd74:	e004      	b.n	cd80 <xQueueGenericSendFromISR+0x120>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    cd76:	bf00      	nop
    cd78:	e002      	b.n	cd80 <xQueueGenericSendFromISR+0x120>
    cd7a:	bf00      	nop
    cd7c:	e000      	b.n	cd80 <xQueueGenericSendFromISR+0x120>
    cd7e:	bf00      	nop
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    cd80:	f04f 0301 	mov.w	r3, #1
    cd84:	613b      	str	r3, [r7, #16]
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    cd86:	e002      	b.n	cd8e <xQueueGenericSendFromISR+0x12e>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    cd88:	f04f 0300 	mov.w	r3, #0
    cd8c:	613b      	str	r3, [r7, #16]
    cd8e:	697b      	ldr	r3, [r7, #20]
    cd90:	637b      	str	r3, [r7, #52]	; 0x34
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
    cd92:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    cd94:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    cd98:	693b      	ldr	r3, [r7, #16]
}
    cd9a:	4618      	mov	r0, r3
    cd9c:	f107 0738 	add.w	r7, r7, #56	; 0x38
    cda0:	46bd      	mov	sp, r7
    cda2:	bd80      	pop	{r7, pc}

0000cda4 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    cda4:	b580      	push	{r7, lr}
    cda6:	b08e      	sub	sp, #56	; 0x38
    cda8:	af00      	add	r7, sp, #0
    cdaa:	6078      	str	r0, [r7, #4]
    cdac:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    cdae:	687b      	ldr	r3, [r7, #4]
    cdb0:	617b      	str	r3, [r7, #20]
	item size is 0.  Don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */

	configASSERT( pxQueue );
    cdb2:	697b      	ldr	r3, [r7, #20]
    cdb4:	2b00      	cmp	r3, #0
    cdb6:	d109      	bne.n	cdcc <xQueueGiveFromISR+0x28>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
    cdb8:	f04f 0328 	mov.w	r3, #40	; 0x28
    cdbc:	f383 8811 	msr	BASEPRI, r3
    cdc0:	f3bf 8f6f 	isb	sy
    cdc4:	f3bf 8f4f 	dsb	sy
    cdc8:	623b      	str	r3, [r7, #32]
    cdca:	e7fe      	b.n	cdca <xQueueGiveFromISR+0x26>

	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
	if the item size is not 0. */
	configASSERT( pxQueue->uxItemSize == 0 );
    cdcc:	697b      	ldr	r3, [r7, #20]
    cdce:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    cdd0:	2b00      	cmp	r3, #0
    cdd2:	d009      	beq.n	cde8 <xQueueGiveFromISR+0x44>
    cdd4:	f04f 0328 	mov.w	r3, #40	; 0x28
    cdd8:	f383 8811 	msr	BASEPRI, r3
    cddc:	f3bf 8f6f 	isb	sy
    cde0:	f3bf 8f4f 	dsb	sy
    cde4:	627b      	str	r3, [r7, #36]	; 0x24
    cde6:	e7fe      	b.n	cde6 <xQueueGiveFromISR+0x42>

	/* Normally a mutex would not be given from an interrupt, especially if
	there is a mutex holder, as priority inheritance makes no sense for an
	interrupts, only tasks. */
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
    cde8:	697b      	ldr	r3, [r7, #20]
    cdea:	681b      	ldr	r3, [r3, #0]
    cdec:	2b00      	cmp	r3, #0
    cdee:	d103      	bne.n	cdf8 <xQueueGiveFromISR+0x54>
    cdf0:	697b      	ldr	r3, [r7, #20]
    cdf2:	689b      	ldr	r3, [r3, #8]
    cdf4:	2b00      	cmp	r3, #0
    cdf6:	d102      	bne.n	cdfe <xQueueGiveFromISR+0x5a>
    cdf8:	f04f 0301 	mov.w	r3, #1
    cdfc:	e001      	b.n	ce02 <xQueueGiveFromISR+0x5e>
    cdfe:	f04f 0300 	mov.w	r3, #0
    ce02:	2b00      	cmp	r3, #0
    ce04:	d109      	bne.n	ce1a <xQueueGiveFromISR+0x76>
    ce06:	f04f 0328 	mov.w	r3, #40	; 0x28
    ce0a:	f383 8811 	msr	BASEPRI, r3
    ce0e:	f3bf 8f6f 	isb	sy
    ce12:	f3bf 8f4f 	dsb	sy
    ce16:	62bb      	str	r3, [r7, #40]	; 0x28
    ce18:	e7fe      	b.n	ce18 <xQueueGiveFromISR+0x74>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    ce1a:	f004 fd79 	bl	11910 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
    ce1e:	f3ef 8211 	mrs	r2, BASEPRI
    ce22:	f04f 0328 	mov.w	r3, #40	; 0x28
    ce26:	f383 8811 	msr	BASEPRI, r3
    ce2a:	f3bf 8f6f 	isb	sy
    ce2e:	f3bf 8f4f 	dsb	sy
    ce32:	633a      	str	r2, [r7, #48]	; 0x30
    ce34:	62fb      	str	r3, [r7, #44]	; 0x2c
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
    ce36:	6b3b      	ldr	r3, [r7, #48]	; 0x30

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    ce38:	613b      	str	r3, [r7, #16]
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    ce3a:	697b      	ldr	r3, [r7, #20]
    ce3c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    ce3e:	61bb      	str	r3, [r7, #24]

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    ce40:	697b      	ldr	r3, [r7, #20]
    ce42:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    ce44:	69bb      	ldr	r3, [r7, #24]
    ce46:	429a      	cmp	r2, r3
    ce48:	d934      	bls.n	ceb4 <xQueueGiveFromISR+0x110>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    ce4a:	697b      	ldr	r3, [r7, #20]
    ce4c:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
    ce50:	77fb      	strb	r3, [r7, #31]
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    ce52:	69bb      	ldr	r3, [r7, #24]
    ce54:	f103 0201 	add.w	r2, r3, #1
    ce58:	697b      	ldr	r3, [r7, #20]
    ce5a:	639a      	str	r2, [r3, #56]	; 0x38

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    ce5c:	f997 301f 	ldrsb.w	r3, [r7, #31]
    ce60:	f1b3 3fff 	cmp.w	r3, #4294967295
    ce64:	d114      	bne.n	ce90 <xQueueGiveFromISR+0xec>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    ce66:	697b      	ldr	r3, [r7, #20]
    ce68:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    ce6a:	2b00      	cmp	r3, #0
    ce6c:	d019      	beq.n	cea2 <xQueueGiveFromISR+0xfe>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    ce6e:	697b      	ldr	r3, [r7, #20]
    ce70:	f103 0324 	add.w	r3, r3, #36	; 0x24
    ce74:	4618      	mov	r0, r3
    ce76:	f002 f9d5 	bl	f224 <xTaskRemoveFromEventList>
    ce7a:	4603      	mov	r3, r0
    ce7c:	2b00      	cmp	r3, #0
    ce7e:	d012      	beq.n	cea6 <xQueueGiveFromISR+0x102>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    ce80:	683b      	ldr	r3, [r7, #0]
    ce82:	2b00      	cmp	r3, #0
    ce84:	d011      	beq.n	ceaa <xQueueGiveFromISR+0x106>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    ce86:	683b      	ldr	r3, [r7, #0]
    ce88:	f04f 0201 	mov.w	r2, #1
    ce8c:	601a      	str	r2, [r3, #0]
    ce8e:	e00d      	b.n	ceac <xQueueGiveFromISR+0x108>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    ce90:	7ffb      	ldrb	r3, [r7, #31]
    ce92:	f103 0301 	add.w	r3, r3, #1
    ce96:	b2db      	uxtb	r3, r3
    ce98:	461a      	mov	r2, r3
    ce9a:	697b      	ldr	r3, [r7, #20]
    ce9c:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
    cea0:	e004      	b.n	ceac <xQueueGiveFromISR+0x108>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    cea2:	bf00      	nop
    cea4:	e002      	b.n	ceac <xQueueGiveFromISR+0x108>
    cea6:	bf00      	nop
    cea8:	e000      	b.n	ceac <xQueueGiveFromISR+0x108>
    ceaa:	bf00      	nop
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    ceac:	f04f 0301 	mov.w	r3, #1
    ceb0:	60fb      	str	r3, [r7, #12]
    ceb2:	e002      	b.n	ceba <xQueueGiveFromISR+0x116>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    ceb4:	f04f 0300 	mov.w	r3, #0
    ceb8:	60fb      	str	r3, [r7, #12]
    ceba:	693b      	ldr	r3, [r7, #16]
    cebc:	637b      	str	r3, [r7, #52]	; 0x34
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
    cebe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    cec0:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    cec4:	68fb      	ldr	r3, [r7, #12]
}
    cec6:	4618      	mov	r0, r3
    cec8:	f107 0738 	add.w	r7, r7, #56	; 0x38
    cecc:	46bd      	mov	sp, r7
    cece:	bd80      	pop	{r7, pc}

0000ced0 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    ced0:	b580      	push	{r7, lr}
    ced2:	b08c      	sub	sp, #48	; 0x30
    ced4:	af00      	add	r7, sp, #0
    ced6:	60f8      	str	r0, [r7, #12]
    ced8:	60b9      	str	r1, [r7, #8]
    ceda:	607a      	str	r2, [r7, #4]
BaseType_t xEntryTimeSet = pdFALSE;
    cedc:	f04f 0300 	mov.w	r3, #0
    cee0:	61bb      	str	r3, [r7, #24]
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    cee2:	68fb      	ldr	r3, [r7, #12]
    cee4:	61fb      	str	r3, [r7, #28]

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
    cee6:	69fb      	ldr	r3, [r7, #28]
    cee8:	2b00      	cmp	r3, #0
    ceea:	d109      	bne.n	cf00 <xQueueReceive+0x30>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
    ceec:	f04f 0328 	mov.w	r3, #40	; 0x28
    cef0:	f383 8811 	msr	BASEPRI, r3
    cef4:	f3bf 8f6f 	isb	sy
    cef8:	f3bf 8f4f 	dsb	sy
    cefc:	627b      	str	r3, [r7, #36]	; 0x24
    cefe:	e7fe      	b.n	cefe <xQueueReceive+0x2e>

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    cf00:	68bb      	ldr	r3, [r7, #8]
    cf02:	2b00      	cmp	r3, #0
    cf04:	d103      	bne.n	cf0e <xQueueReceive+0x3e>
    cf06:	69fb      	ldr	r3, [r7, #28]
    cf08:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    cf0a:	2b00      	cmp	r3, #0
    cf0c:	d102      	bne.n	cf14 <xQueueReceive+0x44>
    cf0e:	f04f 0301 	mov.w	r3, #1
    cf12:	e001      	b.n	cf18 <xQueueReceive+0x48>
    cf14:	f04f 0300 	mov.w	r3, #0
    cf18:	2b00      	cmp	r3, #0
    cf1a:	d109      	bne.n	cf30 <xQueueReceive+0x60>
    cf1c:	f04f 0328 	mov.w	r3, #40	; 0x28
    cf20:	f383 8811 	msr	BASEPRI, r3
    cf24:	f3bf 8f6f 	isb	sy
    cf28:	f3bf 8f4f 	dsb	sy
    cf2c:	62bb      	str	r3, [r7, #40]	; 0x28
    cf2e:	e7fe      	b.n	cf2e <xQueueReceive+0x5e>

	/* Cannot block if the scheduler is suspended. */
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    cf30:	f002 fd1e 	bl	f970 <xTaskGetSchedulerState>
    cf34:	4603      	mov	r3, r0
    cf36:	2b00      	cmp	r3, #0
    cf38:	d102      	bne.n	cf40 <xQueueReceive+0x70>
    cf3a:	687b      	ldr	r3, [r7, #4]
    cf3c:	2b00      	cmp	r3, #0
    cf3e:	d102      	bne.n	cf46 <xQueueReceive+0x76>
    cf40:	f04f 0301 	mov.w	r3, #1
    cf44:	e001      	b.n	cf4a <xQueueReceive+0x7a>
    cf46:	f04f 0300 	mov.w	r3, #0
    cf4a:	2b00      	cmp	r3, #0
    cf4c:	d10c      	bne.n	cf68 <xQueueReceive+0x98>
    cf4e:	f04f 0328 	mov.w	r3, #40	; 0x28
    cf52:	f383 8811 	msr	BASEPRI, r3
    cf56:	f3bf 8f6f 	isb	sy
    cf5a:	f3bf 8f4f 	dsb	sy
    cf5e:	62fb      	str	r3, [r7, #44]	; 0x2c
    cf60:	e7fe      	b.n	cf60 <xQueueReceive+0x90>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    cf62:	bf00      	nop
    cf64:	e000      	b.n	cf68 <xQueueReceive+0x98>
    cf66:	bf00      	nop
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    cf68:	f004 fbee 	bl	11748 <vPortEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    cf6c:	69fb      	ldr	r3, [r7, #28]
    cf6e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    cf70:	623b      	str	r3, [r7, #32]

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    cf72:	6a3b      	ldr	r3, [r7, #32]
    cf74:	2b00      	cmp	r3, #0
    cf76:	d025      	beq.n	cfc4 <xQueueReceive+0xf4>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    cf78:	69f8      	ldr	r0, [r7, #28]
    cf7a:	68b9      	ldr	r1, [r7, #8]
    cf7c:	f000 fce0 	bl	d940 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    cf80:	6a3b      	ldr	r3, [r7, #32]
    cf82:	f103 32ff 	add.w	r2, r3, #4294967295
    cf86:	69fb      	ldr	r3, [r7, #28]
    cf88:	639a      	str	r2, [r3, #56]	; 0x38

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    cf8a:	69fb      	ldr	r3, [r7, #28]
    cf8c:	691b      	ldr	r3, [r3, #16]
    cf8e:	2b00      	cmp	r3, #0
    cf90:	d013      	beq.n	cfba <xQueueReceive+0xea>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    cf92:	69fb      	ldr	r3, [r7, #28]
    cf94:	f103 0310 	add.w	r3, r3, #16
    cf98:	4618      	mov	r0, r3
    cf9a:	f002 f943 	bl	f224 <xTaskRemoveFromEventList>
    cf9e:	4603      	mov	r3, r0
    cfa0:	2b00      	cmp	r3, #0
    cfa2:	d00a      	beq.n	cfba <xQueueReceive+0xea>
					{
						queueYIELD_IF_USING_PREEMPTION();
    cfa4:	f64e 5304 	movw	r3, #60676	; 0xed04
    cfa8:	f2ce 0300 	movt	r3, #57344	; 0xe000
    cfac:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    cfb0:	601a      	str	r2, [r3, #0]
    cfb2:	f3bf 8f4f 	dsb	sy
    cfb6:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    cfba:	f004 fbfd 	bl	117b8 <vPortExitCritical>
				return pdPASS;
    cfbe:	f04f 0301 	mov.w	r3, #1
    cfc2:	e076      	b.n	d0b2 <xQueueReceive+0x1e2>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    cfc4:	687b      	ldr	r3, [r7, #4]
    cfc6:	2b00      	cmp	r3, #0
    cfc8:	d104      	bne.n	cfd4 <xQueueReceive+0x104>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    cfca:	f004 fbf5 	bl	117b8 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    cfce:	f04f 0300 	mov.w	r3, #0
    cfd2:	e06e      	b.n	d0b2 <xQueueReceive+0x1e2>
				}
				else if( xEntryTimeSet == pdFALSE )
    cfd4:	69bb      	ldr	r3, [r7, #24]
    cfd6:	2b00      	cmp	r3, #0
    cfd8:	d107      	bne.n	cfea <xQueueReceive+0x11a>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    cfda:	f107 0310 	add.w	r3, r7, #16
    cfde:	4618      	mov	r0, r3
    cfe0:	f002 fa30 	bl	f444 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    cfe4:	f04f 0301 	mov.w	r3, #1
    cfe8:	61bb      	str	r3, [r7, #24]
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    cfea:	f004 fbe5 	bl	117b8 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    cfee:	f001 fcc7 	bl	e980 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    cff2:	f004 fba9 	bl	11748 <vPortEnterCritical>
    cff6:	69fb      	ldr	r3, [r7, #28]
    cff8:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
    cffc:	b2db      	uxtb	r3, r3
    cffe:	b25b      	sxtb	r3, r3
    d000:	f1b3 3fff 	cmp.w	r3, #4294967295
    d004:	d104      	bne.n	d010 <xQueueReceive+0x140>
    d006:	69fb      	ldr	r3, [r7, #28]
    d008:	f04f 0200 	mov.w	r2, #0
    d00c:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    d010:	69fb      	ldr	r3, [r7, #28]
    d012:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
    d016:	b2db      	uxtb	r3, r3
    d018:	b25b      	sxtb	r3, r3
    d01a:	f1b3 3fff 	cmp.w	r3, #4294967295
    d01e:	d104      	bne.n	d02a <xQueueReceive+0x15a>
    d020:	69fb      	ldr	r3, [r7, #28]
    d022:	f04f 0200 	mov.w	r2, #0
    d026:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
    d02a:	f004 fbc5 	bl	117b8 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    d02e:	f107 0210 	add.w	r2, r7, #16
    d032:	f107 0304 	add.w	r3, r7, #4
    d036:	4610      	mov	r0, r2
    d038:	4619      	mov	r1, r3
    d03a:	f002 fa1b 	bl	f474 <xTaskCheckForTimeOut>
    d03e:	4603      	mov	r3, r0
    d040:	2b00      	cmp	r3, #0
    d042:	d128      	bne.n	d096 <xQueueReceive+0x1c6>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    d044:	69f8      	ldr	r0, [r7, #28]
    d046:	f000 fcf9 	bl	da3c <prvIsQueueEmpty>
    d04a:	4603      	mov	r3, r0
    d04c:	2b00      	cmp	r3, #0
    d04e:	d01c      	beq.n	d08a <xQueueReceive+0x1ba>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    d050:	69fb      	ldr	r3, [r7, #28]
    d052:	f103 0224 	add.w	r2, r3, #36	; 0x24
    d056:	687b      	ldr	r3, [r7, #4]
    d058:	4610      	mov	r0, r2
    d05a:	4619      	mov	r1, r3
    d05c:	f002 f84e 	bl	f0fc <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    d060:	69f8      	ldr	r0, [r7, #28]
    d062:	f000 fc95 	bl	d990 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    d066:	f001 fc9d 	bl	e9a4 <xTaskResumeAll>
    d06a:	4603      	mov	r3, r0
    d06c:	2b00      	cmp	r3, #0
    d06e:	f47f af78 	bne.w	cf62 <xQueueReceive+0x92>
				{
					portYIELD_WITHIN_API();
    d072:	f64e 5304 	movw	r3, #60676	; 0xed04
    d076:	f2ce 0300 	movt	r3, #57344	; 0xe000
    d07a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    d07e:	601a      	str	r2, [r3, #0]
    d080:	f3bf 8f4f 	dsb	sy
    d084:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    d088:	e76e      	b.n	cf68 <xQueueReceive+0x98>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    d08a:	69f8      	ldr	r0, [r7, #28]
    d08c:	f000 fc80 	bl	d990 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    d090:	f001 fc88 	bl	e9a4 <xTaskResumeAll>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    d094:	e768      	b.n	cf68 <xQueueReceive+0x98>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    d096:	69f8      	ldr	r0, [r7, #28]
    d098:	f000 fc7a 	bl	d990 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    d09c:	f001 fc82 	bl	e9a4 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    d0a0:	69f8      	ldr	r0, [r7, #28]
    d0a2:	f000 fccb 	bl	da3c <prvIsQueueEmpty>
    d0a6:	4603      	mov	r3, r0
    d0a8:	2b00      	cmp	r3, #0
    d0aa:	f43f af5c 	beq.w	cf66 <xQueueReceive+0x96>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    d0ae:	f04f 0300 	mov.w	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    d0b2:	4618      	mov	r0, r3
    d0b4:	f107 0730 	add.w	r7, r7, #48	; 0x30
    d0b8:	46bd      	mov	sp, r7
    d0ba:	bd80      	pop	{r7, pc}

0000d0bc <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    d0bc:	b580      	push	{r7, lr}
    d0be:	b08e      	sub	sp, #56	; 0x38
    d0c0:	af00      	add	r7, sp, #0
    d0c2:	6078      	str	r0, [r7, #4]
    d0c4:	6039      	str	r1, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE;
    d0c6:	f04f 0300 	mov.w	r3, #0
    d0ca:	617b      	str	r3, [r7, #20]
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    d0cc:	687b      	ldr	r3, [r7, #4]
    d0ce:	61bb      	str	r3, [r7, #24]

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
    d0d0:	f04f 0300 	mov.w	r3, #0
    d0d4:	61fb      	str	r3, [r7, #28]
#endif

	/* Check the queue pointer is not NULL. */
	configASSERT( ( pxQueue ) );
    d0d6:	69bb      	ldr	r3, [r7, #24]
    d0d8:	2b00      	cmp	r3, #0
    d0da:	d109      	bne.n	d0f0 <xQueueSemaphoreTake+0x34>
    d0dc:	f04f 0328 	mov.w	r3, #40	; 0x28
    d0e0:	f383 8811 	msr	BASEPRI, r3
    d0e4:	f3bf 8f6f 	isb	sy
    d0e8:	f3bf 8f4f 	dsb	sy
    d0ec:	62bb      	str	r3, [r7, #40]	; 0x28
    d0ee:	e7fe      	b.n	d0ee <xQueueSemaphoreTake+0x32>

	/* Check this really is a semaphore, in which case the item size will be
	0. */
	configASSERT( pxQueue->uxItemSize == 0 );
    d0f0:	69bb      	ldr	r3, [r7, #24]
    d0f2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    d0f4:	2b00      	cmp	r3, #0
    d0f6:	d009      	beq.n	d10c <xQueueSemaphoreTake+0x50>
    d0f8:	f04f 0328 	mov.w	r3, #40	; 0x28
    d0fc:	f383 8811 	msr	BASEPRI, r3
    d100:	f3bf 8f6f 	isb	sy
    d104:	f3bf 8f4f 	dsb	sy
    d108:	62fb      	str	r3, [r7, #44]	; 0x2c
    d10a:	e7fe      	b.n	d10a <xQueueSemaphoreTake+0x4e>

	/* Cannot block if the scheduler is suspended. */
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    d10c:	f002 fc30 	bl	f970 <xTaskGetSchedulerState>
    d110:	4603      	mov	r3, r0
    d112:	2b00      	cmp	r3, #0
    d114:	d102      	bne.n	d11c <xQueueSemaphoreTake+0x60>
    d116:	683b      	ldr	r3, [r7, #0]
    d118:	2b00      	cmp	r3, #0
    d11a:	d102      	bne.n	d122 <xQueueSemaphoreTake+0x66>
    d11c:	f04f 0301 	mov.w	r3, #1
    d120:	e001      	b.n	d126 <xQueueSemaphoreTake+0x6a>
    d122:	f04f 0300 	mov.w	r3, #0
    d126:	2b00      	cmp	r3, #0
    d128:	d10c      	bne.n	d144 <xQueueSemaphoreTake+0x88>
    d12a:	f04f 0328 	mov.w	r3, #40	; 0x28
    d12e:	f383 8811 	msr	BASEPRI, r3
    d132:	f3bf 8f6f 	isb	sy
    d136:	f3bf 8f4f 	dsb	sy
    d13a:	633b      	str	r3, [r7, #48]	; 0x30
    d13c:	e7fe      	b.n	d13c <xQueueSemaphoreTake+0x80>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    d13e:	bf00      	nop
    d140:	e000      	b.n	d144 <xQueueSemaphoreTake+0x88>
    d142:	bf00      	nop
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    d144:	f004 fb00 	bl	11748 <vPortEnterCritical>
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    d148:	69bb      	ldr	r3, [r7, #24]
    d14a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    d14c:	623b      	str	r3, [r7, #32]

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    d14e:	6a3b      	ldr	r3, [r7, #32]
    d150:	2b00      	cmp	r3, #0
    d152:	d02a      	beq.n	d1aa <xQueueSemaphoreTake+0xee>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    d154:	6a3b      	ldr	r3, [r7, #32]
    d156:	f103 32ff 	add.w	r2, r3, #4294967295
    d15a:	69bb      	ldr	r3, [r7, #24]
    d15c:	639a      	str	r2, [r3, #56]	; 0x38

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    d15e:	69bb      	ldr	r3, [r7, #24]
    d160:	681b      	ldr	r3, [r3, #0]
    d162:	2b00      	cmp	r3, #0
    d164:	d104      	bne.n	d170 <xQueueSemaphoreTake+0xb4>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    d166:	f002 ffdf 	bl	10128 <pvTaskIncrementMutexHeldCount>
    d16a:	4602      	mov	r2, r0
    d16c:	69bb      	ldr	r3, [r7, #24]
    d16e:	609a      	str	r2, [r3, #8]
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    d170:	69bb      	ldr	r3, [r7, #24]
    d172:	691b      	ldr	r3, [r3, #16]
    d174:	2b00      	cmp	r3, #0
    d176:	d013      	beq.n	d1a0 <xQueueSemaphoreTake+0xe4>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    d178:	69bb      	ldr	r3, [r7, #24]
    d17a:	f103 0310 	add.w	r3, r3, #16
    d17e:	4618      	mov	r0, r3
    d180:	f002 f850 	bl	f224 <xTaskRemoveFromEventList>
    d184:	4603      	mov	r3, r0
    d186:	2b00      	cmp	r3, #0
    d188:	d00a      	beq.n	d1a0 <xQueueSemaphoreTake+0xe4>
					{
						queueYIELD_IF_USING_PREEMPTION();
    d18a:	f64e 5304 	movw	r3, #60676	; 0xed04
    d18e:	f2ce 0300 	movt	r3, #57344	; 0xe000
    d192:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    d196:	601a      	str	r2, [r3, #0]
    d198:	f3bf 8f4f 	dsb	sy
    d19c:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    d1a0:	f004 fb0a 	bl	117b8 <vPortExitCritical>
				return pdPASS;
    d1a4:	f04f 0301 	mov.w	r3, #1
    d1a8:	e0a3      	b.n	d2f2 <xQueueSemaphoreTake+0x236>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    d1aa:	683b      	ldr	r3, [r7, #0]
    d1ac:	2b00      	cmp	r3, #0
    d1ae:	d111      	bne.n	d1d4 <xQueueSemaphoreTake+0x118>
					/* For inheritance to have occurred there must have been an
					initial timeout, and an adjusted timeout cannot become 0, as
					if it were 0 the function would have exited. */
					#if( configUSE_MUTEXES == 1 )
					{
						configASSERT( xInheritanceOccurred == pdFALSE );
    d1b0:	69fb      	ldr	r3, [r7, #28]
    d1b2:	2b00      	cmp	r3, #0
    d1b4:	d009      	beq.n	d1ca <xQueueSemaphoreTake+0x10e>
    d1b6:	f04f 0328 	mov.w	r3, #40	; 0x28
    d1ba:	f383 8811 	msr	BASEPRI, r3
    d1be:	f3bf 8f6f 	isb	sy
    d1c2:	f3bf 8f4f 	dsb	sy
    d1c6:	637b      	str	r3, [r7, #52]	; 0x34
    d1c8:	e7fe      	b.n	d1c8 <xQueueSemaphoreTake+0x10c>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    d1ca:	f004 faf5 	bl	117b8 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    d1ce:	f04f 0300 	mov.w	r3, #0
    d1d2:	e08e      	b.n	d2f2 <xQueueSemaphoreTake+0x236>
				}
				else if( xEntryTimeSet == pdFALSE )
    d1d4:	697b      	ldr	r3, [r7, #20]
    d1d6:	2b00      	cmp	r3, #0
    d1d8:	d107      	bne.n	d1ea <xQueueSemaphoreTake+0x12e>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    d1da:	f107 030c 	add.w	r3, r7, #12
    d1de:	4618      	mov	r0, r3
    d1e0:	f002 f930 	bl	f444 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    d1e4:	f04f 0301 	mov.w	r3, #1
    d1e8:	617b      	str	r3, [r7, #20]
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    d1ea:	f004 fae5 	bl	117b8 <vPortExitCritical>

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    d1ee:	f001 fbc7 	bl	e980 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    d1f2:	f004 faa9 	bl	11748 <vPortEnterCritical>
    d1f6:	69bb      	ldr	r3, [r7, #24]
    d1f8:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
    d1fc:	b2db      	uxtb	r3, r3
    d1fe:	b25b      	sxtb	r3, r3
    d200:	f1b3 3fff 	cmp.w	r3, #4294967295
    d204:	d104      	bne.n	d210 <xQueueSemaphoreTake+0x154>
    d206:	69bb      	ldr	r3, [r7, #24]
    d208:	f04f 0200 	mov.w	r2, #0
    d20c:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    d210:	69bb      	ldr	r3, [r7, #24]
    d212:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
    d216:	b2db      	uxtb	r3, r3
    d218:	b25b      	sxtb	r3, r3
    d21a:	f1b3 3fff 	cmp.w	r3, #4294967295
    d21e:	d104      	bne.n	d22a <xQueueSemaphoreTake+0x16e>
    d220:	69bb      	ldr	r3, [r7, #24]
    d222:	f04f 0200 	mov.w	r2, #0
    d226:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
    d22a:	f004 fac5 	bl	117b8 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    d22e:	f107 020c 	add.w	r2, r7, #12
    d232:	463b      	mov	r3, r7
    d234:	4610      	mov	r0, r2
    d236:	4619      	mov	r1, r3
    d238:	f002 f91c 	bl	f474 <xTaskCheckForTimeOut>
    d23c:	4603      	mov	r3, r0
    d23e:	2b00      	cmp	r3, #0
    d240:	d137      	bne.n	d2b2 <xQueueSemaphoreTake+0x1f6>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    d242:	69b8      	ldr	r0, [r7, #24]
    d244:	f000 fbfa 	bl	da3c <prvIsQueueEmpty>
    d248:	4603      	mov	r3, r0
    d24a:	2b00      	cmp	r3, #0
    d24c:	d02b      	beq.n	d2a6 <xQueueSemaphoreTake+0x1ea>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    d24e:	69bb      	ldr	r3, [r7, #24]
    d250:	681b      	ldr	r3, [r3, #0]
    d252:	2b00      	cmp	r3, #0
    d254:	d10a      	bne.n	d26c <xQueueSemaphoreTake+0x1b0>
					{
						taskENTER_CRITICAL();
    d256:	f004 fa77 	bl	11748 <vPortEnterCritical>
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    d25a:	69bb      	ldr	r3, [r7, #24]
    d25c:	689b      	ldr	r3, [r3, #8]
    d25e:	4618      	mov	r0, r3
    d260:	f002 fbaa 	bl	f9b8 <xTaskPriorityInherit>
    d264:	4603      	mov	r3, r0
    d266:	61fb      	str	r3, [r7, #28]
						}
						taskEXIT_CRITICAL();
    d268:	f004 faa6 	bl	117b8 <vPortExitCritical>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    d26c:	69bb      	ldr	r3, [r7, #24]
    d26e:	f103 0224 	add.w	r2, r3, #36	; 0x24
    d272:	683b      	ldr	r3, [r7, #0]
    d274:	4610      	mov	r0, r2
    d276:	4619      	mov	r1, r3
    d278:	f001 ff40 	bl	f0fc <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    d27c:	69b8      	ldr	r0, [r7, #24]
    d27e:	f000 fb87 	bl	d990 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    d282:	f001 fb8f 	bl	e9a4 <xTaskResumeAll>
    d286:	4603      	mov	r3, r0
    d288:	2b00      	cmp	r3, #0
    d28a:	f47f af58 	bne.w	d13e <xQueueSemaphoreTake+0x82>
				{
					portYIELD_WITHIN_API();
    d28e:	f64e 5304 	movw	r3, #60676	; 0xed04
    d292:	f2ce 0300 	movt	r3, #57344	; 0xe000
    d296:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    d29a:	601a      	str	r2, [r3, #0]
    d29c:	f3bf 8f4f 	dsb	sy
    d2a0:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    d2a4:	e74e      	b.n	d144 <xQueueSemaphoreTake+0x88>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    d2a6:	69b8      	ldr	r0, [r7, #24]
    d2a8:	f000 fb72 	bl	d990 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    d2ac:	f001 fb7a 	bl	e9a4 <xTaskResumeAll>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    d2b0:	e748      	b.n	d144 <xQueueSemaphoreTake+0x88>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    d2b2:	69b8      	ldr	r0, [r7, #24]
    d2b4:	f000 fb6c 	bl	d990 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    d2b8:	f001 fb74 	bl	e9a4 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    d2bc:	69b8      	ldr	r0, [r7, #24]
    d2be:	f000 fbbd 	bl	da3c <prvIsQueueEmpty>
    d2c2:	4603      	mov	r3, r0
    d2c4:	2b00      	cmp	r3, #0
    d2c6:	f43f af3c 	beq.w	d142 <xQueueSemaphoreTake+0x86>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
    d2ca:	69fb      	ldr	r3, [r7, #28]
    d2cc:	2b00      	cmp	r3, #0
    d2ce:	d00e      	beq.n	d2ee <xQueueSemaphoreTake+0x232>
					{
						taskENTER_CRITICAL();
    d2d0:	f004 fa3a 	bl	11748 <vPortEnterCritical>
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
    d2d4:	69b8      	ldr	r0, [r7, #24]
    d2d6:	f000 faa1 	bl	d81c <prvGetDisinheritPriorityAfterTimeout>
    d2da:	4603      	mov	r3, r0
    d2dc:	627b      	str	r3, [r7, #36]	; 0x24
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    d2de:	69bb      	ldr	r3, [r7, #24]
    d2e0:	689b      	ldr	r3, [r3, #8]
    d2e2:	4618      	mov	r0, r3
    d2e4:	6a79      	ldr	r1, [r7, #36]	; 0x24
    d2e6:	f002 fcc3 	bl	fc70 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
    d2ea:	f004 fa65 	bl	117b8 <vPortExitCritical>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    d2ee:	f04f 0300 	mov.w	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    d2f2:	4618      	mov	r0, r3
    d2f4:	f107 0738 	add.w	r7, r7, #56	; 0x38
    d2f8:	46bd      	mov	sp, r7
    d2fa:	bd80      	pop	{r7, pc}

0000d2fc <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    d2fc:	b580      	push	{r7, lr}
    d2fe:	b08e      	sub	sp, #56	; 0x38
    d300:	af00      	add	r7, sp, #0
    d302:	60f8      	str	r0, [r7, #12]
    d304:	60b9      	str	r1, [r7, #8]
    d306:	607a      	str	r2, [r7, #4]
BaseType_t xEntryTimeSet = pdFALSE;
    d308:	f04f 0300 	mov.w	r3, #0
    d30c:	61fb      	str	r3, [r7, #28]
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    d30e:	68fb      	ldr	r3, [r7, #12]
    d310:	627b      	str	r3, [r7, #36]	; 0x24

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
    d312:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d314:	2b00      	cmp	r3, #0
    d316:	d109      	bne.n	d32c <xQueuePeek+0x30>
    d318:	f04f 0328 	mov.w	r3, #40	; 0x28
    d31c:	f383 8811 	msr	BASEPRI, r3
    d320:	f3bf 8f6f 	isb	sy
    d324:	f3bf 8f4f 	dsb	sy
    d328:	62fb      	str	r3, [r7, #44]	; 0x2c
    d32a:	e7fe      	b.n	d32a <xQueuePeek+0x2e>

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    d32c:	68bb      	ldr	r3, [r7, #8]
    d32e:	2b00      	cmp	r3, #0
    d330:	d103      	bne.n	d33a <xQueuePeek+0x3e>
    d332:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d334:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    d336:	2b00      	cmp	r3, #0
    d338:	d102      	bne.n	d340 <xQueuePeek+0x44>
    d33a:	f04f 0301 	mov.w	r3, #1
    d33e:	e001      	b.n	d344 <xQueuePeek+0x48>
    d340:	f04f 0300 	mov.w	r3, #0
    d344:	2b00      	cmp	r3, #0
    d346:	d109      	bne.n	d35c <xQueuePeek+0x60>
    d348:	f04f 0328 	mov.w	r3, #40	; 0x28
    d34c:	f383 8811 	msr	BASEPRI, r3
    d350:	f3bf 8f6f 	isb	sy
    d354:	f3bf 8f4f 	dsb	sy
    d358:	633b      	str	r3, [r7, #48]	; 0x30
    d35a:	e7fe      	b.n	d35a <xQueuePeek+0x5e>

	/* Cannot block if the scheduler is suspended. */
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    d35c:	f002 fb08 	bl	f970 <xTaskGetSchedulerState>
    d360:	4603      	mov	r3, r0
    d362:	2b00      	cmp	r3, #0
    d364:	d102      	bne.n	d36c <xQueuePeek+0x70>
    d366:	687b      	ldr	r3, [r7, #4]
    d368:	2b00      	cmp	r3, #0
    d36a:	d102      	bne.n	d372 <xQueuePeek+0x76>
    d36c:	f04f 0301 	mov.w	r3, #1
    d370:	e001      	b.n	d376 <xQueuePeek+0x7a>
    d372:	f04f 0300 	mov.w	r3, #0
    d376:	2b00      	cmp	r3, #0
    d378:	d10c      	bne.n	d394 <xQueuePeek+0x98>
    d37a:	f04f 0328 	mov.w	r3, #40	; 0x28
    d37e:	f383 8811 	msr	BASEPRI, r3
    d382:	f3bf 8f6f 	isb	sy
    d386:	f3bf 8f4f 	dsb	sy
    d38a:	637b      	str	r3, [r7, #52]	; 0x34
    d38c:	e7fe      	b.n	d38c <xQueuePeek+0x90>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    d38e:	bf00      	nop
    d390:	e000      	b.n	d394 <xQueuePeek+0x98>
    d392:	bf00      	nop
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    d394:	f004 f9d8 	bl	11748 <vPortEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    d398:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d39a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    d39c:	62bb      	str	r3, [r7, #40]	; 0x28

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    d39e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    d3a0:	2b00      	cmp	r3, #0
    d3a2:	d026      	beq.n	d3f2 <xQueuePeek+0xf6>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    d3a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d3a6:	68db      	ldr	r3, [r3, #12]
    d3a8:	623b      	str	r3, [r7, #32]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    d3aa:	6a78      	ldr	r0, [r7, #36]	; 0x24
    d3ac:	68b9      	ldr	r1, [r7, #8]
    d3ae:	f000 fac7 	bl	d940 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    d3b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d3b4:	6a3a      	ldr	r2, [r7, #32]
    d3b6:	60da      	str	r2, [r3, #12]

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    d3b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d3ba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    d3bc:	2b00      	cmp	r3, #0
    d3be:	d013      	beq.n	d3e8 <xQueuePeek+0xec>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    d3c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d3c2:	f103 0324 	add.w	r3, r3, #36	; 0x24
    d3c6:	4618      	mov	r0, r3
    d3c8:	f001 ff2c 	bl	f224 <xTaskRemoveFromEventList>
    d3cc:	4603      	mov	r3, r0
    d3ce:	2b00      	cmp	r3, #0
    d3d0:	d00a      	beq.n	d3e8 <xQueuePeek+0xec>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    d3d2:	f64e 5304 	movw	r3, #60676	; 0xed04
    d3d6:	f2ce 0300 	movt	r3, #57344	; 0xe000
    d3da:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    d3de:	601a      	str	r2, [r3, #0]
    d3e0:	f3bf 8f4f 	dsb	sy
    d3e4:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    d3e8:	f004 f9e6 	bl	117b8 <vPortExitCritical>
				return pdPASS;
    d3ec:	f04f 0301 	mov.w	r3, #1
    d3f0:	e076      	b.n	d4e0 <xQueuePeek+0x1e4>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    d3f2:	687b      	ldr	r3, [r7, #4]
    d3f4:	2b00      	cmp	r3, #0
    d3f6:	d104      	bne.n	d402 <xQueuePeek+0x106>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    d3f8:	f004 f9de 	bl	117b8 <vPortExitCritical>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    d3fc:	f04f 0300 	mov.w	r3, #0
    d400:	e06e      	b.n	d4e0 <xQueuePeek+0x1e4>
				}
				else if( xEntryTimeSet == pdFALSE )
    d402:	69fb      	ldr	r3, [r7, #28]
    d404:	2b00      	cmp	r3, #0
    d406:	d107      	bne.n	d418 <xQueuePeek+0x11c>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    d408:	f107 0314 	add.w	r3, r7, #20
    d40c:	4618      	mov	r0, r3
    d40e:	f002 f819 	bl	f444 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    d412:	f04f 0301 	mov.w	r3, #1
    d416:	61fb      	str	r3, [r7, #28]
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    d418:	f004 f9ce 	bl	117b8 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    d41c:	f001 fab0 	bl	e980 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    d420:	f004 f992 	bl	11748 <vPortEnterCritical>
    d424:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d426:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
    d42a:	b2db      	uxtb	r3, r3
    d42c:	b25b      	sxtb	r3, r3
    d42e:	f1b3 3fff 	cmp.w	r3, #4294967295
    d432:	d104      	bne.n	d43e <xQueuePeek+0x142>
    d434:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d436:	f04f 0200 	mov.w	r2, #0
    d43a:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    d43e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d440:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
    d444:	b2db      	uxtb	r3, r3
    d446:	b25b      	sxtb	r3, r3
    d448:	f1b3 3fff 	cmp.w	r3, #4294967295
    d44c:	d104      	bne.n	d458 <xQueuePeek+0x15c>
    d44e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d450:	f04f 0200 	mov.w	r2, #0
    d454:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
    d458:	f004 f9ae 	bl	117b8 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    d45c:	f107 0214 	add.w	r2, r7, #20
    d460:	f107 0304 	add.w	r3, r7, #4
    d464:	4610      	mov	r0, r2
    d466:	4619      	mov	r1, r3
    d468:	f002 f804 	bl	f474 <xTaskCheckForTimeOut>
    d46c:	4603      	mov	r3, r0
    d46e:	2b00      	cmp	r3, #0
    d470:	d128      	bne.n	d4c4 <xQueuePeek+0x1c8>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    d472:	6a78      	ldr	r0, [r7, #36]	; 0x24
    d474:	f000 fae2 	bl	da3c <prvIsQueueEmpty>
    d478:	4603      	mov	r3, r0
    d47a:	2b00      	cmp	r3, #0
    d47c:	d01c      	beq.n	d4b8 <xQueuePeek+0x1bc>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    d47e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d480:	f103 0224 	add.w	r2, r3, #36	; 0x24
    d484:	687b      	ldr	r3, [r7, #4]
    d486:	4610      	mov	r0, r2
    d488:	4619      	mov	r1, r3
    d48a:	f001 fe37 	bl	f0fc <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    d48e:	6a78      	ldr	r0, [r7, #36]	; 0x24
    d490:	f000 fa7e 	bl	d990 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    d494:	f001 fa86 	bl	e9a4 <xTaskResumeAll>
    d498:	4603      	mov	r3, r0
    d49a:	2b00      	cmp	r3, #0
    d49c:	f47f af77 	bne.w	d38e <xQueuePeek+0x92>
				{
					portYIELD_WITHIN_API();
    d4a0:	f64e 5304 	movw	r3, #60676	; 0xed04
    d4a4:	f2ce 0300 	movt	r3, #57344	; 0xe000
    d4a8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    d4ac:	601a      	str	r2, [r3, #0]
    d4ae:	f3bf 8f4f 	dsb	sy
    d4b2:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    d4b6:	e76d      	b.n	d394 <xQueuePeek+0x98>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    d4b8:	6a78      	ldr	r0, [r7, #36]	; 0x24
    d4ba:	f000 fa69 	bl	d990 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    d4be:	f001 fa71 	bl	e9a4 <xTaskResumeAll>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    d4c2:	e767      	b.n	d394 <xQueuePeek+0x98>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    d4c4:	6a78      	ldr	r0, [r7, #36]	; 0x24
    d4c6:	f000 fa63 	bl	d990 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    d4ca:	f001 fa6b 	bl	e9a4 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    d4ce:	6a78      	ldr	r0, [r7, #36]	; 0x24
    d4d0:	f000 fab4 	bl	da3c <prvIsQueueEmpty>
    d4d4:	4603      	mov	r3, r0
    d4d6:	2b00      	cmp	r3, #0
    d4d8:	f43f af5b 	beq.w	d392 <xQueuePeek+0x96>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    d4dc:	f04f 0300 	mov.w	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    d4e0:	4618      	mov	r0, r3
    d4e2:	f107 0738 	add.w	r7, r7, #56	; 0x38
    d4e6:	46bd      	mov	sp, r7
    d4e8:	bd80      	pop	{r7, pc}
    d4ea:	bf00      	nop

0000d4ec <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    d4ec:	b580      	push	{r7, lr}
    d4ee:	b08e      	sub	sp, #56	; 0x38
    d4f0:	af00      	add	r7, sp, #0
    d4f2:	60f8      	str	r0, [r7, #12]
    d4f4:	60b9      	str	r1, [r7, #8]
    d4f6:	607a      	str	r2, [r7, #4]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    d4f8:	68fb      	ldr	r3, [r7, #12]
    d4fa:	61bb      	str	r3, [r7, #24]

	configASSERT( pxQueue );
    d4fc:	69bb      	ldr	r3, [r7, #24]
    d4fe:	2b00      	cmp	r3, #0
    d500:	d109      	bne.n	d516 <xQueueReceiveFromISR+0x2a>
    d502:	f04f 0328 	mov.w	r3, #40	; 0x28
    d506:	f383 8811 	msr	BASEPRI, r3
    d50a:	f3bf 8f6f 	isb	sy
    d50e:	f3bf 8f4f 	dsb	sy
    d512:	627b      	str	r3, [r7, #36]	; 0x24
    d514:	e7fe      	b.n	d514 <xQueueReceiveFromISR+0x28>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    d516:	68bb      	ldr	r3, [r7, #8]
    d518:	2b00      	cmp	r3, #0
    d51a:	d103      	bne.n	d524 <xQueueReceiveFromISR+0x38>
    d51c:	69bb      	ldr	r3, [r7, #24]
    d51e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    d520:	2b00      	cmp	r3, #0
    d522:	d102      	bne.n	d52a <xQueueReceiveFromISR+0x3e>
    d524:	f04f 0301 	mov.w	r3, #1
    d528:	e001      	b.n	d52e <xQueueReceiveFromISR+0x42>
    d52a:	f04f 0300 	mov.w	r3, #0
    d52e:	2b00      	cmp	r3, #0
    d530:	d109      	bne.n	d546 <xQueueReceiveFromISR+0x5a>
    d532:	f04f 0328 	mov.w	r3, #40	; 0x28
    d536:	f383 8811 	msr	BASEPRI, r3
    d53a:	f3bf 8f6f 	isb	sy
    d53e:	f3bf 8f4f 	dsb	sy
    d542:	62bb      	str	r3, [r7, #40]	; 0x28
    d544:	e7fe      	b.n	d544 <xQueueReceiveFromISR+0x58>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    d546:	f004 f9e3 	bl	11910 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
    d54a:	f3ef 8211 	mrs	r2, BASEPRI
    d54e:	f04f 0328 	mov.w	r3, #40	; 0x28
    d552:	f383 8811 	msr	BASEPRI, r3
    d556:	f3bf 8f6f 	isb	sy
    d55a:	f3bf 8f4f 	dsb	sy
    d55e:	633a      	str	r2, [r7, #48]	; 0x30
    d560:	62fb      	str	r3, [r7, #44]	; 0x2c
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
    d562:	6b3b      	ldr	r3, [r7, #48]	; 0x30

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    d564:	617b      	str	r3, [r7, #20]
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    d566:	69bb      	ldr	r3, [r7, #24]
    d568:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    d56a:	61fb      	str	r3, [r7, #28]

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    d56c:	69fb      	ldr	r3, [r7, #28]
    d56e:	2b00      	cmp	r3, #0
    d570:	d03a      	beq.n	d5e8 <xQueueReceiveFromISR+0xfc>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    d572:	69bb      	ldr	r3, [r7, #24]
    d574:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
    d578:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    d57c:	69b8      	ldr	r0, [r7, #24]
    d57e:	68b9      	ldr	r1, [r7, #8]
    d580:	f000 f9de 	bl	d940 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    d584:	69fb      	ldr	r3, [r7, #28]
    d586:	f103 32ff 	add.w	r2, r3, #4294967295
    d58a:	69bb      	ldr	r3, [r7, #24]
    d58c:	639a      	str	r2, [r3, #56]	; 0x38

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    d58e:	f997 3023 	ldrsb.w	r3, [r7, #35]	; 0x23
    d592:	f1b3 3fff 	cmp.w	r3, #4294967295
    d596:	d114      	bne.n	d5c2 <xQueueReceiveFromISR+0xd6>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    d598:	69bb      	ldr	r3, [r7, #24]
    d59a:	691b      	ldr	r3, [r3, #16]
    d59c:	2b00      	cmp	r3, #0
    d59e:	d01a      	beq.n	d5d6 <xQueueReceiveFromISR+0xea>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    d5a0:	69bb      	ldr	r3, [r7, #24]
    d5a2:	f103 0310 	add.w	r3, r3, #16
    d5a6:	4618      	mov	r0, r3
    d5a8:	f001 fe3c 	bl	f224 <xTaskRemoveFromEventList>
    d5ac:	4603      	mov	r3, r0
    d5ae:	2b00      	cmp	r3, #0
    d5b0:	d013      	beq.n	d5da <xQueueReceiveFromISR+0xee>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    d5b2:	687b      	ldr	r3, [r7, #4]
    d5b4:	2b00      	cmp	r3, #0
    d5b6:	d012      	beq.n	d5de <xQueueReceiveFromISR+0xf2>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    d5b8:	687b      	ldr	r3, [r7, #4]
    d5ba:	f04f 0201 	mov.w	r2, #1
    d5be:	601a      	str	r2, [r3, #0]
    d5c0:	e00e      	b.n	d5e0 <xQueueReceiveFromISR+0xf4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    d5c2:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    d5c6:	f103 0301 	add.w	r3, r3, #1
    d5ca:	b2db      	uxtb	r3, r3
    d5cc:	461a      	mov	r2, r3
    d5ce:	69bb      	ldr	r3, [r7, #24]
    d5d0:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    d5d4:	e004      	b.n	d5e0 <xQueueReceiveFromISR+0xf4>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    d5d6:	bf00      	nop
    d5d8:	e002      	b.n	d5e0 <xQueueReceiveFromISR+0xf4>
    d5da:	bf00      	nop
    d5dc:	e000      	b.n	d5e0 <xQueueReceiveFromISR+0xf4>
    d5de:	bf00      	nop
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
			}

			xReturn = pdPASS;
    d5e0:	f04f 0301 	mov.w	r3, #1
    d5e4:	613b      	str	r3, [r7, #16]
    d5e6:	e002      	b.n	d5ee <xQueueReceiveFromISR+0x102>
		}
		else
		{
			xReturn = pdFAIL;
    d5e8:	f04f 0300 	mov.w	r3, #0
    d5ec:	613b      	str	r3, [r7, #16]
    d5ee:	697b      	ldr	r3, [r7, #20]
    d5f0:	637b      	str	r3, [r7, #52]	; 0x34
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
    d5f2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    d5f4:	f383 8811 	msr	BASEPRI, r3
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    d5f8:	693b      	ldr	r3, [r7, #16]
}
    d5fa:	4618      	mov	r0, r3
    d5fc:	f107 0738 	add.w	r7, r7, #56	; 0x38
    d600:	46bd      	mov	sp, r7
    d602:	bd80      	pop	{r7, pc}

0000d604 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    d604:	b580      	push	{r7, lr}
    d606:	b08c      	sub	sp, #48	; 0x30
    d608:	af00      	add	r7, sp, #0
    d60a:	6078      	str	r0, [r7, #4]
    d60c:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    d60e:	687b      	ldr	r3, [r7, #4]
    d610:	617b      	str	r3, [r7, #20]

	configASSERT( pxQueue );
    d612:	697b      	ldr	r3, [r7, #20]
    d614:	2b00      	cmp	r3, #0
    d616:	d109      	bne.n	d62c <xQueuePeekFromISR+0x28>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
    d618:	f04f 0328 	mov.w	r3, #40	; 0x28
    d61c:	f383 8811 	msr	BASEPRI, r3
    d620:	f3bf 8f6f 	isb	sy
    d624:	f3bf 8f4f 	dsb	sy
    d628:	61bb      	str	r3, [r7, #24]
    d62a:	e7fe      	b.n	d62a <xQueuePeekFromISR+0x26>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    d62c:	683b      	ldr	r3, [r7, #0]
    d62e:	2b00      	cmp	r3, #0
    d630:	d103      	bne.n	d63a <xQueuePeekFromISR+0x36>
    d632:	697b      	ldr	r3, [r7, #20]
    d634:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    d636:	2b00      	cmp	r3, #0
    d638:	d102      	bne.n	d640 <xQueuePeekFromISR+0x3c>
    d63a:	f04f 0301 	mov.w	r3, #1
    d63e:	e001      	b.n	d644 <xQueuePeekFromISR+0x40>
    d640:	f04f 0300 	mov.w	r3, #0
    d644:	2b00      	cmp	r3, #0
    d646:	d109      	bne.n	d65c <xQueuePeekFromISR+0x58>
    d648:	f04f 0328 	mov.w	r3, #40	; 0x28
    d64c:	f383 8811 	msr	BASEPRI, r3
    d650:	f3bf 8f6f 	isb	sy
    d654:	f3bf 8f4f 	dsb	sy
    d658:	61fb      	str	r3, [r7, #28]
    d65a:	e7fe      	b.n	d65a <xQueuePeekFromISR+0x56>
	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
    d65c:	697b      	ldr	r3, [r7, #20]
    d65e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    d660:	2b00      	cmp	r3, #0
    d662:	d109      	bne.n	d678 <xQueuePeekFromISR+0x74>
    d664:	f04f 0328 	mov.w	r3, #40	; 0x28
    d668:	f383 8811 	msr	BASEPRI, r3
    d66c:	f3bf 8f6f 	isb	sy
    d670:	f3bf 8f4f 	dsb	sy
    d674:	623b      	str	r3, [r7, #32]
    d676:	e7fe      	b.n	d676 <xQueuePeekFromISR+0x72>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    d678:	f004 f94a 	bl	11910 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
    d67c:	f3ef 8211 	mrs	r2, BASEPRI
    d680:	f04f 0328 	mov.w	r3, #40	; 0x28
    d684:	f383 8811 	msr	BASEPRI, r3
    d688:	f3bf 8f6f 	isb	sy
    d68c:	f3bf 8f4f 	dsb	sy
    d690:	62ba      	str	r2, [r7, #40]	; 0x28
    d692:	627b      	str	r3, [r7, #36]	; 0x24
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
    d694:	6abb      	ldr	r3, [r7, #40]	; 0x28

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    d696:	60fb      	str	r3, [r7, #12]
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    d698:	697b      	ldr	r3, [r7, #20]
    d69a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    d69c:	2b00      	cmp	r3, #0
    d69e:	d00d      	beq.n	d6bc <xQueuePeekFromISR+0xb8>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    d6a0:	697b      	ldr	r3, [r7, #20]
    d6a2:	68db      	ldr	r3, [r3, #12]
    d6a4:	613b      	str	r3, [r7, #16]
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    d6a6:	6978      	ldr	r0, [r7, #20]
    d6a8:	6839      	ldr	r1, [r7, #0]
    d6aa:	f000 f949 	bl	d940 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    d6ae:	697b      	ldr	r3, [r7, #20]
    d6b0:	693a      	ldr	r2, [r7, #16]
    d6b2:	60da      	str	r2, [r3, #12]

			xReturn = pdPASS;
    d6b4:	f04f 0301 	mov.w	r3, #1
    d6b8:	60bb      	str	r3, [r7, #8]
    d6ba:	e002      	b.n	d6c2 <xQueuePeekFromISR+0xbe>
		}
		else
		{
			xReturn = pdFAIL;
    d6bc:	f04f 0300 	mov.w	r3, #0
    d6c0:	60bb      	str	r3, [r7, #8]
    d6c2:	68fb      	ldr	r3, [r7, #12]
    d6c4:	62fb      	str	r3, [r7, #44]	; 0x2c
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
    d6c6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    d6c8:	f383 8811 	msr	BASEPRI, r3
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    d6cc:	68bb      	ldr	r3, [r7, #8]
}
    d6ce:	4618      	mov	r0, r3
    d6d0:	f107 0730 	add.w	r7, r7, #48	; 0x30
    d6d4:	46bd      	mov	sp, r7
    d6d6:	bd80      	pop	{r7, pc}

0000d6d8 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    d6d8:	b580      	push	{r7, lr}
    d6da:	b084      	sub	sp, #16
    d6dc:	af00      	add	r7, sp, #0
    d6de:	6078      	str	r0, [r7, #4]
UBaseType_t uxReturn;

	configASSERT( xQueue );
    d6e0:	687b      	ldr	r3, [r7, #4]
    d6e2:	2b00      	cmp	r3, #0
    d6e4:	d109      	bne.n	d6fa <uxQueueMessagesWaiting+0x22>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
    d6e6:	f04f 0328 	mov.w	r3, #40	; 0x28
    d6ea:	f383 8811 	msr	BASEPRI, r3
    d6ee:	f3bf 8f6f 	isb	sy
    d6f2:	f3bf 8f4f 	dsb	sy
    d6f6:	60fb      	str	r3, [r7, #12]
    d6f8:	e7fe      	b.n	d6f8 <uxQueueMessagesWaiting+0x20>

	taskENTER_CRITICAL();
    d6fa:	f004 f825 	bl	11748 <vPortEnterCritical>
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    d6fe:	687b      	ldr	r3, [r7, #4]
    d700:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    d702:	60bb      	str	r3, [r7, #8]
	}
	taskEXIT_CRITICAL();
    d704:	f004 f858 	bl	117b8 <vPortExitCritical>

	return uxReturn;
    d708:	68bb      	ldr	r3, [r7, #8]
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    d70a:	4618      	mov	r0, r3
    d70c:	f107 0710 	add.w	r7, r7, #16
    d710:	46bd      	mov	sp, r7
    d712:	bd80      	pop	{r7, pc}

0000d714 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    d714:	b580      	push	{r7, lr}
    d716:	b086      	sub	sp, #24
    d718:	af00      	add	r7, sp, #0
    d71a:	6078      	str	r0, [r7, #4]
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    d71c:	687b      	ldr	r3, [r7, #4]
    d71e:	613b      	str	r3, [r7, #16]

	configASSERT( pxQueue );
    d720:	693b      	ldr	r3, [r7, #16]
    d722:	2b00      	cmp	r3, #0
    d724:	d109      	bne.n	d73a <uxQueueSpacesAvailable+0x26>
    d726:	f04f 0328 	mov.w	r3, #40	; 0x28
    d72a:	f383 8811 	msr	BASEPRI, r3
    d72e:	f3bf 8f6f 	isb	sy
    d732:	f3bf 8f4f 	dsb	sy
    d736:	617b      	str	r3, [r7, #20]
    d738:	e7fe      	b.n	d738 <uxQueueSpacesAvailable+0x24>

	taskENTER_CRITICAL();
    d73a:	f004 f805 	bl	11748 <vPortEnterCritical>
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    d73e:	693b      	ldr	r3, [r7, #16]
    d740:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    d742:	693b      	ldr	r3, [r7, #16]
    d744:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    d746:	ebc3 0302 	rsb	r3, r3, r2
    d74a:	60fb      	str	r3, [r7, #12]
	}
	taskEXIT_CRITICAL();
    d74c:	f004 f834 	bl	117b8 <vPortExitCritical>

	return uxReturn;
    d750:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    d752:	4618      	mov	r0, r3
    d754:	f107 0718 	add.w	r7, r7, #24
    d758:	46bd      	mov	sp, r7
    d75a:	bd80      	pop	{r7, pc}

0000d75c <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    d75c:	b480      	push	{r7}
    d75e:	b087      	sub	sp, #28
    d760:	af00      	add	r7, sp, #0
    d762:	6078      	str	r0, [r7, #4]
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    d764:	687b      	ldr	r3, [r7, #4]
    d766:	613b      	str	r3, [r7, #16]

	configASSERT( pxQueue );
    d768:	693b      	ldr	r3, [r7, #16]
    d76a:	2b00      	cmp	r3, #0
    d76c:	d109      	bne.n	d782 <uxQueueMessagesWaitingFromISR+0x26>
    d76e:	f04f 0328 	mov.w	r3, #40	; 0x28
    d772:	f383 8811 	msr	BASEPRI, r3
    d776:	f3bf 8f6f 	isb	sy
    d77a:	f3bf 8f4f 	dsb	sy
    d77e:	617b      	str	r3, [r7, #20]
    d780:	e7fe      	b.n	d780 <uxQueueMessagesWaitingFromISR+0x24>
	uxReturn = pxQueue->uxMessagesWaiting;
    d782:	693b      	ldr	r3, [r7, #16]
    d784:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    d786:	60fb      	str	r3, [r7, #12]

	return uxReturn;
    d788:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    d78a:	4618      	mov	r0, r3
    d78c:	f107 071c 	add.w	r7, r7, #28
    d790:	46bd      	mov	sp, r7
    d792:	bc80      	pop	{r7}
    d794:	4770      	bx	lr
    d796:	bf00      	nop

0000d798 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    d798:	b580      	push	{r7, lr}
    d79a:	b084      	sub	sp, #16
    d79c:	af00      	add	r7, sp, #0
    d79e:	6078      	str	r0, [r7, #4]
Queue_t * const pxQueue = xQueue;
    d7a0:	687b      	ldr	r3, [r7, #4]
    d7a2:	60bb      	str	r3, [r7, #8]

	configASSERT( pxQueue );
    d7a4:	68bb      	ldr	r3, [r7, #8]
    d7a6:	2b00      	cmp	r3, #0
    d7a8:	d109      	bne.n	d7be <vQueueDelete+0x26>
    d7aa:	f04f 0328 	mov.w	r3, #40	; 0x28
    d7ae:	f383 8811 	msr	BASEPRI, r3
    d7b2:	f3bf 8f6f 	isb	sy
    d7b6:	f3bf 8f4f 	dsb	sy
    d7ba:	60fb      	str	r3, [r7, #12]
    d7bc:	e7fe      	b.n	d7bc <vQueueDelete+0x24>

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    d7be:	68b8      	ldr	r0, [r7, #8]
    d7c0:	f003 fdf8 	bl	113b4 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    d7c4:	f107 0710 	add.w	r7, r7, #16
    d7c8:	46bd      	mov	sp, r7
    d7ca:	bd80      	pop	{r7, pc}

0000d7cc <uxQueueGetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
	{
    d7cc:	b480      	push	{r7}
    d7ce:	b083      	sub	sp, #12
    d7d0:	af00      	add	r7, sp, #0
    d7d2:	6078      	str	r0, [r7, #4]
		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
    d7d4:	687b      	ldr	r3, [r7, #4]
    d7d6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
	}
    d7d8:	4618      	mov	r0, r3
    d7da:	f107 070c 	add.w	r7, r7, #12
    d7de:	46bd      	mov	sp, r7
    d7e0:	bc80      	pop	{r7}
    d7e2:	4770      	bx	lr

0000d7e4 <vQueueSetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
	{
    d7e4:	b480      	push	{r7}
    d7e6:	b083      	sub	sp, #12
    d7e8:	af00      	add	r7, sp, #0
    d7ea:	6078      	str	r0, [r7, #4]
    d7ec:	6039      	str	r1, [r7, #0]
		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
    d7ee:	687b      	ldr	r3, [r7, #4]
    d7f0:	683a      	ldr	r2, [r7, #0]
    d7f2:	649a      	str	r2, [r3, #72]	; 0x48
	}
    d7f4:	f107 070c 	add.w	r7, r7, #12
    d7f8:	46bd      	mov	sp, r7
    d7fa:	bc80      	pop	{r7}
    d7fc:	4770      	bx	lr
    d7fe:	bf00      	nop

0000d800 <ucQueueGetQueueType>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
	{
    d800:	b480      	push	{r7}
    d802:	b083      	sub	sp, #12
    d804:	af00      	add	r7, sp, #0
    d806:	6078      	str	r0, [r7, #4]
		return ( ( Queue_t * ) xQueue )->ucQueueType;
    d808:	687b      	ldr	r3, [r7, #4]
    d80a:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
	}
    d80e:	4618      	mov	r0, r3
    d810:	f107 070c 	add.w	r7, r7, #12
    d814:	46bd      	mov	sp, r7
    d816:	bc80      	pop	{r7}
    d818:	4770      	bx	lr
    d81a:	bf00      	nop

0000d81c <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
    d81c:	b480      	push	{r7}
    d81e:	b085      	sub	sp, #20
    d820:	af00      	add	r7, sp, #0
    d822:	6078      	str	r0, [r7, #4]
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
    d824:	687b      	ldr	r3, [r7, #4]
    d826:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    d828:	2b00      	cmp	r3, #0
    d82a:	d006      	beq.n	d83a <prvGetDisinheritPriorityAfterTimeout+0x1e>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    d82c:	687b      	ldr	r3, [r7, #4]
    d82e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    d830:	681b      	ldr	r3, [r3, #0]
    d832:	f1c3 0305 	rsb	r3, r3, #5
    d836:	60fb      	str	r3, [r7, #12]
    d838:	e002      	b.n	d840 <prvGetDisinheritPriorityAfterTimeout+0x24>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    d83a:	f04f 0300 	mov.w	r3, #0
    d83e:	60fb      	str	r3, [r7, #12]
		}

		return uxHighestPriorityOfWaitingTasks;
    d840:	68fb      	ldr	r3, [r7, #12]
	}
    d842:	4618      	mov	r0, r3
    d844:	f107 0714 	add.w	r7, r7, #20
    d848:	46bd      	mov	sp, r7
    d84a:	bc80      	pop	{r7}
    d84c:	4770      	bx	lr
    d84e:	bf00      	nop

0000d850 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    d850:	b580      	push	{r7, lr}
    d852:	b086      	sub	sp, #24
    d854:	af00      	add	r7, sp, #0
    d856:	60f8      	str	r0, [r7, #12]
    d858:	60b9      	str	r1, [r7, #8]
    d85a:	607a      	str	r2, [r7, #4]
BaseType_t xReturn = pdFALSE;
    d85c:	f04f 0300 	mov.w	r3, #0
    d860:	613b      	str	r3, [r7, #16]
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    d862:	68fb      	ldr	r3, [r7, #12]
    d864:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    d866:	617b      	str	r3, [r7, #20]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    d868:	68fb      	ldr	r3, [r7, #12]
    d86a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    d86c:	2b00      	cmp	r3, #0
    d86e:	d10f      	bne.n	d890 <prvCopyDataToQueue+0x40>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    d870:	68fb      	ldr	r3, [r7, #12]
    d872:	681b      	ldr	r3, [r3, #0]
    d874:	2b00      	cmp	r3, #0
    d876:	d155      	bne.n	d924 <prvCopyDataToQueue+0xd4>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    d878:	68fb      	ldr	r3, [r7, #12]
    d87a:	689b      	ldr	r3, [r3, #8]
    d87c:	4618      	mov	r0, r3
    d87e:	f002 f951 	bl	fb24 <xTaskPriorityDisinherit>
    d882:	4603      	mov	r3, r0
    d884:	613b      	str	r3, [r7, #16]
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
    d886:	68fb      	ldr	r3, [r7, #12]
    d888:	f04f 0200 	mov.w	r2, #0
    d88c:	609a      	str	r2, [r3, #8]
    d88e:	e04c      	b.n	d92a <prvCopyDataToQueue+0xda>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    d890:	687b      	ldr	r3, [r7, #4]
    d892:	2b00      	cmp	r3, #0
    d894:	d11a      	bne.n	d8cc <prvCopyDataToQueue+0x7c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    d896:	68fb      	ldr	r3, [r7, #12]
    d898:	685a      	ldr	r2, [r3, #4]
    d89a:	68fb      	ldr	r3, [r7, #12]
    d89c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    d89e:	4610      	mov	r0, r2
    d8a0:	68b9      	ldr	r1, [r7, #8]
    d8a2:	461a      	mov	r2, r3
    d8a4:	f004 f8a6 	bl	119f4 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    d8a8:	68fb      	ldr	r3, [r7, #12]
    d8aa:	685a      	ldr	r2, [r3, #4]
    d8ac:	68fb      	ldr	r3, [r7, #12]
    d8ae:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    d8b0:	441a      	add	r2, r3
    d8b2:	68fb      	ldr	r3, [r7, #12]
    d8b4:	605a      	str	r2, [r3, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    d8b6:	68fb      	ldr	r3, [r7, #12]
    d8b8:	685a      	ldr	r2, [r3, #4]
    d8ba:	68fb      	ldr	r3, [r7, #12]
    d8bc:	689b      	ldr	r3, [r3, #8]
    d8be:	429a      	cmp	r2, r3
    d8c0:	d332      	bcc.n	d928 <prvCopyDataToQueue+0xd8>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    d8c2:	68fb      	ldr	r3, [r7, #12]
    d8c4:	681a      	ldr	r2, [r3, #0]
    d8c6:	68fb      	ldr	r3, [r7, #12]
    d8c8:	605a      	str	r2, [r3, #4]
    d8ca:	e02e      	b.n	d92a <prvCopyDataToQueue+0xda>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    d8cc:	68fb      	ldr	r3, [r7, #12]
    d8ce:	68da      	ldr	r2, [r3, #12]
    d8d0:	68fb      	ldr	r3, [r7, #12]
    d8d2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    d8d4:	4610      	mov	r0, r2
    d8d6:	68b9      	ldr	r1, [r7, #8]
    d8d8:	461a      	mov	r2, r3
    d8da:	f004 f88b 	bl	119f4 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    d8de:	68fb      	ldr	r3, [r7, #12]
    d8e0:	68da      	ldr	r2, [r3, #12]
    d8e2:	68fb      	ldr	r3, [r7, #12]
    d8e4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    d8e6:	f1c3 0300 	rsb	r3, r3, #0
    d8ea:	441a      	add	r2, r3
    d8ec:	68fb      	ldr	r3, [r7, #12]
    d8ee:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    d8f0:	68fb      	ldr	r3, [r7, #12]
    d8f2:	68da      	ldr	r2, [r3, #12]
    d8f4:	68fb      	ldr	r3, [r7, #12]
    d8f6:	681b      	ldr	r3, [r3, #0]
    d8f8:	429a      	cmp	r2, r3
    d8fa:	d208      	bcs.n	d90e <prvCopyDataToQueue+0xbe>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    d8fc:	68fb      	ldr	r3, [r7, #12]
    d8fe:	689a      	ldr	r2, [r3, #8]
    d900:	68fb      	ldr	r3, [r7, #12]
    d902:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    d904:	f1c3 0300 	rsb	r3, r3, #0
    d908:	441a      	add	r2, r3
    d90a:	68fb      	ldr	r3, [r7, #12]
    d90c:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    d90e:	687b      	ldr	r3, [r7, #4]
    d910:	2b02      	cmp	r3, #2
    d912:	d10a      	bne.n	d92a <prvCopyDataToQueue+0xda>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    d914:	697b      	ldr	r3, [r7, #20]
    d916:	2b00      	cmp	r3, #0
    d918:	d007      	beq.n	d92a <prvCopyDataToQueue+0xda>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    d91a:	697b      	ldr	r3, [r7, #20]
    d91c:	f103 33ff 	add.w	r3, r3, #4294967295
    d920:	617b      	str	r3, [r7, #20]
    d922:	e002      	b.n	d92a <prvCopyDataToQueue+0xda>
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
    d924:	bf00      	nop
    d926:	e000      	b.n	d92a <prvCopyDataToQueue+0xda>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    d928:	bf00      	nop
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    d92a:	697b      	ldr	r3, [r7, #20]
    d92c:	f103 0201 	add.w	r2, r3, #1
    d930:	68fb      	ldr	r3, [r7, #12]
    d932:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
    d934:	693b      	ldr	r3, [r7, #16]
}
    d936:	4618      	mov	r0, r3
    d938:	f107 0718 	add.w	r7, r7, #24
    d93c:	46bd      	mov	sp, r7
    d93e:	bd80      	pop	{r7, pc}

0000d940 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    d940:	b580      	push	{r7, lr}
    d942:	b082      	sub	sp, #8
    d944:	af00      	add	r7, sp, #0
    d946:	6078      	str	r0, [r7, #4]
    d948:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    d94a:	687b      	ldr	r3, [r7, #4]
    d94c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    d94e:	2b00      	cmp	r3, #0
    d950:	d019      	beq.n	d986 <prvCopyDataFromQueue+0x46>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    d952:	687b      	ldr	r3, [r7, #4]
    d954:	68da      	ldr	r2, [r3, #12]
    d956:	687b      	ldr	r3, [r7, #4]
    d958:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    d95a:	441a      	add	r2, r3
    d95c:	687b      	ldr	r3, [r7, #4]
    d95e:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    d960:	687b      	ldr	r3, [r7, #4]
    d962:	68da      	ldr	r2, [r3, #12]
    d964:	687b      	ldr	r3, [r7, #4]
    d966:	689b      	ldr	r3, [r3, #8]
    d968:	429a      	cmp	r2, r3
    d96a:	d303      	bcc.n	d974 <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    d96c:	687b      	ldr	r3, [r7, #4]
    d96e:	681a      	ldr	r2, [r3, #0]
    d970:	687b      	ldr	r3, [r7, #4]
    d972:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    d974:	687b      	ldr	r3, [r7, #4]
    d976:	68da      	ldr	r2, [r3, #12]
    d978:	687b      	ldr	r3, [r7, #4]
    d97a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    d97c:	6838      	ldr	r0, [r7, #0]
    d97e:	4611      	mov	r1, r2
    d980:	461a      	mov	r2, r3
    d982:	f004 f837 	bl	119f4 <memcpy>
	}
}
    d986:	f107 0708 	add.w	r7, r7, #8
    d98a:	46bd      	mov	sp, r7
    d98c:	bd80      	pop	{r7, pc}
    d98e:	bf00      	nop

0000d990 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    d990:	b580      	push	{r7, lr}
    d992:	b084      	sub	sp, #16
    d994:	af00      	add	r7, sp, #0
    d996:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    d998:	f003 fed6 	bl	11748 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
    d99c:	687b      	ldr	r3, [r7, #4]
    d99e:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
    d9a2:	73bb      	strb	r3, [r7, #14]

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    d9a4:	e012      	b.n	d9cc <prvUnlockQueue+0x3c>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    d9a6:	687b      	ldr	r3, [r7, #4]
    d9a8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    d9aa:	2b00      	cmp	r3, #0
    d9ac:	d013      	beq.n	d9d6 <prvUnlockQueue+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    d9ae:	687b      	ldr	r3, [r7, #4]
    d9b0:	f103 0324 	add.w	r3, r3, #36	; 0x24
    d9b4:	4618      	mov	r0, r3
    d9b6:	f001 fc35 	bl	f224 <xTaskRemoveFromEventList>
    d9ba:	4603      	mov	r3, r0
    d9bc:	2b00      	cmp	r3, #0
    d9be:	d001      	beq.n	d9c4 <prvUnlockQueue+0x34>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    d9c0:	f001 fdc2 	bl	f548 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    d9c4:	7bbb      	ldrb	r3, [r7, #14]
    d9c6:	f103 33ff 	add.w	r3, r3, #4294967295
    d9ca:	73bb      	strb	r3, [r7, #14]
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    d9cc:	f997 300e 	ldrsb.w	r3, [r7, #14]
    d9d0:	2b00      	cmp	r3, #0
    d9d2:	dce8      	bgt.n	d9a6 <prvUnlockQueue+0x16>
    d9d4:	e000      	b.n	d9d8 <prvUnlockQueue+0x48>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
    d9d6:	bf00      	nop
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    d9d8:	687b      	ldr	r3, [r7, #4]
    d9da:	f04f 32ff 	mov.w	r2, #4294967295
    d9de:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
    d9e2:	f003 fee9 	bl	117b8 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    d9e6:	f003 feaf 	bl	11748 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
    d9ea:	687b      	ldr	r3, [r7, #4]
    d9ec:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
    d9f0:	73fb      	strb	r3, [r7, #15]

		while( cRxLock > queueLOCKED_UNMODIFIED )
    d9f2:	e012      	b.n	da1a <prvUnlockQueue+0x8a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    d9f4:	687b      	ldr	r3, [r7, #4]
    d9f6:	691b      	ldr	r3, [r3, #16]
    d9f8:	2b00      	cmp	r3, #0
    d9fa:	d013      	beq.n	da24 <prvUnlockQueue+0x94>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    d9fc:	687b      	ldr	r3, [r7, #4]
    d9fe:	f103 0310 	add.w	r3, r3, #16
    da02:	4618      	mov	r0, r3
    da04:	f001 fc0e 	bl	f224 <xTaskRemoveFromEventList>
    da08:	4603      	mov	r3, r0
    da0a:	2b00      	cmp	r3, #0
    da0c:	d001      	beq.n	da12 <prvUnlockQueue+0x82>
				{
					vTaskMissedYield();
    da0e:	f001 fd9b 	bl	f548 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    da12:	7bfb      	ldrb	r3, [r7, #15]
    da14:	f103 33ff 	add.w	r3, r3, #4294967295
    da18:	73fb      	strb	r3, [r7, #15]
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    da1a:	f997 300f 	ldrsb.w	r3, [r7, #15]
    da1e:	2b00      	cmp	r3, #0
    da20:	dce8      	bgt.n	d9f4 <prvUnlockQueue+0x64>
    da22:	e000      	b.n	da26 <prvUnlockQueue+0x96>

				--cRxLock;
			}
			else
			{
				break;
    da24:	bf00      	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    da26:	687b      	ldr	r3, [r7, #4]
    da28:	f04f 32ff 	mov.w	r2, #4294967295
    da2c:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
    da30:	f003 fec2 	bl	117b8 <vPortExitCritical>
}
    da34:	f107 0710 	add.w	r7, r7, #16
    da38:	46bd      	mov	sp, r7
    da3a:	bd80      	pop	{r7, pc}

0000da3c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    da3c:	b580      	push	{r7, lr}
    da3e:	b084      	sub	sp, #16
    da40:	af00      	add	r7, sp, #0
    da42:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
    da44:	f003 fe80 	bl	11748 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    da48:	687b      	ldr	r3, [r7, #4]
    da4a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    da4c:	2b00      	cmp	r3, #0
    da4e:	d103      	bne.n	da58 <prvIsQueueEmpty+0x1c>
		{
			xReturn = pdTRUE;
    da50:	f04f 0301 	mov.w	r3, #1
    da54:	60fb      	str	r3, [r7, #12]
    da56:	e002      	b.n	da5e <prvIsQueueEmpty+0x22>
		}
		else
		{
			xReturn = pdFALSE;
    da58:	f04f 0300 	mov.w	r3, #0
    da5c:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
    da5e:	f003 feab 	bl	117b8 <vPortExitCritical>

	return xReturn;
    da62:	68fb      	ldr	r3, [r7, #12]
}
    da64:	4618      	mov	r0, r3
    da66:	f107 0710 	add.w	r7, r7, #16
    da6a:	46bd      	mov	sp, r7
    da6c:	bd80      	pop	{r7, pc}
    da6e:	bf00      	nop

0000da70 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    da70:	b480      	push	{r7}
    da72:	b087      	sub	sp, #28
    da74:	af00      	add	r7, sp, #0
    da76:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    da78:	687b      	ldr	r3, [r7, #4]
    da7a:	613b      	str	r3, [r7, #16]

	configASSERT( pxQueue );
    da7c:	693b      	ldr	r3, [r7, #16]
    da7e:	2b00      	cmp	r3, #0
    da80:	d109      	bne.n	da96 <xQueueIsQueueEmptyFromISR+0x26>
    da82:	f04f 0328 	mov.w	r3, #40	; 0x28
    da86:	f383 8811 	msr	BASEPRI, r3
    da8a:	f3bf 8f6f 	isb	sy
    da8e:	f3bf 8f4f 	dsb	sy
    da92:	617b      	str	r3, [r7, #20]
    da94:	e7fe      	b.n	da94 <xQueueIsQueueEmptyFromISR+0x24>
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    da96:	693b      	ldr	r3, [r7, #16]
    da98:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    da9a:	2b00      	cmp	r3, #0
    da9c:	d103      	bne.n	daa6 <xQueueIsQueueEmptyFromISR+0x36>
	{
		xReturn = pdTRUE;
    da9e:	f04f 0301 	mov.w	r3, #1
    daa2:	60fb      	str	r3, [r7, #12]
    daa4:	e002      	b.n	daac <xQueueIsQueueEmptyFromISR+0x3c>
	}
	else
	{
		xReturn = pdFALSE;
    daa6:	f04f 0300 	mov.w	r3, #0
    daaa:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
    daac:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    daae:	4618      	mov	r0, r3
    dab0:	f107 071c 	add.w	r7, r7, #28
    dab4:	46bd      	mov	sp, r7
    dab6:	bc80      	pop	{r7}
    dab8:	4770      	bx	lr
    daba:	bf00      	nop

0000dabc <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    dabc:	b580      	push	{r7, lr}
    dabe:	b084      	sub	sp, #16
    dac0:	af00      	add	r7, sp, #0
    dac2:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
    dac4:	f003 fe40 	bl	11748 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    dac8:	687b      	ldr	r3, [r7, #4]
    daca:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    dacc:	687b      	ldr	r3, [r7, #4]
    dace:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    dad0:	429a      	cmp	r2, r3
    dad2:	d103      	bne.n	dadc <prvIsQueueFull+0x20>
		{
			xReturn = pdTRUE;
    dad4:	f04f 0301 	mov.w	r3, #1
    dad8:	60fb      	str	r3, [r7, #12]
    dada:	e002      	b.n	dae2 <prvIsQueueFull+0x26>
		}
		else
		{
			xReturn = pdFALSE;
    dadc:	f04f 0300 	mov.w	r3, #0
    dae0:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
    dae2:	f003 fe69 	bl	117b8 <vPortExitCritical>

	return xReturn;
    dae6:	68fb      	ldr	r3, [r7, #12]
}
    dae8:	4618      	mov	r0, r3
    daea:	f107 0710 	add.w	r7, r7, #16
    daee:	46bd      	mov	sp, r7
    daf0:	bd80      	pop	{r7, pc}
    daf2:	bf00      	nop

0000daf4 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    daf4:	b480      	push	{r7}
    daf6:	b087      	sub	sp, #28
    daf8:	af00      	add	r7, sp, #0
    dafa:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    dafc:	687b      	ldr	r3, [r7, #4]
    dafe:	613b      	str	r3, [r7, #16]

	configASSERT( pxQueue );
    db00:	693b      	ldr	r3, [r7, #16]
    db02:	2b00      	cmp	r3, #0
    db04:	d109      	bne.n	db1a <xQueueIsQueueFullFromISR+0x26>
    db06:	f04f 0328 	mov.w	r3, #40	; 0x28
    db0a:	f383 8811 	msr	BASEPRI, r3
    db0e:	f3bf 8f6f 	isb	sy
    db12:	f3bf 8f4f 	dsb	sy
    db16:	617b      	str	r3, [r7, #20]
    db18:	e7fe      	b.n	db18 <xQueueIsQueueFullFromISR+0x24>
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    db1a:	693b      	ldr	r3, [r7, #16]
    db1c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    db1e:	693b      	ldr	r3, [r7, #16]
    db20:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    db22:	429a      	cmp	r2, r3
    db24:	d103      	bne.n	db2e <xQueueIsQueueFullFromISR+0x3a>
	{
		xReturn = pdTRUE;
    db26:	f04f 0301 	mov.w	r3, #1
    db2a:	60fb      	str	r3, [r7, #12]
    db2c:	e002      	b.n	db34 <xQueueIsQueueFullFromISR+0x40>
	}
	else
	{
		xReturn = pdFALSE;
    db2e:	f04f 0300 	mov.w	r3, #0
    db32:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
    db34:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    db36:	4618      	mov	r0, r3
    db38:	f107 071c 	add.w	r7, r7, #28
    db3c:	46bd      	mov	sp, r7
    db3e:	bc80      	pop	{r7}
    db40:	4770      	bx	lr
    db42:	bf00      	nop

0000db44 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    db44:	b580      	push	{r7, lr}
    db46:	b086      	sub	sp, #24
    db48:	af00      	add	r7, sp, #0
    db4a:	60f8      	str	r0, [r7, #12]
    db4c:	60b9      	str	r1, [r7, #8]
    db4e:	607a      	str	r2, [r7, #4]
	Queue_t * const pxQueue = xQueue;
    db50:	68fb      	ldr	r3, [r7, #12]
    db52:	617b      	str	r3, [r7, #20]
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    db54:	f003 fdf8 	bl	11748 <vPortEnterCritical>
    db58:	697b      	ldr	r3, [r7, #20]
    db5a:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
    db5e:	b2db      	uxtb	r3, r3
    db60:	b25b      	sxtb	r3, r3
    db62:	f1b3 3fff 	cmp.w	r3, #4294967295
    db66:	d104      	bne.n	db72 <vQueueWaitForMessageRestricted+0x2e>
    db68:	697b      	ldr	r3, [r7, #20]
    db6a:	f04f 0200 	mov.w	r2, #0
    db6e:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    db72:	697b      	ldr	r3, [r7, #20]
    db74:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
    db78:	b2db      	uxtb	r3, r3
    db7a:	b25b      	sxtb	r3, r3
    db7c:	f1b3 3fff 	cmp.w	r3, #4294967295
    db80:	d104      	bne.n	db8c <vQueueWaitForMessageRestricted+0x48>
    db82:	697b      	ldr	r3, [r7, #20]
    db84:	f04f 0200 	mov.w	r2, #0
    db88:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
    db8c:	f003 fe14 	bl	117b8 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    db90:	697b      	ldr	r3, [r7, #20]
    db92:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    db94:	2b00      	cmp	r3, #0
    db96:	d107      	bne.n	dba8 <vQueueWaitForMessageRestricted+0x64>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    db98:	697b      	ldr	r3, [r7, #20]
    db9a:	f103 0324 	add.w	r3, r3, #36	; 0x24
    db9e:	4618      	mov	r0, r3
    dba0:	68b9      	ldr	r1, [r7, #8]
    dba2:	687a      	ldr	r2, [r7, #4]
    dba4:	f001 fb12 	bl	f1cc <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    dba8:	6978      	ldr	r0, [r7, #20]
    dbaa:	f7ff fef1 	bl	d990 <prvUnlockQueue>
	}
    dbae:	f107 0718 	add.w	r7, r7, #24
    dbb2:	46bd      	mov	sp, r7
    dbb4:	bd80      	pop	{r7, pc}
    dbb6:	bf00      	nop

0000dbb8 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    dbb8:	b580      	push	{r7, lr}
    dbba:	b08c      	sub	sp, #48	; 0x30
    dbbc:	af04      	add	r7, sp, #16
    dbbe:	60f8      	str	r0, [r7, #12]
    dbc0:	60b9      	str	r1, [r7, #8]
    dbc2:	603b      	str	r3, [r7, #0]
    dbc4:	4613      	mov	r3, r2
    dbc6:	80fb      	strh	r3, [r7, #6]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    dbc8:	88fb      	ldrh	r3, [r7, #6]
    dbca:	ea4f 0383 	mov.w	r3, r3, lsl #2
    dbce:	4618      	mov	r0, r3
    dbd0:	f003 fb3a 	bl	11248 <pvPortMalloc>
    dbd4:	4603      	mov	r3, r0
    dbd6:	61fb      	str	r3, [r7, #28]

			if( pxStack != NULL )
    dbd8:	69fb      	ldr	r3, [r7, #28]
    dbda:	2b00      	cmp	r3, #0
    dbdc:	d010      	beq.n	dc00 <xTaskCreate+0x48>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    dbde:	f04f 005c 	mov.w	r0, #92	; 0x5c
    dbe2:	f003 fb31 	bl	11248 <pvPortMalloc>
    dbe6:	4603      	mov	r3, r0
    dbe8:	617b      	str	r3, [r7, #20]

				if( pxNewTCB != NULL )
    dbea:	697b      	ldr	r3, [r7, #20]
    dbec:	2b00      	cmp	r3, #0
    dbee:	d003      	beq.n	dbf8 <xTaskCreate+0x40>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    dbf0:	697b      	ldr	r3, [r7, #20]
    dbf2:	69fa      	ldr	r2, [r7, #28]
    dbf4:	631a      	str	r2, [r3, #48]	; 0x30
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    dbf6:	e006      	b.n	dc06 <xTaskCreate+0x4e>
    dbf8:	69f8      	ldr	r0, [r7, #28]
    dbfa:	f003 fbdb 	bl	113b4 <vPortFree>
    dbfe:	e002      	b.n	dc06 <xTaskCreate+0x4e>
				}
			}
			else
			{
				pxNewTCB = NULL;
    dc00:	f04f 0300 	mov.w	r3, #0
    dc04:	617b      	str	r3, [r7, #20]
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    dc06:	697b      	ldr	r3, [r7, #20]
    dc08:	2b00      	cmp	r3, #0
    dc0a:	d016      	beq.n	dc3a <xTaskCreate+0x82>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    dc0c:	88fb      	ldrh	r3, [r7, #6]
    dc0e:	6aba      	ldr	r2, [r7, #40]	; 0x28
    dc10:	9200      	str	r2, [sp, #0]
    dc12:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    dc14:	9201      	str	r2, [sp, #4]
    dc16:	697a      	ldr	r2, [r7, #20]
    dc18:	9202      	str	r2, [sp, #8]
    dc1a:	f04f 0200 	mov.w	r2, #0
    dc1e:	9203      	str	r2, [sp, #12]
    dc20:	68f8      	ldr	r0, [r7, #12]
    dc22:	68b9      	ldr	r1, [r7, #8]
    dc24:	461a      	mov	r2, r3
    dc26:	683b      	ldr	r3, [r7, #0]
    dc28:	f000 f810 	bl	dc4c <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    dc2c:	6978      	ldr	r0, [r7, #20]
    dc2e:	f000 f8b1 	bl	dd94 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    dc32:	f04f 0301 	mov.w	r3, #1
    dc36:	61bb      	str	r3, [r7, #24]
    dc38:	e002      	b.n	dc40 <xTaskCreate+0x88>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    dc3a:	f04f 33ff 	mov.w	r3, #4294967295
    dc3e:	61bb      	str	r3, [r7, #24]
		}

		return xReturn;
    dc40:	69bb      	ldr	r3, [r7, #24]
	}
    dc42:	4618      	mov	r0, r3
    dc44:	f107 0720 	add.w	r7, r7, #32
    dc48:	46bd      	mov	sp, r7
    dc4a:	bd80      	pop	{r7, pc}

0000dc4c <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    dc4c:	b580      	push	{r7, lr}
    dc4e:	b088      	sub	sp, #32
    dc50:	af00      	add	r7, sp, #0
    dc52:	60f8      	str	r0, [r7, #12]
    dc54:	60b9      	str	r1, [r7, #8]
    dc56:	607a      	str	r2, [r7, #4]
    dc58:	603b      	str	r3, [r7, #0]
			xRunPrivileged = pdFALSE;
		}
		uxPriority &= ~portPRIVILEGE_BIT;
	#endif /* portUSING_MPU_WRAPPERS == 1 */

	configASSERT( pcName );
    dc5a:	68bb      	ldr	r3, [r7, #8]
    dc5c:	2b00      	cmp	r3, #0
    dc5e:	d109      	bne.n	dc74 <prvInitialiseNewTask+0x28>
    dc60:	f04f 0328 	mov.w	r3, #40	; 0x28
    dc64:	f383 8811 	msr	BASEPRI, r3
    dc68:	f3bf 8f6f 	isb	sy
    dc6c:	f3bf 8f4f 	dsb	sy
    dc70:	61bb      	str	r3, [r7, #24]
    dc72:	e7fe      	b.n	dc72 <prvInitialiseNewTask+0x26>

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    dc74:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    dc76:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    dc78:	687b      	ldr	r3, [r7, #4]
    dc7a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    dc7e:	4610      	mov	r0, r2
    dc80:	f04f 01a5 	mov.w	r1, #165	; 0xa5
    dc84:	461a      	mov	r2, r3
    dc86:	f003 ff7d 	bl	11b84 <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    dc8a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    dc8c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    dc8e:	687b      	ldr	r3, [r7, #4]
    dc90:	f103 33ff 	add.w	r3, r3, #4294967295
    dc94:	ea4f 0383 	mov.w	r3, r3, lsl #2
    dc98:	4413      	add	r3, r2
    dc9a:	613b      	str	r3, [r7, #16]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
    dc9c:	693b      	ldr	r3, [r7, #16]
    dc9e:	f023 0307 	bic.w	r3, r3, #7
    dca2:	613b      	str	r3, [r7, #16]

		/* Check the alignment of the calculated top of stack is correct. */
		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    dca4:	693b      	ldr	r3, [r7, #16]
    dca6:	f003 0307 	and.w	r3, r3, #7
    dcaa:	2b00      	cmp	r3, #0
    dcac:	d009      	beq.n	dcc2 <prvInitialiseNewTask+0x76>
    dcae:	f04f 0328 	mov.w	r3, #40	; 0x28
    dcb2:	f383 8811 	msr	BASEPRI, r3
    dcb6:	f3bf 8f6f 	isb	sy
    dcba:	f3bf 8f4f 	dsb	sy
    dcbe:	61fb      	str	r3, [r7, #28]
    dcc0:	e7fe      	b.n	dcc0 <prvInitialiseNewTask+0x74>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    dcc2:	f04f 0300 	mov.w	r3, #0
    dcc6:	617b      	str	r3, [r7, #20]
    dcc8:	e012      	b.n	dcf0 <prvInitialiseNewTask+0xa4>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    dcca:	6979      	ldr	r1, [r7, #20]
    dccc:	68ba      	ldr	r2, [r7, #8]
    dcce:	697b      	ldr	r3, [r7, #20]
    dcd0:	4413      	add	r3, r2
    dcd2:	781a      	ldrb	r2, [r3, #0]
    dcd4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    dcd6:	440b      	add	r3, r1
    dcd8:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == ( char ) 0x00 )
    dcdc:	68ba      	ldr	r2, [r7, #8]
    dcde:	697b      	ldr	r3, [r7, #20]
    dce0:	4413      	add	r3, r2
    dce2:	781b      	ldrb	r3, [r3, #0]
    dce4:	2b00      	cmp	r3, #0
    dce6:	d007      	beq.n	dcf8 <prvInitialiseNewTask+0xac>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    dce8:	697b      	ldr	r3, [r7, #20]
    dcea:	f103 0301 	add.w	r3, r3, #1
    dcee:	617b      	str	r3, [r7, #20]
    dcf0:	697b      	ldr	r3, [r7, #20]
    dcf2:	2b09      	cmp	r3, #9
    dcf4:	d9e9      	bls.n	dcca <prvInitialiseNewTask+0x7e>
    dcf6:	e000      	b.n	dcfa <prvInitialiseNewTask+0xae>
		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == ( char ) 0x00 )
		{
			break;
    dcf8:	bf00      	nop
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    dcfa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    dcfc:	f04f 0200 	mov.w	r2, #0
    dd00:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    dd04:	6abb      	ldr	r3, [r7, #40]	; 0x28
    dd06:	2b04      	cmp	r3, #4
    dd08:	d902      	bls.n	dd10 <prvInitialiseNewTask+0xc4>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    dd0a:	f04f 0304 	mov.w	r3, #4
    dd0e:	62bb      	str	r3, [r7, #40]	; 0x28
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    dd10:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    dd12:	6aba      	ldr	r2, [r7, #40]	; 0x28
    dd14:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    dd16:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    dd18:	6aba      	ldr	r2, [r7, #40]	; 0x28
    dd1a:	649a      	str	r2, [r3, #72]	; 0x48
		pxNewTCB->uxMutexesHeld = 0;
    dd1c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    dd1e:	f04f 0200 	mov.w	r2, #0
    dd22:	64da      	str	r2, [r3, #76]	; 0x4c
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    dd24:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    dd26:	f103 0304 	add.w	r3, r3, #4
    dd2a:	4618      	mov	r0, r3
    dd2c:	f7fe fc5e 	bl	c5ec <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    dd30:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    dd32:	f103 0318 	add.w	r3, r3, #24
    dd36:	4618      	mov	r0, r3
    dd38:	f7fe fc58 	bl	c5ec <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    dd3c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    dd3e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    dd40:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    dd42:	6abb      	ldr	r3, [r7, #40]	; 0x28
    dd44:	f1c3 0205 	rsb	r2, r3, #5
    dd48:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    dd4a:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    dd4c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    dd4e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    dd50:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif /* configUSE_APPLICATION_TASK_TAG */

	#if ( configGENERATE_RUN_TIME_STATS == 1 )
	{
		pxNewTCB->ulRunTimeCounter = 0UL;
    dd52:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    dd54:	f04f 0200 	mov.w	r2, #0
    dd58:	651a      	str	r2, [r3, #80]	; 0x50
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    dd5a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    dd5c:	f04f 0200 	mov.w	r2, #0
    dd60:	655a      	str	r2, [r3, #84]	; 0x54
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    dd62:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    dd64:	f04f 0200 	mov.w	r2, #0
    dd68:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    dd6c:	6938      	ldr	r0, [r7, #16]
    dd6e:	68f9      	ldr	r1, [r7, #12]
    dd70:	683a      	ldr	r2, [r7, #0]
    dd72:	f003 fbab 	bl	114cc <pxPortInitialiseStack>
    dd76:	4603      	mov	r3, r0
    dd78:	461a      	mov	r2, r3
    dd7a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    dd7c:	601a      	str	r2, [r3, #0]
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    dd7e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    dd80:	2b00      	cmp	r3, #0
    dd82:	d002      	beq.n	dd8a <prvInitialiseNewTask+0x13e>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    dd84:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    dd86:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    dd88:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    dd8a:	f107 0720 	add.w	r7, r7, #32
    dd8e:	46bd      	mov	sp, r7
    dd90:	bd80      	pop	{r7, pc}
    dd92:	bf00      	nop

0000dd94 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    dd94:	b580      	push	{r7, lr}
    dd96:	b082      	sub	sp, #8
    dd98:	af00      	add	r7, sp, #0
    dd9a:	6078      	str	r0, [r7, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    dd9c:	f003 fcd4 	bl	11748 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
    dda0:	f243 03cc 	movw	r3, #12492	; 0x30cc
    dda4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dda8:	681b      	ldr	r3, [r3, #0]
    ddaa:	f103 0201 	add.w	r2, r3, #1
    ddae:	f243 03cc 	movw	r3, #12492	; 0x30cc
    ddb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ddb6:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
    ddb8:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    ddbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ddc0:	681b      	ldr	r3, [r3, #0]
    ddc2:	2b00      	cmp	r3, #0
    ddc4:	d10f      	bne.n	dde6 <prvAddNewTaskToReadyList+0x52>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    ddc6:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    ddca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ddce:	687a      	ldr	r2, [r7, #4]
    ddd0:	601a      	str	r2, [r3, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    ddd2:	f243 03cc 	movw	r3, #12492	; 0x30cc
    ddd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ddda:	681b      	ldr	r3, [r3, #0]
    dddc:	2b01      	cmp	r3, #1
    ddde:	d11a      	bne.n	de16 <prvAddNewTaskToReadyList+0x82>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    dde0:	f001 fc04 	bl	f5ec <prvInitialiseTaskLists>
    dde4:	e018      	b.n	de18 <prvAddNewTaskToReadyList+0x84>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    dde6:	f243 03d8 	movw	r3, #12504	; 0x30d8
    ddea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ddee:	681b      	ldr	r3, [r3, #0]
    ddf0:	2b00      	cmp	r3, #0
    ddf2:	d111      	bne.n	de18 <prvAddNewTaskToReadyList+0x84>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    ddf4:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    ddf8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ddfc:	681b      	ldr	r3, [r3, #0]
    ddfe:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    de00:	687b      	ldr	r3, [r7, #4]
    de02:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    de04:	429a      	cmp	r2, r3
    de06:	d807      	bhi.n	de18 <prvAddNewTaskToReadyList+0x84>
				{
					pxCurrentTCB = pxNewTCB;
    de08:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    de0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de10:	687a      	ldr	r2, [r7, #4]
    de12:	601a      	str	r2, [r3, #0]
    de14:	e000      	b.n	de18 <prvAddNewTaskToReadyList+0x84>
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    de16:	bf00      	nop
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    de18:	f243 03e8 	movw	r3, #12520	; 0x30e8
    de1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de20:	681b      	ldr	r3, [r3, #0]
    de22:	f103 0201 	add.w	r2, r3, #1
    de26:	f243 03e8 	movw	r3, #12520	; 0x30e8
    de2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de2e:	601a      	str	r2, [r3, #0]

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			/* Add a counter into the TCB for tracing only. */
			pxNewTCB->uxTCBNumber = uxTaskNumber;
    de30:	f243 03e8 	movw	r3, #12520	; 0x30e8
    de34:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de38:	681a      	ldr	r2, [r3, #0]
    de3a:	687b      	ldr	r3, [r7, #4]
    de3c:	641a      	str	r2, [r3, #64]	; 0x40
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    de3e:	687b      	ldr	r3, [r7, #4]
    de40:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    de42:	f04f 0201 	mov.w	r2, #1
    de46:	fa02 f203 	lsl.w	r2, r2, r3
    de4a:	f243 03d4 	movw	r3, #12500	; 0x30d4
    de4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de52:	681b      	ldr	r3, [r3, #0]
    de54:	ea42 0203 	orr.w	r2, r2, r3
    de58:	f243 03d4 	movw	r3, #12500	; 0x30d4
    de5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de60:	601a      	str	r2, [r3, #0]
    de62:	687b      	ldr	r3, [r7, #4]
    de64:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    de66:	4613      	mov	r3, r2
    de68:	ea4f 0383 	mov.w	r3, r3, lsl #2
    de6c:	4413      	add	r3, r2
    de6e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    de72:	461a      	mov	r2, r3
    de74:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    de78:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de7c:	441a      	add	r2, r3
    de7e:	687b      	ldr	r3, [r7, #4]
    de80:	f103 0304 	add.w	r3, r3, #4
    de84:	4610      	mov	r0, r2
    de86:	4619      	mov	r1, r3
    de88:	f7fe fbbe 	bl	c608 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    de8c:	f003 fc94 	bl	117b8 <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
    de90:	f243 03d8 	movw	r3, #12504	; 0x30d8
    de94:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de98:	681b      	ldr	r3, [r3, #0]
    de9a:	2b00      	cmp	r3, #0
    de9c:	d014      	beq.n	dec8 <prvAddNewTaskToReadyList+0x134>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    de9e:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    dea2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dea6:	681b      	ldr	r3, [r3, #0]
    dea8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    deaa:	687b      	ldr	r3, [r7, #4]
    deac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    deae:	429a      	cmp	r2, r3
    deb0:	d20a      	bcs.n	dec8 <prvAddNewTaskToReadyList+0x134>
		{
			taskYIELD_IF_USING_PREEMPTION();
    deb2:	f64e 5304 	movw	r3, #60676	; 0xed04
    deb6:	f2ce 0300 	movt	r3, #57344	; 0xe000
    deba:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    debe:	601a      	str	r2, [r3, #0]
    dec0:	f3bf 8f4f 	dsb	sy
    dec4:	f3bf 8f6f 	isb	sy
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    dec8:	f107 0708 	add.w	r7, r7, #8
    decc:	46bd      	mov	sp, r7
    dece:	bd80      	pop	{r7, pc}

0000ded0 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    ded0:	b580      	push	{r7, lr}
    ded2:	b084      	sub	sp, #16
    ded4:	af00      	add	r7, sp, #0
    ded6:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    ded8:	f003 fc36 	bl	11748 <vPortEnterCritical>
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    dedc:	687b      	ldr	r3, [r7, #4]
    dede:	2b00      	cmp	r3, #0
    dee0:	d105      	bne.n	deee <vTaskDelete+0x1e>
    dee2:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    dee6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    deea:	681b      	ldr	r3, [r3, #0]
    deec:	e000      	b.n	def0 <vTaskDelete+0x20>
    deee:	687b      	ldr	r3, [r7, #4]
    def0:	60bb      	str	r3, [r7, #8]

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    def2:	68bb      	ldr	r3, [r7, #8]
    def4:	f103 0304 	add.w	r3, r3, #4
    def8:	4618      	mov	r0, r3
    defa:	f7fe fbe3 	bl	c6c4 <uxListRemove>
    defe:	4603      	mov	r3, r0
    df00:	2b00      	cmp	r3, #0
    df02:	d124      	bne.n	df4e <vTaskDelete+0x7e>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
    df04:	68bb      	ldr	r3, [r7, #8]
    df06:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    df08:	4613      	mov	r3, r2
    df0a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    df0e:	4413      	add	r3, r2
    df10:	ea4f 0383 	mov.w	r3, r3, lsl #2
    df14:	461a      	mov	r2, r3
    df16:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    df1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    df1e:	4413      	add	r3, r2
    df20:	681b      	ldr	r3, [r3, #0]
    df22:	2b00      	cmp	r3, #0
    df24:	d113      	bne.n	df4e <vTaskDelete+0x7e>
    df26:	68bb      	ldr	r3, [r7, #8]
    df28:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    df2a:	f04f 0201 	mov.w	r2, #1
    df2e:	fa02 f303 	lsl.w	r3, r2, r3
    df32:	ea6f 0203 	mvn.w	r2, r3
    df36:	f243 03d4 	movw	r3, #12500	; 0x30d4
    df3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    df3e:	681b      	ldr	r3, [r3, #0]
    df40:	ea02 0203 	and.w	r2, r2, r3
    df44:	f243 03d4 	movw	r3, #12500	; 0x30d4
    df48:	f2c2 0300 	movt	r3, #8192	; 0x2000
    df4c:	601a      	str	r2, [r3, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    df4e:	68bb      	ldr	r3, [r7, #8]
    df50:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    df52:	2b00      	cmp	r3, #0
    df54:	d005      	beq.n	df62 <vTaskDelete+0x92>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    df56:	68bb      	ldr	r3, [r7, #8]
    df58:	f103 0318 	add.w	r3, r3, #24
    df5c:	4618      	mov	r0, r3
    df5e:	f7fe fbb1 	bl	c6c4 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    df62:	f243 03e8 	movw	r3, #12520	; 0x30e8
    df66:	f2c2 0300 	movt	r3, #8192	; 0x2000
    df6a:	681b      	ldr	r3, [r3, #0]
    df6c:	f103 0201 	add.w	r2, r3, #1
    df70:	f243 03e8 	movw	r3, #12520	; 0x30e8
    df74:	f2c2 0300 	movt	r3, #8192	; 0x2000
    df78:	601a      	str	r2, [r3, #0]

			if( pxTCB == pxCurrentTCB )
    df7a:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    df7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    df82:	681b      	ldr	r3, [r3, #0]
    df84:	68ba      	ldr	r2, [r7, #8]
    df86:	429a      	cmp	r2, r3
    df88:	d116      	bne.n	dfb8 <vTaskDelete+0xe8>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    df8a:	68bb      	ldr	r3, [r7, #8]
    df8c:	f103 0304 	add.w	r3, r3, #4
    df90:	f243 00a0 	movw	r0, #12448	; 0x30a0
    df94:	f2c2 0000 	movt	r0, #8192	; 0x2000
    df98:	4619      	mov	r1, r3
    df9a:	f7fe fb35 	bl	c608 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    df9e:	f243 03b4 	movw	r3, #12468	; 0x30b4
    dfa2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dfa6:	681b      	ldr	r3, [r3, #0]
    dfa8:	f103 0201 	add.w	r2, r3, #1
    dfac:	f243 03b4 	movw	r3, #12468	; 0x30b4
    dfb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dfb4:	601a      	str	r2, [r3, #0]
    dfb6:	e010      	b.n	dfda <vTaskDelete+0x10a>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    dfb8:	f243 03cc 	movw	r3, #12492	; 0x30cc
    dfbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dfc0:	681b      	ldr	r3, [r3, #0]
    dfc2:	f103 32ff 	add.w	r2, r3, #4294967295
    dfc6:	f243 03cc 	movw	r3, #12492	; 0x30cc
    dfca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dfce:	601a      	str	r2, [r3, #0]
				prvDeleteTCB( pxTCB );
    dfd0:	68b8      	ldr	r0, [r7, #8]
    dfd2:	f001 fc85 	bl	f8e0 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    dfd6:	f001 fc93 	bl	f900 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    dfda:	f003 fbed 	bl	117b8 <vPortExitCritical>

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    dfde:	f243 03d8 	movw	r3, #12504	; 0x30d8
    dfe2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dfe6:	681b      	ldr	r3, [r3, #0]
    dfe8:	2b00      	cmp	r3, #0
    dfea:	d023      	beq.n	e034 <vTaskDelete+0x164>
		{
			if( pxTCB == pxCurrentTCB )
    dfec:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    dff0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dff4:	681b      	ldr	r3, [r3, #0]
    dff6:	68ba      	ldr	r2, [r7, #8]
    dff8:	429a      	cmp	r2, r3
    dffa:	d11b      	bne.n	e034 <vTaskDelete+0x164>
			{
				configASSERT( uxSchedulerSuspended == 0 );
    dffc:	f243 03f4 	movw	r3, #12532	; 0x30f4
    e000:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e004:	681b      	ldr	r3, [r3, #0]
    e006:	2b00      	cmp	r3, #0
    e008:	d009      	beq.n	e01e <vTaskDelete+0x14e>
    e00a:	f04f 0328 	mov.w	r3, #40	; 0x28
    e00e:	f383 8811 	msr	BASEPRI, r3
    e012:	f3bf 8f6f 	isb	sy
    e016:	f3bf 8f4f 	dsb	sy
    e01a:	60fb      	str	r3, [r7, #12]
    e01c:	e7fe      	b.n	e01c <vTaskDelete+0x14c>
				portYIELD_WITHIN_API();
    e01e:	f64e 5304 	movw	r3, #60676	; 0xed04
    e022:	f2ce 0300 	movt	r3, #57344	; 0xe000
    e026:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    e02a:	601a      	str	r2, [r3, #0]
    e02c:	f3bf 8f4f 	dsb	sy
    e030:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    e034:	f107 0710 	add.w	r7, r7, #16
    e038:	46bd      	mov	sp, r7
    e03a:	bd80      	pop	{r7, pc}

0000e03c <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    e03c:	b580      	push	{r7, lr}
    e03e:	b08a      	sub	sp, #40	; 0x28
    e040:	af00      	add	r7, sp, #0
    e042:	6078      	str	r0, [r7, #4]
    e044:	6039      	str	r1, [r7, #0]
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    e046:	f04f 0300 	mov.w	r3, #0
    e04a:	617b      	str	r3, [r7, #20]

		configASSERT( pxPreviousWakeTime );
    e04c:	687b      	ldr	r3, [r7, #4]
    e04e:	2b00      	cmp	r3, #0
    e050:	d109      	bne.n	e066 <vTaskDelayUntil+0x2a>
    e052:	f04f 0328 	mov.w	r3, #40	; 0x28
    e056:	f383 8811 	msr	BASEPRI, r3
    e05a:	f3bf 8f6f 	isb	sy
    e05e:	f3bf 8f4f 	dsb	sy
    e062:	61fb      	str	r3, [r7, #28]
    e064:	e7fe      	b.n	e064 <vTaskDelayUntil+0x28>
		configASSERT( ( xTimeIncrement > 0U ) );
    e066:	683b      	ldr	r3, [r7, #0]
    e068:	2b00      	cmp	r3, #0
    e06a:	d109      	bne.n	e080 <vTaskDelayUntil+0x44>
    e06c:	f04f 0328 	mov.w	r3, #40	; 0x28
    e070:	f383 8811 	msr	BASEPRI, r3
    e074:	f3bf 8f6f 	isb	sy
    e078:	f3bf 8f4f 	dsb	sy
    e07c:	623b      	str	r3, [r7, #32]
    e07e:	e7fe      	b.n	e07e <vTaskDelayUntil+0x42>
		configASSERT( uxSchedulerSuspended == 0 );
    e080:	f243 03f4 	movw	r3, #12532	; 0x30f4
    e084:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e088:	681b      	ldr	r3, [r3, #0]
    e08a:	2b00      	cmp	r3, #0
    e08c:	d009      	beq.n	e0a2 <vTaskDelayUntil+0x66>
    e08e:	f04f 0328 	mov.w	r3, #40	; 0x28
    e092:	f383 8811 	msr	BASEPRI, r3
    e096:	f3bf 8f6f 	isb	sy
    e09a:	f3bf 8f4f 	dsb	sy
    e09e:	627b      	str	r3, [r7, #36]	; 0x24
    e0a0:	e7fe      	b.n	e0a0 <vTaskDelayUntil+0x64>

		vTaskSuspendAll();
    e0a2:	f000 fc6d 	bl	e980 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    e0a6:	f243 03d0 	movw	r3, #12496	; 0x30d0
    e0aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e0ae:	681b      	ldr	r3, [r3, #0]
    e0b0:	61bb      	str	r3, [r7, #24]

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    e0b2:	687b      	ldr	r3, [r7, #4]
    e0b4:	681a      	ldr	r2, [r3, #0]
    e0b6:	683b      	ldr	r3, [r7, #0]
    e0b8:	4413      	add	r3, r2
    e0ba:	60fb      	str	r3, [r7, #12]

			if( xConstTickCount < *pxPreviousWakeTime )
    e0bc:	687b      	ldr	r3, [r7, #4]
    e0be:	681a      	ldr	r2, [r3, #0]
    e0c0:	69bb      	ldr	r3, [r7, #24]
    e0c2:	429a      	cmp	r2, r3
    e0c4:	d90c      	bls.n	e0e0 <vTaskDelayUntil+0xa4>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    e0c6:	687b      	ldr	r3, [r7, #4]
    e0c8:	681a      	ldr	r2, [r3, #0]
    e0ca:	68fb      	ldr	r3, [r7, #12]
    e0cc:	429a      	cmp	r2, r3
    e0ce:	d914      	bls.n	e0fa <vTaskDelayUntil+0xbe>
    e0d0:	68fa      	ldr	r2, [r7, #12]
    e0d2:	69bb      	ldr	r3, [r7, #24]
    e0d4:	429a      	cmp	r2, r3
    e0d6:	d912      	bls.n	e0fe <vTaskDelayUntil+0xc2>
				{
					xShouldDelay = pdTRUE;
    e0d8:	f04f 0301 	mov.w	r3, #1
    e0dc:	617b      	str	r3, [r7, #20]
    e0de:	e00f      	b.n	e100 <vTaskDelayUntil+0xc4>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    e0e0:	687b      	ldr	r3, [r7, #4]
    e0e2:	681a      	ldr	r2, [r3, #0]
    e0e4:	68fb      	ldr	r3, [r7, #12]
    e0e6:	429a      	cmp	r2, r3
    e0e8:	d803      	bhi.n	e0f2 <vTaskDelayUntil+0xb6>
    e0ea:	68fa      	ldr	r2, [r7, #12]
    e0ec:	69bb      	ldr	r3, [r7, #24]
    e0ee:	429a      	cmp	r2, r3
    e0f0:	d906      	bls.n	e100 <vTaskDelayUntil+0xc4>
				{
					xShouldDelay = pdTRUE;
    e0f2:	f04f 0301 	mov.w	r3, #1
    e0f6:	617b      	str	r3, [r7, #20]
    e0f8:	e002      	b.n	e100 <vTaskDelayUntil+0xc4>
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
    e0fa:	bf00      	nop
    e0fc:	e000      	b.n	e100 <vTaskDelayUntil+0xc4>
    e0fe:	bf00      	nop
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    e100:	687b      	ldr	r3, [r7, #4]
    e102:	68fa      	ldr	r2, [r7, #12]
    e104:	601a      	str	r2, [r3, #0]

			if( xShouldDelay != pdFALSE )
    e106:	697b      	ldr	r3, [r7, #20]
    e108:	2b00      	cmp	r3, #0
    e10a:	d008      	beq.n	e11e <vTaskDelayUntil+0xe2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    e10c:	68fa      	ldr	r2, [r7, #12]
    e10e:	69bb      	ldr	r3, [r7, #24]
    e110:	ebc3 0302 	rsb	r3, r3, r2
    e114:	4618      	mov	r0, r3
    e116:	f04f 0100 	mov.w	r1, #0
    e11a:	f002 fb7b 	bl	10814 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    e11e:	f000 fc41 	bl	e9a4 <xTaskResumeAll>
    e122:	4603      	mov	r3, r0
    e124:	613b      	str	r3, [r7, #16]

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    e126:	693b      	ldr	r3, [r7, #16]
    e128:	2b00      	cmp	r3, #0
    e12a:	d10a      	bne.n	e142 <vTaskDelayUntil+0x106>
		{
			portYIELD_WITHIN_API();
    e12c:	f64e 5304 	movw	r3, #60676	; 0xed04
    e130:	f2ce 0300 	movt	r3, #57344	; 0xe000
    e134:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    e138:	601a      	str	r2, [r3, #0]
    e13a:	f3bf 8f4f 	dsb	sy
    e13e:	f3bf 8f6f 	isb	sy
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    e142:	f107 0728 	add.w	r7, r7, #40	; 0x28
    e146:	46bd      	mov	sp, r7
    e148:	bd80      	pop	{r7, pc}
    e14a:	bf00      	nop

0000e14c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    e14c:	b580      	push	{r7, lr}
    e14e:	b084      	sub	sp, #16
    e150:	af00      	add	r7, sp, #0
    e152:	6078      	str	r0, [r7, #4]
	BaseType_t xAlreadyYielded = pdFALSE;
    e154:	f04f 0300 	mov.w	r3, #0
    e158:	60bb      	str	r3, [r7, #8]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    e15a:	687b      	ldr	r3, [r7, #4]
    e15c:	2b00      	cmp	r3, #0
    e15e:	d01b      	beq.n	e198 <vTaskDelay+0x4c>
		{
			configASSERT( uxSchedulerSuspended == 0 );
    e160:	f243 03f4 	movw	r3, #12532	; 0x30f4
    e164:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e168:	681b      	ldr	r3, [r3, #0]
    e16a:	2b00      	cmp	r3, #0
    e16c:	d009      	beq.n	e182 <vTaskDelay+0x36>
    e16e:	f04f 0328 	mov.w	r3, #40	; 0x28
    e172:	f383 8811 	msr	BASEPRI, r3
    e176:	f3bf 8f6f 	isb	sy
    e17a:	f3bf 8f4f 	dsb	sy
    e17e:	60fb      	str	r3, [r7, #12]
    e180:	e7fe      	b.n	e180 <vTaskDelay+0x34>
			vTaskSuspendAll();
    e182:	f000 fbfd 	bl	e980 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    e186:	6878      	ldr	r0, [r7, #4]
    e188:	f04f 0100 	mov.w	r1, #0
    e18c:	f002 fb42 	bl	10814 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    e190:	f000 fc08 	bl	e9a4 <xTaskResumeAll>
    e194:	4603      	mov	r3, r0
    e196:	60bb      	str	r3, [r7, #8]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    e198:	68bb      	ldr	r3, [r7, #8]
    e19a:	2b00      	cmp	r3, #0
    e19c:	d10a      	bne.n	e1b4 <vTaskDelay+0x68>
		{
			portYIELD_WITHIN_API();
    e19e:	f64e 5304 	movw	r3, #60676	; 0xed04
    e1a2:	f2ce 0300 	movt	r3, #57344	; 0xe000
    e1a6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    e1aa:	601a      	str	r2, [r3, #0]
    e1ac:	f3bf 8f4f 	dsb	sy
    e1b0:	f3bf 8f6f 	isb	sy
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    e1b4:	f107 0710 	add.w	r7, r7, #16
    e1b8:	46bd      	mov	sp, r7
    e1ba:	bd80      	pop	{r7, pc}

0000e1bc <eTaskGetState>:
/*-----------------------------------------------------------*/

#if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )

	eTaskState eTaskGetState( TaskHandle_t xTask )
	{
    e1bc:	b580      	push	{r7, lr}
    e1be:	b088      	sub	sp, #32
    e1c0:	af00      	add	r7, sp, #0
    e1c2:	6078      	str	r0, [r7, #4]
	eTaskState eReturn;
	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
	const TCB_t * const pxTCB = xTask;
    e1c4:	687b      	ldr	r3, [r7, #4]
    e1c6:	61bb      	str	r3, [r7, #24]

		configASSERT( pxTCB );
    e1c8:	69bb      	ldr	r3, [r7, #24]
    e1ca:	2b00      	cmp	r3, #0
    e1cc:	d109      	bne.n	e1e2 <eTaskGetState+0x26>
    e1ce:	f04f 0328 	mov.w	r3, #40	; 0x28
    e1d2:	f383 8811 	msr	BASEPRI, r3
    e1d6:	f3bf 8f6f 	isb	sy
    e1da:	f3bf 8f4f 	dsb	sy
    e1de:	61fb      	str	r3, [r7, #28]
    e1e0:	e7fe      	b.n	e1e0 <eTaskGetState+0x24>

		if( pxTCB == pxCurrentTCB )
    e1e2:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e1e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e1ea:	681b      	ldr	r3, [r3, #0]
    e1ec:	69ba      	ldr	r2, [r7, #24]
    e1ee:	429a      	cmp	r2, r3
    e1f0:	d103      	bne.n	e1fa <eTaskGetState+0x3e>
		{
			/* The task calling this function is querying its own state. */
			eReturn = eRunning;
    e1f2:	f04f 0300 	mov.w	r3, #0
    e1f6:	72fb      	strb	r3, [r7, #11]
    e1f8:	e04c      	b.n	e294 <eTaskGetState+0xd8>
		}
		else
		{
			taskENTER_CRITICAL();
    e1fa:	f003 faa5 	bl	11748 <vPortEnterCritical>
			{
				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
    e1fe:	69bb      	ldr	r3, [r7, #24]
    e200:	695b      	ldr	r3, [r3, #20]
    e202:	60fb      	str	r3, [r7, #12]
				pxDelayedList = pxDelayedTaskList;
    e204:	f243 0384 	movw	r3, #12420	; 0x3084
    e208:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e20c:	681b      	ldr	r3, [r3, #0]
    e20e:	613b      	str	r3, [r7, #16]
				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
    e210:	f243 0388 	movw	r3, #12424	; 0x3088
    e214:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e218:	681b      	ldr	r3, [r3, #0]
    e21a:	617b      	str	r3, [r7, #20]
			}
			taskEXIT_CRITICAL();
    e21c:	f003 facc 	bl	117b8 <vPortExitCritical>

			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
    e220:	68fa      	ldr	r2, [r7, #12]
    e222:	693b      	ldr	r3, [r7, #16]
    e224:	429a      	cmp	r2, r3
    e226:	d003      	beq.n	e230 <eTaskGetState+0x74>
    e228:	68fa      	ldr	r2, [r7, #12]
    e22a:	697b      	ldr	r3, [r7, #20]
    e22c:	429a      	cmp	r2, r3
    e22e:	d103      	bne.n	e238 <eTaskGetState+0x7c>
			{
				/* The task being queried is referenced from one of the Blocked
				lists. */
				eReturn = eBlocked;
    e230:	f04f 0302 	mov.w	r3, #2
    e234:	72fb      	strb	r3, [r7, #11]
				pxDelayedList = pxDelayedTaskList;
				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
			}
			taskEXIT_CRITICAL();

			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
    e236:	e02d      	b.n	e294 <eTaskGetState+0xd8>
				lists. */
				eReturn = eBlocked;
			}

			#if ( INCLUDE_vTaskSuspend == 1 )
				else if( pxStateList == &xSuspendedTaskList )
    e238:	68fa      	ldr	r2, [r7, #12]
    e23a:	f243 03b8 	movw	r3, #12472	; 0x30b8
    e23e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e242:	429a      	cmp	r2, r3
    e244:	d115      	bne.n	e272 <eTaskGetState+0xb6>
				{
					/* The task being queried is referenced from the suspended
					list.  Is it genuinely suspended or is it blocked
					indefinitely? */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
    e246:	69bb      	ldr	r3, [r7, #24]
    e248:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    e24a:	2b00      	cmp	r3, #0
    e24c:	d10d      	bne.n	e26a <eTaskGetState+0xae>
						{
							/* The task does not appear on the event list item of
							and of the RTOS objects, but could still be in the
							blocked state if it is waiting on its notification
							rather than waiting on an object. */
							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    e24e:	69bb      	ldr	r3, [r7, #24]
    e250:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
    e254:	b2db      	uxtb	r3, r3
    e256:	2b01      	cmp	r3, #1
    e258:	d103      	bne.n	e262 <eTaskGetState+0xa6>
							{
								eReturn = eBlocked;
    e25a:	f04f 0302 	mov.w	r3, #2
    e25e:	72fb      	strb	r3, [r7, #11]
						}
						#endif
					}
					else
					{
						eReturn = eBlocked;
    e260:	e018      	b.n	e294 <eTaskGetState+0xd8>
							{
								eReturn = eBlocked;
							}
							else
							{
								eReturn = eSuspended;
    e262:	f04f 0303 	mov.w	r3, #3
    e266:	72fb      	strb	r3, [r7, #11]
						}
						#endif
					}
					else
					{
						eReturn = eBlocked;
    e268:	e014      	b.n	e294 <eTaskGetState+0xd8>
    e26a:	f04f 0302 	mov.w	r3, #2
    e26e:	72fb      	strb	r3, [r7, #11]
    e270:	e010      	b.n	e294 <eTaskGetState+0xd8>
					}
				}
			#endif

			#if ( INCLUDE_vTaskDelete == 1 )
				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
    e272:	68fa      	ldr	r2, [r7, #12]
    e274:	f243 03a0 	movw	r3, #12448	; 0x30a0
    e278:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e27c:	429a      	cmp	r2, r3
    e27e:	d002      	beq.n	e286 <eTaskGetState+0xca>
    e280:	68fb      	ldr	r3, [r7, #12]
    e282:	2b00      	cmp	r3, #0
    e284:	d103      	bne.n	e28e <eTaskGetState+0xd2>
				{
					/* The task being queried is referenced from the deleted
					tasks list, or it is not referenced from any lists at
					all. */
					eReturn = eDeleted;
    e286:	f04f 0304 	mov.w	r3, #4
    e28a:	72fb      	strb	r3, [r7, #11]
					}
				}
			#endif

			#if ( INCLUDE_vTaskDelete == 1 )
				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
    e28c:	e002      	b.n	e294 <eTaskGetState+0xd8>

			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
			{
				/* If the task is not in any other state, it must be in the
				Ready (including pending ready) state. */
				eReturn = eReady;
    e28e:	f04f 0301 	mov.w	r3, #1
    e292:	72fb      	strb	r3, [r7, #11]
			}
		}

		return eReturn;
    e294:	7afb      	ldrb	r3, [r7, #11]
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    e296:	4618      	mov	r0, r3
    e298:	f107 0720 	add.w	r7, r7, #32
    e29c:	46bd      	mov	sp, r7
    e29e:	bd80      	pop	{r7, pc}

0000e2a0 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
	{
    e2a0:	b580      	push	{r7, lr}
    e2a2:	b084      	sub	sp, #16
    e2a4:	af00      	add	r7, sp, #0
    e2a6:	6078      	str	r0, [r7, #4]
	TCB_t const *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    e2a8:	f003 fa4e 	bl	11748 <vPortEnterCritical>
		{
			/* If null is passed in here then it is the priority of the task
			that called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    e2ac:	687b      	ldr	r3, [r7, #4]
    e2ae:	2b00      	cmp	r3, #0
    e2b0:	d105      	bne.n	e2be <uxTaskPriorityGet+0x1e>
    e2b2:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e2b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e2ba:	681b      	ldr	r3, [r3, #0]
    e2bc:	e000      	b.n	e2c0 <uxTaskPriorityGet+0x20>
    e2be:	687b      	ldr	r3, [r7, #4]
    e2c0:	60bb      	str	r3, [r7, #8]
			uxReturn = pxTCB->uxPriority;
    e2c2:	68bb      	ldr	r3, [r7, #8]
    e2c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    e2c6:	60fb      	str	r3, [r7, #12]
		}
		taskEXIT_CRITICAL();
    e2c8:	f003 fa76 	bl	117b8 <vPortExitCritical>

		return uxReturn;
    e2cc:	68fb      	ldr	r3, [r7, #12]
	}
    e2ce:	4618      	mov	r0, r3
    e2d0:	f107 0710 	add.w	r7, r7, #16
    e2d4:	46bd      	mov	sp, r7
    e2d6:	bd80      	pop	{r7, pc}

0000e2d8 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
	{
    e2d8:	b580      	push	{r7, lr}
    e2da:	b088      	sub	sp, #32
    e2dc:	af00      	add	r7, sp, #0
    e2de:	6078      	str	r0, [r7, #4]
		below the maximum system call interrupt priority.  FreeRTOS maintains a
		separate interrupt safe API to ensure interrupt entry is as fast and as
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    e2e0:	f003 fb16 	bl	11910 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
    e2e4:	f3ef 8211 	mrs	r2, BASEPRI
    e2e8:	f04f 0328 	mov.w	r3, #40	; 0x28
    e2ec:	f383 8811 	msr	BASEPRI, r3
    e2f0:	f3bf 8f6f 	isb	sy
    e2f4:	f3bf 8f4f 	dsb	sy
    e2f8:	61ba      	str	r2, [r7, #24]
    e2fa:	617b      	str	r3, [r7, #20]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
    e2fc:	69bb      	ldr	r3, [r7, #24]

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
    e2fe:	613b      	str	r3, [r7, #16]
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    e300:	687b      	ldr	r3, [r7, #4]
    e302:	2b00      	cmp	r3, #0
    e304:	d105      	bne.n	e312 <uxTaskPriorityGetFromISR+0x3a>
    e306:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e30a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e30e:	681b      	ldr	r3, [r3, #0]
    e310:	e000      	b.n	e314 <uxTaskPriorityGetFromISR+0x3c>
    e312:	687b      	ldr	r3, [r7, #4]
    e314:	60bb      	str	r3, [r7, #8]
			uxReturn = pxTCB->uxPriority;
    e316:	68bb      	ldr	r3, [r7, #8]
    e318:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    e31a:	60fb      	str	r3, [r7, #12]
    e31c:	693b      	ldr	r3, [r7, #16]
    e31e:	61fb      	str	r3, [r7, #28]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
    e320:	69fb      	ldr	r3, [r7, #28]
    e322:	f383 8811 	msr	BASEPRI, r3
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
    e326:	68fb      	ldr	r3, [r7, #12]
	}
    e328:	4618      	mov	r0, r3
    e32a:	f107 0720 	add.w	r7, r7, #32
    e32e:	46bd      	mov	sp, r7
    e330:	bd80      	pop	{r7, pc}
    e332:	bf00      	nop

0000e334 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    e334:	b580      	push	{r7, lr}
    e336:	b088      	sub	sp, #32
    e338:	af00      	add	r7, sp, #0
    e33a:	6078      	str	r0, [r7, #4]
    e33c:	6039      	str	r1, [r7, #0]
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    e33e:	f04f 0300 	mov.w	r3, #0
    e342:	61bb      	str	r3, [r7, #24]

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
    e344:	683b      	ldr	r3, [r7, #0]
    e346:	2b04      	cmp	r3, #4
    e348:	d909      	bls.n	e35e <vTaskPrioritySet+0x2a>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
    e34a:	f04f 0328 	mov.w	r3, #40	; 0x28
    e34e:	f383 8811 	msr	BASEPRI, r3
    e352:	f3bf 8f6f 	isb	sy
    e356:	f3bf 8f4f 	dsb	sy
    e35a:	61fb      	str	r3, [r7, #28]
    e35c:	e7fe      	b.n	e35c <vTaskPrioritySet+0x28>

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    e35e:	683b      	ldr	r3, [r7, #0]
    e360:	2b04      	cmp	r3, #4
    e362:	d902      	bls.n	e36a <vTaskPrioritySet+0x36>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    e364:	f04f 0304 	mov.w	r3, #4
    e368:	603b      	str	r3, [r7, #0]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    e36a:	f003 f9ed 	bl	11748 <vPortEnterCritical>
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    e36e:	687b      	ldr	r3, [r7, #4]
    e370:	2b00      	cmp	r3, #0
    e372:	d105      	bne.n	e380 <vTaskPrioritySet+0x4c>
    e374:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e378:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e37c:	681b      	ldr	r3, [r3, #0]
    e37e:	e000      	b.n	e382 <vTaskPrioritySet+0x4e>
    e380:	687b      	ldr	r3, [r7, #4]
    e382:	60fb      	str	r3, [r7, #12]

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    e384:	68fb      	ldr	r3, [r7, #12]
    e386:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    e388:	613b      	str	r3, [r7, #16]
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    e38a:	693a      	ldr	r2, [r7, #16]
    e38c:	683b      	ldr	r3, [r7, #0]
    e38e:	429a      	cmp	r2, r3
    e390:	f000 80a2 	beq.w	e4d8 <vTaskPrioritySet+0x1a4>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    e394:	683a      	ldr	r2, [r7, #0]
    e396:	693b      	ldr	r3, [r7, #16]
    e398:	429a      	cmp	r2, r3
    e39a:	d914      	bls.n	e3c6 <vTaskPrioritySet+0x92>
				{
					if( pxTCB != pxCurrentTCB )
    e39c:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e3a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e3a4:	681b      	ldr	r3, [r3, #0]
    e3a6:	68fa      	ldr	r2, [r7, #12]
    e3a8:	429a      	cmp	r2, r3
    e3aa:	d018      	beq.n	e3de <vTaskPrioritySet+0xaa>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    e3ac:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e3b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e3b4:	681b      	ldr	r3, [r3, #0]
    e3b6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    e3b8:	683b      	ldr	r3, [r7, #0]
    e3ba:	429a      	cmp	r2, r3
    e3bc:	d811      	bhi.n	e3e2 <vTaskPrioritySet+0xae>
						{
							xYieldRequired = pdTRUE;
    e3be:	f04f 0301 	mov.w	r3, #1
    e3c2:	61bb      	str	r3, [r7, #24]
    e3c4:	e00e      	b.n	e3e4 <vTaskPrioritySet+0xb0>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    e3c6:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e3ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e3ce:	681b      	ldr	r3, [r3, #0]
    e3d0:	68fa      	ldr	r2, [r7, #12]
    e3d2:	429a      	cmp	r2, r3
    e3d4:	d106      	bne.n	e3e4 <vTaskPrioritySet+0xb0>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
    e3d6:	f04f 0301 	mov.w	r3, #1
    e3da:	61bb      	str	r3, [r7, #24]
    e3dc:	e002      	b.n	e3e4 <vTaskPrioritySet+0xb0>
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
						{
							xYieldRequired = pdTRUE;
    e3de:	bf00      	nop
    e3e0:	e000      	b.n	e3e4 <vTaskPrioritySet+0xb0>
    e3e2:	bf00      	nop
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    e3e4:	68fb      	ldr	r3, [r7, #12]
    e3e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    e3e8:	617b      	str	r3, [r7, #20]

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    e3ea:	68fb      	ldr	r3, [r7, #12]
    e3ec:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    e3ee:	68fb      	ldr	r3, [r7, #12]
    e3f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    e3f2:	429a      	cmp	r2, r3
    e3f4:	d102      	bne.n	e3fc <vTaskPrioritySet+0xc8>
					{
						pxTCB->uxPriority = uxNewPriority;
    e3f6:	68fb      	ldr	r3, [r7, #12]
    e3f8:	683a      	ldr	r2, [r7, #0]
    e3fa:	62da      	str	r2, [r3, #44]	; 0x2c
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    e3fc:	68fb      	ldr	r3, [r7, #12]
    e3fe:	683a      	ldr	r2, [r7, #0]
    e400:	649a      	str	r2, [r3, #72]	; 0x48
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    e402:	68fb      	ldr	r3, [r7, #12]
    e404:	699b      	ldr	r3, [r3, #24]
    e406:	2b00      	cmp	r3, #0
    e408:	db04      	blt.n	e414 <vTaskPrioritySet+0xe0>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    e40a:	683b      	ldr	r3, [r7, #0]
    e40c:	f1c3 0205 	rsb	r2, r3, #5
    e410:	68fb      	ldr	r3, [r7, #12]
    e412:	619a      	str	r2, [r3, #24]

				/* If the task is in the blocked or suspended list we need do
				nothing more than change its priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    e414:	68fb      	ldr	r3, [r7, #12]
    e416:	6959      	ldr	r1, [r3, #20]
    e418:	697a      	ldr	r2, [r7, #20]
    e41a:	4613      	mov	r3, r2
    e41c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    e420:	4413      	add	r3, r2
    e422:	ea4f 0383 	mov.w	r3, r3, lsl #2
    e426:	461a      	mov	r2, r3
    e428:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    e42c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e430:	4413      	add	r3, r2
    e432:	4299      	cmp	r1, r3
    e434:	d142      	bne.n	e4bc <vTaskPrioritySet+0x188>
				{
					/* The task is currently in its ready list - remove before
					adding it to it's new ready list.  As we are in a critical
					section we can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    e436:	68fb      	ldr	r3, [r7, #12]
    e438:	f103 0304 	add.w	r3, r3, #4
    e43c:	4618      	mov	r0, r3
    e43e:	f7fe f941 	bl	c6c4 <uxListRemove>
    e442:	4603      	mov	r3, r0
    e444:	2b00      	cmp	r3, #0
    e446:	d112      	bne.n	e46e <vTaskPrioritySet+0x13a>
					{
						/* It is known that the task is in its ready list so
						there is no need to check again and the port level
						reset macro can be called directly. */
						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
    e448:	697b      	ldr	r3, [r7, #20]
    e44a:	f04f 0201 	mov.w	r2, #1
    e44e:	fa02 f303 	lsl.w	r3, r2, r3
    e452:	ea6f 0203 	mvn.w	r2, r3
    e456:	f243 03d4 	movw	r3, #12500	; 0x30d4
    e45a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e45e:	681b      	ldr	r3, [r3, #0]
    e460:	ea02 0203 	and.w	r2, r2, r3
    e464:	f243 03d4 	movw	r3, #12500	; 0x30d4
    e468:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e46c:	601a      	str	r2, [r3, #0]
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    e46e:	68fb      	ldr	r3, [r7, #12]
    e470:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    e472:	f04f 0201 	mov.w	r2, #1
    e476:	fa02 f203 	lsl.w	r2, r2, r3
    e47a:	f243 03d4 	movw	r3, #12500	; 0x30d4
    e47e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e482:	681b      	ldr	r3, [r3, #0]
    e484:	ea42 0203 	orr.w	r2, r2, r3
    e488:	f243 03d4 	movw	r3, #12500	; 0x30d4
    e48c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e490:	601a      	str	r2, [r3, #0]
    e492:	68fb      	ldr	r3, [r7, #12]
    e494:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    e496:	4613      	mov	r3, r2
    e498:	ea4f 0383 	mov.w	r3, r3, lsl #2
    e49c:	4413      	add	r3, r2
    e49e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    e4a2:	461a      	mov	r2, r3
    e4a4:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    e4a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e4ac:	441a      	add	r2, r3
    e4ae:	68fb      	ldr	r3, [r7, #12]
    e4b0:	f103 0304 	add.w	r3, r3, #4
    e4b4:	4610      	mov	r0, r2
    e4b6:	4619      	mov	r1, r3
    e4b8:	f7fe f8a6 	bl	c608 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
    e4bc:	69bb      	ldr	r3, [r7, #24]
    e4be:	2b00      	cmp	r3, #0
    e4c0:	d00a      	beq.n	e4d8 <vTaskPrioritySet+0x1a4>
				{
					taskYIELD_IF_USING_PREEMPTION();
    e4c2:	f64e 5304 	movw	r3, #60676	; 0xed04
    e4c6:	f2ce 0300 	movt	r3, #57344	; 0xe000
    e4ca:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    e4ce:	601a      	str	r2, [r3, #0]
    e4d0:	f3bf 8f4f 	dsb	sy
    e4d4:	f3bf 8f6f 	isb	sy
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    e4d8:	f003 f96e 	bl	117b8 <vPortExitCritical>
	}
    e4dc:	f107 0720 	add.w	r7, r7, #32
    e4e0:	46bd      	mov	sp, r7
    e4e2:	bd80      	pop	{r7, pc}

0000e4e4 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    e4e4:	b580      	push	{r7, lr}
    e4e6:	b084      	sub	sp, #16
    e4e8:	af00      	add	r7, sp, #0
    e4ea:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    e4ec:	f003 f92c 	bl	11748 <vPortEnterCritical>
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    e4f0:	687b      	ldr	r3, [r7, #4]
    e4f2:	2b00      	cmp	r3, #0
    e4f4:	d105      	bne.n	e502 <vTaskSuspend+0x1e>
    e4f6:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e4fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e4fe:	681b      	ldr	r3, [r3, #0]
    e500:	e000      	b.n	e504 <vTaskSuspend+0x20>
    e502:	687b      	ldr	r3, [r7, #4]
    e504:	60bb      	str	r3, [r7, #8]

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    e506:	68bb      	ldr	r3, [r7, #8]
    e508:	f103 0304 	add.w	r3, r3, #4
    e50c:	4618      	mov	r0, r3
    e50e:	f7fe f8d9 	bl	c6c4 <uxListRemove>
    e512:	4603      	mov	r3, r0
    e514:	2b00      	cmp	r3, #0
    e516:	d124      	bne.n	e562 <vTaskSuspend+0x7e>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
    e518:	68bb      	ldr	r3, [r7, #8]
    e51a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    e51c:	4613      	mov	r3, r2
    e51e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    e522:	4413      	add	r3, r2
    e524:	ea4f 0383 	mov.w	r3, r3, lsl #2
    e528:	461a      	mov	r2, r3
    e52a:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    e52e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e532:	4413      	add	r3, r2
    e534:	681b      	ldr	r3, [r3, #0]
    e536:	2b00      	cmp	r3, #0
    e538:	d113      	bne.n	e562 <vTaskSuspend+0x7e>
    e53a:	68bb      	ldr	r3, [r7, #8]
    e53c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    e53e:	f04f 0201 	mov.w	r2, #1
    e542:	fa02 f303 	lsl.w	r3, r2, r3
    e546:	ea6f 0203 	mvn.w	r2, r3
    e54a:	f243 03d4 	movw	r3, #12500	; 0x30d4
    e54e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e552:	681b      	ldr	r3, [r3, #0]
    e554:	ea02 0203 	and.w	r2, r2, r3
    e558:	f243 03d4 	movw	r3, #12500	; 0x30d4
    e55c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e560:	601a      	str	r2, [r3, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    e562:	68bb      	ldr	r3, [r7, #8]
    e564:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    e566:	2b00      	cmp	r3, #0
    e568:	d005      	beq.n	e576 <vTaskSuspend+0x92>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    e56a:	68bb      	ldr	r3, [r7, #8]
    e56c:	f103 0318 	add.w	r3, r3, #24
    e570:	4618      	mov	r0, r3
    e572:	f7fe f8a7 	bl	c6c4 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    e576:	68bb      	ldr	r3, [r7, #8]
    e578:	f103 0304 	add.w	r3, r3, #4
    e57c:	f243 00b8 	movw	r0, #12472	; 0x30b8
    e580:	f2c2 0000 	movt	r0, #8192	; 0x2000
    e584:	4619      	mov	r1, r3
    e586:	f7fe f83f 	bl	c608 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    e58a:	68bb      	ldr	r3, [r7, #8]
    e58c:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
    e590:	b2db      	uxtb	r3, r3
    e592:	2b01      	cmp	r3, #1
    e594:	d104      	bne.n	e5a0 <vTaskSuspend+0xbc>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    e596:	68bb      	ldr	r3, [r7, #8]
    e598:	f04f 0200 	mov.w	r2, #0
    e59c:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    e5a0:	f003 f90a 	bl	117b8 <vPortExitCritical>

		if( xSchedulerRunning != pdFALSE )
    e5a4:	f243 03d8 	movw	r3, #12504	; 0x30d8
    e5a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e5ac:	681b      	ldr	r3, [r3, #0]
    e5ae:	2b00      	cmp	r3, #0
    e5b0:	d005      	beq.n	e5be <vTaskSuspend+0xda>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    e5b2:	f003 f8c9 	bl	11748 <vPortEnterCritical>
			{
				prvResetNextTaskUnblockTime();
    e5b6:	f001 f9a3 	bl	f900 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    e5ba:	f003 f8fd 	bl	117b8 <vPortExitCritical>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    e5be:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e5c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e5c6:	681b      	ldr	r3, [r3, #0]
    e5c8:	68ba      	ldr	r2, [r7, #8]
    e5ca:	429a      	cmp	r2, r3
    e5cc:	d139      	bne.n	e642 <vTaskSuspend+0x15e>
		{
			if( xSchedulerRunning != pdFALSE )
    e5ce:	f243 03d8 	movw	r3, #12504	; 0x30d8
    e5d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e5d6:	681b      	ldr	r3, [r3, #0]
    e5d8:	2b00      	cmp	r3, #0
    e5da:	d01c      	beq.n	e616 <vTaskSuspend+0x132>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
    e5dc:	f243 03f4 	movw	r3, #12532	; 0x30f4
    e5e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e5e4:	681b      	ldr	r3, [r3, #0]
    e5e6:	2b00      	cmp	r3, #0
    e5e8:	d009      	beq.n	e5fe <vTaskSuspend+0x11a>
    e5ea:	f04f 0328 	mov.w	r3, #40	; 0x28
    e5ee:	f383 8811 	msr	BASEPRI, r3
    e5f2:	f3bf 8f6f 	isb	sy
    e5f6:	f3bf 8f4f 	dsb	sy
    e5fa:	60fb      	str	r3, [r7, #12]
    e5fc:	e7fe      	b.n	e5fc <vTaskSuspend+0x118>
				portYIELD_WITHIN_API();
    e5fe:	f64e 5304 	movw	r3, #60676	; 0xed04
    e602:	f2ce 0300 	movt	r3, #57344	; 0xe000
    e606:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    e60a:	601a      	str	r2, [r3, #0]
    e60c:	f3bf 8f4f 	dsb	sy
    e610:	f3bf 8f6f 	isb	sy
    e614:	e015      	b.n	e642 <vTaskSuspend+0x15e>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    e616:	f243 03b8 	movw	r3, #12472	; 0x30b8
    e61a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e61e:	681a      	ldr	r2, [r3, #0]
    e620:	f243 03cc 	movw	r3, #12492	; 0x30cc
    e624:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e628:	681b      	ldr	r3, [r3, #0]
    e62a:	429a      	cmp	r2, r3
    e62c:	d107      	bne.n	e63e <vTaskSuspend+0x15a>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    e62e:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e632:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e636:	f04f 0200 	mov.w	r2, #0
    e63a:	601a      	str	r2, [r3, #0]
    e63c:	e001      	b.n	e642 <vTaskSuspend+0x15e>
				}
				else
				{
					vTaskSwitchContext();
    e63e:	f000 fc89 	bl	ef54 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    e642:	f107 0710 	add.w	r7, r7, #16
    e646:	46bd      	mov	sp, r7
    e648:	bd80      	pop	{r7, pc}
    e64a:	bf00      	nop

0000e64c <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    e64c:	b480      	push	{r7}
    e64e:	b087      	sub	sp, #28
    e650:	af00      	add	r7, sp, #0
    e652:	6078      	str	r0, [r7, #4]
	BaseType_t xReturn = pdFALSE;
    e654:	f04f 0300 	mov.w	r3, #0
    e658:	60fb      	str	r3, [r7, #12]
	const TCB_t * const pxTCB = xTask;
    e65a:	687b      	ldr	r3, [r7, #4]
    e65c:	613b      	str	r3, [r7, #16]

		/* Accesses xPendingReadyList so must be called from a critical
		section. */

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );
    e65e:	687b      	ldr	r3, [r7, #4]
    e660:	2b00      	cmp	r3, #0
    e662:	d109      	bne.n	e678 <prvTaskIsTaskSuspended+0x2c>
    e664:	f04f 0328 	mov.w	r3, #40	; 0x28
    e668:	f383 8811 	msr	BASEPRI, r3
    e66c:	f3bf 8f6f 	isb	sy
    e670:	f3bf 8f4f 	dsb	sy
    e674:	617b      	str	r3, [r7, #20]
    e676:	e7fe      	b.n	e676 <prvTaskIsTaskSuspended+0x2a>

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    e678:	693b      	ldr	r3, [r7, #16]
    e67a:	695a      	ldr	r2, [r3, #20]
    e67c:	f243 03b8 	movw	r3, #12472	; 0x30b8
    e680:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e684:	429a      	cmp	r2, r3
    e686:	d10e      	bne.n	e6a6 <prvTaskIsTaskSuspended+0x5a>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    e688:	693b      	ldr	r3, [r7, #16]
    e68a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    e68c:	f243 038c 	movw	r3, #12428	; 0x308c
    e690:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e694:	429a      	cmp	r2, r3
    e696:	d006      	beq.n	e6a6 <prvTaskIsTaskSuspended+0x5a>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    e698:	693b      	ldr	r3, [r7, #16]
    e69a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    e69c:	2b00      	cmp	r3, #0
    e69e:	d102      	bne.n	e6a6 <prvTaskIsTaskSuspended+0x5a>
				{
					xReturn = pdTRUE;
    e6a0:	f04f 0301 	mov.w	r3, #1
    e6a4:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    e6a6:	68fb      	ldr	r3, [r7, #12]
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    e6a8:	4618      	mov	r0, r3
    e6aa:	f107 071c 	add.w	r7, r7, #28
    e6ae:	46bd      	mov	sp, r7
    e6b0:	bc80      	pop	{r7}
    e6b2:	4770      	bx	lr

0000e6b4 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    e6b4:	b580      	push	{r7, lr}
    e6b6:	b084      	sub	sp, #16
    e6b8:	af00      	add	r7, sp, #0
    e6ba:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = xTaskToResume;
    e6bc:	687b      	ldr	r3, [r7, #4]
    e6be:	60bb      	str	r3, [r7, #8]

		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );
    e6c0:	687b      	ldr	r3, [r7, #4]
    e6c2:	2b00      	cmp	r3, #0
    e6c4:	d109      	bne.n	e6da <vTaskResume+0x26>
    e6c6:	f04f 0328 	mov.w	r3, #40	; 0x28
    e6ca:	f383 8811 	msr	BASEPRI, r3
    e6ce:	f3bf 8f6f 	isb	sy
    e6d2:	f3bf 8f4f 	dsb	sy
    e6d6:	60fb      	str	r3, [r7, #12]
    e6d8:	e7fe      	b.n	e6d8 <vTaskResume+0x24>

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    e6da:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e6de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e6e2:	681b      	ldr	r3, [r3, #0]
    e6e4:	68ba      	ldr	r2, [r7, #8]
    e6e6:	429a      	cmp	r2, r3
    e6e8:	d04e      	beq.n	e788 <vTaskResume+0xd4>
    e6ea:	68bb      	ldr	r3, [r7, #8]
    e6ec:	2b00      	cmp	r3, #0
    e6ee:	d04b      	beq.n	e788 <vTaskResume+0xd4>
		{
			taskENTER_CRITICAL();
    e6f0:	f003 f82a 	bl	11748 <vPortEnterCritical>
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    e6f4:	68b8      	ldr	r0, [r7, #8]
    e6f6:	f7ff ffa9 	bl	e64c <prvTaskIsTaskSuspended>
    e6fa:	4603      	mov	r3, r0
    e6fc:	2b00      	cmp	r3, #0
    e6fe:	d041      	beq.n	e784 <vTaskResume+0xd0>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    e700:	68bb      	ldr	r3, [r7, #8]
    e702:	f103 0304 	add.w	r3, r3, #4
    e706:	4618      	mov	r0, r3
    e708:	f7fd ffdc 	bl	c6c4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    e70c:	68bb      	ldr	r3, [r7, #8]
    e70e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    e710:	f04f 0201 	mov.w	r2, #1
    e714:	fa02 f203 	lsl.w	r2, r2, r3
    e718:	f243 03d4 	movw	r3, #12500	; 0x30d4
    e71c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e720:	681b      	ldr	r3, [r3, #0]
    e722:	ea42 0203 	orr.w	r2, r2, r3
    e726:	f243 03d4 	movw	r3, #12500	; 0x30d4
    e72a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e72e:	601a      	str	r2, [r3, #0]
    e730:	68bb      	ldr	r3, [r7, #8]
    e732:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    e734:	4613      	mov	r3, r2
    e736:	ea4f 0383 	mov.w	r3, r3, lsl #2
    e73a:	4413      	add	r3, r2
    e73c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    e740:	461a      	mov	r2, r3
    e742:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    e746:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e74a:	441a      	add	r2, r3
    e74c:	68bb      	ldr	r3, [r7, #8]
    e74e:	f103 0304 	add.w	r3, r3, #4
    e752:	4610      	mov	r0, r2
    e754:	4619      	mov	r1, r3
    e756:	f7fd ff57 	bl	c608 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    e75a:	68bb      	ldr	r3, [r7, #8]
    e75c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    e75e:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e762:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e766:	681b      	ldr	r3, [r3, #0]
    e768:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    e76a:	429a      	cmp	r2, r3
    e76c:	d30a      	bcc.n	e784 <vTaskResume+0xd0>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    e76e:	f64e 5304 	movw	r3, #60676	; 0xed04
    e772:	f2ce 0300 	movt	r3, #57344	; 0xe000
    e776:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    e77a:	601a      	str	r2, [r3, #0]
    e77c:	f3bf 8f4f 	dsb	sy
    e780:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    e784:	f003 f818 	bl	117b8 <vPortExitCritical>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    e788:	f107 0710 	add.w	r7, r7, #16
    e78c:	46bd      	mov	sp, r7
    e78e:	bd80      	pop	{r7, pc}

0000e790 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    e790:	b580      	push	{r7, lr}
    e792:	b08a      	sub	sp, #40	; 0x28
    e794:	af00      	add	r7, sp, #0
    e796:	6078      	str	r0, [r7, #4]
	BaseType_t xYieldRequired = pdFALSE;
    e798:	f04f 0300 	mov.w	r3, #0
    e79c:	60fb      	str	r3, [r7, #12]
	TCB_t * const pxTCB = xTaskToResume;
    e79e:	687b      	ldr	r3, [r7, #4]
    e7a0:	613b      	str	r3, [r7, #16]
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToResume );
    e7a2:	687b      	ldr	r3, [r7, #4]
    e7a4:	2b00      	cmp	r3, #0
    e7a6:	d109      	bne.n	e7bc <xTaskResumeFromISR+0x2c>
    e7a8:	f04f 0328 	mov.w	r3, #40	; 0x28
    e7ac:	f383 8811 	msr	BASEPRI, r3
    e7b0:	f3bf 8f6f 	isb	sy
    e7b4:	f3bf 8f4f 	dsb	sy
    e7b8:	61bb      	str	r3, [r7, #24]
    e7ba:	e7fe      	b.n	e7ba <xTaskResumeFromISR+0x2a>
		below the maximum system call interrupt priority.  FreeRTOS maintains a
		separate interrupt safe API to ensure interrupt entry is as fast and as
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    e7bc:	f003 f8a8 	bl	11910 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
    e7c0:	f3ef 8211 	mrs	r2, BASEPRI
    e7c4:	f04f 0328 	mov.w	r3, #40	; 0x28
    e7c8:	f383 8811 	msr	BASEPRI, r3
    e7cc:	f3bf 8f6f 	isb	sy
    e7d0:	f3bf 8f4f 	dsb	sy
    e7d4:	623a      	str	r2, [r7, #32]
    e7d6:	61fb      	str	r3, [r7, #28]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
    e7d8:	6a3b      	ldr	r3, [r7, #32]

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    e7da:	617b      	str	r3, [r7, #20]
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    e7dc:	6938      	ldr	r0, [r7, #16]
    e7de:	f7ff ff35 	bl	e64c <prvTaskIsTaskSuspended>
    e7e2:	4603      	mov	r3, r0
    e7e4:	2b00      	cmp	r3, #0
    e7e6:	d04b      	beq.n	e880 <xTaskResumeFromISR+0xf0>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    e7e8:	f243 03f4 	movw	r3, #12532	; 0x30f4
    e7ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e7f0:	681b      	ldr	r3, [r3, #0]
    e7f2:	2b00      	cmp	r3, #0
    e7f4:	d13a      	bne.n	e86c <xTaskResumeFromISR+0xdc>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    e7f6:	693b      	ldr	r3, [r7, #16]
    e7f8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    e7fa:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    e7fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e802:	681b      	ldr	r3, [r3, #0]
    e804:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    e806:	429a      	cmp	r2, r3
    e808:	d302      	bcc.n	e810 <xTaskResumeFromISR+0x80>
					{
						xYieldRequired = pdTRUE;
    e80a:	f04f 0301 	mov.w	r3, #1
    e80e:	60fb      	str	r3, [r7, #12]
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    e810:	693b      	ldr	r3, [r7, #16]
    e812:	f103 0304 	add.w	r3, r3, #4
    e816:	4618      	mov	r0, r3
    e818:	f7fd ff54 	bl	c6c4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    e81c:	693b      	ldr	r3, [r7, #16]
    e81e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    e820:	f04f 0201 	mov.w	r2, #1
    e824:	fa02 f203 	lsl.w	r2, r2, r3
    e828:	f243 03d4 	movw	r3, #12500	; 0x30d4
    e82c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e830:	681b      	ldr	r3, [r3, #0]
    e832:	ea42 0203 	orr.w	r2, r2, r3
    e836:	f243 03d4 	movw	r3, #12500	; 0x30d4
    e83a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e83e:	601a      	str	r2, [r3, #0]
    e840:	693b      	ldr	r3, [r7, #16]
    e842:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    e844:	4613      	mov	r3, r2
    e846:	ea4f 0383 	mov.w	r3, r3, lsl #2
    e84a:	4413      	add	r3, r2
    e84c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    e850:	461a      	mov	r2, r3
    e852:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    e856:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e85a:	441a      	add	r2, r3
    e85c:	693b      	ldr	r3, [r7, #16]
    e85e:	f103 0304 	add.w	r3, r3, #4
    e862:	4610      	mov	r0, r2
    e864:	4619      	mov	r1, r3
    e866:	f7fd fecf 	bl	c608 <vListInsertEnd>
    e86a:	e009      	b.n	e880 <xTaskResumeFromISR+0xf0>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    e86c:	693b      	ldr	r3, [r7, #16]
    e86e:	f103 0318 	add.w	r3, r3, #24
    e872:	f243 008c 	movw	r0, #12428	; 0x308c
    e876:	f2c2 0000 	movt	r0, #8192	; 0x2000
    e87a:	4619      	mov	r1, r3
    e87c:	f7fd fec4 	bl	c608 <vListInsertEnd>
    e880:	697b      	ldr	r3, [r7, #20]
    e882:	627b      	str	r3, [r7, #36]	; 0x24
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
    e884:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    e886:	f383 8811 	msr	BASEPRI, r3
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    e88a:	68fb      	ldr	r3, [r7, #12]
	}
    e88c:	4618      	mov	r0, r3
    e88e:	f107 0728 	add.w	r7, r7, #40	; 0x28
    e892:	46bd      	mov	sp, r7
    e894:	bd80      	pop	{r7, pc}
    e896:	bf00      	nop

0000e898 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    e898:	b580      	push	{r7, lr}
    e89a:	b086      	sub	sp, #24
    e89c:	af02      	add	r7, sp, #8
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    e89e:	f04f 0300 	mov.w	r3, #0
    e8a2:	9300      	str	r3, [sp, #0]
    e8a4:	f243 03f0 	movw	r3, #12528	; 0x30f0
    e8a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e8ac:	9301      	str	r3, [sp, #4]
    e8ae:	f24f 50b5 	movw	r0, #62901	; 0xf5b5
    e8b2:	f2c0 0000 	movt	r0, #0
    e8b6:	f24c 21e0 	movw	r1, #49888	; 0xc2e0
    e8ba:	f2c0 0101 	movt	r1, #1
    e8be:	f04f 025a 	mov.w	r2, #90	; 0x5a
    e8c2:	f04f 0300 	mov.w	r3, #0
    e8c6:	f7ff f977 	bl	dbb8 <xTaskCreate>
    e8ca:	4603      	mov	r3, r0
    e8cc:	607b      	str	r3, [r7, #4]
	}
	#endif /* configSUPPORT_STATIC_ALLOCATION */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
    e8ce:	687b      	ldr	r3, [r7, #4]
    e8d0:	2b01      	cmp	r3, #1
    e8d2:	d103      	bne.n	e8dc <vTaskStartScheduler+0x44>
		{
			xReturn = xTimerCreateTimerTask();
    e8d4:	f002 f826 	bl	10924 <xTimerCreateTimerTask>
    e8d8:	4603      	mov	r3, r0
    e8da:	607b      	str	r3, [r7, #4]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    e8dc:	687b      	ldr	r3, [r7, #4]
    e8de:	2b01      	cmp	r3, #1
    e8e0:	d122      	bne.n	e928 <vTaskStartScheduler+0x90>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
    e8e2:	f04f 0328 	mov.w	r3, #40	; 0x28
    e8e6:	f383 8811 	msr	BASEPRI, r3
    e8ea:	f3bf 8f6f 	isb	sy
    e8ee:	f3bf 8f4f 	dsb	sy
    e8f2:	60bb      	str	r3, [r7, #8]
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    e8f4:	f243 03ec 	movw	r3, #12524	; 0x30ec
    e8f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e8fc:	f04f 32ff 	mov.w	r2, #4294967295
    e900:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
    e902:	f243 03d8 	movw	r3, #12504	; 0x30d8
    e906:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e90a:	f04f 0201 	mov.w	r2, #1
    e90e:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    e910:	f243 03d0 	movw	r3, #12496	; 0x30d0
    e914:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e918:	f04f 0200 	mov.w	r2, #0
    e91c:	601a      	str	r2, [r3, #0]
		macro must be defined to configure the timer/counter used to generate
		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
		is set to 0 and the following line fails to build then ensure you do not
		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
		FreeRTOSConfig.h file. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
    e91e:	f7f2 f999 	bl	c54 <vMainConfigureTimerForRunTimeStats>

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    e922:	f002 fe5d 	bl	115e0 <xPortStartScheduler>
    e926:	e00d      	b.n	e944 <vTaskStartScheduler+0xac>
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    e928:	687b      	ldr	r3, [r7, #4]
    e92a:	f1b3 3fff 	cmp.w	r3, #4294967295
    e92e:	d109      	bne.n	e944 <vTaskStartScheduler+0xac>
    e930:	f04f 0328 	mov.w	r3, #40	; 0x28
    e934:	f383 8811 	msr	BASEPRI, r3
    e938:	f3bf 8f6f 	isb	sy
    e93c:	f3bf 8f4f 	dsb	sy
    e940:	60fb      	str	r3, [r7, #12]
    e942:	e7fe      	b.n	e942 <vTaskStartScheduler+0xaa>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    e944:	f107 0710 	add.w	r7, r7, #16
    e948:	46bd      	mov	sp, r7
    e94a:	bd80      	pop	{r7, pc}

0000e94c <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    e94c:	b580      	push	{r7, lr}
    e94e:	b082      	sub	sp, #8
    e950:	af00      	add	r7, sp, #0
    e952:	f04f 0328 	mov.w	r3, #40	; 0x28
    e956:	f383 8811 	msr	BASEPRI, r3
    e95a:	f3bf 8f6f 	isb	sy
    e95e:	f3bf 8f4f 	dsb	sy
    e962:	607b      	str	r3, [r7, #4]
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
	xSchedulerRunning = pdFALSE;
    e964:	f243 03d8 	movw	r3, #12504	; 0x30d8
    e968:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e96c:	f04f 0200 	mov.w	r2, #0
    e970:	601a      	str	r2, [r3, #0]
	vPortEndScheduler();
    e972:	f002 fecf 	bl	11714 <vPortEndScheduler>
}
    e976:	f107 0708 	add.w	r7, r7, #8
    e97a:	46bd      	mov	sp, r7
    e97c:	bd80      	pop	{r7, pc}
    e97e:	bf00      	nop

0000e980 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    e980:	b480      	push	{r7}
    e982:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    e984:	f243 03f4 	movw	r3, #12532	; 0x30f4
    e988:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e98c:	681b      	ldr	r3, [r3, #0]
    e98e:	f103 0201 	add.w	r2, r3, #1
    e992:	f243 03f4 	movw	r3, #12532	; 0x30f4
    e996:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e99a:	601a      	str	r2, [r3, #0]
}
    e99c:	46bd      	mov	sp, r7
    e99e:	bc80      	pop	{r7}
    e9a0:	4770      	bx	lr
    e9a2:	bf00      	nop

0000e9a4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    e9a4:	b580      	push	{r7, lr}
    e9a6:	b084      	sub	sp, #16
    e9a8:	af00      	add	r7, sp, #0
TCB_t *pxTCB = NULL;
    e9aa:	f04f 0300 	mov.w	r3, #0
    e9ae:	603b      	str	r3, [r7, #0]
BaseType_t xAlreadyYielded = pdFALSE;
    e9b0:	f04f 0300 	mov.w	r3, #0
    e9b4:	607b      	str	r3, [r7, #4]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
    e9b6:	f243 03f4 	movw	r3, #12532	; 0x30f4
    e9ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e9be:	681b      	ldr	r3, [r3, #0]
    e9c0:	2b00      	cmp	r3, #0
    e9c2:	d109      	bne.n	e9d8 <xTaskResumeAll+0x34>
    e9c4:	f04f 0328 	mov.w	r3, #40	; 0x28
    e9c8:	f383 8811 	msr	BASEPRI, r3
    e9cc:	f3bf 8f6f 	isb	sy
    e9d0:	f3bf 8f4f 	dsb	sy
    e9d4:	60fb      	str	r3, [r7, #12]
    e9d6:	e7fe      	b.n	e9d6 <xTaskResumeAll+0x32>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    e9d8:	f002 feb6 	bl	11748 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
    e9dc:	f243 03f4 	movw	r3, #12532	; 0x30f4
    e9e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e9e4:	681b      	ldr	r3, [r3, #0]
    e9e6:	f103 32ff 	add.w	r2, r3, #4294967295
    e9ea:	f243 03f4 	movw	r3, #12532	; 0x30f4
    e9ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e9f2:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    e9f4:	f243 03f4 	movw	r3, #12532	; 0x30f4
    e9f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e9fc:	681b      	ldr	r3, [r3, #0]
    e9fe:	2b00      	cmp	r3, #0
    ea00:	f040 8098 	bne.w	eb34 <xTaskResumeAll+0x190>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    ea04:	f243 03cc 	movw	r3, #12492	; 0x30cc
    ea08:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ea0c:	681b      	ldr	r3, [r3, #0]
    ea0e:	2b00      	cmp	r3, #0
    ea10:	f000 8090 	beq.w	eb34 <xTaskResumeAll+0x190>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    ea14:	e04a      	b.n	eaac <xTaskResumeAll+0x108>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    ea16:	f243 038c 	movw	r3, #12428	; 0x308c
    ea1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ea1e:	68db      	ldr	r3, [r3, #12]
    ea20:	68db      	ldr	r3, [r3, #12]
    ea22:	603b      	str	r3, [r7, #0]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    ea24:	683b      	ldr	r3, [r7, #0]
    ea26:	f103 0318 	add.w	r3, r3, #24
    ea2a:	4618      	mov	r0, r3
    ea2c:	f7fd fe4a 	bl	c6c4 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    ea30:	683b      	ldr	r3, [r7, #0]
    ea32:	f103 0304 	add.w	r3, r3, #4
    ea36:	4618      	mov	r0, r3
    ea38:	f7fd fe44 	bl	c6c4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    ea3c:	683b      	ldr	r3, [r7, #0]
    ea3e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    ea40:	f04f 0201 	mov.w	r2, #1
    ea44:	fa02 f203 	lsl.w	r2, r2, r3
    ea48:	f243 03d4 	movw	r3, #12500	; 0x30d4
    ea4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ea50:	681b      	ldr	r3, [r3, #0]
    ea52:	ea42 0203 	orr.w	r2, r2, r3
    ea56:	f243 03d4 	movw	r3, #12500	; 0x30d4
    ea5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ea5e:	601a      	str	r2, [r3, #0]
    ea60:	683b      	ldr	r3, [r7, #0]
    ea62:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    ea64:	4613      	mov	r3, r2
    ea66:	ea4f 0383 	mov.w	r3, r3, lsl #2
    ea6a:	4413      	add	r3, r2
    ea6c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    ea70:	461a      	mov	r2, r3
    ea72:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    ea76:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ea7a:	441a      	add	r2, r3
    ea7c:	683b      	ldr	r3, [r7, #0]
    ea7e:	f103 0304 	add.w	r3, r3, #4
    ea82:	4610      	mov	r0, r2
    ea84:	4619      	mov	r1, r3
    ea86:	f7fd fdbf 	bl	c608 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    ea8a:	683b      	ldr	r3, [r7, #0]
    ea8c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    ea8e:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    ea92:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ea96:	681b      	ldr	r3, [r3, #0]
    ea98:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    ea9a:	429a      	cmp	r2, r3
    ea9c:	d306      	bcc.n	eaac <xTaskResumeAll+0x108>
					{
						xYieldPending = pdTRUE;
    ea9e:	f243 03e0 	movw	r3, #12512	; 0x30e0
    eaa2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    eaa6:	f04f 0201 	mov.w	r2, #1
    eaaa:	601a      	str	r2, [r3, #0]
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    eaac:	f243 038c 	movw	r3, #12428	; 0x308c
    eab0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    eab4:	681b      	ldr	r3, [r3, #0]
    eab6:	2b00      	cmp	r3, #0
    eab8:	d1ad      	bne.n	ea16 <xTaskResumeAll+0x72>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    eaba:	683b      	ldr	r3, [r7, #0]
    eabc:	2b00      	cmp	r3, #0
    eabe:	d001      	beq.n	eac4 <xTaskResumeAll+0x120>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    eac0:	f000 ff1e 	bl	f900 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    eac4:	f243 03dc 	movw	r3, #12508	; 0x30dc
    eac8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    eacc:	681b      	ldr	r3, [r3, #0]
    eace:	60bb      	str	r3, [r7, #8]

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    ead0:	68bb      	ldr	r3, [r7, #8]
    ead2:	2b00      	cmp	r3, #0
    ead4:	d019      	beq.n	eb0a <xTaskResumeAll+0x166>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    ead6:	f000 f93b 	bl	ed50 <xTaskIncrementTick>
    eada:	4603      	mov	r3, r0
    eadc:	2b00      	cmp	r3, #0
    eade:	d006      	beq.n	eaee <xTaskResumeAll+0x14a>
							{
								xYieldPending = pdTRUE;
    eae0:	f243 03e0 	movw	r3, #12512	; 0x30e0
    eae4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    eae8:	f04f 0201 	mov.w	r2, #1
    eaec:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    eaee:	68bb      	ldr	r3, [r7, #8]
    eaf0:	f103 33ff 	add.w	r3, r3, #4294967295
    eaf4:	60bb      	str	r3, [r7, #8]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    eaf6:	68bb      	ldr	r3, [r7, #8]
    eaf8:	2b00      	cmp	r3, #0
    eafa:	d1ec      	bne.n	ead6 <xTaskResumeAll+0x132>

						uxPendedTicks = 0;
    eafc:	f243 03dc 	movw	r3, #12508	; 0x30dc
    eb00:	f2c2 0300 	movt	r3, #8192	; 0x2000
    eb04:	f04f 0200 	mov.w	r2, #0
    eb08:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    eb0a:	f243 03e0 	movw	r3, #12512	; 0x30e0
    eb0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    eb12:	681b      	ldr	r3, [r3, #0]
    eb14:	2b00      	cmp	r3, #0
    eb16:	d00d      	beq.n	eb34 <xTaskResumeAll+0x190>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    eb18:	f04f 0301 	mov.w	r3, #1
    eb1c:	607b      	str	r3, [r7, #4]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    eb1e:	f64e 5304 	movw	r3, #60676	; 0xed04
    eb22:	f2ce 0300 	movt	r3, #57344	; 0xe000
    eb26:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    eb2a:	601a      	str	r2, [r3, #0]
    eb2c:	f3bf 8f4f 	dsb	sy
    eb30:	f3bf 8f6f 	isb	sy
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    eb34:	f002 fe40 	bl	117b8 <vPortExitCritical>

	return xAlreadyYielded;
    eb38:	687b      	ldr	r3, [r7, #4]
}
    eb3a:	4618      	mov	r0, r3
    eb3c:	f107 0710 	add.w	r7, r7, #16
    eb40:	46bd      	mov	sp, r7
    eb42:	bd80      	pop	{r7, pc}

0000eb44 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    eb44:	b480      	push	{r7}
    eb46:	b083      	sub	sp, #12
    eb48:	af00      	add	r7, sp, #0
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
    eb4a:	f243 03d0 	movw	r3, #12496	; 0x30d0
    eb4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    eb52:	681b      	ldr	r3, [r3, #0]
    eb54:	607b      	str	r3, [r7, #4]
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
    eb56:	687b      	ldr	r3, [r7, #4]
}
    eb58:	4618      	mov	r0, r3
    eb5a:	f107 070c 	add.w	r7, r7, #12
    eb5e:	46bd      	mov	sp, r7
    eb60:	bc80      	pop	{r7}
    eb62:	4770      	bx	lr

0000eb64 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    eb64:	b580      	push	{r7, lr}
    eb66:	b082      	sub	sp, #8
    eb68:	af00      	add	r7, sp, #0
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    eb6a:	f002 fed1 	bl	11910 <vPortValidateInterruptPriority>

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    eb6e:	f04f 0300 	mov.w	r3, #0
    eb72:	607b      	str	r3, [r7, #4]
	{
		xReturn = xTickCount;
    eb74:	f243 03d0 	movw	r3, #12496	; 0x30d0
    eb78:	f2c2 0300 	movt	r3, #8192	; 0x2000
    eb7c:	681b      	ldr	r3, [r3, #0]
    eb7e:	603b      	str	r3, [r7, #0]
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    eb80:	683b      	ldr	r3, [r7, #0]
}
    eb82:	4618      	mov	r0, r3
    eb84:	f107 0708 	add.w	r7, r7, #8
    eb88:	46bd      	mov	sp, r7
    eb8a:	bd80      	pop	{r7, pc}

0000eb8c <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    eb8c:	b480      	push	{r7}
    eb8e:	af00      	add	r7, sp, #0
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    eb90:	f243 03cc 	movw	r3, #12492	; 0x30cc
    eb94:	f2c2 0300 	movt	r3, #8192	; 0x2000
    eb98:	681b      	ldr	r3, [r3, #0]
}
    eb9a:	4618      	mov	r0, r3
    eb9c:	46bd      	mov	sp, r7
    eb9e:	bc80      	pop	{r7}
    eba0:	4770      	bx	lr
    eba2:	bf00      	nop

0000eba4 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    eba4:	b480      	push	{r7}
    eba6:	b085      	sub	sp, #20
    eba8:	af00      	add	r7, sp, #0
    ebaa:	6078      	str	r0, [r7, #4]
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    ebac:	687b      	ldr	r3, [r7, #4]
    ebae:	2b00      	cmp	r3, #0
    ebb0:	d105      	bne.n	ebbe <pcTaskGetName+0x1a>
    ebb2:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    ebb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ebba:	681b      	ldr	r3, [r3, #0]
    ebbc:	e000      	b.n	ebc0 <pcTaskGetName+0x1c>
    ebbe:	687b      	ldr	r3, [r7, #4]
    ebc0:	60bb      	str	r3, [r7, #8]
	configASSERT( pxTCB );
    ebc2:	68bb      	ldr	r3, [r7, #8]
    ebc4:	2b00      	cmp	r3, #0
    ebc6:	d109      	bne.n	ebdc <pcTaskGetName+0x38>
    ebc8:	f04f 0328 	mov.w	r3, #40	; 0x28
    ebcc:	f383 8811 	msr	BASEPRI, r3
    ebd0:	f3bf 8f6f 	isb	sy
    ebd4:	f3bf 8f4f 	dsb	sy
    ebd8:	60fb      	str	r3, [r7, #12]
    ebda:	e7fe      	b.n	ebda <pcTaskGetName+0x36>
	return &( pxTCB->pcTaskName[ 0 ] );
    ebdc:	68bb      	ldr	r3, [r7, #8]
    ebde:	f103 0334 	add.w	r3, r3, #52	; 0x34
}
    ebe2:	4618      	mov	r0, r3
    ebe4:	f107 0714 	add.w	r7, r7, #20
    ebe8:	46bd      	mov	sp, r7
    ebea:	bc80      	pop	{r7}
    ebec:	4770      	bx	lr
    ebee:	bf00      	nop

0000ebf0 <uxTaskGetSystemState>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
	{
    ebf0:	b580      	push	{r7, lr}
    ebf2:	b086      	sub	sp, #24
    ebf4:	af00      	add	r7, sp, #0
    ebf6:	60f8      	str	r0, [r7, #12]
    ebf8:	60b9      	str	r1, [r7, #8]
    ebfa:	607a      	str	r2, [r7, #4]
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
    ebfc:	f04f 0300 	mov.w	r3, #0
    ec00:	613b      	str	r3, [r7, #16]
    ec02:	f04f 0305 	mov.w	r3, #5
    ec06:	617b      	str	r3, [r7, #20]

		vTaskSuspendAll();
    ec08:	f7ff feba 	bl	e980 <vTaskSuspendAll>
		{
			/* Is there a space in the array for each task in the system? */
			if( uxArraySize >= uxCurrentNumberOfTasks )
    ec0c:	f243 03cc 	movw	r3, #12492	; 0x30cc
    ec10:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ec14:	681b      	ldr	r3, [r3, #0]
    ec16:	68ba      	ldr	r2, [r7, #8]
    ec18:	429a      	cmp	r2, r3
    ec1a:	f0c0 8091 	bcc.w	ed40 <uxTaskGetSystemState+0x150>
			{
				/* Fill in an TaskStatus_t structure with information on each
				task in the Ready state. */
				do
				{
					uxQueue--;
    ec1e:	697b      	ldr	r3, [r7, #20]
    ec20:	f103 33ff 	add.w	r3, r3, #4294967295
    ec24:	617b      	str	r3, [r7, #20]
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
    ec26:	693a      	ldr	r2, [r7, #16]
    ec28:	4613      	mov	r3, r2
    ec2a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    ec2e:	4413      	add	r3, r2
    ec30:	ea4f 0383 	mov.w	r3, r3, lsl #2
    ec34:	461a      	mov	r2, r3
    ec36:	68fb      	ldr	r3, [r7, #12]
    ec38:	eb02 0103 	add.w	r1, r2, r3
    ec3c:	697a      	ldr	r2, [r7, #20]
    ec3e:	4613      	mov	r3, r2
    ec40:	ea4f 0383 	mov.w	r3, r3, lsl #2
    ec44:	4413      	add	r3, r2
    ec46:	ea4f 0383 	mov.w	r3, r3, lsl #2
    ec4a:	461a      	mov	r2, r3
    ec4c:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    ec50:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ec54:	4413      	add	r3, r2
    ec56:	4608      	mov	r0, r1
    ec58:	4619      	mov	r1, r3
    ec5a:	f04f 0201 	mov.w	r2, #1
    ec5e:	f000 fdc3 	bl	f7e8 <prvListTasksWithinSingleList>
    ec62:	4603      	mov	r3, r0
    ec64:	693a      	ldr	r2, [r7, #16]
    ec66:	4413      	add	r3, r2
    ec68:	613b      	str	r3, [r7, #16]

				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    ec6a:	697b      	ldr	r3, [r7, #20]
    ec6c:	2b00      	cmp	r3, #0
    ec6e:	d1d6      	bne.n	ec1e <uxTaskGetSystemState+0x2e>

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
    ec70:	693a      	ldr	r2, [r7, #16]
    ec72:	4613      	mov	r3, r2
    ec74:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    ec78:	4413      	add	r3, r2
    ec7a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    ec7e:	461a      	mov	r2, r3
    ec80:	68fb      	ldr	r3, [r7, #12]
    ec82:	441a      	add	r2, r3
    ec84:	f243 0384 	movw	r3, #12420	; 0x3084
    ec88:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ec8c:	681b      	ldr	r3, [r3, #0]
    ec8e:	4610      	mov	r0, r2
    ec90:	4619      	mov	r1, r3
    ec92:	f04f 0202 	mov.w	r2, #2
    ec96:	f000 fda7 	bl	f7e8 <prvListTasksWithinSingleList>
    ec9a:	4603      	mov	r3, r0
    ec9c:	693a      	ldr	r2, [r7, #16]
    ec9e:	4413      	add	r3, r2
    eca0:	613b      	str	r3, [r7, #16]
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
    eca2:	693a      	ldr	r2, [r7, #16]
    eca4:	4613      	mov	r3, r2
    eca6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    ecaa:	4413      	add	r3, r2
    ecac:	ea4f 0383 	mov.w	r3, r3, lsl #2
    ecb0:	461a      	mov	r2, r3
    ecb2:	68fb      	ldr	r3, [r7, #12]
    ecb4:	441a      	add	r2, r3
    ecb6:	f243 0388 	movw	r3, #12424	; 0x3088
    ecba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ecbe:	681b      	ldr	r3, [r3, #0]
    ecc0:	4610      	mov	r0, r2
    ecc2:	4619      	mov	r1, r3
    ecc4:	f04f 0202 	mov.w	r2, #2
    ecc8:	f000 fd8e 	bl	f7e8 <prvListTasksWithinSingleList>
    eccc:	4603      	mov	r3, r0
    ecce:	693a      	ldr	r2, [r7, #16]
    ecd0:	4413      	add	r3, r2
    ecd2:	613b      	str	r3, [r7, #16]

				#if( INCLUDE_vTaskDelete == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task that has been deleted but not yet cleaned up. */
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
    ecd4:	693a      	ldr	r2, [r7, #16]
    ecd6:	4613      	mov	r3, r2
    ecd8:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    ecdc:	4413      	add	r3, r2
    ecde:	ea4f 0383 	mov.w	r3, r3, lsl #2
    ece2:	461a      	mov	r2, r3
    ece4:	68fb      	ldr	r3, [r7, #12]
    ece6:	4413      	add	r3, r2
    ece8:	4618      	mov	r0, r3
    ecea:	f243 01a0 	movw	r1, #12448	; 0x30a0
    ecee:	f2c2 0100 	movt	r1, #8192	; 0x2000
    ecf2:	f04f 0204 	mov.w	r2, #4
    ecf6:	f000 fd77 	bl	f7e8 <prvListTasksWithinSingleList>
    ecfa:	4603      	mov	r3, r0
    ecfc:	693a      	ldr	r2, [r7, #16]
    ecfe:	4413      	add	r3, r2
    ed00:	613b      	str	r3, [r7, #16]

				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task in the Suspended state. */
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
    ed02:	693a      	ldr	r2, [r7, #16]
    ed04:	4613      	mov	r3, r2
    ed06:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    ed0a:	4413      	add	r3, r2
    ed0c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    ed10:	461a      	mov	r2, r3
    ed12:	68fb      	ldr	r3, [r7, #12]
    ed14:	4413      	add	r3, r2
    ed16:	4618      	mov	r0, r3
    ed18:	f243 01b8 	movw	r1, #12472	; 0x30b8
    ed1c:	f2c2 0100 	movt	r1, #8192	; 0x2000
    ed20:	f04f 0203 	mov.w	r2, #3
    ed24:	f000 fd60 	bl	f7e8 <prvListTasksWithinSingleList>
    ed28:	4603      	mov	r3, r0
    ed2a:	693a      	ldr	r2, [r7, #16]
    ed2c:	4413      	add	r3, r2
    ed2e:	613b      	str	r3, [r7, #16]
				}
				#endif

				#if ( configGENERATE_RUN_TIME_STATS == 1)
				{
					if( pulTotalRunTime != NULL )
    ed30:	687b      	ldr	r3, [r7, #4]
    ed32:	2b00      	cmp	r3, #0
    ed34:	d004      	beq.n	ed40 <uxTaskGetSystemState+0x150>
					{
						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
						#else
							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
    ed36:	f7f1 ffa1 	bl	c7c <ulGetRunTimeCounterValue>
    ed3a:	4602      	mov	r2, r0
    ed3c:	687b      	ldr	r3, [r7, #4]
    ed3e:	601a      	str	r2, [r3, #0]
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		( void ) xTaskResumeAll();
    ed40:	f7ff fe30 	bl	e9a4 <xTaskResumeAll>

		return uxTask;
    ed44:	693b      	ldr	r3, [r7, #16]
	}
    ed46:	4618      	mov	r0, r3
    ed48:	f107 0718 	add.w	r7, r7, #24
    ed4c:	46bd      	mov	sp, r7
    ed4e:	bd80      	pop	{r7, pc}

0000ed50 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    ed50:	b580      	push	{r7, lr}
    ed52:	b086      	sub	sp, #24
    ed54:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    ed56:	f04f 0300 	mov.w	r3, #0
    ed5a:	60bb      	str	r3, [r7, #8]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    ed5c:	f243 03f4 	movw	r3, #12532	; 0x30f4
    ed60:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ed64:	681b      	ldr	r3, [r3, #0]
    ed66:	2b00      	cmp	r3, #0
    ed68:	f040 80d5 	bne.w	ef16 <xTaskIncrementTick+0x1c6>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    ed6c:	f243 03d0 	movw	r3, #12496	; 0x30d0
    ed70:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ed74:	681b      	ldr	r3, [r3, #0]
    ed76:	f103 0301 	add.w	r3, r3, #1
    ed7a:	60fb      	str	r3, [r7, #12]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    ed7c:	f243 03d0 	movw	r3, #12496	; 0x30d0
    ed80:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ed84:	68fa      	ldr	r2, [r7, #12]
    ed86:	601a      	str	r2, [r3, #0]

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    ed88:	68fb      	ldr	r3, [r7, #12]
    ed8a:	2b00      	cmp	r3, #0
    ed8c:	d135      	bne.n	edfa <xTaskIncrementTick+0xaa>
		{
			taskSWITCH_DELAYED_LISTS();
    ed8e:	f243 0384 	movw	r3, #12420	; 0x3084
    ed92:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ed96:	681b      	ldr	r3, [r3, #0]
    ed98:	681b      	ldr	r3, [r3, #0]
    ed9a:	2b00      	cmp	r3, #0
    ed9c:	d009      	beq.n	edb2 <xTaskIncrementTick+0x62>
    ed9e:	f04f 0328 	mov.w	r3, #40	; 0x28
    eda2:	f383 8811 	msr	BASEPRI, r3
    eda6:	f3bf 8f6f 	isb	sy
    edaa:	f3bf 8f4f 	dsb	sy
    edae:	617b      	str	r3, [r7, #20]
    edb0:	e7fe      	b.n	edb0 <xTaskIncrementTick+0x60>
    edb2:	f243 0384 	movw	r3, #12420	; 0x3084
    edb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    edba:	681b      	ldr	r3, [r3, #0]
    edbc:	613b      	str	r3, [r7, #16]
    edbe:	f243 0388 	movw	r3, #12424	; 0x3088
    edc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    edc6:	681a      	ldr	r2, [r3, #0]
    edc8:	f243 0384 	movw	r3, #12420	; 0x3084
    edcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    edd0:	601a      	str	r2, [r3, #0]
    edd2:	f243 0388 	movw	r3, #12424	; 0x3088
    edd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    edda:	693a      	ldr	r2, [r7, #16]
    eddc:	601a      	str	r2, [r3, #0]
    edde:	f243 03e4 	movw	r3, #12516	; 0x30e4
    ede2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ede6:	681b      	ldr	r3, [r3, #0]
    ede8:	f103 0201 	add.w	r2, r3, #1
    edec:	f243 03e4 	movw	r3, #12516	; 0x30e4
    edf0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    edf4:	601a      	str	r2, [r3, #0]
    edf6:	f000 fd83 	bl	f900 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    edfa:	f243 03ec 	movw	r3, #12524	; 0x30ec
    edfe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ee02:	681b      	ldr	r3, [r3, #0]
    ee04:	68fa      	ldr	r2, [r7, #12]
    ee06:	429a      	cmp	r2, r3
    ee08:	d36c      	bcc.n	eee4 <xTaskIncrementTick+0x194>
    ee0a:	e000      	b.n	ee0e <xTaskIncrementTick+0xbe>
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
    ee0c:	bf00      	nop
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    ee0e:	f243 0384 	movw	r3, #12420	; 0x3084
    ee12:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ee16:	681b      	ldr	r3, [r3, #0]
    ee18:	681b      	ldr	r3, [r3, #0]
    ee1a:	2b00      	cmp	r3, #0
    ee1c:	d107      	bne.n	ee2e <xTaskIncrementTick+0xde>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    ee1e:	f243 03ec 	movw	r3, #12524	; 0x30ec
    ee22:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ee26:	f04f 32ff 	mov.w	r2, #4294967295
    ee2a:	601a      	str	r2, [r3, #0]
					break;
    ee2c:	e05a      	b.n	eee4 <xTaskIncrementTick+0x194>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    ee2e:	f243 0384 	movw	r3, #12420	; 0x3084
    ee32:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ee36:	681b      	ldr	r3, [r3, #0]
    ee38:	68db      	ldr	r3, [r3, #12]
    ee3a:	68db      	ldr	r3, [r3, #12]
    ee3c:	603b      	str	r3, [r7, #0]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    ee3e:	683b      	ldr	r3, [r7, #0]
    ee40:	685b      	ldr	r3, [r3, #4]
    ee42:	607b      	str	r3, [r7, #4]

					if( xConstTickCount < xItemValue )
    ee44:	68fa      	ldr	r2, [r7, #12]
    ee46:	687b      	ldr	r3, [r7, #4]
    ee48:	429a      	cmp	r2, r3
    ee4a:	d206      	bcs.n	ee5a <xTaskIncrementTick+0x10a>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    ee4c:	f243 03ec 	movw	r3, #12524	; 0x30ec
    ee50:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ee54:	687a      	ldr	r2, [r7, #4]
    ee56:	601a      	str	r2, [r3, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
    ee58:	e044      	b.n	eee4 <xTaskIncrementTick+0x194>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    ee5a:	683b      	ldr	r3, [r7, #0]
    ee5c:	f103 0304 	add.w	r3, r3, #4
    ee60:	4618      	mov	r0, r3
    ee62:	f7fd fc2f 	bl	c6c4 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    ee66:	683b      	ldr	r3, [r7, #0]
    ee68:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    ee6a:	2b00      	cmp	r3, #0
    ee6c:	d005      	beq.n	ee7a <xTaskIncrementTick+0x12a>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    ee6e:	683b      	ldr	r3, [r7, #0]
    ee70:	f103 0318 	add.w	r3, r3, #24
    ee74:	4618      	mov	r0, r3
    ee76:	f7fd fc25 	bl	c6c4 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    ee7a:	683b      	ldr	r3, [r7, #0]
    ee7c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    ee7e:	f04f 0201 	mov.w	r2, #1
    ee82:	fa02 f203 	lsl.w	r2, r2, r3
    ee86:	f243 03d4 	movw	r3, #12500	; 0x30d4
    ee8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ee8e:	681b      	ldr	r3, [r3, #0]
    ee90:	ea42 0203 	orr.w	r2, r2, r3
    ee94:	f243 03d4 	movw	r3, #12500	; 0x30d4
    ee98:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ee9c:	601a      	str	r2, [r3, #0]
    ee9e:	683b      	ldr	r3, [r7, #0]
    eea0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    eea2:	4613      	mov	r3, r2
    eea4:	ea4f 0383 	mov.w	r3, r3, lsl #2
    eea8:	4413      	add	r3, r2
    eeaa:	ea4f 0383 	mov.w	r3, r3, lsl #2
    eeae:	461a      	mov	r2, r3
    eeb0:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    eeb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    eeb8:	441a      	add	r2, r3
    eeba:	683b      	ldr	r3, [r7, #0]
    eebc:	f103 0304 	add.w	r3, r3, #4
    eec0:	4610      	mov	r0, r2
    eec2:	4619      	mov	r1, r3
    eec4:	f7fd fba0 	bl	c608 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    eec8:	683b      	ldr	r3, [r7, #0]
    eeca:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    eecc:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    eed0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    eed4:	681b      	ldr	r3, [r3, #0]
    eed6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    eed8:	429a      	cmp	r2, r3
    eeda:	d397      	bcc.n	ee0c <xTaskIncrementTick+0xbc>
						{
							xSwitchRequired = pdTRUE;
    eedc:	f04f 0301 	mov.w	r3, #1
    eee0:	60bb      	str	r3, [r7, #8]
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
    eee2:	e794      	b.n	ee0e <xTaskIncrementTick+0xbe>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    eee4:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    eee8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    eeec:	681b      	ldr	r3, [r3, #0]
    eeee:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    eef0:	4613      	mov	r3, r2
    eef2:	ea4f 0383 	mov.w	r3, r3, lsl #2
    eef6:	4413      	add	r3, r2
    eef8:	ea4f 0383 	mov.w	r3, r3, lsl #2
    eefc:	461a      	mov	r2, r3
    eefe:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    ef02:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ef06:	4413      	add	r3, r2
    ef08:	681b      	ldr	r3, [r3, #0]
    ef0a:	2b01      	cmp	r3, #1
    ef0c:	d910      	bls.n	ef30 <xTaskIncrementTick+0x1e0>
			{
				xSwitchRequired = pdTRUE;
    ef0e:	f04f 0301 	mov.w	r3, #1
    ef12:	60bb      	str	r3, [r7, #8]
    ef14:	e00d      	b.n	ef32 <xTaskIncrementTick+0x1e2>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    ef16:	f243 03dc 	movw	r3, #12508	; 0x30dc
    ef1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ef1e:	681b      	ldr	r3, [r3, #0]
    ef20:	f103 0201 	add.w	r2, r3, #1
    ef24:	f243 03dc 	movw	r3, #12508	; 0x30dc
    ef28:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ef2c:	601a      	str	r2, [r3, #0]
    ef2e:	e000      	b.n	ef32 <xTaskIncrementTick+0x1e2>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
    ef30:	bf00      	nop
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    ef32:	f243 03e0 	movw	r3, #12512	; 0x30e0
    ef36:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ef3a:	681b      	ldr	r3, [r3, #0]
    ef3c:	2b00      	cmp	r3, #0
    ef3e:	d002      	beq.n	ef46 <xTaskIncrementTick+0x1f6>
		{
			xSwitchRequired = pdTRUE;
    ef40:	f04f 0301 	mov.w	r3, #1
    ef44:	60bb      	str	r3, [r7, #8]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    ef46:	68bb      	ldr	r3, [r7, #8]
}
    ef48:	4618      	mov	r0, r3
    ef4a:	f107 0718 	add.w	r7, r7, #24
    ef4e:	46bd      	mov	sp, r7
    ef50:	bd80      	pop	{r7, pc}
    ef52:	bf00      	nop

0000ef54 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    ef54:	b580      	push	{r7, lr}
    ef56:	b088      	sub	sp, #32
    ef58:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    ef5a:	f243 03f4 	movw	r3, #12532	; 0x30f4
    ef5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ef62:	681b      	ldr	r3, [r3, #0]
    ef64:	2b00      	cmp	r3, #0
    ef66:	d007      	beq.n	ef78 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    ef68:	f243 03e0 	movw	r3, #12512	; 0x30e0
    ef6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ef70:	f04f 0201 	mov.w	r2, #1
    ef74:	601a      	str	r2, [r3, #0]
    ef76:	e0bc      	b.n	f0f2 <vTaskSwitchContext+0x19e>
	}
	else
	{
		xYieldPending = pdFALSE;
    ef78:	f243 03e0 	movw	r3, #12512	; 0x30e0
    ef7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ef80:	f04f 0200 	mov.w	r2, #0
    ef84:	601a      	str	r2, [r3, #0]
		#if ( configGENERATE_RUN_TIME_STATS == 1 )
		{
				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
				#else
					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
    ef86:	f7f1 fe79 	bl	c7c <ulGetRunTimeCounterValue>
    ef8a:	4602      	mov	r2, r0
    ef8c:	f243 03fc 	movw	r3, #12540	; 0x30fc
    ef90:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ef94:	601a      	str	r2, [r3, #0]
				stored in ulTaskSwitchedInTime.  Note that there is no overflow
				protection here so count values are only valid until the timer
				overflows.  The guard against negative values is to protect
				against suspect run time stat counter implementations - which
				are provided by the application, not the kernel. */
				if( ulTotalRunTime > ulTaskSwitchedInTime )
    ef96:	f243 03fc 	movw	r3, #12540	; 0x30fc
    ef9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ef9e:	681a      	ldr	r2, [r3, #0]
    efa0:	f243 03f8 	movw	r3, #12536	; 0x30f8
    efa4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    efa8:	681b      	ldr	r3, [r3, #0]
    efaa:	429a      	cmp	r2, r3
    efac:	d913      	bls.n	efd6 <vTaskSwitchContext+0x82>
				{
					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
    efae:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    efb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    efb6:	681a      	ldr	r2, [r3, #0]
    efb8:	6d11      	ldr	r1, [r2, #80]	; 0x50
    efba:	f243 03fc 	movw	r3, #12540	; 0x30fc
    efbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    efc2:	6818      	ldr	r0, [r3, #0]
    efc4:	f243 03f8 	movw	r3, #12536	; 0x30f8
    efc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    efcc:	681b      	ldr	r3, [r3, #0]
    efce:	ebc3 0300 	rsb	r3, r3, r0
    efd2:	440b      	add	r3, r1
    efd4:	6513      	str	r3, [r2, #80]	; 0x50
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				ulTaskSwitchedInTime = ulTotalRunTime;
    efd6:	f243 03fc 	movw	r3, #12540	; 0x30fc
    efda:	f2c2 0300 	movt	r3, #8192	; 0x2000
    efde:	681a      	ldr	r2, [r3, #0]
    efe0:	f243 03f8 	movw	r3, #12536	; 0x30f8
    efe4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    efe8:	601a      	str	r2, [r3, #0]
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();
    efea:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    efee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    eff2:	681b      	ldr	r3, [r3, #0]
    eff4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    eff6:	607b      	str	r3, [r7, #4]
    eff8:	f04f 33a5 	mov.w	r3, #2779096485	; 0xa5a5a5a5
    effc:	60bb      	str	r3, [r7, #8]
    effe:	687b      	ldr	r3, [r7, #4]
    f000:	681a      	ldr	r2, [r3, #0]
    f002:	68bb      	ldr	r3, [r7, #8]
    f004:	429a      	cmp	r2, r3
    f006:	d114      	bne.n	f032 <vTaskSwitchContext+0xde>
    f008:	687b      	ldr	r3, [r7, #4]
    f00a:	f103 0304 	add.w	r3, r3, #4
    f00e:	681a      	ldr	r2, [r3, #0]
    f010:	68bb      	ldr	r3, [r7, #8]
    f012:	429a      	cmp	r2, r3
    f014:	d10d      	bne.n	f032 <vTaskSwitchContext+0xde>
    f016:	687b      	ldr	r3, [r7, #4]
    f018:	f103 0308 	add.w	r3, r3, #8
    f01c:	681a      	ldr	r2, [r3, #0]
    f01e:	68bb      	ldr	r3, [r7, #8]
    f020:	429a      	cmp	r2, r3
    f022:	d106      	bne.n	f032 <vTaskSwitchContext+0xde>
    f024:	687b      	ldr	r3, [r7, #4]
    f026:	f103 030c 	add.w	r3, r3, #12
    f02a:	681a      	ldr	r2, [r3, #0]
    f02c:	68bb      	ldr	r3, [r7, #8]
    f02e:	429a      	cmp	r2, r3
    f030:	d00f      	beq.n	f052 <vTaskSwitchContext+0xfe>
    f032:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    f036:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f03a:	681a      	ldr	r2, [r3, #0]
    f03c:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    f040:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f044:	681b      	ldr	r3, [r3, #0]
    f046:	f103 0334 	add.w	r3, r3, #52	; 0x34
    f04a:	4610      	mov	r0, r2
    f04c:	4619      	mov	r1, r3
    f04e:	f7f1 fdcd 	bl	bec <vApplicationStackOverflowHook>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    f052:	f243 03d4 	movw	r3, #12500	; 0x30d4
    f056:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f05a:	681b      	ldr	r3, [r3, #0]
    f05c:	617b      	str	r3, [r7, #20]
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
	{
	uint8_t ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
    f05e:	697b      	ldr	r3, [r7, #20]
    f060:	fab3 f383 	clz	r3, r3
    f064:	76fb      	strb	r3, [r7, #27]
		return ucReturn;
    f066:	7efb      	ldrb	r3, [r7, #27]
    f068:	f1c3 031f 	rsb	r3, r3, #31
    f06c:	60fb      	str	r3, [r7, #12]
    f06e:	68fa      	ldr	r2, [r7, #12]
    f070:	4613      	mov	r3, r2
    f072:	ea4f 0383 	mov.w	r3, r3, lsl #2
    f076:	4413      	add	r3, r2
    f078:	ea4f 0383 	mov.w	r3, r3, lsl #2
    f07c:	461a      	mov	r2, r3
    f07e:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    f082:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f086:	4413      	add	r3, r2
    f088:	681b      	ldr	r3, [r3, #0]
    f08a:	2b00      	cmp	r3, #0
    f08c:	d109      	bne.n	f0a2 <vTaskSwitchContext+0x14e>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
    f08e:	f04f 0328 	mov.w	r3, #40	; 0x28
    f092:	f383 8811 	msr	BASEPRI, r3
    f096:	f3bf 8f6f 	isb	sy
    f09a:	f3bf 8f4f 	dsb	sy
    f09e:	61fb      	str	r3, [r7, #28]
    f0a0:	e7fe      	b.n	f0a0 <vTaskSwitchContext+0x14c>
    f0a2:	68fa      	ldr	r2, [r7, #12]
    f0a4:	4613      	mov	r3, r2
    f0a6:	ea4f 0383 	mov.w	r3, r3, lsl #2
    f0aa:	4413      	add	r3, r2
    f0ac:	ea4f 0383 	mov.w	r3, r3, lsl #2
    f0b0:	461a      	mov	r2, r3
    f0b2:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    f0b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f0ba:	4413      	add	r3, r2
    f0bc:	613b      	str	r3, [r7, #16]
    f0be:	693b      	ldr	r3, [r7, #16]
    f0c0:	685b      	ldr	r3, [r3, #4]
    f0c2:	685a      	ldr	r2, [r3, #4]
    f0c4:	693b      	ldr	r3, [r7, #16]
    f0c6:	605a      	str	r2, [r3, #4]
    f0c8:	693b      	ldr	r3, [r7, #16]
    f0ca:	685a      	ldr	r2, [r3, #4]
    f0cc:	693b      	ldr	r3, [r7, #16]
    f0ce:	f103 0308 	add.w	r3, r3, #8
    f0d2:	429a      	cmp	r2, r3
    f0d4:	d104      	bne.n	f0e0 <vTaskSwitchContext+0x18c>
    f0d6:	693b      	ldr	r3, [r7, #16]
    f0d8:	685b      	ldr	r3, [r3, #4]
    f0da:	685a      	ldr	r2, [r3, #4]
    f0dc:	693b      	ldr	r3, [r7, #16]
    f0de:	605a      	str	r2, [r3, #4]
    f0e0:	693b      	ldr	r3, [r7, #16]
    f0e2:	685b      	ldr	r3, [r3, #4]
    f0e4:	68db      	ldr	r3, [r3, #12]
    f0e6:	461a      	mov	r2, r3
    f0e8:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    f0ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f0f0:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    f0f2:	f107 0720 	add.w	r7, r7, #32
    f0f6:	46bd      	mov	sp, r7
    f0f8:	bd80      	pop	{r7, pc}
    f0fa:	bf00      	nop

0000f0fc <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    f0fc:	b580      	push	{r7, lr}
    f0fe:	b084      	sub	sp, #16
    f100:	af00      	add	r7, sp, #0
    f102:	6078      	str	r0, [r7, #4]
    f104:	6039      	str	r1, [r7, #0]
	configASSERT( pxEventList );
    f106:	687b      	ldr	r3, [r7, #4]
    f108:	2b00      	cmp	r3, #0
    f10a:	d109      	bne.n	f120 <vTaskPlaceOnEventList+0x24>
    f10c:	f04f 0328 	mov.w	r3, #40	; 0x28
    f110:	f383 8811 	msr	BASEPRI, r3
    f114:	f3bf 8f6f 	isb	sy
    f118:	f3bf 8f4f 	dsb	sy
    f11c:	60fb      	str	r3, [r7, #12]
    f11e:	e7fe      	b.n	f11e <vTaskPlaceOnEventList+0x22>

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    f120:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    f124:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f128:	681b      	ldr	r3, [r3, #0]
    f12a:	f103 0318 	add.w	r3, r3, #24
    f12e:	6878      	ldr	r0, [r7, #4]
    f130:	4619      	mov	r1, r3
    f132:	f7fd fa8d 	bl	c650 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    f136:	6838      	ldr	r0, [r7, #0]
    f138:	f04f 0101 	mov.w	r1, #1
    f13c:	f001 fb6a 	bl	10814 <prvAddCurrentTaskToDelayedList>
}
    f140:	f107 0710 	add.w	r7, r7, #16
    f144:	46bd      	mov	sp, r7
    f146:	bd80      	pop	{r7, pc}

0000f148 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    f148:	b580      	push	{r7, lr}
    f14a:	b086      	sub	sp, #24
    f14c:	af00      	add	r7, sp, #0
    f14e:	60f8      	str	r0, [r7, #12]
    f150:	60b9      	str	r1, [r7, #8]
    f152:	607a      	str	r2, [r7, #4]
	configASSERT( pxEventList );
    f154:	68fb      	ldr	r3, [r7, #12]
    f156:	2b00      	cmp	r3, #0
    f158:	d109      	bne.n	f16e <vTaskPlaceOnUnorderedEventList+0x26>
    f15a:	f04f 0328 	mov.w	r3, #40	; 0x28
    f15e:	f383 8811 	msr	BASEPRI, r3
    f162:	f3bf 8f6f 	isb	sy
    f166:	f3bf 8f4f 	dsb	sy
    f16a:	613b      	str	r3, [r7, #16]
    f16c:	e7fe      	b.n	f16c <vTaskPlaceOnUnorderedEventList+0x24>

	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event groups implementation. */
	configASSERT( uxSchedulerSuspended != 0 );
    f16e:	f243 03f4 	movw	r3, #12532	; 0x30f4
    f172:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f176:	681b      	ldr	r3, [r3, #0]
    f178:	2b00      	cmp	r3, #0
    f17a:	d109      	bne.n	f190 <vTaskPlaceOnUnorderedEventList+0x48>
    f17c:	f04f 0328 	mov.w	r3, #40	; 0x28
    f180:	f383 8811 	msr	BASEPRI, r3
    f184:	f3bf 8f6f 	isb	sy
    f188:	f3bf 8f4f 	dsb	sy
    f18c:	617b      	str	r3, [r7, #20]
    f18e:	e7fe      	b.n	f18e <vTaskPlaceOnUnorderedEventList+0x46>

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    f190:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    f194:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f198:	681b      	ldr	r3, [r3, #0]
    f19a:	68ba      	ldr	r2, [r7, #8]
    f19c:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    f1a0:	619a      	str	r2, [r3, #24]
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    f1a2:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    f1a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f1aa:	681b      	ldr	r3, [r3, #0]
    f1ac:	f103 0318 	add.w	r3, r3, #24
    f1b0:	68f8      	ldr	r0, [r7, #12]
    f1b2:	4619      	mov	r1, r3
    f1b4:	f7fd fa28 	bl	c608 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    f1b8:	6878      	ldr	r0, [r7, #4]
    f1ba:	f04f 0101 	mov.w	r1, #1
    f1be:	f001 fb29 	bl	10814 <prvAddCurrentTaskToDelayedList>
}
    f1c2:	f107 0718 	add.w	r7, r7, #24
    f1c6:	46bd      	mov	sp, r7
    f1c8:	bd80      	pop	{r7, pc}
    f1ca:	bf00      	nop

0000f1cc <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if( configUSE_TIMERS == 1 )

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    f1cc:	b580      	push	{r7, lr}
    f1ce:	b086      	sub	sp, #24
    f1d0:	af00      	add	r7, sp, #0
    f1d2:	60f8      	str	r0, [r7, #12]
    f1d4:	60b9      	str	r1, [r7, #8]
    f1d6:	607a      	str	r2, [r7, #4]
		configASSERT( pxEventList );
    f1d8:	68fb      	ldr	r3, [r7, #12]
    f1da:	2b00      	cmp	r3, #0
    f1dc:	d109      	bne.n	f1f2 <vTaskPlaceOnEventListRestricted+0x26>
    f1de:	f04f 0328 	mov.w	r3, #40	; 0x28
    f1e2:	f383 8811 	msr	BASEPRI, r3
    f1e6:	f3bf 8f6f 	isb	sy
    f1ea:	f3bf 8f4f 	dsb	sy
    f1ee:	617b      	str	r3, [r7, #20]
    f1f0:	e7fe      	b.n	f1f0 <vTaskPlaceOnEventListRestricted+0x24>

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    f1f2:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    f1f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f1fa:	681b      	ldr	r3, [r3, #0]
    f1fc:	f103 0318 	add.w	r3, r3, #24
    f200:	68f8      	ldr	r0, [r7, #12]
    f202:	4619      	mov	r1, r3
    f204:	f7fd fa00 	bl	c608 <vListInsertEnd>

		/* If the task should block indefinitely then set the block time to a
		value that will be recognised as an indefinite delay inside the
		prvAddCurrentTaskToDelayedList() function. */
		if( xWaitIndefinitely != pdFALSE )
    f208:	687b      	ldr	r3, [r7, #4]
    f20a:	2b00      	cmp	r3, #0
    f20c:	d002      	beq.n	f214 <vTaskPlaceOnEventListRestricted+0x48>
		{
			xTicksToWait = portMAX_DELAY;
    f20e:	f04f 33ff 	mov.w	r3, #4294967295
    f212:	60bb      	str	r3, [r7, #8]
		}

		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    f214:	68b8      	ldr	r0, [r7, #8]
    f216:	6879      	ldr	r1, [r7, #4]
    f218:	f001 fafc 	bl	10814 <prvAddCurrentTaskToDelayedList>
	}
    f21c:	f107 0718 	add.w	r7, r7, #24
    f220:	46bd      	mov	sp, r7
    f222:	bd80      	pop	{r7, pc}

0000f224 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    f224:	b580      	push	{r7, lr}
    f226:	b086      	sub	sp, #24
    f228:	af00      	add	r7, sp, #0
    f22a:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    f22c:	687b      	ldr	r3, [r7, #4]
    f22e:	68db      	ldr	r3, [r3, #12]
    f230:	68db      	ldr	r3, [r3, #12]
    f232:	60fb      	str	r3, [r7, #12]
	configASSERT( pxUnblockedTCB );
    f234:	68fb      	ldr	r3, [r7, #12]
    f236:	2b00      	cmp	r3, #0
    f238:	d109      	bne.n	f24e <xTaskRemoveFromEventList+0x2a>
    f23a:	f04f 0328 	mov.w	r3, #40	; 0x28
    f23e:	f383 8811 	msr	BASEPRI, r3
    f242:	f3bf 8f6f 	isb	sy
    f246:	f3bf 8f4f 	dsb	sy
    f24a:	617b      	str	r3, [r7, #20]
    f24c:	e7fe      	b.n	f24c <xTaskRemoveFromEventList+0x28>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    f24e:	68fb      	ldr	r3, [r7, #12]
    f250:	f103 0318 	add.w	r3, r3, #24
    f254:	4618      	mov	r0, r3
    f256:	f7fd fa35 	bl	c6c4 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    f25a:	f243 03f4 	movw	r3, #12532	; 0x30f4
    f25e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f262:	681b      	ldr	r3, [r3, #0]
    f264:	2b00      	cmp	r3, #0
    f266:	d12d      	bne.n	f2c4 <xTaskRemoveFromEventList+0xa0>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    f268:	68fb      	ldr	r3, [r7, #12]
    f26a:	f103 0304 	add.w	r3, r3, #4
    f26e:	4618      	mov	r0, r3
    f270:	f7fd fa28 	bl	c6c4 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    f274:	68fb      	ldr	r3, [r7, #12]
    f276:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    f278:	f04f 0201 	mov.w	r2, #1
    f27c:	fa02 f203 	lsl.w	r2, r2, r3
    f280:	f243 03d4 	movw	r3, #12500	; 0x30d4
    f284:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f288:	681b      	ldr	r3, [r3, #0]
    f28a:	ea42 0203 	orr.w	r2, r2, r3
    f28e:	f243 03d4 	movw	r3, #12500	; 0x30d4
    f292:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f296:	601a      	str	r2, [r3, #0]
    f298:	68fb      	ldr	r3, [r7, #12]
    f29a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    f29c:	4613      	mov	r3, r2
    f29e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    f2a2:	4413      	add	r3, r2
    f2a4:	ea4f 0383 	mov.w	r3, r3, lsl #2
    f2a8:	461a      	mov	r2, r3
    f2aa:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    f2ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f2b2:	441a      	add	r2, r3
    f2b4:	68fb      	ldr	r3, [r7, #12]
    f2b6:	f103 0304 	add.w	r3, r3, #4
    f2ba:	4610      	mov	r0, r2
    f2bc:	4619      	mov	r1, r3
    f2be:	f7fd f9a3 	bl	c608 <vListInsertEnd>
    f2c2:	e009      	b.n	f2d8 <xTaskRemoveFromEventList+0xb4>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    f2c4:	68fb      	ldr	r3, [r7, #12]
    f2c6:	f103 0318 	add.w	r3, r3, #24
    f2ca:	f243 008c 	movw	r0, #12428	; 0x308c
    f2ce:	f2c2 0000 	movt	r0, #8192	; 0x2000
    f2d2:	4619      	mov	r1, r3
    f2d4:	f7fd f998 	bl	c608 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    f2d8:	68fb      	ldr	r3, [r7, #12]
    f2da:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    f2dc:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    f2e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f2e4:	681b      	ldr	r3, [r3, #0]
    f2e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    f2e8:	429a      	cmp	r2, r3
    f2ea:	d90a      	bls.n	f302 <xTaskRemoveFromEventList+0xde>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    f2ec:	f04f 0301 	mov.w	r3, #1
    f2f0:	613b      	str	r3, [r7, #16]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    f2f2:	f243 03e0 	movw	r3, #12512	; 0x30e0
    f2f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f2fa:	f04f 0201 	mov.w	r2, #1
    f2fe:	601a      	str	r2, [r3, #0]
    f300:	e002      	b.n	f308 <xTaskRemoveFromEventList+0xe4>
	}
	else
	{
		xReturn = pdFALSE;
    f302:	f04f 0300 	mov.w	r3, #0
    f306:	613b      	str	r3, [r7, #16]
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
    f308:	693b      	ldr	r3, [r7, #16]
}
    f30a:	4618      	mov	r0, r3
    f30c:	f107 0718 	add.w	r7, r7, #24
    f310:	46bd      	mov	sp, r7
    f312:	bd80      	pop	{r7, pc}

0000f314 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    f314:	b580      	push	{r7, lr}
    f316:	b086      	sub	sp, #24
    f318:	af00      	add	r7, sp, #0
    f31a:	6078      	str	r0, [r7, #4]
    f31c:	6039      	str	r1, [r7, #0]
TCB_t *pxUnblockedTCB;

	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );
    f31e:	f243 03f4 	movw	r3, #12532	; 0x30f4
    f322:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f326:	681b      	ldr	r3, [r3, #0]
    f328:	2b00      	cmp	r3, #0
    f32a:	d109      	bne.n	f340 <vTaskRemoveFromUnorderedEventList+0x2c>
    f32c:	f04f 0328 	mov.w	r3, #40	; 0x28
    f330:	f383 8811 	msr	BASEPRI, r3
    f334:	f3bf 8f6f 	isb	sy
    f338:	f3bf 8f4f 	dsb	sy
    f33c:	613b      	str	r3, [r7, #16]
    f33e:	e7fe      	b.n	f33e <vTaskRemoveFromUnorderedEventList+0x2a>

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    f340:	683b      	ldr	r3, [r7, #0]
    f342:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
    f346:	687b      	ldr	r3, [r7, #4]
    f348:	601a      	str	r2, [r3, #0]

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    f34a:	687b      	ldr	r3, [r7, #4]
    f34c:	68db      	ldr	r3, [r3, #12]
    f34e:	60fb      	str	r3, [r7, #12]
	configASSERT( pxUnblockedTCB );
    f350:	68fb      	ldr	r3, [r7, #12]
    f352:	2b00      	cmp	r3, #0
    f354:	d109      	bne.n	f36a <vTaskRemoveFromUnorderedEventList+0x56>
    f356:	f04f 0328 	mov.w	r3, #40	; 0x28
    f35a:	f383 8811 	msr	BASEPRI, r3
    f35e:	f3bf 8f6f 	isb	sy
    f362:	f3bf 8f4f 	dsb	sy
    f366:	617b      	str	r3, [r7, #20]
    f368:	e7fe      	b.n	f368 <vTaskRemoveFromUnorderedEventList+0x54>
	( void ) uxListRemove( pxEventListItem );
    f36a:	6878      	ldr	r0, [r7, #4]
    f36c:	f7fd f9aa 	bl	c6c4 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    f370:	68fb      	ldr	r3, [r7, #12]
    f372:	f103 0304 	add.w	r3, r3, #4
    f376:	4618      	mov	r0, r3
    f378:	f7fd f9a4 	bl	c6c4 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    f37c:	68fb      	ldr	r3, [r7, #12]
    f37e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    f380:	f04f 0201 	mov.w	r2, #1
    f384:	fa02 f203 	lsl.w	r2, r2, r3
    f388:	f243 03d4 	movw	r3, #12500	; 0x30d4
    f38c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f390:	681b      	ldr	r3, [r3, #0]
    f392:	ea42 0203 	orr.w	r2, r2, r3
    f396:	f243 03d4 	movw	r3, #12500	; 0x30d4
    f39a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f39e:	601a      	str	r2, [r3, #0]
    f3a0:	68fb      	ldr	r3, [r7, #12]
    f3a2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    f3a4:	4613      	mov	r3, r2
    f3a6:	ea4f 0383 	mov.w	r3, r3, lsl #2
    f3aa:	4413      	add	r3, r2
    f3ac:	ea4f 0383 	mov.w	r3, r3, lsl #2
    f3b0:	461a      	mov	r2, r3
    f3b2:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    f3b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f3ba:	441a      	add	r2, r3
    f3bc:	68fb      	ldr	r3, [r7, #12]
    f3be:	f103 0304 	add.w	r3, r3, #4
    f3c2:	4610      	mov	r0, r2
    f3c4:	4619      	mov	r1, r3
    f3c6:	f7fd f91f 	bl	c608 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    f3ca:	68fb      	ldr	r3, [r7, #12]
    f3cc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    f3ce:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    f3d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f3d6:	681b      	ldr	r3, [r3, #0]
    f3d8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    f3da:	429a      	cmp	r2, r3
    f3dc:	d906      	bls.n	f3ec <vTaskRemoveFromUnorderedEventList+0xd8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    f3de:	f243 03e0 	movw	r3, #12512	; 0x30e0
    f3e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f3e6:	f04f 0201 	mov.w	r2, #1
    f3ea:	601a      	str	r2, [r3, #0]
	}
}
    f3ec:	f107 0718 	add.w	r7, r7, #24
    f3f0:	46bd      	mov	sp, r7
    f3f2:	bd80      	pop	{r7, pc}

0000f3f4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    f3f4:	b580      	push	{r7, lr}
    f3f6:	b084      	sub	sp, #16
    f3f8:	af00      	add	r7, sp, #0
    f3fa:	6078      	str	r0, [r7, #4]
	configASSERT( pxTimeOut );
    f3fc:	687b      	ldr	r3, [r7, #4]
    f3fe:	2b00      	cmp	r3, #0
    f400:	d109      	bne.n	f416 <vTaskSetTimeOutState+0x22>
    f402:	f04f 0328 	mov.w	r3, #40	; 0x28
    f406:	f383 8811 	msr	BASEPRI, r3
    f40a:	f3bf 8f6f 	isb	sy
    f40e:	f3bf 8f4f 	dsb	sy
    f412:	60fb      	str	r3, [r7, #12]
    f414:	e7fe      	b.n	f414 <vTaskSetTimeOutState+0x20>
	taskENTER_CRITICAL();
    f416:	f002 f997 	bl	11748 <vPortEnterCritical>
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    f41a:	f243 03e4 	movw	r3, #12516	; 0x30e4
    f41e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f422:	681a      	ldr	r2, [r3, #0]
    f424:	687b      	ldr	r3, [r7, #4]
    f426:	601a      	str	r2, [r3, #0]
		pxTimeOut->xTimeOnEntering = xTickCount;
    f428:	f243 03d0 	movw	r3, #12496	; 0x30d0
    f42c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f430:	681a      	ldr	r2, [r3, #0]
    f432:	687b      	ldr	r3, [r7, #4]
    f434:	605a      	str	r2, [r3, #4]
	}
	taskEXIT_CRITICAL();
    f436:	f002 f9bf 	bl	117b8 <vPortExitCritical>
}
    f43a:	f107 0710 	add.w	r7, r7, #16
    f43e:	46bd      	mov	sp, r7
    f440:	bd80      	pop	{r7, pc}
    f442:	bf00      	nop

0000f444 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    f444:	b480      	push	{r7}
    f446:	b083      	sub	sp, #12
    f448:	af00      	add	r7, sp, #0
    f44a:	6078      	str	r0, [r7, #4]
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    f44c:	f243 03e4 	movw	r3, #12516	; 0x30e4
    f450:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f454:	681a      	ldr	r2, [r3, #0]
    f456:	687b      	ldr	r3, [r7, #4]
    f458:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    f45a:	f243 03d0 	movw	r3, #12496	; 0x30d0
    f45e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f462:	681a      	ldr	r2, [r3, #0]
    f464:	687b      	ldr	r3, [r7, #4]
    f466:	605a      	str	r2, [r3, #4]
}
    f468:	f107 070c 	add.w	r7, r7, #12
    f46c:	46bd      	mov	sp, r7
    f46e:	bc80      	pop	{r7}
    f470:	4770      	bx	lr
    f472:	bf00      	nop

0000f474 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    f474:	b580      	push	{r7, lr}
    f476:	b088      	sub	sp, #32
    f478:	af00      	add	r7, sp, #0
    f47a:	6078      	str	r0, [r7, #4]
    f47c:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
    f47e:	687b      	ldr	r3, [r7, #4]
    f480:	2b00      	cmp	r3, #0
    f482:	d109      	bne.n	f498 <xTaskCheckForTimeOut+0x24>
    f484:	f04f 0328 	mov.w	r3, #40	; 0x28
    f488:	f383 8811 	msr	BASEPRI, r3
    f48c:	f3bf 8f6f 	isb	sy
    f490:	f3bf 8f4f 	dsb	sy
    f494:	61bb      	str	r3, [r7, #24]
    f496:	e7fe      	b.n	f496 <xTaskCheckForTimeOut+0x22>
	configASSERT( pxTicksToWait );
    f498:	683b      	ldr	r3, [r7, #0]
    f49a:	2b00      	cmp	r3, #0
    f49c:	d109      	bne.n	f4b2 <xTaskCheckForTimeOut+0x3e>
    f49e:	f04f 0328 	mov.w	r3, #40	; 0x28
    f4a2:	f383 8811 	msr	BASEPRI, r3
    f4a6:	f3bf 8f6f 	isb	sy
    f4aa:	f3bf 8f4f 	dsb	sy
    f4ae:	61fb      	str	r3, [r7, #28]
    f4b0:	e7fe      	b.n	f4b0 <xTaskCheckForTimeOut+0x3c>

	taskENTER_CRITICAL();
    f4b2:	f002 f949 	bl	11748 <vPortEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    f4b6:	f243 03d0 	movw	r3, #12496	; 0x30d0
    f4ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f4be:	681b      	ldr	r3, [r3, #0]
    f4c0:	613b      	str	r3, [r7, #16]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    f4c2:	687b      	ldr	r3, [r7, #4]
    f4c4:	685b      	ldr	r3, [r3, #4]
    f4c6:	693a      	ldr	r2, [r7, #16]
    f4c8:	ebc3 0302 	rsb	r3, r3, r2
    f4cc:	617b      	str	r3, [r7, #20]
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    f4ce:	683b      	ldr	r3, [r7, #0]
    f4d0:	681b      	ldr	r3, [r3, #0]
    f4d2:	f1b3 3fff 	cmp.w	r3, #4294967295
    f4d6:	d103      	bne.n	f4e0 <xTaskCheckForTimeOut+0x6c>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    f4d8:	f04f 0300 	mov.w	r3, #0
    f4dc:	60fb      	str	r3, [r7, #12]
    f4de:	e02b      	b.n	f538 <xTaskCheckForTimeOut+0xc4>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    f4e0:	687b      	ldr	r3, [r7, #4]
    f4e2:	681a      	ldr	r2, [r3, #0]
    f4e4:	f243 03e4 	movw	r3, #12516	; 0x30e4
    f4e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f4ec:	681b      	ldr	r3, [r3, #0]
    f4ee:	429a      	cmp	r2, r3
    f4f0:	d008      	beq.n	f504 <xTaskCheckForTimeOut+0x90>
    f4f2:	687b      	ldr	r3, [r7, #4]
    f4f4:	685a      	ldr	r2, [r3, #4]
    f4f6:	693b      	ldr	r3, [r7, #16]
    f4f8:	429a      	cmp	r2, r3
    f4fa:	d803      	bhi.n	f504 <xTaskCheckForTimeOut+0x90>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    f4fc:	f04f 0301 	mov.w	r3, #1
    f500:	60fb      	str	r3, [r7, #12]
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    f502:	e019      	b.n	f538 <xTaskCheckForTimeOut+0xc4>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    f504:	683b      	ldr	r3, [r7, #0]
    f506:	681a      	ldr	r2, [r3, #0]
    f508:	697b      	ldr	r3, [r7, #20]
    f50a:	429a      	cmp	r2, r3
    f50c:	d90d      	bls.n	f52a <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    f50e:	683b      	ldr	r3, [r7, #0]
    f510:	681a      	ldr	r2, [r3, #0]
    f512:	697b      	ldr	r3, [r7, #20]
    f514:	ebc3 0202 	rsb	r2, r3, r2
    f518:	683b      	ldr	r3, [r7, #0]
    f51a:	601a      	str	r2, [r3, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
    f51c:	6878      	ldr	r0, [r7, #4]
    f51e:	f7ff ff91 	bl	f444 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    f522:	f04f 0300 	mov.w	r3, #0
    f526:	60fb      	str	r3, [r7, #12]
    f528:	e006      	b.n	f538 <xTaskCheckForTimeOut+0xc4>
		}
		else
		{
			*pxTicksToWait = 0;
    f52a:	683b      	ldr	r3, [r7, #0]
    f52c:	f04f 0200 	mov.w	r2, #0
    f530:	601a      	str	r2, [r3, #0]
			xReturn = pdTRUE;
    f532:	f04f 0301 	mov.w	r3, #1
    f536:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
    f538:	f002 f93e 	bl	117b8 <vPortExitCritical>

	return xReturn;
    f53c:	68fb      	ldr	r3, [r7, #12]
}
    f53e:	4618      	mov	r0, r3
    f540:	f107 0720 	add.w	r7, r7, #32
    f544:	46bd      	mov	sp, r7
    f546:	bd80      	pop	{r7, pc}

0000f548 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    f548:	b480      	push	{r7}
    f54a:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
    f54c:	f243 03e0 	movw	r3, #12512	; 0x30e0
    f550:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f554:	f04f 0201 	mov.w	r2, #1
    f558:	601a      	str	r2, [r3, #0]
}
    f55a:	46bd      	mov	sp, r7
    f55c:	bc80      	pop	{r7}
    f55e:	4770      	bx	lr

0000f560 <uxTaskGetTaskNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
	{
    f560:	b480      	push	{r7}
    f562:	b085      	sub	sp, #20
    f564:	af00      	add	r7, sp, #0
    f566:	6078      	str	r0, [r7, #4]
	UBaseType_t uxReturn;
	TCB_t const *pxTCB;

		if( xTask != NULL )
    f568:	687b      	ldr	r3, [r7, #4]
    f56a:	2b00      	cmp	r3, #0
    f56c:	d005      	beq.n	f57a <uxTaskGetTaskNumber+0x1a>
		{
			pxTCB = xTask;
    f56e:	687b      	ldr	r3, [r7, #4]
    f570:	60fb      	str	r3, [r7, #12]
			uxReturn = pxTCB->uxTaskNumber;
    f572:	68fb      	ldr	r3, [r7, #12]
    f574:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    f576:	60bb      	str	r3, [r7, #8]
    f578:	e002      	b.n	f580 <uxTaskGetTaskNumber+0x20>
		}
		else
		{
			uxReturn = 0U;
    f57a:	f04f 0300 	mov.w	r3, #0
    f57e:	60bb      	str	r3, [r7, #8]
		}

		return uxReturn;
    f580:	68bb      	ldr	r3, [r7, #8]
	}
    f582:	4618      	mov	r0, r3
    f584:	f107 0714 	add.w	r7, r7, #20
    f588:	46bd      	mov	sp, r7
    f58a:	bc80      	pop	{r7}
    f58c:	4770      	bx	lr
    f58e:	bf00      	nop

0000f590 <vTaskSetTaskNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
	{
    f590:	b480      	push	{r7}
    f592:	b085      	sub	sp, #20
    f594:	af00      	add	r7, sp, #0
    f596:	6078      	str	r0, [r7, #4]
    f598:	6039      	str	r1, [r7, #0]
	TCB_t * pxTCB;

		if( xTask != NULL )
    f59a:	687b      	ldr	r3, [r7, #4]
    f59c:	2b00      	cmp	r3, #0
    f59e:	d004      	beq.n	f5aa <vTaskSetTaskNumber+0x1a>
		{
			pxTCB = xTask;
    f5a0:	687b      	ldr	r3, [r7, #4]
    f5a2:	60fb      	str	r3, [r7, #12]
			pxTCB->uxTaskNumber = uxHandle;
    f5a4:	68fb      	ldr	r3, [r7, #12]
    f5a6:	683a      	ldr	r2, [r7, #0]
    f5a8:	645a      	str	r2, [r3, #68]	; 0x44
		}
	}
    f5aa:	f107 0714 	add.w	r7, r7, #20
    f5ae:	46bd      	mov	sp, r7
    f5b0:	bc80      	pop	{r7}
    f5b2:	4770      	bx	lr

0000f5b4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    f5b4:	b580      	push	{r7, lr}
    f5b6:	b082      	sub	sp, #8
    f5b8:	af00      	add	r7, sp, #0
    f5ba:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    f5bc:	f000 f868 	bl	f690 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    f5c0:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    f5c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f5c8:	681b      	ldr	r3, [r3, #0]
    f5ca:	2b01      	cmp	r3, #1
    f5cc:	d90a      	bls.n	f5e4 <prvIdleTask+0x30>
			{
				taskYIELD();
    f5ce:	f64e 5304 	movw	r3, #60676	; 0xed04
    f5d2:	f2ce 0300 	movt	r3, #57344	; 0xe000
    f5d6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    f5da:	601a      	str	r2, [r3, #0]
    f5dc:	f3bf 8f4f 	dsb	sy
    f5e0:	f3bf 8f6f 	isb	sy
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
    f5e4:	f7f1 fb12 	bl	c0c <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    f5e8:	e7e8      	b.n	f5bc <prvIdleTask+0x8>
    f5ea:	bf00      	nop

0000f5ec <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    f5ec:	b580      	push	{r7, lr}
    f5ee:	b082      	sub	sp, #8
    f5f0:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    f5f2:	f04f 0300 	mov.w	r3, #0
    f5f6:	607b      	str	r3, [r7, #4]
    f5f8:	e013      	b.n	f622 <prvInitialiseTaskLists+0x36>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    f5fa:	687a      	ldr	r2, [r7, #4]
    f5fc:	4613      	mov	r3, r2
    f5fe:	ea4f 0383 	mov.w	r3, r3, lsl #2
    f602:	4413      	add	r3, r2
    f604:	ea4f 0383 	mov.w	r3, r3, lsl #2
    f608:	461a      	mov	r2, r3
    f60a:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    f60e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f612:	4413      	add	r3, r2
    f614:	4618      	mov	r0, r3
    f616:	f7fc ffc5 	bl	c5a4 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    f61a:	687b      	ldr	r3, [r7, #4]
    f61c:	f103 0301 	add.w	r3, r3, #1
    f620:	607b      	str	r3, [r7, #4]
    f622:	687b      	ldr	r3, [r7, #4]
    f624:	2b04      	cmp	r3, #4
    f626:	d9e8      	bls.n	f5fa <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    f628:	f243 005c 	movw	r0, #12380	; 0x305c
    f62c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    f630:	f7fc ffb8 	bl	c5a4 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    f634:	f243 0070 	movw	r0, #12400	; 0x3070
    f638:	f2c2 0000 	movt	r0, #8192	; 0x2000
    f63c:	f7fc ffb2 	bl	c5a4 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    f640:	f243 008c 	movw	r0, #12428	; 0x308c
    f644:	f2c2 0000 	movt	r0, #8192	; 0x2000
    f648:	f7fc ffac 	bl	c5a4 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    f64c:	f243 00a0 	movw	r0, #12448	; 0x30a0
    f650:	f2c2 0000 	movt	r0, #8192	; 0x2000
    f654:	f7fc ffa6 	bl	c5a4 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    f658:	f243 00b8 	movw	r0, #12472	; 0x30b8
    f65c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    f660:	f7fc ffa0 	bl	c5a4 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    f664:	f243 0384 	movw	r3, #12420	; 0x3084
    f668:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f66c:	f243 025c 	movw	r2, #12380	; 0x305c
    f670:	f2c2 0200 	movt	r2, #8192	; 0x2000
    f674:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    f676:	f243 0388 	movw	r3, #12424	; 0x3088
    f67a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f67e:	f243 0270 	movw	r2, #12400	; 0x3070
    f682:	f2c2 0200 	movt	r2, #8192	; 0x2000
    f686:	601a      	str	r2, [r3, #0]
}
    f688:	f107 0708 	add.w	r7, r7, #8
    f68c:	46bd      	mov	sp, r7
    f68e:	bd80      	pop	{r7, pc}

0000f690 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    f690:	b580      	push	{r7, lr}
    f692:	b082      	sub	sp, #8
    f694:	af00      	add	r7, sp, #0
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    f696:	e02b      	b.n	f6f0 <prvCheckTasksWaitingTermination+0x60>
		{
			taskENTER_CRITICAL();
    f698:	f002 f856 	bl	11748 <vPortEnterCritical>
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    f69c:	f243 03a0 	movw	r3, #12448	; 0x30a0
    f6a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f6a4:	68db      	ldr	r3, [r3, #12]
    f6a6:	68db      	ldr	r3, [r3, #12]
    f6a8:	607b      	str	r3, [r7, #4]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    f6aa:	687b      	ldr	r3, [r7, #4]
    f6ac:	f103 0304 	add.w	r3, r3, #4
    f6b0:	4618      	mov	r0, r3
    f6b2:	f7fd f807 	bl	c6c4 <uxListRemove>
				--uxCurrentNumberOfTasks;
    f6b6:	f243 03cc 	movw	r3, #12492	; 0x30cc
    f6ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f6be:	681b      	ldr	r3, [r3, #0]
    f6c0:	f103 32ff 	add.w	r2, r3, #4294967295
    f6c4:	f243 03cc 	movw	r3, #12492	; 0x30cc
    f6c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f6cc:	601a      	str	r2, [r3, #0]
				--uxDeletedTasksWaitingCleanUp;
    f6ce:	f243 03b4 	movw	r3, #12468	; 0x30b4
    f6d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f6d6:	681b      	ldr	r3, [r3, #0]
    f6d8:	f103 32ff 	add.w	r2, r3, #4294967295
    f6dc:	f243 03b4 	movw	r3, #12468	; 0x30b4
    f6e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f6e4:	601a      	str	r2, [r3, #0]
			}
			taskEXIT_CRITICAL();
    f6e6:	f002 f867 	bl	117b8 <vPortExitCritical>

			prvDeleteTCB( pxTCB );
    f6ea:	6878      	ldr	r0, [r7, #4]
    f6ec:	f000 f8f8 	bl	f8e0 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    f6f0:	f243 03b4 	movw	r3, #12468	; 0x30b4
    f6f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f6f8:	681b      	ldr	r3, [r3, #0]
    f6fa:	2b00      	cmp	r3, #0
    f6fc:	d1cc      	bne.n	f698 <prvCheckTasksWaitingTermination+0x8>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    f6fe:	f107 0708 	add.w	r7, r7, #8
    f702:	46bd      	mov	sp, r7
    f704:	bd80      	pop	{r7, pc}
    f706:	bf00      	nop

0000f708 <vTaskGetInfo>:
/*-----------------------------------------------------------*/

#if( configUSE_TRACE_FACILITY == 1 )

	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
	{
    f708:	b580      	push	{r7, lr}
    f70a:	b086      	sub	sp, #24
    f70c:	af00      	add	r7, sp, #0
    f70e:	60f8      	str	r0, [r7, #12]
    f710:	60b9      	str	r1, [r7, #8]
    f712:	607a      	str	r2, [r7, #4]
    f714:	70fb      	strb	r3, [r7, #3]
	TCB_t *pxTCB;

		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );
    f716:	68fb      	ldr	r3, [r7, #12]
    f718:	2b00      	cmp	r3, #0
    f71a:	d105      	bne.n	f728 <vTaskGetInfo+0x20>
    f71c:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    f720:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f724:	681b      	ldr	r3, [r3, #0]
    f726:	e000      	b.n	f72a <vTaskGetInfo+0x22>
    f728:	68fb      	ldr	r3, [r7, #12]
    f72a:	617b      	str	r3, [r7, #20]

		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
    f72c:	68bb      	ldr	r3, [r7, #8]
    f72e:	697a      	ldr	r2, [r7, #20]
    f730:	601a      	str	r2, [r3, #0]
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
    f732:	697b      	ldr	r3, [r7, #20]
    f734:	f103 0234 	add.w	r2, r3, #52	; 0x34
    f738:	68bb      	ldr	r3, [r7, #8]
    f73a:	605a      	str	r2, [r3, #4]
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
    f73c:	697b      	ldr	r3, [r7, #20]
    f73e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    f740:	68bb      	ldr	r3, [r7, #8]
    f742:	611a      	str	r2, [r3, #16]
		pxTaskStatus->pxStackBase = pxTCB->pxStack;
    f744:	697b      	ldr	r3, [r7, #20]
    f746:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    f748:	68bb      	ldr	r3, [r7, #8]
    f74a:	61da      	str	r2, [r3, #28]
		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
    f74c:	697b      	ldr	r3, [r7, #20]
    f74e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    f750:	68bb      	ldr	r3, [r7, #8]
    f752:	609a      	str	r2, [r3, #8]

		#if ( configUSE_MUTEXES == 1 )
		{
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
    f754:	697b      	ldr	r3, [r7, #20]
    f756:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    f758:	68bb      	ldr	r3, [r7, #8]
    f75a:	615a      	str	r2, [r3, #20]
		}
		#endif

		#if ( configGENERATE_RUN_TIME_STATS == 1 )
		{
			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
    f75c:	697b      	ldr	r3, [r7, #20]
    f75e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    f760:	68bb      	ldr	r3, [r7, #8]
    f762:	619a      	str	r2, [r3, #24]
		#endif

		/* Obtaining the task state is a little fiddly, so is only done if the
		value of eState passed into this function is eInvalid - otherwise the
		state is just set to whatever is passed in. */
		if( eState != eInvalid )
    f764:	78fb      	ldrb	r3, [r7, #3]
    f766:	2b05      	cmp	r3, #5
    f768:	d01f      	beq.n	f7aa <vTaskGetInfo+0xa2>
		{
			if( pxTCB == pxCurrentTCB )
    f76a:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    f76e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f772:	681b      	ldr	r3, [r3, #0]
    f774:	697a      	ldr	r2, [r7, #20]
    f776:	429a      	cmp	r2, r3
    f778:	d104      	bne.n	f784 <vTaskGetInfo+0x7c>
			{
				pxTaskStatus->eCurrentState = eRunning;
    f77a:	68bb      	ldr	r3, [r7, #8]
    f77c:	f04f 0200 	mov.w	r2, #0
    f780:	731a      	strb	r2, [r3, #12]
							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
							{
								pxTaskStatus->eCurrentState = eBlocked;
							}
						}
						( void ) xTaskResumeAll();
    f782:	e01b      	b.n	f7bc <vTaskGetInfo+0xb4>
			{
				pxTaskStatus->eCurrentState = eRunning;
			}
			else
			{
				pxTaskStatus->eCurrentState = eState;
    f784:	68bb      	ldr	r3, [r7, #8]
    f786:	78fa      	ldrb	r2, [r7, #3]
    f788:	731a      	strb	r2, [r3, #12]
				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* If the task is in the suspended list then there is a
					chance it is actually just blocked indefinitely - so really
					it should be reported as being in the Blocked state. */
					if( eState == eSuspended )
    f78a:	78fb      	ldrb	r3, [r7, #3]
    f78c:	2b03      	cmp	r3, #3
    f78e:	d114      	bne.n	f7ba <vTaskGetInfo+0xb2>
					{
						vTaskSuspendAll();
    f790:	f7ff f8f6 	bl	e980 <vTaskSuspendAll>
						{
							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    f794:	697b      	ldr	r3, [r7, #20]
    f796:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    f798:	2b00      	cmp	r3, #0
    f79a:	d003      	beq.n	f7a4 <vTaskGetInfo+0x9c>
							{
								pxTaskStatus->eCurrentState = eBlocked;
    f79c:	68bb      	ldr	r3, [r7, #8]
    f79e:	f04f 0202 	mov.w	r2, #2
    f7a2:	731a      	strb	r2, [r3, #12]
							}
						}
						( void ) xTaskResumeAll();
    f7a4:	f7ff f8fe 	bl	e9a4 <xTaskResumeAll>
    f7a8:	e008      	b.n	f7bc <vTaskGetInfo+0xb4>
				#endif /* INCLUDE_vTaskSuspend */
			}
		}
		else
		{
			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
    f7aa:	6978      	ldr	r0, [r7, #20]
    f7ac:	f7fe fd06 	bl	e1bc <eTaskGetState>
    f7b0:	4603      	mov	r3, r0
    f7b2:	461a      	mov	r2, r3
    f7b4:	68bb      	ldr	r3, [r7, #8]
    f7b6:	731a      	strb	r2, [r3, #12]
    f7b8:	e000      	b.n	f7bc <vTaskGetInfo+0xb4>
							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
							{
								pxTaskStatus->eCurrentState = eBlocked;
							}
						}
						( void ) xTaskResumeAll();
    f7ba:	bf00      	nop
			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
		}

		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
		parameter is provided to allow it to be skipped. */
		if( xGetFreeStackSpace != pdFALSE )
    f7bc:	687b      	ldr	r3, [r7, #4]
    f7be:	2b00      	cmp	r3, #0
    f7c0:	d009      	beq.n	f7d6 <vTaskGetInfo+0xce>
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
			}
			#else
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
    f7c2:	697b      	ldr	r3, [r7, #20]
    f7c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    f7c6:	4618      	mov	r0, r3
    f7c8:	f000 f86a 	bl	f8a0 <prvTaskCheckFreeStackSpace>
    f7cc:	4603      	mov	r3, r0
    f7ce:	461a      	mov	r2, r3
    f7d0:	68bb      	ldr	r3, [r7, #8]
    f7d2:	841a      	strh	r2, [r3, #32]
    f7d4:	e003      	b.n	f7de <vTaskGetInfo+0xd6>
			}
			#endif
		}
		else
		{
			pxTaskStatus->usStackHighWaterMark = 0;
    f7d6:	68bb      	ldr	r3, [r7, #8]
    f7d8:	f04f 0200 	mov.w	r2, #0
    f7dc:	841a      	strh	r2, [r3, #32]
		}
	}
    f7de:	f107 0718 	add.w	r7, r7, #24
    f7e2:	46bd      	mov	sp, r7
    f7e4:	bd80      	pop	{r7, pc}
    f7e6:	bf00      	nop

0000f7e8 <prvListTasksWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
    f7e8:	b580      	push	{r7, lr}
    f7ea:	b08a      	sub	sp, #40	; 0x28
    f7ec:	af00      	add	r7, sp, #0
    f7ee:	60f8      	str	r0, [r7, #12]
    f7f0:	60b9      	str	r1, [r7, #8]
    f7f2:	4613      	mov	r3, r2
    f7f4:	71fb      	strb	r3, [r7, #7]
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
    f7f6:	f04f 0300 	mov.w	r3, #0
    f7fa:	61fb      	str	r3, [r7, #28]

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
    f7fc:	68bb      	ldr	r3, [r7, #8]
    f7fe:	681b      	ldr	r3, [r3, #0]
    f800:	2b00      	cmp	r3, #0
    f802:	d046      	beq.n	f892 <prvListTasksWithinSingleList+0xaa>
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    f804:	68bb      	ldr	r3, [r7, #8]
    f806:	623b      	str	r3, [r7, #32]
    f808:	6a3b      	ldr	r3, [r7, #32]
    f80a:	685b      	ldr	r3, [r3, #4]
    f80c:	685a      	ldr	r2, [r3, #4]
    f80e:	6a3b      	ldr	r3, [r7, #32]
    f810:	605a      	str	r2, [r3, #4]
    f812:	6a3b      	ldr	r3, [r7, #32]
    f814:	685a      	ldr	r2, [r3, #4]
    f816:	6a3b      	ldr	r3, [r7, #32]
    f818:	f103 0308 	add.w	r3, r3, #8
    f81c:	429a      	cmp	r2, r3
    f81e:	d104      	bne.n	f82a <prvListTasksWithinSingleList+0x42>
    f820:	6a3b      	ldr	r3, [r7, #32]
    f822:	685b      	ldr	r3, [r3, #4]
    f824:	685a      	ldr	r2, [r3, #4]
    f826:	6a3b      	ldr	r3, [r7, #32]
    f828:	605a      	str	r2, [r3, #4]
    f82a:	6a3b      	ldr	r3, [r7, #32]
    f82c:	685b      	ldr	r3, [r3, #4]
    f82e:	68db      	ldr	r3, [r3, #12]
    f830:	61bb      	str	r3, [r7, #24]
			pxTaskStatusArray array for each task that is referenced from
			pxList.  See the definition of TaskStatus_t in task.h for the
			meaning of each TaskStatus_t structure member. */
			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    f832:	68bb      	ldr	r3, [r7, #8]
    f834:	627b      	str	r3, [r7, #36]	; 0x24
    f836:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f838:	685b      	ldr	r3, [r3, #4]
    f83a:	685a      	ldr	r2, [r3, #4]
    f83c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f83e:	605a      	str	r2, [r3, #4]
    f840:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f842:	685a      	ldr	r2, [r3, #4]
    f844:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f846:	f103 0308 	add.w	r3, r3, #8
    f84a:	429a      	cmp	r2, r3
    f84c:	d104      	bne.n	f858 <prvListTasksWithinSingleList+0x70>
    f84e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f850:	685b      	ldr	r3, [r3, #4]
    f852:	685a      	ldr	r2, [r3, #4]
    f854:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f856:	605a      	str	r2, [r3, #4]
    f858:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f85a:	685b      	ldr	r3, [r3, #4]
    f85c:	68db      	ldr	r3, [r3, #12]
    f85e:	617b      	str	r3, [r7, #20]
				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
    f860:	69fa      	ldr	r2, [r7, #28]
    f862:	4613      	mov	r3, r2
    f864:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    f868:	4413      	add	r3, r2
    f86a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    f86e:	461a      	mov	r2, r3
    f870:	68fb      	ldr	r3, [r7, #12]
    f872:	441a      	add	r2, r3
    f874:	79fb      	ldrb	r3, [r7, #7]
    f876:	6978      	ldr	r0, [r7, #20]
    f878:	4611      	mov	r1, r2
    f87a:	f04f 0201 	mov.w	r2, #1
    f87e:	f7ff ff43 	bl	f708 <vTaskGetInfo>
				uxTask++;
    f882:	69fb      	ldr	r3, [r7, #28]
    f884:	f103 0301 	add.w	r3, r3, #1
    f888:	61fb      	str	r3, [r7, #28]
			} while( pxNextTCB != pxFirstTCB );
    f88a:	697a      	ldr	r2, [r7, #20]
    f88c:	69bb      	ldr	r3, [r7, #24]
    f88e:	429a      	cmp	r2, r3
    f890:	d1cf      	bne.n	f832 <prvListTasksWithinSingleList+0x4a>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return uxTask;
    f892:	69fb      	ldr	r3, [r7, #28]
	}
    f894:	4618      	mov	r0, r3
    f896:	f107 0728 	add.w	r7, r7, #40	; 0x28
    f89a:	46bd      	mov	sp, r7
    f89c:	bd80      	pop	{r7, pc}
    f89e:	bf00      	nop

0000f8a0 <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
    f8a0:	b480      	push	{r7}
    f8a2:	b085      	sub	sp, #20
    f8a4:	af00      	add	r7, sp, #0
    f8a6:	6078      	str	r0, [r7, #4]
	uint32_t ulCount = 0U;
    f8a8:	f04f 0300 	mov.w	r3, #0
    f8ac:	60fb      	str	r3, [r7, #12]

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
    f8ae:	e007      	b.n	f8c0 <prvTaskCheckFreeStackSpace+0x20>
		{
			pucStackByte -= portSTACK_GROWTH;
    f8b0:	687b      	ldr	r3, [r7, #4]
    f8b2:	f103 0301 	add.w	r3, r3, #1
    f8b6:	607b      	str	r3, [r7, #4]
			ulCount++;
    f8b8:	68fb      	ldr	r3, [r7, #12]
    f8ba:	f103 0301 	add.w	r3, r3, #1
    f8be:	60fb      	str	r3, [r7, #12]

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
    f8c0:	687b      	ldr	r3, [r7, #4]
    f8c2:	781b      	ldrb	r3, [r3, #0]
    f8c4:	2ba5      	cmp	r3, #165	; 0xa5
    f8c6:	d0f3      	beq.n	f8b0 <prvTaskCheckFreeStackSpace+0x10>
		{
			pucStackByte -= portSTACK_GROWTH;
			ulCount++;
		}

		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
    f8c8:	68fb      	ldr	r3, [r7, #12]
    f8ca:	ea4f 0393 	mov.w	r3, r3, lsr #2
    f8ce:	60fb      	str	r3, [r7, #12]

		return ( configSTACK_DEPTH_TYPE ) ulCount;
    f8d0:	68fb      	ldr	r3, [r7, #12]
    f8d2:	b29b      	uxth	r3, r3
	}
    f8d4:	4618      	mov	r0, r3
    f8d6:	f107 0714 	add.w	r7, r7, #20
    f8da:	46bd      	mov	sp, r7
    f8dc:	bc80      	pop	{r7}
    f8de:	4770      	bx	lr

0000f8e0 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    f8e0:	b580      	push	{r7, lr}
    f8e2:	b082      	sub	sp, #8
    f8e4:	af00      	add	r7, sp, #0
    f8e6:	6078      	str	r0, [r7, #4]

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    f8e8:	687b      	ldr	r3, [r7, #4]
    f8ea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    f8ec:	4618      	mov	r0, r3
    f8ee:	f001 fd61 	bl	113b4 <vPortFree>
			vPortFree( pxTCB );
    f8f2:	6878      	ldr	r0, [r7, #4]
    f8f4:	f001 fd5e 	bl	113b4 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    f8f8:	f107 0708 	add.w	r7, r7, #8
    f8fc:	46bd      	mov	sp, r7
    f8fe:	bd80      	pop	{r7, pc}

0000f900 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    f900:	b480      	push	{r7}
    f902:	b083      	sub	sp, #12
    f904:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    f906:	f243 0384 	movw	r3, #12420	; 0x3084
    f90a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f90e:	681b      	ldr	r3, [r3, #0]
    f910:	681b      	ldr	r3, [r3, #0]
    f912:	2b00      	cmp	r3, #0
    f914:	d107      	bne.n	f926 <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    f916:	f243 03ec 	movw	r3, #12524	; 0x30ec
    f91a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f91e:	f04f 32ff 	mov.w	r2, #4294967295
    f922:	601a      	str	r2, [r3, #0]
    f924:	e00e      	b.n	f944 <prvResetNextTaskUnblockTime+0x44>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    f926:	f243 0384 	movw	r3, #12420	; 0x3084
    f92a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f92e:	681b      	ldr	r3, [r3, #0]
    f930:	68db      	ldr	r3, [r3, #12]
    f932:	68db      	ldr	r3, [r3, #12]
    f934:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    f936:	687b      	ldr	r3, [r7, #4]
    f938:	685a      	ldr	r2, [r3, #4]
    f93a:	f243 03ec 	movw	r3, #12524	; 0x30ec
    f93e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f942:	601a      	str	r2, [r3, #0]
	}
}
    f944:	f107 070c 	add.w	r7, r7, #12
    f948:	46bd      	mov	sp, r7
    f94a:	bc80      	pop	{r7}
    f94c:	4770      	bx	lr
    f94e:	bf00      	nop

0000f950 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    f950:	b480      	push	{r7}
    f952:	b083      	sub	sp, #12
    f954:	af00      	add	r7, sp, #0
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    f956:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    f95a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f95e:	681b      	ldr	r3, [r3, #0]
    f960:	607b      	str	r3, [r7, #4]

		return xReturn;
    f962:	687b      	ldr	r3, [r7, #4]
	}
    f964:	4618      	mov	r0, r3
    f966:	f107 070c 	add.w	r7, r7, #12
    f96a:	46bd      	mov	sp, r7
    f96c:	bc80      	pop	{r7}
    f96e:	4770      	bx	lr

0000f970 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
    f970:	b480      	push	{r7}
    f972:	b083      	sub	sp, #12
    f974:	af00      	add	r7, sp, #0
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    f976:	f243 03d8 	movw	r3, #12504	; 0x30d8
    f97a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f97e:	681b      	ldr	r3, [r3, #0]
    f980:	2b00      	cmp	r3, #0
    f982:	d103      	bne.n	f98c <xTaskGetSchedulerState+0x1c>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    f984:	f04f 0301 	mov.w	r3, #1
    f988:	607b      	str	r3, [r7, #4]
    f98a:	e00d      	b.n	f9a8 <xTaskGetSchedulerState+0x38>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    f98c:	f243 03f4 	movw	r3, #12532	; 0x30f4
    f990:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f994:	681b      	ldr	r3, [r3, #0]
    f996:	2b00      	cmp	r3, #0
    f998:	d103      	bne.n	f9a2 <xTaskGetSchedulerState+0x32>
			{
				xReturn = taskSCHEDULER_RUNNING;
    f99a:	f04f 0302 	mov.w	r3, #2
    f99e:	607b      	str	r3, [r7, #4]
    f9a0:	e002      	b.n	f9a8 <xTaskGetSchedulerState+0x38>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    f9a2:	f04f 0300 	mov.w	r3, #0
    f9a6:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
    f9a8:	687b      	ldr	r3, [r7, #4]
	}
    f9aa:	4618      	mov	r0, r3
    f9ac:	f107 070c 	add.w	r7, r7, #12
    f9b0:	46bd      	mov	sp, r7
    f9b2:	bc80      	pop	{r7}
    f9b4:	4770      	bx	lr
    f9b6:	bf00      	nop

0000f9b8 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    f9b8:	b580      	push	{r7, lr}
    f9ba:	b084      	sub	sp, #16
    f9bc:	af00      	add	r7, sp, #0
    f9be:	6078      	str	r0, [r7, #4]
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
    f9c0:	687b      	ldr	r3, [r7, #4]
    f9c2:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn = pdFALSE;
    f9c4:	f04f 0300 	mov.w	r3, #0
    f9c8:	60fb      	str	r3, [r7, #12]

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
    f9ca:	687b      	ldr	r3, [r7, #4]
    f9cc:	2b00      	cmp	r3, #0
    f9ce:	f000 80a2 	beq.w	fb16 <xTaskPriorityInherit+0x15e>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    f9d2:	68bb      	ldr	r3, [r7, #8]
    f9d4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    f9d6:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    f9da:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f9de:	681b      	ldr	r3, [r3, #0]
    f9e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    f9e2:	429a      	cmp	r2, r3
    f9e4:	f080 808a 	bcs.w	fafc <xTaskPriorityInherit+0x144>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    f9e8:	68bb      	ldr	r3, [r7, #8]
    f9ea:	699b      	ldr	r3, [r3, #24]
    f9ec:	2b00      	cmp	r3, #0
    f9ee:	db09      	blt.n	fa04 <xTaskPriorityInherit+0x4c>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    f9f0:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    f9f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f9f8:	681b      	ldr	r3, [r3, #0]
    f9fa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    f9fc:	f1c3 0205 	rsb	r2, r3, #5
    fa00:	68bb      	ldr	r3, [r7, #8]
    fa02:	619a      	str	r2, [r3, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    fa04:	68bb      	ldr	r3, [r7, #8]
    fa06:	6959      	ldr	r1, [r3, #20]
    fa08:	68bb      	ldr	r3, [r7, #8]
    fa0a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    fa0c:	4613      	mov	r3, r2
    fa0e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    fa12:	4413      	add	r3, r2
    fa14:	ea4f 0383 	mov.w	r3, r3, lsl #2
    fa18:	461a      	mov	r2, r3
    fa1a:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    fa1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fa22:	4413      	add	r3, r2
    fa24:	4299      	cmp	r1, r3
    fa26:	d15d      	bne.n	fae4 <xTaskPriorityInherit+0x12c>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    fa28:	68bb      	ldr	r3, [r7, #8]
    fa2a:	f103 0304 	add.w	r3, r3, #4
    fa2e:	4618      	mov	r0, r3
    fa30:	f7fc fe48 	bl	c6c4 <uxListRemove>
    fa34:	4603      	mov	r3, r0
    fa36:	2b00      	cmp	r3, #0
    fa38:	d124      	bne.n	fa84 <xTaskPriorityInherit+0xcc>
					{
						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
    fa3a:	68bb      	ldr	r3, [r7, #8]
    fa3c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    fa3e:	4613      	mov	r3, r2
    fa40:	ea4f 0383 	mov.w	r3, r3, lsl #2
    fa44:	4413      	add	r3, r2
    fa46:	ea4f 0383 	mov.w	r3, r3, lsl #2
    fa4a:	461a      	mov	r2, r3
    fa4c:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    fa50:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fa54:	4413      	add	r3, r2
    fa56:	681b      	ldr	r3, [r3, #0]
    fa58:	2b00      	cmp	r3, #0
    fa5a:	d113      	bne.n	fa84 <xTaskPriorityInherit+0xcc>
    fa5c:	68bb      	ldr	r3, [r7, #8]
    fa5e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    fa60:	f04f 0201 	mov.w	r2, #1
    fa64:	fa02 f303 	lsl.w	r3, r2, r3
    fa68:	ea6f 0203 	mvn.w	r2, r3
    fa6c:	f243 03d4 	movw	r3, #12500	; 0x30d4
    fa70:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fa74:	681b      	ldr	r3, [r3, #0]
    fa76:	ea02 0203 	and.w	r2, r2, r3
    fa7a:	f243 03d4 	movw	r3, #12500	; 0x30d4
    fa7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fa82:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    fa84:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    fa88:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fa8c:	681b      	ldr	r3, [r3, #0]
    fa8e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    fa90:	68bb      	ldr	r3, [r7, #8]
    fa92:	62da      	str	r2, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
    fa94:	68bb      	ldr	r3, [r7, #8]
    fa96:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    fa98:	f04f 0201 	mov.w	r2, #1
    fa9c:	fa02 f203 	lsl.w	r2, r2, r3
    faa0:	f243 03d4 	movw	r3, #12500	; 0x30d4
    faa4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    faa8:	681b      	ldr	r3, [r3, #0]
    faaa:	ea42 0203 	orr.w	r2, r2, r3
    faae:	f243 03d4 	movw	r3, #12500	; 0x30d4
    fab2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fab6:	601a      	str	r2, [r3, #0]
    fab8:	68bb      	ldr	r3, [r7, #8]
    faba:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    fabc:	4613      	mov	r3, r2
    fabe:	ea4f 0383 	mov.w	r3, r3, lsl #2
    fac2:	4413      	add	r3, r2
    fac4:	ea4f 0383 	mov.w	r3, r3, lsl #2
    fac8:	461a      	mov	r2, r3
    faca:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    face:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fad2:	441a      	add	r2, r3
    fad4:	68bb      	ldr	r3, [r7, #8]
    fad6:	f103 0304 	add.w	r3, r3, #4
    fada:	4610      	mov	r0, r2
    fadc:	4619      	mov	r1, r3
    fade:	f7fc fd93 	bl	c608 <vListInsertEnd>
    fae2:	e007      	b.n	faf4 <xTaskPriorityInherit+0x13c>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    fae4:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    fae8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    faec:	681b      	ldr	r3, [r3, #0]
    faee:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    faf0:	68bb      	ldr	r3, [r7, #8]
    faf2:	62da      	str	r2, [r3, #44]	; 0x2c
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
    faf4:	f04f 0301 	mov.w	r3, #1
    faf8:	60fb      	str	r3, [r7, #12]
    fafa:	e00c      	b.n	fb16 <xTaskPriorityInherit+0x15e>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    fafc:	68bb      	ldr	r3, [r7, #8]
    fafe:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    fb00:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    fb04:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fb08:	681b      	ldr	r3, [r3, #0]
    fb0a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    fb0c:	429a      	cmp	r2, r3
    fb0e:	d202      	bcs.n	fb16 <xTaskPriorityInherit+0x15e>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
    fb10:	f04f 0301 	mov.w	r3, #1
    fb14:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    fb16:	68fb      	ldr	r3, [r7, #12]
	}
    fb18:	4618      	mov	r0, r3
    fb1a:	f107 0710 	add.w	r7, r7, #16
    fb1e:	46bd      	mov	sp, r7
    fb20:	bd80      	pop	{r7, pc}
    fb22:	bf00      	nop

0000fb24 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    fb24:	b580      	push	{r7, lr}
    fb26:	b086      	sub	sp, #24
    fb28:	af00      	add	r7, sp, #0
    fb2a:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = pxMutexHolder;
    fb2c:	687b      	ldr	r3, [r7, #4]
    fb2e:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn = pdFALSE;
    fb30:	f04f 0300 	mov.w	r3, #0
    fb34:	60fb      	str	r3, [r7, #12]

		if( pxMutexHolder != NULL )
    fb36:	687b      	ldr	r3, [r7, #4]
    fb38:	2b00      	cmp	r3, #0
    fb3a:	f000 8092 	beq.w	fc62 <xTaskPriorityDisinherit+0x13e>
		{
			/* A task can only have an inherited priority if it holds the mutex.
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
    fb3e:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    fb42:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fb46:	681b      	ldr	r3, [r3, #0]
    fb48:	68ba      	ldr	r2, [r7, #8]
    fb4a:	429a      	cmp	r2, r3
    fb4c:	d009      	beq.n	fb62 <xTaskPriorityDisinherit+0x3e>
    fb4e:	f04f 0328 	mov.w	r3, #40	; 0x28
    fb52:	f383 8811 	msr	BASEPRI, r3
    fb56:	f3bf 8f6f 	isb	sy
    fb5a:	f3bf 8f4f 	dsb	sy
    fb5e:	613b      	str	r3, [r7, #16]
    fb60:	e7fe      	b.n	fb60 <xTaskPriorityDisinherit+0x3c>
			configASSERT( pxTCB->uxMutexesHeld );
    fb62:	68bb      	ldr	r3, [r7, #8]
    fb64:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    fb66:	2b00      	cmp	r3, #0
    fb68:	d109      	bne.n	fb7e <xTaskPriorityDisinherit+0x5a>
    fb6a:	f04f 0328 	mov.w	r3, #40	; 0x28
    fb6e:	f383 8811 	msr	BASEPRI, r3
    fb72:	f3bf 8f6f 	isb	sy
    fb76:	f3bf 8f4f 	dsb	sy
    fb7a:	617b      	str	r3, [r7, #20]
    fb7c:	e7fe      	b.n	fb7c <xTaskPriorityDisinherit+0x58>
			( pxTCB->uxMutexesHeld )--;
    fb7e:	68bb      	ldr	r3, [r7, #8]
    fb80:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    fb82:	f103 32ff 	add.w	r2, r3, #4294967295
    fb86:	68bb      	ldr	r3, [r7, #8]
    fb88:	64da      	str	r2, [r3, #76]	; 0x4c

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    fb8a:	68bb      	ldr	r3, [r7, #8]
    fb8c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    fb8e:	68bb      	ldr	r3, [r7, #8]
    fb90:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    fb92:	429a      	cmp	r2, r3
    fb94:	d065      	beq.n	fc62 <xTaskPriorityDisinherit+0x13e>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    fb96:	68bb      	ldr	r3, [r7, #8]
    fb98:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    fb9a:	2b00      	cmp	r3, #0
    fb9c:	d161      	bne.n	fc62 <xTaskPriorityDisinherit+0x13e>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    fb9e:	68bb      	ldr	r3, [r7, #8]
    fba0:	f103 0304 	add.w	r3, r3, #4
    fba4:	4618      	mov	r0, r3
    fba6:	f7fc fd8d 	bl	c6c4 <uxListRemove>
    fbaa:	4603      	mov	r3, r0
    fbac:	2b00      	cmp	r3, #0
    fbae:	d124      	bne.n	fbfa <xTaskPriorityDisinherit+0xd6>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
    fbb0:	68bb      	ldr	r3, [r7, #8]
    fbb2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    fbb4:	4613      	mov	r3, r2
    fbb6:	ea4f 0383 	mov.w	r3, r3, lsl #2
    fbba:	4413      	add	r3, r2
    fbbc:	ea4f 0383 	mov.w	r3, r3, lsl #2
    fbc0:	461a      	mov	r2, r3
    fbc2:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    fbc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fbca:	4413      	add	r3, r2
    fbcc:	681b      	ldr	r3, [r3, #0]
    fbce:	2b00      	cmp	r3, #0
    fbd0:	d113      	bne.n	fbfa <xTaskPriorityDisinherit+0xd6>
    fbd2:	68bb      	ldr	r3, [r7, #8]
    fbd4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    fbd6:	f04f 0201 	mov.w	r2, #1
    fbda:	fa02 f303 	lsl.w	r3, r2, r3
    fbde:	ea6f 0203 	mvn.w	r2, r3
    fbe2:	f243 03d4 	movw	r3, #12500	; 0x30d4
    fbe6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fbea:	681b      	ldr	r3, [r3, #0]
    fbec:	ea02 0203 	and.w	r2, r2, r3
    fbf0:	f243 03d4 	movw	r3, #12500	; 0x30d4
    fbf4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fbf8:	601a      	str	r2, [r3, #0]
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    fbfa:	68bb      	ldr	r3, [r7, #8]
    fbfc:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    fbfe:	68bb      	ldr	r3, [r7, #8]
    fc00:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    fc02:	68bb      	ldr	r3, [r7, #8]
    fc04:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    fc06:	f1c3 0205 	rsb	r2, r3, #5
    fc0a:	68bb      	ldr	r3, [r7, #8]
    fc0c:	619a      	str	r2, [r3, #24]
					prvAddTaskToReadyList( pxTCB );
    fc0e:	68bb      	ldr	r3, [r7, #8]
    fc10:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    fc12:	f04f 0201 	mov.w	r2, #1
    fc16:	fa02 f203 	lsl.w	r2, r2, r3
    fc1a:	f243 03d4 	movw	r3, #12500	; 0x30d4
    fc1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fc22:	681b      	ldr	r3, [r3, #0]
    fc24:	ea42 0203 	orr.w	r2, r2, r3
    fc28:	f243 03d4 	movw	r3, #12500	; 0x30d4
    fc2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fc30:	601a      	str	r2, [r3, #0]
    fc32:	68bb      	ldr	r3, [r7, #8]
    fc34:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    fc36:	4613      	mov	r3, r2
    fc38:	ea4f 0383 	mov.w	r3, r3, lsl #2
    fc3c:	4413      	add	r3, r2
    fc3e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    fc42:	461a      	mov	r2, r3
    fc44:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    fc48:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fc4c:	441a      	add	r2, r3
    fc4e:	68bb      	ldr	r3, [r7, #8]
    fc50:	f103 0304 	add.w	r3, r3, #4
    fc54:	4610      	mov	r0, r2
    fc56:	4619      	mov	r1, r3
    fc58:	f7fc fcd6 	bl	c608 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    fc5c:	f04f 0301 	mov.w	r3, #1
    fc60:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    fc62:	68fb      	ldr	r3, [r7, #12]
	}
    fc64:	4618      	mov	r0, r3
    fc66:	f107 0718 	add.w	r7, r7, #24
    fc6a:	46bd      	mov	sp, r7
    fc6c:	bd80      	pop	{r7, pc}
    fc6e:	bf00      	nop

0000fc70 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
    fc70:	b580      	push	{r7, lr}
    fc72:	b088      	sub	sp, #32
    fc74:	af00      	add	r7, sp, #0
    fc76:	6078      	str	r0, [r7, #4]
    fc78:	6039      	str	r1, [r7, #0]
	TCB_t * const pxTCB = pxMutexHolder;
    fc7a:	687b      	ldr	r3, [r7, #4]
    fc7c:	60bb      	str	r3, [r7, #8]
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
    fc7e:	f04f 0301 	mov.w	r3, #1
    fc82:	617b      	str	r3, [r7, #20]

		if( pxMutexHolder != NULL )
    fc84:	687b      	ldr	r3, [r7, #4]
    fc86:	2b00      	cmp	r3, #0
    fc88:	f000 80ac 	beq.w	fde4 <vTaskPriorityDisinheritAfterTimeout+0x174>
		{
			/* If pxMutexHolder is not NULL then the holder must hold at least
			one mutex. */
			configASSERT( pxTCB->uxMutexesHeld );
    fc8c:	68bb      	ldr	r3, [r7, #8]
    fc8e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    fc90:	2b00      	cmp	r3, #0
    fc92:	d109      	bne.n	fca8 <vTaskPriorityDisinheritAfterTimeout+0x38>
    fc94:	f04f 0328 	mov.w	r3, #40	; 0x28
    fc98:	f383 8811 	msr	BASEPRI, r3
    fc9c:	f3bf 8f6f 	isb	sy
    fca0:	f3bf 8f4f 	dsb	sy
    fca4:	61bb      	str	r3, [r7, #24]
    fca6:	e7fe      	b.n	fca6 <vTaskPriorityDisinheritAfterTimeout+0x36>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
    fca8:	68bb      	ldr	r3, [r7, #8]
    fcaa:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    fcac:	683b      	ldr	r3, [r7, #0]
    fcae:	429a      	cmp	r2, r3
    fcb0:	d202      	bcs.n	fcb8 <vTaskPriorityDisinheritAfterTimeout+0x48>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
    fcb2:	683b      	ldr	r3, [r7, #0]
    fcb4:	613b      	str	r3, [r7, #16]
    fcb6:	e002      	b.n	fcbe <vTaskPriorityDisinheritAfterTimeout+0x4e>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
    fcb8:	68bb      	ldr	r3, [r7, #8]
    fcba:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    fcbc:	613b      	str	r3, [r7, #16]
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
    fcbe:	68bb      	ldr	r3, [r7, #8]
    fcc0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    fcc2:	693b      	ldr	r3, [r7, #16]
    fcc4:	429a      	cmp	r2, r3
    fcc6:	f000 808d 	beq.w	fde4 <vTaskPriorityDisinheritAfterTimeout+0x174>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    fcca:	68bb      	ldr	r3, [r7, #8]
    fccc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    fcce:	697b      	ldr	r3, [r7, #20]
    fcd0:	429a      	cmp	r2, r3
    fcd2:	f040 8087 	bne.w	fde4 <vTaskPriorityDisinheritAfterTimeout+0x174>
				{
					/* If a task has timed out because it already holds the
					mutex it was trying to obtain then it cannot of inherited
					its own priority. */
					configASSERT( pxTCB != pxCurrentTCB );
    fcd6:	f642 73f4 	movw	r3, #12276	; 0x2ff4
    fcda:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fcde:	681b      	ldr	r3, [r3, #0]
    fce0:	68ba      	ldr	r2, [r7, #8]
    fce2:	429a      	cmp	r2, r3
    fce4:	d109      	bne.n	fcfa <vTaskPriorityDisinheritAfterTimeout+0x8a>
    fce6:	f04f 0328 	mov.w	r3, #40	; 0x28
    fcea:	f383 8811 	msr	BASEPRI, r3
    fcee:	f3bf 8f6f 	isb	sy
    fcf2:	f3bf 8f4f 	dsb	sy
    fcf6:	61fb      	str	r3, [r7, #28]
    fcf8:	e7fe      	b.n	fcf8 <vTaskPriorityDisinheritAfterTimeout+0x88>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
    fcfa:	68bb      	ldr	r3, [r7, #8]
    fcfc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    fcfe:	60fb      	str	r3, [r7, #12]
					pxTCB->uxPriority = uxPriorityToUse;
    fd00:	68bb      	ldr	r3, [r7, #8]
    fd02:	693a      	ldr	r2, [r7, #16]
    fd04:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    fd06:	68bb      	ldr	r3, [r7, #8]
    fd08:	699b      	ldr	r3, [r3, #24]
    fd0a:	2b00      	cmp	r3, #0
    fd0c:	db04      	blt.n	fd18 <vTaskPriorityDisinheritAfterTimeout+0xa8>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    fd0e:	693b      	ldr	r3, [r7, #16]
    fd10:	f1c3 0205 	rsb	r2, r3, #5
    fd14:	68bb      	ldr	r3, [r7, #8]
    fd16:	619a      	str	r2, [r3, #24]
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    fd18:	68bb      	ldr	r3, [r7, #8]
    fd1a:	6959      	ldr	r1, [r3, #20]
    fd1c:	68fa      	ldr	r2, [r7, #12]
    fd1e:	4613      	mov	r3, r2
    fd20:	ea4f 0383 	mov.w	r3, r3, lsl #2
    fd24:	4413      	add	r3, r2
    fd26:	ea4f 0383 	mov.w	r3, r3, lsl #2
    fd2a:	461a      	mov	r2, r3
    fd2c:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    fd30:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fd34:	4413      	add	r3, r2
    fd36:	4299      	cmp	r1, r3
    fd38:	d154      	bne.n	fde4 <vTaskPriorityDisinheritAfterTimeout+0x174>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    fd3a:	68bb      	ldr	r3, [r7, #8]
    fd3c:	f103 0304 	add.w	r3, r3, #4
    fd40:	4618      	mov	r0, r3
    fd42:	f7fc fcbf 	bl	c6c4 <uxListRemove>
    fd46:	4603      	mov	r3, r0
    fd48:	2b00      	cmp	r3, #0
    fd4a:	d124      	bne.n	fd96 <vTaskPriorityDisinheritAfterTimeout+0x126>
						{
							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
    fd4c:	68bb      	ldr	r3, [r7, #8]
    fd4e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    fd50:	4613      	mov	r3, r2
    fd52:	ea4f 0383 	mov.w	r3, r3, lsl #2
    fd56:	4413      	add	r3, r2
    fd58:	ea4f 0383 	mov.w	r3, r3, lsl #2
    fd5c:	461a      	mov	r2, r3
    fd5e:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    fd62:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fd66:	4413      	add	r3, r2
    fd68:	681b      	ldr	r3, [r3, #0]
    fd6a:	2b00      	cmp	r3, #0
    fd6c:	d113      	bne.n	fd96 <vTaskPriorityDisinheritAfterTimeout+0x126>
    fd6e:	68bb      	ldr	r3, [r7, #8]
    fd70:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    fd72:	f04f 0201 	mov.w	r2, #1
    fd76:	fa02 f303 	lsl.w	r3, r2, r3
    fd7a:	ea6f 0203 	mvn.w	r2, r3
    fd7e:	f243 03d4 	movw	r3, #12500	; 0x30d4
    fd82:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fd86:	681b      	ldr	r3, [r3, #0]
    fd88:	ea02 0203 	and.w	r2, r2, r3
    fd8c:	f243 03d4 	movw	r3, #12500	; 0x30d4
    fd90:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fd94:	601a      	str	r2, [r3, #0]
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
    fd96:	68bb      	ldr	r3, [r7, #8]
    fd98:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    fd9a:	f04f 0201 	mov.w	r2, #1
    fd9e:	fa02 f203 	lsl.w	r2, r2, r3
    fda2:	f243 03d4 	movw	r3, #12500	; 0x30d4
    fda6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fdaa:	681b      	ldr	r3, [r3, #0]
    fdac:	ea42 0203 	orr.w	r2, r2, r3
    fdb0:	f243 03d4 	movw	r3, #12500	; 0x30d4
    fdb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fdb8:	601a      	str	r2, [r3, #0]
    fdba:	68bb      	ldr	r3, [r7, #8]
    fdbc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    fdbe:	4613      	mov	r3, r2
    fdc0:	ea4f 0383 	mov.w	r3, r3, lsl #2
    fdc4:	4413      	add	r3, r2
    fdc6:	ea4f 0383 	mov.w	r3, r3, lsl #2
    fdca:	461a      	mov	r2, r3
    fdcc:	f642 73f8 	movw	r3, #12280	; 0x2ff8
    fdd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fdd4:	441a      	add	r2, r3
    fdd6:	68bb      	ldr	r3, [r7, #8]
    fdd8:	f103 0304 	add.w	r3, r3, #4
    fddc:	4610      	mov	r0, r2
    fdde:	4619      	mov	r1, r3
    fde0:	f7fc fc12 	bl	c608 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    fde4:	f107 0720 	add.w	r7, r7, #32
    fde8:	46bd      	mov	sp, r7
    fdea:	bd80      	pop	{r7, pc}

0000fdec <prvWriteNameToBuffer>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )

	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
	{
    fdec:	b580      	push	{r7, lr}
    fdee:	b084      	sub	sp, #16
    fdf0:	af00      	add	r7, sp, #0
    fdf2:	6078      	str	r0, [r7, #4]
    fdf4:	6039      	str	r1, [r7, #0]
	size_t x;

		/* Start by copying the entire string. */
		strcpy( pcBuffer, pcTaskName );
    fdf6:	6878      	ldr	r0, [r7, #4]
    fdf8:	6839      	ldr	r1, [r7, #0]
    fdfa:	f002 f8f5 	bl	11fe8 <strcpy>

		/* Pad the end of the string with spaces to ensure columns line up when
		printed out. */
		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
    fdfe:	6878      	ldr	r0, [r7, #4]
    fe00:	f002 f950 	bl	120a4 <strlen>
    fe04:	4603      	mov	r3, r0
    fe06:	60fb      	str	r3, [r7, #12]
    fe08:	e009      	b.n	fe1e <prvWriteNameToBuffer+0x32>
		{
			pcBuffer[ x ] = ' ';
    fe0a:	687a      	ldr	r2, [r7, #4]
    fe0c:	68fb      	ldr	r3, [r7, #12]
    fe0e:	4413      	add	r3, r2
    fe10:	f04f 0220 	mov.w	r2, #32
    fe14:	701a      	strb	r2, [r3, #0]
		/* Start by copying the entire string. */
		strcpy( pcBuffer, pcTaskName );

		/* Pad the end of the string with spaces to ensure columns line up when
		printed out. */
		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
    fe16:	68fb      	ldr	r3, [r7, #12]
    fe18:	f103 0301 	add.w	r3, r3, #1
    fe1c:	60fb      	str	r3, [r7, #12]
    fe1e:	68fb      	ldr	r3, [r7, #12]
    fe20:	2b08      	cmp	r3, #8
    fe22:	d9f2      	bls.n	fe0a <prvWriteNameToBuffer+0x1e>
		{
			pcBuffer[ x ] = ' ';
		}

		/* Terminate. */
		pcBuffer[ x ] = ( char ) 0x00;
    fe24:	687a      	ldr	r2, [r7, #4]
    fe26:	68fb      	ldr	r3, [r7, #12]
    fe28:	4413      	add	r3, r2
    fe2a:	f04f 0200 	mov.w	r2, #0
    fe2e:	701a      	strb	r2, [r3, #0]

		/* Return the new end of string. */
		return &( pcBuffer[ x ] );
    fe30:	687a      	ldr	r2, [r7, #4]
    fe32:	68fb      	ldr	r3, [r7, #12]
    fe34:	4413      	add	r3, r2
	}
    fe36:	4618      	mov	r0, r3
    fe38:	f107 0710 	add.w	r7, r7, #16
    fe3c:	46bd      	mov	sp, r7
    fe3e:	bd80      	pop	{r7, pc}

0000fe40 <vTaskList>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	void vTaskList( char * pcWriteBuffer )
	{
    fe40:	b580      	push	{r7, lr}
    fe42:	b088      	sub	sp, #32
    fe44:	af02      	add	r7, sp, #8
    fe46:	6078      	str	r0, [r7, #4]
		 * through a call to vTaskList().
		 */


		/* Make sure the write buffer does not contain a string. */
		*pcWriteBuffer = ( char ) 0x00;
    fe48:	687b      	ldr	r3, [r7, #4]
    fe4a:	f04f 0200 	mov.w	r2, #0
    fe4e:	701a      	strb	r2, [r3, #0]

		/* Take a snapshot of the number of tasks in case it changes while this
		function is executing. */
		uxArraySize = uxCurrentNumberOfTasks;
    fe50:	f243 03cc 	movw	r3, #12492	; 0x30cc
    fe54:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fe58:	681b      	ldr	r3, [r3, #0]
    fe5a:	60fb      	str	r3, [r7, #12]

		/* Allocate an array index for each task.  NOTE!  if
		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
		equate to NULL. */
		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */
    fe5c:	f243 03cc 	movw	r3, #12492	; 0x30cc
    fe60:	f2c2 0300 	movt	r3, #8192	; 0x2000
    fe64:	681a      	ldr	r2, [r3, #0]
    fe66:	4613      	mov	r3, r2
    fe68:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    fe6c:	4413      	add	r3, r2
    fe6e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    fe72:	4618      	mov	r0, r3
    fe74:	f001 f9e8 	bl	11248 <pvPortMalloc>
    fe78:	4603      	mov	r3, r0
    fe7a:	60bb      	str	r3, [r7, #8]

		if( pxTaskStatusArray != NULL )
    fe7c:	68bb      	ldr	r3, [r7, #8]
    fe7e:	2b00      	cmp	r3, #0
    fe80:	f000 8091 	beq.w	ffa6 <vTaskList+0x166>
		{
			/* Generate the (binary) data. */
			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
    fe84:	68b8      	ldr	r0, [r7, #8]
    fe86:	68f9      	ldr	r1, [r7, #12]
    fe88:	f04f 0200 	mov.w	r2, #0
    fe8c:	f7fe feb0 	bl	ebf0 <uxTaskGetSystemState>
    fe90:	4603      	mov	r3, r0
    fe92:	60fb      	str	r3, [r7, #12]

			/* Create a human readable table from the binary data. */
			for( x = 0; x < uxArraySize; x++ )
    fe94:	f04f 0300 	mov.w	r3, #0
    fe98:	613b      	str	r3, [r7, #16]
    fe9a:	e07c      	b.n	ff96 <vTaskList+0x156>
			{
				switch( pxTaskStatusArray[ x ].eCurrentState )
    fe9c:	693a      	ldr	r2, [r7, #16]
    fe9e:	4613      	mov	r3, r2
    fea0:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    fea4:	4413      	add	r3, r2
    fea6:	ea4f 0383 	mov.w	r3, r3, lsl #2
    feaa:	461a      	mov	r2, r3
    feac:	68bb      	ldr	r3, [r7, #8]
    feae:	4413      	add	r3, r2
    feb0:	7b1b      	ldrb	r3, [r3, #12]
    feb2:	2b04      	cmp	r3, #4
    feb4:	d820      	bhi.n	fef8 <vTaskList+0xb8>
    feb6:	a201      	add	r2, pc, #4	; (adr r2, febc <vTaskList+0x7c>)
    feb8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    febc:	0000fed1 	.word	0x0000fed1
    fec0:	0000fed9 	.word	0x0000fed9
    fec4:	0000fee1 	.word	0x0000fee1
    fec8:	0000fee9 	.word	0x0000fee9
    fecc:	0000fef1 	.word	0x0000fef1
				{
					case eRunning:		cStatus = tskRUNNING_CHAR;
    fed0:	f04f 0358 	mov.w	r3, #88	; 0x58
    fed4:	75fb      	strb	r3, [r7, #23]
										break;
    fed6:	e012      	b.n	fefe <vTaskList+0xbe>

					case eReady:		cStatus = tskREADY_CHAR;
    fed8:	f04f 0352 	mov.w	r3, #82	; 0x52
    fedc:	75fb      	strb	r3, [r7, #23]
										break;
    fede:	e00e      	b.n	fefe <vTaskList+0xbe>

					case eBlocked:		cStatus = tskBLOCKED_CHAR;
    fee0:	f04f 0342 	mov.w	r3, #66	; 0x42
    fee4:	75fb      	strb	r3, [r7, #23]
										break;
    fee6:	e00a      	b.n	fefe <vTaskList+0xbe>

					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
    fee8:	f04f 0353 	mov.w	r3, #83	; 0x53
    feec:	75fb      	strb	r3, [r7, #23]
										break;
    feee:	e006      	b.n	fefe <vTaskList+0xbe>

					case eDeleted:		cStatus = tskDELETED_CHAR;
    fef0:	f04f 0344 	mov.w	r3, #68	; 0x44
    fef4:	75fb      	strb	r3, [r7, #23]
										break;
    fef6:	e002      	b.n	fefe <vTaskList+0xbe>

					case eInvalid:		/* Fall through. */
					default:			/* Should not get here, but it is included
										to prevent static checking errors. */
										cStatus = ( char ) 0x00;
    fef8:	f04f 0300 	mov.w	r3, #0
    fefc:	75fb      	strb	r3, [r7, #23]
										break;
				}

				/* Write the task name to the string, padding with spaces so it
				can be printed in tabular form more easily. */
				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
    fefe:	693a      	ldr	r2, [r7, #16]
    ff00:	4613      	mov	r3, r2
    ff02:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    ff06:	4413      	add	r3, r2
    ff08:	ea4f 0383 	mov.w	r3, r3, lsl #2
    ff0c:	461a      	mov	r2, r3
    ff0e:	68bb      	ldr	r3, [r7, #8]
    ff10:	4413      	add	r3, r2
    ff12:	685b      	ldr	r3, [r3, #4]
    ff14:	6878      	ldr	r0, [r7, #4]
    ff16:	4619      	mov	r1, r3
    ff18:	f7ff ff68 	bl	fdec <prvWriteNameToBuffer>
    ff1c:	4603      	mov	r3, r0
    ff1e:	607b      	str	r3, [r7, #4]

				/* Write the rest of the string. */
				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
    ff20:	f897 e017 	ldrb.w	lr, [r7, #23]
    ff24:	693a      	ldr	r2, [r7, #16]
    ff26:	4613      	mov	r3, r2
    ff28:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    ff2c:	4413      	add	r3, r2
    ff2e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    ff32:	461a      	mov	r2, r3
    ff34:	68bb      	ldr	r3, [r7, #8]
    ff36:	4413      	add	r3, r2
    ff38:	f8d3 c010 	ldr.w	ip, [r3, #16]
    ff3c:	693a      	ldr	r2, [r7, #16]
    ff3e:	4613      	mov	r3, r2
    ff40:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    ff44:	4413      	add	r3, r2
    ff46:	ea4f 0383 	mov.w	r3, r3, lsl #2
    ff4a:	461a      	mov	r2, r3
    ff4c:	68bb      	ldr	r3, [r7, #8]
    ff4e:	4413      	add	r3, r2
    ff50:	8c1b      	ldrh	r3, [r3, #32]
    ff52:	4619      	mov	r1, r3
    ff54:	693a      	ldr	r2, [r7, #16]
    ff56:	4613      	mov	r3, r2
    ff58:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    ff5c:	4413      	add	r3, r2
    ff5e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    ff62:	461a      	mov	r2, r3
    ff64:	68bb      	ldr	r3, [r7, #8]
    ff66:	4413      	add	r3, r2
    ff68:	689b      	ldr	r3, [r3, #8]
    ff6a:	9100      	str	r1, [sp, #0]
    ff6c:	9301      	str	r3, [sp, #4]
    ff6e:	6878      	ldr	r0, [r7, #4]
    ff70:	f24c 21e8 	movw	r1, #49896	; 0xc2e8
    ff74:	f2c0 0101 	movt	r1, #1
    ff78:	4672      	mov	r2, lr
    ff7a:	4663      	mov	r3, ip
    ff7c:	f7f1 f8d2 	bl	1124 <sprintf>
				pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
    ff80:	6878      	ldr	r0, [r7, #4]
    ff82:	f002 f88f 	bl	120a4 <strlen>
    ff86:	4603      	mov	r3, r0
    ff88:	687a      	ldr	r2, [r7, #4]
    ff8a:	4413      	add	r3, r2
    ff8c:	607b      	str	r3, [r7, #4]
		{
			/* Generate the (binary) data. */
			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );

			/* Create a human readable table from the binary data. */
			for( x = 0; x < uxArraySize; x++ )
    ff8e:	693b      	ldr	r3, [r7, #16]
    ff90:	f103 0301 	add.w	r3, r3, #1
    ff94:	613b      	str	r3, [r7, #16]
    ff96:	693a      	ldr	r2, [r7, #16]
    ff98:	68fb      	ldr	r3, [r7, #12]
    ff9a:	429a      	cmp	r2, r3
    ff9c:	f4ff af7e 	bcc.w	fe9c <vTaskList+0x5c>
				pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
			}

			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
			is 0 then vPortFree() will be #defined to nothing. */
			vPortFree( pxTaskStatusArray );
    ffa0:	68b8      	ldr	r0, [r7, #8]
    ffa2:	f001 fa07 	bl	113b4 <vPortFree>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    ffa6:	f107 0718 	add.w	r7, r7, #24
    ffaa:	46bd      	mov	sp, r7
    ffac:	bd80      	pop	{r7, pc}
    ffae:	bf00      	nop

0000ffb0 <vTaskGetRunTimeStats>:
/*----------------------------------------------------------*/

#if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	void vTaskGetRunTimeStats( char *pcWriteBuffer )
	{
    ffb0:	b580      	push	{r7, lr}
    ffb2:	b088      	sub	sp, #32
    ffb4:	af00      	add	r7, sp, #0
    ffb6:	6078      	str	r0, [r7, #4]
		 * directly to get access to raw stats data, rather than indirectly
		 * through a call to vTaskGetRunTimeStats().
		 */

		/* Make sure the write buffer does not contain a string. */
		*pcWriteBuffer = ( char ) 0x00;
    ffb8:	687b      	ldr	r3, [r7, #4]
    ffba:	f04f 0200 	mov.w	r2, #0
    ffbe:	701a      	strb	r2, [r3, #0]

		/* Take a snapshot of the number of tasks in case it changes while this
		function is executing. */
		uxArraySize = uxCurrentNumberOfTasks;
    ffc0:	f243 03cc 	movw	r3, #12492	; 0x30cc
    ffc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ffc8:	681b      	ldr	r3, [r3, #0]
    ffca:	617b      	str	r3, [r7, #20]

		/* Allocate an array index for each task.  NOTE!  If
		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
		equate to NULL. */
		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */
    ffcc:	f243 03cc 	movw	r3, #12492	; 0x30cc
    ffd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ffd4:	681a      	ldr	r2, [r3, #0]
    ffd6:	4613      	mov	r3, r2
    ffd8:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    ffdc:	4413      	add	r3, r2
    ffde:	ea4f 0383 	mov.w	r3, r3, lsl #2
    ffe2:	4618      	mov	r0, r3
    ffe4:	f001 f930 	bl	11248 <pvPortMalloc>
    ffe8:	4603      	mov	r3, r0
    ffea:	613b      	str	r3, [r7, #16]

		if( pxTaskStatusArray != NULL )
    ffec:	693b      	ldr	r3, [r7, #16]
    ffee:	2b00      	cmp	r3, #0
    fff0:	d076      	beq.n	100e0 <RAM_SIZE+0xe0>
		{
			/* Generate the (binary) data. */
			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
    fff2:	f107 030c 	add.w	r3, r7, #12
    fff6:	6938      	ldr	r0, [r7, #16]
    fff8:	6979      	ldr	r1, [r7, #20]
    fffa:	461a      	mov	r2, r3
    fffc:	f7fe fdf8 	bl	ebf0 <uxTaskGetSystemState>
   10000:	4603      	mov	r3, r0
   10002:	617b      	str	r3, [r7, #20]

			/* For percentage calculations. */
			ulTotalTime /= 100UL;
   10004:	68fa      	ldr	r2, [r7, #12]
   10006:	f248 531f 	movw	r3, #34079	; 0x851f
   1000a:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
   1000e:	fba3 1302 	umull	r1, r3, r3, r2
   10012:	ea4f 1353 	mov.w	r3, r3, lsr #5
   10016:	60fb      	str	r3, [r7, #12]

			/* Avoid divide by zero errors. */
			if( ulTotalTime > 0UL )
   10018:	68fb      	ldr	r3, [r7, #12]
   1001a:	2b00      	cmp	r3, #0
   1001c:	d05d      	beq.n	100da <RAM_SIZE+0xda>
			{
				/* Create a human readable table from the binary data. */
				for( x = 0; x < uxArraySize; x++ )
   1001e:	f04f 0300 	mov.w	r3, #0
   10022:	61bb      	str	r3, [r7, #24]
   10024:	e055      	b.n	100d2 <RAM_SIZE+0xd2>
				{
					/* What percentage of the total run time has the task used?
					This will always be rounded down to the nearest integer.
					ulTotalRunTimeDiv100 has already been divided by 100. */
					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
   10026:	69ba      	ldr	r2, [r7, #24]
   10028:	4613      	mov	r3, r2
   1002a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   1002e:	4413      	add	r3, r2
   10030:	ea4f 0383 	mov.w	r3, r3, lsl #2
   10034:	461a      	mov	r2, r3
   10036:	693b      	ldr	r3, [r7, #16]
   10038:	4413      	add	r3, r2
   1003a:	699a      	ldr	r2, [r3, #24]
   1003c:	68fb      	ldr	r3, [r7, #12]
   1003e:	fbb2 f3f3 	udiv	r3, r2, r3
   10042:	61fb      	str	r3, [r7, #28]

					/* Write the task name to the string, padding with
					spaces so it can be printed in tabular form more
					easily. */
					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
   10044:	69ba      	ldr	r2, [r7, #24]
   10046:	4613      	mov	r3, r2
   10048:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   1004c:	4413      	add	r3, r2
   1004e:	ea4f 0383 	mov.w	r3, r3, lsl #2
   10052:	461a      	mov	r2, r3
   10054:	693b      	ldr	r3, [r7, #16]
   10056:	4413      	add	r3, r2
   10058:	685b      	ldr	r3, [r3, #4]
   1005a:	6878      	ldr	r0, [r7, #4]
   1005c:	4619      	mov	r1, r3
   1005e:	f7ff fec5 	bl	fdec <prvWriteNameToBuffer>
   10062:	4603      	mov	r3, r0
   10064:	607b      	str	r3, [r7, #4]

					if( ulStatsAsPercentage > 0UL )
   10066:	69fb      	ldr	r3, [r7, #28]
   10068:	2b00      	cmp	r3, #0
   1006a:	d014      	beq.n	10096 <RAM_SIZE+0x96>
						}
						#else
						{
							/* sizeof( int ) == sizeof( long ) so a smaller
							printf() library can be used. */
							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
   1006c:	69ba      	ldr	r2, [r7, #24]
   1006e:	4613      	mov	r3, r2
   10070:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   10074:	4413      	add	r3, r2
   10076:	ea4f 0383 	mov.w	r3, r3, lsl #2
   1007a:	461a      	mov	r2, r3
   1007c:	693b      	ldr	r3, [r7, #16]
   1007e:	4413      	add	r3, r2
   10080:	699b      	ldr	r3, [r3, #24]
   10082:	6878      	ldr	r0, [r7, #4]
   10084:	f24c 21f8 	movw	r1, #49912	; 0xc2f8
   10088:	f2c0 0101 	movt	r1, #1
   1008c:	461a      	mov	r2, r3
   1008e:	69fb      	ldr	r3, [r7, #28]
   10090:	f7f1 f848 	bl	1124 <sprintf>
   10094:	e012      	b.n	100bc <RAM_SIZE+0xbc>
						}
						#else
						{
							/* sizeof( int ) == sizeof( long ) so a smaller
							printf() library can be used. */
							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
   10096:	69ba      	ldr	r2, [r7, #24]
   10098:	4613      	mov	r3, r2
   1009a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   1009e:	4413      	add	r3, r2
   100a0:	ea4f 0383 	mov.w	r3, r3, lsl #2
   100a4:	461a      	mov	r2, r3
   100a6:	693b      	ldr	r3, [r7, #16]
   100a8:	4413      	add	r3, r2
   100aa:	699b      	ldr	r3, [r3, #24]
   100ac:	6878      	ldr	r0, [r7, #4]
   100ae:	f24c 3104 	movw	r1, #49924	; 0xc304
   100b2:	f2c0 0101 	movt	r1, #1
   100b6:	461a      	mov	r2, r3
   100b8:	f7f1 f834 	bl	1124 <sprintf>
						}
						#endif
					}

					pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
   100bc:	6878      	ldr	r0, [r7, #4]
   100be:	f001 fff1 	bl	120a4 <strlen>
   100c2:	4603      	mov	r3, r0
   100c4:	687a      	ldr	r2, [r7, #4]
   100c6:	4413      	add	r3, r2
   100c8:	607b      	str	r3, [r7, #4]

			/* Avoid divide by zero errors. */
			if( ulTotalTime > 0UL )
			{
				/* Create a human readable table from the binary data. */
				for( x = 0; x < uxArraySize; x++ )
   100ca:	69bb      	ldr	r3, [r7, #24]
   100cc:	f103 0301 	add.w	r3, r3, #1
   100d0:	61bb      	str	r3, [r7, #24]
   100d2:	69ba      	ldr	r2, [r7, #24]
   100d4:	697b      	ldr	r3, [r7, #20]
   100d6:	429a      	cmp	r2, r3
   100d8:	d3a5      	bcc.n	10026 <RAM_SIZE+0x26>
				mtCOVERAGE_TEST_MARKER();
			}

			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
			is 0 then vPortFree() will be #defined to nothing. */
			vPortFree( pxTaskStatusArray );
   100da:	6938      	ldr	r0, [r7, #16]
   100dc:	f001 f96a 	bl	113b4 <vPortFree>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   100e0:	f107 0720 	add.w	r7, r7, #32
   100e4:	46bd      	mov	sp, r7
   100e6:	bd80      	pop	{r7, pc}

000100e8 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
   100e8:	b480      	push	{r7}
   100ea:	b083      	sub	sp, #12
   100ec:	af00      	add	r7, sp, #0
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
   100ee:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   100f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   100f6:	681b      	ldr	r3, [r3, #0]
   100f8:	699b      	ldr	r3, [r3, #24]
   100fa:	607b      	str	r3, [r7, #4]

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   100fc:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10100:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10104:	681a      	ldr	r2, [r3, #0]
   10106:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   1010a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1010e:	681b      	ldr	r3, [r3, #0]
   10110:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   10112:	f1c3 0305 	rsb	r3, r3, #5
   10116:	6193      	str	r3, [r2, #24]

	return uxReturn;
   10118:	687b      	ldr	r3, [r7, #4]
}
   1011a:	4618      	mov	r0, r3
   1011c:	f107 070c 	add.w	r7, r7, #12
   10120:	46bd      	mov	sp, r7
   10122:	bc80      	pop	{r7}
   10124:	4770      	bx	lr
   10126:	bf00      	nop

00010128 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
   10128:	b480      	push	{r7}
   1012a:	af00      	add	r7, sp, #0
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
   1012c:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10130:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10134:	681b      	ldr	r3, [r3, #0]
   10136:	2b00      	cmp	r3, #0
   10138:	d008      	beq.n	1014c <pvTaskIncrementMutexHeldCount+0x24>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
   1013a:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   1013e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10142:	681b      	ldr	r3, [r3, #0]
   10144:	6cda      	ldr	r2, [r3, #76]	; 0x4c
   10146:	f102 0201 	add.w	r2, r2, #1
   1014a:	64da      	str	r2, [r3, #76]	; 0x4c
		}

		return pxCurrentTCB;
   1014c:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10150:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10154:	681b      	ldr	r3, [r3, #0]
	}
   10156:	4618      	mov	r0, r3
   10158:	46bd      	mov	sp, r7
   1015a:	bc80      	pop	{r7}
   1015c:	4770      	bx	lr
   1015e:	bf00      	nop

00010160 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
   10160:	b580      	push	{r7, lr}
   10162:	b084      	sub	sp, #16
   10164:	af00      	add	r7, sp, #0
   10166:	6078      	str	r0, [r7, #4]
   10168:	6039      	str	r1, [r7, #0]
	uint32_t ulReturn;

		taskENTER_CRITICAL();
   1016a:	f001 faed 	bl	11748 <vPortEnterCritical>
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
   1016e:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10172:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10176:	681b      	ldr	r3, [r3, #0]
   10178:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   1017a:	2b00      	cmp	r3, #0
   1017c:	d11b      	bne.n	101b6 <ulTaskNotifyTake+0x56>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
   1017e:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10182:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10186:	681b      	ldr	r3, [r3, #0]
   10188:	f04f 0201 	mov.w	r2, #1
   1018c:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

				if( xTicksToWait > ( TickType_t ) 0 )
   10190:	683b      	ldr	r3, [r7, #0]
   10192:	2b00      	cmp	r3, #0
   10194:	d00f      	beq.n	101b6 <ulTaskNotifyTake+0x56>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   10196:	6838      	ldr	r0, [r7, #0]
   10198:	f04f 0101 	mov.w	r1, #1
   1019c:	f000 fb3a 	bl	10814 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
   101a0:	f64e 5304 	movw	r3, #60676	; 0xed04
   101a4:	f2ce 0300 	movt	r3, #57344	; 0xe000
   101a8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   101ac:	601a      	str	r2, [r3, #0]
   101ae:	f3bf 8f4f 	dsb	sy
   101b2:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
   101b6:	f001 faff 	bl	117b8 <vPortExitCritical>

		taskENTER_CRITICAL();
   101ba:	f001 fac5 	bl	11748 <vPortEnterCritical>
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
   101be:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   101c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   101c6:	681b      	ldr	r3, [r3, #0]
   101c8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   101ca:	60fb      	str	r3, [r7, #12]

			if( ulReturn != 0UL )
   101cc:	68fb      	ldr	r3, [r7, #12]
   101ce:	2b00      	cmp	r3, #0
   101d0:	d014      	beq.n	101fc <ulTaskNotifyTake+0x9c>
			{
				if( xClearCountOnExit != pdFALSE )
   101d2:	687b      	ldr	r3, [r7, #4]
   101d4:	2b00      	cmp	r3, #0
   101d6:	d008      	beq.n	101ea <ulTaskNotifyTake+0x8a>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
   101d8:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   101dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   101e0:	681b      	ldr	r3, [r3, #0]
   101e2:	f04f 0200 	mov.w	r2, #0
   101e6:	655a      	str	r2, [r3, #84]	; 0x54
   101e8:	e008      	b.n	101fc <ulTaskNotifyTake+0x9c>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
   101ea:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   101ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
   101f2:	681b      	ldr	r3, [r3, #0]
   101f4:	68fa      	ldr	r2, [r7, #12]
   101f6:	f102 32ff 	add.w	r2, r2, #4294967295
   101fa:	655a      	str	r2, [r3, #84]	; 0x54
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   101fc:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10200:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10204:	681b      	ldr	r3, [r3, #0]
   10206:	f04f 0200 	mov.w	r2, #0
   1020a:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
		}
		taskEXIT_CRITICAL();
   1020e:	f001 fad3 	bl	117b8 <vPortExitCritical>

		return ulReturn;
   10212:	68fb      	ldr	r3, [r7, #12]
	}
   10214:	4618      	mov	r0, r3
   10216:	f107 0710 	add.w	r7, r7, #16
   1021a:	46bd      	mov	sp, r7
   1021c:	bd80      	pop	{r7, pc}
   1021e:	bf00      	nop

00010220 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
   10220:	b580      	push	{r7, lr}
   10222:	b086      	sub	sp, #24
   10224:	af00      	add	r7, sp, #0
   10226:	60f8      	str	r0, [r7, #12]
   10228:	60b9      	str	r1, [r7, #8]
   1022a:	607a      	str	r2, [r7, #4]
   1022c:	603b      	str	r3, [r7, #0]
	BaseType_t xReturn;

		taskENTER_CRITICAL();
   1022e:	f001 fa8b 	bl	11748 <vPortEnterCritical>
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
   10232:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10236:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1023a:	681b      	ldr	r3, [r3, #0]
   1023c:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
   10240:	b2db      	uxtb	r3, r3
   10242:	2b02      	cmp	r3, #2
   10244:	d027      	beq.n	10296 <xTaskNotifyWait+0x76>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
   10246:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   1024a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1024e:	681b      	ldr	r3, [r3, #0]
   10250:	6d59      	ldr	r1, [r3, #84]	; 0x54
   10252:	68fa      	ldr	r2, [r7, #12]
   10254:	ea6f 0202 	mvn.w	r2, r2
   10258:	ea01 0202 	and.w	r2, r1, r2
   1025c:	655a      	str	r2, [r3, #84]	; 0x54

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
   1025e:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10262:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10266:	681b      	ldr	r3, [r3, #0]
   10268:	f04f 0201 	mov.w	r2, #1
   1026c:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

				if( xTicksToWait > ( TickType_t ) 0 )
   10270:	683b      	ldr	r3, [r7, #0]
   10272:	2b00      	cmp	r3, #0
   10274:	d00f      	beq.n	10296 <xTaskNotifyWait+0x76>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   10276:	6838      	ldr	r0, [r7, #0]
   10278:	f04f 0101 	mov.w	r1, #1
   1027c:	f000 faca 	bl	10814 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
   10280:	f64e 5304 	movw	r3, #60676	; 0xed04
   10284:	f2ce 0300 	movt	r3, #57344	; 0xe000
   10288:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1028c:	601a      	str	r2, [r3, #0]
   1028e:	f3bf 8f4f 	dsb	sy
   10292:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
   10296:	f001 fa8f 	bl	117b8 <vPortExitCritical>

		taskENTER_CRITICAL();
   1029a:	f001 fa55 	bl	11748 <vPortEnterCritical>
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
   1029e:	687b      	ldr	r3, [r7, #4]
   102a0:	2b00      	cmp	r3, #0
   102a2:	d007      	beq.n	102b4 <xTaskNotifyWait+0x94>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
   102a4:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   102a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   102ac:	681b      	ldr	r3, [r3, #0]
   102ae:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   102b0:	687b      	ldr	r3, [r7, #4]
   102b2:	601a      	str	r2, [r3, #0]

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
   102b4:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   102b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   102bc:	681b      	ldr	r3, [r3, #0]
   102be:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
   102c2:	b2db      	uxtb	r3, r3
   102c4:	2b02      	cmp	r3, #2
   102c6:	d003      	beq.n	102d0 <xTaskNotifyWait+0xb0>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
   102c8:	f04f 0300 	mov.w	r3, #0
   102cc:	617b      	str	r3, [r7, #20]
   102ce:	e00e      	b.n	102ee <xTaskNotifyWait+0xce>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
   102d0:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   102d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   102d8:	681b      	ldr	r3, [r3, #0]
   102da:	6d59      	ldr	r1, [r3, #84]	; 0x54
   102dc:	68ba      	ldr	r2, [r7, #8]
   102de:	ea6f 0202 	mvn.w	r2, r2
   102e2:	ea01 0202 	and.w	r2, r1, r2
   102e6:	655a      	str	r2, [r3, #84]	; 0x54
				xReturn = pdTRUE;
   102e8:	f04f 0301 	mov.w	r3, #1
   102ec:	617b      	str	r3, [r7, #20]
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   102ee:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   102f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   102f6:	681b      	ldr	r3, [r3, #0]
   102f8:	f04f 0200 	mov.w	r2, #0
   102fc:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
		}
		taskEXIT_CRITICAL();
   10300:	f001 fa5a 	bl	117b8 <vPortExitCritical>

		return xReturn;
   10304:	697b      	ldr	r3, [r7, #20]
	}
   10306:	4618      	mov	r0, r3
   10308:	f107 0718 	add.w	r7, r7, #24
   1030c:	46bd      	mov	sp, r7
   1030e:	bd80      	pop	{r7, pc}

00010310 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
   10310:	b580      	push	{r7, lr}
   10312:	b08a      	sub	sp, #40	; 0x28
   10314:	af00      	add	r7, sp, #0
   10316:	60f8      	str	r0, [r7, #12]
   10318:	60b9      	str	r1, [r7, #8]
   1031a:	603b      	str	r3, [r7, #0]
   1031c:	4613      	mov	r3, r2
   1031e:	71fb      	strb	r3, [r7, #7]
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
   10320:	f04f 0301 	mov.w	r3, #1
   10324:	617b      	str	r3, [r7, #20]
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
   10326:	68fb      	ldr	r3, [r7, #12]
   10328:	2b00      	cmp	r3, #0
   1032a:	d109      	bne.n	10340 <xTaskGenericNotify+0x30>
   1032c:	f04f 0328 	mov.w	r3, #40	; 0x28
   10330:	f383 8811 	msr	BASEPRI, r3
   10334:	f3bf 8f6f 	isb	sy
   10338:	f3bf 8f4f 	dsb	sy
   1033c:	61fb      	str	r3, [r7, #28]
   1033e:	e7fe      	b.n	1033e <xTaskGenericNotify+0x2e>
		pxTCB = xTaskToNotify;
   10340:	68fb      	ldr	r3, [r7, #12]
   10342:	613b      	str	r3, [r7, #16]

		taskENTER_CRITICAL();
   10344:	f001 fa00 	bl	11748 <vPortEnterCritical>
		{
			if( pulPreviousNotificationValue != NULL )
   10348:	683b      	ldr	r3, [r7, #0]
   1034a:	2b00      	cmp	r3, #0
   1034c:	d003      	beq.n	10356 <xTaskGenericNotify+0x46>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
   1034e:	693b      	ldr	r3, [r7, #16]
   10350:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   10352:	683b      	ldr	r3, [r7, #0]
   10354:	601a      	str	r2, [r3, #0]
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
   10356:	693b      	ldr	r3, [r7, #16]
   10358:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
   1035c:	76fb      	strb	r3, [r7, #27]

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   1035e:	693b      	ldr	r3, [r7, #16]
   10360:	f04f 0202 	mov.w	r2, #2
   10364:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

			switch( eAction )
   10368:	79fb      	ldrb	r3, [r7, #7]
   1036a:	2b04      	cmp	r3, #4
   1036c:	d82a      	bhi.n	103c4 <xTaskGenericNotify+0xb4>
   1036e:	a201      	add	r2, pc, #4	; (adr r2, 10374 <xTaskGenericNotify+0x64>)
   10370:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   10374:	000103e3 	.word	0x000103e3
   10378:	00010389 	.word	0x00010389
   1037c:	00010399 	.word	0x00010399
   10380:	000103a7 	.word	0x000103a7
   10384:	000103af 	.word	0x000103af
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
   10388:	693b      	ldr	r3, [r7, #16]
   1038a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   1038c:	68bb      	ldr	r3, [r7, #8]
   1038e:	ea42 0203 	orr.w	r2, r2, r3
   10392:	693b      	ldr	r3, [r7, #16]
   10394:	655a      	str	r2, [r3, #84]	; 0x54
					break;
   10396:	e025      	b.n	103e4 <xTaskGenericNotify+0xd4>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
   10398:	693b      	ldr	r3, [r7, #16]
   1039a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   1039c:	f103 0201 	add.w	r2, r3, #1
   103a0:	693b      	ldr	r3, [r7, #16]
   103a2:	655a      	str	r2, [r3, #84]	; 0x54
					break;
   103a4:	e01e      	b.n	103e4 <xTaskGenericNotify+0xd4>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
   103a6:	693b      	ldr	r3, [r7, #16]
   103a8:	68ba      	ldr	r2, [r7, #8]
   103aa:	655a      	str	r2, [r3, #84]	; 0x54
					break;
   103ac:	e01a      	b.n	103e4 <xTaskGenericNotify+0xd4>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
   103ae:	7efb      	ldrb	r3, [r7, #27]
   103b0:	2b02      	cmp	r3, #2
   103b2:	d003      	beq.n	103bc <xTaskGenericNotify+0xac>
					{
						pxTCB->ulNotifiedValue = ulValue;
   103b4:	693b      	ldr	r3, [r7, #16]
   103b6:	68ba      	ldr	r2, [r7, #8]
   103b8:	655a      	str	r2, [r3, #84]	; 0x54
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
   103ba:	e013      	b.n	103e4 <xTaskGenericNotify+0xd4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
   103bc:	f04f 0300 	mov.w	r3, #0
   103c0:	617b      	str	r3, [r7, #20]
					}
					break;
   103c2:	e00f      	b.n	103e4 <xTaskGenericNotify+0xd4>

				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
   103c4:	693b      	ldr	r3, [r7, #16]
   103c6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   103c8:	f1b3 3fff 	cmp.w	r3, #4294967295
   103cc:	d00a      	beq.n	103e4 <xTaskGenericNotify+0xd4>
   103ce:	f04f 0328 	mov.w	r3, #40	; 0x28
   103d2:	f383 8811 	msr	BASEPRI, r3
   103d6:	f3bf 8f6f 	isb	sy
   103da:	f3bf 8f4f 	dsb	sy
   103de:	623b      	str	r3, [r7, #32]
   103e0:	e7fe      	b.n	103e0 <xTaskGenericNotify+0xd0>
					break;

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
   103e2:	bf00      	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   103e4:	7efb      	ldrb	r3, [r7, #27]
   103e6:	2b01      	cmp	r3, #1
   103e8:	d14f      	bne.n	1048a <xTaskGenericNotify+0x17a>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   103ea:	693b      	ldr	r3, [r7, #16]
   103ec:	f103 0304 	add.w	r3, r3, #4
   103f0:	4618      	mov	r0, r3
   103f2:	f7fc f967 	bl	c6c4 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
   103f6:	693b      	ldr	r3, [r7, #16]
   103f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   103fa:	f04f 0201 	mov.w	r2, #1
   103fe:	fa02 f203 	lsl.w	r2, r2, r3
   10402:	f243 03d4 	movw	r3, #12500	; 0x30d4
   10406:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1040a:	681b      	ldr	r3, [r3, #0]
   1040c:	ea42 0203 	orr.w	r2, r2, r3
   10410:	f243 03d4 	movw	r3, #12500	; 0x30d4
   10414:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10418:	601a      	str	r2, [r3, #0]
   1041a:	693b      	ldr	r3, [r7, #16]
   1041c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1041e:	4613      	mov	r3, r2
   10420:	ea4f 0383 	mov.w	r3, r3, lsl #2
   10424:	4413      	add	r3, r2
   10426:	ea4f 0383 	mov.w	r3, r3, lsl #2
   1042a:	461a      	mov	r2, r3
   1042c:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   10430:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10434:	441a      	add	r2, r3
   10436:	693b      	ldr	r3, [r7, #16]
   10438:	f103 0304 	add.w	r3, r3, #4
   1043c:	4610      	mov	r0, r2
   1043e:	4619      	mov	r1, r3
   10440:	f7fc f8e2 	bl	c608 <vListInsertEnd>

				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   10444:	693b      	ldr	r3, [r7, #16]
   10446:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   10448:	2b00      	cmp	r3, #0
   1044a:	d009      	beq.n	10460 <xTaskGenericNotify+0x150>
   1044c:	f04f 0328 	mov.w	r3, #40	; 0x28
   10450:	f383 8811 	msr	BASEPRI, r3
   10454:	f3bf 8f6f 	isb	sy
   10458:	f3bf 8f4f 	dsb	sy
   1045c:	627b      	str	r3, [r7, #36]	; 0x24
   1045e:	e7fe      	b.n	1045e <xTaskGenericNotify+0x14e>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   10460:	693b      	ldr	r3, [r7, #16]
   10462:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10464:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10468:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1046c:	681b      	ldr	r3, [r3, #0]
   1046e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   10470:	429a      	cmp	r2, r3
   10472:	d90a      	bls.n	1048a <xTaskGenericNotify+0x17a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
   10474:	f64e 5304 	movw	r3, #60676	; 0xed04
   10478:	f2ce 0300 	movt	r3, #57344	; 0xe000
   1047c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   10480:	601a      	str	r2, [r3, #0]
   10482:	f3bf 8f4f 	dsb	sy
   10486:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
   1048a:	f001 f995 	bl	117b8 <vPortExitCritical>

		return xReturn;
   1048e:	697b      	ldr	r3, [r7, #20]
	}
   10490:	4618      	mov	r0, r3
   10492:	f107 0728 	add.w	r7, r7, #40	; 0x28
   10496:	46bd      	mov	sp, r7
   10498:	bd80      	pop	{r7, pc}
   1049a:	bf00      	nop

0001049c <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
   1049c:	b580      	push	{r7, lr}
   1049e:	b08e      	sub	sp, #56	; 0x38
   104a0:	af00      	add	r7, sp, #0
   104a2:	60f8      	str	r0, [r7, #12]
   104a4:	60b9      	str	r1, [r7, #8]
   104a6:	603b      	str	r3, [r7, #0]
   104a8:	4613      	mov	r3, r2
   104aa:	71fb      	strb	r3, [r7, #7]
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
   104ac:	f04f 0301 	mov.w	r3, #1
   104b0:	61bb      	str	r3, [r7, #24]
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
   104b2:	68fb      	ldr	r3, [r7, #12]
   104b4:	2b00      	cmp	r3, #0
   104b6:	d109      	bne.n	104cc <xTaskGenericNotifyFromISR+0x30>
   104b8:	f04f 0328 	mov.w	r3, #40	; 0x28
   104bc:	f383 8811 	msr	BASEPRI, r3
   104c0:	f3bf 8f6f 	isb	sy
   104c4:	f3bf 8f4f 	dsb	sy
   104c8:	623b      	str	r3, [r7, #32]
   104ca:	e7fe      	b.n	104ca <xTaskGenericNotifyFromISR+0x2e>
		below the maximum system call interrupt priority.  FreeRTOS maintains a
		separate interrupt safe API to ensure interrupt entry is as fast and as
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   104cc:	f001 fa20 	bl	11910 <vPortValidateInterruptPriority>

		pxTCB = xTaskToNotify;
   104d0:	68fb      	ldr	r3, [r7, #12]
   104d2:	613b      	str	r3, [r7, #16]

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
   104d4:	f3ef 8211 	mrs	r2, BASEPRI
   104d8:	f04f 0328 	mov.w	r3, #40	; 0x28
   104dc:	f383 8811 	msr	BASEPRI, r3
   104e0:	f3bf 8f6f 	isb	sy
   104e4:	f3bf 8f4f 	dsb	sy
   104e8:	62ba      	str	r2, [r7, #40]	; 0x28
   104ea:	627b      	str	r3, [r7, #36]	; 0x24
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
   104ec:	6abb      	ldr	r3, [r7, #40]	; 0x28

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   104ee:	61fb      	str	r3, [r7, #28]
		{
			if( pulPreviousNotificationValue != NULL )
   104f0:	683b      	ldr	r3, [r7, #0]
   104f2:	2b00      	cmp	r3, #0
   104f4:	d003      	beq.n	104fe <xTaskGenericNotifyFromISR+0x62>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
   104f6:	693b      	ldr	r3, [r7, #16]
   104f8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   104fa:	683b      	ldr	r3, [r7, #0]
   104fc:	601a      	str	r2, [r3, #0]
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
   104fe:	693b      	ldr	r3, [r7, #16]
   10500:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
   10504:	75fb      	strb	r3, [r7, #23]
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   10506:	693b      	ldr	r3, [r7, #16]
   10508:	f04f 0202 	mov.w	r2, #2
   1050c:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

			switch( eAction )
   10510:	79fb      	ldrb	r3, [r7, #7]
   10512:	2b04      	cmp	r3, #4
   10514:	d82a      	bhi.n	1056c <xTaskGenericNotifyFromISR+0xd0>
   10516:	a201      	add	r2, pc, #4	; (adr r2, 1051c <xTaskGenericNotifyFromISR+0x80>)
   10518:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   1051c:	0001058b 	.word	0x0001058b
   10520:	00010531 	.word	0x00010531
   10524:	00010541 	.word	0x00010541
   10528:	0001054f 	.word	0x0001054f
   1052c:	00010557 	.word	0x00010557
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
   10530:	693b      	ldr	r3, [r7, #16]
   10532:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   10534:	68bb      	ldr	r3, [r7, #8]
   10536:	ea42 0203 	orr.w	r2, r2, r3
   1053a:	693b      	ldr	r3, [r7, #16]
   1053c:	655a      	str	r2, [r3, #84]	; 0x54
					break;
   1053e:	e025      	b.n	1058c <xTaskGenericNotifyFromISR+0xf0>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
   10540:	693b      	ldr	r3, [r7, #16]
   10542:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   10544:	f103 0201 	add.w	r2, r3, #1
   10548:	693b      	ldr	r3, [r7, #16]
   1054a:	655a      	str	r2, [r3, #84]	; 0x54
					break;
   1054c:	e01e      	b.n	1058c <xTaskGenericNotifyFromISR+0xf0>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
   1054e:	693b      	ldr	r3, [r7, #16]
   10550:	68ba      	ldr	r2, [r7, #8]
   10552:	655a      	str	r2, [r3, #84]	; 0x54
					break;
   10554:	e01a      	b.n	1058c <xTaskGenericNotifyFromISR+0xf0>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
   10556:	7dfb      	ldrb	r3, [r7, #23]
   10558:	2b02      	cmp	r3, #2
   1055a:	d003      	beq.n	10564 <xTaskGenericNotifyFromISR+0xc8>
					{
						pxTCB->ulNotifiedValue = ulValue;
   1055c:	693b      	ldr	r3, [r7, #16]
   1055e:	68ba      	ldr	r2, [r7, #8]
   10560:	655a      	str	r2, [r3, #84]	; 0x54
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
   10562:	e013      	b.n	1058c <xTaskGenericNotifyFromISR+0xf0>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
   10564:	f04f 0300 	mov.w	r3, #0
   10568:	61bb      	str	r3, [r7, #24]
					}
					break;
   1056a:	e00f      	b.n	1058c <xTaskGenericNotifyFromISR+0xf0>

				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
   1056c:	693b      	ldr	r3, [r7, #16]
   1056e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   10570:	f1b3 3fff 	cmp.w	r3, #4294967295
   10574:	d00a      	beq.n	1058c <xTaskGenericNotifyFromISR+0xf0>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   10576:	f04f 0328 	mov.w	r3, #40	; 0x28
   1057a:	f383 8811 	msr	BASEPRI, r3
   1057e:	f3bf 8f6f 	isb	sy
   10582:	f3bf 8f4f 	dsb	sy
   10586:	62fb      	str	r3, [r7, #44]	; 0x2c
   10588:	e7fe      	b.n	10588 <xTaskGenericNotifyFromISR+0xec>
					break;

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
   1058a:	bf00      	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   1058c:	7dfb      	ldrb	r3, [r7, #23]
   1058e:	2b01      	cmp	r3, #1
   10590:	d164      	bne.n	1065c <xTaskGenericNotifyFromISR+0x1c0>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   10592:	693b      	ldr	r3, [r7, #16]
   10594:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   10596:	2b00      	cmp	r3, #0
   10598:	d009      	beq.n	105ae <xTaskGenericNotifyFromISR+0x112>
   1059a:	f04f 0328 	mov.w	r3, #40	; 0x28
   1059e:	f383 8811 	msr	BASEPRI, r3
   105a2:	f3bf 8f6f 	isb	sy
   105a6:	f3bf 8f4f 	dsb	sy
   105aa:	633b      	str	r3, [r7, #48]	; 0x30
   105ac:	e7fe      	b.n	105ac <xTaskGenericNotifyFromISR+0x110>

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   105ae:	f243 03f4 	movw	r3, #12532	; 0x30f4
   105b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   105b6:	681b      	ldr	r3, [r3, #0]
   105b8:	2b00      	cmp	r3, #0
   105ba:	d12d      	bne.n	10618 <xTaskGenericNotifyFromISR+0x17c>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   105bc:	693b      	ldr	r3, [r7, #16]
   105be:	f103 0304 	add.w	r3, r3, #4
   105c2:	4618      	mov	r0, r3
   105c4:	f7fc f87e 	bl	c6c4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   105c8:	693b      	ldr	r3, [r7, #16]
   105ca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   105cc:	f04f 0201 	mov.w	r2, #1
   105d0:	fa02 f203 	lsl.w	r2, r2, r3
   105d4:	f243 03d4 	movw	r3, #12500	; 0x30d4
   105d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   105dc:	681b      	ldr	r3, [r3, #0]
   105de:	ea42 0203 	orr.w	r2, r2, r3
   105e2:	f243 03d4 	movw	r3, #12500	; 0x30d4
   105e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   105ea:	601a      	str	r2, [r3, #0]
   105ec:	693b      	ldr	r3, [r7, #16]
   105ee:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   105f0:	4613      	mov	r3, r2
   105f2:	ea4f 0383 	mov.w	r3, r3, lsl #2
   105f6:	4413      	add	r3, r2
   105f8:	ea4f 0383 	mov.w	r3, r3, lsl #2
   105fc:	461a      	mov	r2, r3
   105fe:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   10602:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10606:	441a      	add	r2, r3
   10608:	693b      	ldr	r3, [r7, #16]
   1060a:	f103 0304 	add.w	r3, r3, #4
   1060e:	4610      	mov	r0, r2
   10610:	4619      	mov	r1, r3
   10612:	f7fb fff9 	bl	c608 <vListInsertEnd>
   10616:	e009      	b.n	1062c <xTaskGenericNotifyFromISR+0x190>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   10618:	693b      	ldr	r3, [r7, #16]
   1061a:	f103 0318 	add.w	r3, r3, #24
   1061e:	f243 008c 	movw	r0, #12428	; 0x308c
   10622:	f2c2 0000 	movt	r0, #8192	; 0x2000
   10626:	4619      	mov	r1, r3
   10628:	f7fb ffee 	bl	c608 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   1062c:	693b      	ldr	r3, [r7, #16]
   1062e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10630:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10634:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10638:	681b      	ldr	r3, [r3, #0]
   1063a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1063c:	429a      	cmp	r2, r3
   1063e:	d90d      	bls.n	1065c <xTaskGenericNotifyFromISR+0x1c0>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
   10640:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   10642:	2b00      	cmp	r3, #0
   10644:	d003      	beq.n	1064e <xTaskGenericNotifyFromISR+0x1b2>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
   10646:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   10648:	f04f 0201 	mov.w	r2, #1
   1064c:	601a      	str	r2, [r3, #0]
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
   1064e:	f243 03e0 	movw	r3, #12512	; 0x30e0
   10652:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10656:	f04f 0201 	mov.w	r2, #1
   1065a:	601a      	str	r2, [r3, #0]
   1065c:	69fb      	ldr	r3, [r7, #28]
   1065e:	637b      	str	r3, [r7, #52]	; 0x34
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   10660:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   10662:	f383 8811 	msr	BASEPRI, r3
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
   10666:	69bb      	ldr	r3, [r7, #24]
	}
   10668:	4618      	mov	r0, r3
   1066a:	f107 0738 	add.w	r7, r7, #56	; 0x38
   1066e:	46bd      	mov	sp, r7
   10670:	bd80      	pop	{r7, pc}
   10672:	bf00      	nop

00010674 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
   10674:	b580      	push	{r7, lr}
   10676:	b08a      	sub	sp, #40	; 0x28
   10678:	af00      	add	r7, sp, #0
   1067a:	6078      	str	r0, [r7, #4]
   1067c:	6039      	str	r1, [r7, #0]
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
   1067e:	687b      	ldr	r3, [r7, #4]
   10680:	2b00      	cmp	r3, #0
   10682:	d109      	bne.n	10698 <vTaskNotifyGiveFromISR+0x24>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   10684:	f04f 0328 	mov.w	r3, #40	; 0x28
   10688:	f383 8811 	msr	BASEPRI, r3
   1068c:	f3bf 8f6f 	isb	sy
   10690:	f3bf 8f4f 	dsb	sy
   10694:	617b      	str	r3, [r7, #20]
   10696:	e7fe      	b.n	10696 <vTaskNotifyGiveFromISR+0x22>
		below the maximum system call interrupt priority.  FreeRTOS maintains a
		separate interrupt safe API to ensure interrupt entry is as fast and as
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   10698:	f001 f93a 	bl	11910 <vPortValidateInterruptPriority>

		pxTCB = xTaskToNotify;
   1069c:	687b      	ldr	r3, [r7, #4]
   1069e:	60bb      	str	r3, [r7, #8]

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
   106a0:	f3ef 8211 	mrs	r2, BASEPRI
   106a4:	f04f 0328 	mov.w	r3, #40	; 0x28
   106a8:	f383 8811 	msr	BASEPRI, r3
   106ac:	f3bf 8f6f 	isb	sy
   106b0:	f3bf 8f4f 	dsb	sy
   106b4:	61fa      	str	r2, [r7, #28]
   106b6:	61bb      	str	r3, [r7, #24]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
   106b8:	69fb      	ldr	r3, [r7, #28]

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   106ba:	613b      	str	r3, [r7, #16]
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
   106bc:	68bb      	ldr	r3, [r7, #8]
   106be:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
   106c2:	73fb      	strb	r3, [r7, #15]
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   106c4:	68bb      	ldr	r3, [r7, #8]
   106c6:	f04f 0202 	mov.w	r2, #2
   106ca:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
   106ce:	68bb      	ldr	r3, [r7, #8]
   106d0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   106d2:	f103 0201 	add.w	r2, r3, #1
   106d6:	68bb      	ldr	r3, [r7, #8]
   106d8:	655a      	str	r2, [r3, #84]	; 0x54

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   106da:	7bfb      	ldrb	r3, [r7, #15]
   106dc:	2b01      	cmp	r3, #1
   106de:	d164      	bne.n	107aa <vTaskNotifyGiveFromISR+0x136>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   106e0:	68bb      	ldr	r3, [r7, #8]
   106e2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   106e4:	2b00      	cmp	r3, #0
   106e6:	d009      	beq.n	106fc <vTaskNotifyGiveFromISR+0x88>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   106e8:	f04f 0328 	mov.w	r3, #40	; 0x28
   106ec:	f383 8811 	msr	BASEPRI, r3
   106f0:	f3bf 8f6f 	isb	sy
   106f4:	f3bf 8f4f 	dsb	sy
   106f8:	623b      	str	r3, [r7, #32]
   106fa:	e7fe      	b.n	106fa <vTaskNotifyGiveFromISR+0x86>

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   106fc:	f243 03f4 	movw	r3, #12532	; 0x30f4
   10700:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10704:	681b      	ldr	r3, [r3, #0]
   10706:	2b00      	cmp	r3, #0
   10708:	d12d      	bne.n	10766 <vTaskNotifyGiveFromISR+0xf2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   1070a:	68bb      	ldr	r3, [r7, #8]
   1070c:	f103 0304 	add.w	r3, r3, #4
   10710:	4618      	mov	r0, r3
   10712:	f7fb ffd7 	bl	c6c4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   10716:	68bb      	ldr	r3, [r7, #8]
   10718:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1071a:	f04f 0201 	mov.w	r2, #1
   1071e:	fa02 f203 	lsl.w	r2, r2, r3
   10722:	f243 03d4 	movw	r3, #12500	; 0x30d4
   10726:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1072a:	681b      	ldr	r3, [r3, #0]
   1072c:	ea42 0203 	orr.w	r2, r2, r3
   10730:	f243 03d4 	movw	r3, #12500	; 0x30d4
   10734:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10738:	601a      	str	r2, [r3, #0]
   1073a:	68bb      	ldr	r3, [r7, #8]
   1073c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1073e:	4613      	mov	r3, r2
   10740:	ea4f 0383 	mov.w	r3, r3, lsl #2
   10744:	4413      	add	r3, r2
   10746:	ea4f 0383 	mov.w	r3, r3, lsl #2
   1074a:	461a      	mov	r2, r3
   1074c:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   10750:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10754:	441a      	add	r2, r3
   10756:	68bb      	ldr	r3, [r7, #8]
   10758:	f103 0304 	add.w	r3, r3, #4
   1075c:	4610      	mov	r0, r2
   1075e:	4619      	mov	r1, r3
   10760:	f7fb ff52 	bl	c608 <vListInsertEnd>
   10764:	e009      	b.n	1077a <vTaskNotifyGiveFromISR+0x106>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   10766:	68bb      	ldr	r3, [r7, #8]
   10768:	f103 0318 	add.w	r3, r3, #24
   1076c:	f243 008c 	movw	r0, #12428	; 0x308c
   10770:	f2c2 0000 	movt	r0, #8192	; 0x2000
   10774:	4619      	mov	r1, r3
   10776:	f7fb ff47 	bl	c608 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   1077a:	68bb      	ldr	r3, [r7, #8]
   1077c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1077e:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10782:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10786:	681b      	ldr	r3, [r3, #0]
   10788:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1078a:	429a      	cmp	r2, r3
   1078c:	d90d      	bls.n	107aa <vTaskNotifyGiveFromISR+0x136>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
   1078e:	683b      	ldr	r3, [r7, #0]
   10790:	2b00      	cmp	r3, #0
   10792:	d003      	beq.n	1079c <vTaskNotifyGiveFromISR+0x128>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
   10794:	683b      	ldr	r3, [r7, #0]
   10796:	f04f 0201 	mov.w	r2, #1
   1079a:	601a      	str	r2, [r3, #0]
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
   1079c:	f243 03e0 	movw	r3, #12512	; 0x30e0
   107a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   107a4:	f04f 0201 	mov.w	r2, #1
   107a8:	601a      	str	r2, [r3, #0]
   107aa:	693b      	ldr	r3, [r7, #16]
   107ac:	627b      	str	r3, [r7, #36]	; 0x24
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   107ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   107b0:	f383 8811 	msr	BASEPRI, r3
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
   107b4:	f107 0728 	add.w	r7, r7, #40	; 0x28
   107b8:	46bd      	mov	sp, r7
   107ba:	bd80      	pop	{r7, pc}

000107bc <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
   107bc:	b580      	push	{r7, lr}
   107be:	b084      	sub	sp, #16
   107c0:	af00      	add	r7, sp, #0
   107c2:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
   107c4:	687b      	ldr	r3, [r7, #4]
   107c6:	2b00      	cmp	r3, #0
   107c8:	d105      	bne.n	107d6 <xTaskNotifyStateClear+0x1a>
   107ca:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   107ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
   107d2:	681b      	ldr	r3, [r3, #0]
   107d4:	e000      	b.n	107d8 <xTaskNotifyStateClear+0x1c>
   107d6:	687b      	ldr	r3, [r7, #4]
   107d8:	60bb      	str	r3, [r7, #8]

		taskENTER_CRITICAL();
   107da:	f000 ffb5 	bl	11748 <vPortEnterCritical>
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
   107de:	68bb      	ldr	r3, [r7, #8]
   107e0:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
   107e4:	b2db      	uxtb	r3, r3
   107e6:	2b02      	cmp	r3, #2
   107e8:	d108      	bne.n	107fc <xTaskNotifyStateClear+0x40>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   107ea:	68bb      	ldr	r3, [r7, #8]
   107ec:	f04f 0200 	mov.w	r2, #0
   107f0:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
				xReturn = pdPASS;
   107f4:	f04f 0301 	mov.w	r3, #1
   107f8:	60fb      	str	r3, [r7, #12]
   107fa:	e002      	b.n	10802 <xTaskNotifyStateClear+0x46>
			}
			else
			{
				xReturn = pdFAIL;
   107fc:	f04f 0300 	mov.w	r3, #0
   10800:	60fb      	str	r3, [r7, #12]
			}
		}
		taskEXIT_CRITICAL();
   10802:	f000 ffd9 	bl	117b8 <vPortExitCritical>

		return xReturn;
   10806:	68fb      	ldr	r3, [r7, #12]
	}
   10808:	4618      	mov	r0, r3
   1080a:	f107 0710 	add.w	r7, r7, #16
   1080e:	46bd      	mov	sp, r7
   10810:	bd80      	pop	{r7, pc}
   10812:	bf00      	nop

00010814 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
   10814:	b580      	push	{r7, lr}
   10816:	b084      	sub	sp, #16
   10818:	af00      	add	r7, sp, #0
   1081a:	6078      	str	r0, [r7, #4]
   1081c:	6039      	str	r1, [r7, #0]
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
   1081e:	f243 03d0 	movw	r3, #12496	; 0x30d0
   10822:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10826:	681b      	ldr	r3, [r3, #0]
   10828:	60fb      	str	r3, [r7, #12]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   1082a:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   1082e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10832:	681b      	ldr	r3, [r3, #0]
   10834:	f103 0304 	add.w	r3, r3, #4
   10838:	4618      	mov	r0, r3
   1083a:	f7fb ff43 	bl	c6c4 <uxListRemove>
   1083e:	4603      	mov	r3, r0
   10840:	2b00      	cmp	r3, #0
   10842:	d117      	bne.n	10874 <prvAddCurrentTaskToDelayedList+0x60>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
   10844:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10848:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1084c:	681b      	ldr	r3, [r3, #0]
   1084e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   10850:	f04f 0201 	mov.w	r2, #1
   10854:	fa02 f303 	lsl.w	r3, r2, r3
   10858:	ea6f 0203 	mvn.w	r2, r3
   1085c:	f243 03d4 	movw	r3, #12500	; 0x30d4
   10860:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10864:	681b      	ldr	r3, [r3, #0]
   10866:	ea02 0203 	and.w	r2, r2, r3
   1086a:	f243 03d4 	movw	r3, #12500	; 0x30d4
   1086e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10872:	601a      	str	r2, [r3, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   10874:	687b      	ldr	r3, [r7, #4]
   10876:	f1b3 3fff 	cmp.w	r3, #4294967295
   1087a:	d111      	bne.n	108a0 <prvAddCurrentTaskToDelayedList+0x8c>
   1087c:	683b      	ldr	r3, [r7, #0]
   1087e:	2b00      	cmp	r3, #0
   10880:	d00e      	beq.n	108a0 <prvAddCurrentTaskToDelayedList+0x8c>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
   10882:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10886:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1088a:	681b      	ldr	r3, [r3, #0]
   1088c:	f103 0304 	add.w	r3, r3, #4
   10890:	f243 00b8 	movw	r0, #12472	; 0x30b8
   10894:	f2c2 0000 	movt	r0, #8192	; 0x2000
   10898:	4619      	mov	r1, r3
   1089a:	f7fb feb5 	bl	c608 <vListInsertEnd>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   1089e:	e03d      	b.n	1091c <prvAddCurrentTaskToDelayedList+0x108>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
   108a0:	68fa      	ldr	r2, [r7, #12]
   108a2:	687b      	ldr	r3, [r7, #4]
   108a4:	4413      	add	r3, r2
   108a6:	60bb      	str	r3, [r7, #8]

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   108a8:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   108ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
   108b0:	681b      	ldr	r3, [r3, #0]
   108b2:	68ba      	ldr	r2, [r7, #8]
   108b4:	605a      	str	r2, [r3, #4]

			if( xTimeToWake < xConstTickCount )
   108b6:	68ba      	ldr	r2, [r7, #8]
   108b8:	68fb      	ldr	r3, [r7, #12]
   108ba:	429a      	cmp	r2, r3
   108bc:	d210      	bcs.n	108e0 <prvAddCurrentTaskToDelayedList+0xcc>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   108be:	f243 0388 	movw	r3, #12424	; 0x3088
   108c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   108c6:	681a      	ldr	r2, [r3, #0]
   108c8:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   108cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   108d0:	681b      	ldr	r3, [r3, #0]
   108d2:	f103 0304 	add.w	r3, r3, #4
   108d6:	4610      	mov	r0, r2
   108d8:	4619      	mov	r1, r3
   108da:	f7fb feb9 	bl	c650 <vListInsert>
   108de:	e01d      	b.n	1091c <prvAddCurrentTaskToDelayedList+0x108>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   108e0:	f243 0384 	movw	r3, #12420	; 0x3084
   108e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   108e8:	681a      	ldr	r2, [r3, #0]
   108ea:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   108ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
   108f2:	681b      	ldr	r3, [r3, #0]
   108f4:	f103 0304 	add.w	r3, r3, #4
   108f8:	4610      	mov	r0, r2
   108fa:	4619      	mov	r1, r3
   108fc:	f7fb fea8 	bl	c650 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
   10900:	f243 03ec 	movw	r3, #12524	; 0x30ec
   10904:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10908:	681b      	ldr	r3, [r3, #0]
   1090a:	68ba      	ldr	r2, [r7, #8]
   1090c:	429a      	cmp	r2, r3
   1090e:	d205      	bcs.n	1091c <prvAddCurrentTaskToDelayedList+0x108>
				{
					xNextTaskUnblockTime = xTimeToWake;
   10910:	f243 03ec 	movw	r3, #12524	; 0x30ec
   10914:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10918:	68ba      	ldr	r2, [r7, #8]
   1091a:	601a      	str	r2, [r3, #0]

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
   1091c:	f107 0710 	add.w	r7, r7, #16
   10920:	46bd      	mov	sp, r7
   10922:	bd80      	pop	{r7, pc}

00010924 <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
   10924:	b580      	push	{r7, lr}
   10926:	b084      	sub	sp, #16
   10928:	af02      	add	r7, sp, #8
BaseType_t xReturn = pdFAIL;
   1092a:	f04f 0300 	mov.w	r3, #0
   1092e:	603b      	str	r3, [r7, #0]

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
   10930:	f000 fbce 	bl	110d0 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
   10934:	f243 1330 	movw	r3, #12592	; 0x3130
   10938:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1093c:	681b      	ldr	r3, [r3, #0]
   1093e:	2b00      	cmp	r3, #0
   10940:	d017      	beq.n	10972 <xTimerCreateTimerTask+0x4e>
				xReturn = pdPASS;
			}
		}
		#else
		{
			xReturn = xTaskCreate(	prvTimerTask,
   10942:	f04f 0302 	mov.w	r3, #2
   10946:	9300      	str	r3, [sp, #0]
   10948:	f243 1334 	movw	r3, #12596	; 0x3134
   1094c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10950:	9301      	str	r3, [sp, #4]
   10952:	f640 4081 	movw	r0, #3201	; 0xc81
   10956:	f2c0 0001 	movt	r0, #1
   1095a:	f24c 3110 	movw	r1, #49936	; 0xc310
   1095e:	f2c0 0101 	movt	r1, #1
   10962:	f04f 02b4 	mov.w	r2, #180	; 0xb4
   10966:	f04f 0300 	mov.w	r3, #0
   1096a:	f7fd f925 	bl	dbb8 <xTaskCreate>
   1096e:	4603      	mov	r3, r0
   10970:	603b      	str	r3, [r7, #0]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
   10972:	683b      	ldr	r3, [r7, #0]
   10974:	2b00      	cmp	r3, #0
   10976:	d109      	bne.n	1098c <xTimerCreateTimerTask+0x68>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   10978:	f04f 0328 	mov.w	r3, #40	; 0x28
   1097c:	f383 8811 	msr	BASEPRI, r3
   10980:	f3bf 8f6f 	isb	sy
   10984:	f3bf 8f4f 	dsb	sy
   10988:	607b      	str	r3, [r7, #4]
   1098a:	e7fe      	b.n	1098a <xTimerCreateTimerTask+0x66>
	return xReturn;
   1098c:	683b      	ldr	r3, [r7, #0]
}
   1098e:	4618      	mov	r0, r3
   10990:	f107 0708 	add.w	r7, r7, #8
   10994:	46bd      	mov	sp, r7
   10996:	bd80      	pop	{r7, pc}

00010998 <xTimerCreate>:
	TimerHandle_t xTimerCreate(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
								const TickType_t xTimerPeriodInTicks,
								const UBaseType_t uxAutoReload,
								void * const pvTimerID,
								TimerCallbackFunction_t pxCallbackFunction )
	{
   10998:	b580      	push	{r7, lr}
   1099a:	b088      	sub	sp, #32
   1099c:	af02      	add	r7, sp, #8
   1099e:	60f8      	str	r0, [r7, #12]
   109a0:	60b9      	str	r1, [r7, #8]
   109a2:	607a      	str	r2, [r7, #4]
   109a4:	603b      	str	r3, [r7, #0]
	Timer_t *pxNewTimer;

		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
   109a6:	f04f 002c 	mov.w	r0, #44	; 0x2c
   109aa:	f000 fc4d 	bl	11248 <pvPortMalloc>
   109ae:	4603      	mov	r3, r0
   109b0:	617b      	str	r3, [r7, #20]

		if( pxNewTimer != NULL )
   109b2:	697b      	ldr	r3, [r7, #20]
   109b4:	2b00      	cmp	r3, #0
   109b6:	d009      	beq.n	109cc <xTimerCreate+0x34>
		{
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
   109b8:	6a3b      	ldr	r3, [r7, #32]
   109ba:	9300      	str	r3, [sp, #0]
   109bc:	697b      	ldr	r3, [r7, #20]
   109be:	9301      	str	r3, [sp, #4]
   109c0:	68f8      	ldr	r0, [r7, #12]
   109c2:	68b9      	ldr	r1, [r7, #8]
   109c4:	687a      	ldr	r2, [r7, #4]
   109c6:	683b      	ldr	r3, [r7, #0]
   109c8:	f000 f806 	bl	109d8 <prvInitialiseNewTimer>
				pxNewTimer->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */
		}

		return pxNewTimer;
   109cc:	697b      	ldr	r3, [r7, #20]
	}
   109ce:	4618      	mov	r0, r3
   109d0:	f107 0718 	add.w	r7, r7, #24
   109d4:	46bd      	mov	sp, r7
   109d6:	bd80      	pop	{r7, pc}

000109d8 <prvInitialiseNewTimer>:
									const TickType_t xTimerPeriodInTicks,
									const UBaseType_t uxAutoReload,
									void * const pvTimerID,
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer )
{
   109d8:	b580      	push	{r7, lr}
   109da:	b086      	sub	sp, #24
   109dc:	af00      	add	r7, sp, #0
   109de:	60f8      	str	r0, [r7, #12]
   109e0:	60b9      	str	r1, [r7, #8]
   109e2:	607a      	str	r2, [r7, #4]
   109e4:	603b      	str	r3, [r7, #0]
	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );
   109e6:	68bb      	ldr	r3, [r7, #8]
   109e8:	2b00      	cmp	r3, #0
   109ea:	d109      	bne.n	10a00 <prvInitialiseNewTimer+0x28>
   109ec:	f04f 0328 	mov.w	r3, #40	; 0x28
   109f0:	f383 8811 	msr	BASEPRI, r3
   109f4:	f3bf 8f6f 	isb	sy
   109f8:	f3bf 8f4f 	dsb	sy
   109fc:	617b      	str	r3, [r7, #20]
   109fe:	e7fe      	b.n	109fe <prvInitialiseNewTimer+0x26>

	if( pxNewTimer != NULL )
   10a00:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   10a02:	2b00      	cmp	r3, #0
   10a04:	d016      	beq.n	10a34 <prvInitialiseNewTimer+0x5c>
	{
		/* Ensure the infrastructure used by the timer service task has been
		created/initialised. */
		prvCheckForValidListAndQueue();
   10a06:	f000 fb63 	bl	110d0 <prvCheckForValidListAndQueue>

		/* Initialise the timer structure members using the function
		parameters. */
		pxNewTimer->pcTimerName = pcTimerName;
   10a0a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   10a0c:	68fa      	ldr	r2, [r7, #12]
   10a0e:	601a      	str	r2, [r3, #0]
		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
   10a10:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   10a12:	68ba      	ldr	r2, [r7, #8]
   10a14:	619a      	str	r2, [r3, #24]
		pxNewTimer->uxAutoReload = uxAutoReload;
   10a16:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   10a18:	687a      	ldr	r2, [r7, #4]
   10a1a:	61da      	str	r2, [r3, #28]
		pxNewTimer->pvTimerID = pvTimerID;
   10a1c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   10a1e:	683a      	ldr	r2, [r7, #0]
   10a20:	621a      	str	r2, [r3, #32]
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
   10a22:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   10a24:	6a3a      	ldr	r2, [r7, #32]
   10a26:	625a      	str	r2, [r3, #36]	; 0x24
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
   10a28:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   10a2a:	f103 0304 	add.w	r3, r3, #4
   10a2e:	4618      	mov	r0, r3
   10a30:	f7fb fddc 	bl	c5ec <vListInitialiseItem>
		traceTIMER_CREATE( pxNewTimer );
	}
}
   10a34:	f107 0718 	add.w	r7, r7, #24
   10a38:	46bd      	mov	sp, r7
   10a3a:	bd80      	pop	{r7, pc}

00010a3c <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
   10a3c:	b580      	push	{r7, lr}
   10a3e:	b08a      	sub	sp, #40	; 0x28
   10a40:	af00      	add	r7, sp, #0
   10a42:	60f8      	str	r0, [r7, #12]
   10a44:	60b9      	str	r1, [r7, #8]
   10a46:	607a      	str	r2, [r7, #4]
   10a48:	603b      	str	r3, [r7, #0]
BaseType_t xReturn = pdFAIL;
   10a4a:	f04f 0300 	mov.w	r3, #0
   10a4e:	623b      	str	r3, [r7, #32]
DaemonTaskMessage_t xMessage;

	configASSERT( xTimer );
   10a50:	68fb      	ldr	r3, [r7, #12]
   10a52:	2b00      	cmp	r3, #0
   10a54:	d109      	bne.n	10a6a <xTimerGenericCommand+0x2e>
   10a56:	f04f 0328 	mov.w	r3, #40	; 0x28
   10a5a:	f383 8811 	msr	BASEPRI, r3
   10a5e:	f3bf 8f6f 	isb	sy
   10a62:	f3bf 8f4f 	dsb	sy
   10a66:	627b      	str	r3, [r7, #36]	; 0x24
   10a68:	e7fe      	b.n	10a68 <xTimerGenericCommand+0x2c>

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
   10a6a:	f243 1330 	movw	r3, #12592	; 0x3130
   10a6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10a72:	681b      	ldr	r3, [r3, #0]
   10a74:	2b00      	cmp	r3, #0
   10a76:	d040      	beq.n	10afa <xTimerGenericCommand+0xbe>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
   10a78:	68bb      	ldr	r3, [r7, #8]
   10a7a:	617b      	str	r3, [r7, #20]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
   10a7c:	687b      	ldr	r3, [r7, #4]
   10a7e:	61bb      	str	r3, [r7, #24]
		xMessage.u.xTimerParameters.pxTimer = xTimer;
   10a80:	68fb      	ldr	r3, [r7, #12]
   10a82:	61fb      	str	r3, [r7, #28]

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
   10a84:	68bb      	ldr	r3, [r7, #8]
   10a86:	2b05      	cmp	r3, #5
   10a88:	dc27      	bgt.n	10ada <xTimerGenericCommand+0x9e>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
   10a8a:	f7fe ff71 	bl	f970 <xTaskGetSchedulerState>
   10a8e:	4603      	mov	r3, r0
   10a90:	2b02      	cmp	r3, #2
   10a92:	d110      	bne.n	10ab6 <xTimerGenericCommand+0x7a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
   10a94:	f243 1330 	movw	r3, #12592	; 0x3130
   10a98:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10a9c:	681a      	ldr	r2, [r3, #0]
   10a9e:	f107 0314 	add.w	r3, r7, #20
   10aa2:	4610      	mov	r0, r2
   10aa4:	4619      	mov	r1, r3
   10aa6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   10aa8:	f04f 0300 	mov.w	r3, #0
   10aac:	f7fb ffc0 	bl	ca30 <xQueueGenericSend>
   10ab0:	4603      	mov	r3, r0
   10ab2:	623b      	str	r3, [r7, #32]
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
   10ab4:	e021      	b.n	10afa <xTimerGenericCommand+0xbe>
   10ab6:	f243 1330 	movw	r3, #12592	; 0x3130
   10aba:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10abe:	681a      	ldr	r2, [r3, #0]
   10ac0:	f107 0314 	add.w	r3, r7, #20
   10ac4:	4610      	mov	r0, r2
   10ac6:	4619      	mov	r1, r3
   10ac8:	f04f 0200 	mov.w	r2, #0
   10acc:	f04f 0300 	mov.w	r3, #0
   10ad0:	f7fb ffae 	bl	ca30 <xQueueGenericSend>
   10ad4:	4603      	mov	r3, r0
   10ad6:	623b      	str	r3, [r7, #32]
   10ad8:	e00f      	b.n	10afa <xTimerGenericCommand+0xbe>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
   10ada:	f243 1330 	movw	r3, #12592	; 0x3130
   10ade:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10ae2:	681a      	ldr	r2, [r3, #0]
   10ae4:	f107 0314 	add.w	r3, r7, #20
   10ae8:	4610      	mov	r0, r2
   10aea:	4619      	mov	r1, r3
   10aec:	683a      	ldr	r2, [r7, #0]
   10aee:	f04f 0300 	mov.w	r3, #0
   10af2:	f7fc f8b5 	bl	cc60 <xQueueGenericSendFromISR>
   10af6:	4603      	mov	r3, r0
   10af8:	623b      	str	r3, [r7, #32]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
   10afa:	6a3b      	ldr	r3, [r7, #32]
}
   10afc:	4618      	mov	r0, r3
   10afe:	f107 0728 	add.w	r7, r7, #40	; 0x28
   10b02:	46bd      	mov	sp, r7
   10b04:	bd80      	pop	{r7, pc}
   10b06:	bf00      	nop

00010b08 <xTimerGetTimerDaemonTaskHandle>:
/*-----------------------------------------------------------*/

TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
{
   10b08:	b480      	push	{r7}
   10b0a:	b083      	sub	sp, #12
   10b0c:	af00      	add	r7, sp, #0
	/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
	started, then xTimerTaskHandle will be NULL. */
	configASSERT( ( xTimerTaskHandle != NULL ) );
   10b0e:	f243 1334 	movw	r3, #12596	; 0x3134
   10b12:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10b16:	681b      	ldr	r3, [r3, #0]
   10b18:	2b00      	cmp	r3, #0
   10b1a:	d109      	bne.n	10b30 <xTimerGetTimerDaemonTaskHandle+0x28>
   10b1c:	f04f 0328 	mov.w	r3, #40	; 0x28
   10b20:	f383 8811 	msr	BASEPRI, r3
   10b24:	f3bf 8f6f 	isb	sy
   10b28:	f3bf 8f4f 	dsb	sy
   10b2c:	607b      	str	r3, [r7, #4]
   10b2e:	e7fe      	b.n	10b2e <xTimerGetTimerDaemonTaskHandle+0x26>
	return xTimerTaskHandle;
   10b30:	f243 1334 	movw	r3, #12596	; 0x3134
   10b34:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10b38:	681b      	ldr	r3, [r3, #0]
}
   10b3a:	4618      	mov	r0, r3
   10b3c:	f107 070c 	add.w	r7, r7, #12
   10b40:	46bd      	mov	sp, r7
   10b42:	bc80      	pop	{r7}
   10b44:	4770      	bx	lr
   10b46:	bf00      	nop

00010b48 <xTimerGetPeriod>:
/*-----------------------------------------------------------*/

TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
{
   10b48:	b480      	push	{r7}
   10b4a:	b085      	sub	sp, #20
   10b4c:	af00      	add	r7, sp, #0
   10b4e:	6078      	str	r0, [r7, #4]
Timer_t *pxTimer = xTimer;
   10b50:	687b      	ldr	r3, [r7, #4]
   10b52:	60bb      	str	r3, [r7, #8]

	configASSERT( xTimer );
   10b54:	687b      	ldr	r3, [r7, #4]
   10b56:	2b00      	cmp	r3, #0
   10b58:	d109      	bne.n	10b6e <xTimerGetPeriod+0x26>
   10b5a:	f04f 0328 	mov.w	r3, #40	; 0x28
   10b5e:	f383 8811 	msr	BASEPRI, r3
   10b62:	f3bf 8f6f 	isb	sy
   10b66:	f3bf 8f4f 	dsb	sy
   10b6a:	60fb      	str	r3, [r7, #12]
   10b6c:	e7fe      	b.n	10b6c <xTimerGetPeriod+0x24>
	return pxTimer->xTimerPeriodInTicks;
   10b6e:	68bb      	ldr	r3, [r7, #8]
   10b70:	699b      	ldr	r3, [r3, #24]
}
   10b72:	4618      	mov	r0, r3
   10b74:	f107 0714 	add.w	r7, r7, #20
   10b78:	46bd      	mov	sp, r7
   10b7a:	bc80      	pop	{r7}
   10b7c:	4770      	bx	lr
   10b7e:	bf00      	nop

00010b80 <xTimerGetExpiryTime>:
/*-----------------------------------------------------------*/

TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
{
   10b80:	b480      	push	{r7}
   10b82:	b087      	sub	sp, #28
   10b84:	af00      	add	r7, sp, #0
   10b86:	6078      	str	r0, [r7, #4]
Timer_t * pxTimer =  xTimer;
   10b88:	687b      	ldr	r3, [r7, #4]
   10b8a:	60fb      	str	r3, [r7, #12]
TickType_t xReturn;

	configASSERT( xTimer );
   10b8c:	687b      	ldr	r3, [r7, #4]
   10b8e:	2b00      	cmp	r3, #0
   10b90:	d109      	bne.n	10ba6 <xTimerGetExpiryTime+0x26>
   10b92:	f04f 0328 	mov.w	r3, #40	; 0x28
   10b96:	f383 8811 	msr	BASEPRI, r3
   10b9a:	f3bf 8f6f 	isb	sy
   10b9e:	f3bf 8f4f 	dsb	sy
   10ba2:	617b      	str	r3, [r7, #20]
   10ba4:	e7fe      	b.n	10ba4 <xTimerGetExpiryTime+0x24>
	xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
   10ba6:	68fb      	ldr	r3, [r7, #12]
   10ba8:	685b      	ldr	r3, [r3, #4]
   10baa:	613b      	str	r3, [r7, #16]
	return xReturn;
   10bac:	693b      	ldr	r3, [r7, #16]
}
   10bae:	4618      	mov	r0, r3
   10bb0:	f107 071c 	add.w	r7, r7, #28
   10bb4:	46bd      	mov	sp, r7
   10bb6:	bc80      	pop	{r7}
   10bb8:	4770      	bx	lr
   10bba:	bf00      	nop

00010bbc <pcTimerGetName>:
/*-----------------------------------------------------------*/

const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
   10bbc:	b480      	push	{r7}
   10bbe:	b085      	sub	sp, #20
   10bc0:	af00      	add	r7, sp, #0
   10bc2:	6078      	str	r0, [r7, #4]
Timer_t *pxTimer = xTimer;
   10bc4:	687b      	ldr	r3, [r7, #4]
   10bc6:	60bb      	str	r3, [r7, #8]

	configASSERT( xTimer );
   10bc8:	687b      	ldr	r3, [r7, #4]
   10bca:	2b00      	cmp	r3, #0
   10bcc:	d109      	bne.n	10be2 <pcTimerGetName+0x26>
   10bce:	f04f 0328 	mov.w	r3, #40	; 0x28
   10bd2:	f383 8811 	msr	BASEPRI, r3
   10bd6:	f3bf 8f6f 	isb	sy
   10bda:	f3bf 8f4f 	dsb	sy
   10bde:	60fb      	str	r3, [r7, #12]
   10be0:	e7fe      	b.n	10be0 <pcTimerGetName+0x24>
	return pxTimer->pcTimerName;
   10be2:	68bb      	ldr	r3, [r7, #8]
   10be4:	681b      	ldr	r3, [r3, #0]
}
   10be6:	4618      	mov	r0, r3
   10be8:	f107 0714 	add.w	r7, r7, #20
   10bec:	46bd      	mov	sp, r7
   10bee:	bc80      	pop	{r7}
   10bf0:	4770      	bx	lr
   10bf2:	bf00      	nop

00010bf4 <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
   10bf4:	b580      	push	{r7, lr}
   10bf6:	b088      	sub	sp, #32
   10bf8:	af02      	add	r7, sp, #8
   10bfa:	6078      	str	r0, [r7, #4]
   10bfc:	6039      	str	r1, [r7, #0]
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   10bfe:	f243 1328 	movw	r3, #12584	; 0x3128
   10c02:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10c06:	681b      	ldr	r3, [r3, #0]
   10c08:	68db      	ldr	r3, [r3, #12]
   10c0a:	68db      	ldr	r3, [r3, #12]
   10c0c:	613b      	str	r3, [r7, #16]

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   10c0e:	693b      	ldr	r3, [r7, #16]
   10c10:	f103 0304 	add.w	r3, r3, #4
   10c14:	4618      	mov	r0, r3
   10c16:	f7fb fd55 	bl	c6c4 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   10c1a:	693b      	ldr	r3, [r7, #16]
   10c1c:	69db      	ldr	r3, [r3, #28]
   10c1e:	2b01      	cmp	r3, #1
   10c20:	d126      	bne.n	10c70 <prvProcessExpiredTimer+0x7c>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
   10c22:	693b      	ldr	r3, [r7, #16]
   10c24:	699a      	ldr	r2, [r3, #24]
   10c26:	687b      	ldr	r3, [r7, #4]
   10c28:	4413      	add	r3, r2
   10c2a:	6938      	ldr	r0, [r7, #16]
   10c2c:	4619      	mov	r1, r3
   10c2e:	683a      	ldr	r2, [r7, #0]
   10c30:	687b      	ldr	r3, [r7, #4]
   10c32:	f000 f8e3 	bl	10dfc <prvInsertTimerInActiveList>
   10c36:	4603      	mov	r3, r0
   10c38:	2b00      	cmp	r3, #0
   10c3a:	d019      	beq.n	10c70 <prvProcessExpiredTimer+0x7c>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
   10c3c:	f04f 0300 	mov.w	r3, #0
   10c40:	9300      	str	r3, [sp, #0]
   10c42:	6938      	ldr	r0, [r7, #16]
   10c44:	f04f 0100 	mov.w	r1, #0
   10c48:	687a      	ldr	r2, [r7, #4]
   10c4a:	f04f 0300 	mov.w	r3, #0
   10c4e:	f7ff fef5 	bl	10a3c <xTimerGenericCommand>
   10c52:	4603      	mov	r3, r0
   10c54:	60fb      	str	r3, [r7, #12]
			configASSERT( xResult );
   10c56:	68fb      	ldr	r3, [r7, #12]
   10c58:	2b00      	cmp	r3, #0
   10c5a:	d109      	bne.n	10c70 <prvProcessExpiredTimer+0x7c>
   10c5c:	f04f 0328 	mov.w	r3, #40	; 0x28
   10c60:	f383 8811 	msr	BASEPRI, r3
   10c64:	f3bf 8f6f 	isb	sy
   10c68:	f3bf 8f4f 	dsb	sy
   10c6c:	617b      	str	r3, [r7, #20]
   10c6e:	e7fe      	b.n	10c6e <prvProcessExpiredTimer+0x7a>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   10c70:	693b      	ldr	r3, [r7, #16]
   10c72:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   10c74:	6938      	ldr	r0, [r7, #16]
   10c76:	4798      	blx	r3
}
   10c78:	f107 0718 	add.w	r7, r7, #24
   10c7c:	46bd      	mov	sp, r7
   10c7e:	bd80      	pop	{r7, pc}

00010c80 <prvTimerTask>:
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
   10c80:	b580      	push	{r7, lr}
   10c82:	b084      	sub	sp, #16
   10c84:	af00      	add	r7, sp, #0
   10c86:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
   10c88:	f107 0308 	add.w	r3, r7, #8
   10c8c:	4618      	mov	r0, r3
   10c8e:	f000 f863 	bl	10d58 <prvGetNextExpireTime>
   10c92:	4603      	mov	r3, r0
   10c94:	60fb      	str	r3, [r7, #12]

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
   10c96:	68bb      	ldr	r3, [r7, #8]
   10c98:	68f8      	ldr	r0, [r7, #12]
   10c9a:	4619      	mov	r1, r3
   10c9c:	f000 f804 	bl	10ca8 <prvProcessTimerOrBlockTask>

		/* Empty the command queue. */
		prvProcessReceivedCommands();
   10ca0:	f000 f8f8 	bl	10e94 <prvProcessReceivedCommands>
	}
   10ca4:	e7f0      	b.n	10c88 <prvTimerTask+0x8>
   10ca6:	bf00      	nop

00010ca8 <prvProcessTimerOrBlockTask>:
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
   10ca8:	b580      	push	{r7, lr}
   10caa:	b084      	sub	sp, #16
   10cac:	af00      	add	r7, sp, #0
   10cae:	6078      	str	r0, [r7, #4]
   10cb0:	6039      	str	r1, [r7, #0]
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
   10cb2:	f7fd fe65 	bl	e980 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   10cb6:	f107 0308 	add.w	r3, r7, #8
   10cba:	4618      	mov	r0, r3
   10cbc:	f000 f876 	bl	10dac <prvSampleTimeNow>
   10cc0:	4603      	mov	r3, r0
   10cc2:	60fb      	str	r3, [r7, #12]
		if( xTimerListsWereSwitched == pdFALSE )
   10cc4:	68bb      	ldr	r3, [r7, #8]
   10cc6:	2b00      	cmp	r3, #0
   10cc8:	d13e      	bne.n	10d48 <prvProcessTimerOrBlockTask+0xa0>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
   10cca:	683b      	ldr	r3, [r7, #0]
   10ccc:	2b00      	cmp	r3, #0
   10cce:	d10b      	bne.n	10ce8 <prvProcessTimerOrBlockTask+0x40>
   10cd0:	687a      	ldr	r2, [r7, #4]
   10cd2:	68fb      	ldr	r3, [r7, #12]
   10cd4:	429a      	cmp	r2, r3
   10cd6:	d807      	bhi.n	10ce8 <prvProcessTimerOrBlockTask+0x40>
			{
				( void ) xTaskResumeAll();
   10cd8:	f7fd fe64 	bl	e9a4 <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
   10cdc:	6878      	ldr	r0, [r7, #4]
   10cde:	68f9      	ldr	r1, [r7, #12]
   10ce0:	f7ff ff88 	bl	10bf4 <prvProcessExpiredTimer>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
   10ce4:	bf00      	nop
   10ce6:	e033      	b.n	10d50 <prvProcessTimerOrBlockTask+0xa8>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
   10ce8:	683b      	ldr	r3, [r7, #0]
   10cea:	2b00      	cmp	r3, #0
   10cec:	d00d      	beq.n	10d0a <prvProcessTimerOrBlockTask+0x62>
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
   10cee:	f243 132c 	movw	r3, #12588	; 0x312c
   10cf2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10cf6:	681b      	ldr	r3, [r3, #0]
   10cf8:	681b      	ldr	r3, [r3, #0]
   10cfa:	2b00      	cmp	r3, #0
   10cfc:	d102      	bne.n	10d04 <prvProcessTimerOrBlockTask+0x5c>
   10cfe:	f04f 0301 	mov.w	r3, #1
   10d02:	e001      	b.n	10d08 <prvProcessTimerOrBlockTask+0x60>
   10d04:	f04f 0300 	mov.w	r3, #0
   10d08:	603b      	str	r3, [r7, #0]
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
   10d0a:	f243 1330 	movw	r3, #12592	; 0x3130
   10d0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10d12:	681a      	ldr	r2, [r3, #0]
   10d14:	6879      	ldr	r1, [r7, #4]
   10d16:	68fb      	ldr	r3, [r7, #12]
   10d18:	ebc3 0301 	rsb	r3, r3, r1
   10d1c:	4610      	mov	r0, r2
   10d1e:	4619      	mov	r1, r3
   10d20:	683a      	ldr	r2, [r7, #0]
   10d22:	f7fc ff0f 	bl	db44 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
   10d26:	f7fd fe3d 	bl	e9a4 <xTaskResumeAll>
   10d2a:	4603      	mov	r3, r0
   10d2c:	2b00      	cmp	r3, #0
   10d2e:	d10e      	bne.n	10d4e <prvProcessTimerOrBlockTask+0xa6>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
   10d30:	f64e 5304 	movw	r3, #60676	; 0xed04
   10d34:	f2ce 0300 	movt	r3, #57344	; 0xe000
   10d38:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   10d3c:	601a      	str	r2, [r3, #0]
   10d3e:	f3bf 8f4f 	dsb	sy
   10d42:	f3bf 8f6f 	isb	sy
   10d46:	e003      	b.n	10d50 <prvProcessTimerOrBlockTask+0xa8>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
   10d48:	f7fd fe2c 	bl	e9a4 <xTaskResumeAll>
   10d4c:	e000      	b.n	10d50 <prvProcessTimerOrBlockTask+0xa8>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
   10d4e:	bf00      	nop
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
   10d50:	f107 0710 	add.w	r7, r7, #16
   10d54:	46bd      	mov	sp, r7
   10d56:	bd80      	pop	{r7, pc}

00010d58 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
{
   10d58:	b480      	push	{r7}
   10d5a:	b085      	sub	sp, #20
   10d5c:	af00      	add	r7, sp, #0
   10d5e:	6078      	str	r0, [r7, #4]
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
   10d60:	f243 1328 	movw	r3, #12584	; 0x3128
   10d64:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10d68:	681b      	ldr	r3, [r3, #0]
   10d6a:	681b      	ldr	r3, [r3, #0]
   10d6c:	2b00      	cmp	r3, #0
   10d6e:	d102      	bne.n	10d76 <prvGetNextExpireTime+0x1e>
   10d70:	f04f 0301 	mov.w	r3, #1
   10d74:	e001      	b.n	10d7a <prvGetNextExpireTime+0x22>
   10d76:	f04f 0300 	mov.w	r3, #0
   10d7a:	687a      	ldr	r2, [r7, #4]
   10d7c:	6013      	str	r3, [r2, #0]
	if( *pxListWasEmpty == pdFALSE )
   10d7e:	687b      	ldr	r3, [r7, #4]
   10d80:	681b      	ldr	r3, [r3, #0]
   10d82:	2b00      	cmp	r3, #0
   10d84:	d108      	bne.n	10d98 <prvGetNextExpireTime+0x40>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   10d86:	f243 1328 	movw	r3, #12584	; 0x3128
   10d8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10d8e:	681b      	ldr	r3, [r3, #0]
   10d90:	68db      	ldr	r3, [r3, #12]
   10d92:	681b      	ldr	r3, [r3, #0]
   10d94:	60fb      	str	r3, [r7, #12]
   10d96:	e002      	b.n	10d9e <prvGetNextExpireTime+0x46>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
   10d98:	f04f 0300 	mov.w	r3, #0
   10d9c:	60fb      	str	r3, [r7, #12]
	}

	return xNextExpireTime;
   10d9e:	68fb      	ldr	r3, [r7, #12]
}
   10da0:	4618      	mov	r0, r3
   10da2:	f107 0714 	add.w	r7, r7, #20
   10da6:	46bd      	mov	sp, r7
   10da8:	bc80      	pop	{r7}
   10daa:	4770      	bx	lr

00010dac <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
   10dac:	b580      	push	{r7, lr}
   10dae:	b084      	sub	sp, #16
   10db0:	af00      	add	r7, sp, #0
   10db2:	6078      	str	r0, [r7, #4]
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
   10db4:	f7fd fec6 	bl	eb44 <xTaskGetTickCount>
   10db8:	4603      	mov	r3, r0
   10dba:	60fb      	str	r3, [r7, #12]

	if( xTimeNow < xLastTime )
   10dbc:	f243 1338 	movw	r3, #12600	; 0x3138
   10dc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10dc4:	681b      	ldr	r3, [r3, #0]
   10dc6:	68fa      	ldr	r2, [r7, #12]
   10dc8:	429a      	cmp	r2, r3
   10dca:	d206      	bcs.n	10dda <prvSampleTimeNow+0x2e>
	{
		prvSwitchTimerLists();
   10dcc:	f000 f906 	bl	10fdc <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
   10dd0:	687b      	ldr	r3, [r7, #4]
   10dd2:	f04f 0201 	mov.w	r2, #1
   10dd6:	601a      	str	r2, [r3, #0]
   10dd8:	e003      	b.n	10de2 <prvSampleTimeNow+0x36>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
   10dda:	687b      	ldr	r3, [r7, #4]
   10ddc:	f04f 0200 	mov.w	r2, #0
   10de0:	601a      	str	r2, [r3, #0]
	}

	xLastTime = xTimeNow;
   10de2:	f243 1338 	movw	r3, #12600	; 0x3138
   10de6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10dea:	68fa      	ldr	r2, [r7, #12]
   10dec:	601a      	str	r2, [r3, #0]

	return xTimeNow;
   10dee:	68fb      	ldr	r3, [r7, #12]
}
   10df0:	4618      	mov	r0, r3
   10df2:	f107 0710 	add.w	r7, r7, #16
   10df6:	46bd      	mov	sp, r7
   10df8:	bd80      	pop	{r7, pc}
   10dfa:	bf00      	nop

00010dfc <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
   10dfc:	b580      	push	{r7, lr}
   10dfe:	b086      	sub	sp, #24
   10e00:	af00      	add	r7, sp, #0
   10e02:	60f8      	str	r0, [r7, #12]
   10e04:	60b9      	str	r1, [r7, #8]
   10e06:	607a      	str	r2, [r7, #4]
   10e08:	603b      	str	r3, [r7, #0]
BaseType_t xProcessTimerNow = pdFALSE;
   10e0a:	f04f 0300 	mov.w	r3, #0
   10e0e:	617b      	str	r3, [r7, #20]

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
   10e10:	68fb      	ldr	r3, [r7, #12]
   10e12:	68ba      	ldr	r2, [r7, #8]
   10e14:	605a      	str	r2, [r3, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   10e16:	68fb      	ldr	r3, [r7, #12]
   10e18:	68fa      	ldr	r2, [r7, #12]
   10e1a:	611a      	str	r2, [r3, #16]

	if( xNextExpiryTime <= xTimeNow )
   10e1c:	68ba      	ldr	r2, [r7, #8]
   10e1e:	687b      	ldr	r3, [r7, #4]
   10e20:	429a      	cmp	r2, r3
   10e22:	d818      	bhi.n	10e56 <prvInsertTimerInActiveList+0x5a>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   10e24:	687a      	ldr	r2, [r7, #4]
   10e26:	683b      	ldr	r3, [r7, #0]
   10e28:	ebc3 0202 	rsb	r2, r3, r2
   10e2c:	68fb      	ldr	r3, [r7, #12]
   10e2e:	699b      	ldr	r3, [r3, #24]
   10e30:	429a      	cmp	r2, r3
   10e32:	d303      	bcc.n	10e3c <prvInsertTimerInActiveList+0x40>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
   10e34:	f04f 0301 	mov.w	r3, #1
   10e38:	617b      	str	r3, [r7, #20]
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
   10e3a:	e024      	b.n	10e86 <prvInsertTimerInActiveList+0x8a>
   10e3c:	f243 132c 	movw	r3, #12588	; 0x312c
   10e40:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10e44:	681a      	ldr	r2, [r3, #0]
   10e46:	68fb      	ldr	r3, [r7, #12]
   10e48:	f103 0304 	add.w	r3, r3, #4
   10e4c:	4610      	mov	r0, r2
   10e4e:	4619      	mov	r1, r3
   10e50:	f7fb fbfe 	bl	c650 <vListInsert>
   10e54:	e017      	b.n	10e86 <prvInsertTimerInActiveList+0x8a>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
   10e56:	687a      	ldr	r2, [r7, #4]
   10e58:	683b      	ldr	r3, [r7, #0]
   10e5a:	429a      	cmp	r2, r3
   10e5c:	d207      	bcs.n	10e6e <prvInsertTimerInActiveList+0x72>
   10e5e:	68ba      	ldr	r2, [r7, #8]
   10e60:	683b      	ldr	r3, [r7, #0]
   10e62:	429a      	cmp	r2, r3
   10e64:	d303      	bcc.n	10e6e <prvInsertTimerInActiveList+0x72>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
   10e66:	f04f 0301 	mov.w	r3, #1
   10e6a:	617b      	str	r3, [r7, #20]
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
   10e6c:	e00b      	b.n	10e86 <prvInsertTimerInActiveList+0x8a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   10e6e:	f243 1328 	movw	r3, #12584	; 0x3128
   10e72:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10e76:	681a      	ldr	r2, [r3, #0]
   10e78:	68fb      	ldr	r3, [r7, #12]
   10e7a:	f103 0304 	add.w	r3, r3, #4
   10e7e:	4610      	mov	r0, r2
   10e80:	4619      	mov	r1, r3
   10e82:	f7fb fbe5 	bl	c650 <vListInsert>
		}
	}

	return xProcessTimerNow;
   10e86:	697b      	ldr	r3, [r7, #20]
}
   10e88:	4618      	mov	r0, r3
   10e8a:	f107 0718 	add.w	r7, r7, #24
   10e8e:	46bd      	mov	sp, r7
   10e90:	bd80      	pop	{r7, pc}
   10e92:	bf00      	nop

00010e94 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
   10e94:	b580      	push	{r7, lr}
   10e96:	b08c      	sub	sp, #48	; 0x30
   10e98:	af02      	add	r7, sp, #8
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
   10e9a:	e089      	b.n	10fb0 <prvProcessReceivedCommands+0x11c>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
   10e9c:	68bb      	ldr	r3, [r7, #8]
   10e9e:	2b00      	cmp	r3, #0
   10ea0:	f2c0 8086 	blt.w	10fb0 <prvProcessReceivedCommands+0x11c>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
   10ea4:	693b      	ldr	r3, [r7, #16]
   10ea6:	617b      	str	r3, [r7, #20]

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
   10ea8:	697b      	ldr	r3, [r7, #20]
   10eaa:	695b      	ldr	r3, [r3, #20]
   10eac:	2b00      	cmp	r3, #0
   10eae:	d005      	beq.n	10ebc <prvProcessReceivedCommands+0x28>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   10eb0:	697b      	ldr	r3, [r7, #20]
   10eb2:	f103 0304 	add.w	r3, r3, #4
   10eb6:	4618      	mov	r0, r3
   10eb8:	f7fb fc04 	bl	c6c4 <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   10ebc:	f107 0304 	add.w	r3, r7, #4
   10ec0:	4618      	mov	r0, r3
   10ec2:	f7ff ff73 	bl	10dac <prvSampleTimeNow>
   10ec6:	4603      	mov	r3, r0
   10ec8:	61fb      	str	r3, [r7, #28]

			switch( xMessage.xMessageID )
   10eca:	68bb      	ldr	r3, [r7, #8]
   10ecc:	2b09      	cmp	r3, #9
   10ece:	d86f      	bhi.n	10fb0 <prvProcessReceivedCommands+0x11c>
   10ed0:	a201      	add	r2, pc, #4	; (adr r2, 10ed8 <prvProcessReceivedCommands+0x44>)
   10ed2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   10ed6:	bf00      	nop
   10ed8:	00010f01 	.word	0x00010f01
   10edc:	00010f01 	.word	0x00010f01
   10ee0:	00010f01 	.word	0x00010f01
   10ee4:	00010fb1 	.word	0x00010fb1
   10ee8:	00010f67 	.word	0x00010f67
   10eec:	00010f9f 	.word	0x00010f9f
   10ef0:	00010f01 	.word	0x00010f01
   10ef4:	00010f01 	.word	0x00010f01
   10ef8:	00010fb1 	.word	0x00010fb1
   10efc:	00010f67 	.word	0x00010f67
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
   10f00:	68fa      	ldr	r2, [r7, #12]
   10f02:	697b      	ldr	r3, [r7, #20]
   10f04:	699b      	ldr	r3, [r3, #24]
   10f06:	441a      	add	r2, r3
   10f08:	68fb      	ldr	r3, [r7, #12]
   10f0a:	6978      	ldr	r0, [r7, #20]
   10f0c:	4611      	mov	r1, r2
   10f0e:	69fa      	ldr	r2, [r7, #28]
   10f10:	f7ff ff74 	bl	10dfc <prvInsertTimerInActiveList>
   10f14:	4603      	mov	r3, r0
   10f16:	2b00      	cmp	r3, #0
   10f18:	d045      	beq.n	10fa6 <prvProcessReceivedCommands+0x112>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   10f1a:	697b      	ldr	r3, [r7, #20]
   10f1c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   10f1e:	6978      	ldr	r0, [r7, #20]
   10f20:	4798      	blx	r3
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   10f22:	697b      	ldr	r3, [r7, #20]
   10f24:	69db      	ldr	r3, [r3, #28]
   10f26:	2b01      	cmp	r3, #1
   10f28:	d13f      	bne.n	10faa <prvProcessReceivedCommands+0x116>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
   10f2a:	68fa      	ldr	r2, [r7, #12]
   10f2c:	697b      	ldr	r3, [r7, #20]
   10f2e:	699b      	ldr	r3, [r3, #24]
   10f30:	4413      	add	r3, r2
   10f32:	f04f 0200 	mov.w	r2, #0
   10f36:	9200      	str	r2, [sp, #0]
   10f38:	6978      	ldr	r0, [r7, #20]
   10f3a:	f04f 0100 	mov.w	r1, #0
   10f3e:	461a      	mov	r2, r3
   10f40:	f04f 0300 	mov.w	r3, #0
   10f44:	f7ff fd7a 	bl	10a3c <xTimerGenericCommand>
   10f48:	4603      	mov	r3, r0
   10f4a:	61bb      	str	r3, [r7, #24]
							configASSERT( xResult );
   10f4c:	69bb      	ldr	r3, [r7, #24]
   10f4e:	2b00      	cmp	r3, #0
   10f50:	d12d      	bne.n	10fae <prvProcessReceivedCommands+0x11a>
   10f52:	f04f 0328 	mov.w	r3, #40	; 0x28
   10f56:	f383 8811 	msr	BASEPRI, r3
   10f5a:	f3bf 8f6f 	isb	sy
   10f5e:	f3bf 8f4f 	dsb	sy
   10f62:	623b      	str	r3, [r7, #32]
   10f64:	e7fe      	b.n	10f64 <prvProcessReceivedCommands+0xd0>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
   10f66:	68fa      	ldr	r2, [r7, #12]
   10f68:	697b      	ldr	r3, [r7, #20]
   10f6a:	619a      	str	r2, [r3, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
   10f6c:	697b      	ldr	r3, [r7, #20]
   10f6e:	699b      	ldr	r3, [r3, #24]
   10f70:	2b00      	cmp	r3, #0
   10f72:	d109      	bne.n	10f88 <prvProcessReceivedCommands+0xf4>
   10f74:	f04f 0328 	mov.w	r3, #40	; 0x28
   10f78:	f383 8811 	msr	BASEPRI, r3
   10f7c:	f3bf 8f6f 	isb	sy
   10f80:	f3bf 8f4f 	dsb	sy
   10f84:	627b      	str	r3, [r7, #36]	; 0x24
   10f86:	e7fe      	b.n	10f86 <prvProcessReceivedCommands+0xf2>
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
   10f88:	697b      	ldr	r3, [r7, #20]
   10f8a:	699a      	ldr	r2, [r3, #24]
   10f8c:	69fb      	ldr	r3, [r7, #28]
   10f8e:	4413      	add	r3, r2
   10f90:	6978      	ldr	r0, [r7, #20]
   10f92:	4619      	mov	r1, r3
   10f94:	69fa      	ldr	r2, [r7, #28]
   10f96:	69fb      	ldr	r3, [r7, #28]
   10f98:	f7ff ff30 	bl	10dfc <prvInsertTimerInActiveList>
					break;
   10f9c:	e008      	b.n	10fb0 <prvProcessReceivedCommands+0x11c>
					allocated. */
					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
					{
						/* The timer can only have been allocated dynamically -
						free it again. */
						vPortFree( pxTimer );
   10f9e:	6978      	ldr	r0, [r7, #20]
   10fa0:	f000 fa08 	bl	113b4 <vPortFree>
   10fa4:	e004      	b.n	10fb0 <prvProcessReceivedCommands+0x11c>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					break;
   10fa6:	bf00      	nop
   10fa8:	e002      	b.n	10fb0 <prvProcessReceivedCommands+0x11c>
   10faa:	bf00      	nop
   10fac:	e000      	b.n	10fb0 <prvProcessReceivedCommands+0x11c>
   10fae:	bf00      	nop
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
   10fb0:	f243 1330 	movw	r3, #12592	; 0x3130
   10fb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10fb8:	681a      	ldr	r2, [r3, #0]
   10fba:	f107 0308 	add.w	r3, r7, #8
   10fbe:	4610      	mov	r0, r2
   10fc0:	4619      	mov	r1, r3
   10fc2:	f04f 0200 	mov.w	r2, #0
   10fc6:	f7fb ff83 	bl	ced0 <xQueueReceive>
   10fca:	4603      	mov	r3, r0
   10fcc:	2b00      	cmp	r3, #0
   10fce:	f47f af65 	bne.w	10e9c <prvProcessReceivedCommands+0x8>
					/* Don't expect to get here. */
					break;
			}
		}
	}
}
   10fd2:	f107 0728 	add.w	r7, r7, #40	; 0x28
   10fd6:	46bd      	mov	sp, r7
   10fd8:	bd80      	pop	{r7, pc}
   10fda:	bf00      	nop

00010fdc <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
   10fdc:	b580      	push	{r7, lr}
   10fde:	b088      	sub	sp, #32
   10fe0:	af02      	add	r7, sp, #8

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
   10fe2:	e053      	b.n	1108c <prvSwitchTimerLists+0xb0>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   10fe4:	f243 1328 	movw	r3, #12584	; 0x3128
   10fe8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10fec:	681b      	ldr	r3, [r3, #0]
   10fee:	68db      	ldr	r3, [r3, #12]
   10ff0:	681b      	ldr	r3, [r3, #0]
   10ff2:	603b      	str	r3, [r7, #0]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   10ff4:	f243 1328 	movw	r3, #12584	; 0x3128
   10ff8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10ffc:	681b      	ldr	r3, [r3, #0]
   10ffe:	68db      	ldr	r3, [r3, #12]
   11000:	68db      	ldr	r3, [r3, #12]
   11002:	60fb      	str	r3, [r7, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   11004:	68fb      	ldr	r3, [r7, #12]
   11006:	f103 0304 	add.w	r3, r3, #4
   1100a:	4618      	mov	r0, r3
   1100c:	f7fb fb5a 	bl	c6c4 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   11010:	68fb      	ldr	r3, [r7, #12]
   11012:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   11014:	68f8      	ldr	r0, [r7, #12]
   11016:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   11018:	68fb      	ldr	r3, [r7, #12]
   1101a:	69db      	ldr	r3, [r3, #28]
   1101c:	2b01      	cmp	r3, #1
   1101e:	d135      	bne.n	1108c <prvSwitchTimerLists+0xb0>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
   11020:	68fb      	ldr	r3, [r7, #12]
   11022:	699a      	ldr	r2, [r3, #24]
   11024:	683b      	ldr	r3, [r7, #0]
   11026:	4413      	add	r3, r2
   11028:	607b      	str	r3, [r7, #4]
			if( xReloadTime > xNextExpireTime )
   1102a:	687a      	ldr	r2, [r7, #4]
   1102c:	683b      	ldr	r3, [r7, #0]
   1102e:	429a      	cmp	r2, r3
   11030:	d912      	bls.n	11058 <prvSwitchTimerLists+0x7c>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
   11032:	68fb      	ldr	r3, [r7, #12]
   11034:	687a      	ldr	r2, [r7, #4]
   11036:	605a      	str	r2, [r3, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   11038:	68fb      	ldr	r3, [r7, #12]
   1103a:	68fa      	ldr	r2, [r7, #12]
   1103c:	611a      	str	r2, [r3, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   1103e:	f243 1328 	movw	r3, #12584	; 0x3128
   11042:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11046:	681a      	ldr	r2, [r3, #0]
   11048:	68fb      	ldr	r3, [r7, #12]
   1104a:	f103 0304 	add.w	r3, r3, #4
   1104e:	4610      	mov	r0, r2
   11050:	4619      	mov	r1, r3
   11052:	f7fb fafd 	bl	c650 <vListInsert>
   11056:	e019      	b.n	1108c <prvSwitchTimerLists+0xb0>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
   11058:	f04f 0300 	mov.w	r3, #0
   1105c:	9300      	str	r3, [sp, #0]
   1105e:	68f8      	ldr	r0, [r7, #12]
   11060:	f04f 0100 	mov.w	r1, #0
   11064:	683a      	ldr	r2, [r7, #0]
   11066:	f04f 0300 	mov.w	r3, #0
   1106a:	f7ff fce7 	bl	10a3c <xTimerGenericCommand>
   1106e:	4603      	mov	r3, r0
   11070:	613b      	str	r3, [r7, #16]
				configASSERT( xResult );
   11072:	693b      	ldr	r3, [r7, #16]
   11074:	2b00      	cmp	r3, #0
   11076:	d109      	bne.n	1108c <prvSwitchTimerLists+0xb0>
   11078:	f04f 0328 	mov.w	r3, #40	; 0x28
   1107c:	f383 8811 	msr	BASEPRI, r3
   11080:	f3bf 8f6f 	isb	sy
   11084:	f3bf 8f4f 	dsb	sy
   11088:	617b      	str	r3, [r7, #20]
   1108a:	e7fe      	b.n	1108a <prvSwitchTimerLists+0xae>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
   1108c:	f243 1328 	movw	r3, #12584	; 0x3128
   11090:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11094:	681b      	ldr	r3, [r3, #0]
   11096:	681b      	ldr	r3, [r3, #0]
   11098:	2b00      	cmp	r3, #0
   1109a:	d1a3      	bne.n	10fe4 <prvSwitchTimerLists+0x8>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
   1109c:	f243 1328 	movw	r3, #12584	; 0x3128
   110a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   110a4:	681b      	ldr	r3, [r3, #0]
   110a6:	60bb      	str	r3, [r7, #8]
	pxCurrentTimerList = pxOverflowTimerList;
   110a8:	f243 132c 	movw	r3, #12588	; 0x312c
   110ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
   110b0:	681a      	ldr	r2, [r3, #0]
   110b2:	f243 1328 	movw	r3, #12584	; 0x3128
   110b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   110ba:	601a      	str	r2, [r3, #0]
	pxOverflowTimerList = pxTemp;
   110bc:	f243 132c 	movw	r3, #12588	; 0x312c
   110c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   110c4:	68ba      	ldr	r2, [r7, #8]
   110c6:	601a      	str	r2, [r3, #0]
}
   110c8:	f107 0718 	add.w	r7, r7, #24
   110cc:	46bd      	mov	sp, r7
   110ce:	bd80      	pop	{r7, pc}

000110d0 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
   110d0:	b580      	push	{r7, lr}
   110d2:	af00      	add	r7, sp, #0
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
   110d4:	f000 fb38 	bl	11748 <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
   110d8:	f243 1330 	movw	r3, #12592	; 0x3130
   110dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   110e0:	681b      	ldr	r3, [r3, #0]
   110e2:	2b00      	cmp	r3, #0
   110e4:	d12b      	bne.n	1113e <prvCheckForValidListAndQueue+0x6e>
		{
			vListInitialise( &xActiveTimerList1 );
   110e6:	f243 1000 	movw	r0, #12544	; 0x3100
   110ea:	f2c2 0000 	movt	r0, #8192	; 0x2000
   110ee:	f7fb fa59 	bl	c5a4 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
   110f2:	f243 1014 	movw	r0, #12564	; 0x3114
   110f6:	f2c2 0000 	movt	r0, #8192	; 0x2000
   110fa:	f7fb fa53 	bl	c5a4 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
   110fe:	f243 1328 	movw	r3, #12584	; 0x3128
   11102:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11106:	f243 1200 	movw	r2, #12544	; 0x3100
   1110a:	f2c2 0200 	movt	r2, #8192	; 0x2000
   1110e:	601a      	str	r2, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
   11110:	f243 132c 	movw	r3, #12588	; 0x312c
   11114:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11118:	f243 1214 	movw	r2, #12564	; 0x3114
   1111c:	f2c2 0200 	movt	r2, #8192	; 0x2000
   11120:	601a      	str	r2, [r3, #0]

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
   11122:	f04f 000a 	mov.w	r0, #10
   11126:	f04f 010c 	mov.w	r1, #12
   1112a:	f04f 0200 	mov.w	r2, #0
   1112e:	f7fb fb6b 	bl	c808 <xQueueGenericCreate>
   11132:	4602      	mov	r2, r0
   11134:	f243 1330 	movw	r3, #12592	; 0x3130
   11138:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1113c:	601a      	str	r2, [r3, #0]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
   1113e:	f000 fb3b 	bl	117b8 <vPortExitCritical>
}
   11142:	bd80      	pop	{r7, pc}

00011144 <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
{
   11144:	b580      	push	{r7, lr}
   11146:	b086      	sub	sp, #24
   11148:	af00      	add	r7, sp, #0
   1114a:	6078      	str	r0, [r7, #4]
BaseType_t xTimerIsInActiveList;
Timer_t *pxTimer = xTimer;
   1114c:	687b      	ldr	r3, [r7, #4]
   1114e:	613b      	str	r3, [r7, #16]

	configASSERT( xTimer );
   11150:	687b      	ldr	r3, [r7, #4]
   11152:	2b00      	cmp	r3, #0
   11154:	d109      	bne.n	1116a <xTimerIsTimerActive+0x26>
   11156:	f04f 0328 	mov.w	r3, #40	; 0x28
   1115a:	f383 8811 	msr	BASEPRI, r3
   1115e:	f3bf 8f6f 	isb	sy
   11162:	f3bf 8f4f 	dsb	sy
   11166:	617b      	str	r3, [r7, #20]
   11168:	e7fe      	b.n	11168 <xTimerIsTimerActive+0x24>

	/* Is the timer in the list of active timers? */
	taskENTER_CRITICAL();
   1116a:	f000 faed 	bl	11748 <vPortEnterCritical>
	{
		/* Checking to see if it is in the NULL list in effect checks to see if
		it is referenced from either the current or the overflow timer lists in
		one go, but the logic has to be reversed, hence the '!'. */
		if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdTRUE )
   1116e:	693b      	ldr	r3, [r7, #16]
   11170:	695b      	ldr	r3, [r3, #20]
   11172:	2b00      	cmp	r3, #0
   11174:	d103      	bne.n	1117e <xTimerIsTimerActive+0x3a>
		{
			xTimerIsInActiveList = pdFALSE;
   11176:	f04f 0300 	mov.w	r3, #0
   1117a:	60fb      	str	r3, [r7, #12]
   1117c:	e002      	b.n	11184 <xTimerIsTimerActive+0x40>
		}
		else
		{
			xTimerIsInActiveList = pdTRUE;
   1117e:	f04f 0301 	mov.w	r3, #1
   11182:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
   11184:	f000 fb18 	bl	117b8 <vPortExitCritical>

	return xTimerIsInActiveList;
   11188:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 Can't be pointer to const due to the typedef. */
   1118a:	4618      	mov	r0, r3
   1118c:	f107 0718 	add.w	r7, r7, #24
   11190:	46bd      	mov	sp, r7
   11192:	bd80      	pop	{r7, pc}

00011194 <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

void *pvTimerGetTimerID( const TimerHandle_t xTimer )
{
   11194:	b580      	push	{r7, lr}
   11196:	b086      	sub	sp, #24
   11198:	af00      	add	r7, sp, #0
   1119a:	6078      	str	r0, [r7, #4]
Timer_t * const pxTimer = xTimer;
   1119c:	687b      	ldr	r3, [r7, #4]
   1119e:	60fb      	str	r3, [r7, #12]
void *pvReturn;

	configASSERT( xTimer );
   111a0:	687b      	ldr	r3, [r7, #4]
   111a2:	2b00      	cmp	r3, #0
   111a4:	d109      	bne.n	111ba <pvTimerGetTimerID+0x26>
   111a6:	f04f 0328 	mov.w	r3, #40	; 0x28
   111aa:	f383 8811 	msr	BASEPRI, r3
   111ae:	f3bf 8f6f 	isb	sy
   111b2:	f3bf 8f4f 	dsb	sy
   111b6:	617b      	str	r3, [r7, #20]
   111b8:	e7fe      	b.n	111b8 <pvTimerGetTimerID+0x24>

	taskENTER_CRITICAL();
   111ba:	f000 fac5 	bl	11748 <vPortEnterCritical>
	{
		pvReturn = pxTimer->pvTimerID;
   111be:	68fb      	ldr	r3, [r7, #12]
   111c0:	6a1b      	ldr	r3, [r3, #32]
   111c2:	613b      	str	r3, [r7, #16]
	}
	taskEXIT_CRITICAL();
   111c4:	f000 faf8 	bl	117b8 <vPortExitCritical>

	return pvReturn;
   111c8:	693b      	ldr	r3, [r7, #16]
}
   111ca:	4618      	mov	r0, r3
   111cc:	f107 0718 	add.w	r7, r7, #24
   111d0:	46bd      	mov	sp, r7
   111d2:	bd80      	pop	{r7, pc}

000111d4 <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
{
   111d4:	b580      	push	{r7, lr}
   111d6:	b084      	sub	sp, #16
   111d8:	af00      	add	r7, sp, #0
   111da:	6078      	str	r0, [r7, #4]
   111dc:	6039      	str	r1, [r7, #0]
Timer_t * const pxTimer = xTimer;
   111de:	687b      	ldr	r3, [r7, #4]
   111e0:	60bb      	str	r3, [r7, #8]

	configASSERT( xTimer );
   111e2:	687b      	ldr	r3, [r7, #4]
   111e4:	2b00      	cmp	r3, #0
   111e6:	d109      	bne.n	111fc <vTimerSetTimerID+0x28>
   111e8:	f04f 0328 	mov.w	r3, #40	; 0x28
   111ec:	f383 8811 	msr	BASEPRI, r3
   111f0:	f3bf 8f6f 	isb	sy
   111f4:	f3bf 8f4f 	dsb	sy
   111f8:	60fb      	str	r3, [r7, #12]
   111fa:	e7fe      	b.n	111fa <vTimerSetTimerID+0x26>

	taskENTER_CRITICAL();
   111fc:	f000 faa4 	bl	11748 <vPortEnterCritical>
	{
		pxTimer->pvTimerID = pvNewID;
   11200:	68bb      	ldr	r3, [r7, #8]
   11202:	683a      	ldr	r2, [r7, #0]
   11204:	621a      	str	r2, [r3, #32]
	}
	taskEXIT_CRITICAL();
   11206:	f000 fad7 	bl	117b8 <vPortExitCritical>
}
   1120a:	f107 0710 	add.w	r7, r7, #16
   1120e:	46bd      	mov	sp, r7
   11210:	bd80      	pop	{r7, pc}
   11212:	bf00      	nop

00011214 <uxTimerGetTimerNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTimerGetTimerNumber( TimerHandle_t xTimer )
	{
   11214:	b480      	push	{r7}
   11216:	b083      	sub	sp, #12
   11218:	af00      	add	r7, sp, #0
   1121a:	6078      	str	r0, [r7, #4]
		return ( ( Timer_t * ) xTimer )->uxTimerNumber;
   1121c:	687b      	ldr	r3, [r7, #4]
   1121e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	}
   11220:	4618      	mov	r0, r3
   11222:	f107 070c 	add.w	r7, r7, #12
   11226:	46bd      	mov	sp, r7
   11228:	bc80      	pop	{r7}
   1122a:	4770      	bx	lr

0001122c <vTimerSetTimerNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTimerSetTimerNumber( TimerHandle_t xTimer, UBaseType_t uxTimerNumber )
	{
   1122c:	b480      	push	{r7}
   1122e:	b083      	sub	sp, #12
   11230:	af00      	add	r7, sp, #0
   11232:	6078      	str	r0, [r7, #4]
   11234:	6039      	str	r1, [r7, #0]
		( ( Timer_t * ) xTimer )->uxTimerNumber = uxTimerNumber;
   11236:	687b      	ldr	r3, [r7, #4]
   11238:	683a      	ldr	r2, [r7, #0]
   1123a:	629a      	str	r2, [r3, #40]	; 0x28
	}
   1123c:	f107 070c 	add.w	r7, r7, #12
   11240:	46bd      	mov	sp, r7
   11242:	bc80      	pop	{r7}
   11244:	4770      	bx	lr
   11246:	bf00      	nop

00011248 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
   11248:	b580      	push	{r7, lr}
   1124a:	b088      	sub	sp, #32
   1124c:	af00      	add	r7, sp, #0
   1124e:	6078      	str	r0, [r7, #4]
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
   11250:	f04f 0300 	mov.w	r3, #0
   11254:	617b      	str	r3, [r7, #20]

	vTaskSuspendAll();
   11256:	f7fd fb93 	bl	e980 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
   1125a:	f64a 134c 	movw	r3, #43340	; 0xa94c
   1125e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11262:	681b      	ldr	r3, [r3, #0]
   11264:	2b00      	cmp	r3, #0
   11266:	d108      	bne.n	1127a <pvPortMalloc+0x32>
		{
			prvHeapInit();
   11268:	f000 f8fa 	bl	11460 <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
   1126c:	f64a 134c 	movw	r3, #43340	; 0xa94c
   11270:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11274:	f04f 0201 	mov.w	r2, #1
   11278:	601a      	str	r2, [r3, #0]
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
   1127a:	687b      	ldr	r3, [r7, #4]
   1127c:	2b00      	cmp	r3, #0
   1127e:	d012      	beq.n	112a6 <pvPortMalloc+0x5e>
		{
			xWantedSize += heapSTRUCT_SIZE;
   11280:	f24c 3318 	movw	r3, #49944	; 0xc318
   11284:	f2c0 0301 	movt	r3, #1
   11288:	881b      	ldrh	r3, [r3, #0]
   1128a:	687a      	ldr	r2, [r7, #4]
   1128c:	4413      	add	r3, r2
   1128e:	607b      	str	r3, [r7, #4]

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
   11290:	687b      	ldr	r3, [r7, #4]
   11292:	f003 0307 	and.w	r3, r3, #7
   11296:	2b00      	cmp	r3, #0
   11298:	d005      	beq.n	112a6 <pvPortMalloc+0x5e>
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
   1129a:	687b      	ldr	r3, [r7, #4]
   1129c:	f023 0307 	bic.w	r3, r3, #7
   112a0:	f103 0308 	add.w	r3, r3, #8
   112a4:	607b      	str	r3, [r7, #4]
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
   112a6:	687b      	ldr	r3, [r7, #4]
   112a8:	2b00      	cmp	r3, #0
   112aa:	d075      	beq.n	11398 <pvPortMalloc+0x150>
   112ac:	687a      	ldr	r2, [r7, #4]
   112ae:	f247 73f7 	movw	r3, #30711	; 0x77f7
   112b2:	429a      	cmp	r2, r3
   112b4:	d870      	bhi.n	11398 <pvPortMalloc+0x150>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
   112b6:	f64a 133c 	movw	r3, #43324	; 0xa93c
   112ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
   112be:	60fb      	str	r3, [r7, #12]
			pxBlock = xStart.pxNextFreeBlock;
   112c0:	f64a 133c 	movw	r3, #43324	; 0xa93c
   112c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   112c8:	681b      	ldr	r3, [r3, #0]
   112ca:	60bb      	str	r3, [r7, #8]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
   112cc:	e004      	b.n	112d8 <pvPortMalloc+0x90>
			{
				pxPreviousBlock = pxBlock;
   112ce:	68bb      	ldr	r3, [r7, #8]
   112d0:	60fb      	str	r3, [r7, #12]
				pxBlock = pxBlock->pxNextFreeBlock;
   112d2:	68bb      	ldr	r3, [r7, #8]
   112d4:	681b      	ldr	r3, [r3, #0]
   112d6:	60bb      	str	r3, [r7, #8]
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
   112d8:	68bb      	ldr	r3, [r7, #8]
   112da:	685a      	ldr	r2, [r3, #4]
   112dc:	687b      	ldr	r3, [r7, #4]
   112de:	429a      	cmp	r2, r3
   112e0:	d203      	bcs.n	112ea <pvPortMalloc+0xa2>
   112e2:	68bb      	ldr	r3, [r7, #8]
   112e4:	681b      	ldr	r3, [r3, #0]
   112e6:	2b00      	cmp	r3, #0
   112e8:	d1f1      	bne.n	112ce <pvPortMalloc+0x86>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
   112ea:	68ba      	ldr	r2, [r7, #8]
   112ec:	f64a 1344 	movw	r3, #43332	; 0xa944
   112f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   112f4:	429a      	cmp	r2, r3
   112f6:	d04f      	beq.n	11398 <pvPortMalloc+0x150>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
   112f8:	68fb      	ldr	r3, [r7, #12]
   112fa:	681a      	ldr	r2, [r3, #0]
   112fc:	f24c 3318 	movw	r3, #49944	; 0xc318
   11300:	f2c0 0301 	movt	r3, #1
   11304:	881b      	ldrh	r3, [r3, #0]
   11306:	4413      	add	r3, r2
   11308:	617b      	str	r3, [r7, #20]

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
   1130a:	68bb      	ldr	r3, [r7, #8]
   1130c:	681a      	ldr	r2, [r3, #0]
   1130e:	68fb      	ldr	r3, [r7, #12]
   11310:	601a      	str	r2, [r3, #0]

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
   11312:	68bb      	ldr	r3, [r7, #8]
   11314:	685a      	ldr	r2, [r3, #4]
   11316:	687b      	ldr	r3, [r7, #4]
   11318:	ebc3 0202 	rsb	r2, r3, r2
   1131c:	f24c 3318 	movw	r3, #49944	; 0xc318
   11320:	f2c0 0301 	movt	r3, #1
   11324:	881b      	ldrh	r3, [r3, #0]
   11326:	ea4f 0343 	mov.w	r3, r3, lsl #1
   1132a:	429a      	cmp	r2, r3
   1132c:	d926      	bls.n	1137c <pvPortMalloc+0x134>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
   1132e:	68ba      	ldr	r2, [r7, #8]
   11330:	687b      	ldr	r3, [r7, #4]
   11332:	4413      	add	r3, r2
   11334:	613b      	str	r3, [r7, #16]

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
   11336:	68bb      	ldr	r3, [r7, #8]
   11338:	685a      	ldr	r2, [r3, #4]
   1133a:	687b      	ldr	r3, [r7, #4]
   1133c:	ebc3 0202 	rsb	r2, r3, r2
   11340:	693b      	ldr	r3, [r7, #16]
   11342:	605a      	str	r2, [r3, #4]
					pxBlock->xBlockSize = xWantedSize;
   11344:	68bb      	ldr	r3, [r7, #8]
   11346:	687a      	ldr	r2, [r7, #4]
   11348:	605a      	str	r2, [r3, #4]

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
   1134a:	693b      	ldr	r3, [r7, #16]
   1134c:	685b      	ldr	r3, [r3, #4]
   1134e:	61fb      	str	r3, [r7, #28]
   11350:	f64a 133c 	movw	r3, #43324	; 0xa93c
   11354:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11358:	61bb      	str	r3, [r7, #24]
   1135a:	e002      	b.n	11362 <pvPortMalloc+0x11a>
   1135c:	69bb      	ldr	r3, [r7, #24]
   1135e:	681b      	ldr	r3, [r3, #0]
   11360:	61bb      	str	r3, [r7, #24]
   11362:	69bb      	ldr	r3, [r7, #24]
   11364:	681b      	ldr	r3, [r3, #0]
   11366:	685a      	ldr	r2, [r3, #4]
   11368:	69fb      	ldr	r3, [r7, #28]
   1136a:	429a      	cmp	r2, r3
   1136c:	d3f6      	bcc.n	1135c <pvPortMalloc+0x114>
   1136e:	69bb      	ldr	r3, [r7, #24]
   11370:	681a      	ldr	r2, [r3, #0]
   11372:	693b      	ldr	r3, [r7, #16]
   11374:	601a      	str	r2, [r3, #0]
   11376:	69bb      	ldr	r3, [r7, #24]
   11378:	693a      	ldr	r2, [r7, #16]
   1137a:	601a      	str	r2, [r3, #0]
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
   1137c:	f240 03dc 	movw	r3, #220	; 0xdc
   11380:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11384:	681a      	ldr	r2, [r3, #0]
   11386:	68bb      	ldr	r3, [r7, #8]
   11388:	685b      	ldr	r3, [r3, #4]
   1138a:	ebc3 0202 	rsb	r2, r3, r2
   1138e:	f240 03dc 	movw	r3, #220	; 0xdc
   11392:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11396:	601a      	str	r2, [r3, #0]
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
   11398:	f7fd fb04 	bl	e9a4 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
   1139c:	697b      	ldr	r3, [r7, #20]
   1139e:	2b00      	cmp	r3, #0
   113a0:	d101      	bne.n	113a6 <pvPortMalloc+0x15e>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
   113a2:	f7ef fc1f 	bl	be4 <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
   113a6:	697b      	ldr	r3, [r7, #20]
}
   113a8:	4618      	mov	r0, r3
   113aa:	f107 0720 	add.w	r7, r7, #32
   113ae:	46bd      	mov	sp, r7
   113b0:	bd80      	pop	{r7, pc}
   113b2:	bf00      	nop

000113b4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
   113b4:	b580      	push	{r7, lr}
   113b6:	b086      	sub	sp, #24
   113b8:	af00      	add	r7, sp, #0
   113ba:	6078      	str	r0, [r7, #4]
uint8_t *puc = ( uint8_t * ) pv;
   113bc:	687b      	ldr	r3, [r7, #4]
   113be:	60bb      	str	r3, [r7, #8]
BlockLink_t *pxLink;

	if( pv != NULL )
   113c0:	687b      	ldr	r3, [r7, #4]
   113c2:	2b00      	cmp	r3, #0
   113c4:	d035      	beq.n	11432 <vPortFree+0x7e>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
   113c6:	f24c 3318 	movw	r3, #49944	; 0xc318
   113ca:	f2c0 0301 	movt	r3, #1
   113ce:	881b      	ldrh	r3, [r3, #0]
   113d0:	f1c3 0300 	rsb	r3, r3, #0
   113d4:	68ba      	ldr	r2, [r7, #8]
   113d6:	4413      	add	r3, r2
   113d8:	60bb      	str	r3, [r7, #8]

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
   113da:	68bb      	ldr	r3, [r7, #8]
   113dc:	60fb      	str	r3, [r7, #12]

		vTaskSuspendAll();
   113de:	f7fd facf 	bl	e980 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
   113e2:	68fb      	ldr	r3, [r7, #12]
   113e4:	685b      	ldr	r3, [r3, #4]
   113e6:	617b      	str	r3, [r7, #20]
   113e8:	f64a 133c 	movw	r3, #43324	; 0xa93c
   113ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
   113f0:	613b      	str	r3, [r7, #16]
   113f2:	e002      	b.n	113fa <vPortFree+0x46>
   113f4:	693b      	ldr	r3, [r7, #16]
   113f6:	681b      	ldr	r3, [r3, #0]
   113f8:	613b      	str	r3, [r7, #16]
   113fa:	693b      	ldr	r3, [r7, #16]
   113fc:	681b      	ldr	r3, [r3, #0]
   113fe:	685a      	ldr	r2, [r3, #4]
   11400:	697b      	ldr	r3, [r7, #20]
   11402:	429a      	cmp	r2, r3
   11404:	d3f6      	bcc.n	113f4 <vPortFree+0x40>
   11406:	693b      	ldr	r3, [r7, #16]
   11408:	681a      	ldr	r2, [r3, #0]
   1140a:	68fb      	ldr	r3, [r7, #12]
   1140c:	601a      	str	r2, [r3, #0]
   1140e:	693b      	ldr	r3, [r7, #16]
   11410:	68fa      	ldr	r2, [r7, #12]
   11412:	601a      	str	r2, [r3, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
   11414:	68fb      	ldr	r3, [r7, #12]
   11416:	685a      	ldr	r2, [r3, #4]
   11418:	f240 03dc 	movw	r3, #220	; 0xdc
   1141c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11420:	681b      	ldr	r3, [r3, #0]
   11422:	441a      	add	r2, r3
   11424:	f240 03dc 	movw	r3, #220	; 0xdc
   11428:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1142c:	601a      	str	r2, [r3, #0]
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
   1142e:	f7fd fab9 	bl	e9a4 <xTaskResumeAll>
	}
}
   11432:	f107 0718 	add.w	r7, r7, #24
   11436:	46bd      	mov	sp, r7
   11438:	bd80      	pop	{r7, pc}
   1143a:	bf00      	nop

0001143c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
   1143c:	b480      	push	{r7}
   1143e:	af00      	add	r7, sp, #0
	return xFreeBytesRemaining;
   11440:	f240 03dc 	movw	r3, #220	; 0xdc
   11444:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11448:	681b      	ldr	r3, [r3, #0]
}
   1144a:	4618      	mov	r0, r3
   1144c:	46bd      	mov	sp, r7
   1144e:	bc80      	pop	{r7}
   11450:	4770      	bx	lr
   11452:	bf00      	nop

00011454 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
   11454:	b480      	push	{r7}
   11456:	af00      	add	r7, sp, #0
	/* This just exists to keep the linker quiet. */
}
   11458:	46bd      	mov	sp, r7
   1145a:	bc80      	pop	{r7}
   1145c:	4770      	bx	lr
   1145e:	bf00      	nop

00011460 <prvHeapInit>:
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
   11460:	b480      	push	{r7}
   11462:	b083      	sub	sp, #12
   11464:	af00      	add	r7, sp, #0
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
   11466:	4b18      	ldr	r3, [pc, #96]	; (114c8 <prvHeapInit+0x68>)
   11468:	f023 0307 	bic.w	r3, r3, #7
   1146c:	607b      	str	r3, [r7, #4]

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
   1146e:	687a      	ldr	r2, [r7, #4]
   11470:	f64a 133c 	movw	r3, #43324	; 0xa93c
   11474:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11478:	601a      	str	r2, [r3, #0]
	xStart.xBlockSize = ( size_t ) 0;
   1147a:	f64a 133c 	movw	r3, #43324	; 0xa93c
   1147e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11482:	f04f 0200 	mov.w	r2, #0
   11486:	605a      	str	r2, [r3, #4]

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
   11488:	f64a 1344 	movw	r3, #43332	; 0xa944
   1148c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11490:	f247 72f8 	movw	r2, #30712	; 0x77f8
   11494:	605a      	str	r2, [r3, #4]
	xEnd.pxNextFreeBlock = NULL;
   11496:	f64a 1344 	movw	r3, #43332	; 0xa944
   1149a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1149e:	f04f 0200 	mov.w	r2, #0
   114a2:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
   114a4:	687b      	ldr	r3, [r7, #4]
   114a6:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
   114a8:	683b      	ldr	r3, [r7, #0]
   114aa:	f247 72f8 	movw	r2, #30712	; 0x77f8
   114ae:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
   114b0:	683a      	ldr	r2, [r7, #0]
   114b2:	f64a 1344 	movw	r3, #43332	; 0xa944
   114b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   114ba:	6013      	str	r3, [r2, #0]
}
   114bc:	f107 070c 	add.w	r7, r7, #12
   114c0:	46bd      	mov	sp, r7
   114c2:	bc80      	pop	{r7}
   114c4:	4770      	bx	lr
   114c6:	bf00      	nop
   114c8:	20003144 	.word	0x20003144

000114cc <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
   114cc:	b480      	push	{r7}
   114ce:	b085      	sub	sp, #20
   114d0:	af00      	add	r7, sp, #0
   114d2:	60f8      	str	r0, [r7, #12]
   114d4:	60b9      	str	r1, [r7, #8]
   114d6:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
   114d8:	68fb      	ldr	r3, [r7, #12]
   114da:	f1a3 0304 	sub.w	r3, r3, #4
   114de:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
   114e0:	68fb      	ldr	r3, [r7, #12]
   114e2:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   114e6:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   114e8:	68fb      	ldr	r3, [r7, #12]
   114ea:	f1a3 0304 	sub.w	r3, r3, #4
   114ee:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
   114f0:	68bb      	ldr	r3, [r7, #8]
   114f2:	f023 0201 	bic.w	r2, r3, #1
   114f6:	68fb      	ldr	r3, [r7, #12]
   114f8:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   114fa:	68fb      	ldr	r3, [r7, #12]
   114fc:	f1a3 0304 	sub.w	r3, r3, #4
   11500:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
   11502:	f241 5335 	movw	r3, #5429	; 0x1535
   11506:	f2c0 0301 	movt	r3, #1
   1150a:	68fa      	ldr	r2, [r7, #12]
   1150c:	6013      	str	r3, [r2, #0]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
   1150e:	68fb      	ldr	r3, [r7, #12]
   11510:	f1a3 0314 	sub.w	r3, r3, #20
   11514:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
   11516:	687a      	ldr	r2, [r7, #4]
   11518:	68fb      	ldr	r3, [r7, #12]
   1151a:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
   1151c:	68fb      	ldr	r3, [r7, #12]
   1151e:	f1a3 0320 	sub.w	r3, r3, #32
   11522:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
   11524:	68fb      	ldr	r3, [r7, #12]
}
   11526:	4618      	mov	r0, r3
   11528:	f107 0714 	add.w	r7, r7, #20
   1152c:	46bd      	mov	sp, r7
   1152e:	bc80      	pop	{r7}
   11530:	4770      	bx	lr
   11532:	bf00      	nop

00011534 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
   11534:	b480      	push	{r7}
   11536:	b085      	sub	sp, #20
   11538:	af00      	add	r7, sp, #0
volatile uint32_t ulDummy = 0UL;
   1153a:	f04f 0300 	mov.w	r3, #0
   1153e:	607b      	str	r3, [r7, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
   11540:	f240 03e0 	movw	r3, #224	; 0xe0
   11544:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11548:	681b      	ldr	r3, [r3, #0]
   1154a:	f1b3 3fff 	cmp.w	r3, #4294967295
   1154e:	d009      	beq.n	11564 <prvTaskExitError+0x30>
   11550:	f04f 0328 	mov.w	r3, #40	; 0x28
   11554:	f383 8811 	msr	BASEPRI, r3
   11558:	f3bf 8f6f 	isb	sy
   1155c:	f3bf 8f4f 	dsb	sy
   11560:	60bb      	str	r3, [r7, #8]
   11562:	e7fe      	b.n	11562 <prvTaskExitError+0x2e>
   11564:	f04f 0328 	mov.w	r3, #40	; 0x28
   11568:	f383 8811 	msr	BASEPRI, r3
   1156c:	f3bf 8f6f 	isb	sy
   11570:	f3bf 8f4f 	dsb	sy
   11574:	60fb      	str	r3, [r7, #12]
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
   11576:	687b      	ldr	r3, [r7, #4]
   11578:	2b00      	cmp	r3, #0
   1157a:	d0fc      	beq.n	11576 <prvTaskExitError+0x42>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
   1157c:	f107 0714 	add.w	r7, r7, #20
   11580:	46bd      	mov	sp, r7
   11582:	bc80      	pop	{r7}
   11584:	4770      	bx	lr
   11586:	bf00      	nop
	...

00011590 <SVC_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
   11590:	4b07      	ldr	r3, [pc, #28]	; (115b0 <pxCurrentTCBConst2>)
   11592:	6819      	ldr	r1, [r3, #0]
   11594:	6808      	ldr	r0, [r1, #0]
   11596:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   1159a:	f380 8809 	msr	PSP, r0
   1159e:	f3bf 8f6f 	isb	sy
   115a2:	f04f 0000 	mov.w	r0, #0
   115a6:	f380 8811 	msr	BASEPRI, r0
   115aa:	f04e 0e0d 	orr.w	lr, lr, #13
   115ae:	4770      	bx	lr

000115b0 <pxCurrentTCBConst2>:
   115b0:	20002ff4 	.word	0x20002ff4
   115b4:	f3af 8000 	nop.w
   115b8:	f3af 8000 	nop.w
   115bc:	f3af 8000 	nop.w

000115c0 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
   115c0:	4806      	ldr	r0, [pc, #24]	; (115dc <prvPortStartFirstTask+0x1c>)
   115c2:	6800      	ldr	r0, [r0, #0]
   115c4:	6800      	ldr	r0, [r0, #0]
   115c6:	f380 8808 	msr	MSP, r0
   115ca:	b662      	cpsie	i
   115cc:	b661      	cpsie	f
   115ce:	f3bf 8f4f 	dsb	sy
   115d2:	f3bf 8f6f 	isb	sy
   115d6:	df00      	svc	0
   115d8:	bf00      	nop
   115da:	0000      	.short	0x0000
   115dc:	e000ed08 	.word	0xe000ed08

000115e0 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
   115e0:	b580      	push	{r7, lr}
   115e2:	b084      	sub	sp, #16
   115e4:	af00      	add	r7, sp, #0
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	#if( configASSERT_DEFINED == 1 )
	{
		volatile uint32_t ulOriginalPriority;
		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
   115e6:	f24e 4300 	movw	r3, #58368	; 0xe400
   115ea:	f2ce 0300 	movt	r3, #57344	; 0xe000
   115ee:	60bb      	str	r3, [r7, #8]
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
   115f0:	68bb      	ldr	r3, [r7, #8]
   115f2:	781b      	ldrb	r3, [r3, #0]
   115f4:	b2db      	uxtb	r3, r3
   115f6:	607b      	str	r3, [r7, #4]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
   115f8:	68bb      	ldr	r3, [r7, #8]
   115fa:	f04f 32ff 	mov.w	r2, #4294967295
   115fe:	701a      	strb	r2, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
   11600:	68bb      	ldr	r3, [r7, #8]
   11602:	781b      	ldrb	r3, [r3, #0]
   11604:	b2db      	uxtb	r3, r3
   11606:	70fb      	strb	r3, [r7, #3]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
   11608:	78fb      	ldrb	r3, [r7, #3]
   1160a:	b2db      	uxtb	r3, r3
   1160c:	461a      	mov	r2, r3
   1160e:	f002 0228 	and.w	r2, r2, #40	; 0x28
   11612:	f64a 1350 	movw	r3, #43344	; 0xa950
   11616:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1161a:	701a      	strb	r2, [r3, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
   1161c:	f64a 1354 	movw	r3, #43348	; 0xa954
   11620:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11624:	f04f 0207 	mov.w	r2, #7
   11628:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
   1162a:	e011      	b.n	11650 <xPortStartScheduler+0x70>
		{
			ulMaxPRIGROUPValue--;
   1162c:	f64a 1354 	movw	r3, #43348	; 0xa954
   11630:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11634:	681b      	ldr	r3, [r3, #0]
   11636:	f103 32ff 	add.w	r2, r3, #4294967295
   1163a:	f64a 1354 	movw	r3, #43348	; 0xa954
   1163e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11642:	601a      	str	r2, [r3, #0]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
   11644:	78fb      	ldrb	r3, [r7, #3]
   11646:	b2db      	uxtb	r3, r3
   11648:	ea4f 0343 	mov.w	r3, r3, lsl #1
   1164c:	b2db      	uxtb	r3, r3
   1164e:	70fb      	strb	r3, [r7, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
   11650:	78fb      	ldrb	r3, [r7, #3]
   11652:	b2db      	uxtb	r3, r3
   11654:	b25b      	sxtb	r3, r3
   11656:	2b00      	cmp	r3, #0
   11658:	dbe8      	blt.n	1162c <xPortStartScheduler+0x4c>
		#ifdef configPRIO_BITS
		{
			/* Check the FreeRTOS configuration that defines the number of
			priority bits matches the number of priority bits actually queried
			from the hardware. */
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
   1165a:	f64a 1354 	movw	r3, #43348	; 0xa954
   1165e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11662:	681b      	ldr	r3, [r3, #0]
   11664:	f1c3 0307 	rsb	r3, r3, #7
   11668:	2b05      	cmp	r3, #5
   1166a:	d009      	beq.n	11680 <xPortStartScheduler+0xa0>
   1166c:	f04f 0328 	mov.w	r3, #40	; 0x28
   11670:	f383 8811 	msr	BASEPRI, r3
   11674:	f3bf 8f6f 	isb	sy
   11678:	f3bf 8f4f 	dsb	sy
   1167c:	60fb      	str	r3, [r7, #12]
   1167e:	e7fe      	b.n	1167e <xPortStartScheduler+0x9e>
		}
		#endif

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
   11680:	f64a 1354 	movw	r3, #43348	; 0xa954
   11684:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11688:	681b      	ldr	r3, [r3, #0]
   1168a:	ea4f 2203 	mov.w	r2, r3, lsl #8
   1168e:	f64a 1354 	movw	r3, #43348	; 0xa954
   11692:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11696:	601a      	str	r2, [r3, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
   11698:	f64a 1354 	movw	r3, #43348	; 0xa954
   1169c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   116a0:	681b      	ldr	r3, [r3, #0]
   116a2:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
   116a6:	f64a 1354 	movw	r3, #43348	; 0xa954
   116aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
   116ae:	601a      	str	r2, [r3, #0]

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pucFirstUserPriorityRegister = ulOriginalPriority;
   116b0:	687b      	ldr	r3, [r7, #4]
   116b2:	b2da      	uxtb	r2, r3
   116b4:	68bb      	ldr	r3, [r7, #8]
   116b6:	701a      	strb	r2, [r3, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
   116b8:	f64e 5320 	movw	r3, #60704	; 0xed20
   116bc:	f2ce 0300 	movt	r3, #57344	; 0xe000
   116c0:	f64e 5220 	movw	r2, #60704	; 0xed20
   116c4:	f2ce 0200 	movt	r2, #57344	; 0xe000
   116c8:	6812      	ldr	r2, [r2, #0]
   116ca:	f442 0278 	orr.w	r2, r2, #16252928	; 0xf80000
   116ce:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
   116d0:	f64e 5320 	movw	r3, #60704	; 0xed20
   116d4:	f2ce 0300 	movt	r3, #57344	; 0xe000
   116d8:	f64e 5220 	movw	r2, #60704	; 0xed20
   116dc:	f2ce 0200 	movt	r2, #57344	; 0xe000
   116e0:	6812      	ldr	r2, [r2, #0]
   116e2:	f042 4278 	orr.w	r2, r2, #4160749568	; 0xf8000000
   116e6:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
   116e8:	f000 f8e4 	bl	118b4 <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
   116ec:	f240 03e0 	movw	r3, #224	; 0xe0
   116f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   116f4:	f04f 0200 	mov.w	r2, #0
   116f8:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
   116fa:	f7ff ff61 	bl	115c0 <prvPortStartFirstTask>
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS.  Call
	vTaskSwitchContext() so link time optimisation does not remove the
	symbol. */
	vTaskSwitchContext();
   116fe:	f7fd fc29 	bl	ef54 <vTaskSwitchContext>
	prvTaskExitError();
   11702:	f7ff ff17 	bl	11534 <prvTaskExitError>

	/* Should not get here! */
	return 0;
   11706:	f04f 0300 	mov.w	r3, #0
}
   1170a:	4618      	mov	r0, r3
   1170c:	f107 0710 	add.w	r7, r7, #16
   11710:	46bd      	mov	sp, r7
   11712:	bd80      	pop	{r7, pc}

00011714 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
   11714:	b480      	push	{r7}
   11716:	b083      	sub	sp, #12
   11718:	af00      	add	r7, sp, #0
	/* Not implemented in ports where there is nothing to return to.
	Artificially force an assert. */
	configASSERT( uxCriticalNesting == 1000UL );
   1171a:	f240 03e0 	movw	r3, #224	; 0xe0
   1171e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11722:	681b      	ldr	r3, [r3, #0]
   11724:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
   11728:	d009      	beq.n	1173e <vPortEndScheduler+0x2a>
   1172a:	f04f 0328 	mov.w	r3, #40	; 0x28
   1172e:	f383 8811 	msr	BASEPRI, r3
   11732:	f3bf 8f6f 	isb	sy
   11736:	f3bf 8f4f 	dsb	sy
   1173a:	607b      	str	r3, [r7, #4]
   1173c:	e7fe      	b.n	1173c <vPortEndScheduler+0x28>
}
   1173e:	f107 070c 	add.w	r7, r7, #12
   11742:	46bd      	mov	sp, r7
   11744:	bc80      	pop	{r7}
   11746:	4770      	bx	lr

00011748 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
   11748:	b480      	push	{r7}
   1174a:	b083      	sub	sp, #12
   1174c:	af00      	add	r7, sp, #0
   1174e:	f04f 0328 	mov.w	r3, #40	; 0x28
   11752:	f383 8811 	msr	BASEPRI, r3
   11756:	f3bf 8f6f 	isb	sy
   1175a:	f3bf 8f4f 	dsb	sy
   1175e:	603b      	str	r3, [r7, #0]
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
   11760:	f240 03e0 	movw	r3, #224	; 0xe0
   11764:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11768:	681b      	ldr	r3, [r3, #0]
   1176a:	f103 0201 	add.w	r2, r3, #1
   1176e:	f240 03e0 	movw	r3, #224	; 0xe0
   11772:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11776:	601a      	str	r2, [r3, #0]
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
   11778:	f240 03e0 	movw	r3, #224	; 0xe0
   1177c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11780:	681b      	ldr	r3, [r3, #0]
   11782:	2b01      	cmp	r3, #1
   11784:	d112      	bne.n	117ac <vPortEnterCritical+0x64>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
   11786:	f64e 5304 	movw	r3, #60676	; 0xed04
   1178a:	f2ce 0300 	movt	r3, #57344	; 0xe000
   1178e:	681b      	ldr	r3, [r3, #0]
   11790:	f003 03ff 	and.w	r3, r3, #255	; 0xff
   11794:	2b00      	cmp	r3, #0
   11796:	d009      	beq.n	117ac <vPortEnterCritical+0x64>
   11798:	f04f 0328 	mov.w	r3, #40	; 0x28
   1179c:	f383 8811 	msr	BASEPRI, r3
   117a0:	f3bf 8f6f 	isb	sy
   117a4:	f3bf 8f4f 	dsb	sy
   117a8:	607b      	str	r3, [r7, #4]
   117aa:	e7fe      	b.n	117aa <vPortEnterCritical+0x62>
	}
}
   117ac:	f107 070c 	add.w	r7, r7, #12
   117b0:	46bd      	mov	sp, r7
   117b2:	bc80      	pop	{r7}
   117b4:	4770      	bx	lr
   117b6:	bf00      	nop

000117b8 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
   117b8:	b480      	push	{r7}
   117ba:	b083      	sub	sp, #12
   117bc:	af00      	add	r7, sp, #0
	configASSERT( uxCriticalNesting );
   117be:	f240 03e0 	movw	r3, #224	; 0xe0
   117c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   117c6:	681b      	ldr	r3, [r3, #0]
   117c8:	2b00      	cmp	r3, #0
   117ca:	d109      	bne.n	117e0 <vPortExitCritical+0x28>
   117cc:	f04f 0328 	mov.w	r3, #40	; 0x28
   117d0:	f383 8811 	msr	BASEPRI, r3
   117d4:	f3bf 8f6f 	isb	sy
   117d8:	f3bf 8f4f 	dsb	sy
   117dc:	603b      	str	r3, [r7, #0]
   117de:	e7fe      	b.n	117de <vPortExitCritical+0x26>
	uxCriticalNesting--;
   117e0:	f240 03e0 	movw	r3, #224	; 0xe0
   117e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   117e8:	681b      	ldr	r3, [r3, #0]
   117ea:	f103 32ff 	add.w	r2, r3, #4294967295
   117ee:	f240 03e0 	movw	r3, #224	; 0xe0
   117f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   117f6:	601a      	str	r2, [r3, #0]
	if( uxCriticalNesting == 0 )
   117f8:	f240 03e0 	movw	r3, #224	; 0xe0
   117fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11800:	681b      	ldr	r3, [r3, #0]
   11802:	2b00      	cmp	r3, #0
   11804:	d105      	bne.n	11812 <vPortExitCritical+0x5a>
   11806:	f04f 0300 	mov.w	r3, #0
   1180a:	607b      	str	r3, [r7, #4]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   1180c:	687b      	ldr	r3, [r7, #4]
   1180e:	f383 8811 	msr	BASEPRI, r3
	{
		portENABLE_INTERRUPTS();
	}
}
   11812:	f107 070c 	add.w	r7, r7, #12
   11816:	46bd      	mov	sp, r7
   11818:	bc80      	pop	{r7}
   1181a:	4770      	bx	lr
   1181c:	0000      	lsls	r0, r0, #0
	...

00011820 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
   11820:	f3ef 8009 	mrs	r0, PSP
   11824:	f3bf 8f6f 	isb	sy
   11828:	4b0d      	ldr	r3, [pc, #52]	; (11860 <pxCurrentTCBConst>)
   1182a:	681a      	ldr	r2, [r3, #0]
   1182c:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   11830:	6010      	str	r0, [r2, #0]
   11832:	e92d 4008 	stmdb	sp!, {r3, lr}
   11836:	f04f 0028 	mov.w	r0, #40	; 0x28
   1183a:	f380 8811 	msr	BASEPRI, r0
   1183e:	f7fd fb89 	bl	ef54 <vTaskSwitchContext>
   11842:	f04f 0000 	mov.w	r0, #0
   11846:	f380 8811 	msr	BASEPRI, r0
   1184a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   1184e:	6819      	ldr	r1, [r3, #0]
   11850:	6808      	ldr	r0, [r1, #0]
   11852:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   11856:	f380 8809 	msr	PSP, r0
   1185a:	f3bf 8f6f 	isb	sy
   1185e:	4770      	bx	lr

00011860 <pxCurrentTCBConst>:
   11860:	20002ff4 	.word	0x20002ff4
   11864:	f3af 8000 	nop.w
   11868:	f3af 8000 	nop.w
   1186c:	f3af 8000 	nop.w

00011870 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
   11870:	b580      	push	{r7, lr}
   11872:	b082      	sub	sp, #8
   11874:	af00      	add	r7, sp, #0

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   11876:	f04f 0328 	mov.w	r3, #40	; 0x28
   1187a:	f383 8811 	msr	BASEPRI, r3
   1187e:	f3bf 8f6f 	isb	sy
   11882:	f3bf 8f4f 	dsb	sy
   11886:	603b      	str	r3, [r7, #0]
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
   11888:	f7fd fa62 	bl	ed50 <xTaskIncrementTick>
   1188c:	4603      	mov	r3, r0
   1188e:	2b00      	cmp	r3, #0
   11890:	d006      	beq.n	118a0 <SysTick_Handler+0x30>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   11892:	f64e 5304 	movw	r3, #60676	; 0xed04
   11896:	f2ce 0300 	movt	r3, #57344	; 0xe000
   1189a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1189e:	601a      	str	r2, [r3, #0]
   118a0:	f04f 0300 	mov.w	r3, #0
   118a4:	607b      	str	r3, [r7, #4]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   118a6:	687b      	ldr	r3, [r7, #4]
   118a8:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
   118ac:	f107 0708 	add.w	r7, r7, #8
   118b0:	46bd      	mov	sp, r7
   118b2:	bd80      	pop	{r7, pc}

000118b4 <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
   118b4:	b480      	push	{r7}
   118b6:	af00      	add	r7, sp, #0
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Stop and clear the SysTick. */
	portNVIC_SYSTICK_CTRL_REG = 0UL;
   118b8:	f24e 0310 	movw	r3, #57360	; 0xe010
   118bc:	f2ce 0300 	movt	r3, #57344	; 0xe000
   118c0:	f04f 0200 	mov.w	r2, #0
   118c4:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
   118c6:	f24e 0318 	movw	r3, #57368	; 0xe018
   118ca:	f2ce 0300 	movt	r3, #57344	; 0xe000
   118ce:	f04f 0200 	mov.w	r2, #0
   118d2:	601a      	str	r2, [r3, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
   118d4:	f24e 0314 	movw	r3, #57364	; 0xe014
   118d8:	f2ce 0300 	movt	r3, #57344	; 0xe000
   118dc:	f240 02c0 	movw	r2, #192	; 0xc0
   118e0:	f2c2 0200 	movt	r2, #8192	; 0x2000
   118e4:	6811      	ldr	r1, [r2, #0]
   118e6:	f644 52d3 	movw	r2, #19923	; 0x4dd3
   118ea:	f2c1 0262 	movt	r2, #4194	; 0x1062
   118ee:	fba2 0201 	umull	r0, r2, r2, r1
   118f2:	ea4f 1292 	mov.w	r2, r2, lsr #6
   118f6:	f102 32ff 	add.w	r2, r2, #4294967295
   118fa:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
   118fc:	f24e 0310 	movw	r3, #57360	; 0xe010
   11900:	f2ce 0300 	movt	r3, #57344	; 0xe000
   11904:	f04f 0207 	mov.w	r2, #7
   11908:	601a      	str	r2, [r3, #0]
}
   1190a:	46bd      	mov	sp, r7
   1190c:	bc80      	pop	{r7}
   1190e:	4770      	bx	lr

00011910 <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
   11910:	b480      	push	{r7}
   11912:	b085      	sub	sp, #20
   11914:	af00      	add	r7, sp, #0
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
   11916:	f3ef 8305 	mrs	r3, IPSR
   1191a:	603b      	str	r3, [r7, #0]

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
   1191c:	683b      	ldr	r3, [r7, #0]
   1191e:	2b0f      	cmp	r3, #15
   11920:	d91a      	bls.n	11958 <vPortValidateInterruptPriority+0x48>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
   11922:	f24c 331c 	movw	r3, #49948	; 0xc31c
   11926:	f2c0 0301 	movt	r3, #1
   1192a:	681a      	ldr	r2, [r3, #0]
   1192c:	683b      	ldr	r3, [r7, #0]
   1192e:	4413      	add	r3, r2
   11930:	781b      	ldrb	r3, [r3, #0]
   11932:	71fb      	strb	r3, [r7, #7]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
   11934:	f64a 1350 	movw	r3, #43344	; 0xa950
   11938:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1193c:	781b      	ldrb	r3, [r3, #0]
   1193e:	79fa      	ldrb	r2, [r7, #7]
   11940:	429a      	cmp	r2, r3
   11942:	d209      	bcs.n	11958 <vPortValidateInterruptPriority+0x48>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   11944:	f04f 0328 	mov.w	r3, #40	; 0x28
   11948:	f383 8811 	msr	BASEPRI, r3
   1194c:	f3bf 8f6f 	isb	sy
   11950:	f3bf 8f4f 	dsb	sy
   11954:	60bb      	str	r3, [r7, #8]
   11956:	e7fe      	b.n	11956 <vPortValidateInterruptPriority+0x46>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
   11958:	f64e 530c 	movw	r3, #60684	; 0xed0c
   1195c:	f2ce 0300 	movt	r3, #57344	; 0xe000
   11960:	681b      	ldr	r3, [r3, #0]
   11962:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
   11966:	f64a 1354 	movw	r3, #43348	; 0xa954
   1196a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1196e:	681b      	ldr	r3, [r3, #0]
   11970:	429a      	cmp	r2, r3
   11972:	d909      	bls.n	11988 <vPortValidateInterruptPriority+0x78>
   11974:	f04f 0328 	mov.w	r3, #40	; 0x28
   11978:	f383 8811 	msr	BASEPRI, r3
   1197c:	f3bf 8f6f 	isb	sy
   11980:	f3bf 8f4f 	dsb	sy
   11984:	60fb      	str	r3, [r7, #12]
   11986:	e7fe      	b.n	11986 <vPortValidateInterruptPriority+0x76>
	}
   11988:	f107 0714 	add.w	r7, r7, #20
   1198c:	46bd      	mov	sp, r7
   1198e:	bc80      	pop	{r7}
   11990:	4770      	bx	lr
   11992:	bf00      	nop

00011994 <abort>:
   11994:	b508      	push	{r3, lr}
   11996:	2006      	movs	r0, #6
   11998:	f000 fa10 	bl	11dbc <raise>
   1199c:	2001      	movs	r0, #1
   1199e:	f7f5 ffe3 	bl	7968 <_exit>
   119a2:	bf00      	nop

000119a4 <__libc_init_array>:
   119a4:	b570      	push	{r4, r5, r6, lr}
   119a6:	f24c 3640 	movw	r6, #49984	; 0xc340
   119aa:	f24c 3540 	movw	r5, #49984	; 0xc340
   119ae:	f2c0 0601 	movt	r6, #1
   119b2:	f2c0 0501 	movt	r5, #1
   119b6:	1b76      	subs	r6, r6, r5
   119b8:	10b6      	asrs	r6, r6, #2
   119ba:	d006      	beq.n	119ca <__libc_init_array+0x26>
   119bc:	2400      	movs	r4, #0
   119be:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   119c2:	3401      	adds	r4, #1
   119c4:	4798      	blx	r3
   119c6:	42a6      	cmp	r6, r4
   119c8:	d8f9      	bhi.n	119be <__libc_init_array+0x1a>
   119ca:	f24c 3540 	movw	r5, #49984	; 0xc340
   119ce:	f24c 3644 	movw	r6, #49988	; 0xc344
   119d2:	f2c0 0501 	movt	r5, #1
   119d6:	f2c0 0601 	movt	r6, #1
   119da:	1b76      	subs	r6, r6, r5
   119dc:	f00a fca4 	bl	1c328 <_init>
   119e0:	10b6      	asrs	r6, r6, #2
   119e2:	d006      	beq.n	119f2 <__libc_init_array+0x4e>
   119e4:	2400      	movs	r4, #0
   119e6:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   119ea:	3401      	adds	r4, #1
   119ec:	4798      	blx	r3
   119ee:	42a6      	cmp	r6, r4
   119f0:	d8f9      	bhi.n	119e6 <__libc_init_array+0x42>
   119f2:	bd70      	pop	{r4, r5, r6, pc}

000119f4 <memcpy>:
   119f4:	2a03      	cmp	r2, #3
   119f6:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
   119fa:	d80b      	bhi.n	11a14 <memcpy+0x20>
   119fc:	b13a      	cbz	r2, 11a0e <memcpy+0x1a>
   119fe:	2300      	movs	r3, #0
   11a00:	f811 c003 	ldrb.w	ip, [r1, r3]
   11a04:	f800 c003 	strb.w	ip, [r0, r3]
   11a08:	3301      	adds	r3, #1
   11a0a:	4293      	cmp	r3, r2
   11a0c:	d1f8      	bne.n	11a00 <memcpy+0xc>
   11a0e:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
   11a12:	4770      	bx	lr
   11a14:	1882      	adds	r2, r0, r2
   11a16:	460c      	mov	r4, r1
   11a18:	4603      	mov	r3, r0
   11a1a:	e003      	b.n	11a24 <memcpy+0x30>
   11a1c:	f814 1c01 	ldrb.w	r1, [r4, #-1]
   11a20:	f803 1c01 	strb.w	r1, [r3, #-1]
   11a24:	f003 0603 	and.w	r6, r3, #3
   11a28:	4619      	mov	r1, r3
   11a2a:	46a4      	mov	ip, r4
   11a2c:	3301      	adds	r3, #1
   11a2e:	3401      	adds	r4, #1
   11a30:	2e00      	cmp	r6, #0
   11a32:	d1f3      	bne.n	11a1c <memcpy+0x28>
   11a34:	f01c 0403 	ands.w	r4, ip, #3
   11a38:	4663      	mov	r3, ip
   11a3a:	bf08      	it	eq
   11a3c:	ebc1 0c02 	rsbeq	ip, r1, r2
   11a40:	d068      	beq.n	11b14 <memcpy+0x120>
   11a42:	4265      	negs	r5, r4
   11a44:	f1c4 0a04 	rsb	sl, r4, #4
   11a48:	eb0c 0705 	add.w	r7, ip, r5
   11a4c:	4633      	mov	r3, r6
   11a4e:	ea4f 0aca 	mov.w	sl, sl, lsl #3
   11a52:	f85c 6005 	ldr.w	r6, [ip, r5]
   11a56:	ea4f 08c4 	mov.w	r8, r4, lsl #3
   11a5a:	1a55      	subs	r5, r2, r1
   11a5c:	e008      	b.n	11a70 <memcpy+0x7c>
   11a5e:	f857 4f04 	ldr.w	r4, [r7, #4]!
   11a62:	4626      	mov	r6, r4
   11a64:	fa04 f40a 	lsl.w	r4, r4, sl
   11a68:	ea49 0404 	orr.w	r4, r9, r4
   11a6c:	50cc      	str	r4, [r1, r3]
   11a6e:	3304      	adds	r3, #4
   11a70:	185c      	adds	r4, r3, r1
   11a72:	2d03      	cmp	r5, #3
   11a74:	fa26 f908 	lsr.w	r9, r6, r8
   11a78:	f1a5 0504 	sub.w	r5, r5, #4
   11a7c:	eb0c 0603 	add.w	r6, ip, r3
   11a80:	dced      	bgt.n	11a5e <memcpy+0x6a>
   11a82:	2300      	movs	r3, #0
   11a84:	e002      	b.n	11a8c <memcpy+0x98>
   11a86:	5cf1      	ldrb	r1, [r6, r3]
   11a88:	54e1      	strb	r1, [r4, r3]
   11a8a:	3301      	adds	r3, #1
   11a8c:	1919      	adds	r1, r3, r4
   11a8e:	4291      	cmp	r1, r2
   11a90:	d3f9      	bcc.n	11a86 <memcpy+0x92>
   11a92:	e7bc      	b.n	11a0e <memcpy+0x1a>
   11a94:	f853 4c40 	ldr.w	r4, [r3, #-64]
   11a98:	f841 4c40 	str.w	r4, [r1, #-64]
   11a9c:	f853 4c3c 	ldr.w	r4, [r3, #-60]
   11aa0:	f841 4c3c 	str.w	r4, [r1, #-60]
   11aa4:	f853 4c38 	ldr.w	r4, [r3, #-56]
   11aa8:	f841 4c38 	str.w	r4, [r1, #-56]
   11aac:	f853 4c34 	ldr.w	r4, [r3, #-52]
   11ab0:	f841 4c34 	str.w	r4, [r1, #-52]
   11ab4:	f853 4c30 	ldr.w	r4, [r3, #-48]
   11ab8:	f841 4c30 	str.w	r4, [r1, #-48]
   11abc:	f853 4c2c 	ldr.w	r4, [r3, #-44]
   11ac0:	f841 4c2c 	str.w	r4, [r1, #-44]
   11ac4:	f853 4c28 	ldr.w	r4, [r3, #-40]
   11ac8:	f841 4c28 	str.w	r4, [r1, #-40]
   11acc:	f853 4c24 	ldr.w	r4, [r3, #-36]
   11ad0:	f841 4c24 	str.w	r4, [r1, #-36]
   11ad4:	f853 4c20 	ldr.w	r4, [r3, #-32]
   11ad8:	f841 4c20 	str.w	r4, [r1, #-32]
   11adc:	f853 4c1c 	ldr.w	r4, [r3, #-28]
   11ae0:	f841 4c1c 	str.w	r4, [r1, #-28]
   11ae4:	f853 4c18 	ldr.w	r4, [r3, #-24]
   11ae8:	f841 4c18 	str.w	r4, [r1, #-24]
   11aec:	f853 4c14 	ldr.w	r4, [r3, #-20]
   11af0:	f841 4c14 	str.w	r4, [r1, #-20]
   11af4:	f853 4c10 	ldr.w	r4, [r3, #-16]
   11af8:	f841 4c10 	str.w	r4, [r1, #-16]
   11afc:	f853 4c0c 	ldr.w	r4, [r3, #-12]
   11b00:	f841 4c0c 	str.w	r4, [r1, #-12]
   11b04:	f853 4c08 	ldr.w	r4, [r3, #-8]
   11b08:	f841 4c08 	str.w	r4, [r1, #-8]
   11b0c:	f853 4c04 	ldr.w	r4, [r3, #-4]
   11b10:	f841 4c04 	str.w	r4, [r1, #-4]
   11b14:	461c      	mov	r4, r3
   11b16:	460d      	mov	r5, r1
   11b18:	3340      	adds	r3, #64	; 0x40
   11b1a:	3140      	adds	r1, #64	; 0x40
   11b1c:	f1bc 0f3f 	cmp.w	ip, #63	; 0x3f
   11b20:	f1ac 0c40 	sub.w	ip, ip, #64	; 0x40
   11b24:	dcb6      	bgt.n	11a94 <memcpy+0xa0>
   11b26:	4621      	mov	r1, r4
   11b28:	462b      	mov	r3, r5
   11b2a:	1b54      	subs	r4, r2, r5
   11b2c:	e00f      	b.n	11b4e <memcpy+0x15a>
   11b2e:	f851 5c10 	ldr.w	r5, [r1, #-16]
   11b32:	f843 5c10 	str.w	r5, [r3, #-16]
   11b36:	f851 5c0c 	ldr.w	r5, [r1, #-12]
   11b3a:	f843 5c0c 	str.w	r5, [r3, #-12]
   11b3e:	f851 5c08 	ldr.w	r5, [r1, #-8]
   11b42:	f843 5c08 	str.w	r5, [r3, #-8]
   11b46:	f851 5c04 	ldr.w	r5, [r1, #-4]
   11b4a:	f843 5c04 	str.w	r5, [r3, #-4]
   11b4e:	2c0f      	cmp	r4, #15
   11b50:	460d      	mov	r5, r1
   11b52:	469c      	mov	ip, r3
   11b54:	f101 0110 	add.w	r1, r1, #16
   11b58:	f103 0310 	add.w	r3, r3, #16
   11b5c:	f1a4 0410 	sub.w	r4, r4, #16
   11b60:	dce5      	bgt.n	11b2e <memcpy+0x13a>
   11b62:	ebcc 0102 	rsb	r1, ip, r2
   11b66:	2300      	movs	r3, #0
   11b68:	e003      	b.n	11b72 <memcpy+0x17e>
   11b6a:	58ec      	ldr	r4, [r5, r3]
   11b6c:	f84c 4003 	str.w	r4, [ip, r3]
   11b70:	3304      	adds	r3, #4
   11b72:	195e      	adds	r6, r3, r5
   11b74:	2903      	cmp	r1, #3
   11b76:	eb03 040c 	add.w	r4, r3, ip
   11b7a:	f1a1 0104 	sub.w	r1, r1, #4
   11b7e:	dcf4      	bgt.n	11b6a <memcpy+0x176>
   11b80:	e77f      	b.n	11a82 <memcpy+0x8e>
   11b82:	bf00      	nop

00011b84 <memset>:
   11b84:	2a03      	cmp	r2, #3
   11b86:	b2c9      	uxtb	r1, r1
   11b88:	b430      	push	{r4, r5}
   11b8a:	d807      	bhi.n	11b9c <memset+0x18>
   11b8c:	b122      	cbz	r2, 11b98 <memset+0x14>
   11b8e:	2300      	movs	r3, #0
   11b90:	54c1      	strb	r1, [r0, r3]
   11b92:	3301      	adds	r3, #1
   11b94:	4293      	cmp	r3, r2
   11b96:	d1fb      	bne.n	11b90 <memset+0xc>
   11b98:	bc30      	pop	{r4, r5}
   11b9a:	4770      	bx	lr
   11b9c:	eb00 0c02 	add.w	ip, r0, r2
   11ba0:	4603      	mov	r3, r0
   11ba2:	e001      	b.n	11ba8 <memset+0x24>
   11ba4:	f803 1c01 	strb.w	r1, [r3, #-1]
   11ba8:	f003 0403 	and.w	r4, r3, #3
   11bac:	461a      	mov	r2, r3
   11bae:	3301      	adds	r3, #1
   11bb0:	2c00      	cmp	r4, #0
   11bb2:	d1f7      	bne.n	11ba4 <memset+0x20>
   11bb4:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
   11bb8:	ebc2 040c 	rsb	r4, r2, ip
   11bbc:	fb03 f301 	mul.w	r3, r3, r1
   11bc0:	e01f      	b.n	11c02 <memset+0x7e>
   11bc2:	f842 3c40 	str.w	r3, [r2, #-64]
   11bc6:	f842 3c3c 	str.w	r3, [r2, #-60]
   11bca:	f842 3c38 	str.w	r3, [r2, #-56]
   11bce:	f842 3c34 	str.w	r3, [r2, #-52]
   11bd2:	f842 3c30 	str.w	r3, [r2, #-48]
   11bd6:	f842 3c2c 	str.w	r3, [r2, #-44]
   11bda:	f842 3c28 	str.w	r3, [r2, #-40]
   11bde:	f842 3c24 	str.w	r3, [r2, #-36]
   11be2:	f842 3c20 	str.w	r3, [r2, #-32]
   11be6:	f842 3c1c 	str.w	r3, [r2, #-28]
   11bea:	f842 3c18 	str.w	r3, [r2, #-24]
   11bee:	f842 3c14 	str.w	r3, [r2, #-20]
   11bf2:	f842 3c10 	str.w	r3, [r2, #-16]
   11bf6:	f842 3c0c 	str.w	r3, [r2, #-12]
   11bfa:	f842 3c08 	str.w	r3, [r2, #-8]
   11bfe:	f842 3c04 	str.w	r3, [r2, #-4]
   11c02:	4615      	mov	r5, r2
   11c04:	3240      	adds	r2, #64	; 0x40
   11c06:	2c3f      	cmp	r4, #63	; 0x3f
   11c08:	f1a4 0440 	sub.w	r4, r4, #64	; 0x40
   11c0c:	dcd9      	bgt.n	11bc2 <memset+0x3e>
   11c0e:	462a      	mov	r2, r5
   11c10:	ebc5 040c 	rsb	r4, r5, ip
   11c14:	e007      	b.n	11c26 <memset+0xa2>
   11c16:	f842 3c10 	str.w	r3, [r2, #-16]
   11c1a:	f842 3c0c 	str.w	r3, [r2, #-12]
   11c1e:	f842 3c08 	str.w	r3, [r2, #-8]
   11c22:	f842 3c04 	str.w	r3, [r2, #-4]
   11c26:	4615      	mov	r5, r2
   11c28:	3210      	adds	r2, #16
   11c2a:	2c0f      	cmp	r4, #15
   11c2c:	f1a4 0410 	sub.w	r4, r4, #16
   11c30:	dcf1      	bgt.n	11c16 <memset+0x92>
   11c32:	462a      	mov	r2, r5
   11c34:	ebc5 050c 	rsb	r5, r5, ip
   11c38:	e001      	b.n	11c3e <memset+0xba>
   11c3a:	f842 3c04 	str.w	r3, [r2, #-4]
   11c3e:	4614      	mov	r4, r2
   11c40:	3204      	adds	r2, #4
   11c42:	2d03      	cmp	r5, #3
   11c44:	f1a5 0504 	sub.w	r5, r5, #4
   11c48:	dcf7      	bgt.n	11c3a <memset+0xb6>
   11c4a:	e001      	b.n	11c50 <memset+0xcc>
   11c4c:	f804 1b01 	strb.w	r1, [r4], #1
   11c50:	4564      	cmp	r4, ip
   11c52:	d3fb      	bcc.n	11c4c <memset+0xc8>
   11c54:	e7a0      	b.n	11b98 <memset+0x14>
   11c56:	bf00      	nop

00011c58 <_wrapup_reent>:
   11c58:	b570      	push	{r4, r5, r6, lr}
   11c5a:	4604      	mov	r4, r0
   11c5c:	b188      	cbz	r0, 11c82 <_wrapup_reent+0x2a>
   11c5e:	f104 0248 	add.w	r2, r4, #72	; 0x48
   11c62:	6853      	ldr	r3, [r2, #4]
   11c64:	1e5d      	subs	r5, r3, #1
   11c66:	d407      	bmi.n	11c78 <_wrapup_reent+0x20>
   11c68:	3302      	adds	r3, #2
   11c6a:	eb02 0683 	add.w	r6, r2, r3, lsl #2
   11c6e:	f856 3d04 	ldr.w	r3, [r6, #-4]!
   11c72:	4798      	blx	r3
   11c74:	3d01      	subs	r5, #1
   11c76:	d5fa      	bpl.n	11c6e <_wrapup_reent+0x16>
   11c78:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   11c7a:	b10b      	cbz	r3, 11c80 <_wrapup_reent+0x28>
   11c7c:	4620      	mov	r0, r4
   11c7e:	4798      	blx	r3
   11c80:	bd70      	pop	{r4, r5, r6, pc}
   11c82:	f240 03e4 	movw	r3, #228	; 0xe4
   11c86:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11c8a:	681c      	ldr	r4, [r3, #0]
   11c8c:	e7e7      	b.n	11c5e <_wrapup_reent+0x6>
   11c8e:	bf00      	nop

00011c90 <cleanup_glue>:
   11c90:	b570      	push	{r4, r5, r6, lr}
   11c92:	460c      	mov	r4, r1
   11c94:	6809      	ldr	r1, [r1, #0]
   11c96:	4605      	mov	r5, r0
   11c98:	b109      	cbz	r1, 11c9e <cleanup_glue+0xe>
   11c9a:	f7ff fff9 	bl	11c90 <cleanup_glue>
   11c9e:	4628      	mov	r0, r5
   11ca0:	4621      	mov	r1, r4
   11ca2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   11ca6:	f000 bdcb 	b.w	12840 <_free_r>
   11caa:	bf00      	nop

00011cac <_reclaim_reent>:
   11cac:	f240 03e4 	movw	r3, #228	; 0xe4
   11cb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11cb4:	b570      	push	{r4, r5, r6, lr}
   11cb6:	681b      	ldr	r3, [r3, #0]
   11cb8:	4605      	mov	r5, r0
   11cba:	4298      	cmp	r0, r3
   11cbc:	d046      	beq.n	11d4c <_reclaim_reent+0xa0>
   11cbe:	6a43      	ldr	r3, [r0, #36]	; 0x24
   11cc0:	4619      	mov	r1, r3
   11cc2:	b1bb      	cbz	r3, 11cf4 <_reclaim_reent+0x48>
   11cc4:	68da      	ldr	r2, [r3, #12]
   11cc6:	b1aa      	cbz	r2, 11cf4 <_reclaim_reent+0x48>
   11cc8:	2600      	movs	r6, #0
   11cca:	5991      	ldr	r1, [r2, r6]
   11ccc:	b141      	cbz	r1, 11ce0 <_reclaim_reent+0x34>
   11cce:	680c      	ldr	r4, [r1, #0]
   11cd0:	4628      	mov	r0, r5
   11cd2:	f000 fdb5 	bl	12840 <_free_r>
   11cd6:	4621      	mov	r1, r4
   11cd8:	2c00      	cmp	r4, #0
   11cda:	d1f8      	bne.n	11cce <_reclaim_reent+0x22>
   11cdc:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   11cde:	68da      	ldr	r2, [r3, #12]
   11ce0:	3604      	adds	r6, #4
   11ce2:	2e3c      	cmp	r6, #60	; 0x3c
   11ce4:	d001      	beq.n	11cea <_reclaim_reent+0x3e>
   11ce6:	68da      	ldr	r2, [r3, #12]
   11ce8:	e7ef      	b.n	11cca <_reclaim_reent+0x1e>
   11cea:	4611      	mov	r1, r2
   11cec:	4628      	mov	r0, r5
   11cee:	f000 fda7 	bl	12840 <_free_r>
   11cf2:	6a69      	ldr	r1, [r5, #36]	; 0x24
   11cf4:	6809      	ldr	r1, [r1, #0]
   11cf6:	b111      	cbz	r1, 11cfe <_reclaim_reent+0x52>
   11cf8:	4628      	mov	r0, r5
   11cfa:	f000 fda1 	bl	12840 <_free_r>
   11cfe:	6969      	ldr	r1, [r5, #20]
   11d00:	b111      	cbz	r1, 11d08 <_reclaim_reent+0x5c>
   11d02:	4628      	mov	r0, r5
   11d04:	f000 fd9c 	bl	12840 <_free_r>
   11d08:	6a69      	ldr	r1, [r5, #36]	; 0x24
   11d0a:	b111      	cbz	r1, 11d12 <_reclaim_reent+0x66>
   11d0c:	4628      	mov	r0, r5
   11d0e:	f000 fd97 	bl	12840 <_free_r>
   11d12:	6ba9      	ldr	r1, [r5, #56]	; 0x38
   11d14:	b111      	cbz	r1, 11d1c <_reclaim_reent+0x70>
   11d16:	4628      	mov	r0, r5
   11d18:	f000 fd92 	bl	12840 <_free_r>
   11d1c:	6be9      	ldr	r1, [r5, #60]	; 0x3c
   11d1e:	b111      	cbz	r1, 11d26 <_reclaim_reent+0x7a>
   11d20:	4628      	mov	r0, r5
   11d22:	f000 fd8d 	bl	12840 <_free_r>
   11d26:	6c29      	ldr	r1, [r5, #64]	; 0x40
   11d28:	b111      	cbz	r1, 11d30 <_reclaim_reent+0x84>
   11d2a:	4628      	mov	r0, r5
   11d2c:	f000 fd88 	bl	12840 <_free_r>
   11d30:	6cab      	ldr	r3, [r5, #72]	; 0x48
   11d32:	f8d3 1088 	ldr.w	r1, [r3, #136]	; 0x88
   11d36:	b111      	cbz	r1, 11d3e <_reclaim_reent+0x92>
   11d38:	4628      	mov	r0, r5
   11d3a:	f000 fd81 	bl	12840 <_free_r>
   11d3e:	6b69      	ldr	r1, [r5, #52]	; 0x34
   11d40:	b111      	cbz	r1, 11d48 <_reclaim_reent+0x9c>
   11d42:	4628      	mov	r0, r5
   11d44:	f000 fd7c 	bl	12840 <_free_r>
   11d48:	69ab      	ldr	r3, [r5, #24]
   11d4a:	b903      	cbnz	r3, 11d4e <_reclaim_reent+0xa2>
   11d4c:	bd70      	pop	{r4, r5, r6, pc}
   11d4e:	6aab      	ldr	r3, [r5, #40]	; 0x28
   11d50:	4628      	mov	r0, r5
   11d52:	4798      	blx	r3
   11d54:	f8d5 10d8 	ldr.w	r1, [r5, #216]	; 0xd8
   11d58:	2900      	cmp	r1, #0
   11d5a:	d0f7      	beq.n	11d4c <_reclaim_reent+0xa0>
   11d5c:	4628      	mov	r0, r5
   11d5e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   11d62:	e795      	b.n	11c90 <cleanup_glue>

00011d64 <_raise_r>:
   11d64:	291f      	cmp	r1, #31
   11d66:	b570      	push	{r4, r5, r6, lr}
   11d68:	460c      	mov	r4, r1
   11d6a:	4605      	mov	r5, r0
   11d6c:	d820      	bhi.n	11db0 <_raise_r+0x4c>
   11d6e:	6c42      	ldr	r2, [r0, #68]	; 0x44
   11d70:	b1a2      	cbz	r2, 11d9c <_raise_r+0x38>
   11d72:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   11d76:	b18b      	cbz	r3, 11d9c <_raise_r+0x38>
   11d78:	2b01      	cmp	r3, #1
   11d7a:	d00d      	beq.n	11d98 <_raise_r+0x34>
   11d7c:	f1b3 3fff 	cmp.w	r3, #4294967295
   11d80:	d006      	beq.n	11d90 <_raise_r+0x2c>
   11d82:	4608      	mov	r0, r1
   11d84:	2500      	movs	r5, #0
   11d86:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
   11d8a:	4798      	blx	r3
   11d8c:	4628      	mov	r0, r5
   11d8e:	bd70      	pop	{r4, r5, r6, pc}
   11d90:	2316      	movs	r3, #22
   11d92:	6003      	str	r3, [r0, #0]
   11d94:	2001      	movs	r0, #1
   11d96:	bd70      	pop	{r4, r5, r6, pc}
   11d98:	2000      	movs	r0, #0
   11d9a:	bd70      	pop	{r4, r5, r6, pc}
   11d9c:	4628      	mov	r0, r5
   11d9e:	f000 f887 	bl	11eb0 <_getpid_r>
   11da2:	4622      	mov	r2, r4
   11da4:	4601      	mov	r1, r0
   11da6:	4628      	mov	r0, r5
   11da8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   11dac:	f000 b882 	b.w	11eb4 <_kill_r>
   11db0:	2316      	movs	r3, #22
   11db2:	6003      	str	r3, [r0, #0]
   11db4:	f04f 30ff 	mov.w	r0, #4294967295
   11db8:	bd70      	pop	{r4, r5, r6, pc}
   11dba:	bf00      	nop

00011dbc <raise>:
   11dbc:	f240 03e4 	movw	r3, #228	; 0xe4
   11dc0:	4601      	mov	r1, r0
   11dc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11dc6:	6818      	ldr	r0, [r3, #0]
   11dc8:	e7cc      	b.n	11d64 <_raise_r>
   11dca:	bf00      	nop

00011dcc <_init_signal_r>:
   11dcc:	b538      	push	{r3, r4, r5, lr}
   11dce:	6c45      	ldr	r5, [r0, #68]	; 0x44
   11dd0:	4604      	mov	r4, r0
   11dd2:	b10d      	cbz	r5, 11dd8 <_init_signal_r+0xc>
   11dd4:	2000      	movs	r0, #0
   11dd6:	bd38      	pop	{r3, r4, r5, pc}
   11dd8:	2180      	movs	r1, #128	; 0x80
   11dda:	f000 fe11 	bl	12a00 <_malloc_r>
   11dde:	6460      	str	r0, [r4, #68]	; 0x44
   11de0:	b128      	cbz	r0, 11dee <_init_signal_r+0x22>
   11de2:	462b      	mov	r3, r5
   11de4:	5143      	str	r3, [r0, r5]
   11de6:	3504      	adds	r5, #4
   11de8:	2d80      	cmp	r5, #128	; 0x80
   11dea:	d1fb      	bne.n	11de4 <_init_signal_r+0x18>
   11dec:	e7f2      	b.n	11dd4 <_init_signal_r+0x8>
   11dee:	3801      	subs	r0, #1
   11df0:	bd38      	pop	{r3, r4, r5, pc}
   11df2:	bf00      	nop

00011df4 <_init_signal>:
   11df4:	f240 03e4 	movw	r3, #228	; 0xe4
   11df8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11dfc:	6818      	ldr	r0, [r3, #0]
   11dfe:	e7e5      	b.n	11dcc <_init_signal_r>

00011e00 <__sigtramp_r>:
   11e00:	291f      	cmp	r1, #31
   11e02:	b510      	push	{r4, lr}
   11e04:	4604      	mov	r4, r0
   11e06:	b082      	sub	sp, #8
   11e08:	d812      	bhi.n	11e30 <__sigtramp_r+0x30>
   11e0a:	6c42      	ldr	r2, [r0, #68]	; 0x44
   11e0c:	b1ca      	cbz	r2, 11e42 <__sigtramp_r+0x42>
   11e0e:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   11e12:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   11e16:	b183      	cbz	r3, 11e3a <__sigtramp_r+0x3a>
   11e18:	f1b3 3fff 	cmp.w	r3, #4294967295
   11e1c:	d00f      	beq.n	11e3e <__sigtramp_r+0x3e>
   11e1e:	2b01      	cmp	r3, #1
   11e20:	d009      	beq.n	11e36 <__sigtramp_r+0x36>
   11e22:	4608      	mov	r0, r1
   11e24:	2400      	movs	r4, #0
   11e26:	6014      	str	r4, [r2, #0]
   11e28:	4798      	blx	r3
   11e2a:	4620      	mov	r0, r4
   11e2c:	b002      	add	sp, #8
   11e2e:	bd10      	pop	{r4, pc}
   11e30:	f04f 30ff 	mov.w	r0, #4294967295
   11e34:	e7fa      	b.n	11e2c <__sigtramp_r+0x2c>
   11e36:	2003      	movs	r0, #3
   11e38:	e7f8      	b.n	11e2c <__sigtramp_r+0x2c>
   11e3a:	2001      	movs	r0, #1
   11e3c:	e7f6      	b.n	11e2c <__sigtramp_r+0x2c>
   11e3e:	2002      	movs	r0, #2
   11e40:	e7f4      	b.n	11e2c <__sigtramp_r+0x2c>
   11e42:	9101      	str	r1, [sp, #4]
   11e44:	f7ff ffc2 	bl	11dcc <_init_signal_r>
   11e48:	9901      	ldr	r1, [sp, #4]
   11e4a:	2800      	cmp	r0, #0
   11e4c:	d1f0      	bne.n	11e30 <__sigtramp_r+0x30>
   11e4e:	6c62      	ldr	r2, [r4, #68]	; 0x44
   11e50:	e7dd      	b.n	11e0e <__sigtramp_r+0xe>
   11e52:	bf00      	nop

00011e54 <__sigtramp>:
   11e54:	f240 03e4 	movw	r3, #228	; 0xe4
   11e58:	4601      	mov	r1, r0
   11e5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11e5e:	6818      	ldr	r0, [r3, #0]
   11e60:	e7ce      	b.n	11e00 <__sigtramp_r>
   11e62:	bf00      	nop

00011e64 <_signal_r>:
   11e64:	291f      	cmp	r1, #31
   11e66:	b510      	push	{r4, lr}
   11e68:	4604      	mov	r4, r0
   11e6a:	b082      	sub	sp, #8
   11e6c:	d807      	bhi.n	11e7e <_signal_r+0x1a>
   11e6e:	6c43      	ldr	r3, [r0, #68]	; 0x44
   11e70:	b153      	cbz	r3, 11e88 <_signal_r+0x24>
   11e72:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
   11e76:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
   11e7a:	b002      	add	sp, #8
   11e7c:	bd10      	pop	{r4, pc}
   11e7e:	2316      	movs	r3, #22
   11e80:	6003      	str	r3, [r0, #0]
   11e82:	f04f 30ff 	mov.w	r0, #4294967295
   11e86:	e7f8      	b.n	11e7a <_signal_r+0x16>
   11e88:	9101      	str	r1, [sp, #4]
   11e8a:	9200      	str	r2, [sp, #0]
   11e8c:	f7ff ff9e 	bl	11dcc <_init_signal_r>
   11e90:	9901      	ldr	r1, [sp, #4]
   11e92:	9a00      	ldr	r2, [sp, #0]
   11e94:	b908      	cbnz	r0, 11e9a <_signal_r+0x36>
   11e96:	6c63      	ldr	r3, [r4, #68]	; 0x44
   11e98:	e7eb      	b.n	11e72 <_signal_r+0xe>
   11e9a:	f04f 30ff 	mov.w	r0, #4294967295
   11e9e:	e7ec      	b.n	11e7a <_signal_r+0x16>

00011ea0 <signal>:
   11ea0:	f240 03e4 	movw	r3, #228	; 0xe4
   11ea4:	460a      	mov	r2, r1
   11ea6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11eaa:	4601      	mov	r1, r0
   11eac:	6818      	ldr	r0, [r3, #0]
   11eae:	e7d9      	b.n	11e64 <_signal_r>

00011eb0 <_getpid_r>:
   11eb0:	f7f5 bd82 	b.w	79b8 <_getpid>

00011eb4 <_kill_r>:
   11eb4:	b538      	push	{r3, r4, r5, lr}
   11eb6:	f64c 34e8 	movw	r4, #52200	; 0xcbe8
   11eba:	f2c2 0400 	movt	r4, #8192	; 0x2000
   11ebe:	4605      	mov	r5, r0
   11ec0:	4608      	mov	r0, r1
   11ec2:	4611      	mov	r1, r2
   11ec4:	2300      	movs	r3, #0
   11ec6:	6023      	str	r3, [r4, #0]
   11ec8:	f7f5 fd8a 	bl	79e0 <_kill>
   11ecc:	f1b0 3fff 	cmp.w	r0, #4294967295
   11ed0:	d000      	beq.n	11ed4 <_kill_r+0x20>
   11ed2:	bd38      	pop	{r3, r4, r5, pc}
   11ed4:	6823      	ldr	r3, [r4, #0]
   11ed6:	2b00      	cmp	r3, #0
   11ed8:	d0fb      	beq.n	11ed2 <_kill_r+0x1e>
   11eda:	602b      	str	r3, [r5, #0]
   11edc:	bd38      	pop	{r3, r4, r5, pc}
   11ede:	bf00      	nop

00011ee0 <strcat>:
   11ee0:	f010 0f03 	tst.w	r0, #3
   11ee4:	b510      	push	{r4, lr}
   11ee6:	4604      	mov	r4, r0
   11ee8:	bf18      	it	ne
   11eea:	4600      	movne	r0, r0
   11eec:	d111      	bne.n	11f12 <strcat+0x32>
   11eee:	6823      	ldr	r3, [r4, #0]
   11ef0:	4620      	mov	r0, r4
   11ef2:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   11ef6:	ea22 0303 	bic.w	r3, r2, r3
   11efa:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   11efe:	d108      	bne.n	11f12 <strcat+0x32>
   11f00:	f850 3f04 	ldr.w	r3, [r0, #4]!
   11f04:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   11f08:	ea22 0303 	bic.w	r3, r2, r3
   11f0c:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   11f10:	d0f6      	beq.n	11f00 <strcat+0x20>
   11f12:	7803      	ldrb	r3, [r0, #0]
   11f14:	b11b      	cbz	r3, 11f1e <strcat+0x3e>
   11f16:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   11f1a:	2b00      	cmp	r3, #0
   11f1c:	d1fb      	bne.n	11f16 <strcat+0x36>
   11f1e:	f000 f863 	bl	11fe8 <strcpy>
   11f22:	4620      	mov	r0, r4
   11f24:	bd10      	pop	{r4, pc}
   11f26:	bf00      	nop

00011f28 <strchr>:
   11f28:	b2c9      	uxtb	r1, r1
   11f2a:	b430      	push	{r4, r5}
   11f2c:	b119      	cbz	r1, 11f36 <strchr+0xe>
   11f2e:	e024      	b.n	11f7a <strchr+0x52>
   11f30:	7803      	ldrb	r3, [r0, #0]
   11f32:	b1d3      	cbz	r3, 11f6a <strchr+0x42>
   11f34:	3001      	adds	r0, #1
   11f36:	f010 0f03 	tst.w	r0, #3
   11f3a:	d1f9      	bne.n	11f30 <strchr+0x8>
   11f3c:	6803      	ldr	r3, [r0, #0]
   11f3e:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   11f42:	ea22 0303 	bic.w	r3, r2, r3
   11f46:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   11f4a:	d108      	bne.n	11f5e <strchr+0x36>
   11f4c:	f850 3f04 	ldr.w	r3, [r0, #4]!
   11f50:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   11f54:	ea22 0303 	bic.w	r3, r2, r3
   11f58:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   11f5c:	d0f6      	beq.n	11f4c <strchr+0x24>
   11f5e:	7803      	ldrb	r3, [r0, #0]
   11f60:	b11b      	cbz	r3, 11f6a <strchr+0x42>
   11f62:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   11f66:	2b00      	cmp	r3, #0
   11f68:	d1fb      	bne.n	11f62 <strchr+0x3a>
   11f6a:	bc30      	pop	{r4, r5}
   11f6c:	4770      	bx	lr
   11f6e:	7803      	ldrb	r3, [r0, #0]
   11f70:	2b00      	cmp	r3, #0
   11f72:	d036      	beq.n	11fe2 <strchr+0xba>
   11f74:	4299      	cmp	r1, r3
   11f76:	d0f8      	beq.n	11f6a <strchr+0x42>
   11f78:	3001      	adds	r0, #1
   11f7a:	f010 0f03 	tst.w	r0, #3
   11f7e:	d1f6      	bne.n	11f6e <strchr+0x46>
   11f80:	6803      	ldr	r3, [r0, #0]
   11f82:	ea41 2501 	orr.w	r5, r1, r1, lsl #8
   11f86:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   11f8a:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
   11f8e:	ea22 0203 	bic.w	r2, r2, r3
   11f92:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   11f96:	d11b      	bne.n	11fd0 <strchr+0xa8>
   11f98:	ea85 0303 	eor.w	r3, r5, r3
   11f9c:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   11fa0:	ea22 0303 	bic.w	r3, r2, r3
   11fa4:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   11fa8:	d003      	beq.n	11fb2 <strchr+0x8a>
   11faa:	e011      	b.n	11fd0 <strchr+0xa8>
   11fac:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   11fb0:	d10e      	bne.n	11fd0 <strchr+0xa8>
   11fb2:	f850 3f04 	ldr.w	r3, [r0, #4]!
   11fb6:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
   11fba:	ea85 0203 	eor.w	r2, r5, r3
   11fbe:	ea24 0303 	bic.w	r3, r4, r3
   11fc2:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
   11fc6:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   11fca:	ea2c 0202 	bic.w	r2, ip, r2
   11fce:	d0ed      	beq.n	11fac <strchr+0x84>
   11fd0:	7803      	ldrb	r3, [r0, #0]
   11fd2:	b91b      	cbnz	r3, 11fdc <strchr+0xb4>
   11fd4:	e005      	b.n	11fe2 <strchr+0xba>
   11fd6:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   11fda:	b113      	cbz	r3, 11fe2 <strchr+0xba>
   11fdc:	4299      	cmp	r1, r3
   11fde:	d1fa      	bne.n	11fd6 <strchr+0xae>
   11fe0:	e7c3      	b.n	11f6a <strchr+0x42>
   11fe2:	2000      	movs	r0, #0
   11fe4:	e7c1      	b.n	11f6a <strchr+0x42>
   11fe6:	bf00      	nop

00011fe8 <strcpy>:
   11fe8:	ea80 0201 	eor.w	r2, r0, r1
   11fec:	4684      	mov	ip, r0
   11fee:	f012 0f03 	tst.w	r2, #3
   11ff2:	d14f      	bne.n	12094 <strcpy+0xac>
   11ff4:	f011 0f03 	tst.w	r1, #3
   11ff8:	d132      	bne.n	12060 <strcpy+0x78>
   11ffa:	f84d 4d04 	str.w	r4, [sp, #-4]!
   11ffe:	f011 0f04 	tst.w	r1, #4
   12002:	f851 3b04 	ldr.w	r3, [r1], #4
   12006:	d00b      	beq.n	12020 <strcpy+0x38>
   12008:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   1200c:	439a      	bics	r2, r3
   1200e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   12012:	bf04      	itt	eq
   12014:	f84c 3b04 	streq.w	r3, [ip], #4
   12018:	f851 3b04 	ldreq.w	r3, [r1], #4
   1201c:	d116      	bne.n	1204c <strcpy+0x64>
   1201e:	bf00      	nop
   12020:	f851 4b04 	ldr.w	r4, [r1], #4
   12024:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   12028:	439a      	bics	r2, r3
   1202a:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   1202e:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
   12032:	d10b      	bne.n	1204c <strcpy+0x64>
   12034:	f84c 3b04 	str.w	r3, [ip], #4
   12038:	43a2      	bics	r2, r4
   1203a:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   1203e:	bf04      	itt	eq
   12040:	f851 3b04 	ldreq.w	r3, [r1], #4
   12044:	f84c 4b04 	streq.w	r4, [ip], #4
   12048:	d0ea      	beq.n	12020 <strcpy+0x38>
   1204a:	4623      	mov	r3, r4
   1204c:	f80c 3b01 	strb.w	r3, [ip], #1
   12050:	f013 0fff 	tst.w	r3, #255	; 0xff
   12054:	ea4f 2333 	mov.w	r3, r3, ror #8
   12058:	d1f8      	bne.n	1204c <strcpy+0x64>
   1205a:	f85d 4b04 	ldr.w	r4, [sp], #4
   1205e:	4770      	bx	lr
   12060:	f011 0f01 	tst.w	r1, #1
   12064:	d006      	beq.n	12074 <strcpy+0x8c>
   12066:	f811 2b01 	ldrb.w	r2, [r1], #1
   1206a:	f80c 2b01 	strb.w	r2, [ip], #1
   1206e:	2a00      	cmp	r2, #0
   12070:	bf08      	it	eq
   12072:	4770      	bxeq	lr
   12074:	f011 0f02 	tst.w	r1, #2
   12078:	d0bf      	beq.n	11ffa <strcpy+0x12>
   1207a:	f831 2b02 	ldrh.w	r2, [r1], #2
   1207e:	f012 0fff 	tst.w	r2, #255	; 0xff
   12082:	bf16      	itet	ne
   12084:	f82c 2b02 	strhne.w	r2, [ip], #2
   12088:	f88c 2000 	strbeq.w	r2, [ip]
   1208c:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
   12090:	d1b3      	bne.n	11ffa <strcpy+0x12>
   12092:	4770      	bx	lr
   12094:	f811 2b01 	ldrb.w	r2, [r1], #1
   12098:	f80c 2b01 	strb.w	r2, [ip], #1
   1209c:	2a00      	cmp	r2, #0
   1209e:	d1f9      	bne.n	12094 <strcpy+0xac>
   120a0:	4770      	bx	lr
   120a2:	bf00      	nop

000120a4 <strlen>:
   120a4:	f020 0103 	bic.w	r1, r0, #3
   120a8:	f010 0003 	ands.w	r0, r0, #3
   120ac:	f1c0 0000 	rsb	r0, r0, #0
   120b0:	f851 3b04 	ldr.w	r3, [r1], #4
   120b4:	f100 0c04 	add.w	ip, r0, #4
   120b8:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
   120bc:	f06f 0200 	mvn.w	r2, #0
   120c0:	bf1c      	itt	ne
   120c2:	fa22 f20c 	lsrne.w	r2, r2, ip
   120c6:	4313      	orrne	r3, r2
   120c8:	f04f 0c01 	mov.w	ip, #1
   120cc:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
   120d0:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
   120d4:	eba3 020c 	sub.w	r2, r3, ip
   120d8:	ea22 0203 	bic.w	r2, r2, r3
   120dc:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
   120e0:	bf04      	itt	eq
   120e2:	f851 3b04 	ldreq.w	r3, [r1], #4
   120e6:	3004      	addeq	r0, #4
   120e8:	d0f4      	beq.n	120d4 <strlen+0x30>
   120ea:	f013 0fff 	tst.w	r3, #255	; 0xff
   120ee:	bf1f      	itttt	ne
   120f0:	3001      	addne	r0, #1
   120f2:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
   120f6:	3001      	addne	r0, #1
   120f8:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
   120fc:	bf18      	it	ne
   120fe:	3001      	addne	r0, #1
   12100:	4770      	bx	lr
   12102:	bf00      	nop

00012104 <strncmp>:
   12104:	b430      	push	{r4, r5}
   12106:	4613      	mov	r3, r2
   12108:	2a00      	cmp	r2, #0
   1210a:	d043      	beq.n	12194 <strncmp+0x90>
   1210c:	ea41 0200 	orr.w	r2, r1, r0
   12110:	f012 0f03 	tst.w	r2, #3
   12114:	d125      	bne.n	12162 <strncmp+0x5e>
   12116:	2b03      	cmp	r3, #3
   12118:	4604      	mov	r4, r0
   1211a:	460d      	mov	r5, r1
   1211c:	d93d      	bls.n	1219a <strncmp+0x96>
   1211e:	6802      	ldr	r2, [r0, #0]
   12120:	6809      	ldr	r1, [r1, #0]
   12122:	428a      	cmp	r2, r1
   12124:	d139      	bne.n	1219a <strncmp+0x96>
   12126:	3b04      	subs	r3, #4
   12128:	d034      	beq.n	12194 <strncmp+0x90>
   1212a:	f1a2 3101 	sub.w	r1, r2, #16843009	; 0x1010101
   1212e:	ea21 0202 	bic.w	r2, r1, r2
   12132:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   12136:	d00d      	beq.n	12154 <strncmp+0x50>
   12138:	e02c      	b.n	12194 <strncmp+0x90>
   1213a:	6822      	ldr	r2, [r4, #0]
   1213c:	6829      	ldr	r1, [r5, #0]
   1213e:	f1a2 3001 	sub.w	r0, r2, #16843009	; 0x1010101
   12142:	428a      	cmp	r2, r1
   12144:	ea20 0002 	bic.w	r0, r0, r2
   12148:	d127      	bne.n	1219a <strncmp+0x96>
   1214a:	3b04      	subs	r3, #4
   1214c:	d022      	beq.n	12194 <strncmp+0x90>
   1214e:	f010 3f80 	tst.w	r0, #2155905152	; 0x80808080
   12152:	d11f      	bne.n	12194 <strncmp+0x90>
   12154:	3404      	adds	r4, #4
   12156:	3504      	adds	r5, #4
   12158:	2b03      	cmp	r3, #3
   1215a:	d8ee      	bhi.n	1213a <strncmp+0x36>
   1215c:	4620      	mov	r0, r4
   1215e:	4629      	mov	r1, r5
   12160:	b1f3      	cbz	r3, 121a0 <strncmp+0x9c>
   12162:	7804      	ldrb	r4, [r0, #0]
   12164:	3b01      	subs	r3, #1
   12166:	f891 c000 	ldrb.w	ip, [r1]
   1216a:	4564      	cmp	r4, ip
   1216c:	d10f      	bne.n	1218e <strncmp+0x8a>
   1216e:	b18b      	cbz	r3, 12194 <strncmp+0x90>
   12170:	b184      	cbz	r4, 12194 <strncmp+0x90>
   12172:	3b01      	subs	r3, #1
   12174:	2200      	movs	r2, #0
   12176:	e002      	b.n	1217e <strncmp+0x7a>
   12178:	b163      	cbz	r3, 12194 <strncmp+0x90>
   1217a:	b15c      	cbz	r4, 12194 <strncmp+0x90>
   1217c:	3b01      	subs	r3, #1
   1217e:	1884      	adds	r4, r0, r2
   12180:	188d      	adds	r5, r1, r2
   12182:	3201      	adds	r2, #1
   12184:	7864      	ldrb	r4, [r4, #1]
   12186:	f895 c001 	ldrb.w	ip, [r5, #1]
   1218a:	4564      	cmp	r4, ip
   1218c:	d0f4      	beq.n	12178 <strncmp+0x74>
   1218e:	ebcc 0004 	rsb	r0, ip, r4
   12192:	e000      	b.n	12196 <strncmp+0x92>
   12194:	2000      	movs	r0, #0
   12196:	bc30      	pop	{r4, r5}
   12198:	4770      	bx	lr
   1219a:	4620      	mov	r0, r4
   1219c:	4629      	mov	r1, r5
   1219e:	e7e0      	b.n	12162 <strncmp+0x5e>
   121a0:	7824      	ldrb	r4, [r4, #0]
   121a2:	f895 c000 	ldrb.w	ip, [r5]
   121a6:	ebcc 0004 	rsb	r0, ip, r4
   121aa:	e7f4      	b.n	12196 <strncmp+0x92>

000121ac <strncpy>:
   121ac:	ea41 0300 	orr.w	r3, r1, r0
   121b0:	f013 0f03 	tst.w	r3, #3
   121b4:	bf14      	ite	ne
   121b6:	2300      	movne	r3, #0
   121b8:	2301      	moveq	r3, #1
   121ba:	2a03      	cmp	r2, #3
   121bc:	bf94      	ite	ls
   121be:	2300      	movls	r3, #0
   121c0:	f003 0301 	andhi.w	r3, r3, #1
   121c4:	b430      	push	{r4, r5}
   121c6:	2b00      	cmp	r3, #0
   121c8:	d02a      	beq.n	12220 <strncpy+0x74>
   121ca:	4604      	mov	r4, r0
   121cc:	680b      	ldr	r3, [r1, #0]
   121ce:	f1a3 3c01 	sub.w	ip, r3, #16843009	; 0x1010101
   121d2:	ea2c 0c03 	bic.w	ip, ip, r3
   121d6:	f01c 3f80 	tst.w	ip, #2155905152	; 0x80808080
   121da:	d105      	bne.n	121e8 <strncpy+0x3c>
   121dc:	3a04      	subs	r2, #4
   121de:	3104      	adds	r1, #4
   121e0:	2a03      	cmp	r2, #3
   121e2:	f844 3b04 	str.w	r3, [r4], #4
   121e6:	d8f1      	bhi.n	121cc <strncpy+0x20>
   121e8:	4623      	mov	r3, r4
   121ea:	b1ba      	cbz	r2, 1221c <strncpy+0x70>
   121ec:	780d      	ldrb	r5, [r1, #0]
   121ee:	461c      	mov	r4, r3
   121f0:	3a01      	subs	r2, #1
   121f2:	f804 5b01 	strb.w	r5, [r4], #1
   121f6:	b155      	cbz	r5, 1220e <strncpy+0x62>
   121f8:	3302      	adds	r3, #2
   121fa:	b17a      	cbz	r2, 1221c <strncpy+0x70>
   121fc:	f811 5f01 	ldrb.w	r5, [r1, #1]!
   12200:	461c      	mov	r4, r3
   12202:	3a01      	subs	r2, #1
   12204:	f803 5c01 	strb.w	r5, [r3, #-1]
   12208:	3301      	adds	r3, #1
   1220a:	2d00      	cmp	r5, #0
   1220c:	d1f5      	bne.n	121fa <strncpy+0x4e>
   1220e:	b12a      	cbz	r2, 1221c <strncpy+0x70>
   12210:	2300      	movs	r3, #0
   12212:	4619      	mov	r1, r3
   12214:	54e1      	strb	r1, [r4, r3]
   12216:	3301      	adds	r3, #1
   12218:	4293      	cmp	r3, r2
   1221a:	d1fb      	bne.n	12214 <strncpy+0x68>
   1221c:	bc30      	pop	{r4, r5}
   1221e:	4770      	bx	lr
   12220:	4603      	mov	r3, r0
   12222:	e7e2      	b.n	121ea <strncpy+0x3e>

00012224 <strrchr>:
   12224:	b570      	push	{r4, r5, r6, lr}
   12226:	4603      	mov	r3, r0
   12228:	460c      	mov	r4, r1
   1222a:	b161      	cbz	r1, 12246 <strrchr+0x22>
   1222c:	2500      	movs	r5, #0
   1222e:	e000      	b.n	12232 <strrchr+0xe>
   12230:	4615      	mov	r5, r2
   12232:	4618      	mov	r0, r3
   12234:	4621      	mov	r1, r4
   12236:	f7ff fe77 	bl	11f28 <strchr>
   1223a:	4602      	mov	r2, r0
   1223c:	1c43      	adds	r3, r0, #1
   1223e:	2800      	cmp	r0, #0
   12240:	d1f6      	bne.n	12230 <strrchr+0xc>
   12242:	4628      	mov	r0, r5
   12244:	bd70      	pop	{r4, r5, r6, pc}
   12246:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   1224a:	f7ff be6d 	b.w	11f28 <strchr>
   1224e:	bf00      	nop

00012250 <critical_factorization>:
   12250:	2301      	movs	r3, #1
   12252:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
   12256:	461c      	mov	r4, r3
   12258:	2500      	movs	r5, #0
   1225a:	f04f 36ff 	mov.w	r6, #4294967295
   1225e:	eb04 0c05 	add.w	ip, r4, r5
   12262:	19a7      	adds	r7, r4, r6
   12264:	458c      	cmp	ip, r1
   12266:	d20d      	bcs.n	12284 <critical_factorization+0x34>
   12268:	5c3f      	ldrb	r7, [r7, r0]
   1226a:	f810 800c 	ldrb.w	r8, [r0, ip]
   1226e:	45b8      	cmp	r8, r7
   12270:	d22f      	bcs.n	122d2 <critical_factorization+0x82>
   12272:	ebc6 030c 	rsb	r3, r6, ip
   12276:	2401      	movs	r4, #1
   12278:	4665      	mov	r5, ip
   1227a:	eb04 0c05 	add.w	ip, r4, r5
   1227e:	19a7      	adds	r7, r4, r6
   12280:	458c      	cmp	ip, r1
   12282:	d3f1      	bcc.n	12268 <critical_factorization+0x18>
   12284:	f04f 0a01 	mov.w	sl, #1
   12288:	2500      	movs	r5, #0
   1228a:	4654      	mov	r4, sl
   1228c:	f04f 37ff 	mov.w	r7, #4294967295
   12290:	eb04 0c05 	add.w	ip, r4, r5
   12294:	6013      	str	r3, [r2, #0]
   12296:	4561      	cmp	r1, ip
   12298:	eb04 0807 	add.w	r8, r4, r7
   1229c:	d90f      	bls.n	122be <critical_factorization+0x6e>
   1229e:	f818 8000 	ldrb.w	r8, [r8, r0]
   122a2:	f810 900c 	ldrb.w	r9, [r0, ip]
   122a6:	45c1      	cmp	r9, r8
   122a8:	d924      	bls.n	122f4 <critical_factorization+0xa4>
   122aa:	ebc7 0a0c 	rsb	sl, r7, ip
   122ae:	2401      	movs	r4, #1
   122b0:	4665      	mov	r5, ip
   122b2:	eb04 0c05 	add.w	ip, r4, r5
   122b6:	eb04 0807 	add.w	r8, r4, r7
   122ba:	4561      	cmp	r1, ip
   122bc:	d8ef      	bhi.n	1229e <critical_factorization+0x4e>
   122be:	3701      	adds	r7, #1
   122c0:	1c70      	adds	r0, r6, #1
   122c2:	4287      	cmp	r7, r0
   122c4:	bf24      	itt	cs
   122c6:	4653      	movcs	r3, sl
   122c8:	4638      	movcs	r0, r7
   122ca:	6013      	str	r3, [r2, #0]
   122cc:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
   122d0:	4770      	bx	lr
   122d2:	d006      	beq.n	122e2 <critical_factorization+0x92>
   122d4:	2301      	movs	r3, #1
   122d6:	462e      	mov	r6, r5
   122d8:	eb05 0c03 	add.w	ip, r5, r3
   122dc:	461c      	mov	r4, r3
   122de:	4665      	mov	r5, ip
   122e0:	e7cb      	b.n	1227a <critical_factorization+0x2a>
   122e2:	429c      	cmp	r4, r3
   122e4:	f104 0401 	add.w	r4, r4, #1
   122e8:	bf18      	it	ne
   122ea:	46ac      	movne	ip, r5
   122ec:	d1c4      	bne.n	12278 <critical_factorization+0x28>
   122ee:	2401      	movs	r4, #1
   122f0:	4665      	mov	r5, ip
   122f2:	e7c2      	b.n	1227a <critical_factorization+0x2a>
   122f4:	d007      	beq.n	12306 <critical_factorization+0xb6>
   122f6:	f04f 0a01 	mov.w	sl, #1
   122fa:	462f      	mov	r7, r5
   122fc:	eb05 0c0a 	add.w	ip, r5, sl
   12300:	4654      	mov	r4, sl
   12302:	4665      	mov	r5, ip
   12304:	e7d5      	b.n	122b2 <critical_factorization+0x62>
   12306:	4554      	cmp	r4, sl
   12308:	f104 0401 	add.w	r4, r4, #1
   1230c:	bf18      	it	ne
   1230e:	46ac      	movne	ip, r5
   12310:	d1ce      	bne.n	122b0 <critical_factorization+0x60>
   12312:	2401      	movs	r4, #1
   12314:	4665      	mov	r5, ip
   12316:	e7cc      	b.n	122b2 <critical_factorization+0x62>

00012318 <two_way_long_needle>:
   12318:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1231c:	f5ad 6d84 	sub.w	sp, sp, #1056	; 0x420
   12320:	b081      	sub	sp, #4
   12322:	4606      	mov	r6, r0
   12324:	4610      	mov	r0, r2
   12326:	4689      	mov	r9, r1
   12328:	9203      	str	r2, [sp, #12]
   1232a:	f50d 6282 	add.w	r2, sp, #1040	; 0x410
   1232e:	4619      	mov	r1, r3
   12330:	320c      	adds	r2, #12
   12332:	461c      	mov	r4, r3
   12334:	f7ff ff8c 	bl	12250 <critical_factorization>
   12338:	2300      	movs	r3, #0
   1233a:	aa07      	add	r2, sp, #28
   1233c:	4680      	mov	r8, r0
   1233e:	50d4      	str	r4, [r2, r3]
   12340:	3304      	adds	r3, #4
   12342:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
   12346:	d1fa      	bne.n	1233e <two_way_long_needle+0x26>
   12348:	b164      	cbz	r4, 12364 <two_way_long_needle+0x4c>
   1234a:	f8dd c00c 	ldr.w	ip, [sp, #12]
   1234e:	1e62      	subs	r2, r4, #1
   12350:	2300      	movs	r3, #0
   12352:	a807      	add	r0, sp, #28
   12354:	f81c 1003 	ldrb.w	r1, [ip, r3]
   12358:	3301      	adds	r3, #1
   1235a:	f840 2021 	str.w	r2, [r0, r1, lsl #2]
   1235e:	3a01      	subs	r2, #1
   12360:	429c      	cmp	r4, r3
   12362:	d8f7      	bhi.n	12354 <two_way_long_needle+0x3c>
   12364:	9803      	ldr	r0, [sp, #12]
   12366:	4642      	mov	r2, r8
   12368:	f8dd 141c 	ldr.w	r1, [sp, #1052]	; 0x41c
   1236c:	1841      	adds	r1, r0, r1
   1236e:	f000 fe53 	bl	13018 <memcmp>
   12372:	4605      	mov	r5, r0
   12374:	2800      	cmp	r0, #0
   12376:	f040 808b 	bne.w	12490 <two_way_long_needle+0x178>
   1237a:	9402      	str	r4, [sp, #8]
   1237c:	4682      	mov	sl, r0
   1237e:	9b02      	ldr	r3, [sp, #8]
   12380:	f1c8 0201 	rsb	r2, r8, #1
   12384:	9903      	ldr	r1, [sp, #12]
   12386:	1e67      	subs	r7, r4, #1
   12388:	9205      	str	r2, [sp, #20]
   1238a:	eb0a 0403 	add.w	r4, sl, r3
   1238e:	464a      	mov	r2, r9
   12390:	f108 30ff 	add.w	r0, r8, #4294967295
   12394:	4441      	add	r1, r8
   12396:	9001      	str	r0, [sp, #4]
   12398:	9104      	str	r1, [sp, #16]
   1239a:	18b0      	adds	r0, r6, r2
   1239c:	2100      	movs	r1, #0
   1239e:	1aa2      	subs	r2, r4, r2
   123a0:	f8dd b00c 	ldr.w	fp, [sp, #12]
   123a4:	f000 fdfe 	bl	12fa4 <memchr>
   123a8:	4603      	mov	r3, r0
   123aa:	2800      	cmp	r0, #0
   123ac:	d159      	bne.n	12462 <two_way_long_needle+0x14a>
   123ae:	2c00      	cmp	r4, #0
   123b0:	d057      	beq.n	12462 <two_way_long_needle+0x14a>
   123b2:	19a2      	adds	r2, r4, r6
   123b4:	a807      	add	r0, sp, #28
   123b6:	f812 2c01 	ldrb.w	r2, [r2, #-1]
   123ba:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
   123be:	2a00      	cmp	r2, #0
   123c0:	d15b      	bne.n	1247a <two_way_long_needle+0x162>
   123c2:	4545      	cmp	r5, r8
   123c4:	bf2c      	ite	cs
   123c6:	462b      	movcs	r3, r5
   123c8:	4643      	movcc	r3, r8
   123ca:	42bb      	cmp	r3, r7
   123cc:	d213      	bcs.n	123f6 <two_way_long_needle+0xde>
   123ce:	eb03 000a 	add.w	r0, r3, sl
   123d2:	f81b c003 	ldrb.w	ip, [fp, r3]
   123d6:	1832      	adds	r2, r6, r0
   123d8:	eb0b 0103 	add.w	r1, fp, r3
   123dc:	5c30      	ldrb	r0, [r6, r0]
   123de:	4584      	cmp	ip, r0
   123e0:	d006      	beq.n	123f0 <two_way_long_needle+0xd8>
   123e2:	e044      	b.n	1246e <two_way_long_needle+0x156>
   123e4:	f811 cf01 	ldrb.w	ip, [r1, #1]!
   123e8:	f812 0f01 	ldrb.w	r0, [r2, #1]!
   123ec:	4584      	cmp	ip, r0
   123ee:	d13e      	bne.n	1246e <two_way_long_needle+0x156>
   123f0:	3301      	adds	r3, #1
   123f2:	42bb      	cmp	r3, r7
   123f4:	d3f6      	bcc.n	123e4 <two_way_long_needle+0xcc>
   123f6:	4545      	cmp	r5, r8
   123f8:	f080 80b0 	bcs.w	1255c <two_way_long_needle+0x244>
   123fc:	9901      	ldr	r1, [sp, #4]
   123fe:	9b01      	ldr	r3, [sp, #4]
   12400:	eb01 020a 	add.w	r2, r1, sl
   12404:	f81b 1001 	ldrb.w	r1, [fp, r1]
   12408:	5d92      	ldrb	r2, [r2, r6]
   1240a:	4291      	cmp	r1, r2
   1240c:	f040 80a6 	bne.w	1255c <two_way_long_needle+0x244>
   12410:	eb0a 0208 	add.w	r2, sl, r8
   12414:	9904      	ldr	r1, [sp, #16]
   12416:	18b2      	adds	r2, r6, r2
   12418:	46a1      	mov	r9, r4
   1241a:	e008      	b.n	1242e <two_way_long_needle+0x116>
   1241c:	f811 4c02 	ldrb.w	r4, [r1, #-2]
   12420:	3901      	subs	r1, #1
   12422:	f812 cc02 	ldrb.w	ip, [r2, #-2]
   12426:	3a01      	subs	r2, #1
   12428:	4564      	cmp	r4, ip
   1242a:	d104      	bne.n	12436 <two_way_long_needle+0x11e>
   1242c:	4603      	mov	r3, r0
   1242e:	429d      	cmp	r5, r3
   12430:	f103 30ff 	add.w	r0, r3, #4294967295
   12434:	d3f2      	bcc.n	1241c <two_way_long_needle+0x104>
   12436:	3501      	adds	r5, #1
   12438:	464c      	mov	r4, r9
   1243a:	429d      	cmp	r5, r3
   1243c:	f200 8093 	bhi.w	12566 <two_way_long_needle+0x24e>
   12440:	f8dd 541c 	ldr.w	r5, [sp, #1052]	; 0x41c
   12444:	9a02      	ldr	r2, [sp, #8]
   12446:	44aa      	add	sl, r5
   12448:	1b55      	subs	r5, r2, r5
   1244a:	4622      	mov	r2, r4
   1244c:	9b02      	ldr	r3, [sp, #8]
   1244e:	18b0      	adds	r0, r6, r2
   12450:	2100      	movs	r1, #0
   12452:	eb0a 0403 	add.w	r4, sl, r3
   12456:	1aa2      	subs	r2, r4, r2
   12458:	f000 fda4 	bl	12fa4 <memchr>
   1245c:	4603      	mov	r3, r0
   1245e:	2800      	cmp	r0, #0
   12460:	d0a5      	beq.n	123ae <two_way_long_needle+0x96>
   12462:	2000      	movs	r0, #0
   12464:	b009      	add	sp, #36	; 0x24
   12466:	f50d 6d80 	add.w	sp, sp, #1024	; 0x400
   1246a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1246e:	9905      	ldr	r1, [sp, #20]
   12470:	2500      	movs	r5, #0
   12472:	4622      	mov	r2, r4
   12474:	448a      	add	sl, r1
   12476:	449a      	add	sl, r3
   12478:	e7e8      	b.n	1244c <two_way_long_needle+0x134>
   1247a:	b135      	cbz	r5, 1248a <two_way_long_needle+0x172>
   1247c:	f8dd 141c 	ldr.w	r1, [sp, #1052]	; 0x41c
   12480:	428a      	cmp	r2, r1
   12482:	d202      	bcs.n	1248a <two_way_long_needle+0x172>
   12484:	9802      	ldr	r0, [sp, #8]
   12486:	461d      	mov	r5, r3
   12488:	1a42      	subs	r2, r0, r1
   1248a:	4492      	add	sl, r2
   1248c:	4622      	mov	r2, r4
   1248e:	e7dd      	b.n	1244c <two_way_long_needle+0x134>
   12490:	9803      	ldr	r0, [sp, #12]
   12492:	ebc8 0304 	rsb	r3, r8, r4
   12496:	464a      	mov	r2, r9
   12498:	2700      	movs	r7, #0
   1249a:	1e65      	subs	r5, r4, #1
   1249c:	f108 3aff 	add.w	sl, r8, #4294967295
   124a0:	eb00 0b08 	add.w	fp, r0, r8
   124a4:	46a1      	mov	r9, r4
   124a6:	4543      	cmp	r3, r8
   124a8:	bf38      	it	cc
   124aa:	4643      	movcc	r3, r8
   124ac:	f1c8 0101 	rsb	r1, r8, #1
   124b0:	3301      	adds	r3, #1
   124b2:	9101      	str	r1, [sp, #4]
   124b4:	f8cd 341c 	str.w	r3, [sp, #1052]	; 0x41c
   124b8:	eb07 0409 	add.w	r4, r7, r9
   124bc:	18b0      	adds	r0, r6, r2
   124be:	2100      	movs	r1, #0
   124c0:	1aa2      	subs	r2, r4, r2
   124c2:	f000 fd6f 	bl	12fa4 <memchr>
   124c6:	2800      	cmp	r0, #0
   124c8:	d1cb      	bne.n	12462 <two_way_long_needle+0x14a>
   124ca:	2c00      	cmp	r4, #0
   124cc:	d0c9      	beq.n	12462 <two_way_long_needle+0x14a>
   124ce:	19a3      	adds	r3, r4, r6
   124d0:	aa07      	add	r2, sp, #28
   124d2:	f813 3c01 	ldrb.w	r3, [r3, #-1]
   124d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   124da:	2b00      	cmp	r3, #0
   124dc:	d135      	bne.n	1254a <two_way_long_needle+0x232>
   124de:	45a8      	cmp	r8, r5
   124e0:	d214      	bcs.n	1250c <two_way_long_needle+0x1f4>
   124e2:	eb07 0308 	add.w	r3, r7, r8
   124e6:	f89b 2000 	ldrb.w	r2, [fp]
   124ea:	18f1      	adds	r1, r6, r3
   124ec:	5cf3      	ldrb	r3, [r6, r3]
   124ee:	429a      	cmp	r2, r3
   124f0:	bf04      	itt	eq
   124f2:	465a      	moveq	r2, fp
   124f4:	4643      	moveq	r3, r8
   124f6:	d006      	beq.n	12506 <two_way_long_needle+0x1ee>
   124f8:	e02a      	b.n	12550 <two_way_long_needle+0x238>
   124fa:	f812 cf01 	ldrb.w	ip, [r2, #1]!
   124fe:	f811 0f01 	ldrb.w	r0, [r1, #1]!
   12502:	4584      	cmp	ip, r0
   12504:	d125      	bne.n	12552 <two_way_long_needle+0x23a>
   12506:	3301      	adds	r3, #1
   12508:	42ab      	cmp	r3, r5
   1250a:	d3f6      	bcc.n	124fa <two_way_long_needle+0x1e2>
   1250c:	f1ba 3fff 	cmp.w	sl, #4294967295
   12510:	4653      	mov	r3, sl
   12512:	d016      	beq.n	12542 <two_way_long_needle+0x22a>
   12514:	9803      	ldr	r0, [sp, #12]
   12516:	eb0a 0207 	add.w	r2, sl, r7
   1251a:	5d92      	ldrb	r2, [r2, r6]
   1251c:	f810 100a 	ldrb.w	r1, [r0, sl]
   12520:	4291      	cmp	r1, r2
   12522:	d110      	bne.n	12546 <two_way_long_needle+0x22e>
   12524:	eb07 0208 	add.w	r2, r7, r8
   12528:	4659      	mov	r1, fp
   1252a:	18b2      	adds	r2, r6, r2
   1252c:	e007      	b.n	1253e <two_way_long_needle+0x226>
   1252e:	f811 cc02 	ldrb.w	ip, [r1, #-2]
   12532:	3901      	subs	r1, #1
   12534:	f812 0c02 	ldrb.w	r0, [r2, #-2]
   12538:	3a01      	subs	r2, #1
   1253a:	4584      	cmp	ip, r0
   1253c:	d103      	bne.n	12546 <two_way_long_needle+0x22e>
   1253e:	3b01      	subs	r3, #1
   12540:	d2f5      	bcs.n	1252e <two_way_long_needle+0x216>
   12542:	19f0      	adds	r0, r6, r7
   12544:	e78e      	b.n	12464 <two_way_long_needle+0x14c>
   12546:	f8dd 341c 	ldr.w	r3, [sp, #1052]	; 0x41c
   1254a:	18ff      	adds	r7, r7, r3
   1254c:	4622      	mov	r2, r4
   1254e:	e7b3      	b.n	124b8 <two_way_long_needle+0x1a0>
   12550:	4643      	mov	r3, r8
   12552:	9a01      	ldr	r2, [sp, #4]
   12554:	19d7      	adds	r7, r2, r7
   12556:	4622      	mov	r2, r4
   12558:	18ff      	adds	r7, r7, r3
   1255a:	e7ad      	b.n	124b8 <two_way_long_needle+0x1a0>
   1255c:	4643      	mov	r3, r8
   1255e:	3501      	adds	r5, #1
   12560:	429d      	cmp	r5, r3
   12562:	f67f af6d 	bls.w	12440 <two_way_long_needle+0x128>
   12566:	eb06 000a 	add.w	r0, r6, sl
   1256a:	e77b      	b.n	12464 <two_way_long_needle+0x14c>

0001256c <strstr>:
   1256c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12570:	7803      	ldrb	r3, [r0, #0]
   12572:	b087      	sub	sp, #28
   12574:	4606      	mov	r6, r0
   12576:	460d      	mov	r5, r1
   12578:	2b00      	cmp	r3, #0
   1257a:	f000 8104 	beq.w	12786 <strstr+0x21a>
   1257e:	780a      	ldrb	r2, [r1, #0]
   12580:	b192      	cbz	r2, 125a8 <strstr+0x3c>
   12582:	4601      	mov	r1, r0
   12584:	462c      	mov	r4, r5
   12586:	2001      	movs	r0, #1
   12588:	e001      	b.n	1258e <strstr+0x22>
   1258a:	7822      	ldrb	r2, [r4, #0]
   1258c:	b182      	cbz	r2, 125b0 <strstr+0x44>
   1258e:	4293      	cmp	r3, r2
   12590:	bf14      	ite	ne
   12592:	2000      	movne	r0, #0
   12594:	f000 0001 	andeq.w	r0, r0, #1
   12598:	784b      	ldrb	r3, [r1, #1]
   1259a:	3401      	adds	r4, #1
   1259c:	3101      	adds	r1, #1
   1259e:	2b00      	cmp	r3, #0
   125a0:	d1f3      	bne.n	1258a <strstr+0x1e>
   125a2:	7823      	ldrb	r3, [r4, #0]
   125a4:	b123      	cbz	r3, 125b0 <strstr+0x44>
   125a6:	2600      	movs	r6, #0
   125a8:	4630      	mov	r0, r6
   125aa:	b007      	add	sp, #28
   125ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   125b0:	2800      	cmp	r0, #0
   125b2:	d1f9      	bne.n	125a8 <strstr+0x3c>
   125b4:	1c70      	adds	r0, r6, #1
   125b6:	7829      	ldrb	r1, [r5, #0]
   125b8:	f7ff fcb6 	bl	11f28 <strchr>
   125bc:	1b64      	subs	r4, r4, r5
   125be:	2c01      	cmp	r4, #1
   125c0:	bf14      	ite	ne
   125c2:	2300      	movne	r3, #0
   125c4:	2301      	moveq	r3, #1
   125c6:	2800      	cmp	r0, #0
   125c8:	bf08      	it	eq
   125ca:	f043 0301 	orreq.w	r3, r3, #1
   125ce:	4607      	mov	r7, r0
   125d0:	b97b      	cbnz	r3, 125f2 <strstr+0x86>
   125d2:	1936      	adds	r6, r6, r4
   125d4:	42b0      	cmp	r0, r6
   125d6:	bf8c      	ite	hi
   125d8:	f04f 0a01 	movhi.w	sl, #1
   125dc:	ebc0 0a06 	rsbls	sl, r0, r6
   125e0:	2c1f      	cmp	r4, #31
   125e2:	d908      	bls.n	125f6 <strstr+0x8a>
   125e4:	4651      	mov	r1, sl
   125e6:	462a      	mov	r2, r5
   125e8:	4623      	mov	r3, r4
   125ea:	f7ff fe95 	bl	12318 <two_way_long_needle>
   125ee:	4606      	mov	r6, r0
   125f0:	e7da      	b.n	125a8 <strstr+0x3c>
   125f2:	4606      	mov	r6, r0
   125f4:	e7d8      	b.n	125a8 <strstr+0x3c>
   125f6:	4621      	mov	r1, r4
   125f8:	aa05      	add	r2, sp, #20
   125fa:	4628      	mov	r0, r5
   125fc:	f7ff fe28 	bl	12250 <critical_factorization>
   12600:	9905      	ldr	r1, [sp, #20]
   12602:	1869      	adds	r1, r5, r1
   12604:	4680      	mov	r8, r0
   12606:	4628      	mov	r0, r5
   12608:	4642      	mov	r2, r8
   1260a:	f000 fd05 	bl	13018 <memcmp>
   1260e:	4606      	mov	r6, r0
   12610:	2800      	cmp	r0, #0
   12612:	d158      	bne.n	126c6 <strstr+0x15a>
   12614:	f108 32ff 	add.w	r2, r8, #4294967295
   12618:	eb05 0308 	add.w	r3, r5, r8
   1261c:	9201      	str	r2, [sp, #4]
   1261e:	46c3      	mov	fp, r8
   12620:	f1c8 0201 	rsb	r2, r8, #1
   12624:	4681      	mov	r9, r0
   12626:	9203      	str	r2, [sp, #12]
   12628:	46a8      	mov	r8, r5
   1262a:	4652      	mov	r2, sl
   1262c:	9302      	str	r3, [sp, #8]
   1262e:	eb09 0504 	add.w	r5, r9, r4
   12632:	18b8      	adds	r0, r7, r2
   12634:	2100      	movs	r1, #0
   12636:	1aaa      	subs	r2, r5, r2
   12638:	f000 fcb4 	bl	12fa4 <memchr>
   1263c:	2800      	cmp	r0, #0
   1263e:	d1b2      	bne.n	125a6 <strstr+0x3a>
   12640:	2d00      	cmp	r5, #0
   12642:	d0b0      	beq.n	125a6 <strstr+0x3a>
   12644:	455e      	cmp	r6, fp
   12646:	bf2c      	ite	cs
   12648:	4633      	movcs	r3, r6
   1264a:	465b      	movcc	r3, fp
   1264c:	429c      	cmp	r4, r3
   1264e:	d913      	bls.n	12678 <strstr+0x10c>
   12650:	eb03 0009 	add.w	r0, r3, r9
   12654:	f818 c003 	ldrb.w	ip, [r8, r3]
   12658:	183a      	adds	r2, r7, r0
   1265a:	eb08 0103 	add.w	r1, r8, r3
   1265e:	5c38      	ldrb	r0, [r7, r0]
   12660:	4584      	cmp	ip, r0
   12662:	d006      	beq.n	12672 <strstr+0x106>
   12664:	e085      	b.n	12772 <strstr+0x206>
   12666:	f811 cf01 	ldrb.w	ip, [r1, #1]!
   1266a:	f812 0f01 	ldrb.w	r0, [r2, #1]!
   1266e:	4584      	cmp	ip, r0
   12670:	d17f      	bne.n	12772 <strstr+0x206>
   12672:	3301      	adds	r3, #1
   12674:	429c      	cmp	r4, r3
   12676:	d8f6      	bhi.n	12666 <strstr+0xfa>
   12678:	45b3      	cmp	fp, r6
   1267a:	f240 8087 	bls.w	1278c <strstr+0x220>
   1267e:	9b01      	ldr	r3, [sp, #4]
   12680:	eb03 0209 	add.w	r2, r3, r9
   12684:	f818 1003 	ldrb.w	r1, [r8, r3]
   12688:	5dd2      	ldrb	r2, [r2, r7]
   1268a:	4291      	cmp	r1, r2
   1268c:	d17e      	bne.n	1278c <strstr+0x220>
   1268e:	eb09 020b 	add.w	r2, r9, fp
   12692:	9902      	ldr	r1, [sp, #8]
   12694:	18ba      	adds	r2, r7, r2
   12696:	46aa      	mov	sl, r5
   12698:	e008      	b.n	126ac <strstr+0x140>
   1269a:	f811 5c02 	ldrb.w	r5, [r1, #-2]
   1269e:	3901      	subs	r1, #1
   126a0:	f812 cc02 	ldrb.w	ip, [r2, #-2]
   126a4:	3a01      	subs	r2, #1
   126a6:	4565      	cmp	r5, ip
   126a8:	d104      	bne.n	126b4 <strstr+0x148>
   126aa:	4603      	mov	r3, r0
   126ac:	429e      	cmp	r6, r3
   126ae:	f103 30ff 	add.w	r0, r3, #4294967295
   126b2:	d3f2      	bcc.n	1269a <strstr+0x12e>
   126b4:	4655      	mov	r5, sl
   126b6:	3601      	adds	r6, #1
   126b8:	429e      	cmp	r6, r3
   126ba:	d869      	bhi.n	12790 <strstr+0x224>
   126bc:	9e05      	ldr	r6, [sp, #20]
   126be:	462a      	mov	r2, r5
   126c0:	44b1      	add	r9, r6
   126c2:	1ba6      	subs	r6, r4, r6
   126c4:	e7b3      	b.n	1262e <strstr+0xc2>
   126c6:	f1c8 0201 	rsb	r2, r8, #1
   126ca:	ebc8 0304 	rsb	r3, r8, r4
   126ce:	9201      	str	r2, [sp, #4]
   126d0:	2600      	movs	r6, #0
   126d2:	4652      	mov	r2, sl
   126d4:	eb05 0908 	add.w	r9, r5, r8
   126d8:	f108 3bff 	add.w	fp, r8, #4294967295
   126dc:	46aa      	mov	sl, r5
   126de:	4543      	cmp	r3, r8
   126e0:	bf38      	it	cc
   126e2:	4643      	movcc	r3, r8
   126e4:	3301      	adds	r3, #1
   126e6:	9305      	str	r3, [sp, #20]
   126e8:	1935      	adds	r5, r6, r4
   126ea:	18b8      	adds	r0, r7, r2
   126ec:	2100      	movs	r1, #0
   126ee:	1aaa      	subs	r2, r5, r2
   126f0:	f000 fc58 	bl	12fa4 <memchr>
   126f4:	2800      	cmp	r0, #0
   126f6:	f47f af56 	bne.w	125a6 <strstr+0x3a>
   126fa:	2d00      	cmp	r5, #0
   126fc:	f43f af53 	beq.w	125a6 <strstr+0x3a>
   12700:	4544      	cmp	r4, r8
   12702:	d915      	bls.n	12730 <strstr+0x1c4>
   12704:	eb06 0308 	add.w	r3, r6, r8
   12708:	f899 2000 	ldrb.w	r2, [r9]
   1270c:	18f9      	adds	r1, r7, r3
   1270e:	5cfb      	ldrb	r3, [r7, r3]
   12710:	429a      	cmp	r2, r3
   12712:	bf12      	itee	ne
   12714:	4643      	movne	r3, r8
   12716:	464a      	moveq	r2, r9
   12718:	4643      	moveq	r3, r8
   1271a:	d006      	beq.n	1272a <strstr+0x1be>
   1271c:	e024      	b.n	12768 <strstr+0x1fc>
   1271e:	f812 cf01 	ldrb.w	ip, [r2, #1]!
   12722:	f811 0f01 	ldrb.w	r0, [r1, #1]!
   12726:	4584      	cmp	ip, r0
   12728:	d11e      	bne.n	12768 <strstr+0x1fc>
   1272a:	3301      	adds	r3, #1
   1272c:	429c      	cmp	r4, r3
   1272e:	d8f6      	bhi.n	1271e <strstr+0x1b2>
   12730:	f1bb 3fff 	cmp.w	fp, #4294967295
   12734:	465b      	mov	r3, fp
   12736:	d015      	beq.n	12764 <strstr+0x1f8>
   12738:	eb06 020b 	add.w	r2, r6, fp
   1273c:	f81a 100b 	ldrb.w	r1, [sl, fp]
   12740:	5dd2      	ldrb	r2, [r2, r7]
   12742:	4291      	cmp	r1, r2
   12744:	d11b      	bne.n	1277e <strstr+0x212>
   12746:	eb06 0208 	add.w	r2, r6, r8
   1274a:	4649      	mov	r1, r9
   1274c:	18ba      	adds	r2, r7, r2
   1274e:	e007      	b.n	12760 <strstr+0x1f4>
   12750:	f811 cc02 	ldrb.w	ip, [r1, #-2]
   12754:	3901      	subs	r1, #1
   12756:	f812 0c02 	ldrb.w	r0, [r2, #-2]
   1275a:	3a01      	subs	r2, #1
   1275c:	4584      	cmp	ip, r0
   1275e:	d10e      	bne.n	1277e <strstr+0x212>
   12760:	3b01      	subs	r3, #1
   12762:	d2f5      	bcs.n	12750 <strstr+0x1e4>
   12764:	19be      	adds	r6, r7, r6
   12766:	e71f      	b.n	125a8 <strstr+0x3c>
   12768:	9a01      	ldr	r2, [sp, #4]
   1276a:	1996      	adds	r6, r2, r6
   1276c:	462a      	mov	r2, r5
   1276e:	18f6      	adds	r6, r6, r3
   12770:	e7ba      	b.n	126e8 <strstr+0x17c>
   12772:	9a03      	ldr	r2, [sp, #12]
   12774:	2600      	movs	r6, #0
   12776:	4491      	add	r9, r2
   12778:	462a      	mov	r2, r5
   1277a:	4499      	add	r9, r3
   1277c:	e757      	b.n	1262e <strstr+0xc2>
   1277e:	9b05      	ldr	r3, [sp, #20]
   12780:	462a      	mov	r2, r5
   12782:	18f6      	adds	r6, r6, r3
   12784:	e7b0      	b.n	126e8 <strstr+0x17c>
   12786:	460c      	mov	r4, r1
   12788:	2001      	movs	r0, #1
   1278a:	e70a      	b.n	125a2 <strstr+0x36>
   1278c:	465b      	mov	r3, fp
   1278e:	e792      	b.n	126b6 <strstr+0x14a>
   12790:	eb07 0609 	add.w	r6, r7, r9
   12794:	e708      	b.n	125a8 <strstr+0x3c>
   12796:	bf00      	nop

00012798 <_malloc_trim_r>:
   12798:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1279a:	f240 14d8 	movw	r4, #472	; 0x1d8
   1279e:	f2c2 0400 	movt	r4, #8192	; 0x2000
   127a2:	460f      	mov	r7, r1
   127a4:	4605      	mov	r5, r0
   127a6:	f000 fc69 	bl	1307c <__malloc_lock>
   127aa:	68a3      	ldr	r3, [r4, #8]
   127ac:	685e      	ldr	r6, [r3, #4]
   127ae:	f026 0603 	bic.w	r6, r6, #3
   127b2:	f506 637e 	add.w	r3, r6, #4064	; 0xfe0
   127b6:	330f      	adds	r3, #15
   127b8:	1bdf      	subs	r7, r3, r7
   127ba:	0b3f      	lsrs	r7, r7, #12
   127bc:	3f01      	subs	r7, #1
   127be:	033f      	lsls	r7, r7, #12
   127c0:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
   127c4:	db07      	blt.n	127d6 <_malloc_trim_r+0x3e>
   127c6:	2100      	movs	r1, #0
   127c8:	4628      	mov	r0, r5
   127ca:	f000 fc5b 	bl	13084 <_sbrk_r>
   127ce:	68a3      	ldr	r3, [r4, #8]
   127d0:	18f3      	adds	r3, r6, r3
   127d2:	4283      	cmp	r3, r0
   127d4:	d004      	beq.n	127e0 <_malloc_trim_r+0x48>
   127d6:	4628      	mov	r0, r5
   127d8:	f000 fc52 	bl	13080 <__malloc_unlock>
   127dc:	2000      	movs	r0, #0
   127de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   127e0:	4279      	negs	r1, r7
   127e2:	4628      	mov	r0, r5
   127e4:	f000 fc4e 	bl	13084 <_sbrk_r>
   127e8:	f1b0 3fff 	cmp.w	r0, #4294967295
   127ec:	d010      	beq.n	12810 <_malloc_trim_r+0x78>
   127ee:	68a2      	ldr	r2, [r4, #8]
   127f0:	f64a 135c 	movw	r3, #43356	; 0xa95c
   127f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   127f8:	1bf6      	subs	r6, r6, r7
   127fa:	f046 0601 	orr.w	r6, r6, #1
   127fe:	4628      	mov	r0, r5
   12800:	6056      	str	r6, [r2, #4]
   12802:	681a      	ldr	r2, [r3, #0]
   12804:	1bd7      	subs	r7, r2, r7
   12806:	601f      	str	r7, [r3, #0]
   12808:	f000 fc3a 	bl	13080 <__malloc_unlock>
   1280c:	2001      	movs	r0, #1
   1280e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   12810:	2100      	movs	r1, #0
   12812:	4628      	mov	r0, r5
   12814:	f000 fc36 	bl	13084 <_sbrk_r>
   12818:	68a3      	ldr	r3, [r4, #8]
   1281a:	1ac2      	subs	r2, r0, r3
   1281c:	2a0f      	cmp	r2, #15
   1281e:	ddda      	ble.n	127d6 <_malloc_trim_r+0x3e>
   12820:	f240 54e0 	movw	r4, #1504	; 0x5e0
   12824:	f64a 115c 	movw	r1, #43356	; 0xa95c
   12828:	f2c2 0400 	movt	r4, #8192	; 0x2000
   1282c:	f2c2 0100 	movt	r1, #8192	; 0x2000
   12830:	f042 0201 	orr.w	r2, r2, #1
   12834:	6824      	ldr	r4, [r4, #0]
   12836:	1b00      	subs	r0, r0, r4
   12838:	6008      	str	r0, [r1, #0]
   1283a:	605a      	str	r2, [r3, #4]
   1283c:	e7cb      	b.n	127d6 <_malloc_trim_r+0x3e>
   1283e:	bf00      	nop

00012840 <_free_r>:
   12840:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12844:	4605      	mov	r5, r0
   12846:	460c      	mov	r4, r1
   12848:	2900      	cmp	r1, #0
   1284a:	f000 8088 	beq.w	1295e <_free_r+0x11e>
   1284e:	f000 fc15 	bl	1307c <__malloc_lock>
   12852:	f1a4 0208 	sub.w	r2, r4, #8
   12856:	f240 10d8 	movw	r0, #472	; 0x1d8
   1285a:	6856      	ldr	r6, [r2, #4]
   1285c:	f2c2 0000 	movt	r0, #8192	; 0x2000
   12860:	f026 0301 	bic.w	r3, r6, #1
   12864:	f8d0 c008 	ldr.w	ip, [r0, #8]
   12868:	18d1      	adds	r1, r2, r3
   1286a:	458c      	cmp	ip, r1
   1286c:	684f      	ldr	r7, [r1, #4]
   1286e:	f027 0703 	bic.w	r7, r7, #3
   12872:	f000 8095 	beq.w	129a0 <_free_r+0x160>
   12876:	f016 0601 	ands.w	r6, r6, #1
   1287a:	604f      	str	r7, [r1, #4]
   1287c:	d05f      	beq.n	1293e <_free_r+0xfe>
   1287e:	2600      	movs	r6, #0
   12880:	19cc      	adds	r4, r1, r7
   12882:	6864      	ldr	r4, [r4, #4]
   12884:	f014 0f01 	tst.w	r4, #1
   12888:	d106      	bne.n	12898 <_free_r+0x58>
   1288a:	19db      	adds	r3, r3, r7
   1288c:	2e00      	cmp	r6, #0
   1288e:	d07a      	beq.n	12986 <_free_r+0x146>
   12890:	688c      	ldr	r4, [r1, #8]
   12892:	68c9      	ldr	r1, [r1, #12]
   12894:	608c      	str	r4, [r1, #8]
   12896:	60e1      	str	r1, [r4, #12]
   12898:	f043 0101 	orr.w	r1, r3, #1
   1289c:	50d3      	str	r3, [r2, r3]
   1289e:	6051      	str	r1, [r2, #4]
   128a0:	2e00      	cmp	r6, #0
   128a2:	d147      	bne.n	12934 <_free_r+0xf4>
   128a4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   128a8:	d35b      	bcc.n	12962 <_free_r+0x122>
   128aa:	0a59      	lsrs	r1, r3, #9
   128ac:	2904      	cmp	r1, #4
   128ae:	bf9e      	ittt	ls
   128b0:	ea4f 1c93 	movls.w	ip, r3, lsr #6
   128b4:	f10c 0c38 	addls.w	ip, ip, #56	; 0x38
   128b8:	ea4f 04cc 	movls.w	r4, ip, lsl #3
   128bc:	d928      	bls.n	12910 <_free_r+0xd0>
   128be:	2914      	cmp	r1, #20
   128c0:	bf9c      	itt	ls
   128c2:	f101 0c5b 	addls.w	ip, r1, #91	; 0x5b
   128c6:	ea4f 04cc 	movls.w	r4, ip, lsl #3
   128ca:	d921      	bls.n	12910 <_free_r+0xd0>
   128cc:	2954      	cmp	r1, #84	; 0x54
   128ce:	bf9e      	ittt	ls
   128d0:	ea4f 3c13 	movls.w	ip, r3, lsr #12
   128d4:	f10c 0c6e 	addls.w	ip, ip, #110	; 0x6e
   128d8:	ea4f 04cc 	movls.w	r4, ip, lsl #3
   128dc:	d918      	bls.n	12910 <_free_r+0xd0>
   128de:	f5b1 7faa 	cmp.w	r1, #340	; 0x154
   128e2:	bf9e      	ittt	ls
   128e4:	ea4f 3cd3 	movls.w	ip, r3, lsr #15
   128e8:	f10c 0c77 	addls.w	ip, ip, #119	; 0x77
   128ec:	ea4f 04cc 	movls.w	r4, ip, lsl #3
   128f0:	d90e      	bls.n	12910 <_free_r+0xd0>
   128f2:	f240 5c54 	movw	ip, #1364	; 0x554
   128f6:	4561      	cmp	r1, ip
   128f8:	bf95      	itete	ls
   128fa:	ea4f 4c93 	movls.w	ip, r3, lsr #18
   128fe:	f44f 747c 	movhi.w	r4, #1008	; 0x3f0
   12902:	f10c 0c7c 	addls.w	ip, ip, #124	; 0x7c
   12906:	f04f 0c7e 	movhi.w	ip, #126	; 0x7e
   1290a:	bf98      	it	ls
   1290c:	ea4f 04cc 	movls.w	r4, ip, lsl #3
   12910:	1904      	adds	r4, r0, r4
   12912:	68a1      	ldr	r1, [r4, #8]
   12914:	42a1      	cmp	r1, r4
   12916:	d103      	bne.n	12920 <_free_r+0xe0>
   12918:	e064      	b.n	129e4 <_free_r+0x1a4>
   1291a:	6889      	ldr	r1, [r1, #8]
   1291c:	428c      	cmp	r4, r1
   1291e:	d004      	beq.n	1292a <_free_r+0xea>
   12920:	6848      	ldr	r0, [r1, #4]
   12922:	f020 0003 	bic.w	r0, r0, #3
   12926:	4283      	cmp	r3, r0
   12928:	d3f7      	bcc.n	1291a <_free_r+0xda>
   1292a:	68cb      	ldr	r3, [r1, #12]
   1292c:	60d3      	str	r3, [r2, #12]
   1292e:	6091      	str	r1, [r2, #8]
   12930:	60ca      	str	r2, [r1, #12]
   12932:	609a      	str	r2, [r3, #8]
   12934:	4628      	mov	r0, r5
   12936:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1293a:	f000 bba1 	b.w	13080 <__malloc_unlock>
   1293e:	f854 4c08 	ldr.w	r4, [r4, #-8]
   12942:	f100 0c08 	add.w	ip, r0, #8
   12946:	1b12      	subs	r2, r2, r4
   12948:	191b      	adds	r3, r3, r4
   1294a:	6894      	ldr	r4, [r2, #8]
   1294c:	4564      	cmp	r4, ip
   1294e:	d047      	beq.n	129e0 <_free_r+0x1a0>
   12950:	f8d2 c00c 	ldr.w	ip, [r2, #12]
   12954:	f8cc 4008 	str.w	r4, [ip, #8]
   12958:	f8c4 c00c 	str.w	ip, [r4, #12]
   1295c:	e790      	b.n	12880 <_free_r+0x40>
   1295e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   12962:	08db      	lsrs	r3, r3, #3
   12964:	f04f 0c01 	mov.w	ip, #1
   12968:	6846      	ldr	r6, [r0, #4]
   1296a:	eb00 01c3 	add.w	r1, r0, r3, lsl #3
   1296e:	109b      	asrs	r3, r3, #2
   12970:	fa0c f303 	lsl.w	r3, ip, r3
   12974:	60d1      	str	r1, [r2, #12]
   12976:	688c      	ldr	r4, [r1, #8]
   12978:	ea46 0303 	orr.w	r3, r6, r3
   1297c:	6043      	str	r3, [r0, #4]
   1297e:	6094      	str	r4, [r2, #8]
   12980:	60e2      	str	r2, [r4, #12]
   12982:	608a      	str	r2, [r1, #8]
   12984:	e7d6      	b.n	12934 <_free_r+0xf4>
   12986:	688c      	ldr	r4, [r1, #8]
   12988:	4f1c      	ldr	r7, [pc, #112]	; (129fc <_free_r+0x1bc>)
   1298a:	42bc      	cmp	r4, r7
   1298c:	d181      	bne.n	12892 <_free_r+0x52>
   1298e:	50d3      	str	r3, [r2, r3]
   12990:	f043 0301 	orr.w	r3, r3, #1
   12994:	60e2      	str	r2, [r4, #12]
   12996:	60a2      	str	r2, [r4, #8]
   12998:	6053      	str	r3, [r2, #4]
   1299a:	6094      	str	r4, [r2, #8]
   1299c:	60d4      	str	r4, [r2, #12]
   1299e:	e7c9      	b.n	12934 <_free_r+0xf4>
   129a0:	18fb      	adds	r3, r7, r3
   129a2:	f016 0f01 	tst.w	r6, #1
   129a6:	d107      	bne.n	129b8 <_free_r+0x178>
   129a8:	f854 1c08 	ldr.w	r1, [r4, #-8]
   129ac:	1a52      	subs	r2, r2, r1
   129ae:	185b      	adds	r3, r3, r1
   129b0:	68d4      	ldr	r4, [r2, #12]
   129b2:	6891      	ldr	r1, [r2, #8]
   129b4:	60a1      	str	r1, [r4, #8]
   129b6:	60cc      	str	r4, [r1, #12]
   129b8:	f240 51e4 	movw	r1, #1508	; 0x5e4
   129bc:	6082      	str	r2, [r0, #8]
   129be:	f2c2 0100 	movt	r1, #8192	; 0x2000
   129c2:	f043 0001 	orr.w	r0, r3, #1
   129c6:	6050      	str	r0, [r2, #4]
   129c8:	680a      	ldr	r2, [r1, #0]
   129ca:	4293      	cmp	r3, r2
   129cc:	d3b2      	bcc.n	12934 <_free_r+0xf4>
   129ce:	f64a 1358 	movw	r3, #43352	; 0xa958
   129d2:	4628      	mov	r0, r5
   129d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   129d8:	6819      	ldr	r1, [r3, #0]
   129da:	f7ff fedd 	bl	12798 <_malloc_trim_r>
   129de:	e7a9      	b.n	12934 <_free_r+0xf4>
   129e0:	2601      	movs	r6, #1
   129e2:	e74d      	b.n	12880 <_free_r+0x40>
   129e4:	2601      	movs	r6, #1
   129e6:	6844      	ldr	r4, [r0, #4]
   129e8:	ea4f 0cac 	mov.w	ip, ip, asr #2
   129ec:	460b      	mov	r3, r1
   129ee:	fa06 fc0c 	lsl.w	ip, r6, ip
   129f2:	ea44 040c 	orr.w	r4, r4, ip
   129f6:	6044      	str	r4, [r0, #4]
   129f8:	e798      	b.n	1292c <_free_r+0xec>
   129fa:	bf00      	nop
   129fc:	200001e0 	.word	0x200001e0

00012a00 <_malloc_r>:
   12a00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12a04:	f101 040b 	add.w	r4, r1, #11
   12a08:	2c16      	cmp	r4, #22
   12a0a:	b083      	sub	sp, #12
   12a0c:	4606      	mov	r6, r0
   12a0e:	d82f      	bhi.n	12a70 <_malloc_r+0x70>
   12a10:	2300      	movs	r3, #0
   12a12:	2410      	movs	r4, #16
   12a14:	428c      	cmp	r4, r1
   12a16:	bf2c      	ite	cs
   12a18:	4619      	movcs	r1, r3
   12a1a:	f043 0101 	orrcc.w	r1, r3, #1
   12a1e:	2900      	cmp	r1, #0
   12a20:	d130      	bne.n	12a84 <_malloc_r+0x84>
   12a22:	4630      	mov	r0, r6
   12a24:	f000 fb2a 	bl	1307c <__malloc_lock>
   12a28:	f5b4 7ffc 	cmp.w	r4, #504	; 0x1f8
   12a2c:	d22e      	bcs.n	12a8c <_malloc_r+0x8c>
   12a2e:	ea4f 0ed4 	mov.w	lr, r4, lsr #3
   12a32:	f240 15d8 	movw	r5, #472	; 0x1d8
   12a36:	f2c2 0500 	movt	r5, #8192	; 0x2000
   12a3a:	eb05 02ce 	add.w	r2, r5, lr, lsl #3
   12a3e:	68d3      	ldr	r3, [r2, #12]
   12a40:	4293      	cmp	r3, r2
   12a42:	f000 8206 	beq.w	12e52 <_malloc_r+0x452>
   12a46:	685a      	ldr	r2, [r3, #4]
   12a48:	f103 0508 	add.w	r5, r3, #8
   12a4c:	68d9      	ldr	r1, [r3, #12]
   12a4e:	4630      	mov	r0, r6
   12a50:	f022 0c03 	bic.w	ip, r2, #3
   12a54:	689a      	ldr	r2, [r3, #8]
   12a56:	4463      	add	r3, ip
   12a58:	685c      	ldr	r4, [r3, #4]
   12a5a:	608a      	str	r2, [r1, #8]
   12a5c:	f044 0401 	orr.w	r4, r4, #1
   12a60:	60d1      	str	r1, [r2, #12]
   12a62:	605c      	str	r4, [r3, #4]
   12a64:	f000 fb0c 	bl	13080 <__malloc_unlock>
   12a68:	4628      	mov	r0, r5
   12a6a:	b003      	add	sp, #12
   12a6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12a70:	f024 0407 	bic.w	r4, r4, #7
   12a74:	0fe3      	lsrs	r3, r4, #31
   12a76:	428c      	cmp	r4, r1
   12a78:	bf2c      	ite	cs
   12a7a:	4619      	movcs	r1, r3
   12a7c:	f043 0101 	orrcc.w	r1, r3, #1
   12a80:	2900      	cmp	r1, #0
   12a82:	d0ce      	beq.n	12a22 <_malloc_r+0x22>
   12a84:	230c      	movs	r3, #12
   12a86:	2500      	movs	r5, #0
   12a88:	6033      	str	r3, [r6, #0]
   12a8a:	e7ed      	b.n	12a68 <_malloc_r+0x68>
   12a8c:	ea5f 2e54 	movs.w	lr, r4, lsr #9
   12a90:	bf04      	itt	eq
   12a92:	ea4f 0ed4 	moveq.w	lr, r4, lsr #3
   12a96:	ea4f 00ce 	moveq.w	r0, lr, lsl #3
   12a9a:	f040 8090 	bne.w	12bbe <_malloc_r+0x1be>
   12a9e:	f240 15d8 	movw	r5, #472	; 0x1d8
   12aa2:	f2c2 0500 	movt	r5, #8192	; 0x2000
   12aa6:	1828      	adds	r0, r5, r0
   12aa8:	68c3      	ldr	r3, [r0, #12]
   12aaa:	4298      	cmp	r0, r3
   12aac:	d106      	bne.n	12abc <_malloc_r+0xbc>
   12aae:	e00d      	b.n	12acc <_malloc_r+0xcc>
   12ab0:	2a00      	cmp	r2, #0
   12ab2:	f280 816f 	bge.w	12d94 <_malloc_r+0x394>
   12ab6:	68db      	ldr	r3, [r3, #12]
   12ab8:	4298      	cmp	r0, r3
   12aba:	d007      	beq.n	12acc <_malloc_r+0xcc>
   12abc:	6859      	ldr	r1, [r3, #4]
   12abe:	f021 0103 	bic.w	r1, r1, #3
   12ac2:	1b0a      	subs	r2, r1, r4
   12ac4:	2a0f      	cmp	r2, #15
   12ac6:	ddf3      	ble.n	12ab0 <_malloc_r+0xb0>
   12ac8:	f10e 3eff 	add.w	lr, lr, #4294967295
   12acc:	f10e 0e01 	add.w	lr, lr, #1
   12ad0:	f240 17d8 	movw	r7, #472	; 0x1d8
   12ad4:	f2c2 0700 	movt	r7, #8192	; 0x2000
   12ad8:	f107 0108 	add.w	r1, r7, #8
   12adc:	688b      	ldr	r3, [r1, #8]
   12ade:	4299      	cmp	r1, r3
   12ae0:	bf08      	it	eq
   12ae2:	687a      	ldreq	r2, [r7, #4]
   12ae4:	d026      	beq.n	12b34 <_malloc_r+0x134>
   12ae6:	685a      	ldr	r2, [r3, #4]
   12ae8:	f022 0c03 	bic.w	ip, r2, #3
   12aec:	ebc4 020c 	rsb	r2, r4, ip
   12af0:	2a0f      	cmp	r2, #15
   12af2:	f300 8194 	bgt.w	12e1e <_malloc_r+0x41e>
   12af6:	2a00      	cmp	r2, #0
   12af8:	60c9      	str	r1, [r1, #12]
   12afa:	6089      	str	r1, [r1, #8]
   12afc:	f280 8099 	bge.w	12c32 <_malloc_r+0x232>
   12b00:	f5bc 7f00 	cmp.w	ip, #512	; 0x200
   12b04:	f080 8165 	bcs.w	12dd2 <_malloc_r+0x3d2>
   12b08:	ea4f 0cdc 	mov.w	ip, ip, lsr #3
   12b0c:	f04f 0a01 	mov.w	sl, #1
   12b10:	687a      	ldr	r2, [r7, #4]
   12b12:	eb07 00cc 	add.w	r0, r7, ip, lsl #3
   12b16:	ea4f 0cac 	mov.w	ip, ip, asr #2
   12b1a:	fa0a fc0c 	lsl.w	ip, sl, ip
   12b1e:	60d8      	str	r0, [r3, #12]
   12b20:	f8d0 8008 	ldr.w	r8, [r0, #8]
   12b24:	ea4c 0202 	orr.w	r2, ip, r2
   12b28:	607a      	str	r2, [r7, #4]
   12b2a:	f8c3 8008 	str.w	r8, [r3, #8]
   12b2e:	f8c8 300c 	str.w	r3, [r8, #12]
   12b32:	6083      	str	r3, [r0, #8]
   12b34:	f04f 0c01 	mov.w	ip, #1
   12b38:	ea4f 03ae 	mov.w	r3, lr, asr #2
   12b3c:	fa0c fc03 	lsl.w	ip, ip, r3
   12b40:	4594      	cmp	ip, r2
   12b42:	f200 8082 	bhi.w	12c4a <_malloc_r+0x24a>
   12b46:	ea12 0f0c 	tst.w	r2, ip
   12b4a:	d108      	bne.n	12b5e <_malloc_r+0x15e>
   12b4c:	f02e 0e03 	bic.w	lr, lr, #3
   12b50:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
   12b54:	f10e 0e04 	add.w	lr, lr, #4
   12b58:	ea12 0f0c 	tst.w	r2, ip
   12b5c:	d0f8      	beq.n	12b50 <_malloc_r+0x150>
   12b5e:	eb07 09ce 	add.w	r9, r7, lr, lsl #3
   12b62:	46f2      	mov	sl, lr
   12b64:	46c8      	mov	r8, r9
   12b66:	f8d8 300c 	ldr.w	r3, [r8, #12]
   12b6a:	4598      	cmp	r8, r3
   12b6c:	d107      	bne.n	12b7e <_malloc_r+0x17e>
   12b6e:	e168      	b.n	12e42 <_malloc_r+0x442>
   12b70:	2a00      	cmp	r2, #0
   12b72:	f280 8178 	bge.w	12e66 <_malloc_r+0x466>
   12b76:	68db      	ldr	r3, [r3, #12]
   12b78:	4598      	cmp	r8, r3
   12b7a:	f000 8162 	beq.w	12e42 <_malloc_r+0x442>
   12b7e:	6858      	ldr	r0, [r3, #4]
   12b80:	f020 0003 	bic.w	r0, r0, #3
   12b84:	1b02      	subs	r2, r0, r4
   12b86:	2a0f      	cmp	r2, #15
   12b88:	ddf2      	ble.n	12b70 <_malloc_r+0x170>
   12b8a:	461d      	mov	r5, r3
   12b8c:	191f      	adds	r7, r3, r4
   12b8e:	f8d3 c00c 	ldr.w	ip, [r3, #12]
   12b92:	f044 0e01 	orr.w	lr, r4, #1
   12b96:	f855 4f08 	ldr.w	r4, [r5, #8]!
   12b9a:	4630      	mov	r0, r6
   12b9c:	50ba      	str	r2, [r7, r2]
   12b9e:	f042 0201 	orr.w	r2, r2, #1
   12ba2:	f8c3 e004 	str.w	lr, [r3, #4]
   12ba6:	f8cc 4008 	str.w	r4, [ip, #8]
   12baa:	f8c4 c00c 	str.w	ip, [r4, #12]
   12bae:	608f      	str	r7, [r1, #8]
   12bb0:	60cf      	str	r7, [r1, #12]
   12bb2:	607a      	str	r2, [r7, #4]
   12bb4:	60b9      	str	r1, [r7, #8]
   12bb6:	60f9      	str	r1, [r7, #12]
   12bb8:	f000 fa62 	bl	13080 <__malloc_unlock>
   12bbc:	e754      	b.n	12a68 <_malloc_r+0x68>
   12bbe:	f1be 0f04 	cmp.w	lr, #4
   12bc2:	bf9e      	ittt	ls
   12bc4:	ea4f 1e94 	movls.w	lr, r4, lsr #6
   12bc8:	f10e 0e38 	addls.w	lr, lr, #56	; 0x38
   12bcc:	ea4f 00ce 	movls.w	r0, lr, lsl #3
   12bd0:	f67f af65 	bls.w	12a9e <_malloc_r+0x9e>
   12bd4:	f1be 0f14 	cmp.w	lr, #20
   12bd8:	bf9c      	itt	ls
   12bda:	f10e 0e5b 	addls.w	lr, lr, #91	; 0x5b
   12bde:	ea4f 00ce 	movls.w	r0, lr, lsl #3
   12be2:	f67f af5c 	bls.w	12a9e <_malloc_r+0x9e>
   12be6:	f1be 0f54 	cmp.w	lr, #84	; 0x54
   12bea:	bf9e      	ittt	ls
   12bec:	ea4f 3e14 	movls.w	lr, r4, lsr #12
   12bf0:	f10e 0e6e 	addls.w	lr, lr, #110	; 0x6e
   12bf4:	ea4f 00ce 	movls.w	r0, lr, lsl #3
   12bf8:	f67f af51 	bls.w	12a9e <_malloc_r+0x9e>
   12bfc:	f5be 7faa 	cmp.w	lr, #340	; 0x154
   12c00:	bf9e      	ittt	ls
   12c02:	ea4f 3ed4 	movls.w	lr, r4, lsr #15
   12c06:	f10e 0e77 	addls.w	lr, lr, #119	; 0x77
   12c0a:	ea4f 00ce 	movls.w	r0, lr, lsl #3
   12c0e:	f67f af46 	bls.w	12a9e <_malloc_r+0x9e>
   12c12:	f240 5354 	movw	r3, #1364	; 0x554
   12c16:	459e      	cmp	lr, r3
   12c18:	bf95      	itete	ls
   12c1a:	ea4f 4e94 	movls.w	lr, r4, lsr #18
   12c1e:	f44f 707c 	movhi.w	r0, #1008	; 0x3f0
   12c22:	f10e 0e7c 	addls.w	lr, lr, #124	; 0x7c
   12c26:	f04f 0e7e 	movhi.w	lr, #126	; 0x7e
   12c2a:	bf98      	it	ls
   12c2c:	ea4f 00ce 	movls.w	r0, lr, lsl #3
   12c30:	e735      	b.n	12a9e <_malloc_r+0x9e>
   12c32:	eb03 020c 	add.w	r2, r3, ip
   12c36:	f103 0508 	add.w	r5, r3, #8
   12c3a:	4630      	mov	r0, r6
   12c3c:	6853      	ldr	r3, [r2, #4]
   12c3e:	f043 0301 	orr.w	r3, r3, #1
   12c42:	6053      	str	r3, [r2, #4]
   12c44:	f000 fa1c 	bl	13080 <__malloc_unlock>
   12c48:	e70e      	b.n	12a68 <_malloc_r+0x68>
   12c4a:	f8d7 8008 	ldr.w	r8, [r7, #8]
   12c4e:	f8d8 3004 	ldr.w	r3, [r8, #4]
   12c52:	f023 0903 	bic.w	r9, r3, #3
   12c56:	ebc4 0209 	rsb	r2, r4, r9
   12c5a:	454c      	cmp	r4, r9
   12c5c:	bf94      	ite	ls
   12c5e:	2300      	movls	r3, #0
   12c60:	2301      	movhi	r3, #1
   12c62:	2a0f      	cmp	r2, #15
   12c64:	bfd8      	it	le
   12c66:	f043 0301 	orrle.w	r3, r3, #1
   12c6a:	2b00      	cmp	r3, #0
   12c6c:	f000 80a1 	beq.w	12db2 <_malloc_r+0x3b2>
   12c70:	f64a 1b58 	movw	fp, #43352	; 0xa958
   12c74:	f8d5 2408 	ldr.w	r2, [r5, #1032]	; 0x408
   12c78:	f2c2 0b00 	movt	fp, #8192	; 0x2000
   12c7c:	f8db 3000 	ldr.w	r3, [fp]
   12c80:	3310      	adds	r3, #16
   12c82:	191b      	adds	r3, r3, r4
   12c84:	f1b2 3fff 	cmp.w	r2, #4294967295
   12c88:	d006      	beq.n	12c98 <_malloc_r+0x298>
   12c8a:	f503 637e 	add.w	r3, r3, #4064	; 0xfe0
   12c8e:	331f      	adds	r3, #31
   12c90:	f423 637e 	bic.w	r3, r3, #4064	; 0xfe0
   12c94:	f023 031f 	bic.w	r3, r3, #31
   12c98:	4619      	mov	r1, r3
   12c9a:	4630      	mov	r0, r6
   12c9c:	9301      	str	r3, [sp, #4]
   12c9e:	f000 f9f1 	bl	13084 <_sbrk_r>
   12ca2:	9b01      	ldr	r3, [sp, #4]
   12ca4:	f1b0 3fff 	cmp.w	r0, #4294967295
   12ca8:	4682      	mov	sl, r0
   12caa:	f000 80f4 	beq.w	12e96 <_malloc_r+0x496>
   12cae:	eb08 0109 	add.w	r1, r8, r9
   12cb2:	4281      	cmp	r1, r0
   12cb4:	f200 80ec 	bhi.w	12e90 <_malloc_r+0x490>
   12cb8:	f8db 2004 	ldr.w	r2, [fp, #4]
   12cbc:	189a      	adds	r2, r3, r2
   12cbe:	4551      	cmp	r1, sl
   12cc0:	f8cb 2004 	str.w	r2, [fp, #4]
   12cc4:	f000 8145 	beq.w	12f52 <_malloc_r+0x552>
   12cc8:	f8d5 5408 	ldr.w	r5, [r5, #1032]	; 0x408
   12ccc:	f240 10d8 	movw	r0, #472	; 0x1d8
   12cd0:	f2c2 0000 	movt	r0, #8192	; 0x2000
   12cd4:	f1b5 3fff 	cmp.w	r5, #4294967295
   12cd8:	bf08      	it	eq
   12cda:	f8c0 a408 	streq.w	sl, [r0, #1032]	; 0x408
   12cde:	d003      	beq.n	12ce8 <_malloc_r+0x2e8>
   12ce0:	4452      	add	r2, sl
   12ce2:	1a51      	subs	r1, r2, r1
   12ce4:	f8cb 1004 	str.w	r1, [fp, #4]
   12ce8:	f01a 0507 	ands.w	r5, sl, #7
   12cec:	4630      	mov	r0, r6
   12cee:	bf17      	itett	ne
   12cf0:	f1c5 0508 	rsbne	r5, r5, #8
   12cf4:	f44f 5580 	moveq.w	r5, #4096	; 0x1000
   12cf8:	44aa      	addne	sl, r5
   12cfa:	f505 5580 	addne.w	r5, r5, #4096	; 0x1000
   12cfe:	4453      	add	r3, sl
   12d00:	051b      	lsls	r3, r3, #20
   12d02:	0d1b      	lsrs	r3, r3, #20
   12d04:	1aed      	subs	r5, r5, r3
   12d06:	4629      	mov	r1, r5
   12d08:	f000 f9bc 	bl	13084 <_sbrk_r>
   12d0c:	f1b0 3fff 	cmp.w	r0, #4294967295
   12d10:	f000 812c 	beq.w	12f6c <_malloc_r+0x56c>
   12d14:	ebca 0100 	rsb	r1, sl, r0
   12d18:	1949      	adds	r1, r1, r5
   12d1a:	f041 0101 	orr.w	r1, r1, #1
   12d1e:	f8db 2004 	ldr.w	r2, [fp, #4]
   12d22:	f64a 1358 	movw	r3, #43352	; 0xa958
   12d26:	f8c7 a008 	str.w	sl, [r7, #8]
   12d2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12d2e:	18aa      	adds	r2, r5, r2
   12d30:	45b8      	cmp	r8, r7
   12d32:	f8cb 2004 	str.w	r2, [fp, #4]
   12d36:	f8ca 1004 	str.w	r1, [sl, #4]
   12d3a:	d017      	beq.n	12d6c <_malloc_r+0x36c>
   12d3c:	f1b9 0f0f 	cmp.w	r9, #15
   12d40:	f240 80df 	bls.w	12f02 <_malloc_r+0x502>
   12d44:	f1a9 010c 	sub.w	r1, r9, #12
   12d48:	2505      	movs	r5, #5
   12d4a:	f021 0107 	bic.w	r1, r1, #7
   12d4e:	eb08 0001 	add.w	r0, r8, r1
   12d52:	290f      	cmp	r1, #15
   12d54:	6085      	str	r5, [r0, #8]
   12d56:	6045      	str	r5, [r0, #4]
   12d58:	f8d8 0004 	ldr.w	r0, [r8, #4]
   12d5c:	f000 0001 	and.w	r0, r0, #1
   12d60:	ea41 0000 	orr.w	r0, r1, r0
   12d64:	f8c8 0004 	str.w	r0, [r8, #4]
   12d68:	f200 80ac 	bhi.w	12ec4 <_malloc_r+0x4c4>
   12d6c:	46d0      	mov	r8, sl
   12d6e:	f64a 1358 	movw	r3, #43352	; 0xa958
   12d72:	f8db 102c 	ldr.w	r1, [fp, #44]	; 0x2c
   12d76:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12d7a:	428a      	cmp	r2, r1
   12d7c:	f8db 1030 	ldr.w	r1, [fp, #48]	; 0x30
   12d80:	bf88      	it	hi
   12d82:	62da      	strhi	r2, [r3, #44]	; 0x2c
   12d84:	f64a 1358 	movw	r3, #43352	; 0xa958
   12d88:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12d8c:	428a      	cmp	r2, r1
   12d8e:	bf88      	it	hi
   12d90:	631a      	strhi	r2, [r3, #48]	; 0x30
   12d92:	e082      	b.n	12e9a <_malloc_r+0x49a>
   12d94:	185c      	adds	r4, r3, r1
   12d96:	689a      	ldr	r2, [r3, #8]
   12d98:	68d9      	ldr	r1, [r3, #12]
   12d9a:	4630      	mov	r0, r6
   12d9c:	6866      	ldr	r6, [r4, #4]
   12d9e:	f103 0508 	add.w	r5, r3, #8
   12da2:	608a      	str	r2, [r1, #8]
   12da4:	f046 0301 	orr.w	r3, r6, #1
   12da8:	60d1      	str	r1, [r2, #12]
   12daa:	6063      	str	r3, [r4, #4]
   12dac:	f000 f968 	bl	13080 <__malloc_unlock>
   12db0:	e65a      	b.n	12a68 <_malloc_r+0x68>
   12db2:	eb08 0304 	add.w	r3, r8, r4
   12db6:	f042 0201 	orr.w	r2, r2, #1
   12dba:	f044 0401 	orr.w	r4, r4, #1
   12dbe:	4630      	mov	r0, r6
   12dc0:	f8c8 4004 	str.w	r4, [r8, #4]
   12dc4:	f108 0508 	add.w	r5, r8, #8
   12dc8:	605a      	str	r2, [r3, #4]
   12dca:	60bb      	str	r3, [r7, #8]
   12dcc:	f000 f958 	bl	13080 <__malloc_unlock>
   12dd0:	e64a      	b.n	12a68 <_malloc_r+0x68>
   12dd2:	ea4f 225c 	mov.w	r2, ip, lsr #9
   12dd6:	2a04      	cmp	r2, #4
   12dd8:	d954      	bls.n	12e84 <_malloc_r+0x484>
   12dda:	2a14      	cmp	r2, #20
   12ddc:	f200 8089 	bhi.w	12ef2 <_malloc_r+0x4f2>
   12de0:	325b      	adds	r2, #91	; 0x5b
   12de2:	ea4f 08c2 	mov.w	r8, r2, lsl #3
   12de6:	44a8      	add	r8, r5
   12de8:	f240 17d8 	movw	r7, #472	; 0x1d8
   12dec:	f2c2 0700 	movt	r7, #8192	; 0x2000
   12df0:	f8d8 0008 	ldr.w	r0, [r8, #8]
   12df4:	4540      	cmp	r0, r8
   12df6:	d103      	bne.n	12e00 <_malloc_r+0x400>
   12df8:	e06f      	b.n	12eda <_malloc_r+0x4da>
   12dfa:	6880      	ldr	r0, [r0, #8]
   12dfc:	4580      	cmp	r8, r0
   12dfe:	d004      	beq.n	12e0a <_malloc_r+0x40a>
   12e00:	6842      	ldr	r2, [r0, #4]
   12e02:	f022 0203 	bic.w	r2, r2, #3
   12e06:	4594      	cmp	ip, r2
   12e08:	d3f7      	bcc.n	12dfa <_malloc_r+0x3fa>
   12e0a:	f8d0 c00c 	ldr.w	ip, [r0, #12]
   12e0e:	f8c3 c00c 	str.w	ip, [r3, #12]
   12e12:	6098      	str	r0, [r3, #8]
   12e14:	687a      	ldr	r2, [r7, #4]
   12e16:	60c3      	str	r3, [r0, #12]
   12e18:	f8cc 3008 	str.w	r3, [ip, #8]
   12e1c:	e68a      	b.n	12b34 <_malloc_r+0x134>
   12e1e:	191f      	adds	r7, r3, r4
   12e20:	4630      	mov	r0, r6
   12e22:	f044 0401 	orr.w	r4, r4, #1
   12e26:	60cf      	str	r7, [r1, #12]
   12e28:	605c      	str	r4, [r3, #4]
   12e2a:	f103 0508 	add.w	r5, r3, #8
   12e2e:	50ba      	str	r2, [r7, r2]
   12e30:	f042 0201 	orr.w	r2, r2, #1
   12e34:	608f      	str	r7, [r1, #8]
   12e36:	607a      	str	r2, [r7, #4]
   12e38:	60b9      	str	r1, [r7, #8]
   12e3a:	60f9      	str	r1, [r7, #12]
   12e3c:	f000 f920 	bl	13080 <__malloc_unlock>
   12e40:	e612      	b.n	12a68 <_malloc_r+0x68>
   12e42:	f10a 0a01 	add.w	sl, sl, #1
   12e46:	f01a 0f03 	tst.w	sl, #3
   12e4a:	d05f      	beq.n	12f0c <_malloc_r+0x50c>
   12e4c:	f103 0808 	add.w	r8, r3, #8
   12e50:	e689      	b.n	12b66 <_malloc_r+0x166>
   12e52:	f103 0208 	add.w	r2, r3, #8
   12e56:	68d3      	ldr	r3, [r2, #12]
   12e58:	429a      	cmp	r2, r3
   12e5a:	bf08      	it	eq
   12e5c:	f10e 0e02 	addeq.w	lr, lr, #2
   12e60:	f43f ae36 	beq.w	12ad0 <_malloc_r+0xd0>
   12e64:	e5ef      	b.n	12a46 <_malloc_r+0x46>
   12e66:	461d      	mov	r5, r3
   12e68:	1819      	adds	r1, r3, r0
   12e6a:	68da      	ldr	r2, [r3, #12]
   12e6c:	4630      	mov	r0, r6
   12e6e:	f855 3f08 	ldr.w	r3, [r5, #8]!
   12e72:	684c      	ldr	r4, [r1, #4]
   12e74:	6093      	str	r3, [r2, #8]
   12e76:	f044 0401 	orr.w	r4, r4, #1
   12e7a:	60da      	str	r2, [r3, #12]
   12e7c:	604c      	str	r4, [r1, #4]
   12e7e:	f000 f8ff 	bl	13080 <__malloc_unlock>
   12e82:	e5f1      	b.n	12a68 <_malloc_r+0x68>
   12e84:	ea4f 129c 	mov.w	r2, ip, lsr #6
   12e88:	3238      	adds	r2, #56	; 0x38
   12e8a:	ea4f 08c2 	mov.w	r8, r2, lsl #3
   12e8e:	e7aa      	b.n	12de6 <_malloc_r+0x3e6>
   12e90:	45b8      	cmp	r8, r7
   12e92:	f43f af11 	beq.w	12cb8 <_malloc_r+0x2b8>
   12e96:	f8d7 8008 	ldr.w	r8, [r7, #8]
   12e9a:	f8d8 2004 	ldr.w	r2, [r8, #4]
   12e9e:	f022 0203 	bic.w	r2, r2, #3
   12ea2:	4294      	cmp	r4, r2
   12ea4:	bf94      	ite	ls
   12ea6:	2300      	movls	r3, #0
   12ea8:	2301      	movhi	r3, #1
   12eaa:	1b12      	subs	r2, r2, r4
   12eac:	2a0f      	cmp	r2, #15
   12eae:	bfd8      	it	le
   12eb0:	f043 0301 	orrle.w	r3, r3, #1
   12eb4:	2b00      	cmp	r3, #0
   12eb6:	f43f af7c 	beq.w	12db2 <_malloc_r+0x3b2>
   12eba:	4630      	mov	r0, r6
   12ebc:	2500      	movs	r5, #0
   12ebe:	f000 f8df 	bl	13080 <__malloc_unlock>
   12ec2:	e5d1      	b.n	12a68 <_malloc_r+0x68>
   12ec4:	f108 0108 	add.w	r1, r8, #8
   12ec8:	4630      	mov	r0, r6
   12eca:	9301      	str	r3, [sp, #4]
   12ecc:	f7ff fcb8 	bl	12840 <_free_r>
   12ed0:	9b01      	ldr	r3, [sp, #4]
   12ed2:	f8d7 8008 	ldr.w	r8, [r7, #8]
   12ed6:	685a      	ldr	r2, [r3, #4]
   12ed8:	e749      	b.n	12d6e <_malloc_r+0x36e>
   12eda:	f04f 0a01 	mov.w	sl, #1
   12ede:	f8d7 8004 	ldr.w	r8, [r7, #4]
   12ee2:	1092      	asrs	r2, r2, #2
   12ee4:	4684      	mov	ip, r0
   12ee6:	fa0a f202 	lsl.w	r2, sl, r2
   12eea:	ea48 0202 	orr.w	r2, r8, r2
   12eee:	607a      	str	r2, [r7, #4]
   12ef0:	e78d      	b.n	12e0e <_malloc_r+0x40e>
   12ef2:	2a54      	cmp	r2, #84	; 0x54
   12ef4:	d824      	bhi.n	12f40 <_malloc_r+0x540>
   12ef6:	ea4f 321c 	mov.w	r2, ip, lsr #12
   12efa:	326e      	adds	r2, #110	; 0x6e
   12efc:	ea4f 08c2 	mov.w	r8, r2, lsl #3
   12f00:	e771      	b.n	12de6 <_malloc_r+0x3e6>
   12f02:	2301      	movs	r3, #1
   12f04:	46d0      	mov	r8, sl
   12f06:	f8ca 3004 	str.w	r3, [sl, #4]
   12f0a:	e7c6      	b.n	12e9a <_malloc_r+0x49a>
   12f0c:	464a      	mov	r2, r9
   12f0e:	f01e 0f03 	tst.w	lr, #3
   12f12:	4613      	mov	r3, r2
   12f14:	f10e 3eff 	add.w	lr, lr, #4294967295
   12f18:	d033      	beq.n	12f82 <_malloc_r+0x582>
   12f1a:	f853 2908 	ldr.w	r2, [r3], #-8
   12f1e:	429a      	cmp	r2, r3
   12f20:	d0f5      	beq.n	12f0e <_malloc_r+0x50e>
   12f22:	687b      	ldr	r3, [r7, #4]
   12f24:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
   12f28:	459c      	cmp	ip, r3
   12f2a:	f63f ae8e 	bhi.w	12c4a <_malloc_r+0x24a>
   12f2e:	f1bc 0f00 	cmp.w	ip, #0
   12f32:	f43f ae8a 	beq.w	12c4a <_malloc_r+0x24a>
   12f36:	ea1c 0f03 	tst.w	ip, r3
   12f3a:	d027      	beq.n	12f8c <_malloc_r+0x58c>
   12f3c:	46d6      	mov	lr, sl
   12f3e:	e60e      	b.n	12b5e <_malloc_r+0x15e>
   12f40:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
   12f44:	d815      	bhi.n	12f72 <_malloc_r+0x572>
   12f46:	ea4f 32dc 	mov.w	r2, ip, lsr #15
   12f4a:	3277      	adds	r2, #119	; 0x77
   12f4c:	ea4f 08c2 	mov.w	r8, r2, lsl #3
   12f50:	e749      	b.n	12de6 <_malloc_r+0x3e6>
   12f52:	0508      	lsls	r0, r1, #20
   12f54:	0d00      	lsrs	r0, r0, #20
   12f56:	2800      	cmp	r0, #0
   12f58:	f47f aeb6 	bne.w	12cc8 <_malloc_r+0x2c8>
   12f5c:	f8d7 8008 	ldr.w	r8, [r7, #8]
   12f60:	444b      	add	r3, r9
   12f62:	f043 0301 	orr.w	r3, r3, #1
   12f66:	f8c8 3004 	str.w	r3, [r8, #4]
   12f6a:	e700      	b.n	12d6e <_malloc_r+0x36e>
   12f6c:	2101      	movs	r1, #1
   12f6e:	2500      	movs	r5, #0
   12f70:	e6d5      	b.n	12d1e <_malloc_r+0x31e>
   12f72:	f240 5054 	movw	r0, #1364	; 0x554
   12f76:	4282      	cmp	r2, r0
   12f78:	d90d      	bls.n	12f96 <_malloc_r+0x596>
   12f7a:	f44f 787c 	mov.w	r8, #1008	; 0x3f0
   12f7e:	227e      	movs	r2, #126	; 0x7e
   12f80:	e731      	b.n	12de6 <_malloc_r+0x3e6>
   12f82:	687b      	ldr	r3, [r7, #4]
   12f84:	ea23 030c 	bic.w	r3, r3, ip
   12f88:	607b      	str	r3, [r7, #4]
   12f8a:	e7cb      	b.n	12f24 <_malloc_r+0x524>
   12f8c:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
   12f90:	f10a 0a04 	add.w	sl, sl, #4
   12f94:	e7cf      	b.n	12f36 <_malloc_r+0x536>
   12f96:	ea4f 429c 	mov.w	r2, ip, lsr #18
   12f9a:	327c      	adds	r2, #124	; 0x7c
   12f9c:	ea4f 08c2 	mov.w	r8, r2, lsl #3
   12fa0:	e721      	b.n	12de6 <_malloc_r+0x3e6>
   12fa2:	bf00      	nop

00012fa4 <memchr>:
   12fa4:	f010 0f03 	tst.w	r0, #3
   12fa8:	b2c9      	uxtb	r1, r1
   12faa:	b410      	push	{r4}
   12fac:	d010      	beq.n	12fd0 <memchr+0x2c>
   12fae:	2a00      	cmp	r2, #0
   12fb0:	d02f      	beq.n	13012 <memchr+0x6e>
   12fb2:	7803      	ldrb	r3, [r0, #0]
   12fb4:	428b      	cmp	r3, r1
   12fb6:	d02a      	beq.n	1300e <memchr+0x6a>
   12fb8:	3a01      	subs	r2, #1
   12fba:	e005      	b.n	12fc8 <memchr+0x24>
   12fbc:	2a00      	cmp	r2, #0
   12fbe:	d028      	beq.n	13012 <memchr+0x6e>
   12fc0:	7803      	ldrb	r3, [r0, #0]
   12fc2:	3a01      	subs	r2, #1
   12fc4:	428b      	cmp	r3, r1
   12fc6:	d022      	beq.n	1300e <memchr+0x6a>
   12fc8:	3001      	adds	r0, #1
   12fca:	f010 0f03 	tst.w	r0, #3
   12fce:	d1f5      	bne.n	12fbc <memchr+0x18>
   12fd0:	2a03      	cmp	r2, #3
   12fd2:	d911      	bls.n	12ff8 <memchr+0x54>
   12fd4:	ea41 2401 	orr.w	r4, r1, r1, lsl #8
   12fd8:	ea44 4404 	orr.w	r4, r4, r4, lsl #16
   12fdc:	6803      	ldr	r3, [r0, #0]
   12fde:	ea84 0303 	eor.w	r3, r4, r3
   12fe2:	f1a3 3c01 	sub.w	ip, r3, #16843009	; 0x1010101
   12fe6:	ea2c 0303 	bic.w	r3, ip, r3
   12fea:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   12fee:	d103      	bne.n	12ff8 <memchr+0x54>
   12ff0:	3a04      	subs	r2, #4
   12ff2:	3004      	adds	r0, #4
   12ff4:	2a03      	cmp	r2, #3
   12ff6:	d8f1      	bhi.n	12fdc <memchr+0x38>
   12ff8:	b15a      	cbz	r2, 13012 <memchr+0x6e>
   12ffa:	7803      	ldrb	r3, [r0, #0]
   12ffc:	428b      	cmp	r3, r1
   12ffe:	d006      	beq.n	1300e <memchr+0x6a>
   13000:	3a01      	subs	r2, #1
   13002:	b132      	cbz	r2, 13012 <memchr+0x6e>
   13004:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   13008:	3a01      	subs	r2, #1
   1300a:	428b      	cmp	r3, r1
   1300c:	d1f9      	bne.n	13002 <memchr+0x5e>
   1300e:	bc10      	pop	{r4}
   13010:	4770      	bx	lr
   13012:	2000      	movs	r0, #0
   13014:	e7fb      	b.n	1300e <memchr+0x6a>
   13016:	bf00      	nop

00013018 <memcmp>:
   13018:	2a03      	cmp	r2, #3
   1301a:	b430      	push	{r4, r5}
   1301c:	4605      	mov	r5, r0
   1301e:	460c      	mov	r4, r1
   13020:	d925      	bls.n	1306e <memcmp+0x56>
   13022:	ea41 0300 	orr.w	r3, r1, r0
   13026:	f013 0f03 	tst.w	r3, #3
   1302a:	d015      	beq.n	13058 <memcmp+0x40>
   1302c:	7828      	ldrb	r0, [r5, #0]
   1302e:	f894 c000 	ldrb.w	ip, [r4]
   13032:	4560      	cmp	r0, ip
   13034:	d11e      	bne.n	13074 <memcmp+0x5c>
   13036:	3a01      	subs	r2, #1
   13038:	2300      	movs	r3, #0
   1303a:	e006      	b.n	1304a <memcmp+0x32>
   1303c:	7840      	ldrb	r0, [r0, #1]
   1303e:	3301      	adds	r3, #1
   13040:	f891 c001 	ldrb.w	ip, [r1, #1]
   13044:	3a01      	subs	r2, #1
   13046:	4560      	cmp	r0, ip
   13048:	d114      	bne.n	13074 <memcmp+0x5c>
   1304a:	18e8      	adds	r0, r5, r3
   1304c:	18e1      	adds	r1, r4, r3
   1304e:	2a00      	cmp	r2, #0
   13050:	d1f4      	bne.n	1303c <memcmp+0x24>
   13052:	2000      	movs	r0, #0
   13054:	bc30      	pop	{r4, r5}
   13056:	4770      	bx	lr
   13058:	6804      	ldr	r4, [r0, #0]
   1305a:	680b      	ldr	r3, [r1, #0]
   1305c:	429c      	cmp	r4, r3
   1305e:	d104      	bne.n	1306a <memcmp+0x52>
   13060:	3a04      	subs	r2, #4
   13062:	3004      	adds	r0, #4
   13064:	3104      	adds	r1, #4
   13066:	2a03      	cmp	r2, #3
   13068:	d8f6      	bhi.n	13058 <memcmp+0x40>
   1306a:	4605      	mov	r5, r0
   1306c:	460c      	mov	r4, r1
   1306e:	2a00      	cmp	r2, #0
   13070:	d1dc      	bne.n	1302c <memcmp+0x14>
   13072:	e7ee      	b.n	13052 <memcmp+0x3a>
   13074:	ebcc 0000 	rsb	r0, ip, r0
   13078:	e7ec      	b.n	13054 <memcmp+0x3c>
   1307a:	bf00      	nop

0001307c <__malloc_lock>:
   1307c:	4770      	bx	lr
   1307e:	bf00      	nop

00013080 <__malloc_unlock>:
   13080:	4770      	bx	lr
   13082:	bf00      	nop

00013084 <_sbrk_r>:
   13084:	b538      	push	{r3, r4, r5, lr}
   13086:	f64c 34e8 	movw	r4, #52200	; 0xcbe8
   1308a:	f2c2 0400 	movt	r4, #8192	; 0x2000
   1308e:	4605      	mov	r5, r0
   13090:	4608      	mov	r0, r1
   13092:	2300      	movs	r3, #0
   13094:	6023      	str	r3, [r4, #0]
   13096:	f7f4 fcf5 	bl	7a84 <_sbrk>
   1309a:	f1b0 3fff 	cmp.w	r0, #4294967295
   1309e:	d000      	beq.n	130a2 <_sbrk_r+0x1e>
   130a0:	bd38      	pop	{r3, r4, r5, pc}
   130a2:	6823      	ldr	r3, [r4, #0]
   130a4:	2b00      	cmp	r3, #0
   130a6:	d0fb      	beq.n	130a0 <_sbrk_r+0x1c>
   130a8:	602b      	str	r3, [r5, #0]
   130aa:	bd38      	pop	{r3, r4, r5, pc}
   130ac:	00007852 	.word	0x00007852
   130b0:	00005854 	.word	0x00005854
   130b4:	5444454c 	.word	0x5444454c
   130b8:	72656d69 	.word	0x72656d69
   130bc:	00000000 	.word	0x00000000
   130c0:	63656843 	.word	0x63656843
   130c4:	6d69546b 	.word	0x6d69546b
   130c8:	00007265 	.word	0x00007265
   130cc:	00504975 	.word	0x00504975
   130d0:	206c6c41 	.word	0x206c6c41
   130d4:	6b736174 	.word	0x6b736174
   130d8:	75722073 	.word	0x75722073
   130dc:	6e696e6e 	.word	0x6e696e6e
   130e0:	69772067 	.word	0x69772067
   130e4:	756f6874 	.word	0x756f6874
   130e8:	72652074 	.word	0x72652074
   130ec:	00726f72 	.word	0x00726f72
   130f0:	6c756e28 	.word	0x6c756e28
   130f4:	0000296c 	.word	0x0000296c
   130f8:	54505241 	.word	0x54505241
   130fc:	72656d69 	.word	0x72656d69
   13100:	00000000 	.word	0x00000000
   13104:	69726550 	.word	0x69726550
   13108:	6369646f 	.word	0x6369646f
   1310c:	656d6954 	.word	0x656d6954
   13110:	00000072 	.word	0x00000072
   13114:	732e6f69 	.word	0x732e6f69
   13118:	6c6d7468 	.word	0x6c6d7468
   1311c:	00000000 	.word	0x00000000
   13120:	3044454c 	.word	0x3044454c
   13124:	0000313d 	.word	0x0000313d

00013128 <ulARPTimerExpired.4126>:
   13128:	00000004                                ....

0001312c <ulPeriodicTimerExpired.4127>:
   1312c:	00000008 656c6966 6174732d 00007374     ....file-stats..
   1313c:	2d706374 6e6e6f63 69746365 00736e6f     tcp-connections.
   1314c:	2d74656e 74617473 00000073 736f7472     net-stats...rtos
   1315c:	6174732d 00007374 2d6e7572 656d6974     -stats..run-time
   1316c:	00000000 2d64656c 00006f69 00753525     ....led-io..%5u.
   1317c:	3e72743c 3e64743c 2f3c6425 3c3e6474     <tr><td>%d</td><
   1318c:	253e6474 75252e75 2e75252e 253a7525     td>%u.%u.%u.%u:%
   1319c:	742f3c75 743c3e64 73253e64 64742f3c     u</td><td>%s</td
   131ac:	64743c3e 3c75253e 3e64742f 3e64743c     ><td>%u</td><td>
   131bc:	2f3c7525 3c3e6474 253e6474 63252063     %u</td><td>%c %c
   131cc:	64742f3c 742f3c3e 0a0d3e72 00000000     </td></tr>......
   131dc:	0a753525 00000000 3c3e703c 523e7262     %5u.....<p><br>R
   131ec:	65726665 63206873 746e756f 25203d20     efresh count = %
   131fc:	3e703c64 3e72623c 00007325 63656863     d<p><br>%s..chec
   1320c:	0064656b 00000000 706e693c 74207475     ked.....<input t
   1321c:	3d657079 65686322 6f626b63 6e202278     ype="checkbox" n
   1322c:	3d656d61 44454c22 76202230 65756c61     ame="LED0" value
   1323c:	2231223d 3e732520 3c44454c 703c3e70     ="1" %s>LED<p><p
   1324c:	3e703c3e 20776152 746c6f76 20656761     ><p>Raw voltage 
   1325c:	75706e69 73692074 00642520 3c3e703c     input is %d.<p><
   1326c:	523e7262 65726665 63206873 746e756f     br>Refresh count
   1327c:	25203d20 00000064                        = %d...

00013284 <file>:
   13284:	00013130 000018d5                       01......

0001328c <tcp>:
   1328c:	0001313c 00001a69                       <1..i...

00013294 <net>:
   13294:	0001314c 00001b69                       L1..i...

0001329c <rtos>:
   1329c:	00013158 00001c81                       X1......

000132a4 <run>:
   132a4:	00013164 00001e05                       d1......

000132ac <io>:
   132ac:	00013170 00001e6d                       p1..m...

000132b4 <closed>:
   132b4:	534f4c43 00004445                       CLOSED..

000132bc <syn_rcvd>:
   132bc:	2d4e5953 44564352 00000000              SYN-RCVD....

000132c8 <syn_sent>:
   132c8:	2d4e5953 544e4553 00000000              SYN-SENT....

000132d4 <established>:
   132d4:	41545345 53494c42 00444548              ESTABLISHED.

000132e0 <fin_wait_1>:
   132e0:	2d4e4946 54494157 0000312d              FIN-WAIT-1..

000132ec <fin_wait_2>:
   132ec:	2d4e4946 54494157 0000322d              FIN-WAIT-2..

000132f8 <closing>:
   132f8:	534f4c43 00474e49                       CLOSING.

00013300 <time_wait>:
   13300:	454d4954 4941572d 00000054              TIME-WAIT...

0001330c <last_ack>:
   1330c:	5453414c 4b43412d 00000000              LAST-ACK....

00013318 <g_ace_current_resistors>:
   13318:	000186a0 00000001 00000001 00000001     ................
   13328:	00000001                                ....

0001332c <g_ace_channel_0_name>:
   1332c:	72727543 4d746e65 74696e6f 305f726f     CurrentMonitor_0
   1333c:	00000000                                ....

00013340 <g_ace_channel_1_name>:
   13340:	746c6f56 4d656761 74696e6f 305f726f     VoltageMonitor_0
   13350:	00000000                                ....

00013354 <g_ace_channel_2_name>:
   13354:	706d6554 74617265 4d657275 74696e6f     TemperatureMonit
   13364:	305f726f 00000000                       or_0....

0001336c <g_ace_sse_proc_0_name>:
   1336c:	30434441 49414d5f 0000004e              ADC0_MAIN...

00013378 <g_ace_sse_proc_0_sequence>:
   13378:	16011705 14c4155c 152d0000 13098a0c     ....\.....-.....
   13388:	14c30000 8a040000 970c152d 0000132f     ........-.../...
   13398:	000014c8 13019704 10020000              ............

000133a4 <g_ace_sse_proc_1_name>:
   133a4:	31434441 49414d5f 0000004e              ADC1_MAIN...

000133b0 <g_ace_sse_proc_1_sequence>:
   133b0:	26012705 00002200                       .'.&."..

000133b8 <g_ace_sse_proc_2_name>:
   133b8:	32434441 49414d5f 0000004e              ADC2_MAIN...

000133c4 <g_ace_sse_proc_2_sequence>:
   133c4:	36013705 00003200                       .7.6.2..

000133cc <g_config_reg_lut>:
   133cc:	40013000 40013004 40013008 4001300c     .0.@.0.@.0.@.0.@
   133dc:	40013010 40013014 40013018 4001301c     .0.@.0.@.0.@.0.@
   133ec:	40013020 40013024 40013028 4001302c      0.@$0.@(0.@,0.@
   133fc:	40013030 40013034 40013038 4001303c     00.@40.@80.@<0.@
   1340c:	40013040 40013044 40013048 4001304c     @0.@D0.@H0.@L0.@
   1341c:	40013050 40013054 40013058 4001305c     P0.@T0.@X0.@\0.@
   1342c:	40013060 40013064 40013068 4001306c     `0.@d0.@h0.@l0.@
   1343c:	40013070 40013074 40013078 4001307c     p0.@t0.@x0.@|0.@

0001344c <g_gpio_irqn_lut>:
   1344c:	00210020 00230022 00250024 00270026      .!.".#.$.%.&.'.
   1345c:	00290028 002b002a 002d002c 002f002e     (.).*.+.,.-.../.
   1346c:	00310030 00330032 00350034 00370036     0.1.2.3.4.5.6.7.
   1347c:	00390038 003b003a 003d003c 003f003e     8.9.:.;.<.=.>.?.

0001348c <crc32_table>:
   1348c:	00000000 77073096 ee0e612c 990951ba     .....0.w,a...Q..
   1349c:	076dc419 706af48f e963a535 9e6495a3     ..m...jp5.c...d.
   134ac:	0edb8832 79dcb8a4 e0d5e91e 97d2d988     2......y........
   134bc:	09b64c2b 7eb17cbd e7b82d07 90bf1d91     +L...|.~.-......
   134cc:	1db71064 6ab020f2 f3b97148 84be41de     d.... .jHq...A..
   134dc:	1adad47d 6ddde4eb f4d4b551 83d385c7     }......mQ.......
   134ec:	136c9856 646ba8c0 fd62f97a 8a65c9ec     V.l...kdz.b...e.
   134fc:	14015c4f 63066cd9 fa0f3d63 8d080df5     O\...l.cc=......
   1350c:	3b6e20c8 4c69105e d56041e4 a2677172     . n;^.iL.A`.rqg.
   1351c:	3c03e4d1 4b04d447 d20d85fd a50ab56b     ...<G..K....k...
   1352c:	35b5a8fa 42b2986c dbbbc9d6 acbcf940     ...5l..B....@...
   1353c:	32d86ce3 45df5c75 dcd60dcf abd13d59     .l.2u\.E....Y=..
   1354c:	26d930ac 51de003a c8d75180 bfd06116     .0.&:..Q.Q...a..
   1355c:	21b4f4b5 56b3c423 cfba9599 b8bda50f     ...!#..V........
   1356c:	2802b89e 5f058808 c60cd9b2 b10be924     ...(..._....$...
   1357c:	2f6f7c87 58684c11 c1611dab b6662d3d     .|o/.LhX..a.=-f.
   1358c:	76dc4190 01db7106 98d220bc efd5102a     .A.v.q... ..*...
   1359c:	71b18589 06b6b51f 9fbfe4a5 e8b8d433     ...q........3...
   135ac:	7807c9a2 0f00f934 9609a88e e10e9818     ...x4...........
   135bc:	7f6a0dbb 086d3d2d 91646c97 e6635c01     ..j.-=m..ld..\c.
   135cc:	6b6b51f4 1c6c6162 856530d8 f262004e     .Qkkbal..0e.N.b.
   135dc:	6c0695ed 1b01a57b 8208f4c1 f50fc457     ...l{.......W...
   135ec:	65b0d9c6 12b7e950 8bbeb8ea fcb9887c     ...eP.......|...
   135fc:	62dd1ddf 15da2d49 8cd37cf3 fbd44c65     ...bI-...|..eL..
   1360c:	4db26158 3ab551ce a3bc0074 d4bb30e2     Xa.M.Q.:t....0..
   1361c:	4adfa541 3dd895d7 a4d1c46d d3d6f4fb     A..J...=m.......
   1362c:	4369e96a 346ed9fc ad678846 da60b8d0     j.iC..n4F.g...`.
   1363c:	44042d73 33031de5 aa0a4c5f dd0d7cc9     s-.D...3_L...|..
   1364c:	5005713c 270241aa be0b1010 c90c2086     <q.P.A.'..... ..
   1365c:	5768b525 206f85b3 b966d409 ce61e49f     %.hW..o ..f...a.
   1366c:	5edef90e 29d9c998 b0d09822 c7d7a8b4     ...^...)".......
   1367c:	59b33d17 2eb40d81 b7bd5c3b c0ba6cad     .=.Y....;\...l..
   1368c:	edb88320 9abfb3b6 03b6e20c 74b1d29a      ..............t
   1369c:	ead54739 9dd277af 04db2615 73dc1683     9G...w...&.....s
   136ac:	e3630b12 94643b84 0d6d6a3e 7a6a5aa8     ..c..;d.>jm..Zjz
   136bc:	e40ecf0b 9309ff9d 0a00ae27 7d079eb1     ........'......}
   136cc:	f00f9344 8708a3d2 1e01f268 6906c2fe     D.......h......i
   136dc:	f762575d 806567cb 196c3671 6e6b06e7     ]Wb..ge.q6l...kn
   136ec:	fed41b76 89d32be0 10da7a5a 67dd4acc     v....+..Zz...J.g
   136fc:	f9b9df6f 8ebeeff9 17b7be43 60b08ed5     o.......C......`
   1370c:	d6d6a3e8 a1d1937e 38d8c2c4 4fdff252     ....~......8R..O
   1371c:	d1bb67f1 a6bc5767 3fb506dd 48b2364b     .g..gW.....?K6.H
   1372c:	d80d2bda af0a1b4c 36034af6 41047a60     .+..L....J.6`z.A
   1373c:	df60efc3 a867df55 316e8eef 4669be79     ..`.U.g...n1y.iF
   1374c:	cb61b38c bc66831a 256fd2a0 5268e236     ..a...f...o%6.hR
   1375c:	cc0c7795 bb0b4703 220216b9 5505262f     .w...G....."/&.U
   1376c:	c5ba3bbe b2bd0b28 2bb45a92 5cb36a04     .;..(....Z.+.j.\
   1377c:	c2d7ffa7 b5d0cf31 2cd99e8b 5bdeae1d     ....1......,...[
   1378c:	9b64c2b0 ec63f226 756aa39c 026d930a     ..d.&.c...ju..m.
   1379c:	9c0906a9 eb0e363f 72076785 05005713     ....?6...g.r.W..
   137ac:	95bf4a82 e2b87a14 7bb12bae 0cb61b38     .J...z...+.{8...
   137bc:	92d28e9b e5d5be0d 7cdcefb7 0bdbdf21     ...........|!...
   137cc:	86d3d2d4 f1d4e242 68ddb3f8 1fda836e     ....B......hn...
   137dc:	81be16cd f6b9265b 6fb077e1 18b74777     ....[&...w.owG..
   137ec:	88085ae6 ff0f6a70 66063bca 11010b5c     .Z..pj...;.f\...
   137fc:	8f659eff f862ae69 616bffd3 166ccf45     ..e.i.b...kaE.l.
   1380c:	a00ae278 d70dd2ee 4e048354 3903b3c2     x.......T..N...9
   1381c:	a7672661 d06016f7 4969474d 3e6e77db     a&g...`.MGiI.wn>
   1382c:	aed16a4a d9d65adc 40df0b66 37d83bf0     Jj...Z..f..@.;.7
   1383c:	a9bcae53 debb9ec5 47b2cf7f 30b5ffe9     S..........G...0
   1384c:	bdbdf21c cabac28a 53b39330 24b4a3a6     ........0..S...$
   1385c:	bad03605 cdd70693 54de5729 23d967bf     .6......)W.T.g.#
   1386c:	b3667a2e c4614ab8 5d681b02 2a6f2b94     .zf..Ja...h].+o*
   1387c:	b40bbe37 c30c8ea1 5a05df1b 2d02ef8d     7..........Z...-

0001388c <unknown_error>:
   1388c:	6e6b6e55 206e776f 6f727265 00000072     Unknown error...

0001389c <ErrorMessages>:
   1389c:	65206f4e 726f7272 63636f20 64657275     No error occured
	...
   138c4:	6874654d 6620646f 656c6961 00000064     Method failed...
	...
   138ec:	6e6f7257 61702067 656d6172 20726574     Wrong parameter 
   138fc:	65736170 6f742064 6e756620 6f697463     pased to functio
   1390c:	0000006e 00000000 6d617246 73692065     n.......Frame is
   1391c:	6f6f7420 6e6f6c20 00000067 00000000      too long.......
	...
   1393c:	20746f4e 756f6e65 73206867 65636170     Not enough space
   1394c:	206e6920 66667562 00007265 00000000      in buffer......
	...
   13964:	20746f4e 756f6e65 73206867 65636170     Not enough space
   13974:	206e6920 66667562 00007265 00000000      in buffer......
	...
   1398c:	656d6954 756f2064 00000074 00000000     Timed out.......
	...
   139b4:	6d617246 73692065 6f6f7420 616d7320     Frame is too sma
   139c4:	00006c6c 00000000 00000000 00000000     ll..............
	...

000139dc <C.18.3199>:
   139dc:	10131200 00001115                       ........

000139e4 <channel_type_lut>:
   139e4:	01000000 01000002 00000002 00ffff00     ................
   139f4:	01000000 01000002 00000002 00ffff00     ................
   13a04:	01000000 01000002 00000002 00ffff00     ................

00013a14 <channel_quad_lut>:
   13a14:	000000ff 01010100 ffffff01 ffffffff     ................
   13a24:	020202ff 03030302 ffffff03 ffffffff     ................
   13a34:	040404ff 05050504 ffffff05 ffffffff     ................

00013a44 <abps_channel_lut>:
   13a44:	ff0000ff ff0101ff ffffffff ffffffff     ................
   13a54:	ff0202ff ff0303ff ffffffff ffffffff     ................
   13a64:	ff0404ff ff0505ff ffffffff ffffffff     ................

00013a74 <abps_idx_lut>:
   13a74:	ff0100ff ff0302ff ffffffff ffffffff     ................
   13a84:	ff0504ff ff0706ff ffffffff ffffffff     ................
   13a94:	ff0908ff ff0b0aff ffffffff ffffffff     ................

00013aa4 <apbs_gain_lut>:
   13aa4:	0204080c                                ....

00013aa8 <apbs_range>:
   13aa8:	28003c00 0a001400                       .<.(....

00013ab0 <adc_status_reg_lut>:
   13ab0:	40021000 40021004 40021008              ...@...@...@

00013abc <dac_ctrl_reg_lut>:
   13abc:	40020060 400200a0 400200a0              `..@...@...@

00013ac8 <dac_enable_masks_lut>:
   13ac8:	00000010 00000020 00000040              .... ...@...

00013ad4 <dac_byte01_reg_lut>:
   13ad4:	40020500 40020504 40020508              ...@...@...@

00013ae0 <dac_byte2_reg_lut>:
   13ae0:	4002006c 400200ac 400200ec              l..@...@...@

00013aec <p_mtd_data>:
   13aec:	60080010                                ...`

00013af0 <comp_id_2_scb_lut>:
   13af0:	01010000 03030202 05050404              ............

00013afc <C.18.3513>:
   13afc:	00040200                                ....

00013b00 <C.18.2576>:
   13b00:	00000001 00000002 00000004 00000001     ................
   13b10:	70616548 646e6120 61747320 63206b63     Heap and stack c
   13b20:	696c6c6f 6e6f6973 0000000a              ollision....

00013b2c <uip_broadcast_addr>:
   13b2c:	ffffffff                                ....

00013b30 <uip_all_zeroes_addr>:
   13b30:	00000000                                ....

00013b34 <broadcast_ethaddr>:
   13b34:	ffffffff 0000ffff                       ........

00013b3c <http_http>:
   13b3c:	70747468 002f2f3a                       http://.

00013b44 <http_200>:
   13b44:	20303032 00000000                       200 ....

00013b4c <http_301>:
   13b4c:	20313033 00000000                       301 ....

00013b54 <http_302>:
   13b54:	20323033 00000000                       302 ....

00013b5c <http_get>:
   13b5c:	20544547 00000000                       GET ....

00013b64 <http_10>:
   13b64:	50545448 302e312f 00000000              HTTP/1.0....

00013b70 <http_11>:
   13b70:	50545448 312e312f 00000000              HTTP/1.1....

00013b7c <http_content_type>:
   13b7c:	746e6f63 2d746e65 65707974 0000203a     content-type: ..

00013b8c <http_texthtml>:
   13b8c:	74786574 6d74682f 0000006c              text/html...

00013b98 <http_location>:
   13b98:	61636f6c 6e6f6974 0000203a              location: ..

00013ba4 <http_host>:
   13ba4:	74736f68 0000203a                       host: ..

00013bac <http_crnl>:
   13bac:	00000a0d                                ....

00013bb0 <http_index_html>:
   13bb0:	646e692f 682e7865 006c6d74              /index.html.

00013bbc <http_404_html>:
   13bbc:	3430342f 6d74682e 0000006c              /404.html...

00013bc8 <http_referer>:
   13bc8:	65666552 3a726572 00000000              Referer:....

00013bd4 <http_header_200>:
   13bd4:	50545448 302e312f 30303220 0d4b4f20     HTTP/1.0 200 OK.
   13be4:	7265530a 3a726576 50497520 302e312f     .Server: uIP/1.0
   13bf4:	74746820 2f2f3a70 2e777777 73636973      http://www.sics
   13c04:	2f65732e 6164617e 69752f6d 0a0d2f70     .se/~adam/uip/..
   13c14:	6e6e6f43 69746365 203a6e6f 736f6c63     Connection: clos
   13c24:	000a0d65                                e...

00013c28 <http_header_404>:
   13c28:	50545448 302e312f 34303420 746f4e20     HTTP/1.0 404 Not
   13c38:	756f6620 0a0d646e 76726553 203a7265      found..Server: 
   13c48:	2f504975 20302e31 70747468 772f2f3a     uIP/1.0 http://w
   13c58:	732e7777 2e736369 7e2f6573 6d616461     ww.sics.se/~adam
   13c68:	7069752f 430a0d2f 656e6e6f 6f697463     /uip/..Connectio
   13c78:	63203a6e 65736f6c 00000a0d              n: close....

00013c84 <http_content_type_plain>:
   13c84:	746e6f43 2d746e65 65707974 6574203a     Content-type: te
   13c94:	702f7478 6e69616c 0a0d0a0d 00000000     xt/plain........

00013ca4 <http_content_type_html>:
   13ca4:	746e6f43 2d746e65 65707974 6574203a     Content-type: te
   13cb4:	682f7478 0d6c6d74 000a0d0a              xt/html.....

00013cc0 <http_content_type_css>:
   13cc0:	746e6f43 2d746e65 65707974 6574203a     Content-type: te
   13cd0:	632f7478 0a0d7373 00000a0d              xt/css......

00013cdc <http_content_type_text>:
   13cdc:	746e6f43 2d746e65 65707974 6574203a     Content-type: te
   13cec:	742f7478 0d747865 000a0d0a              xt/text.....

00013cf8 <http_content_type_png>:
   13cf8:	746e6f43 2d746e65 65707974 6d69203a     Content-type: im
   13d08:	2f656761 0d676e70 000a0d0a              age/png.....

00013d14 <http_content_type_gif>:
   13d14:	746e6f43 2d746e65 65707974 6d69203a     Content-type: im
   13d24:	2f656761 0d666967 000a0d0a              age/gif.....

00013d30 <http_content_type_jpg>:
   13d30:	746e6f43 2d746e65 65707974 6d69203a     Content-type: im
   13d40:	2f656761 6765706a 0a0d0a0d 00000000     age/jpeg........

00013d50 <http_content_type_binary>:
   13d50:	746e6f43 2d746e65 65707974 7061203a     Content-type: ap
   13d60:	63696c70 6f697461 636f2f6e 2d746574     plication/octet-
   13d70:	65727473 0a0d6d61 00000a0d              stream......

00013d7c <http_html>:
   13d7c:	6d74682e 0000006c                       .html...

00013d84 <http_shtml>:
   13d84:	7468732e 00006c6d                       .shtml..

00013d8c <http_htm>:
   13d8c:	6d74682e 00000000                       .htm....

00013d94 <http_css>:
   13d94:	7373632e 00000000                       .css....

00013d9c <http_png>:
   13d9c:	676e702e 00000000                       .png....

00013da4 <http_gif>:
   13da4:	6669672e 00000000                       .gif....

00013dac <http_jpg>:
   13dac:	67706a2e 00000000                       .jpg....

00013db4 <http_text>:
   13db4:	7478742e 00000000                       .txt....

00013dbc <http_txt>:
   13dbc:	7478742e 00000000                       .txt....

00013dc4 <data_404_html>:
   13dc4:	3430342f 6d74682e 683c006c 3e6c6d74     /404.html.<html>
   13dd4:	20200a0d 646f623c 67622079 6f6c6f63     ..  <body bgcolo
   13de4:	77223d72 65746968 0a0d3e22 20202020     r="white">..    
   13df4:	6e65633c 3e726574 20200a0d 20202020     <center>..      
   13e04:	3e31683c 20343034 6966202d 6e20656c     <h1>404 - file n
   13e14:	6620746f 646e756f 31682f3c 200a0d3e     ot found</h1>.. 
   13e24:	20202020 33683c20 206f473e 6820613c          <h3>Go <a h
   13e34:	3d666572 3e222f22 65726568 3e612f3c     ref="/">here</a>
   13e44:	736e6920 64616574 682f3c2e 0a0d3e33      instead.</h3>..
   13e54:	20202020 65632f3c 7265746e 200a0d3e         </center>.. 
   13e64:	622f3c20 3e79646f 2f3c0a0d 6c6d7468      </body>..</html
   13e74:	0000003e                                >...

00013e78 <data_index_html>:
   13e78:	646e692f 682e7865 006c6d74 4f44213c     /index.html.<!DO
   13e88:	50595443 74682045 0d3e6c6d 74683c0a     CTYPE html>..<ht
   13e98:	0d3e6c6d 3c0a0d0a 64616568 200a0d3e     ml>....<head>.. 
   13ea8:	3c202020 6174656d 74746820 71652d70        <meta http-eq
   13eb8:	3d766975 6e6f4322 746e6574 7079542d     uiv="Content-Typ
   13ec8:	63202265 65746e6f 223d746e 74786574     e" content="text
   13ed8:	6d74682f 63203b6c 73726168 753d7465     /html; charset=u
   13ee8:	382d6674 3e2f2022 20200a0d 743c2020     tf-8" />..    <t
   13ef8:	656c7469 6572463e 4f545265 726f2e53     itle>FreeRTOS.or
   13f08:	49752067 45572050 65732042 72657672     g uIP WEB server
   13f18:	6d656420 742f3c6f 656c7469 3c0a0d3e      demo</title>..<
   13f28:	6165682f 0a0d3e64 623c0a0d 3e79646f     /head>....<body>
   13f38:	0a0d0a0d 20202020 6820613c 3d666572     ....    <a href=
   13f48:	646e6922 682e7865 226c6d74 7361543e     "index.html">Tas
   13f58:	7453206b 73737461 3c737373 203e612f     k Statsssss</a> 
   13f68:	7c3e623c 3e622f3c 20613c20 66657268     <b>|</b> <a href
   13f78:	7572223d 6d69746e 68732e65 226c6d74     ="runtime.shtml"
   13f88:	6e75523e 6d695420 74532065 3c737461     >Run Time Stats<
   13f98:	203e612f 7c3e623c 3e622f3c 20613c20     /a> <b>|</b> <a 
   13fa8:	66657268 7473223d 2e737461 6d746873     href="stats.shtm
   13fb8:	543e226c 53205043 73746174 3e612f3c     l">TCP Stats</a>
   13fc8:	3e623c20 622f3c7c 613c203e 65726820      <b>|</b> <a hre
   13fd8:	74223d66 732e7063 6c6d7468 6f433e22     f="tcp.shtml">Co
   13fe8:	63656e6e 6e6f6974 612f3c73 623c203e     nnections</a> <b
   13ff8:	2f3c7c3e 3c203e62 72682061 223d6665     >|</b> <a href="
   14008:	70747468 772f2f3a 662e7777 72656572     http://www.freer
   14018:	2e736f74 2f67726f 72463e22 54526565     tos.org/">FreeRT
   14028:	4820534f 70656d6f 3c656761 203e612f     OS Homepage</a> 
   14038:	3c202020 3c7c3e62 203e622f 6820613c        <b>|</b> <a h
   14048:	3d666572 2e6f6922 6d746873 493e226c     ref="io.shtml">I
   14058:	612f3c4f 623c203e 2f3c7c3e 3c203e62     O</a> <b>|</b> <
   14068:	72682061 223d6665 6f676f6c 67706a2e     a href="logo.jpg
   14078:	37333e22 706a204b 612f3c67 200a0d3e     ">37K jpg</a>.. 
   14088:	3c202020 0d3e7262 2020200a 3e703c20        <br>..    <p>
   14098:	20200a0d 20202020 683c2020 0a0d3e72     ..        <hr>..
   140a8:	20202020 20202020 3e72623c 20200a0d             <br>..  
   140b8:	20202020 703c2020 0d0a0d3e 2020200a           <p>....   
   140c8:	20202020 20202020 3e703c20 73696854              <p>This
   140d8:	67617020 73692065 6d697320 72616c69      page is similar
   140e8:	206f7420 20656874 656d6f68 67617020      to the home pag
   140f8:	75622065 73752074 57207365 6f536265     e but uses WebSo
   14108:	74656b63 6f662073 65722072 742d6c61     ckets for real-t
   14118:	20656d69 61647075 2e736574 3e702f3c     ime updates.</p>
   14128:	20200a0d 20202020 20202020 643c2020     ..            <d
   14138:	63207669 7373616c 6f63223d 22726576     iv class="cover"
   14148:	200a0d3e 20202020 20202020 20202020     >..             
   14158:	3c202020 766e6163 69207361 63223d64        <canvas id="c
   14168:	74726168 766e6143 20227361 74646977     hartCanvas" widt
   14178:	35223d68 20223231 67696568 223d7468     h="512" height="
   14188:	22303031 632f3c3e 61766e61 0a0d3e73     100"></canvas>..
   14198:	20202020 20202020 20202020 69642f3c                 </di
   141a8:	0a0d3e76 20200a0d 20202020 20202020     v>....          
   141b8:	683c2020 61543e32 73206b73 69746174       <h2>Task stati
   141c8:	63697473 64652073 64657469 32682f3c     stics edited</h2
   141d8:	200a0d3e 20202020 20202020 3c202020     >..            <
   141e8:	69726373 0d3e7470 2020200a 20202020     script>..       
   141f8:	20202020 20202020 66202120 74636e75              ! funct
   14208:	286e6f69 7b202965 20200a0d 20202020     ion(e) {..      
   14218:	20202020 20202020 20202020 61762020                   va
   14228:	20742072 0d7b203d 2020200a 20202020     r t = {..       
   14238:	20202020 20202020 20202020 20202020                     
   14248:	74786520 3a646e65 6e756620 6f697463      extend: functio
   14258:	2029286e 200a0d7b 20202020 20202020     n() {..         
   14268:	20202020 20202020 20202020 20202020                     
   14278:	61202020 6d756772 73746e65 205d305b        arguments[0] 
   14288:	7261203d 656d7567 5b73746e 7c205d30     = arguments[0] |
   14298:	7d7b207c 200a0d3b 20202020 20202020     | {};..         
   142a8:	20202020 20202020 20202020 20202020                     
   142b8:	66202020 2820726f 20726176 203d2065        for (var e = 
   142c8:	65203b31 61203c20 6d756772 73746e65     1; e < arguments
   142d8:	6e656c2e 3b687467 2b206520 2931203d     .length; e += 1)
   142e8:	20200a0d 20202020 20202020 20202020     ..              
   142f8:	20202020 20202020 20202020 20202020                     
   14308:	6f662020 76282072 69207261 206e6920       for (var i in 
   14318:	75677261 746e656d 5d655b73 72612029     arguments[e]) ar
   14328:	656d7567 5b73746e 682e5d65 774f7361     guments[e].hasOw
   14338:	6f72506e 74726570 29692879 20262620     nProperty(i) && 
   14348:	626f2228 7463656a 3d3d2022 70797420     ("object" == typ
   14358:	20666f65 75677261 746e656d 5d655b73     eof arguments[e]
   14368:	205d695b 7261203f 656d7567 5b73746e     [i] ? arguments[
   14378:	695b5d65 6e69205d 6e617473 666f6563     e][i] instanceof
   14388:	72724120 3f207961 67726120 6e656d75      Array ? argumen
   14398:	305b7374 5d695b5d 61203d20 6d756772     ts[0][i] = argum
   143a8:	73746e65 5b5d655b 3a205d69 67726120     ents[e][i] : arg
   143b8:	6e656d75 305b7374 5d695b5d 74203d20     uments[0][i] = t
   143c8:	7478652e 28646e65 75677261 746e656d     .extend(argument
   143d8:	5d305b73 2c5d695b 67726120 6e656d75     s[0][i], argumen
   143e8:	655b7374 5d695b5d 203a2029 75677261     ts[e][i]) : argu
   143f8:	746e656d 5d305b73 205d695b 7261203d     ments[0][i] = ar
   14408:	656d7567 5b73746e 695b5d65 0d3b295d     guments[e][i]);.
   14418:	2020200a 20202020 20202020 20202020     .               
   14428:	20202020 20202020 20202020 74657220                  ret
   14438:	206e7275 75677261 746e656d 5d305b73     urn arguments[0]
   14448:	20200a0d 20202020 20202020 20202020     ..              
   14458:	20202020 20202020 0d7d2020 2020200a               }..   
   14468:	20202020 20202020 20202020 20202020                     
   14478:	0d3b7d20 200a0d0a 20202020 20202020      };....         
   14488:	20202020 20202020 66202020 74636e75                funct
   14498:	206e6f69 29652869 0a0d7b20 20202020     ion i(e) {..    
   144a8:	20202020 20202020 20202020 20202020                     
   144b8:	20202020 73696874 74706f2e 736e6f69         this.options
   144c8:	74203d20 7478652e 28646e65 202c7d7b      = t.extend({}, 
   144d8:	65642e69 6c756166 74704f74 736e6f69     i.defaultOptions
   144e8:	2965202c 6874202c 632e7369 7261656c     , e), this.clear
   144f8:	0a0d2928 20202020 20202020 20202020     ()..            
   14508:	20202020 20202020 0d0a0d7d 2020200a             }....   
   14518:	20202020 20202020 20202020 20202020                     
   14528:	6e756620 6f697463 2861206e 7b202965      function a(e) {
   14538:	20200a0d 20202020 20202020 20202020     ..              
   14548:	20202020 20202020 68742020 6f2e7369               this.o
   14558:	6f697470 3d20736e 652e7420 6e657478     ptions = t.exten
   14568:	7d7b2864 2e61202c 61666564 43746c75     d({}, a.defaultC
   14578:	74726168 6974704f 2c736e6f 2c296520     hartOptions, e),
   14588:	69687420 65732e73 73656972 20746553      this.seriesSet 
   14598:	5d5b203d 6874202c 632e7369 65727275     = [], this.curre
   145a8:	6156746e 5265756c 65676e61 31203d20     ntValueRange = 1
   145b8:	6874202c 632e7369 65727275 6956746e     , this.currentVi
   145c8:	6e694d73 756c6156 203d2065 74202c30     sMinValue = 0, t
   145d8:	2e736968 7473616c 646e6552 69547265     his.lastRenderTi
   145e8:	694d656d 73696c6c 30203d20 20200a0d     meMillis = 0..  
   145f8:	20202020 20202020 20202020 20202020                     
   14608:	0d7d2020 2020200a 20202020 20202020       }..           
   14618:	20202020 20202020 642e6920 75616665              i.defau
   14628:	704f746c 6e6f6974 203d2073 200a0d7b     ltOptions = {.. 
   14638:	20202020 20202020 20202020 20202020                     
   14648:	20202020 72202020 74657365 6e756f42            resetBoun
   14658:	6e497364 76726574 203a6c61 2c336533     dsInterval: 3e3,
   14668:	20200a0d 20202020 20202020 20202020     ..              
   14678:	20202020 20202020 65722020 42746573               resetB
   14688:	646e756f 21203a73 200a0d30 20202020     ounds: !0..     
   14698:	20202020 20202020 20202020 7d202020                    }
   146a8:	2e69202c 746f7270 7079746f 6c632e65     , i.prototype.cl
   146b8:	20726165 7566203d 6974636e 29286e6f     ear = function()
   146c8:	0a0d7b20 20202020 20202020 20202020      {..            
   146d8:	20202020 20202020 20202020 73696874                 this
   146e8:	7461642e 203d2061 202c5d5b 73696874     .data = [], this
   146f8:	78616d2e 756c6156 203d2065 626d754e     .maxValue = Numb
   14708:	4e2e7265 202c4e61 73696874 6e696d2e     er.NaN, this.min
   14718:	756c6156 203d2065 626d754e 4e2e7265     Value = Number.N
   14728:	0a0d4e61 20202020 20202020 20202020     aN..            
   14738:	20202020 20202020 69202c7d 6f72702e             }, i.pro
   14748:	79746f74 722e6570 74657365 6e756f42     totype.resetBoun
   14758:	3d207364 6e756620 6f697463 2029286e     ds = function() 
   14768:	200a0d7b 20202020 20202020 20202020     {..             
   14778:	20202020 20202020 69202020 74282066                if (t
   14788:	2e736968 61746164 6e656c2e 29687467     his.data.length)
   14798:	0a0d7b20 20202020 20202020 20202020      {..            
   147a8:	20202020 20202020 20202020 20202020                     
   147b8:	73696874 78616d2e 756c6156 203d2065     this.maxValue = 
   147c8:	73696874 7461642e 5d305b61 2c5d315b     this.data[0][1],
   147d8:	69687420 696d2e73 6c61566e 3d206575      this.minValue =
   147e8:	69687420 61642e73 305b6174 5d315b5d      this.data[0][1]
   147f8:	200a0d3b 20202020 20202020 20202020     ;..             
   14808:	20202020 20202020 20202020 66202020                    f
   14818:	2820726f 20726176 203d2065 65203b31     or (var e = 1; e
   14828:	74203c20 2e736968 61746164 6e656c2e      < this.data.len
   14838:	3b687467 2b206520 2931203d 0a0d7b20     gth; e += 1) {..
   14848:	20202020 20202020 20202020 20202020                     
   14858:	20202020 20202020 20202020 20202020                     
   14868:	20726176 203d2074 73696874 7461642e     var t = this.dat
   14878:	5d655b61 3b5d315b 20200a0d 20202020     a[e][1];..      
   14888:	20202020 20202020 20202020 20202020                     
   14898:	20202020 20202020 20742020 6874203e               t > th
   148a8:	6d2e7369 61567861 2065756c 28202626     is.maxValue && (
   148b8:	73696874 78616d2e 756c6156 203d2065     this.maxValue = 
   148c8:	202c2974 203c2074 73696874 6e696d2e     t), t < this.min
   148d8:	756c6156 26262065 68742820 6d2e7369     Value && (this.m
   148e8:	61566e69 2065756c 2974203d 20200a0d     inValue = t)..  
   148f8:	20202020 20202020 20202020 20202020                     
   14908:	20202020 20202020 0d7d2020 2020200a               }..   
   14918:	20202020 20202020 20202020 20202020                     
   14928:	20202020 65207d20 2065736c 73696874          } else this
   14938:	78616d2e 756c6156 203d2065 626d754e     .maxValue = Numb
   14948:	4e2e7265 202c4e61 73696874 6e696d2e     er.NaN, this.min
   14958:	756c6156 203d2065 626d754e 4e2e7265     Value = Number.N
   14968:	0a0d4e61 20202020 20202020 20202020     aN..            
   14978:	20202020 20202020 69202c7d 6f72702e             }, i.pro
   14988:	79746f74 612e6570 6e657070 203d2064     totype.append = 
   14998:	636e7566 6e6f6974 202c6528 69202c74     function(e, t, i
   149a8:	0d7b2029 2020200a 20202020 20202020     ) {..           
   149b8:	20202020 20202020 20202020 726f6620                  for
   149c8:	61762820 20612072 6874203d 642e7369      (var a = this.d
   149d8:	2e617461 676e656c 2d206874 203b3120     ata.length - 1; 
   149e8:	3d3e2061 26203020 68742026 642e7369     a >= 0 && this.d
   149f8:	5b617461 305b5d61 203e205d 20293b65     ata[a][0] > e;) 
   14a08:	3d2d2061 203b3120 2031202d 203d3d3d     a -= 1; - 1 === 
   14a18:	203f2061 73696874 7461642e 70732e61     a ? this.data.sp
   14a28:	6563696c 202c3028 5b202c30 74202c65     lice(0, 0, [e, t
   14a38:	3a20295d 69687420 61642e73 6c2e6174     ]) : this.data.l
   14a48:	74676e65 203e2068 26262030 69687420     ength > 0 && thi
   14a58:	61642e73 615b6174 5d305b5d 3d3d3d20     s.data[a][0] ===
   14a68:	3f206520 3f206920 68742820 642e7369      e ? i ? (this.d
   14a78:	5b617461 315b5d61 3d2b205d 202c7420     ata[a][1] += t, 
   14a88:	203d2074 73696874 7461642e 5d615b61     t = this.data[a]
   14a98:	295d315b 74203a20 2e736968 61746164     [1]) : this.data
   14aa8:	5b5d615b 3d205d31 3a207420 3c206120     [a][1] = t : a <
   14ab8:	69687420 61642e73 6c2e6174 74676e65      this.data.lengt
   14ac8:	202d2068 203f2031 73696874 7461642e     h - 1 ? this.dat
   14ad8:	70732e61 6563696c 2b206128 202c3120     a.splice(a + 1, 
   14ae8:	5b202c30 74202c65 3a20295d 69687420     0, [e, t]) : thi
   14af8:	61642e73 702e6174 28687375 202c655b     s.data.push([e, 
   14b08:	2c295d74 69687420 616d2e73 6c615678     t]), this.maxVal
   14b18:	3d206575 4e736920 74284e61 2e736968     ue = isNaN(this.
   14b28:	5678616d 65756c61 203f2029 203a2074     maxValue) ? t : 
   14b38:	6874614d 78616d2e 69687428 616d2e73     Math.max(this.ma
   14b48:	6c615678 202c6575 202c2974 73696874     xValue, t), this
   14b58:	6e696d2e 756c6156 203d2065 614e7369     .minValue = isNa
   14b68:	6874284e 6d2e7369 61566e69 2965756c     N(this.minValue)
   14b78:	74203f20 4d203a20 2e687461 286e696d      ? t : Math.min(
   14b88:	73696874 6e696d2e 756c6156 74202c65     this.minValue, t
   14b98:	200a0d29 20202020 20202020 20202020     )..             
   14ba8:	20202020 7d202020 2e69202c 746f7270            }, i.prot
   14bb8:	7079746f 72642e65 6c4f706f 74614464     otype.dropOldDat
   14bc8:	203d2061 636e7566 6e6f6974 202c6528     a = function(e, 
   14bd8:	7b202974 20200a0d 20202020 20202020     t) {..          
   14be8:	20202020 20202020 20202020 6f662020                   fo
   14bf8:	76282072 69207261 30203d20 6874203b     r (var i = 0; th
   14c08:	642e7369 2e617461 676e656c 2d206874     is.data.length -
   14c18:	3e206920 2074203d 74202626 2e736968      i >= t && this.
   14c28:	61746164 2b20695b 5b5d3120 3c205d30     data[i + 1][0] <
   14c38:	293b6520 2b206920 3b31203d 20200a0d      e;) i += 1;..  
   14c48:	20202020 20202020 20202020 20202020                     
   14c58:	20202020 20302020 203d3d21 26262069           0 !== i &&
   14c68:	69687420 61642e73 732e6174 63696c70      this.data.splic
   14c78:	2c302865 0d296920 2020200a 20202020     e(0, i)..       
   14c88:	20202020 20202020 20202020 202c7d20                  }, 
   14c98:	65642e61 6c756166 61684374 704f7472     a.defaultChartOp
   14ca8:	6e6f6974 203d2073 200a0d7b 20202020     tions = {..     
   14cb8:	20202020 20202020 20202020 20202020                     
   14cc8:	6d202020 696c6c69 72655073 65786950        millisPerPixe
   14cd8:	32203a6c 0a0d2c30 20202020 20202020     l: 20,..        
   14ce8:	20202020 20202020 20202020 20202020                     
   14cf8:	62616e65 7044656c 61635369 676e696c     enableDpiScaling
   14d08:	3021203a 200a0d2c 20202020 20202020     : !0,..         
   14d18:	20202020 20202020 20202020 79202020                    y
   14d28:	466e694d 616d726f 72657474 7566203a     MinFormatter: fu
   14d38:	6974636e 65286e6f 2974202c 0a0d7b20     nction(e, t) {..
   14d48:	20202020 20202020 20202020 20202020                     
   14d58:	20202020 20202020 20202020 75746572                 retu
   14d68:	70206e72 65737261 616f6c46 29652874     rn parseFloat(e)
   14d78:	466f742e 64657869 0d297428 2020200a     .toFixed(t)..   
   14d88:	20202020 20202020 20202020 20202020                     
   14d98:	20202020 0d2c7d20 2020200a 20202020          },..       
   14da8:	20202020 20202020 20202020 20202020                     
   14db8:	614d7920 726f4678 7474616d 203a7265      yMaxFormatter: 
   14dc8:	636e7566 6e6f6974 202c6528 7b202974     function(e, t) {
   14dd8:	20200a0d 20202020 20202020 20202020     ..              
   14de8:	20202020 20202020 20202020 65722020                   re
   14df8:	6e727574 72617020 6c466573 2874616f     turn parseFloat(
   14e08:	742e2965 7869466f 74286465 200a0d29     e).toFixed(t).. 
   14e18:	20202020 20202020 20202020 20202020                     
   14e28:	20202020 7d202020 200a0d2c 20202020            },..     
   14e38:	20202020 20202020 20202020 20202020                     
   14e48:	6d202020 61567861 5365756c 656c6163        maxValueScale
   14e58:	2c31203a 20200a0d 20202020 20202020     : 1,..          
   14e68:	20202020 20202020 20202020 696d2020                   mi
   14e78:	6c61566e 63536575 3a656c61 0d2c3120     nValueScale: 1,.
   14e88:	2020200a 20202020 20202020 20202020     .               
   14e98:	20202020 20202020 746e6920 6f707265              interpo
   14ea8:	6974616c 203a6e6f 7a656222 22726569     lation: "bezier"
   14eb8:	200a0d2c 20202020 20202020 20202020     ,..             
   14ec8:	20202020 20202020 73202020 656c6163                scale
   14ed8:	6f6f6d53 6e696874 2e203a67 2c353231     Smoothing: .125,
   14ee8:	20200a0d 20202020 20202020 20202020     ..              
   14ef8:	20202020 20202020 616d2020 74614478               maxDat
   14f08:	74655361 676e654c 203a6874 0a0d2c32     aSetLength: 2,..
   14f18:	20202020 20202020 20202020 20202020                     
   14f28:	20202020 20202020 6f726373 61426c6c             scrollBa
   14f38:	61776b63 3a736472 2c312120 20200a0d     ckwards: !1,..  
   14f48:	20202020 20202020 20202020 20202020                     
   14f58:	20202020 72672020 203a6469 200a0d7b           grid: {.. 
   14f68:	20202020 20202020 20202020 20202020                     
   14f78:	20202020 20202020 66202020 536c6c69                fillS
   14f88:	656c7974 2322203a 30303030 2c223030     tyle: "#000000",
   14f98:	20200a0d 20202020 20202020 20202020     ..              
   14fa8:	20202020 20202020 20202020 74732020                   st
   14fb8:	656b6f72 6c797453 22203a65 37373723     rokeStyle: "#777
   14fc8:	22373737 200a0d2c 20202020 20202020     777",..         
   14fd8:	20202020 20202020 20202020 20202020                     
   14fe8:	6c202020 57656e69 68746469 2c31203a        lineWidth: 1,
   14ff8:	20200a0d 20202020 20202020 20202020     ..              
   15008:	20202020 20202020 20202020 68732020                   sh
   15018:	4c707261 73656e69 3121203a 200a0d2c     arpLines: !1,.. 
   15028:	20202020 20202020 20202020 20202020                     
   15038:	20202020 20202020 6d202020 696c6c69                milli
   15048:	72655073 656e694c 6531203a 0a0d2c33     sPerLine: 1e3,..
   15058:	20202020 20202020 20202020 20202020                     
   15068:	20202020 20202020 20202020 74726576                 vert
   15078:	6c616369 74636553 736e6f69 2c32203a     icalSections: 2,
   15088:	20200a0d 20202020 20202020 20202020     ..              
   15098:	20202020 20202020 20202020 6f622020                   bo
   150a8:	72656472 69736956 3a656c62 0d302120     rderVisible: !0.
   150b8:	2020200a 20202020 20202020 20202020     .               
   150c8:	20202020 20202020 0d2c7d20 2020200a              },..   
   150d8:	20202020 20202020 20202020 20202020                     
   150e8:	20202020 62616c20 3a736c65 0a0d7b20          labels: {..
   150f8:	20202020 20202020 20202020 20202020                     
   15108:	20202020 20202020 20202020 6c6c6966                 fill
   15118:	6c797453 22203a65 66666623 22666666     Style: "#ffffff"
   15128:	200a0d2c 20202020 20202020 20202020     ,..             
   15138:	20202020 20202020 20202020 64202020                    d
   15148:	62617369 3a64656c 2c312120 20200a0d     isabled: !1,..  
   15158:	20202020 20202020 20202020 20202020                     
   15168:	20202020 20202020 6f662020 6953746e               fontSi
   15178:	203a657a 0d2c3031 2020200a 20202020     ze: 10,..       
   15188:	20202020 20202020 20202020 20202020                     
   15198:	20202020 6e6f6620 6d614674 3a796c69          fontFamily:
   151a8:	6f6d2220 70736f6e 22656361 200a0d2c      "monospace",.. 
   151b8:	20202020 20202020 20202020 20202020                     
   151c8:	20202020 20202020 70202020 69636572                preci
   151d8:	6e6f6973 0d32203a 2020200a 20202020     sion: 2..       
   151e8:	20202020 20202020 20202020 20202020                     
   151f8:	0d2c7d20 2020200a 20202020 20202020      },..           
   15208:	20202020 20202020 20202020 726f6820                  hor
   15218:	6e6f7a69 4c6c6174 73656e69 5d5b203a     izontalLines: []
   15228:	20200a0d 20202020 20202020 20202020     ..              
   15238:	20202020 2c7d2020 412e6120 616d696e           }, a.Anima
   15248:	6f436574 7461706d 6c696269 20797469     teCompatibility 
   15258:	0d7b203d 2020200a 20202020 20202020     = {..           
   15268:	20202020 20202020 20202020 71657220                  req
   15278:	74736575 6d696e41 6f697461 6172466e     uestAnimationFra
   15288:	203a656d 636e7566 6e6f6974 202c6528     me: function(e, 
   15298:	7b202974 20200a0d 20202020 20202020     t) {..          
   152a8:	20202020 20202020 20202020 20202020                     
   152b8:	65722020 6e727574 69772820 776f646e       return (window
   152c8:	7165722e 74736575 6d696e41 6f697461     .requestAnimatio
   152d8:	6172466e 7c20656d 6977207c 776f646e     nFrame || window
   152e8:	6265772e 5274696b 65757165 6e417473     .webkitRequestAn
   152f8:	74616d69 466e6f69 656d6172 207c7c20     imationFrame || 
   15308:	646e6977 6d2e776f 65527a6f 73657571     window.mozReques
   15318:	696e4174 6974616d 72466e6f 20656d61     tAnimationFrame 
   15328:	77207c7c 6f646e69 526f2e77 65757165     || window.oReque
   15338:	6e417473 74616d69 466e6f69 656d6172     stAnimationFrame
   15348:	207c7c20 646e6977 6d2e776f 71655273      || window.msReq
   15358:	74736575 6d696e41 6f697461 6172466e     uestAnimationFra
   15368:	7c20656d 7566207c 6974636e 65286e6f     me || function(e
   15378:	0d7b2029 2020200a 20202020 20202020     ) {..           
   15388:	20202020 20202020 20202020 20202020                     
   15398:	20202020 74657220 206e7275 646e6977          return wind
   153a8:	732e776f 69547465 756f656d 75662874     ow.setTimeout(fu
   153b8:	6974636e 29286e6f 0a0d7b20 20202020     nction() {..    
   153c8:	20202020 20202020 20202020 20202020                     
   153d8:	20202020 20202020 20202020 20202020                     
   153e8:	6e282865 44207765 29657461 7465672e     e((new Date).get
   153f8:	656d6954 0d292928 2020200a 20202020     Time())..       
   15408:	20202020 20202020 20202020 20202020                     
   15418:	20202020 20202020 202c7d20 0d293631              }, 16).
   15428:	2020200a 20202020 20202020 20202020     .               
   15438:	20202020 20202020 20202020 2e297d20                  }).
   15448:	6c6c6163 6e697728 2c776f64 202c6520     call(window, e, 
   15458:	0a0d2974 20202020 20202020 20202020     t)..            
   15468:	20202020 20202020 20202020 0a0d2c7d                 },..
   15478:	20202020 20202020 20202020 20202020                     
   15488:	20202020 20202020 636e6163 6e416c65             cancelAn
   15498:	74616d69 466e6f69 656d6172 7566203a     imationFrame: fu
   154a8:	6974636e 65286e6f 0d7b2029 2020200a     nction(e) {..   
   154b8:	20202020 20202020 20202020 20202020                     
   154c8:	20202020 20202020 74657220 206e7275              return 
   154d8:	6e697728 2e776f64 636e6163 6e416c65     (window.cancelAn
   154e8:	74616d69 466e6f69 656d6172 207c7c20     imationFrame || 
   154f8:	636e7566 6e6f6974 20296528 200a0d7b     function(e) {.. 
   15508:	20202020 20202020 20202020 20202020                     
   15518:	20202020 20202020 20202020 63202020                    c
   15528:	7261656c 656d6954 2874756f 0a0d2965     learTimeout(e)..
   15538:	20202020 20202020 20202020 20202020                     
   15548:	20202020 20202020 20202020 632e297d                 }).c
   15558:	286c6c61 646e6977 202c776f 0a0d2965     all(window, e)..
   15568:	20202020 20202020 20202020 20202020                     
   15578:	20202020 20202020 200a0d7d 20202020             }..     
   15588:	20202020 20202020 20202020 7d202020                    }
   15598:	2e61202c 61666564 53746c75 65697265     , a.defaultSerie
   155a8:	65725073 746e6573 6f697461 74704f6e     sPresentationOpt
   155b8:	736e6f69 7b203d20 20200a0d 20202020     ions = {..      
   155c8:	20202020 20202020 20202020 20202020                     
   155d8:	696c2020 6957656e 3a687464 0d2c3120       lineWidth: 1,.
   155e8:	2020200a 20202020 20202020 20202020     .               
   155f8:	20202020 20202020 72747320 53656b6f              strokeS
   15608:	656c7974 2322203a 66666666 0d226666     tyle: "#ffffff".
   15618:	2020200a 20202020 20202020 20202020     .               
   15628:	20202020 202c7d20 72702e61 746f746f          }, a.protot
   15638:	2e657079 54646461 53656d69 65697265     ype.addTimeSerie
   15648:	203d2073 636e7566 6e6f6974 202c6528     s = function(e, 
   15658:	7b202969 20200a0d 20202020 20202020     i) {..          
   15668:	20202020 20202020 20202020 68742020                   th
   15678:	732e7369 65697265 74655373 7375702e     is.seriesSet.pus
   15688:	0d7b2868 2020200a 20202020 20202020     h({..           
   15698:	20202020 20202020 20202020 20202020                     
   156a8:	6d697420 72655365 3a736569 0d2c6520      timeSeries: e,.
   156b8:	2020200a 20202020 20202020 20202020     .               
   156c8:	20202020 20202020 20202020 74706f20                  opt
   156d8:	736e6f69 2e74203a 65747865 7b28646e     ions: t.extend({
   156e8:	61202c7d 6665642e 746c7561 69726553     }, a.defaultSeri
   156f8:	72507365 6e657365 69746174 704f6e6f     esPresentationOp
   15708:	6e6f6974 69202c73 200a0d29 20202020     tions, i)..     
   15718:	20202020 20202020 20202020 20202020                     
   15728:	7d202020 65202c29 74706f2e 736e6f69        }), e.options
   15738:	7365722e 6f427465 73646e75 20262620     .resetBounds && 
   15748:	706f2e65 6e6f6974 65722e73 42746573     e.options.resetB
   15758:	646e756f 746e4973 61767265 203e206c     oundsInterval > 
   15768:	26262030 2e652820 65736572 756f4274     0 && (e.resetBou
   15778:	5473646e 72656d69 3d206449 74657320     ndsTimerId = set
   15788:	65746e49 6c617672 6e756628 6f697463     Interval(functio
   15798:	2029286e 200a0d7b 20202020 20202020     n() {..         
   157a8:	20202020 20202020 20202020 20202020                     
   157b8:	65202020 7365722e 6f427465 73646e75        e.resetBounds
   157c8:	0a0d2928 20202020 20202020 20202020     ()..            
   157d8:	20202020 20202020 20202020 65202c7d                 }, e
   157e8:	74706f2e 736e6f69 7365722e 6f427465     .options.resetBo
   157f8:	73646e75 65746e49 6c617672 0a0d2929     undsInterval))..
   15808:	20202020 20202020 20202020 20202020                     
   15818:	20202020 61202c7d 6f72702e 79746f74         }, a.prototy
   15828:	722e6570 766f6d65 6d695465 72655365     pe.removeTimeSer
   15838:	20736569 7566203d 6974636e 65286e6f     ies = function(e
   15848:	0d7b2029 2020200a 20202020 20202020     ) {..           
   15858:	20202020 20202020 20202020 726f6620                  for
   15868:	61762820 20742072 6874203d 732e7369      (var t = this.s
   15878:	65697265 74655373 6e656c2e 2c687467     eriesSet.length,
   15888:	3d206920 203b3020 203c2069 69203b74      i = 0; i < t; i
   15898:	203d2b20 0a0d2931 20202020 20202020      += 1)..        
   158a8:	20202020 20202020 20202020 20202020                     
   158b8:	20202020 28206669 73696874 7265732e         if (this.ser
   158c8:	53736569 695b7465 69742e5d 6553656d     iesSet[i].timeSe
   158d8:	73656972 3d3d3d20 20296520 200a0d7b     ries === e) {.. 
   158e8:	20202020 20202020 20202020 20202020                     
   158f8:	20202020 20202020 20202020 74202020                    t
   15908:	2e736968 69726573 65537365 70732e74     his.seriesSet.sp
   15918:	6563696c 202c6928 0d3b2931 2020200a     lice(i, 1);..   
   15928:	20202020 20202020 20202020 20202020                     
   15938:	20202020 20202020 20202020 65726220                  bre
   15948:	0a0d6b61 20202020 20202020 20202020     ak..            
   15958:	20202020 20202020 20202020 20202020                     
   15968:	200a0d7d 20202020 20202020 20202020     }..             
   15978:	20202020 20202020 65202020 7365722e                e.res
   15988:	6f427465 73646e75 656d6954 20644972     etBoundsTimerId 
   15998:	63202626 7261656c 65746e49 6c617672     && clearInterval
   159a8:	722e6528 74657365 6e756f42 69547364     (e.resetBoundsTi
   159b8:	4972656d 0a0d2964 20202020 20202020     merId)..        
   159c8:	20202020 20202020 20202020 61202c7d                 }, a
   159d8:	6f72702e 79746f74 672e6570 69547465     .prototype.getTi
   159e8:	6553656d 73656972 6974704f 20736e6f     meSeriesOptions 
   159f8:	7566203d 6974636e 65286e6f 0d7b2029     = function(e) {.
   15a08:	2020200a 20202020 20202020 20202020     .               
   15a18:	20202020 20202020 726f6620 61762820              for (va
   15a28:	20742072 6874203d 732e7369 65697265     r t = this.serie
   15a38:	74655373 6e656c2e 2c687467 3d206920     sSet.length, i =
   15a48:	203b3020 203c2069 69203b74 203d2b20      0; i < t; i += 
   15a58:	0a0d2931 20202020 20202020 20202020     1)..            
   15a68:	20202020 20202020 20202020 20202020                     
   15a78:	28206669 73696874 7265732e 53736569     if (this.seriesS
   15a88:	695b7465 69742e5d 6553656d 73656972     et[i].timeSeries
   15a98:	3d3d3d20 20296520 75746572 74206e72      === e) return t
   15aa8:	2e736968 69726573 65537365 5d695b74     his.seriesSet[i]
   15ab8:	74706f2e 736e6f69 20200a0d 20202020     .options..      
   15ac8:	20202020 20202020 20202020 2c7d2020                   },
   15ad8:	702e6120 6f746f72 65707974 6972622e      a.prototype.bri
   15ae8:	6f54676e 6e6f7246 203d2074 636e7566     ngToFront = func
   15af8:	6e6f6974 20296528 200a0d7b 20202020     tion(e) {..     
   15b08:	20202020 20202020 20202020 20202020                     
   15b18:	66202020 2820726f 20726176 203d2074        for (var t = 
   15b28:	73696874 7265732e 53736569 6c2e7465     this.seriesSet.l
   15b38:	74676e65 69202c68 30203d20 2069203b     ength, i = 0; i 
   15b48:	3b74203c 2b206920 2931203d 20200a0d     < t; i += 1)..  
   15b58:	20202020 20202020 20202020 20202020                     
   15b68:	20202020 20202020 66692020 68742820               if (th
   15b78:	732e7369 65697265 74655373 2e5d695b     is.seriesSet[i].
   15b88:	656d6974 69726553 3d207365 65203d3d     timeSeries === e
   15b98:	0d7b2029 2020200a 20202020 20202020     ) {..           
   15ba8:	20202020 20202020 20202020 20202020                     
   15bb8:	20202020 72617620 3d206120 69687420          var a = thi
   15bc8:	65732e73 73656972 2e746553 696c7073     s.seriesSet.spli
   15bd8:	69286563 2931202c 200a0d3b 20202020     ce(i, 1);..     
   15be8:	20202020 20202020 20202020 20202020                     
   15bf8:	20202020 20202020 74202020 2e736968                this.
   15c08:	69726573 65537365 75702e74 61286873     seriesSet.push(a
   15c18:	295d305b 200a0d3b 20202020 20202020     [0]);..         
   15c28:	20202020 20202020 20202020 20202020                     
   15c38:	20202020 62202020 6b616572 20200a0d            break..  
   15c48:	20202020 20202020 20202020 20202020                     
   15c58:	20202020 20202020 0d7d2020 2020200a               }..   
   15c68:	20202020 20202020 20202020 20202020                     
   15c78:	202c7d20 72702e61 746f746f 2e657079      }, a.prototype.
   15c88:	65727473 6f546d61 66203d20 74636e75     streamTo = funct
   15c98:	286e6f69 74202c65 0d7b2029 2020200a     ion(e, t) {..   
   15ca8:	20202020 20202020 20202020 20202020                     
   15cb8:	20202020 69687420 61632e73 7361766e          this.canvas
   15cc8:	65203d20 6874202c 642e7369 79616c65      = e, this.delay
   15cd8:	74203d20 6874202c 732e7369 74726174      = t, this.start
   15ce8:	0a0d2928 20202020 20202020 20202020     ()..            
   15cf8:	20202020 20202020 61202c7d 6f72702e             }, a.pro
   15d08:	79746f74 722e6570 7a697365 203d2065     totype.resize = 
   15d18:	636e7566 6e6f6974 7b202928 20200a0d     function() {..  
   15d28:	20202020 20202020 20202020 20202020                     
   15d38:	20202020 66692020 68742820 6f2e7369           if (this.o
   15d48:	6f697470 652e736e 6c62616e 69704465     ptions.enableDpi
   15d58:	6c616353 20676e69 77202626 6f646e69     Scaling && windo
   15d68:	26262077 21203120 77203d3d 6f646e69     w && 1 !== windo
   15d78:	65642e77 65636976 65786950 7461526c     w.devicePixelRat
   15d88:	20296f69 200a0d7b 20202020 20202020     io) {..         
   15d98:	20202020 20202020 20202020 20202020                     
   15da8:	76202020 65207261 77203d20 6f646e69        var e = windo
   15db8:	65642e77 65636976 65786950 7461526c     w.devicePixelRat
   15dc8:	0d2c6f69 2020200a 20202020 20202020     io,..           
   15dd8:	20202020 20202020 20202020 20202020                     
   15de8:	20202020 3d207420 72617020 6e496573          t = parseIn
   15df8:	68742874 632e7369 61766e61 65672e73     t(this.canvas.ge
   15e08:	74744174 75626972 22286574 74646977     tAttribute("widt
   15e18:	29292268 200a0d2c 20202020 20202020     h")),..         
   15e28:	20202020 20202020 20202020 20202020                     
   15e38:	20202020 69202020 70203d20 65737261            i = parse
   15e48:	28746e49 73696874 6e61632e 2e736176     Int(this.canvas.
   15e58:	41746567 69727474 65747562 65682228     getAttribute("he
   15e68:	74686769 3b292922 20200a0d 20202020     ight"));..      
   15e78:	20202020 20202020 20202020 20202020                     
   15e88:	20202020 68742020 6f2e7369 69676972           this.origi
   15e98:	576c616e 68746469 20262620 6874614d     nalWidth && Math
   15ea8:	6f6c662e 7428726f 2e736968 6769726f     .floor(this.orig
   15eb8:	6c616e69 74646957 202a2068 3d202965     inalWidth * e) =
   15ec8:	74203d3d 207c7c20 69687428 726f2e73     == t || (this.or
   15ed8:	6e696769 69576c61 20687464 2c74203d     iginalWidth = t,
   15ee8:	69687420 61632e73 7361766e 7465732e      this.canvas.set
   15ef8:	72747441 74756269 77222865 68746469     Attribute("width
   15f08:	4d202c22 2e687461 6f6f6c66 20742872     ", Math.floor(t 
   15f18:	2965202a 536f742e 6e697274 29292867     * e).toString())
   15f28:	6874202c 632e7369 61766e61 74732e73     , this.canvas.st
   15f38:	2e656c79 74646977 203d2068 202b2074     yle.width = t + 
   15f48:	22787022 6874202c 632e7369 61766e61     "px", this.canva
   15f58:	65672e73 6e6f4374 74786574 64322228     s.getContext("2d
   15f68:	732e2922 656c6163 202c6528 2c292965     ").scale(e, e)),
   15f78:	69687420 726f2e73 6e696769 65486c61      this.originalHe
   15f88:	74686769 20262620 6874614d 6f6c662e     ight && Math.flo
   15f98:	7428726f 2e736968 6769726f 6c616e69     or(this.original
   15fa8:	67696548 2a207468 20296520 203d3d3d     Height * e) === 
   15fb8:	7c7c2069 68742820 6f2e7369 69676972     i || (this.origi
   15fc8:	486c616e 68676965 203d2074 74202c69     nalHeight = i, t
   15fd8:	2e736968 766e6163 732e7361 74417465     his.canvas.setAt
   15fe8:	62697274 28657475 69656822 22746867     tribute("height"
   15ff8:	614d202c 662e6874 726f6f6c 2a206928     , Math.floor(i *
   16008:	2e296520 74536f74 676e6972 2c292928      e).toString()),
   16018:	69687420 61632e73 7361766e 7974732e      this.canvas.sty
   16028:	682e656c 68676965 203d2074 202b2069     le.height = i + 
   16038:	22787022 6874202c 632e7369 61766e61     "px", this.canva
   16048:	65672e73 6e6f4374 74786574 64322228     s.getContext("2d
   16058:	732e2922 656c6163 202c6528 0d292965     ").scale(e, e)).
   16068:	2020200a 20202020 20202020 20202020     .               
   16078:	20202020 20202020 0a0d7d20 20202020              }..    
   16088:	20202020 20202020 20202020 20202020                     
   16098:	61202c7d 6f72702e 79746f74 732e6570     }, a.prototype.s
   160a8:	74726174 66203d20 74636e75 286e6f69     tart = function(
   160b8:	0d7b2029 2020200a 20202020 20202020     ) {..           
   160c8:	20202020 20202020 20202020 20666920                  if 
   160d8:	68742128 662e7369 656d6172 0d7b2029     (!this.frame) {.
   160e8:	2020200a 20202020 20202020 20202020     .               
   160f8:	20202020 20202020 20202020 72617620                  var
   16108:	3d206520 6e756620 6f697463 2029286e      e = function() 
   16118:	200a0d7b 20202020 20202020 20202020     {..             
   16128:	20202020 20202020 20202020 20202020                     
   16138:	74202020 2e736968 6d617266 203d2065        this.frame = 
   16148:	6e412e61 74616d69 6d6f4365 69746170     a.AnimateCompati
   16158:	696c6962 722e7974 65757165 6e417473     bility.requestAn
   16168:	74616d69 466e6f69 656d6172 6e756628     imationFrame(fun
   16178:	6f697463 2029286e 200a0d7b 20202020     ction() {..     
   16188:	20202020 20202020 20202020 20202020                     
   16198:	20202020 20202020 20202020 74202020                    t
   161a8:	2e736968 646e6572 29287265 2865202c     his.render(), e(
   161b8:	200a0d29 20202020 20202020 20202020     )..             
   161c8:	20202020 20202020 20202020 20202020                     
   161d8:	7d202020 6e69622e 68742864 29297369        }.bind(this))
   161e8:	20200a0d 20202020 20202020 20202020     ..              
   161f8:	20202020 20202020 20202020 2e7d2020                   }.
   16208:	646e6962 69687428 0d3b2973 2020200a     bind(this);..   
   16218:	20202020 20202020 20202020 20202020                     
   16228:	20202020 20202020 29286520 20200a0d              e()..  
   16238:	20202020 20202020 20202020 20202020                     
   16248:	20202020 0d7d2020 2020200a 20202020           }..       
   16258:	20202020 20202020 20202020 202c7d20                  }, 
   16268:	72702e61 746f746f 2e657079 706f7473     a.prototype.stop
   16278:	66203d20 74636e75 286e6f69 0d7b2029      = function() {.
   16288:	2020200a 20202020 20202020 20202020     .               
   16298:	20202020 20202020 69687420 72662e73              this.fr
   162a8:	20656d61 28202626 6e412e61 74616d69     ame && (a.Animat
   162b8:	6d6f4365 69746170 696c6962 632e7974     eCompatibility.c
   162c8:	65636e61 696e416c 6974616d 72466e6f     ancelAnimationFr
   162d8:	28656d61 73696874 6172662e 2c29656d     ame(this.frame),
   162e8:	6c656420 20657465 73696874 6172662e      delete this.fra
   162f8:	0d29656d 2020200a 20202020 20202020     me)..           
   16308:	20202020 20202020 202c7d20 72702e61              }, a.pr
   16318:	746f746f 2e657079 61647075 61566574     ototype.updateVa
   16328:	5265756c 65676e61 66203d20 74636e75     lueRange = funct
   16338:	286e6f69 0d7b2029 2020200a 20202020     ion() {..       
   16348:	20202020 20202020 20202020 20202020                     
   16358:	726f6620 61762820 20652072 6874203d      for (var e = th
   16368:	6f2e7369 6f697470 202c736e 203d2074     is.options, t = 
   16378:	626d754e 4e2e7265 202c4e61 203d2069     Number.NaN, i = 
   16388:	626d754e 4e2e7265 202c4e61 203d2061     Number.NaN, a = 
   16398:	61203b30 74203c20 2e736968 69726573     0; a < this.seri
   163a8:	65537365 656c2e74 6874676e 2061203b     esSet.length; a 
   163b8:	31203d2b 0d7b2029 2020200a 20202020     += 1) {..       
   163c8:	20202020 20202020 20202020 20202020                     
   163d8:	20202020 72617620 3d207320 69687420          var s = thi
   163e8:	65732e73 73656972 5b746553 742e5d61     s.seriesSet[a].t
   163f8:	53656d69 65697265 0a0d3b73 20202020     imeSeries;..    
   16408:	20202020 20202020 20202020 20202020                     
   16418:	20202020 20202020 614e7369 2e73284e             isNaN(s.
   16428:	5678616d 65756c61 7c7c2029 20742820     maxValue) || (t 
   16438:	7369203d 284e614e 3f202974 6d2e7320     = isNaN(t) ? s.m
   16448:	61567861 2065756c 614d203a 6d2e6874     axValue : Math.m
   16458:	74287861 2e73202c 5678616d 65756c61     ax(t, s.maxValue
   16468:	202c2929 614e7369 2e73284e 566e696d     )), isNaN(s.minV
   16478:	65756c61 7c7c2029 20692820 7369203d     alue) || (i = is
   16488:	284e614e 3f202969 6d2e7320 61566e69     NaN(i) ? s.minVa
   16498:	2065756c 614d203a 6d2e6874 69286e69     lue : Math.min(i
   164a8:	2e73202c 566e696d 65756c61 0a0d2929     , s.minValue))..
   164b8:	20202020 20202020 20202020 20202020                     
   164c8:	20202020 20202020 200a0d7d 20202020             }..     
   164d8:	20202020 20202020 20202020 20202020                     
   164e8:	69202020 6e282066 206c6c75 65203d21        if (null != e
   164f8:	78616d2e 756c6156 203f2065 203d2074     .maxValue ? t = 
   16508:	616d2e65 6c615678 3a206575 2a207420     e.maxValue : t *
   16518:	2e65203d 5678616d 65756c61 6c616353     = e.maxValueScal
   16528:	6e202c65 206c6c75 65203d21 6e696d2e     e, null != e.min
   16538:	756c6156 203f2065 203d2069 696d2e65     Value ? i = e.mi
   16548:	6c61566e 3a206575 2d206920 614d203d     nValue : i -= Ma
   16558:	612e6874 69287362 65202a20 6e696d2e     th.abs(i * e.min
   16568:	756c6156 61635365 2d20656c 2c296920     ValueScale - i),
   16578:	69687420 706f2e73 6e6f6974 52792e73      this.options.yR
   16588:	65676e61 636e7546 6e6f6974 0d7b2029     angeFunction) {.
   16598:	2020200a 20202020 20202020 20202020     .               
   165a8:	20202020 20202020 20202020 72617620                  var
   165b8:	3d206e20 69687420 706f2e73 6e6f6974      n = this.option
   165c8:	52792e73 65676e61 636e7546 6e6f6974     s.yRangeFunction
   165d8:	0a0d7b28 20202020 20202020 20202020     ({..            
   165e8:	20202020 20202020 20202020 20202020                     
   165f8:	20202020 3a6e696d 0d2c6920 2020200a         min: i,..   
   16608:	20202020 20202020 20202020 20202020                     
   16618:	20202020 20202020 20202020 78616d20                  max
   16628:	0d74203a 2020200a 20202020 20202020     : t..           
   16638:	20202020 20202020 20202020 20202020                     
   16648:	3b297d20 20200a0d 20202020 20202020      });..          
   16658:	20202020 20202020 20202020 20202020                     
   16668:	20692020 2e6e203d 2c6e696d 3d207420       i = n.min, t =
   16678:	6d2e6e20 0a0d7861 20202020 20202020      n.max..        
   16688:	20202020 20202020 20202020 20202020                     
   16698:	200a0d7d 20202020 20202020 20202020     }..             
   166a8:	20202020 20202020 69202020 21282066                if (!
   166b8:	614e7369 2974284e 20262620 4e736921     isNaN(t) && !isN
   166c8:	69284e61 7b202929 20200a0d 20202020     aN(i)) {..      
   166d8:	20202020 20202020 20202020 20202020                     
   166e8:	20202020 61762020 20722072 2074203d           var r = t 
   166f8:	2069202d 6874202d 632e7369 65727275     - i - this.curre
   16708:	6156746e 5265756c 65676e61 200a0d2c     ntValueRange,.. 
   16718:	20202020 20202020 20202020 20202020                     
   16728:	20202020 20202020 20202020 6c202020                    l
   16738:	69203d20 74202d20 2e736968 72727563      = i - this.curr
   16748:	56746e65 694d7369 6c61566e 0d3b6575     entVisMinValue;.
   16758:	2020200a 20202020 20202020 20202020     .               
   16768:	20202020 20202020 20202020 69687420                  thi
   16778:	73692e73 6d696e41 6e697461 61635367     s.isAnimatingSca
   16788:	3d20656c 74614d20 62612e68 29722873     le = Math.abs(r)
   16798:	2e203e20 7c7c2031 74614d20 62612e68      > .1 || Math.ab
   167a8:	296c2873 2e203e20 74202c31 2e736968     s(l) > .1, this.
   167b8:	72727563 56746e65 65756c61 676e6152     currentValueRang
   167c8:	3d2b2065 732e6520 656c6163 6f6f6d53     e += e.scaleSmoo
   167d8:	6e696874 202a2067 74202c72 2e736968     thing * r, this.
   167e8:	72727563 56746e65 694d7369 6c61566e     currentVisMinVal
   167f8:	2b206575 2e65203d 6c616373 6f6d5365     ue += e.scaleSmo
   16808:	6968746f 2a20676e 0a0d6c20 20202020     othing * l..    
   16818:	20202020 20202020 20202020 20202020                     
   16828:	20202020 200a0d7d 20202020 20202020         }..         
   16838:	20202020 20202020 20202020 74202020                    t
   16848:	2e736968 756c6176 6e615265 3d206567     his.valueRange =
   16858:	0a0d7b20 20202020 20202020 20202020      {..            
   16868:	20202020 20202020 20202020 20202020                     
   16878:	3a6e696d 0d2c6920 2020200a 20202020     min: i,..       
   16888:	20202020 20202020 20202020 20202020                     
   16898:	20202020 78616d20 0d74203a 2020200a          max: t..   
   168a8:	20202020 20202020 20202020 20202020                     
   168b8:	20202020 0a0d7d20 20202020 20202020          }..        
   168c8:	20202020 20202020 20202020 61202c7d                 }, a
   168d8:	6f72702e 79746f74 722e6570 65646e65     .prototype.rende
   168e8:	203d2072 636e7566 6e6f6974 202c6528     r = function(e, 
   168f8:	7b202974 20200a0d 20202020 20202020     t) {..          
   16908:	20202020 20202020 20202020 61762020                   va
   16918:	20692072 6e28203d 44207765 29657461     r i = (new Date)
   16928:	7465672e 656d6954 0d3b2928 2020200a     .getTime();..   
   16938:	20202020 20202020 20202020 20202020                     
   16948:	20202020 20666920 68742128 692e7369          if (!this.i
   16958:	696e4173 6974616d 6353676e 29656c61     sAnimatingScale)
   16968:	0a0d7b20 20202020 20202020 20202020      {..            
   16978:	20202020 20202020 20202020 20202020                     
   16988:	20726176 203d2061 6874614d 6e696d2e     var a = Math.min
   16998:	33653128 36202f20 6874202c 6f2e7369     (1e3 / 6, this.o
   169a8:	6f697470 6d2e736e 696c6c69 72655073     ptions.millisPer
   169b8:	65786950 0d3b296c 2020200a 20202020     Pixel);..       
   169c8:	20202020 20202020 20202020 20202020                     
   169d8:	20202020 20666920 2d206928 69687420          if (i - thi
   169e8:	616c2e73 65527473 7265646e 656d6954     s.lastRenderTime
   169f8:	6c6c694d 3c207369 20296120 75746572     Millis < a) retu
   16a08:	0a0d6e72 20202020 20202020 20202020     rn..            
   16a18:	20202020 20202020 20202020 200a0d7d                 }.. 
   16a28:	20202020 20202020 20202020 20202020                     
   16a38:	20202020 74202020 2e736968 69736572            this.resi
   16a48:	2928657a 6874202c 6c2e7369 52747361     ze(), this.lastR
   16a58:	65646e65 6d695472 6c694d65 2073696c     enderTimeMillis 
   16a68:	2c69203d 3d206520 7c206520 6874207c     = i, e = e || th
   16a78:	632e7369 61766e61 74202c73 74203d20     is.canvas, t = t
   16a88:	207c7c20 202d2069 69687428 65642e73      || i - (this.de
   16a98:	2079616c 30207c7c 74202c29 203d2d20     lay || 0), t -= 
   16aa8:	20252074 73696874 74706f2e 736e6f69     t % this.options
   16ab8:	6c696d2e 5073696c 69507265 3b6c6578     .millisPerPixel;
   16ac8:	20200a0d 20202020 20202020 20202020     ..              
   16ad8:	20202020 20202020 61762020 20732072               var s 
   16ae8:	2e65203d 43746567 65746e6f 22287478     = e.getContext("
   16af8:	29226432 200a0d2c 20202020 20202020     2d"),..         
   16b08:	20202020 20202020 20202020 20202020                     
   16b18:	6e202020 74203d20 2e736968 6974706f        n = this.opti
   16b28:	2c736e6f 20200a0d 20202020 20202020     ons,..          
   16b38:	20202020 20202020 20202020 20202020                     
   16b48:	20722020 0d7b203d 2020200a 20202020       r = {..       
   16b58:	20202020 20202020 20202020 20202020                     
   16b68:	20202020 20202020 706f7420 2c30203a              top: 0,
   16b78:	20200a0d 20202020 20202020 20202020     ..              
   16b88:	20202020 20202020 20202020 20202020                     
   16b98:	656c2020 203a7466 0a0d2c30 20202020       left: 0,..    
   16ba8:	20202020 20202020 20202020 20202020                     
   16bb8:	20202020 20202020 20202020 74646977                 widt
   16bc8:	65203a68 696c632e 57746e65 68746469     h: e.clientWidth
   16bd8:	200a0d2c 20202020 20202020 20202020     ,..             
   16be8:	20202020 20202020 20202020 20202020                     
   16bf8:	68202020 68676965 65203a74 696c632e        height: e.cli
   16c08:	48746e65 68676965 200a0d74 20202020     entHeight..     
   16c18:	20202020 20202020 20202020 20202020                     
   16c28:	20202020 7d202020 200a0d2c 20202020            },..     
   16c38:	20202020 20202020 20202020 20202020                     
   16c48:	20202020 6c202020 74203d20 72202d20            l = t - r
   16c58:	6469772e 2a206874 6d2e6e20 696c6c69     .width * n.milli
   16c68:	72655073 65786950 0a0d2c6c 20202020     sPerPixel,..    
   16c78:	20202020 20202020 20202020 20202020                     
   16c88:	20202020 20202020 203d206f 636e7566             o = func
   16c98:	6e6f6974 20296528 200a0d7b 20202020     tion(e) {..     
   16ca8:	20202020 20202020 20202020 20202020                     
   16cb8:	20202020 20202020 76202020 74207261                var t
   16cc8:	65203d20 74202d20 2e736968 72727563      = e - this.curr
   16cd8:	56746e65 694d7369 6c61566e 0d3b6575     entVisMinValue;.
   16ce8:	2020200a 20202020 20202020 20202020     .               
   16cf8:	20202020 20202020 20202020 20202020                     
   16d08:	74657220 206e7275 3d3d2030 6874203d      return 0 === th
   16d18:	632e7369 65727275 6156746e 5265756c     is.currentValueR
   16d28:	65676e61 72203f20 6965682e 20746867     ange ? r.height 
   16d38:	2e72203a 67696568 2d207468 74614d20     : r.height - Mat
   16d48:	6f722e68 28646e75 202f2074 73696874     h.round(t / this
   16d58:	7275632e 746e6572 756c6156 6e615265     .currentValueRan
   16d68:	2a206567 682e7220 68676965 0a0d2974     ge * r.height)..
   16d78:	20202020 20202020 20202020 20202020                     
   16d88:	20202020 20202020 20202020 69622e7d                 }.bi
   16d98:	7428646e 29736968 200a0d2c 20202020     nd(this),..     
   16da8:	20202020 20202020 20202020 20202020                     
   16db8:	20202020 68202020 66203d20 74636e75            h = funct
   16dc8:	286e6f69 7b202965 20200a0d 20202020     ion(e) {..      
   16dd8:	20202020 20202020 20202020 20202020                     
   16de8:	20202020 20202020 65722020 6e727574               return
   16df8:	732e6e20 6c6f7263 6361426c 7261776b      n.scrollBackwar
   16e08:	3f207364 74614d20 6f722e68 28646e75     ds ? Math.round(
   16e18:	2d207428 20296520 2e6e202f 6c6c696d     (t - e) / n.mill
   16e28:	65507369 78695072 20296c65 614d203a     isPerPixel) : Ma
   16e38:	722e6874 646e756f 772e7228 68746469     th.round(r.width
   16e48:	28202d20 202d2074 2f202965 6d2e6e20      - (t - e) / n.m
   16e58:	696c6c69 72655073 65786950 0a0d296c     illisPerPixel)..
   16e68:	20202020 20202020 20202020 20202020                     
   16e78:	20202020 20202020 20202020 0a0d3b7d                 };..
   16e88:	20202020 20202020 20202020 20202020                     
   16e98:	20202020 20202020 28206669 73696874             if (this
   16ea8:	6470752e 56657461 65756c61 676e6152     .updateValueRang
   16eb8:	2c292865 662e7320 20746e6f 2e6e203d     e(), s.font = n.
   16ec8:	6562616c 662e736c 53746e6f 20657a69     labels.fontSize 
   16ed8:	7022202b 20222078 2e6e202b 6562616c     + "px " + n.labe
   16ee8:	662e736c 46746e6f 6c696d61 73202c79     ls.fontFamily, s
   16ef8:	7661732e 2c292865 742e7320 736e6172     .save(), s.trans
   16f08:	6574616c 6c2e7228 2c746665 742e7220     late(r.left, r.t
   16f18:	2c29706f 622e7320 6e696765 68746150     op), s.beginPath
   16f28:	202c2928 65722e73 30287463 2c30202c     (), s.rect(0, 0,
   16f38:	772e7220 68746469 2e72202c 67696568      r.width, r.heig
   16f48:	2c297468 632e7320 2870696c 73202c29     ht), s.clip(), s
   16f58:	7661732e 2c292865 662e7320 536c6c69     .save(), s.fillS
   16f68:	656c7974 6e203d20 6972672e 69662e64     tyle = n.grid.fi
   16f78:	74536c6c 2c656c79 632e7320 7261656c     llStyle, s.clear
   16f88:	74636552 202c3028 72202c30 6469772e     Rect(0, 0, r.wid
   16f98:	202c6874 65682e72 74686769 73202c29     th, r.height), s
   16fa8:	6c69662e 6365526c 2c302874 202c3020     .fillRect(0, 0, 
   16fb8:	69772e72 2c687464 682e7220 68676965     r.width, r.heigh
   16fc8:	202c2974 65722e73 726f7473 2c292865     t), s.restore(),
   16fd8:	732e7320 28657661 73202c29 6e696c2e      s.save(), s.lin
   16fe8:	64695765 3d206874 672e6e20 2e646972     eWidth = n.grid.
   16ff8:	656e696c 74646957 73202c68 7274732e     lineWidth, s.str
   17008:	53656b6f 656c7974 6e203d20 6972672e     okeStyle = n.gri
   17018:	74732e64 656b6f72 6c797453 6e202c65     d.strokeStyle, n
   17028:	6972672e 696d2e64 73696c6c 4c726550     .grid.millisPerL
   17038:	20656e69 2930203e 0a0d7b20 20202020     ine > 0) {..    
   17048:	20202020 20202020 20202020 20202020                     
   17058:	20202020 20202020 65622e73 506e6967             s.beginP
   17068:	28687461 0a0d3b29 20202020 20202020     ath();..        
   17078:	20202020 20202020 20202020 20202020                     
   17088:	20202020 20726f66 72617628 3d206420         for (var d =
   17098:	2d207420 25207420 672e6e20 2e646972      t - t % n.grid.
   170a8:	6c6c696d 65507369 6e694c72 64203b65     millisPerLine; d
   170b8:	203d3e20 64203b6c 203d2d20 72672e6e      >= l; d -= n.gr
   170c8:	6d2e6469 696c6c69 72655073 656e694c     id.millisPerLine
   170d8:	0d7b2029 2020200a 20202020 20202020     ) {..           
   170e8:	20202020 20202020 20202020 20202020                     
   170f8:	20202020 72617620 3d207520 64286820          var u = h(d
   17108:	0a0d3b29 20202020 20202020 20202020     );..            
   17118:	20202020 20202020 20202020 20202020                     
   17128:	20202020 72672e6e 732e6469 70726168         n.grid.sharp
   17138:	656e694c 26262073 20752820 2e203d2d     Lines && (u -= .
   17148:	202c2935 6f6d2e73 6f546576 202c7528     5), s.moveTo(u, 
   17158:	202c2930 696c2e73 6f54656e 202c7528     0), s.lineTo(u, 
   17168:	65682e72 74686769 200a0d29 20202020     r.height)..     
   17178:	20202020 20202020 20202020 20202020                     
   17188:	20202020 7d202020 20200a0d 20202020            }..      
   17198:	20202020 20202020 20202020 20202020                     
   171a8:	20202020 2e732020 6f727473 2928656b           s.stroke()
   171b8:	2e73202c 736f6c63 74615065 0d292868     , s.closePath().
   171c8:	2020200a 20202020 20202020 20202020     .               
   171d8:	20202020 20202020 0a0d7d20 20202020              }..    
   171e8:	20202020 20202020 20202020 20202020                     
   171f8:	20202020 20726f66 72617628 3d206d20         for (var m =
   17208:	203b3120 203c206d 72672e6e 762e6469      1; m < n.grid.v
   17218:	69747265 536c6163 69746365 3b736e6f     erticalSections;
   17228:	2b206d20 2931203d 0a0d7b20 20202020      m += 1) {..    
   17238:	20202020 20202020 20202020 20202020                     
   17248:	20202020 20202020 20726176 203d2063             var c = 
   17258:	6874614d 756f722e 6d28646e 72202a20     Math.round(m * r
   17268:	6965682e 20746867 2e6e202f 64697267     .height / n.grid
   17278:	7265762e 61636974 6365536c 6e6f6974     .verticalSection
   17288:	0d3b2973 2020200a 20202020 20202020     s);..           
   17298:	20202020 20202020 20202020 20202020                     
   172a8:	672e6e20 2e646972 72616873 6e694c70      n.grid.sharpLin
   172b8:	26207365 63282026 203d2d20 2c29352e     es && (c -= .5),
   172c8:	622e7320 6e696765 68746150 202c2928      s.beginPath(), 
   172d8:	6f6d2e73 6f546576 202c3028 202c2963     s.moveTo(0, c), 
   172e8:	696c2e73 6f54656e 772e7228 68746469     s.lineTo(r.width
   172f8:	2963202c 2e73202c 6f727473 2928656b     , c), s.stroke()
   17308:	2e73202c 736f6c63 74615065 0d292868     , s.closePath().
   17318:	2020200a 20202020 20202020 20202020     .               
   17328:	20202020 20202020 0a0d7d20 20202020              }..    
   17338:	20202020 20202020 20202020 20202020                     
   17348:	20202020 28206669 72672e6e 622e6469         if (n.grid.b
   17358:	6564726f 73695672 656c6269 20262620     orderVisible && 
   17368:	622e7328 6e696765 68746150 202c2928     (s.beginPath(), 
   17378:	74732e73 656b6f72 74636552 202c3028     s.strokeRect(0, 
   17388:	72202c30 6469772e 202c6874 65682e72     0, r.width, r.he
   17398:	74686769 73202c29 6f6c632e 61506573     ight), s.closePa
   173a8:	29286874 73202c29 7365722e 65726f74     th()), s.restore
   173b8:	202c2928 6f682e6e 6f7a6972 6c61746e     (), n.horizontal
   173c8:	656e694c 26262073 682e6e20 7a69726f     Lines && n.horiz
   173d8:	61746e6f 6e694c6c 6c2e7365 74676e65     ontalLines.lengt
   173e8:	0a0d2968 20202020 20202020 20202020     h)..            
   173f8:	20202020 20202020 20202020 20202020                     
   17408:	20726f66 72617628 3d206620 203b3020     for (var f = 0; 
   17418:	203c2066 6f682e6e 6f7a6972 6c61746e     f < n.horizontal
   17428:	656e694c 656c2e73 6874676e 2066203b     Lines.length; f 
   17438:	31203d2b 0d7b2029 2020200a 20202020     += 1) {..       
   17448:	20202020 20202020 20202020 20202020                     
   17458:	20202020 20202020 72617620 3d206720              var g =
   17468:	682e6e20 7a69726f 61746e6f 6e694c6c      n.horizontalLin
   17478:	665b7365 0a0d2c5d 20202020 20202020     es[f],..        
   17488:	20202020 20202020 20202020 20202020                     
   17498:	20202020 20202020 20202020 203d2070                 p = 
   174a8:	6874614d 756f722e 6f28646e 762e6728     Math.round(o(g.v
   174b8:	65756c61 2d202929 3b352e20 20200a0d     alue)) - .5;..  
   174c8:	20202020 20202020 20202020 20202020                     
   174d8:	20202020 20202020 20202020 2e732020                   s.
   174e8:	6f727473 7453656b 20656c79 2e67203d     strokeStyle = g.
   174f8:	6f6c6f63 7c7c2072 66232220 66666666     color || "#fffff
   17508:	202c2266 696c2e73 6957656e 20687464     f", s.lineWidth 
   17518:	2e67203d 656e696c 74646957 7c7c2068     = g.lineWidth ||
   17528:	202c3120 65622e73 506e6967 28687461      1, s.beginPath(
   17538:	73202c29 766f6d2e 286f5465 70202c30     ), s.moveTo(0, p
   17548:	73202c29 6e696c2e 286f5465 69772e72     ), s.lineTo(r.wi
   17558:	2c687464 2c297020 732e7320 6b6f7274     dth, p), s.strok
   17568:	2c292865 632e7320 65736f6c 68746150     e(), s.closePath
   17578:	0a0d2928 20202020 20202020 20202020     ()..            
   17588:	20202020 20202020 20202020 20202020                     
   17598:	200a0d7d 20202020 20202020 20202020     }..             
   175a8:	20202020 20202020 66202020 2820726f                for (
   175b8:	20726176 203d2053 53203b30 74203c20     var S = 0; S < t
   175c8:	2e736968 69726573 65537365 656c2e74     his.seriesSet.le
   175d8:	6874676e 2053203b 31203d2b 0d7b2029     ngth; S += 1) {.
   175e8:	2020200a 20202020 20202020 20202020     .               
   175f8:	20202020 20202020 20202020 732e7320                  s.s
   17608:	28657661 0a0d3b29 20202020 20202020     ave();..        
   17618:	20202020 20202020 20202020 20202020                     
   17628:	20202020 20726176 203d2076 73696874         var v = this
   17638:	7265732e 53736569 535b7465 69742e5d     .seriesSet[S].ti
   17648:	6553656d 73656972 200a0d2c 20202020     meSeries,..     
   17658:	20202020 20202020 20202020 20202020                     
   17668:	20202020 20202020 77202020 76203d20                w = v
   17678:	7461642e 0a0d2c61 20202020 20202020     .data,..        
   17688:	20202020 20202020 20202020 20202020                     
   17698:	20202020 20202020 203d2078 73696874             x = this
   176a8:	7265732e 53736569 535b7465 706f2e5d     .seriesSet[S].op
   176b8:	6e6f6974 0a0d3b73 20202020 20202020     tions;..        
   176c8:	20202020 20202020 20202020 20202020                     
   176d8:	20202020 72642e76 6c4f706f 74614464         v.dropOldDat
   176e8:	2c6c2861 6d2e6e20 61447861 65536174     a(l, n.maxDataSe
   176f8:	6e654c74 29687467 2e73202c 656e696c     tLength), s.line
   17708:	74646957 203d2068 696c2e78 6957656e     Width = x.lineWi
   17718:	2c687464 732e7320 6b6f7274 79745365     dth, s.strokeSty
   17728:	3d20656c 732e7820 6b6f7274 79745365     le = x.strokeSty
   17738:	202c656c 65622e73 506e6967 28687461     le, s.beginPath(
   17748:	0a0d3b29 20202020 20202020 20202020     );..            
   17758:	20202020 20202020 20202020 20202020                     
   17768:	20726f66 72617628 3d207920 202c3020     for (var y = 0, 
   17778:	203d2062 56202c30 30203d20 2054202c     b = 0, V = 0, T 
   17788:	3b30203d 3c205420 6c2e7720 74676e65     = 0; T < w.lengt
   17798:	26262068 21203120 77203d3d 6e656c2e     h && 1 !== w.len
   177a8:	3b687467 2b205420 2931203d 0a0d7b20     gth; T += 1) {..
   177b8:	20202020 20202020 20202020 20202020                     
   177c8:	20202020 20202020 20202020 20202020                     
   177d8:	20726176 203d204e 5b772868 305b5d54     var N = h(w[T][0
   177e8:	0d2c295d 2020200a 20202020 20202020     ]),..           
   177f8:	20202020 20202020 20202020 20202020                     
   17808:	20202020 20202020 3d205020 77286f20              P = o(w
   17818:	5b5d545b 3b295d31 20200a0d 20202020     [T][1]);..      
   17828:	20202020 20202020 20202020 20202020                     
   17838:	20202020 20202020 66692020 20302820               if (0 
   17848:	203d3d3d 79202954 4e203d20 2e73202c     === T) y = N, s.
   17858:	65766f6d 4e286f54 2950202c 200a0d3b     moveTo(N, P);.. 
   17868:	20202020 20202020 20202020 20202020                     
   17878:	20202020 20202020 20202020 65202020                    e
   17888:	2065736c 74697773 28206863 6e692e6e     lse switch (n.in
   17898:	70726574 74616c6f 296e6f69 0a0d7b20     terpolation) {..
   178a8:	20202020 20202020 20202020 20202020                     
   178b8:	20202020 20202020 20202020 20202020                     
   178c8:	20202020 65736163 696c2220 7261656e         case "linear
   178d8:	0a0d3a22 20202020 20202020 20202020     ":..            
   178e8:	20202020 20202020 20202020 20202020                     
   178f8:	20202020 20202020 65736163 696c2220             case "li
   17908:	3a22656e 20200a0d 20202020 20202020     ne":..          
   17918:	20202020 20202020 20202020 20202020                     
   17928:	20202020 20202020 20202020 2e732020                   s.
   17938:	656e696c 4e286f54 2950202c 200a0d3b     lineTo(N, P);.. 
   17948:	20202020 20202020 20202020 20202020                     
   17958:	20202020 20202020 20202020 20202020                     
   17968:	20202020 62202020 6b616572 200a0d3b            break;.. 
   17978:	20202020 20202020 20202020 20202020                     
   17988:	20202020 20202020 20202020 20202020                     
   17998:	63202020 20657361 7a656222 22726569        case "bezier"
   179a8:	200a0d3a 20202020 20202020 20202020     :..             
   179b8:	20202020 20202020 20202020 20202020                     
   179c8:	20202020 64202020 75616665 0d3a746c            default:.
   179d8:	2020200a 20202020 20202020 20202020     .               
   179e8:	20202020 20202020 20202020 20202020                     
   179f8:	20202020 20202020 622e7320 65697a65              s.bezie
   17a08:	72754372 6f546576 74614d28 6f722e68     rCurveTo(Math.ro
   17a18:	28646e75 2b206228 20294e20 2932202f     und((b + N) / 2)
   17a28:	2c56202c 74614d20 6f722e68 28646e75     , V, Math.round(
   17a38:	202b2062 2f20294e 202c3220 4e202c50     b + N) / 2, P, N
   17a48:	2950202c 200a0d3b 20202020 20202020     , P);..         
   17a58:	20202020 20202020 20202020 20202020                     
   17a68:	20202020 20202020 20202020 62202020                    b
   17a78:	6b616572 200a0d3b 20202020 20202020     reak;..         
   17a88:	20202020 20202020 20202020 20202020                     
   17a98:	20202020 20202020 63202020 20657361                case 
   17aa8:	65747322 0d3a2270 2020200a 20202020     "step":..       
   17ab8:	20202020 20202020 20202020 20202020                     
   17ac8:	20202020 20202020 20202020 20202020                     
   17ad8:	6c2e7320 54656e69 2c4e286f 2c295620      s.lineTo(N, V),
   17ae8:	6c2e7320 54656e69 2c4e286f 0d295020      s.lineTo(N, P).
   17af8:	2020200a 20202020 20202020 20202020     .               
   17b08:	20202020 20202020 20202020 20202020                     
   17b18:	0a0d7d20 20202020 20202020 20202020      }..            
   17b28:	20202020 20202020 20202020 20202020                     
   17b38:	20202020 203d2062 56202c4e 50203d20         b = N, V = P
   17b48:	20200a0d 20202020 20202020 20202020     ..              
   17b58:	20202020 20202020 20202020 0d7d2020                   }.
   17b68:	2020200a 20202020 20202020 20202020     .               
   17b78:	20202020 20202020 20202020 6c2e7720                  w.l
   17b88:	74676e65 203e2068 26262031 2e782820     ength > 1 && (x.
   17b98:	6c6c6966 6c797453 26262065 2e732820     fillStyle && (s.
   17ba8:	656e696c 72286f54 6469772e 2b206874     lineTo(r.width +
   17bb8:	6c2e7820 57656e69 68746469 31202b20      x.lineWidth + 1
   17bc8:	2956202c 2e73202c 656e696c 72286f54     , V), s.lineTo(r
   17bd8:	6469772e 2b206874 6c2e7820 57656e69     .width + x.lineW
   17be8:	68746469 31202b20 2e72202c 67696568     idth + 1, r.heig
   17bf8:	2b207468 6c2e7820 57656e69 68746469     ht + x.lineWidth
   17c08:	31202b20 73202c29 6e696c2e 286f5465      + 1), s.lineTo(
   17c18:	72202c79 6965682e 20746867 2e78202b     y, r.height + x.
   17c28:	656e696c 74646957 202c2968 69662e73     lineWidth), s.fi
   17c38:	74536c6c 20656c79 2e78203d 6c6c6966     llStyle = x.fill
   17c48:	6c797453 73202c65 6c69662e 2929286c     Style, s.fill())
   17c58:	2e78202c 6f727473 7453656b 20656c79     , x.strokeStyle 
   17c68:	22202626 656e6f6e 3d212022 2e78203d     && "none" !== x.
   17c78:	6f727473 7453656b 20656c79 73202626     strokeStyle && s
   17c88:	7274732e 28656b6f 73202c29 6f6c632e     .stroke(), s.clo
   17c98:	61506573 29286874 73202c29 7365722e     sePath()), s.res
   17ca8:	65726f74 0a0d2928 20202020 20202020     tore()..        
   17cb8:	20202020 20202020 20202020 20202020                     
   17cc8:	200a0d7d 20202020 20202020 20202020     }..             
   17cd8:	20202020 20202020 69202020 21282066                if (!
   17ce8:	616c2e6e 736c6562 7369642e 656c6261     n.labels.disable
   17cf8:	26262064 73692120 284e614e 73696874     d && !isNaN(this
   17d08:	6c61762e 61526575 2e65676e 296e696d     .valueRange.min)
   17d18:	20262620 4e736921 74284e61 2e736968      && !isNaN(this.
   17d28:	756c6176 6e615265 6d2e6567 29297861     valueRange.max))
   17d38:	0a0d7b20 20202020 20202020 20202020      {..            
   17d48:	20202020 20202020 20202020 20202020                     
   17d58:	20726176 203d204d 4d792e6e 6f467861     var M = n.yMaxFo
   17d68:	74616d72 28726574 73696874 6c61762e     rmatter(this.val
   17d78:	61526575 2e65676e 2c78616d 6c2e6e20     ueRange.max, n.l
   17d88:	6c656261 72702e73 73696365 296e6f69     abels.precision)
   17d98:	200a0d2c 20202020 20202020 20202020     ,..             
   17da8:	20202020 20202020 20202020 20202020                     
   17db8:	6b202020 6e203d20 694d792e 726f466e        k = n.yMinFor
   17dc8:	7474616d 74287265 2e736968 756c6176     matter(this.valu
   17dd8:	6e615265 6d2e6567 202c6e69 616c2e6e     eRange.min, n.la
   17de8:	736c6562 6572702e 69736963 2c296e6f     bels.precision),
   17df8:	20200a0d 20202020 20202020 20202020     ..              
   17e08:	20202020 20202020 20202020 20202020                     
   17e18:	20462020 2e6e203d 6f726373 61426c6c       F = n.scrollBa
   17e28:	61776b63 20736472 2030203f 2e72203a     ckwards ? 0 : r.
   17e38:	74646977 202d2068 656d2e73 72757361     width - s.measur
   17e48:	78655465 294d2874 6469772e 2d206874     eText(M).width -
   17e58:	0d2c3220 2020200a 20202020 20202020      2,..           
   17e68:	20202020 20202020 20202020 20202020                     
   17e78:	20202020 3d205220 732e6e20 6c6f7263          R = n.scrol
   17e88:	6361426c 7261776b 3f207364 3a203020     lBackwards ? 0 :
   17e98:	772e7220 68746469 73202d20 61656d2e      r.width - s.mea
   17ea8:	65727573 74786554 2e296b28 74646977     sureText(k).widt
   17eb8:	202d2068 0a0d3b32 20202020 20202020     h - 2;..        
   17ec8:	20202020 20202020 20202020 20202020                     
   17ed8:	20202020 69662e73 74536c6c 20656c79         s.fillStyle 
   17ee8:	2e6e203d 6562616c 662e736c 536c6c69     = n.labels.fillS
   17ef8:	656c7974 2e73202c 6c6c6966 74786554     tyle, s.fillText
   17f08:	202c4d28 6e202c46 62616c2e 2e736c65     (M, F, n.labels.
   17f18:	746e6f66 657a6953 73202c29 6c69662e     fontSize), s.fil
   17f28:	7865546c 2c6b2874 202c5220 65682e72     lText(k, R, r.he
   17f38:	74686769 32202d20 200a0d29 20202020     ight - 2)..     
   17f48:	20202020 20202020 20202020 20202020                     
   17f58:	7d202020 20200a0d 20202020 20202020        }..          
   17f68:	20202020 20202020 20202020 66692020                   if
   17f78:	2e6e2820 656d6974 6d617473 726f4670      (n.timestampFor
   17f88:	7474616d 26207265 2e6e2026 64697267     matter && n.grid
   17f98:	6c696d2e 5073696c 694c7265 3e20656e     .millisPerLine >
   17fa8:	20293020 200a0d7b 20202020 20202020      0) {..         
   17fb8:	20202020 20202020 20202020 20202020                     
   17fc8:	76202020 41207261 6e203d20 7263732e        var A = n.scr
   17fd8:	426c6c6f 776b6361 73647261 73203f20     ollBackwards ? s
   17fe8:	61656d2e 65727573 74786554 2e296b28     .measureText(k).
   17ff8:	74646977 203a2068 69772e72 20687464     width : r.width 
   18008:	2e73202d 7361656d 54657275 28747865     - s.measureText(
   18018:	772e296b 68746469 34202b20 200a0d3b     k).width + 4;.. 
   18028:	20202020 20202020 20202020 20202020                     
   18038:	20202020 20202020 66202020 2820726f                for (
   18048:	203d2064 202d2074 20252074 72672e6e     d = t - t % n.gr
   18058:	6d2e6469 696c6c69 72655073 656e694c     id.millisPerLine
   18068:	2064203b 6c203d3e 2064203b 6e203d2d     ; d >= l; d -= n
   18078:	6972672e 696d2e64 73696c6c 4c726550     .grid.millisPerL
   18088:	29656e69 0a0d7b20 20202020 20202020     ine) {..        
   18098:	20202020 20202020 20202020 20202020                     
   180a8:	20202020 20202020 203d2075 29642868             u = h(d)
   180b8:	200a0d3b 20202020 20202020 20202020     ;..             
   180c8:	20202020 20202020 20202020 20202020                     
   180d8:	69202020 21282066 63732e6e 6c6c6f72        if (!n.scroll
   180e8:	6b636142 64726177 26262073 3c207520     Backwards && u <
   180f8:	7c204120 2e6e207c 6f726373 61426c6c      A || n.scrollBa
   18108:	61776b63 20736472 75202626 41203e20     ckwards && u > A
   18118:	0d7b2029 2020200a 20202020 20202020     ) {..           
   18128:	20202020 20202020 20202020 20202020                     
   18138:	20202020 20202020 72617620 3d204220              var B =
   18148:	77656e20 74614420 29642865 200a0d2c      new Date(d),.. 
   18158:	20202020 20202020 20202020 20202020                     
   18168:	20202020 20202020 20202020 20202020                     
   18178:	20202020 4c202020 6e203d20 6d69742e            L = n.tim
   18188:	61747365 6f46706d 74616d72 28726574     estampFormatter(
   18198:	0d2c2942 2020200a 20202020 20202020     B),..           
   181a8:	20202020 20202020 20202020 20202020                     
   181b8:	20202020 20202020 20202020 3d205720                  W =
   181c8:	6d2e7320 75736165 65546572 4c287478      s.measureText(L
   181d8:	69772e29 3b687464 20200a0d 20202020     ).width;..      
   181e8:	20202020 20202020 20202020 20202020                     
   181f8:	20202020 20202020 20202020 20412020                   A 
   18208:	2e6e203d 6f726373 61426c6c 61776b63     = n.scrollBackwa
   18218:	20736472 2075203f 2057202b 2032202b     rds ? u + W + 2 
   18228:	2075203a 2057202d 2c32202d 662e7320     : u - W - 2, s.f
   18238:	536c6c69 656c7974 6e203d20 62616c2e     illStyle = n.lab
   18248:	2e736c65 6c6c6966 6c797453 6e202c65     els.fillStyle, n
   18258:	7263732e 426c6c6f 776b6361 73647261     .scrollBackwards
   18268:	73203f20 6c69662e 7865546c 2c4c2874      ? s.fillText(L,
   18278:	202c7520 65682e72 74686769 32202d20      u, r.height - 2
   18288:	203a2029 69662e73 65546c6c 4c287478     ) : s.fillText(L
   18298:	2075202c 2c57202d 682e7220 68676965     , u - W, r.heigh
   182a8:	202d2074 0a0d2932 20202020 20202020     t - 2)..        
   182b8:	20202020 20202020 20202020 20202020                     
   182c8:	20202020 20202020 200a0d7d 20202020             }..     
   182d8:	20202020 20202020 20202020 20202020                     
   182e8:	20202020 7d202020 20200a0d 20202020            }..      
   182f8:	20202020 20202020 20202020 20202020                     
   18308:	0d7d2020 2020200a 20202020 20202020       }..           
   18318:	20202020 20202020 20202020 722e7320                  s.r
   18328:	6f747365 29286572 20200a0d 20202020     estore()..      
   18338:	20202020 20202020 20202020 2c7d2020                   },
   18348:	742e6120 46656d69 616d726f 72657474      a.timeFormatter
   18358:	66203d20 74636e75 286e6f69 7b202965      = function(e) {
   18368:	20200a0d 20202020 20202020 20202020     ..              
   18378:	20202020 20202020 75662020 6974636e               functi
   18388:	74206e6f 20296528 200a0d7b 20202020     on t(e) {..     
   18398:	20202020 20202020 20202020 20202020                     
   183a8:	20202020 72202020 72757465 6528206e            return (e
   183b8:	31203c20 203f2030 20223022 2222203a      < 10 ? "0" : ""
   183c8:	202b2029 200a0d65 20202020 20202020     ) + e..         
   183d8:	20202020 20202020 20202020 7d202020                    }
   183e8:	20200a0d 20202020 20202020 20202020     ..              
   183f8:	20202020 20202020 65722020 6e727574               return
   18408:	65287420 7465672e 72756f48 29292873      t(e.getHours())
   18418:	22202b20 2b20223a 65287420 7465672e      + ":" + t(e.get
   18428:	756e694d 28736574 2b202929 223a2220     Minutes()) + ":"
   18438:	74202b20 672e6528 65537465 646e6f63      + t(e.getSecond
   18448:	29292873 20200a0d 20202020 20202020     s())..          
   18458:	20202020 20202020 2c7d2020 542e6520               }, e.T
   18468:	53656d69 65697265 203d2073 65202c69     imeSeries = i, e
   18478:	6f6d532e 6968746f 61684365 3d207472     .SmoothieChart =
   18488:	0a0d6120 20202020 20202020 20202020      a..            
   18498:	20202020 7522287d 6665646e 64656e69         }("undefined
   184a8:	3d3d2022 70797420 20666f65 6f707865     " == typeof expo
   184b8:	20737472 6874203f 3a207369 70786520     rts ? this : exp
   184c8:	7374726f 0a0d3b29 20200a0d 20202020     orts);....      
   184d8:	20202020 20202020 61762020 6d732072               var sm
   184e8:	68746f6f 3d206569 77656e20 6f6d5320     oothie = new Smo
   184f8:	6968746f 61684365 29287472 200a0d3b     othieChart();.. 
   18508:	20202020 20202020 20202020 73202020                    s
   18518:	746f6f6d 2e656968 65727473 6f546d61     moothie.streamTo
   18528:	636f6428 6e656d75 65672e74 656c4574     (document.getEle
   18538:	746e656d 64497942 68632228 43747261     mentById("chartC
   18548:	61766e61 29292273 200a0d3b 20202020     anvas"));..     
   18558:	20202020 20202020 76202020 6c207261                var l
   18568:	31656e69 6e203d20 54207765 53656d69     ine1 = new TimeS
   18578:	65697265 3b292873 20200a0d 20202020     eries();..      
   18588:	20202020 20202020 65732020 746e4974               setInt
   18598:	61767265 7566286c 6974636e 29286e6f     erval(function()
   185a8:	0a0d7b20 20202020 20202020 20202020      {..            
   185b8:	20202020 20202020 656e696c 70612e31             line1.ap
   185c8:	646e6570 77656e28 74614420 2e292865     pend(new Date().
   185d8:	54746567 28656d69 4d202c29 2e687461     getTime(), Math.
   185e8:	646e6172 29286d6f 0a0d3b29 20202020     random());..    
   185f8:	20202020 20202020 20202020 31202c7d                 }, 1
   18608:	29303030 200a0d3b 20202020 20202020     000);..         
   18618:	20202020 73202020 746f6f6d 2e656968            smoothie.
   18628:	54646461 53656d69 65697265 696c2873     addTimeSeries(li
   18638:	2931656e 200a0d3b 20202020 20202020     ne1);..         
   18648:	3c202020 7263732f 3e747069 0a0d0a0d        </script>....
   18658:	6f622f3c 0d3e7964 3c0a0d0a 6d74682f     </body>....</htm
   18668:	00003e6c                                l>..

0001866c <data_io_shtml>:
   1866c:	2e6f692f 6d746873 213c006c 54434f44     /io.shtml.<!DOCT
   1867c:	20455059 4c4d5448 42555020 2043494c     YPE HTML PUBLIC 
   1868c:	2f2f2d22 2f433357 4454442f 4d544820     "-//W3C//DTD HTM
   1869c:	2e34204c 54203130 736e6172 6f697469     L 4.01 Transitio
   186ac:	2f6c616e 224e452f 74682220 2f3a7074     nal//EN" "http:/
   186bc:	7777772f 2e33772e 2f67726f 682f5254     /www.w3.org/TR/h
   186cc:	346c6d74 6f6f6c2f 642e6573 3e226474     tml4/loose.dtd">
   186dc:	683c0a0d 3e6c6d74 20200a0d 6165683c     ..<html>..  <hea
   186ec:	0a0d3e64 20202020 7469743c 463e656c     d>..    <title>F
   186fc:	52656572 2e534f54 2067726f 20504975     reeRTOS.org uIP 
   1870c:	20424557 76726573 64207265 3c6f6d65     WEB server demo<
   1871c:	7469742f 0d3e656c 3c20200a 6165682f     /title>..  </hea
   1872c:	0a0d3e64 423c2020 3e59444f 663c0a0d     d>..  <BODY>..<f
   1873c:	20746e6f 65636166 7261223d 226c6169     ont face="arial"
   1874c:	3c0a0d3e 72682061 223d6665 65646e69     >..<a href="inde
   1875c:	68732e78 226c6d74 7361543e 7453206b     x.shtml">Task St
   1876c:	3c737461 203e612f 7c3e623c 3e622f3c     ats</a> <b>|</b>
   1877c:	20613c20 66657268 7572223d 6d69746e      <a href="runtim
   1878c:	68732e65 226c6d74 6e75523e 6d695420     e.shtml">Run Tim
   1879c:	74532065 3c737461 203e612f 7c3e623c     e Stats</a> <b>|
   187ac:	3e622f3c 20613c20 66657268 7473223d     </b> <a href="st
   187bc:	2e737461 6d746873 543e226c 53205043     ats.shtml">TCP S
   187cc:	73746174 3e612f3c 3e623c20 622f3c7c     tats</a> <b>|</b
   187dc:	613c203e 65726820 74223d66 732e7063     > <a href="tcp.s
   187ec:	6c6d7468 6f433e22 63656e6e 6e6f6974     html">Connection
   187fc:	612f3c73 623c203e 2f3c7c3e 3c203e62     s</a> <b>|</b> <
   1880c:	72682061 223d6665 70747468 772f2f3a     a href="http://w
   1881c:	662e7777 72656572 2e736f74 2f67726f     ww.freertos.org/
   1882c:	72463e22 54526565 4820534f 70656d6f     ">FreeRTOS Homep
   1883c:	3c656761 203e612f 7c3e623c 3e622f3c     age</a> <b>|</b>
   1884c:	20613c20 66657268 6f69223d 7468732e      <a href="io.sht
   1885c:	3e226c6d 2f3c4f49 3c203e61 3c7c3e62     ml">IO</a> <b>|<
   1886c:	203e622f 6820613c 3d666572 676f6c22     /b> <a href="log
   1887c:	706a2e6f 333e2267 6a204b37 2f3c6770     o.jpg">37K jpg</
   1888c:	0a0d3e61 3e72623c 0d3e703c 72683c0a     a>..<br><p>..<hr
   1889c:	3c0a0d3e 454c3e62 6e612044 434c2064     >..<b>LED and LC
   188ac:	4f492044 3e622f3c 3e72623c 0a0d0a0d     D IO</b><br>....
   188bc:	0d3e703c 550a0d0a 74206573 63206568     <p>....Use the c
   188cc:	6b636568 786f6220 206f7420 6e727574     heck box to turn
   188dc:	206e6f20 6f20726f 4c206666 34204445      on or off LED 4
   188ec:	6874202c 63206e65 6b63696c 70552220     , then click "Up
   188fc:	65746164 224f4920 0d0a0d2e 3c0a0d0a     date IO".......<
   1890c:	0a0d3e70 726f663c 616e206d 223d656d     p>..<form name="
   1891c:	726f4661 6120226d 6f697463 2f223d6e     aForm" action="/
   1892c:	732e6f69 6c6d7468 656d2022 646f6874     io.shtml" method
   1893c:	6567223d 0d3e2274 2021250a 2d64656c     ="get">..%! led-
   1894c:	0a0d6f69 0d3e703c 6e693c0a 20747570     io..<p>..<input 
   1895c:	65707974 7573223d 74696d62 61762022     type="submit" va
   1896c:	3d65756c 64705522 20657461 3e224f49     lue="Update IO">
   1897c:	2f3c0a0d 6d726f66 3c0a0d3e 3c3e7262     ..</form>..<br><
   1898c:	0a0d3e70 6f662f3c 0d3e746e 622f3c0a     p>..</font>..</b
   1899c:	3e79646f 2f3c0a0d 6c6d7468 0d0a0d3e     ody>..</html>...
   189ac:	0000000a                                ....

000189b0 <data_runtime_shtml>:
   189b0:	6e75722f 656d6974 7468732e 3c006c6d     /runtime.shtml.<
   189c0:	434f4421 45505954 4d544820 5550204c     !DOCTYPE HTML PU
   189d0:	43494c42 2f2d2220 4333572f 54442f2f     BLIC "-//W3C//DT
   189e0:	54482044 34204c4d 2031302e 6e617254     D HTML 4.01 Tran
   189f0:	69746973 6c616e6f 4e452f2f 68222022     sitional//EN" "h
   18a00:	3a707474 77772f2f 33772e77 67726f2e     ttp://www.w3.org
   18a10:	2f52542f 6c6d7468 6f6c2f34 2e65736f     /TR/html4/loose.
   18a20:	22647464 3c0a0d3e 6c6d7468 200a0d3e     dtd">..<html>.. 
   18a30:	65683c20 0d3e6461 2020200a 69743c20      <head>..    <ti
   18a40:	3e656c74 65657246 534f5452 67726f2e     tle>FreeRTOS.org
   18a50:	50497520 42455720 72657320 20726576      uIP WEB server 
   18a60:	6f6d6564 69742f3c 3e656c74 20200a0d     demo</title>..  
   18a70:	65682f3c 0d3e6461 3c20200a 59444f42     </head>..  <BODY
   18a80:	4c6e6f20 3d64616f 6e697722 2e776f64      onLoad="window.
   18a90:	54746573 6f656d69 26287475 746f7571     setTimeout(&quot
   18aa0:	636f6c3b 6f697461 72682e6e 273d6665     ;location.href='
   18ab0:	746e7572 2e656d69 6d746873 7126276c     runtime.shtml'&q
   18ac0:	3b746f75 3030322c 3e222930 663c0a0d     uot;,2000)">..<f
   18ad0:	20746e6f 65636166 7261223d 226c6169     ont face="arial"
   18ae0:	3c0a0d3e 72682061 223d6665 65646e69     >..<a href="inde
   18af0:	68732e78 226c6d74 7361543e 7453206b     x.shtml">Task St
   18b00:	3c737461 203e612f 7c3e623c 3e622f3c     ats</a> <b>|</b>
   18b10:	20613c20 66657268 7572223d 6d69746e      <a href="runtim
   18b20:	68732e65 226c6d74 6e75523e 6d695420     e.shtml">Run Tim
   18b30:	74532065 3c737461 203e612f 7c3e623c     e Stats</a> <b>|
   18b40:	3e622f3c 20613c20 66657268 7473223d     </b> <a href="st
   18b50:	2e737461 6d746873 543e226c 53205043     ats.shtml">TCP S
   18b60:	73746174 3e612f3c 3e623c20 622f3c7c     tats</a> <b>|</b
   18b70:	613c203e 65726820 74223d66 732e7063     > <a href="tcp.s
   18b80:	6c6d7468 6f433e22 63656e6e 6e6f6974     html">Connection
   18b90:	612f3c73 623c203e 2f3c7c3e 3c203e62     s</a> <b>|</b> <
   18ba0:	72682061 223d6665 70747468 772f2f3a     a href="http://w
   18bb0:	662e7777 72656572 2e736f74 2f67726f     ww.freertos.org/
   18bc0:	72463e22 54526565 4820534f 70656d6f     ">FreeRTOS Homep
   18bd0:	3c656761 203e612f 7c3e623c 3e622f3c     age</a> <b>|</b>
   18be0:	20613c20 66657268 6f69223d 7468732e      <a href="io.sht
   18bf0:	3e226c6d 2f3c4f49 3c203e61 3c7c3e62     ml">IO</a> <b>|<
   18c00:	203e622f 6820613c 3d666572 676f6c22     /b> <a href="log
   18c10:	706a2e6f 333e2267 6a204b37 2f3c6770     o.jpg">37K jpg</
   18c20:	0a0d3e61 3e72623c 0d3e703c 72683c0a     a>..<br><p>..<hr
   18c30:	3c0a0d3e 3c3e7262 0a0d3e70 3e32683c     >..<br><p>..<h2>
   18c40:	2d6e7552 656d6974 61747320 74736974     Run-time statist
   18c50:	3c736369 3e32682f 61500a0d 77206567     ics</h2>..Page w
   18c60:	206c6c69 72666572 20687365 72657665     ill refresh ever
   18c70:	20322079 6f636573 2e73646e 0d3e703c     y 2 seconds.<p>.
   18c80:	6f663c0a 6620746e 3d656361 756f6322     .<font face="cou
   18c90:	72656972 703c3e22 543e6572 206b7361     rier"><pre>Task 
   18ca0:	20202020 20202020 41202020 54207362                Abs T
   18cb0:	20656d69 20202020 54202520 3c656d69     ime      % Time<
   18cc0:	2a3e7262 2a2a2a2a 2a2a2a2a 2a2a2a2a     br>*************
   18cd0:	2a2a2a2a 2a2a2a2a 2a2a2a2a 2a2a2a2a     ****************
   18ce0:	2a2a2a2a 2a2a2a2a 3c2a2a2a 0d3e7262     ***********<br>.
   18cf0:	2021250a 2d6e7572 656d6974 2f3c0a0d     .%! run-time..</
   18d00:	3e657270 6f662f3c 0d3e746e 662f3c0a     pre></font>..</f
   18d10:	3e746e6f 2f3c0a0d 79646f62 3c0a0d3e     ont>..</body>..<
   18d20:	6d74682f 0a0d3e6c 00000a0d              /html>......

00018d2c <data_smoothie_min_js>:
   18d2c:	6f6d732f 6968746f 696d5f65 736a2e6e     /smoothie_min.js
   18d3c:	66202100 74636e75 286e6f69 7b202965     .! function(e) {
   18d4c:	72617620 3d207420 65207b20 6e657478      var t = { exten
   18d5c:	66203a64 74636e75 286e6f69 207b2029     d: function() { 
   18d6c:	75677261 746e656d 5d305b73 61203d20     arguments[0] = a
   18d7c:	6d756772 73746e65 205d305b 7b207c7c     rguments[0] || {
   18d8c:	66203b7d 2820726f 20726176 203d2065     }; for (var e = 
   18d9c:	65203b31 61203c20 6d756772 73746e65     1; e < arguments
   18dac:	6e656c2e 3b687467 2b206520 2931203d     .length; e += 1)
   18dbc:	2020200a 20202020 20202020 20202020     .               
   18dcc:	726f6620 61762820 20692072 61206e69      for (var i in a
   18ddc:	6d756772 73746e65 295d655b 67726120     rguments[e]) arg
   18dec:	6e656d75 655b7374 61682e5d 6e774f73     uments[e].hasOwn
   18dfc:	706f7250 79747265 20296928 28202626     Property(i) && (
   18e0c:	6a626f22 22746365 203d3d20 65707974     "object" == type
   18e1c:	6120666f 6d756772 73746e65 5b5d655b     of arguments[e][
   18e2c:	3f205d69 67726120 6e656d75 655b7374     i] ? arguments[e
   18e3c:	5d695b5d 736e6920 636e6174 20666f65     ][i] instanceof 
   18e4c:	61727241 203f2079 75677261 746e656d     Array ? argument
   18e5c:	5d305b73 205d695b 7261203d 656d7567     s[0][i] = argume
   18e6c:	5b73746e 695b5d65 203a205d 75677261     nts[e][i] : argu
   18e7c:	746e656d 5d305b73 205d695b 2e74203d     ments[0][i] = t.
   18e8c:	65747865 6128646e 6d756772 73746e65     extend(arguments
   18e9c:	5b5d305b 202c5d69 75677261 746e656d     [0][i], argument
   18eac:	5d655b73 295d695b 61203a20 6d756772     s[e][i]) : argum
   18ebc:	73746e65 5b5d305b 3d205d69 67726120     ents[0][i] = arg
   18ecc:	6e656d75 655b7374 5d695b5d 72203b29     uments[e][i]); r
   18edc:	72757465 7261206e 656d7567 5b73746e     eturn arguments[
   18eec:	7d205d30 0a3b7d20 2020200a 6e756620     0] } };..    fun
   18efc:	6f697463 2869206e 7b202965 69687420     ction i(e) { thi
   18f0c:	706f2e73 6e6f6974 203d2073 78652e74     s.options = t.ex
   18f1c:	646e6574 2c7d7b28 642e6920 75616665     tend({}, i.defau
   18f2c:	704f746c 6e6f6974 65202c73 74202c29     ltOptions, e), t
   18f3c:	2e736968 61656c63 20292872 200a0a7d     his.clear() }.. 
   18f4c:	66202020 74636e75 206e6f69 29652861        function a(e)
   18f5c:	74207b20 2e736968 6974706f 20736e6f      { this.options 
   18f6c:	2e74203d 65747865 7b28646e 61202c7d     = t.extend({}, a
   18f7c:	6665642e 746c7561 72616843 74704f74     .defaultChartOpt
   18f8c:	736e6f69 2965202c 6874202c 732e7369     ions, e), this.s
   18f9c:	65697265 74655373 5b203d20 74202c5d     eriesSet = [], t
   18fac:	2e736968 72727563 56746e65 65756c61     his.currentValue
   18fbc:	676e6152 203d2065 74202c31 2e736968     Range = 1, this.
   18fcc:	72727563 56746e65 694d7369 6c61566e     currentVisMinVal
   18fdc:	3d206575 202c3020 73696874 73616c2e     ue = 0, this.las
   18fec:	6e655274 54726564 4d656d69 696c6c69     tRenderTimeMilli
   18ffc:	203d2073 0a7d2030 20202020 65642e69     s = 0 }.    i.de
   1900c:	6c756166 74704f74 736e6f69 7b203d20     faultOptions = {
   1901c:	73657220 6f427465 73646e75 65746e49      resetBoundsInte
   1902c:	6c617672 6533203a 72202c33 74657365     rval: 3e3, reset
   1903c:	6e756f42 203a7364 7d203021 2e69202c     Bounds: !0 }, i.
   1904c:	746f7270 7079746f 6c632e65 20726165     prototype.clear 
   1905c:	7566203d 6974636e 29286e6f 74207b20     = function() { t
   1906c:	2e736968 61746164 5b203d20 74202c5d     his.data = [], t
   1907c:	2e736968 5678616d 65756c61 4e203d20     his.maxValue = N
   1908c:	65626d75 614e2e72 74202c4e 2e736968     umber.NaN, this.
   1909c:	566e696d 65756c61 4e203d20 65626d75     minValue = Numbe
   190ac:	614e2e72 2c7d204e 702e6920 6f746f72     r.NaN }, i.proto
   190bc:	65707974 7365722e 6f427465 73646e75     type.resetBounds
   190cc:	66203d20 74636e75 286e6f69 207b2029      = function() { 
   190dc:	28206669 73696874 7461642e 656c2e61     if (this.data.le
   190ec:	6874676e 207b2029 73696874 78616d2e     ngth) { this.max
   190fc:	756c6156 203d2065 73696874 7461642e     Value = this.dat
   1910c:	5d305b61 2c5d315b 69687420 696d2e73     a[0][1], this.mi
   1911c:	6c61566e 3d206575 69687420 61642e73     nValue = this.da
   1912c:	305b6174 5d315b5d 6f66203b 76282072     ta[0][1]; for (v
   1913c:	65207261 31203d20 2065203b 6874203c     ar e = 1; e < th
   1914c:	642e7369 2e617461 676e656c 203b6874     is.data.length; 
   1915c:	3d2b2065 20293120 6176207b 20742072     e += 1) { var t 
   1916c:	6874203d 642e7369 5b617461 315b5d65     = this.data[e][1
   1917c:	200a3b5d 20202020 20202020 20202020     ];.             
   1918c:	74202020 74203e20 2e736968 5678616d        t > this.maxV
   1919c:	65756c61 20262620 69687428 616d2e73     alue && (this.ma
   191ac:	6c615678 3d206575 2c297420 3c207420     xValue = t), t <
   191bc:	69687420 696d2e73 6c61566e 26206575      this.minValue &
   191cc:	74282026 2e736968 566e696d 65756c61     & (this.minValue
   191dc:	74203d20 207d2029 6c65207d 74206573      = t) } } else t
   191ec:	2e736968 5678616d 65756c61 4e203d20     his.maxValue = N
   191fc:	65626d75 614e2e72 74202c4e 2e736968     umber.NaN, this.
   1920c:	566e696d 65756c61 4e203d20 65626d75     minValue = Numbe
   1921c:	614e2e72 2c7d204e 702e6920 6f746f72     r.NaN }, i.proto
   1922c:	65707974 7070612e 20646e65 7566203d     type.append = fu
   1923c:	6974636e 65286e6f 2c74202c 20296920     nction(e, t, i) 
   1924c:	6f66207b 76282072 61207261 74203d20     { for (var a = t
   1925c:	2e736968 61746164 6e656c2e 20687467     his.data.length 
   1926c:	3b31202d 3e206120 2030203d 74202626     - 1; a >= 0 && t
   1927c:	2e736968 61746164 5b5d615b 3e205d30     his.data[a][0] >
   1928c:	293b6520 2d206120 3b31203d 31202d20      e;) a -= 1; - 1
   1929c:	3d3d3d20 3f206120 69687420 61642e73      === a ? this.da
   192ac:	732e6174 63696c70 2c302865 202c3020     ta.splice(0, 0, 
   192bc:	202c655b 20295d74 6874203a 642e7369     [e, t]) : this.d
   192cc:	2e617461 676e656c 3e206874 26203020     ata.length > 0 &
   192dc:	68742026 642e7369 5b617461 305b5d61     & this.data[a][0
   192ec:	3d3d205d 2065203d 2069203f 7428203f     ] === e ? i ? (t
   192fc:	2e736968 61746164 5b5d615b 2b205d31     his.data[a][1] +
   1930c:	2c74203d 3d207420 69687420 61642e73     = t, t = this.da
   1931c:	615b6174 5d315b5d 203a2029 73696874     ta[a][1]) : this
   1932c:	7461642e 5d615b61 205d315b 2074203d     .data[a][1] = t 
   1933c:	2061203a 6874203c 642e7369 2e617461     : a < this.data.
   1934c:	676e656c 2d206874 3f203120 69687420     length - 1 ? thi
   1935c:	61642e73 732e6174 63696c70 20612865     s.data.splice(a 
   1936c:	2c31202b 202c3020 202c655b 20295d74     + 1, 0, [e, t]) 
   1937c:	6874203a 642e7369 2e617461 68737570     : this.data.push
   1938c:	2c655b28 295d7420 6874202c 6d2e7369     ([e, t]), this.m
   1939c:	61567861 2065756c 7369203d 284e614e     axValue = isNaN(
   193ac:	73696874 78616d2e 756c6156 3f202965     this.maxValue) ?
   193bc:	3a207420 74614d20 616d2e68 68742878      t : Math.max(th
   193cc:	6d2e7369 61567861 2c65756c 2c297420     is.maxValue, t),
   193dc:	69687420 696d2e73 6c61566e 3d206575      this.minValue =
   193ec:	4e736920 74284e61 2e736968 566e696d      isNaN(this.minV
   193fc:	65756c61 203f2029 203a2074 6874614d     alue) ? t : Math
   1940c:	6e696d2e 69687428 696d2e73 6c61566e     .min(this.minVal
   1941c:	202c6575 7d202974 2e69202c 746f7270     ue, t) }, i.prot
   1942c:	7079746f 72642e65 6c4f706f 74614464     otype.dropOldDat
   1943c:	203d2061 636e7566 6e6f6974 202c6528     a = function(e, 
   1944c:	7b202974 726f6620 61762820 20692072     t) { for (var i 
   1945c:	3b30203d 69687420 61642e73 6c2e6174     = 0; this.data.l
   1946c:	74676e65 202d2068 3d3e2069 26207420     ength - i >= t &
   1947c:	68742026 642e7369 5b617461 202b2069     & this.data[i + 
   1948c:	305b5d31 203c205d 20293b65 3d2b2069     1][0] < e;) i +=
   1949c:	0a3b3120 20202020 20202020 3d212030      1;.        0 !=
   194ac:	2069203d 74202626 2e736968 61746164     = i && this.data
   194bc:	6c70732e 28656369 69202c30 2c7d2029     .splice(0, i) },
   194cc:	642e6120 75616665 6843746c 4f747261      a.defaultChartO
   194dc:	6f697470 3d20736e 6d207b20 696c6c69     ptions = { milli
   194ec:	72655073 65786950 32203a6c 65202c30     sPerPixel: 20, e
   194fc:	6c62616e 69704465 6c616353 3a676e69     nableDpiScaling:
   1950c:	2c302120 694d7920 726f466e 7474616d      !0, yMinFormatt
   1951c:	203a7265 636e7566 6e6f6974 202c6528     er: function(e, 
   1952c:	7b202974 74657220 206e7275 73726170     t) { return pars
   1953c:	6f6c4665 65287461 6f742e29 65786946     eFloat(e).toFixe
   1954c:	29742864 202c7d20 78614d79 6d726f46     d(t) }, yMaxForm
   1955c:	65747461 66203a72 74636e75 286e6f69     atter: function(
   1956c:	74202c65 207b2029 75746572 70206e72     e, t) { return p
   1957c:	65737261 616f6c46 29652874 466f742e     arseFloat(e).toF
   1958c:	64657869 20297428 6d202c7d 61567861     ixed(t) }, maxVa
   1959c:	5365756c 656c6163 2c31203a 6e696d20     lueScale: 1, min
   195ac:	756c6156 61635365 203a656c 69202c31     ValueScale: 1, i
   195bc:	7265746e 616c6f70 6e6f6974 6222203a     nterpolation: "b
   195cc:	65697a65 202c2272 6c616373 6f6d5365     ezier", scaleSmo
   195dc:	6968746f 203a676e 3532312e 616d202c     othing: .125, ma
   195ec:	74614478 74655361 676e654c 203a6874     xDataSetLength: 
   195fc:	73202c32 6c6f7263 6361426c 7261776b     2, scrollBackwar
   1960c:	203a7364 202c3121 64697267 207b203a     ds: !1, grid: { 
   1961c:	6c6c6966 6c797453 22203a65 30303023     fillStyle: "#000
   1962c:	22303030 7473202c 656b6f72 6c797453     000", strokeStyl
   1963c:	22203a65 37373723 22373737 696c202c     e: "#777777", li
   1964c:	6957656e 3a687464 202c3120 72616873     neWidth: 1, shar
   1965c:	6e694c70 203a7365 202c3121 6c6c696d     pLines: !1, mill
   1966c:	65507369 6e694c72 31203a65 202c3365     isPerLine: 1e3, 
   1967c:	74726576 6c616369 74636553 736e6f69     verticalSections
   1968c:	2c32203a 726f6220 56726564 62697369     : 2, borderVisib
   1969c:	203a656c 7d203021 616c202c 736c6562     le: !0 }, labels
   196ac:	207b203a 6c6c6966 6c797453 22203a65     : { fillStyle: "
   196bc:	66666623 22666666 6964202c 6c626173     #ffffff", disabl
   196cc:	203a6465 202c3121 746e6f66 657a6953     ed: !1, fontSize
   196dc:	3031203a 6f66202c 6146746e 796c696d     : 10, fontFamily
   196ec:	6d22203a 736f6e6f 65636170 70202c22     : "monospace", p
   196fc:	69636572 6e6f6973 2032203a 68202c7d     recision: 2 }, h
   1970c:	7a69726f 61746e6f 6e694c6c 203a7365     orizontalLines: 
   1971c:	7d205d5b 2e61202c 6d696e41 43657461     [] }, a.AnimateC
   1972c:	61706d6f 69626974 7974696c 7b203d20     ompatibility = {
   1973c:	71657220 74736575 6d696e41 6f697461      requestAnimatio
   1974c:	6172466e 203a656d 636e7566 6e6f6974     nFrame: function
   1975c:	202c6528 7b202974 74657220 206e7275     (e, t) { return 
   1976c:	6e697728 2e776f64 75716572 41747365     (window.requestA
   1977c:	616d696e 6e6f6974 6d617246 7c7c2065     nimationFrame ||
   1978c:	6e697720 2e776f64 6b626577 65527469      window.webkitRe
   1979c:	73657571 696e4174 6974616d 72466e6f     questAnimationFr
   197ac:	20656d61 77207c7c 6f646e69 6f6d2e77     ame || window.mo
   197bc:	7165527a 74736575 6d696e41 6f697461     zRequestAnimatio
   197cc:	6172466e 7c20656d 6977207c 776f646e     nFrame || window
   197dc:	65526f2e 73657571 696e4174 6974616d     .oRequestAnimati
   197ec:	72466e6f 20656d61 77207c7c 6f646e69     onFrame || windo
   197fc:	736d2e77 75716552 41747365 616d696e     w.msRequestAnima
   1980c:	6e6f6974 6d617246 7c7c2065 6e756620     tionFrame || fun
   1981c:	6f697463 2965286e 72207b20 72757465     ction(e) { retur
   1982c:	6977206e 776f646e 7465732e 656d6954     n window.setTime
   1983c:	2874756f 636e7566 6e6f6974 7b202928     out(function() {
   1984c:	28286520 2077656e 65746144 65672e29      e((new Date).ge
   1985c:	6d695474 29292865 202c7d20 20293631     tTime()) }, 16) 
   1986c:	632e297d 286c6c61 646e6977 202c776f     }).call(window, 
   1987c:	74202c65 2c7d2029 6e616320 416c6563     e, t) }, cancelA
   1988c:	616d696e 6e6f6974 6d617246 66203a65     nimationFrame: f
   1989c:	74636e75 286e6f69 7b202965 74657220     unction(e) { ret
   198ac:	206e7275 6e697728 2e776f64 636e6163     urn (window.canc
   198bc:	6e416c65 74616d69 466e6f69 656d6172     elAnimationFrame
   198cc:	207c7c20 636e7566 6e6f6974 20296528      || function(e) 
   198dc:	6c63207b 54726165 6f656d69 65287475     { clearTimeout(e
   198ec:	297d2029 6c61632e 6977286c 776f646e     ) }).call(window
   198fc:	2965202c 7d207d20 2e61202c 61666564     , e) } }, a.defa
   1990c:	53746c75 65697265 65725073 746e6573     ultSeriesPresent
   1991c:	6f697461 74704f6e 736e6f69 7b203d20     ationOptions = {
   1992c:	6e696c20 64695765 203a6874 73202c31      lineWidth: 1, s
   1993c:	6b6f7274 79745365 203a656c 66662322     trokeStyle: "#ff
   1994c:	66666666 2c7d2022 702e6120 6f746f72     ffff" }, a.proto
   1995c:	65707974 6464612e 656d6954 69726553     type.addTimeSeri
   1996c:	3d207365 6e756620 6f697463 2c65286e     es = function(e,
   1997c:	20296920 6874207b 732e7369 65697265      i) { this.serie
   1998c:	74655373 7375702e 207b2868 656d6974     sSet.push({ time
   1999c:	69726553 203a7365 6f202c65 6f697470     Series: e, optio
   199ac:	203a736e 78652e74 646e6574 2c7d7b28     ns: t.extend({},
   199bc:	642e6120 75616665 6553746c 73656972      a.defaultSeries
   199cc:	73657250 61746e65 6e6f6974 6974704f     PresentationOpti
   199dc:	2c736e6f 20296920 202c297d 706f2e65     ons, i) }), e.op
   199ec:	6e6f6974 65722e73 42746573 646e756f     tions.resetBound
   199fc:	26262073 6f2e6520 6f697470 722e736e     s && e.options.r
   19a0c:	74657365 6e756f42 6e497364 76726574     esetBoundsInterv
   19a1c:	3e206c61 26203020 65282026 7365722e     al > 0 && (e.res
   19a2c:	6f427465 73646e75 656d6954 20644972     etBoundsTimerId 
   19a3c:	6573203d 746e4974 61767265 7566286c     = setInterval(fu
   19a4c:	6974636e 29286e6f 65207b20 7365722e     nction() { e.res
   19a5c:	6f427465 73646e75 7d202928 2e65202c     etBounds() }, e.
   19a6c:	6974706f 2e736e6f 65736572 756f4274     options.resetBou
   19a7c:	4973646e 7265746e 296c6176 2c7d2029     ndsInterval)) },
   19a8c:	702e6120 6f746f72 65707974 6d65722e      a.prototype.rem
   19a9c:	5465766f 53656d69 65697265 203d2073     oveTimeSeries = 
   19aac:	636e7566 6e6f6974 20296528 6f66207b     function(e) { fo
   19abc:	76282072 74207261 74203d20 2e736968     r (var t = this.
   19acc:	69726573 65537365 656c2e74 6874676e     seriesSet.length
   19adc:	2069202c 3b30203d 3c206920 203b7420     , i = 0; i < t; 
   19aec:	3d2b2069 0a293120 20202020 20202020     i += 1).        
   19afc:	20202020 28206669 73696874 7265732e         if (this.ser
   19b0c:	53736569 695b7465 69742e5d 6553656d     iesSet[i].timeSe
   19b1c:	73656972 3d3d3d20 20296520 6874207b     ries === e) { th
   19b2c:	732e7369 65697265 74655373 6c70732e     is.seriesSet.spl
   19b3c:	28656369 31202c69 62203b29 6b616572     ice(i, 1); break
   19b4c:	200a7d20 20202020 65202020 7365722e      }.        e.res
   19b5c:	6f427465 73646e75 656d6954 20644972     etBoundsTimerId 
   19b6c:	63202626 7261656c 65746e49 6c617672     && clearInterval
   19b7c:	722e6528 74657365 6e756f42 69547364     (e.resetBoundsTi
   19b8c:	4972656d 7d202964 2e61202c 746f7270     merId) }, a.prot
   19b9c:	7079746f 65672e65 6d695474 72655365     otype.getTimeSer
   19bac:	4f736569 6f697470 3d20736e 6e756620     iesOptions = fun
   19bbc:	6f697463 2965286e 66207b20 2820726f     ction(e) { for (
   19bcc:	20726176 203d2074 73696874 7265732e     var t = this.ser
   19bdc:	53736569 6c2e7465 74676e65 69202c68     iesSet.length, i
   19bec:	30203d20 2069203b 3b74203c 2b206920      = 0; i < t; i +
   19bfc:	2931203d 2020200a 20202020 20202020     = 1).           
   19c0c:	20666920 69687428 65732e73 73656972      if (this.series
   19c1c:	5b746553 742e5d69 53656d69 65697265     Set[i].timeSerie
   19c2c:	3d3d2073 2965203d 74657220 206e7275     s === e) return 
   19c3c:	73696874 7265732e 53736569 695b7465     this.seriesSet[i
   19c4c:	706f2e5d 6e6f6974 2c7d2073 702e6120     ].options }, a.p
   19c5c:	6f746f72 65707974 6972622e 6f54676e     rototype.bringTo
   19c6c:	6e6f7246 203d2074 636e7566 6e6f6974     Front = function
   19c7c:	20296528 6f66207b 76282072 74207261     (e) { for (var t
   19c8c:	74203d20 2e736968 69726573 65537365      = this.seriesSe
   19c9c:	656c2e74 6874676e 2069202c 3b30203d     t.length, i = 0;
   19cac:	3c206920 203b7420 3d2b2069 0a293120      i < t; i += 1).
   19cbc:	20202020 20202020 20202020 28206669                 if (
   19ccc:	73696874 7265732e 53736569 695b7465     this.seriesSet[i
   19cdc:	69742e5d 6553656d 73656972 3d3d3d20     ].timeSeries ===
   19cec:	20296520 6176207b 20612072 6874203d      e) { var a = th
   19cfc:	732e7369 65697265 74655373 6c70732e     is.seriesSet.spl
   19d0c:	28656369 31202c69 200a3b29 20202020     ice(i, 1);.     
   19d1c:	20202020 20202020 74202020 2e736968                this.
   19d2c:	69726573 65537365 75702e74 61286873     seriesSet.push(a
   19d3c:	295d305b 7262203b 206b6165 2c7d207d     [0]); break } },
   19d4c:	702e6120 6f746f72 65707974 7274732e      a.prototype.str
   19d5c:	546d6165 203d206f 636e7566 6e6f6974     eamTo = function
   19d6c:	202c6528 7b202974 69687420 61632e73     (e, t) { this.ca
   19d7c:	7361766e 65203d20 6874202c 642e7369     nvas = e, this.d
   19d8c:	79616c65 74203d20 6874202c 732e7369     elay = t, this.s
   19d9c:	74726174 7d202928 2e61202c 746f7270     tart() }, a.prot
   19dac:	7079746f 65722e65 657a6973 66203d20     otype.resize = f
   19dbc:	74636e75 286e6f69 207b2029 28206669     unction() { if (
   19dcc:	73696874 74706f2e 736e6f69 616e652e     this.options.ena
   19ddc:	44656c62 63536970 6e696c61 26262067     bleDpiScaling &&
   19dec:	6e697720 20776f64 31202626 3d3d2120      window && 1 !==
   19dfc:	6e697720 2e776f64 69766564 69506563      window.devicePi
   19e0c:	526c6578 6f697461 207b2029 20726176     xelRatio) { var 
   19e1c:	203d2065 646e6977 642e776f 63697665     e = window.devic
   19e2c:	78695065 61526c65 2c6f6974 2020200a     ePixelRatio,.   
   19e3c:	20202020 20202020 20202020 3d207420                  t =
   19e4c:	72617020 6e496573 68742874 632e7369      parseInt(this.c
   19e5c:	61766e61 65672e73 74744174 75626972     anvas.getAttribu
   19e6c:	22286574 74646977 29292268 20200a2c     te("width")),.  
   19e7c:	20202020 20202020 20202020 20692020                   i 
   19e8c:	6170203d 49657372 7428746e 2e736968     = parseInt(this.
   19e9c:	766e6163 672e7361 74417465 62697274     canvas.getAttrib
   19eac:	28657475 69656822 22746867 0a3b2929     ute("height"));.
   19ebc:	20202020 20202020 20202020 73696874                 this
   19ecc:	69726f2e 616e6967 6469576c 26206874     .originalWidth &
   19edc:	614d2026 662e6874 726f6f6c 69687428     & Math.floor(thi
   19eec:	726f2e73 6e696769 69576c61 20687464     s.originalWidth 
   19efc:	2965202a 3d3d3d20 7c207420 7428207c     * e) === t || (t
   19f0c:	2e736968 6769726f 6c616e69 74646957     his.originalWidt
   19f1c:	203d2068 74202c74 2e736968 766e6163     h = t, this.canv
   19f2c:	732e7361 74417465 62697274 28657475     as.setAttribute(
   19f3c:	64697722 2c226874 74614d20 6c662e68     "width", Math.fl
   19f4c:	28726f6f 202a2074 742e2965 7274536f     oor(t * e).toStr
   19f5c:	28676e69 202c2929 73696874 6e61632e     ing()), this.can
   19f6c:	2e736176 6c797473 69772e65 20687464     vas.style.width 
   19f7c:	2074203d 7022202b 202c2278 73696874     = t + "px", this
   19f8c:	6e61632e 2e736176 43746567 65746e6f     .canvas.getConte
   19f9c:	22287478 29226432 6163732e 6528656c     xt("2d").scale(e
   19fac:	2965202c 74202c29 2e736968 6769726f     , e)), this.orig
   19fbc:	6c616e69 67696548 26207468 614d2026     inalHeight && Ma
   19fcc:	662e6874 726f6f6c 69687428 726f2e73     th.floor(this.or
   19fdc:	6e696769 65486c61 74686769 65202a20     iginalHeight * e
   19fec:	3d3d2029 2069203d 28207c7c 73696874     ) === i || (this
   19ffc:	69726f2e 616e6967 6965486c 20746867     .originalHeight 
   1a00c:	2c69203d 69687420 61632e73 7361766e     = i, this.canvas
   1a01c:	7465732e 72747441 74756269 68222865     .setAttribute("h
   1a02c:	68676965 202c2274 6874614d 6f6c662e     eight", Math.flo
   1a03c:	6928726f 65202a20 6f742e29 69727453     or(i * e).toStri
   1a04c:	2928676e 74202c29 2e736968 766e6163     ng()), this.canv
   1a05c:	732e7361 656c7974 6965682e 20746867     as.style.height 
   1a06c:	2069203d 7022202b 202c2278 73696874     = i + "px", this
   1a07c:	6e61632e 2e736176 43746567 65746e6f     .canvas.getConte
   1a08c:	22287478 29226432 6163732e 6528656c     xt("2d").scale(e
   1a09c:	2965202c 207d2029 61202c7d 6f72702e     , e)) } }, a.pro
   1a0ac:	79746f74 732e6570 74726174 66203d20     totype.start = f
   1a0bc:	74636e75 286e6f69 207b2029 28206669     unction() { if (
   1a0cc:	69687421 72662e73 29656d61 76207b20     !this.frame) { v
   1a0dc:	65207261 66203d20 74636e75 286e6f69     ar e = function(
   1a0ec:	207b2029 73696874 6172662e 3d20656d     ) { this.frame =
   1a0fc:	412e6120 616d696e 6f436574 7461706d      a.AnimateCompat
   1a10c:	6c696269 2e797469 75716572 41747365     ibility.requestA
   1a11c:	616d696e 6e6f6974 6d617246 75662865     nimationFrame(fu
   1a12c:	6974636e 29286e6f 74207b20 2e736968     nction() { this.
   1a13c:	646e6572 29287265 2865202c 2e7d2029     render(), e() }.
   1a14c:	646e6962 69687428 20292973 69622e7d     bind(this)) }.bi
   1a15c:	7428646e 29736968 20200a3b 20202020     nd(this);.      
   1a16c:	20202020 28652020 207d2029 61202c7d           e() } }, a
   1a17c:	6f72702e 79746f74 732e6570 20706f74     .prototype.stop 
   1a18c:	7566203d 6974636e 29286e6f 74207b20     = function() { t
   1a19c:	2e736968 6d617266 26262065 2e612820     his.frame && (a.
   1a1ac:	6d696e41 43657461 61706d6f 69626974     AnimateCompatibi
   1a1bc:	7974696c 6e61632e 416c6563 616d696e     lity.cancelAnima
   1a1cc:	6e6f6974 6d617246 68742865 662e7369     tionFrame(this.f
   1a1dc:	656d6172 64202c29 74656c65 68742065     rame), delete th
   1a1ec:	662e7369 656d6172 2c7d2029 702e6120     is.frame) }, a.p
   1a1fc:	6f746f72 65707974 6470752e 56657461     rototype.updateV
   1a20c:	65756c61 676e6152 203d2065 636e7566     alueRange = func
   1a21c:	6e6f6974 7b202928 726f6620 61762820     tion() { for (va
   1a22c:	20652072 6874203d 6f2e7369 6f697470     r e = this.optio
   1a23c:	202c736e 203d2074 626d754e 4e2e7265     ns, t = Number.N
   1a24c:	202c4e61 203d2069 626d754e 4e2e7265     aN, i = Number.N
   1a25c:	202c4e61 203d2061 61203b30 74203c20     aN, a = 0; a < t
   1a26c:	2e736968 69726573 65537365 656c2e74     his.seriesSet.le
   1a27c:	6874676e 2061203b 31203d2b 207b2029     ngth; a += 1) { 
   1a28c:	20726176 203d2073 73696874 7265732e     var s = this.ser
   1a29c:	53736569 615b7465 69742e5d 6553656d     iesSet[a].timeSe
   1a2ac:	73656972 20200a3b 20202020 20202020     ries;.          
   1a2bc:	73692020 284e614e 616d2e73 6c615678       isNaN(s.maxVal
   1a2cc:	20296575 28207c7c 203d2074 614e7369     ue) || (t = isNa
   1a2dc:	2974284e 73203f20 78616d2e 756c6156     N(t) ? s.maxValu
   1a2ec:	203a2065 6874614d 78616d2e 202c7428     e : Math.max(t, 
   1a2fc:	616d2e73 6c615678 29296575 7369202c     s.maxValue)), is
   1a30c:	284e614e 696d2e73 6c61566e 20296575     NaN(s.minValue) 
   1a31c:	28207c7c 203d2069 614e7369 2969284e     || (i = isNaN(i)
   1a32c:	73203f20 6e696d2e 756c6156 203a2065      ? s.minValue : 
   1a33c:	6874614d 6e696d2e 202c6928 696d2e73     Math.min(i, s.mi
   1a34c:	6c61566e 29296575 69207d20 6e282066     nValue)) } if (n
   1a35c:	206c6c75 65203d21 78616d2e 756c6156     ull != e.maxValu
   1a36c:	203f2065 203d2074 616d2e65 6c615678     e ? t = e.maxVal
   1a37c:	3a206575 2a207420 2e65203d 5678616d     ue : t *= e.maxV
   1a38c:	65756c61 6c616353 6e202c65 206c6c75     alueScale, null 
   1a39c:	65203d21 6e696d2e 756c6156 203f2065     != e.minValue ? 
   1a3ac:	203d2069 696d2e65 6c61566e 3a206575     i = e.minValue :
   1a3bc:	2d206920 614d203d 612e6874 69287362      i -= Math.abs(i
   1a3cc:	65202a20 6e696d2e 756c6156 61635365      * e.minValueSca
   1a3dc:	2d20656c 2c296920 69687420 706f2e73     le - i), this.op
   1a3ec:	6e6f6974 52792e73 65676e61 636e7546     tions.yRangeFunc
   1a3fc:	6e6f6974 207b2029 20726176 203d206e     tion) { var n = 
   1a40c:	73696874 74706f2e 736e6f69 6152792e     this.options.yRa
   1a41c:	4665676e 74636e75 286e6f69 696d207b     ngeFunction({ mi
   1a42c:	69203a6e 616d202c 74203a78 3b297d20     n: i, max: t });
   1a43c:	2020200a 20202020 20202020 3d206920     .            i =
   1a44c:	6d2e6e20 202c6e69 203d2074 616d2e6e      n.min, t = n.ma
   1a45c:	207d2078 28206669 4e736921 74284e61     x } if (!isNaN(t
   1a46c:	26262029 73692120 284e614e 20292969     ) && !isNaN(i)) 
   1a47c:	6176207b 20722072 2074203d 2069202d     { var r = t - i 
   1a48c:	6874202d 632e7369 65727275 6156746e     - this.currentVa
   1a49c:	5265756c 65676e61 20200a2c 20202020     lueRange,.      
   1a4ac:	20202020 20202020 206c2020 2069203d               l = i 
   1a4bc:	6874202d 632e7369 65727275 6956746e     - this.currentVi
   1a4cc:	6e694d73 756c6156 200a3b65 20202020     sMinValue;.     
   1a4dc:	20202020 74202020 2e736968 6e417369            this.isAn
   1a4ec:	74616d69 53676e69 656c6163 4d203d20     imatingScale = M
   1a4fc:	2e687461 28736261 3e202972 20312e20     ath.abs(r) > .1 
   1a50c:	4d207c7c 2e687461 28736261 3e20296c     || Math.abs(l) >
   1a51c:	2c312e20 69687420 75632e73 6e657272      .1, this.curren
   1a52c:	6c615674 61526575 2065676e 65203d2b     tValueRange += e
   1a53c:	6163732e 6d53656c 68746f6f 20676e69     .scaleSmoothing 
   1a54c:	2c72202a 69687420 75632e73 6e657272     * r, this.curren
   1a55c:	73695674 566e694d 65756c61 203d2b20     tVisMinValue += 
   1a56c:	63732e65 53656c61 746f6f6d 676e6968     e.scaleSmoothing
   1a57c:	6c202a20 200a7d20 20202020 74202020      * l }.        t
   1a58c:	2e736968 756c6176 6e615265 3d206567     his.valueRange =
   1a59c:	6d207b20 203a6e69 6d202c69 203a7861      { min: i, max: 
   1a5ac:	207d2074 61202c7d 6f72702e 79746f74     t } }, a.prototy
   1a5bc:	722e6570 65646e65 203d2072 636e7566     pe.render = func
   1a5cc:	6e6f6974 202c6528 7b202974 72617620     tion(e, t) { var
   1a5dc:	3d206920 656e2820 61442077 2e296574      i = (new Date).
   1a5ec:	54746567 28656d69 69203b29 21282066     getTime(); if (!
   1a5fc:	73696874 4173692e 616d696e 676e6974     this.isAnimating
   1a60c:	6c616353 7b202965 72617620 3d206120     Scale) { var a =
   1a61c:	74614d20 696d2e68 6531286e 202f2033      Math.min(1e3 / 
   1a62c:	74202c36 2e736968 6974706f 2e736e6f     6, this.options.
   1a63c:	6c6c696d 65507369 78695072 3b296c65     millisPerPixel);
   1a64c:	20666920 2d206928 69687420 616c2e73      if (i - this.la
   1a65c:	65527473 7265646e 656d6954 6c6c694d     stRenderTimeMill
   1a66c:	3c207369 20296120 75746572 7d206e72     is < a) return }
   1a67c:	2020200a 20202020 69687420 65722e73     .        this.re
   1a68c:	657a6973 202c2928 73696874 73616c2e     size(), this.las
   1a69c:	6e655274 54726564 4d656d69 696c6c69     tRenderTimeMilli
   1a6ac:	203d2073 65202c69 65203d20 207c7c20     s = i, e = e || 
   1a6bc:	73696874 6e61632e 2c736176 3d207420     this.canvas, t =
   1a6cc:	7c207420 2069207c 7428202d 2e736968      t || i - (this.
   1a6dc:	616c6564 7c7c2079 2c293020 2d207420     delay || 0), t -
   1a6ec:	2074203d 68742025 6f2e7369 6f697470     = t % this.optio
   1a6fc:	6d2e736e 696c6c69 72655073 65786950     ns.millisPerPixe
   1a70c:	76203b6c 73207261 65203d20 7465672e     l; var s = e.get
   1a71c:	746e6f43 28747865 22643222 200a2c29     Context("2d"),. 
   1a72c:	20202020 20202020 6e202020 74203d20                n = t
   1a73c:	2e736968 6974706f 2c736e6f 2020200a     his.options,.   
   1a74c:	20202020 20202020 3d207220 74207b20              r = { t
   1a75c:	203a706f 6c202c30 3a746665 202c3020     op: 0, left: 0, 
   1a76c:	74646977 65203a68 696c632e 57746e65     width: e.clientW
   1a77c:	68746469 6568202c 74686769 2e65203a     idth, height: e.
   1a78c:	65696c63 6548746e 74686769 0a2c7d20     clientHeight },.
   1a79c:	20202020 20202020 20202020 203d206c                 l = 
   1a7ac:	202d2074 69772e72 20687464 2e6e202a     t - r.width * n.
   1a7bc:	6c6c696d 65507369 78695072 0a2c6c65     millisPerPixel,.
   1a7cc:	20202020 20202020 20202020 203d206f                 o = 
   1a7dc:	636e7566 6e6f6974 20296528 6176207b     function(e) { va
   1a7ec:	20742072 2065203d 6874202d 632e7369     r t = e - this.c
   1a7fc:	65727275 6956746e 6e694d73 756c6156     urrentVisMinValu
   1a80c:	72203b65 72757465 2030206e 203d3d3d     e; return 0 === 
   1a81c:	73696874 7275632e 746e6572 756c6156     this.currentValu
   1a82c:	6e615265 3f206567 682e7220 68676965     eRange ? r.heigh
   1a83c:	203a2074 65682e72 74686769 4d202d20     t : r.height - M
   1a84c:	2e687461 6e756f72 20742864 6874202f     ath.round(t / th
   1a85c:	632e7369 65727275 6156746e 5265756c     is.currentValueR
   1a86c:	65676e61 72202a20 6965682e 29746867     ange * r.height)
   1a87c:	622e7d20 28646e69 73696874 200a2c29      }.bind(this),. 
   1a88c:	20202020 20202020 68202020 66203d20                h = f
   1a89c:	74636e75 286e6f69 7b202965 74657220     unction(e) { ret
   1a8ac:	206e7275 63732e6e 6c6c6f72 6b636142     urn n.scrollBack
   1a8bc:	64726177 203f2073 6874614d 756f722e     wards ? Math.rou
   1a8cc:	2828646e 202d2074 2f202965 6d2e6e20     nd((t - e) / n.m
   1a8dc:	696c6c69 72655073 65786950 3a20296c     illisPerPixel) :
   1a8ec:	74614d20 6f722e68 28646e75 69772e72      Math.round(r.wi
   1a8fc:	20687464 7428202d 65202d20 202f2029     dth - (t - e) / 
   1a90c:	696d2e6e 73696c6c 50726550 6c657869     n.millisPerPixel
   1a91c:	3b7d2029 20666920 69687428 70752e73     ) }; if (this.up
   1a92c:	65746164 756c6156 6e615265 29286567     dateValueRange()
   1a93c:	2e73202c 746e6f66 6e203d20 62616c2e     , s.font = n.lab
   1a94c:	2e736c65 746e6f66 657a6953 22202b20     els.fontSize + "
   1a95c:	22207870 6e202b20 62616c2e 2e736c65     px " + n.labels.
   1a96c:	746e6f66 696d6146 202c796c 61732e73     fontFamily, s.sa
   1a97c:	29286576 2e73202c 6e617274 74616c73     ve(), s.translat
   1a98c:	2e722865 7466656c 2e72202c 29706f74     e(r.left, r.top)
   1a99c:	2e73202c 69676562 7461506e 2c292868     , s.beginPath(),
   1a9ac:	722e7320 28746365 30202c30 2e72202c      s.rect(0, 0, r.
   1a9bc:	74646977 72202c68 6965682e 29746867     width, r.height)
   1a9cc:	2e73202c 70696c63 202c2928 61732e73     , s.clip(), s.sa
   1a9dc:	29286576 2e73202c 6c6c6966 6c797453     ve(), s.fillStyl
   1a9ec:	203d2065 72672e6e 662e6469 536c6c69     e = n.grid.fillS
   1a9fc:	656c7974 2e73202c 61656c63 63655272     tyle, s.clearRec
   1aa0c:	2c302874 202c3020 69772e72 2c687464     t(0, 0, r.width,
   1aa1c:	682e7220 68676965 202c2974 69662e73      r.height), s.fi
   1aa2c:	65526c6c 30287463 2c30202c 772e7220     llRect(0, 0, r.w
   1aa3c:	68746469 2e72202c 67696568 2c297468     idth, r.height),
   1aa4c:	722e7320 6f747365 29286572 2e73202c      s.restore(), s.
   1aa5c:	65766173 202c2928 696c2e73 6957656e     save(), s.lineWi
   1aa6c:	20687464 2e6e203d 64697267 6e696c2e     dth = n.grid.lin
   1aa7c:	64695765 202c6874 74732e73 656b6f72     eWidth, s.stroke
   1aa8c:	6c797453 203d2065 72672e6e 732e6469     Style = n.grid.s
   1aa9c:	6b6f7274 79745365 202c656c 72672e6e     trokeStyle, n.gr
   1aaac:	6d2e6469 696c6c69 72655073 656e694c     id.millisPerLine
   1aabc:	30203e20 207b2029 65622e73 506e6967      > 0) { s.beginP
   1aacc:	28687461 66203b29 2820726f 20726176     ath(); for (var 
   1aadc:	203d2064 202d2074 20252074 72672e6e     d = t - t % n.gr
   1aaec:	6d2e6469 696c6c69 72655073 656e694c     id.millisPerLine
   1aafc:	2064203b 6c203d3e 2064203b 6e203d2d     ; d >= l; d -= n
   1ab0c:	6972672e 696d2e64 73696c6c 4c726550     .grid.millisPerL
   1ab1c:	29656e69 76207b20 75207261 68203d20     ine) { var u = h
   1ab2c:	3b296428 2020200a 20202020 20202020     (d);.           
   1ab3c:	20202020 672e6e20 2e646972 72616873          n.grid.shar
   1ab4c:	6e694c70 26207365 75282026 203d2d20     pLines && (u -= 
   1ab5c:	2c29352e 6d2e7320 5465766f 2c75286f     .5), s.moveTo(u,
   1ab6c:	2c293020 6c2e7320 54656e69 2c75286f      0), s.lineTo(u,
   1ab7c:	682e7220 68676965 7d202974 2020200a      r.height) }.   
   1ab8c:	20202020 20202020 732e7320 6b6f7274              s.strok
   1ab9c:	2c292865 632e7320 65736f6c 68746150     e(), s.closePath
   1abac:	7d202928 726f6620 61762820 206d2072     () } for (var m 
   1abbc:	3b31203d 3c206d20 672e6e20 2e646972     = 1; m < n.grid.
   1abcc:	74726576 6c616369 74636553 736e6f69     verticalSections
   1abdc:	206d203b 31203d2b 207b2029 20726176     ; m += 1) { var 
   1abec:	203d2063 6874614d 756f722e 6d28646e     c = Math.round(m
   1abfc:	72202a20 6965682e 20746867 2e6e202f      * r.height / n.
   1ac0c:	64697267 7265762e 61636974 6365536c     grid.verticalSec
   1ac1c:	6e6f6974 0a3b2973 20202020 20202020     tions);.        
   1ac2c:	20202020 72672e6e 732e6469 70726168         n.grid.sharp
   1ac3c:	656e694c 26262073 20632820 2e203d2d     Lines && (c -= .
   1ac4c:	202c2935 65622e73 506e6967 28687461     5), s.beginPath(
   1ac5c:	73202c29 766f6d2e 286f5465 63202c30     ), s.moveTo(0, c
   1ac6c:	73202c29 6e696c2e 286f5465 69772e72     ), s.lineTo(r.wi
   1ac7c:	2c687464 2c296320 732e7320 6b6f7274     dth, c), s.strok
   1ac8c:	2c292865 632e7320 65736f6c 68746150     e(), s.closePath
   1ac9c:	7d202928 20666920 672e6e28 2e646972     () } if (n.grid.
   1acac:	64726f62 69567265 6c626973 26262065     borderVisible &&
   1acbc:	2e732820 69676562 7461506e 2c292868      (s.beginPath(),
   1accc:	732e7320 6b6f7274 63655265 2c302874      s.strokeRect(0,
   1acdc:	202c3020 69772e72 2c687464 682e7220      0, r.width, r.h
   1acec:	68676965 202c2974 6c632e73 5065736f     eight), s.closeP
   1acfc:	28687461 202c2929 65722e73 726f7473     ath()), s.restor
   1ad0c:	2c292865 682e6e20 7a69726f 61746e6f     e(), n.horizonta
   1ad1c:	6e694c6c 26207365 2e6e2026 69726f68     lLines && n.hori
   1ad2c:	746e6f7a 694c6c61 2e73656e 676e656c     zontalLines.leng
   1ad3c:	0a296874 20202020 20202020 20202020     th).            
   1ad4c:	20726f66 72617628 3d206620 203b3020     for (var f = 0; 
   1ad5c:	203c2066 6f682e6e 6f7a6972 6c61746e     f < n.horizontal
   1ad6c:	656e694c 656c2e73 6874676e 2066203b     Lines.length; f 
   1ad7c:	31203d2b 207b2029 20726176 203d2067     += 1) { var g = 
   1ad8c:	6f682e6e 6f7a6972 6c61746e 656e694c     n.horizontalLine
   1ad9c:	5d665b73 20200a2c 20202020 20202020     s[f],.          
   1adac:	20202020 20202020 20702020 614d203d               p = Ma
   1adbc:	722e6874 646e756f 67286f28 6c61762e     th.round(o(g.val
   1adcc:	29296575 2e202d20 200a3b35 20202020     ue)) - .5;.     
   1addc:	20202020 20202020 73202020 7274732e                s.str
   1adec:	53656b6f 656c7974 67203d20 6c6f632e     okeStyle = g.col
   1adfc:	7c20726f 2322207c 66666666 2c226666     or || "#ffffff",
   1ae0c:	6c2e7320 57656e69 68746469 67203d20      s.lineWidth = g
   1ae1c:	6e696c2e 64695765 7c206874 2c31207c     .lineWidth || 1,
   1ae2c:	622e7320 6e696765 68746150 202c2928      s.beginPath(), 
   1ae3c:	6f6d2e73 6f546576 202c3028 202c2970     s.moveTo(0, p), 
   1ae4c:	696c2e73 6f54656e 772e7228 68746469     s.lineTo(r.width
   1ae5c:	2970202c 2e73202c 6f727473 2928656b     , p), s.stroke()
   1ae6c:	2e73202c 736f6c63 74615065 20292868     , s.closePath() 
   1ae7c:	20200a7d 20202020 6f662020 76282072     }.        for (v
   1ae8c:	53207261 30203d20 2053203b 6874203c     ar S = 0; S < th
   1ae9c:	732e7369 65697265 74655373 6e656c2e     is.seriesSet.len
   1aeac:	3b687467 2b205320 2931203d 73207b20     gth; S += 1) { s
   1aebc:	7661732e 3b292865 72617620 3d207620     .save(); var v =
   1aecc:	69687420 65732e73 73656972 5b746553      this.seriesSet[
   1aedc:	742e5d53 53656d69 65697265 200a2c73     S].timeSeries,. 
   1aeec:	20202020 20202020 20202020 77202020                    w
   1aefc:	76203d20 7461642e 200a2c61 20202020      = v.data,.     
   1af0c:	20202020 20202020 78202020 74203d20                x = t
   1af1c:	2e736968 69726573 65537365 5d535b74     his.seriesSet[S]
   1af2c:	74706f2e 736e6f69 20200a3b 20202020     .options;.      
   1af3c:	20202020 2e762020 706f7264 44646c4f           v.dropOldD
   1af4c:	28617461 6e202c6c 78616d2e 61746144     ata(l, n.maxData
   1af5c:	4c746553 74676e65 202c2968 696c2e73     SetLength), s.li
   1af6c:	6957656e 20687464 2e78203d 656e696c     neWidth = x.line
   1af7c:	74646957 73202c68 7274732e 53656b6f     Width, s.strokeS
   1af8c:	656c7974 78203d20 7274732e 53656b6f     tyle = x.strokeS
   1af9c:	656c7974 2e73202c 69676562 7461506e     tyle, s.beginPat
   1afac:	3b292868 726f6620 61762820 20792072     h(); for (var y 
   1afbc:	2c30203d 3d206220 202c3020 203d2056     = 0, b = 0, V = 
   1afcc:	54202c30 30203d20 2054203b 2e77203c     0, T = 0; T < w.
   1afdc:	676e656c 26206874 20312026 203d3d21     length && 1 !== 
   1afec:	656c2e77 6874676e 2054203b 31203d2b     w.length; T += 1
   1affc:	207b2029 20726176 203d204e 5b772868     ) { var N = h(w[
   1b00c:	305b5d54 0a2c295d 20202020 20202020     T][0]),.        
   1b01c:	20202020 20202020 20202020 203d2050                 P = 
   1b02c:	5b77286f 315b5d54 203b295d 28206669     o(w[T][1]); if (
   1b03c:	3d3d2030 2954203d 3d207920 202c4e20     0 === T) y = N, 
   1b04c:	6f6d2e73 6f546576 202c4e28 0a3b2950     s.moveTo(N, P);.
   1b05c:	20202020 20202020 20202020 20202020                     
   1b06c:	65736c65 69777320 20686374 692e6e28     else switch (n.i
   1b07c:	7265746e 616c6f70 6e6f6974 0a7b2029     nterpolation) {.
   1b08c:	20202020 20202020 20202020 20202020                     
   1b09c:	20202020 65736163 696c2220 7261656e         case "linear
   1b0ac:	200a3a22 20202020 20202020 20202020     ":.             
   1b0bc:	20202020 63202020 20657361 6e696c22            case "lin
   1b0cc:	0a3a2265 20202020 20202020 20202020     e":.            
   1b0dc:	20202020 20202020 20202020 696c2e73                 s.li
   1b0ec:	6f54656e 202c4e28 203b2950 61657262     neTo(N, P); brea
   1b0fc:	200a3b6b 20202020 20202020 20202020     k;.             
   1b10c:	20202020 63202020 20657361 7a656222            case "bez
   1b11c:	22726569 20200a3a 20202020 20202020     ier":.          
   1b12c:	20202020 20202020 65642020 6c756166               defaul
   1b13c:	200a3a74 20202020 20202020 20202020     t:.             
   1b14c:	20202020 20202020 73202020 7a65622e                s.bez
   1b15c:	43726569 65767275 4d286f54 2e687461     ierCurveTo(Math.
   1b16c:	6e756f72 62282864 4e202b20 202f2029     round((b + N) / 
   1b17c:	202c2932 4d202c56 2e687461 6e756f72     2), V, Math.roun
   1b18c:	20622864 294e202b 32202f20 2c50202c     d(b + N) / 2, P,
   1b19c:	202c4e20 203b2950 61657262 200a3b6b      N, P); break;. 
   1b1ac:	20202020 20202020 20202020 20202020                     
   1b1bc:	63202020 20657361 65747322 0a3a2270        case "step":.
   1b1cc:	20202020 20202020 20202020 20202020                     
   1b1dc:	20202020 20202020 696c2e73 6f54656e             s.lineTo
   1b1ec:	202c4e28 202c2956 696c2e73 6f54656e     (N, V), s.lineTo
   1b1fc:	202c4e28 7d202950 2020200a 20202020     (N, P) }.       
   1b20c:	20202020 20202020 3d206220 202c4e20              b = N, 
   1b21c:	203d2056 0a7d2050 20202020 20202020     V = P }.        
   1b22c:	20202020 656c2e77 6874676e 31203e20         w.length > 1
   1b23c:	20262620 662e7828 536c6c69 656c7974      && (x.fillStyle
   1b24c:	20262620 6c2e7328 54656e69 2e72286f      && (s.lineTo(r.
   1b25c:	74646977 202b2068 696c2e78 6957656e     width + x.lineWi
   1b26c:	20687464 2c31202b 2c295620 6c2e7320     dth + 1, V), s.l
   1b27c:	54656e69 2e72286f 74646977 202b2068     ineTo(r.width + 
   1b28c:	696c2e78 6957656e 20687464 2c31202b     x.lineWidth + 1,
   1b29c:	682e7220 68676965 202b2074 696c2e78      r.height + x.li
   1b2ac:	6957656e 20687464 2931202b 2e73202c     neWidth + 1), s.
   1b2bc:	656e696c 79286f54 2e72202c 67696568     lineTo(y, r.heig
   1b2cc:	2b207468 6c2e7820 57656e69 68746469     ht + x.lineWidth
   1b2dc:	73202c29 6c69662e 7974536c 3d20656c     ), s.fillStyle =
   1b2ec:	662e7820 536c6c69 656c7974 2e73202c      x.fillStyle, s.
   1b2fc:	6c6c6966 2c292928 732e7820 6b6f7274     fill()), x.strok
   1b30c:	79745365 2620656c 6e222026 22656e6f     eStyle && "none"
   1b31c:	3d3d2120 732e7820 6b6f7274 79745365      !== x.strokeSty
   1b32c:	2620656c 2e732026 6f727473 2928656b     le && s.stroke()
   1b33c:	2e73202c 736f6c63 74615065 29292868     , s.closePath())
   1b34c:	2e73202c 74736572 2865726f 207d2029     , s.restore() } 
   1b35c:	28206669 6c2e6e21 6c656261 69642e73     if (!n.labels.di
   1b36c:	6c626173 26206465 69212026 4e614e73     sabled && !isNaN
   1b37c:	69687428 61762e73 5265756c 65676e61     (this.valueRange
   1b38c:	6e696d2e 26262029 73692120 284e614e     .min) && !isNaN(
   1b39c:	73696874 6c61762e 61526575 2e65676e     this.valueRange.
   1b3ac:	2978616d 207b2029 20726176 203d204d     max)) { var M = 
   1b3bc:	4d792e6e 6f467861 74616d72 28726574     n.yMaxFormatter(
   1b3cc:	73696874 6c61762e 61526575 2e65676e     this.valueRange.
   1b3dc:	2c78616d 6c2e6e20 6c656261 72702e73     max, n.labels.pr
   1b3ec:	73696365 296e6f69 20200a2c 20202020     ecision),.      
   1b3fc:	20202020 20202020 206b2020 2e6e203d               k = n.
   1b40c:	6e694d79 6d726f46 65747461 68742872     yMinFormatter(th
   1b41c:	762e7369 65756c61 676e6152 696d2e65     is.valueRange.mi
   1b42c:	6e202c6e 62616c2e 2e736c65 63657270     n, n.labels.prec
   1b43c:	6f697369 0a2c296e 20202020 20202020     ision),.        
   1b44c:	20202020 20202020 203d2046 63732e6e             F = n.sc
   1b45c:	6c6c6f72 6b636142 64726177 203f2073     rollBackwards ? 
   1b46c:	203a2030 69772e72 20687464 2e73202d     0 : r.width - s.
   1b47c:	7361656d 54657275 28747865 772e294d     measureText(M).w
   1b48c:	68746469 32202d20 20200a2c 20202020     idth - 2,.      
   1b49c:	20202020 20202020 20522020 2e6e203d               R = n.
   1b4ac:	6f726373 61426c6c 61776b63 20736472     scrollBackwards 
   1b4bc:	2030203f 2e72203a 74646977 202d2068     ? 0 : r.width - 
   1b4cc:	656d2e73 72757361 78655465 296b2874     s.measureText(k)
   1b4dc:	6469772e 2d206874 0a3b3220 20202020     .width - 2;.    
   1b4ec:	20202020 20202020 69662e73 74536c6c             s.fillSt
   1b4fc:	20656c79 2e6e203d 6562616c 662e736c     yle = n.labels.f
   1b50c:	536c6c69 656c7974 2e73202c 6c6c6966     illStyle, s.fill
   1b51c:	74786554 202c4d28 6e202c46 62616c2e     Text(M, F, n.lab
   1b52c:	2e736c65 746e6f66 657a6953 73202c29     els.fontSize), s
   1b53c:	6c69662e 7865546c 2c6b2874 202c5220     .fillText(k, R, 
   1b54c:	65682e72 74686769 32202d20 207d2029     r.height - 2) } 
   1b55c:	28206669 69742e6e 7473656d 46706d61     if (n.timestampF
   1b56c:	616d726f 72657474 20262620 72672e6e     ormatter && n.gr
   1b57c:	6d2e6469 696c6c69 72655073 656e694c     id.millisPerLine
   1b58c:	30203e20 207b2029 20726176 203d2041      > 0) { var A = 
   1b59c:	63732e6e 6c6c6f72 6b636142 64726177     n.scrollBackward
   1b5ac:	203f2073 656d2e73 72757361 78655465     s ? s.measureTex
   1b5bc:	296b2874 6469772e 3a206874 772e7220     t(k).width : r.w
   1b5cc:	68746469 73202d20 61656d2e 65727573     idth - s.measure
   1b5dc:	74786554 2e296b28 74646977 202b2068     Text(k).width + 
   1b5ec:	66203b34 2820726f 203d2064 202d2074     4; for (d = t - 
   1b5fc:	20252074 72672e6e 6d2e6469 696c6c69     t % n.grid.milli
   1b60c:	72655073 656e694c 2064203b 6c203d3e     sPerLine; d >= l
   1b61c:	2064203b 6e203d2d 6972672e 696d2e64     ; d -= n.grid.mi
   1b62c:	73696c6c 4c726550 29656e69 75207b20     llisPerLine) { u
   1b63c:	68203d20 3b296428 20666920 2e6e2128      = h(d); if (!n.
   1b64c:	6f726373 61426c6c 61776b63 20736472     scrollBackwards 
   1b65c:	75202626 41203c20 207c7c20 63732e6e     && u < A || n.sc
   1b66c:	6c6c6f72 6b636142 64726177 26262073     rollBackwards &&
   1b67c:	3e207520 20294120 6176207b 20422072      u > A) { var B 
   1b68c:	656e203d 61442077 64286574 200a2c29     = new Date(d),. 
   1b69c:	20202020 20202020 20202020 20202020                     
   1b6ac:	20202020 4c202020 6e203d20 6d69742e            L = n.tim
   1b6bc:	61747365 6f46706d 74616d72 28726574     estampFormatter(
   1b6cc:	0a2c2942 20202020 20202020 20202020     B),.            
   1b6dc:	20202020 20202020 20202020 203d2057                 W = 
   1b6ec:	656d2e73 72757361 78655465 294c2874     s.measureText(L)
   1b6fc:	6469772e 0a3b6874 20202020 20202020     .width;.        
   1b70c:	20202020 20202020 20202020 203d2041                 A = 
   1b71c:	63732e6e 6c6c6f72 6b636142 64726177     n.scrollBackward
   1b72c:	203f2073 202b2075 202b2057 203a2032     s ? u + W + 2 : 
   1b73c:	202d2075 202d2057 73202c32 6c69662e     u - W - 2, s.fil
   1b74c:	7974536c 3d20656c 6c2e6e20 6c656261     lStyle = n.label
   1b75c:	69662e73 74536c6c 2c656c79 732e6e20     s.fillStyle, n.s
   1b76c:	6c6f7263 6361426c 7261776b 3f207364     crollBackwards ?
   1b77c:	662e7320 546c6c69 28747865 75202c4c      s.fillText(L, u
   1b78c:	2e72202c 67696568 2d207468 20293220     , r.height - 2) 
   1b79c:	2e73203a 6c6c6966 74786554 202c4c28     : s.fillText(L, 
   1b7ac:	202d2075 72202c57 6965682e 20746867     u - W, r.height 
   1b7bc:	2932202d 7d207d20 200a7d20 20202020     - 2) } } }.     
   1b7cc:	73202020 7365722e 65726f74 7d202928        s.restore() }
   1b7dc:	2e61202c 656d6974 6d726f46 65747461     , a.timeFormatte
   1b7ec:	203d2072 636e7566 6e6f6974 20296528     r = function(e) 
   1b7fc:	20200a7b 20202020 75662020 6974636e     {.        functi
   1b80c:	74206e6f 20296528 6572207b 6e727574     on t(e) { return
   1b81c:	20652820 3031203c 22203f20 3a202230      (e < 10 ? "0" :
   1b82c:	29222220 65202b20 72207d20 72757465      "") + e } retur
   1b83c:	2874206e 65672e65 756f4874 29287372     n t(e.getHours()
   1b84c:	202b2029 20223a22 2874202b 65672e65     ) + ":" + t(e.ge
   1b85c:	6e694d74 73657475 20292928 3a22202b     tMinutes()) + ":
   1b86c:	202b2022 2e652874 53746567 6e6f6365     " + t(e.getSecon
   1b87c:	29287364 2c7d2029 542e6520 53656d69     ds()) }, e.TimeS
   1b88c:	65697265 203d2073 65202c69 6f6d532e     eries = i, e.Smo
   1b89c:	6968746f 61684365 3d207472 7d206120     othieChart = a }
   1b8ac:	6e752228 69666564 2264656e 203d3d20     ("undefined" == 
   1b8bc:	65707974 6520666f 726f7078 3f207374     typeof exports ?
   1b8cc:	69687420 203a2073 6f707865 29737472      this : exports)
   1b8dc:	0000003b                                ;...

0001b8e0 <data_stats_shtml>:
   1b8e0:	6174732f 732e7374 6c6d7468 44213c00     /stats.shtml.<!D
   1b8f0:	5954434f 48204550 204c4d54 4c425550     OCTYPE HTML PUBL
   1b900:	22204349 572f2f2d 2f2f4333 20445444     IC "-//W3C//DTD 
   1b910:	4c4d5448 302e3420 72542031 69736e61     HTML 4.01 Transi
   1b920:	6e6f6974 2f2f6c61 20224e45 74746822     tional//EN" "htt
   1b930:	2f2f3a70 2e777777 6f2e3377 542f6772     p://www.w3.org/T
   1b940:	74682f52 2f346c6d 736f6f6c 74642e65     R/html4/loose.dt
   1b950:	0d3e2264 74683c0a 0d3e6c6d 3c20200a     d">..<html>..  <
   1b960:	64616568 200a0d3e 3c202020 6c746974     head>..    <titl
   1b970:	72463e65 54526565 6f2e534f 75206772     e>FreeRTOS.org u
   1b980:	57205049 73204245 65767265 65642072     IP WEB server de
   1b990:	2f3c6f6d 6c746974 0a0d3e65 2f3c2020     mo</title>..  </
   1b9a0:	64616568 200a0d3e 4f423c20 0d3e5944     head>..  <BODY>.
   1b9b0:	6f663c0a 6620746e 3d656361 69726122     .<font face="ari
   1b9c0:	3e226c61 613c0a0d 65726820 69223d66     al">..<a href="i
   1b9d0:	7865646e 7468732e 3e226c6d 6b736154     ndex.shtml">Task
   1b9e0:	61745320 2f3c7374 3c203e61 3c7c3e62      Stats</a> <b>|<
   1b9f0:	203e622f 6820613c 3d666572 6e757222     /b> <a href="run
   1ba00:	656d6974 7468732e 3e226c6d 206e7552     time.shtml">Run 
   1ba10:	656d6954 61745320 2f3c7374 3c203e61     Time Stats</a> <
   1ba20:	3c7c3e62 203e622f 6820613c 3d666572     b>|</b> <a href=
   1ba30:	61747322 732e7374 6c6d7468 43543e22     "stats.shtml">TC
   1ba40:	74532050 3c737461 203e612f 7c3e623c     P Stats</a> <b>|
   1ba50:	3e622f3c 20613c20 66657268 6374223d     </b> <a href="tc
   1ba60:	68732e70 226c6d74 6e6f433e 7463656e     p.shtml">Connect
   1ba70:	736e6f69 3e612f3c 3e623c20 622f3c7c     ions</a> <b>|</b
   1ba80:	613c203e 65726820 68223d66 3a707474     > <a href="http:
   1ba90:	77772f2f 72662e77 74726565 6f2e736f     //www.freertos.o
   1baa0:	222f6772 6572463e 4f545265 6f482053     rg/">FreeRTOS Ho
   1bab0:	6170656d 2f3c6567 3c203e61 3c7c3e62     mepage</a> <b>|<
   1bac0:	203e622f 6820613c 3d666572 2e6f6922     /b> <a href="io.
   1bad0:	6d746873 493e226c 612f3c4f 623c203e     shtml">IO</a> <b
   1bae0:	2f3c7c3e 3c203e62 72682061 223d6665     >|</b> <a href="
   1baf0:	6f676f6c 67706a2e 37333e22 706a204b     logo.jpg">37K jp
   1bb00:	612f3c67 3c0a0d3e 3c3e7262 0a0d3e70     g</a>..<br><p>..
   1bb10:	3e72683c 623c0a0d 703c3e72 3c0a0d3e     <hr>..<br><p>..<
   1bb20:	4e3e3268 6f777465 73206b72 69746174     h2>Network stati
   1bb30:	63697473 682f3c73 0a0d3e32 6261743c     stics</h2>..<tab
   1bb40:	7720656c 68746469 3033223d 62202230     le width="300" b
   1bb50:	6564726f 30223d72 0a0d3e22 3e72743c     order="0">..<tr>
   1bb60:	2064743c 67696c61 6c223d6e 22746665     <td align="left"
   1bb70:	6f663c3e 6620746e 3d656361 756f6322     ><font face="cou
   1bb80:	72656972 703c3e22 0d3e6572 2050490a     rier"><pre>..IP 
   1bb90:	20202020 20202020 61502020 74656b63               Packet
   1bba0:	65722073 76696563 0a0d6465 20202020     s received..    
   1bbb0:	20202020 20202020 63615020 7374656b              Packets
   1bbc0:	6e657320 200a0d74 20202020 20202020      sent..         
   1bbd0:	20202020 77726f46 64656461 20200a0d         Forwaded..  
   1bbe0:	20202020 20202020 44202020 70706f72                Dropp
   1bbf0:	0a0d6465 65205049 726f7272 20202073     ed..IP errors   
   1bc00:	20504920 73726576 2f6e6f69 64616568      IP version/head
   1bc10:	6c207265 74676e65 200a0d68 20202020     er length..     
   1bc20:	20202020 20202020 6c205049 74676e65             IP lengt
   1bc30:	68202c68 20686769 65747962 20200a0d     h, high byte..  
   1bc40:	20202020 20202020 49202020 656c2050                IP le
   1bc50:	6874676e 6f6c202c 79622077 0a0d6574     ngth, low byte..
   1bc60:	20202020 20202020 20202020 20504920                  IP 
   1bc70:	67617266 746e656d 200a0d73 20202020     fragments..     
   1bc80:	20202020 20202020 64616548 63207265             Header c
   1bc90:	6b636568 0d6d7573 2020200a 20202020     hecksum..       
   1bca0:	20202020 72572020 20676e6f 746f7270           Wrong prot
   1bcb0:	6c6f636f 43490a0d 2009504d 20202020     ocol..ICMP.     
   1bcc0:	6b636150 20737465 65636572 64657669     Packets received
   1bcd0:	20200a0d 20202020 20202020 50202020     ..             P
   1bce0:	656b6361 73207374 0d746e65 2020200a     ackets sent..   
   1bcf0:	20202020 20202020 61502020 74656b63               Packet
   1bd00:	72642073 6570706f 200a0d64 20202020     s dropped..     
   1bd10:	20202020 20202020 65707954 72726520             Type err
   1bd20:	0d73726f 2020200a 20202020 20202020     ors..           
   1bd30:	68432020 736b6365 65206d75 726f7272       Checksum error
   1bd40:	540a0d73 20205043 20202020 20202020     s..TCP          
   1bd50:	6b636150 20737465 65636572 64657669     Packets received
   1bd60:	20200a0d 20202020 20202020 50202020     ..             P
   1bd70:	656b6361 73207374 0d746e65 2020200a     ackets sent..   
   1bd80:	20202020 20202020 61502020 74656b63               Packet
   1bd90:	72642073 6570706f 200a0d64 20202020     s dropped..     
   1bda0:	20202020 20202020 63656843 6d75736b             Checksum
   1bdb0:	72726520 0d73726f 2020200a 20202020      errors..       
   1bdc0:	20202020 61442020 70206174 656b6361           Data packe
   1bdd0:	77207374 6f687469 41207475 0d734b43     ts without ACKs.
   1bde0:	2020200a 20202020 20202020 65522020     .             Re
   1bdf0:	73746573 20200a0d 20202020 20202020     sets..          
   1be00:	52202020 61727465 696d736e 6f697373        Retransmissio
   1be10:	0d61736e 2020200a 20202020 20202020     nsa..           
   1be20:	79532020 6f74206e 6f6c6320 20646573       Syn to closed 
   1be30:	74726f70 44550a0d 20202050 20202020     port..UDP       
   1be40:	50202020 656b6361 64207374 70706f72        Packets dropp
   1be50:	0a0d6465 20202020 20202020 20202020     ed..            
   1be60:	63615020 7374656b 63657220 65766965      Packets receive
   1be70:	200a0d64 20202020 20202020 20202020     d..             
   1be80:	6b636150 20737465 746e6573 20200a0d     Packets sent..  
   1be90:	20202020 20202020 50202020 656b6361                Packe
   1bea0:	63207374 72656b68 090a0d72 20202020     ts chkerr...    
   1beb0:	206f4e20 6e6e6f63 69746365 61206e6f      No connection a
   1bec0:	696c6176 656c6261 2f3c0a0d 3e657270     valiable..</pre>
   1bed0:	6f662f3c 3c3e746e 3e64742f 3e64743c     </font></td><td>
   1bee0:	6e6f663c 61662074 223d6563 72756f63     <font face="cour
   1bef0:	22726569 72703c3e 21253e65 74656e20     ier"><pre>%! net
   1bf00:	6174732d 0a0d7374 72702f3c 2f3c3e65     -stats..</pre></
   1bf10:	746e6f66 742f3c3e 2f3c3e64 6c626174     font></td></tabl
   1bf20:	0a0d3e65 6f662f3c 0d3e746e 622f3c0a     e>..</font>..</b
   1bf30:	3e79646f 2f3c0a0d 6c6d7468 000a0d3e     ody>..</html>...

0001bf40 <data_tcp_shtml>:
   1bf40:	7063742f 7468732e 3c006c6d 434f4421     /tcp.shtml.<!DOC
   1bf50:	45505954 4d544820 5550204c 43494c42     TYPE HTML PUBLIC
   1bf60:	2f2d2220 4333572f 54442f2f 54482044      "-//W3C//DTD HT
   1bf70:	34204c4d 2031302e 6e617254 69746973     ML 4.01 Transiti
   1bf80:	6c616e6f 4e452f2f 68222022 3a707474     onal//EN" "http:
   1bf90:	77772f2f 33772e77 67726f2e 2f52542f     //www.w3.org/TR/
   1bfa0:	6c6d7468 6f6c2f34 2e65736f 22647464     html4/loose.dtd"
   1bfb0:	3c0a0d3e 6c6d7468 200a0d3e 65683c20     >..<html>..  <he
   1bfc0:	0d3e6461 2020200a 69743c20 3e656c74     ad>..    <title>
   1bfd0:	65657246 534f5452 67726f2e 50497520     FreeRTOS.org uIP
   1bfe0:	42455720 72657320 20726576 6f6d6564      WEB server demo
   1bff0:	69742f3c 3e656c74 20200a0d 65682f3c     </title>..  </he
   1c000:	0d3e6461 3c20200a 59444f42 3c0a0d3e     ad>..  <BODY>..<
   1c010:	746e6f66 63616620 61223d65 6c616972     font face="arial
   1c020:	0a0d3e22 6820613c 3d666572 646e6922     ">..<a href="ind
   1c030:	732e7865 6c6d7468 61543e22 53206b73     ex.shtml">Task S
   1c040:	73746174 3e612f3c 3e623c20 622f3c7c     tats</a> <b>|</b
   1c050:	613c203e 65726820 72223d66 69746e75     > <a href="runti
   1c060:	732e656d 6c6d7468 75523e22 6954206e     me.shtml">Run Ti
   1c070:	5320656d 73746174 3e612f3c 3e623c20     me Stats</a> <b>
   1c080:	622f3c7c 613c203e 65726820 73223d66     |</b> <a href="s
   1c090:	73746174 7468732e 3e226c6d 20504354     tats.shtml">TCP 
   1c0a0:	74617453 612f3c73 623c203e 2f3c7c3e     Stats</a> <b>|</
   1c0b0:	3c203e62 72682061 223d6665 2e706374     b> <a href="tcp.
   1c0c0:	6d746873 433e226c 656e6e6f 6f697463     shtml">Connectio
   1c0d0:	2f3c736e 3c203e61 3c7c3e62 203e622f     ns</a> <b>|</b> 
   1c0e0:	6820613c 3d666572 74746822 2f2f3a70     <a href="http://
   1c0f0:	2e777777 65657266 736f7472 67726f2e     www.freertos.org
   1c100:	463e222f 52656572 20534f54 656d6f48     /">FreeRTOS Home
   1c110:	65676170 3e612f3c 3e623c20 622f3c7c     page</a> <b>|</b
   1c120:	613c203e 65726820 69223d66 68732e6f     > <a href="io.sh
   1c130:	226c6d74 3c4f493e 203e612f 7c3e623c     tml">IO</a> <b>|
   1c140:	3e622f3c 20613c20 66657268 6f6c223d     </b> <a href="lo
   1c150:	6a2e6f67 3e226770 204b3733 3c67706a     go.jpg">37K jpg<
   1c160:	0d3e612f 72623c0a 3e703c3e 683c0a0d     /a>..<br><p>..<h
   1c170:	0a0d3e72 3e72623c 683c0a0d 654e3e32     r>..<br>..<h2>Ne
   1c180:	726f7774 6f63206b 63656e6e 6e6f6974     twork connection
   1c190:	682f3c73 0a0d3e32 0d3e703c 61743c0a     s</h2>..<p>..<ta
   1c1a0:	3e656c62 743c0a0d 743c3e72 6f4c3e68     ble>..<tr><th>Lo
   1c1b0:	3c6c6163 3e68742f 3e68743c 6f6d6552     cal</th><th>Remo
   1c1c0:	2f3c6574 3c3e6874 533e6874 65746174     te</th><th>State
   1c1d0:	68742f3c 68743c3e 7465523e 736e6172     </th><th>Retrans
   1c1e0:	7373696d 736e6f69 68742f3c 68743c3e     missions</th><th
   1c1f0:	6d69543e 2f3c7265 3c3e6874 463e6874     >Timer</th><th>F
   1c200:	7367616c 68742f3c 742f3c3e 0a0d3e72     lags</th></tr>..
   1c210:	74202125 632d7063 656e6e6f 6f697463     %! tcp-connectio
   1c220:	0a0d736e 72702f3c 2f3c3e65 746e6f66     ns..</pre></font
   1c230:	3c0a0d3e 6e6f662f 0a0d3e74 6f622f3c     >..</font>..</bo
   1c240:	0d3e7964 682f3c0a 3e6c6d74 0a0d0a0d     dy>..</html>....
   1c250:	00000000                                ....

0001c254 <file_404_html>:
   1c254:	00000000 00013dc4 00013dce 000000a8     .....=...=......
   1c264:	00000000                                ....

0001c268 <file_index_html>:
   1c268:	0001c254 00013e78 00013e84 000047e7     T...x>...>...G..
   1c278:	00000000                                ....

0001c27c <file_io_shtml>:
   1c27c:	0001c268 0001866c 00018676 00000338     h...l...v...8...
   1c28c:	00000000                                ....

0001c290 <file_runtime_shtml>:
   1c290:	0001c27c 000189b0 000189bf 0000036c     |...........l...
   1c2a0:	00000000                                ....

0001c2a4 <file_smoothie_min_js>:
   1c2a4:	0001c290 00018d2c 00018d3d 00002ba1     ....,...=....+..
   1c2b4:	00000000                                ....

0001c2b8 <file_stats_shtml>:
   1c2b8:	0001c2a4 0001b8e0 0001b8ed 00000653     ............S...
   1c2c8:	00000000                                ....

0001c2cc <file_tcp_shtml>:
   1c2cc:	0001c2b8 0001bf40 0001bf4b 00000306     ....@...K.......
   1c2dc:	00000000 454c4449 00000000 09632509     ....IDLE.....%c.
   1c2ec:	25097525 75250975 00000a0d 09752509     %u.%u.%u.....%u.
   1c2fc:	25752509 000a0d25 09752509 25313c09     .%u%%....%u..<1%
   1c30c:	000a0d25 20726d54 00637653              %...Tmr Svc.

0001c318 <heapSTRUCT_SIZE>:
   1c318:	00000008                                ....

0001c31c <pcInterruptPriorityRegisters>:
   1c31c:	e000e3f0                                ....

0001c320 <_global_impure_ptr>:
   1c320:	200000e8 00000043                       ... C...

0001c328 <_init>:
   1c328:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1c32a:	bf00      	nop
   1c32c:	bcf8      	pop	{r3, r4, r5, r6, r7}
   1c32e:	bc08      	pop	{r3}
   1c330:	469e      	mov	lr, r3
   1c332:	4770      	bx	lr

0001c334 <_fini>:
   1c334:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1c336:	bf00      	nop
   1c338:	bcf8      	pop	{r3, r4, r5, r6, r7}
   1c33a:	bc08      	pop	{r3}
   1c33c:	469e      	mov	lr, r3
   1c33e:	4770      	bx	lr

0001c340 <__frame_dummy_init_array_entry>:
   1c340:	0475 0000                                   u...

0001c344 <__do_global_dtors_aux_fini_array_entry>:
   1c344:	0461 0000                                   a...
