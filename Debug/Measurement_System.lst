
Measurement_System:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .init         00000470  00000000  60000000  00008000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         0002f728  00000470  60000470  00008470  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .ARM.exidx    00000008  20000000  6002fb98  00038000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .data         0000061c  20000008  6002fba0  00038008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          0000c684  20000624  600301bc  00038624  2**2
                  ALLOC
  5 .comment      00000662  00000000  00000000  00038624  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 000013d8  00000000  00000000  00038c86  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 000030df  00000000  00000000  0003a05e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   0001c22d  00000000  00000000  0003d13d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 0000395a  00000000  00000000  0005936a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   0000df3b  00000000  00000000  0005ccc4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00004e00  00000000  00000000  0006ac00  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000089bd  00000000  00000000  0006fa00  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00006d2b  00000000  00000000  000783bd  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_macinfo 000f8261  00000000  00000000  0007f0e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .ARM.attributes 00000025  00000000  00000000  00177349  2**0
                  CONTENTS, READONLY
 16 .debug_ranges 00001320  00000000  00000000  0017736e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .init:

00000000 <__vector_table_vma_base_address>:
   0:	20010000 	.word	0x20010000
   4:	00000299 	.word	0x00000299
   8:	00000309 	.word	0x00000309
   c:	0000030b 	.word	0x0000030b
  10:	0000030d 	.word	0x0000030d
  14:	0000030f 	.word	0x0000030f
  18:	00000311 	.word	0x00000311
	...
  2c:	00014221 	.word	0x00014221
  30:	00000315 	.word	0x00000315
  34:	00000000 	.word	0x00000000
  38:	000144b1 	.word	0x000144b1
  3c:	00014501 	.word	0x00014501
  40:	0000031b 	.word	0x0000031b
  44:	00009fed 	.word	0x00009fed
  48:	0000031f 	.word	0x0000031f
  4c:	00000321 	.word	0x00000321
  50:	00000323 	.word	0x00000323
  54:	000057b9 	.word	0x000057b9
  58:	00000327 	.word	0x00000327
  5c:	00000329 	.word	0x00000329
  60:	0000032b 	.word	0x0000032b
  64:	0000032d 	.word	0x0000032d
  68:	000028b9 	.word	0x000028b9
  6c:	000028e5 	.word	0x000028e5
  70:	00000333 	.word	0x00000333
  74:	00000335 	.word	0x00000335
  78:	00004119 	.word	0x00004119
  7c:	00000339 	.word	0x00000339
  80:	0000033b 	.word	0x0000033b
  84:	00004145 	.word	0x00004145
  88:	0000033f 	.word	0x0000033f
  8c:	00000341 	.word	0x00000341
  90:	00000343 	.word	0x00000343
  94:	00000345 	.word	0x00000345
  98:	00000347 	.word	0x00000347
  9c:	00000349 	.word	0x00000349
  a0:	0000034b 	.word	0x0000034b
	...
  bc:	0000034d 	.word	0x0000034d
  c0:	0000034f 	.word	0x0000034f
  c4:	00000351 	.word	0x00000351
  c8:	00000353 	.word	0x00000353
  cc:	00000355 	.word	0x00000355
  d0:	00000357 	.word	0x00000357
  d4:	00000359 	.word	0x00000359
  d8:	0000035b 	.word	0x0000035b
  dc:	0000035d 	.word	0x0000035d
  e0:	00000a51 	.word	0x00000a51
  e4:	00000361 	.word	0x00000361
  e8:	00000363 	.word	0x00000363
  ec:	00000365 	.word	0x00000365
  f0:	00000367 	.word	0x00000367
  f4:	00000369 	.word	0x00000369
  f8:	0000036b 	.word	0x0000036b
  fc:	0000036d 	.word	0x0000036d
 100:	0000036f 	.word	0x0000036f
 104:	00000371 	.word	0x00000371
 108:	00000373 	.word	0x00000373
 10c:	00000375 	.word	0x00000375
 110:	00000377 	.word	0x00000377
 114:	00000379 	.word	0x00000379
 118:	0000037b 	.word	0x0000037b
 11c:	0000037d 	.word	0x0000037d
 120:	0000037f 	.word	0x0000037f
 124:	00000381 	.word	0x00000381
 128:	00000383 	.word	0x00000383
 12c:	00000385 	.word	0x00000385
 130:	00000387 	.word	0x00000387
 134:	00000389 	.word	0x00000389
 138:	0000038b 	.word	0x0000038b
 13c:	0000038d 	.word	0x0000038d
 140:	0000038f 	.word	0x0000038f
 144:	00000391 	.word	0x00000391
 148:	00000393 	.word	0x00000393
 14c:	00000395 	.word	0x00000395
 150:	00000397 	.word	0x00000397
 154:	00000399 	.word	0x00000399
 158:	0000039b 	.word	0x0000039b
 15c:	0000039d 	.word	0x0000039d
 160:	0000039f 	.word	0x0000039f
 164:	000003a1 	.word	0x000003a1
 168:	000003a3 	.word	0x000003a3
 16c:	000003a5 	.word	0x000003a5
 170:	000003a7 	.word	0x000003a7
 174:	000003a9 	.word	0x000003a9
 178:	000003ab 	.word	0x000003ab
 17c:	000003ad 	.word	0x000003ad
 180:	000003af 	.word	0x000003af
 184:	000003b1 	.word	0x000003b1
 188:	000003b3 	.word	0x000003b3
 18c:	000003b5 	.word	0x000003b5
 190:	000003b7 	.word	0x000003b7
 194:	000003b9 	.word	0x000003b9
 198:	000003bb 	.word	0x000003bb
 19c:	000003bd 	.word	0x000003bd
 1a0:	000003bf 	.word	0x000003bf
 1a4:	000003c1 	.word	0x000003c1
 1a8:	000003c3 	.word	0x000003c3
 1ac:	000003c5 	.word	0x000003c5
 1b0:	000003c7 	.word	0x000003c7
 1b4:	000003c9 	.word	0x000003c9
 1b8:	000003cb 	.word	0x000003cb
 1bc:	000003cd 	.word	0x000003cd
 1c0:	000003cf 	.word	0x000003cf
 1c4:	000003d1 	.word	0x000003d1
 1c8:	000003d3 	.word	0x000003d3
 1cc:	000003d5 	.word	0x000003d5
 1d0:	000003d7 	.word	0x000003d7
 1d4:	000003d9 	.word	0x000003d9
 1d8:	000003db 	.word	0x000003db
 1dc:	000003dd 	.word	0x000003dd
 1e0:	000003df 	.word	0x000003df
 1e4:	000003e1 	.word	0x000003e1
 1e8:	000003e3 	.word	0x000003e3
 1ec:	000003e5 	.word	0x000003e5
 1f0:	000003e7 	.word	0x000003e7
 1f4:	000003e9 	.word	0x000003e9
 1f8:	000003eb 	.word	0x000003eb
 1fc:	000003ed 	.word	0x000003ed
 200:	000003ef 	.word	0x000003ef
 204:	000003f1 	.word	0x000003f1
 208:	000003f3 	.word	0x000003f3
 20c:	000003f5 	.word	0x000003f5
 210:	000003f7 	.word	0x000003f7
 214:	000003f9 	.word	0x000003f9
 218:	00007fb9 	.word	0x00007fb9
 21c:	00007fe1 	.word	0x00007fe1
 220:	00008009 	.word	0x00008009
 224:	00008031 	.word	0x00008031
 228:	00008059 	.word	0x00008059
 22c:	00008081 	.word	0x00008081
 230:	000080a9 	.word	0x000080a9
 234:	000080d1 	.word	0x000080d1
 238:	000080f9 	.word	0x000080f9
 23c:	00008121 	.word	0x00008121
 240:	00008149 	.word	0x00008149
 244:	00008171 	.word	0x00008171
 248:	00008199 	.word	0x00008199
 24c:	000081c1 	.word	0x000081c1
 250:	000081e9 	.word	0x000081e9
 254:	00008211 	.word	0x00008211
 258:	00008239 	.word	0x00008239
 25c:	00008261 	.word	0x00008261
 260:	00008289 	.word	0x00008289
 264:	000082b1 	.word	0x000082b1
 268:	000082d9 	.word	0x000082d9
 26c:	00008301 	.word	0x00008301
 270:	00008329 	.word	0x00008329
 274:	00008351 	.word	0x00008351
 278:	00008379 	.word	0x00008379
 27c:	000083a1 	.word	0x000083a1
 280:	000083c9 	.word	0x000083c9
 284:	000083f1 	.word	0x000083f1
 288:	00008419 	.word	0x00008419
 28c:	00008441 	.word	0x00008441
 290:	00008469 	.word	0x00008469
 294:	00008491 	.word	0x00008491

00000298 <Reset_Handler>:
 298:	4868      	ldr	r0, [pc, #416]	; (43c <ACE_ADC2_FifoEmpty_IRQHandler+0x44>)
 29a:	4780      	blx	r0
 29c:	4868      	ldr	r0, [pc, #416]	; (440 <ACE_ADC2_FifoEmpty_IRQHandler+0x48>)
 29e:	2800      	cmp	r0, #0
 2a0:	d10b      	bne.n	2ba <copy_data>
 2a2:	4868      	ldr	r0, [pc, #416]	; (444 <ACE_ADC2_FifoEmpty_IRQHandler+0x4c>)
 2a4:	4968      	ldr	r1, [pc, #416]	; (448 <ACE_ADC2_FifoEmpty_IRQHandler+0x50>)
 2a6:	4a69      	ldr	r2, [pc, #420]	; (44c <ACE_ADC2_FifoEmpty_IRQHandler+0x54>)
 2a8:	4288      	cmp	r0, r1
 2aa:	d006      	beq.n	2ba <copy_data>

000002ac <copy_code_loop>:
 2ac:	4291      	cmp	r1, r2
 2ae:	bf1c      	itt	ne
 2b0:	f850 3b04 	ldrne.w	r3, [r0], #4
 2b4:	f841 3b04 	strne.w	r3, [r1], #4
 2b8:	d1f8      	bne.n	2ac <copy_code_loop>

000002ba <copy_data>:
 2ba:	4865      	ldr	r0, [pc, #404]	; (450 <ACE_ADC2_FifoEmpty_IRQHandler+0x58>)
 2bc:	4965      	ldr	r1, [pc, #404]	; (454 <ACE_ADC2_FifoEmpty_IRQHandler+0x5c>)
 2be:	4a66      	ldr	r2, [pc, #408]	; (458 <ACE_ADC2_FifoEmpty_IRQHandler+0x60>)
 2c0:	4288      	cmp	r0, r1
 2c2:	d006      	beq.n	2d2 <clear_bss>

000002c4 <copy_data_loop>:
 2c4:	4291      	cmp	r1, r2
 2c6:	bf1c      	itt	ne
 2c8:	f850 3b04 	ldrne.w	r3, [r0], #4
 2cc:	f841 3b04 	strne.w	r3, [r1], #4
 2d0:	d1f8      	bne.n	2c4 <copy_data_loop>

000002d2 <clear_bss>:
 2d2:	4862      	ldr	r0, [pc, #392]	; (45c <ACE_ADC2_FifoEmpty_IRQHandler+0x64>)
 2d4:	4962      	ldr	r1, [pc, #392]	; (460 <ACE_ADC2_FifoEmpty_IRQHandler+0x68>)
 2d6:	4a63      	ldr	r2, [pc, #396]	; (464 <ACE_ADC2_FifoEmpty_IRQHandler+0x6c>)

000002d8 <clear_bss_loop>:
 2d8:	4291      	cmp	r1, r2
 2da:	bf18      	it	ne
 2dc:	f841 0b04 	strne.w	r0, [r1], #4
 2e0:	d1fa      	bne.n	2d8 <clear_bss_loop>
	...

000002f0 <call_glob_ctor>:
 2f0:	f8df 0174 	ldr.w	r0, [pc, #372]	; 468 <ACE_ADC2_FifoEmpty_IRQHandler+0x70>
 2f4:	f20f 0e03 	addw	lr, pc, #3
 2f8:	4700      	bx	r0

000002fa <branch_to_main>:
 2fa:	f04f 0000 	mov.w	r0, #0
 2fe:	f04f 0100 	mov.w	r1, #0
 302:	f8df f168 	ldr.w	pc, [pc, #360]	; 46c <ACE_ADC2_FifoEmpty_IRQHandler+0x74>

00000306 <ExitLoop>:
 306:	e7fe      	b.n	306 <ExitLoop>

00000308 <NMI_Handler>:
 308:	e7fe      	b.n	308 <NMI_Handler>

0000030a <HardFault_Handler>:
 30a:	e7fe      	b.n	30a <HardFault_Handler>

0000030c <MemManage_Handler>:
 30c:	e7fe      	b.n	30c <MemManage_Handler>

0000030e <BusFault_Handler>:
 30e:	e7fe      	b.n	30e <BusFault_Handler>

00000310 <UsageFault_Handler>:
 310:	e7fe      	b.n	310 <UsageFault_Handler>
 312:	e7fe      	b.n	312 <UsageFault_Handler+0x2>

00000314 <DebugMon_Handler>:
 314:	e7fe      	b.n	314 <DebugMon_Handler>
 316:	e7fe      	b.n	316 <DebugMon_Handler+0x2>
 318:	e7fe      	b.n	318 <DebugMon_Handler+0x4>

0000031a <WdogWakeup_IRQHandler>:
 31a:	e7fe      	b.n	31a <WdogWakeup_IRQHandler>
 31c:	e7fe      	b.n	31c <WdogWakeup_IRQHandler+0x2>

0000031e <BrownOut_3_3V_IRQHandler>:
 31e:	e7fe      	b.n	31e <BrownOut_3_3V_IRQHandler>

00000320 <RTC_Match_IRQHandler>:
 320:	e7fe      	b.n	320 <RTC_Match_IRQHandler>

00000322 <RTCIF_Pub_IRQHandler>:
 322:	e7fe      	b.n	322 <RTCIF_Pub_IRQHandler>
 324:	e7fe      	b.n	324 <RTCIF_Pub_IRQHandler+0x2>

00000326 <IAP_IRQHandler>:
 326:	e7fe      	b.n	326 <IAP_IRQHandler>

00000328 <ENVM0_IRQHandler>:
 328:	e7fe      	b.n	328 <ENVM0_IRQHandler>

0000032a <ENVM1_IRQHandler>:
 32a:	e7fe      	b.n	32a <ENVM1_IRQHandler>

0000032c <DMA_IRQHandler>:
 32c:	e7fe      	b.n	32c <DMA_IRQHandler>
 32e:	e7fe      	b.n	32e <DMA_IRQHandler+0x2>
 330:	e7fe      	b.n	330 <DMA_IRQHandler+0x4>

00000332 <SPI0_IRQHandler>:
 332:	e7fe      	b.n	332 <SPI0_IRQHandler>

00000334 <SPI1_IRQHandler>:
 334:	e7fe      	b.n	334 <SPI1_IRQHandler>
 336:	e7fe      	b.n	336 <SPI1_IRQHandler+0x2>

00000338 <I2C0_SMBAlert_IRQHandler>:
 338:	e7fe      	b.n	338 <I2C0_SMBAlert_IRQHandler>

0000033a <I2C0_SMBus_IRQHandler>:
 33a:	e7fe      	b.n	33a <I2C0_SMBus_IRQHandler>
 33c:	e7fe      	b.n	33c <I2C0_SMBus_IRQHandler+0x2>

0000033e <I2C1_SMBAlert_IRQHandler>:
 33e:	e7fe      	b.n	33e <I2C1_SMBAlert_IRQHandler>

00000340 <I2C1_SMBus_IRQHandler>:
 340:	e7fe      	b.n	340 <I2C1_SMBus_IRQHandler>

00000342 <Timer1_IRQHandler>:
 342:	e7fe      	b.n	342 <Timer1_IRQHandler>

00000344 <Timer2_IRQHandler>:
 344:	e7fe      	b.n	344 <Timer2_IRQHandler>

00000346 <PLL_Lock_IRQHandler>:
 346:	e7fe      	b.n	346 <PLL_Lock_IRQHandler>

00000348 <PLL_LockLost_IRQHandler>:
 348:	e7fe      	b.n	348 <PLL_LockLost_IRQHandler>

0000034a <CommError_IRQHandler>:
 34a:	e7fe      	b.n	34a <CommError_IRQHandler>

0000034c <Fabric_IRQHandler>:
 34c:	e7fe      	b.n	34c <Fabric_IRQHandler>

0000034e <GPIO0_IRQHandler>:
 34e:	e7fe      	b.n	34e <GPIO0_IRQHandler>

00000350 <GPIO1_IRQHandler>:
 350:	e7fe      	b.n	350 <GPIO1_IRQHandler>

00000352 <GPIO2_IRQHandler>:
 352:	e7fe      	b.n	352 <GPIO2_IRQHandler>

00000354 <GPIO3_IRQHandler>:
 354:	e7fe      	b.n	354 <GPIO3_IRQHandler>

00000356 <GPIO4_IRQHandler>:
 356:	e7fe      	b.n	356 <GPIO4_IRQHandler>

00000358 <GPIO5_IRQHandler>:
 358:	e7fe      	b.n	358 <GPIO5_IRQHandler>

0000035a <GPIO6_IRQHandler>:
 35a:	e7fe      	b.n	35a <GPIO6_IRQHandler>

0000035c <GPIO7_IRQHandler>:
 35c:	e7fe      	b.n	35c <GPIO7_IRQHandler>
 35e:	e7fe      	b.n	35e <GPIO7_IRQHandler+0x2>

00000360 <GPIO9_IRQHandler>:
 360:	e7fe      	b.n	360 <GPIO9_IRQHandler>

00000362 <GPIO10_IRQHandler>:
 362:	e7fe      	b.n	362 <GPIO10_IRQHandler>

00000364 <GPIO11_IRQHandler>:
 364:	e7fe      	b.n	364 <GPIO11_IRQHandler>

00000366 <GPIO12_IRQHandler>:
 366:	e7fe      	b.n	366 <GPIO12_IRQHandler>

00000368 <GPIO13_IRQHandler>:
 368:	e7fe      	b.n	368 <GPIO13_IRQHandler>

0000036a <GPIO14_IRQHandler>:
 36a:	e7fe      	b.n	36a <GPIO14_IRQHandler>

0000036c <GPIO15_IRQHandler>:
 36c:	e7fe      	b.n	36c <GPIO15_IRQHandler>

0000036e <GPIO16_IRQHandler>:
 36e:	e7fe      	b.n	36e <GPIO16_IRQHandler>

00000370 <GPIO17_IRQHandler>:
 370:	e7fe      	b.n	370 <GPIO17_IRQHandler>

00000372 <GPIO18_IRQHandler>:
 372:	e7fe      	b.n	372 <GPIO18_IRQHandler>

00000374 <GPIO19_IRQHandler>:
 374:	e7fe      	b.n	374 <GPIO19_IRQHandler>

00000376 <GPIO20_IRQHandler>:
 376:	e7fe      	b.n	376 <GPIO20_IRQHandler>

00000378 <GPIO21_IRQHandler>:
 378:	e7fe      	b.n	378 <GPIO21_IRQHandler>

0000037a <GPIO22_IRQHandler>:
 37a:	e7fe      	b.n	37a <GPIO22_IRQHandler>

0000037c <GPIO23_IRQHandler>:
 37c:	e7fe      	b.n	37c <GPIO23_IRQHandler>

0000037e <GPIO24_IRQHandler>:
 37e:	e7fe      	b.n	37e <GPIO24_IRQHandler>

00000380 <GPIO25_IRQHandler>:
 380:	e7fe      	b.n	380 <GPIO25_IRQHandler>

00000382 <GPIO26_IRQHandler>:
 382:	e7fe      	b.n	382 <GPIO26_IRQHandler>

00000384 <GPIO27_IRQHandler>:
 384:	e7fe      	b.n	384 <GPIO27_IRQHandler>

00000386 <GPIO28_IRQHandler>:
 386:	e7fe      	b.n	386 <GPIO28_IRQHandler>

00000388 <GPIO29_IRQHandler>:
 388:	e7fe      	b.n	388 <GPIO29_IRQHandler>

0000038a <GPIO30_IRQHandler>:
 38a:	e7fe      	b.n	38a <GPIO30_IRQHandler>

0000038c <GPIO31_IRQHandler>:
 38c:	e7fe      	b.n	38c <GPIO31_IRQHandler>

0000038e <ACE_PC0_Flag0_IRQHandler>:
 38e:	e7fe      	b.n	38e <ACE_PC0_Flag0_IRQHandler>

00000390 <ACE_PC0_Flag1_IRQHandler>:
 390:	e7fe      	b.n	390 <ACE_PC0_Flag1_IRQHandler>

00000392 <ACE_PC0_Flag2_IRQHandler>:
 392:	e7fe      	b.n	392 <ACE_PC0_Flag2_IRQHandler>

00000394 <ACE_PC0_Flag3_IRQHandler>:
 394:	e7fe      	b.n	394 <ACE_PC0_Flag3_IRQHandler>

00000396 <ACE_PC1_Flag0_IRQHandler>:
 396:	e7fe      	b.n	396 <ACE_PC1_Flag0_IRQHandler>

00000398 <ACE_PC1_Flag1_IRQHandler>:
 398:	e7fe      	b.n	398 <ACE_PC1_Flag1_IRQHandler>

0000039a <ACE_PC1_Flag2_IRQHandler>:
 39a:	e7fe      	b.n	39a <ACE_PC1_Flag2_IRQHandler>

0000039c <ACE_PC1_Flag3_IRQHandler>:
 39c:	e7fe      	b.n	39c <ACE_PC1_Flag3_IRQHandler>

0000039e <ACE_PC2_Flag0_IRQHandler>:
 39e:	e7fe      	b.n	39e <ACE_PC2_Flag0_IRQHandler>

000003a0 <ACE_PC2_Flag1_IRQHandler>:
 3a0:	e7fe      	b.n	3a0 <ACE_PC2_Flag1_IRQHandler>

000003a2 <ACE_PC2_Flag2_IRQHandler>:
 3a2:	e7fe      	b.n	3a2 <ACE_PC2_Flag2_IRQHandler>

000003a4 <ACE_PC2_Flag3_IRQHandler>:
 3a4:	e7fe      	b.n	3a4 <ACE_PC2_Flag3_IRQHandler>

000003a6 <ACE_ADC0_DataValid_IRQHandler>:
 3a6:	e7fe      	b.n	3a6 <ACE_ADC0_DataValid_IRQHandler>

000003a8 <ACE_ADC1_DataValid_IRQHandler>:
 3a8:	e7fe      	b.n	3a8 <ACE_ADC1_DataValid_IRQHandler>

000003aa <ACE_ADC2_DataValid_IRQHandler>:
 3aa:	e7fe      	b.n	3aa <ACE_ADC2_DataValid_IRQHandler>

000003ac <ACE_ADC0_CalDone_IRQHandler>:
 3ac:	e7fe      	b.n	3ac <ACE_ADC0_CalDone_IRQHandler>

000003ae <ACE_ADC1_CalDone_IRQHandler>:
 3ae:	e7fe      	b.n	3ae <ACE_ADC1_CalDone_IRQHandler>

000003b0 <ACE_ADC2_CalDone_IRQHandler>:
 3b0:	e7fe      	b.n	3b0 <ACE_ADC2_CalDone_IRQHandler>

000003b2 <ACE_ADC0_CalStart_IRQHandler>:
 3b2:	e7fe      	b.n	3b2 <ACE_ADC0_CalStart_IRQHandler>

000003b4 <ACE_ADC1_CalStart_IRQHandler>:
 3b4:	e7fe      	b.n	3b4 <ACE_ADC1_CalStart_IRQHandler>

000003b6 <ACE_ADC2_CalStart_IRQHandler>:
 3b6:	e7fe      	b.n	3b6 <ACE_ADC2_CalStart_IRQHandler>

000003b8 <ACE_Comp0_Fall_IRQHandler>:
 3b8:	e7fe      	b.n	3b8 <ACE_Comp0_Fall_IRQHandler>

000003ba <ACE_Comp1_Fall_IRQHandler>:
 3ba:	e7fe      	b.n	3ba <ACE_Comp1_Fall_IRQHandler>

000003bc <ACE_Comp2_Fall_IRQHandler>:
 3bc:	e7fe      	b.n	3bc <ACE_Comp2_Fall_IRQHandler>

000003be <ACE_Comp3_Fall_IRQHandler>:
 3be:	e7fe      	b.n	3be <ACE_Comp3_Fall_IRQHandler>

000003c0 <ACE_Comp4_Fall_IRQHandler>:
 3c0:	e7fe      	b.n	3c0 <ACE_Comp4_Fall_IRQHandler>

000003c2 <ACE_Comp5_Fall_IRQHandler>:
 3c2:	e7fe      	b.n	3c2 <ACE_Comp5_Fall_IRQHandler>

000003c4 <ACE_Comp6_Fall_IRQHandler>:
 3c4:	e7fe      	b.n	3c4 <ACE_Comp6_Fall_IRQHandler>

000003c6 <ACE_Comp7_Fall_IRQHandler>:
 3c6:	e7fe      	b.n	3c6 <ACE_Comp7_Fall_IRQHandler>

000003c8 <ACE_Comp8_Fall_IRQHandler>:
 3c8:	e7fe      	b.n	3c8 <ACE_Comp8_Fall_IRQHandler>

000003ca <ACE_Comp9_Fall_IRQHandler>:
 3ca:	e7fe      	b.n	3ca <ACE_Comp9_Fall_IRQHandler>

000003cc <ACE_Comp10_Fall_IRQHandler>:
 3cc:	e7fe      	b.n	3cc <ACE_Comp10_Fall_IRQHandler>

000003ce <ACE_Comp11_Fall_IRQHandler>:
 3ce:	e7fe      	b.n	3ce <ACE_Comp11_Fall_IRQHandler>

000003d0 <ACE_Comp0_Rise_IRQHandler>:
 3d0:	e7fe      	b.n	3d0 <ACE_Comp0_Rise_IRQHandler>

000003d2 <ACE_Comp1_Rise_IRQHandler>:
 3d2:	e7fe      	b.n	3d2 <ACE_Comp1_Rise_IRQHandler>

000003d4 <ACE_Comp2_Rise_IRQHandler>:
 3d4:	e7fe      	b.n	3d4 <ACE_Comp2_Rise_IRQHandler>

000003d6 <ACE_Comp3_Rise_IRQHandler>:
 3d6:	e7fe      	b.n	3d6 <ACE_Comp3_Rise_IRQHandler>

000003d8 <ACE_Comp4_Rise_IRQHandler>:
 3d8:	e7fe      	b.n	3d8 <ACE_Comp4_Rise_IRQHandler>

000003da <ACE_Comp5_Rise_IRQHandler>:
 3da:	e7fe      	b.n	3da <ACE_Comp5_Rise_IRQHandler>

000003dc <ACE_Comp6_Rise_IRQHandler>:
 3dc:	e7fe      	b.n	3dc <ACE_Comp6_Rise_IRQHandler>

000003de <ACE_Comp7_Rise_IRQHandler>:
 3de:	e7fe      	b.n	3de <ACE_Comp7_Rise_IRQHandler>

000003e0 <ACE_Comp8_Rise_IRQHandler>:
 3e0:	e7fe      	b.n	3e0 <ACE_Comp8_Rise_IRQHandler>

000003e2 <ACE_Comp9_Rise_IRQHandler>:
 3e2:	e7fe      	b.n	3e2 <ACE_Comp9_Rise_IRQHandler>

000003e4 <ACE_Comp10_Rise_IRQHandler>:
 3e4:	e7fe      	b.n	3e4 <ACE_Comp10_Rise_IRQHandler>

000003e6 <ACE_Comp11_Rise_IRQHandler>:
 3e6:	e7fe      	b.n	3e6 <ACE_Comp11_Rise_IRQHandler>

000003e8 <ACE_ADC0_FifoFull_IRQHandler>:
 3e8:	e7fe      	b.n	3e8 <ACE_ADC0_FifoFull_IRQHandler>

000003ea <ACE_ADC0_FifoAFull_IRQHandler>:
 3ea:	e7fe      	b.n	3ea <ACE_ADC0_FifoAFull_IRQHandler>

000003ec <ACE_ADC0_FifoEmpty_IRQHandler>:
 3ec:	e7fe      	b.n	3ec <ACE_ADC0_FifoEmpty_IRQHandler>

000003ee <ACE_ADC1_FifoFull_IRQHandler>:
 3ee:	e7fe      	b.n	3ee <ACE_ADC1_FifoFull_IRQHandler>

000003f0 <ACE_ADC1_FifoAFull_IRQHandler>:
 3f0:	e7fe      	b.n	3f0 <ACE_ADC1_FifoAFull_IRQHandler>

000003f2 <ACE_ADC1_FifoEmpty_IRQHandler>:
 3f2:	e7fe      	b.n	3f2 <ACE_ADC1_FifoEmpty_IRQHandler>

000003f4 <ACE_ADC2_FifoFull_IRQHandler>:
 3f4:	e7fe      	b.n	3f4 <ACE_ADC2_FifoFull_IRQHandler>

000003f6 <ACE_ADC2_FifoAFull_IRQHandler>:
 3f6:	e7fe      	b.n	3f6 <ACE_ADC2_FifoAFull_IRQHandler>

000003f8 <ACE_ADC2_FifoEmpty_IRQHandler>:
 3f8:	e7fe      	b.n	3f8 <ACE_ADC2_FifoEmpty_IRQHandler>
 3fa:	e7fe      	b.n	3fa <ACE_ADC2_FifoEmpty_IRQHandler+0x2>
 3fc:	e7fe      	b.n	3fc <ACE_ADC2_FifoEmpty_IRQHandler+0x4>
 3fe:	e7fe      	b.n	3fe <ACE_ADC2_FifoEmpty_IRQHandler+0x6>
 400:	e7fe      	b.n	400 <ACE_ADC2_FifoEmpty_IRQHandler+0x8>
 402:	e7fe      	b.n	402 <ACE_ADC2_FifoEmpty_IRQHandler+0xa>
 404:	e7fe      	b.n	404 <ACE_ADC2_FifoEmpty_IRQHandler+0xc>
 406:	e7fe      	b.n	406 <ACE_ADC2_FifoEmpty_IRQHandler+0xe>
 408:	e7fe      	b.n	408 <ACE_ADC2_FifoEmpty_IRQHandler+0x10>
 40a:	e7fe      	b.n	40a <ACE_ADC2_FifoEmpty_IRQHandler+0x12>
 40c:	e7fe      	b.n	40c <ACE_ADC2_FifoEmpty_IRQHandler+0x14>
 40e:	e7fe      	b.n	40e <ACE_ADC2_FifoEmpty_IRQHandler+0x16>
 410:	e7fe      	b.n	410 <ACE_ADC2_FifoEmpty_IRQHandler+0x18>
 412:	e7fe      	b.n	412 <ACE_ADC2_FifoEmpty_IRQHandler+0x1a>
 414:	e7fe      	b.n	414 <ACE_ADC2_FifoEmpty_IRQHandler+0x1c>
 416:	e7fe      	b.n	416 <ACE_ADC2_FifoEmpty_IRQHandler+0x1e>
 418:	e7fe      	b.n	418 <ACE_ADC2_FifoEmpty_IRQHandler+0x20>
 41a:	e7fe      	b.n	41a <ACE_ADC2_FifoEmpty_IRQHandler+0x22>
 41c:	e7fe      	b.n	41c <ACE_ADC2_FifoEmpty_IRQHandler+0x24>
 41e:	e7fe      	b.n	41e <ACE_ADC2_FifoEmpty_IRQHandler+0x26>
 420:	e7fe      	b.n	420 <ACE_ADC2_FifoEmpty_IRQHandler+0x28>
 422:	e7fe      	b.n	422 <ACE_ADC2_FifoEmpty_IRQHandler+0x2a>
 424:	e7fe      	b.n	424 <ACE_ADC2_FifoEmpty_IRQHandler+0x2c>
 426:	e7fe      	b.n	426 <ACE_ADC2_FifoEmpty_IRQHandler+0x2e>
 428:	e7fe      	b.n	428 <ACE_ADC2_FifoEmpty_IRQHandler+0x30>
 42a:	e7fe      	b.n	42a <ACE_ADC2_FifoEmpty_IRQHandler+0x32>
 42c:	e7fe      	b.n	42c <ACE_ADC2_FifoEmpty_IRQHandler+0x34>
 42e:	e7fe      	b.n	42e <ACE_ADC2_FifoEmpty_IRQHandler+0x36>
 430:	e7fe      	b.n	430 <ACE_ADC2_FifoEmpty_IRQHandler+0x38>
 432:	e7fe      	b.n	432 <ACE_ADC2_FifoEmpty_IRQHandler+0x3a>
 434:	e7fe      	b.n	434 <ACE_ADC2_FifoEmpty_IRQHandler+0x3c>
 436:	e7fe      	b.n	436 <ACE_ADC2_FifoEmpty_IRQHandler+0x3e>
 438:	e7fe      	b.n	438 <ACE_ADC2_FifoEmpty_IRQHandler+0x40>
 43a:	0000      	.short	0x0000
 43c:	0000a329 	.word	0x0000a329
 440:	00000001 	.word	0x00000001
 444:	60000470 	.word	0x60000470
 448:	00000470 	.word	0x00000470
 44c:	20000008 	.word	0x20000008
 450:	6002fba0 	.word	0x6002fba0
 454:	20000008 	.word	0x20000008
 458:	20000624 	.word	0x20000624
 45c:	00000000 	.word	0x00000000
 460:	20000624 	.word	0x20000624
 464:	2000cca8 	.word	0x2000cca8
 468:	000153e5 	.word	0x000153e5
 46c:	00000909 	.word	0x00000909

Disassembly of section .text:

00000470 <__do_global_dtors_aux>:
     470:	f240 6324 	movw	r3, #1572	; 0x624
     474:	f2c2 0300 	movt	r3, #8192	; 0x2000
     478:	781a      	ldrb	r2, [r3, #0]
     47a:	b90a      	cbnz	r2, 480 <__do_global_dtors_aux+0x10>
     47c:	2001      	movs	r0, #1
     47e:	7018      	strb	r0, [r3, #0]
     480:	4770      	bx	lr
     482:	bf00      	nop

00000484 <frame_dummy>:
     484:	f240 0008 	movw	r0, #8
     488:	f2c2 0000 	movt	r0, #8192	; 0x2000
     48c:	b508      	push	{r3, lr}
     48e:	6803      	ldr	r3, [r0, #0]
     490:	b12b      	cbz	r3, 49e <frame_dummy+0x1a>
     492:	f240 0300 	movw	r3, #0
     496:	f2c0 0300 	movt	r3, #0
     49a:	b103      	cbz	r3, 49e <frame_dummy+0x1a>
     49c:	4798      	blx	r3
     49e:	bd08      	pop	{r3, pc}

000004a0 <MSS_GPIO_set_outputs>:
static __INLINE void
MSS_GPIO_set_outputs
(
   uint32_t value
)
{
     4a0:	b480      	push	{r7}
     4a2:	b083      	sub	sp, #12
     4a4:	af00      	add	r7, sp, #0
     4a6:	6078      	str	r0, [r7, #4]
    GPIO->GPIO_OUT = value;
     4a8:	f243 0300 	movw	r3, #12288	; 0x3000
     4ac:	f2c4 0301 	movt	r3, #16385	; 0x4001
     4b0:	687a      	ldr	r2, [r7, #4]
     4b2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
}
     4b6:	f107 070c 	add.w	r7, r7, #12
     4ba:	46bd      	mov	sp, r7
     4bc:	bc80      	pop	{r7}
     4be:	4770      	bx	lr

000004c0 <vParTestInitialise>:
static volatile unsigned long ulGPIOState = 0UL;

/*-----------------------------------------------------------*/

void vParTestInitialise( void )
{
     4c0:	b580      	push	{r7, lr}
     4c2:	b082      	sub	sp, #8
     4c4:	af00      	add	r7, sp, #0
long x;

	/* Initialise the GPIO */
	MSS_GPIO_init();
     4c6:	f003 fe8d 	bl	41e4 <MSS_GPIO_init>

	/* Set up GPIO for the LEDs. */
	for( x = 0; x < partstMAX_LEDS; x++ )
     4ca:	f04f 0300 	mov.w	r3, #0
     4ce:	607b      	str	r3, [r7, #4]
     4d0:	e00a      	b.n	4e8 <vParTestInitialise+0x28>
	{
		MSS_GPIO_config( ( mss_gpio_id_t ) x , MSS_GPIO_OUTPUT_MODE );
     4d2:	687b      	ldr	r3, [r7, #4]
     4d4:	b2db      	uxtb	r3, r3
     4d6:	4618      	mov	r0, r3
     4d8:	f04f 0105 	mov.w	r1, #5
     4dc:	f003 feb8 	bl	4250 <MSS_GPIO_config>

	/* Initialise the GPIO */
	MSS_GPIO_init();

	/* Set up GPIO for the LEDs. */
	for( x = 0; x < partstMAX_LEDS; x++ )
     4e0:	687b      	ldr	r3, [r7, #4]
     4e2:	f103 0301 	add.w	r3, r3, #1
     4e6:	607b      	str	r3, [r7, #4]
     4e8:	687b      	ldr	r3, [r7, #4]
     4ea:	2b07      	cmp	r3, #7
     4ec:	ddf1      	ble.n	4d2 <vParTestInitialise+0x12>
	{
		MSS_GPIO_config( ( mss_gpio_id_t ) x , MSS_GPIO_OUTPUT_MODE );
	}

	/* All LEDs start off. */
	ulGPIOState = 0xffffffffUL;
     4ee:	f240 6328 	movw	r3, #1576	; 0x628
     4f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
     4f6:	f04f 32ff 	mov.w	r2, #4294967295
     4fa:	601a      	str	r2, [r3, #0]
	MSS_GPIO_set_outputs( ulGPIOState );
     4fc:	f240 6328 	movw	r3, #1576	; 0x628
     500:	f2c2 0300 	movt	r3, #8192	; 0x2000
     504:	681b      	ldr	r3, [r3, #0]
     506:	4618      	mov	r0, r3
     508:	f7ff ffca 	bl	4a0 <MSS_GPIO_set_outputs>
}
     50c:	f107 0708 	add.w	r7, r7, #8
     510:	46bd      	mov	sp, r7
     512:	bd80      	pop	{r7, pc}

00000514 <vParTestSetLED>:
/*-----------------------------------------------------------*/

void vParTestSetLED( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
{
     514:	b580      	push	{r7, lr}
     516:	b082      	sub	sp, #8
     518:	af00      	add	r7, sp, #0
     51a:	6078      	str	r0, [r7, #4]
     51c:	6039      	str	r1, [r7, #0]
	if( uxLED < partstMAX_LEDS )
     51e:	687b      	ldr	r3, [r7, #4]
     520:	2b07      	cmp	r3, #7
     522:	d833      	bhi.n	58c <vParTestSetLED+0x78>
	{
		/* A critical section is used as the LEDs are also accessed from an
		interrupt. */
		taskENTER_CRITICAL();
     524:	f013 ff58 	bl	143d8 <vPortEnterCritical>
		{
			if( xValue == pdTRUE )
     528:	683b      	ldr	r3, [r7, #0]
     52a:	2b01      	cmp	r3, #1
     52c:	d113      	bne.n	556 <vParTestSetLED+0x42>
			{
				ulGPIOState &= ~( 1UL << uxLED );
     52e:	687b      	ldr	r3, [r7, #4]
     530:	f04f 0201 	mov.w	r2, #1
     534:	fa02 f303 	lsl.w	r3, r2, r3
     538:	ea6f 0203 	mvn.w	r2, r3
     53c:	f240 6328 	movw	r3, #1576	; 0x628
     540:	f2c2 0300 	movt	r3, #8192	; 0x2000
     544:	681b      	ldr	r3, [r3, #0]
     546:	ea02 0203 	and.w	r2, r2, r3
     54a:	f240 6328 	movw	r3, #1576	; 0x628
     54e:	f2c2 0300 	movt	r3, #8192	; 0x2000
     552:	601a      	str	r2, [r3, #0]
     554:	e010      	b.n	578 <vParTestSetLED+0x64>
			}
			else
			{
				ulGPIOState |= ( 1UL << uxLED );
     556:	687b      	ldr	r3, [r7, #4]
     558:	f04f 0201 	mov.w	r2, #1
     55c:	fa02 f203 	lsl.w	r2, r2, r3
     560:	f240 6328 	movw	r3, #1576	; 0x628
     564:	f2c2 0300 	movt	r3, #8192	; 0x2000
     568:	681b      	ldr	r3, [r3, #0]
     56a:	ea42 0203 	orr.w	r2, r2, r3
     56e:	f240 6328 	movw	r3, #1576	; 0x628
     572:	f2c2 0300 	movt	r3, #8192	; 0x2000
     576:	601a      	str	r2, [r3, #0]
			}
			
			MSS_GPIO_set_outputs( ulGPIOState );
     578:	f240 6328 	movw	r3, #1576	; 0x628
     57c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     580:	681b      	ldr	r3, [r3, #0]
     582:	4618      	mov	r0, r3
     584:	f7ff ff8c 	bl	4a0 <MSS_GPIO_set_outputs>
		}
		taskEXIT_CRITICAL();
     588:	f013 ff5e 	bl	14448 <vPortExitCritical>
	}
}
     58c:	f107 0708 	add.w	r7, r7, #8
     590:	46bd      	mov	sp, r7
     592:	bd80      	pop	{r7, pc}

00000594 <vParTestSetLEDFromISR>:
/*-----------------------------------------------------------*/

void vParTestSetLEDFromISR( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
{
     594:	b580      	push	{r7, lr}
     596:	b086      	sub	sp, #24
     598:	af00      	add	r7, sp, #0
     59a:	6078      	str	r0, [r7, #4]
     59c:	6039      	str	r1, [r7, #0]

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
     59e:	f3ef 8211 	mrs	r2, BASEPRI
     5a2:	f04f 0328 	mov.w	r3, #40	; 0x28
     5a6:	f383 8811 	msr	BASEPRI, r3
     5aa:	f3bf 8f6f 	isb	sy
     5ae:	f3bf 8f4f 	dsb	sy
     5b2:	613a      	str	r2, [r7, #16]
     5b4:	60fb      	str	r3, [r7, #12]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
     5b6:	693b      	ldr	r3, [r7, #16]
unsigned portBASE_TYPE uxInterruptFlags;

	uxInterruptFlags = portSET_INTERRUPT_MASK_FROM_ISR();
     5b8:	60bb      	str	r3, [r7, #8]
	{
		if( uxLED < partstMAX_LEDS )
     5ba:	687b      	ldr	r3, [r7, #4]
     5bc:	2b07      	cmp	r3, #7
     5be:	d82f      	bhi.n	620 <vParTestSetLEDFromISR+0x8c>
		{
			if( xValue == pdTRUE )
     5c0:	683b      	ldr	r3, [r7, #0]
     5c2:	2b01      	cmp	r3, #1
     5c4:	d113      	bne.n	5ee <vParTestSetLEDFromISR+0x5a>
			{
				ulGPIOState &= ~( 1UL << uxLED );
     5c6:	687b      	ldr	r3, [r7, #4]
     5c8:	f04f 0201 	mov.w	r2, #1
     5cc:	fa02 f303 	lsl.w	r3, r2, r3
     5d0:	ea6f 0203 	mvn.w	r2, r3
     5d4:	f240 6328 	movw	r3, #1576	; 0x628
     5d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
     5dc:	681b      	ldr	r3, [r3, #0]
     5de:	ea02 0203 	and.w	r2, r2, r3
     5e2:	f240 6328 	movw	r3, #1576	; 0x628
     5e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
     5ea:	601a      	str	r2, [r3, #0]
     5ec:	e010      	b.n	610 <vParTestSetLEDFromISR+0x7c>
			}
			else
			{
				ulGPIOState |= ( 1UL << uxLED );
     5ee:	687b      	ldr	r3, [r7, #4]
     5f0:	f04f 0201 	mov.w	r2, #1
     5f4:	fa02 f203 	lsl.w	r2, r2, r3
     5f8:	f240 6328 	movw	r3, #1576	; 0x628
     5fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
     600:	681b      	ldr	r3, [r3, #0]
     602:	ea42 0203 	orr.w	r2, r2, r3
     606:	f240 6328 	movw	r3, #1576	; 0x628
     60a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     60e:	601a      	str	r2, [r3, #0]
			}

			MSS_GPIO_set_outputs( ulGPIOState );
     610:	f240 6328 	movw	r3, #1576	; 0x628
     614:	f2c2 0300 	movt	r3, #8192	; 0x2000
     618:	681b      	ldr	r3, [r3, #0]
     61a:	4618      	mov	r0, r3
     61c:	f7ff ff40 	bl	4a0 <MSS_GPIO_set_outputs>
     620:	68bb      	ldr	r3, [r7, #8]
     622:	617b      	str	r3, [r7, #20]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
     624:	697b      	ldr	r3, [r7, #20]
     626:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxInterruptFlags );
}
     62a:	f107 0718 	add.w	r7, r7, #24
     62e:	46bd      	mov	sp, r7
     630:	bd80      	pop	{r7, pc}
     632:	bf00      	nop

00000634 <vParTestToggleLED>:
/*-----------------------------------------------------------*/

void vParTestToggleLED( unsigned portBASE_TYPE uxLED )
{
     634:	b580      	push	{r7, lr}
     636:	b082      	sub	sp, #8
     638:	af00      	add	r7, sp, #0
     63a:	6078      	str	r0, [r7, #4]
	if( uxLED < partstMAX_LEDS )
     63c:	687b      	ldr	r3, [r7, #4]
     63e:	2b07      	cmp	r3, #7
     640:	d83d      	bhi.n	6be <vParTestToggleLED+0x8a>
	{
		/* A critical section is used as the LEDs are also accessed from an
		interrupt. */
		taskENTER_CRITICAL();
     642:	f013 fec9 	bl	143d8 <vPortEnterCritical>
		{
			if( ( ulGPIOState & ( 1UL << uxLED ) ) != 0UL )
     646:	f240 6328 	movw	r3, #1576	; 0x628
     64a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     64e:	681a      	ldr	r2, [r3, #0]
     650:	687b      	ldr	r3, [r7, #4]
     652:	fa22 f303 	lsr.w	r3, r2, r3
     656:	f003 0301 	and.w	r3, r3, #1
     65a:	b2db      	uxtb	r3, r3
     65c:	2b00      	cmp	r3, #0
     65e:	d013      	beq.n	688 <vParTestToggleLED+0x54>
			{
				ulGPIOState &= ~( 1UL << uxLED );
     660:	687b      	ldr	r3, [r7, #4]
     662:	f04f 0201 	mov.w	r2, #1
     666:	fa02 f303 	lsl.w	r3, r2, r3
     66a:	ea6f 0203 	mvn.w	r2, r3
     66e:	f240 6328 	movw	r3, #1576	; 0x628
     672:	f2c2 0300 	movt	r3, #8192	; 0x2000
     676:	681b      	ldr	r3, [r3, #0]
     678:	ea02 0203 	and.w	r2, r2, r3
     67c:	f240 6328 	movw	r3, #1576	; 0x628
     680:	f2c2 0300 	movt	r3, #8192	; 0x2000
     684:	601a      	str	r2, [r3, #0]
     686:	e010      	b.n	6aa <vParTestToggleLED+0x76>
			}
			else
			{
				ulGPIOState |= ( 1UL << uxLED );
     688:	687b      	ldr	r3, [r7, #4]
     68a:	f04f 0201 	mov.w	r2, #1
     68e:	fa02 f203 	lsl.w	r2, r2, r3
     692:	f240 6328 	movw	r3, #1576	; 0x628
     696:	f2c2 0300 	movt	r3, #8192	; 0x2000
     69a:	681b      	ldr	r3, [r3, #0]
     69c:	ea42 0203 	orr.w	r2, r2, r3
     6a0:	f240 6328 	movw	r3, #1576	; 0x628
     6a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     6a8:	601a      	str	r2, [r3, #0]
			}
			
			MSS_GPIO_set_outputs( ulGPIOState );
     6aa:	f240 6328 	movw	r3, #1576	; 0x628
     6ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
     6b2:	681b      	ldr	r3, [r3, #0]
     6b4:	4618      	mov	r0, r3
     6b6:	f7ff fef3 	bl	4a0 <MSS_GPIO_set_outputs>
		}
		taskEXIT_CRITICAL();
     6ba:	f013 fec5 	bl	14448 <vPortExitCritical>
	}
}
     6be:	f107 0708 	add.w	r7, r7, #8
     6c2:	46bd      	mov	sp, r7
     6c4:	bd80      	pop	{r7, pc}
     6c6:	bf00      	nop

000006c8 <lParTestGetLEDState>:
/*-----------------------------------------------------------*/

long lParTestGetLEDState( unsigned long ulLED )
{
     6c8:	b580      	push	{r7, lr}
     6ca:	b084      	sub	sp, #16
     6cc:	af00      	add	r7, sp, #0
     6ce:	6078      	str	r0, [r7, #4]
long lReturn = pdFALSE;
     6d0:	f04f 0300 	mov.w	r3, #0
     6d4:	60fb      	str	r3, [r7, #12]

	if( ulLED < partstMAX_LEDS )
     6d6:	687b      	ldr	r3, [r7, #4]
     6d8:	2b07      	cmp	r3, #7
     6da:	d812      	bhi.n	702 <lParTestGetLEDState+0x3a>
	{
		taskENTER_CRITICAL();
     6dc:	f013 fe7c 	bl	143d8 <vPortEnterCritical>
		{
			if( ( ulGPIOState & ( 1UL << ulLED ) ) == 0UL )
     6e0:	f240 6328 	movw	r3, #1576	; 0x628
     6e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     6e8:	681a      	ldr	r2, [r3, #0]
     6ea:	687b      	ldr	r3, [r7, #4]
     6ec:	fa22 f303 	lsr.w	r3, r2, r3
     6f0:	f003 0301 	and.w	r3, r3, #1
     6f4:	2b00      	cmp	r3, #0
     6f6:	d102      	bne.n	6fe <lParTestGetLEDState+0x36>
			{
				lReturn = pdTRUE;
     6f8:	f04f 0301 	mov.w	r3, #1
     6fc:	60fb      	str	r3, [r7, #12]
			}
		}
		taskEXIT_CRITICAL();
     6fe:	f013 fea3 	bl	14448 <vPortExitCritical>
	}

	return lReturn;
     702:	68fb      	ldr	r3, [r7, #12]
}
     704:	4618      	mov	r0, r3
     706:	f107 0710 	add.w	r7, r7, #16
     70a:	46bd      	mov	sp, r7
     70c:	bd80      	pop	{r7, pc}
     70e:	bf00      	nop

00000710 <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
     710:	b480      	push	{r7}
     712:	b083      	sub	sp, #12
     714:	af00      	add	r7, sp, #0
     716:	4603      	mov	r3, r0
     718:	80fb      	strh	r3, [r7, #6]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
     71a:	f24e 1300 	movw	r3, #57600	; 0xe100
     71e:	f2ce 0300 	movt	r3, #57344	; 0xe000
     722:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
     726:	ea4f 1252 	mov.w	r2, r2, lsr #5
     72a:	88f9      	ldrh	r1, [r7, #6]
     72c:	f001 011f 	and.w	r1, r1, #31
     730:	f04f 0001 	mov.w	r0, #1
     734:	fa00 f101 	lsl.w	r1, r0, r1
     738:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
     73c:	f107 070c 	add.w	r7, r7, #12
     740:	46bd      	mov	sp, r7
     742:	bc80      	pop	{r7}
     744:	4770      	bx	lr
     746:	bf00      	nop

00000748 <NVIC_DisableIRQ>:
 * 
 * Disable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
     748:	b480      	push	{r7}
     74a:	b083      	sub	sp, #12
     74c:	af00      	add	r7, sp, #0
     74e:	4603      	mov	r3, r0
     750:	80fb      	strh	r3, [r7, #6]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
     752:	f24e 1300 	movw	r3, #57600	; 0xe100
     756:	f2ce 0300 	movt	r3, #57344	; 0xe000
     75a:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
     75e:	ea4f 1252 	mov.w	r2, r2, lsr #5
     762:	88f9      	ldrh	r1, [r7, #6]
     764:	f001 011f 	and.w	r1, r1, #31
     768:	f04f 0001 	mov.w	r0, #1
     76c:	fa00 f101 	lsl.w	r1, r0, r1
     770:	f102 0220 	add.w	r2, r2, #32
     774:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
     778:	f107 070c 	add.w	r7, r7, #12
     77c:	46bd      	mov	sp, r7
     77e:	bc80      	pop	{r7}
     780:	4770      	bx	lr
     782:	bf00      	nop

00000784 <NVIC_ClearPendingIRQ>:
 *
 * Clear the pending bit for the specified interrupt. 
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
     784:	b480      	push	{r7}
     786:	b083      	sub	sp, #12
     788:	af00      	add	r7, sp, #0
     78a:	4603      	mov	r3, r0
     78c:	80fb      	strh	r3, [r7, #6]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
     78e:	f24e 1300 	movw	r3, #57600	; 0xe100
     792:	f2ce 0300 	movt	r3, #57344	; 0xe000
     796:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
     79a:	ea4f 1252 	mov.w	r2, r2, lsr #5
     79e:	88f9      	ldrh	r1, [r7, #6]
     7a0:	f001 011f 	and.w	r1, r1, #31
     7a4:	f04f 0001 	mov.w	r0, #1
     7a8:	fa00 f101 	lsl.w	r1, r0, r1
     7ac:	f102 0260 	add.w	r2, r2, #96	; 0x60
     7b0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
     7b4:	f107 070c 	add.w	r7, r7, #12
     7b8:	46bd      	mov	sp, r7
     7ba:	bc80      	pop	{r7}
     7bc:	4770      	bx	lr
     7be:	bf00      	nop

000007c0 <NVIC_SetPriority>:
 * interrupt, or negative to specify an internal (core) interrupt.
 *
 * Note: The priority cannot be set for every core interrupt.
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
     7c0:	b480      	push	{r7}
     7c2:	b083      	sub	sp, #12
     7c4:	af00      	add	r7, sp, #0
     7c6:	4603      	mov	r3, r0
     7c8:	6039      	str	r1, [r7, #0]
     7ca:	80fb      	strh	r3, [r7, #6]
  if(IRQn < 0) {
     7cc:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
     7d0:	2b00      	cmp	r3, #0
     7d2:	da10      	bge.n	7f6 <NVIC_SetPriority+0x36>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M3 System Interrupts */
     7d4:	f64e 5300 	movw	r3, #60672	; 0xed00
     7d8:	f2ce 0300 	movt	r3, #57344	; 0xe000
     7dc:	88fa      	ldrh	r2, [r7, #6]
     7de:	f002 020f 	and.w	r2, r2, #15
     7e2:	f1a2 0104 	sub.w	r1, r2, #4
     7e6:	683a      	ldr	r2, [r7, #0]
     7e8:	b2d2      	uxtb	r2, r2
     7ea:	ea4f 02c2 	mov.w	r2, r2, lsl #3
     7ee:	b2d2      	uxtb	r2, r2
     7f0:	440b      	add	r3, r1
     7f2:	761a      	strb	r2, [r3, #24]
     7f4:	e00d      	b.n	812 <NVIC_SetPriority+0x52>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
     7f6:	f24e 1300 	movw	r3, #57600	; 0xe100
     7fa:	f2ce 0300 	movt	r3, #57344	; 0xe000
     7fe:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
     802:	683a      	ldr	r2, [r7, #0]
     804:	b2d2      	uxtb	r2, r2
     806:	ea4f 02c2 	mov.w	r2, r2, lsl #3
     80a:	b2d2      	uxtb	r2, r2
     80c:	440b      	add	r3, r1
     80e:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
     812:	f107 070c 	add.w	r7, r7, #12
     816:	46bd      	mov	sp, r7
     818:	bc80      	pop	{r7}
     81a:	4770      	bx	lr

0000081c <MSS_TIM64_init>:
    one-shot mode. Allowed values for this parameter are:
        - MSS_TIMER_PERIODIC_MODE
        - MSS_TIMER_ONE_SHOT_MODE 
 */
static __INLINE void MSS_TIM64_init( mss_timer_mode_t mode )
{
     81c:	b580      	push	{r7, lr}
     81e:	b082      	sub	sp, #8
     820:	af00      	add	r7, sp, #0
     822:	4603      	mov	r3, r0
     824:	71fb      	strb	r3, [r7, #7]
    NVIC_DisableIRQ( Timer1_IRQn );         /* disable timer 1 interrupt within NVIC */
     826:	f04f 0014 	mov.w	r0, #20
     82a:	f7ff ff8d 	bl	748 <NVIC_DisableIRQ>
    NVIC_DisableIRQ( Timer2_IRQn );         /* disable timer 2 interrupt within NVIC */
     82e:	f04f 0015 	mov.w	r0, #21
     832:	f7ff ff89 	bl	748 <NVIC_DisableIRQ>
    
    SYSREG->SOFT_RST_CR &= ~SYSREG_TIMER_SOFTRESET_MASK; /* Take timer block out of reset */
     836:	f242 0300 	movw	r3, #8192	; 0x2000
     83a:	f2ce 0304 	movt	r3, #57348	; 0xe004
     83e:	f242 0200 	movw	r2, #8192	; 0x2000
     842:	f2ce 0204 	movt	r2, #57348	; 0xe004
     846:	6b12      	ldr	r2, [r2, #48]	; 0x30
     848:	f022 0240 	bic.w	r2, r2, #64	; 0x40
     84c:	631a      	str	r2, [r3, #48]	; 0x30
    
    TIMER->TIM64_MODE = 1U;                     /* switch to 64 bits mode */
     84e:	f245 0300 	movw	r3, #20480	; 0x5000
     852:	f2c4 0300 	movt	r3, #16384	; 0x4000
     856:	f04f 0201 	mov.w	r2, #1
     85a:	655a      	str	r2, [r3, #84]	; 0x54
    
    TIMER_BITBAND->TIM64ENABLE = 0U;            /* disable timer */
     85c:	f240 0300 	movw	r3, #0
     860:	f2c4 230a 	movt	r3, #16906	; 0x420a
     864:	f04f 0200 	mov.w	r2, #0
     868:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
    TIMER_BITBAND->TIM64INTEN = 0U;             /* disable interrupt */
     86c:	f240 0300 	movw	r3, #0
     870:	f2c4 230a 	movt	r3, #16906	; 0x420a
     874:	f04f 0200 	mov.w	r2, #0
     878:	f8c3 2908 	str.w	r2, [r3, #2312]	; 0x908
    TIMER_BITBAND->TIM64MODE = (uint32_t)mode;  /* set mode (continuous/one-shot) */
     87c:	f240 0300 	movw	r3, #0
     880:	f2c4 230a 	movt	r3, #16906	; 0x420a
     884:	79fa      	ldrb	r2, [r7, #7]
     886:	f8c3 2904 	str.w	r2, [r3, #2308]	; 0x904
    
    TIMER->TIM1_RIS = 1U;                   /* clear timer 1 interrupt */
     88a:	f245 0300 	movw	r3, #20480	; 0x5000
     88e:	f2c4 0300 	movt	r3, #16384	; 0x4000
     892:	f04f 0201 	mov.w	r2, #1
     896:	611a      	str	r2, [r3, #16]
    TIMER->TIM2_RIS = 1U;                   /* clear timer 2 interrupt */
     898:	f245 0300 	movw	r3, #20480	; 0x5000
     89c:	f2c4 0300 	movt	r3, #16384	; 0x4000
     8a0:	f04f 0201 	mov.w	r2, #1
     8a4:	629a      	str	r2, [r3, #40]	; 0x28
    NVIC_ClearPendingIRQ( Timer1_IRQn );    /* clear timer 1 interrupt within NVIC */
     8a6:	f04f 0014 	mov.w	r0, #20
     8aa:	f7ff ff6b 	bl	784 <NVIC_ClearPendingIRQ>
    NVIC_ClearPendingIRQ( Timer2_IRQn );    /* clear timer 2 interrupt within NVIC */
     8ae:	f04f 0015 	mov.w	r0, #21
     8b2:	f7ff ff67 	bl	784 <NVIC_ClearPendingIRQ>
}
     8b6:	f107 0708 	add.w	r7, r7, #8
     8ba:	46bd      	mov	sp, r7
     8bc:	bd80      	pop	{r7, pc}
     8be:	bf00      	nop

000008c0 <MSS_TIM64_start>:
  The MSS_TIM64_start() function enables the 64-bit timer and starts its
  down-counter decrementing from the load_value specified in previous calls to
  the MSS_TIM64_load_immediate() or MSS_TIM64_load_background() functions.
 */
static __INLINE void MSS_TIM64_start( void )
{
     8c0:	b480      	push	{r7}
     8c2:	af00      	add	r7, sp, #0
    TIMER_BITBAND->TIM64ENABLE = 1U;    /* enable timer */
     8c4:	f240 0300 	movw	r3, #0
     8c8:	f2c4 230a 	movt	r3, #16906	; 0x420a
     8cc:	f04f 0201 	mov.w	r2, #1
     8d0:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
}
     8d4:	46bd      	mov	sp, r7
     8d6:	bc80      	pop	{r7}
     8d8:	4770      	bx	lr
     8da:	bf00      	nop

000008dc <MSS_TIM64_load_immediate>:
static __INLINE void MSS_TIM64_load_immediate
(
    uint32_t load_value_u,
    uint32_t load_value_l
)
{
     8dc:	b480      	push	{r7}
     8de:	b083      	sub	sp, #12
     8e0:	af00      	add	r7, sp, #0
     8e2:	6078      	str	r0, [r7, #4]
     8e4:	6039      	str	r1, [r7, #0]
    TIMER->TIM64_LOADVAL_U = load_value_u;
     8e6:	f245 0300 	movw	r3, #20480	; 0x5000
     8ea:	f2c4 0300 	movt	r3, #16384	; 0x4000
     8ee:	687a      	ldr	r2, [r7, #4]
     8f0:	639a      	str	r2, [r3, #56]	; 0x38
    TIMER->TIM64_LOADVAL_L = load_value_l;
     8f2:	f245 0300 	movw	r3, #20480	; 0x5000
     8f6:	f2c4 0300 	movt	r3, #16384	; 0x4000
     8fa:	683a      	ldr	r2, [r7, #0]
     8fc:	63da      	str	r2, [r3, #60]	; 0x3c
}
     8fe:	f107 070c 	add.w	r7, r7, #12
     902:	46bd      	mov	sp, r7
     904:	bc80      	pop	{r7}
     906:	4770      	bx	lr

00000908 <main>:
|   (O)            (+)              (O)   |\n\r \
\_______________________________________/"


int main(void)
{
     908:	b580      	push	{r7, lr}
     90a:	b082      	sub	sp, #8
     90c:	af02      	add	r7, sp, #8
	/* Configure the NVIC, LED outputs and button inputs. */
	prvSetupHardware();
     90e:	f000 f90d 	bl	b2c <prvSetupHardware>

	/* Create the queue. */
	xQueue = xQueueCreate( mainQUEUE_LENGTH, sizeof( unsigned long ) );
     912:	f04f 0001 	mov.w	r0, #1
     916:	f04f 0104 	mov.w	r1, #4
     91a:	f04f 0200 	mov.w	r2, #0
     91e:	f00e fdbd 	bl	f49c <xQueueGenericCreate>
     922:	4602      	mov	r2, r0
     924:	f240 632c 	movw	r3, #1580	; 0x62c
     928:	f2c2 0300 	movt	r3, #8192	; 0x2000
     92c:	601a      	str	r2, [r3, #0]

	if( xQueue != NULL )
     92e:	f240 632c 	movw	r3, #1580	; 0x62c
     932:	f2c2 0300 	movt	r3, #8192	; 0x2000
     936:	681b      	ldr	r3, [r3, #0]
     938:	2b00      	cmp	r3, #0
     93a:	d068      	beq.n	a0e <main+0x106>
	{

		xTaskCreate( prvQueueReceiveTask, "Rx", configMINIMAL_STACK_SIZE, NULL, mainQUEUE_RECEIVE_TASK_PRIORITY, NULL );
     93c:	f04f 0302 	mov.w	r3, #2
     940:	9300      	str	r3, [sp, #0]
     942:	f04f 0300 	mov.w	r3, #0
     946:	9301      	str	r3, [sp, #4]
     948:	f640 20f5 	movw	r0, #2805	; 0xaf5
     94c:	f2c0 0000 	movt	r0, #0
     950:	f24c 5138 	movw	r1, #50488	; 0xc538
     954:	f2c0 0101 	movt	r1, #1
     958:	f04f 025a 	mov.w	r2, #90	; 0x5a
     95c:	f04f 0300 	mov.w	r3, #0
     960:	f00f ff74 	bl	1084c <xTaskCreate>
		xTaskCreate( prvQueueSendTask, "TX", configMINIMAL_STACK_SIZE, NULL, mainQUEUE_SEND_TASK_PRIORITY, NULL );
     964:	f04f 0301 	mov.w	r3, #1
     968:	9300      	str	r3, [sp, #0]
     96a:	f04f 0300 	mov.w	r3, #0
     96e:	9301      	str	r3, [sp, #4]
     970:	f640 2089 	movw	r0, #2697	; 0xa89
     974:	f2c0 0000 	movt	r0, #0
     978:	f24c 513c 	movw	r1, #50492	; 0xc53c
     97c:	f2c0 0101 	movt	r1, #1
     980:	f04f 025a 	mov.w	r2, #90	; 0x5a
     984:	f04f 0300 	mov.w	r3, #0
     988:	f00f ff60 	bl	1084c <xTaskCreate>
		//printf( "\n\r********* Welcome to the Measurement System  *********\n\r" );


		/* Create the software timer that performs the 'check' functionality,
		as described at the top of this file. */
		xCheckTimer = xTimerCreate( "CheckTimer",					/* A text name, purely to help debugging. */
     98c:	f640 2311 	movw	r3, #2577	; 0xa11
     990:	f2c0 0300 	movt	r3, #0
     994:	9300      	str	r3, [sp, #0]
     996:	f24c 5040 	movw	r0, #50496	; 0xc540
     99a:	f2c0 0001 	movt	r0, #1
     99e:	f640 31b8 	movw	r1, #3000	; 0xbb8
     9a2:	f04f 0201 	mov.w	r2, #1
     9a6:	f04f 0300 	mov.w	r3, #0
     9aa:	f012 fe3f 	bl	1362c <xTimerCreate>
     9ae:	4602      	mov	r2, r0
     9b0:	f240 6330 	movw	r3, #1584	; 0x630
     9b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     9b8:	601a      	str	r2, [r3, #0]
									( void * ) 0,					/* The ID is not used, so can be set to anything. */
									prvCheckTimerCallback			/* The callback function that inspects the status of all the other tasks. */
								  );

		/* Create the web server task. */
		xTaskCreate( vuIP_Task, "uIP", mainuIP_STACK_SIZE, NULL, mainuIP_TASK_PRIORITY, NULL );
     9ba:	f04f 0302 	mov.w	r3, #2
     9be:	9300      	str	r3, [sp, #0]
     9c0:	f04f 0300 	mov.w	r3, #0
     9c4:	9301      	str	r3, [sp, #4]
     9c6:	f241 10f5 	movw	r0, #4597	; 0x11f5
     9ca:	f2c0 0000 	movt	r0, #0
     9ce:	f24c 514c 	movw	r1, #50508	; 0xc54c
     9d2:	f2c0 0101 	movt	r1, #1
     9d6:	f44f 7287 	mov.w	r2, #270	; 0x10e
     9da:	f04f 0300 	mov.w	r3, #0
     9de:	f00f ff35 	bl	1084c <xTaskCreate>

		xTaskCreate( uart_task, "uart_task" ,configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+1, NULL);
     9e2:	f04f 0301 	mov.w	r3, #1
     9e6:	9300      	str	r3, [sp, #0]
     9e8:	f04f 0300 	mov.w	r3, #0
     9ec:	9301      	str	r3, [sp, #4]
     9ee:	f640 4029 	movw	r0, #3113	; 0xc29
     9f2:	f2c0 0000 	movt	r0, #0
     9f6:	f24c 5150 	movw	r1, #50512	; 0xc550
     9fa:	f2c0 0101 	movt	r1, #1
     9fe:	f04f 025a 	mov.w	r2, #90	; 0x5a
     a02:	f04f 0300 	mov.w	r3, #0
     a06:	f00f ff21 	bl	1084c <xTaskCreate>


		/* Start the tasks and timer running. */
		vTaskStartScheduler();
     a0a:	f010 fd8f 	bl	1152c <vTaskStartScheduler>
	/* If all is well, the scheduler will now be running, and the following line
	will never be reached.  If the following line does execute, then there was
	insufficient FreeRTOS heap memory available for the idle and/or timer tasks
	to be created.  See the memory management section on the FreeRTOS web site
	for more details. */
	for( ;; );
     a0e:	e7fe      	b.n	a0e <main+0x106>

00000a10 <prvCheckTimerCallback>:




static void prvCheckTimerCallback( TimerHandle_t xTimer )
{
     a10:	b580      	push	{r7, lr}
     a12:	b084      	sub	sp, #16
     a14:	af02      	add	r7, sp, #8
     a16:	6078      	str	r0, [r7, #4]

	/* Have any errors been latch in pcStatusMessage?  If so, shorten the
	period of the check timer to mainERROR_CHECK_TIMER_PERIOD_MS milliseconds.
	This will result in an increase in the rate at which mainCHECK_LED
	toggles. */
	if( pcStatusMessage != NULL )
     a18:	f240 6334 	movw	r3, #1588	; 0x634
     a1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a20:	681b      	ldr	r3, [r3, #0]
     a22:	2b00      	cmp	r3, #0
     a24:	d010      	beq.n	a48 <prvCheckTimerCallback+0x38>
	{
		/* This call to xTimerChangePeriod() uses a zero block time.  Functions
		called from inside of a timer callback function must *never* attempt
		to block. */
		xTimerChangePeriod( xCheckTimer, ( mainERROR_CHECK_TIMER_PERIOD_MS ), mainDONT_BLOCK );
     a26:	f240 6330 	movw	r3, #1584	; 0x630
     a2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a2e:	681b      	ldr	r3, [r3, #0]
     a30:	f04f 0200 	mov.w	r2, #0
     a34:	9200      	str	r2, [sp, #0]
     a36:	4618      	mov	r0, r3
     a38:	f04f 0104 	mov.w	r1, #4
     a3c:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
     a40:	f04f 0300 	mov.w	r3, #0
     a44:	f012 fe44 	bl	136d0 <xTimerGenericCommand>
	}
}
     a48:	f107 0708 	add.w	r7, r7, #8
     a4c:	46bd      	mov	sp, r7
     a4e:	bd80      	pop	{r7, pc}

00000a50 <GPIO8_IRQHandler>:

/*-----------------------------------------------------------*/

/* The ISR executed when the user button is pushed. */
void GPIO8_IRQHandler( void )
{
     a50:	b580      	push	{r7, lr}
     a52:	b082      	sub	sp, #8
     a54:	af00      	add	r7, sp, #0
portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     a56:	f04f 0300 	mov.w	r3, #0
     a5a:	607b      	str	r3, [r7, #4]

//DO SOMETHING IF INTERUPTED BY BUTTON ON GPIO8 (SW1)


	/* Clear the interrupt before leaving. */
    MSS_GPIO_clear_irq( MSS_GPIO_8 );
     a5c:	f04f 0008 	mov.w	r0, #8
     a60:	f003 fd22 	bl	44a8 <MSS_GPIO_clear_irq>
	/* If calling xTimerResetFromISR() caused a task (in this case the timer
	service/daemon task) to unblock, and the unblocked task has a priority
	higher than or equal to the task that was interrupted, then
	xHigherPriorityTaskWoken will now be set to pdTRUE, and calling
	portEND_SWITCHING_ISR() will ensure the unblocked task runs next. */
	portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );
     a64:	687b      	ldr	r3, [r7, #4]
     a66:	2b00      	cmp	r3, #0
     a68:	d00a      	beq.n	a80 <GPIO8_IRQHandler+0x30>
     a6a:	f64e 5304 	movw	r3, #60676	; 0xed04
     a6e:	f2ce 0300 	movt	r3, #57344	; 0xe000
     a72:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
     a76:	601a      	str	r2, [r3, #0]
     a78:	f3bf 8f4f 	dsb	sy
     a7c:	f3bf 8f6f 	isb	sy
}
     a80:	f107 0708 	add.w	r7, r7, #8
     a84:	46bd      	mov	sp, r7
     a86:	bd80      	pop	{r7, pc}

00000a88 <prvQueueSendTask>:
/*-----------------------------------------------------------*/

static void prvQueueSendTask( void *pvParameters )
{
     a88:	b590      	push	{r4, r7, lr}
     a8a:	b087      	sub	sp, #28
     a8c:	af02      	add	r7, sp, #8
     a8e:	6078      	str	r0, [r7, #4]
TickType_t xNextWakeTime;
const unsigned long ulValueToSend = 100UL;
     a90:	f04f 0364 	mov.w	r3, #100	; 0x64
     a94:	60bb      	str	r3, [r7, #8]
	/* The timer command queue will have been filled when the timer test tasks
	were created in main() (this is part of the test they perform).  Therefore,
	while the check timer can be created in main(), it cannot be started from
	main().  Once the scheduler has started, the timer service task will drain
	the command queue, and now the check timer can be started successfully. */
	xTimerStart( xCheckTimer, portMAX_DELAY );
     a96:	f240 6330 	movw	r3, #1584	; 0x630
     a9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a9e:	681c      	ldr	r4, [r3, #0]
     aa0:	f010 fe9a 	bl	117d8 <xTaskGetTickCount>
     aa4:	4603      	mov	r3, r0
     aa6:	f04f 32ff 	mov.w	r2, #4294967295
     aaa:	9200      	str	r2, [sp, #0]
     aac:	4620      	mov	r0, r4
     aae:	f04f 0101 	mov.w	r1, #1
     ab2:	461a      	mov	r2, r3
     ab4:	f04f 0300 	mov.w	r3, #0
     ab8:	f012 fe0a 	bl	136d0 <xTimerGenericCommand>

	/* Initialise xNextWakeTime - this only needs to be done once. */
	xNextWakeTime = xTaskGetTickCount();
     abc:	f010 fe8c 	bl	117d8 <xTaskGetTickCount>
     ac0:	4603      	mov	r3, r0
     ac2:	60fb      	str	r3, [r7, #12]
	{
		/* Place this task in the blocked state until it is time to run again.
		The block time is specified in ticks, the constant used converts ticks
		to ms.  While in the Blocked state this task will not consume any CPU
		time. */
		vTaskDelayUntil( &xNextWakeTime, mainQUEUE_SEND_FREQUENCY_MS );
     ac4:	f107 030c 	add.w	r3, r7, #12
     ac8:	4618      	mov	r0, r3
     aca:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
     ace:	f010 f8ff 	bl	10cd0 <vTaskDelayUntil>

		/* Send to the queue - causing the queue receive task to unblock and
		toggle an LED.  0 is used as the block time so the sending operation
		will not block - it shouldn't need to block as the queue should always
		be empty at this point in the code. */
		xQueueSend( xQueue, &ulValueToSend, mainDONT_BLOCK );
     ad2:	f240 632c 	movw	r3, #1580	; 0x62c
     ad6:	f2c2 0300 	movt	r3, #8192	; 0x2000
     ada:	681a      	ldr	r2, [r3, #0]
     adc:	f107 0308 	add.w	r3, r7, #8
     ae0:	4610      	mov	r0, r2
     ae2:	4619      	mov	r1, r3
     ae4:	f04f 0200 	mov.w	r2, #0
     ae8:	f04f 0300 	mov.w	r3, #0
     aec:	f00e fdea 	bl	f6c4 <xQueueGenericSend>
	}
     af0:	e7e8      	b.n	ac4 <prvQueueSendTask+0x3c>
     af2:	bf00      	nop

00000af4 <prvQueueReceiveTask>:
}
/*-----------------------------------------------------------*/

static void prvQueueReceiveTask( void *pvParameters )
{
     af4:	b580      	push	{r7, lr}
     af6:	b084      	sub	sp, #16
     af8:	af00      	add	r7, sp, #0
     afa:	6078      	str	r0, [r7, #4]
     afc:	e000      	b.n	b00 <prvQueueReceiveTask+0xc>
		is it the expected value?  If it is, toggle the LED. */
		if( ulReceivedValue == 100UL )
		{
			vParTestToggleLED( mainTASK_CONTROLLED_LED );
		}
	}
     afe:	bf00      	nop
	for( ;; )
	{
		/* Wait until something arrives in the queue - this task will block
		indefinitely provided INCLUDE_vTaskSuspend is set to 1 in
		FreeRTOSConfig.h. */
		xQueueReceive( xQueue, &ulReceivedValue, portMAX_DELAY );
     b00:	f240 632c 	movw	r3, #1580	; 0x62c
     b04:	f2c2 0300 	movt	r3, #8192	; 0x2000
     b08:	681a      	ldr	r2, [r3, #0]
     b0a:	f107 030c 	add.w	r3, r7, #12
     b0e:	4610      	mov	r0, r2
     b10:	4619      	mov	r1, r3
     b12:	f04f 32ff 	mov.w	r2, #4294967295
     b16:	f00f f825 	bl	fb64 <xQueueReceive>

		/*  To get here something must have been received from the queue, but
		is it the expected value?  If it is, toggle the LED. */
		if( ulReceivedValue == 100UL )
     b1a:	68fb      	ldr	r3, [r7, #12]
     b1c:	2b64      	cmp	r3, #100	; 0x64
     b1e:	d1ee      	bne.n	afe <prvQueueReceiveTask+0xa>
		{
			vParTestToggleLED( mainTASK_CONTROLLED_LED );
     b20:	f04f 0005 	mov.w	r0, #5
     b24:	f7ff fd86 	bl	634 <vParTestToggleLED>
		}
	}
     b28:	e7ea      	b.n	b00 <prvQueueReceiveTask+0xc>
     b2a:	bf00      	nop

00000b2c <prvSetupHardware>:
}
/*-----------------------------------------------------------*/


static void prvSetupHardware( void )
{
     b2c:	b580      	push	{r7, lr}
     b2e:	af00      	add	r7, sp, #0
	SystemCoreClockUpdate();
     b30:	f009 fc00 	bl	a334 <SystemCoreClockUpdate>


	/* Configure the GPIO for the LEDs. */
	vParTestInitialise();
     b34:	f7ff fcc4 	bl	4c0 <vParTestInitialise>

    MSS_UART_init
     b38:	f64a 10d0 	movw	r0, #43472	; 0xa9d0
     b3c:	f2c2 0000 	movt	r0, #8192	; 0x2000
     b40:	f44f 4161 	mov.w	r1, #57600	; 0xe100
     b44:	f04f 0203 	mov.w	r2, #3
     b48:	f001 f9ac 	bl	1ea4 <MSS_UART_init>
        MSS_UART_57600_BAUD,
        MSS_UART_DATA_8_BITS | MSS_UART_NO_PARITY | MSS_UART_ONE_STOP_BIT
    );

	/* ACE Initialization */
	ACE_init();
     b4c:	f008 fbfa 	bl	9344 <ACE_init>

	/* Setup the GPIO and the NVIC for the switch used in this simple demo. */
	NVIC_SetPriority( GPIO8_IRQn, configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY );
     b50:	f04f 0028 	mov.w	r0, #40	; 0x28
     b54:	f04f 0105 	mov.w	r1, #5
     b58:	f7ff fe32 	bl	7c0 <NVIC_SetPriority>
    NVIC_EnableIRQ( GPIO8_IRQn );
     b5c:	f04f 0028 	mov.w	r0, #40	; 0x28
     b60:	f7ff fdd6 	bl	710 <NVIC_EnableIRQ>
    MSS_GPIO_config( MSS_GPIO_8, MSS_GPIO_INPUT_MODE | MSS_GPIO_IRQ_EDGE_NEGATIVE );
     b64:	f04f 0008 	mov.w	r0, #8
     b68:	f04f 0162 	mov.w	r1, #98	; 0x62
     b6c:	f003 fb70 	bl	4250 <MSS_GPIO_config>
    MSS_GPIO_enable_irq( MSS_GPIO_8 );
     b70:	f04f 0008 	mov.w	r0, #8
     b74:	f003 fc3e 	bl	43f4 <MSS_GPIO_enable_irq>
}
     b78:	bd80      	pop	{r7, pc}
     b7a:	bf00      	nop

00000b7c <vApplicationMallocFailedHook>:
/*-----------------------------------------------------------*/

void vApplicationMallocFailedHook( void )
{
     b7c:	b480      	push	{r7}
     b7e:	af00      	add	r7, sp, #0
	/* Called if a call to pvPortMalloc() fails because there is insufficient
	free memory available in the FreeRTOS heap.  pvPortMalloc() is called
	internally by FreeRTOS API functions that create tasks, queues, software
	timers, and semaphores.  The size of the FreeRTOS heap is set by the
	configTOTAL_HEAP_SIZE configuration constant in FreeRTOSConfig.h. */
	for( ;; );
     b80:	e7fe      	b.n	b80 <vApplicationMallocFailedHook+0x4>
     b82:	bf00      	nop

00000b84 <vApplicationStackOverflowHook>:
}
/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName )
{
     b84:	b480      	push	{r7}
     b86:	b085      	sub	sp, #20
     b88:	af00      	add	r7, sp, #0
     b8a:	6078      	str	r0, [r7, #4]
     b8c:	6039      	str	r1, [r7, #0]

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
     b8e:	f04f 0328 	mov.w	r3, #40	; 0x28
     b92:	f383 8811 	msr	BASEPRI, r3
     b96:	f3bf 8f6f 	isb	sy
     b9a:	f3bf 8f4f 	dsb	sy
     b9e:	60fb      	str	r3, [r7, #12]

	/* Run time stack overflow checking is performed if
	configconfigCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected. */
	taskDISABLE_INTERRUPTS();
	for( ;; );
     ba0:	e7fe      	b.n	ba0 <vApplicationStackOverflowHook+0x1c>
     ba2:	bf00      	nop

00000ba4 <vApplicationIdleHook>:
}
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
     ba4:	b580      	push	{r7, lr}
     ba6:	b082      	sub	sp, #8
     ba8:	af00      	add	r7, sp, #0
volatile size_t xFreeStackSpace;

	/* This function is called on each cycle of the idle task.  In this case it
	does nothing useful, other than report the amount of FreeRTOS heap that
	remains unallocated. */
	xFreeStackSpace = xPortGetFreeHeapSize();
     baa:	f013 fa91 	bl	140d0 <xPortGetFreeHeapSize>
     bae:	4603      	mov	r3, r0
     bb0:	607b      	str	r3, [r7, #4]

	if( xFreeStackSpace > 100 )
     bb2:	687b      	ldr	r3, [r7, #4]
		/* By now, the kernel has allocated everything it is going to, so
		if there is a lot of heap remaining unallocated then
		the value of configTOTAL_HEAP_SIZE in FreeRTOSConfig.h can be
		reduced accordingly. */
	}
}
     bb4:	f107 0708 	add.w	r7, r7, #8
     bb8:	46bd      	mov	sp, r7
     bba:	bd80      	pop	{r7, pc}

00000bbc <pcGetTaskStatusMessage>:
/*-----------------------------------------------------------*/

char *pcGetTaskStatusMessage( void )
{
     bbc:	b480      	push	{r7}
     bbe:	af00      	add	r7, sp, #0
	/* Not bothered about a critical section here although technically because
	of the task priorities the pointer could change it will be atomic if not
	near atomic and its not critical. */
	if( pcStatusMessage == NULL )
     bc0:	f240 6334 	movw	r3, #1588	; 0x634
     bc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     bc8:	681b      	ldr	r3, [r3, #0]
     bca:	2b00      	cmp	r3, #0
     bcc:	d104      	bne.n	bd8 <pcGetTaskStatusMessage+0x1c>
	{
		return "All tasks running without error";
     bce:	f24c 535c 	movw	r3, #50524	; 0xc55c
     bd2:	f2c0 0301 	movt	r3, #1
     bd6:	e004      	b.n	be2 <pcGetTaskStatusMessage+0x26>
	}
	else
	{
		return ( char * ) pcStatusMessage;
     bd8:	f240 6334 	movw	r3, #1588	; 0x634
     bdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
     be0:	681b      	ldr	r3, [r3, #0]
	}
}
     be2:	4618      	mov	r0, r3
     be4:	46bd      	mov	sp, r7
     be6:	bc80      	pop	{r7}
     be8:	4770      	bx	lr
     bea:	bf00      	nop

00000bec <vMainConfigureTimerForRunTimeStats>:
/*-----------------------------------------------------------*/

void vMainConfigureTimerForRunTimeStats( void )
{
     bec:	b580      	push	{r7, lr}
     bee:	b082      	sub	sp, #8
     bf0:	af00      	add	r7, sp, #0
const unsigned long ulMax32BitValue = 0xffffffffUL;
     bf2:	f04f 33ff 	mov.w	r3, #4294967295
     bf6:	607b      	str	r3, [r7, #4]

	MSS_TIM64_init( MSS_TIMER_PERIODIC_MODE );
     bf8:	f04f 0000 	mov.w	r0, #0
     bfc:	f7ff fe0e 	bl	81c <MSS_TIM64_init>
	MSS_TIM64_load_immediate( ulMax32BitValue, ulMax32BitValue );
     c00:	6878      	ldr	r0, [r7, #4]
     c02:	6879      	ldr	r1, [r7, #4]
     c04:	f7ff fe6a 	bl	8dc <MSS_TIM64_load_immediate>
	MSS_TIM64_start();
     c08:	f7ff fe5a 	bl	8c0 <MSS_TIM64_start>
}
     c0c:	f107 0708 	add.w	r7, r7, #8
     c10:	46bd      	mov	sp, r7
     c12:	bd80      	pop	{r7, pc}

00000c14 <ulGetRunTimeCounterValue>:
/*-----------------------------------------------------------*/

unsigned long ulGetRunTimeCounterValue( void )
{
     c14:	b480      	push	{r7}
     c16:	af00      	add	r7, sp, #0
	return 0UL;
     c18:	f04f 0300 	mov.w	r3, #0
}
     c1c:	4618      	mov	r0, r3
     c1e:	46bd      	mov	sp, r7
     c20:	bc80      	pop	{r7}
     c22:	4770      	bx	lr
     c24:	0000      	lsls	r0, r0, #0
	...

00000c28 <uart_task>:


void uart_task(void *para)
{
     c28:	b580      	push	{r7, lr}
     c2a:	b088      	sub	sp, #32
     c2c:	af00      	add	r7, sp, #0
     c2e:	6078      	str	r0, [r7, #4]
	uart_string_print((uint8_t *) "\n********* Welcome to the Measurement System  *********\n\r");
     c30:	f24c 507c 	movw	r0, #50556	; 0xc57c
     c34:	f2c0 0001 	movt	r0, #1
     c38:	f009 fdf8 	bl	a82c <uart_string_print>

	for( ;; )
		{
			uart_string_print((uint8_t *)"\n\r");
     c3c:	f24c 50b8 	movw	r0, #50616	; 0xc5b8
     c40:	f2c0 0001 	movt	r0, #1
     c44:	f009 fdf2 	bl	a82c <uart_string_print>
			uart_string_print((uint8_t *) "********* SmartFusion Play Menu **************\n\r" );
     c48:	f24c 50bc 	movw	r0, #50620	; 0xc5bc
     c4c:	f2c0 0001 	movt	r0, #1
     c50:	f009 fdec 	bl	a82c <uart_string_print>
			uart_string_print((uint8_t *) "********* 0.  Multimeter *********************\n\r" );
     c54:	f24c 50f0 	movw	r0, #50672	; 0xc5f0
     c58:	f2c0 0001 	movt	r0, #1
     c5c:	f009 fde6 	bl	a82c <uart_string_print>
			uart_string_print((uint8_t *) "\n");
     c60:	f24c 6024 	movw	r0, #50724	; 0xc624
     c64:	f2c0 0001 	movt	r0, #1
     c68:	f009 fde0 	bl	a82c <uart_string_print>

	        do
	        {
	            rx_size = MSS_UART_get_rx(&g_mss_uart0, &key, 1);
     c6c:	f64a 10d0 	movw	r0, #43472	; 0xa9d0
     c70:	f2c2 0000 	movt	r0, #8192	; 0x2000
     c74:	f240 6138 	movw	r1, #1592	; 0x638
     c78:	f2c2 0100 	movt	r1, #8192	; 0x2000
     c7c:	f04f 0201 	mov.w	r2, #1
     c80:	f001 fb8c 	bl	239c <MSS_UART_get_rx>
     c84:	4603      	mov	r3, r0
     c86:	b2da      	uxtb	r2, r3
     c88:	f240 6339 	movw	r3, #1593	; 0x639
     c8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     c90:	701a      	strb	r2, [r3, #0]
	        }while(rx_size == 0);
     c92:	f240 6339 	movw	r3, #1593	; 0x639
     c96:	f2c2 0300 	movt	r3, #8192	; 0x2000
     c9a:	781b      	ldrb	r3, [r3, #0]
     c9c:	2b00      	cmp	r3, #0
     c9e:	d0e5      	beq.n	c6c <uart_task+0x44>

	        rx_size = 0;
     ca0:	f240 6339 	movw	r3, #1593	; 0x639
     ca4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     ca8:	f04f 0200 	mov.w	r2, #0
     cac:	701a      	strb	r2, [r3, #0]
	        inMultimeter = 0;
     cae:	f64a 1399 	movw	r3, #43417	; 0xa999
     cb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
     cb6:	f04f 0200 	mov.w	r2, #0
     cba:	701a      	strb	r2, [r3, #0]
	        switch(key)
     cbc:	f240 6338 	movw	r3, #1592	; 0x638
     cc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
     cc4:	781b      	ldrb	r3, [r3, #0]
     cc6:	2b30      	cmp	r3, #48	; 0x30
     cc8:	d116      	bne.n	cf8 <uart_task+0xd0>
	            case MULTIMETER:
	            {
	                //inWebTask = 0;
	                //inLedTask = 0;

	                std_menu = 0;
     cca:	f64a 1398 	movw	r3, #43416	; 0xa998
     cce:	f2c2 0300 	movt	r3, #8192	; 0x2000
     cd2:	f04f 0200 	mov.w	r2, #0
     cd6:	701a      	strb	r2, [r3, #0]
	                char voltage_str[20];
//	                char voltage_val_str[5];
//	                strcpy(voltage_str, "Voltage: ");
//	                fprintf(voltage_val_str, "%5.2f", 42.6);
//	                strcat(voltage_str,voltage_val_str);
	                gcvt(55.3, 6, voltage_str);
     cd8:	f107 030c 	add.w	r3, r7, #12
     cdc:	a10e      	add	r1, pc, #56	; (adr r1, d18 <uart_task+0xf0>)
     cde:	e9d1 0100 	ldrd	r0, r1, [r1]
     ce2:	f04f 0206 	mov.w	r2, #6
     ce6:	f014 fb15 	bl	15314 <gcvt>
	                //strcat(voltage_str, " mV");

	                uart_string_print((uint8_t *)voltage_str);
     cea:	f107 030c 	add.w	r3, r7, #12
     cee:	4618      	mov	r0, r3
     cf0:	f009 fd9c 	bl	a82c <uart_string_print>

	                break;
     cf4:	bf00      	nop
	            	uart_string_print((uint8_t *)"**** Please Enter Your Choice      ****** \n\r");
	                break;
	            }

	        }
		}
     cf6:	e7a1      	b.n	c3c <uart_task+0x14>
	                break;
	            }

	            default:  /* If selected key is out of range */
	            {
	            	uart_string_print((uint8_t *)"Invalid Key \n\r");
     cf8:	f24c 6028 	movw	r0, #50728	; 0xc628
     cfc:	f2c0 0001 	movt	r0, #1
     d00:	f009 fd94 	bl	a82c <uart_string_print>
	            	uart_string_print((uint8_t *)"**** Please Enter Your Choice      ****** \n\r");
     d04:	f24c 6038 	movw	r0, #50744	; 0xc638
     d08:	f2c0 0001 	movt	r0, #1
     d0c:	f009 fd8e 	bl	a82c <uart_string_print>
	                break;
	            }

	        }
		}
     d10:	e794      	b.n	c3c <uart_task+0x14>
     d12:	bf00      	nop
     d14:	f3af 8000 	nop.w
     d18:	66666666 	.word	0x66666666
     d1c:	404ba666 	.word	0x404ba666

00000d20 <convert_lm35_result_to_temp>:
/* Driver Includes */
/**************************************************************************/

#include "../drivers/mss_ace/mss_ace.h"

float convert_lm35_result_to_temp(ace_channel_handle_t ext_temp_channel ,uint16_t adc_result){
     d20:	b580      	push	{r7, lr}
     d22:	b084      	sub	sp, #16
     d24:	af00      	add	r7, sp, #0
     d26:	4602      	mov	r2, r0
     d28:	460b      	mov	r3, r1
     d2a:	71fa      	strb	r2, [r7, #7]
     d2c:	80bb      	strh	r3, [r7, #4]
	 float real_temp;
	 real_temp = ((float)ACE_convert_to_mV( ext_temp_channel,adc_result )/(float)10)-1;
     d2e:	79fa      	ldrb	r2, [r7, #7]
     d30:	88bb      	ldrh	r3, [r7, #4]
     d32:	4610      	mov	r0, r2
     d34:	4619      	mov	r1, r3
     d36:	f006 fbb3 	bl	74a0 <ACE_convert_to_mV>
     d3a:	4603      	mov	r3, r0
     d3c:	4618      	mov	r0, r3
     d3e:	f014 f945 	bl	14fcc <__aeabi_i2f>
     d42:	4603      	mov	r3, r0
     d44:	4618      	mov	r0, r3
     d46:	4908      	ldr	r1, [pc, #32]	; (d68 <convert_lm35_result_to_temp+0x48>)
     d48:	f014 fa48 	bl	151dc <__aeabi_fdiv>
     d4c:	4603      	mov	r3, r0
     d4e:	4618      	mov	r0, r3
     d50:	4906      	ldr	r1, [pc, #24]	; (d6c <convert_lm35_result_to_temp+0x4c>)
     d52:	f014 f885 	bl	14e60 <__aeabi_fsub>
     d56:	4603      	mov	r3, r0
     d58:	60fb      	str	r3, [r7, #12]
	 return real_temp;
     d5a:	68fb      	ldr	r3, [r7, #12]
}
     d5c:	4618      	mov	r0, r3
     d5e:	f107 0710 	add.w	r7, r7, #16
     d62:	46bd      	mov	sp, r7
     d64:	bd80      	pop	{r7, pc}
     d66:	bf00      	nop
     d68:	41200000 	.word	0x41200000
     d6c:	3f800000 	.word	0x3f800000

00000d70 <get_internal_temp>:

float get_internal_temp(void)
{
     d70:	b580      	push	{r7, lr}
     d72:	b082      	sub	sp, #8
     d74:	af00      	add	r7, sp, #0
		 uint16_t adc_result;
		 ace_channel_handle_t internal_temp_channel;
		 internal_temp_channel = (ace_channel_handle_t)2;
     d76:	f04f 0302 	mov.w	r3, #2
     d7a:	70fb      	strb	r3, [r7, #3]
		 adc_result = ACE_get_ppe_sample( internal_temp_channel );
     d7c:	78fb      	ldrb	r3, [r7, #3]
     d7e:	4618      	mov	r0, r3
     d80:	f009 f90a 	bl	9f98 <ACE_get_ppe_sample>
     d84:	4603      	mov	r3, r0
     d86:	803b      	strh	r3, [r7, #0]
		 float real_temperature_value_tc;
		 real_temperature_value_tc = (float)ACE_convert_to_Celsius( internal_temp_channel,adc_result )/(float)10;
     d88:	78fa      	ldrb	r2, [r7, #3]
     d8a:	883b      	ldrh	r3, [r7, #0]
     d8c:	4610      	mov	r0, r2
     d8e:	4619      	mov	r1, r3
     d90:	f006 fcde 	bl	7750 <ACE_convert_to_Celsius>
     d94:	4603      	mov	r3, r0
     d96:	4618      	mov	r0, r3
     d98:	f014 f918 	bl	14fcc <__aeabi_i2f>
     d9c:	4603      	mov	r3, r0
     d9e:	4618      	mov	r0, r3
     da0:	4905      	ldr	r1, [pc, #20]	; (db8 <get_internal_temp+0x48>)
     da2:	f014 fa1b 	bl	151dc <__aeabi_fdiv>
     da6:	4603      	mov	r3, r0
     da8:	607b      	str	r3, [r7, #4]

		 return real_temperature_value_tc;
     daa:	687b      	ldr	r3, [r7, #4]
}
     dac:	4618      	mov	r0, r3
     dae:	f107 0708 	add.w	r7, r7, #8
     db2:	46bd      	mov	sp, r7
     db4:	bd80      	pop	{r7, pc}
     db6:	bf00      	nop
     db8:	41200000 	.word	0x41200000

00000dbc <get_pot_voltage>:

float get_pot_voltage(void)
{
     dbc:	b580      	push	{r7, lr}
     dbe:	b082      	sub	sp, #8
     dc0:	af00      	add	r7, sp, #0
		 uint16_t adc_result;
		 ace_channel_handle_t pot_voltage_channel;
		 pot_voltage_channel = (ace_channel_handle_t) 1;
     dc2:	f04f 0301 	mov.w	r3, #1
     dc6:	70fb      	strb	r3, [r7, #3]
		 adc_result = ACE_get_ppe_sample( pot_voltage_channel );
     dc8:	78fb      	ldrb	r3, [r7, #3]
     dca:	4618      	mov	r0, r3
     dcc:	f009 f8e4 	bl	9f98 <ACE_get_ppe_sample>
     dd0:	4603      	mov	r3, r0
     dd2:	803b      	strh	r3, [r7, #0]
		 float real_voltage_uv;
		 real_voltage_uv = (float)ACE_convert_to_mV( pot_voltage_channel,adc_result )/(float)1000;
     dd4:	78fa      	ldrb	r2, [r7, #3]
     dd6:	883b      	ldrh	r3, [r7, #0]
     dd8:	4610      	mov	r0, r2
     dda:	4619      	mov	r1, r3
     ddc:	f006 fb60 	bl	74a0 <ACE_convert_to_mV>
     de0:	4603      	mov	r3, r0
     de2:	4618      	mov	r0, r3
     de4:	f014 f8f2 	bl	14fcc <__aeabi_i2f>
     de8:	4603      	mov	r3, r0
     dea:	4618      	mov	r0, r3
     dec:	4905      	ldr	r1, [pc, #20]	; (e04 <get_pot_voltage+0x48>)
     dee:	f014 f9f5 	bl	151dc <__aeabi_fdiv>
     df2:	4603      	mov	r3, r0
     df4:	607b      	str	r3, [r7, #4]

		 return real_voltage_uv;
     df6:	687b      	ldr	r3, [r7, #4]
}
     df8:	4618      	mov	r0, r3
     dfa:	f107 0708 	add.w	r7, r7, #8
     dfe:	46bd      	mov	sp, r7
     e00:	bd80      	pop	{r7, pc}
     e02:	bf00      	nop
     e04:	447a0000 	.word	0x447a0000

00000e08 <get_external_temp>:

float get_external_temp(void)
{
     e08:	b580      	push	{r7, lr}
     e0a:	b082      	sub	sp, #8
     e0c:	af00      	add	r7, sp, #0
		 uint16_t adc_result;
		 ace_channel_handle_t ext_temp_channel;
		 ext_temp_channel = (ace_channel_handle_t) 2;
     e0e:	f04f 0302 	mov.w	r3, #2
     e12:	70fb      	strb	r3, [r7, #3]
		 adc_result = ACE_get_ppe_sample( ext_temp_channel );
     e14:	78fb      	ldrb	r3, [r7, #3]
     e16:	4618      	mov	r0, r3
     e18:	f009 f8be 	bl	9f98 <ACE_get_ppe_sample>
     e1c:	4603      	mov	r3, r0
     e1e:	803b      	strh	r3, [r7, #0]
		 float real_temp;
		 real_temp = convert_lm35_result_to_temp(ext_temp_channel,adc_result);
     e20:	78fa      	ldrb	r2, [r7, #3]
     e22:	883b      	ldrh	r3, [r7, #0]
     e24:	4610      	mov	r0, r2
     e26:	4619      	mov	r1, r3
     e28:	f7ff ff7a 	bl	d20 <convert_lm35_result_to_temp>
     e2c:	4603      	mov	r3, r0
     e2e:	607b      	str	r3, [r7, #4]

		 return real_temp;
     e30:	687b      	ldr	r3, [r7, #4]
}
     e32:	4618      	mov	r0, r3
     e34:	f107 0708 	add.w	r7, r7, #8
     e38:	46bd      	mov	sp, r7
     e3a:	bd80      	pop	{r7, pc}

00000e3c <get_avg_external_temp>:

float get_avg_external_temp(void)
{
     e3c:	b580      	push	{r7, lr}
     e3e:	b082      	sub	sp, #8
     e40:	af00      	add	r7, sp, #0
	float short_avg_temp;
	 int a;
	   /* for loop execution */
	   for( a = 0; a < 1000; a = a + 1 ){
     e42:	f04f 0300 	mov.w	r3, #0
     e46:	607b      	str	r3, [r7, #4]
     e48:	e00c      	b.n	e64 <get_avg_external_temp+0x28>
		   short_avg_temp = short_avg_temp + get_external_temp();
     e4a:	f7ff ffdd 	bl	e08 <get_external_temp>
     e4e:	4603      	mov	r3, r0
     e50:	6838      	ldr	r0, [r7, #0]
     e52:	4619      	mov	r1, r3
     e54:	f014 f806 	bl	14e64 <__addsf3>
     e58:	4603      	mov	r3, r0
     e5a:	603b      	str	r3, [r7, #0]
float get_avg_external_temp(void)
{
	float short_avg_temp;
	 int a;
	   /* for loop execution */
	   for( a = 0; a < 1000; a = a + 1 ){
     e5c:	687b      	ldr	r3, [r7, #4]
     e5e:	f103 0301 	add.w	r3, r3, #1
     e62:	607b      	str	r3, [r7, #4]
     e64:	687a      	ldr	r2, [r7, #4]
     e66:	f240 33e7 	movw	r3, #999	; 0x3e7
     e6a:	429a      	cmp	r2, r3
     e6c:	dded      	ble.n	e4a <get_avg_external_temp+0xe>
		   short_avg_temp = short_avg_temp + get_external_temp();
		   //vTaskDelay(50); //configTICK_RATE_HZ	=1000 (5ms delay)
	   }
	   short_avg_temp=short_avg_temp/1000;
     e6e:	6838      	ldr	r0, [r7, #0]
     e70:	4905      	ldr	r1, [pc, #20]	; (e88 <get_avg_external_temp+0x4c>)
     e72:	f014 f9b3 	bl	151dc <__aeabi_fdiv>
     e76:	4603      	mov	r3, r0
     e78:	603b      	str	r3, [r7, #0]

	return short_avg_temp;
     e7a:	683b      	ldr	r3, [r7, #0]
}
     e7c:	4618      	mov	r0, r3
     e7e:	f107 0708 	add.w	r7, r7, #8
     e82:	46bd      	mov	sp, r7
     e84:	bd80      	pop	{r7, pc}
     e86:	bf00      	nop
     e88:	447a0000 	.word	0x447a0000
     e8c:	00000000 	.word	0x00000000

00000e90 <get_humidity>:

float get_humidity(void)
{
     e90:	b5b0      	push	{r4, r5, r7, lr}
     e92:	b082      	sub	sp, #8
     e94:	af00      	add	r7, sp, #0
		 uint16_t adc_result;
		 ace_channel_handle_t ext_humid_channel;
		 ext_humid_channel = (ace_channel_handle_t)3;
     e96:	f04f 0303 	mov.w	r3, #3
     e9a:	70fb      	strb	r3, [r7, #3]
		 adc_result = ACE_get_ppe_sample( ext_humid_channel );
     e9c:	78fb      	ldrb	r3, [r7, #3]
     e9e:	4618      	mov	r0, r3
     ea0:	f009 f87a 	bl	9f98 <ACE_get_ppe_sample>
     ea4:	4603      	mov	r3, r0
     ea6:	803b      	strh	r3, [r7, #0]
		 float real_humid_val;
		 real_humid_val = (float)ACE_convert_to_mV( ext_humid_channel,adc_result )/(float)1000;
     ea8:	78fa      	ldrb	r2, [r7, #3]
     eaa:	883b      	ldrh	r3, [r7, #0]
     eac:	4610      	mov	r0, r2
     eae:	4619      	mov	r1, r3
     eb0:	f006 faf6 	bl	74a0 <ACE_convert_to_mV>
     eb4:	4603      	mov	r3, r0
     eb6:	4618      	mov	r0, r3
     eb8:	f014 f888 	bl	14fcc <__aeabi_i2f>
     ebc:	4603      	mov	r3, r0
     ebe:	4618      	mov	r0, r3
     ec0:	4917      	ldr	r1, [pc, #92]	; (f20 <get_humidity+0x90>)
     ec2:	f014 f98b 	bl	151dc <__aeabi_fdiv>
     ec6:	4603      	mov	r3, r0
     ec8:	607b      	str	r3, [r7, #4]

		 return 30*real_humid_val*pow(1.015,real_humid_val);
     eca:	6878      	ldr	r0, [r7, #4]
     ecc:	4915      	ldr	r1, [pc, #84]	; (f24 <get_humidity+0x94>)
     ece:	f014 f8d1 	bl	15074 <__aeabi_fmul>
     ed2:	4603      	mov	r3, r0
     ed4:	4618      	mov	r0, r3
     ed6:	f013 fd09 	bl	148ec <__aeabi_f2d>
     eda:	4604      	mov	r4, r0
     edc:	460d      	mov	r5, r1
     ede:	6878      	ldr	r0, [r7, #4]
     ee0:	f013 fd04 	bl	148ec <__aeabi_f2d>
     ee4:	4602      	mov	r2, r0
     ee6:	460b      	mov	r3, r1
     ee8:	a10b      	add	r1, pc, #44	; (adr r1, f18 <get_humidity+0x88>)
     eea:	e9d1 0100 	ldrd	r0, r1, [r1]
     eee:	f01a f991 	bl	1b214 <pow>
     ef2:	4602      	mov	r2, r0
     ef4:	460b      	mov	r3, r1
     ef6:	4620      	mov	r0, r4
     ef8:	4629      	mov	r1, r5
     efa:	f013 fd4b 	bl	14994 <__aeabi_dmul>
     efe:	4602      	mov	r2, r0
     f00:	460b      	mov	r3, r1
     f02:	4610      	mov	r0, r2
     f04:	4619      	mov	r1, r3
     f06:	f013 ff57 	bl	14db8 <__aeabi_d2f>
     f0a:	4603      	mov	r3, r0
}
     f0c:	4618      	mov	r0, r3
     f0e:	f107 0708 	add.w	r7, r7, #8
     f12:	46bd      	mov	sp, r7
     f14:	bdb0      	pop	{r4, r5, r7, pc}
     f16:	bf00      	nop
     f18:	a3d70a3d 	.word	0xa3d70a3d
     f1c:	3ff03d70 	.word	0x3ff03d70
     f20:	447a0000 	.word	0x447a0000
     f24:	41f00000 	.word	0x41f00000

00000f28 <get_uv_index>:

float get_uv_index(void)
{
     f28:	b580      	push	{r7, lr}
     f2a:	b082      	sub	sp, #8
     f2c:	af00      	add	r7, sp, #0
		 uint16_t adc_result;
		 ace_channel_handle_t ext_uv_channel;
		 ext_uv_channel = (ace_channel_handle_t)5;
     f2e:	f04f 0305 	mov.w	r3, #5
     f32:	70fb      	strb	r3, [r7, #3]
		 adc_result = ACE_get_ppe_sample( ext_uv_channel );
     f34:	78fb      	ldrb	r3, [r7, #3]
     f36:	4618      	mov	r0, r3
     f38:	f009 f82e 	bl	9f98 <ACE_get_ppe_sample>
     f3c:	4603      	mov	r3, r0
     f3e:	803b      	strh	r3, [r7, #0]
		 float real_uv_val;
		 real_uv_val = (float)ACE_convert_to_mV( ext_uv_channel,adc_result )/(float)1000;
     f40:	78fa      	ldrb	r2, [r7, #3]
     f42:	883b      	ldrh	r3, [r7, #0]
     f44:	4610      	mov	r0, r2
     f46:	4619      	mov	r1, r3
     f48:	f006 faaa 	bl	74a0 <ACE_convert_to_mV>
     f4c:	4603      	mov	r3, r0
     f4e:	4618      	mov	r0, r3
     f50:	f014 f83c 	bl	14fcc <__aeabi_i2f>
     f54:	4603      	mov	r3, r0
     f56:	4618      	mov	r0, r3
     f58:	4917      	ldr	r1, [pc, #92]	; (fb8 <get_uv_index+0x90>)
     f5a:	f014 f93f 	bl	151dc <__aeabi_fdiv>
     f5e:	4603      	mov	r3, r0
     f60:	607b      	str	r3, [r7, #4]

		 return ((7.2*real_uv_val)-7);
     f62:	6878      	ldr	r0, [r7, #4]
     f64:	f013 fcc2 	bl	148ec <__aeabi_f2d>
     f68:	4602      	mov	r2, r0
     f6a:	460b      	mov	r3, r1
     f6c:	4610      	mov	r0, r2
     f6e:	4619      	mov	r1, r3
     f70:	a30f      	add	r3, pc, #60	; (adr r3, fb0 <get_uv_index+0x88>)
     f72:	e9d3 2300 	ldrd	r2, r3, [r3]
     f76:	f013 fd0d 	bl	14994 <__aeabi_dmul>
     f7a:	4602      	mov	r2, r0
     f7c:	460b      	mov	r3, r1
     f7e:	4610      	mov	r0, r2
     f80:	4619      	mov	r1, r3
     f82:	f04f 0200 	mov.w	r2, #0
     f86:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     f8a:	f503 13e0 	add.w	r3, r3, #1835008	; 0x1c0000
     f8e:	f013 fb4d 	bl	1462c <__aeabi_dsub>
     f92:	4602      	mov	r2, r0
     f94:	460b      	mov	r3, r1
     f96:	4610      	mov	r0, r2
     f98:	4619      	mov	r1, r3
     f9a:	f013 ff0d 	bl	14db8 <__aeabi_d2f>
     f9e:	4603      	mov	r3, r0
}
     fa0:	4618      	mov	r0, r3
     fa2:	f107 0708 	add.w	r7, r7, #8
     fa6:	46bd      	mov	sp, r7
     fa8:	bd80      	pop	{r7, pc}
     faa:	bf00      	nop
     fac:	f3af 8000 	nop.w
     fb0:	cccccccd 	.word	0xcccccccd
     fb4:	401ccccc 	.word	0x401ccccc
     fb8:	447a0000 	.word	0x447a0000
     fbc:	f3af 8000 	nop.w

00000fc0 <calc_lux_from_voltage>:

float calc_lux_from_voltage(float voltage){
     fc0:	b580      	push	{r7, lr}
     fc2:	b084      	sub	sp, #16
     fc4:	af00      	add	r7, sp, #0
     fc6:	6078      	str	r0, [r7, #4]
	float ldrVoltage = 4.6 - voltage;
     fc8:	6878      	ldr	r0, [r7, #4]
     fca:	f013 fc8f 	bl	148ec <__aeabi_f2d>
     fce:	4602      	mov	r2, r0
     fd0:	460b      	mov	r3, r1
     fd2:	a11d      	add	r1, pc, #116	; (adr r1, 1048 <PROCESS_STACK_SIZE+0x48>)
     fd4:	e9d1 0100 	ldrd	r0, r1, [r1]
     fd8:	f013 fb28 	bl	1462c <__aeabi_dsub>
     fdc:	4602      	mov	r2, r0
     fde:	460b      	mov	r3, r1
     fe0:	4610      	mov	r0, r2
     fe2:	4619      	mov	r1, r3
     fe4:	f013 fee8 	bl	14db8 <__aeabi_d2f>
     fe8:	4603      	mov	r3, r0
     fea:	60bb      	str	r3, [r7, #8]
	float ldrResistance = ldrVoltage/voltage * 47000;  // 5600 is the ref resistance
     fec:	68b8      	ldr	r0, [r7, #8]
     fee:	6879      	ldr	r1, [r7, #4]
     ff0:	f014 f8f4 	bl	151dc <__aeabi_fdiv>
     ff4:	4603      	mov	r3, r0
     ff6:	4618      	mov	r0, r3
     ff8:	4919      	ldr	r1, [pc, #100]	; (1060 <PROCESS_STACK_SIZE+0x60>)
     ffa:	f014 f83b 	bl	15074 <__aeabi_fmul>
     ffe:	4603      	mov	r3, r0
    1000:	60fb      	str	r3, [r7, #12]
	return 12518931*pow(ldrResistance, -1.405);
    1002:	68f8      	ldr	r0, [r7, #12]
    1004:	f013 fc72 	bl	148ec <__aeabi_f2d>
    1008:	4602      	mov	r2, r0
    100a:	460b      	mov	r3, r1
    100c:	4610      	mov	r0, r2
    100e:	4619      	mov	r1, r3
    1010:	a30f      	add	r3, pc, #60	; (adr r3, 1050 <PROCESS_STACK_SIZE+0x50>)
    1012:	e9d3 2300 	ldrd	r2, r3, [r3]
    1016:	f01a f8fd 	bl	1b214 <pow>
    101a:	4602      	mov	r2, r0
    101c:	460b      	mov	r3, r1
    101e:	4610      	mov	r0, r2
    1020:	4619      	mov	r1, r3
    1022:	a30d      	add	r3, pc, #52	; (adr r3, 1058 <PROCESS_STACK_SIZE+0x58>)
    1024:	e9d3 2300 	ldrd	r2, r3, [r3]
    1028:	f013 fcb4 	bl	14994 <__aeabi_dmul>
    102c:	4602      	mov	r2, r0
    102e:	460b      	mov	r3, r1
    1030:	4610      	mov	r0, r2
    1032:	4619      	mov	r1, r3
    1034:	f013 fec0 	bl	14db8 <__aeabi_d2f>
    1038:	4603      	mov	r3, r0
}
    103a:	4618      	mov	r0, r3
    103c:	f107 0710 	add.w	r7, r7, #16
    1040:	46bd      	mov	sp, r7
    1042:	bd80      	pop	{r7, pc}
    1044:	f3af 8000 	nop.w
    1048:	66666666 	.word	0x66666666
    104c:	40126666 	.word	0x40126666
    1050:	47ae147b 	.word	0x47ae147b
    1054:	bff67ae1 	.word	0xbff67ae1
    1058:	60000000 	.word	0x60000000
    105c:	4167e0c2 	.word	0x4167e0c2
    1060:	47379800 	.word	0x47379800
    1064:	f3af 8000 	nop.w

00001068 <get_avg_external_lux_volts>:

float get_avg_external_lux_volts(void)
{
    1068:	b580      	push	{r7, lr}
    106a:	b082      	sub	sp, #8
    106c:	af00      	add	r7, sp, #0
	float short_avg_lux;
	 int a;
	   /* for loop execution */
	   for( a = 0; a < 1000; a = a + 1 ){
    106e:	f04f 0300 	mov.w	r3, #0
    1072:	607b      	str	r3, [r7, #4]
    1074:	e00c      	b.n	1090 <get_avg_external_lux_volts+0x28>
		   short_avg_lux = short_avg_lux + get_lux_voltage();
    1076:	f000 f82b 	bl	10d0 <get_lux_voltage>
    107a:	4603      	mov	r3, r0
    107c:	6838      	ldr	r0, [r7, #0]
    107e:	4619      	mov	r1, r3
    1080:	f013 fef0 	bl	14e64 <__addsf3>
    1084:	4603      	mov	r3, r0
    1086:	603b      	str	r3, [r7, #0]
float get_avg_external_lux_volts(void)
{
	float short_avg_lux;
	 int a;
	   /* for loop execution */
	   for( a = 0; a < 1000; a = a + 1 ){
    1088:	687b      	ldr	r3, [r7, #4]
    108a:	f103 0301 	add.w	r3, r3, #1
    108e:	607b      	str	r3, [r7, #4]
    1090:	687a      	ldr	r2, [r7, #4]
    1092:	f240 33e7 	movw	r3, #999	; 0x3e7
    1096:	429a      	cmp	r2, r3
    1098:	dded      	ble.n	1076 <get_avg_external_lux_volts+0xe>
		   short_avg_lux = short_avg_lux + get_lux_voltage();
		   //vTaskDelay(50); //configTICK_RATE_HZ	=1000 (5ms delay)
	   }
	   short_avg_lux=short_avg_lux/1000;
    109a:	6838      	ldr	r0, [r7, #0]
    109c:	4905      	ldr	r1, [pc, #20]	; (10b4 <get_avg_external_lux_volts+0x4c>)
    109e:	f014 f89d 	bl	151dc <__aeabi_fdiv>
    10a2:	4603      	mov	r3, r0
    10a4:	603b      	str	r3, [r7, #0]

	return short_avg_lux;
    10a6:	683b      	ldr	r3, [r7, #0]
}
    10a8:	4618      	mov	r0, r3
    10aa:	f107 0708 	add.w	r7, r7, #8
    10ae:	46bd      	mov	sp, r7
    10b0:	bd80      	pop	{r7, pc}
    10b2:	bf00      	nop
    10b4:	447a0000 	.word	0x447a0000

000010b8 <get_avg_lux>:

float get_avg_lux(void)
{
    10b8:	b580      	push	{r7, lr}
    10ba:	af00      	add	r7, sp, #0
		 return calc_lux_from_voltage(get_avg_external_lux_volts());
    10bc:	f7ff ffd4 	bl	1068 <get_avg_external_lux_volts>
    10c0:	4603      	mov	r3, r0
    10c2:	4618      	mov	r0, r3
    10c4:	f7ff ff7c 	bl	fc0 <calc_lux_from_voltage>
    10c8:	4603      	mov	r3, r0
}
    10ca:	4618      	mov	r0, r3
    10cc:	bd80      	pop	{r7, pc}
    10ce:	bf00      	nop

000010d0 <get_lux_voltage>:

float get_lux_voltage(void)
{
    10d0:	b580      	push	{r7, lr}
    10d2:	b082      	sub	sp, #8
    10d4:	af00      	add	r7, sp, #0
		 uint16_t adc_result;
		 ace_channel_handle_t ext_lux_channel;
		 ext_lux_channel = (ace_channel_handle_t)6;
    10d6:	f04f 0306 	mov.w	r3, #6
    10da:	70fb      	strb	r3, [r7, #3]
		 adc_result = ACE_get_ppe_sample( ext_lux_channel );
    10dc:	78fb      	ldrb	r3, [r7, #3]
    10de:	4618      	mov	r0, r3
    10e0:	f008 ff5a 	bl	9f98 <ACE_get_ppe_sample>
    10e4:	4603      	mov	r3, r0
    10e6:	803b      	strh	r3, [r7, #0]
		 float real_lux_val;
		 real_lux_val = ((float)ACE_convert_to_mV( ext_lux_channel,adc_result )/(float)1000)+0.1;// scale voltage to 5v range
    10e8:	78fa      	ldrb	r2, [r7, #3]
    10ea:	883b      	ldrh	r3, [r7, #0]
    10ec:	4610      	mov	r0, r2
    10ee:	4619      	mov	r1, r3
    10f0:	f006 f9d6 	bl	74a0 <ACE_convert_to_mV>
    10f4:	4603      	mov	r3, r0
    10f6:	4618      	mov	r0, r3
    10f8:	f013 ff68 	bl	14fcc <__aeabi_i2f>
    10fc:	4603      	mov	r3, r0
    10fe:	4618      	mov	r0, r3
    1100:	4911      	ldr	r1, [pc, #68]	; (1148 <get_lux_voltage+0x78>)
    1102:	f014 f86b 	bl	151dc <__aeabi_fdiv>
    1106:	4603      	mov	r3, r0
    1108:	4618      	mov	r0, r3
    110a:	f013 fbef 	bl	148ec <__aeabi_f2d>
    110e:	4602      	mov	r2, r0
    1110:	460b      	mov	r3, r1
    1112:	4610      	mov	r0, r2
    1114:	4619      	mov	r1, r3
    1116:	a30a      	add	r3, pc, #40	; (adr r3, 1140 <get_lux_voltage+0x70>)
    1118:	e9d3 2300 	ldrd	r2, r3, [r3]
    111c:	f013 fa88 	bl	14630 <__adddf3>
    1120:	4602      	mov	r2, r0
    1122:	460b      	mov	r3, r1
    1124:	4610      	mov	r0, r2
    1126:	4619      	mov	r1, r3
    1128:	f013 fe46 	bl	14db8 <__aeabi_d2f>
    112c:	4603      	mov	r3, r0
    112e:	607b      	str	r3, [r7, #4]

		 return real_lux_val;
    1130:	687b      	ldr	r3, [r7, #4]
}
    1132:	4618      	mov	r0, r3
    1134:	f107 0708 	add.w	r7, r7, #8
    1138:	46bd      	mov	sp, r7
    113a:	bd80      	pop	{r7, pc}
    113c:	f3af 8000 	nop.w
    1140:	9999999a 	.word	0x9999999a
    1144:	3fb99999 	.word	0x3fb99999
    1148:	447a0000 	.word	0x447a0000
    114c:	f3af 8000 	nop.w

00001150 <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
    1150:	b480      	push	{r7}
    1152:	b083      	sub	sp, #12
    1154:	af00      	add	r7, sp, #0
    1156:	4603      	mov	r3, r0
    1158:	80fb      	strh	r3, [r7, #6]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    115a:	f24e 1300 	movw	r3, #57600	; 0xe100
    115e:	f2ce 0300 	movt	r3, #57344	; 0xe000
    1162:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    1166:	ea4f 1252 	mov.w	r2, r2, lsr #5
    116a:	88f9      	ldrh	r1, [r7, #6]
    116c:	f001 011f 	and.w	r1, r1, #31
    1170:	f04f 0001 	mov.w	r0, #1
    1174:	fa00 f101 	lsl.w	r1, r0, r1
    1178:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    117c:	f107 070c 	add.w	r7, r7, #12
    1180:	46bd      	mov	sp, r7
    1182:	bc80      	pop	{r7}
    1184:	4770      	bx	lr
    1186:	bf00      	nop

00001188 <NVIC_SetPriority>:
 * interrupt, or negative to specify an internal (core) interrupt.
 *
 * Note: The priority cannot be set for every core interrupt.
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
    1188:	b480      	push	{r7}
    118a:	b083      	sub	sp, #12
    118c:	af00      	add	r7, sp, #0
    118e:	4603      	mov	r3, r0
    1190:	6039      	str	r1, [r7, #0]
    1192:	80fb      	strh	r3, [r7, #6]
  if(IRQn < 0) {
    1194:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    1198:	2b00      	cmp	r3, #0
    119a:	da10      	bge.n	11be <NVIC_SetPriority+0x36>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M3 System Interrupts */
    119c:	f64e 5300 	movw	r3, #60672	; 0xed00
    11a0:	f2ce 0300 	movt	r3, #57344	; 0xe000
    11a4:	88fa      	ldrh	r2, [r7, #6]
    11a6:	f002 020f 	and.w	r2, r2, #15
    11aa:	f1a2 0104 	sub.w	r1, r2, #4
    11ae:	683a      	ldr	r2, [r7, #0]
    11b0:	b2d2      	uxtb	r2, r2
    11b2:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    11b6:	b2d2      	uxtb	r2, r2
    11b8:	440b      	add	r3, r1
    11ba:	761a      	strb	r2, [r3, #24]
    11bc:	e00d      	b.n	11da <NVIC_SetPriority+0x52>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
    11be:	f24e 1300 	movw	r3, #57600	; 0xe100
    11c2:	f2ce 0300 	movt	r3, #57344	; 0xe000
    11c6:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
    11ca:	683a      	ldr	r2, [r7, #0]
    11cc:	b2d2      	uxtb	r2, r2
    11ce:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    11d2:	b2d2      	uxtb	r2, r2
    11d4:	440b      	add	r3, r1
    11d6:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
    11da:	f107 070c 	add.w	r7, r7, #12
    11de:	46bd      	mov	sp, r7
    11e0:	bc80      	pop	{r7}
    11e2:	4770      	bx	lr

000011e4 <clock_time>:
QueueHandle_t xEMACEventQueue = NULL;

/*-----------------------------------------------------------*/

clock_time_t clock_time( void )
{
    11e4:	b580      	push	{r7, lr}
    11e6:	af00      	add	r7, sp, #0
	return xTaskGetTickCount();
    11e8:	f010 faf6 	bl	117d8 <xTaskGetTickCount>
    11ec:	4603      	mov	r3, r0
}
    11ee:	4618      	mov	r0, r3
    11f0:	bd80      	pop	{r7, pc}
    11f2:	bf00      	nop

000011f4 <vuIP_Task>:
/*-----------------------------------------------------------*/

void vuIP_Task( void *pvParameters )
{
    11f4:	b590      	push	{r4, r7, lr}
    11f6:	b087      	sub	sp, #28
    11f8:	af00      	add	r7, sp, #0
    11fa:	6078      	str	r0, [r7, #4]
portBASE_TYPE i;
unsigned long ulNewEvent = 0UL, ulUIP_Events = 0UL;
    11fc:	f04f 0300 	mov.w	r3, #0
    1200:	60bb      	str	r3, [r7, #8]
    1202:	f04f 0300 	mov.w	r3, #0
    1206:	613b      	str	r3, [r7, #16]

	/* Just to prevent compiler warnings about the unused parameter. */
	( void ) pvParameters;

	/* Initialise the uIP stack, configuring for web server usage. */
	prvInitialise_uIP();
    1208:	f000 f8fe 	bl	1408 <prvInitialise_uIP>

	/* Initialise the MAC and PHY. */
	prvInitEmac();
    120c:	f000 fa06 	bl	161c <prvInitEmac>
    1210:	e000      	b.n	1214 <vuIP_Task+0x20>
		if( ulUIP_Events == pdFALSE )
		{
			xQueueReceive( xEMACEventQueue, &ulNewEvent, portMAX_DELAY );
			ulUIP_Events |= ulNewEvent;
		}
	}
    1212:	bf00      	nop
	prvInitEmac();

	for( ;; )
	{
		/* Is there received data ready to be processed? */
		lPacketLength = MSS_MAC_rx_packet();
    1214:	f004 f800 	bl	5218 <MSS_MAC_rx_packet>
    1218:	4603      	mov	r3, r0
    121a:	617b      	str	r3, [r7, #20]

		/* Statements to be executed if data has been received on the Ethernet. */
		if( ( lPacketLength > 0 ) && ( uip_buf != NULL ) )
    121c:	697b      	ldr	r3, [r7, #20]
    121e:	2b00      	cmp	r3, #0
    1220:	dd4f      	ble.n	12c2 <vuIP_Task+0xce>
    1222:	f240 6370 	movw	r3, #1648	; 0x670
    1226:	f2c2 0300 	movt	r3, #8192	; 0x2000
    122a:	681b      	ldr	r3, [r3, #0]
    122c:	2b00      	cmp	r3, #0
    122e:	d048      	beq.n	12c2 <vuIP_Task+0xce>
		{
			uip_len = ( u16_t ) lPacketLength;
    1230:	697b      	ldr	r3, [r7, #20]
    1232:	b29a      	uxth	r2, r3
    1234:	f64a 4314 	movw	r3, #44052	; 0xac14
    1238:	f2c2 0300 	movt	r3, #8192	; 0x2000
    123c:	801a      	strh	r2, [r3, #0]

			/* Standard uIP loop taken from the uIP manual. */
			if( xHeader->type == htons( UIP_ETHTYPE_IP ) )
    123e:	f240 6370 	movw	r3, #1648	; 0x670
    1242:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1246:	681b      	ldr	r3, [r3, #0]
    1248:	7b1a      	ldrb	r2, [r3, #12]
    124a:	7b5b      	ldrb	r3, [r3, #13]
    124c:	ea4f 2303 	mov.w	r3, r3, lsl #8
    1250:	ea43 0302 	orr.w	r3, r3, r2
    1254:	b29c      	uxth	r4, r3
    1256:	f44f 6000 	mov.w	r0, #2048	; 0x800
    125a:	f00c fb2b 	bl	d8b4 <htons>
    125e:	4603      	mov	r3, r0
    1260:	429c      	cmp	r4, r3
    1262:	d10f      	bne.n	1284 <vuIP_Task+0x90>
			{
				uip_arp_ipin();
				uip_input();
    1264:	f04f 0001 	mov.w	r0, #1
    1268:	f00a fa4c 	bl	b704 <uip_process>

				/* If the above function invocation resulted in data that
				should be sent out on the network, the global variable
				uip_len is set to a value > 0. */
				if( uip_len > 0 )
    126c:	f64a 4314 	movw	r3, #44052	; 0xac14
    1270:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1274:	881b      	ldrh	r3, [r3, #0]
    1276:	2b00      	cmp	r3, #0
    1278:	d028      	beq.n	12cc <vuIP_Task+0xd8>
				{
					uip_arp_out();
    127a:	f00c ff11 	bl	e0a0 <uip_arp_out>
					vEMACWrite();
    127e:	f000 f9eb 	bl	1658 <vEMACWrite>
	{
		/* Is there received data ready to be processed? */
		lPacketLength = MSS_MAC_rx_packet();

		/* Statements to be executed if data has been received on the Ethernet. */
		if( ( lPacketLength > 0 ) && ( uip_buf != NULL ) )
    1282:	e028      	b.n	12d6 <vuIP_Task+0xe2>
				{
					uip_arp_out();
					vEMACWrite();
				}
			}
			else if( xHeader->type == htons( UIP_ETHTYPE_ARP ) )
    1284:	f240 6370 	movw	r3, #1648	; 0x670
    1288:	f2c2 0300 	movt	r3, #8192	; 0x2000
    128c:	681b      	ldr	r3, [r3, #0]
    128e:	7b1a      	ldrb	r2, [r3, #12]
    1290:	7b5b      	ldrb	r3, [r3, #13]
    1292:	ea4f 2303 	mov.w	r3, r3, lsl #8
    1296:	ea43 0302 	orr.w	r3, r3, r2
    129a:	b29c      	uxth	r4, r3
    129c:	f640 0006 	movw	r0, #2054	; 0x806
    12a0:	f00c fb08 	bl	d8b4 <htons>
    12a4:	4603      	mov	r3, r0
    12a6:	429c      	cmp	r4, r3
    12a8:	d112      	bne.n	12d0 <vuIP_Task+0xdc>
			{
				uip_arp_arpin();
    12aa:	f00c fd75 	bl	dd98 <uip_arp_arpin>

				/* If the above function invocation resulted in data that
				should be sent out on the network, the global variable
				uip_len is set to a value > 0. */
				if( uip_len > 0 )
    12ae:	f64a 4314 	movw	r3, #44052	; 0xac14
    12b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    12b6:	881b      	ldrh	r3, [r3, #0]
    12b8:	2b00      	cmp	r3, #0
    12ba:	d00b      	beq.n	12d4 <vuIP_Task+0xe0>
				{
					vEMACWrite();
    12bc:	f000 f9cc 	bl	1658 <vEMACWrite>
	{
		/* Is there received data ready to be processed? */
		lPacketLength = MSS_MAC_rx_packet();

		/* Statements to be executed if data has been received on the Ethernet. */
		if( ( lPacketLength > 0 ) && ( uip_buf != NULL ) )
    12c0:	e009      	b.n	12d6 <vuIP_Task+0xe2>
			}
		}
		else
		{
			/* Clear the RX event latched in ulUIP_Events - if one was latched. */
			ulUIP_Events &= ~uipETHERNET_RX_EVENT;
    12c2:	693b      	ldr	r3, [r7, #16]
    12c4:	f023 0301 	bic.w	r3, r3, #1
    12c8:	613b      	str	r3, [r7, #16]
    12ca:	e004      	b.n	12d6 <vuIP_Task+0xe2>
	{
		/* Is there received data ready to be processed? */
		lPacketLength = MSS_MAC_rx_packet();

		/* Statements to be executed if data has been received on the Ethernet. */
		if( ( lPacketLength > 0 ) && ( uip_buf != NULL ) )
    12cc:	bf00      	nop
    12ce:	e002      	b.n	12d6 <vuIP_Task+0xe2>
    12d0:	bf00      	nop
    12d2:	e000      	b.n	12d6 <vuIP_Task+0xe2>
    12d4:	bf00      	nop
			/* Clear the RX event latched in ulUIP_Events - if one was latched. */
			ulUIP_Events &= ~uipETHERNET_RX_EVENT;
		}

		/* Statements to be executed if the TCP/IP period timer has expired. */
		if( ( ulUIP_Events & uipPERIODIC_TIMER_EVENT ) != 0UL )
    12d6:	693b      	ldr	r3, [r7, #16]
    12d8:	f003 0308 	and.w	r3, r3, #8
    12dc:	2b00      	cmp	r3, #0
    12de:	d033      	beq.n	1348 <vuIP_Task+0x154>
		{
			ulUIP_Events &= ~uipPERIODIC_TIMER_EVENT;
    12e0:	693b      	ldr	r3, [r7, #16]
    12e2:	f023 0308 	bic.w	r3, r3, #8
    12e6:	613b      	str	r3, [r7, #16]

			if( uip_buf != NULL )
    12e8:	f240 6370 	movw	r3, #1648	; 0x670
    12ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    12f0:	681b      	ldr	r3, [r3, #0]
    12f2:	2b00      	cmp	r3, #0
    12f4:	d028      	beq.n	1348 <vuIP_Task+0x154>
			{
				for( i = 0; i < UIP_CONNS; i++ )
    12f6:	f04f 0300 	mov.w	r3, #0
    12fa:	60fb      	str	r3, [r7, #12]
    12fc:	e021      	b.n	1342 <vuIP_Task+0x14e>
				{
					uip_periodic( i );
    12fe:	68fb      	ldr	r3, [r7, #12]
    1300:	f04f 02cc 	mov.w	r2, #204	; 0xcc
    1304:	fb02 f203 	mul.w	r2, r2, r3
    1308:	f64a 432c 	movw	r3, #44076	; 0xac2c
    130c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1310:	441a      	add	r2, r3
    1312:	f64a 4328 	movw	r3, #44072	; 0xac28
    1316:	f2c2 0300 	movt	r3, #8192	; 0x2000
    131a:	601a      	str	r2, [r3, #0]
    131c:	f04f 0002 	mov.w	r0, #2
    1320:	f00a f9f0 	bl	b704 <uip_process>

					/* If the above function invocation resulted in data that
					should be sent out on the network, the global variable
					uip_len is set to a value > 0. */
					if( uip_len > 0 )
    1324:	f64a 4314 	movw	r3, #44052	; 0xac14
    1328:	f2c2 0300 	movt	r3, #8192	; 0x2000
    132c:	881b      	ldrh	r3, [r3, #0]
    132e:	2b00      	cmp	r3, #0
    1330:	d003      	beq.n	133a <vuIP_Task+0x146>
					{
						uip_arp_out();
    1332:	f00c feb5 	bl	e0a0 <uip_arp_out>
						vEMACWrite();
    1336:	f000 f98f 	bl	1658 <vEMACWrite>
		{
			ulUIP_Events &= ~uipPERIODIC_TIMER_EVENT;

			if( uip_buf != NULL )
			{
				for( i = 0; i < UIP_CONNS; i++ )
    133a:	68fb      	ldr	r3, [r7, #12]
    133c:	f103 0301 	add.w	r3, r3, #1
    1340:	60fb      	str	r3, [r7, #12]
    1342:	68fb      	ldr	r3, [r7, #12]
    1344:	2b27      	cmp	r3, #39	; 0x27
    1346:	ddda      	ble.n	12fe <vuIP_Task+0x10a>
				}
			}
		}

		/* Statements to be executed if the ARP timer has expired. */
		if( ( ulUIP_Events & uipARP_TIMER_EVENT ) != 0 )
    1348:	693b      	ldr	r3, [r7, #16]
    134a:	f003 0304 	and.w	r3, r3, #4
    134e:	2b00      	cmp	r3, #0
    1350:	d005      	beq.n	135e <vuIP_Task+0x16a>
		{
			ulUIP_Events &= ~uipARP_TIMER_EVENT;
    1352:	693b      	ldr	r3, [r7, #16]
    1354:	f023 0304 	bic.w	r3, r3, #4
    1358:	613b      	str	r3, [r7, #16]
			uip_arp_timer();
    135a:	f00c fb6b 	bl	da34 <uip_arp_timer>
		}

		/* If all latched events have been cleared - block until another event
		occurs. */
		if( ulUIP_Events == pdFALSE )
    135e:	693b      	ldr	r3, [r7, #16]
    1360:	2b00      	cmp	r3, #0
    1362:	f47f af56 	bne.w	1212 <vuIP_Task+0x1e>
		{
			xQueueReceive( xEMACEventQueue, &ulNewEvent, portMAX_DELAY );
    1366:	f240 6340 	movw	r3, #1600	; 0x640
    136a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    136e:	681a      	ldr	r2, [r3, #0]
    1370:	f107 0308 	add.w	r3, r7, #8
    1374:	4610      	mov	r0, r2
    1376:	4619      	mov	r1, r3
    1378:	f04f 32ff 	mov.w	r2, #4294967295
    137c:	f00e fbf2 	bl	fb64 <xQueueReceive>
			ulUIP_Events |= ulNewEvent;
    1380:	68bb      	ldr	r3, [r7, #8]
    1382:	693a      	ldr	r2, [r7, #16]
    1384:	ea42 0303 	orr.w	r3, r2, r3
    1388:	613b      	str	r3, [r7, #16]
		}
	}
    138a:	e743      	b.n	1214 <vuIP_Task+0x20>

0000138c <prvSetMACAddress>:
}
/*-----------------------------------------------------------*/

static void prvSetMACAddress( void )
{
    138c:	b480      	push	{r7}
    138e:	b083      	sub	sp, #12
    1390:	af00      	add	r7, sp, #0
struct uip_eth_addr xAddr;

	/* Configure the MAC address in the uIP stack. */
	xAddr.addr[ 0 ] = configMAC_ADDR0;
    1392:	f04f 0300 	mov.w	r3, #0
    1396:	703b      	strb	r3, [r7, #0]
	xAddr.addr[ 1 ] = configMAC_ADDR1;
    1398:	f04f 0312 	mov.w	r3, #18
    139c:	707b      	strb	r3, [r7, #1]
	xAddr.addr[ 2 ] = configMAC_ADDR2;
    139e:	f04f 0313 	mov.w	r3, #19
    13a2:	70bb      	strb	r3, [r7, #2]
	xAddr.addr[ 3 ] = configMAC_ADDR3;
    13a4:	f04f 0310 	mov.w	r3, #16
    13a8:	70fb      	strb	r3, [r7, #3]
	xAddr.addr[ 4 ] = configMAC_ADDR4;
    13aa:	f04f 0315 	mov.w	r3, #21
    13ae:	713b      	strb	r3, [r7, #4]
	xAddr.addr[ 5 ] = configMAC_ADDR5;
    13b0:	f04f 0311 	mov.w	r3, #17
    13b4:	717b      	strb	r3, [r7, #5]
	uip_setethaddr( xAddr );
    13b6:	783a      	ldrb	r2, [r7, #0]
    13b8:	f642 734c 	movw	r3, #12108	; 0x2f4c
    13bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    13c0:	701a      	strb	r2, [r3, #0]
    13c2:	787a      	ldrb	r2, [r7, #1]
    13c4:	f642 734c 	movw	r3, #12108	; 0x2f4c
    13c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    13cc:	705a      	strb	r2, [r3, #1]
    13ce:	78ba      	ldrb	r2, [r7, #2]
    13d0:	f642 734c 	movw	r3, #12108	; 0x2f4c
    13d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    13d8:	709a      	strb	r2, [r3, #2]
    13da:	78fa      	ldrb	r2, [r7, #3]
    13dc:	f642 734c 	movw	r3, #12108	; 0x2f4c
    13e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    13e4:	70da      	strb	r2, [r3, #3]
    13e6:	793a      	ldrb	r2, [r7, #4]
    13e8:	f642 734c 	movw	r3, #12108	; 0x2f4c
    13ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    13f0:	711a      	strb	r2, [r3, #4]
    13f2:	797a      	ldrb	r2, [r7, #5]
    13f4:	f642 734c 	movw	r3, #12108	; 0x2f4c
    13f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    13fc:	715a      	strb	r2, [r3, #5]
}
    13fe:	f107 070c 	add.w	r7, r7, #12
    1402:	46bd      	mov	sp, r7
    1404:	bc80      	pop	{r7}
    1406:	4770      	bx	lr

00001408 <prvInitialise_uIP>:
/*-----------------------------------------------------------*/

static void prvInitialise_uIP( void )
{
    1408:	b580      	push	{r7, lr}
    140a:	b088      	sub	sp, #32
    140c:	af02      	add	r7, sp, #8
uip_ipaddr_t xIPAddr;
TimerHandle_t xARPTimer, xPeriodicTimer;

	uip_init();
    140e:	f009 ff5b 	bl	b2c8 <uip_init>
	uip_ipaddr( &xIPAddr, configIP_ADDR0, configIP_ADDR1, configIP_ADDR2, configIP_ADDR3 );
    1412:	f06f 033f 	mvn.w	r3, #63	; 0x3f
    1416:	713b      	strb	r3, [r7, #4]
    1418:	f06f 0357 	mvn.w	r3, #87	; 0x57
    141c:	717b      	strb	r3, [r7, #5]
    141e:	f04f 0300 	mov.w	r3, #0
    1422:	71bb      	strb	r3, [r7, #6]
    1424:	f06f 0337 	mvn.w	r3, #55	; 0x37
    1428:	71fb      	strb	r3, [r7, #7]
	uip_sethostaddr( &xIPAddr );
    142a:	793a      	ldrb	r2, [r7, #4]
    142c:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    1430:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1434:	701a      	strb	r2, [r3, #0]
    1436:	797a      	ldrb	r2, [r7, #5]
    1438:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    143c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1440:	705a      	strb	r2, [r3, #1]
    1442:	79ba      	ldrb	r2, [r7, #6]
    1444:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    1448:	f2c2 0300 	movt	r3, #8192	; 0x2000
    144c:	709a      	strb	r2, [r3, #2]
    144e:	79fa      	ldrb	r2, [r7, #7]
    1450:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    1454:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1458:	70da      	strb	r2, [r3, #3]
	uip_ipaddr( &xIPAddr, configNET_MASK0, configNET_MASK1, configNET_MASK2, configNET_MASK3 );
    145a:	f04f 33ff 	mov.w	r3, #4294967295
    145e:	713b      	strb	r3, [r7, #4]
    1460:	f04f 33ff 	mov.w	r3, #4294967295
    1464:	717b      	strb	r3, [r7, #5]
    1466:	f04f 33ff 	mov.w	r3, #4294967295
    146a:	71bb      	strb	r3, [r7, #6]
    146c:	f04f 0300 	mov.w	r3, #0
    1470:	71fb      	strb	r3, [r7, #7]
	uip_setnetmask( &xIPAddr );
    1472:	793a      	ldrb	r2, [r7, #4]
    1474:	f64c 4398 	movw	r3, #52376	; 0xcc98
    1478:	f2c2 0300 	movt	r3, #8192	; 0x2000
    147c:	701a      	strb	r2, [r3, #0]
    147e:	797a      	ldrb	r2, [r7, #5]
    1480:	f64c 4398 	movw	r3, #52376	; 0xcc98
    1484:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1488:	705a      	strb	r2, [r3, #1]
    148a:	79ba      	ldrb	r2, [r7, #6]
    148c:	f64c 4398 	movw	r3, #52376	; 0xcc98
    1490:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1494:	709a      	strb	r2, [r3, #2]
    1496:	79fa      	ldrb	r2, [r7, #7]
    1498:	f64c 4398 	movw	r3, #52376	; 0xcc98
    149c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    14a0:	70da      	strb	r2, [r3, #3]
	prvSetMACAddress();
    14a2:	f7ff ff73 	bl	138c <prvSetMACAddress>
	httpd_init();
    14a6:	f00d febf 	bl	f228 <httpd_init>

	/* Create the queue used to sent TCP/IP events to the uIP stack. */
	xEMACEventQueue = xQueueCreate( uipEVENT_QUEUE_LENGTH, sizeof( unsigned long ) );
    14aa:	f04f 000a 	mov.w	r0, #10
    14ae:	f04f 0104 	mov.w	r1, #4
    14b2:	f04f 0200 	mov.w	r2, #0
    14b6:	f00d fff1 	bl	f49c <xQueueGenericCreate>
    14ba:	4602      	mov	r2, r0
    14bc:	f240 6340 	movw	r3, #1600	; 0x640
    14c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    14c4:	601a      	str	r2, [r3, #0]

	/* Create and start the uIP timers. */
	xARPTimer = xTimerCreate( 	"ARPTimer", /* Just a name that is helpful for debugging, not used by the kernel. */
    14c6:	f241 63ad 	movw	r3, #5805	; 0x16ad
    14ca:	f2c0 0300 	movt	r3, #0
    14ce:	9300      	str	r3, [sp, #0]
    14d0:	f24c 6068 	movw	r0, #50792	; 0xc668
    14d4:	f2c0 0001 	movt	r0, #1
    14d8:	f242 7110 	movw	r1, #10000	; 0x2710
    14dc:	f04f 0201 	mov.w	r2, #1
    14e0:	f04f 0300 	mov.w	r3, #0
    14e4:	f012 f8a2 	bl	1362c <xTimerCreate>
    14e8:	4603      	mov	r3, r0
    14ea:	60bb      	str	r3, [r7, #8]
								pdTRUE, /* Autor-reload. */
								( void * ) uipARP_TIMER,
								prvUIPTimerCallback
							);

	xPeriodicTimer = xTimerCreate( 	"PeriodicTimer",
    14ec:	f241 63ad 	movw	r3, #5805	; 0x16ad
    14f0:	f2c0 0300 	movt	r3, #0
    14f4:	9300      	str	r3, [sp, #0]
    14f6:	f24c 6074 	movw	r0, #50804	; 0xc674
    14fa:	f2c0 0001 	movt	r0, #1
    14fe:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
    1502:	f04f 0201 	mov.w	r2, #1
    1506:	f04f 0301 	mov.w	r3, #1
    150a:	f012 f88f 	bl	1362c <xTimerCreate>
    150e:	4603      	mov	r3, r0
    1510:	60fb      	str	r3, [r7, #12]
									( void * ) uipPERIODIC_TIMER,
									prvUIPTimerCallback
								);

	/* Sanity check that the timers were indeed created. */
	configASSERT( xARPTimer );
    1512:	68bb      	ldr	r3, [r7, #8]
    1514:	2b00      	cmp	r3, #0
    1516:	d109      	bne.n	152c <prvInitialise_uIP+0x124>
    1518:	f04f 0328 	mov.w	r3, #40	; 0x28
    151c:	f383 8811 	msr	BASEPRI, r3
    1520:	f3bf 8f6f 	isb	sy
    1524:	f3bf 8f4f 	dsb	sy
    1528:	613b      	str	r3, [r7, #16]
    152a:	e7fe      	b.n	152a <prvInitialise_uIP+0x122>
	configASSERT( xPeriodicTimer );
    152c:	68fb      	ldr	r3, [r7, #12]
    152e:	2b00      	cmp	r3, #0
    1530:	d109      	bne.n	1546 <prvInitialise_uIP+0x13e>
    1532:	f04f 0328 	mov.w	r3, #40	; 0x28
    1536:	f383 8811 	msr	BASEPRI, r3
    153a:	f3bf 8f6f 	isb	sy
    153e:	f3bf 8f4f 	dsb	sy
    1542:	617b      	str	r3, [r7, #20]
    1544:	e7fe      	b.n	1544 <prvInitialise_uIP+0x13c>

	/* These commands will block indefinitely until they succeed, so there is
	no point in checking their return values. */
	xTimerStart( xARPTimer, portMAX_DELAY );
    1546:	f010 f947 	bl	117d8 <xTaskGetTickCount>
    154a:	4603      	mov	r3, r0
    154c:	f04f 32ff 	mov.w	r2, #4294967295
    1550:	9200      	str	r2, [sp, #0]
    1552:	68b8      	ldr	r0, [r7, #8]
    1554:	f04f 0101 	mov.w	r1, #1
    1558:	461a      	mov	r2, r3
    155a:	f04f 0300 	mov.w	r3, #0
    155e:	f012 f8b7 	bl	136d0 <xTimerGenericCommand>
	xTimerStart( xPeriodicTimer, portMAX_DELAY );
    1562:	f010 f939 	bl	117d8 <xTaskGetTickCount>
    1566:	4603      	mov	r3, r0
    1568:	f04f 32ff 	mov.w	r2, #4294967295
    156c:	9200      	str	r2, [sp, #0]
    156e:	68f8      	ldr	r0, [r7, #12]
    1570:	f04f 0101 	mov.w	r1, #1
    1574:	461a      	mov	r2, r3
    1576:	f04f 0300 	mov.w	r3, #0
    157a:	f012 f8a9 	bl	136d0 <xTimerGenericCommand>
}
    157e:	f107 0718 	add.w	r7, r7, #24
    1582:	46bd      	mov	sp, r7
    1584:	bd80      	pop	{r7, pc}
    1586:	bf00      	nop

00001588 <prvEMACEventListener>:
/*-----------------------------------------------------------*/

static void prvEMACEventListener( unsigned long ulISREvents )
{
    1588:	b580      	push	{r7, lr}
    158a:	b086      	sub	sp, #24
    158c:	af00      	add	r7, sp, #0
    158e:	6078      	str	r0, [r7, #4]
long lHigherPriorityTaskWoken = pdFALSE;
    1590:	f04f 0300 	mov.w	r3, #0
    1594:	613b      	str	r3, [r7, #16]
const unsigned long ulRxEvent = uipETHERNET_RX_EVENT;
    1596:	f04f 0301 	mov.w	r3, #1
    159a:	60fb      	str	r3, [r7, #12]

	/* Sanity check that the event queue was indeed created. */
	configASSERT( xEMACEventQueue );
    159c:	f240 6340 	movw	r3, #1600	; 0x640
    15a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    15a4:	681b      	ldr	r3, [r3, #0]
    15a6:	2b00      	cmp	r3, #0
    15a8:	d109      	bne.n	15be <prvEMACEventListener+0x36>
    15aa:	f04f 0328 	mov.w	r3, #40	; 0x28
    15ae:	f383 8811 	msr	BASEPRI, r3
    15b2:	f3bf 8f6f 	isb	sy
    15b6:	f3bf 8f4f 	dsb	sy
    15ba:	617b      	str	r3, [r7, #20]
    15bc:	e7fe      	b.n	15bc <prvEMACEventListener+0x34>

	if( ( ulISREvents & MSS_MAC_EVENT_PACKET_SEND ) != 0UL )
    15be:	687b      	ldr	r3, [r7, #4]
    15c0:	f003 0301 	and.w	r3, r3, #1
    15c4:	b2db      	uxtb	r3, r3
    15c6:	2b00      	cmp	r3, #0
    15c8:	d001      	beq.n	15ce <prvEMACEventListener+0x46>
	{
		/* An Ethernet Tx event has occurred. */
		MSS_MAC_FreeTxBuffers();
    15ca:	f005 fae7 	bl	6b9c <MSS_MAC_FreeTxBuffers>
	}

	if( ( ulISREvents & MSS_MAC_EVENT_PACKET_RECEIVED ) != 0UL )
    15ce:	687b      	ldr	r3, [r7, #4]
    15d0:	f003 0302 	and.w	r3, r3, #2
    15d4:	2b00      	cmp	r3, #0
    15d6:	d00f      	beq.n	15f8 <prvEMACEventListener+0x70>
	{
		/* An Ethernet Rx event has occurred. */
		xQueueSendFromISR( xEMACEventQueue, &ulRxEvent, &lHigherPriorityTaskWoken );
    15d8:	f240 6340 	movw	r3, #1600	; 0x640
    15dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    15e0:	6819      	ldr	r1, [r3, #0]
    15e2:	f107 020c 	add.w	r2, r7, #12
    15e6:	f107 0310 	add.w	r3, r7, #16
    15ea:	4608      	mov	r0, r1
    15ec:	4611      	mov	r1, r2
    15ee:	461a      	mov	r2, r3
    15f0:	f04f 0300 	mov.w	r3, #0
    15f4:	f00e f97e 	bl	f8f4 <xQueueGenericSendFromISR>
	}

	portEND_SWITCHING_ISR( lHigherPriorityTaskWoken );
    15f8:	693b      	ldr	r3, [r7, #16]
    15fa:	2b00      	cmp	r3, #0
    15fc:	d00a      	beq.n	1614 <prvEMACEventListener+0x8c>
    15fe:	f64e 5304 	movw	r3, #60676	; 0xed04
    1602:	f2ce 0300 	movt	r3, #57344	; 0xe000
    1606:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    160a:	601a      	str	r2, [r3, #0]
    160c:	f3bf 8f4f 	dsb	sy
    1610:	f3bf 8f6f 	isb	sy
}
    1614:	f107 0718 	add.w	r7, r7, #24
    1618:	46bd      	mov	sp, r7
    161a:	bd80      	pop	{r7, pc}

0000161c <prvInitEmac>:
/*-----------------------------------------------------------*/

static void prvInitEmac( void )
{
    161c:	b580      	push	{r7, lr}
    161e:	b082      	sub	sp, #8
    1620:	af00      	add	r7, sp, #0
const unsigned char ucPHYAddress = 1;
    1622:	f04f 0301 	mov.w	r3, #1
    1626:	71fb      	strb	r3, [r7, #7]

	/* Initialise the MAC and PHY hardware. */
	MSS_MAC_init( ucPHYAddress );
    1628:	79fb      	ldrb	r3, [r7, #7]
    162a:	4618      	mov	r0, r3
    162c:	f002 ffa6 	bl	457c <MSS_MAC_init>

	/* Register the event listener.  The Ethernet interrupt handler will call
	this listener whenever an Rx or a Tx interrupt occurs. */
	MSS_MAC_set_callback( ( MSS_MAC_callback_t ) prvEMACEventListener );
    1630:	f241 5089 	movw	r0, #5513	; 0x1589
    1634:	f2c0 0000 	movt	r0, #0
    1638:	f004 f95c 	bl	58f4 <MSS_MAC_set_callback>

    /* Setup the EMAC and the NVIC for MAC interrupts. */
    NVIC_SetPriority( EthernetMAC_IRQn, configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY );
    163c:	f04f 0005 	mov.w	r0, #5
    1640:	f04f 0105 	mov.w	r1, #5
    1644:	f7ff fda0 	bl	1188 <NVIC_SetPriority>
    NVIC_EnableIRQ( EthernetMAC_IRQn );
    1648:	f04f 0005 	mov.w	r0, #5
    164c:	f7ff fd80 	bl	1150 <NVIC_EnableIRQ>
}
    1650:	f107 0708 	add.w	r7, r7, #8
    1654:	46bd      	mov	sp, r7
    1656:	bd80      	pop	{r7, pc}

00001658 <vEMACWrite>:
/*-----------------------------------------------------------*/

void vEMACWrite( void )
{
    1658:	b580      	push	{r7, lr}
    165a:	b084      	sub	sp, #16
    165c:	af00      	add	r7, sp, #0
const long lMaxAttempts = 10;
    165e:	f04f 030a 	mov.w	r3, #10
    1662:	607b      	str	r3, [r7, #4]
long lAttempt;
const TickType_t xShortDelay = ( 5 / portTICK_PERIOD_MS );
    1664:	f04f 0305 	mov.w	r3, #5
    1668:	60fb      	str	r3, [r7, #12]

	/* Try to send data to the Ethernet.  Keep trying for a while if data cannot
	be sent immediately.  Note that this will actually cause the data to be sent
	twice to get around delayed ACK problems when communicating with non real-
	time TCP/IP stacks (such as a Windows machine). */
	for( lAttempt = 0; lAttempt < lMaxAttempts; lAttempt++ )
    166a:	f04f 0300 	mov.w	r3, #0
    166e:	60bb      	str	r3, [r7, #8]
    1670:	e011      	b.n	1696 <vEMACWrite+0x3e>
	{
		if( MSS_MAC_tx_packet( uip_len ) != 0 )
    1672:	f64a 4314 	movw	r3, #44052	; 0xac14
    1676:	f2c2 0300 	movt	r3, #8192	; 0x2000
    167a:	881b      	ldrh	r3, [r3, #0]
    167c:	4618      	mov	r0, r3
    167e:	f003 faef 	bl	4c60 <MSS_MAC_tx_packet>
    1682:	4603      	mov	r3, r0
    1684:	2b00      	cmp	r3, #0
    1686:	d10b      	bne.n	16a0 <vEMACWrite+0x48>
		{
			break;
		}
		else
		{
			vTaskDelay( xShortDelay );
    1688:	68f8      	ldr	r0, [r7, #12]
    168a:	f00f fba9 	bl	10de0 <vTaskDelay>

	/* Try to send data to the Ethernet.  Keep trying for a while if data cannot
	be sent immediately.  Note that this will actually cause the data to be sent
	twice to get around delayed ACK problems when communicating with non real-
	time TCP/IP stacks (such as a Windows machine). */
	for( lAttempt = 0; lAttempt < lMaxAttempts; lAttempt++ )
    168e:	68bb      	ldr	r3, [r7, #8]
    1690:	f103 0301 	add.w	r3, r3, #1
    1694:	60bb      	str	r3, [r7, #8]
    1696:	68ba      	ldr	r2, [r7, #8]
    1698:	687b      	ldr	r3, [r7, #4]
    169a:	429a      	cmp	r2, r3
    169c:	dbe9      	blt.n	1672 <vEMACWrite+0x1a>
    169e:	e000      	b.n	16a2 <vEMACWrite+0x4a>
	{
		if( MSS_MAC_tx_packet( uip_len ) != 0 )
		{
			break;
    16a0:	bf00      	nop
		else
		{
			vTaskDelay( xShortDelay );
		}
	}
}
    16a2:	f107 0710 	add.w	r7, r7, #16
    16a6:	46bd      	mov	sp, r7
    16a8:	bd80      	pop	{r7, pc}
    16aa:	bf00      	nop

000016ac <prvUIPTimerCallback>:
/*-----------------------------------------------------------*/

static void prvUIPTimerCallback( TimerHandle_t xTimer )
{
    16ac:	b580      	push	{r7, lr}
    16ae:	b082      	sub	sp, #8
    16b0:	af00      	add	r7, sp, #0
    16b2:	6078      	str	r0, [r7, #4]
static const unsigned long ulPeriodicTimerExpired = uipPERIODIC_TIMER_EVENT;

	/* This is a time callback, so calls to xQueueSend() must not attempt to
	block.  As this callback is assigned to both the ARP and Periodic timers, the
	first thing to do is ascertain which timer it was that actually expired. */
	switch( ( int ) pvTimerGetTimerID( xTimer ) )
    16b4:	6878      	ldr	r0, [r7, #4]
    16b6:	f012 fbb7 	bl	13e28 <pvTimerGetTimerID>
    16ba:	4603      	mov	r3, r0
    16bc:	2b00      	cmp	r3, #0
    16be:	d002      	beq.n	16c6 <prvUIPTimerCallback+0x1a>
    16c0:	2b01      	cmp	r3, #1
    16c2:	d011      	beq.n	16e8 <prvUIPTimerCallback+0x3c>
    16c4:	e020      	b.n	1708 <prvUIPTimerCallback+0x5c>
	{
		case uipARP_TIMER		:	xQueueSend( xEMACEventQueue, &ulARPTimerExpired, uipDONT_BLOCK );
    16c6:	f240 6340 	movw	r3, #1600	; 0x640
    16ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    16ce:	681b      	ldr	r3, [r3, #0]
    16d0:	4618      	mov	r0, r3
    16d2:	f24c 619c 	movw	r1, #50844	; 0xc69c
    16d6:	f2c0 0101 	movt	r1, #1
    16da:	f04f 0200 	mov.w	r2, #0
    16de:	f04f 0300 	mov.w	r3, #0
    16e2:	f00d ffef 	bl	f6c4 <xQueueGenericSend>
									break;
    16e6:	e00f      	b.n	1708 <prvUIPTimerCallback+0x5c>

		case uipPERIODIC_TIMER	:	xQueueSend( xEMACEventQueue, &ulPeriodicTimerExpired, uipDONT_BLOCK );
    16e8:	f240 6340 	movw	r3, #1600	; 0x640
    16ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    16f0:	681b      	ldr	r3, [r3, #0]
    16f2:	4618      	mov	r0, r3
    16f4:	f24c 61a0 	movw	r1, #50848	; 0xc6a0
    16f8:	f2c0 0101 	movt	r1, #1
    16fc:	f04f 0200 	mov.w	r2, #0
    1700:	f04f 0300 	mov.w	r3, #0
    1704:	f00d ffde 	bl	f6c4 <xQueueGenericSend>
									break;

		default					:  	/* Should not get here. */
									break;
	}
}
    1708:	f107 0708 	add.w	r7, r7, #8
    170c:	46bd      	mov	sp, r7
    170e:	bd80      	pop	{r7, pc}

00001710 <vApplicationProcessFormInput>:
/*-----------------------------------------------------------*/

void vApplicationProcessFormInput( char *pcInputString )
{
    1710:	b580      	push	{r7, lr}
    1712:	b084      	sub	sp, #16
    1714:	af00      	add	r7, sp, #0
    1716:	6078      	str	r0, [r7, #4]
char *c;

	/* Only interested in processing form input if this is the IO page. */
	c = strstr( pcInputString, "control.shtml" );
    1718:	6878      	ldr	r0, [r7, #4]
    171a:	f24c 6184 	movw	r1, #50820	; 0xc684
    171e:	f2c0 0101 	movt	r1, #1
    1722:	f014 fb93 	bl	15e4c <strstr>
    1726:	4603      	mov	r3, r0
    1728:	60fb      	str	r3, [r7, #12]

	if( c )
    172a:	68fb      	ldr	r3, [r7, #12]
    172c:	2b00      	cmp	r3, #0
    172e:	d039      	beq.n	17a4 <vApplicationProcessFormInput+0x94>
	{
		/* Is there a command in the string? */
		c = strstr( pcInputString, "?" );
    1730:	6878      	ldr	r0, [r7, #4]
    1732:	f04f 013f 	mov.w	r1, #63	; 0x3f
    1736:	f014 f867 	bl	15808 <strchr>
    173a:	4603      	mov	r3, r0
    173c:	60fb      	str	r3, [r7, #12]
	    if( c )
    173e:	68fb      	ldr	r3, [r7, #12]
    1740:	2b00      	cmp	r3, #0
    1742:	d023      	beq.n	178c <vApplicationProcessFormInput+0x7c>
	    {
			/* Turn the LED's on or off in accordance with the check box status. */
			if( strstr( c, "LED0=1" ) != NULL )
    1744:	68f8      	ldr	r0, [r7, #12]
    1746:	f24c 6194 	movw	r1, #50836	; 0xc694
    174a:	f2c0 0101 	movt	r1, #1
    174e:	f014 fb7d 	bl	15e4c <strstr>
    1752:	4603      	mov	r3, r0
    1754:	2b00      	cmp	r3, #0
    1756:	d00c      	beq.n	1772 <vApplicationProcessFormInput+0x62>
			{
				/* Turn the LEDs on. */
				vParTestSetLED( 3, 1 );
    1758:	f04f 0003 	mov.w	r0, #3
    175c:	f04f 0101 	mov.w	r1, #1
    1760:	f7fe fed8 	bl	514 <vParTestSetLED>
				vParTestSetLED( 4, 1 );
    1764:	f04f 0004 	mov.w	r0, #4
    1768:	f04f 0101 	mov.w	r1, #1
    176c:	f7fe fed2 	bl	514 <vParTestSetLED>
			}
			else
			{
				/* Turn the LEDs off. */
				vParTestSetLED( 3, 0 );
				vParTestSetLED( 4, 0 );
    1770:	e018      	b.n	17a4 <vApplicationProcessFormInput+0x94>
				vParTestSetLED( 4, 1 );
			}
			else
			{
				/* Turn the LEDs off. */
				vParTestSetLED( 3, 0 );
    1772:	f04f 0003 	mov.w	r0, #3
    1776:	f04f 0100 	mov.w	r1, #0
    177a:	f7fe fecb 	bl	514 <vParTestSetLED>
				vParTestSetLED( 4, 0 );
    177e:	f04f 0004 	mov.w	r0, #4
    1782:	f04f 0100 	mov.w	r1, #0
    1786:	f7fe fec5 	bl	514 <vParTestSetLED>
    178a:	e00b      	b.n	17a4 <vApplicationProcessFormInput+0x94>
			}
	    }
		else
		{
			/* Commands to turn LEDs off are not always explicit. */
			vParTestSetLED( 3, 0 );
    178c:	f04f 0003 	mov.w	r0, #3
    1790:	f04f 0100 	mov.w	r1, #0
    1794:	f7fe febe 	bl	514 <vParTestSetLED>
			vParTestSetLED( 4, 0 );
    1798:	f04f 0004 	mov.w	r0, #4
    179c:	f04f 0100 	mov.w	r1, #0
    17a0:	f7fe feb8 	bl	514 <vParTestSetLED>
		}
	}
}
    17a4:	f107 0710 	add.w	r7, r7, #16
    17a8:	46bd      	mov	sp, r7
    17aa:	bd80      	pop	{r7, pc}

000017ac <nullfunction>:

float                            real_temperature_value_tc;

/*---------------------------------------------------------------------------*/
static PT_THREAD( nullfunction ( struct httpd_state *s, char *ptr ) )
{
    17ac:	b480      	push	{r7}
    17ae:	b085      	sub	sp, #20
    17b0:	af00      	add	r7, sp, #0
    17b2:	6078      	str	r0, [r7, #4]
    17b4:	6039      	str	r1, [r7, #0]
	PSOCK_BEGIN( &s->sout );
    17b6:	f04f 0301 	mov.w	r3, #1
    17ba:	73fb      	strb	r3, [r7, #15]
	( void ) ptr;
	( void ) PT_YIELD_FLAG;
	PSOCK_END( &s->sout );
    17bc:	f04f 0300 	mov.w	r3, #0
    17c0:	73fb      	strb	r3, [r7, #15]
    17c2:	687b      	ldr	r3, [r7, #4]
    17c4:	f04f 0200 	mov.w	r2, #0
    17c8:	851a      	strh	r2, [r3, #40]	; 0x28
    17ca:	f04f 0302 	mov.w	r3, #2
}
    17ce:	4618      	mov	r0, r3
    17d0:	f107 0714 	add.w	r7, r7, #20
    17d4:	46bd      	mov	sp, r7
    17d6:	bc80      	pop	{r7}
    17d8:	4770      	bx	lr
    17da:	bf00      	nop

000017dc <httpd_cgi>:

/*---------------------------------------------------------------------------*/
httpd_cgifunction httpd_cgi( char *name )
{
    17dc:	b590      	push	{r4, r7, lr}
    17de:	b085      	sub	sp, #20
    17e0:	af00      	add	r7, sp, #0
    17e2:	6078      	str	r0, [r7, #4]
	const struct httpd_cgi_call **f;

	/* Find the matching name in the table, return the function. */
	for( f = calls; *f != NULL; ++f )
    17e4:	f240 0310 	movw	r3, #16
    17e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    17ec:	60fb      	str	r3, [r7, #12]
    17ee:	e019      	b.n	1824 <httpd_cgi+0x48>
	{
		if( strncmp((*f)->name, name, strlen((*f)->name)) == 0 )
    17f0:	68fb      	ldr	r3, [r7, #12]
    17f2:	681b      	ldr	r3, [r3, #0]
    17f4:	681c      	ldr	r4, [r3, #0]
    17f6:	68fb      	ldr	r3, [r7, #12]
    17f8:	681b      	ldr	r3, [r3, #0]
    17fa:	681b      	ldr	r3, [r3, #0]
    17fc:	4618      	mov	r0, r3
    17fe:	f014 f8c1 	bl	15984 <strlen>
    1802:	4603      	mov	r3, r0
    1804:	4620      	mov	r0, r4
    1806:	6879      	ldr	r1, [r7, #4]
    1808:	461a      	mov	r2, r3
    180a:	f014 f8eb 	bl	159e4 <strncmp>
    180e:	4603      	mov	r3, r0
    1810:	2b00      	cmp	r3, #0
    1812:	d103      	bne.n	181c <httpd_cgi+0x40>
		{
			return( *f )->function;
    1814:	68fb      	ldr	r3, [r7, #12]
    1816:	681b      	ldr	r3, [r3, #0]
    1818:	685b      	ldr	r3, [r3, #4]
    181a:	e00b      	b.n	1834 <httpd_cgi+0x58>
httpd_cgifunction httpd_cgi( char *name )
{
	const struct httpd_cgi_call **f;

	/* Find the matching name in the table, return the function. */
	for( f = calls; *f != NULL; ++f )
    181c:	68fb      	ldr	r3, [r7, #12]
    181e:	f103 0304 	add.w	r3, r3, #4
    1822:	60fb      	str	r3, [r7, #12]
    1824:	68fb      	ldr	r3, [r7, #12]
    1826:	681b      	ldr	r3, [r3, #0]
    1828:	2b00      	cmp	r3, #0
    182a:	d1e1      	bne.n	17f0 <httpd_cgi+0x14>
		{
			return( *f )->function;
		}
	}

	return nullfunction;
    182c:	f241 73ad 	movw	r3, #6061	; 0x17ad
    1830:	f2c0 0300 	movt	r3, #0
}
    1834:	4618      	mov	r0, r3
    1836:	f107 0714 	add.w	r7, r7, #20
    183a:	46bd      	mov	sp, r7
    183c:	bd90      	pop	{r4, r7, pc}
    183e:	bf00      	nop

00001840 <generate_tcp_stats>:
static const char	last_ack[] = /*  "LAST-ACK"*/ { 0x4c, 0x41, 0x53, 0x54, 0x2d, 0x41, 0x43, 0x4b, 0 };

static const char	*states[] = { closed, syn_rcvd, syn_sent, established, fin_wait_1, fin_wait_2, closing, time_wait, last_ack };

static unsigned short generate_tcp_stats( void *arg )
{
    1840:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    1844:	b08e      	sub	sp, #56	; 0x38
    1846:	af0a      	add	r7, sp, #40	; 0x28
    1848:	6078      	str	r0, [r7, #4]
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;
    184a:	687b      	ldr	r3, [r7, #4]
    184c:	60fb      	str	r3, [r7, #12]

	conn = &uip_conns[s->count];
    184e:	68fb      	ldr	r3, [r7, #12]
    1850:	f8b3 30ac 	ldrh.w	r3, [r3, #172]	; 0xac
    1854:	f04f 02cc 	mov.w	r2, #204	; 0xcc
    1858:	fb02 f203 	mul.w	r2, r2, r3
    185c:	f64a 432c 	movw	r3, #44076	; 0xac2c
    1860:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1864:	4413      	add	r3, r2
    1866:	60bb      	str	r3, [r7, #8]
	return sprintf( ( char * ) uip_appdata,
    1868:	f64a 4324 	movw	r3, #44068	; 0xac24
    186c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1870:	681b      	ldr	r3, [r3, #0]
    1872:	461e      	mov	r6, r3
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
    1874:	68bb      	ldr	r3, [r7, #8]
    1876:	889b      	ldrh	r3, [r3, #4]
    1878:	4618      	mov	r0, r3
    187a:	f00c f81b 	bl	d8b4 <htons>
    187e:	4603      	mov	r3, r0
{
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;

	conn = &uip_conns[s->count];
	return sprintf( ( char * ) uip_appdata,
    1880:	461d      	mov	r5, r3
    1882:	68bb      	ldr	r3, [r7, #8]
    1884:	881b      	ldrh	r3, [r3, #0]
    1886:	4618      	mov	r0, r3
    1888:	f00c f814 	bl	d8b4 <htons>
    188c:	4603      	mov	r3, r0
    188e:	ea4f 2313 	mov.w	r3, r3, lsr #8
    1892:	b29b      	uxth	r3, r3
    1894:	461c      	mov	r4, r3
    1896:	68bb      	ldr	r3, [r7, #8]
    1898:	881b      	ldrh	r3, [r3, #0]
    189a:	4618      	mov	r0, r3
    189c:	f00c f80a 	bl	d8b4 <htons>
    18a0:	4603      	mov	r3, r0
    18a2:	f003 09ff 	and.w	r9, r3, #255	; 0xff
    18a6:	68bb      	ldr	r3, [r7, #8]
    18a8:	885b      	ldrh	r3, [r3, #2]
    18aa:	4618      	mov	r0, r3
    18ac:	f00c f802 	bl	d8b4 <htons>
    18b0:	4603      	mov	r3, r0
    18b2:	ea4f 2313 	mov.w	r3, r3, lsr #8
    18b6:	b29b      	uxth	r3, r3
    18b8:	469a      	mov	sl, r3
    18ba:	68bb      	ldr	r3, [r7, #8]
    18bc:	885b      	ldrh	r3, [r3, #2]
    18be:	4618      	mov	r0, r3
    18c0:	f00b fff8 	bl	d8b4 <htons>
    18c4:	4603      	mov	r3, r0
    18c6:	f003 08ff 	and.w	r8, r3, #255	; 0xff
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
					 htons(conn->ripaddr.u16[0]) >> 8, htons(conn->ripaddr.u16[0]) & 0xff, htons(conn->ripaddr.u16[1]) >> 8,
					 htons(conn->ripaddr.u16[1]) & 0xff, htons(conn->rport), states[conn->tcpstateflags & UIP_TS_MASK], conn->nrtx, conn->timer,
    18ca:	68bb      	ldr	r3, [r7, #8]
    18cc:	88db      	ldrh	r3, [r3, #6]
    18ce:	4618      	mov	r0, r3
    18d0:	f00b fff0 	bl	d8b4 <htons>
    18d4:	4603      	mov	r3, r0
{
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;

	conn = &uip_conns[s->count];
	return sprintf( ( char * ) uip_appdata,
    18d6:	469e      	mov	lr, r3
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
					 htons(conn->ripaddr.u16[0]) >> 8, htons(conn->ripaddr.u16[0]) & 0xff, htons(conn->ripaddr.u16[1]) >> 8,
					 htons(conn->ripaddr.u16[1]) & 0xff, htons(conn->rport), states[conn->tcpstateflags & UIP_TS_MASK], conn->nrtx, conn->timer,
    18d8:	68bb      	ldr	r3, [r7, #8]
    18da:	7e5b      	ldrb	r3, [r3, #25]
    18dc:	f003 020f 	and.w	r2, r3, #15
{
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;

	conn = &uip_conns[s->count];
	return sprintf( ( char * ) uip_appdata,
    18e0:	f240 0324 	movw	r3, #36	; 0x24
    18e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    18e8:	f853 c022 	ldr.w	ip, [r3, r2, lsl #2]
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
					 htons(conn->ripaddr.u16[0]) >> 8, htons(conn->ripaddr.u16[0]) & 0xff, htons(conn->ripaddr.u16[1]) >> 8,
					 htons(conn->ripaddr.u16[1]) & 0xff, htons(conn->rport), states[conn->tcpstateflags & UIP_TS_MASK], conn->nrtx, conn->timer,
    18ec:	68bb      	ldr	r3, [r7, #8]
    18ee:	7edb      	ldrb	r3, [r3, #27]
{
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;

	conn = &uip_conns[s->count];
	return sprintf( ( char * ) uip_appdata,
    18f0:	4618      	mov	r0, r3
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
					 htons(conn->ripaddr.u16[0]) >> 8, htons(conn->ripaddr.u16[0]) & 0xff, htons(conn->ripaddr.u16[1]) >> 8,
					 htons(conn->ripaddr.u16[1]) & 0xff, htons(conn->rport), states[conn->tcpstateflags & UIP_TS_MASK], conn->nrtx, conn->timer,
    18f2:	68bb      	ldr	r3, [r7, #8]
    18f4:	7e9b      	ldrb	r3, [r3, #26]
{
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;

	conn = &uip_conns[s->count];
	return sprintf( ( char * ) uip_appdata,
    18f6:	4619      	mov	r1, r3
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
					 htons(conn->ripaddr.u16[0]) >> 8, htons(conn->ripaddr.u16[0]) & 0xff, htons(conn->ripaddr.u16[1]) >> 8,
					 htons(conn->ripaddr.u16[1]) & 0xff, htons(conn->rport), states[conn->tcpstateflags & UIP_TS_MASK], conn->nrtx, conn->timer,
					 (uip_outstanding(conn)) ? '*' : ' ', (uip_stopped(conn)) ? '!' : ' ' );
    18f8:	68bb      	ldr	r3, [r7, #8]
    18fa:	8a1b      	ldrh	r3, [r3, #16]
{
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;

	conn = &uip_conns[s->count];
	return sprintf( ( char * ) uip_appdata,
    18fc:	2b00      	cmp	r3, #0
    18fe:	d002      	beq.n	1906 <generate_tcp_stats+0xc6>
    1900:	f04f 022a 	mov.w	r2, #42	; 0x2a
    1904:	e001      	b.n	190a <generate_tcp_stats+0xca>
    1906:	f04f 0220 	mov.w	r2, #32
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
					 htons(conn->ripaddr.u16[0]) >> 8, htons(conn->ripaddr.u16[0]) & 0xff, htons(conn->ripaddr.u16[1]) >> 8,
					 htons(conn->ripaddr.u16[1]) & 0xff, htons(conn->rport), states[conn->tcpstateflags & UIP_TS_MASK], conn->nrtx, conn->timer,
					 (uip_outstanding(conn)) ? '*' : ' ', (uip_stopped(conn)) ? '!' : ' ' );
    190a:	68bb      	ldr	r3, [r7, #8]
    190c:	7e5b      	ldrb	r3, [r3, #25]
    190e:	f003 0310 	and.w	r3, r3, #16
{
	struct uip_conn		*conn;
	struct httpd_state	*s = ( struct httpd_state * ) arg;

	conn = &uip_conns[s->count];
	return sprintf( ( char * ) uip_appdata,
    1912:	2b00      	cmp	r3, #0
    1914:	d002      	beq.n	191c <generate_tcp_stats+0xdc>
    1916:	f04f 0321 	mov.w	r3, #33	; 0x21
    191a:	e001      	b.n	1920 <generate_tcp_stats+0xe0>
    191c:	f04f 0320 	mov.w	r3, #32
    1920:	f8cd 9000 	str.w	r9, [sp]
    1924:	f8cd a004 	str.w	sl, [sp, #4]
    1928:	f8cd 8008 	str.w	r8, [sp, #8]
    192c:	f8cd e00c 	str.w	lr, [sp, #12]
    1930:	f8cd c010 	str.w	ip, [sp, #16]
    1934:	9005      	str	r0, [sp, #20]
    1936:	9106      	str	r1, [sp, #24]
    1938:	9207      	str	r2, [sp, #28]
    193a:	9308      	str	r3, [sp, #32]
    193c:	4630      	mov	r0, r6
    193e:	f24c 61d8 	movw	r1, #50904	; 0xc6d8
    1942:	f2c0 0101 	movt	r1, #1
    1946:	462a      	mov	r2, r5
    1948:	4623      	mov	r3, r4
    194a:	f013 ff13 	bl	15774 <sprintf>
    194e:	4603      	mov	r3, r0
    1950:	b29b      	uxth	r3, r3
					 "<tr><td>%d</td><td>%u.%u.%u.%u:%u</td><td>%s</td><td>%u</td><td>%u</td><td>%c %c</td></tr>\r\n", htons(conn->lport),
					 htons(conn->ripaddr.u16[0]) >> 8, htons(conn->ripaddr.u16[0]) & 0xff, htons(conn->ripaddr.u16[1]) >> 8,
					 htons(conn->ripaddr.u16[1]) & 0xff, htons(conn->rport), states[conn->tcpstateflags & UIP_TS_MASK], conn->nrtx, conn->timer,
					 (uip_outstanding(conn)) ? '*' : ' ', (uip_stopped(conn)) ? '!' : ' ' );
}
    1952:	4618      	mov	r0, r3
    1954:	f107 0710 	add.w	r7, r7, #16
    1958:	46bd      	mov	sp, r7
    195a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    195e:	bf00      	nop

00001960 <tcp_stats>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( tcp_stats ( struct httpd_state *s, char *ptr ) )
{
    1960:	b580      	push	{r7, lr}
    1962:	b084      	sub	sp, #16
    1964:	af00      	add	r7, sp, #0
    1966:	6078      	str	r0, [r7, #4]
    1968:	6039      	str	r1, [r7, #0]
	PSOCK_BEGIN( &s->sout );
    196a:	f04f 0301 	mov.w	r3, #1
    196e:	73fb      	strb	r3, [r7, #15]
    1970:	687b      	ldr	r3, [r7, #4]
    1972:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    1974:	2b00      	cmp	r3, #0
    1976:	d002      	beq.n	197e <tcp_stats+0x1e>
    1978:	2b8b      	cmp	r3, #139	; 0x8b
    197a:	d01e      	beq.n	19ba <tcp_stats+0x5a>
    197c:	e03c      	b.n	19f8 <tcp_stats+0x98>
	( void ) ptr;
	( void ) PT_YIELD_FLAG;
	for( s->count = 0; s->count < UIP_CONNS; ++s->count )
    197e:	687b      	ldr	r3, [r7, #4]
    1980:	f04f 0200 	mov.w	r2, #0
    1984:	f8a3 20ac 	strh.w	r2, [r3, #172]	; 0xac
    1988:	e031      	b.n	19ee <tcp_stats+0x8e>
	{
		if( (uip_conns[s->count].tcpstateflags & UIP_TS_MASK) != UIP_CLOSED )
    198a:	687b      	ldr	r3, [r7, #4]
    198c:	f8b3 30ac 	ldrh.w	r3, [r3, #172]	; 0xac
    1990:	461a      	mov	r2, r3
    1992:	f64a 432c 	movw	r3, #44076	; 0xac2c
    1996:	f2c2 0300 	movt	r3, #8192	; 0x2000
    199a:	f04f 01cc 	mov.w	r1, #204	; 0xcc
    199e:	fb01 f202 	mul.w	r2, r1, r2
    19a2:	4413      	add	r3, r2
    19a4:	f103 0318 	add.w	r3, r3, #24
    19a8:	785b      	ldrb	r3, [r3, #1]
    19aa:	f003 030f 	and.w	r3, r3, #15
    19ae:	2b00      	cmp	r3, #0
    19b0:	d014      	beq.n	19dc <tcp_stats+0x7c>
		{
			PSOCK_GENERATOR_SEND( &s->sout, generate_tcp_stats, s );
    19b2:	687b      	ldr	r3, [r7, #4]
    19b4:	f04f 028b 	mov.w	r2, #139	; 0x8b
    19b8:	851a      	strh	r2, [r3, #40]	; 0x28
    19ba:	687b      	ldr	r3, [r7, #4]
    19bc:	f103 0328 	add.w	r3, r3, #40	; 0x28
    19c0:	4618      	mov	r0, r3
    19c2:	f641 0141 	movw	r1, #6209	; 0x1841
    19c6:	f2c0 0100 	movt	r1, #0
    19ca:	687a      	ldr	r2, [r7, #4]
    19cc:	f009 f8f8 	bl	abc0 <psock_generator_send>
    19d0:	4603      	mov	r3, r0
    19d2:	2b00      	cmp	r3, #0
    19d4:	d102      	bne.n	19dc <tcp_stats+0x7c>
    19d6:	f04f 0300 	mov.w	r3, #0
    19da:	e016      	b.n	1a0a <tcp_stats+0xaa>
static PT_THREAD( tcp_stats ( struct httpd_state *s, char *ptr ) )
{
	PSOCK_BEGIN( &s->sout );
	( void ) ptr;
	( void ) PT_YIELD_FLAG;
	for( s->count = 0; s->count < UIP_CONNS; ++s->count )
    19dc:	687b      	ldr	r3, [r7, #4]
    19de:	f8b3 30ac 	ldrh.w	r3, [r3, #172]	; 0xac
    19e2:	f103 0301 	add.w	r3, r3, #1
    19e6:	b29a      	uxth	r2, r3
    19e8:	687b      	ldr	r3, [r7, #4]
    19ea:	f8a3 20ac 	strh.w	r2, [r3, #172]	; 0xac
    19ee:	687b      	ldr	r3, [r7, #4]
    19f0:	f8b3 30ac 	ldrh.w	r3, [r3, #172]	; 0xac
    19f4:	2b27      	cmp	r3, #39	; 0x27
    19f6:	d9c8      	bls.n	198a <tcp_stats+0x2a>
		{
			PSOCK_GENERATOR_SEND( &s->sout, generate_tcp_stats, s );
		}
	}

	PSOCK_END( &s->sout );
    19f8:	f04f 0300 	mov.w	r3, #0
    19fc:	73fb      	strb	r3, [r7, #15]
    19fe:	687b      	ldr	r3, [r7, #4]
    1a00:	f04f 0200 	mov.w	r2, #0
    1a04:	851a      	strh	r2, [r3, #40]	; 0x28
    1a06:	f04f 0302 	mov.w	r3, #2
}
    1a0a:	4618      	mov	r0, r3
    1a0c:	f107 0710 	add.w	r7, r7, #16
    1a10:	46bd      	mov	sp, r7
    1a12:	bd80      	pop	{r7, pc}

00001a14 <generate_net_stats>:

/*---------------------------------------------------------------------------*/
static unsigned short generate_net_stats( void *arg )
{
    1a14:	b580      	push	{r7, lr}
    1a16:	b084      	sub	sp, #16
    1a18:	af00      	add	r7, sp, #0
    1a1a:	6078      	str	r0, [r7, #4]
	struct httpd_state	*s = ( struct httpd_state * ) arg;
    1a1c:	687b      	ldr	r3, [r7, #4]
    1a1e:	60fb      	str	r3, [r7, #12]
	return sprintf( ( char * ) uip_appdata, "%5u\n", (( uip_stats_t * ) &uip_stat)[s->count] );
    1a20:	f64a 4324 	movw	r3, #44068	; 0xac24
    1a24:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1a28:	681b      	ldr	r3, [r3, #0]
    1a2a:	461a      	mov	r2, r3
    1a2c:	68fb      	ldr	r3, [r7, #12]
    1a2e:	f8b3 30ac 	ldrh.w	r3, [r3, #172]	; 0xac
    1a32:	ea4f 0143 	mov.w	r1, r3, lsl #1
    1a36:	f64c 4360 	movw	r3, #52320	; 0xcc60
    1a3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1a3e:	440b      	add	r3, r1
    1a40:	881b      	ldrh	r3, [r3, #0]
    1a42:	4610      	mov	r0, r2
    1a44:	f24c 7138 	movw	r1, #51000	; 0xc738
    1a48:	f2c0 0101 	movt	r1, #1
    1a4c:	461a      	mov	r2, r3
    1a4e:	f013 fe91 	bl	15774 <sprintf>
    1a52:	4603      	mov	r3, r0
    1a54:	b29b      	uxth	r3, r3
}
    1a56:	4618      	mov	r0, r3
    1a58:	f107 0710 	add.w	r7, r7, #16
    1a5c:	46bd      	mov	sp, r7
    1a5e:	bd80      	pop	{r7, pc}

00001a60 <net_stats>:

static PT_THREAD( net_stats ( struct httpd_state *s, char *ptr ) )
{
    1a60:	b580      	push	{r7, lr}
    1a62:	b084      	sub	sp, #16
    1a64:	af00      	add	r7, sp, #0
    1a66:	6078      	str	r0, [r7, #4]
    1a68:	6039      	str	r1, [r7, #0]
	PSOCK_BEGIN( &s->sout );
    1a6a:	f04f 0301 	mov.w	r3, #1
    1a6e:	73fb      	strb	r3, [r7, #15]
    1a70:	687b      	ldr	r3, [r7, #4]
    1a72:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    1a74:	2b00      	cmp	r3, #0
    1a76:	d002      	beq.n	1a7e <net_stats+0x1e>
    1a78:	2ba1      	cmp	r3, #161	; 0xa1
    1a7a:	d00a      	beq.n	1a92 <net_stats+0x32>
    1a7c:	e028      	b.n	1ad0 <net_stats+0x70>
	( void ) ptr;
	( void ) PT_YIELD_FLAG;
#if UIP_STATISTICS
	for( s->count = 0; s->count < sizeof(uip_stat) / sizeof(uip_stats_t); ++s->count )
    1a7e:	687b      	ldr	r3, [r7, #4]
    1a80:	f04f 0200 	mov.w	r2, #0
    1a84:	f8a3 20ac 	strh.w	r2, [r3, #172]	; 0xac
    1a88:	e01d      	b.n	1ac6 <net_stats+0x66>
	{
		PSOCK_GENERATOR_SEND( &s->sout, generate_net_stats, s );
    1a8a:	687b      	ldr	r3, [r7, #4]
    1a8c:	f04f 02a1 	mov.w	r2, #161	; 0xa1
    1a90:	851a      	strh	r2, [r3, #40]	; 0x28
    1a92:	687b      	ldr	r3, [r7, #4]
    1a94:	f103 0328 	add.w	r3, r3, #40	; 0x28
    1a98:	4618      	mov	r0, r3
    1a9a:	f641 2115 	movw	r1, #6677	; 0x1a15
    1a9e:	f2c0 0100 	movt	r1, #0
    1aa2:	687a      	ldr	r2, [r7, #4]
    1aa4:	f009 f88c 	bl	abc0 <psock_generator_send>
    1aa8:	4603      	mov	r3, r0
    1aaa:	2b00      	cmp	r3, #0
    1aac:	d102      	bne.n	1ab4 <net_stats+0x54>
    1aae:	f04f 0300 	mov.w	r3, #0
    1ab2:	e016      	b.n	1ae2 <net_stats+0x82>
{
	PSOCK_BEGIN( &s->sout );
	( void ) ptr;
	( void ) PT_YIELD_FLAG;
#if UIP_STATISTICS
	for( s->count = 0; s->count < sizeof(uip_stat) / sizeof(uip_stats_t); ++s->count )
    1ab4:	687b      	ldr	r3, [r7, #4]
    1ab6:	f8b3 30ac 	ldrh.w	r3, [r3, #172]	; 0xac
    1aba:	f103 0301 	add.w	r3, r3, #1
    1abe:	b29a      	uxth	r2, r3
    1ac0:	687b      	ldr	r3, [r7, #4]
    1ac2:	f8a3 20ac 	strh.w	r2, [r3, #172]	; 0xac
    1ac6:	687b      	ldr	r3, [r7, #4]
    1ac8:	f8b3 30ac 	ldrh.w	r3, [r3, #172]	; 0xac
    1acc:	2b1b      	cmp	r3, #27
    1ace:	d9dc      	bls.n	1a8a <net_stats+0x2a>
		PSOCK_GENERATOR_SEND( &s->sout, generate_net_stats, s );
	}

#endif /* UIP_STATISTICS */

	PSOCK_END( &s->sout );
    1ad0:	f04f 0300 	mov.w	r3, #0
    1ad4:	73fb      	strb	r3, [r7, #15]
    1ad6:	687b      	ldr	r3, [r7, #4]
    1ad8:	f04f 0200 	mov.w	r2, #0
    1adc:	851a      	strh	r2, [r3, #40]	; 0x28
    1ade:	f04f 0302 	mov.w	r3, #2
}
    1ae2:	4618      	mov	r0, r3
    1ae4:	f107 0710 	add.w	r7, r7, #16
    1ae8:	46bd      	mov	sp, r7
    1aea:	bd80      	pop	{r7, pc}

00001aec <generate_io_state>:
/*---------------------------------------------------------------------------*/
char			*pcStatus;
unsigned long	ulString;

static unsigned short generate_io_state( void *arg )
{
    1aec:	b580      	push	{r7, lr}
    1aee:	b082      	sub	sp, #8
    1af0:	af00      	add	r7, sp, #0
    1af2:	6078      	str	r0, [r7, #4]
	extern long lParTestGetLEDState( unsigned long ulLED );
	( void ) arg;

	/* Are the dynamically setable LEDs currently on or off? */
	if( lParTestGetLEDState( 3 ) )
    1af4:	f04f 0003 	mov.w	r0, #3
    1af8:	f7fe fde6 	bl	6c8 <lParTestGetLEDState>
    1afc:	4603      	mov	r3, r0
    1afe:	2b00      	cmp	r3, #0
    1b00:	d009      	beq.n	1b16 <generate_io_state+0x2a>
	{
		pcStatus = "checked";
    1b02:	f64a 13a0 	movw	r3, #43424	; 0xa9a0
    1b06:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1b0a:	f24c 7240 	movw	r2, #51008	; 0xc740
    1b0e:	f2c0 0201 	movt	r2, #1
    1b12:	601a      	str	r2, [r3, #0]
    1b14:	e008      	b.n	1b28 <generate_io_state+0x3c>
	}
	else
	{
		pcStatus = "";
    1b16:	f64a 13a0 	movw	r3, #43424	; 0xa9a0
    1b1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1b1e:	f24c 7248 	movw	r2, #51016	; 0xc748
    1b22:	f2c0 0201 	movt	r2, #1
    1b26:	601a      	str	r2, [r3, #0]
	}

	sprintf( uip_appdata, "<input type=\"checkbox\" name=\"LED0\" value=\"1\" %s>LED<p>", pcStatus );
    1b28:	f64a 4324 	movw	r3, #44068	; 0xac24
    1b2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1b30:	681b      	ldr	r3, [r3, #0]
    1b32:	461a      	mov	r2, r3
    1b34:	f64a 13a0 	movw	r3, #43424	; 0xa9a0
    1b38:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1b3c:	681b      	ldr	r3, [r3, #0]
    1b3e:	4610      	mov	r0, r2
    1b40:	f24c 714c 	movw	r1, #51020	; 0xc74c
    1b44:	f2c0 0101 	movt	r1, #1
    1b48:	461a      	mov	r2, r3
    1b4a:	f013 fe13 	bl	15774 <sprintf>

	return strlen( uip_appdata );
    1b4e:	f64a 4324 	movw	r3, #44068	; 0xac24
    1b52:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1b56:	681b      	ldr	r3, [r3, #0]
    1b58:	4618      	mov	r0, r3
    1b5a:	f013 ff13 	bl	15984 <strlen>
    1b5e:	4603      	mov	r3, r0
    1b60:	b29b      	uxth	r3, r3
}
    1b62:	4618      	mov	r0, r3
    1b64:	f107 0708 	add.w	r7, r7, #8
    1b68:	46bd      	mov	sp, r7
    1b6a:	bd80      	pop	{r7, pc}

00001b6c <led_io>:


/*---------------------------------------------------------------------------*/
static PT_THREAD( led_io ( struct httpd_state *s, char *ptr ) )
{
    1b6c:	b580      	push	{r7, lr}
    1b6e:	b084      	sub	sp, #16
    1b70:	af00      	add	r7, sp, #0
    1b72:	6078      	str	r0, [r7, #4]
    1b74:	6039      	str	r1, [r7, #0]
	PSOCK_BEGIN( &s->sout );
    1b76:	f04f 0301 	mov.w	r3, #1
    1b7a:	73fb      	strb	r3, [r7, #15]
    1b7c:	687b      	ldr	r3, [r7, #4]
    1b7e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    1b80:	2b00      	cmp	r3, #0
    1b82:	d002      	beq.n	1b8a <led_io+0x1e>
    1b84:	2bc8      	cmp	r3, #200	; 0xc8
    1b86:	d004      	beq.n	1b92 <led_io+0x26>
    1b88:	e015      	b.n	1bb6 <led_io+0x4a>
	( void ) ptr;
	( void ) PT_YIELD_FLAG;
	PSOCK_GENERATOR_SEND( &s->sout, generate_io_state, NULL );
    1b8a:	687b      	ldr	r3, [r7, #4]
    1b8c:	f04f 02c8 	mov.w	r2, #200	; 0xc8
    1b90:	851a      	strh	r2, [r3, #40]	; 0x28
    1b92:	687b      	ldr	r3, [r7, #4]
    1b94:	f103 0328 	add.w	r3, r3, #40	; 0x28
    1b98:	4618      	mov	r0, r3
    1b9a:	f641 21ed 	movw	r1, #6893	; 0x1aed
    1b9e:	f2c0 0100 	movt	r1, #0
    1ba2:	f04f 0200 	mov.w	r2, #0
    1ba6:	f009 f80b 	bl	abc0 <psock_generator_send>
    1baa:	4603      	mov	r3, r0
    1bac:	2b00      	cmp	r3, #0
    1bae:	d102      	bne.n	1bb6 <led_io+0x4a>
    1bb0:	f04f 0300 	mov.w	r3, #0
    1bb4:	e008      	b.n	1bc8 <led_io+0x5c>
	PSOCK_END( &s->sout );
    1bb6:	f04f 0300 	mov.w	r3, #0
    1bba:	73fb      	strb	r3, [r7, #15]
    1bbc:	687b      	ldr	r3, [r7, #4]
    1bbe:	f04f 0200 	mov.w	r2, #0
    1bc2:	851a      	strh	r2, [r3, #40]	; 0x28
    1bc4:	f04f 0302 	mov.w	r3, #2
}
    1bc8:	4618      	mov	r0, r3
    1bca:	f107 0710 	add.w	r7, r7, #16
    1bce:	46bd      	mov	sp, r7
    1bd0:	bd80      	pop	{r7, pc}
    1bd2:	bf00      	nop

00001bd4 <sensor_readings>:


static PT_THREAD( sensor_readings ( struct httpd_state *s, char *ptr ) )
{
    1bd4:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
    1bd8:	b08c      	sub	sp, #48	; 0x30
    1bda:	af08      	add	r7, sp, #32
    1bdc:	6078      	str	r0, [r7, #4]
    1bde:	6039      	str	r1, [r7, #0]
		static char buf[35];

		PSOCK_BEGIN( &s->sout );
    1be0:	f04f 0301 	mov.w	r3, #1
    1be4:	73fb      	strb	r3, [r7, #15]
    1be6:	687b      	ldr	r3, [r7, #4]
    1be8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    1bea:	2b00      	cmp	r3, #0
    1bec:	d002      	beq.n	1bf4 <sensor_readings+0x20>
    1bee:	2bd3      	cmp	r3, #211	; 0xd3
    1bf0:	d038      	beq.n	1c64 <sensor_readings+0x90>
    1bf2:	e04f      	b.n	1c94 <sensor_readings+0xc0>
		snprintf( buf, sizeof(buf), "%.4f,%.4f,%.4f,%.4f", get_avg_external_temp() ,get_humidity(), get_avg_lux(), get_uv_index());
    1bf4:	f7ff f922 	bl	e3c <get_avg_external_temp>
    1bf8:	4603      	mov	r3, r0
    1bfa:	4618      	mov	r0, r3
    1bfc:	f012 fe76 	bl	148ec <__aeabi_f2d>
    1c00:	4682      	mov	sl, r0
    1c02:	468b      	mov	fp, r1
    1c04:	f7ff f944 	bl	e90 <get_humidity>
    1c08:	4603      	mov	r3, r0
    1c0a:	4618      	mov	r0, r3
    1c0c:	f012 fe6e 	bl	148ec <__aeabi_f2d>
    1c10:	4680      	mov	r8, r0
    1c12:	4689      	mov	r9, r1
    1c14:	f7ff fa50 	bl	10b8 <get_avg_lux>
    1c18:	4603      	mov	r3, r0
    1c1a:	4618      	mov	r0, r3
    1c1c:	f012 fe66 	bl	148ec <__aeabi_f2d>
    1c20:	4604      	mov	r4, r0
    1c22:	460d      	mov	r5, r1
    1c24:	f7ff f980 	bl	f28 <get_uv_index>
    1c28:	4603      	mov	r3, r0
    1c2a:	4618      	mov	r0, r3
    1c2c:	f012 fe5e 	bl	148ec <__aeabi_f2d>
    1c30:	4602      	mov	r2, r0
    1c32:	460b      	mov	r3, r1
    1c34:	e9cd ab00 	strd	sl, fp, [sp]
    1c38:	e9cd 8902 	strd	r8, r9, [sp, #8]
    1c3c:	e9cd 4504 	strd	r4, r5, [sp, #16]
    1c40:	e9cd 2306 	strd	r2, r3, [sp, #24]
    1c44:	f240 6044 	movw	r0, #1604	; 0x644
    1c48:	f2c2 0000 	movt	r0, #8192	; 0x2000
    1c4c:	f04f 0123 	mov.w	r1, #35	; 0x23
    1c50:	f24c 7284 	movw	r2, #51076	; 0xc784
    1c54:	f2c0 0201 	movt	r2, #1
    1c58:	f013 fd1e 	bl	15698 <snprintf>
		PSOCK_SEND_STR( &s->sout, buf);
    1c5c:	687b      	ldr	r3, [r7, #4]
    1c5e:	f04f 02d3 	mov.w	r2, #211	; 0xd3
    1c62:	851a      	strh	r2, [r3, #40]	; 0x28
    1c64:	687b      	ldr	r3, [r7, #4]
    1c66:	f103 0428 	add.w	r4, r3, #40	; 0x28
    1c6a:	f240 6044 	movw	r0, #1604	; 0x644
    1c6e:	f2c2 0000 	movt	r0, #8192	; 0x2000
    1c72:	f013 fe87 	bl	15984 <strlen>
    1c76:	4603      	mov	r3, r0
    1c78:	4620      	mov	r0, r4
    1c7a:	f240 6144 	movw	r1, #1604	; 0x644
    1c7e:	f2c2 0100 	movt	r1, #8192	; 0x2000
    1c82:	461a      	mov	r2, r3
    1c84:	f008 ff52 	bl	ab2c <psock_send>
    1c88:	4603      	mov	r3, r0
    1c8a:	2b00      	cmp	r3, #0
    1c8c:	d102      	bne.n	1c94 <sensor_readings+0xc0>
    1c8e:	f04f 0300 	mov.w	r3, #0
    1c92:	e008      	b.n	1ca6 <sensor_readings+0xd2>
		PSOCK_END( &s->sout );
    1c94:	f04f 0300 	mov.w	r3, #0
    1c98:	73fb      	strb	r3, [r7, #15]
    1c9a:	687b      	ldr	r3, [r7, #4]
    1c9c:	f04f 0200 	mov.w	r2, #0
    1ca0:	851a      	strh	r2, [r3, #40]	; 0x28
    1ca2:	f04f 0302 	mov.w	r3, #2
}
    1ca6:	4618      	mov	r0, r3
    1ca8:	f107 0710 	add.w	r7, r7, #16
    1cac:	46bd      	mov	sp, r7
    1cae:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
    1cb2:	bf00      	nop

00001cb4 <NVIC_init>:

/***************************************************************************//**
 * 
 */
void NVIC_init( void )
{
    1cb4:	b480      	push	{r7}
    1cb6:	af00      	add	r7, sp, #0
     * Please use SmartFusion CMSIS-PAL provided NVIC control functions.
     * The use of the Actel HAL NVIC control functions is obsolete on SmartFusion
     * devices.
     * Simply remove the call to NVIC_init() from your application code.
     */
    ASSERT(0);
    1cb8:	be00      	bkpt	0x0000
}
    1cba:	46bd      	mov	sp, r7
    1cbc:	bc80      	pop	{r7}
    1cbe:	4770      	bx	lr

00001cc0 <NVIC_set_handler>:
void NVIC_set_handler
(
    uint32_t interrupt_number,
    interrupt_handler_t handler
)
{
    1cc0:	b480      	push	{r7}
    1cc2:	b083      	sub	sp, #12
    1cc4:	af00      	add	r7, sp, #0
    1cc6:	6078      	str	r0, [r7, #4]
    1cc8:	6039      	str	r1, [r7, #0]
     * devices.
     * Please provide a function using the folowing prototype to handle interrupts
     * from peripherals implemeted in the SmartFusion FPGA fabric:
     *      void Fabric_IRQHandler( void )
     */
    ASSERT(0);
    1cca:	be00      	bkpt	0x0000
}
    1ccc:	f107 070c 	add.w	r7, r7, #12
    1cd0:	46bd      	mov	sp, r7
    1cd2:	bc80      	pop	{r7}
    1cd4:	4770      	bx	lr
    1cd6:	bf00      	nop

00001cd8 <NVIC_set_priority>:
void NVIC_set_priority
(
    uint32_t interrupt_number,
    uint8_t priority_level
)
{
    1cd8:	b480      	push	{r7}
    1cda:	b083      	sub	sp, #12
    1cdc:	af00      	add	r7, sp, #0
    1cde:	6078      	str	r0, [r7, #4]
    1ce0:	460b      	mov	r3, r1
    1ce2:	70fb      	strb	r3, [r7, #3]
     * Please replace calls to NVIC_set_priority() with a call to the CMSIS-PAL
     * void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority) function where
     * IRQn is set to Fabric_IRQn in order to set the priority of interrupts
     * generated from peripheral implemented in the SmartFusion FPGA fabric.
     */
    ASSERT(0);
    1ce4:	be00      	bkpt	0x0000
}
    1ce6:	f107 070c 	add.w	r7, r7, #12
    1cea:	46bd      	mov	sp, r7
    1cec:	bc80      	pop	{r7}
    1cee:	4770      	bx	lr

00001cf0 <NVIC_enable_interrupt>:

/***************************************************************************//**
 * 
 */
void NVIC_enable_interrupt( uint32_t interrupt_number )
{
    1cf0:	b480      	push	{r7}
    1cf2:	b083      	sub	sp, #12
    1cf4:	af00      	add	r7, sp, #0
    1cf6:	6078      	str	r0, [r7, #4]
     * Please replace calls to NVIC_enable_interrupt() with a call to the CMSIS-PAL
     * void NVIC_EnableIRQ(IRQn_Type IRQn) function where IRQn is set to
     * Fabric_IRQn in order to enable interrupts from peripheral implemented in
     * the SmartFusion FPGA fabric.
     */
    ASSERT(0);
    1cf8:	be00      	bkpt	0x0000
}
    1cfa:	f107 070c 	add.w	r7, r7, #12
    1cfe:	46bd      	mov	sp, r7
    1d00:	bc80      	pop	{r7}
    1d02:	4770      	bx	lr

00001d04 <NVIC_disable_interrupt>:

/***************************************************************************//**
 * 
 */
void NVIC_disable_interrupt( uint32_t interrupt_number )
{
    1d04:	b480      	push	{r7}
    1d06:	b083      	sub	sp, #12
    1d08:	af00      	add	r7, sp, #0
    1d0a:	6078      	str	r0, [r7, #4]
     * Please replace calls to NVIC_disable_interrupt() with a call to the CMSIS-PAL
     * void NVIC_DisableIRQ(IRQn_Type IRQn) function where IRQn is set to
     * Fabric_IRQn in order to disable interrupts from peripheral implemented in
     * the SmartFusion FPGA fabric.
     */
    ASSERT(0);
    1d0c:	be00      	bkpt	0x0000
}
    1d0e:	f107 070c 	add.w	r7, r7, #12
    1d12:	46bd      	mov	sp, r7
    1d14:	bc80      	pop	{r7}
    1d16:	4770      	bx	lr

00001d18 <NVIC_clear_interrupt>:

/***************************************************************************//**
 * 
 */
void NVIC_clear_interrupt( uint32_t interrupt_number )
{
    1d18:	b480      	push	{r7}
    1d1a:	b083      	sub	sp, #12
    1d1c:	af00      	add	r7, sp, #0
    1d1e:	6078      	str	r0, [r7, #4]
     * Please replace calls to NVIC_clear_interrupt() with a call to the CMSIS-PAL
     * void NVIC_ClearPendingIRQ(IRQn_Type IRQn) function where IRQn is set to
     * Fabric_IRQn in order to clear interrupts from peripheral implemented in
     * the SmartFusion FPGA fabric.
     */
    ASSERT(0);
    1d20:	be00      	bkpt	0x0000
}
    1d22:	f107 070c 	add.w	r7, r7, #12
    1d26:	46bd      	mov	sp, r7
    1d28:	bc80      	pop	{r7}
    1d2a:	4770      	bx	lr

00001d2c <HAL_disable_interrupts>:
    1d2c:	f3ef 8010 	mrs	r0, PRIMASK
    1d30:	b672      	cpsid	i
    1d32:	4770      	bx	lr

00001d34 <HAL_restore_interrupts>:
    1d34:	f380 8810 	msr	PRIMASK, r0
    1d38:	4770      	bx	lr
	...

00001d3c <HAL_assert_fail>:
void HAL_assert_fail
(
    const uint8_t * file_name,
    uint32_t line_no
)
{
    1d3c:	b480      	push	{r7}
    1d3e:	b087      	sub	sp, #28
    1d40:	af00      	add	r7, sp, #0
    1d42:	6078      	str	r0, [r7, #4]
    1d44:	6039      	str	r1, [r7, #0]
    while(1)
    {
        volatile const uint8_t * assert_file = file_name;
    1d46:	687b      	ldr	r3, [r7, #4]
    1d48:	617b      	str	r3, [r7, #20]
        volatile uint32_t assert_line = line_no;
    1d4a:	683b      	ldr	r3, [r7, #0]
    1d4c:	613b      	str	r3, [r7, #16]
        volatile char dummy;
		volatile uint32_t i_dummy;
		
		/* following lines to avoid compiler warnings: */
        dummy = *assert_file;
    1d4e:	697b      	ldr	r3, [r7, #20]
    1d50:	781b      	ldrb	r3, [r3, #0]
    1d52:	b2db      	uxtb	r3, r3
    1d54:	73fb      	strb	r3, [r7, #15]
		i_dummy = assert_line;
    1d56:	693b      	ldr	r3, [r7, #16]
    1d58:	60bb      	str	r3, [r7, #8]
		i_dummy++;
    1d5a:	68bb      	ldr	r3, [r7, #8]
    1d5c:	f103 0301 	add.w	r3, r3, #1
    1d60:	60bb      	str	r3, [r7, #8]
    }
    1d62:	e7f0      	b.n	1d46 <HAL_assert_fail+0xa>

00001d64 <HW_set_32bit_reg>:
    1d64:	6001      	str	r1, [r0, #0]
    1d66:	4770      	bx	lr

00001d68 <HW_get_32bit_reg>:
    1d68:	6800      	ldr	r0, [r0, #0]
    1d6a:	4770      	bx	lr

00001d6c <HW_set_32bit_reg_field>:
    1d6c:	b50e      	push	{r1, r2, r3, lr}
    1d6e:	fa03 f301 	lsl.w	r3, r3, r1
    1d72:	ea03 0302 	and.w	r3, r3, r2
    1d76:	6801      	ldr	r1, [r0, #0]
    1d78:	ea6f 0202 	mvn.w	r2, r2
    1d7c:	ea01 0102 	and.w	r1, r1, r2
    1d80:	ea41 0103 	orr.w	r1, r1, r3
    1d84:	6001      	str	r1, [r0, #0]
    1d86:	bd0e      	pop	{r1, r2, r3, pc}

00001d88 <HW_get_32bit_reg_field>:
    1d88:	6800      	ldr	r0, [r0, #0]
    1d8a:	ea00 0002 	and.w	r0, r0, r2
    1d8e:	fa20 f001 	lsr.w	r0, r0, r1
    1d92:	4770      	bx	lr

00001d94 <HW_set_16bit_reg>:
    1d94:	8001      	strh	r1, [r0, #0]
    1d96:	4770      	bx	lr

00001d98 <HW_get_16bit_reg>:
    1d98:	8800      	ldrh	r0, [r0, #0]
    1d9a:	4770      	bx	lr

00001d9c <HW_set_16bit_reg_field>:
    1d9c:	b50e      	push	{r1, r2, r3, lr}
    1d9e:	fa03 f301 	lsl.w	r3, r3, r1
    1da2:	ea03 0302 	and.w	r3, r3, r2
    1da6:	8801      	ldrh	r1, [r0, #0]
    1da8:	ea6f 0202 	mvn.w	r2, r2
    1dac:	ea01 0102 	and.w	r1, r1, r2
    1db0:	ea41 0103 	orr.w	r1, r1, r3
    1db4:	8001      	strh	r1, [r0, #0]
    1db6:	bd0e      	pop	{r1, r2, r3, pc}

00001db8 <HW_get_16bit_reg_field>:
    1db8:	8800      	ldrh	r0, [r0, #0]
    1dba:	ea00 0002 	and.w	r0, r0, r2
    1dbe:	fa20 f001 	lsr.w	r0, r0, r1
    1dc2:	4770      	bx	lr

00001dc4 <HW_set_8bit_reg>:
    1dc4:	7001      	strb	r1, [r0, #0]
    1dc6:	4770      	bx	lr

00001dc8 <HW_get_8bit_reg>:
    1dc8:	7800      	ldrb	r0, [r0, #0]
    1dca:	4770      	bx	lr

00001dcc <HW_set_8bit_reg_field>:
    1dcc:	b50e      	push	{r1, r2, r3, lr}
    1dce:	fa03 f301 	lsl.w	r3, r3, r1
    1dd2:	ea03 0302 	and.w	r3, r3, r2
    1dd6:	7801      	ldrb	r1, [r0, #0]
    1dd8:	ea6f 0202 	mvn.w	r2, r2
    1ddc:	ea01 0102 	and.w	r1, r1, r2
    1de0:	ea41 0103 	orr.w	r1, r1, r3
    1de4:	7001      	strb	r1, [r0, #0]
    1de6:	bd0e      	pop	{r1, r2, r3, pc}

00001de8 <HW_get_8bit_reg_field>:
    1de8:	7800      	ldrb	r0, [r0, #0]
    1dea:	ea00 0002 	and.w	r0, r0, r2
    1dee:	fa20 f001 	lsr.w	r0, r0, r1
    1df2:	4770      	bx	lr

00001df4 <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
    1df4:	b480      	push	{r7}
    1df6:	b083      	sub	sp, #12
    1df8:	af00      	add	r7, sp, #0
    1dfa:	4603      	mov	r3, r0
    1dfc:	80fb      	strh	r3, [r7, #6]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    1dfe:	f24e 1300 	movw	r3, #57600	; 0xe100
    1e02:	f2ce 0300 	movt	r3, #57344	; 0xe000
    1e06:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    1e0a:	ea4f 1252 	mov.w	r2, r2, lsr #5
    1e0e:	88f9      	ldrh	r1, [r7, #6]
    1e10:	f001 011f 	and.w	r1, r1, #31
    1e14:	f04f 0001 	mov.w	r0, #1
    1e18:	fa00 f101 	lsl.w	r1, r0, r1
    1e1c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    1e20:	f107 070c 	add.w	r7, r7, #12
    1e24:	46bd      	mov	sp, r7
    1e26:	bc80      	pop	{r7}
    1e28:	4770      	bx	lr
    1e2a:	bf00      	nop

00001e2c <NVIC_DisableIRQ>:
 * 
 * Disable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
    1e2c:	b480      	push	{r7}
    1e2e:	b083      	sub	sp, #12
    1e30:	af00      	add	r7, sp, #0
    1e32:	4603      	mov	r3, r0
    1e34:	80fb      	strh	r3, [r7, #6]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
    1e36:	f24e 1300 	movw	r3, #57600	; 0xe100
    1e3a:	f2ce 0300 	movt	r3, #57344	; 0xe000
    1e3e:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    1e42:	ea4f 1252 	mov.w	r2, r2, lsr #5
    1e46:	88f9      	ldrh	r1, [r7, #6]
    1e48:	f001 011f 	and.w	r1, r1, #31
    1e4c:	f04f 0001 	mov.w	r0, #1
    1e50:	fa00 f101 	lsl.w	r1, r0, r1
    1e54:	f102 0220 	add.w	r2, r2, #32
    1e58:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    1e5c:	f107 070c 	add.w	r7, r7, #12
    1e60:	46bd      	mov	sp, r7
    1e62:	bc80      	pop	{r7}
    1e64:	4770      	bx	lr
    1e66:	bf00      	nop

00001e68 <NVIC_ClearPendingIRQ>:
 *
 * Clear the pending bit for the specified interrupt. 
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
    1e68:	b480      	push	{r7}
    1e6a:	b083      	sub	sp, #12
    1e6c:	af00      	add	r7, sp, #0
    1e6e:	4603      	mov	r3, r0
    1e70:	80fb      	strh	r3, [r7, #6]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    1e72:	f24e 1300 	movw	r3, #57600	; 0xe100
    1e76:	f2ce 0300 	movt	r3, #57344	; 0xe000
    1e7a:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    1e7e:	ea4f 1252 	mov.w	r2, r2, lsr #5
    1e82:	88f9      	ldrh	r1, [r7, #6]
    1e84:	f001 011f 	and.w	r1, r1, #31
    1e88:	f04f 0001 	mov.w	r0, #1
    1e8c:	fa00 f101 	lsl.w	r1, r0, r1
    1e90:	f102 0260 	add.w	r2, r2, #96	; 0x60
    1e94:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    1e98:	f107 070c 	add.w	r7, r7, #12
    1e9c:	46bd      	mov	sp, r7
    1e9e:	bc80      	pop	{r7}
    1ea0:	4770      	bx	lr
    1ea2:	bf00      	nop

00001ea4 <MSS_UART_init>:
(
    mss_uart_instance_t* this_uart,
    uint32_t baud_rate,
    uint8_t line_config
)
{
    1ea4:	b580      	push	{r7, lr}
    1ea6:	b088      	sub	sp, #32
    1ea8:	af00      	add	r7, sp, #0
    1eaa:	60f8      	str	r0, [r7, #12]
    1eac:	60b9      	str	r1, [r7, #8]
    1eae:	4613      	mov	r3, r2
    1eb0:	71fb      	strb	r3, [r7, #7]
    uint16_t baud_value = 1U;
    1eb2:	f04f 0301 	mov.w	r3, #1
    1eb6:	82fb      	strh	r3, [r7, #22]
    uint32_t pclk_freq = 0U;
    1eb8:	f04f 0300 	mov.w	r3, #0
    1ebc:	61bb      	str	r3, [r7, #24]
    uint32_t baud_value_l;

    /* The driver expects g_mss_uart0 and g_mss_uart1 to be the only
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    1ebe:	68fa      	ldr	r2, [r7, #12]
    1ec0:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    1ec4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1ec8:	429a      	cmp	r2, r3
    1eca:	d007      	beq.n	1edc <MSS_UART_init+0x38>
    1ecc:	68fa      	ldr	r2, [r7, #12]
    1ece:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    1ed2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1ed6:	429a      	cmp	r2, r3
    1ed8:	d000      	beq.n	1edc <MSS_UART_init+0x38>
    1eda:	be00      	bkpt	0x0000

    /* baud_rate should be greater than 0 */
    ASSERT( 0U < baud_rate );
    1edc:	68bb      	ldr	r3, [r7, #8]
    1ede:	2b00      	cmp	r3, #0
    1ee0:	d100      	bne.n	1ee4 <MSS_UART_init+0x40>
    1ee2:	be00      	bkpt	0x0000

    /* Force the value of the CMSIS global variables holding the various system
     * clock frequencies to be updated. */
    SystemCoreClockUpdate();
    1ee4:	f008 fa26 	bl	a334 <SystemCoreClockUpdate>

    if ( this_uart == &g_mss_uart0 )
    1ee8:	68fa      	ldr	r2, [r7, #12]
    1eea:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    1eee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1ef2:	429a      	cmp	r2, r3
    1ef4:	d12e      	bne.n	1f54 <MSS_UART_init+0xb0>
    {
        this_uart->hw_reg = UART0;
    1ef6:	68fb      	ldr	r3, [r7, #12]
    1ef8:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    1efc:	601a      	str	r2, [r3, #0]
        this_uart->hw_reg_bit = UART0_BITBAND;
    1efe:	68fb      	ldr	r3, [r7, #12]
    1f00:	f04f 4284 	mov.w	r2, #1107296256	; 0x42000000
    1f04:	605a      	str	r2, [r3, #4]
        this_uart->irqn = UART0_IRQn;
    1f06:	68fb      	ldr	r3, [r7, #12]
    1f08:	f04f 020a 	mov.w	r2, #10
    1f0c:	811a      	strh	r2, [r3, #8]

        pclk_freq = g_FrequencyPCLK0;
    1f0e:	f240 03f0 	movw	r3, #240	; 0xf0
    1f12:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1f16:	681b      	ldr	r3, [r3, #0]
    1f18:	61bb      	str	r3, [r7, #24]

        /* reset UART0 */
        SYSREG->SOFT_RST_CR |= SYSREG_UART0_SOFTRESET_MASK;
    1f1a:	f242 0300 	movw	r3, #8192	; 0x2000
    1f1e:	f2ce 0304 	movt	r3, #57348	; 0xe004
    1f22:	f242 0200 	movw	r2, #8192	; 0x2000
    1f26:	f2ce 0204 	movt	r2, #57348	; 0xe004
    1f2a:	6b12      	ldr	r2, [r2, #48]	; 0x30
    1f2c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    1f30:	631a      	str	r2, [r3, #48]	; 0x30
        /* Clear any previously pended UART0 interrupt */
        NVIC_ClearPendingIRQ( UART0_IRQn );
    1f32:	f04f 000a 	mov.w	r0, #10
    1f36:	f7ff ff97 	bl	1e68 <NVIC_ClearPendingIRQ>
        /* Take UART0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_UART0_SOFTRESET_MASK;
    1f3a:	f242 0300 	movw	r3, #8192	; 0x2000
    1f3e:	f2ce 0304 	movt	r3, #57348	; 0xe004
    1f42:	f242 0200 	movw	r2, #8192	; 0x2000
    1f46:	f2ce 0204 	movt	r2, #57348	; 0xe004
    1f4a:	6b12      	ldr	r2, [r2, #48]	; 0x30
    1f4c:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    1f50:	631a      	str	r2, [r3, #48]	; 0x30
    1f52:	e031      	b.n	1fb8 <MSS_UART_init+0x114>
    }
    else
    {
        this_uart->hw_reg = UART1;
    1f54:	68fa      	ldr	r2, [r7, #12]
    1f56:	f240 0300 	movw	r3, #0
    1f5a:	f2c4 0301 	movt	r3, #16385	; 0x4001
    1f5e:	6013      	str	r3, [r2, #0]
        this_uart->hw_reg_bit = UART1_BITBAND;
    1f60:	68fa      	ldr	r2, [r7, #12]
    1f62:	f240 0300 	movw	r3, #0
    1f66:	f2c4 2320 	movt	r3, #16928	; 0x4220
    1f6a:	6053      	str	r3, [r2, #4]
        this_uart->irqn = UART1_IRQn;
    1f6c:	68fb      	ldr	r3, [r7, #12]
    1f6e:	f04f 020b 	mov.w	r2, #11
    1f72:	811a      	strh	r2, [r3, #8]

        pclk_freq = g_FrequencyPCLK1;
    1f74:	f240 03f4 	movw	r3, #244	; 0xf4
    1f78:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1f7c:	681b      	ldr	r3, [r3, #0]
    1f7e:	61bb      	str	r3, [r7, #24]

        /* Reset UART1 */
        SYSREG->SOFT_RST_CR |= SYSREG_UART1_SOFTRESET_MASK;
    1f80:	f242 0300 	movw	r3, #8192	; 0x2000
    1f84:	f2ce 0304 	movt	r3, #57348	; 0xe004
    1f88:	f242 0200 	movw	r2, #8192	; 0x2000
    1f8c:	f2ce 0204 	movt	r2, #57348	; 0xe004
    1f90:	6b12      	ldr	r2, [r2, #48]	; 0x30
    1f92:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    1f96:	631a      	str	r2, [r3, #48]	; 0x30
        /* Clear any previously pended UART1 interrupt */
        NVIC_ClearPendingIRQ( UART1_IRQn );
    1f98:	f04f 000b 	mov.w	r0, #11
    1f9c:	f7ff ff64 	bl	1e68 <NVIC_ClearPendingIRQ>
        /* Take UART1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_UART1_SOFTRESET_MASK;
    1fa0:	f242 0300 	movw	r3, #8192	; 0x2000
    1fa4:	f2ce 0304 	movt	r3, #57348	; 0xe004
    1fa8:	f242 0200 	movw	r2, #8192	; 0x2000
    1fac:	f2ce 0204 	movt	r2, #57348	; 0xe004
    1fb0:	6b12      	ldr	r2, [r2, #48]	; 0x30
    1fb2:	f422 7280 	bic.w	r2, r2, #256	; 0x100
    1fb6:	631a      	str	r2, [r3, #48]	; 0x30
    }

    /* disable interrupts */
    this_uart->hw_reg->IER = 0U;
    1fb8:	68fb      	ldr	r3, [r7, #12]
    1fba:	681b      	ldr	r3, [r3, #0]
    1fbc:	f04f 0200 	mov.w	r2, #0
    1fc0:	711a      	strb	r2, [r3, #4]
     * The baud value is computed using the following equation:
     *      baud_value_l = PCLK_Frequency / (baud_rate * 16)
     * The baud value is rounded up or down depending on what would be the remainder
     * of the divide by 16 operation.
     */
    if( 0U < baud_rate )
    1fc2:	68bb      	ldr	r3, [r7, #8]
    1fc4:	2b00      	cmp	r3, #0
    1fc6:	d021      	beq.n	200c <MAIN_STACK_SIZE+0xc>
    {
        baud_value_l = (uint32_t)(pclk_freq / baud_rate);
    1fc8:	69ba      	ldr	r2, [r7, #24]
    1fca:	68bb      	ldr	r3, [r7, #8]
    1fcc:	fbb2 f3f3 	udiv	r3, r2, r3
    1fd0:	61fb      	str	r3, [r7, #28]
        if( baud_value_l & 0x00000008U )
    1fd2:	69fb      	ldr	r3, [r7, #28]
    1fd4:	f003 0308 	and.w	r3, r3, #8
    1fd8:	2b00      	cmp	r3, #0
    1fda:	d006      	beq.n	1fea <MSS_UART_init+0x146>
        {
            /* remainder above 0.5 */
            baud_value_l = (baud_value_l >> 4U) + 1U;        
    1fdc:	69fb      	ldr	r3, [r7, #28]
    1fde:	ea4f 1313 	mov.w	r3, r3, lsr #4
    1fe2:	f103 0301 	add.w	r3, r3, #1
    1fe6:	61fb      	str	r3, [r7, #28]
    1fe8:	e003      	b.n	1ff2 <MSS_UART_init+0x14e>
        }
        else
        {
            /* remainder below 0.5 */
            baud_value_l = (baud_value_l >> 4U);
    1fea:	69fb      	ldr	r3, [r7, #28]
    1fec:	ea4f 1313 	mov.w	r3, r3, lsr #4
    1ff0:	61fb      	str	r3, [r7, #28]
        }
    
        /* Check if the baud rate is supported by the PCLK */
        ASSERT( baud_value_l <= UINT16_MAX);
    1ff2:	69fa      	ldr	r2, [r7, #28]
    1ff4:	f64f 73ff 	movw	r3, #65535	; 0xffff
    1ff8:	429a      	cmp	r2, r3
    1ffa:	d900      	bls.n	1ffe <MSS_UART_init+0x15a>
    1ffc:	be00      	bkpt	0x0000
        if( baud_value_l <= (uint32_t)UINT16_MAX)
    1ffe:	69fa      	ldr	r2, [r7, #28]
    2000:	f64f 73ff 	movw	r3, #65535	; 0xffff
    2004:	429a      	cmp	r2, r3
    2006:	d801      	bhi.n	200c <MAIN_STACK_SIZE+0xc>
        {
            baud_value = (uint16_t)baud_value_l;
    2008:	69fb      	ldr	r3, [r7, #28]
    200a:	82fb      	strh	r3, [r7, #22]
        }
    }
    
    /* set divisor latch */
    this_uart->hw_reg_bit->LCR_DLAB = (uint32_t)1;
    200c:	68fb      	ldr	r3, [r7, #12]
    200e:	685b      	ldr	r3, [r3, #4]
    2010:	f04f 0201 	mov.w	r2, #1
    2014:	f8c3 219c 	str.w	r2, [r3, #412]	; 0x19c

    /* msb of baud value */
    this_uart->hw_reg->DMR = (uint8_t)(baud_value >> 8);
    2018:	68fb      	ldr	r3, [r7, #12]
    201a:	681b      	ldr	r3, [r3, #0]
    201c:	8afa      	ldrh	r2, [r7, #22]
    201e:	ea4f 2212 	mov.w	r2, r2, lsr #8
    2022:	b292      	uxth	r2, r2
    2024:	b2d2      	uxtb	r2, r2
    2026:	711a      	strb	r2, [r3, #4]
    /* lsb of baud value */
    this_uart->hw_reg->DLR = (uint8_t)baud_value;
    2028:	68fb      	ldr	r3, [r7, #12]
    202a:	681b      	ldr	r3, [r3, #0]
    202c:	8afa      	ldrh	r2, [r7, #22]
    202e:	b2d2      	uxtb	r2, r2
    2030:	701a      	strb	r2, [r3, #0]

    /* reset divisor latch */
    this_uart->hw_reg_bit->LCR_DLAB = (uint32_t)0;
    2032:	68fb      	ldr	r3, [r7, #12]
    2034:	685b      	ldr	r3, [r3, #4]
    2036:	f04f 0200 	mov.w	r2, #0
    203a:	f8c3 219c 	str.w	r2, [r3, #412]	; 0x19c

    /* set the line control register (bit length, stop bits, parity) */
    this_uart->hw_reg->LCR = line_config;
    203e:	68fb      	ldr	r3, [r7, #12]
    2040:	681b      	ldr	r3, [r3, #0]
    2042:	79fa      	ldrb	r2, [r7, #7]
    2044:	731a      	strb	r2, [r3, #12]

    /* FIFO configuration */
    /* RX FIFO length = 1 byte, clear receiver FIFO, 
       clear transmitter FIFO, enable RXRDYN and TXRDYN pins. */
    this_uart->hw_reg->FCR = (uint8_t)MSS_UART_FIFO_SINGLE_BYTE | 
    2046:	68fb      	ldr	r3, [r7, #12]
    2048:	681b      	ldr	r3, [r3, #0]
    204a:	f04f 020e 	mov.w	r2, #14
    204e:	721a      	strb	r2, [r3, #8]
                              FCR_CLEAR_RX_FIFO_MASK | FCR_CLEAR_TX_FIFO_MASK | 
                              FCR_ENABLE_TXRDY_RXRDY_MASK;
    /* disable loopback */
    this_uart->hw_reg_bit->MCR_LOOP = (uint32_t)0;
    2050:	68fb      	ldr	r3, [r7, #12]
    2052:	685b      	ldr	r3, [r3, #4]
    2054:	f04f 0200 	mov.w	r2, #0
    2058:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210

    /* Instance setup */
    this_uart->tx_buff_size = TX_COMPLETE;
    205c:	68fb      	ldr	r3, [r7, #12]
    205e:	f04f 0200 	mov.w	r2, #0
    2062:	611a      	str	r2, [r3, #16]
    this_uart->tx_buffer = (const uint8_t *)0;
    2064:	68fb      	ldr	r3, [r7, #12]
    2066:	f04f 0200 	mov.w	r2, #0
    206a:	60da      	str	r2, [r3, #12]
    this_uart->tx_idx = 0U;
    206c:	68fb      	ldr	r3, [r7, #12]
    206e:	f04f 0200 	mov.w	r2, #0
    2072:	615a      	str	r2, [r3, #20]

    /* Default handlers for MSS UART interrupts */
    this_uart->rx_handler       = NULL_HANDLER;
    2074:	68fb      	ldr	r3, [r7, #12]
    2076:	f04f 0200 	mov.w	r2, #0
    207a:	61da      	str	r2, [r3, #28]
    this_uart->tx_handler       = default_tx_handler;
    207c:	68fa      	ldr	r2, [r7, #12]
    207e:	f242 6399 	movw	r3, #9881	; 0x2699
    2082:	f2c0 0300 	movt	r3, #0
    2086:	6213      	str	r3, [r2, #32]
    this_uart->linests_handler  = NULL_HANDLER;
    2088:	68fb      	ldr	r3, [r7, #12]
    208a:	f04f 0200 	mov.w	r2, #0
    208e:	619a      	str	r2, [r3, #24]
    this_uart->modemsts_handler = NULL_HANDLER;
    2090:	68fb      	ldr	r3, [r7, #12]
    2092:	f04f 0200 	mov.w	r2, #0
    2096:	625a      	str	r2, [r3, #36]	; 0x24

    /* Initialize the sticky status */
    this_uart->status = 0U;
    2098:	68fb      	ldr	r3, [r7, #12]
    209a:	f04f 0200 	mov.w	r2, #0
    209e:	729a      	strb	r2, [r3, #10]
}
    20a0:	f107 0720 	add.w	r7, r7, #32
    20a4:	46bd      	mov	sp, r7
    20a6:	bd80      	pop	{r7, pc}

000020a8 <MSS_UART_polled_tx>:
(
    mss_uart_instance_t * this_uart,
    const uint8_t * pbuff,
    uint32_t tx_size
)
{
    20a8:	b480      	push	{r7}
    20aa:	b089      	sub	sp, #36	; 0x24
    20ac:	af00      	add	r7, sp, #0
    20ae:	60f8      	str	r0, [r7, #12]
    20b0:	60b9      	str	r1, [r7, #8]
    20b2:	607a      	str	r2, [r7, #4]
    uint32_t char_idx = 0U;
    20b4:	f04f 0300 	mov.w	r3, #0
    20b8:	613b      	str	r3, [r7, #16]
    uint32_t size_sent;
    uint8_t status;

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    20ba:	68fa      	ldr	r2, [r7, #12]
    20bc:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    20c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    20c4:	429a      	cmp	r2, r3
    20c6:	d007      	beq.n	20d8 <MSS_UART_polled_tx+0x30>
    20c8:	68fa      	ldr	r2, [r7, #12]
    20ca:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    20ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    20d2:	429a      	cmp	r2, r3
    20d4:	d000      	beq.n	20d8 <MSS_UART_polled_tx+0x30>
    20d6:	be00      	bkpt	0x0000
    ASSERT( pbuff != ( (uint8_t *)0 ) );
    20d8:	68bb      	ldr	r3, [r7, #8]
    20da:	2b00      	cmp	r3, #0
    20dc:	d100      	bne.n	20e0 <MSS_UART_polled_tx+0x38>
    20de:	be00      	bkpt	0x0000
    ASSERT( tx_size > 0U );
    20e0:	687b      	ldr	r3, [r7, #4]
    20e2:	2b00      	cmp	r3, #0
    20e4:	d100      	bne.n	20e8 <MSS_UART_polled_tx+0x40>
    20e6:	be00      	bkpt	0x0000

    if( ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) ) &&
    20e8:	68fa      	ldr	r2, [r7, #12]
    20ea:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    20ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    20f2:	429a      	cmp	r2, r3
    20f4:	d006      	beq.n	2104 <MSS_UART_polled_tx+0x5c>
    20f6:	68fa      	ldr	r2, [r7, #12]
    20f8:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    20fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2100:	429a      	cmp	r2, r3
    2102:	d13d      	bne.n	2180 <MSS_UART_polled_tx+0xd8>
    2104:	68bb      	ldr	r3, [r7, #8]
    2106:	2b00      	cmp	r3, #0
    2108:	d03a      	beq.n	2180 <MSS_UART_polled_tx+0xd8>
    210a:	687b      	ldr	r3, [r7, #4]
    210c:	2b00      	cmp	r3, #0
    210e:	d037      	beq.n	2180 <MSS_UART_polled_tx+0xd8>
         /* Remain in this loop until the entire input buffer
          * has been transferred to the UART.
          */
        do {
            /* Read the Line Status Register and update the sticky record */
            status = this_uart->hw_reg->LSR;
    2110:	68fb      	ldr	r3, [r7, #12]
    2112:	681b      	ldr	r3, [r3, #0]
    2114:	7d1b      	ldrb	r3, [r3, #20]
    2116:	76fb      	strb	r3, [r7, #27]
            this_uart->status |= status;
    2118:	68fb      	ldr	r3, [r7, #12]
    211a:	7a9a      	ldrb	r2, [r3, #10]
    211c:	7efb      	ldrb	r3, [r7, #27]
    211e:	ea42 0303 	orr.w	r3, r2, r3
    2122:	b2da      	uxtb	r2, r3
    2124:	68fb      	ldr	r3, [r7, #12]
    2126:	729a      	strb	r2, [r3, #10]

            /* Check if TX FIFO is empty. */
            if( status & MSS_UART_THRE )
    2128:	7efb      	ldrb	r3, [r7, #27]
    212a:	f003 0320 	and.w	r3, r3, #32
    212e:	2b00      	cmp	r3, #0
    2130:	d023      	beq.n	217a <MSS_UART_polled_tx+0xd2>
            {
                uint32_t fill_size = TX_FIFO_SIZE;
    2132:	f04f 0310 	mov.w	r3, #16
    2136:	61fb      	str	r3, [r7, #28]

                /* Calculate the number of bytes to transmit. */
                if ( tx_size < TX_FIFO_SIZE )
    2138:	687b      	ldr	r3, [r7, #4]
    213a:	2b0f      	cmp	r3, #15
    213c:	d801      	bhi.n	2142 <MSS_UART_polled_tx+0x9a>
                {
                    fill_size = tx_size;
    213e:	687b      	ldr	r3, [r7, #4]
    2140:	61fb      	str	r3, [r7, #28]
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for ( size_sent = 0U; size_sent < fill_size; ++size_sent )
    2142:	f04f 0300 	mov.w	r3, #0
    2146:	617b      	str	r3, [r7, #20]
    2148:	e00e      	b.n	2168 <MSS_UART_polled_tx+0xc0>
                {
                    /* Send next character in the buffer. */
                    this_uart->hw_reg->THR = pbuff[char_idx++];
    214a:	68fb      	ldr	r3, [r7, #12]
    214c:	681b      	ldr	r3, [r3, #0]
    214e:	68b9      	ldr	r1, [r7, #8]
    2150:	693a      	ldr	r2, [r7, #16]
    2152:	440a      	add	r2, r1
    2154:	7812      	ldrb	r2, [r2, #0]
    2156:	701a      	strb	r2, [r3, #0]
    2158:	693b      	ldr	r3, [r7, #16]
    215a:	f103 0301 	add.w	r3, r3, #1
    215e:	613b      	str	r3, [r7, #16]
                {
                    fill_size = tx_size;
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for ( size_sent = 0U; size_sent < fill_size; ++size_sent )
    2160:	697b      	ldr	r3, [r7, #20]
    2162:	f103 0301 	add.w	r3, r3, #1
    2166:	617b      	str	r3, [r7, #20]
    2168:	697a      	ldr	r2, [r7, #20]
    216a:	69fb      	ldr	r3, [r7, #28]
    216c:	429a      	cmp	r2, r3
    216e:	d3ec      	bcc.n	214a <MSS_UART_polled_tx+0xa2>
                    /* Send next character in the buffer. */
                    this_uart->hw_reg->THR = pbuff[char_idx++];
                }

                /* Calculate the number of untransmitted bytes remaining. */
                tx_size -= size_sent;
    2170:	687a      	ldr	r2, [r7, #4]
    2172:	697b      	ldr	r3, [r7, #20]
    2174:	ebc3 0302 	rsb	r3, r3, r2
    2178:	607b      	str	r3, [r7, #4]
            }
        }while( tx_size );
    217a:	687b      	ldr	r3, [r7, #4]
    217c:	2b00      	cmp	r3, #0
    217e:	d1c7      	bne.n	2110 <MSS_UART_polled_tx+0x68>
    }
}
    2180:	f107 0724 	add.w	r7, r7, #36	; 0x24
    2184:	46bd      	mov	sp, r7
    2186:	bc80      	pop	{r7}
    2188:	4770      	bx	lr
    218a:	bf00      	nop

0000218c <MSS_UART_polled_tx_string>:
MSS_UART_polled_tx_string
(
    mss_uart_instance_t * this_uart,
    const uint8_t * p_sz_string
)
{
    218c:	b480      	push	{r7}
    218e:	b087      	sub	sp, #28
    2190:	af00      	add	r7, sp, #0
    2192:	6078      	str	r0, [r7, #4]
    2194:	6039      	str	r1, [r7, #0]
    uint32_t char_idx = 0U;
    2196:	f04f 0300 	mov.w	r3, #0
    219a:	60bb      	str	r3, [r7, #8]
    uint32_t fill_size;
    uint_fast8_t data_byte;
    uint8_t status;

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    219c:	687a      	ldr	r2, [r7, #4]
    219e:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    21a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    21a6:	429a      	cmp	r2, r3
    21a8:	d007      	beq.n	21ba <MSS_UART_polled_tx_string+0x2e>
    21aa:	687a      	ldr	r2, [r7, #4]
    21ac:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    21b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    21b4:	429a      	cmp	r2, r3
    21b6:	d000      	beq.n	21ba <MSS_UART_polled_tx_string+0x2e>
    21b8:	be00      	bkpt	0x0000
    ASSERT( p_sz_string != ( (uint8_t *)0 ) );
    21ba:	683b      	ldr	r3, [r7, #0]
    21bc:	2b00      	cmp	r3, #0
    21be:	d100      	bne.n	21c2 <MSS_UART_polled_tx_string+0x36>
    21c0:	be00      	bkpt	0x0000

    if( ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) ) &&
    21c2:	687a      	ldr	r2, [r7, #4]
    21c4:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    21c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    21cc:	429a      	cmp	r2, r3
    21ce:	d006      	beq.n	21de <MSS_UART_polled_tx_string+0x52>
    21d0:	687a      	ldr	r2, [r7, #4]
    21d2:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    21d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    21da:	429a      	cmp	r2, r3
    21dc:	d138      	bne.n	2250 <MSS_UART_polled_tx_string+0xc4>
    21de:	683b      	ldr	r3, [r7, #0]
    21e0:	2b00      	cmp	r3, #0
    21e2:	d035      	beq.n	2250 <MSS_UART_polled_tx_string+0xc4>
          ( p_sz_string != ( (uint8_t *)0 ) ) )
    {
        /* Get the first data byte from the input buffer */
        data_byte = (uint_fast8_t)p_sz_string[char_idx];
    21e4:	683a      	ldr	r2, [r7, #0]
    21e6:	68bb      	ldr	r3, [r7, #8]
    21e8:	4413      	add	r3, r2
    21ea:	781b      	ldrb	r3, [r3, #0]
    21ec:	613b      	str	r3, [r7, #16]

        /* First check for the NULL terminator byte.
         * Then remain in this loop until the entire string in the input buffer
         * has been transferred to the UART.
         */
        while ( 0U != data_byte )
    21ee:	e02c      	b.n	224a <MSS_UART_polled_tx_string+0xbe>
        {
            /* Wait until TX FIFO is empty. */
            do {
                status = this_uart->hw_reg->LSR;
    21f0:	687b      	ldr	r3, [r7, #4]
    21f2:	681b      	ldr	r3, [r3, #0]
    21f4:	7d1b      	ldrb	r3, [r3, #20]
    21f6:	75fb      	strb	r3, [r7, #23]
                this_uart->status |= status;
    21f8:	687b      	ldr	r3, [r7, #4]
    21fa:	7a9a      	ldrb	r2, [r3, #10]
    21fc:	7dfb      	ldrb	r3, [r7, #23]
    21fe:	ea42 0303 	orr.w	r3, r2, r3
    2202:	b2da      	uxtb	r2, r3
    2204:	687b      	ldr	r3, [r7, #4]
    2206:	729a      	strb	r2, [r3, #10]
            } while ( !( status & MSS_UART_THRE ) );
    2208:	7dfb      	ldrb	r3, [r7, #23]
    220a:	f003 0320 	and.w	r3, r3, #32
    220e:	2b00      	cmp	r3, #0
    2210:	d0ee      	beq.n	21f0 <MSS_UART_polled_tx_string+0x64>

            /* Send bytes from the input buffer until the TX FIFO is full
             * or we reach the NULL terminator byte.
             */
            fill_size = 0U;
    2212:	f04f 0300 	mov.w	r3, #0
    2216:	60fb      	str	r3, [r7, #12]
            while ( (0U != data_byte) && (fill_size < TX_FIFO_SIZE) )
    2218:	e011      	b.n	223e <MSS_UART_polled_tx_string+0xb2>
            {
                /* Send the data byte */
                this_uart->hw_reg->THR = data_byte;
    221a:	687b      	ldr	r3, [r7, #4]
    221c:	681b      	ldr	r3, [r3, #0]
    221e:	693a      	ldr	r2, [r7, #16]
    2220:	b2d2      	uxtb	r2, r2
    2222:	701a      	strb	r2, [r3, #0]
                ++fill_size;
    2224:	68fb      	ldr	r3, [r7, #12]
    2226:	f103 0301 	add.w	r3, r3, #1
    222a:	60fb      	str	r3, [r7, #12]
                char_idx++;
    222c:	68bb      	ldr	r3, [r7, #8]
    222e:	f103 0301 	add.w	r3, r3, #1
    2232:	60bb      	str	r3, [r7, #8]
                /* Get the next data byte from the input buffer */
                data_byte = (uint_fast8_t)p_sz_string[char_idx];
    2234:	683a      	ldr	r2, [r7, #0]
    2236:	68bb      	ldr	r3, [r7, #8]
    2238:	4413      	add	r3, r2
    223a:	781b      	ldrb	r3, [r3, #0]
    223c:	613b      	str	r3, [r7, #16]

            /* Send bytes from the input buffer until the TX FIFO is full
             * or we reach the NULL terminator byte.
             */
            fill_size = 0U;
            while ( (0U != data_byte) && (fill_size < TX_FIFO_SIZE) )
    223e:	693b      	ldr	r3, [r7, #16]
    2240:	2b00      	cmp	r3, #0
    2242:	d002      	beq.n	224a <MSS_UART_polled_tx_string+0xbe>
    2244:	68fb      	ldr	r3, [r7, #12]
    2246:	2b0f      	cmp	r3, #15
    2248:	d9e7      	bls.n	221a <MSS_UART_polled_tx_string+0x8e>

        /* First check for the NULL terminator byte.
         * Then remain in this loop until the entire string in the input buffer
         * has been transferred to the UART.
         */
        while ( 0U != data_byte )
    224a:	693b      	ldr	r3, [r7, #16]
    224c:	2b00      	cmp	r3, #0
    224e:	d1cf      	bne.n	21f0 <MSS_UART_polled_tx_string+0x64>
                /* Get the next data byte from the input buffer */
                data_byte = (uint_fast8_t)p_sz_string[char_idx];
            }
        }
    }
}
    2250:	f107 071c 	add.w	r7, r7, #28
    2254:	46bd      	mov	sp, r7
    2256:	bc80      	pop	{r7}
    2258:	4770      	bx	lr
    225a:	bf00      	nop

0000225c <MSS_UART_irq_tx>:
(
    mss_uart_instance_t * this_uart,
    const uint8_t * pbuff,
    uint32_t tx_size
)
{
    225c:	b580      	push	{r7, lr}
    225e:	b084      	sub	sp, #16
    2260:	af00      	add	r7, sp, #0
    2262:	60f8      	str	r0, [r7, #12]
    2264:	60b9      	str	r1, [r7, #8]
    2266:	607a      	str	r2, [r7, #4]
    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    2268:	68fa      	ldr	r2, [r7, #12]
    226a:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    226e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2272:	429a      	cmp	r2, r3
    2274:	d007      	beq.n	2286 <MSS_UART_irq_tx+0x2a>
    2276:	68fa      	ldr	r2, [r7, #12]
    2278:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    227c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2280:	429a      	cmp	r2, r3
    2282:	d000      	beq.n	2286 <MSS_UART_irq_tx+0x2a>
    2284:	be00      	bkpt	0x0000
    ASSERT( pbuff != ((uint8_t *)0) );
    2286:	68bb      	ldr	r3, [r7, #8]
    2288:	2b00      	cmp	r3, #0
    228a:	d100      	bne.n	228e <MSS_UART_irq_tx+0x32>
    228c:	be00      	bkpt	0x0000
    ASSERT( tx_size > 0U );
    228e:	687b      	ldr	r3, [r7, #4]
    2290:	2b00      	cmp	r3, #0
    2292:	d100      	bne.n	2296 <MSS_UART_irq_tx+0x3a>
    2294:	be00      	bkpt	0x0000

    if ( ( tx_size > 0U ) && ( pbuff != ((uint8_t *)0) ) &&
    2296:	687b      	ldr	r3, [r7, #4]
    2298:	2b00      	cmp	r3, #0
    229a:	d032      	beq.n	2302 <MSS_UART_irq_tx+0xa6>
    229c:	68bb      	ldr	r3, [r7, #8]
    229e:	2b00      	cmp	r3, #0
    22a0:	d02f      	beq.n	2302 <MSS_UART_irq_tx+0xa6>
       ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) ) )
    22a2:	68fa      	ldr	r2, [r7, #12]
    22a4:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    22a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    22ac:	429a      	cmp	r2, r3
    22ae:	d006      	beq.n	22be <MSS_UART_irq_tx+0x62>
    22b0:	68fa      	ldr	r2, [r7, #12]
    22b2:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    22b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    22ba:	429a      	cmp	r2, r3
    22bc:	d121      	bne.n	2302 <MSS_UART_irq_tx+0xa6>
    {
        /*Initialise the transmit info for the UART instance with the arguments.*/
        this_uart->tx_buffer = pbuff;
    22be:	68fb      	ldr	r3, [r7, #12]
    22c0:	68ba      	ldr	r2, [r7, #8]
    22c2:	60da      	str	r2, [r3, #12]
        this_uart->tx_buff_size = tx_size;
    22c4:	68fb      	ldr	r3, [r7, #12]
    22c6:	687a      	ldr	r2, [r7, #4]
    22c8:	611a      	str	r2, [r3, #16]
        this_uart->tx_idx = (uint16_t)0;
    22ca:	68fb      	ldr	r3, [r7, #12]
    22cc:	f04f 0200 	mov.w	r2, #0
    22d0:	615a      	str	r2, [r3, #20]

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ( this_uart->irqn );
    22d2:	68fb      	ldr	r3, [r7, #12]
    22d4:	891b      	ldrh	r3, [r3, #8]
    22d6:	b21b      	sxth	r3, r3
    22d8:	4618      	mov	r0, r3
    22da:	f7ff fdc5 	bl	1e68 <NVIC_ClearPendingIRQ>

        /* assign default handler for data transfer */
        this_uart->tx_handler = default_tx_handler;
    22de:	68fa      	ldr	r2, [r7, #12]
    22e0:	f242 6399 	movw	r3, #9881	; 0x2699
    22e4:	f2c0 0300 	movt	r3, #0
    22e8:	6213      	str	r3, [r2, #32]

        /* enables TX interrupt */
        this_uart->hw_reg_bit->IER_ETBEI = (uint32_t)1;
    22ea:	68fb      	ldr	r3, [r7, #12]
    22ec:	685b      	ldr	r3, [r3, #4]
    22ee:	f04f 0201 	mov.w	r2, #1
    22f2:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

        /* Enable UART instance interrupt in Cortex-M3 NVIC. */
        NVIC_EnableIRQ( this_uart->irqn );
    22f6:	68fb      	ldr	r3, [r7, #12]
    22f8:	891b      	ldrh	r3, [r3, #8]
    22fa:	b21b      	sxth	r3, r3
    22fc:	4618      	mov	r0, r3
    22fe:	f7ff fd79 	bl	1df4 <NVIC_EnableIRQ>
    }
}
    2302:	f107 0710 	add.w	r7, r7, #16
    2306:	46bd      	mov	sp, r7
    2308:	bd80      	pop	{r7, pc}
    230a:	bf00      	nop

0000230c <MSS_UART_tx_complete>:
int8_t
MSS_UART_tx_complete
(
    mss_uart_instance_t * this_uart
)
{
    230c:	b480      	push	{r7}
    230e:	b085      	sub	sp, #20
    2310:	af00      	add	r7, sp, #0
    2312:	6078      	str	r0, [r7, #4]
    int8_t ret_value = 0;
    2314:	f04f 0300 	mov.w	r3, #0
    2318:	73bb      	strb	r3, [r7, #14]
    uint8_t status = 0U;
    231a:	f04f 0300 	mov.w	r3, #0
    231e:	73fb      	strb	r3, [r7, #15]

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    2320:	687a      	ldr	r2, [r7, #4]
    2322:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    2326:	f2c2 0300 	movt	r3, #8192	; 0x2000
    232a:	429a      	cmp	r2, r3
    232c:	d007      	beq.n	233e <MSS_UART_tx_complete+0x32>
    232e:	687a      	ldr	r2, [r7, #4]
    2330:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    2334:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2338:	429a      	cmp	r2, r3
    233a:	d000      	beq.n	233e <MSS_UART_tx_complete+0x32>
    233c:	be00      	bkpt	0x0000

    if ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) )
    233e:	687a      	ldr	r2, [r7, #4]
    2340:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    2344:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2348:	429a      	cmp	r2, r3
    234a:	d006      	beq.n	235a <MSS_UART_tx_complete+0x4e>
    234c:	687a      	ldr	r2, [r7, #4]
    234e:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    2352:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2356:	429a      	cmp	r2, r3
    2358:	d117      	bne.n	238a <MSS_UART_tx_complete+0x7e>
    {
        /* Read the Line Status Register and update the sticky record. */
        status = this_uart->hw_reg->LSR;
    235a:	687b      	ldr	r3, [r7, #4]
    235c:	681b      	ldr	r3, [r3, #0]
    235e:	7d1b      	ldrb	r3, [r3, #20]
    2360:	73fb      	strb	r3, [r7, #15]
        this_uart->status |= status;
    2362:	687b      	ldr	r3, [r7, #4]
    2364:	7a9a      	ldrb	r2, [r3, #10]
    2366:	7bfb      	ldrb	r3, [r7, #15]
    2368:	ea42 0303 	orr.w	r3, r2, r3
    236c:	b2da      	uxtb	r2, r3
    236e:	687b      	ldr	r3, [r7, #4]
    2370:	729a      	strb	r2, [r3, #10]

        if ( ( TX_COMPLETE == this_uart->tx_buff_size ) &&
    2372:	687b      	ldr	r3, [r7, #4]
    2374:	691b      	ldr	r3, [r3, #16]
    2376:	2b00      	cmp	r3, #0
    2378:	d107      	bne.n	238a <MSS_UART_tx_complete+0x7e>
             ( status & MSS_UART_TEMT ) )
    237a:	7bfb      	ldrb	r3, [r7, #15]
    237c:	f003 0340 	and.w	r3, r3, #64	; 0x40
    {
        /* Read the Line Status Register and update the sticky record. */
        status = this_uart->hw_reg->LSR;
        this_uart->status |= status;

        if ( ( TX_COMPLETE == this_uart->tx_buff_size ) &&
    2380:	2b00      	cmp	r3, #0
    2382:	d002      	beq.n	238a <MSS_UART_tx_complete+0x7e>
             ( status & MSS_UART_TEMT ) )
        {
            ret_value = (int8_t)1;
    2384:	f04f 0301 	mov.w	r3, #1
    2388:	73bb      	strb	r3, [r7, #14]
        }
    }
    return ret_value;
    238a:	7bbb      	ldrb	r3, [r7, #14]
    238c:	b25b      	sxtb	r3, r3
}
    238e:	4618      	mov	r0, r3
    2390:	f107 0714 	add.w	r7, r7, #20
    2394:	46bd      	mov	sp, r7
    2396:	bc80      	pop	{r7}
    2398:	4770      	bx	lr
    239a:	bf00      	nop

0000239c <MSS_UART_get_rx>:
(
    mss_uart_instance_t * this_uart,
    uint8_t * rx_buff,
    size_t buff_size
)
{
    239c:	b480      	push	{r7}
    239e:	b087      	sub	sp, #28
    23a0:	af00      	add	r7, sp, #0
    23a2:	60f8      	str	r0, [r7, #12]
    23a4:	60b9      	str	r1, [r7, #8]
    23a6:	607a      	str	r2, [r7, #4]
    size_t rx_size = 0U;
    23a8:	f04f 0300 	mov.w	r3, #0
    23ac:	613b      	str	r3, [r7, #16]
    uint8_t status = 0U;
    23ae:	f04f 0300 	mov.w	r3, #0
    23b2:	75fb      	strb	r3, [r7, #23]

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    23b4:	68fa      	ldr	r2, [r7, #12]
    23b6:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    23ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    23be:	429a      	cmp	r2, r3
    23c0:	d007      	beq.n	23d2 <MSS_UART_get_rx+0x36>
    23c2:	68fa      	ldr	r2, [r7, #12]
    23c4:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    23c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    23cc:	429a      	cmp	r2, r3
    23ce:	d000      	beq.n	23d2 <MSS_UART_get_rx+0x36>
    23d0:	be00      	bkpt	0x0000
    ASSERT( rx_buff != ((uint8_t *)0) );
    23d2:	68bb      	ldr	r3, [r7, #8]
    23d4:	2b00      	cmp	r3, #0
    23d6:	d100      	bne.n	23da <MSS_UART_get_rx+0x3e>
    23d8:	be00      	bkpt	0x0000
    ASSERT( buff_size > 0U );
    23da:	687b      	ldr	r3, [r7, #4]
    23dc:	2b00      	cmp	r3, #0
    23de:	d100      	bne.n	23e2 <MSS_UART_get_rx+0x46>
    23e0:	be00      	bkpt	0x0000

    if( ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) ) &&
    23e2:	68fa      	ldr	r2, [r7, #12]
    23e4:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    23e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    23ec:	429a      	cmp	r2, r3
    23ee:	d006      	beq.n	23fe <MSS_UART_get_rx+0x62>
    23f0:	68fa      	ldr	r2, [r7, #12]
    23f2:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    23f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    23fa:	429a      	cmp	r2, r3
    23fc:	d134      	bne.n	2468 <MSS_UART_get_rx+0xcc>
    23fe:	68bb      	ldr	r3, [r7, #8]
    2400:	2b00      	cmp	r3, #0
    2402:	d031      	beq.n	2468 <MSS_UART_get_rx+0xcc>
    2404:	687b      	ldr	r3, [r7, #4]
    2406:	2b00      	cmp	r3, #0
    2408:	d02e      	beq.n	2468 <MSS_UART_get_rx+0xcc>
          ( rx_buff != ((uint8_t *)0) ) && ( buff_size > 0U ) )
    {
        status = this_uart->hw_reg->LSR;
    240a:	68fb      	ldr	r3, [r7, #12]
    240c:	681b      	ldr	r3, [r3, #0]
    240e:	7d1b      	ldrb	r3, [r3, #20]
    2410:	75fb      	strb	r3, [r7, #23]
        this_uart->status |= status;
    2412:	68fb      	ldr	r3, [r7, #12]
    2414:	7a9a      	ldrb	r2, [r3, #10]
    2416:	7dfb      	ldrb	r3, [r7, #23]
    2418:	ea42 0303 	orr.w	r3, r2, r3
    241c:	b2da      	uxtb	r2, r3
    241e:	68fb      	ldr	r3, [r7, #12]
    2420:	729a      	strb	r2, [r3, #10]

        while (( (status & MSS_UART_DATA_READY) != 0U) &&
    2422:	e017      	b.n	2454 <MSS_UART_get_rx+0xb8>
               ( rx_size < buff_size ) )
        {
            rx_buff[rx_size] = this_uart->hw_reg->RBR;
    2424:	68ba      	ldr	r2, [r7, #8]
    2426:	693b      	ldr	r3, [r7, #16]
    2428:	4413      	add	r3, r2
    242a:	68fa      	ldr	r2, [r7, #12]
    242c:	6812      	ldr	r2, [r2, #0]
    242e:	7812      	ldrb	r2, [r2, #0]
    2430:	b2d2      	uxtb	r2, r2
    2432:	701a      	strb	r2, [r3, #0]
            ++rx_size;
    2434:	693b      	ldr	r3, [r7, #16]
    2436:	f103 0301 	add.w	r3, r3, #1
    243a:	613b      	str	r3, [r7, #16]
            status = this_uart->hw_reg->LSR;
    243c:	68fb      	ldr	r3, [r7, #12]
    243e:	681b      	ldr	r3, [r3, #0]
    2440:	7d1b      	ldrb	r3, [r3, #20]
    2442:	75fb      	strb	r3, [r7, #23]
            this_uart->status |= status;
    2444:	68fb      	ldr	r3, [r7, #12]
    2446:	7a9a      	ldrb	r2, [r3, #10]
    2448:	7dfb      	ldrb	r3, [r7, #23]
    244a:	ea42 0303 	orr.w	r3, r2, r3
    244e:	b2da      	uxtb	r2, r3
    2450:	68fb      	ldr	r3, [r7, #12]
    2452:	729a      	strb	r2, [r3, #10]
          ( rx_buff != ((uint8_t *)0) ) && ( buff_size > 0U ) )
    {
        status = this_uart->hw_reg->LSR;
        this_uart->status |= status;

        while (( (status & MSS_UART_DATA_READY) != 0U) &&
    2454:	7dfb      	ldrb	r3, [r7, #23]
    2456:	f003 0301 	and.w	r3, r3, #1
    245a:	b2db      	uxtb	r3, r3
    245c:	2b00      	cmp	r3, #0
    245e:	d003      	beq.n	2468 <MSS_UART_get_rx+0xcc>
    2460:	693a      	ldr	r2, [r7, #16]
    2462:	687b      	ldr	r3, [r7, #4]
    2464:	429a      	cmp	r2, r3
    2466:	d3dd      	bcc.n	2424 <MSS_UART_get_rx+0x88>
            ++rx_size;
            status = this_uart->hw_reg->LSR;
            this_uart->status |= status;
        }
    }
    return rx_size;
    2468:	693b      	ldr	r3, [r7, #16]
}
    246a:	4618      	mov	r0, r3
    246c:	f107 071c 	add.w	r7, r7, #28
    2470:	46bd      	mov	sp, r7
    2472:	bc80      	pop	{r7}
    2474:	4770      	bx	lr
    2476:	bf00      	nop

00002478 <MSS_UART_enable_irq>:
MSS_UART_enable_irq
(
    mss_uart_instance_t * this_uart,
    uint8_t irq_mask
)
{
    2478:	b580      	push	{r7, lr}
    247a:	b082      	sub	sp, #8
    247c:	af00      	add	r7, sp, #0
    247e:	6078      	str	r0, [r7, #4]
    2480:	460b      	mov	r3, r1
    2482:	70fb      	strb	r3, [r7, #3]
    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    2484:	687a      	ldr	r2, [r7, #4]
    2486:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    248a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    248e:	429a      	cmp	r2, r3
    2490:	d007      	beq.n	24a2 <MSS_UART_enable_irq+0x2a>
    2492:	687a      	ldr	r2, [r7, #4]
    2494:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    2498:	f2c2 0300 	movt	r3, #8192	; 0x2000
    249c:	429a      	cmp	r2, r3
    249e:	d000      	beq.n	24a2 <MSS_UART_enable_irq+0x2a>
    24a0:	be00      	bkpt	0x0000

    if( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) )
    24a2:	687a      	ldr	r2, [r7, #4]
    24a4:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    24a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    24ac:	429a      	cmp	r2, r3
    24ae:	d006      	beq.n	24be <MSS_UART_enable_irq+0x46>
    24b0:	687a      	ldr	r2, [r7, #4]
    24b2:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    24b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    24ba:	429a      	cmp	r2, r3
    24bc:	d116      	bne.n	24ec <MSS_UART_enable_irq+0x74>
    {
        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ( this_uart->irqn );
    24be:	687b      	ldr	r3, [r7, #4]
    24c0:	891b      	ldrh	r3, [r3, #8]
    24c2:	b21b      	sxth	r3, r3
    24c4:	4618      	mov	r0, r3
    24c6:	f7ff fccf 	bl	1e68 <NVIC_ClearPendingIRQ>
         * bit 0 - Receive Data Available Interrupt
         * bit 1 - Transmitter Holding  Register Empty Interrupt
         * bit 2 - Receiver Line Status Interrupt
         * bit 3 - Modem Status Interrupt
         */
        this_uart->hw_reg->IER |= irq_mask;
    24ca:	687b      	ldr	r3, [r7, #4]
    24cc:	681b      	ldr	r3, [r3, #0]
    24ce:	687a      	ldr	r2, [r7, #4]
    24d0:	6812      	ldr	r2, [r2, #0]
    24d2:	7912      	ldrb	r2, [r2, #4]
    24d4:	b2d1      	uxtb	r1, r2
    24d6:	78fa      	ldrb	r2, [r7, #3]
    24d8:	ea41 0202 	orr.w	r2, r1, r2
    24dc:	b2d2      	uxtb	r2, r2
    24de:	711a      	strb	r2, [r3, #4]

        /* Enable UART instance interrupt in Cortex-M3 NVIC. */
        NVIC_EnableIRQ( this_uart->irqn );
    24e0:	687b      	ldr	r3, [r7, #4]
    24e2:	891b      	ldrh	r3, [r3, #8]
    24e4:	b21b      	sxth	r3, r3
    24e6:	4618      	mov	r0, r3
    24e8:	f7ff fc84 	bl	1df4 <NVIC_EnableIRQ>
    }
}
    24ec:	f107 0708 	add.w	r7, r7, #8
    24f0:	46bd      	mov	sp, r7
    24f2:	bd80      	pop	{r7, pc}

000024f4 <MSS_UART_disable_irq>:
MSS_UART_disable_irq
(
    mss_uart_instance_t * this_uart,
    uint8_t irq_mask
)
{
    24f4:	b580      	push	{r7, lr}
    24f6:	b082      	sub	sp, #8
    24f8:	af00      	add	r7, sp, #0
    24fa:	6078      	str	r0, [r7, #4]
    24fc:	460b      	mov	r3, r1
    24fe:	70fb      	strb	r3, [r7, #3]
    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    2500:	687a      	ldr	r2, [r7, #4]
    2502:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    2506:	f2c2 0300 	movt	r3, #8192	; 0x2000
    250a:	429a      	cmp	r2, r3
    250c:	d007      	beq.n	251e <MSS_UART_disable_irq+0x2a>
    250e:	687a      	ldr	r2, [r7, #4]
    2510:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    2514:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2518:	429a      	cmp	r2, r3
    251a:	d000      	beq.n	251e <MSS_UART_disable_irq+0x2a>
    251c:	be00      	bkpt	0x0000

    if( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) )
    251e:	687a      	ldr	r2, [r7, #4]
    2520:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    2524:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2528:	429a      	cmp	r2, r3
    252a:	d006      	beq.n	253a <MSS_UART_disable_irq+0x46>
    252c:	687a      	ldr	r2, [r7, #4]
    252e:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    2532:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2536:	429a      	cmp	r2, r3
    2538:	d11c      	bne.n	2574 <MSS_UART_disable_irq+0x80>
         * bit 0 - Receive Data Available Interrupt
         * bit 1 - Transmitter Holding  Register Empty Interrupt
         * bit 2 - Receiver Line Status Interrupt
         * bit 3 - Modem Status Interrupt
         */
        this_uart->hw_reg->IER &= ( (uint8_t)~irq_mask );
    253a:	687b      	ldr	r3, [r7, #4]
    253c:	681b      	ldr	r3, [r3, #0]
    253e:	687a      	ldr	r2, [r7, #4]
    2540:	6812      	ldr	r2, [r2, #0]
    2542:	7912      	ldrb	r2, [r2, #4]
    2544:	b2d1      	uxtb	r1, r2
    2546:	78fa      	ldrb	r2, [r7, #3]
    2548:	ea6f 0202 	mvn.w	r2, r2
    254c:	b2d2      	uxtb	r2, r2
    254e:	ea01 0202 	and.w	r2, r1, r2
    2552:	b2d2      	uxtb	r2, r2
    2554:	711a      	strb	r2, [r3, #4]

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ( this_uart->irqn );
    2556:	687b      	ldr	r3, [r7, #4]
    2558:	891b      	ldrh	r3, [r3, #8]
    255a:	b21b      	sxth	r3, r3
    255c:	4618      	mov	r0, r3
    255e:	f7ff fc83 	bl	1e68 <NVIC_ClearPendingIRQ>

        if( irq_mask == IIRF_MASK )
    2562:	78fb      	ldrb	r3, [r7, #3]
    2564:	2b0f      	cmp	r3, #15
    2566:	d105      	bne.n	2574 <MSS_UART_disable_irq+0x80>
        {
            /* Disable UART instance interrupt in Cortex-M3 NVIC. */
            NVIC_DisableIRQ( this_uart->irqn );
    2568:	687b      	ldr	r3, [r7, #4]
    256a:	891b      	ldrh	r3, [r3, #8]
    256c:	b21b      	sxth	r3, r3
    256e:	4618      	mov	r0, r3
    2570:	f7ff fc5c 	bl	1e2c <NVIC_DisableIRQ>

        }
    }
}
    2574:	f107 0708 	add.w	r7, r7, #8
    2578:	46bd      	mov	sp, r7
    257a:	bd80      	pop	{r7, pc}

0000257c <MSS_UART_isr>:
static void
MSS_UART_isr
(
    mss_uart_instance_t * this_uart
)
{
    257c:	b580      	push	{r7, lr}
    257e:	b084      	sub	sp, #16
    2580:	af00      	add	r7, sp, #0
    2582:	6078      	str	r0, [r7, #4]
    uint8_t iirf;

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    2584:	687a      	ldr	r2, [r7, #4]
    2586:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    258a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    258e:	429a      	cmp	r2, r3
    2590:	d007      	beq.n	25a2 <MSS_UART_isr+0x26>
    2592:	687a      	ldr	r2, [r7, #4]
    2594:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    2598:	f2c2 0300 	movt	r3, #8192	; 0x2000
    259c:	429a      	cmp	r2, r3
    259e:	d000      	beq.n	25a2 <MSS_UART_isr+0x26>
    25a0:	be00      	bkpt	0x0000

    if ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) )
    25a2:	687a      	ldr	r2, [r7, #4]
    25a4:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    25a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    25ac:	429a      	cmp	r2, r3
    25ae:	d006      	beq.n	25be <MSS_UART_isr+0x42>
    25b0:	687a      	ldr	r2, [r7, #4]
    25b2:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    25b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    25ba:	429a      	cmp	r2, r3
    25bc:	d167      	bne.n	268e <MSS_UART_isr+0x112>
    {
        iirf = this_uart->hw_reg->IIR & IIRF_MASK;
    25be:	687b      	ldr	r3, [r7, #4]
    25c0:	681b      	ldr	r3, [r3, #0]
    25c2:	7a1b      	ldrb	r3, [r3, #8]
    25c4:	b2db      	uxtb	r3, r3
    25c6:	f003 030f 	and.w	r3, r3, #15
    25ca:	73fb      	strb	r3, [r7, #15]

        switch ( iirf )
    25cc:	7bfb      	ldrb	r3, [r7, #15]
    25ce:	2b0c      	cmp	r3, #12
    25d0:	d854      	bhi.n	267c <MSS_UART_isr+0x100>
    25d2:	a201      	add	r2, pc, #4	; (adr r2, 25d8 <MSS_UART_isr+0x5c>)
    25d4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    25d8:	0000260d 	.word	0x0000260d
    25dc:	0000267d 	.word	0x0000267d
    25e0:	00002629 	.word	0x00002629
    25e4:	0000267d 	.word	0x0000267d
    25e8:	00002645 	.word	0x00002645
    25ec:	0000267d 	.word	0x0000267d
    25f0:	00002661 	.word	0x00002661
    25f4:	0000267d 	.word	0x0000267d
    25f8:	0000267d 	.word	0x0000267d
    25fc:	0000267d 	.word	0x0000267d
    2600:	0000267d 	.word	0x0000267d
    2604:	0000267d 	.word	0x0000267d
    2608:	00002645 	.word	0x00002645
        {
            case IIRF_MODEM_STATUS:  /* Modem status interrupt */
            {
                ASSERT( NULL_HANDLER != this_uart->modemsts_handler );
    260c:	687b      	ldr	r3, [r7, #4]
    260e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2610:	2b00      	cmp	r3, #0
    2612:	d100      	bne.n	2616 <MSS_UART_isr+0x9a>
    2614:	be00      	bkpt	0x0000
                if( NULL_HANDLER != this_uart->modemsts_handler )
    2616:	687b      	ldr	r3, [r7, #4]
    2618:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    261a:	2b00      	cmp	r3, #0
    261c:	d030      	beq.n	2680 <MSS_UART_isr+0x104>
                {
                   (*(this_uart->modemsts_handler))( this_uart );
    261e:	687b      	ldr	r3, [r7, #4]
    2620:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2622:	6878      	ldr	r0, [r7, #4]
    2624:	4798      	blx	r3
                }
            }
            break;
    2626:	e032      	b.n	268e <MSS_UART_isr+0x112>

            case IIRF_THRE: /* Transmitter Holding Register Empty */
            {
                ASSERT( NULL_HANDLER != this_uart->tx_handler );
    2628:	687b      	ldr	r3, [r7, #4]
    262a:	6a1b      	ldr	r3, [r3, #32]
    262c:	2b00      	cmp	r3, #0
    262e:	d100      	bne.n	2632 <MSS_UART_isr+0xb6>
    2630:	be00      	bkpt	0x0000
                if ( NULL_HANDLER != this_uart->tx_handler )
    2632:	687b      	ldr	r3, [r7, #4]
    2634:	6a1b      	ldr	r3, [r3, #32]
    2636:	2b00      	cmp	r3, #0
    2638:	d024      	beq.n	2684 <MSS_UART_isr+0x108>
                {
                    (*(this_uart->tx_handler))( this_uart );
    263a:	687b      	ldr	r3, [r7, #4]
    263c:	6a1b      	ldr	r3, [r3, #32]
    263e:	6878      	ldr	r0, [r7, #4]
    2640:	4798      	blx	r3
                }
            }
            break;
    2642:	e024      	b.n	268e <MSS_UART_isr+0x112>

            case IIRF_RX_DATA:      /* Received Data Available */
            case IIRF_DATA_TIMEOUT: /* Received Data Timed-out */
            {
                ASSERT( NULL_HANDLER != this_uart->rx_handler );
    2644:	687b      	ldr	r3, [r7, #4]
    2646:	69db      	ldr	r3, [r3, #28]
    2648:	2b00      	cmp	r3, #0
    264a:	d100      	bne.n	264e <MSS_UART_isr+0xd2>
    264c:	be00      	bkpt	0x0000
                if ( NULL_HANDLER != this_uart->rx_handler )
    264e:	687b      	ldr	r3, [r7, #4]
    2650:	69db      	ldr	r3, [r3, #28]
    2652:	2b00      	cmp	r3, #0
    2654:	d018      	beq.n	2688 <MSS_UART_isr+0x10c>
                {
                    (*(this_uart->rx_handler))( this_uart );
    2656:	687b      	ldr	r3, [r7, #4]
    2658:	69db      	ldr	r3, [r3, #28]
    265a:	6878      	ldr	r0, [r7, #4]
    265c:	4798      	blx	r3
                }
            }
            break;
    265e:	e016      	b.n	268e <MSS_UART_isr+0x112>

            case IIRF_RX_LINE_STATUS:  /* Line Status Interrupt */
            {
                ASSERT( NULL_HANDLER != this_uart->linests_handler );
    2660:	687b      	ldr	r3, [r7, #4]
    2662:	699b      	ldr	r3, [r3, #24]
    2664:	2b00      	cmp	r3, #0
    2666:	d100      	bne.n	266a <MSS_UART_isr+0xee>
    2668:	be00      	bkpt	0x0000
                if ( NULL_HANDLER != this_uart->linests_handler )
    266a:	687b      	ldr	r3, [r7, #4]
    266c:	699b      	ldr	r3, [r3, #24]
    266e:	2b00      	cmp	r3, #0
    2670:	d00c      	beq.n	268c <MSS_UART_isr+0x110>
                {
                   (*(this_uart->linests_handler))( this_uart );
    2672:	687b      	ldr	r3, [r7, #4]
    2674:	699b      	ldr	r3, [r3, #24]
    2676:	6878      	ldr	r0, [r7, #4]
    2678:	4798      	blx	r3
                }
            }
            break;
    267a:	e008      	b.n	268e <MSS_UART_isr+0x112>

            default:
            {
                ASSERT( INVALID_INTERRUPT );
    267c:	be00      	bkpt	0x0000
    267e:	e006      	b.n	268e <MSS_UART_isr+0x112>
                if( NULL_HANDLER != this_uart->modemsts_handler )
                {
                   (*(this_uart->modemsts_handler))( this_uart );
                }
            }
            break;
    2680:	bf00      	nop
    2682:	e004      	b.n	268e <MSS_UART_isr+0x112>
                if ( NULL_HANDLER != this_uart->tx_handler )
                {
                    (*(this_uart->tx_handler))( this_uart );
                }
            }
            break;
    2684:	bf00      	nop
    2686:	e002      	b.n	268e <MSS_UART_isr+0x112>
                if ( NULL_HANDLER != this_uart->rx_handler )
                {
                    (*(this_uart->rx_handler))( this_uart );
                }
            }
            break;
    2688:	bf00      	nop
    268a:	e000      	b.n	268e <MSS_UART_isr+0x112>
                if ( NULL_HANDLER != this_uart->linests_handler )
                {
                   (*(this_uart->linests_handler))( this_uart );
                }
            }
            break;
    268c:	bf00      	nop
                ASSERT( INVALID_INTERRUPT );
            }
            break;
        }
    }
}
    268e:	f107 0710 	add.w	r7, r7, #16
    2692:	46bd      	mov	sp, r7
    2694:	bd80      	pop	{r7, pc}
    2696:	bf00      	nop

00002698 <default_tx_handler>:
static void
default_tx_handler
(
    mss_uart_instance_t * this_uart
)
{
    2698:	b480      	push	{r7}
    269a:	b087      	sub	sp, #28
    269c:	af00      	add	r7, sp, #0
    269e:	6078      	str	r0, [r7, #4]
    uint8_t status;

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    26a0:	687a      	ldr	r2, [r7, #4]
    26a2:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    26a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    26aa:	429a      	cmp	r2, r3
    26ac:	d007      	beq.n	26be <default_tx_handler+0x26>
    26ae:	687a      	ldr	r2, [r7, #4]
    26b0:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    26b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    26b8:	429a      	cmp	r2, r3
    26ba:	d000      	beq.n	26be <default_tx_handler+0x26>
    26bc:	be00      	bkpt	0x0000
    ASSERT( ( (uint8_t *)0 ) != this_uart->tx_buffer );
    26be:	687b      	ldr	r3, [r7, #4]
    26c0:	68db      	ldr	r3, [r3, #12]
    26c2:	2b00      	cmp	r3, #0
    26c4:	d100      	bne.n	26c8 <default_tx_handler+0x30>
    26c6:	be00      	bkpt	0x0000
    ASSERT( 0U < this_uart->tx_buff_size );
    26c8:	687b      	ldr	r3, [r7, #4]
    26ca:	691b      	ldr	r3, [r3, #16]
    26cc:	2b00      	cmp	r3, #0
    26ce:	d100      	bne.n	26d2 <default_tx_handler+0x3a>
    26d0:	be00      	bkpt	0x0000

    if( ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) ) &&
    26d2:	687a      	ldr	r2, [r7, #4]
    26d4:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    26d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    26dc:	429a      	cmp	r2, r3
    26de:	d006      	beq.n	26ee <default_tx_handler+0x56>
    26e0:	687a      	ldr	r2, [r7, #4]
    26e2:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    26e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    26ea:	429a      	cmp	r2, r3
    26ec:	d152      	bne.n	2794 <default_tx_handler+0xfc>
        ( ( (uint8_t *)0 ) != this_uart->tx_buffer ) &&
    26ee:	687b      	ldr	r3, [r7, #4]
    26f0:	68db      	ldr	r3, [r3, #12]

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    ASSERT( ( (uint8_t *)0 ) != this_uart->tx_buffer );
    ASSERT( 0U < this_uart->tx_buff_size );

    if( ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) ) &&
    26f2:	2b00      	cmp	r3, #0
    26f4:	d04e      	beq.n	2794 <default_tx_handler+0xfc>
        ( ( (uint8_t *)0 ) != this_uart->tx_buffer ) &&
        ( 0U < this_uart->tx_buff_size ) )
    26f6:	687b      	ldr	r3, [r7, #4]
    26f8:	691b      	ldr	r3, [r3, #16]

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    ASSERT( ( (uint8_t *)0 ) != this_uart->tx_buffer );
    ASSERT( 0U < this_uart->tx_buff_size );

    if( ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) ) &&
    26fa:	2b00      	cmp	r3, #0
    26fc:	d04a      	beq.n	2794 <default_tx_handler+0xfc>
        ( ( (uint8_t *)0 ) != this_uart->tx_buffer ) &&
        ( 0U < this_uart->tx_buff_size ) )
    {
        /* Read the Line Status Register and update the sticky record. */
        status = this_uart->hw_reg->LSR;
    26fe:	687b      	ldr	r3, [r7, #4]
    2700:	681b      	ldr	r3, [r3, #0]
    2702:	7d1b      	ldrb	r3, [r3, #20]
    2704:	72fb      	strb	r3, [r7, #11]
        this_uart->status |= status;
    2706:	687b      	ldr	r3, [r7, #4]
    2708:	7a9a      	ldrb	r2, [r3, #10]
    270a:	7afb      	ldrb	r3, [r7, #11]
    270c:	ea42 0303 	orr.w	r3, r2, r3
    2710:	b2da      	uxtb	r2, r3
    2712:	687b      	ldr	r3, [r7, #4]
    2714:	729a      	strb	r2, [r3, #10]

        /*
         * This function should only be called as a result of a THRE interrupt.
         * Verify that this is true before proceeding to transmit data.
         */
        if ( status & MSS_UART_THRE )
    2716:	7afb      	ldrb	r3, [r7, #11]
    2718:	f003 0320 	and.w	r3, r3, #32
    271c:	2b00      	cmp	r3, #0
    271e:	d029      	beq.n	2774 <default_tx_handler+0xdc>
        {
            uint32_t i;
            uint32_t fill_size = TX_FIFO_SIZE;
    2720:	f04f 0310 	mov.w	r3, #16
    2724:	613b      	str	r3, [r7, #16]
            uint32_t tx_remain = this_uart->tx_buff_size - this_uart->tx_idx;
    2726:	687b      	ldr	r3, [r7, #4]
    2728:	691a      	ldr	r2, [r3, #16]
    272a:	687b      	ldr	r3, [r7, #4]
    272c:	695b      	ldr	r3, [r3, #20]
    272e:	ebc3 0302 	rsb	r3, r3, r2
    2732:	617b      	str	r3, [r7, #20]

            /* Calculate the number of bytes to transmit. */
            if ( tx_remain < TX_FIFO_SIZE )
    2734:	697b      	ldr	r3, [r7, #20]
    2736:	2b0f      	cmp	r3, #15
    2738:	d801      	bhi.n	273e <default_tx_handler+0xa6>
            {
                fill_size = tx_remain;
    273a:	697b      	ldr	r3, [r7, #20]
    273c:	613b      	str	r3, [r7, #16]
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for ( i = 0U; i < fill_size; ++i )
    273e:	f04f 0300 	mov.w	r3, #0
    2742:	60fb      	str	r3, [r7, #12]
    2744:	e012      	b.n	276c <default_tx_handler+0xd4>
            {
                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = this_uart->tx_buffer[this_uart->tx_idx];
    2746:	687b      	ldr	r3, [r7, #4]
    2748:	681b      	ldr	r3, [r3, #0]
    274a:	687a      	ldr	r2, [r7, #4]
    274c:	68d1      	ldr	r1, [r2, #12]
    274e:	687a      	ldr	r2, [r7, #4]
    2750:	6952      	ldr	r2, [r2, #20]
    2752:	440a      	add	r2, r1
    2754:	7812      	ldrb	r2, [r2, #0]
    2756:	701a      	strb	r2, [r3, #0]
                ++this_uart->tx_idx;
    2758:	687b      	ldr	r3, [r7, #4]
    275a:	695b      	ldr	r3, [r3, #20]
    275c:	f103 0201 	add.w	r2, r3, #1
    2760:	687b      	ldr	r3, [r7, #4]
    2762:	615a      	str	r2, [r3, #20]
            {
                fill_size = tx_remain;
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for ( i = 0U; i < fill_size; ++i )
    2764:	68fb      	ldr	r3, [r7, #12]
    2766:	f103 0301 	add.w	r3, r3, #1
    276a:	60fb      	str	r3, [r7, #12]
    276c:	68fa      	ldr	r2, [r7, #12]
    276e:	693b      	ldr	r3, [r7, #16]
    2770:	429a      	cmp	r2, r3
    2772:	d3e8      	bcc.n	2746 <default_tx_handler+0xae>
                ++this_uart->tx_idx;
            }
        }

        /* Flag Tx as complete if all data has been pushed into the Tx FIFO. */
        if ( this_uart->tx_idx == this_uart->tx_buff_size )
    2774:	687b      	ldr	r3, [r7, #4]
    2776:	695a      	ldr	r2, [r3, #20]
    2778:	687b      	ldr	r3, [r7, #4]
    277a:	691b      	ldr	r3, [r3, #16]
    277c:	429a      	cmp	r2, r3
    277e:	d109      	bne.n	2794 <default_tx_handler+0xfc>
        {
            this_uart->tx_buff_size = TX_COMPLETE;
    2780:	687b      	ldr	r3, [r7, #4]
    2782:	f04f 0200 	mov.w	r2, #0
    2786:	611a      	str	r2, [r3, #16]
            /* disables TX interrupt */
            this_uart->hw_reg_bit->IER_ETBEI = 0U;
    2788:	687b      	ldr	r3, [r7, #4]
    278a:	685b      	ldr	r3, [r3, #4]
    278c:	f04f 0200 	mov.w	r2, #0
    2790:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
        }
    }
}
    2794:	f107 071c 	add.w	r7, r7, #28
    2798:	46bd      	mov	sp, r7
    279a:	bc80      	pop	{r7}
    279c:	4770      	bx	lr
    279e:	bf00      	nop

000027a0 <MSS_UART_set_rx_handler>:
(
    mss_uart_instance_t *       this_uart,
    mss_uart_irq_handler_t      handler,
    mss_uart_rx_trig_level_t    trigger_level
)
{
    27a0:	b580      	push	{r7, lr}
    27a2:	b084      	sub	sp, #16
    27a4:	af00      	add	r7, sp, #0
    27a6:	60f8      	str	r0, [r7, #12]
    27a8:	60b9      	str	r1, [r7, #8]
    27aa:	4613      	mov	r3, r2
    27ac:	71fb      	strb	r3, [r7, #7]
    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    27ae:	68fa      	ldr	r2, [r7, #12]
    27b0:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    27b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    27b8:	429a      	cmp	r2, r3
    27ba:	d007      	beq.n	27cc <MSS_UART_set_rx_handler+0x2c>
    27bc:	68fa      	ldr	r2, [r7, #12]
    27be:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    27c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    27c6:	429a      	cmp	r2, r3
    27c8:	d000      	beq.n	27cc <MSS_UART_set_rx_handler+0x2c>
    27ca:	be00      	bkpt	0x0000
    ASSERT( handler != INVALID_IRQ_HANDLER );
    27cc:	68bb      	ldr	r3, [r7, #8]
    27ce:	2b00      	cmp	r3, #0
    27d0:	d100      	bne.n	27d4 <MSS_UART_set_rx_handler+0x34>
    27d2:	be00      	bkpt	0x0000
    ASSERT( trigger_level < MSS_UART_FIFO_INVALID_TRIG_LEVEL );
    27d4:	79fb      	ldrb	r3, [r7, #7]
    27d6:	2bc0      	cmp	r3, #192	; 0xc0
    27d8:	d900      	bls.n	27dc <MSS_UART_set_rx_handler+0x3c>
    27da:	be00      	bkpt	0x0000

    if( ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) ) &&
    27dc:	68fa      	ldr	r2, [r7, #12]
    27de:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    27e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    27e6:	429a      	cmp	r2, r3
    27e8:	d006      	beq.n	27f8 <MSS_UART_set_rx_handler+0x58>
    27ea:	68fa      	ldr	r2, [r7, #12]
    27ec:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    27f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    27f4:	429a      	cmp	r2, r3
    27f6:	d123      	bne.n	2840 <MSS_UART_set_rx_handler+0xa0>
    27f8:	68bb      	ldr	r3, [r7, #8]
    27fa:	2b00      	cmp	r3, #0
    27fc:	d020      	beq.n	2840 <MSS_UART_set_rx_handler+0xa0>
    27fe:	79fb      	ldrb	r3, [r7, #7]
    2800:	2bc0      	cmp	r3, #192	; 0xc0
    2802:	d81d      	bhi.n	2840 <MSS_UART_set_rx_handler+0xa0>
        ( handler != INVALID_IRQ_HANDLER) &&
        ( trigger_level < MSS_UART_FIFO_INVALID_TRIG_LEVEL) )
    {
        this_uart->rx_handler = handler;
    2804:	68fb      	ldr	r3, [r7, #12]
    2806:	68ba      	ldr	r2, [r7, #8]
    2808:	61da      	str	r2, [r3, #28]

        /* Set the receive interrupt trigger level. */
        /* Clear RX FIFO; Enable TXRDY and RXRDY for PDMA */
        this_uart->hw_reg->FCR = (uint8_t)(FCR_TRIG_LEVEL_MASK & (uint8_t)trigger_level) |
    280a:	68fb      	ldr	r3, [r7, #12]
    280c:	681a      	ldr	r2, [r3, #0]
    280e:	79fb      	ldrb	r3, [r7, #7]
    2810:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    2814:	f043 030a 	orr.w	r3, r3, #10
    2818:	b2db      	uxtb	r3, r3
    281a:	7213      	strb	r3, [r2, #8]
                              FCR_CLEAR_RX_FIFO_MASK | FCR_ENABLE_TXRDY_RXRDY_MASK;

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ( this_uart->irqn );
    281c:	68fb      	ldr	r3, [r7, #12]
    281e:	891b      	ldrh	r3, [r3, #8]
    2820:	b21b      	sxth	r3, r3
    2822:	4618      	mov	r0, r3
    2824:	f7ff fb20 	bl	1e68 <NVIC_ClearPendingIRQ>

        /* Enable receive interrupt. */
        this_uart->hw_reg_bit->IER_ERBFI = 1U;
    2828:	68fb      	ldr	r3, [r7, #12]
    282a:	685b      	ldr	r3, [r3, #4]
    282c:	f04f 0201 	mov.w	r2, #1
    2830:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

        /* Enable UART instance interrupt in Cortex-M3 NVIC. */
        NVIC_EnableIRQ( this_uart->irqn );
    2834:	68fb      	ldr	r3, [r7, #12]
    2836:	891b      	ldrh	r3, [r3, #8]
    2838:	b21b      	sxth	r3, r3
    283a:	4618      	mov	r0, r3
    283c:	f7ff fada 	bl	1df4 <NVIC_EnableIRQ>
    }
}
    2840:	f107 0710 	add.w	r7, r7, #16
    2844:	46bd      	mov	sp, r7
    2846:	bd80      	pop	{r7, pc}

00002848 <MSS_UART_set_loopback>:
MSS_UART_set_loopback
(
    mss_uart_instance_t *   this_uart,
    mss_uart_loopback_t     loopback
)
{
    2848:	b480      	push	{r7}
    284a:	b083      	sub	sp, #12
    284c:	af00      	add	r7, sp, #0
    284e:	6078      	str	r0, [r7, #4]
    2850:	460b      	mov	r3, r1
    2852:	70fb      	strb	r3, [r7, #3]
    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    2854:	687a      	ldr	r2, [r7, #4]
    2856:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    285a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    285e:	429a      	cmp	r2, r3
    2860:	d007      	beq.n	2872 <MSS_UART_set_loopback+0x2a>
    2862:	687a      	ldr	r2, [r7, #4]
    2864:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    2868:	f2c2 0300 	movt	r3, #8192	; 0x2000
    286c:	429a      	cmp	r2, r3
    286e:	d000      	beq.n	2872 <MSS_UART_set_loopback+0x2a>
    2870:	be00      	bkpt	0x0000

    if( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) )
    2872:	687a      	ldr	r2, [r7, #4]
    2874:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    2878:	f2c2 0300 	movt	r3, #8192	; 0x2000
    287c:	429a      	cmp	r2, r3
    287e:	d006      	beq.n	288e <MSS_UART_set_loopback+0x46>
    2880:	687a      	ldr	r2, [r7, #4]
    2882:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    2886:	f2c2 0300 	movt	r3, #8192	; 0x2000
    288a:	429a      	cmp	r2, r3
    288c:	d10f      	bne.n	28ae <MSS_UART_set_loopback+0x66>
    {
        if ( loopback == MSS_UART_LOOPBACK_OFF )
    288e:	78fb      	ldrb	r3, [r7, #3]
    2890:	2b00      	cmp	r3, #0
    2892:	d106      	bne.n	28a2 <MSS_UART_set_loopback+0x5a>
        {
            this_uart->hw_reg_bit->MCR_LOOP = 0U;
    2894:	687b      	ldr	r3, [r7, #4]
    2896:	685b      	ldr	r3, [r3, #4]
    2898:	f04f 0200 	mov.w	r2, #0
    289c:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
    28a0:	e005      	b.n	28ae <MSS_UART_set_loopback+0x66>
        }
        else
        {
            this_uart->hw_reg_bit->MCR_LOOP = 1U;
    28a2:	687b      	ldr	r3, [r7, #4]
    28a4:	685b      	ldr	r3, [r3, #4]
    28a6:	f04f 0201 	mov.w	r2, #1
    28aa:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
        }
    }
}
    28ae:	f107 070c 	add.w	r7, r7, #12
    28b2:	46bd      	mov	sp, r7
    28b4:	bc80      	pop	{r7}
    28b6:	4770      	bx	lr

000028b8 <UART0_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void UART0_IRQHandler( void )
#else
void UART0_IRQHandler( void )
#endif
{
    28b8:	4668      	mov	r0, sp
    28ba:	f020 0107 	bic.w	r1, r0, #7
    28be:	468d      	mov	sp, r1
    28c0:	b589      	push	{r0, r3, r7, lr}
    28c2:	af00      	add	r7, sp, #0
    MSS_UART_isr( &g_mss_uart0 );
    28c4:	f64a 10d0 	movw	r0, #43472	; 0xa9d0
    28c8:	f2c2 0000 	movt	r0, #8192	; 0x2000
    28cc:	f7ff fe56 	bl	257c <MSS_UART_isr>
    NVIC_ClearPendingIRQ( UART0_IRQn );
    28d0:	f04f 000a 	mov.w	r0, #10
    28d4:	f7ff fac8 	bl	1e68 <NVIC_ClearPendingIRQ>
}
    28d8:	46bd      	mov	sp, r7
    28da:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    28de:	4685      	mov	sp, r0
    28e0:	4770      	bx	lr
    28e2:	bf00      	nop

000028e4 <UART1_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void UART1_IRQHandler( void )
#else
void UART1_IRQHandler( void )
#endif
{
    28e4:	4668      	mov	r0, sp
    28e6:	f020 0107 	bic.w	r1, r0, #7
    28ea:	468d      	mov	sp, r1
    28ec:	b589      	push	{r0, r3, r7, lr}
    28ee:	af00      	add	r7, sp, #0
    MSS_UART_isr( &g_mss_uart1 );
    28f0:	f64a 10a8 	movw	r0, #43432	; 0xa9a8
    28f4:	f2c2 0000 	movt	r0, #8192	; 0x2000
    28f8:	f7ff fe40 	bl	257c <MSS_UART_isr>
    NVIC_ClearPendingIRQ( UART1_IRQn );
    28fc:	f04f 000b 	mov.w	r0, #11
    2900:	f7ff fab2 	bl	1e68 <NVIC_ClearPendingIRQ>
}
    2904:	46bd      	mov	sp, r7
    2906:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    290a:	4685      	mov	sp, r0
    290c:	4770      	bx	lr
    290e:	bf00      	nop

00002910 <MSS_UART_set_rxstatus_handler>:
MSS_UART_set_rxstatus_handler
(
    mss_uart_instance_t * this_uart,
    mss_uart_irq_handler_t handler
)
{
    2910:	b580      	push	{r7, lr}
    2912:	b082      	sub	sp, #8
    2914:	af00      	add	r7, sp, #0
    2916:	6078      	str	r0, [r7, #4]
    2918:	6039      	str	r1, [r7, #0]
    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    291a:	687a      	ldr	r2, [r7, #4]
    291c:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    2920:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2924:	429a      	cmp	r2, r3
    2926:	d007      	beq.n	2938 <MSS_UART_set_rxstatus_handler+0x28>
    2928:	687a      	ldr	r2, [r7, #4]
    292a:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    292e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2932:	429a      	cmp	r2, r3
    2934:	d000      	beq.n	2938 <MSS_UART_set_rxstatus_handler+0x28>
    2936:	be00      	bkpt	0x0000
    ASSERT( handler != INVALID_IRQ_HANDLER);
    2938:	683b      	ldr	r3, [r7, #0]
    293a:	2b00      	cmp	r3, #0
    293c:	d100      	bne.n	2940 <MSS_UART_set_rxstatus_handler+0x30>
    293e:	be00      	bkpt	0x0000

    if( ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) ) &&
    2940:	687a      	ldr	r2, [r7, #4]
    2942:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    2946:	f2c2 0300 	movt	r3, #8192	; 0x2000
    294a:	429a      	cmp	r2, r3
    294c:	d006      	beq.n	295c <MSS_UART_set_rxstatus_handler+0x4c>
    294e:	687a      	ldr	r2, [r7, #4]
    2950:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    2954:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2958:	429a      	cmp	r2, r3
    295a:	d117      	bne.n	298c <MSS_UART_set_rxstatus_handler+0x7c>
    295c:	683b      	ldr	r3, [r7, #0]
    295e:	2b00      	cmp	r3, #0
    2960:	d014      	beq.n	298c <MSS_UART_set_rxstatus_handler+0x7c>
        ( handler != INVALID_IRQ_HANDLER) )
    {
        this_uart->linests_handler = handler;
    2962:	687b      	ldr	r3, [r7, #4]
    2964:	683a      	ldr	r2, [r7, #0]
    2966:	619a      	str	r2, [r3, #24]

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ( this_uart->irqn );
    2968:	687b      	ldr	r3, [r7, #4]
    296a:	891b      	ldrh	r3, [r3, #8]
    296c:	b21b      	sxth	r3, r3
    296e:	4618      	mov	r0, r3
    2970:	f7ff fa7a 	bl	1e68 <NVIC_ClearPendingIRQ>

        /* Enable receiver line status interrupt. */
        this_uart->hw_reg_bit->IER_ELSI = 1U;
    2974:	687b      	ldr	r3, [r7, #4]
    2976:	685b      	ldr	r3, [r3, #4]
    2978:	f04f 0201 	mov.w	r2, #1
    297c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

        /* Enable UART instance interrupt in Cortex-M3 NVIC. */
        NVIC_EnableIRQ( this_uart->irqn );
    2980:	687b      	ldr	r3, [r7, #4]
    2982:	891b      	ldrh	r3, [r3, #8]
    2984:	b21b      	sxth	r3, r3
    2986:	4618      	mov	r0, r3
    2988:	f7ff fa34 	bl	1df4 <NVIC_EnableIRQ>
    }
}
    298c:	f107 0708 	add.w	r7, r7, #8
    2990:	46bd      	mov	sp, r7
    2992:	bd80      	pop	{r7, pc}

00002994 <MSS_UART_set_tx_handler>:
MSS_UART_set_tx_handler
(
    mss_uart_instance_t * this_uart,
    mss_uart_irq_handler_t handler
)
{
    2994:	b580      	push	{r7, lr}
    2996:	b082      	sub	sp, #8
    2998:	af00      	add	r7, sp, #0
    299a:	6078      	str	r0, [r7, #4]
    299c:	6039      	str	r1, [r7, #0]
    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    299e:	687a      	ldr	r2, [r7, #4]
    29a0:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    29a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    29a8:	429a      	cmp	r2, r3
    29aa:	d007      	beq.n	29bc <MSS_UART_set_tx_handler+0x28>
    29ac:	687a      	ldr	r2, [r7, #4]
    29ae:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    29b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    29b6:	429a      	cmp	r2, r3
    29b8:	d000      	beq.n	29bc <MSS_UART_set_tx_handler+0x28>
    29ba:	be00      	bkpt	0x0000
    ASSERT( handler != INVALID_IRQ_HANDLER);
    29bc:	683b      	ldr	r3, [r7, #0]
    29be:	2b00      	cmp	r3, #0
    29c0:	d100      	bne.n	29c4 <MSS_UART_set_tx_handler+0x30>
    29c2:	be00      	bkpt	0x0000

    if( ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) ) &&
    29c4:	687a      	ldr	r2, [r7, #4]
    29c6:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    29ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    29ce:	429a      	cmp	r2, r3
    29d0:	d006      	beq.n	29e0 <MSS_UART_set_tx_handler+0x4c>
    29d2:	687a      	ldr	r2, [r7, #4]
    29d4:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    29d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    29dc:	429a      	cmp	r2, r3
    29de:	d11f      	bne.n	2a20 <MSS_UART_set_tx_handler+0x8c>
    29e0:	683b      	ldr	r3, [r7, #0]
    29e2:	2b00      	cmp	r3, #0
    29e4:	d01c      	beq.n	2a20 <MSS_UART_set_tx_handler+0x8c>
        ( handler != INVALID_IRQ_HANDLER) )
    {
        this_uart->tx_handler = handler;
    29e6:	687b      	ldr	r3, [r7, #4]
    29e8:	683a      	ldr	r2, [r7, #0]
    29ea:	621a      	str	r2, [r3, #32]

        /* Make TX buffer info invalid */
        this_uart->tx_buffer = (const uint8_t *)0;
    29ec:	687b      	ldr	r3, [r7, #4]
    29ee:	f04f 0200 	mov.w	r2, #0
    29f2:	60da      	str	r2, [r3, #12]
        this_uart->tx_buff_size = 0U;
    29f4:	687b      	ldr	r3, [r7, #4]
    29f6:	f04f 0200 	mov.w	r2, #0
    29fa:	611a      	str	r2, [r3, #16]

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ( this_uart->irqn );
    29fc:	687b      	ldr	r3, [r7, #4]
    29fe:	891b      	ldrh	r3, [r3, #8]
    2a00:	b21b      	sxth	r3, r3
    2a02:	4618      	mov	r0, r3
    2a04:	f7ff fa30 	bl	1e68 <NVIC_ClearPendingIRQ>

        /* Enable transmitter holding register Empty interrupt. */
        this_uart->hw_reg_bit->IER_ETBEI = 1U;
    2a08:	687b      	ldr	r3, [r7, #4]
    2a0a:	685b      	ldr	r3, [r3, #4]
    2a0c:	f04f 0201 	mov.w	r2, #1
    2a10:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

        /* Enable UART instance interrupt in Cortex-M3 NVIC. */
        NVIC_EnableIRQ( this_uart->irqn );
    2a14:	687b      	ldr	r3, [r7, #4]
    2a16:	891b      	ldrh	r3, [r3, #8]
    2a18:	b21b      	sxth	r3, r3
    2a1a:	4618      	mov	r0, r3
    2a1c:	f7ff f9ea 	bl	1df4 <NVIC_EnableIRQ>
    }
}
    2a20:	f107 0708 	add.w	r7, r7, #8
    2a24:	46bd      	mov	sp, r7
    2a26:	bd80      	pop	{r7, pc}

00002a28 <MSS_UART_set_modemstatus_handler>:
MSS_UART_set_modemstatus_handler
(
    mss_uart_instance_t * this_uart,
    mss_uart_irq_handler_t handler
)
{
    2a28:	b580      	push	{r7, lr}
    2a2a:	b082      	sub	sp, #8
    2a2c:	af00      	add	r7, sp, #0
    2a2e:	6078      	str	r0, [r7, #4]
    2a30:	6039      	str	r1, [r7, #0]
    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    2a32:	687a      	ldr	r2, [r7, #4]
    2a34:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    2a38:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a3c:	429a      	cmp	r2, r3
    2a3e:	d007      	beq.n	2a50 <MSS_UART_set_modemstatus_handler+0x28>
    2a40:	687a      	ldr	r2, [r7, #4]
    2a42:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    2a46:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a4a:	429a      	cmp	r2, r3
    2a4c:	d000      	beq.n	2a50 <MSS_UART_set_modemstatus_handler+0x28>
    2a4e:	be00      	bkpt	0x0000
    ASSERT( handler != INVALID_IRQ_HANDLER );
    2a50:	683b      	ldr	r3, [r7, #0]
    2a52:	2b00      	cmp	r3, #0
    2a54:	d100      	bne.n	2a58 <MSS_UART_set_modemstatus_handler+0x30>
    2a56:	be00      	bkpt	0x0000

    if( ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) ) &&
    2a58:	687a      	ldr	r2, [r7, #4]
    2a5a:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    2a5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a62:	429a      	cmp	r2, r3
    2a64:	d006      	beq.n	2a74 <MSS_UART_set_modemstatus_handler+0x4c>
    2a66:	687a      	ldr	r2, [r7, #4]
    2a68:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    2a6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a70:	429a      	cmp	r2, r3
    2a72:	d117      	bne.n	2aa4 <MSS_UART_set_modemstatus_handler+0x7c>
    2a74:	683b      	ldr	r3, [r7, #0]
    2a76:	2b00      	cmp	r3, #0
    2a78:	d014      	beq.n	2aa4 <MSS_UART_set_modemstatus_handler+0x7c>
        ( handler != INVALID_IRQ_HANDLER) )
    {
        this_uart->modemsts_handler = handler;
    2a7a:	687b      	ldr	r3, [r7, #4]
    2a7c:	683a      	ldr	r2, [r7, #0]
    2a7e:	625a      	str	r2, [r3, #36]	; 0x24

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ( this_uart->irqn );
    2a80:	687b      	ldr	r3, [r7, #4]
    2a82:	891b      	ldrh	r3, [r3, #8]
    2a84:	b21b      	sxth	r3, r3
    2a86:	4618      	mov	r0, r3
    2a88:	f7ff f9ee 	bl	1e68 <NVIC_ClearPendingIRQ>

        /* Enable modem status interrupt. */
        this_uart->hw_reg_bit->IER_EDSSI = 1U;
    2a8c:	687b      	ldr	r3, [r7, #4]
    2a8e:	685b      	ldr	r3, [r3, #4]
    2a90:	f04f 0201 	mov.w	r2, #1
    2a94:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

        /* Enable UART instance interrupt in Cortex-M3 NVIC. */
        NVIC_EnableIRQ( this_uart->irqn );
    2a98:	687b      	ldr	r3, [r7, #4]
    2a9a:	891b      	ldrh	r3, [r3, #8]
    2a9c:	b21b      	sxth	r3, r3
    2a9e:	4618      	mov	r0, r3
    2aa0:	f7ff f9a8 	bl	1df4 <NVIC_EnableIRQ>
    }
}
    2aa4:	f107 0708 	add.w	r7, r7, #8
    2aa8:	46bd      	mov	sp, r7
    2aaa:	bd80      	pop	{r7, pc}

00002aac <MSS_UART_fill_tx_fifo>:
(
    mss_uart_instance_t * this_uart,
    const uint8_t * tx_buffer,
    size_t tx_size
)
{
    2aac:	b480      	push	{r7}
    2aae:	b089      	sub	sp, #36	; 0x24
    2ab0:	af00      	add	r7, sp, #0
    2ab2:	60f8      	str	r0, [r7, #12]
    2ab4:	60b9      	str	r1, [r7, #8]
    2ab6:	607a      	str	r2, [r7, #4]
    uint8_t status = 0U;
    2ab8:	f04f 0300 	mov.w	r3, #0
    2abc:	75fb      	strb	r3, [r7, #23]
    size_t size_sent = 0U;
    2abe:	f04f 0300 	mov.w	r3, #0
    2ac2:	61bb      	str	r3, [r7, #24]

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    2ac4:	68fa      	ldr	r2, [r7, #12]
    2ac6:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    2aca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2ace:	429a      	cmp	r2, r3
    2ad0:	d007      	beq.n	2ae2 <MSS_UART_fill_tx_fifo+0x36>
    2ad2:	68fa      	ldr	r2, [r7, #12]
    2ad4:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    2ad8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2adc:	429a      	cmp	r2, r3
    2ade:	d000      	beq.n	2ae2 <MSS_UART_fill_tx_fifo+0x36>
    2ae0:	be00      	bkpt	0x0000
    ASSERT( tx_buffer != ( (uint8_t *)0 ) );
    2ae2:	68bb      	ldr	r3, [r7, #8]
    2ae4:	2b00      	cmp	r3, #0
    2ae6:	d100      	bne.n	2aea <MSS_UART_fill_tx_fifo+0x3e>
    2ae8:	be00      	bkpt	0x0000
    ASSERT( tx_size > 0 );
    2aea:	687b      	ldr	r3, [r7, #4]
    2aec:	2b00      	cmp	r3, #0
    2aee:	d100      	bne.n	2af2 <MSS_UART_fill_tx_fifo+0x46>
    2af0:	be00      	bkpt	0x0000

    /* Fill the UART's Tx FIFO until the FIFO is full or the complete input
     * buffer has been written. */
    if( ( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1 ) ) &&
    2af2:	68fa      	ldr	r2, [r7, #12]
    2af4:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    2af8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2afc:	429a      	cmp	r2, r3
    2afe:	d006      	beq.n	2b0e <MSS_UART_fill_tx_fifo+0x62>
    2b00:	68fa      	ldr	r2, [r7, #12]
    2b02:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    2b06:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2b0a:	429a      	cmp	r2, r3
    2b0c:	d131      	bne.n	2b72 <MSS_UART_fill_tx_fifo+0xc6>
    2b0e:	68bb      	ldr	r3, [r7, #8]
    2b10:	2b00      	cmp	r3, #0
    2b12:	d02e      	beq.n	2b72 <MSS_UART_fill_tx_fifo+0xc6>
    2b14:	687b      	ldr	r3, [r7, #4]
    2b16:	2b00      	cmp	r3, #0
    2b18:	d02b      	beq.n	2b72 <MSS_UART_fill_tx_fifo+0xc6>
        (tx_buffer != ( (uint8_t *)0 ))   &&
        (tx_size > 0u) )
    {
        status = this_uart->hw_reg->LSR;
    2b1a:	68fb      	ldr	r3, [r7, #12]
    2b1c:	681b      	ldr	r3, [r3, #0]
    2b1e:	7d1b      	ldrb	r3, [r3, #20]
    2b20:	75fb      	strb	r3, [r7, #23]
        this_uart->status |= status;
    2b22:	68fb      	ldr	r3, [r7, #12]
    2b24:	7a9a      	ldrb	r2, [r3, #10]
    2b26:	7dfb      	ldrb	r3, [r7, #23]
    2b28:	ea42 0303 	orr.w	r3, r2, r3
    2b2c:	b2da      	uxtb	r2, r3
    2b2e:	68fb      	ldr	r3, [r7, #12]
    2b30:	729a      	strb	r2, [r3, #10]

        if( status & MSS_UART_THRE )
    2b32:	7dfb      	ldrb	r3, [r7, #23]
    2b34:	f003 0320 	and.w	r3, r3, #32
    2b38:	2b00      	cmp	r3, #0
    2b3a:	d01a      	beq.n	2b72 <MSS_UART_fill_tx_fifo+0xc6>
        {
            uint32_t fill_size = TX_FIFO_SIZE;
    2b3c:	f04f 0310 	mov.w	r3, #16
    2b40:	61fb      	str	r3, [r7, #28]

            if ( tx_size < TX_FIFO_SIZE )
    2b42:	687b      	ldr	r3, [r7, #4]
    2b44:	2b0f      	cmp	r3, #15
    2b46:	d801      	bhi.n	2b4c <MSS_UART_fill_tx_fifo+0xa0>
            {
                fill_size = tx_size;
    2b48:	687b      	ldr	r3, [r7, #4]
    2b4a:	61fb      	str	r3, [r7, #28]
            }
            /* Fill up FIFO */
            for ( size_sent = 0U; size_sent < fill_size; ++size_sent )
    2b4c:	f04f 0300 	mov.w	r3, #0
    2b50:	61bb      	str	r3, [r7, #24]
    2b52:	e00a      	b.n	2b6a <MSS_UART_fill_tx_fifo+0xbe>
            {

                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = tx_buffer[size_sent];
    2b54:	68fb      	ldr	r3, [r7, #12]
    2b56:	681b      	ldr	r3, [r3, #0]
    2b58:	68b9      	ldr	r1, [r7, #8]
    2b5a:	69ba      	ldr	r2, [r7, #24]
    2b5c:	440a      	add	r2, r1
    2b5e:	7812      	ldrb	r2, [r2, #0]
    2b60:	701a      	strb	r2, [r3, #0]
            if ( tx_size < TX_FIFO_SIZE )
            {
                fill_size = tx_size;
            }
            /* Fill up FIFO */
            for ( size_sent = 0U; size_sent < fill_size; ++size_sent )
    2b62:	69bb      	ldr	r3, [r7, #24]
    2b64:	f103 0301 	add.w	r3, r3, #1
    2b68:	61bb      	str	r3, [r7, #24]
    2b6a:	69ba      	ldr	r2, [r7, #24]
    2b6c:	69fb      	ldr	r3, [r7, #28]
    2b6e:	429a      	cmp	r2, r3
    2b70:	d3f0      	bcc.n	2b54 <MSS_UART_fill_tx_fifo+0xa8>
                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = tx_buffer[size_sent];
            }
        }
    }
    return size_sent;
    2b72:	69bb      	ldr	r3, [r7, #24]
}
    2b74:	4618      	mov	r0, r3
    2b76:	f107 0724 	add.w	r7, r7, #36	; 0x24
    2b7a:	46bd      	mov	sp, r7
    2b7c:	bc80      	pop	{r7}
    2b7e:	4770      	bx	lr

00002b80 <MSS_UART_get_rx_status>:
uint8_t
MSS_UART_get_rx_status
(
    mss_uart_instance_t * this_uart
)
{
    2b80:	b480      	push	{r7}
    2b82:	b085      	sub	sp, #20
    2b84:	af00      	add	r7, sp, #0
    2b86:	6078      	str	r0, [r7, #4]
    uint8_t status = MSS_UART_INVALID_PARAM;
    2b88:	f04f 33ff 	mov.w	r3, #4294967295
    2b8c:	73fb      	strb	r3, [r7, #15]

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    2b8e:	687a      	ldr	r2, [r7, #4]
    2b90:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    2b94:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2b98:	429a      	cmp	r2, r3
    2b9a:	d007      	beq.n	2bac <MSS_UART_get_rx_status+0x2c>
    2b9c:	687a      	ldr	r2, [r7, #4]
    2b9e:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    2ba2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2ba6:	429a      	cmp	r2, r3
    2ba8:	d000      	beq.n	2bac <MSS_UART_get_rx_status+0x2c>
    2baa:	be00      	bkpt	0x0000

    if( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) )
    2bac:	687a      	ldr	r2, [r7, #4]
    2bae:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    2bb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2bb6:	429a      	cmp	r2, r3
    2bb8:	d006      	beq.n	2bc8 <MSS_UART_get_rx_status+0x48>
    2bba:	687a      	ldr	r2, [r7, #4]
    2bbc:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    2bc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2bc4:	429a      	cmp	r2, r3
    2bc6:	d113      	bne.n	2bf0 <MSS_UART_get_rx_status+0x70>
         * Bit 2 - Parity error status
         * Bit 3 - Frame error status
         * Bit 4 - Break interrupt indicator
         * Bit 7 - FIFO data error status
         */
        this_uart->status |= (this_uart->hw_reg->LSR);
    2bc8:	687b      	ldr	r3, [r7, #4]
    2bca:	7a9a      	ldrb	r2, [r3, #10]
    2bcc:	687b      	ldr	r3, [r7, #4]
    2bce:	681b      	ldr	r3, [r3, #0]
    2bd0:	7d1b      	ldrb	r3, [r3, #20]
    2bd2:	b2db      	uxtb	r3, r3
    2bd4:	ea42 0303 	orr.w	r3, r2, r3
    2bd8:	b2da      	uxtb	r2, r3
    2bda:	687b      	ldr	r3, [r7, #4]
    2bdc:	729a      	strb	r2, [r3, #10]
        status = (this_uart->status & STATUS_ERROR_MASK );
    2bde:	687b      	ldr	r3, [r7, #4]
    2be0:	7a9b      	ldrb	r3, [r3, #10]
    2be2:	f023 0361 	bic.w	r3, r3, #97	; 0x61
    2be6:	73fb      	strb	r3, [r7, #15]
        /* Clear the sticky status after reading */
        this_uart->status = 0U;
    2be8:	687b      	ldr	r3, [r7, #4]
    2bea:	f04f 0200 	mov.w	r2, #0
    2bee:	729a      	strb	r2, [r3, #10]
    }
    return status;
    2bf0:	7bfb      	ldrb	r3, [r7, #15]
}
    2bf2:	4618      	mov	r0, r3
    2bf4:	f107 0714 	add.w	r7, r7, #20
    2bf8:	46bd      	mov	sp, r7
    2bfa:	bc80      	pop	{r7}
    2bfc:	4770      	bx	lr
    2bfe:	bf00      	nop

00002c00 <MSS_UART_get_modem_status>:
uint8_t
MSS_UART_get_modem_status
(
    mss_uart_instance_t * this_uart
)
{
    2c00:	b480      	push	{r7}
    2c02:	b085      	sub	sp, #20
    2c04:	af00      	add	r7, sp, #0
    2c06:	6078      	str	r0, [r7, #4]
    uint8_t status = MSS_UART_INVALID_PARAM;
    2c08:	f04f 33ff 	mov.w	r3, #4294967295
    2c0c:	73fb      	strb	r3, [r7, #15]

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    2c0e:	687a      	ldr	r2, [r7, #4]
    2c10:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    2c14:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2c18:	429a      	cmp	r2, r3
    2c1a:	d007      	beq.n	2c2c <MSS_UART_get_modem_status+0x2c>
    2c1c:	687a      	ldr	r2, [r7, #4]
    2c1e:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    2c22:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2c26:	429a      	cmp	r2, r3
    2c28:	d000      	beq.n	2c2c <MSS_UART_get_modem_status+0x2c>
    2c2a:	be00      	bkpt	0x0000

    if( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) )
    2c2c:	687a      	ldr	r2, [r7, #4]
    2c2e:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    2c32:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2c36:	429a      	cmp	r2, r3
    2c38:	d006      	beq.n	2c48 <MSS_UART_get_modem_status+0x48>
    2c3a:	687a      	ldr	r2, [r7, #4]
    2c3c:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    2c40:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2c44:	429a      	cmp	r2, r3
    2c46:	d103      	bne.n	2c50 <MSS_UART_get_modem_status+0x50>
         * Bit 4 - Clear To Send
         * Bit 5 - Data Set Ready
         * Bit 6 - Ring Indicator
         * Bit 7 - Data Carrier Detect
         */
        status = this_uart->hw_reg->MSR;
    2c48:	687b      	ldr	r3, [r7, #4]
    2c4a:	681b      	ldr	r3, [r3, #0]
    2c4c:	7e1b      	ldrb	r3, [r3, #24]
    2c4e:	73fb      	strb	r3, [r7, #15]
    }
    return status;
    2c50:	7bfb      	ldrb	r3, [r7, #15]
}
    2c52:	4618      	mov	r0, r3
    2c54:	f107 0714 	add.w	r7, r7, #20
    2c58:	46bd      	mov	sp, r7
    2c5a:	bc80      	pop	{r7}
    2c5c:	4770      	bx	lr
    2c5e:	bf00      	nop

00002c60 <MSS_UART_get_tx_status>:
uint8_t
MSS_UART_get_tx_status
(
    mss_uart_instance_t * this_uart
)
{
    2c60:	b480      	push	{r7}
    2c62:	b085      	sub	sp, #20
    2c64:	af00      	add	r7, sp, #0
    2c66:	6078      	str	r0, [r7, #4]
    uint8_t status = MSS_UART_TX_BUSY;
    2c68:	f04f 0300 	mov.w	r3, #0
    2c6c:	73fb      	strb	r3, [r7, #15]

    ASSERT( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) );
    2c6e:	687a      	ldr	r2, [r7, #4]
    2c70:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    2c74:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2c78:	429a      	cmp	r2, r3
    2c7a:	d007      	beq.n	2c8c <MSS_UART_get_tx_status+0x2c>
    2c7c:	687a      	ldr	r2, [r7, #4]
    2c7e:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    2c82:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2c86:	429a      	cmp	r2, r3
    2c88:	d000      	beq.n	2c8c <MSS_UART_get_tx_status+0x2c>
    2c8a:	be00      	bkpt	0x0000

    if( (this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1) )
    2c8c:	687a      	ldr	r2, [r7, #4]
    2c8e:	f64a 13d0 	movw	r3, #43472	; 0xa9d0
    2c92:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2c96:	429a      	cmp	r2, r3
    2c98:	d006      	beq.n	2ca8 <MSS_UART_get_tx_status+0x48>
    2c9a:	687a      	ldr	r2, [r7, #4]
    2c9c:	f64a 13a8 	movw	r3, #43432	; 0xa9a8
    2ca0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2ca4:	429a      	cmp	r2, r3
    2ca6:	d10f      	bne.n	2cc8 <MSS_UART_get_tx_status+0x68>
    {
        /* Read the Line Status Register and update the sticky record. */
        status = this_uart->hw_reg->LSR;
    2ca8:	687b      	ldr	r3, [r7, #4]
    2caa:	681b      	ldr	r3, [r3, #0]
    2cac:	7d1b      	ldrb	r3, [r3, #20]
    2cae:	73fb      	strb	r3, [r7, #15]
        this_uart->status |= status;
    2cb0:	687b      	ldr	r3, [r7, #4]
    2cb2:	7a9a      	ldrb	r2, [r3, #10]
    2cb4:	7bfb      	ldrb	r3, [r7, #15]
    2cb6:	ea42 0303 	orr.w	r3, r2, r3
    2cba:	b2da      	uxtb	r2, r3
    2cbc:	687b      	ldr	r3, [r7, #4]
    2cbe:	729a      	strb	r2, [r3, #10]
        /*
         * Extract the transmit status bits from the UART's Line Status Register.
         * Bit 5 - Transmitter Holding Register/FIFO Empty (THRE) status. (If = 1, TX FIFO is empty)
         * Bit 6 - Transmitter Empty (TEMT) status. (If = 1, both TX FIFO and shift register are empty)
         */
        status &= ( MSS_UART_THRE | MSS_UART_TEMT );
    2cc0:	7bfb      	ldrb	r3, [r7, #15]
    2cc2:	f003 0360 	and.w	r3, r3, #96	; 0x60
    2cc6:	73fb      	strb	r3, [r7, #15]
    }
    return status;
    2cc8:	7bfb      	ldrb	r3, [r7, #15]
}
    2cca:	4618      	mov	r0, r3
    2ccc:	f107 0714 	add.w	r7, r7, #20
    2cd0:	46bd      	mov	sp, r7
    2cd2:	bc80      	pop	{r7}
    2cd4:	4770      	bx	lr
    2cd6:	bf00      	nop

00002cd8 <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
    2cd8:	b480      	push	{r7}
    2cda:	b083      	sub	sp, #12
    2cdc:	af00      	add	r7, sp, #0
    2cde:	4603      	mov	r3, r0
    2ce0:	80fb      	strh	r3, [r7, #6]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    2ce2:	f24e 1300 	movw	r3, #57600	; 0xe100
    2ce6:	f2ce 0300 	movt	r3, #57344	; 0xe000
    2cea:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    2cee:	ea4f 1252 	mov.w	r2, r2, lsr #5
    2cf2:	88f9      	ldrh	r1, [r7, #6]
    2cf4:	f001 011f 	and.w	r1, r1, #31
    2cf8:	f04f 0001 	mov.w	r0, #1
    2cfc:	fa00 f101 	lsl.w	r1, r0, r1
    2d00:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    2d04:	f107 070c 	add.w	r7, r7, #12
    2d08:	46bd      	mov	sp, r7
    2d0a:	bc80      	pop	{r7}
    2d0c:	4770      	bx	lr
    2d0e:	bf00      	nop

00002d10 <NVIC_DisableIRQ>:
 * 
 * Disable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
    2d10:	b480      	push	{r7}
    2d12:	b083      	sub	sp, #12
    2d14:	af00      	add	r7, sp, #0
    2d16:	4603      	mov	r3, r0
    2d18:	80fb      	strh	r3, [r7, #6]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
    2d1a:	f24e 1300 	movw	r3, #57600	; 0xe100
    2d1e:	f2ce 0300 	movt	r3, #57344	; 0xe000
    2d22:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    2d26:	ea4f 1252 	mov.w	r2, r2, lsr #5
    2d2a:	88f9      	ldrh	r1, [r7, #6]
    2d2c:	f001 011f 	and.w	r1, r1, #31
    2d30:	f04f 0001 	mov.w	r0, #1
    2d34:	fa00 f101 	lsl.w	r1, r0, r1
    2d38:	f102 0220 	add.w	r2, r2, #32
    2d3c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    2d40:	f107 070c 	add.w	r7, r7, #12
    2d44:	46bd      	mov	sp, r7
    2d46:	bc80      	pop	{r7}
    2d48:	4770      	bx	lr
    2d4a:	bf00      	nop

00002d4c <NVIC_ClearPendingIRQ>:
 *
 * Clear the pending bit for the specified interrupt. 
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
    2d4c:	b480      	push	{r7}
    2d4e:	b083      	sub	sp, #12
    2d50:	af00      	add	r7, sp, #0
    2d52:	4603      	mov	r3, r0
    2d54:	80fb      	strh	r3, [r7, #6]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    2d56:	f24e 1300 	movw	r3, #57600	; 0xe100
    2d5a:	f2ce 0300 	movt	r3, #57344	; 0xe000
    2d5e:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    2d62:	ea4f 1252 	mov.w	r2, r2, lsr #5
    2d66:	88f9      	ldrh	r1, [r7, #6]
    2d68:	f001 011f 	and.w	r1, r1, #31
    2d6c:	f04f 0001 	mov.w	r0, #1
    2d70:	fa00 f101 	lsl.w	r1, r0, r1
    2d74:	f102 0260 	add.w	r2, r2, #96	; 0x60
    2d78:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    2d7c:	f107 070c 	add.w	r7, r7, #12
    2d80:	46bd      	mov	sp, r7
    2d82:	bc80      	pop	{r7}
    2d84:	4770      	bx	lr
    2d86:	bf00      	nop

00002d88 <MSS_I2C_init>:
(
    mss_i2c_instance_t * this_i2c,
    uint8_t ser_address,
    mss_i2c_clock_divider_t ser_clock_speed
)
{
    2d88:	b580      	push	{r7, lr}
    2d8a:	b084      	sub	sp, #16
    2d8c:	af00      	add	r7, sp, #0
    2d8e:	6078      	str	r0, [r7, #4]
    2d90:	4613      	mov	r3, r2
    2d92:	460a      	mov	r2, r1
    2d94:	70fa      	strb	r2, [r7, #3]
    2d96:	70bb      	strb	r3, [r7, #2]
    uint32_t primask;
    uint_fast16_t clock_speed = (uint_fast16_t)ser_clock_speed;
    2d98:	78bb      	ldrb	r3, [r7, #2]
    2d9a:	60fb      	str	r3, [r7, #12]
    
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    2d9c:	687a      	ldr	r2, [r7, #4]
    2d9e:	f64a 13f8 	movw	r3, #43512	; 0xa9f8
    2da2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2da6:	429a      	cmp	r2, r3
    2da8:	d007      	beq.n	2dba <MSS_I2C_init+0x32>
    2daa:	687a      	ldr	r2, [r7, #4]
    2dac:	f64a 236c 	movw	r3, #43628	; 0xaa6c
    2db0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2db4:	429a      	cmp	r2, r3
    2db6:	d000      	beq.n	2dba <MSS_I2C_init+0x32>
    2db8:	be00      	bkpt	0x0000
     * Initialize all items of the this_i2c data structure to zero. This
     * initializes all state variables to their init value. It relies on
     * the fact that NO_TRANSACTION, I2C_SUCCESS and I2C_RELEASE_BUS all
     * have an actual value of zero.
     */
    primask = disable_interrupts();
    2dba:	f001 f98f 	bl	40dc <disable_interrupts>
    2dbe:	4603      	mov	r3, r0
    2dc0:	60bb      	str	r3, [r7, #8]
    memset(this_i2c, 0, sizeof(mss_i2c_instance_t));
    2dc2:	6878      	ldr	r0, [r7, #4]
    2dc4:	f04f 0100 	mov.w	r1, #0
    2dc8:	f04f 0274 	mov.w	r2, #116	; 0x74
    2dcc:	f012 fbfa 	bl	155c4 <memset>
    
    if ( this_i2c == &g_mss_i2c0 )
    2dd0:	687a      	ldr	r2, [r7, #4]
    2dd2:	f64a 13f8 	movw	r3, #43512	; 0xa9f8
    2dd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2dda:	429a      	cmp	r2, r3
    2ddc:	d12c      	bne.n	2e38 <MSS_I2C_init+0xb0>
    {
        this_i2c->irqn = I2C0_IRQn;
    2dde:	687b      	ldr	r3, [r7, #4]
    2de0:	f04f 020e 	mov.w	r2, #14
    2de4:	825a      	strh	r2, [r3, #18]
        this_i2c->hw_reg = I2C0;
    2de6:	687a      	ldr	r2, [r7, #4]
    2de8:	f242 0300 	movw	r3, #8192	; 0x2000
    2dec:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2df0:	6153      	str	r3, [r2, #20]
        this_i2c->hw_reg_bit = I2C0_BITBAND;
    2df2:	687a      	ldr	r2, [r7, #4]
    2df4:	f240 0300 	movw	r3, #0
    2df8:	f2c4 2304 	movt	r3, #16900	; 0x4204
    2dfc:	6193      	str	r3, [r2, #24]
        
        /* reset I2C0 */
        SYSREG->SOFT_RST_CR |= SYSREG_I2C0_SOFTRESET_MASK;
    2dfe:	f242 0300 	movw	r3, #8192	; 0x2000
    2e02:	f2ce 0304 	movt	r3, #57348	; 0xe004
    2e06:	f242 0200 	movw	r2, #8192	; 0x2000
    2e0a:	f2ce 0204 	movt	r2, #57348	; 0xe004
    2e0e:	6b12      	ldr	r2, [r2, #48]	; 0x30
    2e10:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
    2e14:	631a      	str	r2, [r3, #48]	; 0x30
        /* Clear any previously pended I2C0 interrupt */
        NVIC_ClearPendingIRQ( I2C0_IRQn );
    2e16:	f04f 000e 	mov.w	r0, #14
    2e1a:	f7ff ff97 	bl	2d4c <NVIC_ClearPendingIRQ>
        /* Take I2C0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_I2C0_SOFTRESET_MASK;
    2e1e:	f242 0300 	movw	r3, #8192	; 0x2000
    2e22:	f2ce 0304 	movt	r3, #57348	; 0xe004
    2e26:	f242 0200 	movw	r2, #8192	; 0x2000
    2e2a:	f2ce 0204 	movt	r2, #57348	; 0xe004
    2e2e:	6b12      	ldr	r2, [r2, #48]	; 0x30
    2e30:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
    2e34:	631a      	str	r2, [r3, #48]	; 0x30
    2e36:	e02b      	b.n	2e90 <MSS_I2C_init+0x108>
    }
    else
    {
        this_i2c->irqn = I2C1_IRQn;
    2e38:	687b      	ldr	r3, [r7, #4]
    2e3a:	f04f 0211 	mov.w	r2, #17
    2e3e:	825a      	strh	r2, [r3, #18]
        this_i2c->hw_reg = I2C1;
    2e40:	687a      	ldr	r2, [r7, #4]
    2e42:	f242 0300 	movw	r3, #8192	; 0x2000
    2e46:	f2c4 0301 	movt	r3, #16385	; 0x4001
    2e4a:	6153      	str	r3, [r2, #20]
        this_i2c->hw_reg_bit = I2C1_BITBAND;
    2e4c:	687a      	ldr	r2, [r7, #4]
    2e4e:	f240 0300 	movw	r3, #0
    2e52:	f2c4 2324 	movt	r3, #16932	; 0x4224
    2e56:	6193      	str	r3, [r2, #24]
        
        /* reset I2C1 */
        SYSREG->SOFT_RST_CR |= SYSREG_I2C1_SOFTRESET_MASK;
    2e58:	f242 0300 	movw	r3, #8192	; 0x2000
    2e5c:	f2ce 0304 	movt	r3, #57348	; 0xe004
    2e60:	f242 0200 	movw	r2, #8192	; 0x2000
    2e64:	f2ce 0204 	movt	r2, #57348	; 0xe004
    2e68:	6b12      	ldr	r2, [r2, #48]	; 0x30
    2e6a:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
    2e6e:	631a      	str	r2, [r3, #48]	; 0x30
        /* Clear any previously pended I2C1 interrupt */
        NVIC_ClearPendingIRQ( I2C1_IRQn );
    2e70:	f04f 0011 	mov.w	r0, #17
    2e74:	f7ff ff6a 	bl	2d4c <NVIC_ClearPendingIRQ>
        /* Take I2C1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_I2C1_SOFTRESET_MASK;
    2e78:	f242 0300 	movw	r3, #8192	; 0x2000
    2e7c:	f2ce 0304 	movt	r3, #57348	; 0xe004
    2e80:	f242 0200 	movw	r2, #8192	; 0x2000
    2e84:	f2ce 0204 	movt	r2, #57348	; 0xe004
    2e88:	6b12      	ldr	r2, [r2, #48]	; 0x30
    2e8a:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
    2e8e:	631a      	str	r2, [r3, #48]	; 0x30
    }
    
    /* Use same base address for SMBus bitband access */
    this_i2c->hw_smb_reg_bit = (I2C_SMBus_BitBand_TypeDef *)this_i2c->hw_reg_bit;
    2e90:	687b      	ldr	r3, [r7, #4]
    2e92:	699b      	ldr	r3, [r3, #24]
    2e94:	461a      	mov	r2, r3
    2e96:	687b      	ldr	r3, [r7, #4]
    2e98:	61da      	str	r2, [r3, #28]

    /* Update Serial address of the device */
    this_i2c->ser_address = (uint_fast8_t)ser_address << 1u;
    2e9a:	78fb      	ldrb	r3, [r7, #3]
    2e9c:	ea4f 0243 	mov.w	r2, r3, lsl #1
    2ea0:	687b      	ldr	r3, [r7, #4]
    2ea2:	601a      	str	r2, [r3, #0]

    this_i2c->hw_reg_bit->CTRL_CR2 = (uint32_t)((clock_speed >> 2u) & 0x01u);
    2ea4:	687b      	ldr	r3, [r7, #4]
    2ea6:	699b      	ldr	r3, [r3, #24]
    2ea8:	68fa      	ldr	r2, [r7, #12]
    2eaa:	ea4f 0292 	mov.w	r2, r2, lsr #2
    2eae:	f002 0201 	and.w	r2, r2, #1
    2eb2:	61da      	str	r2, [r3, #28]
    this_i2c->hw_reg_bit->CTRL_CR1 = (uint32_t)((clock_speed >> 1u) & 0x01u);
    2eb4:	687b      	ldr	r3, [r7, #4]
    2eb6:	699b      	ldr	r3, [r3, #24]
    2eb8:	68fa      	ldr	r2, [r7, #12]
    2eba:	ea4f 0252 	mov.w	r2, r2, lsr #1
    2ebe:	f002 0201 	and.w	r2, r2, #1
    2ec2:	605a      	str	r2, [r3, #4]
    this_i2c->hw_reg_bit->CTRL_CR0 = (uint32_t)(clock_speed & 0x01u);
    2ec4:	687b      	ldr	r3, [r7, #4]
    2ec6:	699b      	ldr	r3, [r3, #24]
    2ec8:	68fa      	ldr	r2, [r7, #12]
    2eca:	f002 0201 	and.w	r2, r2, #1
    2ece:	601a      	str	r2, [r3, #0]
    this_i2c->hw_reg->ADDR = (uint8_t)this_i2c->ser_address;
    2ed0:	687b      	ldr	r3, [r7, #4]
    2ed2:	695b      	ldr	r3, [r3, #20]
    2ed4:	687a      	ldr	r2, [r7, #4]
    2ed6:	6812      	ldr	r2, [r2, #0]
    2ed8:	b2d2      	uxtb	r2, r2
    2eda:	731a      	strb	r2, [r3, #12]
    this_i2c->hw_reg_bit->CTRL_ENS1 = 0x01u; /* set enable bit */
    2edc:	687b      	ldr	r3, [r7, #4]
    2ede:	699b      	ldr	r3, [r3, #24]
    2ee0:	f04f 0201 	mov.w	r2, #1
    2ee4:	619a      	str	r2, [r3, #24]
    restore_interrupts( primask );
    2ee6:	68b8      	ldr	r0, [r7, #8]
    2ee8:	f001 f90a 	bl	4100 <restore_interrupts>
}
    2eec:	f107 0710 	add.w	r7, r7, #16
    2ef0:	46bd      	mov	sp, r7
    2ef2:	bd80      	pop	{r7, pc}

00002ef4 <MSS_I2C_write>:
    uint8_t serial_addr,
    const uint8_t * write_buffer,
    uint16_t write_size,
    uint8_t options
)
{
    2ef4:	b580      	push	{r7, lr}
    2ef6:	b086      	sub	sp, #24
    2ef8:	af00      	add	r7, sp, #0
    2efa:	60f8      	str	r0, [r7, #12]
    2efc:	607a      	str	r2, [r7, #4]
    2efe:	460a      	mov	r2, r1
    2f00:	72fa      	strb	r2, [r7, #11]
    2f02:	807b      	strh	r3, [r7, #2]
    uint32_t primask;
    volatile uint8_t stat_ctrl;

    ASSERT((this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1));
    2f04:	68fa      	ldr	r2, [r7, #12]
    2f06:	f64a 13f8 	movw	r3, #43512	; 0xa9f8
    2f0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2f0e:	429a      	cmp	r2, r3
    2f10:	d007      	beq.n	2f22 <MSS_I2C_write+0x2e>
    2f12:	68fa      	ldr	r2, [r7, #12]
    2f14:	f64a 236c 	movw	r3, #43628	; 0xaa6c
    2f18:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2f1c:	429a      	cmp	r2, r3
    2f1e:	d000      	beq.n	2f22 <MSS_I2C_write+0x2e>
    2f20:	be00      	bkpt	0x0000

    primask = disable_interrupts();
    2f22:	f001 f8db 	bl	40dc <disable_interrupts>
    2f26:	4603      	mov	r3, r0
    2f28:	617b      	str	r3, [r7, #20]

    /* Update the transaction only when there is no transaction going on I2C */
    if( this_i2c->transaction == NO_TRANSACTION)
    2f2a:	68fb      	ldr	r3, [r7, #12]
    2f2c:	7a1b      	ldrb	r3, [r3, #8]
    2f2e:	2b00      	cmp	r3, #0
    2f30:	d103      	bne.n	2f3a <MSS_I2C_write+0x46>
    {
      this_i2c->transaction = MASTER_WRITE_TRANSACTION;
    2f32:	68fb      	ldr	r3, [r7, #12]
    2f34:	f04f 0201 	mov.w	r2, #1
    2f38:	721a      	strb	r2, [r3, #8]
    }

    /* Update the Pending transaction information so that transaction can restarted */
    this_i2c->pending_transaction = MASTER_WRITE_TRANSACTION ;
    2f3a:	68fb      	ldr	r3, [r7, #12]
    2f3c:	f04f 0201 	mov.w	r2, #1
    2f40:	f883 2072 	strb.w	r2, [r3, #114]	; 0x72

    /* Update target address */
    this_i2c->target_addr = (uint_fast8_t)serial_addr << 1u;
    2f44:	7afb      	ldrb	r3, [r7, #11]
    2f46:	ea4f 0243 	mov.w	r2, r3, lsl #1
    2f4a:	68fb      	ldr	r3, [r7, #12]
    2f4c:	605a      	str	r2, [r3, #4]

    this_i2c->dir = WRITE_DIR;
    2f4e:	68fb      	ldr	r3, [r7, #12]
    2f50:	f04f 0200 	mov.w	r2, #0
    2f54:	62da      	str	r2, [r3, #44]	; 0x2c

    this_i2c->master_tx_buffer = write_buffer;
    2f56:	68fb      	ldr	r3, [r7, #12]
    2f58:	687a      	ldr	r2, [r7, #4]
    2f5a:	621a      	str	r2, [r3, #32]
    this_i2c->master_tx_size = write_size;
    2f5c:	887a      	ldrh	r2, [r7, #2]
    2f5e:	68fb      	ldr	r3, [r7, #12]
    2f60:	625a      	str	r2, [r3, #36]	; 0x24
    this_i2c->master_tx_idx = 0u;
    2f62:	68fb      	ldr	r3, [r7, #12]
    2f64:	f04f 0200 	mov.w	r2, #0
    2f68:	629a      	str	r2, [r3, #40]	; 0x28

    /* Set I2C status in progress */
    this_i2c->master_status = MSS_I2C_IN_PROGRESS;
    2f6a:	68fb      	ldr	r3, [r7, #12]
    2f6c:	f04f 0201 	mov.w	r2, #1
    2f70:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    this_i2c->options = options;
    2f74:	68fb      	ldr	r3, [r7, #12]
    2f76:	f897 2020 	ldrb.w	r2, [r7, #32]
    2f7a:	741a      	strb	r2, [r3, #16]

    if(MSS_I2C_IN_PROGRESS == this_i2c->slave_status)
    2f7c:	68fb      	ldr	r3, [r7, #12]
    2f7e:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    2f82:	b2db      	uxtb	r3, r3
    2f84:	2b01      	cmp	r3, #1
    2f86:	d105      	bne.n	2f94 <MSS_I2C_write+0xa0>
    {
        this_i2c->is_transaction_pending = 1u;
    2f88:	68fb      	ldr	r3, [r7, #12]
    2f8a:	f04f 0201 	mov.w	r2, #1
    2f8e:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
    2f92:	e004      	b.n	2f9e <MSS_I2C_write+0xaa>
    }
    else
    {
        this_i2c->hw_reg_bit->CTRL_STA = 0x01u;
    2f94:	68fb      	ldr	r3, [r7, #12]
    2f96:	699b      	ldr	r3, [r3, #24]
    2f98:	f04f 0201 	mov.w	r2, #1
    2f9c:	615a      	str	r2, [r3, #20]
    /*
     * Clear interrupts if required (depends on repeated starts).
     * Since the Bus is on hold, only then prior status needs to
     * be cleared.
     */
    if ( MSS_I2C_HOLD_BUS == this_i2c->bus_status )
    2f9e:	68fb      	ldr	r3, [r7, #12]
    2fa0:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
    2fa4:	2b01      	cmp	r3, #1
    2fa6:	d111      	bne.n	2fcc <MSS_I2C_write+0xd8>
    {
        this_i2c->hw_reg_bit->CTRL_SI = 0u;
    2fa8:	68fb      	ldr	r3, [r7, #12]
    2faa:	699b      	ldr	r3, [r3, #24]
    2fac:	f04f 0200 	mov.w	r2, #0
    2fb0:	60da      	str	r2, [r3, #12]
        stat_ctrl = this_i2c->hw_reg->STATUS;
    2fb2:	68fb      	ldr	r3, [r7, #12]
    2fb4:	695b      	ldr	r3, [r3, #20]
    2fb6:	791b      	ldrb	r3, [r3, #4]
    2fb8:	74fb      	strb	r3, [r7, #19]
        stat_ctrl = stat_ctrl;  /* Avoids Lint warning */
    2fba:	7cfb      	ldrb	r3, [r7, #19]
    2fbc:	b2db      	uxtb	r3, r3
    2fbe:	74fb      	strb	r3, [r7, #19]
        NVIC_ClearPendingIRQ( this_i2c->irqn );
    2fc0:	68fb      	ldr	r3, [r7, #12]
    2fc2:	8a5b      	ldrh	r3, [r3, #18]
    2fc4:	b21b      	sxth	r3, r3
    2fc6:	4618      	mov	r0, r3
    2fc8:	f7ff fec0 	bl	2d4c <NVIC_ClearPendingIRQ>
    }

    /* Enable the interrupt. ( Re-enable) */
    NVIC_EnableIRQ( this_i2c->irqn );
    2fcc:	68fb      	ldr	r3, [r7, #12]
    2fce:	8a5b      	ldrh	r3, [r3, #18]
    2fd0:	b21b      	sxth	r3, r3
    2fd2:	4618      	mov	r0, r3
    2fd4:	f7ff fe80 	bl	2cd8 <NVIC_EnableIRQ>

    restore_interrupts( primask );
    2fd8:	6978      	ldr	r0, [r7, #20]
    2fda:	f001 f891 	bl	4100 <restore_interrupts>
}
    2fde:	f107 0718 	add.w	r7, r7, #24
    2fe2:	46bd      	mov	sp, r7
    2fe4:	bd80      	pop	{r7, pc}
    2fe6:	bf00      	nop

00002fe8 <MSS_I2C_read>:
    uint8_t serial_addr,
    uint8_t * read_buffer,
    uint16_t read_size,
    uint8_t options
)
{
    2fe8:	b580      	push	{r7, lr}
    2fea:	b086      	sub	sp, #24
    2fec:	af00      	add	r7, sp, #0
    2fee:	60f8      	str	r0, [r7, #12]
    2ff0:	607a      	str	r2, [r7, #4]
    2ff2:	460a      	mov	r2, r1
    2ff4:	72fa      	strb	r2, [r7, #11]
    2ff6:	807b      	strh	r3, [r7, #2]
    uint32_t primask;
    volatile uint8_t stat_ctrl;

    ASSERT((this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1));
    2ff8:	68fa      	ldr	r2, [r7, #12]
    2ffa:	f64a 13f8 	movw	r3, #43512	; 0xa9f8
    2ffe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3002:	429a      	cmp	r2, r3
    3004:	d007      	beq.n	3016 <MSS_I2C_read+0x2e>
    3006:	68fa      	ldr	r2, [r7, #12]
    3008:	f64a 236c 	movw	r3, #43628	; 0xaa6c
    300c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3010:	429a      	cmp	r2, r3
    3012:	d000      	beq.n	3016 <MSS_I2C_read+0x2e>
    3014:	be00      	bkpt	0x0000

    primask = disable_interrupts();
    3016:	f001 f861 	bl	40dc <disable_interrupts>
    301a:	4603      	mov	r3, r0
    301c:	617b      	str	r3, [r7, #20]
    
    /* Update the transaction only when there is no transaction going on I2C */
    if( this_i2c->transaction == NO_TRANSACTION)
    301e:	68fb      	ldr	r3, [r7, #12]
    3020:	7a1b      	ldrb	r3, [r3, #8]
    3022:	2b00      	cmp	r3, #0
    3024:	d103      	bne.n	302e <MSS_I2C_read+0x46>
    {
      this_i2c->transaction = MASTER_READ_TRANSACTION;
    3026:	68fb      	ldr	r3, [r7, #12]
    3028:	f04f 0202 	mov.w	r2, #2
    302c:	721a      	strb	r2, [r3, #8]
    }

    /* Update the Pending transaction information so that transaction can restarted */
    this_i2c->pending_transaction = MASTER_READ_TRANSACTION ;
    302e:	68fb      	ldr	r3, [r7, #12]
    3030:	f04f 0202 	mov.w	r2, #2
    3034:	f883 2072 	strb.w	r2, [r3, #114]	; 0x72

    /* Update target address */
    this_i2c->target_addr = (uint_fast8_t)serial_addr << 1u;
    3038:	7afb      	ldrb	r3, [r7, #11]
    303a:	ea4f 0243 	mov.w	r2, r3, lsl #1
    303e:	68fb      	ldr	r3, [r7, #12]
    3040:	605a      	str	r2, [r3, #4]

    this_i2c->dir = READ_DIR;
    3042:	68fb      	ldr	r3, [r7, #12]
    3044:	f04f 0201 	mov.w	r2, #1
    3048:	62da      	str	r2, [r3, #44]	; 0x2c

    this_i2c->master_rx_buffer = read_buffer;
    304a:	68fb      	ldr	r3, [r7, #12]
    304c:	687a      	ldr	r2, [r7, #4]
    304e:	631a      	str	r2, [r3, #48]	; 0x30
    this_i2c->master_rx_size = read_size;
    3050:	887a      	ldrh	r2, [r7, #2]
    3052:	68fb      	ldr	r3, [r7, #12]
    3054:	635a      	str	r2, [r3, #52]	; 0x34
    this_i2c->master_rx_idx = 0u;
    3056:	68fb      	ldr	r3, [r7, #12]
    3058:	f04f 0200 	mov.w	r2, #0
    305c:	639a      	str	r2, [r3, #56]	; 0x38
    
    /* Set I2C status in progress */
    this_i2c->master_status = MSS_I2C_IN_PROGRESS;
    305e:	68fb      	ldr	r3, [r7, #12]
    3060:	f04f 0201 	mov.w	r2, #1
    3064:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    this_i2c->options = options;
    3068:	68fb      	ldr	r3, [r7, #12]
    306a:	f897 2020 	ldrb.w	r2, [r7, #32]
    306e:	741a      	strb	r2, [r3, #16]

    if(MSS_I2C_IN_PROGRESS == this_i2c->slave_status)
    3070:	68fb      	ldr	r3, [r7, #12]
    3072:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    3076:	b2db      	uxtb	r3, r3
    3078:	2b01      	cmp	r3, #1
    307a:	d105      	bne.n	3088 <MSS_I2C_read+0xa0>
    {
        this_i2c->is_transaction_pending = 1u;
    307c:	68fb      	ldr	r3, [r7, #12]
    307e:	f04f 0201 	mov.w	r2, #1
    3082:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
    3086:	e004      	b.n	3092 <MSS_I2C_read+0xaa>
    }
    else
    {
        this_i2c->hw_reg_bit->CTRL_STA = 0x01u;
    3088:	68fb      	ldr	r3, [r7, #12]
    308a:	699b      	ldr	r3, [r3, #24]
    308c:	f04f 0201 	mov.w	r2, #1
    3090:	615a      	str	r2, [r3, #20]
    /*
     * Clear interrupts if required (depends on repeated starts).
     * Since the Bus is on hold, only then prior status needs to
     * be cleared.
     */
    if ( MSS_I2C_HOLD_BUS == this_i2c->bus_status )
    3092:	68fb      	ldr	r3, [r7, #12]
    3094:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
    3098:	2b01      	cmp	r3, #1
    309a:	d111      	bne.n	30c0 <MSS_I2C_read+0xd8>
    {
        this_i2c->hw_reg_bit->CTRL_SI = 0u;
    309c:	68fb      	ldr	r3, [r7, #12]
    309e:	699b      	ldr	r3, [r3, #24]
    30a0:	f04f 0200 	mov.w	r2, #0
    30a4:	60da      	str	r2, [r3, #12]
        stat_ctrl = this_i2c->hw_reg->STATUS;
    30a6:	68fb      	ldr	r3, [r7, #12]
    30a8:	695b      	ldr	r3, [r3, #20]
    30aa:	791b      	ldrb	r3, [r3, #4]
    30ac:	74fb      	strb	r3, [r7, #19]
        stat_ctrl = stat_ctrl;  /* Avoids Lint warning */
    30ae:	7cfb      	ldrb	r3, [r7, #19]
    30b0:	b2db      	uxtb	r3, r3
    30b2:	74fb      	strb	r3, [r7, #19]
        NVIC_ClearPendingIRQ( this_i2c->irqn );
    30b4:	68fb      	ldr	r3, [r7, #12]
    30b6:	8a5b      	ldrh	r3, [r3, #18]
    30b8:	b21b      	sxth	r3, r3
    30ba:	4618      	mov	r0, r3
    30bc:	f7ff fe46 	bl	2d4c <NVIC_ClearPendingIRQ>
    }
    
    /* Enable the interrupt. ( Re-enable) */
    NVIC_EnableIRQ( this_i2c->irqn );
    30c0:	68fb      	ldr	r3, [r7, #12]
    30c2:	8a5b      	ldrh	r3, [r3, #18]
    30c4:	b21b      	sxth	r3, r3
    30c6:	4618      	mov	r0, r3
    30c8:	f7ff fe06 	bl	2cd8 <NVIC_EnableIRQ>
    restore_interrupts( primask );
    30cc:	6978      	ldr	r0, [r7, #20]
    30ce:	f001 f817 	bl	4100 <restore_interrupts>
}
    30d2:	f107 0718 	add.w	r7, r7, #24
    30d6:	46bd      	mov	sp, r7
    30d8:	bd80      	pop	{r7, pc}
    30da:	bf00      	nop

000030dc <MSS_I2C_write_read>:
    uint16_t offset_size,
    uint8_t * read_buffer,
    uint16_t read_size,
    uint8_t options
)
{
    30dc:	b580      	push	{r7, lr}
    30de:	b086      	sub	sp, #24
    30e0:	af00      	add	r7, sp, #0
    30e2:	60f8      	str	r0, [r7, #12]
    30e4:	607a      	str	r2, [r7, #4]
    30e6:	460a      	mov	r2, r1
    30e8:	72fa      	strb	r2, [r7, #11]
    30ea:	807b      	strh	r3, [r7, #2]
    ASSERT((this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1));
    30ec:	68fa      	ldr	r2, [r7, #12]
    30ee:	f64a 13f8 	movw	r3, #43512	; 0xa9f8
    30f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    30f6:	429a      	cmp	r2, r3
    30f8:	d007      	beq.n	310a <MSS_I2C_write_read+0x2e>
    30fa:	68fa      	ldr	r2, [r7, #12]
    30fc:	f64a 236c 	movw	r3, #43628	; 0xaa6c
    3100:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3104:	429a      	cmp	r2, r3
    3106:	d000      	beq.n	310a <MSS_I2C_write_read+0x2e>
    3108:	be00      	bkpt	0x0000
    ASSERT(offset_size > 0u);
    310a:	887b      	ldrh	r3, [r7, #2]
    310c:	2b00      	cmp	r3, #0
    310e:	d100      	bne.n	3112 <MSS_I2C_write_read+0x36>
    3110:	be00      	bkpt	0x0000
    ASSERT(addr_offset != (const uint8_t *)0);
    3112:	687b      	ldr	r3, [r7, #4]
    3114:	2b00      	cmp	r3, #0
    3116:	d100      	bne.n	311a <MSS_I2C_write_read+0x3e>
    3118:	be00      	bkpt	0x0000
    ASSERT(read_size > 0u);
    311a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
    311c:	2b00      	cmp	r3, #0
    311e:	d100      	bne.n	3122 <MSS_I2C_write_read+0x46>
    3120:	be00      	bkpt	0x0000
    ASSERT(read_buffer != (uint8_t *)0);
    3122:	6a3b      	ldr	r3, [r7, #32]
    3124:	2b00      	cmp	r3, #0
    3126:	d100      	bne.n	312a <MSS_I2C_write_read+0x4e>
    3128:	be00      	bkpt	0x0000

    if((read_size > 0u) && (offset_size > 0u))
    312a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
    312c:	2b00      	cmp	r3, #0
    312e:	d06a      	beq.n	3206 <MSS_I2C_write_read+0x12a>
    3130:	887b      	ldrh	r3, [r7, #2]
    3132:	2b00      	cmp	r3, #0
    3134:	d067      	beq.n	3206 <MSS_I2C_write_read+0x12a>
    {
        uint32_t primask;
        volatile uint8_t stat_ctrl;

        primask = disable_interrupts();
    3136:	f000 ffd1 	bl	40dc <disable_interrupts>
    313a:	4603      	mov	r3, r0
    313c:	617b      	str	r3, [r7, #20]

        /* Update the transaction only when there is no transaction going on I2C */
        if( this_i2c->transaction == NO_TRANSACTION)
    313e:	68fb      	ldr	r3, [r7, #12]
    3140:	7a1b      	ldrb	r3, [r3, #8]
    3142:	2b00      	cmp	r3, #0
    3144:	d103      	bne.n	314e <MSS_I2C_write_read+0x72>
        {
            this_i2c->transaction = MASTER_RANDOM_READ_TRANSACTION;
    3146:	68fb      	ldr	r3, [r7, #12]
    3148:	f04f 0203 	mov.w	r2, #3
    314c:	721a      	strb	r2, [r3, #8]
        }

        /* Update the Pending transaction information so that transaction can restarted */
        this_i2c->pending_transaction = MASTER_RANDOM_READ_TRANSACTION ;
    314e:	68fb      	ldr	r3, [r7, #12]
    3150:	f04f 0203 	mov.w	r2, #3
    3154:	f883 2072 	strb.w	r2, [r3, #114]	; 0x72

        /* Update target address */
        this_i2c->target_addr = (uint_fast8_t)serial_addr << 1u;
    3158:	7afb      	ldrb	r3, [r7, #11]
    315a:	ea4f 0243 	mov.w	r2, r3, lsl #1
    315e:	68fb      	ldr	r3, [r7, #12]
    3160:	605a      	str	r2, [r3, #4]

        this_i2c->dir = WRITE_DIR;
    3162:	68fb      	ldr	r3, [r7, #12]
    3164:	f04f 0200 	mov.w	r2, #0
    3168:	62da      	str	r2, [r3, #44]	; 0x2c
        this_i2c->master_tx_buffer = addr_offset;
    316a:	68fb      	ldr	r3, [r7, #12]
    316c:	687a      	ldr	r2, [r7, #4]
    316e:	621a      	str	r2, [r3, #32]
        this_i2c->master_tx_size = offset_size;
    3170:	887a      	ldrh	r2, [r7, #2]
    3172:	68fb      	ldr	r3, [r7, #12]
    3174:	625a      	str	r2, [r3, #36]	; 0x24
        this_i2c->master_tx_idx = 0u;
    3176:	68fb      	ldr	r3, [r7, #12]
    3178:	f04f 0200 	mov.w	r2, #0
    317c:	629a      	str	r2, [r3, #40]	; 0x28

        this_i2c->master_rx_buffer = read_buffer;
    317e:	68fb      	ldr	r3, [r7, #12]
    3180:	6a3a      	ldr	r2, [r7, #32]
    3182:	631a      	str	r2, [r3, #48]	; 0x30
        this_i2c->master_rx_size = read_size;
    3184:	8cba      	ldrh	r2, [r7, #36]	; 0x24
    3186:	68fb      	ldr	r3, [r7, #12]
    3188:	635a      	str	r2, [r3, #52]	; 0x34
        this_i2c->master_rx_idx = 0u;
    318a:	68fb      	ldr	r3, [r7, #12]
    318c:	f04f 0200 	mov.w	r2, #0
    3190:	639a      	str	r2, [r3, #56]	; 0x38

        /* Set I2C status in progress */
        this_i2c->master_status = MSS_I2C_IN_PROGRESS;
    3192:	68fb      	ldr	r3, [r7, #12]
    3194:	f04f 0201 	mov.w	r2, #1
    3198:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
        this_i2c->options = options;
    319c:	68fb      	ldr	r3, [r7, #12]
    319e:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
    31a2:	741a      	strb	r2, [r3, #16]

        if(MSS_I2C_IN_PROGRESS == this_i2c->slave_status)
    31a4:	68fb      	ldr	r3, [r7, #12]
    31a6:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    31aa:	b2db      	uxtb	r3, r3
    31ac:	2b01      	cmp	r3, #1
    31ae:	d105      	bne.n	31bc <MSS_I2C_write_read+0xe0>
        {
            this_i2c->is_transaction_pending = 1u;
    31b0:	68fb      	ldr	r3, [r7, #12]
    31b2:	f04f 0201 	mov.w	r2, #1
    31b6:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
    31ba:	e004      	b.n	31c6 <MSS_I2C_write_read+0xea>
        }
        else
        {
            this_i2c->hw_reg_bit->CTRL_STA = 0x01u;
    31bc:	68fb      	ldr	r3, [r7, #12]
    31be:	699b      	ldr	r3, [r3, #24]
    31c0:	f04f 0201 	mov.w	r2, #1
    31c4:	615a      	str	r2, [r3, #20]
        /*
         * Clear interrupts if required (depends on repeated starts).
         * Since the Bus is on hold, only then prior status needs to
         * be cleared.
         */
        if ( MSS_I2C_HOLD_BUS == this_i2c->bus_status )
    31c6:	68fb      	ldr	r3, [r7, #12]
    31c8:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
    31cc:	2b01      	cmp	r3, #1
    31ce:	d111      	bne.n	31f4 <MSS_I2C_write_read+0x118>
        {
            this_i2c->hw_reg_bit->CTRL_SI = 0u;
    31d0:	68fb      	ldr	r3, [r7, #12]
    31d2:	699b      	ldr	r3, [r3, #24]
    31d4:	f04f 0200 	mov.w	r2, #0
    31d8:	60da      	str	r2, [r3, #12]
            stat_ctrl = this_i2c->hw_reg->STATUS;
    31da:	68fb      	ldr	r3, [r7, #12]
    31dc:	695b      	ldr	r3, [r3, #20]
    31de:	791b      	ldrb	r3, [r3, #4]
    31e0:	74fb      	strb	r3, [r7, #19]
            stat_ctrl = stat_ctrl;  /* Avoids Lint warning */
    31e2:	7cfb      	ldrb	r3, [r7, #19]
    31e4:	b2db      	uxtb	r3, r3
    31e6:	74fb      	strb	r3, [r7, #19]
            NVIC_ClearPendingIRQ( this_i2c->irqn );
    31e8:	68fb      	ldr	r3, [r7, #12]
    31ea:	8a5b      	ldrh	r3, [r3, #18]
    31ec:	b21b      	sxth	r3, r3
    31ee:	4618      	mov	r0, r3
    31f0:	f7ff fdac 	bl	2d4c <NVIC_ClearPendingIRQ>
        }

        /* Enable the interrupt. ( Re-enable) */
        NVIC_EnableIRQ( this_i2c->irqn );
    31f4:	68fb      	ldr	r3, [r7, #12]
    31f6:	8a5b      	ldrh	r3, [r3, #18]
    31f8:	b21b      	sxth	r3, r3
    31fa:	4618      	mov	r0, r3
    31fc:	f7ff fd6c 	bl	2cd8 <NVIC_EnableIRQ>

        restore_interrupts( primask );
    3200:	6978      	ldr	r0, [r7, #20]
    3202:	f000 ff7d 	bl	4100 <restore_interrupts>
    }
}
    3206:	f107 0718 	add.w	r7, r7, #24
    320a:	46bd      	mov	sp, r7
    320c:	bd80      	pop	{r7, pc}
    320e:	bf00      	nop

00003210 <MSS_I2C_get_status>:
 */
mss_i2c_status_t MSS_I2C_get_status
(
    mss_i2c_instance_t * this_i2c
)
{
    3210:	b480      	push	{r7}
    3212:	b085      	sub	sp, #20
    3214:	af00      	add	r7, sp, #0
    3216:	6078      	str	r0, [r7, #4]
    mss_i2c_status_t i2c_status ;

    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    3218:	687a      	ldr	r2, [r7, #4]
    321a:	f64a 13f8 	movw	r3, #43512	; 0xa9f8
    321e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3222:	429a      	cmp	r2, r3
    3224:	d007      	beq.n	3236 <MSS_I2C_get_status+0x26>
    3226:	687a      	ldr	r2, [r7, #4]
    3228:	f64a 236c 	movw	r3, #43628	; 0xaa6c
    322c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3230:	429a      	cmp	r2, r3
    3232:	d000      	beq.n	3236 <MSS_I2C_get_status+0x26>
    3234:	be00      	bkpt	0x0000

    i2c_status = this_i2c->master_status ;
    3236:	687b      	ldr	r3, [r7, #4]
    3238:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    323c:	73fb      	strb	r3, [r7, #15]
    return i2c_status;
    323e:	7bfb      	ldrb	r3, [r7, #15]
}
    3240:	4618      	mov	r0, r3
    3242:	f107 0714 	add.w	r7, r7, #20
    3246:	46bd      	mov	sp, r7
    3248:	bc80      	pop	{r7}
    324a:	4770      	bx	lr

0000324c <MSS_I2C_wait_complete>:
mss_i2c_status_t MSS_I2C_wait_complete
(
    mss_i2c_instance_t * this_i2c,
    uint32_t timeout_ms
)
{
    324c:	b480      	push	{r7}
    324e:	b085      	sub	sp, #20
    3250:	af00      	add	r7, sp, #0
    3252:	6078      	str	r0, [r7, #4]
    3254:	6039      	str	r1, [r7, #0]
	mss_i2c_status_t i2c_status;
    
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    3256:	687a      	ldr	r2, [r7, #4]
    3258:	f64a 13f8 	movw	r3, #43512	; 0xa9f8
    325c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3260:	429a      	cmp	r2, r3
    3262:	d007      	beq.n	3274 <MSS_I2C_wait_complete+0x28>
    3264:	687a      	ldr	r2, [r7, #4]
    3266:	f64a 236c 	movw	r3, #43628	; 0xaa6c
    326a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    326e:	429a      	cmp	r2, r3
    3270:	d000      	beq.n	3274 <MSS_I2C_wait_complete+0x28>
    3272:	be00      	bkpt	0x0000
    
    this_i2c->master_timeout_ms = timeout_ms;
    3274:	687b      	ldr	r3, [r7, #4]
    3276:	683a      	ldr	r2, [r7, #0]
    3278:	641a      	str	r2, [r3, #64]	; 0x40

    /* Run the loop until state returns I2C_FAILED  or I2C_SUCESS*/
    do {
        i2c_status = this_i2c->master_status;
    327a:	687b      	ldr	r3, [r7, #4]
    327c:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    3280:	73fb      	strb	r3, [r7, #15]
    } while(MSS_I2C_IN_PROGRESS == i2c_status);
    3282:	7bfb      	ldrb	r3, [r7, #15]
    3284:	2b01      	cmp	r3, #1
    3286:	d0f8      	beq.n	327a <MSS_I2C_wait_complete+0x2e>

    return i2c_status;
    3288:	7bfb      	ldrb	r3, [r7, #15]
}
    328a:	4618      	mov	r0, r3
    328c:	f107 0714 	add.w	r7, r7, #20
    3290:	46bd      	mov	sp, r7
    3292:	bc80      	pop	{r7}
    3294:	4770      	bx	lr
    3296:	bf00      	nop

00003298 <MSS_I2C_system_tick>:
void MSS_I2C_system_tick
(
    mss_i2c_instance_t * this_i2c,
    uint32_t ms_since_last_tick
)
{
    3298:	b480      	push	{r7}
    329a:	b083      	sub	sp, #12
    329c:	af00      	add	r7, sp, #0
    329e:	6078      	str	r0, [r7, #4]
    32a0:	6039      	str	r1, [r7, #0]
    if(this_i2c->master_timeout_ms != MSS_I2C_NO_TIMEOUT)
    32a2:	687b      	ldr	r3, [r7, #4]
    32a4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    32a6:	2b00      	cmp	r3, #0
    32a8:	d01e      	beq.n	32e8 <MSS_I2C_system_tick+0x50>
    {
        if(this_i2c->master_timeout_ms > ms_since_last_tick)
    32aa:	687b      	ldr	r3, [r7, #4]
    32ac:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    32ae:	683b      	ldr	r3, [r7, #0]
    32b0:	429a      	cmp	r2, r3
    32b2:	d907      	bls.n	32c4 <MSS_I2C_system_tick+0x2c>
        {
            this_i2c->master_timeout_ms -= ms_since_last_tick;
    32b4:	687b      	ldr	r3, [r7, #4]
    32b6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    32b8:	683b      	ldr	r3, [r7, #0]
    32ba:	ebc3 0202 	rsb	r2, r3, r2
    32be:	687b      	ldr	r3, [r7, #4]
    32c0:	641a      	str	r2, [r3, #64]	; 0x40
    32c2:	e011      	b.n	32e8 <MSS_I2C_system_tick+0x50>
        else
        {
            /*
             * Mark current transaction as having timed out.
             */
            this_i2c->master_status = MSS_I2C_TIMED_OUT;
    32c4:	687b      	ldr	r3, [r7, #4]
    32c6:	f04f 0203 	mov.w	r2, #3
    32ca:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            this_i2c->transaction = NO_TRANSACTION;
    32ce:	687b      	ldr	r3, [r7, #4]
    32d0:	f04f 0200 	mov.w	r2, #0
    32d4:	721a      	strb	r2, [r3, #8]
            this_i2c->is_transaction_pending = 0;
    32d6:	687b      	ldr	r3, [r7, #4]
    32d8:	f04f 0200 	mov.w	r2, #0
    32dc:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
            
            /*
             * Make sure we do not incorrectly signal a timeout for subsequent
             * transactions.
             */
            this_i2c->master_timeout_ms = MSS_I2C_NO_TIMEOUT;
    32e0:	687b      	ldr	r3, [r7, #4]
    32e2:	f04f 0200 	mov.w	r2, #0
    32e6:	641a      	str	r2, [r3, #64]	; 0x40
        }
    }
}
    32e8:	f107 070c 	add.w	r7, r7, #12
    32ec:	46bd      	mov	sp, r7
    32ee:	bc80      	pop	{r7}
    32f0:	4770      	bx	lr
    32f2:	bf00      	nop

000032f4 <MSS_I2C_set_slave_tx_buffer>:
(
    mss_i2c_instance_t * this_i2c,
    const uint8_t * tx_buffer,
    uint16_t tx_size
)
{
    32f4:	b580      	push	{r7, lr}
    32f6:	b086      	sub	sp, #24
    32f8:	af00      	add	r7, sp, #0
    32fa:	60f8      	str	r0, [r7, #12]
    32fc:	60b9      	str	r1, [r7, #8]
    32fe:	4613      	mov	r3, r2
    3300:	80fb      	strh	r3, [r7, #6]
    uint32_t primask;
    
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    3302:	68fa      	ldr	r2, [r7, #12]
    3304:	f64a 13f8 	movw	r3, #43512	; 0xa9f8
    3308:	f2c2 0300 	movt	r3, #8192	; 0x2000
    330c:	429a      	cmp	r2, r3
    330e:	d007      	beq.n	3320 <MSS_I2C_set_slave_tx_buffer+0x2c>
    3310:	68fa      	ldr	r2, [r7, #12]
    3312:	f64a 236c 	movw	r3, #43628	; 0xaa6c
    3316:	f2c2 0300 	movt	r3, #8192	; 0x2000
    331a:	429a      	cmp	r2, r3
    331c:	d000      	beq.n	3320 <MSS_I2C_set_slave_tx_buffer+0x2c>
    331e:	be00      	bkpt	0x0000

    primask = disable_interrupts();
    3320:	f000 fedc 	bl	40dc <disable_interrupts>
    3324:	4603      	mov	r3, r0
    3326:	617b      	str	r3, [r7, #20]
    
    this_i2c->slave_tx_buffer = tx_buffer;
    3328:	68fb      	ldr	r3, [r7, #12]
    332a:	68ba      	ldr	r2, [r7, #8]
    332c:	645a      	str	r2, [r3, #68]	; 0x44
    this_i2c->slave_tx_size = tx_size;
    332e:	88fa      	ldrh	r2, [r7, #6]
    3330:	68fb      	ldr	r3, [r7, #12]
    3332:	649a      	str	r2, [r3, #72]	; 0x48
    this_i2c->slave_tx_idx = 0u;
    3334:	68fb      	ldr	r3, [r7, #12]
    3336:	f04f 0200 	mov.w	r2, #0
    333a:	64da      	str	r2, [r3, #76]	; 0x4c
    
    restore_interrupts( primask );
    333c:	6978      	ldr	r0, [r7, #20]
    333e:	f000 fedf 	bl	4100 <restore_interrupts>
}
    3342:	f107 0718 	add.w	r7, r7, #24
    3346:	46bd      	mov	sp, r7
    3348:	bd80      	pop	{r7, pc}
    334a:	bf00      	nop

0000334c <MSS_I2C_set_slave_rx_buffer>:
(
    mss_i2c_instance_t * this_i2c,
    uint8_t * rx_buffer,
    uint16_t rx_size
)
{
    334c:	b580      	push	{r7, lr}
    334e:	b086      	sub	sp, #24
    3350:	af00      	add	r7, sp, #0
    3352:	60f8      	str	r0, [r7, #12]
    3354:	60b9      	str	r1, [r7, #8]
    3356:	4613      	mov	r3, r2
    3358:	80fb      	strh	r3, [r7, #6]
    uint32_t primask;

    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    335a:	68fa      	ldr	r2, [r7, #12]
    335c:	f64a 13f8 	movw	r3, #43512	; 0xa9f8
    3360:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3364:	429a      	cmp	r2, r3
    3366:	d007      	beq.n	3378 <MSS_I2C_set_slave_rx_buffer+0x2c>
    3368:	68fa      	ldr	r2, [r7, #12]
    336a:	f64a 236c 	movw	r3, #43628	; 0xaa6c
    336e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3372:	429a      	cmp	r2, r3
    3374:	d000      	beq.n	3378 <MSS_I2C_set_slave_rx_buffer+0x2c>
    3376:	be00      	bkpt	0x0000

    primask = disable_interrupts();
    3378:	f000 feb0 	bl	40dc <disable_interrupts>
    337c:	4603      	mov	r3, r0
    337e:	617b      	str	r3, [r7, #20]
    
    this_i2c->slave_rx_buffer = rx_buffer;
    3380:	68fb      	ldr	r3, [r7, #12]
    3382:	68ba      	ldr	r2, [r7, #8]
    3384:	651a      	str	r2, [r3, #80]	; 0x50
    this_i2c->slave_rx_size = rx_size;
    3386:	88fa      	ldrh	r2, [r7, #6]
    3388:	68fb      	ldr	r3, [r7, #12]
    338a:	655a      	str	r2, [r3, #84]	; 0x54
    this_i2c->slave_rx_idx = 0u;
    338c:	68fb      	ldr	r3, [r7, #12]
    338e:	f04f 0200 	mov.w	r2, #0
    3392:	659a      	str	r2, [r3, #88]	; 0x58

    restore_interrupts( primask );
    3394:	6978      	ldr	r0, [r7, #20]
    3396:	f000 feb3 	bl	4100 <restore_interrupts>
}
    339a:	f107 0718 	add.w	r7, r7, #24
    339e:	46bd      	mov	sp, r7
    33a0:	bd80      	pop	{r7, pc}
    33a2:	bf00      	nop

000033a4 <MSS_I2C_set_slave_mem_offset_length>:
void MSS_I2C_set_slave_mem_offset_length
(
    mss_i2c_instance_t * this_i2c,
    uint8_t offset_length
)
{
    33a4:	b480      	push	{r7}
    33a6:	b083      	sub	sp, #12
    33a8:	af00      	add	r7, sp, #0
    33aa:	6078      	str	r0, [r7, #4]
    33ac:	460b      	mov	r3, r1
    33ae:	70fb      	strb	r3, [r7, #3]
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    33b0:	687a      	ldr	r2, [r7, #4]
    33b2:	f64a 13f8 	movw	r3, #43512	; 0xa9f8
    33b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    33ba:	429a      	cmp	r2, r3
    33bc:	d007      	beq.n	33ce <MSS_I2C_set_slave_mem_offset_length+0x2a>
    33be:	687a      	ldr	r2, [r7, #4]
    33c0:	f64a 236c 	movw	r3, #43628	; 0xaa6c
    33c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    33c8:	429a      	cmp	r2, r3
    33ca:	d000      	beq.n	33ce <MSS_I2C_set_slave_mem_offset_length+0x2a>
    33cc:	be00      	bkpt	0x0000
    ASSERT(offset_length <= MAX_OFFSET_LENGTH);
    33ce:	78fb      	ldrb	r3, [r7, #3]
    33d0:	2b02      	cmp	r3, #2
    33d2:	d900      	bls.n	33d6 <MSS_I2C_set_slave_mem_offset_length+0x32>
    33d4:	be00      	bkpt	0x0000
    
    if(offset_length > MAX_OFFSET_LENGTH)
    33d6:	78fb      	ldrb	r3, [r7, #3]
    33d8:	2b02      	cmp	r3, #2
    33da:	d904      	bls.n	33e6 <MSS_I2C_set_slave_mem_offset_length+0x42>
    {
        this_i2c->slave_mem_offset_length = MAX_OFFSET_LENGTH;
    33dc:	687b      	ldr	r3, [r7, #4]
    33de:	f04f 0202 	mov.w	r2, #2
    33e2:	661a      	str	r2, [r3, #96]	; 0x60
    33e4:	e002      	b.n	33ec <MSS_I2C_set_slave_mem_offset_length+0x48>
    }
    else
    {
        this_i2c->slave_mem_offset_length = offset_length;
    33e6:	78fa      	ldrb	r2, [r7, #3]
    33e8:	687b      	ldr	r3, [r7, #4]
    33ea:	661a      	str	r2, [r3, #96]	; 0x60
    }
}
    33ec:	f107 070c 	add.w	r7, r7, #12
    33f0:	46bd      	mov	sp, r7
    33f2:	bc80      	pop	{r7}
    33f4:	4770      	bx	lr
    33f6:	bf00      	nop

000033f8 <MSS_I2C_register_write_handler>:
void MSS_I2C_register_write_handler
(
    mss_i2c_instance_t * this_i2c,
    mss_i2c_slave_wr_handler_t handler
)
{
    33f8:	b480      	push	{r7}
    33fa:	b083      	sub	sp, #12
    33fc:	af00      	add	r7, sp, #0
    33fe:	6078      	str	r0, [r7, #4]
    3400:	6039      	str	r1, [r7, #0]
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    3402:	687a      	ldr	r2, [r7, #4]
    3404:	f64a 13f8 	movw	r3, #43512	; 0xa9f8
    3408:	f2c2 0300 	movt	r3, #8192	; 0x2000
    340c:	429a      	cmp	r2, r3
    340e:	d007      	beq.n	3420 <MSS_I2C_register_write_handler+0x28>
    3410:	687a      	ldr	r2, [r7, #4]
    3412:	f64a 236c 	movw	r3, #43628	; 0xaa6c
    3416:	f2c2 0300 	movt	r3, #8192	; 0x2000
    341a:	429a      	cmp	r2, r3
    341c:	d000      	beq.n	3420 <MSS_I2C_register_write_handler+0x28>
    341e:	be00      	bkpt	0x0000

    this_i2c->slave_write_handler = handler;
    3420:	687b      	ldr	r3, [r7, #4]
    3422:	683a      	ldr	r2, [r7, #0]
    3424:	665a      	str	r2, [r3, #100]	; 0x64
}
    3426:	f107 070c 	add.w	r7, r7, #12
    342a:	46bd      	mov	sp, r7
    342c:	bc80      	pop	{r7}
    342e:	4770      	bx	lr

00003430 <MSS_I2C_enable_slave>:
 */
void MSS_I2C_enable_slave
(
    mss_i2c_instance_t * this_i2c
)
{
    3430:	b580      	push	{r7, lr}
    3432:	b084      	sub	sp, #16
    3434:	af00      	add	r7, sp, #0
    3436:	6078      	str	r0, [r7, #4]
    uint32_t primask;

    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    3438:	687a      	ldr	r2, [r7, #4]
    343a:	f64a 13f8 	movw	r3, #43512	; 0xa9f8
    343e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3442:	429a      	cmp	r2, r3
    3444:	d007      	beq.n	3456 <MSS_I2C_enable_slave+0x26>
    3446:	687a      	ldr	r2, [r7, #4]
    3448:	f64a 236c 	movw	r3, #43628	; 0xaa6c
    344c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3450:	429a      	cmp	r2, r3
    3452:	d000      	beq.n	3456 <MSS_I2C_enable_slave+0x26>
    3454:	be00      	bkpt	0x0000

    primask = disable_interrupts();
    3456:	f000 fe41 	bl	40dc <disable_interrupts>
    345a:	4603      	mov	r3, r0
    345c:	60fb      	str	r3, [r7, #12]

    /* Set the assert acknowledge bit. */
    this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
    345e:	687b      	ldr	r3, [r7, #4]
    3460:	699b      	ldr	r3, [r3, #24]
    3462:	f04f 0201 	mov.w	r2, #1
    3466:	609a      	str	r2, [r3, #8]
    
    /* Enable slave */
    this_i2c->is_slave_enabled = 1u;
    3468:	687b      	ldr	r3, [r7, #4]
    346a:	f04f 0201 	mov.w	r2, #1
    346e:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68

    restore_interrupts( primask );
    3472:	68f8      	ldr	r0, [r7, #12]
    3474:	f000 fe44 	bl	4100 <restore_interrupts>

    /* Enable Interrupt */
    NVIC_EnableIRQ( this_i2c->irqn );
    3478:	687b      	ldr	r3, [r7, #4]
    347a:	8a5b      	ldrh	r3, [r3, #18]
    347c:	b21b      	sxth	r3, r3
    347e:	4618      	mov	r0, r3
    3480:	f7ff fc2a 	bl	2cd8 <NVIC_EnableIRQ>
}
    3484:	f107 0710 	add.w	r7, r7, #16
    3488:	46bd      	mov	sp, r7
    348a:	bd80      	pop	{r7, pc}

0000348c <MSS_I2C_disable_slave>:
 */
void MSS_I2C_disable_slave
(
    mss_i2c_instance_t * this_i2c
)
{
    348c:	b580      	push	{r7, lr}
    348e:	b084      	sub	sp, #16
    3490:	af00      	add	r7, sp, #0
    3492:	6078      	str	r0, [r7, #4]
    uint32_t primask;

    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    3494:	687a      	ldr	r2, [r7, #4]
    3496:	f64a 13f8 	movw	r3, #43512	; 0xa9f8
    349a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    349e:	429a      	cmp	r2, r3
    34a0:	d007      	beq.n	34b2 <MSS_I2C_disable_slave+0x26>
    34a2:	687a      	ldr	r2, [r7, #4]
    34a4:	f64a 236c 	movw	r3, #43628	; 0xaa6c
    34a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    34ac:	429a      	cmp	r2, r3
    34ae:	d000      	beq.n	34b2 <MSS_I2C_disable_slave+0x26>
    34b0:	be00      	bkpt	0x0000

    primask = disable_interrupts();
    34b2:	f000 fe13 	bl	40dc <disable_interrupts>
    34b6:	4603      	mov	r3, r0
    34b8:	60fb      	str	r3, [r7, #12]

    /* Reset the assert acknowledge bit. */
    this_i2c->hw_reg_bit->CTRL_AA = 0x00u;
    34ba:	687b      	ldr	r3, [r7, #4]
    34bc:	699b      	ldr	r3, [r3, #24]
    34be:	f04f 0200 	mov.w	r2, #0
    34c2:	609a      	str	r2, [r3, #8]

    /* Disable slave */
    this_i2c->is_slave_enabled = 0u;
    34c4:	687b      	ldr	r3, [r7, #4]
    34c6:	f04f 0200 	mov.w	r2, #0
    34ca:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68

    restore_interrupts( primask );
    34ce:	68f8      	ldr	r0, [r7, #12]
    34d0:	f000 fe16 	bl	4100 <restore_interrupts>
}
    34d4:	f107 0710 	add.w	r7, r7, #16
    34d8:	46bd      	mov	sp, r7
    34da:	bd80      	pop	{r7, pc}

000034dc <enable_slave_if_required>:
 */
static void enable_slave_if_required
(
    mss_i2c_instance_t * this_i2c
)
{
    34dc:	b480      	push	{r7}
    34de:	b083      	sub	sp, #12
    34e0:	af00      	add	r7, sp, #0
    34e2:	6078      	str	r0, [r7, #4]
    if( this_i2c->is_slave_enabled )
    34e4:	687b      	ldr	r3, [r7, #4]
    34e6:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
    34ea:	2b00      	cmp	r3, #0
    34ec:	d004      	beq.n	34f8 <enable_slave_if_required+0x1c>
    {
        this_i2c->hw_reg_bit->CTRL_AA = 1u;
    34ee:	687b      	ldr	r3, [r7, #4]
    34f0:	699b      	ldr	r3, [r3, #24]
    34f2:	f04f 0201 	mov.w	r2, #1
    34f6:	609a      	str	r2, [r3, #8]
    }
}
    34f8:	f107 070c 	add.w	r7, r7, #12
    34fc:	46bd      	mov	sp, r7
    34fe:	bc80      	pop	{r7}
    3500:	4770      	bx	lr
    3502:	bf00      	nop

00003504 <mss_i2c_isr>:
 */
static void mss_i2c_isr
(
    mss_i2c_instance_t * this_i2c
)
{
    3504:	b580      	push	{r7, lr}
    3506:	b084      	sub	sp, #16
    3508:	af00      	add	r7, sp, #0
    350a:	6078      	str	r0, [r7, #4]
    volatile uint8_t status;
    uint8_t data;
    uint8_t hold_bus;
    uint8_t clear_irq = 1u;
    350c:	f04f 0301 	mov.w	r3, #1
    3510:	73bb      	strb	r3, [r7, #14]
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    3512:	687a      	ldr	r2, [r7, #4]
    3514:	f64a 13f8 	movw	r3, #43512	; 0xa9f8
    3518:	f2c2 0300 	movt	r3, #8192	; 0x2000
    351c:	429a      	cmp	r2, r3
    351e:	d007      	beq.n	3530 <mss_i2c_isr+0x2c>
    3520:	687a      	ldr	r2, [r7, #4]
    3522:	f64a 236c 	movw	r3, #43628	; 0xaa6c
    3526:	f2c2 0300 	movt	r3, #8192	; 0x2000
    352a:	429a      	cmp	r2, r3
    352c:	d000      	beq.n	3530 <mss_i2c_isr+0x2c>
    352e:	be00      	bkpt	0x0000

    status = this_i2c->hw_reg->STATUS;
    3530:	687b      	ldr	r3, [r7, #4]
    3532:	695b      	ldr	r3, [r3, #20]
    3534:	791b      	ldrb	r3, [r3, #4]
    3536:	72fb      	strb	r3, [r7, #11]

    switch( status )
    3538:	7afb      	ldrb	r3, [r7, #11]
    353a:	b2db      	uxtb	r3, r3
    353c:	f1a3 0308 	sub.w	r3, r3, #8
    3540:	2bd0      	cmp	r3, #208	; 0xd0
    3542:	f200 841c 	bhi.w	3d7e <mss_i2c_isr+0x87a>
    3546:	a201      	add	r2, pc, #4	; (adr r2, 354c <mss_i2c_isr+0x48>)
    3548:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    354c:	00003891 	.word	0x00003891
    3550:	00003d7f 	.word	0x00003d7f
    3554:	00003d7f 	.word	0x00003d7f
    3558:	00003d7f 	.word	0x00003d7f
    355c:	00003d7f 	.word	0x00003d7f
    3560:	00003d7f 	.word	0x00003d7f
    3564:	00003d7f 	.word	0x00003d7f
    3568:	00003d7f 	.word	0x00003d7f
    356c:	00003891 	.word	0x00003891
    3570:	00003d7f 	.word	0x00003d7f
    3574:	00003d7f 	.word	0x00003d7f
    3578:	00003d7f 	.word	0x00003d7f
    357c:	00003d7f 	.word	0x00003d7f
    3580:	00003d7f 	.word	0x00003d7f
    3584:	00003d7f 	.word	0x00003d7f
    3588:	00003d7f 	.word	0x00003d7f
    358c:	00003935 	.word	0x00003935
    3590:	00003d7f 	.word	0x00003d7f
    3594:	00003d7f 	.word	0x00003d7f
    3598:	00003d7f 	.word	0x00003d7f
    359c:	00003d7f 	.word	0x00003d7f
    35a0:	00003d7f 	.word	0x00003d7f
    35a4:	00003d7f 	.word	0x00003d7f
    35a8:	00003d7f 	.word	0x00003d7f
    35ac:	00003911 	.word	0x00003911
    35b0:	00003d7f 	.word	0x00003d7f
    35b4:	00003d7f 	.word	0x00003d7f
    35b8:	00003d7f 	.word	0x00003d7f
    35bc:	00003d7f 	.word	0x00003d7f
    35c0:	00003d7f 	.word	0x00003d7f
    35c4:	00003d7f 	.word	0x00003d7f
    35c8:	00003d7f 	.word	0x00003d7f
    35cc:	00003935 	.word	0x00003935
    35d0:	00003d7f 	.word	0x00003d7f
    35d4:	00003d7f 	.word	0x00003d7f
    35d8:	00003d7f 	.word	0x00003d7f
    35dc:	00003d7f 	.word	0x00003d7f
    35e0:	00003d7f 	.word	0x00003d7f
    35e4:	00003d7f 	.word	0x00003d7f
    35e8:	00003d7f 	.word	0x00003d7f
    35ec:	000039c9 	.word	0x000039c9
    35f0:	00003d7f 	.word	0x00003d7f
    35f4:	00003d7f 	.word	0x00003d7f
    35f8:	00003d7f 	.word	0x00003d7f
    35fc:	00003d7f 	.word	0x00003d7f
    3600:	00003d7f 	.word	0x00003d7f
    3604:	00003d7f 	.word	0x00003d7f
    3608:	00003d7f 	.word	0x00003d7f
    360c:	00003905 	.word	0x00003905
    3610:	00003d7f 	.word	0x00003d7f
    3614:	00003d7f 	.word	0x00003d7f
    3618:	00003d7f 	.word	0x00003d7f
    361c:	00003d7f 	.word	0x00003d7f
    3620:	00003d7f 	.word	0x00003d7f
    3624:	00003d7f 	.word	0x00003d7f
    3628:	00003d7f 	.word	0x00003d7f
    362c:	000039ed 	.word	0x000039ed
    3630:	00003d7f 	.word	0x00003d7f
    3634:	00003d7f 	.word	0x00003d7f
    3638:	00003d7f 	.word	0x00003d7f
    363c:	00003d7f 	.word	0x00003d7f
    3640:	00003d7f 	.word	0x00003d7f
    3644:	00003d7f 	.word	0x00003d7f
    3648:	00003d7f 	.word	0x00003d7f
    364c:	00003a3d 	.word	0x00003a3d
    3650:	00003d7f 	.word	0x00003d7f
    3654:	00003d7f 	.word	0x00003d7f
    3658:	00003d7f 	.word	0x00003d7f
    365c:	00003d7f 	.word	0x00003d7f
    3660:	00003d7f 	.word	0x00003d7f
    3664:	00003d7f 	.word	0x00003d7f
    3668:	00003d7f 	.word	0x00003d7f
    366c:	00003a61 	.word	0x00003a61
    3670:	00003d7f 	.word	0x00003d7f
    3674:	00003d7f 	.word	0x00003d7f
    3678:	00003d7f 	.word	0x00003d7f
    367c:	00003d7f 	.word	0x00003d7f
    3680:	00003d7f 	.word	0x00003d7f
    3684:	00003d7f 	.word	0x00003d7f
    3688:	00003d7f 	.word	0x00003d7f
    368c:	00003a9b 	.word	0x00003a9b
    3690:	00003d7f 	.word	0x00003d7f
    3694:	00003d7f 	.word	0x00003d7f
    3698:	00003d7f 	.word	0x00003d7f
    369c:	00003d7f 	.word	0x00003d7f
    36a0:	00003d7f 	.word	0x00003d7f
    36a4:	00003d7f 	.word	0x00003d7f
    36a8:	00003d7f 	.word	0x00003d7f
    36ac:	00003b3d 	.word	0x00003b3d
    36b0:	00003d7f 	.word	0x00003d7f
    36b4:	00003d7f 	.word	0x00003d7f
    36b8:	00003d7f 	.word	0x00003d7f
    36bc:	00003d7f 	.word	0x00003d7f
    36c0:	00003d7f 	.word	0x00003d7f
    36c4:	00003d7f 	.word	0x00003d7f
    36c8:	00003d7f 	.word	0x00003d7f
    36cc:	00003b33 	.word	0x00003b33
    36d0:	00003d7f 	.word	0x00003d7f
    36d4:	00003d7f 	.word	0x00003d7f
    36d8:	00003d7f 	.word	0x00003d7f
    36dc:	00003d7f 	.word	0x00003d7f
    36e0:	00003d7f 	.word	0x00003d7f
    36e4:	00003d7f 	.word	0x00003d7f
    36e8:	00003d7f 	.word	0x00003d7f
    36ec:	00003b3d 	.word	0x00003b3d
    36f0:	00003d7f 	.word	0x00003d7f
    36f4:	00003d7f 	.word	0x00003d7f
    36f8:	00003d7f 	.word	0x00003d7f
    36fc:	00003d7f 	.word	0x00003d7f
    3700:	00003d7f 	.word	0x00003d7f
    3704:	00003d7f 	.word	0x00003d7f
    3708:	00003d7f 	.word	0x00003d7f
    370c:	00003b33 	.word	0x00003b33
    3710:	00003d7f 	.word	0x00003d7f
    3714:	00003d7f 	.word	0x00003d7f
    3718:	00003d7f 	.word	0x00003d7f
    371c:	00003d7f 	.word	0x00003d7f
    3720:	00003d7f 	.word	0x00003d7f
    3724:	00003d7f 	.word	0x00003d7f
    3728:	00003d7f 	.word	0x00003d7f
    372c:	00003b7f 	.word	0x00003b7f
    3730:	00003d7f 	.word	0x00003d7f
    3734:	00003d7f 	.word	0x00003d7f
    3738:	00003d7f 	.word	0x00003d7f
    373c:	00003d7f 	.word	0x00003d7f
    3740:	00003d7f 	.word	0x00003d7f
    3744:	00003d7f 	.word	0x00003d7f
    3748:	00003d7f 	.word	0x00003d7f
    374c:	00003aff 	.word	0x00003aff
    3750:	00003d7f 	.word	0x00003d7f
    3754:	00003d7f 	.word	0x00003d7f
    3758:	00003d7f 	.word	0x00003d7f
    375c:	00003d7f 	.word	0x00003d7f
    3760:	00003d7f 	.word	0x00003d7f
    3764:	00003d7f 	.word	0x00003d7f
    3768:	00003d7f 	.word	0x00003d7f
    376c:	00003b7f 	.word	0x00003b7f
    3770:	00003d7f 	.word	0x00003d7f
    3774:	00003d7f 	.word	0x00003d7f
    3778:	00003d7f 	.word	0x00003d7f
    377c:	00003d7f 	.word	0x00003d7f
    3780:	00003d7f 	.word	0x00003d7f
    3784:	00003d7f 	.word	0x00003d7f
    3788:	00003d7f 	.word	0x00003d7f
    378c:	00003aff 	.word	0x00003aff
    3790:	00003d7f 	.word	0x00003d7f
    3794:	00003d7f 	.word	0x00003d7f
    3798:	00003d7f 	.word	0x00003d7f
    379c:	00003d7f 	.word	0x00003d7f
    37a0:	00003d7f 	.word	0x00003d7f
    37a4:	00003d7f 	.word	0x00003d7f
    37a8:	00003d7f 	.word	0x00003d7f
    37ac:	00003bdb 	.word	0x00003bdb
    37b0:	00003d7f 	.word	0x00003d7f
    37b4:	00003d7f 	.word	0x00003d7f
    37b8:	00003d7f 	.word	0x00003d7f
    37bc:	00003d7f 	.word	0x00003d7f
    37c0:	00003d7f 	.word	0x00003d7f
    37c4:	00003d7f 	.word	0x00003d7f
    37c8:	00003d7f 	.word	0x00003d7f
    37cc:	00003cb3 	.word	0x00003cb3
    37d0:	00003d7f 	.word	0x00003d7f
    37d4:	00003d7f 	.word	0x00003d7f
    37d8:	00003d7f 	.word	0x00003d7f
    37dc:	00003d7f 	.word	0x00003d7f
    37e0:	00003d7f 	.word	0x00003d7f
    37e4:	00003d7f 	.word	0x00003d7f
    37e8:	00003d7f 	.word	0x00003d7f
    37ec:	00003cb3 	.word	0x00003cb3
    37f0:	00003d7f 	.word	0x00003d7f
    37f4:	00003d7f 	.word	0x00003d7f
    37f8:	00003d7f 	.word	0x00003d7f
    37fc:	00003d7f 	.word	0x00003d7f
    3800:	00003d7f 	.word	0x00003d7f
    3804:	00003d7f 	.word	0x00003d7f
    3808:	00003d7f 	.word	0x00003d7f
    380c:	00003cb3 	.word	0x00003cb3
    3810:	00003d7f 	.word	0x00003d7f
    3814:	00003d7f 	.word	0x00003d7f
    3818:	00003d7f 	.word	0x00003d7f
    381c:	00003d7f 	.word	0x00003d7f
    3820:	00003d7f 	.word	0x00003d7f
    3824:	00003d7f 	.word	0x00003d7f
    3828:	00003d7f 	.word	0x00003d7f
    382c:	00003d45 	.word	0x00003d45
    3830:	00003d7f 	.word	0x00003d7f
    3834:	00003d7f 	.word	0x00003d7f
    3838:	00003d7f 	.word	0x00003d7f
    383c:	00003d7f 	.word	0x00003d7f
    3840:	00003d7f 	.word	0x00003d7f
    3844:	00003d7f 	.word	0x00003d7f
    3848:	00003d7f 	.word	0x00003d7f
    384c:	00003d45 	.word	0x00003d45
    3850:	00003d7f 	.word	0x00003d7f
    3854:	00003d7f 	.word	0x00003d7f
    3858:	00003d7f 	.word	0x00003d7f
    385c:	00003d7f 	.word	0x00003d7f
    3860:	00003d7f 	.word	0x00003d7f
    3864:	00003d7f 	.word	0x00003d7f
    3868:	00003d7f 	.word	0x00003d7f
    386c:	00003d7f 	.word	0x00003d7f
    3870:	00003d7f 	.word	0x00003d7f
    3874:	00003d7f 	.word	0x00003d7f
    3878:	00003d7f 	.word	0x00003d7f
    387c:	00003d7f 	.word	0x00003d7f
    3880:	00003d7f 	.word	0x00003d7f
    3884:	00003d7f 	.word	0x00003d7f
    3888:	00003d7f 	.word	0x00003d7f
    388c:	00003c85 	.word	0x00003c85
    {
        /************** MASTER TRANSMITTER / RECEIVER *******************/
      
        case ST_START: /* start has been xmt'd */
        case ST_RESTART: /* repeated start has been xmt'd */
            this_i2c->hw_reg_bit->CTRL_STA = 0u;
    3890:	687b      	ldr	r3, [r7, #4]
    3892:	699b      	ldr	r3, [r3, #24]
    3894:	f04f 0200 	mov.w	r2, #0
    3898:	615a      	str	r2, [r3, #20]
            this_i2c->hw_reg->DATA = (uint8_t)this_i2c->target_addr;
    389a:	687b      	ldr	r3, [r7, #4]
    389c:	695b      	ldr	r3, [r3, #20]
    389e:	687a      	ldr	r2, [r7, #4]
    38a0:	6852      	ldr	r2, [r2, #4]
    38a2:	b2d2      	uxtb	r2, r2
    38a4:	721a      	strb	r2, [r3, #8]
            this_i2c->hw_reg_bit->DATA_DIR = this_i2c->dir;
    38a6:	687b      	ldr	r3, [r7, #4]
    38a8:	699b      	ldr	r3, [r3, #24]
    38aa:	687a      	ldr	r2, [r7, #4]
    38ac:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    38ae:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
            if ( this_i2c->dir == WRITE_DIR )
    38b2:	687b      	ldr	r3, [r7, #4]
    38b4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    38b6:	2b00      	cmp	r3, #0
    38b8:	d104      	bne.n	38c4 <mss_i2c_isr+0x3c0>
            {
                this_i2c->master_tx_idx = 0u;
    38ba:	687b      	ldr	r3, [r7, #4]
    38bc:	f04f 0200 	mov.w	r2, #0
    38c0:	629a      	str	r2, [r3, #40]	; 0x28
    38c2:	e007      	b.n	38d4 <mss_i2c_isr+0x3d0>
            }
            else if ( this_i2c->dir == READ_DIR)
    38c4:	687b      	ldr	r3, [r7, #4]
    38c6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    38c8:	2b01      	cmp	r3, #1
    38ca:	d103      	bne.n	38d4 <mss_i2c_isr+0x3d0>
            {
                this_i2c->master_rx_idx = 0u;
    38cc:	687b      	ldr	r3, [r7, #4]
    38ce:	f04f 0200 	mov.w	r2, #0
    38d2:	639a      	str	r2, [r3, #56]	; 0x38
            /*
             * Clear the pending transaction. This condition will be true if the slave 
             * has acquired the bus to carry out pending master transaction which 
             * it had received during its slave transmission or reception mode. 
             */
            if(this_i2c->is_transaction_pending)
    38d4:	687b      	ldr	r3, [r7, #4]
    38d6:	f893 3071 	ldrb.w	r3, [r3, #113]	; 0x71
    38da:	2b00      	cmp	r3, #0
    38dc:	d004      	beq.n	38e8 <mss_i2c_isr+0x3e4>
            {
                this_i2c->is_transaction_pending = 0u;
    38de:	687b      	ldr	r3, [r7, #4]
    38e0:	f04f 0200 	mov.w	r2, #0
    38e4:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71

            /*
             * Make sure to update proper transaction after master START
             * or RESTART
             */
            if(this_i2c->transaction != this_i2c->pending_transaction)
    38e8:	687b      	ldr	r3, [r7, #4]
    38ea:	7a1a      	ldrb	r2, [r3, #8]
    38ec:	687b      	ldr	r3, [r7, #4]
    38ee:	f893 3072 	ldrb.w	r3, [r3, #114]	; 0x72
    38f2:	429a      	cmp	r2, r3
    38f4:	f000 8267 	beq.w	3dc6 <mss_i2c_isr+0x8c2>
            {
                this_i2c->transaction = this_i2c->pending_transaction;
    38f8:	687b      	ldr	r3, [r7, #4]
    38fa:	f893 2072 	ldrb.w	r2, [r3, #114]	; 0x72
    38fe:	687b      	ldr	r3, [r7, #4]
    3900:	721a      	strb	r2, [r3, #8]
            }
            break;
    3902:	e269      	b.n	3dd8 <mss_i2c_isr+0x8d4>
            
        case ST_LOST_ARB:
            /* Set start bit.  Let's keep trying!  Don't give up! */
            this_i2c->hw_reg_bit->CTRL_STA = 0x01u;
    3904:	687b      	ldr	r3, [r7, #4]
    3906:	699b      	ldr	r3, [r3, #24]
    3908:	f04f 0201 	mov.w	r2, #1
    390c:	615a      	str	r2, [r3, #20]
            break;
    390e:	e263      	b.n	3dd8 <mss_i2c_isr+0x8d4>
            
        /******************* MASTER TRANSMITTER *************************/
        case ST_SLAW_NACK:
            /* SLA+W has been transmitted; not ACK has been received - let's stop. */
            this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
    3910:	687b      	ldr	r3, [r7, #4]
    3912:	699b      	ldr	r3, [r3, #24]
    3914:	f04f 0201 	mov.w	r2, #1
    3918:	611a      	str	r2, [r3, #16]
            this_i2c->master_status = MSS_I2C_FAILED;
    391a:	687b      	ldr	r3, [r7, #4]
    391c:	f04f 0202 	mov.w	r2, #2
    3920:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            this_i2c->transaction = NO_TRANSACTION;
    3924:	687b      	ldr	r3, [r7, #4]
    3926:	f04f 0200 	mov.w	r2, #0
    392a:	721a      	strb	r2, [r3, #8]
            enable_slave_if_required(this_i2c);
    392c:	6878      	ldr	r0, [r7, #4]
    392e:	f7ff fdd5 	bl	34dc <enable_slave_if_required>
            break;
    3932:	e251      	b.n	3dd8 <mss_i2c_isr+0x8d4>
            
        case ST_SLAW_ACK:
        case ST_TX_DATA_ACK:
            /* data byte has been xmt'd with ACK, time to send stop bit or repeated start. */
            if (this_i2c->master_tx_idx < this_i2c->master_tx_size)
    3934:	687b      	ldr	r3, [r7, #4]
    3936:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    3938:	687b      	ldr	r3, [r7, #4]
    393a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    393c:	429a      	cmp	r2, r3
    393e:	d20d      	bcs.n	395c <mss_i2c_isr+0x458>
            {    
                this_i2c->hw_reg->DATA = this_i2c->master_tx_buffer[this_i2c->master_tx_idx++];
    3940:	687b      	ldr	r3, [r7, #4]
    3942:	695a      	ldr	r2, [r3, #20]
    3944:	687b      	ldr	r3, [r7, #4]
    3946:	6a19      	ldr	r1, [r3, #32]
    3948:	687b      	ldr	r3, [r7, #4]
    394a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    394c:	4419      	add	r1, r3
    394e:	7809      	ldrb	r1, [r1, #0]
    3950:	7211      	strb	r1, [r2, #8]
    3952:	f103 0201 	add.w	r2, r3, #1
    3956:	687b      	ldr	r3, [r7, #4]
    3958:	629a      	str	r2, [r3, #40]	; 0x28
                    NVIC_DisableIRQ( this_i2c->irqn );
                    clear_irq = 0u;
                }
                this_i2c->master_status = MSS_I2C_SUCCESS;
            }
            break;
    395a:	e23d      	b.n	3dd8 <mss_i2c_isr+0x8d4>
            /* data byte has been xmt'd with ACK, time to send stop bit or repeated start. */
            if (this_i2c->master_tx_idx < this_i2c->master_tx_size)
            {    
                this_i2c->hw_reg->DATA = this_i2c->master_tx_buffer[this_i2c->master_tx_idx++];
            }
            else if ( this_i2c->transaction == MASTER_RANDOM_READ_TRANSACTION )
    395c:	687b      	ldr	r3, [r7, #4]
    395e:	7a1b      	ldrb	r3, [r3, #8]
    3960:	2b03      	cmp	r3, #3
    3962:	d109      	bne.n	3978 <mss_i2c_isr+0x474>
            {
                /* We are finished sending the address offset part of a random read transaction.
                 * It is is time to send a restart in order to change direction. */
                 this_i2c->dir = READ_DIR;
    3964:	687b      	ldr	r3, [r7, #4]
    3966:	f04f 0201 	mov.w	r2, #1
    396a:	62da      	str	r2, [r3, #44]	; 0x2c
                 this_i2c->hw_reg_bit->CTRL_STA = 0x01u;
    396c:	687b      	ldr	r3, [r7, #4]
    396e:	699b      	ldr	r3, [r3, #24]
    3970:	f04f 0201 	mov.w	r2, #1
    3974:	615a      	str	r2, [r3, #20]
                    NVIC_DisableIRQ( this_i2c->irqn );
                    clear_irq = 0u;
                }
                this_i2c->master_status = MSS_I2C_SUCCESS;
            }
            break;
    3976:	e22f      	b.n	3dd8 <mss_i2c_isr+0x8d4>
            {
                /*
                 * Set the transaction back to NO_TRANSACTION to allow user to do further
                 * transaction
                 */
                this_i2c->transaction = NO_TRANSACTION;
    3978:	687b      	ldr	r3, [r7, #4]
    397a:	f04f 0200 	mov.w	r2, #0
    397e:	721a      	strb	r2, [r3, #8]
                hold_bus = this_i2c->options & MSS_I2C_HOLD_BUS;
    3980:	687b      	ldr	r3, [r7, #4]
    3982:	7c1b      	ldrb	r3, [r3, #16]
    3984:	f003 0301 	and.w	r3, r3, #1
    3988:	737b      	strb	r3, [r7, #13]

                /* Store the information of current I2C bus status in the bus_status*/
                this_i2c->bus_status  = hold_bus;
    398a:	687b      	ldr	r3, [r7, #4]
    398c:	7b7a      	ldrb	r2, [r7, #13]
    398e:	f883 2070 	strb.w	r2, [r3, #112]	; 0x70
                if ( hold_bus == 0u )
    3992:	7b7b      	ldrb	r3, [r7, #13]
    3994:	2b00      	cmp	r3, #0
    3996:	d108      	bne.n	39aa <mss_i2c_isr+0x4a6>
                { 
                    this_i2c->hw_reg_bit->CTRL_STO = 0x01u; /*xmt stop condition */
    3998:	687b      	ldr	r3, [r7, #4]
    399a:	699b      	ldr	r3, [r3, #24]
    399c:	f04f 0201 	mov.w	r2, #1
    39a0:	611a      	str	r2, [r3, #16]
                    enable_slave_if_required(this_i2c);
    39a2:	6878      	ldr	r0, [r7, #4]
    39a4:	f7ff fd9a 	bl	34dc <enable_slave_if_required>
    39a8:	e008      	b.n	39bc <mss_i2c_isr+0x4b8>
                }
                else
                {
                    NVIC_DisableIRQ( this_i2c->irqn );
    39aa:	687b      	ldr	r3, [r7, #4]
    39ac:	8a5b      	ldrh	r3, [r3, #18]
    39ae:	b21b      	sxth	r3, r3
    39b0:	4618      	mov	r0, r3
    39b2:	f7ff f9ad 	bl	2d10 <NVIC_DisableIRQ>
                    clear_irq = 0u;
    39b6:	f04f 0300 	mov.w	r3, #0
    39ba:	73bb      	strb	r3, [r7, #14]
                }
                this_i2c->master_status = MSS_I2C_SUCCESS;
    39bc:	687b      	ldr	r3, [r7, #4]
    39be:	f04f 0200 	mov.w	r2, #0
    39c2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            }
            break;
    39c6:	e207      	b.n	3dd8 <mss_i2c_isr+0x8d4>
            /* data byte SENT, ACK to be received
             * In fact, this means we've received a NACK (This may not be 
             * obvious, but if we've rec'd an ACK then we would be in state 
             * 0x28!) hence, let's send a stop bit
             */
            this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
    39c8:	687b      	ldr	r3, [r7, #4]
    39ca:	699b      	ldr	r3, [r3, #24]
    39cc:	f04f 0201 	mov.w	r2, #1
    39d0:	611a      	str	r2, [r3, #16]
            this_i2c->master_status = MSS_I2C_FAILED;
    39d2:	687b      	ldr	r3, [r7, #4]
    39d4:	f04f 0202 	mov.w	r2, #2
    39d8:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
    39dc:	687b      	ldr	r3, [r7, #4]
    39de:	f04f 0200 	mov.w	r2, #0
    39e2:	721a      	strb	r2, [r3, #8]
            enable_slave_if_required(this_i2c);
    39e4:	6878      	ldr	r0, [r7, #4]
    39e6:	f7ff fd79 	bl	34dc <enable_slave_if_required>

            break;
    39ea:	e1f5      	b.n	3dd8 <mss_i2c_isr+0x8d4>
      /* STATUS codes 08H, 10H, 38H are all covered in MTX mode */
        case ST_SLAR_ACK: /* SLA+R tx'ed. */
            /* Let's make sure we ACK the first data byte received (set AA bit in CTRL) unless
             * the next byte is the last byte of the read transaction.
             */
            if(this_i2c->master_rx_size > 1u)
    39ec:	687b      	ldr	r3, [r7, #4]
    39ee:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    39f0:	2b01      	cmp	r3, #1
    39f2:	d905      	bls.n	3a00 <mss_i2c_isr+0x4fc>
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
    39f4:	687b      	ldr	r3, [r7, #4]
    39f6:	699b      	ldr	r3, [r3, #24]
    39f8:	f04f 0201 	mov.w	r2, #1
    39fc:	609a      	str	r2, [r3, #8]
                this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
                this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
                this_i2c->master_status = MSS_I2C_SUCCESS;
                this_i2c->transaction = NO_TRANSACTION;
            }
            break;
    39fe:	e1eb      	b.n	3dd8 <mss_i2c_isr+0x8d4>
             */
            if(this_i2c->master_rx_size > 1u)
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
            }
            else if(1u == this_i2c->master_rx_size)
    3a00:	687b      	ldr	r3, [r7, #4]
    3a02:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    3a04:	2b01      	cmp	r3, #1
    3a06:	d105      	bne.n	3a14 <mss_i2c_isr+0x510>
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
    3a08:	687b      	ldr	r3, [r7, #4]
    3a0a:	699b      	ldr	r3, [r3, #24]
    3a0c:	f04f 0200 	mov.w	r2, #0
    3a10:	609a      	str	r2, [r3, #8]
                this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
                this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
                this_i2c->master_status = MSS_I2C_SUCCESS;
                this_i2c->transaction = NO_TRANSACTION;
            }
            break;
    3a12:	e1e1      	b.n	3dd8 <mss_i2c_isr+0x8d4>
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
            }
            else /* this_i2c->master_rx_size == 0u */
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
    3a14:	687b      	ldr	r3, [r7, #4]
    3a16:	699b      	ldr	r3, [r3, #24]
    3a18:	f04f 0201 	mov.w	r2, #1
    3a1c:	609a      	str	r2, [r3, #8]
                this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
    3a1e:	687b      	ldr	r3, [r7, #4]
    3a20:	699b      	ldr	r3, [r3, #24]
    3a22:	f04f 0201 	mov.w	r2, #1
    3a26:	611a      	str	r2, [r3, #16]
                this_i2c->master_status = MSS_I2C_SUCCESS;
    3a28:	687b      	ldr	r3, [r7, #4]
    3a2a:	f04f 0200 	mov.w	r2, #0
    3a2e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
                this_i2c->transaction = NO_TRANSACTION;
    3a32:	687b      	ldr	r3, [r7, #4]
    3a34:	f04f 0200 	mov.w	r2, #0
    3a38:	721a      	strb	r2, [r3, #8]
            }
            break;
    3a3a:	e1cd      	b.n	3dd8 <mss_i2c_isr+0x8d4>
            
        case ST_SLAR_NACK: /* SLA+R tx'ed; let's release the bus (send a stop condition) */
            this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
    3a3c:	687b      	ldr	r3, [r7, #4]
    3a3e:	699b      	ldr	r3, [r3, #24]
    3a40:	f04f 0201 	mov.w	r2, #1
    3a44:	611a      	str	r2, [r3, #16]
            this_i2c->master_status = MSS_I2C_FAILED;
    3a46:	687b      	ldr	r3, [r7, #4]
    3a48:	f04f 0202 	mov.w	r2, #2
    3a4c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
    3a50:	687b      	ldr	r3, [r7, #4]
    3a52:	f04f 0200 	mov.w	r2, #0
    3a56:	721a      	strb	r2, [r3, #8]
            enable_slave_if_required(this_i2c);
    3a58:	6878      	ldr	r0, [r7, #4]
    3a5a:	f7ff fd3f 	bl	34dc <enable_slave_if_required>
            break;
    3a5e:	e1bb      	b.n	3dd8 <mss_i2c_isr+0x8d4>
          
        case ST_RX_DATA_ACK: /* Data byte received, ACK returned */
            /* First, get the data */
            this_i2c->master_rx_buffer[this_i2c->master_rx_idx++] = this_i2c->hw_reg->DATA;
    3a60:	687b      	ldr	r3, [r7, #4]
    3a62:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    3a64:	687b      	ldr	r3, [r7, #4]
    3a66:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    3a68:	441a      	add	r2, r3
    3a6a:	6879      	ldr	r1, [r7, #4]
    3a6c:	6949      	ldr	r1, [r1, #20]
    3a6e:	7a09      	ldrb	r1, [r1, #8]
    3a70:	b2c9      	uxtb	r1, r1
    3a72:	7011      	strb	r1, [r2, #0]
    3a74:	f103 0201 	add.w	r2, r3, #1
    3a78:	687b      	ldr	r3, [r7, #4]
    3a7a:	639a      	str	r2, [r3, #56]	; 0x38

            if( this_i2c->master_rx_idx >= (this_i2c->master_rx_size - 1u))
    3a7c:	687b      	ldr	r3, [r7, #4]
    3a7e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    3a80:	687b      	ldr	r3, [r7, #4]
    3a82:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    3a84:	f103 33ff 	add.w	r3, r3, #4294967295
    3a88:	429a      	cmp	r2, r3
    3a8a:	f0c0 819e 	bcc.w	3dca <mss_i2c_isr+0x8c6>
            {
                /* If we're at the second last byte, let's set AA to 0 so
                 * we return a NACK at the last byte. */
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
    3a8e:	687b      	ldr	r3, [r7, #4]
    3a90:	699b      	ldr	r3, [r3, #24]
    3a92:	f04f 0200 	mov.w	r2, #0
    3a96:	609a      	str	r2, [r3, #8]
            }
            break;
    3a98:	e19e      	b.n	3dd8 <mss_i2c_isr+0x8d4>
            
        case ST_RX_DATA_NACK: /* Data byte received, NACK returned */
            /* Get the data, then send a stop condition */
            this_i2c->master_rx_buffer[this_i2c->master_rx_idx] = this_i2c->hw_reg->DATA;
    3a9a:	687b      	ldr	r3, [r7, #4]
    3a9c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    3a9e:	687b      	ldr	r3, [r7, #4]
    3aa0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    3aa2:	4413      	add	r3, r2
    3aa4:	687a      	ldr	r2, [r7, #4]
    3aa6:	6952      	ldr	r2, [r2, #20]
    3aa8:	7a12      	ldrb	r2, [r2, #8]
    3aaa:	b2d2      	uxtb	r2, r2
    3aac:	701a      	strb	r2, [r3, #0]
          
            hold_bus = this_i2c->options &  MSS_I2C_HOLD_BUS; 
    3aae:	687b      	ldr	r3, [r7, #4]
    3ab0:	7c1b      	ldrb	r3, [r3, #16]
    3ab2:	f003 0301 	and.w	r3, r3, #1
    3ab6:	737b      	strb	r3, [r7, #13]

            /* Store the information of current I2C bus status in the bus_status*/
            this_i2c->bus_status  = hold_bus;
    3ab8:	687b      	ldr	r3, [r7, #4]
    3aba:	7b7a      	ldrb	r2, [r7, #13]
    3abc:	f883 2070 	strb.w	r2, [r3, #112]	; 0x70
            if ( hold_bus == 0u )
    3ac0:	7b7b      	ldrb	r3, [r7, #13]
    3ac2:	2b00      	cmp	r3, #0
    3ac4:	d108      	bne.n	3ad8 <mss_i2c_isr+0x5d4>
            { 
                this_i2c->hw_reg_bit->CTRL_STO = 0x01u;  /*xmt stop condition */
    3ac6:	687b      	ldr	r3, [r7, #4]
    3ac8:	699b      	ldr	r3, [r3, #24]
    3aca:	f04f 0201 	mov.w	r2, #1
    3ace:	611a      	str	r2, [r3, #16]

                /* Bus is released, now we can start listening to bus, if it is slave */
                   enable_slave_if_required(this_i2c);
    3ad0:	6878      	ldr	r0, [r7, #4]
    3ad2:	f7ff fd03 	bl	34dc <enable_slave_if_required>
    3ad6:	e008      	b.n	3aea <mss_i2c_isr+0x5e6>
            }
            else
            {
                NVIC_DisableIRQ( this_i2c->irqn );
    3ad8:	687b      	ldr	r3, [r7, #4]
    3ada:	8a5b      	ldrh	r3, [r3, #18]
    3adc:	b21b      	sxth	r3, r3
    3ade:	4618      	mov	r0, r3
    3ae0:	f7ff f916 	bl	2d10 <NVIC_DisableIRQ>
                clear_irq = 0u;
    3ae4:	f04f 0300 	mov.w	r3, #0
    3ae8:	73bb      	strb	r3, [r7, #14]

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
    3aea:	687b      	ldr	r3, [r7, #4]
    3aec:	f04f 0200 	mov.w	r2, #0
    3af0:	721a      	strb	r2, [r3, #8]
            this_i2c->master_status = MSS_I2C_SUCCESS;
    3af2:	687b      	ldr	r3, [r7, #4]
    3af4:	f04f 0200 	mov.w	r2, #0
    3af8:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            break;
    3afc:	e16c      	b.n	3dd8 <mss_i2c_isr+0x8d4>
        
        /******************** SLAVE RECEIVER **************************/
        case ST_GCA_NACK: /* NACK after, GCA addressing */
        case ST_SLA_NACK: /* Re-enable AA (assert ack) bit for future transmissions */
            this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
    3afe:	687b      	ldr	r3, [r7, #4]
    3b00:	699b      	ldr	r3, [r3, #24]
    3b02:	f04f 0201 	mov.w	r2, #1
    3b06:	609a      	str	r2, [r3, #8]
            
            this_i2c->transaction = NO_TRANSACTION;
    3b08:	687b      	ldr	r3, [r7, #4]
    3b0a:	f04f 0200 	mov.w	r2, #0
    3b0e:	721a      	strb	r2, [r3, #8]
            this_i2c->slave_status = MSS_I2C_SUCCESS;
    3b10:	687b      	ldr	r3, [r7, #4]
    3b12:	f04f 0200 	mov.w	r2, #0
    3b16:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
            
            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
    3b1a:	687b      	ldr	r3, [r7, #4]
    3b1c:	f893 3071 	ldrb.w	r3, [r3, #113]	; 0x71
    3b20:	2b00      	cmp	r3, #0
    3b22:	f000 8154 	beq.w	3dce <mss_i2c_isr+0x8ca>
            {
                this_i2c->hw_reg_bit->CTRL_STA = 1u ;
    3b26:	687b      	ldr	r3, [r7, #4]
    3b28:	699b      	ldr	r3, [r3, #24]
    3b2a:	f04f 0201 	mov.w	r2, #1
    3b2e:	615a      	str	r2, [r3, #20]
            }
            break;
    3b30:	e152      	b.n	3dd8 <mss_i2c_isr+0x8d4>
        case ST_SLV_LA: /* Arbitr. lost (SLA rec'd) */
            /*
             *  We lost arbitration and either the GCE or our address was the
             *  one received so pend the master operation we were starting.
             */
            this_i2c->is_transaction_pending = 1u;
    3b32:	687b      	ldr	r3, [r7, #4]
    3b34:	f04f 0201 	mov.w	r2, #1
    3b38:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
            /* Fall through to normal ST processing as we are now in slave mode */

        case ST_GCA: /* General call address received, ACK returned */
        case ST_SLAVE_SLAW: /* SLA+W received, ACK returned */

            this_i2c->transaction = WRITE_SLAVE_TRANSACTION;
    3b3c:	687b      	ldr	r3, [r7, #4]
    3b3e:	f04f 0204 	mov.w	r2, #4
    3b42:	721a      	strb	r2, [r3, #8]
            this_i2c->slave_rx_idx = 0u;
    3b44:	687b      	ldr	r3, [r7, #4]
    3b46:	f04f 0200 	mov.w	r2, #0
    3b4a:	659a      	str	r2, [r3, #88]	; 0x58
            this_i2c->random_read_addr = 0u;
    3b4c:	687b      	ldr	r3, [r7, #4]
    3b4e:	f04f 0200 	mov.w	r2, #0
    3b52:	60da      	str	r2, [r3, #12]

             /* If Start Bit is set, clear it, but store that information since it is because of
              * pending transaction
              */
            if(this_i2c->hw_reg_bit->CTRL_STA)
    3b54:	687b      	ldr	r3, [r7, #4]
    3b56:	699b      	ldr	r3, [r3, #24]
    3b58:	695b      	ldr	r3, [r3, #20]
    3b5a:	2b00      	cmp	r3, #0
    3b5c:	d009      	beq.n	3b72 <mss_i2c_isr+0x66e>
            {
                this_i2c->hw_reg_bit->CTRL_STA = 0u ;
    3b5e:	687b      	ldr	r3, [r7, #4]
    3b60:	699b      	ldr	r3, [r3, #24]
    3b62:	f04f 0200 	mov.w	r2, #0
    3b66:	615a      	str	r2, [r3, #20]
                this_i2c->is_transaction_pending = 1u;
    3b68:	687b      	ldr	r3, [r7, #4]
    3b6a:	f04f 0201 	mov.w	r2, #1
    3b6e:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
            }
            this_i2c->slave_status = MSS_I2C_IN_PROGRESS;
    3b72:	687b      	ldr	r3, [r7, #4]
    3b74:	f04f 0201 	mov.w	r2, #1
    3b78:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
#ifdef MSS_I2C_INCLUDE_SLA_IN_RX_PAYLOAD
            /* Fall through to put address as first byte in payload buffer */
#else
            /* Only break from this case if the slave address must NOT be included at the
             * beginning of the received write data. */
            break;
    3b7c:	e12c      	b.n	3dd8 <mss_i2c_isr+0x8d4>
#endif            
        case ST_GCA_ACK: /* DATA received; ACK sent after GCA */
        case ST_RDATA: /* DATA received; must clear DATA register */
            if((this_i2c->slave_rx_buffer != (uint8_t *)0)
    3b7e:	687b      	ldr	r3, [r7, #4]
    3b80:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    3b82:	2b00      	cmp	r3, #0
    3b84:	d01c      	beq.n	3bc0 <mss_i2c_isr+0x6bc>
               && (this_i2c->slave_rx_idx < this_i2c->slave_rx_size))
    3b86:	687b      	ldr	r3, [r7, #4]
    3b88:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    3b8a:	687b      	ldr	r3, [r7, #4]
    3b8c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
             * beginning of the received write data. */
            break;
#endif            
        case ST_GCA_ACK: /* DATA received; ACK sent after GCA */
        case ST_RDATA: /* DATA received; must clear DATA register */
            if((this_i2c->slave_rx_buffer != (uint8_t *)0)
    3b8e:	429a      	cmp	r2, r3
    3b90:	d216      	bcs.n	3bc0 <mss_i2c_isr+0x6bc>
               && (this_i2c->slave_rx_idx < this_i2c->slave_rx_size))
            {
                data = this_i2c->hw_reg->DATA;
    3b92:	687b      	ldr	r3, [r7, #4]
    3b94:	695b      	ldr	r3, [r3, #20]
    3b96:	7a1b      	ldrb	r3, [r3, #8]
    3b98:	733b      	strb	r3, [r7, #12]
                this_i2c->slave_rx_buffer[this_i2c->slave_rx_idx++] = data;
    3b9a:	687b      	ldr	r3, [r7, #4]
    3b9c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    3b9e:	687b      	ldr	r3, [r7, #4]
    3ba0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    3ba2:	441a      	add	r2, r3
    3ba4:	7b39      	ldrb	r1, [r7, #12]
    3ba6:	7011      	strb	r1, [r2, #0]
    3ba8:	f103 0201 	add.w	r2, r3, #1
    3bac:	687b      	ldr	r3, [r7, #4]
    3bae:	659a      	str	r2, [r3, #88]	; 0x58
                {
                    /* Ignore the slave address byte in the random read address
                       computation in the case where INCLUDE_SLA_IN_RX_PAYLOAD
                       is defined. */
#endif
                    this_i2c->random_read_addr = (this_i2c->random_read_addr << 8) + data;
    3bb0:	687b      	ldr	r3, [r7, #4]
    3bb2:	68db      	ldr	r3, [r3, #12]
    3bb4:	ea4f 2203 	mov.w	r2, r3, lsl #8
    3bb8:	7b3b      	ldrb	r3, [r7, #12]
    3bba:	441a      	add	r2, r3
    3bbc:	687b      	ldr	r3, [r7, #4]
    3bbe:	60da      	str	r2, [r3, #12]
#ifdef MSS_I2C_INCLUDE_SLA_IN_RX_PAYLOAD
                }
#endif
            }
            
            if (this_i2c->slave_rx_idx >= this_i2c->slave_rx_size)
    3bc0:	687b      	ldr	r3, [r7, #4]
    3bc2:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    3bc4:	687b      	ldr	r3, [r7, #4]
    3bc6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    3bc8:	429a      	cmp	r2, r3
    3bca:	f0c0 8102 	bcc.w	3dd2 <mss_i2c_isr+0x8ce>
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0u;   /* send a NACK when done (next reception) */
    3bce:	687b      	ldr	r3, [r7, #4]
    3bd0:	699b      	ldr	r3, [r3, #24]
    3bd2:	f04f 0200 	mov.w	r2, #0
    3bd6:	609a      	str	r2, [r3, #8]
            }
            break;
    3bd8:	e0fe      	b.n	3dd8 <mss_i2c_isr+0x8d4>
            /* STOP or repeated START occurred. */
            /* We cannot be sure if the transaction has actually completed as
             * this hardware state reports that either a STOP or repeated START
             * condition has occurred. We assume that this is a repeated START
             * if the transaction was a write from the master to this point.*/
            if ( this_i2c->transaction == WRITE_SLAVE_TRANSACTION )
    3bda:	687b      	ldr	r3, [r7, #4]
    3bdc:	7a1b      	ldrb	r3, [r3, #8]
    3bde:	2b04      	cmp	r3, #4
    3be0:	d135      	bne.n	3c4e <mss_i2c_isr+0x74a>
            {
                if ( this_i2c->slave_rx_idx == this_i2c->slave_mem_offset_length )
    3be2:	687b      	ldr	r3, [r7, #4]
    3be4:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    3be6:	687b      	ldr	r3, [r7, #4]
    3be8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    3bea:	429a      	cmp	r2, r3
    3bec:	d103      	bne.n	3bf6 <mss_i2c_isr+0x6f2>
                {
                    this_i2c->slave_tx_idx = this_i2c->random_read_addr;
    3bee:	687b      	ldr	r3, [r7, #4]
    3bf0:	68da      	ldr	r2, [r3, #12]
    3bf2:	687b      	ldr	r3, [r7, #4]
    3bf4:	64da      	str	r2, [r3, #76]	; 0x4c
                }
                {
                    /* Call the slave's write transaction handler if it exists. */
                    if ( this_i2c->slave_write_handler != 0u )
    3bf6:	687b      	ldr	r3, [r7, #4]
    3bf8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    3bfa:	2b00      	cmp	r3, #0
    3bfc:	d021      	beq.n	3c42 <mss_i2c_isr+0x73e>
                    {
                        mss_i2c_slave_handler_ret_t h_ret;
                        h_ret = this_i2c->slave_write_handler( this_i2c, this_i2c->slave_rx_buffer, (uint16_t)this_i2c->slave_rx_idx );
    3bfe:	687b      	ldr	r3, [r7, #4]
    3c00:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    3c02:	687a      	ldr	r2, [r7, #4]
    3c04:	6d11      	ldr	r1, [r2, #80]	; 0x50
    3c06:	687a      	ldr	r2, [r7, #4]
    3c08:	6d92      	ldr	r2, [r2, #88]	; 0x58
    3c0a:	b292      	uxth	r2, r2
    3c0c:	6878      	ldr	r0, [r7, #4]
    3c0e:	4798      	blx	r3
    3c10:	4603      	mov	r3, r0
    3c12:	73fb      	strb	r3, [r7, #15]
                        if ( MSS_I2C_REENABLE_SLAVE_RX == h_ret )
    3c14:	7bfb      	ldrb	r3, [r7, #15]
    3c16:	2b00      	cmp	r3, #0
    3c18:	d108      	bne.n	3c2c <mss_i2c_isr+0x728>
                        {
                            /* There is a small risk that the write handler could
                             * call MSS_I2C_disable_slave() but return
                             * MSS_I2C_REENABLE_SLAVE_RX in error so we only
                             * enable ACKs if still in slave mode. */
                             enable_slave_if_required(this_i2c);
    3c1a:	6878      	ldr	r0, [r7, #4]
    3c1c:	f7ff fc5e 	bl	34dc <enable_slave_if_required>
                             this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
    3c20:	687b      	ldr	r3, [r7, #4]
    3c22:	699b      	ldr	r3, [r3, #24]
    3c24:	f04f 0201 	mov.w	r2, #1
    3c28:	609a      	str	r2, [r3, #8]
                        }
                    }
                    else
                    {
                        /* Re-enable address acknowledge in case we were ready to nack the next received byte. */
                        this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
    3c2a:	e017      	b.n	3c5c <mss_i2c_isr+0x758>
                             enable_slave_if_required(this_i2c);
                             this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
                        }
                        else
                        {
                            this_i2c->hw_reg_bit->CTRL_AA = 0u;
    3c2c:	687b      	ldr	r3, [r7, #4]
    3c2e:	699b      	ldr	r3, [r3, #24]
    3c30:	f04f 0200 	mov.w	r2, #0
    3c34:	609a      	str	r2, [r3, #8]
                            /* Clear slave mode flag as well otherwise in mixed
                             * master/slave applications, the AA bit will get set by
                             * subsequent master operations. */
                            this_i2c->is_slave_enabled = 0u;
    3c36:	687b      	ldr	r3, [r7, #4]
    3c38:	f04f 0200 	mov.w	r2, #0
    3c3c:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
                        }
                    }
                    else
                    {
                        /* Re-enable address acknowledge in case we were ready to nack the next received byte. */
                        this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
    3c40:	e00c      	b.n	3c5c <mss_i2c_isr+0x758>
    3c42:	687b      	ldr	r3, [r7, #4]
    3c44:	699b      	ldr	r3, [r3, #24]
    3c46:	f04f 0201 	mov.w	r2, #1
    3c4a:	609a      	str	r2, [r3, #8]
    3c4c:	e006      	b.n	3c5c <mss_i2c_isr+0x758>
            {
                /*
                 * Reset slave_tx_idx so that a subsequent read will result in the slave's
                 * transmit buffer being sent from the first byte.
                 */
                this_i2c->slave_tx_idx = 0u;
    3c4e:	687b      	ldr	r3, [r7, #4]
    3c50:	f04f 0200 	mov.w	r2, #0
    3c54:	64da      	str	r2, [r3, #76]	; 0x4c
                /*
                 * See if we need to re-enable acknowledgement as some error conditions, such
                 * as a master prematurely ending a transfer, can see us get here with AA set
                 * to 0 which will disable slave operation if we are not careful.
                 */
                enable_slave_if_required(this_i2c);
    3c56:	6878      	ldr	r0, [r7, #4]
    3c58:	f7ff fc40 	bl	34dc <enable_slave_if_required>
            }

            /* Mark any previous master write transaction as complete. */
            this_i2c->slave_status = MSS_I2C_SUCCESS;
    3c5c:	687b      	ldr	r3, [r7, #4]
    3c5e:	f04f 0200 	mov.w	r2, #0
    3c62:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
    3c66:	687b      	ldr	r3, [r7, #4]
    3c68:	f893 3071 	ldrb.w	r3, [r3, #113]	; 0x71
    3c6c:	2b00      	cmp	r3, #0
    3c6e:	d004      	beq.n	3c7a <mss_i2c_isr+0x776>
            {
                this_i2c->hw_reg_bit->CTRL_STA = 1u ;
    3c70:	687b      	ldr	r3, [r7, #4]
    3c72:	699b      	ldr	r3, [r3, #24]
    3c74:	f04f 0201 	mov.w	r2, #1
    3c78:	615a      	str	r2, [r3, #20]

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
    3c7a:	687b      	ldr	r3, [r7, #4]
    3c7c:	f04f 0200 	mov.w	r2, #0
    3c80:	721a      	strb	r2, [r3, #8]
            break;
    3c82:	e0a9      	b.n	3dd8 <mss_i2c_isr+0x8d4>
        case ST_SLV_RST: /* SMBUS ONLY: timeout state. must clear interrupt */
            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction.
             */
            this_i2c->transaction = NO_TRANSACTION;
    3c84:	687b      	ldr	r3, [r7, #4]
    3c86:	f04f 0200 	mov.w	r2, #0
    3c8a:	721a      	strb	r2, [r3, #8]
            /*
             * Reset slave_tx_idx so that a subsequent read will result in the slave's
             * transmit buffer being sent from the first byte.
             */
            this_i2c->slave_tx_idx = 0u;
    3c8c:	687b      	ldr	r3, [r7, #4]
    3c8e:	f04f 0200 	mov.w	r2, #0
    3c92:	64da      	str	r2, [r3, #76]	; 0x4c
            /*
             * Clear status to I2C_FAILED only if there was an operation in progress.
             */
            if(MSS_I2C_IN_PROGRESS == this_i2c->slave_status)
    3c94:	687b      	ldr	r3, [r7, #4]
    3c96:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    3c9a:	b2db      	uxtb	r3, r3
    3c9c:	2b01      	cmp	r3, #1
    3c9e:	d104      	bne.n	3caa <mss_i2c_isr+0x7a6>
            {
                this_i2c->slave_status = MSS_I2C_FAILED;
    3ca0:	687b      	ldr	r3, [r7, #4]
    3ca2:	f04f 0202 	mov.w	r2, #2
    3ca6:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
            }

            enable_slave_if_required(this_i2c); /* Make sure AA is set correctly */
    3caa:	6878      	ldr	r0, [r7, #4]
    3cac:	f7ff fc16 	bl	34dc <enable_slave_if_required>

            break;
    3cb0:	e092      	b.n	3dd8 <mss_i2c_isr+0x8d4>
            
        /****************** SLAVE TRANSMITTER **************************/
        case ST_SLAVE_SLAR_ACK: /* SLA+R received, ACK returned */
        case ST_SLARW_LA:   /* Arbitration lost, SLA+R received, ACK returned */
        case ST_RACK: /* Data tx'ed, ACK received */
            if ( status == ST_SLAVE_SLAR_ACK )
    3cb2:	7afb      	ldrb	r3, [r7, #11]
    3cb4:	b2db      	uxtb	r3, r3
    3cb6:	2ba8      	cmp	r3, #168	; 0xa8
    3cb8:	d11b      	bne.n	3cf2 <mss_i2c_isr+0x7ee>
            {
                this_i2c->transaction = READ_SLAVE_TRANSACTION;
    3cba:	687b      	ldr	r3, [r7, #4]
    3cbc:	f04f 0205 	mov.w	r2, #5
    3cc0:	721a      	strb	r2, [r3, #8]
                this_i2c->random_read_addr = 0u;
    3cc2:	687b      	ldr	r3, [r7, #4]
    3cc4:	f04f 0200 	mov.w	r2, #0
    3cc8:	60da      	str	r2, [r3, #12]

                this_i2c->slave_status = MSS_I2C_IN_PROGRESS;
    3cca:	687b      	ldr	r3, [r7, #4]
    3ccc:	f04f 0201 	mov.w	r2, #1
    3cd0:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

                /* If Start Bit is set, clear it, but store that information since it is because of
                 * pending transaction
                 */
                if(this_i2c->hw_reg_bit->CTRL_STA)
    3cd4:	687b      	ldr	r3, [r7, #4]
    3cd6:	699b      	ldr	r3, [r3, #24]
    3cd8:	695b      	ldr	r3, [r3, #20]
    3cda:	2b00      	cmp	r3, #0
    3cdc:	d009      	beq.n	3cf2 <mss_i2c_isr+0x7ee>
                {
                    this_i2c->hw_reg_bit->CTRL_STA = 0u ;
    3cde:	687b      	ldr	r3, [r7, #4]
    3ce0:	699b      	ldr	r3, [r3, #24]
    3ce2:	f04f 0200 	mov.w	r2, #0
    3ce6:	615a      	str	r2, [r3, #20]
                    this_i2c->is_transaction_pending = 1u;
    3ce8:	687b      	ldr	r3, [r7, #4]
    3cea:	f04f 0201 	mov.w	r2, #1
    3cee:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
                }
            }
            if (this_i2c->slave_tx_idx >= this_i2c->slave_tx_size)
    3cf2:	687b      	ldr	r3, [r7, #4]
    3cf4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    3cf6:	687b      	ldr	r3, [r7, #4]
    3cf8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    3cfa:	429a      	cmp	r2, r3
    3cfc:	d305      	bcc.n	3d0a <mss_i2c_isr+0x806>
            {
                /* Ensure 0xFF is returned to the master when the slave specifies
                 * an empty transmit buffer. */
                this_i2c->hw_reg->DATA = 0xFFu;
    3cfe:	687b      	ldr	r3, [r7, #4]
    3d00:	695b      	ldr	r3, [r3, #20]
    3d02:	f04f 32ff 	mov.w	r2, #4294967295
    3d06:	721a      	strb	r2, [r3, #8]
    3d08:	e00c      	b.n	3d24 <mss_i2c_isr+0x820>
            }
            else
            {
                /* Load the data the data byte to be sent to the master. */
                this_i2c->hw_reg->DATA = this_i2c->slave_tx_buffer[this_i2c->slave_tx_idx++];
    3d0a:	687b      	ldr	r3, [r7, #4]
    3d0c:	695a      	ldr	r2, [r3, #20]
    3d0e:	687b      	ldr	r3, [r7, #4]
    3d10:	6c59      	ldr	r1, [r3, #68]	; 0x44
    3d12:	687b      	ldr	r3, [r7, #4]
    3d14:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    3d16:	4419      	add	r1, r3
    3d18:	7809      	ldrb	r1, [r1, #0]
    3d1a:	7211      	strb	r1, [r2, #8]
    3d1c:	f103 0201 	add.w	r2, r3, #1
    3d20:	687b      	ldr	r3, [r7, #4]
    3d22:	64da      	str	r2, [r3, #76]	; 0x4c
            }
            /* Determine if this is the last data byte to send to the master. */
            if (this_i2c->slave_tx_idx >= this_i2c->slave_tx_size) /* last byte? */
    3d24:	687b      	ldr	r3, [r7, #4]
    3d26:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    3d28:	687b      	ldr	r3, [r7, #4]
    3d2a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    3d2c:	429a      	cmp	r2, r3
    3d2e:	d352      	bcc.n	3dd6 <mss_i2c_isr+0x8d2>
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
    3d30:	687b      	ldr	r3, [r7, #4]
    3d32:	699b      	ldr	r3, [r3, #24]
    3d34:	f04f 0200 	mov.w	r2, #0
    3d38:	609a      	str	r2, [r3, #8]
                /* Next read transaction will result in slave's transmit buffer
                 * being sent from the first byte. */
                this_i2c->slave_tx_idx = 0u;
    3d3a:	687b      	ldr	r3, [r7, #4]
    3d3c:	f04f 0200 	mov.w	r2, #0
    3d40:	64da      	str	r2, [r3, #76]	; 0x4c
            }
            break;
    3d42:	e049      	b.n	3dd8 <mss_i2c_isr+0x8d4>
        case ST_SLAVE_RNACK:    /* Data byte has been transmitted; not-ACK has been received. */
        case ST_FINAL: /* Last Data byte tx'ed, ACK received */
            /* We assume that the transaction will be stopped by the master.
             * Reset slave_tx_idx so that a subsequent read will result in the slave's
             * transmit buffer being sent from the first byte. */
            this_i2c->slave_tx_idx = 0u;
    3d44:	687b      	ldr	r3, [r7, #4]
    3d46:	f04f 0200 	mov.w	r2, #0
    3d4a:	64da      	str	r2, [r3, #76]	; 0x4c
            this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
    3d4c:	687b      	ldr	r3, [r7, #4]
    3d4e:	699b      	ldr	r3, [r3, #24]
    3d50:	f04f 0201 	mov.w	r2, #1
    3d54:	609a      	str	r2, [r3, #8]

            /*  Mark previous state as complete */
            this_i2c->slave_status = MSS_I2C_SUCCESS;
    3d56:	687b      	ldr	r3, [r7, #4]
    3d58:	f04f 0200 	mov.w	r2, #0
    3d5c:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
    3d60:	687b      	ldr	r3, [r7, #4]
    3d62:	f893 3071 	ldrb.w	r3, [r3, #113]	; 0x71
    3d66:	2b00      	cmp	r3, #0
    3d68:	d004      	beq.n	3d74 <mss_i2c_isr+0x870>
            {
                this_i2c->hw_reg_bit->CTRL_STA = 1u ;
    3d6a:	687b      	ldr	r3, [r7, #4]
    3d6c:	699b      	ldr	r3, [r3, #24]
    3d6e:	f04f 0201 	mov.w	r2, #1
    3d72:	615a      	str	r2, [r3, #20]

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
    3d74:	687b      	ldr	r3, [r7, #4]
    3d76:	f04f 0200 	mov.w	r2, #0
    3d7a:	721a      	strb	r2, [r3, #8]
            break;
    3d7c:	e02c      	b.n	3dd8 <mss_i2c_isr+0x8d4>
        case ST_RESET_ACTIVATED:
        case ST_BUS_ERROR: /* Bus error during MST or selected slave modes */
        default:
            /* Some undefined state has encountered. Clear Start bit to make
             * sure, next good transaction happen */
            this_i2c->hw_reg_bit->CTRL_STA = 0x00u;
    3d7e:	687b      	ldr	r3, [r7, #4]
    3d80:	699b      	ldr	r3, [r3, #24]
    3d82:	f04f 0200 	mov.w	r2, #0
    3d86:	615a      	str	r2, [r3, #20]
            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
    3d88:	687b      	ldr	r3, [r7, #4]
    3d8a:	f04f 0200 	mov.w	r2, #0
    3d8e:	721a      	strb	r2, [r3, #8]
            /*
             * Reset slave_tx_idx so that a subsequent read will result in the slave's
             * transmit buffer being sent from the first byte.
             */
            this_i2c->slave_tx_idx = 0u;
    3d90:	687b      	ldr	r3, [r7, #4]
    3d92:	f04f 0200 	mov.w	r2, #0
    3d96:	64da      	str	r2, [r3, #76]	; 0x4c
            /*
             * Clear statuses to I2C_FAILED only if there was an operation in progress.
             */
            if(MSS_I2C_IN_PROGRESS == this_i2c->master_status)
    3d98:	687b      	ldr	r3, [r7, #4]
    3d9a:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    3d9e:	b2db      	uxtb	r3, r3
    3da0:	2b01      	cmp	r3, #1
    3da2:	d104      	bne.n	3dae <mss_i2c_isr+0x8aa>
            {
                this_i2c->master_status = MSS_I2C_FAILED;
    3da4:	687b      	ldr	r3, [r7, #4]
    3da6:	f04f 0202 	mov.w	r2, #2
    3daa:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            }

            if(MSS_I2C_IN_PROGRESS == this_i2c->slave_status)
    3dae:	687b      	ldr	r3, [r7, #4]
    3db0:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    3db4:	b2db      	uxtb	r3, r3
    3db6:	2b01      	cmp	r3, #1
    3db8:	d10e      	bne.n	3dd8 <mss_i2c_isr+0x8d4>
            {
                this_i2c->slave_status = MSS_I2C_FAILED;
    3dba:	687b      	ldr	r3, [r7, #4]
    3dbc:	f04f 0202 	mov.w	r2, #2
    3dc0:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
    3dc4:	e008      	b.n	3dd8 <mss_i2c_isr+0x8d4>
             */
            if(this_i2c->transaction != this_i2c->pending_transaction)
            {
                this_i2c->transaction = this_i2c->pending_transaction;
            }
            break;
    3dc6:	bf00      	nop
    3dc8:	e006      	b.n	3dd8 <mss_i2c_isr+0x8d4>
            {
                /* If we're at the second last byte, let's set AA to 0 so
                 * we return a NACK at the last byte. */
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
            }
            break;
    3dca:	bf00      	nop
    3dcc:	e004      	b.n	3dd8 <mss_i2c_isr+0x8d4>
            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
            {
                this_i2c->hw_reg_bit->CTRL_STA = 1u ;
            }
            break;
    3dce:	bf00      	nop
    3dd0:	e002      	b.n	3dd8 <mss_i2c_isr+0x8d4>
            
            if (this_i2c->slave_rx_idx >= this_i2c->slave_rx_size)
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0u;   /* send a NACK when done (next reception) */
            }
            break;
    3dd2:	bf00      	nop
    3dd4:	e000      	b.n	3dd8 <mss_i2c_isr+0x8d4>
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
                /* Next read transaction will result in slave's transmit buffer
                 * being sent from the first byte. */
                this_i2c->slave_tx_idx = 0u;
            }
            break;
    3dd6:	bf00      	nop


            break;
    }
    
    if ( clear_irq )
    3dd8:	7bbb      	ldrb	r3, [r7, #14]
    3dda:	2b00      	cmp	r3, #0
    3ddc:	d004      	beq.n	3de8 <mss_i2c_isr+0x8e4>
    {
        /* clear interrupt. */
        this_i2c->hw_reg_bit->CTRL_SI = 0u;
    3dde:	687b      	ldr	r3, [r7, #4]
    3de0:	699b      	ldr	r3, [r3, #24]
    3de2:	f04f 0200 	mov.w	r2, #0
    3de6:	60da      	str	r2, [r3, #12]
    }
    
    /* Read the status register to ensure the last I2C registers write took place
     * in a system built around a bus making use of posted writes. */
    status = this_i2c->hw_reg->STATUS;
    3de8:	687b      	ldr	r3, [r7, #4]
    3dea:	695b      	ldr	r3, [r3, #20]
    3dec:	791b      	ldrb	r3, [r3, #4]
    3dee:	72fb      	strb	r3, [r7, #11]
}
    3df0:	f107 0710 	add.w	r7, r7, #16
    3df4:	46bd      	mov	sp, r7
    3df6:	bd80      	pop	{r7, pc}

00003df8 <MSS_I2C_smbus_init>:
void MSS_I2C_smbus_init
(
    mss_i2c_instance_t * this_i2c,
    uint8_t frequency
)
{
    3df8:	b480      	push	{r7}
    3dfa:	b083      	sub	sp, #12
    3dfc:	af00      	add	r7, sp, #0
    3dfe:	6078      	str	r0, [r7, #4]
    3e00:	460b      	mov	r3, r1
    3e02:	70fb      	strb	r3, [r7, #3]
    /* Set the frequency before enabling time out logic */
    this_i2c->hw_reg->FREQ = frequency;
    3e04:	687b      	ldr	r3, [r7, #4]
    3e06:	695b      	ldr	r3, [r3, #20]
    3e08:	78fa      	ldrb	r2, [r7, #3]
    3e0a:	751a      	strb	r2, [r3, #20]

    /* Enable SMBUS */
    this_i2c->hw_reg->SMBUS = MSS_INIT_AND_ENABLE_SMBUS;
    3e0c:	687b      	ldr	r3, [r7, #4]
    3e0e:	695b      	ldr	r3, [r3, #20]
    3e10:	f04f 0254 	mov.w	r2, #84	; 0x54
    3e14:	741a      	strb	r2, [r3, #16]
}
    3e16:	f107 070c 	add.w	r7, r7, #12
    3e1a:	46bd      	mov	sp, r7
    3e1c:	bc80      	pop	{r7}
    3e1e:	4770      	bx	lr

00003e20 <MSS_I2C_enable_smbus_irq>:
void MSS_I2C_enable_smbus_irq
(
    mss_i2c_instance_t * this_i2c,
    uint8_t  irq_type
)
{
    3e20:	b580      	push	{r7, lr}
    3e22:	b082      	sub	sp, #8
    3e24:	af00      	add	r7, sp, #0
    3e26:	6078      	str	r0, [r7, #4]
    3e28:	460b      	mov	r3, r1
    3e2a:	70fb      	strb	r3, [r7, #3]
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    3e2c:	687a      	ldr	r2, [r7, #4]
    3e2e:	f64a 13f8 	movw	r3, #43512	; 0xa9f8
    3e32:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3e36:	429a      	cmp	r2, r3
    3e38:	d007      	beq.n	3e4a <MSS_I2C_enable_smbus_irq+0x2a>
    3e3a:	687a      	ldr	r2, [r7, #4]
    3e3c:	f64a 236c 	movw	r3, #43628	; 0xaa6c
    3e40:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3e44:	429a      	cmp	r2, r3
    3e46:	d000      	beq.n	3e4a <MSS_I2C_enable_smbus_irq+0x2a>
    3e48:	be00      	bkpt	0x0000

	/* Enable any interrupts selected by the user */
    if ( this_i2c == &g_mss_i2c0 )
    3e4a:	687a      	ldr	r2, [r7, #4]
    3e4c:	f64a 13f8 	movw	r3, #43512	; 0xa9f8
    3e50:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3e54:	429a      	cmp	r2, r3
    3e56:	d127      	bne.n	3ea8 <MSS_I2C_enable_smbus_irq+0x88>
    {
        if ( irq_type & MSS_I2C_SMBALERT_IRQ )
    3e58:	78fb      	ldrb	r3, [r7, #3]
    3e5a:	f003 0301 	and.w	r3, r3, #1
    3e5e:	b2db      	uxtb	r3, r3
    3e60:	2b00      	cmp	r3, #0
    3e62:	d00d      	beq.n	3e80 <MSS_I2C_enable_smbus_irq+0x60>
        {
            /* Clear interrupt at the NVIC and enable in MSS I2C */
        	NVIC_ClearPendingIRQ( I2C0_SMBAlert_IRQn );
    3e64:	f04f 000f 	mov.w	r0, #15
    3e68:	f7fe ff70 	bl	2d4c <NVIC_ClearPendingIRQ>
            this_i2c->hw_smb_reg_bit->SMB_SMBALERT_IE = 0x01u;
    3e6c:	687b      	ldr	r3, [r7, #4]
    3e6e:	69db      	ldr	r3, [r3, #28]
    3e70:	f04f 0201 	mov.w	r2, #1
    3e74:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
            /* Enable the interrupt at the NVIC */
            NVIC_EnableIRQ( I2C0_SMBAlert_IRQn );
    3e78:	f04f 000f 	mov.w	r0, #15
    3e7c:	f7fe ff2c 	bl	2cd8 <NVIC_EnableIRQ>
        }
        if (irq_type & MSS_I2C_SMBSUS_IRQ )
    3e80:	78fb      	ldrb	r3, [r7, #3]
    3e82:	f003 0302 	and.w	r3, r3, #2
    3e86:	2b00      	cmp	r3, #0
    3e88:	d036      	beq.n	3ef8 <MSS_I2C_enable_smbus_irq+0xd8>
        {
            /* Clear interrupt at the NVIC and enable in MSS I2C */
            NVIC_ClearPendingIRQ( I2C0_SMBus_IRQn );
    3e8a:	f04f 0010 	mov.w	r0, #16
    3e8e:	f7fe ff5d 	bl	2d4c <NVIC_ClearPendingIRQ>
            this_i2c->hw_smb_reg_bit->SMB_SMBSUS_IE = 0x01u;
    3e92:	687b      	ldr	r3, [r7, #4]
    3e94:	69db      	ldr	r3, [r3, #28]
    3e96:	f04f 0201 	mov.w	r2, #1
    3e9a:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
            /* Enable the interrupt at the NVIC */
            NVIC_EnableIRQ( I2C0_SMBus_IRQn );
    3e9e:	f04f 0010 	mov.w	r0, #16
    3ea2:	f7fe ff19 	bl	2cd8 <NVIC_EnableIRQ>
    3ea6:	e028      	b.n	3efa <MSS_I2C_enable_smbus_irq+0xda>
        }
    }
    else
    {
        if ( irq_type & MSS_I2C_SMBALERT_IRQ )
    3ea8:	78fb      	ldrb	r3, [r7, #3]
    3eaa:	f003 0301 	and.w	r3, r3, #1
    3eae:	b2db      	uxtb	r3, r3
    3eb0:	2b00      	cmp	r3, #0
    3eb2:	d00d      	beq.n	3ed0 <MSS_I2C_enable_smbus_irq+0xb0>
        {
            /* Clear interrupt at the NVIC and enable in MSS I2C */
            NVIC_ClearPendingIRQ( I2C1_SMBAlert_IRQn );
    3eb4:	f04f 0012 	mov.w	r0, #18
    3eb8:	f7fe ff48 	bl	2d4c <NVIC_ClearPendingIRQ>
            this_i2c->hw_smb_reg_bit->SMB_SMBALERT_IE = 0x01u;
    3ebc:	687b      	ldr	r3, [r7, #4]
    3ebe:	69db      	ldr	r3, [r3, #28]
    3ec0:	f04f 0201 	mov.w	r2, #1
    3ec4:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
            /* Enable the interrupt at the NVIC */
            NVIC_EnableIRQ( I2C1_SMBAlert_IRQn );
    3ec8:	f04f 0012 	mov.w	r0, #18
    3ecc:	f7fe ff04 	bl	2cd8 <NVIC_EnableIRQ>
        }
        if (irq_type & MSS_I2C_SMBSUS_IRQ )
    3ed0:	78fb      	ldrb	r3, [r7, #3]
    3ed2:	f003 0302 	and.w	r3, r3, #2
    3ed6:	2b00      	cmp	r3, #0
    3ed8:	d00f      	beq.n	3efa <MSS_I2C_enable_smbus_irq+0xda>
        {
            /* Clear interrupt at the NVIC and enable in MSS I2C */
            NVIC_ClearPendingIRQ( I2C1_SMBus_IRQn );
    3eda:	f04f 0013 	mov.w	r0, #19
    3ede:	f7fe ff35 	bl	2d4c <NVIC_ClearPendingIRQ>
            this_i2c->hw_smb_reg_bit->SMB_SMBSUS_IE = 0x01u;
    3ee2:	687b      	ldr	r3, [r7, #4]
    3ee4:	69db      	ldr	r3, [r3, #28]
    3ee6:	f04f 0201 	mov.w	r2, #1
    3eea:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
            /* Enable the interrupt at the NVIC */
            NVIC_EnableIRQ( I2C1_SMBus_IRQn );
    3eee:	f04f 0013 	mov.w	r0, #19
    3ef2:	f7fe fef1 	bl	2cd8 <NVIC_EnableIRQ>
    3ef6:	e000      	b.n	3efa <MSS_I2C_enable_smbus_irq+0xda>
        {
            /* Clear interrupt at the NVIC and enable in MSS I2C */
            NVIC_ClearPendingIRQ( I2C0_SMBus_IRQn );
            this_i2c->hw_smb_reg_bit->SMB_SMBSUS_IE = 0x01u;
            /* Enable the interrupt at the NVIC */
            NVIC_EnableIRQ( I2C0_SMBus_IRQn );
    3ef8:	bf00      	nop
            this_i2c->hw_smb_reg_bit->SMB_SMBSUS_IE = 0x01u;
            /* Enable the interrupt at the NVIC */
            NVIC_EnableIRQ( I2C1_SMBus_IRQn );
        }
    }
}
    3efa:	f107 0708 	add.w	r7, r7, #8
    3efe:	46bd      	mov	sp, r7
    3f00:	bd80      	pop	{r7, pc}
    3f02:	bf00      	nop

00003f04 <MSS_I2C_disable_smbus_irq>:
void MSS_I2C_disable_smbus_irq
(
    mss_i2c_instance_t * this_i2c,
    uint8_t  irq_type
)
{
    3f04:	b580      	push	{r7, lr}
    3f06:	b082      	sub	sp, #8
    3f08:	af00      	add	r7, sp, #0
    3f0a:	6078      	str	r0, [r7, #4]
    3f0c:	460b      	mov	r3, r1
    3f0e:	70fb      	strb	r3, [r7, #3]
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
    3f10:	687a      	ldr	r2, [r7, #4]
    3f12:	f64a 13f8 	movw	r3, #43512	; 0xa9f8
    3f16:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3f1a:	429a      	cmp	r2, r3
    3f1c:	d007      	beq.n	3f2e <MSS_I2C_disable_smbus_irq+0x2a>
    3f1e:	687a      	ldr	r2, [r7, #4]
    3f20:	f64a 236c 	movw	r3, #43628	; 0xaa6c
    3f24:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3f28:	429a      	cmp	r2, r3
    3f2a:	d000      	beq.n	3f2e <MSS_I2C_disable_smbus_irq+0x2a>
    3f2c:	be00      	bkpt	0x0000

	/* Disable any interrupts selected by the user */
    if ( this_i2c == &g_mss_i2c0 )
    3f2e:	687a      	ldr	r2, [r7, #4]
    3f30:	f64a 13f8 	movw	r3, #43512	; 0xa9f8
    3f34:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3f38:	429a      	cmp	r2, r3
    3f3a:	d11f      	bne.n	3f7c <MSS_I2C_disable_smbus_irq+0x78>
    {
        if ( irq_type & MSS_I2C_SMBALERT_IRQ )
    3f3c:	78fb      	ldrb	r3, [r7, #3]
    3f3e:	f003 0301 	and.w	r3, r3, #1
    3f42:	b2db      	uxtb	r3, r3
    3f44:	2b00      	cmp	r3, #0
    3f46:	d009      	beq.n	3f5c <MSS_I2C_disable_smbus_irq+0x58>
        {
            /* Disable interrupt at the NVIC and the MSS I2C */
            this_i2c->hw_smb_reg_bit->SMB_SMBALERT_IE = 0x00u;
    3f48:	687b      	ldr	r3, [r7, #4]
    3f4a:	69db      	ldr	r3, [r3, #28]
    3f4c:	f04f 0200 	mov.w	r2, #0
    3f50:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
            NVIC_DisableIRQ( I2C0_SMBAlert_IRQn );
    3f54:	f04f 000f 	mov.w	r0, #15
    3f58:	f7fe feda 	bl	2d10 <NVIC_DisableIRQ>
        }
        if (irq_type & MSS_I2C_SMBSUS_IRQ )
    3f5c:	78fb      	ldrb	r3, [r7, #3]
    3f5e:	f003 0302 	and.w	r3, r3, #2
    3f62:	2b00      	cmp	r3, #0
    3f64:	d02a      	beq.n	3fbc <MSS_I2C_disable_smbus_irq+0xb8>
        {
            /* Disable interrupt at the NVIC and the MSS I2C */
            this_i2c->hw_smb_reg_bit->SMB_SMBSUS_IE = 0x00u;
    3f66:	687b      	ldr	r3, [r7, #4]
    3f68:	69db      	ldr	r3, [r3, #28]
    3f6a:	f04f 0200 	mov.w	r2, #0
    3f6e:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
            NVIC_DisableIRQ( I2C0_SMBus_IRQn );
    3f72:	f04f 0010 	mov.w	r0, #16
    3f76:	f7fe fecb 	bl	2d10 <NVIC_DisableIRQ>
    3f7a:	e020      	b.n	3fbe <MSS_I2C_disable_smbus_irq+0xba>
        }
    }
    else
    {
        if ( irq_type & MSS_I2C_SMBALERT_IRQ )
    3f7c:	78fb      	ldrb	r3, [r7, #3]
    3f7e:	f003 0301 	and.w	r3, r3, #1
    3f82:	b2db      	uxtb	r3, r3
    3f84:	2b00      	cmp	r3, #0
    3f86:	d009      	beq.n	3f9c <MSS_I2C_disable_smbus_irq+0x98>
        {
            /* Disable interrupt at the NVIC and the MSS I2C */
            this_i2c->hw_smb_reg_bit->SMB_SMBALERT_IE = 0x00u;
    3f88:	687b      	ldr	r3, [r7, #4]
    3f8a:	69db      	ldr	r3, [r3, #28]
    3f8c:	f04f 0200 	mov.w	r2, #0
    3f90:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
            NVIC_DisableIRQ( I2C1_SMBAlert_IRQn );
    3f94:	f04f 0012 	mov.w	r0, #18
    3f98:	f7fe feba 	bl	2d10 <NVIC_DisableIRQ>
        }
        if (irq_type & MSS_I2C_SMBSUS_IRQ )
    3f9c:	78fb      	ldrb	r3, [r7, #3]
    3f9e:	f003 0302 	and.w	r3, r3, #2
    3fa2:	2b00      	cmp	r3, #0
    3fa4:	d00b      	beq.n	3fbe <MSS_I2C_disable_smbus_irq+0xba>
        {
            /* Disable interrupt at the NVIC and the MSS I2C */
            this_i2c->hw_smb_reg_bit->SMB_SMBSUS_IE = 0x00u;
    3fa6:	687b      	ldr	r3, [r7, #4]
    3fa8:	69db      	ldr	r3, [r3, #28]
    3faa:	f04f 0200 	mov.w	r2, #0
    3fae:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
            NVIC_DisableIRQ( I2C1_SMBus_IRQn );
    3fb2:	f04f 0013 	mov.w	r0, #19
    3fb6:	f7fe feab 	bl	2d10 <NVIC_DisableIRQ>
    3fba:	e000      	b.n	3fbe <MSS_I2C_disable_smbus_irq+0xba>
        }
        if (irq_type & MSS_I2C_SMBSUS_IRQ )
        {
            /* Disable interrupt at the NVIC and the MSS I2C */
            this_i2c->hw_smb_reg_bit->SMB_SMBSUS_IE = 0x00u;
            NVIC_DisableIRQ( I2C0_SMBus_IRQn );
    3fbc:	bf00      	nop
            /* Disable interrupt at the NVIC and the MSS I2C */
            this_i2c->hw_smb_reg_bit->SMB_SMBSUS_IE = 0x00u;
            NVIC_DisableIRQ( I2C1_SMBus_IRQn );
        }
    }
}
    3fbe:	f107 0708 	add.w	r7, r7, #8
    3fc2:	46bd      	mov	sp, r7
    3fc4:	bd80      	pop	{r7, pc}
    3fc6:	bf00      	nop

00003fc8 <MSS_I2C_suspend_smbus_slave>:
 */
void MSS_I2C_suspend_smbus_slave
(
    mss_i2c_instance_t * this_i2c
)
{
    3fc8:	b480      	push	{r7}
    3fca:	b083      	sub	sp, #12
    3fcc:	af00      	add	r7, sp, #0
    3fce:	6078      	str	r0, [r7, #4]
    /* Active low output so 0 asserts condition */
    this_i2c->hw_smb_reg_bit->SMB_SMBSUS_NO = 0x00u;
    3fd0:	687b      	ldr	r3, [r7, #4]
    3fd2:	69db      	ldr	r3, [r3, #28]
    3fd4:	f04f 0200 	mov.w	r2, #0
    3fd8:	f8c3 2218 	str.w	r2, [r3, #536]	; 0x218
}
    3fdc:	f107 070c 	add.w	r7, r7, #12
    3fe0:	46bd      	mov	sp, r7
    3fe2:	bc80      	pop	{r7}
    3fe4:	4770      	bx	lr
    3fe6:	bf00      	nop

00003fe8 <MSS_I2C_resume_smbus_slave>:
 */
void MSS_I2C_resume_smbus_slave
(
    mss_i2c_instance_t * this_i2c
)
{
    3fe8:	b480      	push	{r7}
    3fea:	b083      	sub	sp, #12
    3fec:	af00      	add	r7, sp, #0
    3fee:	6078      	str	r0, [r7, #4]
    /* Active low output so 1 clears condition */
    this_i2c->hw_smb_reg_bit->SMB_SMBSUS_NO = 0x01u;
    3ff0:	687b      	ldr	r3, [r7, #4]
    3ff2:	69db      	ldr	r3, [r3, #28]
    3ff4:	f04f 0201 	mov.w	r2, #1
    3ff8:	f8c3 2218 	str.w	r2, [r3, #536]	; 0x218
}
    3ffc:	f107 070c 	add.w	r7, r7, #12
    4000:	46bd      	mov	sp, r7
    4002:	bc80      	pop	{r7}
    4004:	4770      	bx	lr
    4006:	bf00      	nop

00004008 <MSS_I2C_reset_smbus>:
 */
void MSS_I2C_reset_smbus
(
    mss_i2c_instance_t * this_i2c
)
{
    4008:	b480      	push	{r7}
    400a:	b083      	sub	sp, #12
    400c:	af00      	add	r7, sp, #0
    400e:	6078      	str	r0, [r7, #4]
    this_i2c->hw_smb_reg_bit->SMB_SMBus_Reset = 0x01u;
    4010:	687b      	ldr	r3, [r7, #4]
    4012:	69db      	ldr	r3, [r3, #28]
    4014:	f04f 0201 	mov.w	r2, #1
    4018:	f8c3 221c 	str.w	r2, [r3, #540]	; 0x21c
}
    401c:	f107 070c 	add.w	r7, r7, #12
    4020:	46bd      	mov	sp, r7
    4022:	bc80      	pop	{r7}
    4024:	4770      	bx	lr
    4026:	bf00      	nop

00004028 <MSS_I2C_set_smbus_alert>:
 */
void MSS_I2C_set_smbus_alert
(
    mss_i2c_instance_t * this_i2c
)
{
    4028:	b480      	push	{r7}
    402a:	b083      	sub	sp, #12
    402c:	af00      	add	r7, sp, #0
    402e:	6078      	str	r0, [r7, #4]
    /* Active low output so 0 asserts condition */
    this_i2c->hw_smb_reg_bit->SMB_SMBALERT_NO = 0x00u;
    4030:	687b      	ldr	r3, [r7, #4]
    4032:	69db      	ldr	r3, [r3, #28]
    4034:	f04f 0200 	mov.w	r2, #0
    4038:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
}
    403c:	f107 070c 	add.w	r7, r7, #12
    4040:	46bd      	mov	sp, r7
    4042:	bc80      	pop	{r7}
    4044:	4770      	bx	lr
    4046:	bf00      	nop

00004048 <MSS_I2C_clear_smbus_alert>:
 */
void MSS_I2C_clear_smbus_alert
(
    mss_i2c_instance_t * this_i2c
)
{
    4048:	b480      	push	{r7}
    404a:	b083      	sub	sp, #12
    404c:	af00      	add	r7, sp, #0
    404e:	6078      	str	r0, [r7, #4]
    /* Active low output so 1 clears condition */
    this_i2c->hw_smb_reg_bit->SMB_SMBALERT_NO = 0x01u;
    4050:	687b      	ldr	r3, [r7, #4]
    4052:	69db      	ldr	r3, [r3, #28]
    4054:	f04f 0201 	mov.w	r2, #1
    4058:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
}
    405c:	f107 070c 	add.w	r7, r7, #12
    4060:	46bd      	mov	sp, r7
    4062:	bc80      	pop	{r7}
    4064:	4770      	bx	lr
    4066:	bf00      	nop

00004068 <MSS_I2C_set_gca>:

void MSS_I2C_set_gca
(
    mss_i2c_instance_t * this_i2c
)
{
    4068:	b480      	push	{r7}
    406a:	b083      	sub	sp, #12
    406c:	af00      	add	r7, sp, #0
    406e:	6078      	str	r0, [r7, #4]
    /* accept GC addressing. */
    this_i2c->hw_reg_bit->ADDR_GC = 0x01u;
    4070:	687b      	ldr	r3, [r7, #4]
    4072:	699b      	ldr	r3, [r3, #24]
    4074:	f04f 0201 	mov.w	r2, #1
    4078:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
    407c:	f107 070c 	add.w	r7, r7, #12
    4080:	46bd      	mov	sp, r7
    4082:	bc80      	pop	{r7}
    4084:	4770      	bx	lr
    4086:	bf00      	nop

00004088 <MSS_I2C_clear_gca>:
 */
void MSS_I2C_clear_gca
(
    mss_i2c_instance_t * this_i2c
)
{
    4088:	b480      	push	{r7}
    408a:	b083      	sub	sp, #12
    408c:	af00      	add	r7, sp, #0
    408e:	6078      	str	r0, [r7, #4]
    /* Disable GC addressing. */
    this_i2c->hw_reg_bit->ADDR_GC = 0u;
    4090:	687b      	ldr	r3, [r7, #4]
    4092:	699b      	ldr	r3, [r3, #24]
    4094:	f04f 0200 	mov.w	r2, #0
    4098:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
    409c:	f107 070c 	add.w	r7, r7, #12
    40a0:	46bd      	mov	sp, r7
    40a2:	bc80      	pop	{r7}
    40a4:	4770      	bx	lr
    40a6:	bf00      	nop

000040a8 <MSS_I2C_set_user_data>:
void MSS_I2C_set_user_data
(
    mss_i2c_instance_t * this_i2c,
    void * p_user_data
)
{
    40a8:	b480      	push	{r7}
    40aa:	b083      	sub	sp, #12
    40ac:	af00      	add	r7, sp, #0
    40ae:	6078      	str	r0, [r7, #4]
    40b0:	6039      	str	r1, [r7, #0]
    this_i2c->p_user_data = p_user_data ;
    40b2:	687b      	ldr	r3, [r7, #4]
    40b4:	683a      	ldr	r2, [r7, #0]
    40b6:	66da      	str	r2, [r3, #108]	; 0x6c
}
    40b8:	f107 070c 	add.w	r7, r7, #12
    40bc:	46bd      	mov	sp, r7
    40be:	bc80      	pop	{r7}
    40c0:	4770      	bx	lr
    40c2:	bf00      	nop

000040c4 <MSS_I2C_get_user_data>:
 */
void * MSS_I2C_get_user_data
(
    mss_i2c_instance_t * this_i2c
)
{
    40c4:	b480      	push	{r7}
    40c6:	b083      	sub	sp, #12
    40c8:	af00      	add	r7, sp, #0
    40ca:	6078      	str	r0, [r7, #4]
    return( this_i2c->p_user_data);
    40cc:	687b      	ldr	r3, [r7, #4]
    40ce:	6edb      	ldr	r3, [r3, #108]	; 0x6c
}
    40d0:	4618      	mov	r0, r3
    40d2:	f107 070c 	add.w	r7, r7, #12
    40d6:	46bd      	mov	sp, r7
    40d8:	bc80      	pop	{r7}
    40da:	4770      	bx	lr

000040dc <disable_interrupts>:
/*------------------------------------------------------------------------------
 *
 */
static uint32_t disable_interrupts( void )
{
    40dc:	b580      	push	{r7, lr}
    40de:	b082      	sub	sp, #8
    40e0:	af00      	add	r7, sp, #0
    uint32_t primask;
    primask = __get_PRIMASK();
    40e2:	f006 f80f 	bl	a104 <__get_PRIMASK>
    40e6:	4603      	mov	r3, r0
    40e8:	607b      	str	r3, [r7, #4]
    __set_PRIMASK(1u);
    40ea:	f04f 0001 	mov.w	r0, #1
    40ee:	f006 f819 	bl	a124 <__set_PRIMASK>
    return primask;
    40f2:	687b      	ldr	r3, [r7, #4]
}
    40f4:	4618      	mov	r0, r3
    40f6:	f107 0708 	add.w	r7, r7, #8
    40fa:	46bd      	mov	sp, r7
    40fc:	bd80      	pop	{r7, pc}
    40fe:	bf00      	nop

00004100 <restore_interrupts>:

/*------------------------------------------------------------------------------
 *
 */
static void restore_interrupts( uint32_t primask )
{
    4100:	b580      	push	{r7, lr}
    4102:	b082      	sub	sp, #8
    4104:	af00      	add	r7, sp, #0
    4106:	6078      	str	r0, [r7, #4]
    __set_PRIMASK( primask );
    4108:	6878      	ldr	r0, [r7, #4]
    410a:	f006 f80b 	bl	a124 <__set_PRIMASK>
}
    410e:	f107 0708 	add.w	r7, r7, #8
    4112:	46bd      	mov	sp, r7
    4114:	bd80      	pop	{r7, pc}
    4116:	bf00      	nop

00004118 <I2C0_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void I2C0_IRQHandler( void )
#else
void I2C0_IRQHandler( void )
#endif
{
    4118:	4668      	mov	r0, sp
    411a:	f020 0107 	bic.w	r1, r0, #7
    411e:	468d      	mov	sp, r1
    4120:	b589      	push	{r0, r3, r7, lr}
    4122:	af00      	add	r7, sp, #0
    mss_i2c_isr( &g_mss_i2c0 );
    4124:	f64a 10f8 	movw	r0, #43512	; 0xa9f8
    4128:	f2c2 0000 	movt	r0, #8192	; 0x2000
    412c:	f7ff f9ea 	bl	3504 <mss_i2c_isr>
    NVIC_ClearPendingIRQ( I2C0_IRQn );
    4130:	f04f 000e 	mov.w	r0, #14
    4134:	f7fe fe0a 	bl	2d4c <NVIC_ClearPendingIRQ>
}
    4138:	46bd      	mov	sp, r7
    413a:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    413e:	4685      	mov	sp, r0
    4140:	4770      	bx	lr
    4142:	bf00      	nop

00004144 <I2C1_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void I2C1_IRQHandler( void )
#else
void I2C1_IRQHandler( void )
#endif
{
    4144:	4668      	mov	r0, sp
    4146:	f020 0107 	bic.w	r1, r0, #7
    414a:	468d      	mov	sp, r1
    414c:	b589      	push	{r0, r3, r7, lr}
    414e:	af00      	add	r7, sp, #0
    mss_i2c_isr( &g_mss_i2c1 );
    4150:	f64a 206c 	movw	r0, #43628	; 0xaa6c
    4154:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4158:	f7ff f9d4 	bl	3504 <mss_i2c_isr>
    NVIC_ClearPendingIRQ( I2C1_IRQn );
    415c:	f04f 0011 	mov.w	r0, #17
    4160:	f7fe fdf4 	bl	2d4c <NVIC_ClearPendingIRQ>
}
    4164:	46bd      	mov	sp, r7
    4166:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    416a:	4685      	mov	sp, r0
    416c:	4770      	bx	lr
    416e:	bf00      	nop

00004170 <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
    4170:	b480      	push	{r7}
    4172:	b083      	sub	sp, #12
    4174:	af00      	add	r7, sp, #0
    4176:	4603      	mov	r3, r0
    4178:	80fb      	strh	r3, [r7, #6]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    417a:	f24e 1300 	movw	r3, #57600	; 0xe100
    417e:	f2ce 0300 	movt	r3, #57344	; 0xe000
    4182:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    4186:	ea4f 1252 	mov.w	r2, r2, lsr #5
    418a:	88f9      	ldrh	r1, [r7, #6]
    418c:	f001 011f 	and.w	r1, r1, #31
    4190:	f04f 0001 	mov.w	r0, #1
    4194:	fa00 f101 	lsl.w	r1, r0, r1
    4198:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    419c:	f107 070c 	add.w	r7, r7, #12
    41a0:	46bd      	mov	sp, r7
    41a2:	bc80      	pop	{r7}
    41a4:	4770      	bx	lr
    41a6:	bf00      	nop

000041a8 <NVIC_ClearPendingIRQ>:
 *
 * Clear the pending bit for the specified interrupt. 
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
    41a8:	b480      	push	{r7}
    41aa:	b083      	sub	sp, #12
    41ac:	af00      	add	r7, sp, #0
    41ae:	4603      	mov	r3, r0
    41b0:	80fb      	strh	r3, [r7, #6]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    41b2:	f24e 1300 	movw	r3, #57600	; 0xe100
    41b6:	f2ce 0300 	movt	r3, #57344	; 0xe000
    41ba:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    41be:	ea4f 1252 	mov.w	r2, r2, lsr #5
    41c2:	88f9      	ldrh	r1, [r7, #6]
    41c4:	f001 011f 	and.w	r1, r1, #31
    41c8:	f04f 0001 	mov.w	r0, #1
    41cc:	fa00 f101 	lsl.w	r1, r0, r1
    41d0:	f102 0260 	add.w	r2, r2, #96	; 0x60
    41d4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    41d8:	f107 070c 	add.w	r7, r7, #12
    41dc:	46bd      	mov	sp, r7
    41de:	bc80      	pop	{r7}
    41e0:	4770      	bx	lr
    41e2:	bf00      	nop

000041e4 <MSS_GPIO_init>:
/*-------------------------------------------------------------------------*//**
 * MSS_GPIO_init
 * See "mss_gpio.h" for details of how to use this function.
 */
void MSS_GPIO_init( void )
{
    41e4:	b580      	push	{r7, lr}
    41e6:	b082      	sub	sp, #8
    41e8:	af00      	add	r7, sp, #0
    uint32_t i;
    
    /* reset MSS GPIO hardware */
    SYSREG->SOFT_RST_CR |= SYSREG_GPIO_SOFTRESET_MASK;
    41ea:	f242 0300 	movw	r3, #8192	; 0x2000
    41ee:	f2ce 0304 	movt	r3, #57348	; 0xe004
    41f2:	f242 0200 	movw	r2, #8192	; 0x2000
    41f6:	f2ce 0204 	movt	r2, #57348	; 0xe004
    41fa:	6b12      	ldr	r2, [r2, #48]	; 0x30
    41fc:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    4200:	631a      	str	r2, [r3, #48]	; 0x30
    /* Clear any previously pended MSS GPIO interrupt */
    for ( i = 0U; i < NB_OF_GPIO; ++i )
    4202:	f04f 0300 	mov.w	r3, #0
    4206:	607b      	str	r3, [r7, #4]
    4208:	e00e      	b.n	4228 <MSS_GPIO_init+0x44>
    {
        NVIC_ClearPendingIRQ( g_gpio_irqn_lut[i] );
    420a:	687a      	ldr	r2, [r7, #4]
    420c:	f64c 13bc 	movw	r3, #51644	; 0xc9bc
    4210:	f2c0 0301 	movt	r3, #1
    4214:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    4218:	b21b      	sxth	r3, r3
    421a:	4618      	mov	r0, r3
    421c:	f7ff ffc4 	bl	41a8 <NVIC_ClearPendingIRQ>
    uint32_t i;
    
    /* reset MSS GPIO hardware */
    SYSREG->SOFT_RST_CR |= SYSREG_GPIO_SOFTRESET_MASK;
    /* Clear any previously pended MSS GPIO interrupt */
    for ( i = 0U; i < NB_OF_GPIO; ++i )
    4220:	687b      	ldr	r3, [r7, #4]
    4222:	f103 0301 	add.w	r3, r3, #1
    4226:	607b      	str	r3, [r7, #4]
    4228:	687b      	ldr	r3, [r7, #4]
    422a:	2b1f      	cmp	r3, #31
    422c:	d9ed      	bls.n	420a <MSS_GPIO_init+0x26>
    {
        NVIC_ClearPendingIRQ( g_gpio_irqn_lut[i] );
    }
    /* Take MSS GPIO hardware out of reset. */
    SYSREG->SOFT_RST_CR &= ~SYSREG_GPIO_SOFTRESET_MASK;
    422e:	f242 0300 	movw	r3, #8192	; 0x2000
    4232:	f2ce 0304 	movt	r3, #57348	; 0xe004
    4236:	f242 0200 	movw	r2, #8192	; 0x2000
    423a:	f2ce 0204 	movt	r2, #57348	; 0xe004
    423e:	6b12      	ldr	r2, [r2, #48]	; 0x30
    4240:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
    4244:	631a      	str	r2, [r3, #48]	; 0x30
}
    4246:	f107 0708 	add.w	r7, r7, #8
    424a:	46bd      	mov	sp, r7
    424c:	bd80      	pop	{r7, pc}
    424e:	bf00      	nop

00004250 <MSS_GPIO_config>:
void MSS_GPIO_config
(
    mss_gpio_id_t port_id,
    uint32_t config
)
{
    4250:	b480      	push	{r7}
    4252:	b085      	sub	sp, #20
    4254:	af00      	add	r7, sp, #0
    4256:	4603      	mov	r3, r0
    4258:	6039      	str	r1, [r7, #0]
    425a:	71fb      	strb	r3, [r7, #7]
    uint32_t gpio_idx = (uint32_t)port_id;
    425c:	79fb      	ldrb	r3, [r7, #7]
    425e:	60fb      	str	r3, [r7, #12]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
    4260:	68fb      	ldr	r3, [r7, #12]
    4262:	2b1f      	cmp	r3, #31
    4264:	d900      	bls.n	4268 <MSS_GPIO_config+0x18>
    4266:	be00      	bkpt	0x0000

    if ( gpio_idx < NB_OF_GPIO )
    4268:	68fb      	ldr	r3, [r7, #12]
    426a:	2b1f      	cmp	r3, #31
    426c:	d808      	bhi.n	4280 <MSS_GPIO_config+0x30>
    {
        *(g_config_reg_lut[gpio_idx]) = config;
    426e:	68fa      	ldr	r2, [r7, #12]
    4270:	f64c 133c 	movw	r3, #51516	; 0xc93c
    4274:	f2c0 0301 	movt	r3, #1
    4278:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    427c:	683a      	ldr	r2, [r7, #0]
    427e:	601a      	str	r2, [r3, #0]
    }
}
    4280:	f107 0714 	add.w	r7, r7, #20
    4284:	46bd      	mov	sp, r7
    4286:	bc80      	pop	{r7}
    4288:	4770      	bx	lr
    428a:	bf00      	nop

0000428c <MSS_GPIO_set_output>:
void MSS_GPIO_set_output
(
    mss_gpio_id_t       port_id,
    uint8_t             value
)
{
    428c:	b480      	push	{r7}
    428e:	b085      	sub	sp, #20
    4290:	af00      	add	r7, sp, #0
    4292:	4602      	mov	r2, r0
    4294:	460b      	mov	r3, r1
    4296:	71fa      	strb	r2, [r7, #7]
    4298:	71bb      	strb	r3, [r7, #6]
    uint32_t gpio_idx = (uint32_t)port_id;
    429a:	79fb      	ldrb	r3, [r7, #7]
    429c:	60fb      	str	r3, [r7, #12]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
    429e:	68fb      	ldr	r3, [r7, #12]
    42a0:	2b1f      	cmp	r3, #31
    42a2:	d900      	bls.n	42a6 <MSS_GPIO_set_output+0x1a>
    42a4:	be00      	bkpt	0x0000
    
    if ( gpio_idx < NB_OF_GPIO )
    42a6:	68fb      	ldr	r3, [r7, #12]
    42a8:	2b1f      	cmp	r3, #31
    42aa:	d809      	bhi.n	42c0 <MSS_GPIO_set_output+0x34>
    {
        GPIO_BITBAND->GPIO_OUT[gpio_idx] = (uint32_t)value;
    42ac:	f240 0300 	movw	r3, #0
    42b0:	f2c4 2326 	movt	r3, #16934	; 0x4226
    42b4:	68fa      	ldr	r2, [r7, #12]
    42b6:	79b9      	ldrb	r1, [r7, #6]
    42b8:	f502 6288 	add.w	r2, r2, #1088	; 0x440
    42bc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }
}
    42c0:	f107 0714 	add.w	r7, r7, #20
    42c4:	46bd      	mov	sp, r7
    42c6:	bc80      	pop	{r7}
    42c8:	4770      	bx	lr
    42ca:	bf00      	nop

000042cc <MSS_GPIO_drive_inout>:
void MSS_GPIO_drive_inout
(
    mss_gpio_id_t port_id,
    mss_gpio_inout_state_t inout_state
)
{
    42cc:	b480      	push	{r7}
    42ce:	b087      	sub	sp, #28
    42d0:	af00      	add	r7, sp, #0
    42d2:	4602      	mov	r2, r0
    42d4:	460b      	mov	r3, r1
    42d6:	71fa      	strb	r2, [r7, #7]
    42d8:	71bb      	strb	r3, [r7, #6]
    uint32_t outputs_state;
    uint32_t config;
    uint32_t gpio_idx = (uint32_t)port_id;
    42da:	79fb      	ldrb	r3, [r7, #7]
    42dc:	617b      	str	r3, [r7, #20]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
    42de:	697b      	ldr	r3, [r7, #20]
    42e0:	2b1f      	cmp	r3, #31
    42e2:	d900      	bls.n	42e6 <MSS_GPIO_drive_inout+0x1a>
    42e4:	be00      	bkpt	0x0000
    
    if ( gpio_idx < NB_OF_GPIO )
    42e6:	697b      	ldr	r3, [r7, #20]
    42e8:	2b1f      	cmp	r3, #31
    42ea:	d87d      	bhi.n	43e8 <MSS_GPIO_drive_inout+0x11c>
    {
        switch( inout_state )
    42ec:	79bb      	ldrb	r3, [r7, #6]
    42ee:	2b01      	cmp	r3, #1
    42f0:	d004      	beq.n	42fc <MSS_GPIO_drive_inout+0x30>
    42f2:	2b02      	cmp	r3, #2
    42f4:	d060      	beq.n	43b8 <MSS_GPIO_drive_inout+0xec>
    42f6:	2b00      	cmp	r3, #0
    42f8:	d02e      	beq.n	4358 <MSS_GPIO_drive_inout+0x8c>
    42fa:	e074      	b.n	43e6 <MSS_GPIO_drive_inout+0x11a>
        {
        case MSS_GPIO_DRIVE_HIGH:
            /* Set output high */
            outputs_state = GPIO->GPIO_OUT;
    42fc:	f243 0300 	movw	r3, #12288	; 0x3000
    4300:	f2c4 0301 	movt	r3, #16385	; 0x4001
    4304:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    4308:	60fb      	str	r3, [r7, #12]
            outputs_state |= (uint32_t)1 << gpio_idx;
    430a:	697b      	ldr	r3, [r7, #20]
    430c:	f04f 0201 	mov.w	r2, #1
    4310:	fa02 f303 	lsl.w	r3, r2, r3
    4314:	68fa      	ldr	r2, [r7, #12]
    4316:	ea42 0303 	orr.w	r3, r2, r3
    431a:	60fb      	str	r3, [r7, #12]
            GPIO->GPIO_OUT = outputs_state;
    431c:	f243 0300 	movw	r3, #12288	; 0x3000
    4320:	f2c4 0301 	movt	r3, #16385	; 0x4001
    4324:	68fa      	ldr	r2, [r7, #12]
    4326:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
            /* Enable output buffer */
            config = *(g_config_reg_lut[gpio_idx]);
    432a:	697a      	ldr	r2, [r7, #20]
    432c:	f64c 133c 	movw	r3, #51516	; 0xc93c
    4330:	f2c0 0301 	movt	r3, #1
    4334:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    4338:	681b      	ldr	r3, [r3, #0]
    433a:	613b      	str	r3, [r7, #16]
            config |= OUTPUT_BUFFER_ENABLE_MASK;
    433c:	693b      	ldr	r3, [r7, #16]
    433e:	f043 0304 	orr.w	r3, r3, #4
    4342:	613b      	str	r3, [r7, #16]
            *(g_config_reg_lut[gpio_idx]) = config;
    4344:	697a      	ldr	r2, [r7, #20]
    4346:	f64c 133c 	movw	r3, #51516	; 0xc93c
    434a:	f2c0 0301 	movt	r3, #1
    434e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    4352:	693a      	ldr	r2, [r7, #16]
    4354:	601a      	str	r2, [r3, #0]
            break;
    4356:	e047      	b.n	43e8 <MSS_GPIO_drive_inout+0x11c>
            
        case MSS_GPIO_DRIVE_LOW:
            /* Set output low */
            outputs_state = GPIO->GPIO_OUT;
    4358:	f243 0300 	movw	r3, #12288	; 0x3000
    435c:	f2c4 0301 	movt	r3, #16385	; 0x4001
    4360:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    4364:	60fb      	str	r3, [r7, #12]
            outputs_state &= ~((uint32_t)((uint32_t)1 << gpio_idx));
    4366:	697b      	ldr	r3, [r7, #20]
    4368:	f04f 0201 	mov.w	r2, #1
    436c:	fa02 f303 	lsl.w	r3, r2, r3
    4370:	ea6f 0303 	mvn.w	r3, r3
    4374:	68fa      	ldr	r2, [r7, #12]
    4376:	ea02 0303 	and.w	r3, r2, r3
    437a:	60fb      	str	r3, [r7, #12]
            GPIO->GPIO_OUT = outputs_state;
    437c:	f243 0300 	movw	r3, #12288	; 0x3000
    4380:	f2c4 0301 	movt	r3, #16385	; 0x4001
    4384:	68fa      	ldr	r2, [r7, #12]
    4386:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
            /* Enable output buffer */
            config = *(g_config_reg_lut[gpio_idx]);
    438a:	697a      	ldr	r2, [r7, #20]
    438c:	f64c 133c 	movw	r3, #51516	; 0xc93c
    4390:	f2c0 0301 	movt	r3, #1
    4394:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    4398:	681b      	ldr	r3, [r3, #0]
    439a:	613b      	str	r3, [r7, #16]
            config |= OUTPUT_BUFFER_ENABLE_MASK;
    439c:	693b      	ldr	r3, [r7, #16]
    439e:	f043 0304 	orr.w	r3, r3, #4
    43a2:	613b      	str	r3, [r7, #16]
            *(g_config_reg_lut[gpio_idx]) = config;
    43a4:	697a      	ldr	r2, [r7, #20]
    43a6:	f64c 133c 	movw	r3, #51516	; 0xc93c
    43aa:	f2c0 0301 	movt	r3, #1
    43ae:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    43b2:	693a      	ldr	r2, [r7, #16]
    43b4:	601a      	str	r2, [r3, #0]
            break;
    43b6:	e017      	b.n	43e8 <MSS_GPIO_drive_inout+0x11c>
            
        case MSS_GPIO_HIGH_Z:
            /* Disable output buffer */
            config = *(g_config_reg_lut[gpio_idx]);
    43b8:	697a      	ldr	r2, [r7, #20]
    43ba:	f64c 133c 	movw	r3, #51516	; 0xc93c
    43be:	f2c0 0301 	movt	r3, #1
    43c2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    43c6:	681b      	ldr	r3, [r3, #0]
    43c8:	613b      	str	r3, [r7, #16]
            config &= ~OUTPUT_BUFFER_ENABLE_MASK;
    43ca:	693b      	ldr	r3, [r7, #16]
    43cc:	f023 0304 	bic.w	r3, r3, #4
    43d0:	613b      	str	r3, [r7, #16]
            *(g_config_reg_lut[gpio_idx]) = config;
    43d2:	697a      	ldr	r2, [r7, #20]
    43d4:	f64c 133c 	movw	r3, #51516	; 0xc93c
    43d8:	f2c0 0301 	movt	r3, #1
    43dc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    43e0:	693a      	ldr	r2, [r7, #16]
    43e2:	601a      	str	r2, [r3, #0]
            break;
    43e4:	e000      	b.n	43e8 <MSS_GPIO_drive_inout+0x11c>
            
        default:
            ASSERT(0);
    43e6:	be00      	bkpt	0x0000
            break;
        }
    }
}
    43e8:	f107 071c 	add.w	r7, r7, #28
    43ec:	46bd      	mov	sp, r7
    43ee:	bc80      	pop	{r7}
    43f0:	4770      	bx	lr
    43f2:	bf00      	nop

000043f4 <MSS_GPIO_enable_irq>:
 */
void MSS_GPIO_enable_irq
(
    mss_gpio_id_t port_id
)
{
    43f4:	b580      	push	{r7, lr}
    43f6:	b084      	sub	sp, #16
    43f8:	af00      	add	r7, sp, #0
    43fa:	4603      	mov	r3, r0
    43fc:	71fb      	strb	r3, [r7, #7]
    uint32_t cfg_value;
    uint32_t gpio_idx = (uint32_t)port_id;
    43fe:	79fb      	ldrb	r3, [r7, #7]
    4400:	60fb      	str	r3, [r7, #12]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
    4402:	68fb      	ldr	r3, [r7, #12]
    4404:	2b1f      	cmp	r3, #31
    4406:	d900      	bls.n	440a <MSS_GPIO_enable_irq+0x16>
    4408:	be00      	bkpt	0x0000
    
    if ( gpio_idx < NB_OF_GPIO )
    440a:	68fb      	ldr	r3, [r7, #12]
    440c:	2b1f      	cmp	r3, #31
    440e:	d81e      	bhi.n	444e <MSS_GPIO_enable_irq+0x5a>
    {
        cfg_value = *(g_config_reg_lut[gpio_idx]);
    4410:	68fa      	ldr	r2, [r7, #12]
    4412:	f64c 133c 	movw	r3, #51516	; 0xc93c
    4416:	f2c0 0301 	movt	r3, #1
    441a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    441e:	681b      	ldr	r3, [r3, #0]
    4420:	60bb      	str	r3, [r7, #8]
        *(g_config_reg_lut[gpio_idx]) = (cfg_value | GPIO_INT_ENABLE_MASK);
    4422:	68fa      	ldr	r2, [r7, #12]
    4424:	f64c 133c 	movw	r3, #51516	; 0xc93c
    4428:	f2c0 0301 	movt	r3, #1
    442c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    4430:	68ba      	ldr	r2, [r7, #8]
    4432:	f042 0208 	orr.w	r2, r2, #8
    4436:	601a      	str	r2, [r3, #0]
        NVIC_EnableIRQ( g_gpio_irqn_lut[gpio_idx] );
    4438:	68fa      	ldr	r2, [r7, #12]
    443a:	f64c 13bc 	movw	r3, #51644	; 0xc9bc
    443e:	f2c0 0301 	movt	r3, #1
    4442:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    4446:	b21b      	sxth	r3, r3
    4448:	4618      	mov	r0, r3
    444a:	f7ff fe91 	bl	4170 <NVIC_EnableIRQ>
    }
}
    444e:	f107 0710 	add.w	r7, r7, #16
    4452:	46bd      	mov	sp, r7
    4454:	bd80      	pop	{r7, pc}
    4456:	bf00      	nop

00004458 <MSS_GPIO_disable_irq>:
 */
void MSS_GPIO_disable_irq
(
    mss_gpio_id_t port_id
)
{
    4458:	b480      	push	{r7}
    445a:	b085      	sub	sp, #20
    445c:	af00      	add	r7, sp, #0
    445e:	4603      	mov	r3, r0
    4460:	71fb      	strb	r3, [r7, #7]
    uint32_t cfg_value;
    uint32_t gpio_idx = (uint32_t)port_id;
    4462:	79fb      	ldrb	r3, [r7, #7]
    4464:	60fb      	str	r3, [r7, #12]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
    4466:	68fb      	ldr	r3, [r7, #12]
    4468:	2b1f      	cmp	r3, #31
    446a:	d900      	bls.n	446e <MSS_GPIO_disable_irq+0x16>
    446c:	be00      	bkpt	0x0000

    if ( gpio_idx < NB_OF_GPIO )
    446e:	68fb      	ldr	r3, [r7, #12]
    4470:	2b1f      	cmp	r3, #31
    4472:	d813      	bhi.n	449c <MSS_GPIO_disable_irq+0x44>
    {
        cfg_value = *(g_config_reg_lut[gpio_idx]);
    4474:	68fa      	ldr	r2, [r7, #12]
    4476:	f64c 133c 	movw	r3, #51516	; 0xc93c
    447a:	f2c0 0301 	movt	r3, #1
    447e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    4482:	681b      	ldr	r3, [r3, #0]
    4484:	60bb      	str	r3, [r7, #8]
        *(g_config_reg_lut[gpio_idx]) = (cfg_value & ~GPIO_INT_ENABLE_MASK);
    4486:	68fa      	ldr	r2, [r7, #12]
    4488:	f64c 133c 	movw	r3, #51516	; 0xc93c
    448c:	f2c0 0301 	movt	r3, #1
    4490:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    4494:	68ba      	ldr	r2, [r7, #8]
    4496:	f022 0208 	bic.w	r2, r2, #8
    449a:	601a      	str	r2, [r3, #0]
    }
}
    449c:	f107 0714 	add.w	r7, r7, #20
    44a0:	46bd      	mov	sp, r7
    44a2:	bc80      	pop	{r7}
    44a4:	4770      	bx	lr
    44a6:	bf00      	nop

000044a8 <MSS_GPIO_clear_irq>:
 */
void MSS_GPIO_clear_irq
(
    mss_gpio_id_t port_id
)
{
    44a8:	b580      	push	{r7, lr}
    44aa:	b084      	sub	sp, #16
    44ac:	af00      	add	r7, sp, #0
    44ae:	4603      	mov	r3, r0
    44b0:	71fb      	strb	r3, [r7, #7]
    uint32_t gpio_idx = (uint32_t)port_id;
    44b2:	79fb      	ldrb	r3, [r7, #7]
    44b4:	60fb      	str	r3, [r7, #12]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
    44b6:	68fb      	ldr	r3, [r7, #12]
    44b8:	2b1f      	cmp	r3, #31
    44ba:	d900      	bls.n	44be <MSS_GPIO_clear_irq+0x16>
    44bc:	be00      	bkpt	0x0000
    
    if ( gpio_idx < NB_OF_GPIO )
    44be:	68fb      	ldr	r3, [r7, #12]
    44c0:	2b1f      	cmp	r3, #31
    44c2:	d815      	bhi.n	44f0 <MSS_GPIO_clear_irq+0x48>
    {
        GPIO->GPIO_IRQ = ((uint32_t)1) << gpio_idx;
    44c4:	f243 0300 	movw	r3, #12288	; 0x3000
    44c8:	f2c4 0301 	movt	r3, #16385	; 0x4001
    44cc:	68fa      	ldr	r2, [r7, #12]
    44ce:	f04f 0101 	mov.w	r1, #1
    44d2:	fa01 f202 	lsl.w	r2, r1, r2
    44d6:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
        NVIC_ClearPendingIRQ( g_gpio_irqn_lut[gpio_idx] );
    44da:	68fa      	ldr	r2, [r7, #12]
    44dc:	f64c 13bc 	movw	r3, #51644	; 0xc9bc
    44e0:	f2c0 0301 	movt	r3, #1
    44e4:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    44e8:	b21b      	sxth	r3, r3
    44ea:	4618      	mov	r0, r3
    44ec:	f7ff fe5c 	bl	41a8 <NVIC_ClearPendingIRQ>
    }
}
    44f0:	f107 0710 	add.w	r7, r7, #16
    44f4:	46bd      	mov	sp, r7
    44f6:	bd80      	pop	{r7, pc}

000044f8 <mss_mac_crc32>:
(
    uint32_t value,
    const uint8_t *data,
    uint32_t data_length
)
{
    44f8:	b480      	push	{r7}
    44fa:	b087      	sub	sp, #28
    44fc:	af00      	add	r7, sp, #0
    44fe:	60f8      	str	r0, [r7, #12]
    4500:	60b9      	str	r1, [r7, #8]
    4502:	607a      	str	r2, [r7, #4]
  uint32_t a;
  
  for(a=0; a<data_length; a++) {
    4504:	f04f 0300 	mov.w	r3, #0
    4508:	617b      	str	r3, [r7, #20]
    450a:	e019      	b.n	4540 <mss_mac_crc32+0x48>
	value = crc32_table[(value ^ data[a]) & 0xff] ^ (value >> 8);
    450c:	68ba      	ldr	r2, [r7, #8]
    450e:	697b      	ldr	r3, [r7, #20]
    4510:	4413      	add	r3, r2
    4512:	781b      	ldrb	r3, [r3, #0]
    4514:	461a      	mov	r2, r3
    4516:	68fb      	ldr	r3, [r7, #12]
    4518:	ea82 0303 	eor.w	r3, r2, r3
    451c:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    4520:	f64c 13fc 	movw	r3, #51708	; 0xc9fc
    4524:	f2c0 0301 	movt	r3, #1
    4528:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    452c:	68fb      	ldr	r3, [r7, #12]
    452e:	ea4f 2313 	mov.w	r3, r3, lsr #8
    4532:	ea82 0303 	eor.w	r3, r2, r3
    4536:	60fb      	str	r3, [r7, #12]
    uint32_t data_length
)
{
  uint32_t a;
  
  for(a=0; a<data_length; a++) {
    4538:	697b      	ldr	r3, [r7, #20]
    453a:	f103 0301 	add.w	r3, r3, #1
    453e:	617b      	str	r3, [r7, #20]
    4540:	697a      	ldr	r2, [r7, #20]
    4542:	687b      	ldr	r3, [r7, #4]
    4544:	429a      	cmp	r2, r3
    4546:	d3e1      	bcc.n	450c <mss_mac_crc32+0x14>
	value = crc32_table[(value ^ data[a]) & 0xff] ^ (value >> 8);
  }
  
  return value;
    4548:	68fb      	ldr	r3, [r7, #12]
}
    454a:	4618      	mov	r0, r3
    454c:	f107 071c 	add.w	r7, r7, #28
    4550:	46bd      	mov	sp, r7
    4552:	bc80      	pop	{r7}
    4554:	4770      	bx	lr
    4556:	bf00      	nop

00004558 <mss_ethernet_crc>:
mss_ethernet_crc
(
    const uint8_t *data,
    uint32_t data_length
)
{
    4558:	b580      	push	{r7, lr}
    455a:	b082      	sub	sp, #8
    455c:	af00      	add	r7, sp, #0
    455e:	6078      	str	r0, [r7, #4]
    4560:	6039      	str	r1, [r7, #0]
	return mss_mac_crc32( 0xffffffffUL, data, data_length );
    4562:	f04f 30ff 	mov.w	r0, #4294967295
    4566:	6879      	ldr	r1, [r7, #4]
    4568:	683a      	ldr	r2, [r7, #0]
    456a:	f7ff ffc5 	bl	44f8 <mss_mac_crc32>
    456e:	4603      	mov	r3, r0
}
    4570:	4618      	mov	r0, r3
    4572:	f107 0708 	add.w	r7, r7, #8
    4576:	46bd      	mov	sp, r7
    4578:	bd80      	pop	{r7, pc}
    457a:	bf00      	nop

0000457c <MSS_MAC_init>:
void
MSS_MAC_init
(
	uint8_t phy_address
)
{
    457c:	b580      	push	{r7, lr}
    457e:	b08a      	sub	sp, #40	; 0x28
    4580:	af00      	add	r7, sp, #0
    4582:	4603      	mov	r3, r0
    4584:	71fb      	strb	r3, [r7, #7]
    const uint8_t mac_address[6] = { DEFAULT_MAC_ADDRESS };
    4586:	f64c 724c 	movw	r2, #53068	; 0xcf4c
    458a:	f2c0 0201 	movt	r2, #1
    458e:	f107 030c 	add.w	r3, r7, #12
    4592:	e892 0003 	ldmia.w	r2, {r0, r1}
    4596:	6018      	str	r0, [r3, #0]
    4598:	f103 0304 	add.w	r3, r3, #4
    459c:	8019      	strh	r1, [r3, #0]
    int32_t a;

	/* To start with all buffers are free. */
	for( a = 0; a < macNUM_BUFFERS; a++ )
    459e:	f04f 0300 	mov.w	r3, #0
    45a2:	617b      	str	r3, [r7, #20]
    45a4:	e00b      	b.n	45be <MSS_MAC_init+0x42>
	{
		ucMACBufferInUse[ a ] = pdFALSE;
    45a6:	697a      	ldr	r2, [r7, #20]
    45a8:	f642 7324 	movw	r3, #12068	; 0x2f24
    45ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    45b0:	f04f 0100 	mov.w	r1, #0
    45b4:	5499      	strb	r1, [r3, r2]
{
    const uint8_t mac_address[6] = { DEFAULT_MAC_ADDRESS };
    int32_t a;

	/* To start with all buffers are free. */
	for( a = 0; a < macNUM_BUFFERS; a++ )
    45b6:	697b      	ldr	r3, [r7, #20]
    45b8:	f103 0301 	add.w	r3, r3, #1
    45bc:	617b      	str	r3, [r7, #20]
    45be:	697b      	ldr	r3, [r7, #20]
    45c0:	2b06      	cmp	r3, #6
    45c2:	ddf0      	ble.n	45a6 <MSS_MAC_init+0x2a>
	{
		ucMACBufferInUse[ a ] = pdFALSE;
	}
	
    /* Try to reset chip */
    MAC_BITBAND->CSR0_SWR = 1u;
    45c4:	f240 0300 	movw	r3, #0
    45c8:	f2c4 2306 	movt	r3, #16902	; 0x4206
    45cc:	f04f 0201 	mov.w	r2, #1
    45d0:	601a      	str	r2, [r3, #0]

    do
    {
    	vTaskDelay( 10 );
    45d2:	f04f 000a 	mov.w	r0, #10
    45d6:	f00c fc03 	bl	10de0 <vTaskDelay>
    } while ( 1u == MAC_BITBAND->CSR0_SWR );
    45da:	f240 0300 	movw	r3, #0
    45de:	f2c4 2306 	movt	r3, #16902	; 0x4206
    45e2:	681b      	ldr	r3, [r3, #0]
    45e4:	2b01      	cmp	r3, #1
    45e6:	d0f4      	beq.n	45d2 <MSS_MAC_init+0x56>

    /* Check reset values of some registers to constrol
     * base address validity */
    configASSERT( MAC->CSR0 == 0xFE000000uL );
    45e8:	f243 0300 	movw	r3, #12288	; 0x3000
    45ec:	f2c4 0300 	movt	r3, #16384	; 0x4000
    45f0:	681b      	ldr	r3, [r3, #0]
    45f2:	f1b3 4f7e 	cmp.w	r3, #4261412864	; 0xfe000000
    45f6:	d009      	beq.n	460c <MSS_MAC_init+0x90>
    45f8:	f04f 0328 	mov.w	r3, #40	; 0x28
    45fc:	f383 8811 	msr	BASEPRI, r3
    4600:	f3bf 8f6f 	isb	sy
    4604:	f3bf 8f4f 	dsb	sy
    4608:	61bb      	str	r3, [r7, #24]
    460a:	e7fe      	b.n	460a <MSS_MAC_init+0x8e>
    configASSERT( MAC->CSR5 == 0xF0000000uL );
    460c:	f243 0300 	movw	r3, #12288	; 0x3000
    4610:	f2c4 0300 	movt	r3, #16384	; 0x4000
    4614:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4616:	f1b3 4f70 	cmp.w	r3, #4026531840	; 0xf0000000
    461a:	d009      	beq.n	4630 <MSS_MAC_init+0xb4>
    461c:	f04f 0328 	mov.w	r3, #40	; 0x28
    4620:	f383 8811 	msr	BASEPRI, r3
    4624:	f3bf 8f6f 	isb	sy
    4628:	f3bf 8f4f 	dsb	sy
    462c:	61fb      	str	r3, [r7, #28]
    462e:	e7fe      	b.n	462e <MSS_MAC_init+0xb2>
    configASSERT( MAC->CSR6 == 0x32000040uL );
    4630:	f243 0300 	movw	r3, #12288	; 0x3000
    4634:	f2c4 0300 	movt	r3, #16384	; 0x4000
    4638:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    463a:	f240 0340 	movw	r3, #64	; 0x40
    463e:	f2c3 2300 	movt	r3, #12800	; 0x3200
    4642:	429a      	cmp	r2, r3
    4644:	d009      	beq.n	465a <MSS_MAC_init+0xde>
    4646:	f04f 0328 	mov.w	r3, #40	; 0x28
    464a:	f383 8811 	msr	BASEPRI, r3
    464e:	f3bf 8f6f 	isb	sy
    4652:	f3bf 8f4f 	dsb	sy
    4656:	623b      	str	r3, [r7, #32]
    4658:	e7fe      	b.n	4658 <MSS_MAC_init+0xdc>

    /* Instance setup */
    MAC_memset_All( &g_mss_mac, 0u );
    465a:	f64a 20e0 	movw	r0, #43744	; 0xaae0
    465e:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4662:	f04f 0100 	mov.w	r1, #0
    4666:	f002 f857 	bl	6718 <MAC_memset_All>

    g_mss_mac.base_address = MAC_BASE;
    466a:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    466e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4672:	f243 0200 	movw	r2, #12288	; 0x3000
    4676:	f2c4 0200 	movt	r2, #16384	; 0x4000
    467a:	601a      	str	r2, [r3, #0]
    g_mss_mac.phy_address = phy_address;
    467c:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4680:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4684:	79fa      	ldrb	r2, [r7, #7]
    4686:	f883 20e8 	strb.w	r2, [r3, #232]	; 0xe8

    for( a=0; a<RX_RING_SIZE; a++ )
    468a:	f04f 0300 	mov.w	r3, #0
    468e:	617b      	str	r3, [r7, #20]
    4690:	e03b      	b.n	470a <MSS_MAC_init+0x18e>
    {
        /* Give the ownership to the MAC */
        g_mss_mac.rx_descriptors[a].descriptor_0 = RDES0_OWN;
    4692:	697a      	ldr	r2, [r7, #20]
    4694:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4698:	f2c2 0300 	movt	r3, #8192	; 0x2000
    469c:	ea4f 1202 	mov.w	r2, r2, lsl #4
    46a0:	4413      	add	r3, r2
    46a2:	f103 0398 	add.w	r3, r3, #152	; 0x98
    46a6:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    46aa:	601a      	str	r2, [r3, #0]
        g_mss_mac.rx_descriptors[a].descriptor_1 = (MSS_RX_BUFF_SIZE << RDES1_RBS1_OFFSET);
    46ac:	697a      	ldr	r2, [r7, #20]
    46ae:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    46b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    46b6:	ea4f 1202 	mov.w	r2, r2, lsl #4
    46ba:	4413      	add	r3, r2
    46bc:	f103 039c 	add.w	r3, r3, #156	; 0x9c
    46c0:	f44f 62be 	mov.w	r2, #1520	; 0x5f0
    46c4:	601a      	str	r2, [r3, #0]
		
		/* Allocate a buffer to the descriptor, then mark the buffer as in use
		(not free). */
        g_mss_mac.rx_descriptors[a].buffer_1 = ( unsigned long ) &( xMACBuffers.ucBuffer[ a ][ 0 ] );
    46c6:	6979      	ldr	r1, [r7, #20]
    46c8:	f240 6374 	movw	r3, #1652	; 0x674
    46cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    46d0:	697a      	ldr	r2, [r7, #20]
    46d2:	f44f 60ba 	mov.w	r0, #1488	; 0x5d0
    46d6:	fb00 f202 	mul.w	r2, r0, r2
    46da:	4413      	add	r3, r2
    46dc:	461a      	mov	r2, r3
    46de:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    46e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    46e6:	f101 010a 	add.w	r1, r1, #10
    46ea:	ea4f 1101 	mov.w	r1, r1, lsl #4
    46ee:	440b      	add	r3, r1
    46f0:	601a      	str	r2, [r3, #0]
		ucMACBufferInUse[ a ] = pdTRUE;
    46f2:	697a      	ldr	r2, [r7, #20]
    46f4:	f642 7324 	movw	r3, #12068	; 0x2f24
    46f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    46fc:	f04f 0101 	mov.w	r1, #1
    4700:	5499      	strb	r1, [r3, r2]
    MAC_memset_All( &g_mss_mac, 0u );

    g_mss_mac.base_address = MAC_BASE;
    g_mss_mac.phy_address = phy_address;

    for( a=0; a<RX_RING_SIZE; a++ )
    4702:	697b      	ldr	r3, [r7, #20]
    4704:	f103 0301 	add.w	r3, r3, #1
    4708:	617b      	str	r3, [r7, #20]
    470a:	697b      	ldr	r3, [r7, #20]
    470c:	2b04      	cmp	r3, #4
    470e:	ddc0      	ble.n	4692 <MSS_MAC_init+0x116>
		/* Allocate a buffer to the descriptor, then mark the buffer as in use
		(not free). */
        g_mss_mac.rx_descriptors[a].buffer_1 = ( unsigned long ) &( xMACBuffers.ucBuffer[ a ][ 0 ] );
		ucMACBufferInUse[ a ] = pdTRUE;
    }
    g_mss_mac.rx_descriptors[RX_RING_SIZE-1].descriptor_1 |= RDES1_RER;
    4710:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4714:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4718:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
    471c:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
    4720:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4724:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4728:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc

    for( a = 0; a < TX_RING_SIZE; a++ )
    472c:	f04f 0300 	mov.w	r3, #0
    4730:	617b      	str	r3, [r7, #20]
    4732:	e010      	b.n	4756 <MSS_MAC_init+0x1da>
    {
		/* Buffers only get allocated to the Tx buffers when something is
		actually tranmitted. */
        g_mss_mac.tx_descriptors[a].buffer_1 = ( unsigned long ) NULL;
    4734:	697a      	ldr	r2, [r7, #20]
    4736:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    473a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    473e:	ea4f 1202 	mov.w	r2, r2, lsl #4
    4742:	4413      	add	r3, r2
    4744:	f103 037c 	add.w	r3, r3, #124	; 0x7c
    4748:	f04f 0200 	mov.w	r2, #0
    474c:	601a      	str	r2, [r3, #0]
        g_mss_mac.rx_descriptors[a].buffer_1 = ( unsigned long ) &( xMACBuffers.ucBuffer[ a ][ 0 ] );
		ucMACBufferInUse[ a ] = pdTRUE;
    }
    g_mss_mac.rx_descriptors[RX_RING_SIZE-1].descriptor_1 |= RDES1_RER;

    for( a = 0; a < TX_RING_SIZE; a++ )
    474e:	697b      	ldr	r3, [r7, #20]
    4750:	f103 0301 	add.w	r3, r3, #1
    4754:	617b      	str	r3, [r7, #20]
    4756:	697b      	ldr	r3, [r7, #20]
    4758:	2b01      	cmp	r3, #1
    475a:	ddeb      	ble.n	4734 <MSS_MAC_init+0x1b8>
    {
		/* Buffers only get allocated to the Tx buffers when something is
		actually tranmitted. */
        g_mss_mac.tx_descriptors[a].buffer_1 = ( unsigned long ) NULL;
    }
    g_mss_mac.tx_descriptors[TX_RING_SIZE - 1].descriptor_1 |= TDES1_TER;
    475c:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4760:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4764:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    4768:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
    476c:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4770:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4774:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

    /* Configurable settings */
    MAC_BITBAND->CSR0_DBO = DESCRIPTOR_BYTE_ORDERING_MODE;
    4778:	f240 0300 	movw	r3, #0
    477c:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4780:	f04f 0200 	mov.w	r2, #0
    4784:	651a      	str	r2, [r3, #80]	; 0x50
    MAC->CSR0 = (MAC->CSR0 & ~CSR0_PBL_MASK) | ((uint32_t)PROGRAMMABLE_BURST_LENGTH << CSR0_PBL_SHIFT);
    4786:	f243 0300 	movw	r3, #12288	; 0x3000
    478a:	f2c4 0300 	movt	r3, #16384	; 0x4000
    478e:	f243 0200 	movw	r2, #12288	; 0x3000
    4792:	f2c4 0200 	movt	r2, #16384	; 0x4000
    4796:	6812      	ldr	r2, [r2, #0]
    4798:	f422 527c 	bic.w	r2, r2, #16128	; 0x3f00
    479c:	601a      	str	r2, [r3, #0]
    MAC_BITBAND->CSR0_BLE = BUFFER_BYTE_ORDERING_MODE;
    479e:	f240 0300 	movw	r3, #0
    47a2:	f2c4 2306 	movt	r3, #16902	; 0x4206
    47a6:	f04f 0200 	mov.w	r2, #0
    47aa:	61da      	str	r2, [r3, #28]
    MAC_BITBAND->CSR0_BAR = (uint32_t)BUS_ARBITRATION_SCHEME;
    47ac:	f240 0300 	movw	r3, #0
    47b0:	f2c4 2306 	movt	r3, #16902	; 0x4206
    47b4:	f04f 0200 	mov.w	r2, #0
    47b8:	605a      	str	r2, [r3, #4]

    /* Fixed settings */
    /* No space between descriptors */
    MAC->CSR0 = MAC->CSR0 &~ CSR0_DSL_MASK;
    47ba:	f243 0300 	movw	r3, #12288	; 0x3000
    47be:	f2c4 0300 	movt	r3, #16384	; 0x4000
    47c2:	f243 0200 	movw	r2, #12288	; 0x3000
    47c6:	f2c4 0200 	movt	r2, #16384	; 0x4000
    47ca:	6812      	ldr	r2, [r2, #0]
    47cc:	f022 027c 	bic.w	r2, r2, #124	; 0x7c
    47d0:	601a      	str	r2, [r3, #0]
    /* General-purpose timer works in continuous mode */
    MAC_BITBAND->CSR11_CON = 1u;
    47d2:	f240 0300 	movw	r3, #0
    47d6:	f2c4 2306 	movt	r3, #16902	; 0x4206
    47da:	f04f 0201 	mov.w	r2, #1
    47de:	f8c3 2b40 	str.w	r2, [r3, #2880]	; 0xb40
    /* Start general-purpose */
    MAC->CSR11 =  (MAC->CSR11 & ~CSR11_TIM_MASK) | (0x0000FFFFuL << CSR11_TIM_SHIFT);
    47e2:	f243 0300 	movw	r3, #12288	; 0x3000
    47e6:	f2c4 0300 	movt	r3, #16384	; 0x4000
    47ea:	f243 0200 	movw	r2, #12288	; 0x3000
    47ee:	f2c4 0200 	movt	r2, #16384	; 0x4000
    47f2:	6d92      	ldr	r2, [r2, #88]	; 0x58
    47f4:	ea6f 4212 	mvn.w	r2, r2, lsr #16
    47f8:	ea6f 4202 	mvn.w	r2, r2, lsl #16
    47fc:	659a      	str	r2, [r3, #88]	; 0x58

	/* Ensure promiscous mode is off (it should be by default anyway). */
	MAC_BITBAND->CSR6_PR = 0;
    47fe:	f240 0300 	movw	r3, #0
    4802:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4806:	f04f 0200 	mov.w	r2, #0
    480a:	f8c3 2618 	str.w	r2, [r3, #1560]	; 0x618
	
	/* Perfect filter. */
	MAC_BITBAND->CSR6_HP = 1;
    480e:	f240 0300 	movw	r3, #0
    4812:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4816:	f04f 0201 	mov.w	r2, #1
    481a:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
	
	/* Pass multcast. */
	MAC_BITBAND->CSR6_PM = 1;
    481e:	f240 0300 	movw	r3, #0
    4822:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4826:	f04f 0201 	mov.w	r2, #1
    482a:	f8c3 261c 	str.w	r2, [r3, #1564]	; 0x61c
	
    /* Set descriptors */
    MAC->CSR3 = (uint32_t)&(g_mss_mac.rx_descriptors[0].descriptor_0);
    482e:	f243 0300 	movw	r3, #12288	; 0x3000
    4832:	f2c4 0300 	movt	r3, #16384	; 0x4000
    4836:	4a24      	ldr	r2, [pc, #144]	; (48c8 <MSS_MAC_init+0x34c>)
    4838:	619a      	str	r2, [r3, #24]
    MAC->CSR4 = (uint32_t)&(g_mss_mac.tx_descriptors[0].descriptor_0);
    483a:	f243 0300 	movw	r3, #12288	; 0x3000
    483e:	f2c4 0300 	movt	r3, #16384	; 0x4000
    4842:	4a22      	ldr	r2, [pc, #136]	; (48cc <MSS_MAC_init+0x350>)
    4844:	621a      	str	r2, [r3, #32]

	/* enable normal interrupts */
    MAC_BITBAND->CSR7_NIE = 1u;
    4846:	f240 0300 	movw	r3, #0
    484a:	f2c4 2306 	movt	r3, #16902	; 0x4206
    484e:	f04f 0201 	mov.w	r2, #1
    4852:	f8c3 2740 	str.w	r2, [r3, #1856]	; 0x740

    /* Set default MAC address and reset mac filters */
   	MAC_memcpy( g_mss_mac.mac_address, mac_address, 6u );
    4856:	f107 030c 	add.w	r3, r7, #12
    485a:	481d      	ldr	r0, [pc, #116]	; (48d0 <MSS_MAC_init+0x354>)
    485c:	4619      	mov	r1, r3
    485e:	f04f 0206 	mov.w	r2, #6
    4862:	f002 f97d 	bl	6b60 <MAC_memcpy>
 	MSS_MAC_set_mac_address((uint8_t *)mac_address);
    4866:	f107 030c 	add.w	r3, r7, #12
    486a:	4618      	mov	r0, r3
    486c:	f000 fe66 	bl	553c <MSS_MAC_set_mac_address>
	
    /* Detect PHY */
    if( g_mss_mac.phy_address > MSS_PHY_ADDRESS_MAX )
    4870:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4874:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4878:	f893 30e8 	ldrb.w	r3, [r3, #232]	; 0xe8
    487c:	2b1f      	cmp	r3, #31
    487e:	d913      	bls.n	48a8 <MSS_MAC_init+0x32c>
    {
    	PHY_probe();
    4880:	f002 fbd2 	bl	7028 <PHY_probe>
    	configASSERT( g_mss_mac.phy_address <= MSS_PHY_ADDRESS_MAX );
    4884:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4888:	f2c2 0300 	movt	r3, #8192	; 0x2000
    488c:	f893 30e8 	ldrb.w	r3, [r3, #232]	; 0xe8
    4890:	2b1f      	cmp	r3, #31
    4892:	d909      	bls.n	48a8 <MSS_MAC_init+0x32c>
    4894:	f04f 0328 	mov.w	r3, #40	; 0x28
    4898:	f383 8811 	msr	BASEPRI, r3
    489c:	f3bf 8f6f 	isb	sy
    48a0:	f3bf 8f4f 	dsb	sy
    48a4:	627b      	str	r3, [r7, #36]	; 0x24
    48a6:	e7fe      	b.n	48a6 <MSS_MAC_init+0x32a>
    }

    /* Reset PHY */
    PHY_reset();
    48a8:	f002 fc00 	bl	70ac <PHY_reset>

	/* Configure chip according to PHY status */
    MSS_MAC_auto_setup_link();
    48ac:	f000 fdde 	bl	546c <MSS_MAC_auto_setup_link>
	
	/* Ensure uip_buf starts by pointing somewhere. */
	uip_buf = MAC_obtain_buffer();	
    48b0:	f002 f9b8 	bl	6c24 <MAC_obtain_buffer>
    48b4:	4602      	mov	r2, r0
    48b6:	f240 6370 	movw	r3, #1648	; 0x670
    48ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    48be:	601a      	str	r2, [r3, #0]
}
    48c0:	f107 0728 	add.w	r7, r7, #40	; 0x28
    48c4:	46bd      	mov	sp, r7
    48c6:	bd80      	pop	{r7, pc}
    48c8:	2000ab78 	.word	0x2000ab78
    48cc:	2000ab54 	.word	0x2000ab54
    48d0:	2000aae6 	.word	0x2000aae6

000048d4 <MSS_MAC_configure>:
void
MSS_MAC_configure
(
    uint32_t configuration
)
{
    48d4:	b580      	push	{r7, lr}
    48d6:	b086      	sub	sp, #24
    48d8:	af00      	add	r7, sp, #0
    48da:	6078      	str	r0, [r7, #4]
    int32_t ret;

    ret = MAC_stop_transmission();
    48dc:	f001 fd90 	bl	6400 <MAC_stop_transmission>
    48e0:	4603      	mov	r3, r0
    48e2:	60fb      	str	r3, [r7, #12]
    configASSERT( ret == MAC_OK );
    48e4:	68fb      	ldr	r3, [r7, #12]
    48e6:	2b00      	cmp	r3, #0
    48e8:	d009      	beq.n	48fe <MSS_MAC_configure+0x2a>
    48ea:	f04f 0328 	mov.w	r3, #40	; 0x28
    48ee:	f383 8811 	msr	BASEPRI, r3
    48f2:	f3bf 8f6f 	isb	sy
    48f6:	f3bf 8f4f 	dsb	sy
    48fa:	613b      	str	r3, [r7, #16]
    48fc:	e7fe      	b.n	48fc <MSS_MAC_configure+0x28>

    ret = MAC_stop_receiving();
    48fe:	f001 fdbd 	bl	647c <MAC_stop_receiving>
    4902:	4603      	mov	r3, r0
    4904:	60fb      	str	r3, [r7, #12]
    configASSERT( ret == MAC_OK );
    4906:	68fb      	ldr	r3, [r7, #12]
    4908:	2b00      	cmp	r3, #0
    490a:	d009      	beq.n	4920 <MSS_MAC_configure+0x4c>
    490c:	f04f 0328 	mov.w	r3, #40	; 0x28
    4910:	f383 8811 	msr	BASEPRI, r3
    4914:	f3bf 8f6f 	isb	sy
    4918:	f3bf 8f4f 	dsb	sy
    491c:	617b      	str	r3, [r7, #20]
    491e:	e7fe      	b.n	491e <MSS_MAC_configure+0x4a>

    MAC_BITBAND->CSR6_RA = (uint32_t)(((configuration & MSS_MAC_CFG_RECEIVE_ALL) != 0u) ? 1u : 0u );
    4920:	f240 0300 	movw	r3, #0
    4924:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4928:	687a      	ldr	r2, [r7, #4]
    492a:	f002 0201 	and.w	r2, r2, #1
    492e:	b2d2      	uxtb	r2, r2
    4930:	2a00      	cmp	r2, #0
    4932:	d002      	beq.n	493a <MSS_MAC_configure+0x66>
    4934:	f04f 0201 	mov.w	r2, #1
    4938:	e001      	b.n	493e <MSS_MAC_configure+0x6a>
    493a:	f04f 0200 	mov.w	r2, #0
    493e:	f8c3 2678 	str.w	r2, [r3, #1656]	; 0x678
    MAC_BITBAND->CSR6_TTM = (((configuration & MSS_MAC_CFG_TRANSMIT_THRESHOLD_MODE) != 0u) ? 1u : 0u );
    4942:	f240 0300 	movw	r3, #0
    4946:	f2c4 2306 	movt	r3, #16902	; 0x4206
    494a:	687a      	ldr	r2, [r7, #4]
    494c:	f002 0202 	and.w	r2, r2, #2
    4950:	2a00      	cmp	r2, #0
    4952:	d002      	beq.n	495a <MSS_MAC_configure+0x86>
    4954:	f04f 0201 	mov.w	r2, #1
    4958:	e001      	b.n	495e <MSS_MAC_configure+0x8a>
    495a:	f04f 0200 	mov.w	r2, #0
    495e:	f8c3 2658 	str.w	r2, [r3, #1624]	; 0x658
    MAC_BITBAND->CSR6_SF = (uint32_t)(((configuration & MSS_MAC_CFG_STORE_AND_FORWARD) != 0u) ? 1u : 0u );
    4962:	f240 0300 	movw	r3, #0
    4966:	f2c4 2306 	movt	r3, #16902	; 0x4206
    496a:	687a      	ldr	r2, [r7, #4]
    496c:	f002 0204 	and.w	r2, r2, #4
    4970:	2a00      	cmp	r2, #0
    4972:	d002      	beq.n	497a <MSS_MAC_configure+0xa6>
    4974:	f04f 0201 	mov.w	r2, #1
    4978:	e001      	b.n	497e <MSS_MAC_configure+0xaa>
    497a:	f04f 0200 	mov.w	r2, #0
    497e:	f8c3 2654 	str.w	r2, [r3, #1620]	; 0x654

    switch( configuration & MSS_MAC_CFG_THRESHOLD_CONTROL_11 ) {
    4982:	687b      	ldr	r3, [r7, #4]
    4984:	f003 0318 	and.w	r3, r3, #24
    4988:	2b18      	cmp	r3, #24
    498a:	d86c      	bhi.n	4a66 <MSS_MAC_configure+0x192>
    498c:	a201      	add	r2, pc, #4	; (adr r2, 4994 <MSS_MAC_configure+0xc0>)
    498e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    4992:	bf00      	nop
    4994:	000049f9 	.word	0x000049f9
    4998:	00004a67 	.word	0x00004a67
    499c:	00004a67 	.word	0x00004a67
    49a0:	00004a67 	.word	0x00004a67
    49a4:	00004a67 	.word	0x00004a67
    49a8:	00004a67 	.word	0x00004a67
    49ac:	00004a67 	.word	0x00004a67
    49b0:	00004a67 	.word	0x00004a67
    49b4:	00004a13 	.word	0x00004a13
    49b8:	00004a67 	.word	0x00004a67
    49bc:	00004a67 	.word	0x00004a67
    49c0:	00004a67 	.word	0x00004a67
    49c4:	00004a67 	.word	0x00004a67
    49c8:	00004a67 	.word	0x00004a67
    49cc:	00004a67 	.word	0x00004a67
    49d0:	00004a67 	.word	0x00004a67
    49d4:	00004a31 	.word	0x00004a31
    49d8:	00004a67 	.word	0x00004a67
    49dc:	00004a67 	.word	0x00004a67
    49e0:	00004a67 	.word	0x00004a67
    49e4:	00004a67 	.word	0x00004a67
    49e8:	00004a67 	.word	0x00004a67
    49ec:	00004a67 	.word	0x00004a67
    49f0:	00004a67 	.word	0x00004a67
    49f4:	00004a4f 	.word	0x00004a4f
    case MSS_MAC_CFG_THRESHOLD_CONTROL_00:
        MAC->CSR6 = MAC->CSR6 & ~CSR6_TR_MASK;
    49f8:	f243 0300 	movw	r3, #12288	; 0x3000
    49fc:	f2c4 0300 	movt	r3, #16384	; 0x4000
    4a00:	f243 0200 	movw	r2, #12288	; 0x3000
    4a04:	f2c4 0200 	movt	r2, #16384	; 0x4000
    4a08:	6b12      	ldr	r2, [r2, #48]	; 0x30
    4a0a:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
    4a0e:	631a      	str	r2, [r3, #48]	; 0x30
        break;
    4a10:	e029      	b.n	4a66 <MSS_MAC_configure+0x192>
    case MSS_MAC_CFG_THRESHOLD_CONTROL_01:
        MAC->CSR6 = (MAC->CSR6 & ~CSR6_TR_MASK) | ((uint32_t)1 << CSR6_TR_SHIFT );
    4a12:	f243 0300 	movw	r3, #12288	; 0x3000
    4a16:	f2c4 0300 	movt	r3, #16384	; 0x4000
    4a1a:	f243 0200 	movw	r2, #12288	; 0x3000
    4a1e:	f2c4 0200 	movt	r2, #16384	; 0x4000
    4a22:	6b12      	ldr	r2, [r2, #48]	; 0x30
    4a24:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
    4a28:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    4a2c:	631a      	str	r2, [r3, #48]	; 0x30
        break;
    4a2e:	e01a      	b.n	4a66 <MSS_MAC_configure+0x192>
    case MSS_MAC_CFG_THRESHOLD_CONTROL_10:
        MAC->CSR6 = (MAC->CSR6 & ~CSR6_TR_MASK) | ((uint32_t)2 << CSR6_TR_SHIFT );
    4a30:	f243 0300 	movw	r3, #12288	; 0x3000
    4a34:	f2c4 0300 	movt	r3, #16384	; 0x4000
    4a38:	f243 0200 	movw	r2, #12288	; 0x3000
    4a3c:	f2c4 0200 	movt	r2, #16384	; 0x4000
    4a40:	6b12      	ldr	r2, [r2, #48]	; 0x30
    4a42:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
    4a46:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    4a4a:	631a      	str	r2, [r3, #48]	; 0x30
        break;
    4a4c:	e00b      	b.n	4a66 <MSS_MAC_configure+0x192>
    case MSS_MAC_CFG_THRESHOLD_CONTROL_11:
        MAC->CSR6 = (MAC->CSR6 & ~CSR6_TR_MASK) | ((uint32_t)3 << CSR6_TR_SHIFT );
    4a4e:	f243 0300 	movw	r3, #12288	; 0x3000
    4a52:	f2c4 0300 	movt	r3, #16384	; 0x4000
    4a56:	f243 0200 	movw	r2, #12288	; 0x3000
    4a5a:	f2c4 0200 	movt	r2, #16384	; 0x4000
    4a5e:	6b12      	ldr	r2, [r2, #48]	; 0x30
    4a60:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
    4a64:	631a      	str	r2, [r3, #48]	; 0x30
        break;
    default:
        break;
    }
    MAC_BITBAND->CSR6_FD = (uint32_t)(((configuration & MSS_MAC_CFG_FULL_DUPLEX_MODE) != 0u) ? 1u : 0u );
    4a66:	f240 0300 	movw	r3, #0
    4a6a:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4a6e:	687a      	ldr	r2, [r7, #4]
    4a70:	f002 0220 	and.w	r2, r2, #32
    4a74:	2a00      	cmp	r2, #0
    4a76:	d002      	beq.n	4a7e <MSS_MAC_configure+0x1aa>
    4a78:	f04f 0201 	mov.w	r2, #1
    4a7c:	e001      	b.n	4a82 <MSS_MAC_configure+0x1ae>
    4a7e:	f04f 0200 	mov.w	r2, #0
    4a82:	f8c3 2624 	str.w	r2, [r3, #1572]	; 0x624
    MAC_BITBAND->CSR6_PM = (uint32_t)(((configuration & MSS_MAC_CFG_PASS_ALL_MULTICAST) != 0u) ? 1u : 0u );
    4a86:	f240 0300 	movw	r3, #0
    4a8a:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4a8e:	687a      	ldr	r2, [r7, #4]
    4a90:	f002 0240 	and.w	r2, r2, #64	; 0x40
    4a94:	2a00      	cmp	r2, #0
    4a96:	d002      	beq.n	4a9e <MSS_MAC_configure+0x1ca>
    4a98:	f04f 0201 	mov.w	r2, #1
    4a9c:	e001      	b.n	4aa2 <MSS_MAC_configure+0x1ce>
    4a9e:	f04f 0200 	mov.w	r2, #0
    4aa2:	f8c3 261c 	str.w	r2, [r3, #1564]	; 0x61c
    MAC_BITBAND->CSR6_PR = (uint32_t)(((configuration & MSS_MAC_CFG_PROMISCUOUS_MODE) != 0u) ? 1u : 0u );
    4aa6:	f240 0300 	movw	r3, #0
    4aaa:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4aae:	687a      	ldr	r2, [r7, #4]
    4ab0:	f002 0280 	and.w	r2, r2, #128	; 0x80
    4ab4:	2a00      	cmp	r2, #0
    4ab6:	d002      	beq.n	4abe <MSS_MAC_configure+0x1ea>
    4ab8:	f04f 0201 	mov.w	r2, #1
    4abc:	e001      	b.n	4ac2 <MSS_MAC_configure+0x1ee>
    4abe:	f04f 0200 	mov.w	r2, #0
    4ac2:	f8c3 2618 	str.w	r2, [r3, #1560]	; 0x618
    MAC_BITBAND->CSR6_PB = (uint32_t)(((configuration & MSS_MAC_CFG_PASS_BAD_FRAMES) != 0u) ? 1u : 0u );
    4ac6:	f240 0300 	movw	r3, #0
    4aca:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4ace:	687a      	ldr	r2, [r7, #4]
    4ad0:	f402 7200 	and.w	r2, r2, #512	; 0x200
    4ad4:	2a00      	cmp	r2, #0
    4ad6:	d002      	beq.n	4ade <MSS_MAC_configure+0x20a>
    4ad8:	f04f 0201 	mov.w	r2, #1
    4adc:	e001      	b.n	4ae2 <MSS_MAC_configure+0x20e>
    4ade:	f04f 0200 	mov.w	r2, #0
    4ae2:	f8c3 260c 	str.w	r2, [r3, #1548]	; 0x60c
    PHY_set_link_type( (uint8_t)
    4ae6:	687b      	ldr	r3, [r7, #4]
    4ae8:	b2db      	uxtb	r3, r3
    4aea:	f003 0302 	and.w	r3, r3, #2
        ((((configuration & MSS_MAC_CFG_TRANSMIT_THRESHOLD_MODE) != 0u) ? MSS_MAC_LINK_STATUS_100MB : 0u ) |
        (((configuration & MSS_MAC_CFG_FULL_DUPLEX_MODE) != 0u) ? MSS_MAC_LINK_STATUS_FDX : 0u )) );
    4aee:	687a      	ldr	r2, [r7, #4]
    4af0:	f002 0220 	and.w	r2, r2, #32
    }
    MAC_BITBAND->CSR6_FD = (uint32_t)(((configuration & MSS_MAC_CFG_FULL_DUPLEX_MODE) != 0u) ? 1u : 0u );
    MAC_BITBAND->CSR6_PM = (uint32_t)(((configuration & MSS_MAC_CFG_PASS_ALL_MULTICAST) != 0u) ? 1u : 0u );
    MAC_BITBAND->CSR6_PR = (uint32_t)(((configuration & MSS_MAC_CFG_PROMISCUOUS_MODE) != 0u) ? 1u : 0u );
    MAC_BITBAND->CSR6_PB = (uint32_t)(((configuration & MSS_MAC_CFG_PASS_BAD_FRAMES) != 0u) ? 1u : 0u );
    PHY_set_link_type( (uint8_t)
    4af4:	2a00      	cmp	r2, #0
    4af6:	d002      	beq.n	4afe <MSS_MAC_configure+0x22a>
    4af8:	f04f 0204 	mov.w	r2, #4
    4afc:	e001      	b.n	4b02 <MSS_MAC_configure+0x22e>
    4afe:	f04f 0200 	mov.w	r2, #0
    4b02:	ea43 0302 	orr.w	r3, r3, r2
    4b06:	b2db      	uxtb	r3, r3
    4b08:	4618      	mov	r0, r3
    4b0a:	f002 fb43 	bl	7194 <PHY_set_link_type>
        ((((configuration & MSS_MAC_CFG_TRANSMIT_THRESHOLD_MODE) != 0u) ? MSS_MAC_LINK_STATUS_100MB : 0u ) |
        (((configuration & MSS_MAC_CFG_FULL_DUPLEX_MODE) != 0u) ? MSS_MAC_LINK_STATUS_FDX : 0u )) );

    MSS_MAC_auto_setup_link();
    4b0e:	f000 fcad 	bl	546c <MSS_MAC_auto_setup_link>
}
    4b12:	f107 0718 	add.w	r7, r7, #24
    4b16:	46bd      	mov	sp, r7
    4b18:	bd80      	pop	{r7, pc}
    4b1a:	bf00      	nop

00004b1c <MSS_MAC_get_configuration>:
 *    - #MSS_MAC_CFG_HASH_PERFECT_RECEIVE_FILTERING_MODE
 * @see   MAC_configure()
 */
int32_t
MSS_MAC_get_configuration( void )
{
    4b1c:	b480      	push	{r7}
    4b1e:	b083      	sub	sp, #12
    4b20:	af00      	add	r7, sp, #0
    uint32_t configuration;

    configuration = 0u;
    4b22:	f04f 0300 	mov.w	r3, #0
    4b26:	607b      	str	r3, [r7, #4]
    if( MAC_BITBAND->CSR6_RA != 0u ) {
    4b28:	f240 0300 	movw	r3, #0
    4b2c:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4b30:	f8d3 3678 	ldr.w	r3, [r3, #1656]	; 0x678
    4b34:	2b00      	cmp	r3, #0
    4b36:	d003      	beq.n	4b40 <MSS_MAC_get_configuration+0x24>
        configuration |= MSS_MAC_CFG_RECEIVE_ALL;
    4b38:	687b      	ldr	r3, [r7, #4]
    4b3a:	f043 0301 	orr.w	r3, r3, #1
    4b3e:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_TTM != 0u ) {
    4b40:	f240 0300 	movw	r3, #0
    4b44:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4b48:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
    4b4c:	2b00      	cmp	r3, #0
    4b4e:	d003      	beq.n	4b58 <MSS_MAC_get_configuration+0x3c>
        configuration |= MSS_MAC_CFG_TRANSMIT_THRESHOLD_MODE;
    4b50:	687b      	ldr	r3, [r7, #4]
    4b52:	f043 0302 	orr.w	r3, r3, #2
    4b56:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_SF != 0u ) {
    4b58:	f240 0300 	movw	r3, #0
    4b5c:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4b60:	f8d3 3654 	ldr.w	r3, [r3, #1620]	; 0x654
    4b64:	2b00      	cmp	r3, #0
    4b66:	d003      	beq.n	4b70 <MSS_MAC_get_configuration+0x54>
        configuration |= MSS_MAC_CFG_STORE_AND_FORWARD;
    4b68:	687b      	ldr	r3, [r7, #4]
    4b6a:	f043 0304 	orr.w	r3, r3, #4
    4b6e:	607b      	str	r3, [r7, #4]
    }

    switch( (MAC->CSR6 & CSR6_TR_MASK) >> CSR6_TR_SHIFT ) {
    4b70:	f243 0300 	movw	r3, #12288	; 0x3000
    4b74:	f2c4 0300 	movt	r3, #16384	; 0x4000
    4b78:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    4b7a:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
    4b7e:	ea4f 3393 	mov.w	r3, r3, lsr #14
    4b82:	2b02      	cmp	r3, #2
    4b84:	d008      	beq.n	4b98 <MSS_MAC_get_configuration+0x7c>
    4b86:	2b03      	cmp	r3, #3
    4b88:	d00b      	beq.n	4ba2 <MSS_MAC_get_configuration+0x86>
    4b8a:	2b01      	cmp	r3, #1
    4b8c:	d10d      	bne.n	4baa <MSS_MAC_get_configuration+0x8e>
    case 1: configuration |= MSS_MAC_CFG_THRESHOLD_CONTROL_01; break;
    4b8e:	687b      	ldr	r3, [r7, #4]
    4b90:	f043 0308 	orr.w	r3, r3, #8
    4b94:	607b      	str	r3, [r7, #4]
    4b96:	e008      	b.n	4baa <MSS_MAC_get_configuration+0x8e>
    case 2: configuration |= MSS_MAC_CFG_THRESHOLD_CONTROL_10; break;
    4b98:	687b      	ldr	r3, [r7, #4]
    4b9a:	f043 0310 	orr.w	r3, r3, #16
    4b9e:	607b      	str	r3, [r7, #4]
    4ba0:	e003      	b.n	4baa <MSS_MAC_get_configuration+0x8e>
    case 3: configuration |= MSS_MAC_CFG_THRESHOLD_CONTROL_11; break;
    4ba2:	687b      	ldr	r3, [r7, #4]
    4ba4:	f043 0318 	orr.w	r3, r3, #24
    4ba8:	607b      	str	r3, [r7, #4]
    default: break;
    }
    if( MAC_BITBAND->CSR6_FD != 0u ) {
    4baa:	f240 0300 	movw	r3, #0
    4bae:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4bb2:	f8d3 3624 	ldr.w	r3, [r3, #1572]	; 0x624
    4bb6:	2b00      	cmp	r3, #0
    4bb8:	d003      	beq.n	4bc2 <MSS_MAC_get_configuration+0xa6>
        configuration |= MSS_MAC_CFG_FULL_DUPLEX_MODE;
    4bba:	687b      	ldr	r3, [r7, #4]
    4bbc:	f043 0320 	orr.w	r3, r3, #32
    4bc0:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_PM != 0u ) {
    4bc2:	f240 0300 	movw	r3, #0
    4bc6:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4bca:	f8d3 361c 	ldr.w	r3, [r3, #1564]	; 0x61c
    4bce:	2b00      	cmp	r3, #0
    4bd0:	d003      	beq.n	4bda <MSS_MAC_get_configuration+0xbe>
        configuration |= MSS_MAC_CFG_PASS_ALL_MULTICAST;
    4bd2:	687b      	ldr	r3, [r7, #4]
    4bd4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    4bd8:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_PR != 0u ) {
    4bda:	f240 0300 	movw	r3, #0
    4bde:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4be2:	f8d3 3618 	ldr.w	r3, [r3, #1560]	; 0x618
    4be6:	2b00      	cmp	r3, #0
    4be8:	d003      	beq.n	4bf2 <MSS_MAC_get_configuration+0xd6>
        configuration |= MSS_MAC_CFG_PROMISCUOUS_MODE;
    4bea:	687b      	ldr	r3, [r7, #4]
    4bec:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    4bf0:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_IF != 0u ) {
    4bf2:	f240 0300 	movw	r3, #0
    4bf6:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4bfa:	f8d3 3610 	ldr.w	r3, [r3, #1552]	; 0x610
    4bfe:	2b00      	cmp	r3, #0
    4c00:	d003      	beq.n	4c0a <MSS_MAC_get_configuration+0xee>
        configuration |= MSS_MAC_CFG_INVERSE_FILTERING;
    4c02:	687b      	ldr	r3, [r7, #4]
    4c04:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    4c08:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_PB != 0u ) {
    4c0a:	f240 0300 	movw	r3, #0
    4c0e:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4c12:	f8d3 360c 	ldr.w	r3, [r3, #1548]	; 0x60c
    4c16:	2b00      	cmp	r3, #0
    4c18:	d003      	beq.n	4c22 <MSS_MAC_get_configuration+0x106>
        configuration |= MSS_MAC_CFG_PASS_BAD_FRAMES;
    4c1a:	687b      	ldr	r3, [r7, #4]
    4c1c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    4c20:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_HO != 0u ) {
    4c22:	f240 0300 	movw	r3, #0
    4c26:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4c2a:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    4c2e:	2b00      	cmp	r3, #0
    4c30:	d003      	beq.n	4c3a <MSS_MAC_get_configuration+0x11e>
        configuration |= MSS_MAC_CFG_HASH_ONLY_FILTERING_MODE;
    4c32:	687b      	ldr	r3, [r7, #4]
    4c34:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    4c38:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_HP != 0u ) {
    4c3a:	f240 0300 	movw	r3, #0
    4c3e:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4c42:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4c46:	2b00      	cmp	r3, #0
    4c48:	d003      	beq.n	4c52 <MSS_MAC_get_configuration+0x136>
        configuration |= MSS_MAC_CFG_HASH_PERFECT_RECEIVE_FILTERING_MODE;
    4c4a:	687b      	ldr	r3, [r7, #4]
    4c4c:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
    4c50:	607b      	str	r3, [r7, #4]
    }

    return (int32_t)configuration;
    4c52:	687b      	ldr	r3, [r7, #4]
}
    4c54:	4618      	mov	r0, r3
    4c56:	f107 070c 	add.w	r7, r7, #12
    4c5a:	46bd      	mov	sp, r7
    4c5c:	bc80      	pop	{r7}
    4c5e:	4770      	bx	lr

00004c60 <MSS_MAC_tx_packet>:
int32_t
MSS_MAC_tx_packet
(
    unsigned short usLength
)
{
    4c60:	b580      	push	{r7, lr}
    4c62:	b08a      	sub	sp, #40	; 0x28
    4c64:	af00      	add	r7, sp, #0
    4c66:	4603      	mov	r3, r0
    4c68:	80fb      	strh	r3, [r7, #6]
	uint32_t desc;
	unsigned long ulDescriptor;
    int32_t error = MAC_OK;
    4c6a:	f04f 0300 	mov.w	r3, #0
    4c6e:	617b      	str	r3, [r7, #20]

    configASSERT( uip_buf != NULL_buffer );
    4c70:	f240 6370 	movw	r3, #1648	; 0x670
    4c74:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4c78:	681a      	ldr	r2, [r3, #0]
    4c7a:	f240 6368 	movw	r3, #1640	; 0x668
    4c7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4c82:	681b      	ldr	r3, [r3, #0]
    4c84:	429a      	cmp	r2, r3
    4c86:	d109      	bne.n	4c9c <MSS_MAC_tx_packet+0x3c>
    4c88:	f04f 0328 	mov.w	r3, #40	; 0x28
    4c8c:	f383 8811 	msr	BASEPRI, r3
    4c90:	f3bf 8f6f 	isb	sy
    4c94:	f3bf 8f4f 	dsb	sy
    4c98:	61bb      	str	r3, [r7, #24]
    4c9a:	e7fe      	b.n	4c9a <MSS_MAC_tx_packet+0x3a>

	configASSERT( usLength >= 12 );
    4c9c:	88fb      	ldrh	r3, [r7, #6]
    4c9e:	2b0b      	cmp	r3, #11
    4ca0:	d809      	bhi.n	4cb6 <MSS_MAC_tx_packet+0x56>
    4ca2:	f04f 0328 	mov.w	r3, #40	; 0x28
    4ca6:	f383 8811 	msr	BASEPRI, r3
    4caa:	f3bf 8f6f 	isb	sy
    4cae:	f3bf 8f4f 	dsb	sy
    4cb2:	61fb      	str	r3, [r7, #28]
    4cb4:	e7fe      	b.n	4cb4 <MSS_MAC_tx_packet+0x54>

    if( (g_mss_mac.flags & FLAG_EXCEED_LIMIT) == 0u )
    4cb6:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4cba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4cbe:	791b      	ldrb	r3, [r3, #4]
    4cc0:	f003 0308 	and.w	r3, r3, #8
    4cc4:	2b00      	cmp	r3, #0
    4cc6:	d10e      	bne.n	4ce6 <MSS_MAC_tx_packet+0x86>
    {
		configASSERT( usLength <= MSS_MAX_PACKET_SIZE );
    4cc8:	88fa      	ldrh	r2, [r7, #6]
    4cca:	f240 53ea 	movw	r3, #1514	; 0x5ea
    4cce:	429a      	cmp	r2, r3
    4cd0:	d909      	bls.n	4ce6 <MSS_MAC_tx_packet+0x86>
    4cd2:	f04f 0328 	mov.w	r3, #40	; 0x28
    4cd6:	f383 8811 	msr	BASEPRI, r3
    4cda:	f3bf 8f6f 	isb	sy
    4cde:	f3bf 8f4f 	dsb	sy
    4ce2:	623b      	str	r3, [r7, #32]
    4ce4:	e7fe      	b.n	4ce4 <MSS_MAC_tx_packet+0x84>
	}

	taskENTER_CRITICAL();
    4ce6:	f00f fb77 	bl	143d8 <vPortEnterCritical>
	{
		/* Check both Tx descriptors are free, meaning the double send has completed. */
		if( ( ( (g_mss_mac.tx_descriptors[ 0 ].descriptor_0) & TDES0_OWN) == TDES0_OWN ) || ( ( (g_mss_mac.tx_descriptors[ 1 ].descriptor_0) & TDES0_OWN) == TDES0_OWN ) )
    4cea:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4cee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4cf2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    4cf4:	2b00      	cmp	r3, #0
    4cf6:	db07      	blt.n	4d08 <MSS_MAC_tx_packet+0xa8>
    4cf8:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4cfc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4d00:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
    4d04:	2b00      	cmp	r3, #0
    4d06:	da02      	bge.n	4d0e <MSS_MAC_tx_packet+0xae>
		{
			error = MAC_BUFFER_IS_FULL;
    4d08:	f06f 0303 	mvn.w	r3, #3
    4d0c:	617b      	str	r3, [r7, #20]
		}
	}
	taskEXIT_CRITICAL();
    4d0e:	f00f fb9b 	bl	14448 <vPortExitCritical>

	configASSERT( ( g_mss_mac.tx_desc_index == 0 ) );
    4d12:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4d16:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4d1a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    4d1c:	2b00      	cmp	r3, #0
    4d1e:	d009      	beq.n	4d34 <MSS_MAC_tx_packet+0xd4>
    4d20:	f04f 0328 	mov.w	r3, #40	; 0x28
    4d24:	f383 8811 	msr	BASEPRI, r3
    4d28:	f3bf 8f6f 	isb	sy
    4d2c:	f3bf 8f4f 	dsb	sy
    4d30:	627b      	str	r3, [r7, #36]	; 0x24
    4d32:	e7fe      	b.n	4d32 <MSS_MAC_tx_packet+0xd2>
	
	if( error == MAC_OK )
    4d34:	697b      	ldr	r3, [r7, #20]
    4d36:	2b00      	cmp	r3, #0
    4d38:	f040 820d 	bne.w	5156 <MSS_MAC_tx_packet+0x4f6>
	{
		/* Ensure nothing is going to get sent until both descriptors are ready.
		This is done to	prevent a Tx end occurring prior to the second descriptor
		being ready. */
		MAC_BITBAND->CSR6_ST = 0u;
    4d3c:	f240 0300 	movw	r3, #0
    4d40:	f2c4 2306 	movt	r3, #16902	; 0x4206
    4d44:	f04f 0200 	mov.w	r2, #0
    4d48:	f8c3 2634 	str.w	r2, [r3, #1588]	; 0x634

		/* Assumed TX_RING_SIZE == 2.  A #error directive checks this is the
		case. */
		taskENTER_CRITICAL();
    4d4c:	f00f fb44 	bl	143d8 <vPortEnterCritical>
		{
			for( ulDescriptor = 0; ulDescriptor < TX_RING_SIZE; ulDescriptor++ )
    4d50:	f04f 0300 	mov.w	r3, #0
    4d54:	613b      	str	r3, [r7, #16]
    4d56:	e1f8      	b.n	514a <MSS_MAC_tx_packet+0x4ea>
			{
				g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_1 = 0u;
    4d58:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4d5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4d60:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    4d62:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4d66:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4d6a:	f102 0207 	add.w	r2, r2, #7
    4d6e:	ea4f 1202 	mov.w	r2, r2, lsl #4
    4d72:	4413      	add	r3, r2
    4d74:	f103 0308 	add.w	r3, r3, #8
    4d78:	f04f 0200 	mov.w	r2, #0
    4d7c:	601a      	str	r2, [r3, #0]
	
				if( (g_mss_mac.flags & FLAG_CRC_DISABLE) != 0u ) {
    4d7e:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4d82:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4d86:	791b      	ldrb	r3, [r3, #4]
    4d88:	f003 0304 	and.w	r3, r3, #4
    4d8c:	2b00      	cmp	r3, #0
    4d8e:	d023      	beq.n	4dd8 <MSS_MAC_tx_packet+0x178>
					g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_1 |= TDES1_AC;
    4d90:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4d94:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4d98:	6f19      	ldr	r1, [r3, #112]	; 0x70
    4d9a:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4d9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4da2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    4da4:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4da8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4dac:	f102 0207 	add.w	r2, r2, #7
    4db0:	ea4f 1202 	mov.w	r2, r2, lsl #4
    4db4:	4413      	add	r3, r2
    4db6:	f103 0308 	add.w	r3, r3, #8
    4dba:	681b      	ldr	r3, [r3, #0]
    4dbc:	f043 6280 	orr.w	r2, r3, #67108864	; 0x4000000
    4dc0:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4dc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4dc8:	f101 0107 	add.w	r1, r1, #7
    4dcc:	ea4f 1101 	mov.w	r1, r1, lsl #4
    4dd0:	440b      	add	r3, r1
    4dd2:	f103 0308 	add.w	r3, r3, #8
    4dd6:	601a      	str	r2, [r3, #0]
				}
	
				/* Every buffer can hold a full frame so they are always first and last
				   descriptor */
				g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_1 |= TDES1_LS | TDES1_FS;
    4dd8:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4ddc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4de0:	6f19      	ldr	r1, [r3, #112]	; 0x70
    4de2:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4de6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4dea:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    4dec:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4df0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4df4:	f102 0207 	add.w	r2, r2, #7
    4df8:	ea4f 1202 	mov.w	r2, r2, lsl #4
    4dfc:	4413      	add	r3, r2
    4dfe:	f103 0308 	add.w	r3, r3, #8
    4e02:	681b      	ldr	r3, [r3, #0]
    4e04:	f043 42c0 	orr.w	r2, r3, #1610612736	; 0x60000000
    4e08:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4e0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4e10:	f101 0107 	add.w	r1, r1, #7
    4e14:	ea4f 1101 	mov.w	r1, r1, lsl #4
    4e18:	440b      	add	r3, r1
    4e1a:	f103 0308 	add.w	r3, r3, #8
    4e1e:	601a      	str	r2, [r3, #0]
	
				/* set data size */
				g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_1 |= usLength;
    4e20:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4e24:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4e28:	6f19      	ldr	r1, [r3, #112]	; 0x70
    4e2a:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4e2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4e32:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    4e34:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4e38:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4e3c:	f102 0207 	add.w	r2, r2, #7
    4e40:	ea4f 1202 	mov.w	r2, r2, lsl #4
    4e44:	4413      	add	r3, r2
    4e46:	f103 0308 	add.w	r3, r3, #8
    4e4a:	681a      	ldr	r2, [r3, #0]
    4e4c:	88fb      	ldrh	r3, [r7, #6]
    4e4e:	ea42 0203 	orr.w	r2, r2, r3
    4e52:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4e56:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4e5a:	f101 0107 	add.w	r1, r1, #7
    4e5e:	ea4f 1101 	mov.w	r1, r1, lsl #4
    4e62:	440b      	add	r3, r1
    4e64:	f103 0308 	add.w	r3, r3, #8
    4e68:	601a      	str	r2, [r3, #0]
	
				/* reset end of ring */
				g_mss_mac.tx_descriptors[TX_RING_SIZE-1].descriptor_1 |= TDES1_TER;
    4e6a:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4e6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4e72:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    4e76:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
    4e7a:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4e7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4e82:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	
				if( usLength > MSS_TX_BUFF_SIZE ) /* FLAG_EXCEED_LIMIT */
    4e86:	88fa      	ldrh	r2, [r7, #6]
    4e88:	f240 53ec 	movw	r3, #1516	; 0x5ec
    4e8c:	429a      	cmp	r2, r3
    4e8e:	d902      	bls.n	4e96 <MSS_MAC_tx_packet+0x236>
				{
					usLength = (uint16_t)MSS_TX_BUFF_SIZE;
    4e90:	f240 53ec 	movw	r3, #1516	; 0x5ec
    4e94:	80fb      	strh	r3, [r7, #6]
				}
	
				/* The data buffer is assigned to the Tx descriptor. */
				g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].buffer_1 = ( unsigned long ) uip_buf;
    4e96:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4e9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4e9e:	6f19      	ldr	r1, [r3, #112]	; 0x70
    4ea0:	f240 6370 	movw	r3, #1648	; 0x670
    4ea4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4ea8:	681b      	ldr	r3, [r3, #0]
    4eaa:	461a      	mov	r2, r3
    4eac:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4eb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4eb4:	ea4f 1101 	mov.w	r1, r1, lsl #4
    4eb8:	440b      	add	r3, r1
    4eba:	f103 037c 	add.w	r3, r3, #124	; 0x7c
    4ebe:	601a      	str	r2, [r3, #0]
	
				/* update counters */
				desc = g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_0;
    4ec0:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4ec4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4ec8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    4eca:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4ece:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4ed2:	f102 0207 	add.w	r2, r2, #7
    4ed6:	ea4f 1202 	mov.w	r2, r2, lsl #4
    4eda:	4413      	add	r3, r2
    4edc:	f103 0304 	add.w	r3, r3, #4
    4ee0:	681b      	ldr	r3, [r3, #0]
    4ee2:	60fb      	str	r3, [r7, #12]
				if( (desc & TDES0_LO) != 0u ) {
    4ee4:	68fb      	ldr	r3, [r7, #12]
    4ee6:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    4eea:	2b00      	cmp	r3, #0
    4eec:	d027      	beq.n	4f3e <MSS_MAC_tx_packet+0x2de>
					g_mss_mac.statistics.tx_loss_of_carrier++;
    4eee:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4ef2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4ef6:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    4efa:	ea4f 2212 	mov.w	r2, r2, lsr #8
    4efe:	f893 311c 	ldrb.w	r3, [r3, #284]	; 0x11c
    4f02:	ea4f 6303 	mov.w	r3, r3, lsl #24
    4f06:	ea43 0302 	orr.w	r3, r3, r2
    4f0a:	f103 0201 	add.w	r2, r3, #1
    4f0e:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4f12:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4f16:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    4f1a:	ea4f 2101 	mov.w	r1, r1, lsl #8
    4f1e:	f8d3 0118 	ldr.w	r0, [r3, #280]	; 0x118
    4f22:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    4f26:	ea40 0101 	orr.w	r1, r0, r1
    4f2a:	f8c3 1118 	str.w	r1, [r3, #280]	; 0x118
    4f2e:	ea4f 6212 	mov.w	r2, r2, lsr #24
    4f32:	f04f 0100 	mov.w	r1, #0
    4f36:	ea41 0202 	orr.w	r2, r1, r2
    4f3a:	f883 211c 	strb.w	r2, [r3, #284]	; 0x11c
				}
				if( (desc & TDES0_NC) != 0u ) {
    4f3e:	68fb      	ldr	r3, [r7, #12]
    4f40:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    4f44:	2b00      	cmp	r3, #0
    4f46:	d027      	beq.n	4f98 <MSS_MAC_tx_packet+0x338>
					g_mss_mac.statistics.tx_no_carrier++;
    4f48:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4f4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4f50:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
    4f54:	ea4f 2212 	mov.w	r2, r2, lsr #8
    4f58:	f893 3120 	ldrb.w	r3, [r3, #288]	; 0x120
    4f5c:	ea4f 6303 	mov.w	r3, r3, lsl #24
    4f60:	ea43 0302 	orr.w	r3, r3, r2
    4f64:	f103 0201 	add.w	r2, r3, #1
    4f68:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4f6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4f70:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    4f74:	ea4f 2101 	mov.w	r1, r1, lsl #8
    4f78:	f8d3 011c 	ldr.w	r0, [r3, #284]	; 0x11c
    4f7c:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    4f80:	ea40 0101 	orr.w	r1, r0, r1
    4f84:	f8c3 111c 	str.w	r1, [r3, #284]	; 0x11c
    4f88:	ea4f 6212 	mov.w	r2, r2, lsr #24
    4f8c:	f04f 0100 	mov.w	r1, #0
    4f90:	ea41 0202 	orr.w	r2, r1, r2
    4f94:	f883 2120 	strb.w	r2, [r3, #288]	; 0x120
				}
				if( (desc & TDES0_LC) != 0u ) {
    4f98:	68fb      	ldr	r3, [r7, #12]
    4f9a:	f403 7300 	and.w	r3, r3, #512	; 0x200
    4f9e:	2b00      	cmp	r3, #0
    4fa0:	d027      	beq.n	4ff2 <MSS_MAC_tx_packet+0x392>
					g_mss_mac.statistics.tx_late_collision++;
    4fa2:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4fa6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4faa:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    4fae:	ea4f 2212 	mov.w	r2, r2, lsr #8
    4fb2:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
    4fb6:	ea4f 6303 	mov.w	r3, r3, lsl #24
    4fba:	ea43 0302 	orr.w	r3, r3, r2
    4fbe:	f103 0201 	add.w	r2, r3, #1
    4fc2:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    4fc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4fca:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    4fce:	ea4f 2101 	mov.w	r1, r1, lsl #8
    4fd2:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
    4fd6:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    4fda:	ea40 0101 	orr.w	r1, r0, r1
    4fde:	f8c3 1120 	str.w	r1, [r3, #288]	; 0x120
    4fe2:	ea4f 6212 	mov.w	r2, r2, lsr #24
    4fe6:	f04f 0100 	mov.w	r1, #0
    4fea:	ea41 0202 	orr.w	r2, r1, r2
    4fee:	f883 2124 	strb.w	r2, [r3, #292]	; 0x124
				}
				if( (desc & TDES0_EC) != 0u ) {
    4ff2:	68fb      	ldr	r3, [r7, #12]
    4ff4:	f403 7380 	and.w	r3, r3, #256	; 0x100
    4ff8:	2b00      	cmp	r3, #0
    4ffa:	d027      	beq.n	504c <MSS_MAC_tx_packet+0x3ec>
					g_mss_mac.statistics.tx_excessive_collision++;
    4ffc:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5000:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5004:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    5008:	ea4f 2212 	mov.w	r2, r2, lsr #8
    500c:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
    5010:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5014:	ea43 0302 	orr.w	r3, r3, r2
    5018:	f103 0201 	add.w	r2, r3, #1
    501c:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5020:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5024:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    5028:	ea4f 2101 	mov.w	r1, r1, lsl #8
    502c:	f8d3 0124 	ldr.w	r0, [r3, #292]	; 0x124
    5030:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    5034:	ea40 0101 	orr.w	r1, r0, r1
    5038:	f8c3 1124 	str.w	r1, [r3, #292]	; 0x124
    503c:	ea4f 6212 	mov.w	r2, r2, lsr #24
    5040:	f04f 0100 	mov.w	r1, #0
    5044:	ea41 0202 	orr.w	r2, r1, r2
    5048:	f883 2128 	strb.w	r2, [r3, #296]	; 0x128
				}
				if( (desc & TDES0_UF) != 0u ) {
    504c:	68fb      	ldr	r3, [r7, #12]
    504e:	f003 0302 	and.w	r3, r3, #2
    5052:	2b00      	cmp	r3, #0
    5054:	d027      	beq.n	50a6 <MSS_MAC_tx_packet+0x446>
					g_mss_mac.statistics.tx_underflow_error++;
    5056:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    505a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    505e:	f8d3 212c 	ldr.w	r2, [r3, #300]	; 0x12c
    5062:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5066:	f893 3130 	ldrb.w	r3, [r3, #304]	; 0x130
    506a:	ea4f 6303 	mov.w	r3, r3, lsl #24
    506e:	ea43 0302 	orr.w	r3, r3, r2
    5072:	f103 0201 	add.w	r2, r3, #1
    5076:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    507a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    507e:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    5082:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5086:	f8d3 012c 	ldr.w	r0, [r3, #300]	; 0x12c
    508a:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    508e:	ea40 0101 	orr.w	r1, r0, r1
    5092:	f8c3 112c 	str.w	r1, [r3, #300]	; 0x12c
    5096:	ea4f 6212 	mov.w	r2, r2, lsr #24
    509a:	f04f 0100 	mov.w	r1, #0
    509e:	ea41 0202 	orr.w	r2, r1, r2
    50a2:	f883 2130 	strb.w	r2, [r3, #304]	; 0x130
				}
				g_mss_mac.statistics.tx_collision_count +=
    50a6:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    50aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    50ae:	f8d3 2128 	ldr.w	r2, [r3, #296]	; 0x128
    50b2:	ea4f 2212 	mov.w	r2, r2, lsr #8
    50b6:	f893 312c 	ldrb.w	r3, [r3, #300]	; 0x12c
    50ba:	ea4f 6303 	mov.w	r3, r3, lsl #24
    50be:	ea43 0302 	orr.w	r3, r3, r2
    50c2:	461a      	mov	r2, r3
					(desc >> TDES0_CC_OFFSET) & TDES0_CC_MASK;
    50c4:	68fb      	ldr	r3, [r7, #12]
    50c6:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    50ca:	f003 030f 	and.w	r3, r3, #15
					g_mss_mac.statistics.tx_excessive_collision++;
				}
				if( (desc & TDES0_UF) != 0u ) {
					g_mss_mac.statistics.tx_underflow_error++;
				}
				g_mss_mac.statistics.tx_collision_count +=
    50ce:	441a      	add	r2, r3
    50d0:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    50d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    50d8:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    50dc:	ea4f 2101 	mov.w	r1, r1, lsl #8
    50e0:	f8d3 0128 	ldr.w	r0, [r3, #296]	; 0x128
    50e4:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    50e8:	ea40 0101 	orr.w	r1, r0, r1
    50ec:	f8c3 1128 	str.w	r1, [r3, #296]	; 0x128
    50f0:	ea4f 6212 	mov.w	r2, r2, lsr #24
    50f4:	f04f 0100 	mov.w	r1, #0
    50f8:	ea41 0202 	orr.w	r2, r1, r2
    50fc:	f883 212c 	strb.w	r2, [r3, #300]	; 0x12c
					(desc >> TDES0_CC_OFFSET) & TDES0_CC_MASK;
	
				/* Give ownership of descriptor to the MAC */
				g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_0 = TDES0_OWN;
    5100:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5104:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5108:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    510a:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    510e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5112:	f102 0207 	add.w	r2, r2, #7
    5116:	ea4f 1202 	mov.w	r2, r2, lsl #4
    511a:	4413      	add	r3, r2
    511c:	f103 0304 	add.w	r3, r3, #4
    5120:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    5124:	601a      	str	r2, [r3, #0]
				
				g_mss_mac.tx_desc_index = (g_mss_mac.tx_desc_index + 1u) % (uint32_t)TX_RING_SIZE;
    5126:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    512a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    512e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    5130:	f103 0301 	add.w	r3, r3, #1
    5134:	f003 0201 	and.w	r2, r3, #1
    5138:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    513c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5140:	671a      	str	r2, [r3, #112]	; 0x70

		/* Assumed TX_RING_SIZE == 2.  A #error directive checks this is the
		case. */
		taskENTER_CRITICAL();
		{
			for( ulDescriptor = 0; ulDescriptor < TX_RING_SIZE; ulDescriptor++ )
    5142:	693b      	ldr	r3, [r7, #16]
    5144:	f103 0301 	add.w	r3, r3, #1
    5148:	613b      	str	r3, [r7, #16]
    514a:	693b      	ldr	r3, [r7, #16]
    514c:	2b01      	cmp	r3, #1
    514e:	f67f ae03 	bls.w	4d58 <MSS_MAC_tx_packet+0xf8>
				g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_0 = TDES0_OWN;
				
				g_mss_mac.tx_desc_index = (g_mss_mac.tx_desc_index + 1u) % (uint32_t)TX_RING_SIZE;
			}		
		}
		taskEXIT_CRITICAL();
    5152:	f00f f979 	bl	14448 <vPortExitCritical>
    }
	
    if (error == MAC_OK)
    5156:	697b      	ldr	r3, [r7, #20]
    5158:	2b00      	cmp	r3, #0
    515a:	d119      	bne.n	5190 <MSS_MAC_tx_packet+0x530>
    {
        error = (int32_t)usLength;
    515c:	88fb      	ldrh	r3, [r7, #6]
    515e:	617b      	str	r3, [r7, #20]
		
		/* Start sending now both descriptors are set up.  This is done to
		prevent a Tx end occurring prior to the second descriptor being
		ready. */
		MAC_BITBAND->CSR6_ST = 1u;
    5160:	f240 0300 	movw	r3, #0
    5164:	f2c4 2306 	movt	r3, #16902	; 0x4206
    5168:	f04f 0201 	mov.w	r2, #1
    516c:	f8c3 2634 	str.w	r2, [r3, #1588]	; 0x634
		MAC->CSR1 = 1u;
    5170:	f243 0300 	movw	r3, #12288	; 0x3000
    5174:	f2c4 0300 	movt	r3, #16384	; 0x4000
    5178:	f04f 0201 	mov.w	r2, #1
    517c:	609a      	str	r2, [r3, #8]
		
		/* The buffer pointed to by uip_buf is now assigned to a Tx descriptor.
		Find anothere free buffer for uip_buf. */
		uip_buf = MAC_obtain_buffer();
    517e:	f001 fd51 	bl	6c24 <MAC_obtain_buffer>
    5182:	4602      	mov	r2, r0
    5184:	f240 6370 	movw	r3, #1648	; 0x670
    5188:	f2c2 0300 	movt	r3, #8192	; 0x2000
    518c:	601a      	str	r2, [r3, #0]
    518e:	e002      	b.n	5196 <MSS_MAC_tx_packet+0x536>
    }
    else
    {
        error = 0;
    5190:	f04f 0300 	mov.w	r3, #0
    5194:	617b      	str	r3, [r7, #20]
    }
    return ( error );
    5196:	697b      	ldr	r3, [r7, #20]
}
    5198:	4618      	mov	r0, r3
    519a:	f107 0728 	add.w	r7, r7, #40	; 0x28
    519e:	46bd      	mov	sp, r7
    51a0:	bd80      	pop	{r7, pc}
    51a2:	bf00      	nop

000051a4 <MSS_MAC_rx_pckt_size>:
int32_t
MSS_MAC_rx_pckt_size
(
    void
)
{
    51a4:	b580      	push	{r7, lr}
    51a6:	b082      	sub	sp, #8
    51a8:	af00      	add	r7, sp, #0
    int32_t retval;
    MAC_dismiss_bad_frames();
    51aa:	f001 f9a5 	bl	64f8 <MAC_dismiss_bad_frames>

    if( (g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &	RDES0_OWN) != 0u )
    51ae:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    51b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    51b6:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    51ba:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    51be:	f2c2 0300 	movt	r3, #8192	; 0x2000
    51c2:	ea4f 1202 	mov.w	r2, r2, lsl #4
    51c6:	4413      	add	r3, r2
    51c8:	f103 0398 	add.w	r3, r3, #152	; 0x98
    51cc:	681b      	ldr	r3, [r3, #0]
    51ce:	2b00      	cmp	r3, #0
    51d0:	da03      	bge.n	51da <MSS_MAC_rx_pckt_size+0x36>
    {
    	/* Current descriptor is empty */
    	retval = 0;
    51d2:	f04f 0300 	mov.w	r3, #0
    51d6:	603b      	str	r3, [r7, #0]
    51d8:	e018      	b.n	520c <MSS_MAC_rx_pckt_size+0x68>
    }
    else
    {
        uint32_t frame_length;
        frame_length = ( g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 >> RDES0_FL_OFFSET ) & RDES0_FL_MASK;
    51da:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    51de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    51e2:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    51e6:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    51ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    51ee:	ea4f 1202 	mov.w	r2, r2, lsl #4
    51f2:	4413      	add	r3, r2
    51f4:	f103 0398 	add.w	r3, r3, #152	; 0x98
    51f8:	681b      	ldr	r3, [r3, #0]
    51fa:	ea4f 4313 	mov.w	r3, r3, lsr #16
    51fe:	ea4f 4383 	mov.w	r3, r3, lsl #18
    5202:	ea4f 4393 	mov.w	r3, r3, lsr #18
    5206:	607b      	str	r3, [r7, #4]
        retval = (int32_t)( frame_length );
    5208:	687b      	ldr	r3, [r7, #4]
    520a:	603b      	str	r3, [r7, #0]
    }
    return retval;
    520c:	683b      	ldr	r3, [r7, #0]
}
    520e:	4618      	mov	r0, r3
    5210:	f107 0708 	add.w	r7, r7, #8
    5214:	46bd      	mov	sp, r7
    5216:	bd80      	pop	{r7, pc}

00005218 <MSS_MAC_rx_packet>:
int32_t
MSS_MAC_rx_packet
(
	void
)
{
    5218:	b590      	push	{r4, r7, lr}
    521a:	b083      	sub	sp, #12
    521c:	af00      	add	r7, sp, #0
	uint16_t frame_length=0u;
    521e:	f04f 0300 	mov.w	r3, #0
    5222:	80fb      	strh	r3, [r7, #6]

    MAC_dismiss_bad_frames();
    5224:	f001 f968 	bl	64f8 <MAC_dismiss_bad_frames>

    if( (g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 & RDES0_OWN) == 0u )
    5228:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    522c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5230:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    5234:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5238:	f2c2 0300 	movt	r3, #8192	; 0x2000
    523c:	ea4f 1202 	mov.w	r2, r2, lsl #4
    5240:	4413      	add	r3, r2
    5242:	f103 0398 	add.w	r3, r3, #152	; 0x98
    5246:	681b      	ldr	r3, [r3, #0]
    5248:	2b00      	cmp	r3, #0
    524a:	db56      	blt.n	52fa <MSS_MAC_rx_packet+0xe2>
    {
        frame_length = ( (
    	    g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 >>
    524c:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5250:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5254:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    5258:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    525c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5260:	ea4f 1202 	mov.w	r2, r2, lsl #4
    5264:	4413      	add	r3, r2
    5266:	f103 0398 	add.w	r3, r3, #152	; 0x98
    526a:	681b      	ldr	r3, [r3, #0]
    526c:	ea4f 4313 	mov.w	r3, r3, lsr #16

    MAC_dismiss_bad_frames();

    if( (g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 & RDES0_OWN) == 0u )
    {
        frame_length = ( (
    5270:	b29b      	uxth	r3, r3
    5272:	ea4f 4383 	mov.w	r3, r3, lsl #18
    5276:	ea4f 4393 	mov.w	r3, r3, lsr #18
    527a:	80fb      	strh	r3, [r7, #6]
    	    g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 >>
    	    RDES0_FL_OFFSET ) & RDES0_FL_MASK );

        /* strip crc */
        frame_length -= 4u;
    527c:	88fb      	ldrh	r3, [r7, #6]
    527e:	f1a3 0304 	sub.w	r3, r3, #4
    5282:	80fb      	strh	r3, [r7, #6]

        if( frame_length > macBUFFER_SIZE ) {
    5284:	88fb      	ldrh	r3, [r7, #6]
    5286:	f5b3 6fba 	cmp.w	r3, #1488	; 0x5d0
    528a:	d902      	bls.n	5292 <MSS_MAC_rx_packet+0x7a>
        	return MAC_NOT_ENOUGH_SPACE;
    528c:	f06f 0304 	mvn.w	r3, #4
    5290:	e034      	b.n	52fc <MSS_MAC_rx_packet+0xe4>
        }

		/* uip_buf is about to point to the buffer that contains the received
		data, mark the buffer that uip_buf is currently pointing to as free
		again. */
		MAC_release_buffer( uip_buf );
    5292:	f240 6370 	movw	r3, #1648	; 0x670
    5296:	f2c2 0300 	movt	r3, #8192	; 0x2000
    529a:	681b      	ldr	r3, [r3, #0]
    529c:	4618      	mov	r0, r3
    529e:	f001 fd7d 	bl	6d9c <MAC_release_buffer>
        uip_buf = ( unsigned char * ) g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].buffer_1;
    52a2:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    52a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    52aa:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    52ae:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    52b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    52b6:	f102 020a 	add.w	r2, r2, #10
    52ba:	ea4f 1202 	mov.w	r2, r2, lsl #4
    52be:	4413      	add	r3, r2
    52c0:	681b      	ldr	r3, [r3, #0]
    52c2:	461a      	mov	r2, r3
    52c4:	f240 6370 	movw	r3, #1648	; 0x670
    52c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    52cc:	601a      	str	r2, [r3, #0]
		
		/* The buffer the Rx descriptor was pointing to is now in use by the
		uIP stack - allocate a new buffer to the Rx descriptor. */
		g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].buffer_1 = ( unsigned long ) MAC_obtain_buffer();
    52ce:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    52d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    52d6:	f8d3 4094 	ldr.w	r4, [r3, #148]	; 0x94
    52da:	f001 fca3 	bl	6c24 <MAC_obtain_buffer>
    52de:	4603      	mov	r3, r0
    52e0:	461a      	mov	r2, r3
    52e2:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    52e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    52ea:	f104 010a 	add.w	r1, r4, #10
    52ee:	ea4f 1101 	mov.w	r1, r1, lsl #4
    52f2:	440b      	add	r3, r1
    52f4:	601a      	str	r2, [r3, #0]

        MSS_MAC_prepare_rx_descriptor();
    52f6:	f000 fcb9 	bl	5c6c <MSS_MAC_prepare_rx_descriptor>
    }
    return ((int32_t)frame_length);
    52fa:	88fb      	ldrh	r3, [r7, #6]
}
    52fc:	4618      	mov	r0, r3
    52fe:	f107 070c 	add.w	r7, r7, #12
    5302:	46bd      	mov	sp, r7
    5304:	bd90      	pop	{r4, r7, pc}
    5306:	bf00      	nop

00005308 <MSS_MAC_rx_packet_ptrset>:
MSS_MAC_rx_packet_ptrset
(
    uint8_t **pacData,
    uint32_t time_out
)
{
    5308:	b580      	push	{r7, lr}
    530a:	b084      	sub	sp, #16
    530c:	af00      	add	r7, sp, #0
    530e:	6078      	str	r0, [r7, #4]
    5310:	6039      	str	r1, [r7, #0]
	uint16_t frame_length = 0u;
    5312:	f04f 0300 	mov.w	r3, #0
    5316:	813b      	strh	r3, [r7, #8]
    int8_t exit = 0;
    5318:	f04f 0300 	mov.w	r3, #0
    531c:	72fb      	strb	r3, [r7, #11]

    configASSERT(  (time_out == MSS_MAC_BLOCKING) ||
    531e:	683b      	ldr	r3, [r7, #0]
    5320:	f1b3 3fff 	cmp.w	r3, #4294967295
    5324:	d009      	beq.n	533a <MSS_MAC_rx_packet_ptrset+0x32>
    5326:	683b      	ldr	r3, [r7, #0]
    5328:	2b00      	cmp	r3, #0
    532a:	d006      	beq.n	533a <MSS_MAC_rx_packet_ptrset+0x32>
    532c:	683b      	ldr	r3, [r7, #0]
    532e:	2b00      	cmp	r3, #0
    5330:	d006      	beq.n	5340 <MSS_MAC_rx_packet_ptrset+0x38>
    5332:	683b      	ldr	r3, [r7, #0]
    5334:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
    5338:	d802      	bhi.n	5340 <MSS_MAC_rx_packet_ptrset+0x38>
    533a:	f04f 0301 	mov.w	r3, #1
    533e:	e001      	b.n	5344 <MSS_MAC_rx_packet_ptrset+0x3c>
    5340:	f04f 0300 	mov.w	r3, #0
    5344:	2b00      	cmp	r3, #0
    5346:	d109      	bne.n	535c <MSS_MAC_rx_packet_ptrset+0x54>
    5348:	f04f 0328 	mov.w	r3, #40	; 0x28
    534c:	f383 8811 	msr	BASEPRI, r3
    5350:	f3bf 8f6f 	isb	sy
    5354:	f3bf 8f4f 	dsb	sy
    5358:	60fb      	str	r3, [r7, #12]
    535a:	e7fe      	b.n	535a <MSS_MAC_rx_packet_ptrset+0x52>
    			(time_out == MSS_MAC_NONBLOCKING) ||
    			((time_out >= 1) && (time_out <= 0x01000000UL)) );

    MAC_dismiss_bad_frames();
    535c:	f001 f8cc 	bl	64f8 <MAC_dismiss_bad_frames>

    /* wait for a packet */
	if( time_out != MSS_MAC_BLOCKING ) {
    5360:	683b      	ldr	r3, [r7, #0]
    5362:	f1b3 3fff 	cmp.w	r3, #4294967295
    5366:	d018      	beq.n	539a <MSS_MAC_rx_packet_ptrset+0x92>
		if( time_out == MSS_MAC_NONBLOCKING ) {
    5368:	683b      	ldr	r3, [r7, #0]
    536a:	2b00      	cmp	r3, #0
    536c:	d104      	bne.n	5378 <MSS_MAC_rx_packet_ptrset+0x70>
    		MAC_set_time_out( 0u );
    536e:	f04f 0000 	mov.w	r0, #0
    5372:	f001 f913 	bl	659c <MAC_set_time_out>
		} else {
    		MAC_set_time_out( time_out );
		}
	}

    while( ((g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    5376:	e011      	b.n	539c <MSS_MAC_rx_packet_ptrset+0x94>
    /* wait for a packet */
	if( time_out != MSS_MAC_BLOCKING ) {
		if( time_out == MSS_MAC_NONBLOCKING ) {
    		MAC_set_time_out( 0u );
		} else {
    		MAC_set_time_out( time_out );
    5378:	6838      	ldr	r0, [r7, #0]
    537a:	f001 f90f 	bl	659c <MAC_set_time_out>
		}
	}

    while( ((g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    537e:	e00d      	b.n	539c <MSS_MAC_rx_packet_ptrset+0x94>
    	RDES0_OWN) != 0u) && (exit == 0) )
    {
    	if( time_out != MSS_MAC_BLOCKING )
    5380:	683b      	ldr	r3, [r7, #0]
    5382:	f1b3 3fff 	cmp.w	r3, #4294967295
    5386:	d009      	beq.n	539c <MSS_MAC_rx_packet_ptrset+0x94>
    	{
    		if( MAC_get_time_out() == 0u ) {
    5388:	f001 f930 	bl	65ec <MAC_get_time_out>
    538c:	4603      	mov	r3, r0
    538e:	2b00      	cmp	r3, #0
    5390:	d104      	bne.n	539c <MSS_MAC_rx_packet_ptrset+0x94>
    			exit = 1;
    5392:	f04f 0301 	mov.w	r3, #1
    5396:	72fb      	strb	r3, [r7, #11]
    5398:	e000      	b.n	539c <MSS_MAC_rx_packet_ptrset+0x94>
		} else {
    		MAC_set_time_out( time_out );
		}
	}

    while( ((g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    539a:	bf00      	nop
    539c:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    53a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    53a4:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    53a8:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    53ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    53b0:	ea4f 1202 	mov.w	r2, r2, lsl #4
    53b4:	4413      	add	r3, r2
    53b6:	f103 0398 	add.w	r3, r3, #152	; 0x98
    53ba:	681b      	ldr	r3, [r3, #0]
    53bc:	2b00      	cmp	r3, #0
    53be:	da03      	bge.n	53c8 <MSS_MAC_rx_packet_ptrset+0xc0>
    53c0:	f997 300b 	ldrsb.w	r3, [r7, #11]
    53c4:	2b00      	cmp	r3, #0
    53c6:	d0db      	beq.n	5380 <MSS_MAC_rx_packet_ptrset+0x78>
    			exit = 1;
    		}
    	}
    }

    if(exit == 0)
    53c8:	f997 300b 	ldrsb.w	r3, [r7, #11]
    53cc:	2b00      	cmp	r3, #0
    53ce:	d12e      	bne.n	542e <MSS_MAC_rx_packet_ptrset+0x126>
    {
        frame_length = ( (
    	    g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 >>
    53d0:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    53d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    53d8:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    53dc:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    53e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    53e4:	ea4f 1202 	mov.w	r2, r2, lsl #4
    53e8:	4413      	add	r3, r2
    53ea:	f103 0398 	add.w	r3, r3, #152	; 0x98
    53ee:	681b      	ldr	r3, [r3, #0]
    53f0:	ea4f 4313 	mov.w	r3, r3, lsr #16
    	}
    }

    if(exit == 0)
    {
        frame_length = ( (
    53f4:	b29b      	uxth	r3, r3
    53f6:	ea4f 4383 	mov.w	r3, r3, lsl #18
    53fa:	ea4f 4393 	mov.w	r3, r3, lsr #18
    53fe:	813b      	strh	r3, [r7, #8]
    	    g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 >>
    	    RDES0_FL_OFFSET ) & RDES0_FL_MASK );

        /* strip crc */
        frame_length -= 4u;
    5400:	893b      	ldrh	r3, [r7, #8]
    5402:	f1a3 0304 	sub.w	r3, r3, #4
    5406:	813b      	strh	r3, [r7, #8]
       /* Here we are setting the buffer 'pacData' address to the address
          RX descriptor address. After this is called, the following function
          must be called 'MAC_prepare_rx_descriptor'
          to prepare the current rx descriptor for receiving the next packet.
       */
    	*pacData = (uint8_t *)g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].buffer_1 ;
    5408:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    540c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5410:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    5414:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5418:	f2c2 0300 	movt	r3, #8192	; 0x2000
    541c:	f102 020a 	add.w	r2, r2, #10
    5420:	ea4f 1202 	mov.w	r2, r2, lsl #4
    5424:	4413      	add	r3, r2
    5426:	681b      	ldr	r3, [r3, #0]
    5428:	461a      	mov	r2, r3
    542a:	687b      	ldr	r3, [r7, #4]
    542c:	601a      	str	r2, [r3, #0]

    }
    return ((int32_t)frame_length);
    542e:	893b      	ldrh	r3, [r7, #8]
}
    5430:	4618      	mov	r0, r3
    5432:	f107 0710 	add.w	r7, r7, #16
    5436:	46bd      	mov	sp, r7
    5438:	bd80      	pop	{r7, pc}
    543a:	bf00      	nop

0000543c <MSS_MAC_link_status>:
int32_t
MSS_MAC_link_status
(
    void
)
{
    543c:	b580      	push	{r7, lr}
    543e:	b082      	sub	sp, #8
    5440:	af00      	add	r7, sp, #0
	uint32_t link;

    link = PHY_link_status();
    5442:	f001 fe6b 	bl	711c <PHY_link_status>
    5446:	4603      	mov	r3, r0
    5448:	607b      	str	r3, [r7, #4]
    if( link == MSS_MAC_LINK_STATUS_LINK ) {
    544a:	687b      	ldr	r3, [r7, #4]
    544c:	2b01      	cmp	r3, #1
    544e:	d106      	bne.n	545e <MSS_MAC_link_status+0x22>
    	link |= PHY_link_type();
    5450:	f001 fe7c 	bl	714c <PHY_link_type>
    5454:	4603      	mov	r3, r0
    5456:	687a      	ldr	r2, [r7, #4]
    5458:	ea42 0303 	orr.w	r3, r2, r3
    545c:	607b      	str	r3, [r7, #4]
    }

    return ((int32_t)link);
    545e:	687b      	ldr	r3, [r7, #4]
}
    5460:	4618      	mov	r0, r3
    5462:	f107 0708 	add.w	r7, r7, #8
    5466:	46bd      	mov	sp, r7
    5468:	bd80      	pop	{r7, pc}
    546a:	bf00      	nop

0000546c <MSS_MAC_auto_setup_link>:
int32_t
MSS_MAC_auto_setup_link
(
    void
)
{
    546c:	b580      	push	{r7, lr}
    546e:	b084      	sub	sp, #16
    5470:	af00      	add	r7, sp, #0
	int32_t link;

    PHY_auto_negotiate();
    5472:	f001 fe2b 	bl	70cc <PHY_auto_negotiate>

    link = MSS_MAC_link_status();
    5476:	f7ff ffe1 	bl	543c <MSS_MAC_link_status>
    547a:	4603      	mov	r3, r0
    547c:	603b      	str	r3, [r7, #0]

    if( (link & MSS_MAC_LINK_STATUS_LINK) != 0u ) {
    547e:	683b      	ldr	r3, [r7, #0]
    5480:	f003 0301 	and.w	r3, r3, #1
    5484:	b2db      	uxtb	r3, r3
    5486:	2b00      	cmp	r3, #0
    5488:	d051      	beq.n	552e <MSS_MAC_auto_setup_link+0xc2>
    	int32_t ret;
	    ret = MAC_stop_transmission();
    548a:	f000 ffb9 	bl	6400 <MAC_stop_transmission>
    548e:	4603      	mov	r3, r0
    5490:	607b      	str	r3, [r7, #4]
	    MAC_CHECK( ret == MAC_OK, ret );
    5492:	687b      	ldr	r3, [r7, #4]
    5494:	2b00      	cmp	r3, #0
    5496:	d013      	beq.n	54c0 <MSS_MAC_auto_setup_link+0x54>
    5498:	687b      	ldr	r3, [r7, #4]
    549a:	b2da      	uxtb	r2, r3
    549c:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    54a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    54a4:	715a      	strb	r2, [r3, #5]
    54a6:	687b      	ldr	r3, [r7, #4]
    54a8:	2b00      	cmp	r3, #0
    54aa:	d009      	beq.n	54c0 <MSS_MAC_auto_setup_link+0x54>
    54ac:	f04f 0328 	mov.w	r3, #40	; 0x28
    54b0:	f383 8811 	msr	BASEPRI, r3
    54b4:	f3bf 8f6f 	isb	sy
    54b8:	f3bf 8f4f 	dsb	sy
    54bc:	60bb      	str	r3, [r7, #8]
    54be:	e7fe      	b.n	54be <MSS_MAC_auto_setup_link+0x52>

	    ret = MAC_stop_receiving();
    54c0:	f000 ffdc 	bl	647c <MAC_stop_receiving>
    54c4:	4603      	mov	r3, r0
    54c6:	607b      	str	r3, [r7, #4]
	    MAC_CHECK( ret == MAC_OK, ret );
    54c8:	687b      	ldr	r3, [r7, #4]
    54ca:	2b00      	cmp	r3, #0
    54cc:	d013      	beq.n	54f6 <MSS_MAC_auto_setup_link+0x8a>
    54ce:	687b      	ldr	r3, [r7, #4]
    54d0:	b2da      	uxtb	r2, r3
    54d2:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    54d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    54da:	715a      	strb	r2, [r3, #5]
    54dc:	687b      	ldr	r3, [r7, #4]
    54de:	2b00      	cmp	r3, #0
    54e0:	d009      	beq.n	54f6 <MSS_MAC_auto_setup_link+0x8a>
    54e2:	f04f 0328 	mov.w	r3, #40	; 0x28
    54e6:	f383 8811 	msr	BASEPRI, r3
    54ea:	f3bf 8f6f 	isb	sy
    54ee:	f3bf 8f4f 	dsb	sy
    54f2:	60fb      	str	r3, [r7, #12]
    54f4:	e7fe      	b.n	54f4 <MSS_MAC_auto_setup_link+0x88>
        MAC_BITBAND->CSR6_TTM = (uint32_t)((((uint32_t)link & MSS_MAC_LINK_STATUS_100MB) != 0u) ? 1u : 0u );
    54f6:	f240 0300 	movw	r3, #0
    54fa:	f2c4 2306 	movt	r3, #16902	; 0x4206
    54fe:	683a      	ldr	r2, [r7, #0]
    5500:	f002 0202 	and.w	r2, r2, #2
    5504:	2a00      	cmp	r2, #0
    5506:	d002      	beq.n	550e <MSS_MAC_auto_setup_link+0xa2>
    5508:	f04f 0201 	mov.w	r2, #1
    550c:	e001      	b.n	5512 <MSS_MAC_auto_setup_link+0xa6>
    550e:	f04f 0200 	mov.w	r2, #0
    5512:	f8c3 2658 	str.w	r2, [r3, #1624]	; 0x658
        MAC_BITBAND->CSR6_FD = (uint32_t)((((uint32_t)link & MSS_MAC_LINK_STATUS_FDX) != 0u) ? 1u : 1u );
    5516:	f240 0300 	movw	r3, #0
    551a:	f2c4 2306 	movt	r3, #16902	; 0x4206
    551e:	f04f 0201 	mov.w	r2, #1
    5522:	f8c3 2624 	str.w	r2, [r3, #1572]	; 0x624
	    MAC_start_transmission();
    5526:	f000 ff9b 	bl	6460 <MAC_start_transmission>
	    MAC_start_receiving();
    552a:	f000 ffd7 	bl	64dc <MAC_start_receiving>
    }

    return link;
    552e:	683b      	ldr	r3, [r7, #0]
}
    5530:	4618      	mov	r0, r3
    5532:	f107 0710 	add.w	r7, r7, #16
    5536:	46bd      	mov	sp, r7
    5538:	bd80      	pop	{r7, pc}
    553a:	bf00      	nop

0000553c <MSS_MAC_set_mac_address>:
void
MSS_MAC_set_mac_address
(
    const uint8_t *new_address
)
{
    553c:	b580      	push	{r7, lr}
    553e:	b084      	sub	sp, #16
    5540:	af00      	add	r7, sp, #0
    5542:	6078      	str	r0, [r7, #4]
    /* Check if the new address is unicast */
    configASSERT( (new_address[0]&1) == 0 );
    5544:	687b      	ldr	r3, [r7, #4]
    5546:	781b      	ldrb	r3, [r3, #0]
    5548:	f003 0301 	and.w	r3, r3, #1
    554c:	2b00      	cmp	r3, #0
    554e:	d009      	beq.n	5564 <MSS_MAC_set_mac_address+0x28>
    5550:	f04f 0328 	mov.w	r3, #40	; 0x28
    5554:	f383 8811 	msr	BASEPRI, r3
    5558:	f3bf 8f6f 	isb	sy
    555c:	f3bf 8f4f 	dsb	sy
    5560:	60fb      	str	r3, [r7, #12]
    5562:	e7fe      	b.n	5562 <MSS_MAC_set_mac_address+0x26>

   	MAC_memcpy( g_mss_mac.mac_address, new_address, 6u );
    5564:	481c      	ldr	r0, [pc, #112]	; (55d8 <MSS_MAC_set_mac_address+0x9c>)
    5566:	6879      	ldr	r1, [r7, #4]
    5568:	f04f 0206 	mov.w	r2, #6
    556c:	f001 faf8 	bl	6b60 <MAC_memcpy>

   	if((g_mss_mac.flags & FLAG_PERFECT_FILTERING) != 0u ) {
    5570:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5574:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5578:	791b      	ldrb	r3, [r3, #4]
    557a:	f003 0302 	and.w	r3, r3, #2
    557e:	2b00      	cmp	r3, #0
    5580:	d023      	beq.n	55ca <MSS_MAC_set_mac_address+0x8e>
		int32_t a;
	   	/* set unused filters to the new mac address */
		for( a=14*6; a>=0; a-=6 ) {
    5582:	f04f 0354 	mov.w	r3, #84	; 0x54
    5586:	60bb      	str	r3, [r7, #8]
    5588:	e01c      	b.n	55c4 <MSS_MAC_set_mac_address+0x88>
			if( (g_mss_mac.mac_filter_data[a] & 1u) != 0u ) {
    558a:	68ba      	ldr	r2, [r7, #8]
    558c:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5590:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5594:	4413      	add	r3, r2
    5596:	7b1b      	ldrb	r3, [r3, #12]
    5598:	f003 0301 	and.w	r3, r3, #1
    559c:	b2db      	uxtb	r3, r3
    559e:	2b00      	cmp	r3, #0
    55a0:	d003      	beq.n	55aa <MSS_MAC_set_mac_address+0x6e>
				/* Filters with multicast addresses are used */
				a = -1;
    55a2:	f04f 33ff 	mov.w	r3, #4294967295
    55a6:	60bb      	str	r3, [r7, #8]
    55a8:	e008      	b.n	55bc <MSS_MAC_set_mac_address+0x80>
			} else {
				MAC_memcpy( &(g_mss_mac.mac_filter_data[a]),
    55aa:	68ba      	ldr	r2, [r7, #8]
    55ac:	4b0b      	ldr	r3, [pc, #44]	; (55dc <MSS_MAC_set_mac_address+0xa0>)
    55ae:	4413      	add	r3, r2
    55b0:	4618      	mov	r0, r3
    55b2:	4909      	ldr	r1, [pc, #36]	; (55d8 <MSS_MAC_set_mac_address+0x9c>)
    55b4:	f04f 0206 	mov.w	r2, #6
    55b8:	f001 fad2 	bl	6b60 <MAC_memcpy>
   	MAC_memcpy( g_mss_mac.mac_address, new_address, 6u );

   	if((g_mss_mac.flags & FLAG_PERFECT_FILTERING) != 0u ) {
		int32_t a;
	   	/* set unused filters to the new mac address */
		for( a=14*6; a>=0; a-=6 ) {
    55bc:	68bb      	ldr	r3, [r7, #8]
    55be:	f1a3 0306 	sub.w	r3, r3, #6
    55c2:	60bb      	str	r3, [r7, #8]
    55c4:	68bb      	ldr	r3, [r7, #8]
    55c6:	2b00      	cmp	r3, #0
    55c8:	dadf      	bge.n	558a <MSS_MAC_set_mac_address+0x4e>
					g_mss_mac.mac_address, 6u );
			}
		}
   	}

   	MAC_send_setup_frame();
    55ca:	f000 fd63 	bl	6094 <MAC_send_setup_frame>
}
    55ce:	f107 0710 	add.w	r7, r7, #16
    55d2:	46bd      	mov	sp, r7
    55d4:	bd80      	pop	{r7, pc}
    55d6:	bf00      	nop
    55d8:	2000aae6 	.word	0x2000aae6
    55dc:	2000aaec 	.word	0x2000aaec

000055e0 <MSS_MAC_get_mac_address>:
void
MSS_MAC_get_mac_address
(
    uint8_t *address
)
{
    55e0:	b580      	push	{r7, lr}
    55e2:	b082      	sub	sp, #8
    55e4:	af00      	add	r7, sp, #0
    55e6:	6078      	str	r0, [r7, #4]
   	MAC_memcpy( address, g_mss_mac.mac_address, 6u );
    55e8:	6878      	ldr	r0, [r7, #4]
    55ea:	4904      	ldr	r1, [pc, #16]	; (55fc <MSS_MAC_get_mac_address+0x1c>)
    55ec:	f04f 0206 	mov.w	r2, #6
    55f0:	f001 fab6 	bl	6b60 <MAC_memcpy>
}
    55f4:	f107 0708 	add.w	r7, r7, #8
    55f8:	46bd      	mov	sp, r7
    55fa:	bd80      	pop	{r7, pc}
    55fc:	2000aae6 	.word	0x2000aae6

00005600 <MSS_MAC_set_mac_filters>:
MSS_MAC_set_mac_filters
(
	uint16_t filter_count,
	const uint8_t *filters
)
{
    5600:	b580      	push	{r7, lr}
    5602:	b08a      	sub	sp, #40	; 0x28
    5604:	af00      	add	r7, sp, #0
    5606:	4603      	mov	r3, r0
    5608:	6039      	str	r1, [r7, #0]
    560a:	80fb      	strh	r3, [r7, #6]
    configASSERT( (filter_count==0) || (filters != NULL_buffer) );
    560c:	88fb      	ldrh	r3, [r7, #6]
    560e:	2b00      	cmp	r3, #0
    5610:	d007      	beq.n	5622 <MSS_MAC_set_mac_filters+0x22>
    5612:	f240 6368 	movw	r3, #1640	; 0x668
    5616:	f2c2 0300 	movt	r3, #8192	; 0x2000
    561a:	681b      	ldr	r3, [r3, #0]
    561c:	683a      	ldr	r2, [r7, #0]
    561e:	429a      	cmp	r2, r3
    5620:	d002      	beq.n	5628 <MSS_MAC_set_mac_filters+0x28>
    5622:	f04f 0301 	mov.w	r3, #1
    5626:	e001      	b.n	562c <MSS_MAC_set_mac_filters+0x2c>
    5628:	f04f 0300 	mov.w	r3, #0
    562c:	2b00      	cmp	r3, #0
    562e:	d109      	bne.n	5644 <MSS_MAC_set_mac_filters+0x44>
    5630:	f04f 0328 	mov.w	r3, #40	; 0x28
    5634:	f383 8811 	msr	BASEPRI, r3
    5638:	f3bf 8f6f 	isb	sy
    563c:	f3bf 8f4f 	dsb	sy
    5640:	623b      	str	r3, [r7, #32]
    5642:	e7fe      	b.n	5642 <MSS_MAC_set_mac_filters+0x42>
    /* Check if the mac addresses is multicast */
    {
    	int32_t a;
    	for( a = 0u; a < filter_count; a++ ) {
    5644:	f04f 0300 	mov.w	r3, #0
    5648:	60fb      	str	r3, [r7, #12]
    564a:	e01c      	b.n	5686 <MSS_MAC_set_mac_filters+0x86>
    		configASSERT( (filters[a*6]&1) == 1 );
    564c:	68fa      	ldr	r2, [r7, #12]
    564e:	4613      	mov	r3, r2
    5650:	ea4f 0343 	mov.w	r3, r3, lsl #1
    5654:	4413      	add	r3, r2
    5656:	ea4f 0343 	mov.w	r3, r3, lsl #1
    565a:	461a      	mov	r2, r3
    565c:	683b      	ldr	r3, [r7, #0]
    565e:	4413      	add	r3, r2
    5660:	781b      	ldrb	r3, [r3, #0]
    5662:	f003 0301 	and.w	r3, r3, #1
    5666:	2b00      	cmp	r3, #0
    5668:	d109      	bne.n	567e <MSS_MAC_set_mac_filters+0x7e>
    566a:	f04f 0328 	mov.w	r3, #40	; 0x28
    566e:	f383 8811 	msr	BASEPRI, r3
    5672:	f3bf 8f6f 	isb	sy
    5676:	f3bf 8f4f 	dsb	sy
    567a:	627b      	str	r3, [r7, #36]	; 0x24
    567c:	e7fe      	b.n	567c <MSS_MAC_set_mac_filters+0x7c>
{
    configASSERT( (filter_count==0) || (filters != NULL_buffer) );
    /* Check if the mac addresses is multicast */
    {
    	int32_t a;
    	for( a = 0u; a < filter_count; a++ ) {
    567e:	68fb      	ldr	r3, [r7, #12]
    5680:	f103 0301 	add.w	r3, r3, #1
    5684:	60fb      	str	r3, [r7, #12]
    5686:	88fa      	ldrh	r2, [r7, #6]
    5688:	68fb      	ldr	r3, [r7, #12]
    568a:	429a      	cmp	r2, r3
    568c:	dcde      	bgt.n	564c <MSS_MAC_set_mac_filters+0x4c>
    		configASSERT( (filters[a*6]&1) == 1 );
    	}
    }

    if( filter_count <= 15 ){
    568e:	88fb      	ldrh	r3, [r7, #6]
    5690:	2b0f      	cmp	r3, #15
    5692:	d833      	bhi.n	56fc <MSS_MAC_set_mac_filters+0xfc>
    	int32_t a;
    	g_mss_mac.flags |= FLAG_PERFECT_FILTERING;
    5694:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5698:	f2c2 0300 	movt	r3, #8192	; 0x2000
    569c:	791b      	ldrb	r3, [r3, #4]
    569e:	f043 0302 	orr.w	r3, r3, #2
    56a2:	b2da      	uxtb	r2, r3
    56a4:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    56a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    56ac:	711a      	strb	r2, [r3, #4]

    	/* copy new filters */
    	MAC_memcpy( g_mss_mac.mac_filter_data, filters, (uint32_t)(filter_count*6));
    56ae:	88fa      	ldrh	r2, [r7, #6]
    56b0:	4613      	mov	r3, r2
    56b2:	ea4f 0343 	mov.w	r3, r3, lsl #1
    56b6:	4413      	add	r3, r2
    56b8:	ea4f 0343 	mov.w	r3, r3, lsl #1
    56bc:	483c      	ldr	r0, [pc, #240]	; (57b0 <MSS_MAC_set_mac_filters+0x1b0>)
    56be:	6839      	ldr	r1, [r7, #0]
    56c0:	461a      	mov	r2, r3
    56c2:	f001 fa4d 	bl	6b60 <MAC_memcpy>

    	/* set unused filters to our mac address */
    	for( a=filter_count; a<15; a++ ) {
    56c6:	88fb      	ldrh	r3, [r7, #6]
    56c8:	613b      	str	r3, [r7, #16]
    56ca:	e013      	b.n	56f4 <MSS_MAC_set_mac_filters+0xf4>
   			MAC_memcpy( &(g_mss_mac.mac_filter_data[a*6]),
    56cc:	693a      	ldr	r2, [r7, #16]
    56ce:	4613      	mov	r3, r2
    56d0:	ea4f 0343 	mov.w	r3, r3, lsl #1
    56d4:	4413      	add	r3, r2
    56d6:	ea4f 0343 	mov.w	r3, r3, lsl #1
    56da:	461a      	mov	r2, r3
    56dc:	4b34      	ldr	r3, [pc, #208]	; (57b0 <MSS_MAC_set_mac_filters+0x1b0>)
    56de:	4413      	add	r3, r2
    56e0:	4618      	mov	r0, r3
    56e2:	4934      	ldr	r1, [pc, #208]	; (57b4 <MSS_MAC_set_mac_filters+0x1b4>)
    56e4:	f04f 0206 	mov.w	r2, #6
    56e8:	f001 fa3a 	bl	6b60 <MAC_memcpy>

    	/* copy new filters */
    	MAC_memcpy( g_mss_mac.mac_filter_data, filters, (uint32_t)(filter_count*6));

    	/* set unused filters to our mac address */
    	for( a=filter_count; a<15; a++ ) {
    56ec:	693b      	ldr	r3, [r7, #16]
    56ee:	f103 0301 	add.w	r3, r3, #1
    56f2:	613b      	str	r3, [r7, #16]
    56f4:	693b      	ldr	r3, [r7, #16]
    56f6:	2b0e      	cmp	r3, #14
    56f8:	dde8      	ble.n	56cc <MSS_MAC_set_mac_filters+0xcc>
    56fa:	e052      	b.n	57a2 <MSS_MAC_set_mac_filters+0x1a2>
    	}
    } else {
    	int32_t a,b;
    	uint32_t hash;

    	g_mss_mac.flags &= ~FLAG_PERFECT_FILTERING;
    56fc:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5700:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5704:	791b      	ldrb	r3, [r3, #4]
    5706:	461a      	mov	r2, r3
    5708:	f002 02fd 	and.w	r2, r2, #253	; 0xfd
    570c:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5710:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5714:	711a      	strb	r2, [r3, #4]

    	/* reset hash table */
    	MAC_memset( g_mss_mac.mac_filter_data, 0u, 64u );
    5716:	4826      	ldr	r0, [pc, #152]	; (57b0 <MSS_MAC_set_mac_filters+0x1b0>)
    5718:	f04f 0100 	mov.w	r1, #0
    571c:	f04f 0240 	mov.w	r2, #64	; 0x40
    5720:	f000 ffde 	bl	66e0 <MAC_memset>

    	for( a=0, b=0; a<filter_count; a++, b+=6 ) {
    5724:	f04f 0300 	mov.w	r3, #0
    5728:	617b      	str	r3, [r7, #20]
    572a:	f04f 0300 	mov.w	r3, #0
    572e:	61bb      	str	r3, [r7, #24]
    5730:	e033      	b.n	579a <MSS_MAC_set_mac_filters+0x19a>
    		hash = mss_ethernet_crc( &(filters[b]), 6 ) & 0x1FF;
    5732:	69ba      	ldr	r2, [r7, #24]
    5734:	683b      	ldr	r3, [r7, #0]
    5736:	4413      	add	r3, r2
    5738:	4618      	mov	r0, r3
    573a:	f04f 0106 	mov.w	r1, #6
    573e:	f7fe ff0b 	bl	4558 <mss_ethernet_crc>
    5742:	4603      	mov	r3, r0
    5744:	ea4f 53c3 	mov.w	r3, r3, lsl #23
    5748:	ea4f 53d3 	mov.w	r3, r3, lsr #23
    574c:	61fb      	str	r3, [r7, #28]
    		g_mss_mac.mac_filter_data[ hash / 8 ] |= 1 << (hash & 0x7);
    574e:	69fb      	ldr	r3, [r7, #28]
    5750:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    5754:	4619      	mov	r1, r3
    5756:	461a      	mov	r2, r3
    5758:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    575c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5760:	4413      	add	r3, r2
    5762:	7b1b      	ldrb	r3, [r3, #12]
    5764:	461a      	mov	r2, r3
    5766:	69fb      	ldr	r3, [r7, #28]
    5768:	f003 0307 	and.w	r3, r3, #7
    576c:	f04f 0001 	mov.w	r0, #1
    5770:	fa00 f303 	lsl.w	r3, r0, r3
    5774:	b2db      	uxtb	r3, r3
    5776:	ea42 0303 	orr.w	r3, r2, r3
    577a:	b2db      	uxtb	r3, r3
    577c:	b2da      	uxtb	r2, r3
    577e:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5782:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5786:	440b      	add	r3, r1
    5788:	731a      	strb	r2, [r3, #12]
    	g_mss_mac.flags &= ~FLAG_PERFECT_FILTERING;

    	/* reset hash table */
    	MAC_memset( g_mss_mac.mac_filter_data, 0u, 64u );

    	for( a=0, b=0; a<filter_count; a++, b+=6 ) {
    578a:	697b      	ldr	r3, [r7, #20]
    578c:	f103 0301 	add.w	r3, r3, #1
    5790:	617b      	str	r3, [r7, #20]
    5792:	69bb      	ldr	r3, [r7, #24]
    5794:	f103 0306 	add.w	r3, r3, #6
    5798:	61bb      	str	r3, [r7, #24]
    579a:	88fa      	ldrh	r2, [r7, #6]
    579c:	697b      	ldr	r3, [r7, #20]
    579e:	429a      	cmp	r2, r3
    57a0:	dcc7      	bgt.n	5732 <MSS_MAC_set_mac_filters+0x132>
    		hash = mss_ethernet_crc( &(filters[b]), 6 ) & 0x1FF;
    		g_mss_mac.mac_filter_data[ hash / 8 ] |= 1 << (hash & 0x7);
    	}
    }

    MAC_send_setup_frame();
    57a2:	f000 fc77 	bl	6094 <MAC_send_setup_frame>
}
    57a6:	f107 0728 	add.w	r7, r7, #40	; 0x28
    57aa:	46bd      	mov	sp, r7
    57ac:	bd80      	pop	{r7, pc}
    57ae:	bf00      	nop
    57b0:	2000aaec 	.word	0x2000aaec
    57b4:	2000aae6 	.word	0x2000aae6

000057b8 <EthernetMAC_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void EthernetMAC_IRQHandler( void )
#else
void EthernetMAC_IRQHandler( void )
#endif
{
    57b8:	4668      	mov	r0, sp
    57ba:	f020 0107 	bic.w	r1, r0, #7
    57be:	468d      	mov	sp, r1
    57c0:	b581      	push	{r0, r7, lr}
    57c2:	b083      	sub	sp, #12
    57c4:	af00      	add	r7, sp, #0
    uint32_t events;
    uint32_t intr_status;

    events = 0u;
    57c6:	f04f 0300 	mov.w	r3, #0
    57ca:	603b      	str	r3, [r7, #0]
    intr_status = MAC->CSR5;
    57cc:	f243 0300 	movw	r3, #12288	; 0x3000
    57d0:	f2c4 0300 	movt	r3, #16384	; 0x4000
    57d4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    57d6:	607b      	str	r3, [r7, #4]

    if( (intr_status & CSR5_NIS_MASK) != 0u ) {
    57d8:	687b      	ldr	r3, [r7, #4]
    57da:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
    57de:	2b00      	cmp	r3, #0
    57e0:	d062      	beq.n	58a8 <EthernetMAC_IRQHandler+0xf0>
    	if( (intr_status & CSR5_TI_MASK) != 0u ) { /* Transmit */
    57e2:	687b      	ldr	r3, [r7, #4]
    57e4:	f003 0301 	and.w	r3, r3, #1
    57e8:	b2db      	uxtb	r3, r3
    57ea:	2b00      	cmp	r3, #0
    57ec:	d02b      	beq.n	5846 <EthernetMAC_IRQHandler+0x8e>
    		g_mss_mac.statistics.tx_interrupts++;
    57ee:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    57f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    57f6:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
    57fa:	ea4f 2212 	mov.w	r2, r2, lsr #8
    57fe:	f893 3118 	ldrb.w	r3, [r3, #280]	; 0x118
    5802:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5806:	ea43 0302 	orr.w	r3, r3, r2
    580a:	f103 0201 	add.w	r2, r3, #1
    580e:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5812:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5816:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    581a:	ea4f 2101 	mov.w	r1, r1, lsl #8
    581e:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
    5822:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    5826:	ea40 0101 	orr.w	r1, r0, r1
    582a:	f8c3 1114 	str.w	r1, [r3, #276]	; 0x114
    582e:	ea4f 6212 	mov.w	r2, r2, lsr #24
    5832:	f04f 0100 	mov.w	r1, #0
    5836:	ea41 0202 	orr.w	r2, r1, r2
    583a:	f883 2118 	strb.w	r2, [r3, #280]	; 0x118
    		events |= MSS_MAC_EVENT_PACKET_SEND;
    583e:	683b      	ldr	r3, [r7, #0]
    5840:	f043 0301 	orr.w	r3, r3, #1
    5844:	603b      	str	r3, [r7, #0]
    	}

    	if( (intr_status & CSR5_RI_MASK) != 0u ) { /* Receive */
    5846:	687b      	ldr	r3, [r7, #4]
    5848:	f003 0340 	and.w	r3, r3, #64	; 0x40
    584c:	2b00      	cmp	r3, #0
    584e:	d02b      	beq.n	58a8 <EthernetMAC_IRQHandler+0xf0>
    		g_mss_mac.statistics.rx_interrupts++;
    5850:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5854:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5858:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
    585c:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5860:	f893 30ec 	ldrb.w	r3, [r3, #236]	; 0xec
    5864:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5868:	ea43 0302 	orr.w	r3, r3, r2
    586c:	f103 0201 	add.w	r2, r3, #1
    5870:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5874:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5878:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    587c:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5880:	f8d3 00e8 	ldr.w	r0, [r3, #232]	; 0xe8
    5884:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    5888:	ea40 0101 	orr.w	r1, r0, r1
    588c:	f8c3 10e8 	str.w	r1, [r3, #232]	; 0xe8
    5890:	ea4f 6212 	mov.w	r2, r2, lsr #24
    5894:	f04f 0100 	mov.w	r1, #0
    5898:	ea41 0202 	orr.w	r2, r1, r2
    589c:	f883 20ec 	strb.w	r2, [r3, #236]	; 0xec
    		events |= MSS_MAC_EVENT_PACKET_RECEIVED;
    58a0:	683b      	ldr	r3, [r7, #0]
    58a2:	f043 0302 	orr.w	r3, r3, #2
    58a6:	603b      	str	r3, [r7, #0]
    	}
    }

    /* Clear interrupts */
    MAC->CSR5 = CSR5_INT_BITS;
    58a8:	f243 0300 	movw	r3, #12288	; 0x3000
    58ac:	f2c4 0300 	movt	r3, #16384	; 0x4000
    58b0:	f64c 52e7 	movw	r2, #52711	; 0xcde7
    58b4:	f2c0 0201 	movt	r2, #1
    58b8:	629a      	str	r2, [r3, #40]	; 0x28

    if( (events != 0u) && (g_mss_mac.listener != NULL_callback) ) {
    58ba:	683b      	ldr	r3, [r7, #0]
    58bc:	2b00      	cmp	r3, #0
    58be:	d012      	beq.n	58e6 <EthernetMAC_IRQHandler+0x12e>
    58c0:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    58c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    58c8:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    58ca:	f240 636c 	movw	r3, #1644	; 0x66c
    58ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    58d2:	681b      	ldr	r3, [r3, #0]
    58d4:	429a      	cmp	r2, r3
    58d6:	d006      	beq.n	58e6 <EthernetMAC_IRQHandler+0x12e>
        g_mss_mac.listener( events );
    58d8:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    58dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    58e0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    58e2:	6838      	ldr	r0, [r7, #0]
    58e4:	4798      	blx	r3
    }
}
    58e6:	f107 070c 	add.w	r7, r7, #12
    58ea:	46bd      	mov	sp, r7
    58ec:	e8bd 4081 	ldmia.w	sp!, {r0, r7, lr}
    58f0:	4685      	mov	sp, r0
    58f2:	4770      	bx	lr

000058f4 <MSS_MAC_set_callback>:
void
MSS_MAC_set_callback
(
    MSS_MAC_callback_t listener
)
{
    58f4:	b480      	push	{r7}
    58f6:	b083      	sub	sp, #12
    58f8:	af00      	add	r7, sp, #0
    58fa:	6078      	str	r0, [r7, #4]
	/* disable tx and rx interrupts */
    MAC_BITBAND->CSR7_RIE = 0u;
    58fc:	f240 0300 	movw	r3, #0
    5900:	f2c4 2306 	movt	r3, #16902	; 0x4206
    5904:	f04f 0200 	mov.w	r2, #0
    5908:	f8c3 2718 	str.w	r2, [r3, #1816]	; 0x718
    MAC_BITBAND->CSR7_TIE = 0u;
    590c:	f240 0300 	movw	r3, #0
    5910:	f2c4 2306 	movt	r3, #16902	; 0x4206
    5914:	f04f 0200 	mov.w	r2, #0
    5918:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700

    g_mss_mac.listener = listener;
    591c:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5920:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5924:	687a      	ldr	r2, [r7, #4]
    5926:	66da      	str	r2, [r3, #108]	; 0x6c

	if( listener != NULL_callback ) {
    5928:	f240 636c 	movw	r3, #1644	; 0x66c
    592c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5930:	681b      	ldr	r3, [r3, #0]
    5932:	687a      	ldr	r2, [r7, #4]
    5934:	429a      	cmp	r2, r3
    5936:	d00f      	beq.n	5958 <MSS_MAC_set_callback+0x64>
		/* enable tx and rx interrupts */
        MAC_BITBAND->CSR7_RIE = 1u;
    5938:	f240 0300 	movw	r3, #0
    593c:	f2c4 2306 	movt	r3, #16902	; 0x4206
    5940:	f04f 0201 	mov.w	r2, #1
    5944:	f8c3 2718 	str.w	r2, [r3, #1816]	; 0x718
        MAC_BITBAND->CSR7_TIE = 1u;
    5948:	f240 0300 	movw	r3, #0
    594c:	f2c4 2306 	movt	r3, #16902	; 0x4206
    5950:	f04f 0201 	mov.w	r2, #1
    5954:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700
	}
}
    5958:	f107 070c 	add.w	r7, r7, #12
    595c:	46bd      	mov	sp, r7
    595e:	bc80      	pop	{r7}
    5960:	4770      	bx	lr
    5962:	bf00      	nop

00005964 <MSS_MAC_last_error>:
const int8_t*
MSS_MAC_last_error
(
    void
)
{
    5964:	b480      	push	{r7}
    5966:	b083      	sub	sp, #12
    5968:	af00      	add	r7, sp, #0
	int8_t error_msg_nb;
    const int8_t* returnvalue;

	error_msg_nb = -(g_mss_mac.last_error);
    596a:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    596e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5972:	795b      	ldrb	r3, [r3, #5]
    5974:	f1c3 0300 	rsb	r3, r3, #0
    5978:	70fb      	strb	r3, [r7, #3]
	if( error_msg_nb >= ERROR_MESSAGE_COUNT ) {
    597a:	f997 3003 	ldrsb.w	r3, [r7, #3]
    597e:	2b07      	cmp	r3, #7
    5980:	dd05      	ble.n	598e <MSS_MAC_last_error+0x2a>
		returnvalue = unknown_error;
    5982:	f64c 53fc 	movw	r3, #52732	; 0xcdfc
    5986:	f2c0 0301 	movt	r3, #1
    598a:	607b      	str	r3, [r7, #4]
    598c:	e00d      	b.n	59aa <MSS_MAC_last_error+0x46>
	} else {
		returnvalue = ErrorMessages[error_msg_nb];
    598e:	f64c 620c 	movw	r2, #52748	; 0xce0c
    5992:	f2c0 0201 	movt	r2, #1
    5996:	f997 1003 	ldrsb.w	r1, [r7, #3]
    599a:	460b      	mov	r3, r1
    599c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    59a0:	440b      	add	r3, r1
    59a2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    59a6:	4413      	add	r3, r2
    59a8:	607b      	str	r3, [r7, #4]
	}
	return returnvalue;
    59aa:	687b      	ldr	r3, [r7, #4]
}
    59ac:	4618      	mov	r0, r3
    59ae:	f107 070c 	add.w	r7, r7, #12
    59b2:	46bd      	mov	sp, r7
    59b4:	bc80      	pop	{r7}
    59b6:	4770      	bx	lr

000059b8 <MSS_MAC_get_statistics>:
uint32_t
MSS_MAC_get_statistics
(
    mss_mac_statistics_id_t stat_id
)
{
    59b8:	b480      	push	{r7}
    59ba:	b085      	sub	sp, #20
    59bc:	af00      	add	r7, sp, #0
    59be:	4603      	mov	r3, r0
    59c0:	71fb      	strb	r3, [r7, #7]
    uint32_t returnval = 0u;
    59c2:	f04f 0300 	mov.w	r3, #0
    59c6:	60fb      	str	r3, [r7, #12]

	switch( stat_id ) {
    59c8:	79fb      	ldrb	r3, [r7, #7]
    59ca:	2b11      	cmp	r3, #17
    59cc:	f200 8147 	bhi.w	5c5e <MSS_MAC_get_statistics+0x2a6>
    59d0:	a201      	add	r2, pc, #4	; (adr r2, 59d8 <MSS_MAC_get_statistics+0x20>)
    59d2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    59d6:	bf00      	nop
    59d8:	00005a21 	.word	0x00005a21
    59dc:	00005a41 	.word	0x00005a41
    59e0:	00005a61 	.word	0x00005a61
    59e4:	00005a81 	.word	0x00005a81
    59e8:	00005aa1 	.word	0x00005aa1
    59ec:	00005ac1 	.word	0x00005ac1
    59f0:	00005ae1 	.word	0x00005ae1
    59f4:	00005b01 	.word	0x00005b01
    59f8:	00005b21 	.word	0x00005b21
    59fc:	00005b41 	.word	0x00005b41
    5a00:	00005b61 	.word	0x00005b61
    5a04:	00005b81 	.word	0x00005b81
    5a08:	00005ba1 	.word	0x00005ba1
    5a0c:	00005bc1 	.word	0x00005bc1
    5a10:	00005be1 	.word	0x00005be1
    5a14:	00005c01 	.word	0x00005c01
    5a18:	00005c21 	.word	0x00005c21
    5a1c:	00005c41 	.word	0x00005c41
	case MSS_MAC_RX_INTERRUPTS:
		returnval = g_mss_mac.statistics.rx_interrupts;
    5a20:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5a24:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5a28:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
    5a2c:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5a30:	f893 30ec 	ldrb.w	r3, [r3, #236]	; 0xec
    5a34:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5a38:	ea43 0302 	orr.w	r3, r3, r2
    5a3c:	60fb      	str	r3, [r7, #12]
        break;
    5a3e:	e10e      	b.n	5c5e <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_FILTERING_FAIL:
		returnval = g_mss_mac.statistics.rx_filtering_fail;
    5a40:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5a44:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5a48:	f8d3 20ec 	ldr.w	r2, [r3, #236]	; 0xec
    5a4c:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5a50:	f893 30f0 	ldrb.w	r3, [r3, #240]	; 0xf0
    5a54:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5a58:	ea43 0302 	orr.w	r3, r3, r2
    5a5c:	60fb      	str	r3, [r7, #12]
        break;
    5a5e:	e0fe      	b.n	5c5e <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_DESCRIPTOR_ERROR:
		returnval = g_mss_mac.statistics.rx_descriptor_error;
    5a60:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5a64:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5a68:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
    5a6c:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5a70:	f893 30f4 	ldrb.w	r3, [r3, #244]	; 0xf4
    5a74:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5a78:	ea43 0302 	orr.w	r3, r3, r2
    5a7c:	60fb      	str	r3, [r7, #12]
        break;
    5a7e:	e0ee      	b.n	5c5e <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_RUNT_FRAME:
		returnval = g_mss_mac.statistics.rx_runt_frame;
    5a80:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5a84:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5a88:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
    5a8c:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5a90:	f893 30f8 	ldrb.w	r3, [r3, #248]	; 0xf8
    5a94:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5a98:	ea43 0302 	orr.w	r3, r3, r2
    5a9c:	60fb      	str	r3, [r7, #12]
        break;
    5a9e:	e0de      	b.n	5c5e <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_NOT_FIRST:
		returnval = g_mss_mac.statistics.rx_not_first;
    5aa0:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5aa4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5aa8:	f8d3 20f8 	ldr.w	r2, [r3, #248]	; 0xf8
    5aac:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5ab0:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
    5ab4:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5ab8:	ea43 0302 	orr.w	r3, r3, r2
    5abc:	60fb      	str	r3, [r7, #12]
        break;
    5abe:	e0ce      	b.n	5c5e <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_NOT_LAST:
		returnval = g_mss_mac.statistics.rx_not_last;
    5ac0:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5ac4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5ac8:	f8d3 20fc 	ldr.w	r2, [r3, #252]	; 0xfc
    5acc:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5ad0:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
    5ad4:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5ad8:	ea43 0302 	orr.w	r3, r3, r2
    5adc:	60fb      	str	r3, [r7, #12]
        break;
    5ade:	e0be      	b.n	5c5e <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_FRAME_TOO_LONG:
		returnval = g_mss_mac.statistics.rx_frame_too_long;
    5ae0:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5ae4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5ae8:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    5aec:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5af0:	f893 3104 	ldrb.w	r3, [r3, #260]	; 0x104
    5af4:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5af8:	ea43 0302 	orr.w	r3, r3, r2
    5afc:	60fb      	str	r3, [r7, #12]
        break;
    5afe:	e0ae      	b.n	5c5e <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_COLLISION_SEEN:
		returnval = g_mss_mac.statistics.rx_collision_seen;
    5b00:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5b04:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5b08:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    5b0c:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5b10:	f893 3108 	ldrb.w	r3, [r3, #264]	; 0x108
    5b14:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5b18:	ea43 0302 	orr.w	r3, r3, r2
    5b1c:	60fb      	str	r3, [r7, #12]
        break;
    5b1e:	e09e      	b.n	5c5e <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_CRC_ERROR:
		returnval = g_mss_mac.statistics.rx_crc_error;
    5b20:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5b24:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5b28:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
    5b2c:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5b30:	f893 310c 	ldrb.w	r3, [r3, #268]	; 0x10c
    5b34:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5b38:	ea43 0302 	orr.w	r3, r3, r2
    5b3c:	60fb      	str	r3, [r7, #12]
        break;
    5b3e:	e08e      	b.n	5c5e <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_FIFO_OVERFLOW:
		returnval = g_mss_mac.statistics.rx_fifo_overflow;
    5b40:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5b44:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5b48:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    5b4c:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5b50:	f893 3110 	ldrb.w	r3, [r3, #272]	; 0x110
    5b54:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5b58:	ea43 0302 	orr.w	r3, r3, r2
    5b5c:	60fb      	str	r3, [r7, #12]
        break;
    5b5e:	e07e      	b.n	5c5e <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_RX_MISSED_FRAME:
		returnval = g_mss_mac.statistics.rx_missed_frame;
    5b60:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5b64:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5b68:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    5b6c:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5b70:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
    5b74:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5b78:	ea43 0302 	orr.w	r3, r3, r2
    5b7c:	60fb      	str	r3, [r7, #12]
        break;
    5b7e:	e06e      	b.n	5c5e <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_TX_INTERRUPTS:
		returnval = g_mss_mac.statistics.tx_interrupts;
    5b80:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5b84:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5b88:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
    5b8c:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5b90:	f893 3118 	ldrb.w	r3, [r3, #280]	; 0x118
    5b94:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5b98:	ea43 0302 	orr.w	r3, r3, r2
    5b9c:	60fb      	str	r3, [r7, #12]
        break;
    5b9e:	e05e      	b.n	5c5e <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_TX_LOSS_OF_CARRIER:
		returnval = g_mss_mac.statistics.tx_loss_of_carrier;
    5ba0:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5ba4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5ba8:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    5bac:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5bb0:	f893 311c 	ldrb.w	r3, [r3, #284]	; 0x11c
    5bb4:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5bb8:	ea43 0302 	orr.w	r3, r3, r2
    5bbc:	60fb      	str	r3, [r7, #12]
        break;
    5bbe:	e04e      	b.n	5c5e <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_TX_NO_CARRIER:
		returnval = g_mss_mac.statistics.tx_no_carrier;
    5bc0:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5bc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5bc8:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
    5bcc:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5bd0:	f893 3120 	ldrb.w	r3, [r3, #288]	; 0x120
    5bd4:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5bd8:	ea43 0302 	orr.w	r3, r3, r2
    5bdc:	60fb      	str	r3, [r7, #12]
        break;
    5bde:	e03e      	b.n	5c5e <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_TX_LATE_COLLISION:
		returnval = g_mss_mac.statistics.tx_late_collision;
    5be0:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5be4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5be8:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    5bec:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5bf0:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
    5bf4:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5bf8:	ea43 0302 	orr.w	r3, r3, r2
    5bfc:	60fb      	str	r3, [r7, #12]
        break;
    5bfe:	e02e      	b.n	5c5e <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_TX_EXCESSIVE_COLLISION:
		returnval = g_mss_mac.statistics.tx_excessive_collision;
    5c00:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5c04:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5c08:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    5c0c:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5c10:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
    5c14:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5c18:	ea43 0302 	orr.w	r3, r3, r2
    5c1c:	60fb      	str	r3, [r7, #12]
        break;
    5c1e:	e01e      	b.n	5c5e <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_TX_COLLISION_COUNT:
		returnval = g_mss_mac.statistics.tx_collision_count;
    5c20:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5c24:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5c28:	f8d3 2128 	ldr.w	r2, [r3, #296]	; 0x128
    5c2c:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5c30:	f893 312c 	ldrb.w	r3, [r3, #300]	; 0x12c
    5c34:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5c38:	ea43 0302 	orr.w	r3, r3, r2
    5c3c:	60fb      	str	r3, [r7, #12]
        break;
    5c3e:	e00e      	b.n	5c5e <MSS_MAC_get_statistics+0x2a6>
	case MSS_MAC_TX_UNDERFLOW_ERROR:
		returnval = g_mss_mac.statistics.tx_underflow_error;
    5c40:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5c44:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5c48:	f8d3 212c 	ldr.w	r2, [r3, #300]	; 0x12c
    5c4c:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5c50:	f893 3130 	ldrb.w	r3, [r3, #304]	; 0x130
    5c54:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5c58:	ea43 0302 	orr.w	r3, r3, r2
    5c5c:	60fb      	str	r3, [r7, #12]
        break;
    default:
        break;
	}

	return returnval;
    5c5e:	68fb      	ldr	r3, [r7, #12]
}
    5c60:	4618      	mov	r0, r3
    5c62:	f107 0714 	add.w	r7, r7, #20
    5c66:	46bd      	mov	sp, r7
    5c68:	bc80      	pop	{r7}
    5c6a:	4770      	bx	lr

00005c6c <MSS_MAC_prepare_rx_descriptor>:
void
MSS_MAC_prepare_rx_descriptor
(
    void
)
{
    5c6c:	b580      	push	{r7, lr}
    5c6e:	b082      	sub	sp, #8
    5c70:	af00      	add	r7, sp, #0
	uint32_t desc;

	/* update counters */
	desc = g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0;
    5c72:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5c76:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5c7a:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    5c7e:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5c82:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5c86:	ea4f 1202 	mov.w	r2, r2, lsl #4
    5c8a:	4413      	add	r3, r2
    5c8c:	f103 0398 	add.w	r3, r3, #152	; 0x98
    5c90:	681b      	ldr	r3, [r3, #0]
    5c92:	607b      	str	r3, [r7, #4]
	if( (desc & RDES0_FF) != 0u ) {
    5c94:	687b      	ldr	r3, [r7, #4]
    5c96:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
    5c9a:	2b00      	cmp	r3, #0
    5c9c:	d027      	beq.n	5cee <MSS_MAC_prepare_rx_descriptor+0x82>
		g_mss_mac.statistics.rx_filtering_fail++;
    5c9e:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5ca2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5ca6:	f8d3 20ec 	ldr.w	r2, [r3, #236]	; 0xec
    5caa:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5cae:	f893 30f0 	ldrb.w	r3, [r3, #240]	; 0xf0
    5cb2:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5cb6:	ea43 0302 	orr.w	r3, r3, r2
    5cba:	f103 0201 	add.w	r2, r3, #1
    5cbe:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5cc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5cc6:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    5cca:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5cce:	f8d3 00ec 	ldr.w	r0, [r3, #236]	; 0xec
    5cd2:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    5cd6:	ea40 0101 	orr.w	r1, r0, r1
    5cda:	f8c3 10ec 	str.w	r1, [r3, #236]	; 0xec
    5cde:	ea4f 6212 	mov.w	r2, r2, lsr #24
    5ce2:	f04f 0100 	mov.w	r1, #0
    5ce6:	ea41 0202 	orr.w	r2, r1, r2
    5cea:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
	}
	if( (desc & RDES0_DE) != 0u ) {
    5cee:	687b      	ldr	r3, [r7, #4]
    5cf0:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    5cf4:	2b00      	cmp	r3, #0
    5cf6:	d027      	beq.n	5d48 <MSS_MAC_prepare_rx_descriptor+0xdc>
		g_mss_mac.statistics.rx_descriptor_error++;
    5cf8:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5cfc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5d00:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
    5d04:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5d08:	f893 30f4 	ldrb.w	r3, [r3, #244]	; 0xf4
    5d0c:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5d10:	ea43 0302 	orr.w	r3, r3, r2
    5d14:	f103 0201 	add.w	r2, r3, #1
    5d18:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5d1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5d20:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    5d24:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5d28:	f8d3 00f0 	ldr.w	r0, [r3, #240]	; 0xf0
    5d2c:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    5d30:	ea40 0101 	orr.w	r1, r0, r1
    5d34:	f8c3 10f0 	str.w	r1, [r3, #240]	; 0xf0
    5d38:	ea4f 6212 	mov.w	r2, r2, lsr #24
    5d3c:	f04f 0100 	mov.w	r1, #0
    5d40:	ea41 0202 	orr.w	r2, r1, r2
    5d44:	f883 20f4 	strb.w	r2, [r3, #244]	; 0xf4
	}
	if( (desc & RDES0_RF) != 0u ) {
    5d48:	687b      	ldr	r3, [r7, #4]
    5d4a:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    5d4e:	2b00      	cmp	r3, #0
    5d50:	d027      	beq.n	5da2 <MSS_MAC_prepare_rx_descriptor+0x136>
		g_mss_mac.statistics.rx_runt_frame++;
    5d52:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5d56:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5d5a:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
    5d5e:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5d62:	f893 30f8 	ldrb.w	r3, [r3, #248]	; 0xf8
    5d66:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5d6a:	ea43 0302 	orr.w	r3, r3, r2
    5d6e:	f103 0201 	add.w	r2, r3, #1
    5d72:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5d76:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5d7a:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    5d7e:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5d82:	f8d3 00f4 	ldr.w	r0, [r3, #244]	; 0xf4
    5d86:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    5d8a:	ea40 0101 	orr.w	r1, r0, r1
    5d8e:	f8c3 10f4 	str.w	r1, [r3, #244]	; 0xf4
    5d92:	ea4f 6212 	mov.w	r2, r2, lsr #24
    5d96:	f04f 0100 	mov.w	r1, #0
    5d9a:	ea41 0202 	orr.w	r2, r1, r2
    5d9e:	f883 20f8 	strb.w	r2, [r3, #248]	; 0xf8
	}
	if( (desc & RDES0_FS) == 0u ) {
    5da2:	687b      	ldr	r3, [r7, #4]
    5da4:	f403 7300 	and.w	r3, r3, #512	; 0x200
    5da8:	2b00      	cmp	r3, #0
    5daa:	d127      	bne.n	5dfc <MSS_MAC_prepare_rx_descriptor+0x190>
		g_mss_mac.statistics.rx_not_first++;
    5dac:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5db0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5db4:	f8d3 20f8 	ldr.w	r2, [r3, #248]	; 0xf8
    5db8:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5dbc:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
    5dc0:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5dc4:	ea43 0302 	orr.w	r3, r3, r2
    5dc8:	f103 0201 	add.w	r2, r3, #1
    5dcc:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5dd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5dd4:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    5dd8:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5ddc:	f8d3 00f8 	ldr.w	r0, [r3, #248]	; 0xf8
    5de0:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    5de4:	ea40 0101 	orr.w	r1, r0, r1
    5de8:	f8c3 10f8 	str.w	r1, [r3, #248]	; 0xf8
    5dec:	ea4f 6212 	mov.w	r2, r2, lsr #24
    5df0:	f04f 0100 	mov.w	r1, #0
    5df4:	ea41 0202 	orr.w	r2, r1, r2
    5df8:	f883 20fc 	strb.w	r2, [r3, #252]	; 0xfc
	}
	if( (desc & RDES0_LS) == 0u ) {
    5dfc:	687b      	ldr	r3, [r7, #4]
    5dfe:	f403 7380 	and.w	r3, r3, #256	; 0x100
    5e02:	2b00      	cmp	r3, #0
    5e04:	d127      	bne.n	5e56 <MSS_MAC_prepare_rx_descriptor+0x1ea>
		g_mss_mac.statistics.rx_not_last++;
    5e06:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5e0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5e0e:	f8d3 20fc 	ldr.w	r2, [r3, #252]	; 0xfc
    5e12:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5e16:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
    5e1a:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5e1e:	ea43 0302 	orr.w	r3, r3, r2
    5e22:	f103 0201 	add.w	r2, r3, #1
    5e26:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5e2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5e2e:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    5e32:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5e36:	f8d3 00fc 	ldr.w	r0, [r3, #252]	; 0xfc
    5e3a:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    5e3e:	ea40 0101 	orr.w	r1, r0, r1
    5e42:	f8c3 10fc 	str.w	r1, [r3, #252]	; 0xfc
    5e46:	ea4f 6212 	mov.w	r2, r2, lsr #24
    5e4a:	f04f 0100 	mov.w	r1, #0
    5e4e:	ea41 0202 	orr.w	r2, r1, r2
    5e52:	f883 2100 	strb.w	r2, [r3, #256]	; 0x100
	}
	if( (desc & RDES0_TL) != 0u ) {
    5e56:	687b      	ldr	r3, [r7, #4]
    5e58:	f003 0380 	and.w	r3, r3, #128	; 0x80
    5e5c:	2b00      	cmp	r3, #0
    5e5e:	d027      	beq.n	5eb0 <MSS_MAC_prepare_rx_descriptor+0x244>
		g_mss_mac.statistics.rx_frame_too_long++;
    5e60:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5e64:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5e68:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    5e6c:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5e70:	f893 3104 	ldrb.w	r3, [r3, #260]	; 0x104
    5e74:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5e78:	ea43 0302 	orr.w	r3, r3, r2
    5e7c:	f103 0201 	add.w	r2, r3, #1
    5e80:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5e84:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5e88:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    5e8c:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5e90:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
    5e94:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    5e98:	ea40 0101 	orr.w	r1, r0, r1
    5e9c:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
    5ea0:	ea4f 6212 	mov.w	r2, r2, lsr #24
    5ea4:	f04f 0100 	mov.w	r1, #0
    5ea8:	ea41 0202 	orr.w	r2, r1, r2
    5eac:	f883 2104 	strb.w	r2, [r3, #260]	; 0x104
	}
	if( (desc & RDES0_CS) != 0u ) {
    5eb0:	687b      	ldr	r3, [r7, #4]
    5eb2:	f003 0340 	and.w	r3, r3, #64	; 0x40
    5eb6:	2b00      	cmp	r3, #0
    5eb8:	d027      	beq.n	5f0a <MSS_MAC_prepare_rx_descriptor+0x29e>
		g_mss_mac.statistics.rx_collision_seen++;
    5eba:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5ebe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5ec2:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    5ec6:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5eca:	f893 3108 	ldrb.w	r3, [r3, #264]	; 0x108
    5ece:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5ed2:	ea43 0302 	orr.w	r3, r3, r2
    5ed6:	f103 0201 	add.w	r2, r3, #1
    5eda:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5ede:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5ee2:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    5ee6:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5eea:	f8d3 0104 	ldr.w	r0, [r3, #260]	; 0x104
    5eee:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    5ef2:	ea40 0101 	orr.w	r1, r0, r1
    5ef6:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
    5efa:	ea4f 6212 	mov.w	r2, r2, lsr #24
    5efe:	f04f 0100 	mov.w	r1, #0
    5f02:	ea41 0202 	orr.w	r2, r1, r2
    5f06:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
	}
	if( (desc & RDES0_CE) != 0u ) {
    5f0a:	687b      	ldr	r3, [r7, #4]
    5f0c:	f003 0302 	and.w	r3, r3, #2
    5f10:	2b00      	cmp	r3, #0
    5f12:	d027      	beq.n	5f64 <MSS_MAC_prepare_rx_descriptor+0x2f8>
		g_mss_mac.statistics.rx_crc_error++;
    5f14:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5f18:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5f1c:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
    5f20:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5f24:	f893 310c 	ldrb.w	r3, [r3, #268]	; 0x10c
    5f28:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5f2c:	ea43 0302 	orr.w	r3, r3, r2
    5f30:	f103 0201 	add.w	r2, r3, #1
    5f34:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5f38:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5f3c:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    5f40:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5f44:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
    5f48:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    5f4c:	ea40 0101 	orr.w	r1, r0, r1
    5f50:	f8c3 1108 	str.w	r1, [r3, #264]	; 0x108
    5f54:	ea4f 6212 	mov.w	r2, r2, lsr #24
    5f58:	f04f 0100 	mov.w	r1, #0
    5f5c:	ea41 0202 	orr.w	r2, r1, r2
    5f60:	f883 210c 	strb.w	r2, [r3, #268]	; 0x10c
	}

	desc = MAC->CSR8;
    5f64:	f243 0300 	movw	r3, #12288	; 0x3000
    5f68:	f2c4 0300 	movt	r3, #16384	; 0x4000
    5f6c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    5f6e:	607b      	str	r3, [r7, #4]
	g_mss_mac.statistics.rx_fifo_overflow +=
    5f70:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5f74:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5f78:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    5f7c:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5f80:	f893 3110 	ldrb.w	r3, [r3, #272]	; 0x110
    5f84:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5f88:	ea43 0302 	orr.w	r3, r3, r2
    5f8c:	461a      	mov	r2, r3
		(desc & (CSR8_OCO_MASK|CSR8_FOC_MASK)) >> CSR8_FOC_SHIFT;
    5f8e:	6879      	ldr	r1, [r7, #4]
    5f90:	f240 0300 	movw	r3, #0
    5f94:	f6c1 73fe 	movt	r3, #8190	; 0x1ffe
    5f98:	ea01 0303 	and.w	r3, r1, r3
    5f9c:	ea4f 4353 	mov.w	r3, r3, lsr #17
	if( (desc & RDES0_CE) != 0u ) {
		g_mss_mac.statistics.rx_crc_error++;
	}

	desc = MAC->CSR8;
	g_mss_mac.statistics.rx_fifo_overflow +=
    5fa0:	441a      	add	r2, r3
    5fa2:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5fa6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5faa:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    5fae:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5fb2:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
    5fb6:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    5fba:	ea40 0101 	orr.w	r1, r0, r1
    5fbe:	f8c3 110c 	str.w	r1, [r3, #268]	; 0x10c
    5fc2:	ea4f 6212 	mov.w	r2, r2, lsr #24
    5fc6:	f04f 0100 	mov.w	r1, #0
    5fca:	ea41 0202 	orr.w	r2, r1, r2
    5fce:	f883 2110 	strb.w	r2, [r3, #272]	; 0x110
		(desc & (CSR8_OCO_MASK|CSR8_FOC_MASK)) >> CSR8_FOC_SHIFT;
	g_mss_mac.statistics.rx_missed_frame +=
    5fd2:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    5fd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5fda:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    5fde:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5fe2:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
    5fe6:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5fea:	ea43 0302 	orr.w	r3, r3, r2
    5fee:	461a      	mov	r2, r3
		(desc & (CSR8_MFO_MASK|CSR8_MFC_MASK));
    5ff0:	687b      	ldr	r3, [r7, #4]
    5ff2:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    5ff6:	f423 037e 	bic.w	r3, r3, #16646144	; 0xfe0000
	}

	desc = MAC->CSR8;
	g_mss_mac.statistics.rx_fifo_overflow +=
		(desc & (CSR8_OCO_MASK|CSR8_FOC_MASK)) >> CSR8_FOC_SHIFT;
	g_mss_mac.statistics.rx_missed_frame +=
    5ffa:	441a      	add	r2, r3
    5ffc:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    6000:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6004:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
    6008:	ea4f 2101 	mov.w	r1, r1, lsl #8
    600c:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
    6010:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    6014:	ea40 0101 	orr.w	r1, r0, r1
    6018:	f8c3 1110 	str.w	r1, [r3, #272]	; 0x110
    601c:	ea4f 6212 	mov.w	r2, r2, lsr #24
    6020:	f04f 0100 	mov.w	r1, #0
    6024:	ea41 0202 	orr.w	r2, r1, r2
    6028:	f883 2114 	strb.w	r2, [r3, #276]	; 0x114
		(desc & (CSR8_MFO_MASK|CSR8_MFC_MASK));

	/* Give ownership of descriptor to the MAC */
	g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 = RDES0_OWN;
    602c:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    6030:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6034:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    6038:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    603c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6040:	ea4f 1202 	mov.w	r2, r2, lsl #4
    6044:	4413      	add	r3, r2
    6046:	f103 0398 	add.w	r3, r3, #152	; 0x98
    604a:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    604e:	601a      	str	r2, [r3, #0]
	g_mss_mac.rx_desc_index = (g_mss_mac.rx_desc_index + 1u) % RX_RING_SIZE;
    6050:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    6054:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6058:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    605c:	f103 0101 	add.w	r1, r3, #1
    6060:	f64c 43cd 	movw	r3, #52429	; 0xcccd
    6064:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
    6068:	fba3 2301 	umull	r2, r3, r3, r1
    606c:	ea4f 0293 	mov.w	r2, r3, lsr #2
    6070:	4613      	mov	r3, r2
    6072:	ea4f 0383 	mov.w	r3, r3, lsl #2
    6076:	4413      	add	r3, r2
    6078:	ebc3 0201 	rsb	r2, r3, r1
    607c:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    6080:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6084:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

	/* Start receive */
    MAC_start_receiving();
    6088:	f000 fa28 	bl	64dc <MAC_start_receiving>
}
    608c:	f107 0708 	add.w	r7, r7, #8
    6090:	46bd      	mov	sp, r7
    6092:	bd80      	pop	{r7, pc}

00006094 <MAC_send_setup_frame>:
static int32_t
MAC_send_setup_frame
(
    void
)
{
    6094:	b580      	push	{r7, lr}
    6096:	b0be      	sub	sp, #248	; 0xf8
    6098:	af00      	add	r7, sp, #0
	uint8_t *data;
	int32_t a,b,c,d;
	int32_t ret;

    /* prepare descriptor */
	descriptor.descriptor_0 = TDES0_OWN;
    609a:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    609e:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
	descriptor.descriptor_1 = TDES1_SET | TDES1_TER |
    60a2:	f240 03c0 	movw	r3, #192	; 0xc0
    60a6:	f6c0 2300 	movt	r3, #2560	; 0xa00
    60aa:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
		(sizeof(frame_data) << TDES1_TBS1_OFFSET);

	if( (g_mss_mac.flags & FLAG_PERFECT_FILTERING) == 0u ) {
    60ae:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    60b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    60b6:	791b      	ldrb	r3, [r3, #4]
    60b8:	f003 0302 	and.w	r3, r3, #2
    60bc:	2b00      	cmp	r3, #0
    60be:	d105      	bne.n	60cc <MAC_send_setup_frame+0x38>
		descriptor.descriptor_1 |= TDES1_FT0;
    60c0:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
    60c4:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
    60c8:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	}

	descriptor.buffer_1 = (uint32_t)frame_data;
    60cc:	f107 0304 	add.w	r3, r7, #4
    60d0:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
	descriptor.buffer_2 = 0u;
    60d4:	f04f 0300 	mov.w	r3, #0
    60d8:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0

    /* prepare frame */
    if( (g_mss_mac.flags & FLAG_PERFECT_FILTERING) != 0u ) {
    60dc:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    60e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    60e4:	791b      	ldrb	r3, [r3, #4]
    60e6:	f003 0302 	and.w	r3, r3, #2
    60ea:	2b00      	cmp	r3, #0
    60ec:	d00c      	beq.n	6108 <MAC_send_setup_frame+0x74>
    	b = 0;
    60ee:	f04f 0300 	mov.w	r3, #0
    60f2:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    	d = 12;
    60f6:	f04f 030c 	mov.w	r3, #12
    60fa:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    	c = 90;
    60fe:	f04f 035a 	mov.w	r3, #90	; 0x5a
    6102:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    6106:	e00b      	b.n	6120 <MAC_send_setup_frame+0x8c>
    } else {
    	b = 156;
    6108:	f04f 039c 	mov.w	r3, #156	; 0x9c
    610c:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    	d = 0;
    6110:	f04f 0300 	mov.w	r3, #0
    6114:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    	c = 64;
    6118:	f04f 0340 	mov.w	r3, #64	; 0x40
    611c:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    }

   	data = g_mss_mac.mac_address;
    6120:	4bb4      	ldr	r3, [pc, #720]	; (63f4 <MAC_send_setup_frame+0x360>)
    6122:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
   	frame_data[b] = data[0];
    6126:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
    612a:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    612e:	7812      	ldrb	r2, [r2, #0]
    6130:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    6134:	440b      	add	r3, r1
    6136:	f803 2cf4 	strb.w	r2, [r3, #-244]
   	frame_data[b+1] = data[1];
    613a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
    613e:	f103 0301 	add.w	r3, r3, #1
    6142:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    6146:	f102 0201 	add.w	r2, r2, #1
    614a:	7812      	ldrb	r2, [r2, #0]
    614c:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    6150:	440b      	add	r3, r1
    6152:	f803 2cf4 	strb.w	r2, [r3, #-244]
   	frame_data[b+4] = data[2];
    6156:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
    615a:	f103 0304 	add.w	r3, r3, #4
    615e:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    6162:	f102 0202 	add.w	r2, r2, #2
    6166:	7812      	ldrb	r2, [r2, #0]
    6168:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    616c:	440b      	add	r3, r1
    616e:	f803 2cf4 	strb.w	r2, [r3, #-244]
   	frame_data[b+5] = data[3];
    6172:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
    6176:	f103 0305 	add.w	r3, r3, #5
    617a:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    617e:	f102 0203 	add.w	r2, r2, #3
    6182:	7812      	ldrb	r2, [r2, #0]
    6184:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    6188:	440b      	add	r3, r1
    618a:	f803 2cf4 	strb.w	r2, [r3, #-244]
   	frame_data[b+8] = data[4];
    618e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
    6192:	f103 0308 	add.w	r3, r3, #8
    6196:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    619a:	f102 0204 	add.w	r2, r2, #4
    619e:	7812      	ldrb	r2, [r2, #0]
    61a0:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    61a4:	440b      	add	r3, r1
    61a6:	f803 2cf4 	strb.w	r2, [r3, #-244]
   	frame_data[b+9] = data[5];
    61aa:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
    61ae:	f103 0309 	add.w	r3, r3, #9
    61b2:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    61b6:	f102 0205 	add.w	r2, r2, #5
    61ba:	7812      	ldrb	r2, [r2, #0]
    61bc:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    61c0:	440b      	add	r3, r1
    61c2:	f803 2cf4 	strb.w	r2, [r3, #-244]

   	data = g_mss_mac.mac_filter_data;
    61c6:	4b8c      	ldr	r3, [pc, #560]	; (63f8 <MAC_send_setup_frame+0x364>)
    61c8:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
    for( a = 0; a < c; ) {
    61cc:	f04f 0300 	mov.w	r3, #0
    61d0:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    61d4:	e081      	b.n	62da <MAC_send_setup_frame+0x246>
		frame_data[d] = data[a++];
    61d6:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    61da:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
    61de:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    61e2:	440a      	add	r2, r1
    61e4:	7812      	ldrb	r2, [r2, #0]
    61e6:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    61ea:	440b      	add	r3, r1
    61ec:	f803 2cf4 	strb.w	r2, [r3, #-244]
    61f0:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    61f4:	f103 0301 	add.w	r3, r3, #1
    61f8:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
	   	frame_data[d+1] = data[a++];
    61fc:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    6200:	f103 0301 	add.w	r3, r3, #1
    6204:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
    6208:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    620c:	440a      	add	r2, r1
    620e:	7812      	ldrb	r2, [r2, #0]
    6210:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    6214:	440b      	add	r3, r1
    6216:	f803 2cf4 	strb.w	r2, [r3, #-244]
    621a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    621e:	f103 0301 	add.w	r3, r3, #1
    6222:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
	   	frame_data[d+4] = data[a++];
    6226:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    622a:	f103 0304 	add.w	r3, r3, #4
    622e:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
    6232:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    6236:	440a      	add	r2, r1
    6238:	7812      	ldrb	r2, [r2, #0]
    623a:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    623e:	440b      	add	r3, r1
    6240:	f803 2cf4 	strb.w	r2, [r3, #-244]
    6244:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    6248:	f103 0301 	add.w	r3, r3, #1
    624c:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
	   	frame_data[d+5] = data[a++];
    6250:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    6254:	f103 0305 	add.w	r3, r3, #5
    6258:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
    625c:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    6260:	440a      	add	r2, r1
    6262:	7812      	ldrb	r2, [r2, #0]
    6264:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    6268:	440b      	add	r3, r1
    626a:	f803 2cf4 	strb.w	r2, [r3, #-244]
    626e:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    6272:	f103 0301 	add.w	r3, r3, #1
    6276:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
	   	frame_data[d+8] = data[a++];
    627a:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    627e:	f103 0308 	add.w	r3, r3, #8
    6282:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
    6286:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    628a:	440a      	add	r2, r1
    628c:	7812      	ldrb	r2, [r2, #0]
    628e:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    6292:	440b      	add	r3, r1
    6294:	f803 2cf4 	strb.w	r2, [r3, #-244]
    6298:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    629c:	f103 0301 	add.w	r3, r3, #1
    62a0:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
	   	frame_data[d+9] = data[a++];
    62a4:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    62a8:	f103 0309 	add.w	r3, r3, #9
    62ac:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
    62b0:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    62b4:	440a      	add	r2, r1
    62b6:	7812      	ldrb	r2, [r2, #0]
    62b8:	f107 01f8 	add.w	r1, r7, #248	; 0xf8
    62bc:	440b      	add	r3, r1
    62be:	f803 2cf4 	strb.w	r2, [r3, #-244]
    62c2:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    62c6:	f103 0301 	add.w	r3, r3, #1
    62ca:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
	   	d += 12;
    62ce:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    62d2:	f103 030c 	add.w	r3, r3, #12
    62d6:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
   	frame_data[b+5] = data[3];
   	frame_data[b+8] = data[4];
   	frame_data[b+9] = data[5];

   	data = g_mss_mac.mac_filter_data;
    for( a = 0; a < c; ) {
    62da:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
    62de:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
    62e2:	429a      	cmp	r2, r3
    62e4:	f6ff af77 	blt.w	61d6 <MAC_send_setup_frame+0x142>
	   	frame_data[d+9] = data[a++];
	   	d += 12;
	}

	/* Stop transmission */
    ret = MAC_stop_transmission();
    62e8:	f000 f88a 	bl	6400 <MAC_stop_transmission>
    62ec:	4603      	mov	r3, r0
    62ee:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    configASSERT( ret == MAC_OK );
    62f2:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
    62f6:	2b00      	cmp	r3, #0
    62f8:	d00a      	beq.n	6310 <MAC_send_setup_frame+0x27c>
    62fa:	f04f 0328 	mov.w	r3, #40	; 0x28
    62fe:	f383 8811 	msr	BASEPRI, r3
    6302:	f3bf 8f6f 	isb	sy
    6306:	f3bf 8f4f 	dsb	sy
    630a:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
    630e:	e7fe      	b.n	630e <MAC_send_setup_frame+0x27a>

    ret = MAC_stop_receiving();
    6310:	f000 f8b4 	bl	647c <MAC_stop_receiving>
    6314:	4603      	mov	r3, r0
    6316:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    configASSERT( ret == MAC_OK );
    631a:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
    631e:	2b00      	cmp	r3, #0
    6320:	d00a      	beq.n	6338 <MAC_send_setup_frame+0x2a4>
    6322:	f04f 0328 	mov.w	r3, #40	; 0x28
    6326:	f383 8811 	msr	BASEPRI, r3
    632a:	f3bf 8f6f 	isb	sy
    632e:	f3bf 8f4f 	dsb	sy
    6332:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
    6336:	e7fe      	b.n	6336 <MAC_send_setup_frame+0x2a2>

    /* Set descriptor */
    MAC->CSR4 = (uint32_t)&descriptor;
    6338:	f243 0300 	movw	r3, #12288	; 0x3000
    633c:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6340:	f107 02c4 	add.w	r2, r7, #196	; 0xc4
    6344:	621a      	str	r2, [r3, #32]

	/* Start transmission */
    MAC_start_transmission();
    6346:	f000 f88b 	bl	6460 <MAC_start_transmission>

    /* Wait until transmission over */
    ret = MAC_OK;
    634a:	f04f 0300 	mov.w	r3, #0
    634e:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    MAC_set_time_out( (uint32_t)SETUP_FRAME_TIME_OUT );
    6352:	f242 7010 	movw	r0, #10000	; 0x2710
    6356:	f000 f921 	bl	659c <MAC_set_time_out>

    while( (((MAC->CSR5 & CSR5_TS_MASK) >> CSR5_TS_SHIFT) !=
    635a:	e00f      	b.n	637c <MAC_send_setup_frame+0x2e8>
    	CSR5_TS_SUSPENDED) && (MAC_OK == ret) )
    {
    	/* transmit poll demand */
    	MAC->CSR1 = 1u;
    635c:	f243 0300 	movw	r3, #12288	; 0x3000
    6360:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6364:	f04f 0201 	mov.w	r2, #1
    6368:	609a      	str	r2, [r3, #8]
    	if( MAC_get_time_out() == 0u ) {
    636a:	f000 f93f 	bl	65ec <MAC_get_time_out>
    636e:	4603      	mov	r3, r0
    6370:	2b00      	cmp	r3, #0
    6372:	d103      	bne.n	637c <MAC_send_setup_frame+0x2e8>
    		ret = MAC_TIME_OUT;
    6374:	f06f 0305 	mvn.w	r3, #5
    6378:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8

    /* Wait until transmission over */
    ret = MAC_OK;
    MAC_set_time_out( (uint32_t)SETUP_FRAME_TIME_OUT );

    while( (((MAC->CSR5 & CSR5_TS_MASK) >> CSR5_TS_SHIFT) !=
    637c:	f243 0300 	movw	r3, #12288	; 0x3000
    6380:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6384:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6386:	f403 03e0 	and.w	r3, r3, #7340032	; 0x700000
    638a:	ea4f 5313 	mov.w	r3, r3, lsr #20
    638e:	2b06      	cmp	r3, #6
    6390:	d003      	beq.n	639a <MAC_send_setup_frame+0x306>
    6392:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
    6396:	2b00      	cmp	r3, #0
    6398:	d0e0      	beq.n	635c <MAC_send_setup_frame+0x2c8>
    	if( MAC_get_time_out() == 0u ) {
    		ret = MAC_TIME_OUT;
    	}
    }

	MAC_CHECK( MAC_stop_transmission() == MAC_OK, MAC_FAIL );
    639a:	f000 f831 	bl	6400 <MAC_stop_transmission>
    639e:	4603      	mov	r3, r0
    63a0:	2b00      	cmp	r3, #0
    63a2:	d016      	beq.n	63d2 <MAC_send_setup_frame+0x33e>
    63a4:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    63a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    63ac:	f04f 32ff 	mov.w	r2, #4294967295
    63b0:	715a      	strb	r2, [r3, #5]
    63b2:	f000 f825 	bl	6400 <MAC_stop_transmission>
    63b6:	4603      	mov	r3, r0
    63b8:	2b00      	cmp	r3, #0
    63ba:	d00a      	beq.n	63d2 <MAC_send_setup_frame+0x33e>
    63bc:	f04f 0328 	mov.w	r3, #40	; 0x28
    63c0:	f383 8811 	msr	BASEPRI, r3
    63c4:	f3bf 8f6f 	isb	sy
    63c8:	f3bf 8f4f 	dsb	sy
    63cc:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
    63d0:	e7fe      	b.n	63d0 <MAC_send_setup_frame+0x33c>

    /* Set tx descriptor */
    MAC->CSR4 = (uint32_t)g_mss_mac.tx_descriptors;
    63d2:	f243 0300 	movw	r3, #12288	; 0x3000
    63d6:	f2c4 0300 	movt	r3, #16384	; 0x4000
    63da:	4a08      	ldr	r2, [pc, #32]	; (63fc <MAC_send_setup_frame+0x368>)
    63dc:	621a      	str	r2, [r3, #32]

    /* Start receiving and transmission */
    MAC_start_receiving();
    63de:	f000 f87d 	bl	64dc <MAC_start_receiving>
    MAC_start_transmission();
    63e2:	f000 f83d 	bl	6460 <MAC_start_transmission>

    return ret;
    63e6:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
}
    63ea:	4618      	mov	r0, r3
    63ec:	f107 07f8 	add.w	r7, r7, #248	; 0xf8
    63f0:	46bd      	mov	sp, r7
    63f2:	bd80      	pop	{r7, pc}
    63f4:	2000aae6 	.word	0x2000aae6
    63f8:	2000aaec 	.word	0x2000aaec
    63fc:	2000ab54 	.word	0x2000ab54

00006400 <MAC_stop_transmission>:
static int32_t
MAC_stop_transmission
(
    void
)
{
    6400:	b580      	push	{r7, lr}
    6402:	b082      	sub	sp, #8
    6404:	af00      	add	r7, sp, #0
    int32_t retval = MAC_OK;
    6406:	f04f 0300 	mov.w	r3, #0
    640a:	607b      	str	r3, [r7, #4]
    MAC_set_time_out( (uint16_t)STATE_CHANGE_TIME_OUT );
    640c:	f242 7010 	movw	r0, #10000	; 0x2710
    6410:	f000 f8c4 	bl	659c <MAC_set_time_out>

	while( (((MAC->CSR5 & CSR5_TS_MASK) >> CSR5_TS_SHIFT) !=
    6414:	e00f      	b.n	6436 <MAC_stop_transmission+0x36>
		CSR5_TS_STOPPED) && (retval == MAC_OK) )
	{
    	MAC_BITBAND->CSR6_ST = 0u;
    6416:	f240 0300 	movw	r3, #0
    641a:	f2c4 2306 	movt	r3, #16902	; 0x4206
    641e:	f04f 0200 	mov.w	r2, #0
    6422:	f8c3 2634 	str.w	r2, [r3, #1588]	; 0x634
    	if( MAC_get_time_out() == 0u ) {
    6426:	f000 f8e1 	bl	65ec <MAC_get_time_out>
    642a:	4603      	mov	r3, r0
    642c:	2b00      	cmp	r3, #0
    642e:	d102      	bne.n	6436 <MAC_stop_transmission+0x36>
    		retval = MAC_TIME_OUT;
    6430:	f06f 0305 	mvn.w	r3, #5
    6434:	607b      	str	r3, [r7, #4]
)
{
    int32_t retval = MAC_OK;
    MAC_set_time_out( (uint16_t)STATE_CHANGE_TIME_OUT );

	while( (((MAC->CSR5 & CSR5_TS_MASK) >> CSR5_TS_SHIFT) !=
    6436:	f243 0300 	movw	r3, #12288	; 0x3000
    643a:	f2c4 0300 	movt	r3, #16384	; 0x4000
    643e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6440:	f403 03e0 	and.w	r3, r3, #7340032	; 0x700000
    6444:	ea4f 5313 	mov.w	r3, r3, lsr #20
    6448:	2b00      	cmp	r3, #0
    644a:	d002      	beq.n	6452 <MAC_stop_transmission+0x52>
    644c:	687b      	ldr	r3, [r7, #4]
    644e:	2b00      	cmp	r3, #0
    6450:	d0e1      	beq.n	6416 <MAC_stop_transmission+0x16>
    	MAC_BITBAND->CSR6_ST = 0u;
    	if( MAC_get_time_out() == 0u ) {
    		retval = MAC_TIME_OUT;
    	}
	}
	return retval;
    6452:	687b      	ldr	r3, [r7, #4]
}
    6454:	4618      	mov	r0, r3
    6456:	f107 0708 	add.w	r7, r7, #8
    645a:	46bd      	mov	sp, r7
    645c:	bd80      	pop	{r7, pc}
    645e:	bf00      	nop

00006460 <MAC_start_transmission>:
static void
MAC_start_transmission
(
    void
)
{
    6460:	b480      	push	{r7}
    6462:	af00      	add	r7, sp, #0
    MAC_BITBAND->CSR6_ST = 1u;
    6464:	f240 0300 	movw	r3, #0
    6468:	f2c4 2306 	movt	r3, #16902	; 0x4206
    646c:	f04f 0201 	mov.w	r2, #1
    6470:	f8c3 2634 	str.w	r2, [r3, #1588]	; 0x634
}
    6474:	46bd      	mov	sp, r7
    6476:	bc80      	pop	{r7}
    6478:	4770      	bx	lr
    647a:	bf00      	nop

0000647c <MAC_stop_receiving>:
static int32_t
MAC_stop_receiving
(
    void
)
{
    647c:	b580      	push	{r7, lr}
    647e:	b082      	sub	sp, #8
    6480:	af00      	add	r7, sp, #0
    int32_t retval = MAC_OK;
    6482:	f04f 0300 	mov.w	r3, #0
    6486:	607b      	str	r3, [r7, #4]
    MAC_set_time_out( (uint16_t)STATE_CHANGE_TIME_OUT );
    6488:	f242 7010 	movw	r0, #10000	; 0x2710
    648c:	f000 f886 	bl	659c <MAC_set_time_out>

	while( (((MAC->CSR5 & CSR5_RS_MASK) >> CSR5_RS_SHIFT) != CSR5_RS_STOPPED)
    6490:	e00f      	b.n	64b2 <MAC_stop_receiving+0x36>
            && (retval == MAC_OK) )
	{
    	MAC_BITBAND->CSR6_SR = 0u;
    6492:	f240 0300 	movw	r3, #0
    6496:	f2c4 2306 	movt	r3, #16902	; 0x4206
    649a:	f04f 0200 	mov.w	r2, #0
    649e:	f8c3 2604 	str.w	r2, [r3, #1540]	; 0x604
    	if( MAC_get_time_out() == 0u ) {
    64a2:	f000 f8a3 	bl	65ec <MAC_get_time_out>
    64a6:	4603      	mov	r3, r0
    64a8:	2b00      	cmp	r3, #0
    64aa:	d102      	bne.n	64b2 <MAC_stop_receiving+0x36>
    		retval = MAC_TIME_OUT;
    64ac:	f06f 0305 	mvn.w	r3, #5
    64b0:	607b      	str	r3, [r7, #4]
)
{
    int32_t retval = MAC_OK;
    MAC_set_time_out( (uint16_t)STATE_CHANGE_TIME_OUT );

	while( (((MAC->CSR5 & CSR5_RS_MASK) >> CSR5_RS_SHIFT) != CSR5_RS_STOPPED)
    64b2:	f243 0300 	movw	r3, #12288	; 0x3000
    64b6:	f2c4 0300 	movt	r3, #16384	; 0x4000
    64ba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    64bc:	f403 23c0 	and.w	r3, r3, #393216	; 0x60000
    64c0:	ea4f 4353 	mov.w	r3, r3, lsr #17
    64c4:	2b00      	cmp	r3, #0
    64c6:	d002      	beq.n	64ce <MAC_stop_receiving+0x52>
    64c8:	687b      	ldr	r3, [r7, #4]
    64ca:	2b00      	cmp	r3, #0
    64cc:	d0e1      	beq.n	6492 <MAC_stop_receiving+0x16>
    	if( MAC_get_time_out() == 0u ) {
    		retval = MAC_TIME_OUT;
    	}
	}

	return retval;
    64ce:	687b      	ldr	r3, [r7, #4]
}
    64d0:	4618      	mov	r0, r3
    64d2:	f107 0708 	add.w	r7, r7, #8
    64d6:	46bd      	mov	sp, r7
    64d8:	bd80      	pop	{r7, pc}
    64da:	bf00      	nop

000064dc <MAC_start_receiving>:
static void
MAC_start_receiving
(
    void
)
{
    64dc:	b480      	push	{r7}
    64de:	af00      	add	r7, sp, #0
    MAC_BITBAND->CSR6_SR = 1u;
    64e0:	f240 0300 	movw	r3, #0
    64e4:	f2c4 2306 	movt	r3, #16902	; 0x4206
    64e8:	f04f 0201 	mov.w	r2, #1
    64ec:	f8c3 2604 	str.w	r2, [r3, #1540]	; 0x604
}
    64f0:	46bd      	mov	sp, r7
    64f2:	bc80      	pop	{r7}
    64f4:	4770      	bx	lr
    64f6:	bf00      	nop

000064f8 <MAC_dismiss_bad_frames>:
static int32_t
MAC_dismiss_bad_frames
(
    void
)
{
    64f8:	b580      	push	{r7, lr}
    64fa:	b082      	sub	sp, #8
    64fc:	af00      	add	r7, sp, #0
	int32_t dc = 0;
    64fe:	f04f 0300 	mov.w	r3, #0
    6502:	603b      	str	r3, [r7, #0]
	int8_t cont = 1;
    6504:	f04f 0301 	mov.w	r3, #1
    6508:	71fb      	strb	r3, [r7, #7]

	if( MAC_BITBAND->CSR6_PB != 0u ) {
    650a:	f240 0300 	movw	r3, #0
    650e:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6512:	f8d3 360c 	ldr.w	r3, [r3, #1548]	; 0x60c
    6516:	2b00      	cmp	r3, #0
    6518:	d023      	beq.n	6562 <MAC_dismiss_bad_frames+0x6a>
		/* User wants bad frames too, don't dismiss anything */
		cont = 0;
    651a:	f04f 0300 	mov.w	r3, #0
    651e:	71fb      	strb	r3, [r7, #7]
	}

	while( ( (g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    6520:	e020      	b.n	6564 <MAC_dismiss_bad_frames+0x6c>
            RDES0_OWN) == 0u) && (cont == 1) ) /* Host owns this descriptor */
    {
    	/* check error summary */
    	if( (g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    6522:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    6526:	f2c2 0300 	movt	r3, #8192	; 0x2000
    652a:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    652e:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    6532:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6536:	ea4f 1202 	mov.w	r2, r2, lsl #4
    653a:	4413      	add	r3, r2
    653c:	f103 0398 	add.w	r3, r3, #152	; 0x98
    6540:	681b      	ldr	r3, [r3, #0]
    6542:	f403 4303 	and.w	r3, r3, #33536	; 0x8300
    6546:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    654a:	d006      	beq.n	655a <MAC_dismiss_bad_frames+0x62>
    		(RDES0_ES | RDES0_LS | RDES0_FS)) != (RDES0_LS | RDES0_FS) )
    	{
    		MSS_MAC_prepare_rx_descriptor();
    654c:	f7ff fb8e 	bl	5c6c <MSS_MAC_prepare_rx_descriptor>
    		dc++;
    6550:	683b      	ldr	r3, [r7, #0]
    6552:	f103 0301 	add.w	r3, r3, #1
    6556:	603b      	str	r3, [r7, #0]
    6558:	e004      	b.n	6564 <MAC_dismiss_bad_frames+0x6c>
    	}
        else
        {
    		cont = 0;
    655a:	f04f 0300 	mov.w	r3, #0
    655e:	71fb      	strb	r3, [r7, #7]
    6560:	e000      	b.n	6564 <MAC_dismiss_bad_frames+0x6c>
	if( MAC_BITBAND->CSR6_PB != 0u ) {
		/* User wants bad frames too, don't dismiss anything */
		cont = 0;
	}

	while( ( (g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    6562:	bf00      	nop
    6564:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    6568:	f2c2 0300 	movt	r3, #8192	; 0x2000
    656c:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    6570:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    6574:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6578:	ea4f 1202 	mov.w	r2, r2, lsl #4
    657c:	4413      	add	r3, r2
    657e:	f103 0398 	add.w	r3, r3, #152	; 0x98
    6582:	681b      	ldr	r3, [r3, #0]
    6584:	2b00      	cmp	r3, #0
    6586:	db03      	blt.n	6590 <MAC_dismiss_bad_frames+0x98>
    6588:	f997 3007 	ldrsb.w	r3, [r7, #7]
    658c:	2b01      	cmp	r3, #1
    658e:	d0c8      	beq.n	6522 <MAC_dismiss_bad_frames+0x2a>
        {
    		cont = 0;
    	}
    }

	return dc;
    6590:	683b      	ldr	r3, [r7, #0]
}
    6592:	4618      	mov	r0, r3
    6594:	f107 0708 	add.w	r7, r7, #8
    6598:	46bd      	mov	sp, r7
    659a:	bd80      	pop	{r7, pc}

0000659c <MAC_set_time_out>:
static void
MAC_set_time_out
(
    uint32_t time_out
)
{
    659c:	b480      	push	{r7}
    659e:	b083      	sub	sp, #12
    65a0:	af00      	add	r7, sp, #0
    65a2:	6078      	str	r0, [r7, #4]
	g_mss_mac.time_out_value = (time_out * 122u) / 10u;
    65a4:	687b      	ldr	r3, [r7, #4]
    65a6:	f04f 027a 	mov.w	r2, #122	; 0x7a
    65aa:	fb02 f203 	mul.w	r2, r2, r3
    65ae:	f64c 43cd 	movw	r3, #52429	; 0xcccd
    65b2:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
    65b6:	fba3 1302 	umull	r1, r3, r3, r2
    65ba:	ea4f 02d3 	mov.w	r2, r3, lsr #3
    65be:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    65c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    65c6:	669a      	str	r2, [r3, #104]	; 0x68

	g_mss_mac.last_timer_value = (uint16_t)( MAC->CSR11 & CSR11_TIM_MASK );
    65c8:	f243 0300 	movw	r3, #12288	; 0x3000
    65cc:	f2c4 0300 	movt	r3, #16384	; 0x4000
    65d0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    65d2:	b29a      	uxth	r2, r3
    65d4:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    65d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    65dc:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
}
    65e0:	f107 070c 	add.w	r7, r7, #12
    65e4:	46bd      	mov	sp, r7
    65e6:	bc80      	pop	{r7}
    65e8:	4770      	bx	lr
    65ea:	bf00      	nop

000065ec <MAC_get_time_out>:
static uint32_t
MAC_get_time_out
(
    void
)
{
    65ec:	b480      	push	{r7}
    65ee:	b083      	sub	sp, #12
    65f0:	af00      	add	r7, sp, #0
	uint32_t timer;
	uint32_t time = 0u;
    65f2:	f04f 0300 	mov.w	r3, #0
    65f6:	607b      	str	r3, [r7, #4]

	timer = ( MAC->CSR11 & CSR11_TIM_MASK );
    65f8:	f243 0300 	movw	r3, #12288	; 0x3000
    65fc:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6600:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    6602:	ea4f 4303 	mov.w	r3, r3, lsl #16
    6606:	ea4f 4313 	mov.w	r3, r3, lsr #16
    660a:	603b      	str	r3, [r7, #0]

	if( timer > g_mss_mac.last_timer_value ) {
    660c:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    6610:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6614:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
    6618:	461a      	mov	r2, r3
    661a:	683b      	ldr	r3, [r7, #0]
    661c:	429a      	cmp	r2, r3
    661e:	d202      	bcs.n	6626 <MAC_get_time_out+0x3a>
		time = 0x0000ffffUL;
    6620:	f64f 73ff 	movw	r3, #65535	; 0xffff
    6624:	607b      	str	r3, [r7, #4]
	}
	time += g_mss_mac.last_timer_value - timer;
    6626:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    662a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    662e:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
    6632:	461a      	mov	r2, r3
    6634:	683b      	ldr	r3, [r7, #0]
    6636:	ebc3 0302 	rsb	r3, r3, r2
    663a:	687a      	ldr	r2, [r7, #4]
    663c:	4413      	add	r3, r2
    663e:	607b      	str	r3, [r7, #4]

	if( MAC_BITBAND->CSR6_TTM == 0u ) {
    6640:	f240 0300 	movw	r3, #0
    6644:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6648:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
    664c:	2b00      	cmp	r3, #0
    664e:	d107      	bne.n	6660 <MAC_get_time_out+0x74>
		time *= 10u;
    6650:	687a      	ldr	r2, [r7, #4]
    6652:	4613      	mov	r3, r2
    6654:	ea4f 0383 	mov.w	r3, r3, lsl #2
    6658:	4413      	add	r3, r2
    665a:	ea4f 0343 	mov.w	r3, r3, lsl #1
    665e:	607b      	str	r3, [r7, #4]
	}
	if( g_mss_mac.time_out_value <= time ){
    6660:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    6664:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6668:	6e9a      	ldr	r2, [r3, #104]	; 0x68
    666a:	687b      	ldr	r3, [r7, #4]
    666c:	429a      	cmp	r2, r3
    666e:	d807      	bhi.n	6680 <MAC_get_time_out+0x94>
		g_mss_mac.time_out_value = 0u;
    6670:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    6674:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6678:	f04f 0200 	mov.w	r2, #0
    667c:	669a      	str	r2, [r3, #104]	; 0x68
    667e:	e00c      	b.n	669a <MAC_get_time_out+0xae>
	} else {
		g_mss_mac.time_out_value -= time;
    6680:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    6684:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6688:	6e9a      	ldr	r2, [r3, #104]	; 0x68
    668a:	687b      	ldr	r3, [r7, #4]
    668c:	ebc3 0202 	rsb	r2, r3, r2
    6690:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    6694:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6698:	669a      	str	r2, [r3, #104]	; 0x68
	}

	g_mss_mac.last_timer_value = (uint16_t)timer;
    669a:	683b      	ldr	r3, [r7, #0]
    669c:	b29a      	uxth	r2, r3
    669e:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    66a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    66a6:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66

	return ((g_mss_mac.time_out_value * 10u) / 122u);
    66aa:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    66ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    66b2:	6e9a      	ldr	r2, [r3, #104]	; 0x68
    66b4:	4613      	mov	r3, r2
    66b6:	ea4f 0383 	mov.w	r3, r3, lsl #2
    66ba:	4413      	add	r3, r2
    66bc:	ea4f 0343 	mov.w	r3, r3, lsl #1
    66c0:	461a      	mov	r2, r3
    66c2:	f24c 533f 	movw	r3, #50495	; 0xc53f
    66c6:	f2c4 3325 	movt	r3, #17189	; 0x4325
    66ca:	fba3 1302 	umull	r1, r3, r3, r2
    66ce:	ea4f 1353 	mov.w	r3, r3, lsr #5
}
    66d2:	4618      	mov	r0, r3
    66d4:	f107 070c 	add.w	r7, r7, #12
    66d8:	46bd      	mov	sp, r7
    66da:	bc80      	pop	{r7}
    66dc:	4770      	bx	lr
    66de:	bf00      	nop

000066e0 <MAC_memset>:
/***************************************************************************//**
 * Fills the first n bytes of the memory area pointed to by s with the constant
 * byte c.
 */
static void MAC_memset(uint8_t *s, uint8_t c, uint32_t n)
{
    66e0:	b480      	push	{r7}
    66e2:	b087      	sub	sp, #28
    66e4:	af00      	add	r7, sp, #0
    66e6:	60f8      	str	r0, [r7, #12]
    66e8:	460b      	mov	r3, r1
    66ea:	607a      	str	r2, [r7, #4]
    66ec:	72fb      	strb	r3, [r7, #11]
    uint8_t *sb = s;
    66ee:	68fb      	ldr	r3, [r7, #12]
    66f0:	617b      	str	r3, [r7, #20]

    while( n > 0u ) {
    66f2:	e008      	b.n	6706 <MAC_memset+0x26>
    	n--;
    66f4:	687b      	ldr	r3, [r7, #4]
    66f6:	f103 33ff 	add.w	r3, r3, #4294967295
    66fa:	607b      	str	r3, [r7, #4]
        sb[n] = c;
    66fc:	697a      	ldr	r2, [r7, #20]
    66fe:	687b      	ldr	r3, [r7, #4]
    6700:	4413      	add	r3, r2
    6702:	7afa      	ldrb	r2, [r7, #11]
    6704:	701a      	strb	r2, [r3, #0]
 */
static void MAC_memset(uint8_t *s, uint8_t c, uint32_t n)
{
    uint8_t *sb = s;

    while( n > 0u ) {
    6706:	687b      	ldr	r3, [r7, #4]
    6708:	2b00      	cmp	r3, #0
    670a:	d1f3      	bne.n	66f4 <MAC_memset+0x14>
    	n--;
        sb[n] = c;
    }
}
    670c:	f107 071c 	add.w	r7, r7, #28
    6710:	46bd      	mov	sp, r7
    6712:	bc80      	pop	{r7}
    6714:	4770      	bx	lr
    6716:	bf00      	nop

00006718 <MAC_memset_All>:
 * Fills all fields of MAC_instance_t with c.
 *
 * @return          a pointer to the given MAC_instance_t s.
 */
static void MAC_memset_All(MAC_instance_t *s, uint32_t c)
{
    6718:	b580      	push	{r7, lr}
    671a:	b084      	sub	sp, #16
    671c:	af00      	add	r7, sp, #0
    671e:	6078      	str	r0, [r7, #4]
    6720:	6039      	str	r1, [r7, #0]
    int32_t count;
    s->base_address = (addr_t)c;
    6722:	687b      	ldr	r3, [r7, #4]
    6724:	683a      	ldr	r2, [r7, #0]
    6726:	601a      	str	r2, [r3, #0]
    s->flags = (uint8_t)c;
    6728:	683b      	ldr	r3, [r7, #0]
    672a:	b2da      	uxtb	r2, r3
    672c:	687b      	ldr	r3, [r7, #4]
    672e:	711a      	strb	r2, [r3, #4]
    s->last_error = (int8_t)c;
    6730:	683b      	ldr	r3, [r7, #0]
    6732:	b2da      	uxtb	r2, r3
    6734:	687b      	ldr	r3, [r7, #4]
    6736:	715a      	strb	r2, [r3, #5]
    s->last_timer_value = (uint16_t)c;
    6738:	683b      	ldr	r3, [r7, #0]
    673a:	b29a      	uxth	r2, r3
    673c:	687b      	ldr	r3, [r7, #4]
    673e:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
    s->listener = NULL_callback;
    6742:	f240 636c 	movw	r3, #1644	; 0x66c
    6746:	f2c2 0300 	movt	r3, #8192	; 0x2000
    674a:	681a      	ldr	r2, [r3, #0]
    674c:	687b      	ldr	r3, [r7, #4]
    674e:	66da      	str	r2, [r3, #108]	; 0x6c
   	MAC_memset( s->mac_address, (uint8_t)c, 6u );
    6750:	687b      	ldr	r3, [r7, #4]
    6752:	f103 0206 	add.w	r2, r3, #6
    6756:	683b      	ldr	r3, [r7, #0]
    6758:	b2db      	uxtb	r3, r3
    675a:	4610      	mov	r0, r2
    675c:	4619      	mov	r1, r3
    675e:	f04f 0206 	mov.w	r2, #6
    6762:	f7ff ffbd 	bl	66e0 <MAC_memset>
   	MAC_memset( s->mac_filter_data, (uint8_t)c, 90u );
    6766:	687b      	ldr	r3, [r7, #4]
    6768:	f103 020c 	add.w	r2, r3, #12
    676c:	683b      	ldr	r3, [r7, #0]
    676e:	b2db      	uxtb	r3, r3
    6770:	4610      	mov	r0, r2
    6772:	4619      	mov	r1, r3
    6774:	f04f 025a 	mov.w	r2, #90	; 0x5a
    6778:	f7ff ffb2 	bl	66e0 <MAC_memset>
    s->phy_address = (uint8_t)c;
    677c:	683b      	ldr	r3, [r7, #0]
    677e:	b2da      	uxtb	r2, r3
    6780:	687b      	ldr	r3, [r7, #4]
    6782:	f883 20e8 	strb.w	r2, [r3, #232]	; 0xe8
    s->rx_desc_index =c;
    6786:	687b      	ldr	r3, [r7, #4]
    6788:	683a      	ldr	r2, [r7, #0]
    678a:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    for(count = 0; count<RX_RING_SIZE ;count++)
    678e:	f04f 0300 	mov.w	r3, #0
    6792:	60fb      	str	r3, [r7, #12]
    6794:	e029      	b.n	67ea <MAC_memset_All+0xd2>
    {
        s->rx_descriptors[count].buffer_1 = c;
    6796:	68fa      	ldr	r2, [r7, #12]
    6798:	687b      	ldr	r3, [r7, #4]
    679a:	f102 020a 	add.w	r2, r2, #10
    679e:	ea4f 1202 	mov.w	r2, r2, lsl #4
    67a2:	4413      	add	r3, r2
    67a4:	683a      	ldr	r2, [r7, #0]
    67a6:	601a      	str	r2, [r3, #0]
        s->rx_descriptors[count].buffer_2 = c;
    67a8:	68fa      	ldr	r2, [r7, #12]
    67aa:	687b      	ldr	r3, [r7, #4]
    67ac:	f102 020a 	add.w	r2, r2, #10
    67b0:	ea4f 1202 	mov.w	r2, r2, lsl #4
    67b4:	4413      	add	r3, r2
    67b6:	f103 0304 	add.w	r3, r3, #4
    67ba:	683a      	ldr	r2, [r7, #0]
    67bc:	601a      	str	r2, [r3, #0]
        s->rx_descriptors[count].descriptor_0 = c;
    67be:	68fa      	ldr	r2, [r7, #12]
    67c0:	687b      	ldr	r3, [r7, #4]
    67c2:	ea4f 1202 	mov.w	r2, r2, lsl #4
    67c6:	4413      	add	r3, r2
    67c8:	f103 0398 	add.w	r3, r3, #152	; 0x98
    67cc:	683a      	ldr	r2, [r7, #0]
    67ce:	601a      	str	r2, [r3, #0]
        s->rx_descriptors[count].descriptor_1 = c;
    67d0:	68fa      	ldr	r2, [r7, #12]
    67d2:	687b      	ldr	r3, [r7, #4]
    67d4:	ea4f 1202 	mov.w	r2, r2, lsl #4
    67d8:	4413      	add	r3, r2
    67da:	f103 039c 	add.w	r3, r3, #156	; 0x9c
    67de:	683a      	ldr	r2, [r7, #0]
    67e0:	601a      	str	r2, [r3, #0]
    s->listener = NULL_callback;
   	MAC_memset( s->mac_address, (uint8_t)c, 6u );
   	MAC_memset( s->mac_filter_data, (uint8_t)c, 90u );
    s->phy_address = (uint8_t)c;
    s->rx_desc_index =c;
    for(count = 0; count<RX_RING_SIZE ;count++)
    67e2:	68fb      	ldr	r3, [r7, #12]
    67e4:	f103 0301 	add.w	r3, r3, #1
    67e8:	60fb      	str	r3, [r7, #12]
    67ea:	68fb      	ldr	r3, [r7, #12]
    67ec:	2b04      	cmp	r3, #4
    67ee:	ddd2      	ble.n	6796 <MAC_memset_All+0x7e>
        s->rx_descriptors[count].buffer_1 = c;
        s->rx_descriptors[count].buffer_2 = c;
        s->rx_descriptors[count].descriptor_0 = c;
        s->rx_descriptors[count].descriptor_1 = c;
    }
    s->statistics.rx_collision_seen =c;
    67f0:	687b      	ldr	r3, [r7, #4]
    67f2:	683a      	ldr	r2, [r7, #0]
    67f4:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    67f8:	ea4f 2202 	mov.w	r2, r2, lsl #8
    67fc:	f8d3 1104 	ldr.w	r1, [r3, #260]	; 0x104
    6800:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6804:	ea41 0202 	orr.w	r2, r1, r2
    6808:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    680c:	78fa      	ldrb	r2, [r7, #3]
    680e:	f04f 0100 	mov.w	r1, #0
    6812:	ea41 0202 	orr.w	r2, r1, r2
    6816:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
    s->statistics.rx_crc_error = c;
    681a:	687b      	ldr	r3, [r7, #4]
    681c:	683a      	ldr	r2, [r7, #0]
    681e:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    6822:	ea4f 2202 	mov.w	r2, r2, lsl #8
    6826:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
    682a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    682e:	ea41 0202 	orr.w	r2, r1, r2
    6832:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
    6836:	78fa      	ldrb	r2, [r7, #3]
    6838:	f04f 0100 	mov.w	r1, #0
    683c:	ea41 0202 	orr.w	r2, r1, r2
    6840:	f883 210c 	strb.w	r2, [r3, #268]	; 0x10c
    s->statistics.rx_descriptor_error = c;
    6844:	687b      	ldr	r3, [r7, #4]
    6846:	683a      	ldr	r2, [r7, #0]
    6848:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    684c:	ea4f 2202 	mov.w	r2, r2, lsl #8
    6850:	f8d3 10f0 	ldr.w	r1, [r3, #240]	; 0xf0
    6854:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6858:	ea41 0202 	orr.w	r2, r1, r2
    685c:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
    6860:	78fa      	ldrb	r2, [r7, #3]
    6862:	f04f 0100 	mov.w	r1, #0
    6866:	ea41 0202 	orr.w	r2, r1, r2
    686a:	f883 20f4 	strb.w	r2, [r3, #244]	; 0xf4
    s->statistics.rx_fifo_overflow = c;
    686e:	687b      	ldr	r3, [r7, #4]
    6870:	683a      	ldr	r2, [r7, #0]
    6872:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    6876:	ea4f 2202 	mov.w	r2, r2, lsl #8
    687a:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
    687e:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6882:	ea41 0202 	orr.w	r2, r1, r2
    6886:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    688a:	78fa      	ldrb	r2, [r7, #3]
    688c:	f04f 0100 	mov.w	r1, #0
    6890:	ea41 0202 	orr.w	r2, r1, r2
    6894:	f883 2110 	strb.w	r2, [r3, #272]	; 0x110
    s->statistics.rx_filtering_fail = c;
    6898:	687b      	ldr	r3, [r7, #4]
    689a:	683a      	ldr	r2, [r7, #0]
    689c:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    68a0:	ea4f 2202 	mov.w	r2, r2, lsl #8
    68a4:	f8d3 10ec 	ldr.w	r1, [r3, #236]	; 0xec
    68a8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    68ac:	ea41 0202 	orr.w	r2, r1, r2
    68b0:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
    68b4:	78fa      	ldrb	r2, [r7, #3]
    68b6:	f04f 0100 	mov.w	r1, #0
    68ba:	ea41 0202 	orr.w	r2, r1, r2
    68be:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
    s->statistics.rx_frame_too_long = c;
    68c2:	687b      	ldr	r3, [r7, #4]
    68c4:	683a      	ldr	r2, [r7, #0]
    68c6:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    68ca:	ea4f 2202 	mov.w	r2, r2, lsl #8
    68ce:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
    68d2:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    68d6:	ea41 0202 	orr.w	r2, r1, r2
    68da:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    68de:	78fa      	ldrb	r2, [r7, #3]
    68e0:	f04f 0100 	mov.w	r1, #0
    68e4:	ea41 0202 	orr.w	r2, r1, r2
    68e8:	f883 2104 	strb.w	r2, [r3, #260]	; 0x104
    s->statistics.rx_interrupts = c;
    68ec:	687b      	ldr	r3, [r7, #4]
    68ee:	683a      	ldr	r2, [r7, #0]
    68f0:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    68f4:	ea4f 2202 	mov.w	r2, r2, lsl #8
    68f8:	f8d3 10e8 	ldr.w	r1, [r3, #232]	; 0xe8
    68fc:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6900:	ea41 0202 	orr.w	r2, r1, r2
    6904:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
    6908:	78fa      	ldrb	r2, [r7, #3]
    690a:	f04f 0100 	mov.w	r1, #0
    690e:	ea41 0202 	orr.w	r2, r1, r2
    6912:	f883 20ec 	strb.w	r2, [r3, #236]	; 0xec
    s->statistics.rx_missed_frame = c;
    6916:	687b      	ldr	r3, [r7, #4]
    6918:	683a      	ldr	r2, [r7, #0]
    691a:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    691e:	ea4f 2202 	mov.w	r2, r2, lsl #8
    6922:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
    6926:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    692a:	ea41 0202 	orr.w	r2, r1, r2
    692e:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
    6932:	78fa      	ldrb	r2, [r7, #3]
    6934:	f04f 0100 	mov.w	r1, #0
    6938:	ea41 0202 	orr.w	r2, r1, r2
    693c:	f883 2114 	strb.w	r2, [r3, #276]	; 0x114
    s->statistics.rx_not_first = c;
    6940:	687b      	ldr	r3, [r7, #4]
    6942:	683a      	ldr	r2, [r7, #0]
    6944:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    6948:	ea4f 2202 	mov.w	r2, r2, lsl #8
    694c:	f8d3 10f8 	ldr.w	r1, [r3, #248]	; 0xf8
    6950:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6954:	ea41 0202 	orr.w	r2, r1, r2
    6958:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
    695c:	78fa      	ldrb	r2, [r7, #3]
    695e:	f04f 0100 	mov.w	r1, #0
    6962:	ea41 0202 	orr.w	r2, r1, r2
    6966:	f883 20fc 	strb.w	r2, [r3, #252]	; 0xfc
    s->statistics.rx_not_last = c;
    696a:	687b      	ldr	r3, [r7, #4]
    696c:	683a      	ldr	r2, [r7, #0]
    696e:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    6972:	ea4f 2202 	mov.w	r2, r2, lsl #8
    6976:	f8d3 10fc 	ldr.w	r1, [r3, #252]	; 0xfc
    697a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    697e:	ea41 0202 	orr.w	r2, r1, r2
    6982:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
    6986:	78fa      	ldrb	r2, [r7, #3]
    6988:	f04f 0100 	mov.w	r1, #0
    698c:	ea41 0202 	orr.w	r2, r1, r2
    6990:	f883 2100 	strb.w	r2, [r3, #256]	; 0x100
    s->statistics.rx_runt_frame = c;
    6994:	687b      	ldr	r3, [r7, #4]
    6996:	683a      	ldr	r2, [r7, #0]
    6998:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    699c:	ea4f 2202 	mov.w	r2, r2, lsl #8
    69a0:	f8d3 10f4 	ldr.w	r1, [r3, #244]	; 0xf4
    69a4:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    69a8:	ea41 0202 	orr.w	r2, r1, r2
    69ac:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
    69b0:	78fa      	ldrb	r2, [r7, #3]
    69b2:	f04f 0100 	mov.w	r1, #0
    69b6:	ea41 0202 	orr.w	r2, r1, r2
    69ba:	f883 20f8 	strb.w	r2, [r3, #248]	; 0xf8
    s->statistics.tx_collision_count = c;
    69be:	687b      	ldr	r3, [r7, #4]
    69c0:	683a      	ldr	r2, [r7, #0]
    69c2:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    69c6:	ea4f 2202 	mov.w	r2, r2, lsl #8
    69ca:	f8d3 1128 	ldr.w	r1, [r3, #296]	; 0x128
    69ce:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    69d2:	ea41 0202 	orr.w	r2, r1, r2
    69d6:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
    69da:	78fa      	ldrb	r2, [r7, #3]
    69dc:	f04f 0100 	mov.w	r1, #0
    69e0:	ea41 0202 	orr.w	r2, r1, r2
    69e4:	f883 212c 	strb.w	r2, [r3, #300]	; 0x12c
    s->statistics.tx_excessive_collision = c;
    69e8:	687b      	ldr	r3, [r7, #4]
    69ea:	683a      	ldr	r2, [r7, #0]
    69ec:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    69f0:	ea4f 2202 	mov.w	r2, r2, lsl #8
    69f4:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
    69f8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    69fc:	ea41 0202 	orr.w	r2, r1, r2
    6a00:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
    6a04:	78fa      	ldrb	r2, [r7, #3]
    6a06:	f04f 0100 	mov.w	r1, #0
    6a0a:	ea41 0202 	orr.w	r2, r1, r2
    6a0e:	f883 2128 	strb.w	r2, [r3, #296]	; 0x128
    s->statistics.tx_interrupts = c;
    6a12:	687b      	ldr	r3, [r7, #4]
    6a14:	683a      	ldr	r2, [r7, #0]
    6a16:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    6a1a:	ea4f 2202 	mov.w	r2, r2, lsl #8
    6a1e:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
    6a22:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6a26:	ea41 0202 	orr.w	r2, r1, r2
    6a2a:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    6a2e:	78fa      	ldrb	r2, [r7, #3]
    6a30:	f04f 0100 	mov.w	r1, #0
    6a34:	ea41 0202 	orr.w	r2, r1, r2
    6a38:	f883 2118 	strb.w	r2, [r3, #280]	; 0x118
    s->statistics.tx_late_collision = c;
    6a3c:	687b      	ldr	r3, [r7, #4]
    6a3e:	683a      	ldr	r2, [r7, #0]
    6a40:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    6a44:	ea4f 2202 	mov.w	r2, r2, lsl #8
    6a48:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
    6a4c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6a50:	ea41 0202 	orr.w	r2, r1, r2
    6a54:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
    6a58:	78fa      	ldrb	r2, [r7, #3]
    6a5a:	f04f 0100 	mov.w	r1, #0
    6a5e:	ea41 0202 	orr.w	r2, r1, r2
    6a62:	f883 2124 	strb.w	r2, [r3, #292]	; 0x124
    s->statistics.tx_loss_of_carrier = c;
    6a66:	687b      	ldr	r3, [r7, #4]
    6a68:	683a      	ldr	r2, [r7, #0]
    6a6a:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    6a6e:	ea4f 2202 	mov.w	r2, r2, lsl #8
    6a72:	f8d3 1118 	ldr.w	r1, [r3, #280]	; 0x118
    6a76:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6a7a:	ea41 0202 	orr.w	r2, r1, r2
    6a7e:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
    6a82:	78fa      	ldrb	r2, [r7, #3]
    6a84:	f04f 0100 	mov.w	r1, #0
    6a88:	ea41 0202 	orr.w	r2, r1, r2
    6a8c:	f883 211c 	strb.w	r2, [r3, #284]	; 0x11c
    s->statistics.tx_no_carrier = c;
    6a90:	687b      	ldr	r3, [r7, #4]
    6a92:	683a      	ldr	r2, [r7, #0]
    6a94:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    6a98:	ea4f 2202 	mov.w	r2, r2, lsl #8
    6a9c:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
    6aa0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6aa4:	ea41 0202 	orr.w	r2, r1, r2
    6aa8:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
    6aac:	78fa      	ldrb	r2, [r7, #3]
    6aae:	f04f 0100 	mov.w	r1, #0
    6ab2:	ea41 0202 	orr.w	r2, r1, r2
    6ab6:	f883 2120 	strb.w	r2, [r3, #288]	; 0x120
    s->statistics.tx_underflow_error = c;
    6aba:	687b      	ldr	r3, [r7, #4]
    6abc:	683a      	ldr	r2, [r7, #0]
    6abe:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    6ac2:	ea4f 2202 	mov.w	r2, r2, lsl #8
    6ac6:	f8d3 112c 	ldr.w	r1, [r3, #300]	; 0x12c
    6aca:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6ace:	ea41 0202 	orr.w	r2, r1, r2
    6ad2:	f8c3 212c 	str.w	r2, [r3, #300]	; 0x12c
    6ad6:	78fa      	ldrb	r2, [r7, #3]
    6ad8:	f04f 0100 	mov.w	r1, #0
    6adc:	ea41 0202 	orr.w	r2, r1, r2
    6ae0:	f883 2130 	strb.w	r2, [r3, #304]	; 0x130
    s->time_out_value = c;
    6ae4:	687b      	ldr	r3, [r7, #4]
    6ae6:	683a      	ldr	r2, [r7, #0]
    6ae8:	669a      	str	r2, [r3, #104]	; 0x68
    s->tx_desc_index = c;
    6aea:	687b      	ldr	r3, [r7, #4]
    6aec:	683a      	ldr	r2, [r7, #0]
    6aee:	671a      	str	r2, [r3, #112]	; 0x70
    for(count = 0; count < TX_RING_SIZE ;count++)
    6af0:	f04f 0300 	mov.w	r3, #0
    6af4:	60fb      	str	r3, [r7, #12]
    6af6:	e02b      	b.n	6b50 <MAC_memset_All+0x438>
    {
        s->tx_descriptors[count].buffer_1 = c;
    6af8:	68fa      	ldr	r2, [r7, #12]
    6afa:	687b      	ldr	r3, [r7, #4]
    6afc:	ea4f 1202 	mov.w	r2, r2, lsl #4
    6b00:	4413      	add	r3, r2
    6b02:	f103 037c 	add.w	r3, r3, #124	; 0x7c
    6b06:	683a      	ldr	r2, [r7, #0]
    6b08:	601a      	str	r2, [r3, #0]
        s->tx_descriptors[count].buffer_2 = c;
    6b0a:	68fa      	ldr	r2, [r7, #12]
    6b0c:	687b      	ldr	r3, [r7, #4]
    6b0e:	ea4f 1202 	mov.w	r2, r2, lsl #4
    6b12:	4413      	add	r3, r2
    6b14:	f103 0380 	add.w	r3, r3, #128	; 0x80
    6b18:	683a      	ldr	r2, [r7, #0]
    6b1a:	601a      	str	r2, [r3, #0]
        s->tx_descriptors[count].descriptor_0 = c;
    6b1c:	68fa      	ldr	r2, [r7, #12]
    6b1e:	687b      	ldr	r3, [r7, #4]
    6b20:	f102 0207 	add.w	r2, r2, #7
    6b24:	ea4f 1202 	mov.w	r2, r2, lsl #4
    6b28:	4413      	add	r3, r2
    6b2a:	f103 0304 	add.w	r3, r3, #4
    6b2e:	683a      	ldr	r2, [r7, #0]
    6b30:	601a      	str	r2, [r3, #0]
        s->tx_descriptors[count].descriptor_1 = c;
    6b32:	68fa      	ldr	r2, [r7, #12]
    6b34:	687b      	ldr	r3, [r7, #4]
    6b36:	f102 0207 	add.w	r2, r2, #7
    6b3a:	ea4f 1202 	mov.w	r2, r2, lsl #4
    6b3e:	4413      	add	r3, r2
    6b40:	f103 0308 	add.w	r3, r3, #8
    6b44:	683a      	ldr	r2, [r7, #0]
    6b46:	601a      	str	r2, [r3, #0]
    s->statistics.tx_loss_of_carrier = c;
    s->statistics.tx_no_carrier = c;
    s->statistics.tx_underflow_error = c;
    s->time_out_value = c;
    s->tx_desc_index = c;
    for(count = 0; count < TX_RING_SIZE ;count++)
    6b48:	68fb      	ldr	r3, [r7, #12]
    6b4a:	f103 0301 	add.w	r3, r3, #1
    6b4e:	60fb      	str	r3, [r7, #12]
    6b50:	68fb      	ldr	r3, [r7, #12]
    6b52:	2b01      	cmp	r3, #1
    6b54:	ddd0      	ble.n	6af8 <MAC_memset_All+0x3e0>
        s->tx_descriptors[count].buffer_1 = c;
        s->tx_descriptors[count].buffer_2 = c;
        s->tx_descriptors[count].descriptor_0 = c;
        s->tx_descriptors[count].descriptor_1 = c;
    }
}
    6b56:	f107 0710 	add.w	r7, r7, #16
    6b5a:	46bd      	mov	sp, r7
    6b5c:	bd80      	pop	{r7, pc}
    6b5e:	bf00      	nop

00006b60 <MAC_memcpy>:
 * The memory areas should not overlap.
 *
 * @return          a pointer to the memory area dest.
 */
static void MAC_memcpy(uint8_t *dest, const uint8_t *src, uint32_t n)
{
    6b60:	b480      	push	{r7}
    6b62:	b087      	sub	sp, #28
    6b64:	af00      	add	r7, sp, #0
    6b66:	60f8      	str	r0, [r7, #12]
    6b68:	60b9      	str	r1, [r7, #8]
    6b6a:	607a      	str	r2, [r7, #4]
    uint8_t *d = dest;
    6b6c:	68fb      	ldr	r3, [r7, #12]
    6b6e:	617b      	str	r3, [r7, #20]

    while( n > 0u ) {
    6b70:	e00b      	b.n	6b8a <MAC_memcpy+0x2a>
    	n--;
    6b72:	687b      	ldr	r3, [r7, #4]
    6b74:	f103 33ff 	add.w	r3, r3, #4294967295
    6b78:	607b      	str	r3, [r7, #4]
        d[n] = src[n];
    6b7a:	697a      	ldr	r2, [r7, #20]
    6b7c:	687b      	ldr	r3, [r7, #4]
    6b7e:	4413      	add	r3, r2
    6b80:	68b9      	ldr	r1, [r7, #8]
    6b82:	687a      	ldr	r2, [r7, #4]
    6b84:	440a      	add	r2, r1
    6b86:	7812      	ldrb	r2, [r2, #0]
    6b88:	701a      	strb	r2, [r3, #0]
 */
static void MAC_memcpy(uint8_t *dest, const uint8_t *src, uint32_t n)
{
    uint8_t *d = dest;

    while( n > 0u ) {
    6b8a:	687b      	ldr	r3, [r7, #4]
    6b8c:	2b00      	cmp	r3, #0
    6b8e:	d1f0      	bne.n	6b72 <MAC_memcpy+0x12>
    	n--;
        d[n] = src[n];
    }
}
    6b90:	f107 071c 	add.w	r7, r7, #28
    6b94:	46bd      	mov	sp, r7
    6b96:	bc80      	pop	{r7}
    6b98:	4770      	bx	lr
    6b9a:	bf00      	nop

00006b9c <MSS_MAC_FreeTxBuffers>:
 * Tx has completed, mark the buffers that were assigned to the Tx descriptors
 * as free again.
 *
 */
void MSS_MAC_FreeTxBuffers( void )
{
    6b9c:	b580      	push	{r7, lr}
    6b9e:	b082      	sub	sp, #8
    6ba0:	af00      	add	r7, sp, #0
	/* Check the buffers have not already been freed in the first of the
	two Tx interrupts - which could potentially happen if the second Tx completed
	during the interrupt for the first Tx. */
	if( g_mss_mac.tx_descriptors[ 0 ].buffer_1 != ( uint32_t ) NULL )
    6ba2:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    6ba6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6baa:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
    6bac:	2b00      	cmp	r3, #0
    6bae:	d034      	beq.n	6c1a <MSS_MAC_FreeTxBuffers+0x7e>
	{
		if( ( ( (g_mss_mac.tx_descriptors[ 0 ].descriptor_0) & TDES0_OWN) == 0 ) && ( ( (g_mss_mac.tx_descriptors[ 1 ].descriptor_0) & TDES0_OWN) == 0 ) )
    6bb0:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    6bb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6bb8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    6bba:	2b00      	cmp	r3, #0
    6bbc:	db2d      	blt.n	6c1a <MSS_MAC_FreeTxBuffers+0x7e>
    6bbe:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    6bc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6bc6:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
    6bca:	2b00      	cmp	r3, #0
    6bcc:	db25      	blt.n	6c1a <MSS_MAC_FreeTxBuffers+0x7e>
		{
			configASSERT( g_mss_mac.tx_descriptors[ 0 ].buffer_1 == g_mss_mac.tx_descriptors[ 1 ].buffer_1 );
    6bce:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    6bd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6bd6:	6fda      	ldr	r2, [r3, #124]	; 0x7c
    6bd8:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    6bdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6be0:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
    6be4:	429a      	cmp	r2, r3
    6be6:	d009      	beq.n	6bfc <MSS_MAC_FreeTxBuffers+0x60>
    6be8:	f04f 0328 	mov.w	r3, #40	; 0x28
    6bec:	f383 8811 	msr	BASEPRI, r3
    6bf0:	f3bf 8f6f 	isb	sy
    6bf4:	f3bf 8f4f 	dsb	sy
    6bf8:	607b      	str	r3, [r7, #4]
    6bfa:	e7fe      	b.n	6bfa <MSS_MAC_FreeTxBuffers+0x5e>
			MAC_release_buffer( ( unsigned char * ) g_mss_mac.tx_descriptors[ 0 ].buffer_1 );
    6bfc:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    6c00:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6c04:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
    6c06:	4618      	mov	r0, r3
    6c08:	f000 f8c8 	bl	6d9c <MAC_release_buffer>
			
			/* Just to mark the fact that the buffer has already been released. */
			g_mss_mac.tx_descriptors[ 0 ].buffer_1 = ( uint32_t ) NULL;
    6c0c:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    6c10:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6c14:	f04f 0200 	mov.w	r2, #0
    6c18:	67da      	str	r2, [r3, #124]	; 0x7c
		}
	}
}
    6c1a:	f107 0708 	add.w	r7, r7, #8
    6c1e:	46bd      	mov	sp, r7
    6c20:	bd80      	pop	{r7, pc}
    6c22:	bf00      	nop

00006c24 <MAC_obtain_buffer>:
 * as in use, then return its address.
 *
 * @return          a pointer to a free buffer.
 */
unsigned char *MAC_obtain_buffer( void )
{
    6c24:	b480      	push	{r7}
    6c26:	b089      	sub	sp, #36	; 0x24
    6c28:	af00      	add	r7, sp, #0
long lIndex, lAttempt = 0, lDescriptor, lBufferIsInUse;
    6c2a:	f04f 0300 	mov.w	r3, #0
    6c2e:	60bb      	str	r3, [r7, #8]
unsigned char *pcReturn = NULL;
    6c30:	f04f 0300 	mov.w	r3, #0
    6c34:	617b      	str	r3, [r7, #20]
unsigned char *pcBufferAddress;

	/* Find and return the address of a buffer that is not being used.  Mark
	the buffer as now in use. */
	while( ( lAttempt <= 1 ) && ( pcReturn == NULL ) )
    6c36:	e096      	b.n	6d66 <MAC_obtain_buffer+0x142>
	{
		for( lIndex = 0; lIndex < macNUM_BUFFERS; lIndex++ )
    6c38:	f04f 0300 	mov.w	r3, #0
    6c3c:	607b      	str	r3, [r7, #4]
    6c3e:	e01f      	b.n	6c80 <MAC_obtain_buffer+0x5c>
		{
			if( ucMACBufferInUse[ lIndex ] == pdFALSE )
    6c40:	687a      	ldr	r2, [r7, #4]
    6c42:	f642 7324 	movw	r3, #12068	; 0x2f24
    6c46:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6c4a:	5c9b      	ldrb	r3, [r3, r2]
    6c4c:	2b00      	cmp	r3, #0
    6c4e:	d113      	bne.n	6c78 <MAC_obtain_buffer+0x54>
			{
				pcReturn = &( xMACBuffers.ucBuffer[ lIndex ][ 0 ] );
    6c50:	f240 6374 	movw	r3, #1652	; 0x674
    6c54:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6c58:	687a      	ldr	r2, [r7, #4]
    6c5a:	f44f 61ba 	mov.w	r1, #1488	; 0x5d0
    6c5e:	fb01 f202 	mul.w	r2, r1, r2
    6c62:	4413      	add	r3, r2
    6c64:	617b      	str	r3, [r7, #20]
				ucMACBufferInUse[ lIndex ] = pdTRUE;
    6c66:	687a      	ldr	r2, [r7, #4]
    6c68:	f642 7324 	movw	r3, #12068	; 0x2f24
    6c6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6c70:	f04f 0101 	mov.w	r1, #1
    6c74:	5499      	strb	r1, [r3, r2]
				break;
    6c76:	e006      	b.n	6c86 <MAC_obtain_buffer+0x62>

	/* Find and return the address of a buffer that is not being used.  Mark
	the buffer as now in use. */
	while( ( lAttempt <= 1 ) && ( pcReturn == NULL ) )
	{
		for( lIndex = 0; lIndex < macNUM_BUFFERS; lIndex++ )
    6c78:	687b      	ldr	r3, [r7, #4]
    6c7a:	f103 0301 	add.w	r3, r3, #1
    6c7e:	607b      	str	r3, [r7, #4]
    6c80:	687b      	ldr	r3, [r7, #4]
    6c82:	2b06      	cmp	r3, #6
    6c84:	dddc      	ble.n	6c40 <MAC_obtain_buffer+0x1c>
				ucMACBufferInUse[ lIndex ] = pdTRUE;
				break;
			}
		}
		
		if( pcReturn == NULL )
    6c86:	697b      	ldr	r3, [r7, #20]
    6c88:	2b00      	cmp	r3, #0
    6c8a:	d168      	bne.n	6d5e <MAC_obtain_buffer+0x13a>
		{
			/* Did not find a buffer.  That should not really happen, but could if
			an interrupt was missed.  See if any buffers are marked as in use, but
			are not actually in use. */
			for( lIndex = 0; lIndex < macNUM_BUFFERS; lIndex++ )
    6c8c:	f04f 0300 	mov.w	r3, #0
    6c90:	607b      	str	r3, [r7, #4]
    6c92:	e061      	b.n	6d58 <MAC_obtain_buffer+0x134>
			{
				pcBufferAddress = &( xMACBuffers.ucBuffer[ lIndex ][ 0 ] );
    6c94:	f240 6374 	movw	r3, #1652	; 0x674
    6c98:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6c9c:	687a      	ldr	r2, [r7, #4]
    6c9e:	f44f 61ba 	mov.w	r1, #1488	; 0x5d0
    6ca2:	fb01 f202 	mul.w	r2, r1, r2
    6ca6:	4413      	add	r3, r2
    6ca8:	61bb      	str	r3, [r7, #24]
				lBufferIsInUse = pdFALSE;
    6caa:	f04f 0300 	mov.w	r3, #0
    6cae:	613b      	str	r3, [r7, #16]
				
				/* Is the buffer used by an Rx descriptor? */
				for( lDescriptor = 0; lDescriptor < RX_RING_SIZE; lDescriptor++ )
    6cb0:	f04f 0300 	mov.w	r3, #0
    6cb4:	60fb      	str	r3, [r7, #12]
    6cb6:	e015      	b.n	6ce4 <MAC_obtain_buffer+0xc0>
				{
					if( g_mss_mac.rx_descriptors[ lDescriptor ].buffer_1 == ( uint32_t ) pcBufferAddress )
    6cb8:	68fa      	ldr	r2, [r7, #12]
    6cba:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    6cbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6cc2:	f102 020a 	add.w	r2, r2, #10
    6cc6:	ea4f 1202 	mov.w	r2, r2, lsl #4
    6cca:	4413      	add	r3, r2
    6ccc:	681a      	ldr	r2, [r3, #0]
    6cce:	69bb      	ldr	r3, [r7, #24]
    6cd0:	429a      	cmp	r2, r3
    6cd2:	d103      	bne.n	6cdc <MAC_obtain_buffer+0xb8>
					{
						/* The buffer is in use by an Rx descriptor. */
						lBufferIsInUse = pdTRUE;
    6cd4:	f04f 0301 	mov.w	r3, #1
    6cd8:	613b      	str	r3, [r7, #16]
						break;
    6cda:	e006      	b.n	6cea <MAC_obtain_buffer+0xc6>
			{
				pcBufferAddress = &( xMACBuffers.ucBuffer[ lIndex ][ 0 ] );
				lBufferIsInUse = pdFALSE;
				
				/* Is the buffer used by an Rx descriptor? */
				for( lDescriptor = 0; lDescriptor < RX_RING_SIZE; lDescriptor++ )
    6cdc:	68fb      	ldr	r3, [r7, #12]
    6cde:	f103 0301 	add.w	r3, r3, #1
    6ce2:	60fb      	str	r3, [r7, #12]
    6ce4:	68fb      	ldr	r3, [r7, #12]
    6ce6:	2b04      	cmp	r3, #4
    6ce8:	dde6      	ble.n	6cb8 <MAC_obtain_buffer+0x94>
						lBufferIsInUse = pdTRUE;
						break;
					}
				}
				
				if( lBufferIsInUse != pdTRUE )
    6cea:	693b      	ldr	r3, [r7, #16]
    6cec:	2b01      	cmp	r3, #1
    6cee:	d01c      	beq.n	6d2a <MAC_obtain_buffer+0x106>
				{
					/* Is the buffer used by an Tx descriptor? */
					for( lDescriptor = 0; lDescriptor < TX_RING_SIZE; lDescriptor++ )
    6cf0:	f04f 0300 	mov.w	r3, #0
    6cf4:	60fb      	str	r3, [r7, #12]
    6cf6:	e015      	b.n	6d24 <MAC_obtain_buffer+0x100>
					{
						if( g_mss_mac.tx_descriptors[ lDescriptor ].buffer_1 == ( uint32_t ) pcBufferAddress )
    6cf8:	68fa      	ldr	r2, [r7, #12]
    6cfa:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    6cfe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6d02:	ea4f 1202 	mov.w	r2, r2, lsl #4
    6d06:	4413      	add	r3, r2
    6d08:	f103 037c 	add.w	r3, r3, #124	; 0x7c
    6d0c:	681a      	ldr	r2, [r3, #0]
    6d0e:	69bb      	ldr	r3, [r7, #24]
    6d10:	429a      	cmp	r2, r3
    6d12:	d103      	bne.n	6d1c <MAC_obtain_buffer+0xf8>
						{
							/* The buffer is in use by an Tx descriptor. */
							lBufferIsInUse = pdTRUE;
    6d14:	f04f 0301 	mov.w	r3, #1
    6d18:	613b      	str	r3, [r7, #16]
							break;
    6d1a:	e006      	b.n	6d2a <MAC_obtain_buffer+0x106>
				}
				
				if( lBufferIsInUse != pdTRUE )
				{
					/* Is the buffer used by an Tx descriptor? */
					for( lDescriptor = 0; lDescriptor < TX_RING_SIZE; lDescriptor++ )
    6d1c:	68fb      	ldr	r3, [r7, #12]
    6d1e:	f103 0301 	add.w	r3, r3, #1
    6d22:	60fb      	str	r3, [r7, #12]
    6d24:	68fb      	ldr	r3, [r7, #12]
    6d26:	2b01      	cmp	r3, #1
    6d28:	dde6      	ble.n	6cf8 <MAC_obtain_buffer+0xd4>
				}
				
				/* If the buffer was not found to be in use by either a Tx or an
				Rx descriptor, but the buffer is marked as in use, then mark the
				buffer to be in it's correct state of "not in use". */
				if( ( lBufferIsInUse == pdFALSE ) && ( ucMACBufferInUse[ lIndex ] == pdTRUE ) )
    6d2a:	693b      	ldr	r3, [r7, #16]
    6d2c:	2b00      	cmp	r3, #0
    6d2e:	d10f      	bne.n	6d50 <MAC_obtain_buffer+0x12c>
    6d30:	687a      	ldr	r2, [r7, #4]
    6d32:	f642 7324 	movw	r3, #12068	; 0x2f24
    6d36:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6d3a:	5c9b      	ldrb	r3, [r3, r2]
    6d3c:	2b01      	cmp	r3, #1
    6d3e:	d107      	bne.n	6d50 <MAC_obtain_buffer+0x12c>
				{
					ucMACBufferInUse[ lIndex ] = pdFALSE;
    6d40:	687a      	ldr	r2, [r7, #4]
    6d42:	f642 7324 	movw	r3, #12068	; 0x2f24
    6d46:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6d4a:	f04f 0100 	mov.w	r1, #0
    6d4e:	5499      	strb	r1, [r3, r2]
		if( pcReturn == NULL )
		{
			/* Did not find a buffer.  That should not really happen, but could if
			an interrupt was missed.  See if any buffers are marked as in use, but
			are not actually in use. */
			for( lIndex = 0; lIndex < macNUM_BUFFERS; lIndex++ )
    6d50:	687b      	ldr	r3, [r7, #4]
    6d52:	f103 0301 	add.w	r3, r3, #1
    6d56:	607b      	str	r3, [r7, #4]
    6d58:	687b      	ldr	r3, [r7, #4]
    6d5a:	2b06      	cmp	r3, #6
    6d5c:	dd9a      	ble.n	6c94 <MAC_obtain_buffer+0x70>
			}
		}
																	
		/* If any buffer states were changed it might be that a buffer can now
		be obtained.  Try again, but only one more time. */
		lAttempt++;
    6d5e:	68bb      	ldr	r3, [r7, #8]
    6d60:	f103 0301 	add.w	r3, r3, #1
    6d64:	60bb      	str	r3, [r7, #8]
unsigned char *pcReturn = NULL;
unsigned char *pcBufferAddress;

	/* Find and return the address of a buffer that is not being used.  Mark
	the buffer as now in use. */
	while( ( lAttempt <= 1 ) && ( pcReturn == NULL ) )
    6d66:	68bb      	ldr	r3, [r7, #8]
    6d68:	2b01      	cmp	r3, #1
    6d6a:	dc03      	bgt.n	6d74 <MAC_obtain_buffer+0x150>
    6d6c:	697b      	ldr	r3, [r7, #20]
    6d6e:	2b00      	cmp	r3, #0
    6d70:	f43f af62 	beq.w	6c38 <MAC_obtain_buffer+0x14>
		/* If any buffer states were changed it might be that a buffer can now
		be obtained.  Try again, but only one more time. */
		lAttempt++;
	}
	
	configASSERT( pcReturn );
    6d74:	697b      	ldr	r3, [r7, #20]
    6d76:	2b00      	cmp	r3, #0
    6d78:	d109      	bne.n	6d8e <MAC_obtain_buffer+0x16a>
    6d7a:	f04f 0328 	mov.w	r3, #40	; 0x28
    6d7e:	f383 8811 	msr	BASEPRI, r3
    6d82:	f3bf 8f6f 	isb	sy
    6d86:	f3bf 8f4f 	dsb	sy
    6d8a:	61fb      	str	r3, [r7, #28]
    6d8c:	e7fe      	b.n	6d8c <MAC_obtain_buffer+0x168>
	return pcReturn;
    6d8e:	697b      	ldr	r3, [r7, #20]
}
    6d90:	4618      	mov	r0, r3
    6d92:	f107 0724 	add.w	r7, r7, #36	; 0x24
    6d96:	46bd      	mov	sp, r7
    6d98:	bc80      	pop	{r7}
    6d9a:	4770      	bx	lr

00006d9c <MAC_release_buffer>:
/***************************************************************************//**
 * Return a buffer to the list of free buffers, it was in use, but is not now.
 *
 */
void MAC_release_buffer( unsigned char *pucBufferToRelease )
{
    6d9c:	b480      	push	{r7}
    6d9e:	b085      	sub	sp, #20
    6da0:	af00      	add	r7, sp, #0
    6da2:	6078      	str	r0, [r7, #4]
long lIndex;

	/* uip_buf is going to point to a different buffer - first ensure the buffer
	it is currently pointing to is marked as being free again. */
	for( lIndex = 0; lIndex < macNUM_BUFFERS; lIndex++ )
    6da4:	f04f 0300 	mov.w	r3, #0
    6da8:	60bb      	str	r3, [r7, #8]
    6daa:	e019      	b.n	6de0 <MAC_release_buffer+0x44>
	{
		if( pucBufferToRelease == &( xMACBuffers.ucBuffer[ lIndex ][ 0 ] ) )
    6dac:	f240 6374 	movw	r3, #1652	; 0x674
    6db0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6db4:	68ba      	ldr	r2, [r7, #8]
    6db6:	f44f 61ba 	mov.w	r1, #1488	; 0x5d0
    6dba:	fb01 f202 	mul.w	r2, r1, r2
    6dbe:	441a      	add	r2, r3
    6dc0:	687b      	ldr	r3, [r7, #4]
    6dc2:	429a      	cmp	r2, r3
    6dc4:	d108      	bne.n	6dd8 <MAC_release_buffer+0x3c>
		{
			/* This is the buffer in use, mark it as being free. */
			ucMACBufferInUse[ lIndex ] = pdFALSE;
    6dc6:	68ba      	ldr	r2, [r7, #8]
    6dc8:	f642 7324 	movw	r3, #12068	; 0x2f24
    6dcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6dd0:	f04f 0100 	mov.w	r1, #0
    6dd4:	5499      	strb	r1, [r3, r2]
			break;
    6dd6:	e006      	b.n	6de6 <MAC_release_buffer+0x4a>
{
long lIndex;

	/* uip_buf is going to point to a different buffer - first ensure the buffer
	it is currently pointing to is marked as being free again. */
	for( lIndex = 0; lIndex < macNUM_BUFFERS; lIndex++ )
    6dd8:	68bb      	ldr	r3, [r7, #8]
    6dda:	f103 0301 	add.w	r3, r3, #1
    6dde:	60bb      	str	r3, [r7, #8]
    6de0:	68bb      	ldr	r3, [r7, #8]
    6de2:	2b06      	cmp	r3, #6
    6de4:	dde2      	ble.n	6dac <MAC_release_buffer+0x10>
			ucMACBufferInUse[ lIndex ] = pdFALSE;
			break;
		}
	}
	
	configASSERT( lIndex < macNUM_BUFFERS );
    6de6:	68bb      	ldr	r3, [r7, #8]
    6de8:	2b06      	cmp	r3, #6
    6dea:	dd09      	ble.n	6e00 <MAC_release_buffer+0x64>
    6dec:	f04f 0328 	mov.w	r3, #40	; 0x28
    6df0:	f383 8811 	msr	BASEPRI, r3
    6df4:	f3bf 8f6f 	isb	sy
    6df8:	f3bf 8f4f 	dsb	sy
    6dfc:	60fb      	str	r3, [r7, #12]
    6dfe:	e7fe      	b.n	6dfe <MAC_release_buffer+0x62>
}
    6e00:	f107 0714 	add.w	r7, r7, #20
    6e04:	46bd      	mov	sp, r7
    6e06:	bc80      	pop	{r7}
    6e08:	4770      	bx	lr
    6e0a:	bf00      	nop

00006e0c <MDIO_management_clock>:
static void
MDIO_management_clock
(
    int32_t clock
)
{
    6e0c:	b480      	push	{r7}
    6e0e:	b085      	sub	sp, #20
    6e10:	af00      	add	r7, sp, #0
    6e12:	6078      	str	r0, [r7, #4]
	int32_t volatile a;
    
    MAC_BITBAND->CSR9_MDC = (uint32_t)clock;
    6e14:	f240 0300 	movw	r3, #0
    6e18:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6e1c:	687a      	ldr	r2, [r7, #4]
    6e1e:	f8c3 2940 	str.w	r2, [r3, #2368]	; 0x940
    
	/* delay for 1us */
	for( a = 0; a < ONEMICROSECOND; a++ ){}
    6e22:	f04f 0300 	mov.w	r3, #0
    6e26:	60fb      	str	r3, [r7, #12]
    6e28:	e003      	b.n	6e32 <MDIO_management_clock+0x26>
    6e2a:	68fb      	ldr	r3, [r7, #12]
    6e2c:	f103 0301 	add.w	r3, r3, #1
    6e30:	60fb      	str	r3, [r7, #12]
    6e32:	68fb      	ldr	r3, [r7, #12]
    6e34:	2b13      	cmp	r3, #19
    6e36:	d9f8      	bls.n	6e2a <MDIO_management_clock+0x1e>
}
    6e38:	f107 0714 	add.w	r7, r7, #20
    6e3c:	46bd      	mov	sp, r7
    6e3e:	bc80      	pop	{r7}
    6e40:	4770      	bx	lr
    6e42:	bf00      	nop

00006e44 <MDIO_send_cmd>:
MDIO_send_cmd
(
    uint8_t regad,
    mdio_cmd_t mdio_cmd
)
{
    6e44:	b580      	push	{r7, lr}
    6e46:	b084      	sub	sp, #16
    6e48:	af00      	add	r7, sp, #0
    6e4a:	4602      	mov	r2, r0
    6e4c:	460b      	mov	r3, r1
    6e4e:	71fa      	strb	r2, [r7, #7]
    6e50:	71bb      	strb	r3, [r7, #6]
    int32_t i;
    uint16_t mask, data;

    /* enable MII output */
    MAC_BITBAND->CSR9_MDEN = 1;
    6e52:	f240 0300 	movw	r3, #0
    6e56:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6e5a:	f04f 0201 	mov.w	r2, #1
    6e5e:	f8c3 2948 	str.w	r2, [r3, #2376]	; 0x948

    /* send 32 1's preamble */
    MAC_BITBAND->CSR9_MDO = 1;
    6e62:	f240 0300 	movw	r3, #0
    6e66:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6e6a:	f04f 0201 	mov.w	r2, #1
    6e6e:	f8c3 2944 	str.w	r2, [r3, #2372]	; 0x944
    for (i = 0; i < PREAMBLECOUNT; i++) {
    6e72:	f04f 0300 	mov.w	r3, #0
    6e76:	60bb      	str	r3, [r7, #8]
    6e78:	e00b      	b.n	6e92 <MDIO_send_cmd+0x4e>
    	MDIO_management_clock( 0 );
    6e7a:	f04f 0000 	mov.w	r0, #0
    6e7e:	f7ff ffc5 	bl	6e0c <MDIO_management_clock>
    	MDIO_management_clock( 1 );
    6e82:	f04f 0001 	mov.w	r0, #1
    6e86:	f7ff ffc1 	bl	6e0c <MDIO_management_clock>
    /* enable MII output */
    MAC_BITBAND->CSR9_MDEN = 1;

    /* send 32 1's preamble */
    MAC_BITBAND->CSR9_MDO = 1;
    for (i = 0; i < PREAMBLECOUNT; i++) {
    6e8a:	68bb      	ldr	r3, [r7, #8]
    6e8c:	f103 0301 	add.w	r3, r3, #1
    6e90:	60bb      	str	r3, [r7, #8]
    6e92:	68bb      	ldr	r3, [r7, #8]
    6e94:	2b1f      	cmp	r3, #31
    6e96:	d9f0      	bls.n	6e7a <MDIO_send_cmd+0x36>
    	MDIO_management_clock( 0 );
    	MDIO_management_clock( 1 );
    }

    /* calculate data bits */
    data = MDIO_START |
    6e98:	79bb      	ldrb	r3, [r7, #6]
    6e9a:	2b00      	cmp	r3, #0
    6e9c:	d102      	bne.n	6ea4 <MDIO_send_cmd+0x60>
    6e9e:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    6ea2:	e001      	b.n	6ea8 <MDIO_send_cmd+0x64>
    6ea4:	f245 0202 	movw	r2, #20482	; 0x5002
    6ea8:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    6eac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6eb0:	f893 30e8 	ldrb.w	r3, [r3, #232]	; 0xe8
    6eb4:	ea4f 13c3 	mov.w	r3, r3, lsl #7
    6eb8:	b29b      	uxth	r3, r3
    6eba:	f403 6378 	and.w	r3, r3, #3968	; 0xf80
    6ebe:	ea42 0303 	orr.w	r3, r2, r3
    6ec2:	b29a      	uxth	r2, r3
    6ec4:	79fb      	ldrb	r3, [r7, #7]
    6ec6:	ea4f 0383 	mov.w	r3, r3, lsl #2
    6eca:	b29b      	uxth	r3, r3
    6ecc:	f003 037c 	and.w	r3, r3, #124	; 0x7c
    6ed0:	ea42 0303 	orr.w	r3, r2, r3
    6ed4:	81fb      	strh	r3, [r7, #14]
    	(( mdio_cmd == MDIO_CMD_READ ) ? MDIO_READ : MDIO_WRITE ) |
    	((g_mss_mac.phy_address << MDIO_ADDR_OFFSET) & MDIO_ADDR_MASK) |
    	((regad << MDIO_REG_ADDR_OFFSET) & MDIO_REG_ADDR_MASK);

    /* sent out */
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    6ed6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    6eda:	81bb      	strh	r3, [r7, #12]
    6edc:	e02b      	b.n	6f36 <MDIO_send_cmd+0xf2>
    {
        if ((mask == 0x2) && (mdio_cmd == MDIO_CMD_READ)) {
    6ede:	89bb      	ldrh	r3, [r7, #12]
    6ee0:	2b02      	cmp	r3, #2
    6ee2:	d10a      	bne.n	6efa <MDIO_send_cmd+0xb6>
    6ee4:	79bb      	ldrb	r3, [r7, #6]
    6ee6:	2b00      	cmp	r3, #0
    6ee8:	d107      	bne.n	6efa <MDIO_send_cmd+0xb6>
    		/* enable MII input */
            MAC_BITBAND->CSR9_MDEN = 0;
    6eea:	f240 0300 	movw	r3, #0
    6eee:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6ef2:	f04f 0200 	mov.w	r2, #0
    6ef6:	f8c3 2948 	str.w	r2, [r3, #2376]	; 0x948
        }

    	MDIO_management_clock( 0 );
    6efa:	f04f 0000 	mov.w	r0, #0
    6efe:	f7ff ff85 	bl	6e0c <MDIO_management_clock>

        /* prepare MDO */
        MAC_BITBAND->CSR9_MDO = (uint32_t)((mask & data) != 0 ? 1UL : 0UL);
    6f02:	f240 0300 	movw	r3, #0
    6f06:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6f0a:	89b9      	ldrh	r1, [r7, #12]
    6f0c:	89fa      	ldrh	r2, [r7, #14]
    6f0e:	ea01 0202 	and.w	r2, r1, r2
    6f12:	b292      	uxth	r2, r2
    6f14:	2a00      	cmp	r2, #0
    6f16:	d002      	beq.n	6f1e <MDIO_send_cmd+0xda>
    6f18:	f04f 0201 	mov.w	r2, #1
    6f1c:	e001      	b.n	6f22 <MDIO_send_cmd+0xde>
    6f1e:	f04f 0200 	mov.w	r2, #0
    6f22:	f8c3 2944 	str.w	r2, [r3, #2372]	; 0x944
        
    	MDIO_management_clock( 1 );
    6f26:	f04f 0001 	mov.w	r0, #1
    6f2a:	f7ff ff6f 	bl	6e0c <MDIO_management_clock>
    	(( mdio_cmd == MDIO_CMD_READ ) ? MDIO_READ : MDIO_WRITE ) |
    	((g_mss_mac.phy_address << MDIO_ADDR_OFFSET) & MDIO_ADDR_MASK) |
    	((regad << MDIO_REG_ADDR_OFFSET) & MDIO_REG_ADDR_MASK);

    /* sent out */
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    6f2e:	89bb      	ldrh	r3, [r7, #12]
    6f30:	ea4f 0353 	mov.w	r3, r3, lsr #1
    6f34:	81bb      	strh	r3, [r7, #12]
    6f36:	89bb      	ldrh	r3, [r7, #12]
    6f38:	2b00      	cmp	r3, #0
    6f3a:	d1d0      	bne.n	6ede <MDIO_send_cmd+0x9a>
        /* prepare MDO */
        MAC_BITBAND->CSR9_MDO = (uint32_t)((mask & data) != 0 ? 1UL : 0UL);
        
    	MDIO_management_clock( 1 );
    }
}
    6f3c:	f107 0710 	add.w	r7, r7, #16
    6f40:	46bd      	mov	sp, r7
    6f42:	bd80      	pop	{r7, pc}

00006f44 <MDIO_read>:
static uint16_t
MDIO_read
(
    uint8_t regad
)
{
    6f44:	b580      	push	{r7, lr}
    6f46:	b084      	sub	sp, #16
    6f48:	af00      	add	r7, sp, #0
    6f4a:	4603      	mov	r3, r0
    6f4c:	71fb      	strb	r3, [r7, #7]
    uint16_t mask;
    uint16_t data;

    MDIO_send_cmd( regad, MDIO_CMD_READ);
    6f4e:	79fb      	ldrb	r3, [r7, #7]
    6f50:	4618      	mov	r0, r3
    6f52:	f04f 0100 	mov.w	r1, #0
    6f56:	f7ff ff75 	bl	6e44 <MDIO_send_cmd>

    /* read data */
    data = 0;
    6f5a:	f04f 0300 	mov.w	r3, #0
    6f5e:	81fb      	strh	r3, [r7, #14]
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    6f60:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    6f64:	81bb      	strh	r3, [r7, #12]
    6f66:	e018      	b.n	6f9a <MDIO_read+0x56>
    {
    	MDIO_management_clock( 0 );
    6f68:	f04f 0000 	mov.w	r0, #0
    6f6c:	f7ff ff4e 	bl	6e0c <MDIO_management_clock>

        /* read MDI */
        if(MAC_BITBAND-> CSR9_MDI != 0){
    6f70:	f240 0300 	movw	r3, #0
    6f74:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6f78:	f8d3 394c 	ldr.w	r3, [r3, #2380]	; 0x94c
    6f7c:	2b00      	cmp	r3, #0
    6f7e:	d004      	beq.n	6f8a <MDIO_read+0x46>
            data |= mask;
    6f80:	89fa      	ldrh	r2, [r7, #14]
    6f82:	89bb      	ldrh	r3, [r7, #12]
    6f84:	ea42 0303 	orr.w	r3, r2, r3
    6f88:	81fb      	strh	r3, [r7, #14]
        }

    	MDIO_management_clock( 1 );
    6f8a:	f04f 0001 	mov.w	r0, #1
    6f8e:	f7ff ff3d 	bl	6e0c <MDIO_management_clock>

    MDIO_send_cmd( regad, MDIO_CMD_READ);

    /* read data */
    data = 0;
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    6f92:	89bb      	ldrh	r3, [r7, #12]
    6f94:	ea4f 0353 	mov.w	r3, r3, lsr #1
    6f98:	81bb      	strh	r3, [r7, #12]
    6f9a:	89bb      	ldrh	r3, [r7, #12]
    6f9c:	2b00      	cmp	r3, #0
    6f9e:	d1e3      	bne.n	6f68 <MDIO_read+0x24>
        }

    	MDIO_management_clock( 1 );
    }

    MDIO_management_clock( 0 );
    6fa0:	f04f 0000 	mov.w	r0, #0
    6fa4:	f7ff ff32 	bl	6e0c <MDIO_management_clock>

    return data;
    6fa8:	89fb      	ldrh	r3, [r7, #14]
}
    6faa:	4618      	mov	r0, r3
    6fac:	f107 0710 	add.w	r7, r7, #16
    6fb0:	46bd      	mov	sp, r7
    6fb2:	bd80      	pop	{r7, pc}

00006fb4 <MDIO_write>:
MDIO_write
(
    uint8_t regad,
    uint16_t data
)
{
    6fb4:	b580      	push	{r7, lr}
    6fb6:	b084      	sub	sp, #16
    6fb8:	af00      	add	r7, sp, #0
    6fba:	4602      	mov	r2, r0
    6fbc:	460b      	mov	r3, r1
    6fbe:	71fa      	strb	r2, [r7, #7]
    6fc0:	80bb      	strh	r3, [r7, #4]
    uint16_t mask;

    MDIO_send_cmd(regad, MDIO_CMD_WRITE);
    6fc2:	79fb      	ldrb	r3, [r7, #7]
    6fc4:	4618      	mov	r0, r3
    6fc6:	f04f 0101 	mov.w	r1, #1
    6fca:	f7ff ff3b 	bl	6e44 <MDIO_send_cmd>

    /* write data */
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    6fce:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    6fd2:	81fb      	strh	r3, [r7, #14]
    6fd4:	e01d      	b.n	7012 <MDIO_write+0x5e>
    {
    	MDIO_management_clock( 0 );
    6fd6:	f04f 0000 	mov.w	r0, #0
    6fda:	f7ff ff17 	bl	6e0c <MDIO_management_clock>

        /* prepare MDO */
    	MAC_BITBAND->CSR9_MDO = (uint32_t)((mask & data) != 0 ? 1UL : 0UL);
    6fde:	f240 0300 	movw	r3, #0
    6fe2:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6fe6:	89f9      	ldrh	r1, [r7, #14]
    6fe8:	88ba      	ldrh	r2, [r7, #4]
    6fea:	ea01 0202 	and.w	r2, r1, r2
    6fee:	b292      	uxth	r2, r2
    6ff0:	2a00      	cmp	r2, #0
    6ff2:	d002      	beq.n	6ffa <MDIO_write+0x46>
    6ff4:	f04f 0201 	mov.w	r2, #1
    6ff8:	e001      	b.n	6ffe <MDIO_write+0x4a>
    6ffa:	f04f 0200 	mov.w	r2, #0
    6ffe:	f8c3 2944 	str.w	r2, [r3, #2372]	; 0x944

    	MDIO_management_clock( 1 );
    7002:	f04f 0001 	mov.w	r0, #1
    7006:	f7ff ff01 	bl	6e0c <MDIO_management_clock>
    uint16_t mask;

    MDIO_send_cmd(regad, MDIO_CMD_WRITE);

    /* write data */
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    700a:	89fb      	ldrh	r3, [r7, #14]
    700c:	ea4f 0353 	mov.w	r3, r3, lsr #1
    7010:	81fb      	strh	r3, [r7, #14]
    7012:	89fb      	ldrh	r3, [r7, #14]
    7014:	2b00      	cmp	r3, #0
    7016:	d1de      	bne.n	6fd6 <MDIO_write+0x22>
    	MAC_BITBAND->CSR9_MDO = (uint32_t)((mask & data) != 0 ? 1UL : 0UL);

    	MDIO_management_clock( 1 );
    }

    MDIO_management_clock( 0 );
    7018:	f04f 0000 	mov.w	r0, #0
    701c:	f7ff fef6 	bl	6e0c <MDIO_management_clock>
}
    7020:	f107 0710 	add.w	r7, r7, #16
    7024:	46bd      	mov	sp, r7
    7026:	bd80      	pop	{r7, pc}

00007028 <PHY_probe>:
 * Probe used PHY.
 *
 * return	PHY address. If PHY don't fount, returns 255.
 */
uint8_t PHY_probe( void )
{
    7028:	b580      	push	{r7, lr}
    702a:	b082      	sub	sp, #8
    702c:	af00      	add	r7, sp, #0
	uint8_t phy;
	uint8_t phy_found;
	uint16_t reg;

	phy_found = 0;
    702e:	f04f 0300 	mov.w	r3, #0
    7032:	717b      	strb	r3, [r7, #5]
	for (phy = MSS_PHY_ADDRESS_MIN; phy <= MSS_PHY_ADDRESS_MAX; phy++) {
    7034:	f04f 0300 	mov.w	r3, #0
    7038:	713b      	strb	r3, [r7, #4]
    703a:	e01e      	b.n	707a <PHY_probe+0x52>
		g_mss_mac.phy_address = phy;
    703c:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    7040:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7044:	793a      	ldrb	r2, [r7, #4]
    7046:	f883 20e8 	strb.w	r2, [r3, #232]	; 0xe8

        reg = MDIO_read( PHYREG_PHYID1R );
    704a:	f04f 0002 	mov.w	r0, #2
    704e:	f7ff ff79 	bl	6f44 <MDIO_read>
    7052:	4603      	mov	r3, r0
    7054:	80fb      	strh	r3, [r7, #6]

        if ((reg != 0x0000ffffUL) && (reg != 0x00000000UL)) {
    7056:	88fa      	ldrh	r2, [r7, #6]
    7058:	f64f 73ff 	movw	r3, #65535	; 0xffff
    705c:	429a      	cmp	r2, r3
    705e:	d008      	beq.n	7072 <PHY_probe+0x4a>
    7060:	88fb      	ldrh	r3, [r7, #6]
    7062:	2b00      	cmp	r3, #0
    7064:	d005      	beq.n	7072 <PHY_probe+0x4a>
        	phy_found = 1;
    7066:	f04f 0301 	mov.w	r3, #1
    706a:	717b      	strb	r3, [r7, #5]
        	phy = MSS_PHY_ADDRESS_MAX + 1;
    706c:	f04f 0320 	mov.w	r3, #32
    7070:	713b      	strb	r3, [r7, #4]
	uint8_t phy;
	uint8_t phy_found;
	uint16_t reg;

	phy_found = 0;
	for (phy = MSS_PHY_ADDRESS_MIN; phy <= MSS_PHY_ADDRESS_MAX; phy++) {
    7072:	793b      	ldrb	r3, [r7, #4]
    7074:	f103 0301 	add.w	r3, r3, #1
    7078:	713b      	strb	r3, [r7, #4]
    707a:	793b      	ldrb	r3, [r7, #4]
    707c:	2b1f      	cmp	r3, #31
    707e:	d9dd      	bls.n	703c <PHY_probe+0x14>
        	phy_found = 1;
        	phy = MSS_PHY_ADDRESS_MAX + 1;
        }
    }

    if( phy_found == 0 ) {
    7080:	797b      	ldrb	r3, [r7, #5]
    7082:	2b00      	cmp	r3, #0
    7084:	d107      	bne.n	7096 <PHY_probe+0x6e>
    	g_mss_mac.phy_address = MSS_PHY_ADDRESS_AUTO_DETECT;
    7086:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    708a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    708e:	f04f 32ff 	mov.w	r2, #4294967295
    7092:	f883 20e8 	strb.w	r2, [r3, #232]	; 0xe8
    }
    return g_mss_mac.phy_address;
    7096:	f64a 23e0 	movw	r3, #43744	; 0xaae0
    709a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    709e:	f893 30e8 	ldrb.w	r3, [r3, #232]	; 0xe8
}
    70a2:	4618      	mov	r0, r3
    70a4:	f107 0708 	add.w	r7, r7, #8
    70a8:	46bd      	mov	sp, r7
    70aa:	bd80      	pop	{r7, pc}

000070ac <PHY_reset>:

/***************************************************************************//**
 * Resets the PHY.
 */
void PHY_reset( void )
{
    70ac:	b580      	push	{r7, lr}
    70ae:	af00      	add	r7, sp, #0
	MDIO_write( PHYREG_MIIMCR, MIIMCR_RESET );
    70b0:	f04f 0000 	mov.w	r0, #0
    70b4:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    70b8:	f7ff ff7c 	bl	6fb4 <MDIO_write>
	MDIO_write( PHYREG_MIIMCR,
    70bc:	f04f 0000 	mov.w	r0, #0
    70c0:	f44f 5194 	mov.w	r1, #4736	; 0x1280
    70c4:	f7ff ff76 	bl	6fb4 <MDIO_write>
		MIIMCR_ENABLE_AUTONEGOTIATION |
		MIIMCR_RESTART_AUTONEGOTIATION |
		MIIMCR_COLLISION_TEST );
}
    70c8:	bd80      	pop	{r7, pc}
    70ca:	bf00      	nop

000070cc <PHY_auto_negotiate>:

/***************************************************************************//**
 * Restarts PHY auto-negotiation and wait until it's over.
 */
void PHY_auto_negotiate( void )
{
    70cc:	b580      	push	{r7, lr}
    70ce:	b082      	sub	sp, #8
    70d0:	af00      	add	r7, sp, #0
	uint16_t reg;

	reg = MDIO_read( PHYREG_MIIMCR );
    70d2:	f04f 0000 	mov.w	r0, #0
    70d6:	f7ff ff35 	bl	6f44 <MDIO_read>
    70da:	4603      	mov	r3, r0
    70dc:	80fb      	strh	r3, [r7, #6]
	MDIO_write( PHYREG_MIIMCR,
    70de:	88fb      	ldrh	r3, [r7, #6]
    70e0:	f443 5390 	orr.w	r3, r3, #4608	; 0x1200
    70e4:	b29b      	uxth	r3, r3
    70e6:	f04f 0000 	mov.w	r0, #0
    70ea:	4619      	mov	r1, r3
    70ec:	f7ff ff62 	bl	6fb4 <MDIO_write>
		(uint16_t)( MIIMCR_ENABLE_AUTONEGOTIATION |
		MIIMCR_RESTART_AUTONEGOTIATION |
		reg) );

	for( ;; ) {
		reg = MDIO_read( PHYREG_MIIMSR );
    70f0:	f04f 0001 	mov.w	r0, #1
    70f4:	f7ff ff26 	bl	6f44 <MDIO_read>
    70f8:	4603      	mov	r3, r0
    70fa:	80fb      	strh	r3, [r7, #6]
		if( (reg & MIIMSR_ANC) != 0 ) {
    70fc:	88fb      	ldrh	r3, [r7, #6]
    70fe:	f003 0320 	and.w	r3, r3, #32
    7102:	2b00      	cmp	r3, #0
    7104:	d104      	bne.n	7110 <PHY_auto_negotiate+0x44>
			break;
		} else {
			vTaskDelay( 200 );
    7106:	f04f 00c8 	mov.w	r0, #200	; 0xc8
    710a:	f009 fe69 	bl	10de0 <vTaskDelay>
		}
	}
    710e:	e7ef      	b.n	70f0 <PHY_auto_negotiate+0x24>
}
    7110:	bf00      	nop
    7112:	f107 0708 	add.w	r7, r7, #8
    7116:	46bd      	mov	sp, r7
    7118:	bd80      	pop	{r7, pc}
    711a:	bf00      	nop

0000711c <PHY_link_status>:
 * Returns link status.
 *
 * @return          #MAC_LINK_STATUS_LINK if link is up.
 */
uint8_t PHY_link_status( void )
{
    711c:	b580      	push	{r7, lr}
    711e:	b082      	sub	sp, #8
    7120:	af00      	add	r7, sp, #0
	uint8_t retval = 0;
    7122:	f04f 0300 	mov.w	r3, #0
    7126:	71fb      	strb	r3, [r7, #7]
	if(( MDIO_read( PHYREG_MIIMSR ) & MIIMSR_LINK ) != 0 ){
    7128:	f04f 0001 	mov.w	r0, #1
    712c:	f7ff ff0a 	bl	6f44 <MDIO_read>
    7130:	4603      	mov	r3, r0
    7132:	f003 0304 	and.w	r3, r3, #4
    7136:	2b00      	cmp	r3, #0
    7138:	d002      	beq.n	7140 <PHY_link_status+0x24>
		retval = MSS_MAC_LINK_STATUS_LINK;
    713a:	f04f 0301 	mov.w	r3, #1
    713e:	71fb      	strb	r3, [r7, #7]
	}
	return retval;
    7140:	79fb      	ldrb	r3, [r7, #7]
}
    7142:	4618      	mov	r0, r3
    7144:	f107 0708 	add.w	r7, r7, #8
    7148:	46bd      	mov	sp, r7
    714a:	bd80      	pop	{r7, pc}

0000714c <PHY_link_type>:
 * @return          the logical OR of the following values:
 *      #MAC_LINK_STATUS_100MB   - Connection is 100Mb
 *      #MAC_LINK_STATUS_FDX     - Connection is full duplex
 */
uint8_t PHY_link_type( void )
{
    714c:	b580      	push	{r7, lr}
    714e:	b082      	sub	sp, #8
    7150:	af00      	add	r7, sp, #0
	uint16_t diagnostic;
	uint8_t type = 0;
    7152:	f04f 0300 	mov.w	r3, #0
    7156:	71fb      	strb	r3, [r7, #7]

	diagnostic = MDIO_read( PHYREG_DR );
    7158:	f04f 0012 	mov.w	r0, #18
    715c:	f7ff fef2 	bl	6f44 <MDIO_read>
    7160:	4603      	mov	r3, r0
    7162:	80bb      	strh	r3, [r7, #4]

    if( (diagnostic & DR_DPLX) != 0 ) {
    7164:	88bb      	ldrh	r3, [r7, #4]
    7166:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    716a:	2b00      	cmp	r3, #0
    716c:	d002      	beq.n	7174 <PHY_link_type+0x28>
    	type = MSS_MAC_LINK_STATUS_FDX;
    716e:	f04f 0304 	mov.w	r3, #4
    7172:	71fb      	strb	r3, [r7, #7]
    }

    if( (diagnostic & DR_DATA_RATE) != 0 ) {
    7174:	88bb      	ldrh	r3, [r7, #4]
    7176:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    717a:	2b00      	cmp	r3, #0
    717c:	d003      	beq.n	7186 <PHY_link_type+0x3a>
    	type |= MSS_MAC_LINK_STATUS_100MB;
    717e:	79fb      	ldrb	r3, [r7, #7]
    7180:	f043 0302 	orr.w	r3, r3, #2
    7184:	71fb      	strb	r3, [r7, #7]
    }

    return type;
    7186:	79fb      	ldrb	r3, [r7, #7]
}
    7188:	4618      	mov	r0, r3
    718a:	f107 0708 	add.w	r7, r7, #8
    718e:	46bd      	mov	sp, r7
    7190:	bd80      	pop	{r7, pc}
    7192:	bf00      	nop

00007194 <PHY_set_link_type>:
void
PHY_set_link_type
(
    uint8_t type
)
{
    7194:	b580      	push	{r7, lr}
    7196:	b084      	sub	sp, #16
    7198:	af00      	add	r7, sp, #0
    719a:	4603      	mov	r3, r0
    719c:	71fb      	strb	r3, [r7, #7]
	uint16_t reg;

	reg = MDIO_read( PHYREG_ANAR );
    719e:	f04f 0004 	mov.w	r0, #4
    71a2:	f7ff fecf 	bl	6f44 <MDIO_read>
    71a6:	4603      	mov	r3, r0
    71a8:	81fb      	strh	r3, [r7, #14]
	reg |= ANAR_100FD | ANAR_100HD | ANAR_10FD | ANAR_10HD;
    71aa:	89fb      	ldrh	r3, [r7, #14]
    71ac:	f443 73f0 	orr.w	r3, r3, #480	; 0x1e0
    71b0:	81fb      	strh	r3, [r7, #14]

	if( (type & MSS_MAC_LINK_STATUS_100MB) == 0 ) {
    71b2:	79fb      	ldrb	r3, [r7, #7]
    71b4:	f003 0302 	and.w	r3, r3, #2
    71b8:	2b00      	cmp	r3, #0
    71ba:	d103      	bne.n	71c4 <PHY_set_link_type+0x30>
		reg &= ~(ANAR_100FD | ANAR_100HD);
    71bc:	89fb      	ldrh	r3, [r7, #14]
    71be:	f423 73c0 	bic.w	r3, r3, #384	; 0x180
    71c2:	81fb      	strh	r3, [r7, #14]
	}

	if( (type & MSS_MAC_LINK_STATUS_FDX) == 0 ) {
    71c4:	79fb      	ldrb	r3, [r7, #7]
    71c6:	f003 0304 	and.w	r3, r3, #4
    71ca:	2b00      	cmp	r3, #0
    71cc:	d103      	bne.n	71d6 <PHY_set_link_type+0x42>
		reg &= ~(ANAR_100FD | ANAR_10FD);
    71ce:	89fb      	ldrh	r3, [r7, #14]
    71d0:	f423 73a0 	bic.w	r3, r3, #320	; 0x140
    71d4:	81fb      	strh	r3, [r7, #14]
	}

	MDIO_write( PHYREG_ANAR, reg );
    71d6:	89fb      	ldrh	r3, [r7, #14]
    71d8:	f04f 0004 	mov.w	r0, #4
    71dc:	4619      	mov	r1, r3
    71de:	f7ff fee9 	bl	6fb4 <MDIO_write>
}
    71e2:	f107 0710 	add.w	r7, r7, #16
    71e6:	46bd      	mov	sp, r7
    71e8:	bd80      	pop	{r7, pc}
    71ea:	bf00      	nop

000071ec <PHY_set_loopback>:
uint16_t
PHY_set_loopback
(
   uint8_t enable
)
{
    71ec:	b580      	push	{r7, lr}
    71ee:	b084      	sub	sp, #16
    71f0:	af00      	add	r7, sp, #0
    71f2:	4603      	mov	r3, r0
    71f4:	71fb      	strb	r3, [r7, #7]

	uint16_t reg = 0;   
    71f6:	f04f 0300 	mov.w	r3, #0
    71fa:	81fb      	strh	r3, [r7, #14]
	

	reg = MDIO_read( PHYREG_MIIMCR );
    71fc:	f04f 0000 	mov.w	r0, #0
    7200:	f7ff fea0 	bl	6f44 <MDIO_read>
    7204:	4603      	mov	r3, r0
    7206:	81fb      	strh	r3, [r7, #14]
	// If set to one we need to set the LOCAL Phy loopback
	if(enable == 1)
    7208:	79fb      	ldrb	r3, [r7, #7]
    720a:	2b01      	cmp	r3, #1
    720c:	d104      	bne.n	7218 <PHY_set_loopback+0x2c>
		reg |= MIIMCR_LOOPBACK;
    720e:	89fb      	ldrh	r3, [r7, #14]
    7210:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    7214:	81fb      	strh	r3, [r7, #14]
    7216:	e003      	b.n	7220 <PHY_set_loopback+0x34>
	else // else we want to clear the bit..
		reg ^= MIIMCR_LOOPBACK;
    7218:	89fb      	ldrh	r3, [r7, #14]
    721a:	f483 4380 	eor.w	r3, r3, #16384	; 0x4000
    721e:	81fb      	strh	r3, [r7, #14]
	
	
	MDIO_write( PHYREG_MIIMCR,reg );
    7220:	89fb      	ldrh	r3, [r7, #14]
    7222:	f04f 0000 	mov.w	r0, #0
    7226:	4619      	mov	r1, r3
    7228:	f7ff fec4 	bl	6fb4 <MDIO_write>
	reg = MDIO_read( PHYREG_MIIMCR );
    722c:	f04f 0000 	mov.w	r0, #0
    7230:	f7ff fe88 	bl	6f44 <MDIO_read>
    7234:	4603      	mov	r3, r0
    7236:	81fb      	strh	r3, [r7, #14]
	
	return reg;
    7238:	89fb      	ldrh	r3, [r7, #14]
	
}
    723a:	4618      	mov	r0, r3
    723c:	f107 0710 	add.w	r7, r7, #16
    7240:	46bd      	mov	sp, r7
    7242:	bd80      	pop	{r7, pc}

00007244 <ACE_get_channel_type>:
channel_type_t
ACE_get_channel_type
(
    ace_channel_handle_t    channel_handle
)
{
    7244:	b480      	push	{r7}
    7246:	b085      	sub	sp, #20
    7248:	af00      	add	r7, sp, #0
    724a:	4603      	mov	r3, r0
    724c:	71fb      	strb	r3, [r7, #7]
    channel_type_t channel_type = VOLTAGE;
    724e:	f04f 0300 	mov.w	r3, #0
    7252:	73fb      	strb	r3, [r7, #15]
    
    ASSERT((int32_t)channel_handle < ACE_NB_OF_INPUT_CHANNELS);
    7254:	79fb      	ldrb	r3, [r7, #7]
    7256:	2b06      	cmp	r3, #6
    7258:	d900      	bls.n	725c <ACE_get_channel_type+0x18>
    725a:	be00      	bkpt	0x0000
    
    if((int32_t)channel_handle < ACE_NB_OF_INPUT_CHANNELS)
    725c:	79fb      	ldrb	r3, [r7, #7]
    725e:	2b06      	cmp	r3, #6
    7260:	d807      	bhi.n	7272 <ACE_get_channel_type+0x2e>
    {
        channel_type = channel_type_lut_h[channel_handle];
    7262:	79fa      	ldrb	r2, [r7, #7]
    7264:	f642 7338 	movw	r3, #12088	; 0x2f38
    7268:	f2c2 0300 	movt	r3, #8192	; 0x2000
    726c:	5c9b      	ldrb	r3, [r3, r2]
    726e:	73fb      	strb	r3, [r7, #15]
    7270:	e002      	b.n	7278 <ACE_get_channel_type+0x34>
    }
    else
    {
        channel_type = VOLTAGE;
    7272:	f04f 0300 	mov.w	r3, #0
    7276:	73fb      	strb	r3, [r7, #15]
    }
    
    return channel_type;
    7278:	7bfb      	ldrb	r3, [r7, #15]
}
    727a:	4618      	mov	r0, r3
    727c:	f107 0714 	add.w	r7, r7, #20
    7280:	46bd      	mov	sp, r7
    7282:	bc80      	pop	{r7}
    7284:	4770      	bx	lr
    7286:	bf00      	nop

00007288 <ACE_convert_adc_input_to_mV>:
uint32_t ACE_convert_adc_input_to_mV
(
    ace_channel_handle_t    channel_handle,
    uint16_t                sample_value
)
{
    7288:	b480      	push	{r7}
    728a:	b085      	sub	sp, #20
    728c:	af00      	add	r7, sp, #0
    728e:	4602      	mov	r2, r0
    7290:	460b      	mov	r3, r1
    7292:	71fa      	strb	r2, [r7, #7]
    7294:	80bb      	strh	r3, [r7, #4]
    uint32_t voltage;
    adc_channel_id_t channel_id;
    uint8_t adc_id;
    
    channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    7296:	79fa      	ldrb	r2, [r7, #7]
    7298:	f240 0350 	movw	r3, #80	; 0x50
    729c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    72a0:	ea4f 1202 	mov.w	r2, r2, lsl #4
    72a4:	4413      	add	r3, r2
    72a6:	791b      	ldrb	r3, [r3, #4]
    72a8:	73bb      	strb	r3, [r7, #14]
    adc_id = (uint8_t)channel_id >> 4u;
    72aa:	7bbb      	ldrb	r3, [r7, #14]
    72ac:	ea4f 1313 	mov.w	r3, r3, lsr #4
    72b0:	73fb      	strb	r3, [r7, #15]
    voltage = ( g_ace_adc_config[adc_id].va_ref * (uint32_t)sample_value ) / g_ace_adc_config[adc_id].adc_resolution;
    72b2:	7bfb      	ldrb	r3, [r7, #15]
    72b4:	f240 0248 	movw	r2, #72	; 0x48
    72b8:	f2c2 0200 	movt	r2, #8192	; 0x2000
    72bc:	ea4f 0383 	mov.w	r3, r3, lsl #2
    72c0:	4413      	add	r3, r2
    72c2:	885b      	ldrh	r3, [r3, #2]
    72c4:	88ba      	ldrh	r2, [r7, #4]
    72c6:	fb02 f203 	mul.w	r2, r2, r3
    72ca:	7bf9      	ldrb	r1, [r7, #15]
    72cc:	f240 0348 	movw	r3, #72	; 0x48
    72d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    72d4:	f833 3021 	ldrh.w	r3, [r3, r1, lsl #2]
    72d8:	fbb2 f3f3 	udiv	r3, r2, r3
    72dc:	60bb      	str	r3, [r7, #8]
    
    return voltage;
    72de:	68bb      	ldr	r3, [r7, #8]
}
    72e0:	4618      	mov	r0, r3
    72e2:	f107 0714 	add.w	r7, r7, #20
    72e6:	46bd      	mov	sp, r7
    72e8:	bc80      	pop	{r7}
    72ea:	4770      	bx	lr

000072ec <ace_init_convert>:

/*-------------------------------------------------------------------------*//**
 *
 */
void ace_init_convert(void)
{
    72ec:	b480      	push	{r7}
    72ee:	b087      	sub	sp, #28
    72f0:	af00      	add	r7, sp, #0
    uint8_t abps_idx;
    int32_t channel;
    uint32_t saved_pc2_ctrl;
    
    /* Pause the SSE PC2 while accesses to ACB from APB3 are taking place. */
    saved_pc2_ctrl = ACE->PC2_CTRL;
    72f2:	f240 0300 	movw	r3, #0
    72f6:	f2c4 0302 	movt	r3, #16386	; 0x4002
    72fa:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
    72fe:	60fb      	str	r3, [r7, #12]
    ACE->PC2_CTRL = 0u;
    7300:	f240 0300 	movw	r3, #0
    7304:	f2c4 0302 	movt	r3, #16386	; 0x4002
    7308:	f04f 0200 	mov.w	r2, #0
    730c:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    
    /* Populate the g_gdec_lut look-up table. */
    for(abps_idx = 0u; abps_idx < MAX_NB_OF_APBS; ++abps_idx)
    7310:	f04f 0300 	mov.w	r3, #0
    7314:	71fb      	strb	r3, [r7, #7]
    7316:	e039      	b.n	738c <ace_init_convert+0xa0>
    {
        uint8_t quad_id;
        uint8_t acb_config_byte;
        uint8_t channel_is_abps2;
        
        quad_id = abps_idx / 2u;
    7318:	79fb      	ldrb	r3, [r7, #7]
    731a:	ea4f 0353 	mov.w	r3, r3, lsr #1
    731e:	747b      	strb	r3, [r7, #17]
        acb_config_byte = ACE->ACB_DATA[quad_id].b8;
    7320:	f240 0200 	movw	r2, #0
    7324:	f2c4 0202 	movt	r2, #16386	; 0x4002
    7328:	7c79      	ldrb	r1, [r7, #17]
    732a:	460b      	mov	r3, r1
    732c:	ea4f 0343 	mov.w	r3, r3, lsl #1
    7330:	440b      	add	r3, r1
    7332:	ea4f 1303 	mov.w	r3, r3, lsl #4
    7336:	4413      	add	r3, r2
    7338:	f503 7308 	add.w	r3, r3, #544	; 0x220
    733c:	791b      	ldrb	r3, [r3, #4]
    733e:	74bb      	strb	r3, [r7, #18]
        channel_is_abps2 = abps_idx & 0x01u;
    7340:	79fb      	ldrb	r3, [r7, #7]
    7342:	f003 0301 	and.w	r3, r3, #1
    7346:	74fb      	strb	r3, [r7, #19]
        if(channel_is_abps2)
    7348:	7cfb      	ldrb	r3, [r7, #19]
    734a:	2b00      	cmp	r3, #0
    734c:	d00d      	beq.n	736a <ace_init_convert+0x7e>
        {
            /* ABPS2 */
            g_gdec_lut[abps_idx] = (acb_config_byte >> 5u) & 0x03u;
    734e:	79f9      	ldrb	r1, [r7, #7]
    7350:	7cbb      	ldrb	r3, [r7, #18]
    7352:	ea4f 1353 	mov.w	r3, r3, lsr #5
    7356:	b2db      	uxtb	r3, r3
    7358:	461a      	mov	r2, r3
    735a:	f002 0203 	and.w	r2, r2, #3
    735e:	f642 732c 	movw	r3, #12076	; 0x2f2c
    7362:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7366:	545a      	strb	r2, [r3, r1]
    7368:	e00c      	b.n	7384 <ace_init_convert+0x98>
        }
        else
        {
            /* ABPS1 */
            g_gdec_lut[abps_idx] = (acb_config_byte >> 1u) & 0x03u;
    736a:	79f9      	ldrb	r1, [r7, #7]
    736c:	7cbb      	ldrb	r3, [r7, #18]
    736e:	ea4f 0353 	mov.w	r3, r3, lsr #1
    7372:	b2db      	uxtb	r3, r3
    7374:	461a      	mov	r2, r3
    7376:	f002 0203 	and.w	r2, r2, #3
    737a:	f642 732c 	movw	r3, #12076	; 0x2f2c
    737e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7382:	545a      	strb	r2, [r3, r1]
    /* Pause the SSE PC2 while accesses to ACB from APB3 are taking place. */
    saved_pc2_ctrl = ACE->PC2_CTRL;
    ACE->PC2_CTRL = 0u;
    
    /* Populate the g_gdec_lut look-up table. */
    for(abps_idx = 0u; abps_idx < MAX_NB_OF_APBS; ++abps_idx)
    7384:	79fb      	ldrb	r3, [r7, #7]
    7386:	f103 0301 	add.w	r3, r3, #1
    738a:	71fb      	strb	r3, [r7, #7]
    738c:	79fb      	ldrb	r3, [r7, #7]
    738e:	2b09      	cmp	r3, #9
    7390:	d9c2      	bls.n	7318 <ace_init_convert+0x2c>
            g_gdec_lut[abps_idx] = (acb_config_byte >> 1u) & 0x03u;
        }
    }
    
    /* Populate the channel_type_lut_h look-up table. */
    for(channel = 0; channel < ACE_NB_OF_INPUT_CHANNELS; ++channel)
    7392:	f04f 0300 	mov.w	r3, #0
    7396:	60bb      	str	r3, [r7, #8]
    7398:	e073      	b.n	7482 <ace_init_convert+0x196>
        uint8_t quad_id;
        uint8_t acb_config_byte;
        adc_channel_id_t channel_id;
        channel_type_t channel_type;
    
        channel_id = g_ace_channel_desc_table[channel].signal_id;
    739a:	68ba      	ldr	r2, [r7, #8]
    739c:	f240 0350 	movw	r3, #80	; 0x50
    73a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    73a4:	ea4f 1202 	mov.w	r2, r2, lsl #4
    73a8:	4413      	add	r3, r2
    73aa:	791b      	ldrb	r3, [r3, #4]
    73ac:	75bb      	strb	r3, [r7, #22]
        quad_id = channel_quad_lut[channel_id];
    73ae:	7dba      	ldrb	r2, [r7, #22]
    73b0:	f64c 7384 	movw	r3, #53124	; 0xcf84
    73b4:	f2c0 0301 	movt	r3, #1
    73b8:	5c9b      	ldrb	r3, [r3, r2]
    73ba:	753b      	strb	r3, [r7, #20]
        
        switch (channel_type_lut[channel_id])
    73bc:	7dba      	ldrb	r2, [r7, #22]
    73be:	f64c 7354 	movw	r3, #53076	; 0xcf54
    73c2:	f2c0 0301 	movt	r3, #1
    73c6:	5c9b      	ldrb	r3, [r3, r2]
    73c8:	2b01      	cmp	r3, #1
    73ca:	d007      	beq.n	73dc <ace_init_convert+0xf0>
    73cc:	2b02      	cmp	r3, #2
    73ce:	d027      	beq.n	7420 <ace_init_convert+0x134>
    73d0:	2b00      	cmp	r3, #0
    73d2:	d147      	bne.n	7464 <ace_init_convert+0x178>
        {
            case VOLTAGE_CHANNEL:
                channel_type = VOLTAGE;
    73d4:	f04f 0300 	mov.w	r3, #0
    73d8:	75fb      	strb	r3, [r7, #23]
                break;
    73da:	e047      	b.n	746c <ace_init_convert+0x180>
                
            case CURRENT_CHANNEL:
                ASSERT( quad_id != INVALID_QUAD_ID );
    73dc:	7d3b      	ldrb	r3, [r7, #20]
    73de:	2bff      	cmp	r3, #255	; 0xff
    73e0:	d100      	bne.n	73e4 <ace_init_convert+0xf8>
    73e2:	be00      	bkpt	0x0000
                acb_config_byte = ACE->ACB_DATA[quad_id].b9;
    73e4:	f240 0200 	movw	r2, #0
    73e8:	f2c4 0202 	movt	r2, #16386	; 0x4002
    73ec:	7d39      	ldrb	r1, [r7, #20]
    73ee:	460b      	mov	r3, r1
    73f0:	ea4f 0343 	mov.w	r3, r3, lsl #1
    73f4:	440b      	add	r3, r1
    73f6:	ea4f 1303 	mov.w	r3, r3, lsl #4
    73fa:	4413      	add	r3, r2
    73fc:	f503 7308 	add.w	r3, r3, #544	; 0x220
    7400:	7a1b      	ldrb	r3, [r3, #8]
    7402:	757b      	strb	r3, [r7, #21]
                if ( acb_config_byte & 0x01u )
    7404:	7d7b      	ldrb	r3, [r7, #21]
    7406:	f003 0301 	and.w	r3, r3, #1
    740a:	b2db      	uxtb	r3, r3
    740c:	2b00      	cmp	r3, #0
    740e:	d003      	beq.n	7418 <ace_init_convert+0x12c>
                {
                    channel_type = VOLTAGE;
    7410:	f04f 0300 	mov.w	r3, #0
    7414:	75fb      	strb	r3, [r7, #23]
                }
                else
                {
                    channel_type = CURRENT;
                }
                break;
    7416:	e029      	b.n	746c <ace_init_convert+0x180>
                {
                    channel_type = VOLTAGE;
                }
                else
                {
                    channel_type = CURRENT;
    7418:	f04f 0301 	mov.w	r3, #1
    741c:	75fb      	strb	r3, [r7, #23]
                }
                break;
    741e:	e025      	b.n	746c <ace_init_convert+0x180>
            
            case TEMPERATURE_CHANNEL:
                ASSERT( quad_id != INVALID_QUAD_ID );
    7420:	7d3b      	ldrb	r3, [r7, #20]
    7422:	2bff      	cmp	r3, #255	; 0xff
    7424:	d100      	bne.n	7428 <ace_init_convert+0x13c>
    7426:	be00      	bkpt	0x0000
                acb_config_byte = ACE->ACB_DATA[quad_id].b10;
    7428:	f240 0200 	movw	r2, #0
    742c:	f2c4 0202 	movt	r2, #16386	; 0x4002
    7430:	7d39      	ldrb	r1, [r7, #20]
    7432:	460b      	mov	r3, r1
    7434:	ea4f 0343 	mov.w	r3, r3, lsl #1
    7438:	440b      	add	r3, r1
    743a:	ea4f 1303 	mov.w	r3, r3, lsl #4
    743e:	4413      	add	r3, r2
    7440:	f503 730a 	add.w	r3, r3, #552	; 0x228
    7444:	791b      	ldrb	r3, [r3, #4]
    7446:	757b      	strb	r3, [r7, #21]
                if ( acb_config_byte & 0x01u )
    7448:	7d7b      	ldrb	r3, [r7, #21]
    744a:	f003 0301 	and.w	r3, r3, #1
    744e:	b2db      	uxtb	r3, r3
    7450:	2b00      	cmp	r3, #0
    7452:	d003      	beq.n	745c <ace_init_convert+0x170>
                {
                    channel_type = VOLTAGE;
    7454:	f04f 0300 	mov.w	r3, #0
    7458:	75fb      	strb	r3, [r7, #23]
                }
                else
                {
                    channel_type = TEMPERATURE;
                }
                break;
    745a:	e007      	b.n	746c <ace_init_convert+0x180>
                {
                    channel_type = VOLTAGE;
                }
                else
                {
                    channel_type = TEMPERATURE;
    745c:	f04f 0302 	mov.w	r3, #2
    7460:	75fb      	strb	r3, [r7, #23]
                }
                break;
    7462:	e003      	b.n	746c <ace_init_convert+0x180>
                
            default:
                ASSERT(0);
    7464:	be00      	bkpt	0x0000
                channel_type = VOLTAGE;
    7466:	f04f 0300 	mov.w	r3, #0
    746a:	75fb      	strb	r3, [r7, #23]
                break;
        }
        
        channel_type_lut_h[channel] = channel_type;
    746c:	68ba      	ldr	r2, [r7, #8]
    746e:	f642 7338 	movw	r3, #12088	; 0x2f38
    7472:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7476:	7df9      	ldrb	r1, [r7, #23]
    7478:	5499      	strb	r1, [r3, r2]
            g_gdec_lut[abps_idx] = (acb_config_byte >> 1u) & 0x03u;
        }
    }
    
    /* Populate the channel_type_lut_h look-up table. */
    for(channel = 0; channel < ACE_NB_OF_INPUT_CHANNELS; ++channel)
    747a:	68bb      	ldr	r3, [r7, #8]
    747c:	f103 0301 	add.w	r3, r3, #1
    7480:	60bb      	str	r3, [r7, #8]
    7482:	68bb      	ldr	r3, [r7, #8]
    7484:	2b06      	cmp	r3, #6
    7486:	dd88      	ble.n	739a <ace_init_convert+0xae>
        
        channel_type_lut_h[channel] = channel_type;
    }
    
    /* Restore SSE PC2 operations. */
    ACE->PC2_CTRL = saved_pc2_ctrl;
    7488:	f240 0300 	movw	r3, #0
    748c:	f2c4 0302 	movt	r3, #16386	; 0x4002
    7490:	68fa      	ldr	r2, [r7, #12]
    7492:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
}
    7496:	f107 071c 	add.w	r7, r7, #28
    749a:	46bd      	mov	sp, r7
    749c:	bc80      	pop	{r7}
    749e:	4770      	bx	lr

000074a0 <ACE_convert_to_mV>:
int32_t ACE_convert_to_mV
(
    ace_channel_handle_t    channel_handle,
    uint16_t                sample_value
)
{
    74a0:	b480      	push	{r7}
    74a2:	b08d      	sub	sp, #52	; 0x34
    74a4:	af00      	add	r7, sp, #0
    74a6:	4602      	mov	r2, r0
    74a8:	460b      	mov	r3, r1
    74aa:	71fa      	strb	r2, [r7, #7]
    74ac:	80bb      	strh	r3, [r7, #4]
    int32_t voltage;
    adc_channel_id_t channel_id;
    uint8_t adc_id;
    
    channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    74ae:	79fa      	ldrb	r2, [r7, #7]
    74b0:	f240 0350 	movw	r3, #80	; 0x50
    74b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    74b8:	ea4f 1202 	mov.w	r2, r2, lsl #4
    74bc:	4413      	add	r3, r2
    74be:	791b      	ldrb	r3, [r3, #4]
    74c0:	74bb      	strb	r3, [r7, #18]
    adc_id = (uint8_t)channel_id >> 4u;
    74c2:	7cbb      	ldrb	r3, [r7, #18]
    74c4:	ea4f 1313 	mov.w	r3, r3, lsr #4
    74c8:	74fb      	strb	r3, [r7, #19]
    
    if (NON_ABPS_CHANNEL == abps_channel_lut[channel_id])
    74ca:	7cba      	ldrb	r2, [r7, #18]
    74cc:	f64c 73b4 	movw	r3, #53172	; 0xcfb4
    74d0:	f2c0 0301 	movt	r3, #1
    74d4:	5c9b      	ldrb	r3, [r3, r2]
    74d6:	2bff      	cmp	r3, #255	; 0xff
    74d8:	d11c      	bne.n	7514 <ACE_convert_to_mV+0x74>
    {
        uint32_t adc_voltage;
        
        adc_voltage = ( g_ace_adc_config[adc_id].va_ref * (uint32_t)sample_value ) / PPE_SAMPLES_RESOLUTION;
    74da:	7cfb      	ldrb	r3, [r7, #19]
    74dc:	f240 0248 	movw	r2, #72	; 0x48
    74e0:	f2c2 0200 	movt	r2, #8192	; 0x2000
    74e4:	ea4f 0383 	mov.w	r3, r3, lsl #2
    74e8:	4413      	add	r3, r2
    74ea:	885b      	ldrh	r3, [r3, #2]
    74ec:	88ba      	ldrh	r2, [r7, #4]
    74ee:	fb02 f203 	mul.w	r2, r2, r3
    74f2:	f240 1301 	movw	r3, #257	; 0x101
    74f6:	f2c0 0310 	movt	r3, #16
    74fa:	fba3 1302 	umull	r1, r3, r3, r2
    74fe:	ebc3 0202 	rsb	r2, r3, r2
    7502:	ea4f 0252 	mov.w	r2, r2, lsr #1
    7506:	4413      	add	r3, r2
    7508:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    750c:	617b      	str	r3, [r7, #20]
        voltage = (int32_t)adc_voltage;
    750e:	697b      	ldr	r3, [r7, #20]
    7510:	60fb      	str	r3, [r7, #12]
    7512:	e03d      	b.n	7590 <ACE_convert_to_mV+0xf0>
        int32_t gain;
        int32_t va_ref;
        int32_t sample;
        int32_t ppe_resolution;
        
        apbs_idx = abps_idx_lut[channel_id];
    7514:	7cba      	ldrb	r2, [r7, #18]
    7516:	f64c 73e4 	movw	r3, #53220	; 0xcfe4
    751a:	f2c0 0301 	movt	r3, #1
    751e:	5c9b      	ldrb	r3, [r3, r2]
    7520:	76fb      	strb	r3, [r7, #27]
        gdec = g_gdec_lut[apbs_idx];
    7522:	7efa      	ldrb	r2, [r7, #27]
    7524:	f642 732c 	movw	r3, #12076	; 0x2f2c
    7528:	f2c2 0300 	movt	r3, #8192	; 0x2000
    752c:	5c9b      	ldrb	r3, [r3, r2]
    752e:	76bb      	strb	r3, [r7, #26]

        sample = (int32_t)sample_value;
    7530:	88bb      	ldrh	r3, [r7, #4]
    7532:	62bb      	str	r3, [r7, #40]	; 0x28
        ppe_resolution = (int32_t)PPE_SAMPLES_RESOLUTION;
    7534:	f640 73ff 	movw	r3, #4095	; 0xfff
    7538:	62fb      	str	r3, [r7, #44]	; 0x2c
        gain = (int32_t)apbs_gain_lut[gdec];
    753a:	7eba      	ldrb	r2, [r7, #26]
    753c:	f24d 0314 	movw	r3, #53268	; 0xd014
    7540:	f2c0 0301 	movt	r3, #1
    7544:	5c9b      	ldrb	r3, [r3, r2]
    7546:	623b      	str	r3, [r7, #32]
        range = (int32_t)apbs_range[gdec];
    7548:	7eba      	ldrb	r2, [r7, #26]
    754a:	f24d 0318 	movw	r3, #53272	; 0xd018
    754e:	f2c0 0301 	movt	r3, #1
    7552:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    7556:	b21b      	sxth	r3, r3
    7558:	61fb      	str	r3, [r7, #28]
        va_ref = (int32_t)g_ace_adc_config[adc_id].va_ref;
    755a:	7cfb      	ldrb	r3, [r7, #19]
    755c:	f240 0248 	movw	r2, #72	; 0x48
    7560:	f2c2 0200 	movt	r2, #8192	; 0x2000
    7564:	ea4f 0383 	mov.w	r3, r3, lsl #2
    7568:	4413      	add	r3, r2
    756a:	885b      	ldrh	r3, [r3, #2]
    756c:	627b      	str	r3, [r7, #36]	; 0x24
        
        voltage = range - (((ppe_resolution - sample) * (va_ref * gain)) / ppe_resolution);
    756e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    7570:	6abb      	ldr	r3, [r7, #40]	; 0x28
    7572:	ebc3 0302 	rsb	r3, r3, r2
    7576:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    7578:	6a39      	ldr	r1, [r7, #32]
    757a:	fb01 f202 	mul.w	r2, r1, r2
    757e:	fb02 f203 	mul.w	r2, r2, r3
    7582:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    7584:	fb92 f3f3 	sdiv	r3, r2, r3
    7588:	69fa      	ldr	r2, [r7, #28]
    758a:	ebc3 0302 	rsb	r3, r3, r2
    758e:	60fb      	str	r3, [r7, #12]
    }
    return voltage;
    7590:	68fb      	ldr	r3, [r7, #12]
}
    7592:	4618      	mov	r0, r3
    7594:	f107 0734 	add.w	r7, r7, #52	; 0x34
    7598:	46bd      	mov	sp, r7
    759a:	bc80      	pop	{r7}
    759c:	4770      	bx	lr
    759e:	bf00      	nop

000075a0 <ACE_convert_to_mA>:
uint32_t ACE_convert_to_mA
(
    ace_channel_handle_t    channel_handle,
    uint16_t                sample_value
)
{
    75a0:	b580      	push	{r7, lr}
    75a2:	b086      	sub	sp, #24
    75a4:	af00      	add	r7, sp, #0
    75a6:	4602      	mov	r2, r0
    75a8:	460b      	mov	r3, r1
    75aa:	71fa      	strb	r2, [r7, #7]
    75ac:	80bb      	strh	r3, [r7, #4]
    uint32_t current = 0u;
    75ae:	f04f 0300 	mov.w	r3, #0
    75b2:	60bb      	str	r3, [r7, #8]
    
    ASSERT((int32_t)channel_handle < ACE_NB_OF_INPUT_CHANNELS);
    75b4:	79fb      	ldrb	r3, [r7, #7]
    75b6:	2b06      	cmp	r3, #6
    75b8:	d900      	bls.n	75bc <ACE_convert_to_mA+0x1c>
    75ba:	be00      	bkpt	0x0000
    
    if((int32_t)channel_handle < ACE_NB_OF_INPUT_CHANNELS)
    75bc:	79fb      	ldrb	r3, [r7, #7]
    75be:	2b06      	cmp	r3, #6
    75c0:	d842      	bhi.n	7648 <ACE_convert_to_mA+0xa8>
    {
        adc_channel_id_t channel_id;
        uint8_t current_monitor_idx;
        
        channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    75c2:	79fa      	ldrb	r2, [r7, #7]
    75c4:	f240 0350 	movw	r3, #80	; 0x50
    75c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    75cc:	ea4f 1202 	mov.w	r2, r2, lsl #4
    75d0:	4413      	add	r3, r2
    75d2:	791b      	ldrb	r3, [r3, #4]
    75d4:	73bb      	strb	r3, [r7, #14]
        ASSERT((int32_t)channel_id < sizeof(channel_type_lut));
    75d6:	7bbb      	ldrb	r3, [r7, #14]
    75d8:	2b2f      	cmp	r3, #47	; 0x2f
    75da:	d900      	bls.n	75de <ACE_convert_to_mA+0x3e>
    75dc:	be00      	bkpt	0x0000
        if(CURRENT_CHANNEL == channel_type_lut[channel_id])
    75de:	7bba      	ldrb	r2, [r7, #14]
    75e0:	f64c 7354 	movw	r3, #53076	; 0xcf54
    75e4:	f2c0 0301 	movt	r3, #1
    75e8:	5c9b      	ldrb	r3, [r3, r2]
    75ea:	2b01      	cmp	r3, #1
    75ec:	d12c      	bne.n	7648 <ACE_convert_to_mA+0xa8>
             *       CM2     :       0x13     :   2
             *       CM3     :       0x17     :   3
             *       CM4     :       0x23     :   4
             */
            current_monitor_idx
                = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
    75ee:	7bbb      	ldrb	r3, [r7, #14]
    75f0:	f003 0304 	and.w	r3, r3, #4
    75f4:	ea4f 0393 	mov.w	r3, r3, lsr #2
             *       CM1     :       0x07     :   1
             *       CM2     :       0x13     :   2
             *       CM3     :       0x17     :   3
             *       CM4     :       0x23     :   4
             */
            current_monitor_idx
    75f8:	b2da      	uxtb	r2, r3
                = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
    75fa:	7bbb      	ldrb	r3, [r7, #14]
    75fc:	f003 0330 	and.w	r3, r3, #48	; 0x30
    7600:	ea4f 03d3 	mov.w	r3, r3, lsr #3
             *       CM1     :       0x07     :   1
             *       CM2     :       0x13     :   2
             *       CM3     :       0x17     :   3
             *       CM4     :       0x23     :   4
             */
            current_monitor_idx
    7604:	b2db      	uxtb	r3, r3
    7606:	4413      	add	r3, r2
    7608:	73fb      	strb	r3, [r7, #15]
                = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
            
            if(current_monitor_idx < (uint8_t)ACE_NB_OF_CURRENT_MONITORS)
    760a:	7bfb      	ldrb	r3, [r7, #15]
    760c:	2b03      	cmp	r3, #3
    760e:	d81b      	bhi.n	7648 <ACE_convert_to_mA+0xa8>
            {
                /* Retrieve the current sensing external resistor value from 
                 * the ACE configuration data generated by the ACE configurator. */
                resistor = g_ace_current_resistors[current_monitor_idx];
    7610:	7bfa      	ldrb	r2, [r7, #15]
    7612:	f64c 031c 	movw	r3, #51228	; 0xc81c
    7616:	f2c0 0301 	movt	r3, #1
    761a:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    761e:	613b      	str	r3, [r7, #16]
                
                /* Compute mA current value taking into account the amplication
                 * factor of 50 used within the current monitor hardware. */
                voltage = (uint32_t)ACE_convert_to_mV(channel_handle, sample_value);
    7620:	79fa      	ldrb	r2, [r7, #7]
    7622:	88bb      	ldrh	r3, [r7, #4]
    7624:	4610      	mov	r0, r2
    7626:	4619      	mov	r1, r3
    7628:	f7ff ff3a 	bl	74a0 <ACE_convert_to_mV>
    762c:	4603      	mov	r3, r0
    762e:	617b      	str	r3, [r7, #20]
                current = (voltage * 20u) / resistor;
    7630:	697a      	ldr	r2, [r7, #20]
    7632:	4613      	mov	r3, r2
    7634:	ea4f 0383 	mov.w	r3, r3, lsl #2
    7638:	4413      	add	r3, r2
    763a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    763e:	461a      	mov	r2, r3
    7640:	693b      	ldr	r3, [r7, #16]
    7642:	fbb2 f3f3 	udiv	r3, r2, r3
    7646:	60bb      	str	r3, [r7, #8]
            }
        }
    }
    

    return current;
    7648:	68bb      	ldr	r3, [r7, #8]
}
    764a:	4618      	mov	r0, r3
    764c:	f107 0718 	add.w	r7, r7, #24
    7650:	46bd      	mov	sp, r7
    7652:	bd80      	pop	{r7, pc}

00007654 <ACE_convert_to_uA>:
uint32_t ACE_convert_to_uA
(
    ace_channel_handle_t    channel_handle,
    uint16_t                sample_value
)
{
    7654:	b580      	push	{r7, lr}
    7656:	b086      	sub	sp, #24
    7658:	af00      	add	r7, sp, #0
    765a:	4602      	mov	r2, r0
    765c:	460b      	mov	r3, r1
    765e:	71fa      	strb	r2, [r7, #7]
    7660:	80bb      	strh	r3, [r7, #4]
    uint32_t current = 0u;
    7662:	f04f 0300 	mov.w	r3, #0
    7666:	60bb      	str	r3, [r7, #8]
    
    ASSERT((int32_t)channel_handle < ACE_NB_OF_INPUT_CHANNELS);
    7668:	79fb      	ldrb	r3, [r7, #7]
    766a:	2b06      	cmp	r3, #6
    766c:	d900      	bls.n	7670 <ACE_convert_to_uA+0x1c>
    766e:	be00      	bkpt	0x0000
    
    if((int32_t)channel_handle < ACE_NB_OF_INPUT_CHANNELS)
    7670:	79fb      	ldrb	r3, [r7, #7]
    7672:	2b06      	cmp	r3, #6
    7674:	d83f      	bhi.n	76f6 <ACE_convert_to_uA+0xa2>
    {
        adc_channel_id_t channel_id;
        uint8_t current_monitor_idx;
        
        channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    7676:	79fa      	ldrb	r2, [r7, #7]
    7678:	f240 0350 	movw	r3, #80	; 0x50
    767c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7680:	ea4f 1202 	mov.w	r2, r2, lsl #4
    7684:	4413      	add	r3, r2
    7686:	791b      	ldrb	r3, [r3, #4]
    7688:	73bb      	strb	r3, [r7, #14]
        ASSERT((int32_t)channel_id < sizeof(channel_type_lut));
    768a:	7bbb      	ldrb	r3, [r7, #14]
    768c:	2b2f      	cmp	r3, #47	; 0x2f
    768e:	d900      	bls.n	7692 <ACE_convert_to_uA+0x3e>
    7690:	be00      	bkpt	0x0000
        if(CURRENT_CHANNEL == channel_type_lut[channel_id])
    7692:	7bba      	ldrb	r2, [r7, #14]
    7694:	f64c 7354 	movw	r3, #53076	; 0xcf54
    7698:	f2c0 0301 	movt	r3, #1
    769c:	5c9b      	ldrb	r3, [r3, r2]
    769e:	2b01      	cmp	r3, #1
    76a0:	d129      	bne.n	76f6 <ACE_convert_to_uA+0xa2>
             *       CM2     :       0x13     :   2
             *       CM3     :       0x17     :   3
             *       CM4     :       0x23     :   4
             */
            current_monitor_idx
                = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
    76a2:	7bbb      	ldrb	r3, [r7, #14]
    76a4:	f003 0304 	and.w	r3, r3, #4
    76a8:	ea4f 0393 	mov.w	r3, r3, lsr #2
             *       CM1     :       0x07     :   1
             *       CM2     :       0x13     :   2
             *       CM3     :       0x17     :   3
             *       CM4     :       0x23     :   4
             */
            current_monitor_idx
    76ac:	b2da      	uxtb	r2, r3
                = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
    76ae:	7bbb      	ldrb	r3, [r7, #14]
    76b0:	f003 0330 	and.w	r3, r3, #48	; 0x30
    76b4:	ea4f 03d3 	mov.w	r3, r3, lsr #3
             *       CM1     :       0x07     :   1
             *       CM2     :       0x13     :   2
             *       CM3     :       0x17     :   3
             *       CM4     :       0x23     :   4
             */
            current_monitor_idx
    76b8:	b2db      	uxtb	r3, r3
    76ba:	4413      	add	r3, r2
    76bc:	73fb      	strb	r3, [r7, #15]
                = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
            
            if(current_monitor_idx < (uint8_t)ACE_NB_OF_CURRENT_MONITORS)
    76be:	7bfb      	ldrb	r3, [r7, #15]
    76c0:	2b03      	cmp	r3, #3
    76c2:	d818      	bhi.n	76f6 <ACE_convert_to_uA+0xa2>
            {
                /* Retrieve the current sensing external resistor value from 
                 * the ACE configuration data generated by the ACE configurator. */
                resistor = g_ace_current_resistors[current_monitor_idx];
    76c4:	7bfa      	ldrb	r2, [r7, #15]
    76c6:	f64c 031c 	movw	r3, #51228	; 0xc81c
    76ca:	f2c0 0301 	movt	r3, #1
    76ce:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    76d2:	613b      	str	r3, [r7, #16]
                
                /* Compute mA current value taking into account the amplication
                 * factor of 50 used within the current monitor hardware. */
                voltage = (uint32_t)ACE_convert_to_mV(channel_handle, sample_value);
    76d4:	79fa      	ldrb	r2, [r7, #7]
    76d6:	88bb      	ldrh	r3, [r7, #4]
    76d8:	4610      	mov	r0, r2
    76da:	4619      	mov	r1, r3
    76dc:	f7ff fee0 	bl	74a0 <ACE_convert_to_mV>
    76e0:	4603      	mov	r3, r0
    76e2:	617b      	str	r3, [r7, #20]
                current = (voltage * (1000000u / 50u) ) / resistor;
    76e4:	697b      	ldr	r3, [r7, #20]
    76e6:	f644 6220 	movw	r2, #20000	; 0x4e20
    76ea:	fb02 f203 	mul.w	r2, r2, r3
    76ee:	693b      	ldr	r3, [r7, #16]
    76f0:	fbb2 f3f3 	udiv	r3, r2, r3
    76f4:	60bb      	str	r3, [r7, #8]
            }
        }
    }
    
    return current;
    76f6:	68bb      	ldr	r3, [r7, #8]
}
    76f8:	4618      	mov	r0, r3
    76fa:	f107 0718 	add.w	r7, r7, #24
    76fe:	46bd      	mov	sp, r7
    7700:	bd80      	pop	{r7, pc}
    7702:	bf00      	nop

00007704 <ACE_convert_to_Kelvin>:
uint32_t ACE_convert_to_Kelvin
(
    ace_channel_handle_t    channel_handle,
    uint16_t                sample_value
)
{
    7704:	b580      	push	{r7, lr}
    7706:	b084      	sub	sp, #16
    7708:	af00      	add	r7, sp, #0
    770a:	4602      	mov	r2, r0
    770c:	460b      	mov	r3, r1
    770e:	71fa      	strb	r2, [r7, #7]
    7710:	80bb      	strh	r3, [r7, #4]
    uint32_t temperature;
    uint32_t voltage;
    
    voltage = (uint32_t)ACE_convert_to_mV( channel_handle, sample_value );
    7712:	79fa      	ldrb	r2, [r7, #7]
    7714:	88bb      	ldrh	r3, [r7, #4]
    7716:	4610      	mov	r0, r2
    7718:	4619      	mov	r1, r3
    771a:	f7ff fec1 	bl	74a0 <ACE_convert_to_mV>
    771e:	4603      	mov	r3, r0
    7720:	60fb      	str	r3, [r7, #12]
    
    /* Tk = (V * 10^3) / 2.5  */
    temperature = (voltage * 10u) / 25u;
    7722:	68fa      	ldr	r2, [r7, #12]
    7724:	4613      	mov	r3, r2
    7726:	ea4f 0383 	mov.w	r3, r3, lsl #2
    772a:	4413      	add	r3, r2
    772c:	ea4f 0343 	mov.w	r3, r3, lsl #1
    7730:	461a      	mov	r2, r3
    7732:	f248 531f 	movw	r3, #34079	; 0x851f
    7736:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
    773a:	fba3 1302 	umull	r1, r3, r3, r2
    773e:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    7742:	60bb      	str	r3, [r7, #8]
    
    return temperature;
    7744:	68bb      	ldr	r3, [r7, #8]
}
    7746:	4618      	mov	r0, r3
    7748:	f107 0710 	add.w	r7, r7, #16
    774c:	46bd      	mov	sp, r7
    774e:	bd80      	pop	{r7, pc}

00007750 <ACE_convert_to_Celsius>:
int32_t ACE_convert_to_Celsius
(
    ace_channel_handle_t    channel_handle,
    uint16_t                sample_value
)
{
    7750:	b580      	push	{r7, lr}
    7752:	b084      	sub	sp, #16
    7754:	af00      	add	r7, sp, #0
    7756:	4602      	mov	r2, r0
    7758:	460b      	mov	r3, r1
    775a:	71fa      	strb	r2, [r7, #7]
    775c:	80bb      	strh	r3, [r7, #4]
    int32_t temperature;
    int32_t voltage;
    
    voltage = (int32_t)ACE_convert_to_mV( channel_handle, sample_value );
    775e:	79fa      	ldrb	r2, [r7, #7]
    7760:	88bb      	ldrh	r3, [r7, #4]
    7762:	4610      	mov	r0, r2
    7764:	4619      	mov	r1, r3
    7766:	f7ff fe9b 	bl	74a0 <ACE_convert_to_mV>
    776a:	4603      	mov	r3, r0
    776c:	60fb      	str	r3, [r7, #12]
    
    /* Tk = (V * 10^3) / 2.5  */
    /* Tc = Tk - 273.15 */
    temperature = (voltage * 4) - 2731;
    776e:	68fb      	ldr	r3, [r7, #12]
    7770:	ea4f 0383 	mov.w	r3, r3, lsl #2
    7774:	f5a3 632a 	sub.w	r3, r3, #2720	; 0xaa0
    7778:	f1a3 030b 	sub.w	r3, r3, #11
    777c:	60bb      	str	r3, [r7, #8]
    
    return temperature;
    777e:	68bb      	ldr	r3, [r7, #8]
}
    7780:	4618      	mov	r0, r3
    7782:	f107 0710 	add.w	r7, r7, #16
    7786:	46bd      	mov	sp, r7
    7788:	bd80      	pop	{r7, pc}
    778a:	bf00      	nop

0000778c <ACE_convert_to_Fahrenheit>:
int32_t ACE_convert_to_Fahrenheit
(
    ace_channel_handle_t    channel_handle,
    uint16_t                sample_value
)
{
    778c:	b580      	push	{r7, lr}
    778e:	b084      	sub	sp, #16
    7790:	af00      	add	r7, sp, #0
    7792:	4602      	mov	r2, r0
    7794:	460b      	mov	r3, r1
    7796:	71fa      	strb	r2, [r7, #7]
    7798:	80bb      	strh	r3, [r7, #4]
    int32_t temperature;
    
    temperature = (int32_t)ACE_convert_to_Kelvin( channel_handle, sample_value );
    779a:	79fa      	ldrb	r2, [r7, #7]
    779c:	88bb      	ldrh	r3, [r7, #4]
    779e:	4610      	mov	r0, r2
    77a0:	4619      	mov	r1, r3
    77a2:	f7ff ffaf 	bl	7704 <ACE_convert_to_Kelvin>
    77a6:	4603      	mov	r3, r0
    77a8:	60fb      	str	r3, [r7, #12]
    
    /* F = (K * 9/5) - 459.67 */
    temperature = ((temperature * 9) / 5) - 459;
    77aa:	68fa      	ldr	r2, [r7, #12]
    77ac:	4613      	mov	r3, r2
    77ae:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    77b2:	441a      	add	r2, r3
    77b4:	f246 6367 	movw	r3, #26215	; 0x6667
    77b8:	f2c6 6366 	movt	r3, #26214	; 0x6666
    77bc:	fb83 1302 	smull	r1, r3, r3, r2
    77c0:	ea4f 0163 	mov.w	r1, r3, asr #1
    77c4:	ea4f 73e2 	mov.w	r3, r2, asr #31
    77c8:	ebc3 0301 	rsb	r3, r3, r1
    77cc:	f5a3 73e4 	sub.w	r3, r3, #456	; 0x1c8
    77d0:	f1a3 0303 	sub.w	r3, r3, #3
    77d4:	60fb      	str	r3, [r7, #12]
    
    return temperature;
    77d6:	68fb      	ldr	r3, [r7, #12]
}
    77d8:	4618      	mov	r0, r3
    77da:	f107 0710 	add.w	r7, r7, #16
    77de:	46bd      	mov	sp, r7
    77e0:	bd80      	pop	{r7, pc}
    77e2:	bf00      	nop

000077e4 <ACE_get_channel_name>:
 */
const uint8_t * ACE_get_channel_name
(
    ace_channel_handle_t    channel_handle
)
{
    77e4:	b480      	push	{r7}
    77e6:	b085      	sub	sp, #20
    77e8:	af00      	add	r7, sp, #0
    77ea:	4603      	mov	r3, r0
    77ec:	71fb      	strb	r3, [r7, #7]
    const uint8_t * p_channel_name = 0;
    77ee:	f04f 0300 	mov.w	r3, #0
    77f2:	60fb      	str	r3, [r7, #12]
    
    if ( channel_handle < NB_OF_ACE_CHANNEL_HANDLES)
    77f4:	79fb      	ldrb	r3, [r7, #7]
    77f6:	2b06      	cmp	r3, #6
    77f8:	d809      	bhi.n	780e <ACE_get_channel_name+0x2a>
    {
        p_channel_name = g_ace_channel_desc_table[channel_handle].p_sz_channel_name;
    77fa:	79fa      	ldrb	r2, [r7, #7]
    77fc:	f240 0350 	movw	r3, #80	; 0x50
    7800:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7804:	ea4f 1202 	mov.w	r2, r2, lsl #4
    7808:	4413      	add	r3, r2
    780a:	681b      	ldr	r3, [r3, #0]
    780c:	60fb      	str	r3, [r7, #12]
    }
    
    return p_channel_name;
    780e:	68fb      	ldr	r3, [r7, #12]
}
    7810:	4618      	mov	r0, r3
    7812:	f107 0714 	add.w	r7, r7, #20
    7816:	46bd      	mov	sp, r7
    7818:	bc80      	pop	{r7}
    781a:	4770      	bx	lr

0000781c <ACE_convert_mV_to_adc_value>:
uint16_t ACE_convert_mV_to_adc_value
(
    ace_channel_handle_t    channel_handle,
    uint32_t                voltage
)
{
    781c:	b480      	push	{r7}
    781e:	b087      	sub	sp, #28
    7820:	af00      	add	r7, sp, #0
    7822:	4603      	mov	r3, r0
    7824:	6039      	str	r1, [r7, #0]
    7826:	71fb      	strb	r3, [r7, #7]
    uint16_t sample_value;
    adc_channel_id_t channel_id;
    uint8_t adc_id;
    
    channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    7828:	79fa      	ldrb	r2, [r7, #7]
    782a:	f240 0350 	movw	r3, #80	; 0x50
    782e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7832:	ea4f 1202 	mov.w	r2, r2, lsl #4
    7836:	4413      	add	r3, r2
    7838:	791b      	ldrb	r3, [r3, #4]
    783a:	73bb      	strb	r3, [r7, #14]
    adc_id = (uint8_t)channel_id >> 4u;
    783c:	7bbb      	ldrb	r3, [r7, #14]
    783e:	ea4f 1313 	mov.w	r3, r3, lsr #4
    7842:	73fb      	strb	r3, [r7, #15]
    
    if (voltage > g_ace_adc_config[adc_id].va_ref)
    7844:	7bfb      	ldrb	r3, [r7, #15]
    7846:	f240 0248 	movw	r2, #72	; 0x48
    784a:	f2c2 0200 	movt	r2, #8192	; 0x2000
    784e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    7852:	4413      	add	r3, r2
    7854:	885b      	ldrh	r3, [r3, #2]
    7856:	461a      	mov	r2, r3
    7858:	683b      	ldr	r3, [r7, #0]
    785a:	429a      	cmp	r2, r3
    785c:	d20a      	bcs.n	7874 <ACE_convert_mV_to_adc_value+0x58>
    {
        sample_value = g_ace_adc_config[adc_id].adc_resolution - 1u;
    785e:	7bfa      	ldrb	r2, [r7, #15]
    7860:	f240 0348 	movw	r3, #72	; 0x48
    7864:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7868:	f833 3022 	ldrh.w	r3, [r3, r2, lsl #2]
    786c:	f103 33ff 	add.w	r3, r3, #4294967295
    7870:	81bb      	strh	r3, [r7, #12]
    7872:	e01b      	b.n	78ac <ACE_convert_mV_to_adc_value+0x90>
    else
    {
        uint32_t va_ref;
        uint32_t adc_resolution;
        
        va_ref = g_ace_adc_config[adc_id].va_ref;
    7874:	7bfb      	ldrb	r3, [r7, #15]
    7876:	f240 0248 	movw	r2, #72	; 0x48
    787a:	f2c2 0200 	movt	r2, #8192	; 0x2000
    787e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    7882:	4413      	add	r3, r2
    7884:	885b      	ldrh	r3, [r3, #2]
    7886:	613b      	str	r3, [r7, #16]
        adc_resolution = g_ace_adc_config[adc_id].adc_resolution;
    7888:	7bfa      	ldrb	r2, [r7, #15]
    788a:	f240 0348 	movw	r3, #72	; 0x48
    788e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7892:	f833 3022 	ldrh.w	r3, [r3, r2, lsl #2]
    7896:	617b      	str	r3, [r7, #20]
        
        sample_value = (uint16_t)((voltage * (adc_resolution - 1u)) / va_ref);
    7898:	697b      	ldr	r3, [r7, #20]
    789a:	f103 33ff 	add.w	r3, r3, #4294967295
    789e:	683a      	ldr	r2, [r7, #0]
    78a0:	fb02 f203 	mul.w	r2, r2, r3
    78a4:	693b      	ldr	r3, [r7, #16]
    78a6:	fbb2 f3f3 	udiv	r3, r2, r3
    78aa:	81bb      	strh	r3, [r7, #12]
    }
    
    return sample_value;
    78ac:	89bb      	ldrh	r3, [r7, #12]
}
    78ae:	4618      	mov	r0, r3
    78b0:	f107 071c 	add.w	r7, r7, #28
    78b4:	46bd      	mov	sp, r7
    78b6:	bc80      	pop	{r7}
    78b8:	4770      	bx	lr
    78ba:	bf00      	nop

000078bc <convert_mV_to_ppe_value>:
static uint16_t convert_mV_to_ppe_value
(
    ace_channel_handle_t    channel_handle,
    uint32_t                voltage
)
{
    78bc:	b480      	push	{r7}
    78be:	b085      	sub	sp, #20
    78c0:	af00      	add	r7, sp, #0
    78c2:	4603      	mov	r3, r0
    78c4:	6039      	str	r1, [r7, #0]
    78c6:	71fb      	strb	r3, [r7, #7]
    uint16_t sample_value;
    adc_channel_id_t channel_id;
    uint8_t adc_id;
    
    channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    78c8:	79fa      	ldrb	r2, [r7, #7]
    78ca:	f240 0350 	movw	r3, #80	; 0x50
    78ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    78d2:	ea4f 1202 	mov.w	r2, r2, lsl #4
    78d6:	4413      	add	r3, r2
    78d8:	791b      	ldrb	r3, [r3, #4]
    78da:	73bb      	strb	r3, [r7, #14]
    adc_id = (uint8_t)channel_id >> 4u;
    78dc:	7bbb      	ldrb	r3, [r7, #14]
    78de:	ea4f 1313 	mov.w	r3, r3, lsr #4
    78e2:	73fb      	strb	r3, [r7, #15]
    
    if (voltage > g_ace_adc_config[adc_id].va_ref)
    78e4:	7bfb      	ldrb	r3, [r7, #15]
    78e6:	f240 0248 	movw	r2, #72	; 0x48
    78ea:	f2c2 0200 	movt	r2, #8192	; 0x2000
    78ee:	ea4f 0383 	mov.w	r3, r3, lsl #2
    78f2:	4413      	add	r3, r2
    78f4:	885b      	ldrh	r3, [r3, #2]
    78f6:	461a      	mov	r2, r3
    78f8:	683b      	ldr	r3, [r7, #0]
    78fa:	429a      	cmp	r2, r3
    78fc:	d203      	bcs.n	7906 <convert_mV_to_ppe_value+0x4a>
    {
        sample_value = PPE_SAMPLES_RESOLUTION;
    78fe:	f640 73ff 	movw	r3, #4095	; 0xfff
    7902:	81bb      	strh	r3, [r7, #12]
    7904:	e011      	b.n	792a <convert_mV_to_ppe_value+0x6e>
    }
    else
    {
        sample_value = (uint16_t)((voltage * PPE_SAMPLES_RESOLUTION) / g_ace_adc_config[adc_id].va_ref);
    7906:	683a      	ldr	r2, [r7, #0]
    7908:	4613      	mov	r3, r2
    790a:	ea4f 3303 	mov.w	r3, r3, lsl #12
    790e:	ebc2 0103 	rsb	r1, r2, r3
    7912:	7bfb      	ldrb	r3, [r7, #15]
    7914:	f240 0248 	movw	r2, #72	; 0x48
    7918:	f2c2 0200 	movt	r2, #8192	; 0x2000
    791c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    7920:	4413      	add	r3, r2
    7922:	885b      	ldrh	r3, [r3, #2]
    7924:	fbb1 f3f3 	udiv	r3, r1, r3
    7928:	81bb      	strh	r3, [r7, #12]
    }
    
    return sample_value;
    792a:	89bb      	ldrh	r3, [r7, #12]
}
    792c:	4618      	mov	r0, r3
    792e:	f107 0714 	add.w	r7, r7, #20
    7932:	46bd      	mov	sp, r7
    7934:	bc80      	pop	{r7}
    7936:	4770      	bx	lr

00007938 <ACE_convert_from_mV>:
uint16_t ACE_convert_from_mV
(
    ace_channel_handle_t    channel_handle,
    int32_t                 voltage
)
{
    7938:	b480      	push	{r7}
    793a:	b08b      	sub	sp, #44	; 0x2c
    793c:	af00      	add	r7, sp, #0
    793e:	4603      	mov	r3, r0
    7940:	6039      	str	r1, [r7, #0]
    7942:	71fb      	strb	r3, [r7, #7]
    uint16_t sample_value;
    adc_channel_id_t channel_id;
    uint8_t adc_id;
    uint32_t adc_voltage;
    
    channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    7944:	79fa      	ldrb	r2, [r7, #7]
    7946:	f240 0350 	movw	r3, #80	; 0x50
    794a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    794e:	ea4f 1202 	mov.w	r2, r2, lsl #4
    7952:	4413      	add	r3, r2
    7954:	791b      	ldrb	r3, [r3, #4]
    7956:	72bb      	strb	r3, [r7, #10]
    adc_id = (uint8_t)channel_id >> 4u;
    7958:	7abb      	ldrb	r3, [r7, #10]
    795a:	ea4f 1313 	mov.w	r3, r3, lsr #4
    795e:	72fb      	strb	r3, [r7, #11]
    
    if ( abps_channel_lut[channel_id] == NON_ABPS_CHANNEL )
    7960:	7aba      	ldrb	r2, [r7, #10]
    7962:	f64c 73b4 	movw	r3, #53172	; 0xcfb4
    7966:	f2c0 0301 	movt	r3, #1
    796a:	5c9b      	ldrb	r3, [r3, r2]
    796c:	2bff      	cmp	r3, #255	; 0xff
    796e:	d11b      	bne.n	79a8 <ACE_convert_from_mV+0x70>
    {
        if (voltage > 0)
    7970:	683b      	ldr	r3, [r7, #0]
    7972:	2b00      	cmp	r3, #0
    7974:	dd02      	ble.n	797c <ACE_convert_from_mV+0x44>
        {
            adc_voltage = (uint32_t)voltage;
    7976:	683b      	ldr	r3, [r7, #0]
    7978:	60fb      	str	r3, [r7, #12]
    797a:	e002      	b.n	7982 <ACE_convert_from_mV+0x4a>
        }
        else
        {
            adc_voltage = 0u;
    797c:	f04f 0300 	mov.w	r3, #0
    7980:	60fb      	str	r3, [r7, #12]
        }
        sample_value = (uint16_t)((adc_voltage * PPE_SAMPLES_RESOLUTION) / g_ace_adc_config[adc_id].va_ref);
    7982:	68fa      	ldr	r2, [r7, #12]
    7984:	4613      	mov	r3, r2
    7986:	ea4f 3303 	mov.w	r3, r3, lsl #12
    798a:	ebc2 0103 	rsb	r1, r2, r3
    798e:	7afb      	ldrb	r3, [r7, #11]
    7990:	f240 0248 	movw	r2, #72	; 0x48
    7994:	f2c2 0200 	movt	r2, #8192	; 0x2000
    7998:	ea4f 0383 	mov.w	r3, r3, lsl #2
    799c:	4413      	add	r3, r2
    799e:	885b      	ldrh	r3, [r3, #2]
    79a0:	fbb1 f3f3 	udiv	r3, r1, r3
    79a4:	813b      	strh	r3, [r7, #8]
    79a6:	e03f      	b.n	7a28 <ACE_convert_from_mV+0xf0>
        int32_t actual_afe_voltage;
        uint32_t gain;
        uint32_t va_ref;
        uint32_t ppe_resolution;
        
        apbs_idx = abps_idx_lut[channel_id];
    79a8:	7aba      	ldrb	r2, [r7, #10]
    79aa:	f64c 73e4 	movw	r3, #53220	; 0xcfe4
    79ae:	f2c0 0301 	movt	r3, #1
    79b2:	5c9b      	ldrb	r3, [r3, r2]
    79b4:	74bb      	strb	r3, [r7, #18]
        gdec = g_gdec_lut[apbs_idx];
    79b6:	7cba      	ldrb	r2, [r7, #18]
    79b8:	f642 732c 	movw	r3, #12076	; 0x2f2c
    79bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    79c0:	5c9b      	ldrb	r3, [r3, r2]
    79c2:	74fb      	strb	r3, [r7, #19]

        ppe_resolution = (uint32_t)PPE_SAMPLES_RESOLUTION;
    79c4:	f640 73ff 	movw	r3, #4095	; 0xfff
    79c8:	627b      	str	r3, [r7, #36]	; 0x24
        gain = (uint32_t)apbs_gain_lut[gdec];
    79ca:	7cfa      	ldrb	r2, [r7, #19]
    79cc:	f24d 0314 	movw	r3, #53268	; 0xd014
    79d0:	f2c0 0301 	movt	r3, #1
    79d4:	5c9b      	ldrb	r3, [r3, r2]
    79d6:	61fb      	str	r3, [r7, #28]
        range = (int32_t)apbs_range[gdec];
    79d8:	7cfa      	ldrb	r2, [r7, #19]
    79da:	f24d 0318 	movw	r3, #53272	; 0xd018
    79de:	f2c0 0301 	movt	r3, #1
    79e2:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    79e6:	b21b      	sxth	r3, r3
    79e8:	617b      	str	r3, [r7, #20]
        va_ref = (uint32_t)g_ace_adc_config[adc_id].va_ref;
    79ea:	7afb      	ldrb	r3, [r7, #11]
    79ec:	f240 0248 	movw	r2, #72	; 0x48
    79f0:	f2c2 0200 	movt	r2, #8192	; 0x2000
    79f4:	ea4f 0383 	mov.w	r3, r3, lsl #2
    79f8:	4413      	add	r3, r2
    79fa:	885b      	ldrh	r3, [r3, #2]
    79fc:	623b      	str	r3, [r7, #32]
        
        actual_afe_voltage = range - voltage;
    79fe:	697a      	ldr	r2, [r7, #20]
    7a00:	683b      	ldr	r3, [r7, #0]
    7a02:	ebc3 0302 	rsb	r3, r3, r2
    7a06:	61bb      	str	r3, [r7, #24]
        sample_value = (uint16_t)(ppe_resolution - ((((ppe_resolution * (uint32_t)actual_afe_voltage) / gain) / va_ref)));
    7a08:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    7a0a:	b29a      	uxth	r2, r3
    7a0c:	69bb      	ldr	r3, [r7, #24]
    7a0e:	6a79      	ldr	r1, [r7, #36]	; 0x24
    7a10:	fb01 f103 	mul.w	r1, r1, r3
    7a14:	69fb      	ldr	r3, [r7, #28]
    7a16:	fbb1 f1f3 	udiv	r1, r1, r3
    7a1a:	6a3b      	ldr	r3, [r7, #32]
    7a1c:	fbb1 f3f3 	udiv	r3, r1, r3
    7a20:	b29b      	uxth	r3, r3
    7a22:	ebc3 0302 	rsb	r3, r3, r2
    7a26:	813b      	strh	r3, [r7, #8]
    }
        
    if (sample_value > MAX_PPE_SAMPLE_VALUE)
    7a28:	893a      	ldrh	r2, [r7, #8]
    7a2a:	f640 73ff 	movw	r3, #4095	; 0xfff
    7a2e:	429a      	cmp	r2, r3
    7a30:	d902      	bls.n	7a38 <ACE_convert_from_mV+0x100>
    {
        sample_value = MAX_PPE_SAMPLE_VALUE;
    7a32:	f640 73ff 	movw	r3, #4095	; 0xfff
    7a36:	813b      	strh	r3, [r7, #8]
    }
    
    return sample_value;
    7a38:	893b      	ldrh	r3, [r7, #8]
}
    7a3a:	4618      	mov	r0, r3
    7a3c:	f107 072c 	add.w	r7, r7, #44	; 0x2c
    7a40:	46bd      	mov	sp, r7
    7a42:	bc80      	pop	{r7}
    7a44:	4770      	bx	lr
    7a46:	bf00      	nop

00007a48 <ACE_convert_from_mA>:
uint16_t ACE_convert_from_mA
(
    ace_channel_handle_t    channel_handle,
    uint32_t                current
)
{
    7a48:	b580      	push	{r7, lr}
    7a4a:	b086      	sub	sp, #24
    7a4c:	af00      	add	r7, sp, #0
    7a4e:	4603      	mov	r3, r0
    7a50:	6039      	str	r1, [r7, #0]
    7a52:	71fb      	strb	r3, [r7, #7]
    uint16_t sample_value = 0u;
    7a54:	f04f 0300 	mov.w	r3, #0
    7a58:	817b      	strh	r3, [r7, #10]
    uint32_t voltage;
    uint32_t resistor = 1u;
    7a5a:	f04f 0301 	mov.w	r3, #1
    7a5e:	613b      	str	r3, [r7, #16]
    adc_channel_id_t channel_id;
    
    ASSERT((int32_t)channel_handle < ACE_NB_OF_INPUT_CHANNELS);
    7a60:	79fb      	ldrb	r3, [r7, #7]
    7a62:	2b06      	cmp	r3, #6
    7a64:	d900      	bls.n	7a68 <ACE_convert_from_mA+0x20>
    7a66:	be00      	bkpt	0x0000
    
    channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    7a68:	79fa      	ldrb	r2, [r7, #7]
    7a6a:	f240 0350 	movw	r3, #80	; 0x50
    7a6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7a72:	ea4f 1202 	mov.w	r2, r2, lsl #4
    7a76:	4413      	add	r3, r2
    7a78:	791b      	ldrb	r3, [r3, #4]
    7a7a:	75bb      	strb	r3, [r7, #22]
    ASSERT((int32_t)channel_id < sizeof(channel_type_lut));
    7a7c:	7dbb      	ldrb	r3, [r7, #22]
    7a7e:	2b2f      	cmp	r3, #47	; 0x2f
    7a80:	d900      	bls.n	7a84 <ACE_convert_from_mA+0x3c>
    7a82:	be00      	bkpt	0x0000
    
    if(CURRENT_CHANNEL == channel_type_lut[channel_id])
    7a84:	7dba      	ldrb	r2, [r7, #22]
    7a86:	f64c 7354 	movw	r3, #53076	; 0xcf54
    7a8a:	f2c0 0301 	movt	r3, #1
    7a8e:	5c9b      	ldrb	r3, [r3, r2]
    7a90:	2b01      	cmp	r3, #1
    7a92:	d134      	bne.n	7afe <ACE_convert_from_mA+0xb6>
    {
        uint8_t current_monitor_idx;
        
        current_monitor_idx
            = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
    7a94:	7dbb      	ldrb	r3, [r7, #22]
    7a96:	f003 0304 	and.w	r3, r3, #4
    7a9a:	ea4f 0393 	mov.w	r3, r3, lsr #2
    
    if(CURRENT_CHANNEL == channel_type_lut[channel_id])
    {
        uint8_t current_monitor_idx;
        
        current_monitor_idx
    7a9e:	b2da      	uxtb	r2, r3
            = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
    7aa0:	7dbb      	ldrb	r3, [r7, #22]
    7aa2:	f003 0330 	and.w	r3, r3, #48	; 0x30
    7aa6:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    
    if(CURRENT_CHANNEL == channel_type_lut[channel_id])
    {
        uint8_t current_monitor_idx;
        
        current_monitor_idx
    7aaa:	b2db      	uxtb	r3, r3
    7aac:	4413      	add	r3, r2
    7aae:	75fb      	strb	r3, [r7, #23]
            = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
    
        if(current_monitor_idx < (uint8_t)ACE_NB_OF_CURRENT_MONITORS)
    7ab0:	7dfb      	ldrb	r3, [r7, #23]
    7ab2:	2b03      	cmp	r3, #3
    7ab4:	d823      	bhi.n	7afe <ACE_convert_from_mA+0xb6>
        {
            resistor = g_ace_current_resistors[current_monitor_idx];
    7ab6:	7dfa      	ldrb	r2, [r7, #23]
    7ab8:	f64c 031c 	movw	r3, #51228	; 0xc81c
    7abc:	f2c0 0301 	movt	r3, #1
    7ac0:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    7ac4:	613b      	str	r3, [r7, #16]
            /* 
             * Keep in mind the multiply by 50 gain within the current monitor.
             * Therefore the voltage seen on the ADC input is:
             *      V = (I * 50 * R) / 1000.
             */
            voltage = (current * resistor) / 20u;
    7ac6:	683b      	ldr	r3, [r7, #0]
    7ac8:	693a      	ldr	r2, [r7, #16]
    7aca:	fb02 f203 	mul.w	r2, r2, r3
    7ace:	f64c 43cd 	movw	r3, #52429	; 0xcccd
    7ad2:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
    7ad6:	fba3 1302 	umull	r1, r3, r3, r2
    7ada:	ea4f 1313 	mov.w	r3, r3, lsr #4
    7ade:	60fb      	str	r3, [r7, #12]
            sample_value = convert_mV_to_ppe_value( channel_handle, voltage );
    7ae0:	79fb      	ldrb	r3, [r7, #7]
    7ae2:	4618      	mov	r0, r3
    7ae4:	68f9      	ldr	r1, [r7, #12]
    7ae6:	f7ff fee9 	bl	78bc <convert_mV_to_ppe_value>
    7aea:	4603      	mov	r3, r0
    7aec:	817b      	strh	r3, [r7, #10]
            
            if (sample_value > MAX_PPE_SAMPLE_VALUE)
    7aee:	897a      	ldrh	r2, [r7, #10]
    7af0:	f640 73ff 	movw	r3, #4095	; 0xfff
    7af4:	429a      	cmp	r2, r3
    7af6:	d902      	bls.n	7afe <ACE_convert_from_mA+0xb6>
            {
                sample_value = MAX_PPE_SAMPLE_VALUE;
    7af8:	f640 73ff 	movw	r3, #4095	; 0xfff
    7afc:	817b      	strh	r3, [r7, #10]
            }
        }
    }
    return sample_value;
    7afe:	897b      	ldrh	r3, [r7, #10]
}
    7b00:	4618      	mov	r0, r3
    7b02:	f107 0718 	add.w	r7, r7, #24
    7b06:	46bd      	mov	sp, r7
    7b08:	bd80      	pop	{r7, pc}
    7b0a:	bf00      	nop

00007b0c <ACE_convert_from_uA>:
uint16_t ACE_convert_from_uA
(
    ace_channel_handle_t    channel_handle,
    uint32_t                current
)
{
    7b0c:	b580      	push	{r7, lr}
    7b0e:	b086      	sub	sp, #24
    7b10:	af00      	add	r7, sp, #0
    7b12:	4603      	mov	r3, r0
    7b14:	6039      	str	r1, [r7, #0]
    7b16:	71fb      	strb	r3, [r7, #7]
    uint16_t sample_value = 0u;
    7b18:	f04f 0300 	mov.w	r3, #0
    7b1c:	817b      	strh	r3, [r7, #10]
    uint32_t voltage;
    uint32_t resistor = 1u;
    7b1e:	f04f 0301 	mov.w	r3, #1
    7b22:	613b      	str	r3, [r7, #16]
    adc_channel_id_t channel_id;
    
    ASSERT((int32_t)channel_handle < ACE_NB_OF_INPUT_CHANNELS);
    7b24:	79fb      	ldrb	r3, [r7, #7]
    7b26:	2b06      	cmp	r3, #6
    7b28:	d900      	bls.n	7b2c <ACE_convert_from_uA+0x20>
    7b2a:	be00      	bkpt	0x0000
    
    channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    7b2c:	79fa      	ldrb	r2, [r7, #7]
    7b2e:	f240 0350 	movw	r3, #80	; 0x50
    7b32:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7b36:	ea4f 1202 	mov.w	r2, r2, lsl #4
    7b3a:	4413      	add	r3, r2
    7b3c:	791b      	ldrb	r3, [r3, #4]
    7b3e:	75bb      	strb	r3, [r7, #22]
    ASSERT((int32_t)channel_id < sizeof(channel_type_lut));
    7b40:	7dbb      	ldrb	r3, [r7, #22]
    7b42:	2b2f      	cmp	r3, #47	; 0x2f
    7b44:	d900      	bls.n	7b48 <ACE_convert_from_uA+0x3c>
    7b46:	be00      	bkpt	0x0000
    
    if(CURRENT_CHANNEL == channel_type_lut[channel_id])
    7b48:	7dba      	ldrb	r2, [r7, #22]
    7b4a:	f64c 7354 	movw	r3, #53076	; 0xcf54
    7b4e:	f2c0 0301 	movt	r3, #1
    7b52:	5c9b      	ldrb	r3, [r3, r2]
    7b54:	2b01      	cmp	r3, #1
    7b56:	d134      	bne.n	7bc2 <ACE_convert_from_uA+0xb6>
    {
        uint8_t current_monitor_idx;
        
        current_monitor_idx
            = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
    7b58:	7dbb      	ldrb	r3, [r7, #22]
    7b5a:	f003 0304 	and.w	r3, r3, #4
    7b5e:	ea4f 0393 	mov.w	r3, r3, lsr #2
    
    if(CURRENT_CHANNEL == channel_type_lut[channel_id])
    {
        uint8_t current_monitor_idx;
        
        current_monitor_idx
    7b62:	b2da      	uxtb	r2, r3
            = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
    7b64:	7dbb      	ldrb	r3, [r7, #22]
    7b66:	f003 0330 	and.w	r3, r3, #48	; 0x30
    7b6a:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    
    if(CURRENT_CHANNEL == channel_type_lut[channel_id])
    {
        uint8_t current_monitor_idx;
        
        current_monitor_idx
    7b6e:	b2db      	uxtb	r3, r3
    7b70:	4413      	add	r3, r2
    7b72:	75fb      	strb	r3, [r7, #23]
            = (((uint8_t)channel_id & 0x04u) >> 2u) + (((uint8_t)channel_id & 0x30u) >> 3u);
    
        if(current_monitor_idx < (uint8_t)ACE_NB_OF_CURRENT_MONITORS)
    7b74:	7dfb      	ldrb	r3, [r7, #23]
    7b76:	2b03      	cmp	r3, #3
    7b78:	d823      	bhi.n	7bc2 <ACE_convert_from_uA+0xb6>
        {
            resistor = g_ace_current_resistors[current_monitor_idx];
    7b7a:	7dfa      	ldrb	r2, [r7, #23]
    7b7c:	f64c 031c 	movw	r3, #51228	; 0xc81c
    7b80:	f2c0 0301 	movt	r3, #1
    7b84:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    7b88:	613b      	str	r3, [r7, #16]
            voltage = (current * resistor) / 20000u;
    7b8a:	683b      	ldr	r3, [r7, #0]
    7b8c:	693a      	ldr	r2, [r7, #16]
    7b8e:	fb02 f203 	mul.w	r2, r2, r3
    7b92:	f241 7359 	movw	r3, #5977	; 0x1759
    7b96:	f2cd 13b7 	movt	r3, #53687	; 0xd1b7
    7b9a:	fba3 1302 	umull	r1, r3, r3, r2
    7b9e:	ea4f 3393 	mov.w	r3, r3, lsr #14
    7ba2:	60fb      	str	r3, [r7, #12]
            sample_value = convert_mV_to_ppe_value( channel_handle, voltage );
    7ba4:	79fb      	ldrb	r3, [r7, #7]
    7ba6:	4618      	mov	r0, r3
    7ba8:	68f9      	ldr	r1, [r7, #12]
    7baa:	f7ff fe87 	bl	78bc <convert_mV_to_ppe_value>
    7bae:	4603      	mov	r3, r0
    7bb0:	817b      	strh	r3, [r7, #10]
            
            if (sample_value > MAX_PPE_SAMPLE_VALUE)
    7bb2:	897a      	ldrh	r2, [r7, #10]
    7bb4:	f640 73ff 	movw	r3, #4095	; 0xfff
    7bb8:	429a      	cmp	r2, r3
    7bba:	d902      	bls.n	7bc2 <ACE_convert_from_uA+0xb6>
            {
                sample_value = MAX_PPE_SAMPLE_VALUE;
    7bbc:	f640 73ff 	movw	r3, #4095	; 0xfff
    7bc0:	817b      	strh	r3, [r7, #10]
            }
        }
    }
    return sample_value;
    7bc2:	897b      	ldrh	r3, [r7, #10]
}
    7bc4:	4618      	mov	r0, r3
    7bc6:	f107 0718 	add.w	r7, r7, #24
    7bca:	46bd      	mov	sp, r7
    7bcc:	bd80      	pop	{r7, pc}
    7bce:	bf00      	nop

00007bd0 <ACE_convert_from_Kelvin>:
uint16_t ACE_convert_from_Kelvin
(
    ace_channel_handle_t    channel_handle,
    uint32_t                temperature
)
{
    7bd0:	b580      	push	{r7, lr}
    7bd2:	b084      	sub	sp, #16
    7bd4:	af00      	add	r7, sp, #0
    7bd6:	4603      	mov	r3, r0
    7bd8:	6039      	str	r1, [r7, #0]
    7bda:	71fb      	strb	r3, [r7, #7]
    uint16_t sample_value;
    uint32_t voltage;
    
    voltage = (temperature * 25u) / 10u;
    7bdc:	683a      	ldr	r2, [r7, #0]
    7bde:	4613      	mov	r3, r2
    7be0:	ea4f 0383 	mov.w	r3, r3, lsl #2
    7be4:	4413      	add	r3, r2
    7be6:	ea4f 0283 	mov.w	r2, r3, lsl #2
    7bea:	441a      	add	r2, r3
    7bec:	f64c 43cd 	movw	r3, #52429	; 0xcccd
    7bf0:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
    7bf4:	fba3 1302 	umull	r1, r3, r3, r2
    7bf8:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    7bfc:	60fb      	str	r3, [r7, #12]
    sample_value = convert_mV_to_ppe_value( channel_handle, voltage );
    7bfe:	79fb      	ldrb	r3, [r7, #7]
    7c00:	4618      	mov	r0, r3
    7c02:	68f9      	ldr	r1, [r7, #12]
    7c04:	f7ff fe5a 	bl	78bc <convert_mV_to_ppe_value>
    7c08:	4603      	mov	r3, r0
    7c0a:	817b      	strh	r3, [r7, #10]
    
    if (sample_value > MAX_PPE_SAMPLE_VALUE)
    7c0c:	897a      	ldrh	r2, [r7, #10]
    7c0e:	f640 73ff 	movw	r3, #4095	; 0xfff
    7c12:	429a      	cmp	r2, r3
    7c14:	d902      	bls.n	7c1c <ACE_convert_from_Kelvin+0x4c>
    {
        sample_value = MAX_PPE_SAMPLE_VALUE;
    7c16:	f640 73ff 	movw	r3, #4095	; 0xfff
    7c1a:	817b      	strh	r3, [r7, #10]
    }
    return sample_value;
    7c1c:	897b      	ldrh	r3, [r7, #10]
}
    7c1e:	4618      	mov	r0, r3
    7c20:	f107 0710 	add.w	r7, r7, #16
    7c24:	46bd      	mov	sp, r7
    7c26:	bd80      	pop	{r7, pc}

00007c28 <ACE_convert_from_Celsius>:
uint16_t ACE_convert_from_Celsius
(
    ace_channel_handle_t    channel_handle,
    int32_t                 temperature
)
{
    7c28:	b580      	push	{r7, lr}
    7c2a:	b084      	sub	sp, #16
    7c2c:	af00      	add	r7, sp, #0
    7c2e:	4603      	mov	r3, r0
    7c30:	6039      	str	r1, [r7, #0]
    7c32:	71fb      	strb	r3, [r7, #7]
    uint16_t sample_value;
    uint32_t voltage;
    
    temperature = temperature + 2731;
    7c34:	683b      	ldr	r3, [r7, #0]
    7c36:	f503 632a 	add.w	r3, r3, #2720	; 0xaa0
    7c3a:	f103 030b 	add.w	r3, r3, #11
    7c3e:	603b      	str	r3, [r7, #0]
    voltage = (uint32_t)temperature / 4u;
    7c40:	683b      	ldr	r3, [r7, #0]
    7c42:	ea4f 0393 	mov.w	r3, r3, lsr #2
    7c46:	60fb      	str	r3, [r7, #12]
    sample_value = convert_mV_to_ppe_value( channel_handle, voltage );
    7c48:	79fb      	ldrb	r3, [r7, #7]
    7c4a:	4618      	mov	r0, r3
    7c4c:	68f9      	ldr	r1, [r7, #12]
    7c4e:	f7ff fe35 	bl	78bc <convert_mV_to_ppe_value>
    7c52:	4603      	mov	r3, r0
    7c54:	817b      	strh	r3, [r7, #10]
    
    if (sample_value > MAX_PPE_SAMPLE_VALUE)
    7c56:	897a      	ldrh	r2, [r7, #10]
    7c58:	f640 73ff 	movw	r3, #4095	; 0xfff
    7c5c:	429a      	cmp	r2, r3
    7c5e:	d902      	bls.n	7c66 <ACE_convert_from_Celsius+0x3e>
    {
        sample_value = MAX_PPE_SAMPLE_VALUE;
    7c60:	f640 73ff 	movw	r3, #4095	; 0xfff
    7c64:	817b      	strh	r3, [r7, #10]
    }
    return sample_value;
    7c66:	897b      	ldrh	r3, [r7, #10]
}
    7c68:	4618      	mov	r0, r3
    7c6a:	f107 0710 	add.w	r7, r7, #16
    7c6e:	46bd      	mov	sp, r7
    7c70:	bd80      	pop	{r7, pc}
    7c72:	bf00      	nop

00007c74 <ACE_convert_from_Fahrenheit>:
uint16_t ACE_convert_from_Fahrenheit
(
    ace_channel_handle_t    channel_handle,
    int32_t                 temperature
)
{
    7c74:	b580      	push	{r7, lr}
    7c76:	b084      	sub	sp, #16
    7c78:	af00      	add	r7, sp, #0
    7c7a:	4603      	mov	r3, r0
    7c7c:	6039      	str	r1, [r7, #0]
    7c7e:	71fb      	strb	r3, [r7, #7]
    uint16_t sample_value;
    uint32_t kelvin;
    
    temperature = temperature + 459;
    7c80:	683b      	ldr	r3, [r7, #0]
    7c82:	f503 73e4 	add.w	r3, r3, #456	; 0x1c8
    7c86:	f103 0303 	add.w	r3, r3, #3
    7c8a:	603b      	str	r3, [r7, #0]
    kelvin = (uint32_t)temperature;
    7c8c:	683b      	ldr	r3, [r7, #0]
    7c8e:	60fb      	str	r3, [r7, #12]
    kelvin = (kelvin * 5u) / 9u;
    7c90:	68fa      	ldr	r2, [r7, #12]
    7c92:	4613      	mov	r3, r2
    7c94:	ea4f 0383 	mov.w	r3, r3, lsl #2
    7c98:	441a      	add	r2, r3
    7c9a:	f648 6339 	movw	r3, #36409	; 0x8e39
    7c9e:	f6c3 03e3 	movt	r3, #14563	; 0x38e3
    7ca2:	fba3 1302 	umull	r1, r3, r3, r2
    7ca6:	ea4f 0353 	mov.w	r3, r3, lsr #1
    7caa:	60fb      	str	r3, [r7, #12]
    
    sample_value = ACE_convert_from_Kelvin( channel_handle, kelvin );
    7cac:	79fb      	ldrb	r3, [r7, #7]
    7cae:	4618      	mov	r0, r3
    7cb0:	68f9      	ldr	r1, [r7, #12]
    7cb2:	f7ff ff8d 	bl	7bd0 <ACE_convert_from_Kelvin>
    7cb6:	4603      	mov	r3, r0
    7cb8:	817b      	strh	r3, [r7, #10]
    
    if (sample_value > MAX_PPE_SAMPLE_VALUE)
    7cba:	897a      	ldrh	r2, [r7, #10]
    7cbc:	f640 73ff 	movw	r3, #4095	; 0xfff
    7cc0:	429a      	cmp	r2, r3
    7cc2:	d902      	bls.n	7cca <ACE_convert_from_Fahrenheit+0x56>
    {
        sample_value = MAX_PPE_SAMPLE_VALUE;
    7cc4:	f640 73ff 	movw	r3, #4095	; 0xfff
    7cc8:	817b      	strh	r3, [r7, #10]
    }
    return sample_value;
    7cca:	897b      	ldrh	r3, [r7, #10]
}
    7ccc:	4618      	mov	r0, r3
    7cce:	f107 0710 	add.w	r7, r7, #16
    7cd2:	46bd      	mov	sp, r7
    7cd4:	bd80      	pop	{r7, pc}
    7cd6:	bf00      	nop

00007cd8 <ACE_translate_pdma_value>:
uint16_t ACE_translate_pdma_value
(
    uint32_t            pdma_value,
    adc_channel_id_t *  channel_id
)
{
    7cd8:	b480      	push	{r7}
    7cda:	b085      	sub	sp, #20
    7cdc:	af00      	add	r7, sp, #0
    7cde:	6078      	str	r0, [r7, #4]
    7ce0:	6039      	str	r1, [r7, #0]
    uint16_t ppe_value;
      
    ppe_value = (uint16_t)((pdma_value >> 8u) & 0xFFFFu);
    7ce2:	687b      	ldr	r3, [r7, #4]
    7ce4:	ea4f 2313 	mov.w	r3, r3, lsr #8
    7ce8:	81fb      	strh	r3, [r7, #14]
    if ( channel_id != 0 )
    7cea:	683b      	ldr	r3, [r7, #0]
    7cec:	2b00      	cmp	r3, #0
    7cee:	d005      	beq.n	7cfc <ACE_translate_pdma_value+0x24>
    {
        *channel_id = (adc_channel_id_t)((pdma_value >> 24u) & 0xFFu);
    7cf0:	687b      	ldr	r3, [r7, #4]
    7cf2:	ea4f 6313 	mov.w	r3, r3, lsr #24
    7cf6:	b2da      	uxtb	r2, r3
    7cf8:	683b      	ldr	r3, [r7, #0]
    7cfa:	701a      	strb	r2, [r3, #0]
    }
    
    return ppe_value;
    7cfc:	89fb      	ldrh	r3, [r7, #14]
}
    7cfe:	4618      	mov	r0, r3
    7d00:	f107 0714 	add.w	r7, r7, #20
    7d04:	46bd      	mov	sp, r7
    7d06:	bc80      	pop	{r7}
    7d08:	4770      	bx	lr
    7d0a:	bf00      	nop

00007d0c <NVIC_ClearPendingIRQ>:
 *
 * Clear the pending bit for the specified interrupt. 
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
    7d0c:	b480      	push	{r7}
    7d0e:	b083      	sub	sp, #12
    7d10:	af00      	add	r7, sp, #0
    7d12:	4603      	mov	r3, r0
    7d14:	80fb      	strh	r3, [r7, #6]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    7d16:	f24e 1300 	movw	r3, #57600	; 0xe100
    7d1a:	f2ce 0300 	movt	r3, #57344	; 0xe000
    7d1e:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    7d22:	ea4f 1252 	mov.w	r2, r2, lsr #5
    7d26:	88f9      	ldrh	r1, [r7, #6]
    7d28:	f001 011f 	and.w	r1, r1, #31
    7d2c:	f04f 0001 	mov.w	r0, #1
    7d30:	fa00 f101 	lsl.w	r1, r0, r1
    7d34:	f102 0260 	add.w	r2, r2, #96	; 0x60
    7d38:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    7d3c:	f107 070c 	add.w	r7, r7, #12
    7d40:	46bd      	mov	sp, r7
    7d42:	bc80      	pop	{r7}
    7d44:	4770      	bx	lr
    7d46:	bf00      	nop

00007d48 <ace_init_flags>:
/*-------------------------------------------------------------------------*//**
  Intialise the ACE driver's internal data structures used by flag control
  functions.
 */
void ace_init_flags( void )
{
    7d48:	b480      	push	{r7}
    7d4a:	af00      	add	r7, sp, #0
        }
        
        g_ppe_global_flags_isr = 0u;
    }
#endif
}
    7d4c:	46bd      	mov	sp, r7
    7d4e:	bc80      	pop	{r7}
    7d50:	4770      	bx	lr
    7d52:	bf00      	nop

00007d54 <ACE_is_hysteresis_flag>:

/*-------------------------------------------------------------------------*//**
 *
 */
uint32_t ACE_is_hysteresis_flag( ace_flag_handle_t   flag_handle )
{
    7d54:	b480      	push	{r7}
    7d56:	b085      	sub	sp, #20
    7d58:	af00      	add	r7, sp, #0
    7d5a:	4603      	mov	r3, r0
    7d5c:	71fb      	strb	r3, [r7, #7]
    uint32_t hysteresis = 0u;
    7d5e:	f04f 0300 	mov.w	r3, #0
    7d62:	60fb      	str	r3, [r7, #12]
    if ( g_ppe_flags_desc_table[flag_handle].flag_type >= DUAL_HYSTERESIS_OVER )
    {
        hysteresis = 1u;
    }
#endif
    return hysteresis;
    7d64:	68fb      	ldr	r3, [r7, #12]
}
    7d66:	4618      	mov	r0, r3
    7d68:	f107 0714 	add.w	r7, r7, #20
    7d6c:	46bd      	mov	sp, r7
    7d6e:	bc80      	pop	{r7}
    7d70:	4770      	bx	lr
    7d72:	bf00      	nop

00007d74 <ACE_is_under_flag>:
 */
uint32_t ACE_is_under_flag
(
    ace_flag_handle_t   flag_handle
)
{
    7d74:	b480      	push	{r7}
    7d76:	b085      	sub	sp, #20
    7d78:	af00      	add	r7, sp, #0
    7d7a:	4603      	mov	r3, r0
    7d7c:	71fb      	strb	r3, [r7, #7]
    uint32_t is_under = 0;
    7d7e:	f04f 0300 	mov.w	r3, #0
    7d82:	60fb      	str	r3, [r7, #12]
        {
            is_under = flag_type_lut[flag_type];
        }
    }
#endif
    return is_under;
    7d84:	68fb      	ldr	r3, [r7, #12]
}
    7d86:	4618      	mov	r0, r3
    7d88:	f107 0714 	add.w	r7, r7, #20
    7d8c:	46bd      	mov	sp, r7
    7d8e:	bc80      	pop	{r7}
    7d90:	4770      	bx	lr
    7d92:	bf00      	nop

00007d94 <ACE_set_flag_threshold>:
void ACE_set_flag_threshold
(
    ace_flag_handle_t   flag_handle,
    uint16_t            new_threshold
)
{
    7d94:	b480      	push	{r7}
    7d96:	b083      	sub	sp, #12
    7d98:	af00      	add	r7, sp, #0
    7d9a:	4602      	mov	r2, r0
    7d9c:	460b      	mov	r3, r1
    7d9e:	71fa      	strb	r2, [r7, #7]
    7da0:	80bb      	strh	r3, [r7, #4]
                ACE->PPE_RAM_DATA[ppe_offset + 1u] = (ACE->PPE_RAM_DATA[ppe_offset + 1u] & (uint32_t)~PPE_RAM_THRESHOLD_MASK) + low_threshold;
            }
        }
    }
#endif
}
    7da2:	f107 070c 	add.w	r7, r7, #12
    7da6:	46bd      	mov	sp, r7
    7da8:	bc80      	pop	{r7}
    7daa:	4770      	bx	lr

00007dac <ACE_set_flag_assertion>:
void ACE_set_flag_assertion
(
    ace_flag_handle_t   flag_handle,
    uint16_t            assertion_value
)
{
    7dac:	b480      	push	{r7}
    7dae:	b083      	sub	sp, #12
    7db0:	af00      	add	r7, sp, #0
    7db2:	4602      	mov	r2, r0
    7db4:	460b      	mov	r3, r1
    7db6:	71fa      	strb	r2, [r7, #7]
    7db8:	80bb      	strh	r3, [r7, #4]
            ppe_offset = g_ppe_flags_desc_table[flag_handle].threshold_ppe_offset;
        }
        ACE->PPE_RAM_DATA[ppe_offset] = (ACE->PPE_RAM_DATA[ppe_offset] & ~PPE_RAM_THRESHOLD_MASK) + assertion_value;
    }
#endif
}
    7dba:	f107 070c 	add.w	r7, r7, #12
    7dbe:	46bd      	mov	sp, r7
    7dc0:	bc80      	pop	{r7}
    7dc2:	4770      	bx	lr

00007dc4 <ACE_set_flag_deassertion>:
void ACE_set_flag_deassertion
(
    ace_flag_handle_t   flag_handle,
    uint16_t            assertion_value
)
{
    7dc4:	b480      	push	{r7}
    7dc6:	b083      	sub	sp, #12
    7dc8:	af00      	add	r7, sp, #0
    7dca:	4602      	mov	r2, r0
    7dcc:	460b      	mov	r3, r1
    7dce:	71fa      	strb	r2, [r7, #7]
    7dd0:	80bb      	strh	r3, [r7, #4]
        }
        
        ACE->PPE_RAM_DATA[ppe_offset] = (ACE->PPE_RAM_DATA[ppe_offset] & ~PPE_RAM_THRESHOLD_MASK) + assertion_value;
    }
#endif
}
    7dd2:	f107 070c 	add.w	r7, r7, #12
    7dd6:	46bd      	mov	sp, r7
    7dd8:	bc80      	pop	{r7}
    7dda:	4770      	bx	lr

00007ddc <ACE_set_flag_hysteresis>:
ACE_set_flag_hysteresis
(
    ace_flag_handle_t   flag_handle,
    uint16_t            adc_hysteresis
)
{
    7ddc:	b480      	push	{r7}
    7dde:	b083      	sub	sp, #12
    7de0:	af00      	add	r7, sp, #0
    7de2:	4602      	mov	r2, r0
    7de4:	460b      	mov	r3, r1
    7de6:	71fa      	strb	r2, [r7, #7]
    7de8:	80bb      	strh	r3, [r7, #4]
            ACE->PPE_RAM_DATA[ppe_offset] = (ACE->PPE_RAM_DATA[ppe_offset] & ~PPE_RAM_THRESHOLD_MASK) + high_threshold;
            ACE->PPE_RAM_DATA[ppe_offset + 1u] = (ACE->PPE_RAM_DATA[ppe_offset + 1u] & ~PPE_RAM_THRESHOLD_MASK) + low_threshold;
        }
    }
#endif
}
    7dea:	f107 070c 	add.w	r7, r7, #12
    7dee:	46bd      	mov	sp, r7
    7df0:	bc80      	pop	{r7}
    7df2:	4770      	bx	lr

00007df4 <ACE_set_channel_hysteresis>:
ACE_set_channel_hysteresis
(
    ace_channel_handle_t    channel_handle,
    uint16_t                adc_hysteresis
)
{
    7df4:	b480      	push	{r7}
    7df6:	b083      	sub	sp, #12
    7df8:	af00      	add	r7, sp, #0
    7dfa:	4602      	mov	r2, r0
    7dfc:	460b      	mov	r3, r1
    7dfe:	71fa      	strb	r2, [r7, #7]
    7e00:	80bb      	strh	r3, [r7, #4]
            flag_handle = (ace_flag_handle_t)g_ace_channel_desc_table[channel_handle].p_flags_array[i];
            ACE_set_flag_hysteresis( flag_handle, adc_hysteresis );
        }
    }
#endif
}
    7e02:	f107 070c 	add.w	r7, r7, #12
    7e06:	46bd      	mov	sp, r7
    7e08:	bc80      	pop	{r7}
    7e0a:	4770      	bx	lr

00007e0c <ACE_get_flag_handle>:
ace_flag_handle_t
ACE_get_flag_handle
(
    const uint8_t * p_sz_full_flag_name
)
{
    7e0c:	b480      	push	{r7}
    7e0e:	b085      	sub	sp, #20
    7e10:	af00      	add	r7, sp, #0
    7e12:	6078      	str	r0, [r7, #4]
    ace_flag_handle_t flag_handle = INVALID_FLAG_HANDLE;
    7e14:	f04f 0300 	mov.w	r3, #0
    7e18:	73fb      	strb	r3, [r7, #15]
                break;
            }
        }
    }
#endif
    return flag_handle;
    7e1a:	7bfb      	ldrb	r3, [r7, #15]
}
    7e1c:	4618      	mov	r0, r3
    7e1e:	f107 0714 	add.w	r7, r7, #20
    7e22:	46bd      	mov	sp, r7
    7e24:	bc80      	pop	{r7}
    7e26:	4770      	bx	lr

00007e28 <ACE_get_flag_status>:
int32_t
ACE_get_flag_status
(
    ace_flag_handle_t   flag_handle
)
{
    7e28:	b480      	push	{r7}
    7e2a:	b085      	sub	sp, #20
    7e2c:	af00      	add	r7, sp, #0
    7e2e:	4603      	mov	r3, r0
    7e30:	71fb      	strb	r3, [r7, #7]
    int32_t flag_state = UNKNOWN_FLAG;
    7e32:	f04f 33ff 	mov.w	r3, #4294967295
    7e36:	60fb      	str	r3, [r7, #12]
            }
        }

    }
#endif
    return flag_state;
    7e38:	68fb      	ldr	r3, [r7, #12]
}
    7e3a:	4618      	mov	r0, r3
    7e3c:	f107 0714 	add.w	r7, r7, #20
    7e40:	46bd      	mov	sp, r7
    7e42:	bc80      	pop	{r7}
    7e44:	4770      	bx	lr
    7e46:	bf00      	nop

00007e48 <ACE_get_flag_name>:
const uint8_t *
ACE_get_flag_name
(
    ace_flag_handle_t flag_handle
)
{
    7e48:	b480      	push	{r7}
    7e4a:	b085      	sub	sp, #20
    7e4c:	af00      	add	r7, sp, #0
    7e4e:	4603      	mov	r3, r0
    7e50:	71fb      	strb	r3, [r7, #7]
    const uint8_t * psz_flag_name = 0;
    7e52:	f04f 0300 	mov.w	r3, #0
    7e56:	60fb      	str	r3, [r7, #12]
    if ( flag_handle < NB_OF_ACE_FLAG_HANDLES )
    {
        psz_flag_name = g_ppe_flags_desc_table[flag_handle].p_sz_flag_name;
    }
#endif
    return psz_flag_name;
    7e58:	68fb      	ldr	r3, [r7, #12]
}
    7e5a:	4618      	mov	r0, r3
    7e5c:	f107 0714 	add.w	r7, r7, #20
    7e60:	46bd      	mov	sp, r7
    7e62:	bc80      	pop	{r7}
    7e64:	4770      	bx	lr
    7e66:	bf00      	nop

00007e68 <ACE_get_flag_channel>:
ace_channel_handle_t
ACE_get_flag_channel
(
    ace_flag_handle_t flag_handle
)
{
    7e68:	b480      	push	{r7}
    7e6a:	b085      	sub	sp, #20
    7e6c:	af00      	add	r7, sp, #0
    7e6e:	4603      	mov	r3, r0
    7e70:	71fb      	strb	r3, [r7, #7]
    ace_channel_handle_t channel_handle = INVALID_CHANNEL_HANDLE;
    7e72:	f04f 0307 	mov.w	r3, #7
    7e76:	73fb      	strb	r3, [r7, #15]
    if ( flag_handle < NB_OF_ACE_FLAG_HANDLES )
    {
        channel_handle = g_ppe_flags_desc_table[flag_handle].channel_handle;
    }
#endif
    return channel_handle;
    7e78:	7bfb      	ldrb	r3, [r7, #15]
}
    7e7a:	4618      	mov	r0, r3
    7e7c:	f107 0714 	add.w	r7, r7, #20
    7e80:	46bd      	mov	sp, r7
    7e82:	bc80      	pop	{r7}
    7e84:	4770      	bx	lr
    7e86:	bf00      	nop

00007e88 <ACE_get_channel_flag_count>:
uint32_t
ACE_get_channel_flag_count
(
    ace_channel_handle_t    channel_handle
)
{
    7e88:	b480      	push	{r7}
    7e8a:	b085      	sub	sp, #20
    7e8c:	af00      	add	r7, sp, #0
    7e8e:	4603      	mov	r3, r0
    7e90:	71fb      	strb	r3, [r7, #7]
    uint32_t flag_count = 0;
    7e92:	f04f 0300 	mov.w	r3, #0
    7e96:	60fb      	str	r3, [r7, #12]
    if (channel_handle < ACE_NB_OF_INPUT_CHANNELS)
    {
        flag_count = g_ace_channel_desc_table[channel_handle].nb_of_flags;
    }
#endif
    return flag_count;
    7e98:	68fb      	ldr	r3, [r7, #12]
}
    7e9a:	4618      	mov	r0, r3
    7e9c:	f107 0714 	add.w	r7, r7, #20
    7ea0:	46bd      	mov	sp, r7
    7ea2:	bc80      	pop	{r7}
    7ea4:	4770      	bx	lr
    7ea6:	bf00      	nop

00007ea8 <ACE_get_channel_first_flag>:
ACE_get_channel_first_flag
(
    ace_channel_handle_t    channel_handle,
    uint16_t *              iterator
)
{
    7ea8:	b480      	push	{r7}
    7eaa:	b085      	sub	sp, #20
    7eac:	af00      	add	r7, sp, #0
    7eae:	4603      	mov	r3, r0
    7eb0:	6039      	str	r1, [r7, #0]
    7eb2:	71fb      	strb	r3, [r7, #7]
    ace_flag_handle_t flag_handle = INVALID_FLAG_HANDLE;
    7eb4:	f04f 0300 	mov.w	r3, #0
    7eb8:	73fb      	strb	r3, [r7, #15]
        {
            flag_handle = (ace_flag_handle_t)g_ace_channel_desc_table[channel_handle].p_flags_array[*iterator];
        }
    }
#endif    
    return flag_handle;
    7eba:	7bfb      	ldrb	r3, [r7, #15]
}
    7ebc:	4618      	mov	r0, r3
    7ebe:	f107 0714 	add.w	r7, r7, #20
    7ec2:	46bd      	mov	sp, r7
    7ec4:	bc80      	pop	{r7}
    7ec6:	4770      	bx	lr

00007ec8 <ACE_get_channel_next_flag>:
ACE_get_channel_next_flag
(
    ace_channel_handle_t    channel_handle,
    uint16_t *              iterator
)
{
    7ec8:	b480      	push	{r7}
    7eca:	b085      	sub	sp, #20
    7ecc:	af00      	add	r7, sp, #0
    7ece:	4603      	mov	r3, r0
    7ed0:	6039      	str	r1, [r7, #0]
    7ed2:	71fb      	strb	r3, [r7, #7]
    ace_flag_handle_t flag_handle = INVALID_FLAG_HANDLE;
    7ed4:	f04f 0300 	mov.w	r3, #0
    7ed8:	73fb      	strb	r3, [r7, #15]
        {
            flag_handle = (ace_flag_handle_t)g_ace_channel_desc_table[channel_handle].p_flags_array[*iterator];
        }
    }
#endif
    return flag_handle;
    7eda:	7bfb      	ldrb	r3, [r7, #15]
}
    7edc:	4618      	mov	r0, r3
    7ede:	f107 0714 	add.w	r7, r7, #20
    7ee2:	46bd      	mov	sp, r7
    7ee4:	bc80      	pop	{r7}
    7ee6:	4770      	bx	lr

00007ee8 <ACE_enable_channel_flags_irq>:
 */
void ACE_enable_channel_flags_irq
(
    ace_channel_handle_t channel_handle
)
{
    7ee8:	b480      	push	{r7}
    7eea:	b083      	sub	sp, #12
    7eec:	af00      	add	r7, sp, #0
    7eee:	4603      	mov	r3, r0
    7ef0:	71fb      	strb	r3, [r7, #7]
            flag_handle = (ace_flag_handle_t)g_ace_channel_desc_table[channel_handle].p_flags_array[flag_idx];
            ACE_enable_flag_irq( flag_handle );
        }
    }
#endif
}
    7ef2:	f107 070c 	add.w	r7, r7, #12
    7ef6:	46bd      	mov	sp, r7
    7ef8:	bc80      	pop	{r7}
    7efa:	4770      	bx	lr

00007efc <ACE_disable_channel_flags_irq>:
 */
void ACE_disable_channel_flags_irq
(
    ace_channel_handle_t channel_handle
)
{
    7efc:	b480      	push	{r7}
    7efe:	b083      	sub	sp, #12
    7f00:	af00      	add	r7, sp, #0
    7f02:	4603      	mov	r3, r0
    7f04:	71fb      	strb	r3, [r7, #7]
            flag_handle = (ace_flag_handle_t)g_ace_channel_desc_table[channel_handle].p_flags_array[flag_idx];
            ACE_disable_flag_irq( flag_handle );
        }
    }
#endif
}
    7f06:	f107 070c 	add.w	r7, r7, #12
    7f0a:	46bd      	mov	sp, r7
    7f0c:	bc80      	pop	{r7}
    7f0e:	4770      	bx	lr

00007f10 <ACE_clear_channel_flags_irq>:
 */
void ACE_clear_channel_flags_irq
(
    ace_channel_handle_t channel_handle
)
{
    7f10:	b480      	push	{r7}
    7f12:	b083      	sub	sp, #12
    7f14:	af00      	add	r7, sp, #0
    7f16:	4603      	mov	r3, r0
    7f18:	71fb      	strb	r3, [r7, #7]
            flag_handle = (ace_flag_handle_t)g_ace_channel_desc_table[channel_handle].p_flags_array[flag_idx];
            ACE_clear_flag_irq( flag_handle );
        }
    }
#endif
}
    7f1a:	f107 070c 	add.w	r7, r7, #12
    7f1e:	46bd      	mov	sp, r7
    7f20:	bc80      	pop	{r7}
    7f22:	4770      	bx	lr

00007f24 <ACE_enable_flag_irq>:
 */
void ACE_enable_flag_irq
(
    ace_flag_handle_t flag_handle
)
{
    7f24:	b480      	push	{r7}
    7f26:	b083      	sub	sp, #12
    7f28:	af00      	add	r7, sp, #0
    7f2a:	4603      	mov	r3, r0
    7f2c:	71fb      	strb	r3, [r7, #7]
        }
        
        NVIC_EnableIRQ( threshold_irqn_lut[flag_bit_offset] );
    }
#endif
}
    7f2e:	f107 070c 	add.w	r7, r7, #12
    7f32:	46bd      	mov	sp, r7
    7f34:	bc80      	pop	{r7}
    7f36:	4770      	bx	lr

00007f38 <ACE_disable_flag_irq>:
 */
void ACE_disable_flag_irq
(
    ace_flag_handle_t flag_handle
)
{
    7f38:	b480      	push	{r7}
    7f3a:	b083      	sub	sp, #12
    7f3c:	af00      	add	r7, sp, #0
    7f3e:	4603      	mov	r3, r0
    7f40:	71fb      	strb	r3, [r7, #7]
            dummy_read = *(flags_irq_enable_regs_lut[ppe_flag_group]);
            ++dummy_read;
        }
    }
#endif
}
    7f42:	f107 070c 	add.w	r7, r7, #12
    7f46:	46bd      	mov	sp, r7
    7f48:	bc80      	pop	{r7}
    7f4a:	4770      	bx	lr

00007f4c <ACE_clear_flag_irq>:
 */
void ACE_clear_flag_irq
(
    ace_flag_handle_t flag_handle
)
{
    7f4c:	b480      	push	{r7}
    7f4e:	b083      	sub	sp, #12
    7f50:	af00      	add	r7, sp, #0
    7f52:	4603      	mov	r3, r0
    7f54:	71fb      	strb	r3, [r7, #7]
            dummy_read = *(flags_irq_clear_regs_lut[ppe_flag_group]);
            ++dummy_read;
        }
    }
#endif
}
    7f56:	f107 070c 	add.w	r7, r7, #12
    7f5a:	46bd      	mov	sp, r7
    7f5c:	bc80      	pop	{r7}
    7f5e:	4770      	bx	lr

00007f60 <ACE_register_flag_isr>:
void ACE_register_flag_isr
(
    ace_flag_handle_t   flag_handle,
    flag_isr_t          flag_isr
)
{
    7f60:	b480      	push	{r7}
    7f62:	b083      	sub	sp, #12
    7f64:	af00      	add	r7, sp, #0
    7f66:	4603      	mov	r3, r0
    7f68:	6039      	str	r1, [r7, #0]
    7f6a:	71fb      	strb	r3, [r7, #7]
        {
            g_ppe_flags_isr_lut[flag_id] = flag_isr;
        }
    }
#endif
}
    7f6c:	f107 070c 	add.w	r7, r7, #12
    7f70:	46bd      	mov	sp, r7
    7f72:	bc80      	pop	{r7}
    7f74:	4770      	bx	lr
    7f76:	bf00      	nop

00007f78 <ACE_register_channel_flags_isr>:
void ACE_register_channel_flags_isr
(
    ace_channel_handle_t    channel_handle,
    channel_flag_isr_t      channel_flag_isr
)
{
    7f78:	b480      	push	{r7}
    7f7a:	b083      	sub	sp, #12
    7f7c:	af00      	add	r7, sp, #0
    7f7e:	4603      	mov	r3, r0
    7f80:	6039      	str	r1, [r7, #0]
    7f82:	71fb      	strb	r3, [r7, #7]
    if ( channel_handle < NB_OF_ACE_CHANNEL_HANDLES )
    {
        g_ppe_channel_flags_isr_lut[channel_handle] = channel_flag_isr;
    }
#endif
}
    7f84:	f107 070c 	add.w	r7, r7, #12
    7f88:	46bd      	mov	sp, r7
    7f8a:	bc80      	pop	{r7}
    7f8c:	4770      	bx	lr
    7f8e:	bf00      	nop

00007f90 <ACE_register_global_flags_isr>:
 */
void ACE_register_global_flags_isr
(
    global_flag_isr_t  global_flag_isr
)
{
    7f90:	b480      	push	{r7}
    7f92:	b083      	sub	sp, #12
    7f94:	af00      	add	r7, sp, #0
    7f96:	6078      	str	r0, [r7, #4]
#if (ACE_NB_OF_PPE_FLAGS > 0)
    g_ppe_global_flags_isr = global_flag_isr;
#endif
}
    7f98:	f107 070c 	add.w	r7, r7, #12
    7f9c:	46bd      	mov	sp, r7
    7f9e:	bc80      	pop	{r7}
    7fa0:	4770      	bx	lr
    7fa2:	bf00      	nop

00007fa4 <process_flag_irq>:
/*-------------------------------------------------------------------------*//**
 * Actual PPE flag interrupt service routines:
 */

static void process_flag_irq( uint8_t threshold_flag_id )
{
    7fa4:	b480      	push	{r7}
    7fa6:	b083      	sub	sp, #12
    7fa8:	af00      	add	r7, sp, #0
    7faa:	4603      	mov	r3, r0
    7fac:	71fb      	strb	r3, [r7, #7]
            dummy_read = *(flags_irq_clear_regs_lut[flag_group]);
            ++dummy_read;
        }
    }
#endif
}
    7fae:	f107 070c 	add.w	r7, r7, #12
    7fb2:	46bd      	mov	sp, r7
    7fb4:	bc80      	pop	{r7}
    7fb6:	4770      	bx	lr

00007fb8 <ACE_PPE_Flag0_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag0_IRQHandler( void )
#else
void ACE_PPE_Flag0_IRQHandler( void )
#endif
{
    7fb8:	4668      	mov	r0, sp
    7fba:	f020 0107 	bic.w	r1, r0, #7
    7fbe:	468d      	mov	sp, r1
    7fc0:	b589      	push	{r0, r3, r7, lr}
    7fc2:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG0 );
    7fc4:	f04f 0000 	mov.w	r0, #0
    7fc8:	f7ff ffec 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag0_IRQn );
    7fcc:	f04f 0076 	mov.w	r0, #118	; 0x76
    7fd0:	f7ff fe9c 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    7fd4:	46bd      	mov	sp, r7
    7fd6:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    7fda:	4685      	mov	sp, r0
    7fdc:	4770      	bx	lr
    7fde:	bf00      	nop

00007fe0 <ACE_PPE_Flag1_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag1_IRQHandler( void )
#else
void ACE_PPE_Flag1_IRQHandler( void )
#endif
{
    7fe0:	4668      	mov	r0, sp
    7fe2:	f020 0107 	bic.w	r1, r0, #7
    7fe6:	468d      	mov	sp, r1
    7fe8:	b589      	push	{r0, r3, r7, lr}
    7fea:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG1 );
    7fec:	f04f 0001 	mov.w	r0, #1
    7ff0:	f7ff ffd8 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag1_IRQn );
    7ff4:	f04f 0077 	mov.w	r0, #119	; 0x77
    7ff8:	f7ff fe88 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    7ffc:	46bd      	mov	sp, r7
    7ffe:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    8002:	4685      	mov	sp, r0
    8004:	4770      	bx	lr
    8006:	bf00      	nop

00008008 <ACE_PPE_Flag2_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag2_IRQHandler( void )
#else
void ACE_PPE_Flag2_IRQHandler( void )
#endif
{
    8008:	4668      	mov	r0, sp
    800a:	f020 0107 	bic.w	r1, r0, #7
    800e:	468d      	mov	sp, r1
    8010:	b589      	push	{r0, r3, r7, lr}
    8012:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG2 );
    8014:	f04f 0002 	mov.w	r0, #2
    8018:	f7ff ffc4 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag2_IRQn );
    801c:	f04f 0078 	mov.w	r0, #120	; 0x78
    8020:	f7ff fe74 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    8024:	46bd      	mov	sp, r7
    8026:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    802a:	4685      	mov	sp, r0
    802c:	4770      	bx	lr
    802e:	bf00      	nop

00008030 <ACE_PPE_Flag3_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag3_IRQHandler( void )
#else
void ACE_PPE_Flag3_IRQHandler( void )
#endif
{
    8030:	4668      	mov	r0, sp
    8032:	f020 0107 	bic.w	r1, r0, #7
    8036:	468d      	mov	sp, r1
    8038:	b589      	push	{r0, r3, r7, lr}
    803a:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG3 );
    803c:	f04f 0003 	mov.w	r0, #3
    8040:	f7ff ffb0 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag3_IRQn );
    8044:	f04f 0079 	mov.w	r0, #121	; 0x79
    8048:	f7ff fe60 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    804c:	46bd      	mov	sp, r7
    804e:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    8052:	4685      	mov	sp, r0
    8054:	4770      	bx	lr
    8056:	bf00      	nop

00008058 <ACE_PPE_Flag4_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag4_IRQHandler( void )
#else
void ACE_PPE_Flag4_IRQHandler( void )
#endif
{
    8058:	4668      	mov	r0, sp
    805a:	f020 0107 	bic.w	r1, r0, #7
    805e:	468d      	mov	sp, r1
    8060:	b589      	push	{r0, r3, r7, lr}
    8062:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG4 );
    8064:	f04f 0004 	mov.w	r0, #4
    8068:	f7ff ff9c 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag4_IRQn );
    806c:	f04f 007a 	mov.w	r0, #122	; 0x7a
    8070:	f7ff fe4c 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    8074:	46bd      	mov	sp, r7
    8076:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    807a:	4685      	mov	sp, r0
    807c:	4770      	bx	lr
    807e:	bf00      	nop

00008080 <ACE_PPE_Flag5_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag5_IRQHandler( void )
#else
void ACE_PPE_Flag5_IRQHandler( void )
#endif
{
    8080:	4668      	mov	r0, sp
    8082:	f020 0107 	bic.w	r1, r0, #7
    8086:	468d      	mov	sp, r1
    8088:	b589      	push	{r0, r3, r7, lr}
    808a:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG5 );
    808c:	f04f 0005 	mov.w	r0, #5
    8090:	f7ff ff88 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag5_IRQn );
    8094:	f04f 007b 	mov.w	r0, #123	; 0x7b
    8098:	f7ff fe38 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    809c:	46bd      	mov	sp, r7
    809e:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    80a2:	4685      	mov	sp, r0
    80a4:	4770      	bx	lr
    80a6:	bf00      	nop

000080a8 <ACE_PPE_Flag6_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag6_IRQHandler( void )
#else
void ACE_PPE_Flag6_IRQHandler( void )
#endif
{
    80a8:	4668      	mov	r0, sp
    80aa:	f020 0107 	bic.w	r1, r0, #7
    80ae:	468d      	mov	sp, r1
    80b0:	b589      	push	{r0, r3, r7, lr}
    80b2:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG6 );
    80b4:	f04f 0006 	mov.w	r0, #6
    80b8:	f7ff ff74 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag6_IRQn );
    80bc:	f04f 007c 	mov.w	r0, #124	; 0x7c
    80c0:	f7ff fe24 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    80c4:	46bd      	mov	sp, r7
    80c6:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    80ca:	4685      	mov	sp, r0
    80cc:	4770      	bx	lr
    80ce:	bf00      	nop

000080d0 <ACE_PPE_Flag7_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag7_IRQHandler( void )
#else
void ACE_PPE_Flag7_IRQHandler( void )
#endif
{
    80d0:	4668      	mov	r0, sp
    80d2:	f020 0107 	bic.w	r1, r0, #7
    80d6:	468d      	mov	sp, r1
    80d8:	b589      	push	{r0, r3, r7, lr}
    80da:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG7 );
    80dc:	f04f 0007 	mov.w	r0, #7
    80e0:	f7ff ff60 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag7_IRQn );
    80e4:	f04f 007d 	mov.w	r0, #125	; 0x7d
    80e8:	f7ff fe10 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    80ec:	46bd      	mov	sp, r7
    80ee:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    80f2:	4685      	mov	sp, r0
    80f4:	4770      	bx	lr
    80f6:	bf00      	nop

000080f8 <ACE_PPE_Flag8_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag8_IRQHandler( void )
#else
void ACE_PPE_Flag8_IRQHandler( void )
#endif
{
    80f8:	4668      	mov	r0, sp
    80fa:	f020 0107 	bic.w	r1, r0, #7
    80fe:	468d      	mov	sp, r1
    8100:	b589      	push	{r0, r3, r7, lr}
    8102:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG8 );
    8104:	f04f 0008 	mov.w	r0, #8
    8108:	f7ff ff4c 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag8_IRQn );
    810c:	f04f 007e 	mov.w	r0, #126	; 0x7e
    8110:	f7ff fdfc 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    8114:	46bd      	mov	sp, r7
    8116:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    811a:	4685      	mov	sp, r0
    811c:	4770      	bx	lr
    811e:	bf00      	nop

00008120 <ACE_PPE_Flag9_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag9_IRQHandler( void )
#else
void ACE_PPE_Flag9_IRQHandler( void )
#endif
{
    8120:	4668      	mov	r0, sp
    8122:	f020 0107 	bic.w	r1, r0, #7
    8126:	468d      	mov	sp, r1
    8128:	b589      	push	{r0, r3, r7, lr}
    812a:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG9 );
    812c:	f04f 0009 	mov.w	r0, #9
    8130:	f7ff ff38 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag9_IRQn );
    8134:	f04f 007f 	mov.w	r0, #127	; 0x7f
    8138:	f7ff fde8 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    813c:	46bd      	mov	sp, r7
    813e:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    8142:	4685      	mov	sp, r0
    8144:	4770      	bx	lr
    8146:	bf00      	nop

00008148 <ACE_PPE_Flag10_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag10_IRQHandler( void )
#else
void ACE_PPE_Flag10_IRQHandler( void )
#endif
{
    8148:	4668      	mov	r0, sp
    814a:	f020 0107 	bic.w	r1, r0, #7
    814e:	468d      	mov	sp, r1
    8150:	b589      	push	{r0, r3, r7, lr}
    8152:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG10 );
    8154:	f04f 000a 	mov.w	r0, #10
    8158:	f7ff ff24 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag10_IRQn );
    815c:	f04f 0080 	mov.w	r0, #128	; 0x80
    8160:	f7ff fdd4 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    8164:	46bd      	mov	sp, r7
    8166:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    816a:	4685      	mov	sp, r0
    816c:	4770      	bx	lr
    816e:	bf00      	nop

00008170 <ACE_PPE_Flag11_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag11_IRQHandler( void )
#else
void ACE_PPE_Flag11_IRQHandler( void )
#endif
{
    8170:	4668      	mov	r0, sp
    8172:	f020 0107 	bic.w	r1, r0, #7
    8176:	468d      	mov	sp, r1
    8178:	b589      	push	{r0, r3, r7, lr}
    817a:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG11 );
    817c:	f04f 000b 	mov.w	r0, #11
    8180:	f7ff ff10 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag11_IRQn );
    8184:	f04f 0081 	mov.w	r0, #129	; 0x81
    8188:	f7ff fdc0 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    818c:	46bd      	mov	sp, r7
    818e:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    8192:	4685      	mov	sp, r0
    8194:	4770      	bx	lr
    8196:	bf00      	nop

00008198 <ACE_PPE_Flag12_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag12_IRQHandler( void )
#else
void ACE_PPE_Flag12_IRQHandler( void )
#endif
{
    8198:	4668      	mov	r0, sp
    819a:	f020 0107 	bic.w	r1, r0, #7
    819e:	468d      	mov	sp, r1
    81a0:	b589      	push	{r0, r3, r7, lr}
    81a2:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG12 );
    81a4:	f04f 000c 	mov.w	r0, #12
    81a8:	f7ff fefc 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag12_IRQn );
    81ac:	f04f 0082 	mov.w	r0, #130	; 0x82
    81b0:	f7ff fdac 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    81b4:	46bd      	mov	sp, r7
    81b6:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    81ba:	4685      	mov	sp, r0
    81bc:	4770      	bx	lr
    81be:	bf00      	nop

000081c0 <ACE_PPE_Flag13_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag13_IRQHandler( void )
#else
void ACE_PPE_Flag13_IRQHandler( void )
#endif
{
    81c0:	4668      	mov	r0, sp
    81c2:	f020 0107 	bic.w	r1, r0, #7
    81c6:	468d      	mov	sp, r1
    81c8:	b589      	push	{r0, r3, r7, lr}
    81ca:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG13 );
    81cc:	f04f 000d 	mov.w	r0, #13
    81d0:	f7ff fee8 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag13_IRQn );
    81d4:	f04f 0083 	mov.w	r0, #131	; 0x83
    81d8:	f7ff fd98 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    81dc:	46bd      	mov	sp, r7
    81de:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    81e2:	4685      	mov	sp, r0
    81e4:	4770      	bx	lr
    81e6:	bf00      	nop

000081e8 <ACE_PPE_Flag14_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag14_IRQHandler( void )
#else
void ACE_PPE_Flag14_IRQHandler( void )
#endif
{
    81e8:	4668      	mov	r0, sp
    81ea:	f020 0107 	bic.w	r1, r0, #7
    81ee:	468d      	mov	sp, r1
    81f0:	b589      	push	{r0, r3, r7, lr}
    81f2:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG14 );
    81f4:	f04f 000e 	mov.w	r0, #14
    81f8:	f7ff fed4 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag14_IRQn );
    81fc:	f04f 0084 	mov.w	r0, #132	; 0x84
    8200:	f7ff fd84 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    8204:	46bd      	mov	sp, r7
    8206:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    820a:	4685      	mov	sp, r0
    820c:	4770      	bx	lr
    820e:	bf00      	nop

00008210 <ACE_PPE_Flag15_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag15_IRQHandler( void )
#else
void ACE_PPE_Flag15_IRQHandler( void )
#endif
{
    8210:	4668      	mov	r0, sp
    8212:	f020 0107 	bic.w	r1, r0, #7
    8216:	468d      	mov	sp, r1
    8218:	b589      	push	{r0, r3, r7, lr}
    821a:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG15 );
    821c:	f04f 000f 	mov.w	r0, #15
    8220:	f7ff fec0 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag15_IRQn );
    8224:	f04f 0085 	mov.w	r0, #133	; 0x85
    8228:	f7ff fd70 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    822c:	46bd      	mov	sp, r7
    822e:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    8232:	4685      	mov	sp, r0
    8234:	4770      	bx	lr
    8236:	bf00      	nop

00008238 <ACE_PPE_Flag16_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag16_IRQHandler( void )
#else
void ACE_PPE_Flag16_IRQHandler( void )
#endif
{
    8238:	4668      	mov	r0, sp
    823a:	f020 0107 	bic.w	r1, r0, #7
    823e:	468d      	mov	sp, r1
    8240:	b589      	push	{r0, r3, r7, lr}
    8242:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG16 );
    8244:	f04f 0010 	mov.w	r0, #16
    8248:	f7ff feac 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag16_IRQn );
    824c:	f04f 0086 	mov.w	r0, #134	; 0x86
    8250:	f7ff fd5c 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    8254:	46bd      	mov	sp, r7
    8256:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    825a:	4685      	mov	sp, r0
    825c:	4770      	bx	lr
    825e:	bf00      	nop

00008260 <ACE_PPE_Flag17_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag17_IRQHandler( void )
#else
void ACE_PPE_Flag17_IRQHandler( void )
#endif
{
    8260:	4668      	mov	r0, sp
    8262:	f020 0107 	bic.w	r1, r0, #7
    8266:	468d      	mov	sp, r1
    8268:	b589      	push	{r0, r3, r7, lr}
    826a:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG17 );
    826c:	f04f 0011 	mov.w	r0, #17
    8270:	f7ff fe98 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag17_IRQn );
    8274:	f04f 0087 	mov.w	r0, #135	; 0x87
    8278:	f7ff fd48 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    827c:	46bd      	mov	sp, r7
    827e:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    8282:	4685      	mov	sp, r0
    8284:	4770      	bx	lr
    8286:	bf00      	nop

00008288 <ACE_PPE_Flag18_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag18_IRQHandler( void )
#else
void ACE_PPE_Flag18_IRQHandler( void )
#endif
{
    8288:	4668      	mov	r0, sp
    828a:	f020 0107 	bic.w	r1, r0, #7
    828e:	468d      	mov	sp, r1
    8290:	b589      	push	{r0, r3, r7, lr}
    8292:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG18 );
    8294:	f04f 0012 	mov.w	r0, #18
    8298:	f7ff fe84 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag18_IRQn );
    829c:	f04f 0088 	mov.w	r0, #136	; 0x88
    82a0:	f7ff fd34 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    82a4:	46bd      	mov	sp, r7
    82a6:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    82aa:	4685      	mov	sp, r0
    82ac:	4770      	bx	lr
    82ae:	bf00      	nop

000082b0 <ACE_PPE_Flag19_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag19_IRQHandler( void )
#else
void ACE_PPE_Flag19_IRQHandler( void )
#endif
{
    82b0:	4668      	mov	r0, sp
    82b2:	f020 0107 	bic.w	r1, r0, #7
    82b6:	468d      	mov	sp, r1
    82b8:	b589      	push	{r0, r3, r7, lr}
    82ba:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG19 );
    82bc:	f04f 0013 	mov.w	r0, #19
    82c0:	f7ff fe70 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag19_IRQn );
    82c4:	f04f 0089 	mov.w	r0, #137	; 0x89
    82c8:	f7ff fd20 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    82cc:	46bd      	mov	sp, r7
    82ce:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    82d2:	4685      	mov	sp, r0
    82d4:	4770      	bx	lr
    82d6:	bf00      	nop

000082d8 <ACE_PPE_Flag20_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag20_IRQHandler( void )
#else
void ACE_PPE_Flag20_IRQHandler( void )
#endif
{
    82d8:	4668      	mov	r0, sp
    82da:	f020 0107 	bic.w	r1, r0, #7
    82de:	468d      	mov	sp, r1
    82e0:	b589      	push	{r0, r3, r7, lr}
    82e2:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG20 );
    82e4:	f04f 0014 	mov.w	r0, #20
    82e8:	f7ff fe5c 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag20_IRQn );
    82ec:	f04f 008a 	mov.w	r0, #138	; 0x8a
    82f0:	f7ff fd0c 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    82f4:	46bd      	mov	sp, r7
    82f6:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    82fa:	4685      	mov	sp, r0
    82fc:	4770      	bx	lr
    82fe:	bf00      	nop

00008300 <ACE_PPE_Flag21_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag21_IRQHandler( void )
#else
void ACE_PPE_Flag21_IRQHandler( void )
#endif
{
    8300:	4668      	mov	r0, sp
    8302:	f020 0107 	bic.w	r1, r0, #7
    8306:	468d      	mov	sp, r1
    8308:	b589      	push	{r0, r3, r7, lr}
    830a:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG21 );
    830c:	f04f 0015 	mov.w	r0, #21
    8310:	f7ff fe48 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag21_IRQn );
    8314:	f04f 008b 	mov.w	r0, #139	; 0x8b
    8318:	f7ff fcf8 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    831c:	46bd      	mov	sp, r7
    831e:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    8322:	4685      	mov	sp, r0
    8324:	4770      	bx	lr
    8326:	bf00      	nop

00008328 <ACE_PPE_Flag22_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag22_IRQHandler( void )
#else
void ACE_PPE_Flag22_IRQHandler( void )
#endif
{
    8328:	4668      	mov	r0, sp
    832a:	f020 0107 	bic.w	r1, r0, #7
    832e:	468d      	mov	sp, r1
    8330:	b589      	push	{r0, r3, r7, lr}
    8332:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG22 );
    8334:	f04f 0016 	mov.w	r0, #22
    8338:	f7ff fe34 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag22_IRQn );
    833c:	f04f 008c 	mov.w	r0, #140	; 0x8c
    8340:	f7ff fce4 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    8344:	46bd      	mov	sp, r7
    8346:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    834a:	4685      	mov	sp, r0
    834c:	4770      	bx	lr
    834e:	bf00      	nop

00008350 <ACE_PPE_Flag23_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag23_IRQHandler( void )
#else
void ACE_PPE_Flag23_IRQHandler( void )
#endif
{
    8350:	4668      	mov	r0, sp
    8352:	f020 0107 	bic.w	r1, r0, #7
    8356:	468d      	mov	sp, r1
    8358:	b589      	push	{r0, r3, r7, lr}
    835a:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG23 );
    835c:	f04f 0017 	mov.w	r0, #23
    8360:	f7ff fe20 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag23_IRQn );
    8364:	f04f 008d 	mov.w	r0, #141	; 0x8d
    8368:	f7ff fcd0 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    836c:	46bd      	mov	sp, r7
    836e:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    8372:	4685      	mov	sp, r0
    8374:	4770      	bx	lr
    8376:	bf00      	nop

00008378 <ACE_PPE_Flag24_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag24_IRQHandler( void )
#else
void ACE_PPE_Flag24_IRQHandler( void )
#endif
{
    8378:	4668      	mov	r0, sp
    837a:	f020 0107 	bic.w	r1, r0, #7
    837e:	468d      	mov	sp, r1
    8380:	b589      	push	{r0, r3, r7, lr}
    8382:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG24 );
    8384:	f04f 0018 	mov.w	r0, #24
    8388:	f7ff fe0c 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag24_IRQn );
    838c:	f04f 008e 	mov.w	r0, #142	; 0x8e
    8390:	f7ff fcbc 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    8394:	46bd      	mov	sp, r7
    8396:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    839a:	4685      	mov	sp, r0
    839c:	4770      	bx	lr
    839e:	bf00      	nop

000083a0 <ACE_PPE_Flag25_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag25_IRQHandler( void )
#else
void ACE_PPE_Flag25_IRQHandler( void )
#endif
{
    83a0:	4668      	mov	r0, sp
    83a2:	f020 0107 	bic.w	r1, r0, #7
    83a6:	468d      	mov	sp, r1
    83a8:	b589      	push	{r0, r3, r7, lr}
    83aa:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG25 );
    83ac:	f04f 0019 	mov.w	r0, #25
    83b0:	f7ff fdf8 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag25_IRQn );
    83b4:	f04f 008f 	mov.w	r0, #143	; 0x8f
    83b8:	f7ff fca8 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    83bc:	46bd      	mov	sp, r7
    83be:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    83c2:	4685      	mov	sp, r0
    83c4:	4770      	bx	lr
    83c6:	bf00      	nop

000083c8 <ACE_PPE_Flag26_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag26_IRQHandler( void )
#else
void ACE_PPE_Flag26_IRQHandler( void )
#endif
{
    83c8:	4668      	mov	r0, sp
    83ca:	f020 0107 	bic.w	r1, r0, #7
    83ce:	468d      	mov	sp, r1
    83d0:	b589      	push	{r0, r3, r7, lr}
    83d2:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG26 );
    83d4:	f04f 001a 	mov.w	r0, #26
    83d8:	f7ff fde4 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag26_IRQn );
    83dc:	f04f 0090 	mov.w	r0, #144	; 0x90
    83e0:	f7ff fc94 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    83e4:	46bd      	mov	sp, r7
    83e6:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    83ea:	4685      	mov	sp, r0
    83ec:	4770      	bx	lr
    83ee:	bf00      	nop

000083f0 <ACE_PPE_Flag27_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag27_IRQHandler( void )
#else
void ACE_PPE_Flag27_IRQHandler( void )
#endif
{
    83f0:	4668      	mov	r0, sp
    83f2:	f020 0107 	bic.w	r1, r0, #7
    83f6:	468d      	mov	sp, r1
    83f8:	b589      	push	{r0, r3, r7, lr}
    83fa:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG27 );
    83fc:	f04f 001b 	mov.w	r0, #27
    8400:	f7ff fdd0 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag27_IRQn );
    8404:	f04f 0091 	mov.w	r0, #145	; 0x91
    8408:	f7ff fc80 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    840c:	46bd      	mov	sp, r7
    840e:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    8412:	4685      	mov	sp, r0
    8414:	4770      	bx	lr
    8416:	bf00      	nop

00008418 <ACE_PPE_Flag28_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag28_IRQHandler( void )
#else
void ACE_PPE_Flag28_IRQHandler( void )
#endif
{
    8418:	4668      	mov	r0, sp
    841a:	f020 0107 	bic.w	r1, r0, #7
    841e:	468d      	mov	sp, r1
    8420:	b589      	push	{r0, r3, r7, lr}
    8422:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG28 );
    8424:	f04f 001c 	mov.w	r0, #28
    8428:	f7ff fdbc 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag28_IRQn );
    842c:	f04f 0092 	mov.w	r0, #146	; 0x92
    8430:	f7ff fc6c 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    8434:	46bd      	mov	sp, r7
    8436:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    843a:	4685      	mov	sp, r0
    843c:	4770      	bx	lr
    843e:	bf00      	nop

00008440 <ACE_PPE_Flag29_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag29_IRQHandler( void )
#else
void ACE_PPE_Flag29_IRQHandler( void )
#endif
{
    8440:	4668      	mov	r0, sp
    8442:	f020 0107 	bic.w	r1, r0, #7
    8446:	468d      	mov	sp, r1
    8448:	b589      	push	{r0, r3, r7, lr}
    844a:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG29 );
    844c:	f04f 001d 	mov.w	r0, #29
    8450:	f7ff fda8 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag29_IRQn );
    8454:	f04f 0093 	mov.w	r0, #147	; 0x93
    8458:	f7ff fc58 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    845c:	46bd      	mov	sp, r7
    845e:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    8462:	4685      	mov	sp, r0
    8464:	4770      	bx	lr
    8466:	bf00      	nop

00008468 <ACE_PPE_Flag30_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag30_IRQHandler( void )
#else
void ACE_PPE_Flag30_IRQHandler( void )
#endif
{
    8468:	4668      	mov	r0, sp
    846a:	f020 0107 	bic.w	r1, r0, #7
    846e:	468d      	mov	sp, r1
    8470:	b589      	push	{r0, r3, r7, lr}
    8472:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG30 );
    8474:	f04f 001e 	mov.w	r0, #30
    8478:	f7ff fd94 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag30_IRQn );
    847c:	f04f 0094 	mov.w	r0, #148	; 0x94
    8480:	f7ff fc44 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    8484:	46bd      	mov	sp, r7
    8486:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    848a:	4685      	mov	sp, r0
    848c:	4770      	bx	lr
    848e:	bf00      	nop

00008490 <ACE_PPE_Flag31_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void ACE_PPE_Flag31_IRQHandler( void )
#else
void ACE_PPE_Flag31_IRQHandler( void )
#endif
{
    8490:	4668      	mov	r0, sp
    8492:	f020 0107 	bic.w	r1, r0, #7
    8496:	468d      	mov	sp, r1
    8498:	b589      	push	{r0, r3, r7, lr}
    849a:	af00      	add	r7, sp, #0
    process_flag_irq( THRESHOLD_FLAG31 );
    849c:	f04f 001f 	mov.w	r0, #31
    84a0:	f7ff fd80 	bl	7fa4 <process_flag_irq>
    NVIC_ClearPendingIRQ( ACE_PPE_Flag31_IRQn );
    84a4:	f04f 0095 	mov.w	r0, #149	; 0x95
    84a8:	f7ff fc30 	bl	7d0c <NVIC_ClearPendingIRQ>
}
    84ac:	46bd      	mov	sp, r7
    84ae:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    84b2:	4685      	mov	sp, r0
    84b4:	4770      	bx	lr
    84b6:	bf00      	nop

000084b8 <ACE_get_sse_seq_handle>:
sse_sequence_handle_t
ACE_get_sse_seq_handle
(
    const uint8_t * p_sz_sequence_name
)
{
    84b8:	b580      	push	{r7, lr}
    84ba:	b084      	sub	sp, #16
    84bc:	af00      	add	r7, sp, #0
    84be:	6078      	str	r0, [r7, #4]
    uint16_t seq_idx;
    sse_sequence_handle_t handle = INVALID_SSE_SEQ_HANDLE;
    84c0:	f64f 73ff 	movw	r3, #65535	; 0xffff
    84c4:	817b      	strh	r3, [r7, #10]
    
    for ( seq_idx = 0u;  seq_idx < (uint32_t)ACE_NB_OF_SSE_PROCEDURES; ++seq_idx )
    84c6:	f04f 0300 	mov.w	r3, #0
    84ca:	813b      	strh	r3, [r7, #8]
    84cc:	e02d      	b.n	852a <ACE_get_sse_seq_handle+0x72>
    {
        if ( g_sse_sequences_desc_table[seq_idx].p_sz_proc_name != 0 )
    84ce:	8939      	ldrh	r1, [r7, #8]
    84d0:	f240 02c0 	movw	r2, #192	; 0xc0
    84d4:	f2c2 0200 	movt	r2, #8192	; 0x2000
    84d8:	460b      	mov	r3, r1
    84da:	ea4f 0383 	mov.w	r3, r3, lsl #2
    84de:	440b      	add	r3, r1
    84e0:	ea4f 0383 	mov.w	r3, r3, lsl #2
    84e4:	4413      	add	r3, r2
    84e6:	681b      	ldr	r3, [r3, #0]
    84e8:	2b00      	cmp	r3, #0
    84ea:	d01a      	beq.n	8522 <ACE_get_sse_seq_handle+0x6a>
        {
            int32_t diff;
            diff = strncmp( (const char *)p_sz_sequence_name, (const char *)g_sse_sequences_desc_table[seq_idx].p_sz_proc_name, MAX_PROCEDURE_NAME_LENGTH );
    84ec:	8939      	ldrh	r1, [r7, #8]
    84ee:	f240 02c0 	movw	r2, #192	; 0xc0
    84f2:	f2c2 0200 	movt	r2, #8192	; 0x2000
    84f6:	460b      	mov	r3, r1
    84f8:	ea4f 0383 	mov.w	r3, r3, lsl #2
    84fc:	440b      	add	r3, r1
    84fe:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8502:	4413      	add	r3, r2
    8504:	681b      	ldr	r3, [r3, #0]
    8506:	6878      	ldr	r0, [r7, #4]
    8508:	4619      	mov	r1, r3
    850a:	f04f 0209 	mov.w	r2, #9
    850e:	f00d fa69 	bl	159e4 <strncmp>
    8512:	4603      	mov	r3, r0
    8514:	60fb      	str	r3, [r7, #12]
            if ( 0 == diff )
    8516:	68fb      	ldr	r3, [r7, #12]
    8518:	2b00      	cmp	r3, #0
    851a:	d102      	bne.n	8522 <ACE_get_sse_seq_handle+0x6a>
            {
                /* channel name found. */
                handle = seq_idx;
    851c:	893b      	ldrh	r3, [r7, #8]
    851e:	817b      	strh	r3, [r7, #10]
                break;
    8520:	e006      	b.n	8530 <ACE_get_sse_seq_handle+0x78>
)
{
    uint16_t seq_idx;
    sse_sequence_handle_t handle = INVALID_SSE_SEQ_HANDLE;
    
    for ( seq_idx = 0u;  seq_idx < (uint32_t)ACE_NB_OF_SSE_PROCEDURES; ++seq_idx )
    8522:	893b      	ldrh	r3, [r7, #8]
    8524:	f103 0301 	add.w	r3, r3, #1
    8528:	813b      	strh	r3, [r7, #8]
    852a:	893b      	ldrh	r3, [r7, #8]
    852c:	2b01      	cmp	r3, #1
    852e:	d9ce      	bls.n	84ce <ACE_get_sse_seq_handle+0x16>
                handle = seq_idx;
                break;
            }
        }
    }
    return handle;
    8530:	897b      	ldrh	r3, [r7, #10]
}
    8532:	4618      	mov	r0, r3
    8534:	f107 0710 	add.w	r7, r7, #16
    8538:	46bd      	mov	sp, r7
    853a:	bd80      	pop	{r7, pc}

0000853c <ACE_load_sse>:
 */
void ACE_load_sse
(
    sse_sequence_handle_t  sequence
)
{
    853c:	b480      	push	{r7}
    853e:	b085      	sub	sp, #20
    8540:	af00      	add	r7, sp, #0
    8542:	4603      	mov	r3, r0
    8544:	80fb      	strh	r3, [r7, #6]
    ASSERT( sequence < (sse_sequence_handle_t)ACE_NB_OF_SSE_PROCEDURES );
    8546:	88fb      	ldrh	r3, [r7, #6]
    8548:	2b01      	cmp	r3, #1
    854a:	d900      	bls.n	854e <ACE_load_sse+0x12>
    854c:	be00      	bkpt	0x0000
    
    if ( sequence < (sse_sequence_handle_t)ACE_NB_OF_SSE_PROCEDURES )
    854e:	88fb      	ldrh	r3, [r7, #6]
    8550:	2b01      	cmp	r3, #1
    8552:	f200 8085 	bhi.w	8660 <ACE_load_sse+0x124>
    {
        uint16_t i;
        uint16_t offset;
        const uint16_t * p_ucode;
        
        ASSERT( g_sse_sequences_desc_table[sequence].sse_pc_id < NB_OF_ANALOG_BLOCKS );
    8556:	88f9      	ldrh	r1, [r7, #6]
    8558:	f240 02c0 	movw	r2, #192	; 0xc0
    855c:	f2c2 0200 	movt	r2, #8192	; 0x2000
    8560:	460b      	mov	r3, r1
    8562:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8566:	440b      	add	r3, r1
    8568:	ea4f 0383 	mov.w	r3, r3, lsl #2
    856c:	4413      	add	r3, r2
    856e:	f103 0310 	add.w	r3, r3, #16
    8572:	781b      	ldrb	r3, [r3, #0]
    8574:	2b02      	cmp	r3, #2
    8576:	d900      	bls.n	857a <ACE_load_sse+0x3e>
    8578:	be00      	bkpt	0x0000
        
        if ( g_sse_sequences_desc_table[sequence].sse_pc_id < NB_OF_ANALOG_BLOCKS )
    857a:	88f9      	ldrh	r1, [r7, #6]
    857c:	f240 02c0 	movw	r2, #192	; 0xc0
    8580:	f2c2 0200 	movt	r2, #8192	; 0x2000
    8584:	460b      	mov	r3, r1
    8586:	ea4f 0383 	mov.w	r3, r3, lsl #2
    858a:	440b      	add	r3, r1
    858c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8590:	4413      	add	r3, r2
    8592:	f103 0310 	add.w	r3, r3, #16
    8596:	781b      	ldrb	r3, [r3, #0]
    8598:	2b02      	cmp	r3, #2
    859a:	d861      	bhi.n	8660 <ACE_load_sse+0x124>
        {
            /* Stop relevant program counter. */
            *sse_pc_ctrl_lut[g_sse_sequences_desc_table[sequence].sse_pc_id] = SSE_STOP;
    859c:	88f9      	ldrh	r1, [r7, #6]
    859e:	f240 02c0 	movw	r2, #192	; 0xc0
    85a2:	f2c2 0200 	movt	r2, #8192	; 0x2000
    85a6:	460b      	mov	r3, r1
    85a8:	ea4f 0383 	mov.w	r3, r3, lsl #2
    85ac:	440b      	add	r3, r1
    85ae:	ea4f 0383 	mov.w	r3, r3, lsl #2
    85b2:	4413      	add	r3, r2
    85b4:	f103 0310 	add.w	r3, r3, #16
    85b8:	781b      	ldrb	r3, [r3, #0]
    85ba:	461a      	mov	r2, r3
    85bc:	f24d 0320 	movw	r3, #53280	; 0xd020
    85c0:	f2c0 0301 	movt	r3, #1
    85c4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    85c8:	f04f 0200 	mov.w	r2, #0
    85cc:	601a      	str	r2, [r3, #0]
            
            /* Load microcode into SEE RAM.*/
            p_ucode = g_sse_sequences_desc_table[sequence].sse_ucode;
    85ce:	88f9      	ldrh	r1, [r7, #6]
    85d0:	f240 02c0 	movw	r2, #192	; 0xc0
    85d4:	f2c2 0200 	movt	r2, #8192	; 0x2000
    85d8:	460b      	mov	r3, r1
    85da:	ea4f 0383 	mov.w	r3, r3, lsl #2
    85de:	440b      	add	r3, r1
    85e0:	ea4f 0383 	mov.w	r3, r3, lsl #2
    85e4:	4413      	add	r3, r2
    85e6:	f103 030c 	add.w	r3, r3, #12
    85ea:	681b      	ldr	r3, [r3, #0]
    85ec:	60fb      	str	r3, [r7, #12]
            offset = g_sse_sequences_desc_table[sequence].sse_load_offset;
    85ee:	88f9      	ldrh	r1, [r7, #6]
    85f0:	f240 02c0 	movw	r2, #192	; 0xc0
    85f4:	f2c2 0200 	movt	r2, #8192	; 0x2000
    85f8:	460b      	mov	r3, r1
    85fa:	ea4f 0383 	mov.w	r3, r3, lsl #2
    85fe:	440b      	add	r3, r1
    8600:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8604:	4413      	add	r3, r2
    8606:	88db      	ldrh	r3, [r3, #6]
    8608:	817b      	strh	r3, [r7, #10]
            
            for ( i = 0u; i < g_sse_sequences_desc_table[sequence].sse_ucode_length; ++i )
    860a:	f04f 0300 	mov.w	r3, #0
    860e:	813b      	strh	r3, [r7, #8]
    8610:	e014      	b.n	863c <ACE_load_sse+0x100>
            {
                ACE->SSE_RAM_DATA[offset + i] = (uint32_t)*p_ucode;
    8612:	f240 0300 	movw	r3, #0
    8616:	f2c4 0302 	movt	r3, #16386	; 0x4002
    861a:	8979      	ldrh	r1, [r7, #10]
    861c:	893a      	ldrh	r2, [r7, #8]
    861e:	440a      	add	r2, r1
    8620:	68f9      	ldr	r1, [r7, #12]
    8622:	8809      	ldrh	r1, [r1, #0]
    8624:	f502 7200 	add.w	r2, r2, #512	; 0x200
    8628:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
                ++p_ucode;
    862c:	68fb      	ldr	r3, [r7, #12]
    862e:	f103 0302 	add.w	r3, r3, #2
    8632:	60fb      	str	r3, [r7, #12]
            
            /* Load microcode into SEE RAM.*/
            p_ucode = g_sse_sequences_desc_table[sequence].sse_ucode;
            offset = g_sse_sequences_desc_table[sequence].sse_load_offset;
            
            for ( i = 0u; i < g_sse_sequences_desc_table[sequence].sse_ucode_length; ++i )
    8634:	893b      	ldrh	r3, [r7, #8]
    8636:	f103 0301 	add.w	r3, r3, #1
    863a:	813b      	strh	r3, [r7, #8]
    863c:	88f9      	ldrh	r1, [r7, #6]
    863e:	f240 02c0 	movw	r2, #192	; 0xc0
    8642:	f2c2 0200 	movt	r2, #8192	; 0x2000
    8646:	460b      	mov	r3, r1
    8648:	ea4f 0383 	mov.w	r3, r3, lsl #2
    864c:	440b      	add	r3, r1
    864e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8652:	4413      	add	r3, r2
    8654:	f103 0308 	add.w	r3, r3, #8
    8658:	881b      	ldrh	r3, [r3, #0]
    865a:	893a      	ldrh	r2, [r7, #8]
    865c:	429a      	cmp	r2, r3
    865e:	d3d8      	bcc.n	8612 <ACE_load_sse+0xd6>
                ACE->SSE_RAM_DATA[offset + i] = (uint32_t)*p_ucode;
                ++p_ucode;
            }
        }
    }
}
    8660:	f107 0714 	add.w	r7, r7, #20
    8664:	46bd      	mov	sp, r7
    8666:	bc80      	pop	{r7}
    8668:	4770      	bx	lr
    866a:	bf00      	nop

0000866c <ACE_start_sse>:
 */
void ACE_start_sse
(
    sse_sequence_handle_t  sequence
)
{
    866c:	b480      	push	{r7}
    866e:	b085      	sub	sp, #20
    8670:	af00      	add	r7, sp, #0
    8672:	4603      	mov	r3, r0
    8674:	80fb      	strh	r3, [r7, #6]
    ASSERT( sequence < (sse_sequence_handle_t)ACE_NB_OF_SSE_PROCEDURES );
    8676:	88fb      	ldrh	r3, [r7, #6]
    8678:	2b01      	cmp	r3, #1
    867a:	d900      	bls.n	867e <ACE_start_sse+0x12>
    867c:	be00      	bkpt	0x0000
    
    if ( sequence < (sse_sequence_handle_t)ACE_NB_OF_SSE_PROCEDURES )
    867e:	88fb      	ldrh	r3, [r7, #6]
    8680:	2b01      	cmp	r3, #1
    8682:	f200 808d 	bhi.w	87a0 <ACE_start_sse+0x134>
    {
        uint16_t pc;
        
        ASSERT( g_sse_sequences_desc_table[sequence].sse_pc_id < NB_OF_ANALOG_BLOCKS );
    8686:	88f9      	ldrh	r1, [r7, #6]
    8688:	f240 02c0 	movw	r2, #192	; 0xc0
    868c:	f2c2 0200 	movt	r2, #8192	; 0x2000
    8690:	460b      	mov	r3, r1
    8692:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8696:	440b      	add	r3, r1
    8698:	ea4f 0383 	mov.w	r3, r3, lsl #2
    869c:	4413      	add	r3, r2
    869e:	f103 0310 	add.w	r3, r3, #16
    86a2:	781b      	ldrb	r3, [r3, #0]
    86a4:	2b02      	cmp	r3, #2
    86a6:	d900      	bls.n	86aa <ACE_start_sse+0x3e>
    86a8:	be00      	bkpt	0x0000
        ASSERT( g_sse_sequences_desc_table[sequence].sse_load_offset < SEE_RAM_WORD_SIZE );
    86aa:	88f9      	ldrh	r1, [r7, #6]
    86ac:	f240 02c0 	movw	r2, #192	; 0xc0
    86b0:	f2c2 0200 	movt	r2, #8192	; 0x2000
    86b4:	460b      	mov	r3, r1
    86b6:	ea4f 0383 	mov.w	r3, r3, lsl #2
    86ba:	440b      	add	r3, r1
    86bc:	ea4f 0383 	mov.w	r3, r3, lsl #2
    86c0:	4413      	add	r3, r2
    86c2:	88da      	ldrh	r2, [r3, #6]
    86c4:	f240 13ff 	movw	r3, #511	; 0x1ff
    86c8:	429a      	cmp	r2, r3
    86ca:	d900      	bls.n	86ce <ACE_start_sse+0x62>
    86cc:	be00      	bkpt	0x0000
    
        pc = g_sse_sequences_desc_table[sequence].sse_load_offset;
    86ce:	88f9      	ldrh	r1, [r7, #6]
    86d0:	f240 02c0 	movw	r2, #192	; 0xc0
    86d4:	f2c2 0200 	movt	r2, #8192	; 0x2000
    86d8:	460b      	mov	r3, r1
    86da:	ea4f 0383 	mov.w	r3, r3, lsl #2
    86de:	440b      	add	r3, r1
    86e0:	ea4f 0383 	mov.w	r3, r3, lsl #2
    86e4:	4413      	add	r3, r2
    86e6:	88db      	ldrh	r3, [r3, #6]
    86e8:	81fb      	strh	r3, [r7, #14]
        
        if ( pc < 256u )
    86ea:	89fb      	ldrh	r3, [r7, #14]
    86ec:	2bff      	cmp	r3, #255	; 0xff
    86ee:	d818      	bhi.n	8722 <ACE_start_sse+0xb6>
        {
            *sse_pc_lo_lut[g_sse_sequences_desc_table[sequence].sse_pc_id] = pc;
    86f0:	88f9      	ldrh	r1, [r7, #6]
    86f2:	f240 02c0 	movw	r2, #192	; 0xc0
    86f6:	f2c2 0200 	movt	r2, #8192	; 0x2000
    86fa:	460b      	mov	r3, r1
    86fc:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8700:	440b      	add	r3, r1
    8702:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8706:	4413      	add	r3, r2
    8708:	f103 0310 	add.w	r3, r3, #16
    870c:	781b      	ldrb	r3, [r3, #0]
    870e:	461a      	mov	r2, r3
    8710:	f24d 032c 	movw	r3, #53292	; 0xd02c
    8714:	f2c0 0301 	movt	r3, #1
    8718:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    871c:	89fa      	ldrh	r2, [r7, #14]
    871e:	601a      	str	r2, [r3, #0]
    8720:	e019      	b.n	8756 <ACE_start_sse+0xea>
        }
        else
        {
            *sse_pc_hi_lut[g_sse_sequences_desc_table[sequence].sse_pc_id] = pc - 256;
    8722:	88f9      	ldrh	r1, [r7, #6]
    8724:	f240 02c0 	movw	r2, #192	; 0xc0
    8728:	f2c2 0200 	movt	r2, #8192	; 0x2000
    872c:	460b      	mov	r3, r1
    872e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8732:	440b      	add	r3, r1
    8734:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8738:	4413      	add	r3, r2
    873a:	f103 0310 	add.w	r3, r3, #16
    873e:	781b      	ldrb	r3, [r3, #0]
    8740:	461a      	mov	r2, r3
    8742:	f24d 0338 	movw	r3, #53304	; 0xd038
    8746:	f2c0 0301 	movt	r3, #1
    874a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    874e:	89fa      	ldrh	r2, [r7, #14]
    8750:	f5a2 7280 	sub.w	r2, r2, #256	; 0x100
    8754:	601a      	str	r2, [r3, #0]
        }
        
        *sse_pc_ctrl_lut[g_sse_sequences_desc_table[sequence].sse_pc_id] = SSE_START;
    8756:	88f9      	ldrh	r1, [r7, #6]
    8758:	f240 02c0 	movw	r2, #192	; 0xc0
    875c:	f2c2 0200 	movt	r2, #8192	; 0x2000
    8760:	460b      	mov	r3, r1
    8762:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8766:	440b      	add	r3, r1
    8768:	ea4f 0383 	mov.w	r3, r3, lsl #2
    876c:	4413      	add	r3, r2
    876e:	f103 0310 	add.w	r3, r3, #16
    8772:	781b      	ldrb	r3, [r3, #0]
    8774:	461a      	mov	r2, r3
    8776:	f24d 0320 	movw	r3, #53280	; 0xd020
    877a:	f2c0 0301 	movt	r3, #1
    877e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    8782:	f04f 0201 	mov.w	r2, #1
    8786:	601a      	str	r2, [r3, #0]
        
        /* Enable Sample Sequencing Engine in case it was not done as part of
         * system boot. */
        ACE->SSE_TS_CTRL |= TS_ENABLE_MASK;
    8788:	f240 0300 	movw	r3, #0
    878c:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8790:	f240 0200 	movw	r2, #0
    8794:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8798:	6852      	ldr	r2, [r2, #4]
    879a:	f042 0201 	orr.w	r2, r2, #1
    879e:	605a      	str	r2, [r3, #4]
    }
}
    87a0:	f107 0714 	add.w	r7, r7, #20
    87a4:	46bd      	mov	sp, r7
    87a6:	bc80      	pop	{r7}
    87a8:	4770      	bx	lr
    87aa:	bf00      	nop

000087ac <ACE_restart_sse>:
 */
void ACE_restart_sse
(
    sse_sequence_handle_t  sequence
)
{
    87ac:	b480      	push	{r7}
    87ae:	b085      	sub	sp, #20
    87b0:	af00      	add	r7, sp, #0
    87b2:	4603      	mov	r3, r0
    87b4:	80fb      	strh	r3, [r7, #6]
    ASSERT( sequence < ACE_NB_OF_SSE_PROCEDURES );
    87b6:	88fb      	ldrh	r3, [r7, #6]
    87b8:	2b01      	cmp	r3, #1
    87ba:	d900      	bls.n	87be <ACE_restart_sse+0x12>
    87bc:	be00      	bkpt	0x0000
    ASSERT( g_sse_sequences_desc_table[sequence].sse_pc_id < NB_OF_ANALOG_BLOCKS );
    87be:	88f9      	ldrh	r1, [r7, #6]
    87c0:	f240 02c0 	movw	r2, #192	; 0xc0
    87c4:	f2c2 0200 	movt	r2, #8192	; 0x2000
    87c8:	460b      	mov	r3, r1
    87ca:	ea4f 0383 	mov.w	r3, r3, lsl #2
    87ce:	440b      	add	r3, r1
    87d0:	ea4f 0383 	mov.w	r3, r3, lsl #2
    87d4:	4413      	add	r3, r2
    87d6:	f103 0310 	add.w	r3, r3, #16
    87da:	781b      	ldrb	r3, [r3, #0]
    87dc:	2b02      	cmp	r3, #2
    87de:	d900      	bls.n	87e2 <ACE_restart_sse+0x36>
    87e0:	be00      	bkpt	0x0000
    ASSERT( g_sse_sequences_desc_table[sequence].sse_load_offset < SEE_RAM_WORD_SIZE );
    87e2:	88f9      	ldrh	r1, [r7, #6]
    87e4:	f240 02c0 	movw	r2, #192	; 0xc0
    87e8:	f2c2 0200 	movt	r2, #8192	; 0x2000
    87ec:	460b      	mov	r3, r1
    87ee:	ea4f 0383 	mov.w	r3, r3, lsl #2
    87f2:	440b      	add	r3, r1
    87f4:	ea4f 0383 	mov.w	r3, r3, lsl #2
    87f8:	4413      	add	r3, r2
    87fa:	88da      	ldrh	r2, [r3, #6]
    87fc:	f240 13ff 	movw	r3, #511	; 0x1ff
    8800:	429a      	cmp	r2, r3
    8802:	d900      	bls.n	8806 <ACE_restart_sse+0x5a>
    8804:	be00      	bkpt	0x0000
    
    if ( sequence < (sse_sequence_handle_t)ACE_NB_OF_SSE_PROCEDURES )
    8806:	88fb      	ldrh	r3, [r7, #6]
    8808:	2b01      	cmp	r3, #1
    880a:	d85c      	bhi.n	88c6 <ACE_restart_sse+0x11a>
    {
        uint16_t pc;
        
        pc = g_sse_sequences_desc_table[sequence].sse_loop_pc;
    880c:	88f9      	ldrh	r1, [r7, #6]
    880e:	f240 02c0 	movw	r2, #192	; 0xc0
    8812:	f2c2 0200 	movt	r2, #8192	; 0x2000
    8816:	460b      	mov	r3, r1
    8818:	ea4f 0383 	mov.w	r3, r3, lsl #2
    881c:	440b      	add	r3, r1
    881e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8822:	4413      	add	r3, r2
    8824:	889b      	ldrh	r3, [r3, #4]
    8826:	81fb      	strh	r3, [r7, #14]
        
        if ( pc < 256u )
    8828:	89fb      	ldrh	r3, [r7, #14]
    882a:	2bff      	cmp	r3, #255	; 0xff
    882c:	d818      	bhi.n	8860 <ACE_restart_sse+0xb4>
        {
            *sse_pc_lo_lut[g_sse_sequences_desc_table[sequence].sse_pc_id] = pc;
    882e:	88f9      	ldrh	r1, [r7, #6]
    8830:	f240 02c0 	movw	r2, #192	; 0xc0
    8834:	f2c2 0200 	movt	r2, #8192	; 0x2000
    8838:	460b      	mov	r3, r1
    883a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    883e:	440b      	add	r3, r1
    8840:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8844:	4413      	add	r3, r2
    8846:	f103 0310 	add.w	r3, r3, #16
    884a:	781b      	ldrb	r3, [r3, #0]
    884c:	461a      	mov	r2, r3
    884e:	f24d 032c 	movw	r3, #53292	; 0xd02c
    8852:	f2c0 0301 	movt	r3, #1
    8856:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    885a:	89fa      	ldrh	r2, [r7, #14]
    885c:	601a      	str	r2, [r3, #0]
    885e:	e019      	b.n	8894 <ACE_restart_sse+0xe8>
        }
        else
        {
            *sse_pc_hi_lut[g_sse_sequences_desc_table[sequence].sse_pc_id] = pc - 256;
    8860:	88f9      	ldrh	r1, [r7, #6]
    8862:	f240 02c0 	movw	r2, #192	; 0xc0
    8866:	f2c2 0200 	movt	r2, #8192	; 0x2000
    886a:	460b      	mov	r3, r1
    886c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8870:	440b      	add	r3, r1
    8872:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8876:	4413      	add	r3, r2
    8878:	f103 0310 	add.w	r3, r3, #16
    887c:	781b      	ldrb	r3, [r3, #0]
    887e:	461a      	mov	r2, r3
    8880:	f24d 0338 	movw	r3, #53304	; 0xd038
    8884:	f2c0 0301 	movt	r3, #1
    8888:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    888c:	89fa      	ldrh	r2, [r7, #14]
    888e:	f5a2 7280 	sub.w	r2, r2, #256	; 0x100
    8892:	601a      	str	r2, [r3, #0]
        }
        
        *sse_pc_ctrl_lut[g_sse_sequences_desc_table[sequence].sse_pc_id] = SSE_START;
    8894:	88f9      	ldrh	r1, [r7, #6]
    8896:	f240 02c0 	movw	r2, #192	; 0xc0
    889a:	f2c2 0200 	movt	r2, #8192	; 0x2000
    889e:	460b      	mov	r3, r1
    88a0:	ea4f 0383 	mov.w	r3, r3, lsl #2
    88a4:	440b      	add	r3, r1
    88a6:	ea4f 0383 	mov.w	r3, r3, lsl #2
    88aa:	4413      	add	r3, r2
    88ac:	f103 0310 	add.w	r3, r3, #16
    88b0:	781b      	ldrb	r3, [r3, #0]
    88b2:	461a      	mov	r2, r3
    88b4:	f24d 0320 	movw	r3, #53280	; 0xd020
    88b8:	f2c0 0301 	movt	r3, #1
    88bc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    88c0:	f04f 0201 	mov.w	r2, #1
    88c4:	601a      	str	r2, [r3, #0]
    }
}
    88c6:	f107 0714 	add.w	r7, r7, #20
    88ca:	46bd      	mov	sp, r7
    88cc:	bc80      	pop	{r7}
    88ce:	4770      	bx	lr

000088d0 <ACE_stop_sse>:
 */
void ACE_stop_sse
(
    sse_sequence_handle_t  sequence
)
{
    88d0:	b480      	push	{r7}
    88d2:	b083      	sub	sp, #12
    88d4:	af00      	add	r7, sp, #0
    88d6:	4603      	mov	r3, r0
    88d8:	80fb      	strh	r3, [r7, #6]
    ASSERT( sequence < ACE_NB_OF_SSE_PROCEDURES );
    88da:	88fb      	ldrh	r3, [r7, #6]
    88dc:	2b01      	cmp	r3, #1
    88de:	d900      	bls.n	88e2 <ACE_stop_sse+0x12>
    88e0:	be00      	bkpt	0x0000
    
    if ( sequence < (sse_sequence_handle_t)ACE_NB_OF_SSE_PROCEDURES )
    88e2:	88fb      	ldrh	r3, [r7, #6]
    88e4:	2b01      	cmp	r3, #1
    88e6:	d818      	bhi.n	891a <ACE_stop_sse+0x4a>
    {
        /* Stop relevant program counter. */
        *sse_pc_ctrl_lut[g_sse_sequences_desc_table[sequence].sse_pc_id] = SSE_STOP;
    88e8:	88f9      	ldrh	r1, [r7, #6]
    88ea:	f240 02c0 	movw	r2, #192	; 0xc0
    88ee:	f2c2 0200 	movt	r2, #8192	; 0x2000
    88f2:	460b      	mov	r3, r1
    88f4:	ea4f 0383 	mov.w	r3, r3, lsl #2
    88f8:	440b      	add	r3, r1
    88fa:	ea4f 0383 	mov.w	r3, r3, lsl #2
    88fe:	4413      	add	r3, r2
    8900:	f103 0310 	add.w	r3, r3, #16
    8904:	781b      	ldrb	r3, [r3, #0]
    8906:	461a      	mov	r2, r3
    8908:	f24d 0320 	movw	r3, #53280	; 0xd020
    890c:	f2c0 0301 	movt	r3, #1
    8910:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    8914:	f04f 0200 	mov.w	r2, #0
    8918:	601a      	str	r2, [r3, #0]
    }
}
    891a:	f107 070c 	add.w	r7, r7, #12
    891e:	46bd      	mov	sp, r7
    8920:	bc80      	pop	{r7}
    8922:	4770      	bx	lr

00008924 <ACE_resume_sse>:
 */
void ACE_resume_sse
(
    sse_sequence_handle_t  sequence
)
{
    8924:	b480      	push	{r7}
    8926:	b083      	sub	sp, #12
    8928:	af00      	add	r7, sp, #0
    892a:	4603      	mov	r3, r0
    892c:	80fb      	strh	r3, [r7, #6]
    ASSERT( sequence < ACE_NB_OF_SSE_PROCEDURES );
    892e:	88fb      	ldrh	r3, [r7, #6]
    8930:	2b01      	cmp	r3, #1
    8932:	d900      	bls.n	8936 <ACE_resume_sse+0x12>
    8934:	be00      	bkpt	0x0000
    
    if ( sequence < (sse_sequence_handle_t)ACE_NB_OF_SSE_PROCEDURES )
    8936:	88fb      	ldrh	r3, [r7, #6]
    8938:	2b01      	cmp	r3, #1
    893a:	d818      	bhi.n	896e <ACE_resume_sse+0x4a>
    {
        *sse_pc_ctrl_lut[g_sse_sequences_desc_table[sequence].sse_pc_id] = SSE_START;
    893c:	88f9      	ldrh	r1, [r7, #6]
    893e:	f240 02c0 	movw	r2, #192	; 0xc0
    8942:	f2c2 0200 	movt	r2, #8192	; 0x2000
    8946:	460b      	mov	r3, r1
    8948:	ea4f 0383 	mov.w	r3, r3, lsl #2
    894c:	440b      	add	r3, r1
    894e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8952:	4413      	add	r3, r2
    8954:	f103 0310 	add.w	r3, r3, #16
    8958:	781b      	ldrb	r3, [r3, #0]
    895a:	461a      	mov	r2, r3
    895c:	f24d 0320 	movw	r3, #53280	; 0xd020
    8960:	f2c0 0301 	movt	r3, #1
    8964:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    8968:	f04f 0201 	mov.w	r2, #1
    896c:	601a      	str	r2, [r3, #0]
    }
}
    896e:	f107 070c 	add.w	r7, r7, #12
    8972:	46bd      	mov	sp, r7
    8974:	bc80      	pop	{r7}
    8976:	4770      	bx	lr

00008978 <ACE_enable_sse_irq>:
 */
void ACE_enable_sse_irq
(
	sse_irq_id_t sse_irq_id
)
{
    8978:	b480      	push	{r7}
    897a:	b083      	sub	sp, #12
    897c:	af00      	add	r7, sp, #0
    897e:	4603      	mov	r3, r0
    8980:	71fb      	strb	r3, [r7, #7]
    ASSERT( sse_irq_id < NB_OF_SSE_FLAG_IRQS );
    8982:	79fb      	ldrb	r3, [r7, #7]
    8984:	2b14      	cmp	r3, #20
    8986:	d900      	bls.n	898a <ACE_enable_sse_irq+0x12>
    8988:	be00      	bkpt	0x0000
    
    ACE->SSE_IRQ_EN |= 1uL << (uint32_t)sse_irq_id;
    898a:	f240 0300 	movw	r3, #0
    898e:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8992:	f240 0200 	movw	r2, #0
    8996:	f2c4 0202 	movt	r2, #16386	; 0x4002
    899a:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    899e:	6811      	ldr	r1, [r2, #0]
    89a0:	79fa      	ldrb	r2, [r7, #7]
    89a2:	f04f 0001 	mov.w	r0, #1
    89a6:	fa00 f202 	lsl.w	r2, r0, r2
    89aa:	ea41 0202 	orr.w	r2, r1, r2
    89ae:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    89b2:	601a      	str	r2, [r3, #0]
}
    89b4:	f107 070c 	add.w	r7, r7, #12
    89b8:	46bd      	mov	sp, r7
    89ba:	bc80      	pop	{r7}
    89bc:	4770      	bx	lr
    89be:	bf00      	nop

000089c0 <ACE_disable_sse_irq>:
 */
void ACE_disable_sse_irq
(
	sse_irq_id_t sse_irq_id
)
{
    89c0:	b480      	push	{r7}
    89c2:	b085      	sub	sp, #20
    89c4:	af00      	add	r7, sp, #0
    89c6:	4603      	mov	r3, r0
    89c8:	71fb      	strb	r3, [r7, #7]
    volatile uint32_t dummy_read;
    
    ASSERT( sse_irq_id < NB_OF_SSE_FLAG_IRQS );
    89ca:	79fb      	ldrb	r3, [r7, #7]
    89cc:	2b14      	cmp	r3, #20
    89ce:	d900      	bls.n	89d2 <ACE_disable_sse_irq+0x12>
    89d0:	be00      	bkpt	0x0000
    
    ACE->SSE_IRQ_EN &= (uint32_t)~(1uL << (uint32_t)sse_irq_id);
    89d2:	f240 0300 	movw	r3, #0
    89d6:	f2c4 0302 	movt	r3, #16386	; 0x4002
    89da:	f240 0200 	movw	r2, #0
    89de:	f2c4 0202 	movt	r2, #16386	; 0x4002
    89e2:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    89e6:	6811      	ldr	r1, [r2, #0]
    89e8:	79fa      	ldrb	r2, [r7, #7]
    89ea:	f04f 0001 	mov.w	r0, #1
    89ee:	fa00 f202 	lsl.w	r2, r0, r2
    89f2:	ea6f 0202 	mvn.w	r2, r2
    89f6:	ea01 0202 	and.w	r2, r1, r2
    89fa:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    89fe:	601a      	str	r2, [r3, #0]
    /*
     * Ensure that the posted write to the SSE_IRQ_EN register completed before
     * returning from this function. Not doing this may result in the interrupt
     * only being disabled some time after this function returns.
     */
    dummy_read = ACE->SSE_IRQ_EN;
    8a00:	f240 0300 	movw	r3, #0
    8a04:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8a08:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    8a0c:	681b      	ldr	r3, [r3, #0]
    8a0e:	60fb      	str	r3, [r7, #12]
    ++dummy_read;
    8a10:	68fb      	ldr	r3, [r7, #12]
    8a12:	f103 0301 	add.w	r3, r3, #1
    8a16:	60fb      	str	r3, [r7, #12]
}
    8a18:	f107 0714 	add.w	r7, r7, #20
    8a1c:	46bd      	mov	sp, r7
    8a1e:	bc80      	pop	{r7}
    8a20:	4770      	bx	lr
    8a22:	bf00      	nop

00008a24 <ACE_clear_sse_irq>:
 */
void ACE_clear_sse_irq
(
	sse_irq_id_t sse_irq_id
)
{
    8a24:	b480      	push	{r7}
    8a26:	b085      	sub	sp, #20
    8a28:	af00      	add	r7, sp, #0
    8a2a:	4603      	mov	r3, r0
    8a2c:	71fb      	strb	r3, [r7, #7]
    volatile uint32_t dummy_read;
    
    ASSERT( sse_irq_id < NB_OF_SSE_FLAG_IRQS );
    8a2e:	79fb      	ldrb	r3, [r7, #7]
    8a30:	2b14      	cmp	r3, #20
    8a32:	d900      	bls.n	8a36 <ACE_clear_sse_irq+0x12>
    8a34:	be00      	bkpt	0x0000
    
    ACE->SSE_IRQ_CLR |= 1uL << (uint32_t)sse_irq_id;
    8a36:	f240 0300 	movw	r3, #0
    8a3a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8a3e:	f240 0200 	movw	r2, #0
    8a42:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8a46:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    8a4a:	f102 0208 	add.w	r2, r2, #8
    8a4e:	6811      	ldr	r1, [r2, #0]
    8a50:	79fa      	ldrb	r2, [r7, #7]
    8a52:	f04f 0001 	mov.w	r0, #1
    8a56:	fa00 f202 	lsl.w	r2, r0, r2
    8a5a:	ea41 0202 	orr.w	r2, r1, r2
    8a5e:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    8a62:	f103 0308 	add.w	r3, r3, #8
    8a66:	601a      	str	r2, [r3, #0]
     * Ensure that the posted write to the SSE_IRQ_CLR register completed before
     * returning from this function. Not doing this may result in the interrupt
     * retriggering if the Cortex-M3 returns from interrupt before the posted
     * write completes.
     */
    dummy_read = ACE->SSE_IRQ_CLR;
    8a68:	f240 0300 	movw	r3, #0
    8a6c:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8a70:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    8a74:	f103 0308 	add.w	r3, r3, #8
    8a78:	681b      	ldr	r3, [r3, #0]
    8a7a:	60fb      	str	r3, [r7, #12]
    ++dummy_read;
    8a7c:	68fb      	ldr	r3, [r7, #12]
    8a7e:	f103 0301 	add.w	r3, r3, #1
    8a82:	60fb      	str	r3, [r7, #12]
}
    8a84:	f107 0714 	add.w	r7, r7, #20
    8a88:	46bd      	mov	sp, r7
    8a8a:	bc80      	pop	{r7}
    8a8c:	4770      	bx	lr
    8a8e:	bf00      	nop

00008a90 <ACE_clear_sample_pipeline>:

/*-------------------------------------------------------------------------*//**
 *
 */
void ACE_clear_sample_pipeline(void)
{
    8a90:	b480      	push	{r7}
    8a92:	b083      	sub	sp, #12
    8a94:	af00      	add	r7, sp, #0
    uint32_t saved_sse_ctrl;
    uint32_t saved_ppe_ctrl;
    
    /* Pause the Sample Sequencing Engine. */
    saved_sse_ctrl = ACE->SSE_TS_CTRL;
    8a96:	f240 0300 	movw	r3, #0
    8a9a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8a9e:	685b      	ldr	r3, [r3, #4]
    8aa0:	603b      	str	r3, [r7, #0]
    ACE->SSE_TS_CTRL = ACE->SSE_TS_CTRL & ~((uint32_t)TS_ENABLE_MASK);
    8aa2:	f240 0300 	movw	r3, #0
    8aa6:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8aaa:	f240 0200 	movw	r2, #0
    8aae:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8ab2:	6852      	ldr	r2, [r2, #4]
    8ab4:	f022 0201 	bic.w	r2, r2, #1
    8ab8:	605a      	str	r2, [r3, #4]
    
    /* Pause the Post Processing Engine. */
    saved_ppe_ctrl = ACE->PPE_CTRL;
    8aba:	f240 0300 	movw	r3, #0
    8abe:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8ac2:	f503 53a0 	add.w	r3, r3, #5120	; 0x1400
    8ac6:	f103 0304 	add.w	r3, r3, #4
    8aca:	681b      	ldr	r3, [r3, #0]
    8acc:	607b      	str	r3, [r7, #4]
    ACE->PPE_CTRL = ACE->PPE_CTRL & ~((uint32_t)PPE_ENABLE_MASK);
    8ace:	f240 0300 	movw	r3, #0
    8ad2:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8ad6:	f240 0200 	movw	r2, #0
    8ada:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8ade:	f502 52a0 	add.w	r2, r2, #5120	; 0x1400
    8ae2:	f102 0204 	add.w	r2, r2, #4
    8ae6:	6812      	ldr	r2, [r2, #0]
    8ae8:	f022 0201 	bic.w	r2, r2, #1
    8aec:	f503 53a0 	add.w	r3, r3, #5120	; 0x1400
    8af0:	f103 0304 	add.w	r3, r3, #4
    8af4:	601a      	str	r2, [r3, #0]
    
    /* Reset the ADCs */
    ACE->ADC0_MISC_CTRL |= ADC_RESET_MASK;
    8af6:	f240 0300 	movw	r3, #0
    8afa:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8afe:	f240 0200 	movw	r2, #0
    8b02:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8b06:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
    8b08:	f042 0210 	orr.w	r2, r2, #16
    8b0c:	65da      	str	r2, [r3, #92]	; 0x5c
    ACE->ADC1_MISC_CTRL |= ADC_RESET_MASK;
    8b0e:	f240 0300 	movw	r3, #0
    8b12:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8b16:	f240 0200 	movw	r2, #0
    8b1a:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8b1e:	f8d2 209c 	ldr.w	r2, [r2, #156]	; 0x9c
    8b22:	f042 0210 	orr.w	r2, r2, #16
    8b26:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
    ACE->ADC2_MISC_CTRL |= ADC_RESET_MASK;
    8b2a:	f240 0300 	movw	r3, #0
    8b2e:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8b32:	f240 0200 	movw	r2, #0
    8b36:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8b3a:	f8d2 20dc 	ldr.w	r2, [r2, #220]	; 0xdc
    8b3e:	f042 0210 	orr.w	r2, r2, #16
    8b42:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
    
    /* Clear ADC FIFOs */
    ACE->ADC0_FIFO_CTRL |= ADC_FIFO_CLR_MASK;
    8b46:	f240 0300 	movw	r3, #0
    8b4a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8b4e:	f240 0200 	movw	r2, #0
    8b52:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8b56:	f502 52a4 	add.w	r2, r2, #5248	; 0x1480
    8b5a:	f102 0210 	add.w	r2, r2, #16
    8b5e:	6812      	ldr	r2, [r2, #0]
    8b60:	f042 0204 	orr.w	r2, r2, #4
    8b64:	f503 53a4 	add.w	r3, r3, #5248	; 0x1480
    8b68:	f103 0310 	add.w	r3, r3, #16
    8b6c:	601a      	str	r2, [r3, #0]
    ACE->ADC1_FIFO_CTRL |= ADC_FIFO_CLR_MASK;
    8b6e:	f240 0300 	movw	r3, #0
    8b72:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8b76:	f240 0200 	movw	r2, #0
    8b7a:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8b7e:	f502 52a4 	add.w	r2, r2, #5248	; 0x1480
    8b82:	f102 021c 	add.w	r2, r2, #28
    8b86:	6812      	ldr	r2, [r2, #0]
    8b88:	f042 0204 	orr.w	r2, r2, #4
    8b8c:	f503 53a4 	add.w	r3, r3, #5248	; 0x1480
    8b90:	f103 031c 	add.w	r3, r3, #28
    8b94:	601a      	str	r2, [r3, #0]
    ACE->ADC2_FIFO_CTRL |= ADC_FIFO_CLR_MASK;
    8b96:	f240 0300 	movw	r3, #0
    8b9a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8b9e:	f240 0200 	movw	r2, #0
    8ba2:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8ba6:	f502 52a4 	add.w	r2, r2, #5248	; 0x1480
    8baa:	f102 0228 	add.w	r2, r2, #40	; 0x28
    8bae:	6812      	ldr	r2, [r2, #0]
    8bb0:	f042 0204 	orr.w	r2, r2, #4
    8bb4:	f503 53a4 	add.w	r3, r3, #5248	; 0x1480
    8bb8:	f103 0328 	add.w	r3, r3, #40	; 0x28
    8bbc:	601a      	str	r2, [r3, #0]
    
    /* clear DMA FIFOs */
    ACE->PPE_PDMA_CTRL |= PDMA_DATAOUT_CLR_MASK;
    8bbe:	f240 0300 	movw	r3, #0
    8bc2:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8bc6:	f240 0200 	movw	r2, #0
    8bca:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8bce:	f502 5298 	add.w	r2, r2, #4864	; 0x1300
    8bd2:	6812      	ldr	r2, [r2, #0]
    8bd4:	f042 0204 	orr.w	r2, r2, #4
    8bd8:	f503 5398 	add.w	r3, r3, #4864	; 0x1300
    8bdc:	601a      	str	r2, [r3, #0]
    
    /* Unpause the Post Processing Engine. */
    ACE->PPE_CTRL = saved_ppe_ctrl;
    8bde:	f240 0300 	movw	r3, #0
    8be2:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8be6:	f503 53a0 	add.w	r3, r3, #5120	; 0x1400
    8bea:	f103 0304 	add.w	r3, r3, #4
    8bee:	687a      	ldr	r2, [r7, #4]
    8bf0:	601a      	str	r2, [r3, #0]
    
    /* Unpause the Sample Sequencing Engine. */
    ACE->SSE_TS_CTRL = saved_sse_ctrl;
    8bf2:	f240 0300 	movw	r3, #0
    8bf6:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8bfa:	683a      	ldr	r2, [r7, #0]
    8bfc:	605a      	str	r2, [r3, #4]
}
    8bfe:	f107 070c 	add.w	r7, r7, #12
    8c02:	46bd      	mov	sp, r7
    8c04:	bc80      	pop	{r7}
    8c06:	4770      	bx	lr

00008c08 <ACE_get_default_m_factor>:
 */
int16_t ACE_get_default_m_factor
(
    ace_channel_handle_t channel_handle
)
{
    8c08:	b480      	push	{r7}
    8c0a:	b083      	sub	sp, #12
    8c0c:	af00      	add	r7, sp, #0
    8c0e:	4603      	mov	r3, r0
    8c10:	71fb      	strb	r3, [r7, #7]
    ASSERT( channel_handle < NB_OF_ACE_CHANNEL_HANDLES );
    8c12:	79fb      	ldrb	r3, [r7, #7]
    8c14:	2b06      	cmp	r3, #6
    8c16:	d900      	bls.n	8c1a <ACE_get_default_m_factor+0x12>
    8c18:	be00      	bkpt	0x0000
    
    return g_ace_ppe_transforms_desc_table[channel_handle].m_ppe_offset;
    8c1a:	79fa      	ldrb	r2, [r7, #7]
    8c1c:	f64c 03a4 	movw	r3, #51364	; 0xc8a4
    8c20:	f2c0 0301 	movt	r3, #1
    8c24:	f833 3032 	ldrh.w	r3, [r3, r2, lsl #3]
    8c28:	b21b      	sxth	r3, r3
}
    8c2a:	4618      	mov	r0, r3
    8c2c:	f107 070c 	add.w	r7, r7, #12
    8c30:	46bd      	mov	sp, r7
    8c32:	bc80      	pop	{r7}
    8c34:	4770      	bx	lr
    8c36:	bf00      	nop

00008c38 <ACE_get_default_c_offset>:
 */
int16_t ACE_get_default_c_offset
(
    ace_channel_handle_t channel_handle
)
{
    8c38:	b480      	push	{r7}
    8c3a:	b083      	sub	sp, #12
    8c3c:	af00      	add	r7, sp, #0
    8c3e:	4603      	mov	r3, r0
    8c40:	71fb      	strb	r3, [r7, #7]
    ASSERT( channel_handle < NB_OF_ACE_CHANNEL_HANDLES );
    8c42:	79fb      	ldrb	r3, [r7, #7]
    8c44:	2b06      	cmp	r3, #6
    8c46:	d900      	bls.n	8c4a <ACE_get_default_c_offset+0x12>
    8c48:	be00      	bkpt	0x0000
    
    return g_ace_ppe_transforms_desc_table[channel_handle].c_ppe_offset;
    8c4a:	79fb      	ldrb	r3, [r7, #7]
    8c4c:	f64c 02a4 	movw	r2, #51364	; 0xc8a4
    8c50:	f2c0 0201 	movt	r2, #1
    8c54:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    8c58:	4413      	add	r3, r2
    8c5a:	885b      	ldrh	r3, [r3, #2]
    8c5c:	b21b      	sxth	r3, r3
}
    8c5e:	4618      	mov	r0, r3
    8c60:	f107 070c 	add.w	r7, r7, #12
    8c64:	46bd      	mov	sp, r7
    8c66:	bc80      	pop	{r7}
    8c68:	4770      	bx	lr
    8c6a:	bf00      	nop

00008c6c <ACE_set_linear_transform>:
(
    ace_channel_handle_t channel_handle,
	int16_t m2,
	int16_t c2
)
{
    8c6c:	b5b0      	push	{r4, r5, r7, lr}
    8c6e:	b092      	sub	sp, #72	; 0x48
    8c70:	af00      	add	r7, sp, #0
    8c72:	4613      	mov	r3, r2
    8c74:	4602      	mov	r2, r0
    8c76:	71fa      	strb	r2, [r7, #7]
    8c78:	460a      	mov	r2, r1
    8c7a:	80ba      	strh	r2, [r7, #4]
    8c7c:	807b      	strh	r3, [r7, #2]
    int64_t c64_2;
    uint16_t m1;
    uint16_t c1;
    uint16_t mext;
    
    channel_calibration_t calibration = {0x4000u, 0x4000u, 0x0000u};
    8c7e:	f24d 0298 	movw	r2, #53400	; 0xd098
    8c82:	f2c0 0201 	movt	r2, #1
    8c86:	f107 030c 	add.w	r3, r7, #12
    8c8a:	e892 0003 	ldmia.w	r2, {r0, r1}
    8c8e:	6018      	str	r0, [r3, #0]
    8c90:	f103 0304 	add.w	r3, r3, #4
    8c94:	8019      	strh	r1, [r3, #0]
    
    ASSERT( channel_handle < NB_OF_ACE_CHANNEL_HANDLES );
    8c96:	79fb      	ldrb	r3, [r7, #7]
    8c98:	2b06      	cmp	r3, #6
    8c9a:	d900      	bls.n	8c9e <ACE_set_linear_transform+0x32>
    8c9c:	be00      	bkpt	0x0000
    
    if(channel_handle < NB_OF_ACE_CHANNEL_HANDLES)
    8c9e:	79fb      	ldrb	r3, [r7, #7]
    8ca0:	2b06      	cmp	r3, #6
    8ca2:	f200 809d 	bhi.w	8de0 <ACE_set_linear_transform+0x174>
    {
        channel_id = g_ace_channel_desc_table[channel_handle].signal_id;
    8ca6:	79fa      	ldrb	r2, [r7, #7]
    8ca8:	f240 0350 	movw	r3, #80	; 0x50
    8cac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8cb0:	ea4f 1202 	mov.w	r2, r2, lsl #4
    8cb4:	4413      	add	r3, r2
    8cb6:	791b      	ldrb	r3, [r3, #4]
    8cb8:	74fb      	strb	r3, [r7, #19]
        
        get_calibration(channel_id, &calibration);
    8cba:	7cfa      	ldrb	r2, [r7, #19]
    8cbc:	f107 030c 	add.w	r3, r7, #12
    8cc0:	4610      	mov	r0, r2
    8cc2:	4619      	mov	r1, r3
    8cc4:	f000 f928 	bl	8f18 <get_calibration>
        
        m1 = calibration.m1;
    8cc8:	89fb      	ldrh	r3, [r7, #14]
    8cca:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
        c1 = calibration.c1;
    8cce:	8a3b      	ldrh	r3, [r7, #16]
    8cd0:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
        
        mext = calibration.mext;
    8cd4:	89bb      	ldrh	r3, [r7, #12]
    8cd6:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46

        /* 
         * m = m2 * m1 * mext
         */
        m32 = extend_sign(m2) * extend_sign(m1);
    8cda:	88bb      	ldrh	r3, [r7, #4]
    8cdc:	4618      	mov	r0, r3
    8cde:	f000 f883 	bl	8de8 <extend_sign>
    8ce2:	4604      	mov	r4, r0
    8ce4:	f8b7 3042 	ldrh.w	r3, [r7, #66]	; 0x42
    8ce8:	4618      	mov	r0, r3
    8cea:	f000 f87d 	bl	8de8 <extend_sign>
    8cee:	4603      	mov	r3, r0
    8cf0:	fb03 f304 	mul.w	r3, r3, r4
    8cf4:	61fb      	str	r3, [r7, #28]
        m64 = (int64_t)m32 * extend_sign(mext);
    8cf6:	69fb      	ldr	r3, [r7, #28]
    8cf8:	461c      	mov	r4, r3
    8cfa:	ea4f 75e4 	mov.w	r5, r4, asr #31
    8cfe:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
    8d02:	4618      	mov	r0, r3
    8d04:	f000 f870 	bl	8de8 <extend_sign>
    8d08:	4603      	mov	r3, r0
    8d0a:	461a      	mov	r2, r3
    8d0c:	ea4f 73e2 	mov.w	r3, r2, asr #31
    8d10:	fb02 f105 	mul.w	r1, r2, r5
    8d14:	fb04 f003 	mul.w	r0, r4, r3
    8d18:	4401      	add	r1, r0
    8d1a:	fba4 2302 	umull	r2, r3, r4, r2
    8d1e:	4419      	add	r1, r3
    8d20:	460b      	mov	r3, r1
    8d22:	e9c7 2308 	strd	r2, r3, [r7, #32]
    8d26:	e9c7 2308 	strd	r2, r3, [r7, #32]
        
        /* Convert 48-bit result to 32-bit ACE format result. */
        m = adjust_to_16bit_ace_format(m64);
    8d2a:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
    8d2e:	f000 f8b3 	bl	8e98 <adjust_to_16bit_ace_format>
    8d32:	4603      	mov	r3, r0
    8d34:	617b      	str	r3, [r7, #20]

        /*
         * c = (m2 * c1 * mext) + (c2 * mext)
         */
        c32 = extend_sign(m2) * extend_sign(c1);
    8d36:	88bb      	ldrh	r3, [r7, #4]
    8d38:	4618      	mov	r0, r3
    8d3a:	f000 f855 	bl	8de8 <extend_sign>
    8d3e:	4604      	mov	r4, r0
    8d40:	f8b7 3044 	ldrh.w	r3, [r7, #68]	; 0x44
    8d44:	4618      	mov	r0, r3
    8d46:	f000 f84f 	bl	8de8 <extend_sign>
    8d4a:	4603      	mov	r3, r0
    8d4c:	fb03 f304 	mul.w	r3, r3, r4
    8d50:	62fb      	str	r3, [r7, #44]	; 0x2c
        c64_1 = (int64_t)c32 * extend_sign(mext);
    8d52:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8d54:	461c      	mov	r4, r3
    8d56:	ea4f 75e4 	mov.w	r5, r4, asr #31
    8d5a:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
    8d5e:	4618      	mov	r0, r3
    8d60:	f000 f842 	bl	8de8 <extend_sign>
    8d64:	4603      	mov	r3, r0
    8d66:	461a      	mov	r2, r3
    8d68:	ea4f 73e2 	mov.w	r3, r2, asr #31
    8d6c:	fb02 f105 	mul.w	r1, r2, r5
    8d70:	fb04 f003 	mul.w	r0, r4, r3
    8d74:	4401      	add	r1, r0
    8d76:	fba4 2302 	umull	r2, r3, r4, r2
    8d7a:	4419      	add	r1, r3
    8d7c:	460b      	mov	r3, r1
    8d7e:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
    8d82:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30

        c64_2 = ((int64_t)(extend_sign(c2) * extend_sign(mext))) << 14;
    8d86:	887b      	ldrh	r3, [r7, #2]
    8d88:	4618      	mov	r0, r3
    8d8a:	f000 f82d 	bl	8de8 <extend_sign>
    8d8e:	4604      	mov	r4, r0
    8d90:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
    8d94:	4618      	mov	r0, r3
    8d96:	f000 f827 	bl	8de8 <extend_sign>
    8d9a:	4603      	mov	r3, r0
    8d9c:	fb03 f304 	mul.w	r3, r3, r4
    8da0:	461a      	mov	r2, r3
    8da2:	ea4f 73e2 	mov.w	r3, r2, asr #31
    8da6:	ea4f 4192 	mov.w	r1, r2, lsr #18
    8daa:	ea4f 3083 	mov.w	r0, r3, lsl #14
    8dae:	ea40 0101 	orr.w	r1, r0, r1
    8db2:	63f9      	str	r1, [r7, #60]	; 0x3c
    8db4:	ea4f 3382 	mov.w	r3, r2, lsl #14
    8db8:	63bb      	str	r3, [r7, #56]	; 0x38
        
        c = adjust_to_24bit_ace_format(c64_1 + c64_2);
    8dba:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
    8dbe:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
    8dc2:	1812      	adds	r2, r2, r0
    8dc4:	eb43 0301 	adc.w	r3, r3, r1
    8dc8:	4610      	mov	r0, r2
    8dca:	4619      	mov	r1, r3
    8dcc:	f000 f824 	bl	8e18 <adjust_to_24bit_ace_format>
    8dd0:	4603      	mov	r3, r0
    8dd2:	61bb      	str	r3, [r7, #24]
        
        write_transform_coefficients(channel_handle, m, c);
    8dd4:	79fb      	ldrb	r3, [r7, #7]
    8dd6:	4618      	mov	r0, r3
    8dd8:	6979      	ldr	r1, [r7, #20]
    8dda:	69ba      	ldr	r2, [r7, #24]
    8ddc:	f000 fa5c 	bl	9298 <write_transform_coefficients>
    }
}
    8de0:	f107 0748 	add.w	r7, r7, #72	; 0x48
    8de4:	46bd      	mov	sp, r7
    8de6:	bdb0      	pop	{r4, r5, r7, pc}

00008de8 <extend_sign>:
 */
int32_t extend_sign
(
    uint16_t x
)
{
    8de8:	b480      	push	{r7}
    8dea:	b085      	sub	sp, #20
    8dec:	af00      	add	r7, sp, #0
    8dee:	4603      	mov	r3, r0
    8df0:	80fb      	strh	r3, [r7, #6]
    int32_t y;
    const uint32_t sign_bit_mask = 0x00008000u;
    8df2:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    8df6:	60fb      	str	r3, [r7, #12]
    
    y = (x ^ sign_bit_mask) - sign_bit_mask;
    8df8:	88fa      	ldrh	r2, [r7, #6]
    8dfa:	68fb      	ldr	r3, [r7, #12]
    8dfc:	ea82 0203 	eor.w	r2, r2, r3
    8e00:	68fb      	ldr	r3, [r7, #12]
    8e02:	ebc3 0302 	rsb	r3, r3, r2
    8e06:	60bb      	str	r3, [r7, #8]
    
    return y;
    8e08:	68bb      	ldr	r3, [r7, #8]
}
    8e0a:	4618      	mov	r0, r3
    8e0c:	f107 0714 	add.w	r7, r7, #20
    8e10:	46bd      	mov	sp, r7
    8e12:	bc80      	pop	{r7}
    8e14:	4770      	bx	lr
    8e16:	bf00      	nop

00008e18 <adjust_to_24bit_ace_format>:
 */
uint32_t adjust_to_24bit_ace_format
(
    int64_t signed48
)
{
    8e18:	b4b0      	push	{r4, r5, r7}
    8e1a:	b089      	sub	sp, #36	; 0x24
    8e1c:	af00      	add	r7, sp, #0
    8e1e:	e9c7 0100 	strd	r0, r1, [r7]
    int32_t ace24_format;
    const int64_t MAX_POSITIVE = 0x00001FFFFFFFFFFFuLL; /* +7.9999 */
    8e22:	f04f 30ff 	mov.w	r0, #4294967295
    8e26:	f641 71ff 	movw	r1, #8191	; 0x1fff
    8e2a:	e9c7 0104 	strd	r0, r1, [r7, #16]
    const int64_t MIN_NEGATIVE = 0xFFFF200000000000uLL; /* -8 */
    8e2e:	f04f 0000 	mov.w	r0, #0
    8e32:	f04f 4110 	mov.w	r1, #2415919104	; 0x90000000
    8e36:	ea4f 31e1 	mov.w	r1, r1, asr #15
    8e3a:	e9c7 0106 	strd	r0, r1, [r7, #24]
    
    /* Check saturation. */
    if(signed48 > MAX_POSITIVE)
    8e3e:	e9d7 0100 	ldrd	r0, r1, [r7]
    8e42:	e9d7 4504 	ldrd	r4, r5, [r7, #16]
    8e46:	4284      	cmp	r4, r0
    8e48:	eb75 0c01 	sbcs.w	ip, r5, r1
    8e4c:	da04      	bge.n	8e58 <adjust_to_24bit_ace_format+0x40>
    {
        signed48 = MAX_POSITIVE;
    8e4e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
    8e52:	e9c7 0100 	strd	r0, r1, [r7]
    8e56:	e00b      	b.n	8e70 <adjust_to_24bit_ace_format+0x58>
    }
    else if(signed48 < MIN_NEGATIVE)
    8e58:	e9d7 4500 	ldrd	r4, r5, [r7]
    8e5c:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
    8e60:	4284      	cmp	r4, r0
    8e62:	eb75 0c01 	sbcs.w	ip, r5, r1
    8e66:	da03      	bge.n	8e70 <adjust_to_24bit_ace_format+0x58>
    {
        signed48 = MIN_NEGATIVE;
    8e68:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
    8e6c:	e9c7 0100 	strd	r0, r1, [r7]
    }
    
    /* Adjust to 24-bit ACE format. */
    ace24_format = (uint32_t)(signed48 >> 14);
    8e70:	6879      	ldr	r1, [r7, #4]
    8e72:	ea4f 4181 	mov.w	r1, r1, lsl #18
    8e76:	6838      	ldr	r0, [r7, #0]
    8e78:	ea4f 3290 	mov.w	r2, r0, lsr #14
    8e7c:	ea41 0202 	orr.w	r2, r1, r2
    8e80:	6879      	ldr	r1, [r7, #4]
    8e82:	ea4f 33a1 	mov.w	r3, r1, asr #14
    8e86:	4613      	mov	r3, r2
    8e88:	60fb      	str	r3, [r7, #12]
    
    return ace24_format;
    8e8a:	68fb      	ldr	r3, [r7, #12]
}
    8e8c:	4618      	mov	r0, r3
    8e8e:	f107 0724 	add.w	r7, r7, #36	; 0x24
    8e92:	46bd      	mov	sp, r7
    8e94:	bcb0      	pop	{r4, r5, r7}
    8e96:	4770      	bx	lr

00008e98 <adjust_to_16bit_ace_format>:
 */
uint32_t adjust_to_16bit_ace_format
(
    int64_t signed48
)
{
    8e98:	b4b0      	push	{r4, r5, r7}
    8e9a:	b089      	sub	sp, #36	; 0x24
    8e9c:	af00      	add	r7, sp, #0
    8e9e:	e9c7 0100 	strd	r0, r1, [r7]
    int32_t ace24_format;
    const int64_t MAX_POSITIVE = 0x00001FFFFFFFFFFFuLL; /* +7.9999 */
    8ea2:	f04f 30ff 	mov.w	r0, #4294967295
    8ea6:	f641 71ff 	movw	r1, #8191	; 0x1fff
    8eaa:	e9c7 0104 	strd	r0, r1, [r7, #16]
    const int64_t MIN_NEGATIVE = 0xFFFF200000000000uLL; /* -8 */
    8eae:	f04f 0000 	mov.w	r0, #0
    8eb2:	f04f 4110 	mov.w	r1, #2415919104	; 0x90000000
    8eb6:	ea4f 31e1 	mov.w	r1, r1, asr #15
    8eba:	e9c7 0106 	strd	r0, r1, [r7, #24]
    
    /* Check saturation. */
    if(signed48 > MAX_POSITIVE)
    8ebe:	e9d7 0100 	ldrd	r0, r1, [r7]
    8ec2:	e9d7 4504 	ldrd	r4, r5, [r7, #16]
    8ec6:	4284      	cmp	r4, r0
    8ec8:	eb75 0c01 	sbcs.w	ip, r5, r1
    8ecc:	da04      	bge.n	8ed8 <adjust_to_16bit_ace_format+0x40>
    {
        signed48 = MAX_POSITIVE;
    8ece:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
    8ed2:	e9c7 0100 	strd	r0, r1, [r7]
    8ed6:	e00b      	b.n	8ef0 <adjust_to_16bit_ace_format+0x58>
    }
    else if(signed48 < MIN_NEGATIVE)
    8ed8:	e9d7 4500 	ldrd	r4, r5, [r7]
    8edc:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
    8ee0:	4284      	cmp	r4, r0
    8ee2:	eb75 0c01 	sbcs.w	ip, r5, r1
    8ee6:	da03      	bge.n	8ef0 <adjust_to_16bit_ace_format+0x58>
    {
        signed48 = MIN_NEGATIVE;
    8ee8:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
    8eec:	e9c7 0100 	strd	r0, r1, [r7]
    }
    
    /* Adjust to 24-bit ACE format. */
    ace24_format = (uint32_t)(signed48 >> 20);
    8ef0:	6879      	ldr	r1, [r7, #4]
    8ef2:	ea4f 3101 	mov.w	r1, r1, lsl #12
    8ef6:	6838      	ldr	r0, [r7, #0]
    8ef8:	ea4f 5210 	mov.w	r2, r0, lsr #20
    8efc:	ea41 0202 	orr.w	r2, r1, r2
    8f00:	6879      	ldr	r1, [r7, #4]
    8f02:	ea4f 5321 	mov.w	r3, r1, asr #20
    8f06:	4613      	mov	r3, r2
    8f08:	60fb      	str	r3, [r7, #12]
    
    return ace24_format;
    8f0a:	68fb      	ldr	r3, [r7, #12]
}
    8f0c:	4618      	mov	r0, r3
    8f0e:	f107 0724 	add.w	r7, r7, #36	; 0x24
    8f12:	46bd      	mov	sp, r7
    8f14:	bcb0      	pop	{r4, r5, r7}
    8f16:	4770      	bx	lr

00008f18 <get_calibration>:
void get_calibration
(
    adc_channel_id_t channel_id,
    channel_calibration_t * p_calibration
)
{
    8f18:	b490      	push	{r4, r7}
    8f1a:	b0a4      	sub	sp, #144	; 0x90
    8f1c:	af00      	add	r7, sp, #0
    8f1e:	4603      	mov	r3, r0
    8f20:	6039      	str	r1, [r7, #0]
    8f22:	71fb      	strb	r3, [r7, #7]
    const uint32_t channel_mask = 0x0000000F;
    8f24:	f04f 030f 	mov.w	r3, #15
    8f28:	65bb      	str	r3, [r7, #88]	; 0x58
    const uint32_t CMB_MUX_SEL_MASK = 0x01;
    8f2a:	f04f 0301 	mov.w	r3, #1
    8f2e:	65fb      	str	r3, [r7, #92]	; 0x5c
    const uint32_t TMB_MUX_SEL_MASK = 0x01;
    8f30:	f04f 0301 	mov.w	r3, #1
    8f34:	663b      	str	r3, [r7, #96]	; 0x60
        DIRECT_ADC_INPUT_CHAN,
        DIRECT_ADC_INPUT_CHAN,
        FLOATING_CHAN,
        FLOATING_CHAN,
        OBDOUT_CHAN
    };
    8f36:	f24d 0348 	movw	r3, #53320	; 0xd048
    8f3a:	f2c0 0301 	movt	r3, #1
    8f3e:	f107 0c48 	add.w	ip, r7, #72	; 0x48
    8f42:	cb0f      	ldmia	r3!, {r0, r1, r2, r3}
    8f44:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
    cal_channel_type_t channel_type;
    uint32_t channel_nb;
    uint32_t adc_nb;
    uint32_t range;
    uint32_t quad_id;
    mtd_calibration_mc_t const * p_mc_coeff = 0;
    8f48:	f04f 0300 	mov.w	r3, #0
    8f4c:	67bb      	str	r3, [r7, #120]	; 0x78
    
    channel_nb = channel_id & channel_mask;
    8f4e:	79fa      	ldrb	r2, [r7, #7]
    8f50:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    8f52:	ea02 0303 	and.w	r3, r2, r3
    8f56:	66bb      	str	r3, [r7, #104]	; 0x68
    channel_type = channel_type_lut[channel_nb];
    8f58:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    8f5a:	f107 0290 	add.w	r2, r7, #144	; 0x90
    8f5e:	4413      	add	r3, r2
    8f60:	f813 3c48 	ldrb.w	r3, [r3, #-72]
    8f64:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
    adc_nb = ((uint32_t)channel_id & 0x30u) >> 4u;
    8f68:	79fb      	ldrb	r3, [r7, #7]
    8f6a:	f003 0330 	and.w	r3, r3, #48	; 0x30
    8f6e:	ea4f 1313 	mov.w	r3, r3, lsr #4
    8f72:	66fb      	str	r3, [r7, #108]	; 0x6c
    
    quad_id = adc_nb * 2;
    8f74:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    8f76:	ea4f 0343 	mov.w	r3, r3, lsl #1
    8f7a:	677b      	str	r3, [r7, #116]	; 0x74
    
    if ( (channel_nb > 4) && (channel_nb < 9) ) { ++quad_id; }
    8f7c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    8f7e:	2b04      	cmp	r3, #4
    8f80:	d906      	bls.n	8f90 <get_calibration+0x78>
    8f82:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    8f84:	2b08      	cmp	r3, #8
    8f86:	d803      	bhi.n	8f90 <get_calibration+0x78>
    8f88:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    8f8a:	f103 0301 	add.w	r3, r3, #1
    8f8e:	677b      	str	r3, [r7, #116]	; 0x74
    
    switch ( channel_type )
    8f90:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
    8f94:	2b05      	cmp	r3, #5
    8f96:	f200 8151 	bhi.w	923c <get_calibration+0x324>
    8f9a:	a201      	add	r2, pc, #4	; (adr r2, 8fa0 <get_calibration+0x88>)
    8f9c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    8fa0:	00008fb9 	.word	0x00008fb9
    8fa4:	00009007 	.word	0x00009007
    8fa8:	0000905d 	.word	0x0000905d
    8fac:	000090c3 	.word	0x000090c3
    8fb0:	00009135 	.word	0x00009135
    8fb4:	0000919d 	.word	0x0000919d
    {
    case ABPS1_CHAN:
        range = (ACE->ACB_DATA[quad_id].b8 & ABPS1_CFG_BITS_MASK) >> ABPS1_CFG_BITS_SHIFT;
    8fb8:	f240 0200 	movw	r2, #0
    8fbc:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8fc0:	6f79      	ldr	r1, [r7, #116]	; 0x74
    8fc2:	460b      	mov	r3, r1
    8fc4:	ea4f 0343 	mov.w	r3, r3, lsl #1
    8fc8:	440b      	add	r3, r1
    8fca:	ea4f 1303 	mov.w	r3, r3, lsl #4
    8fce:	4413      	add	r3, r2
    8fd0:	f503 7308 	add.w	r3, r3, #544	; 0x220
    8fd4:	791b      	ldrb	r3, [r3, #4]
    8fd6:	b2db      	uxtb	r3, r3
    8fd8:	f003 0306 	and.w	r3, r3, #6
    8fdc:	ea4f 0353 	mov.w	r3, r3, lsr #1
    8fe0:	673b      	str	r3, [r7, #112]	; 0x70
        p_mc_coeff = &p_mtd_data->abps_calibration[quad_id][0][range];
    8fe2:	f24d 0344 	movw	r3, #53316	; 0xd044
    8fe6:	f2c0 0301 	movt	r3, #1
    8fea:	681b      	ldr	r3, [r3, #0]
    8fec:	f103 0390 	add.w	r3, r3, #144	; 0x90
    8ff0:	461a      	mov	r2, r3
    8ff2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    8ff4:	ea4f 01c3 	mov.w	r1, r3, lsl #3
    8ff8:	6f3b      	ldr	r3, [r7, #112]	; 0x70
    8ffa:	440b      	add	r3, r1
    8ffc:	ea4f 0383 	mov.w	r3, r3, lsl #2
    9000:	4413      	add	r3, r2
    9002:	67bb      	str	r3, [r7, #120]	; 0x78
        break;
    9004:	e122      	b.n	924c <get_calibration+0x334>
        
    case ABPS2_CHAN:
        range = (ACE->ACB_DATA[quad_id].b8 & ABPS2_CFG_BITS_MASK) >> ABPS2_CFG_BITS_SHIFT;
    9006:	f240 0200 	movw	r2, #0
    900a:	f2c4 0202 	movt	r2, #16386	; 0x4002
    900e:	6f79      	ldr	r1, [r7, #116]	; 0x74
    9010:	460b      	mov	r3, r1
    9012:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9016:	440b      	add	r3, r1
    9018:	ea4f 1303 	mov.w	r3, r3, lsl #4
    901c:	4413      	add	r3, r2
    901e:	f503 7308 	add.w	r3, r3, #544	; 0x220
    9022:	791b      	ldrb	r3, [r3, #4]
    9024:	b2db      	uxtb	r3, r3
    9026:	f003 0360 	and.w	r3, r3, #96	; 0x60
    902a:	ea4f 1353 	mov.w	r3, r3, lsr #5
    902e:	673b      	str	r3, [r7, #112]	; 0x70
        p_mc_coeff = &p_mtd_data->abps_calibration[quad_id][1][range];
    9030:	f24d 0344 	movw	r3, #53316	; 0xd044
    9034:	f2c0 0301 	movt	r3, #1
    9038:	681b      	ldr	r3, [r3, #0]
    903a:	f103 0390 	add.w	r3, r3, #144	; 0x90
    903e:	461a      	mov	r2, r3
    9040:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    9042:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9046:	f103 0301 	add.w	r3, r3, #1
    904a:	ea4f 0183 	mov.w	r1, r3, lsl #2
    904e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
    9050:	440b      	add	r3, r1
    9052:	ea4f 0383 	mov.w	r3, r3, lsl #2
    9056:	4413      	add	r3, r2
    9058:	67bb      	str	r3, [r7, #120]	; 0x78
        break;
    905a:	e0f7      	b.n	924c <get_calibration+0x334>
        
    case CMB_CHAN:
        {
            uint32_t cmb_mux_sel = (uint32_t)ACE->ACB_DATA[quad_id].b9 & CMB_MUX_SEL_MASK;
    905c:	f240 0200 	movw	r2, #0
    9060:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9064:	6f79      	ldr	r1, [r7, #116]	; 0x74
    9066:	460b      	mov	r3, r1
    9068:	ea4f 0343 	mov.w	r3, r3, lsl #1
    906c:	440b      	add	r3, r1
    906e:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9072:	4413      	add	r3, r2
    9074:	f503 7308 	add.w	r3, r3, #544	; 0x220
    9078:	7a1b      	ldrb	r3, [r3, #8]
    907a:	b2db      	uxtb	r3, r3
    907c:	461a      	mov	r2, r3
    907e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    9080:	ea02 0303 	and.w	r3, r2, r3
    9084:	67fb      	str	r3, [r7, #124]	; 0x7c
            if ( cmb_mux_sel == 0 )
    9086:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
    9088:	2b00      	cmp	r3, #0
    908a:	d10c      	bne.n	90a6 <get_calibration+0x18e>
            {   /* current monitor */
                p_mc_coeff = &p_mtd_data->cm_calibration[quad_id];
    908c:	f24d 0344 	movw	r3, #53316	; 0xd044
    9090:	f2c0 0301 	movt	r3, #1
    9094:	681b      	ldr	r3, [r3, #0]
    9096:	f503 72c0 	add.w	r2, r3, #384	; 0x180
    909a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    909c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    90a0:	4413      	add	r3, r2
    90a2:	67bb      	str	r3, [r7, #120]	; 0x78
            else
            {   /* direct input */
                p_mc_coeff = &p_mtd_data->quads_direct_input_cal[quad_id][0];
            }
        }
        break;
    90a4:	e0d2      	b.n	924c <get_calibration+0x334>
            {   /* current monitor */
                p_mc_coeff = &p_mtd_data->cm_calibration[quad_id];
            }
            else
            {   /* direct input */
                p_mc_coeff = &p_mtd_data->quads_direct_input_cal[quad_id][0];
    90a6:	f24d 0344 	movw	r3, #53316	; 0xd044
    90aa:	f2c0 0301 	movt	r3, #1
    90ae:	681b      	ldr	r3, [r3, #0]
    90b0:	f503 73d8 	add.w	r3, r3, #432	; 0x1b0
    90b4:	461a      	mov	r2, r3
    90b6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    90b8:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    90bc:	4413      	add	r3, r2
    90be:	67bb      	str	r3, [r7, #120]	; 0x78
            }
        }
        break;
    90c0:	e0c4      	b.n	924c <get_calibration+0x334>
        
    case TMB_CHAN:
        {
            uint32_t tmb_mux_sel = (uint32_t)ACE->ACB_DATA[quad_id].b10 & TMB_MUX_SEL_MASK;
    90c2:	f240 0200 	movw	r2, #0
    90c6:	f2c4 0202 	movt	r2, #16386	; 0x4002
    90ca:	6f79      	ldr	r1, [r7, #116]	; 0x74
    90cc:	460b      	mov	r3, r1
    90ce:	ea4f 0343 	mov.w	r3, r3, lsl #1
    90d2:	440b      	add	r3, r1
    90d4:	ea4f 1303 	mov.w	r3, r3, lsl #4
    90d8:	4413      	add	r3, r2
    90da:	f503 730a 	add.w	r3, r3, #552	; 0x228
    90de:	791b      	ldrb	r3, [r3, #4]
    90e0:	b2db      	uxtb	r3, r3
    90e2:	461a      	mov	r2, r3
    90e4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    90e6:	ea02 0303 	and.w	r3, r2, r3
    90ea:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
            if ( tmb_mux_sel == 0 )
    90ee:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
    90f2:	2b00      	cmp	r3, #0
    90f4:	d10c      	bne.n	9110 <get_calibration+0x1f8>
            {   /* temperature monitor */
                p_mc_coeff = &p_mtd_data->tm_calibration[quad_id];
    90f6:	f24d 0344 	movw	r3, #53316	; 0xd044
    90fa:	f2c0 0301 	movt	r3, #1
    90fe:	681b      	ldr	r3, [r3, #0]
    9100:	f503 72cc 	add.w	r2, r3, #408	; 0x198
    9104:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    9106:	ea4f 0383 	mov.w	r3, r3, lsl #2
    910a:	4413      	add	r3, r2
    910c:	67bb      	str	r3, [r7, #120]	; 0x78
            else
            {   /* direct input */
                p_mc_coeff = &p_mtd_data->quads_direct_input_cal[quad_id][1];
            }
        }
        break;
    910e:	e09d      	b.n	924c <get_calibration+0x334>
            {   /* temperature monitor */
                p_mc_coeff = &p_mtd_data->tm_calibration[quad_id];
            }
            else
            {   /* direct input */
                p_mc_coeff = &p_mtd_data->quads_direct_input_cal[quad_id][1];
    9110:	f24d 0344 	movw	r3, #53316	; 0xd044
    9114:	f2c0 0301 	movt	r3, #1
    9118:	681b      	ldr	r3, [r3, #0]
    911a:	f503 73d8 	add.w	r3, r3, #432	; 0x1b0
    911e:	461a      	mov	r2, r3
    9120:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    9122:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9126:	f103 0301 	add.w	r3, r3, #1
    912a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    912e:	4413      	add	r3, r2
    9130:	67bb      	str	r3, [r7, #120]	; 0x78
            }
        }
        break;
    9132:	e08b      	b.n	924c <get_calibration+0x334>
#ifdef SMARTFUSION_060_DEVICE
            const uint32_t channel_to_direct_in_lut[16]
                = { 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
#else
            const uint32_t channel_to_direct_in_lut[16]
                = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0 };
    9134:	f24d 0358 	movw	r3, #53336	; 0xd058
    9138:	f2c0 0301 	movt	r3, #1
    913c:	f107 0c08 	add.w	ip, r7, #8
    9140:	461c      	mov	r4, r3
    9142:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    9144:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    9148:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    914a:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    914e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    9150:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    9154:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
    9158:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
#endif
            uint32_t direct_in_id;
            
            direct_in_id = channel_to_direct_in_lut[channel_id & channel_mask];
    915c:	79fa      	ldrb	r2, [r7, #7]
    915e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    9160:	ea02 0303 	and.w	r3, r2, r3
    9164:	ea4f 0383 	mov.w	r3, r3, lsl #2
    9168:	f107 0290 	add.w	r2, r7, #144	; 0x90
    916c:	4413      	add	r3, r2
    916e:	f853 3c88 	ldr.w	r3, [r3, #-136]
    9172:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
            p_mc_coeff = &p_mtd_data->adc_direct_input_cal[adc_nb][direct_in_id];
    9176:	f24d 0344 	movw	r3, #53316	; 0xd044
    917a:	f2c0 0301 	movt	r3, #1
    917e:	681b      	ldr	r3, [r3, #0]
    9180:	f503 73f0 	add.w	r3, r3, #480	; 0x1e0
    9184:	461a      	mov	r2, r3
    9186:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    9188:	ea4f 0183 	mov.w	r1, r3, lsl #2
    918c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
    9190:	440b      	add	r3, r1
    9192:	ea4f 0383 	mov.w	r3, r3, lsl #2
    9196:	4413      	add	r3, r2
    9198:	67bb      	str	r3, [r7, #120]	; 0x78
        }
        break;
    919a:	e057      	b.n	924c <get_calibration+0x334>
        
    case OBDOUT_CHAN:
        {
            uint32_t obd_mode = (uint32_t)ACE->ACB_DATA[quad_id].b6 & OBD_MODE_MASK;
    919c:	f240 0200 	movw	r2, #0
    91a0:	f2c4 0202 	movt	r2, #16386	; 0x4002
    91a4:	6f79      	ldr	r1, [r7, #116]	; 0x74
    91a6:	460b      	mov	r3, r1
    91a8:	ea4f 0343 	mov.w	r3, r3, lsl #1
    91ac:	440b      	add	r3, r1
    91ae:	ea4f 1303 	mov.w	r3, r3, lsl #4
    91b2:	4413      	add	r3, r2
    91b4:	f503 7306 	add.w	r3, r3, #536	; 0x218
    91b8:	791b      	ldrb	r3, [r3, #4]
    91ba:	b2db      	uxtb	r3, r3
    91bc:	f003 0301 	and.w	r3, r3, #1
    91c0:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
            uint32_t chopping_option = (uint32_t)ACE->ACB_DATA[quad_id].b6 & OBD_CHOPPING_MASK;
    91c4:	f240 0200 	movw	r2, #0
    91c8:	f2c4 0202 	movt	r2, #16386	; 0x4002
    91cc:	6f79      	ldr	r1, [r7, #116]	; 0x74
    91ce:	460b      	mov	r3, r1
    91d0:	ea4f 0343 	mov.w	r3, r3, lsl #1
    91d4:	440b      	add	r3, r1
    91d6:	ea4f 1303 	mov.w	r3, r3, lsl #4
    91da:	4413      	add	r3, r2
    91dc:	f503 7306 	add.w	r3, r3, #536	; 0x218
    91e0:	791b      	ldrb	r3, [r3, #4]
    91e2:	b2db      	uxtb	r3, r3
    91e4:	f003 0302 	and.w	r3, r3, #2
    91e8:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
            if (obd_mode > 0)
    91ec:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
    91f0:	2b00      	cmp	r3, #0
    91f2:	d003      	beq.n	91fc <get_calibration+0x2e4>
            {
                obd_mode = 1;
    91f4:	f04f 0301 	mov.w	r3, #1
    91f8:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
            }
            if (chopping_option > 0)
    91fc:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
    9200:	2b00      	cmp	r3, #0
    9202:	d003      	beq.n	920c <get_calibration+0x2f4>
            {
                chopping_option = 1;
    9204:	f04f 0301 	mov.w	r3, #1
    9208:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
            }
            p_mc_coeff = &p_mtd_data->obd_calibration[adc_nb][obd_mode][chopping_option];
    920c:	f24d 0344 	movw	r3, #53316	; 0xd044
    9210:	f2c0 0301 	movt	r3, #1
    9214:	681b      	ldr	r3, [r3, #0]
    9216:	f503 73a8 	add.w	r3, r3, #336	; 0x150
    921a:	461a      	mov	r2, r3
    921c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    921e:	ea4f 0143 	mov.w	r1, r3, lsl #1
    9222:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
    9226:	440b      	add	r3, r1
    9228:	ea4f 0143 	mov.w	r1, r3, lsl #1
    922c:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
    9230:	440b      	add	r3, r1
    9232:	ea4f 0383 	mov.w	r3, r3, lsl #2
    9236:	4413      	add	r3, r2
    9238:	67bb      	str	r3, [r7, #120]	; 0x78
        }
        break;
    923a:	e007      	b.n	924c <get_calibration+0x334>
       
    case FLOATING_CHAN:
    default:
        /* Give neutral values is invalid channel. */
        p_calibration->m1 = NEUTRAL_M_FACTOR;
    923c:	683b      	ldr	r3, [r7, #0]
    923e:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    9242:	805a      	strh	r2, [r3, #2]
        p_calibration->c1 = NEUTRAL_C_OFFSET;
    9244:	683b      	ldr	r3, [r7, #0]
    9246:	f04f 0200 	mov.w	r2, #0
    924a:	809a      	strh	r2, [r3, #4]
        break;
    }
    
    if (p_mc_coeff != 0)
    924c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
    924e:	2b00      	cmp	r3, #0
    9250:	d007      	beq.n	9262 <get_calibration+0x34a>
    {
        p_calibration->m1 = p_mc_coeff->m;
    9252:	6fbb      	ldr	r3, [r7, #120]	; 0x78
    9254:	881a      	ldrh	r2, [r3, #0]
    9256:	683b      	ldr	r3, [r7, #0]
    9258:	805a      	strh	r2, [r3, #2]
        p_calibration->c1 = p_mc_coeff->c;
    925a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
    925c:	885a      	ldrh	r2, [r3, #2]
    925e:	683b      	ldr	r3, [r7, #0]
    9260:	809a      	strh	r2, [r3, #4]
    
    /*--------------------------------------------------------------------------
      Retrieve the value of the mext factor. This depends if external VAREF is
      used by the ADC sampling the analog input channel.
     */
    if (g_ace_external_varef_used[adc_nb])
    9262:	6efa      	ldr	r2, [r7, #108]	; 0x6c
    9264:	f64c 0324 	movw	r3, #51236	; 0xc824
    9268:	f2c0 0301 	movt	r3, #1
    926c:	5c9b      	ldrb	r3, [r3, r2]
    926e:	2b00      	cmp	r3, #0
    9270:	d008      	beq.n	9284 <get_calibration+0x36c>
    {
        p_calibration->mext = p_mtd_data->global_settings.varef_m;
    9272:	f24d 0344 	movw	r3, #53316	; 0xd044
    9276:	f2c0 0301 	movt	r3, #1
    927a:	681b      	ldr	r3, [r3, #0]
    927c:	8b9a      	ldrh	r2, [r3, #28]
    927e:	683b      	ldr	r3, [r7, #0]
    9280:	801a      	strh	r2, [r3, #0]
    9282:	e003      	b.n	928c <get_calibration+0x374>
    }
    else
    {
        p_calibration->mext = NEUTRAL_M_FACTOR;
    9284:	683b      	ldr	r3, [r7, #0]
    9286:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    928a:	801a      	strh	r2, [r3, #0]
    }
}
    928c:	f107 0790 	add.w	r7, r7, #144	; 0x90
    9290:	46bd      	mov	sp, r7
    9292:	bc90      	pop	{r4, r7}
    9294:	4770      	bx	lr
    9296:	bf00      	nop

00009298 <write_transform_coefficients>:
(
    ace_channel_handle_t channel_handle,
	uint32_t m,
	uint32_t c
)
{
    9298:	b480      	push	{r7}
    929a:	b087      	sub	sp, #28
    929c:	af00      	add	r7, sp, #0
    929e:	4603      	mov	r3, r0
    92a0:	60b9      	str	r1, [r7, #8]
    92a2:	607a      	str	r2, [r7, #4]
    92a4:	73fb      	strb	r3, [r7, #15]
    uint16_t m_ppe_offset;
    uint16_t c_ppe_offset;
    const uint32_t PPE_OPCODE_MASK = 0xFF000000u;
    92a6:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
    92aa:	617b      	str	r3, [r7, #20]
    
    m_ppe_offset = g_ace_ppe_transforms_desc_table[channel_handle].m_ppe_offset;
    92ac:	7bfa      	ldrb	r2, [r7, #15]
    92ae:	f64c 03a4 	movw	r3, #51364	; 0xc8a4
    92b2:	f2c0 0301 	movt	r3, #1
    92b6:	f833 3032 	ldrh.w	r3, [r3, r2, lsl #3]
    92ba:	823b      	strh	r3, [r7, #16]
    c_ppe_offset = g_ace_ppe_transforms_desc_table[channel_handle].c_ppe_offset;
    92bc:	7bfb      	ldrb	r3, [r7, #15]
    92be:	f64c 02a4 	movw	r2, #51364	; 0xc8a4
    92c2:	f2c0 0201 	movt	r2, #1
    92c6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    92ca:	4413      	add	r3, r2
    92cc:	885b      	ldrh	r3, [r3, #2]
    92ce:	827b      	strh	r3, [r7, #18]
    
    ACE->PPE_RAM_DATA[m_ppe_offset]
    92d0:	f240 0300 	movw	r3, #0
    92d4:	f2c4 0302 	movt	r3, #16386	; 0x4002
    92d8:	8a38      	ldrh	r0, [r7, #16]
        = (ACE->PPE_RAM_DATA[m_ppe_offset] & PPE_OPCODE_MASK) | (m >> 8u);
    92da:	f240 0200 	movw	r2, #0
    92de:	f2c4 0202 	movt	r2, #16386	; 0x4002
    92e2:	8a39      	ldrh	r1, [r7, #16]
    92e4:	f501 61c0 	add.w	r1, r1, #1536	; 0x600
    92e8:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
    92ec:	697a      	ldr	r2, [r7, #20]
    92ee:	ea01 0102 	and.w	r1, r1, r2
    92f2:	68ba      	ldr	r2, [r7, #8]
    92f4:	ea4f 2212 	mov.w	r2, r2, lsr #8
    92f8:	ea41 0102 	orr.w	r1, r1, r2
    const uint32_t PPE_OPCODE_MASK = 0xFF000000u;
    
    m_ppe_offset = g_ace_ppe_transforms_desc_table[channel_handle].m_ppe_offset;
    c_ppe_offset = g_ace_ppe_transforms_desc_table[channel_handle].c_ppe_offset;
    
    ACE->PPE_RAM_DATA[m_ppe_offset]
    92fc:	f500 62c0 	add.w	r2, r0, #1536	; 0x600
    9300:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        = (ACE->PPE_RAM_DATA[m_ppe_offset] & PPE_OPCODE_MASK) | (m >> 8u);
        
    ACE->PPE_RAM_DATA[c_ppe_offset]
    9304:	f240 0300 	movw	r3, #0
    9308:	f2c4 0302 	movt	r3, #16386	; 0x4002
    930c:	8a78      	ldrh	r0, [r7, #18]
        = (ACE->PPE_RAM_DATA[c_ppe_offset] & PPE_OPCODE_MASK) | (c >> 8u);
    930e:	f240 0200 	movw	r2, #0
    9312:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9316:	8a79      	ldrh	r1, [r7, #18]
    9318:	f501 61c0 	add.w	r1, r1, #1536	; 0x600
    931c:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
    9320:	697a      	ldr	r2, [r7, #20]
    9322:	ea01 0102 	and.w	r1, r1, r2
    9326:	687a      	ldr	r2, [r7, #4]
    9328:	ea4f 2212 	mov.w	r2, r2, lsr #8
    932c:	ea41 0102 	orr.w	r1, r1, r2
    c_ppe_offset = g_ace_ppe_transforms_desc_table[channel_handle].c_ppe_offset;
    
    ACE->PPE_RAM_DATA[m_ppe_offset]
        = (ACE->PPE_RAM_DATA[m_ppe_offset] & PPE_OPCODE_MASK) | (m >> 8u);
        
    ACE->PPE_RAM_DATA[c_ppe_offset]
    9330:	f500 62c0 	add.w	r2, r0, #1536	; 0x600
    9334:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        = (ACE->PPE_RAM_DATA[c_ppe_offset] & PPE_OPCODE_MASK) | (c >> 8u);
}
    9338:	f107 071c 	add.w	r7, r7, #28
    933c:	46bd      	mov	sp, r7
    933e:	bc80      	pop	{r7}
    9340:	4770      	bx	lr
    9342:	bf00      	nop

00009344 <ACE_init>:

/*-------------------------------------------------------------------------*//**
  See "mss_ace.h" for details of how to use this function.
 */
void ACE_init( void )
{
    9344:	b580      	push	{r7, lr}
    9346:	af00      	add	r7, sp, #0
    /* Initialize driver's internal data. */
    ace_init_flags();
    9348:	f7fe fcfe 	bl	7d48 <ace_init_flags>
    
    /* Initialize the data structures used by conversion functions. */
    ace_init_convert();
    934c:	f7fd ffce 	bl	72ec <ace_init_convert>
}
    9350:	bd80      	pop	{r7, pc}
    9352:	bf00      	nop

00009354 <ACE_start_adc>:
 */
void ACE_start_adc
(
	adc_channel_id_t channel_id
)
{
    9354:	b480      	push	{r7}
    9356:	b083      	sub	sp, #12
    9358:	af00      	add	r7, sp, #0
    935a:	4603      	mov	r3, r0
    935c:	71fb      	strb	r3, [r7, #7]
    ACE->ADC0_CONV_CTRL = (uint32_t)((uint32_t)channel_id | START_ADC_CONVERSION);
    935e:	f240 0300 	movw	r3, #0
    9362:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9366:	79fa      	ldrb	r2, [r7, #7]
    9368:	ea6f 6242 	mvn.w	r2, r2, lsl #25
    936c:	ea6f 6252 	mvn.w	r2, r2, lsr #25
    9370:	b2d2      	uxtb	r2, r2
    9372:	651a      	str	r2, [r3, #80]	; 0x50
}
    9374:	f107 070c 	add.w	r7, r7, #12
    9378:	46bd      	mov	sp, r7
    937a:	bc80      	pop	{r7}
    937c:	4770      	bx	lr
    937e:	bf00      	nop

00009380 <ACE_get_adc_result>:

uint16_t ACE_get_adc_result
(
    uint8_t adc_id
)
{
    9380:	b480      	push	{r7}
    9382:	b085      	sub	sp, #20
    9384:	af00      	add	r7, sp, #0
    9386:	4603      	mov	r3, r0
    9388:	71fb      	strb	r3, [r7, #7]
    uint16_t result = 0u;
    938a:	f04f 0300 	mov.w	r3, #0
    938e:	817b      	strh	r3, [r7, #10]
    uint32_t data_valid;

    ASSERT( adc_id < NB_OF_ANALOG_MODULES );
    9390:	79fb      	ldrb	r3, [r7, #7]
    9392:	2b02      	cmp	r3, #2
    9394:	d900      	bls.n	9398 <ACE_get_adc_result+0x18>
    9396:	be00      	bkpt	0x0000
    
    if ( adc_id < (uint8_t)NB_OF_ANALOG_MODULES )
    9398:	79fb      	ldrb	r3, [r7, #7]
    939a:	2b02      	cmp	r3, #2
    939c:	d81b      	bhi.n	93d6 <ACE_get_adc_result+0x56>
    {
        do {
            data_valid = (uint32_t)(*adc_status_reg_lut[adc_id] & ADC_DATAVALID_MASK);
    939e:	79fa      	ldrb	r2, [r7, #7]
    93a0:	f24d 03a0 	movw	r3, #53408	; 0xd0a0
    93a4:	f2c0 0301 	movt	r3, #1
    93a8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    93ac:	681b      	ldr	r3, [r3, #0]
    93ae:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    93b2:	60fb      	str	r3, [r7, #12]
        } while ( !data_valid );
    93b4:	68fb      	ldr	r3, [r7, #12]
    93b6:	2b00      	cmp	r3, #0
    93b8:	d0f1      	beq.n	939e <ACE_get_adc_result+0x1e>
        
        result = (uint16_t)(*adc_status_reg_lut[adc_id] & ADC_RESULT_MASK);
    93ba:	79fa      	ldrb	r2, [r7, #7]
    93bc:	f24d 03a0 	movw	r3, #53408	; 0xd0a0
    93c0:	f2c0 0301 	movt	r3, #1
    93c4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    93c8:	681b      	ldr	r3, [r3, #0]
    93ca:	b29b      	uxth	r3, r3
    93cc:	ea4f 5303 	mov.w	r3, r3, lsl #20
    93d0:	ea4f 5313 	mov.w	r3, r3, lsr #20
    93d4:	817b      	strh	r3, [r7, #10]
    }
    return result;
    93d6:	897b      	ldrh	r3, [r7, #10]
}
    93d8:	4618      	mov	r0, r3
    93da:	f107 0714 	add.w	r7, r7, #20
    93de:	46bd      	mov	sp, r7
    93e0:	bc80      	pop	{r7}
    93e2:	4770      	bx	lr

000093e4 <ACE_configure_sdd>:
	sdd_id_t            sdd_id,
	sdd_resolution_t    resolution,
    uint8_t             mode,
    sdd_update_method_t sync_update
)
{
    93e4:	b490      	push	{r4, r7}
    93e6:	b086      	sub	sp, #24
    93e8:	af00      	add	r7, sp, #0
    93ea:	71f8      	strb	r0, [r7, #7]
    93ec:	71b9      	strb	r1, [r7, #6]
    93ee:	717a      	strb	r2, [r7, #5]
    93f0:	713b      	strb	r3, [r7, #4]
    ASSERT( sdd_id < NB_OF_SDD );
    93f2:	79fb      	ldrb	r3, [r7, #7]
    93f4:	2b02      	cmp	r3, #2
    93f6:	d900      	bls.n	93fa <ACE_configure_sdd+0x16>
    93f8:	be00      	bkpt	0x0000
    
    if ( sdd_id < NB_OF_SDD )
    93fa:	79fb      	ldrb	r3, [r7, #7]
    93fc:	2b02      	cmp	r3, #2
    93fe:	f200 80bc 	bhi.w	957a <ACE_configure_sdd+0x196>
    {
#ifdef SMARTFUSION_060_DEVICE
        const uint8_t sdd_2_quad_lut[NB_OF_SDD] = {0u};
#else	
        const uint8_t sdd_2_quad_lut[NB_OF_SDD] = {0u, 2u, 4u};
    9402:	f24d 02ec 	movw	r2, #53484	; 0xd0ec
    9406:	f2c0 0201 	movt	r2, #1
    940a:	f107 030c 	add.w	r3, r7, #12
    940e:	6812      	ldr	r2, [r2, #0]
    9410:	4611      	mov	r1, r2
    9412:	8019      	strh	r1, [r3, #0]
    9414:	f103 0302 	add.w	r3, r3, #2
    9418:	ea4f 4212 	mov.w	r2, r2, lsr #16
    941c:	701a      	strb	r2, [r3, #0]
#endif
        uint8_t quad_id;
        uint8_t obd_mode_idx = 1u;
    941e:	f04f 0301 	mov.w	r3, #1
    9422:	74bb      	strb	r3, [r7, #18]
        uint8_t chopping_mode_idx = 0u;
    9424:	f04f 0300 	mov.w	r3, #0
    9428:	74fb      	strb	r3, [r7, #19]
        uint32_t saved_pc2_ctrl;
        
        quad_id = sdd_2_quad_lut[sdd_id];
    942a:	79fb      	ldrb	r3, [r7, #7]
    942c:	f107 0218 	add.w	r2, r7, #24
    9430:	4413      	add	r3, r2
    9432:	f813 3c0c 	ldrb.w	r3, [r3, #-12]
    9436:	747b      	strb	r3, [r7, #17]
        
        /* Pause the SSE PC2 while accesses to ACB from APB3 are taking place. */
        saved_pc2_ctrl = ACE->PC2_CTRL;
    9438:	f240 0300 	movw	r3, #0
    943c:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9440:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
    9444:	617b      	str	r3, [r7, #20]
        ACE->PC2_CTRL = 0u;
    9446:	f240 0300 	movw	r3, #0
    944a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    944e:	f04f 0200 	mov.w	r2, #0
    9452:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
        
        /* Select between voltage/current and RTZ modes.*/
        ACE->ACB_DATA[quad_id].b6 = mode;
    9456:	f240 0200 	movw	r2, #0
    945a:	f2c4 0202 	movt	r2, #16386	; 0x4002
    945e:	7c79      	ldrb	r1, [r7, #17]
    9460:	460b      	mov	r3, r1
    9462:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9466:	440b      	add	r3, r1
    9468:	ea4f 1303 	mov.w	r3, r3, lsl #4
    946c:	4413      	add	r3, r2
    946e:	f503 7306 	add.w	r3, r3, #536	; 0x218
    9472:	797a      	ldrb	r2, [r7, #5]
    9474:	711a      	strb	r2, [r3, #4]
        
        /* Load manufacturing generated trim value. */
        if ( (mode & OBD_MODE_MASK) > 0u )
    9476:	797b      	ldrb	r3, [r7, #5]
    9478:	f003 0301 	and.w	r3, r3, #1
    947c:	b2db      	uxtb	r3, r3
    947e:	2b00      	cmp	r3, #0
    9480:	d002      	beq.n	9488 <ACE_configure_sdd+0xa4>
        {
            obd_mode_idx = 0u;
    9482:	f04f 0300 	mov.w	r3, #0
    9486:	74bb      	strb	r3, [r7, #18]
        }
        if ( (mode & OBD_CHOPPING_MASK) > 0u )
    9488:	797b      	ldrb	r3, [r7, #5]
    948a:	f003 0302 	and.w	r3, r3, #2
    948e:	2b00      	cmp	r3, #0
    9490:	d002      	beq.n	9498 <ACE_configure_sdd+0xb4>
        {
            chopping_mode_idx = 1u;
    9492:	f04f 0301 	mov.w	r3, #1
    9496:	74fb      	strb	r3, [r7, #19]
        }
        ACE->ACB_DATA[quad_id].b4
    9498:	f240 0200 	movw	r2, #0
    949c:	f2c4 0202 	movt	r2, #16386	; 0x4002
    94a0:	7c79      	ldrb	r1, [r7, #17]
            = p_mtd_data->odb_trimming[sdd_id][obd_mode_idx][chopping_mode_idx];
    94a2:	f24d 03dc 	movw	r3, #53468	; 0xd0dc
    94a6:	f2c0 0301 	movt	r3, #1
    94aa:	681b      	ldr	r3, [r3, #0]
    94ac:	79fc      	ldrb	r4, [r7, #7]
    94ae:	f897 c012 	ldrb.w	ip, [r7, #18]
    94b2:	7cf8      	ldrb	r0, [r7, #19]
    94b4:	ea4f 0444 	mov.w	r4, r4, lsl #1
    94b8:	44a4      	add	ip, r4
    94ba:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
    94be:	4460      	add	r0, ip
    94c0:	4403      	add	r3, r0
    94c2:	f103 0380 	add.w	r3, r3, #128	; 0x80
    94c6:	7918      	ldrb	r0, [r3, #4]
        }
        if ( (mode & OBD_CHOPPING_MASK) > 0u )
        {
            chopping_mode_idx = 1u;
        }
        ACE->ACB_DATA[quad_id].b4
    94c8:	460b      	mov	r3, r1
    94ca:	ea4f 0343 	mov.w	r3, r3, lsl #1
    94ce:	440b      	add	r3, r1
    94d0:	ea4f 1303 	mov.w	r3, r3, lsl #4
    94d4:	4413      	add	r3, r2
    94d6:	f503 7304 	add.w	r3, r3, #528	; 0x210
    94da:	4602      	mov	r2, r0
    94dc:	711a      	strb	r2, [r3, #4]
            = p_mtd_data->odb_trimming[sdd_id][obd_mode_idx][chopping_mode_idx];
        
        /* Restore SSE PC2 operations since no ACB accesses should take place
         * beyond this point. */
        ACE->PC2_CTRL = saved_pc2_ctrl;
    94de:	f240 0300 	movw	r3, #0
    94e2:	f2c4 0302 	movt	r3, #16386	; 0x4002
    94e6:	697a      	ldr	r2, [r7, #20]
    94e8:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    
        /* Set SDD resolution. */
        *dac_ctrl_reg_lut[sdd_id] = (uint32_t)resolution;
    94ec:	79fa      	ldrb	r2, [r7, #7]
    94ee:	f24d 03ac 	movw	r3, #53420	; 0xd0ac
    94f2:	f2c0 0301 	movt	r3, #1
    94f6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    94fa:	79ba      	ldrb	r2, [r7, #6]
    94fc:	601a      	str	r2, [r3, #0]
        
        /* Update SDD value through SSE_DACn_BYTES01. */
        *dac_ctrl_reg_lut[sdd_id] |= SDD_REG_SEL_MASK;
    94fe:	79fa      	ldrb	r2, [r7, #7]
    9500:	f24d 03ac 	movw	r3, #53420	; 0xd0ac
    9504:	f2c0 0301 	movt	r3, #1
    9508:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    950c:	79f9      	ldrb	r1, [r7, #7]
    950e:	f24d 03ac 	movw	r3, #53420	; 0xd0ac
    9512:	f2c0 0301 	movt	r3, #1
    9516:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    951a:	681b      	ldr	r3, [r3, #0]
    951c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    9520:	6013      	str	r3, [r2, #0]
        
        /* Synchronous or individual SDD update. */
        if ( INDIVIDUAL_UPDATE == sync_update )
    9522:	793b      	ldrb	r3, [r7, #4]
    9524:	2b00      	cmp	r3, #0
    9526:	d115      	bne.n	9554 <ACE_configure_sdd+0x170>
        {
            ACE->DAC_SYNC_CTRL &= ~dac_enable_masks_lut[sdd_id];
    9528:	f240 0300 	movw	r3, #0
    952c:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9530:	f240 0200 	movw	r2, #0
    9534:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9538:	6911      	ldr	r1, [r2, #16]
    953a:	79f8      	ldrb	r0, [r7, #7]
    953c:	f24d 02b8 	movw	r2, #53432	; 0xd0b8
    9540:	f2c0 0201 	movt	r2, #1
    9544:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
    9548:	ea6f 0202 	mvn.w	r2, r2
    954c:	ea01 0202 	and.w	r2, r1, r2
    9550:	611a      	str	r2, [r3, #16]
    9552:	e012      	b.n	957a <ACE_configure_sdd+0x196>
        }
        else
        {
            ACE->DAC_SYNC_CTRL |= dac_enable_masks_lut[sdd_id];
    9554:	f240 0300 	movw	r3, #0
    9558:	f2c4 0302 	movt	r3, #16386	; 0x4002
    955c:	f240 0200 	movw	r2, #0
    9560:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9564:	6911      	ldr	r1, [r2, #16]
    9566:	79f8      	ldrb	r0, [r7, #7]
    9568:	f24d 02b8 	movw	r2, #53432	; 0xd0b8
    956c:	f2c0 0201 	movt	r2, #1
    9570:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
    9574:	ea41 0202 	orr.w	r2, r1, r2
    9578:	611a      	str	r2, [r3, #16]
        }
    }
}
    957a:	f107 0718 	add.w	r7, r7, #24
    957e:	46bd      	mov	sp, r7
    9580:	bc90      	pop	{r4, r7}
    9582:	4770      	bx	lr

00009584 <ACE_enable_sdd>:
 */
void ACE_enable_sdd
(
	sdd_id_t    sdd_id
)
{
    9584:	b480      	push	{r7}
    9586:	b083      	sub	sp, #12
    9588:	af00      	add	r7, sp, #0
    958a:	4603      	mov	r3, r0
    958c:	71fb      	strb	r3, [r7, #7]
    ASSERT( sdd_id < NB_OF_SDD );
    958e:	79fb      	ldrb	r3, [r7, #7]
    9590:	2b02      	cmp	r3, #2
    9592:	d900      	bls.n	9596 <ACE_enable_sdd+0x12>
    9594:	be00      	bkpt	0x0000
    
    if ( sdd_id < NB_OF_SDD )
    9596:	79fb      	ldrb	r3, [r7, #7]
    9598:	2b02      	cmp	r3, #2
    959a:	d811      	bhi.n	95c0 <ACE_enable_sdd+0x3c>
    {
        *dac_ctrl_reg_lut[sdd_id] |= SDD_ENABLE_MASK;
    959c:	79fa      	ldrb	r2, [r7, #7]
    959e:	f24d 03ac 	movw	r3, #53420	; 0xd0ac
    95a2:	f2c0 0301 	movt	r3, #1
    95a6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    95aa:	79f9      	ldrb	r1, [r7, #7]
    95ac:	f24d 03ac 	movw	r3, #53420	; 0xd0ac
    95b0:	f2c0 0301 	movt	r3, #1
    95b4:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    95b8:	681b      	ldr	r3, [r3, #0]
    95ba:	f043 0320 	orr.w	r3, r3, #32
    95be:	6013      	str	r3, [r2, #0]
    }
}
    95c0:	f107 070c 	add.w	r7, r7, #12
    95c4:	46bd      	mov	sp, r7
    95c6:	bc80      	pop	{r7}
    95c8:	4770      	bx	lr
    95ca:	bf00      	nop

000095cc <ACE_disable_sdd>:
 */
void ACE_disable_sdd
(
	sdd_id_t    sdd_id
)
{
    95cc:	b480      	push	{r7}
    95ce:	b083      	sub	sp, #12
    95d0:	af00      	add	r7, sp, #0
    95d2:	4603      	mov	r3, r0
    95d4:	71fb      	strb	r3, [r7, #7]
    ASSERT( sdd_id < NB_OF_SDD );
    95d6:	79fb      	ldrb	r3, [r7, #7]
    95d8:	2b02      	cmp	r3, #2
    95da:	d900      	bls.n	95de <ACE_disable_sdd+0x12>
    95dc:	be00      	bkpt	0x0000
    
    if ( sdd_id < NB_OF_SDD )
    95de:	79fb      	ldrb	r3, [r7, #7]
    95e0:	2b02      	cmp	r3, #2
    95e2:	d811      	bhi.n	9608 <ACE_disable_sdd+0x3c>
    {
        *dac_ctrl_reg_lut[sdd_id] &= ~SDD_ENABLE_MASK;
    95e4:	79fa      	ldrb	r2, [r7, #7]
    95e6:	f24d 03ac 	movw	r3, #53420	; 0xd0ac
    95ea:	f2c0 0301 	movt	r3, #1
    95ee:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    95f2:	79f9      	ldrb	r1, [r7, #7]
    95f4:	f24d 03ac 	movw	r3, #53420	; 0xd0ac
    95f8:	f2c0 0301 	movt	r3, #1
    95fc:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    9600:	681b      	ldr	r3, [r3, #0]
    9602:	f023 0320 	bic.w	r3, r3, #32
    9606:	6013      	str	r3, [r2, #0]
    }
}
    9608:	f107 070c 	add.w	r7, r7, #12
    960c:	46bd      	mov	sp, r7
    960e:	bc80      	pop	{r7}
    9610:	4770      	bx	lr
    9612:	bf00      	nop

00009614 <ACE_set_sdd_value>:
void ACE_set_sdd_value
(
	sdd_id_t    sdd_id,
	uint32_t    sdd_value
)
{
    9614:	b480      	push	{r7}
    9616:	b083      	sub	sp, #12
    9618:	af00      	add	r7, sp, #0
    961a:	4603      	mov	r3, r0
    961c:	6039      	str	r1, [r7, #0]
    961e:	71fb      	strb	r3, [r7, #7]
    ASSERT( sdd_id < NB_OF_SDD );
    9620:	79fb      	ldrb	r3, [r7, #7]
    9622:	2b02      	cmp	r3, #2
    9624:	d900      	bls.n	9628 <ACE_set_sdd_value+0x14>
    9626:	be00      	bkpt	0x0000
    
    if ( sdd_id < NB_OF_SDD )
    9628:	79fb      	ldrb	r3, [r7, #7]
    962a:	2b02      	cmp	r3, #2
    962c:	d813      	bhi.n	9656 <ACE_set_sdd_value+0x42>
    {
        *dac_byte2_reg_lut[sdd_id] = sdd_value >> 16;
    962e:	79fa      	ldrb	r2, [r7, #7]
    9630:	f24d 03d0 	movw	r3, #53456	; 0xd0d0
    9634:	f2c0 0301 	movt	r3, #1
    9638:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    963c:	683a      	ldr	r2, [r7, #0]
    963e:	ea4f 4212 	mov.w	r2, r2, lsr #16
    9642:	601a      	str	r2, [r3, #0]
        *dac_byte01_reg_lut[sdd_id] = sdd_value;
    9644:	79fa      	ldrb	r2, [r7, #7]
    9646:	f24d 03c4 	movw	r3, #53444	; 0xd0c4
    964a:	f2c0 0301 	movt	r3, #1
    964e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    9652:	683a      	ldr	r2, [r7, #0]
    9654:	601a      	str	r2, [r3, #0]
    }
}
    9656:	f107 070c 	add.w	r7, r7, #12
    965a:	46bd      	mov	sp, r7
    965c:	bc80      	pop	{r7}
    965e:	4770      	bx	lr

00009660 <ACE_set_sdd_value_sync>:
(
    uint32_t sdd0_value,
    uint32_t sdd1_value,
    uint32_t sdd2_value
)
{
    9660:	b480      	push	{r7}
    9662:	b087      	sub	sp, #28
    9664:	af00      	add	r7, sp, #0
    9666:	60f8      	str	r0, [r7, #12]
    9668:	60b9      	str	r1, [r7, #8]
    966a:	607a      	str	r2, [r7, #4]
    uint32_t dac_sync_ctrl;
    
    dac_sync_ctrl = ACE->DAC_SYNC_CTRL;
    966c:	f240 0300 	movw	r3, #0
    9670:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9674:	691b      	ldr	r3, [r3, #16]
    9676:	617b      	str	r3, [r7, #20]
    
    if ( SDD_NO_UPDATE != sdd0_value )
    9678:	68fb      	ldr	r3, [r7, #12]
    967a:	f1b3 3fff 	cmp.w	r3, #4294967295
    967e:	d012      	beq.n	96a6 <ACE_set_sdd_value_sync+0x46>
    {
        ACE->DAC0_BYTE2 = sdd0_value >> 16;
    9680:	f240 0300 	movw	r3, #0
    9684:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9688:	68fa      	ldr	r2, [r7, #12]
    968a:	ea4f 4212 	mov.w	r2, r2, lsr #16
    968e:	66da      	str	r2, [r3, #108]	; 0x6c
        ACE->SSE_DAC0_BYTES01 = sdd0_value;
    9690:	f240 0300 	movw	r3, #0
    9694:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9698:	68fa      	ldr	r2, [r7, #12]
    969a:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
        dac_sync_ctrl |= DAC0_SYNC_UPDATE;
    969e:	697b      	ldr	r3, [r7, #20]
    96a0:	f043 0301 	orr.w	r3, r3, #1
    96a4:	617b      	str	r3, [r7, #20]
    }

    if ( SDD_NO_UPDATE != sdd1_value )
    96a6:	68bb      	ldr	r3, [r7, #8]
    96a8:	f1b3 3fff 	cmp.w	r3, #4294967295
    96ac:	d013      	beq.n	96d6 <ACE_set_sdd_value_sync+0x76>
    {
        ACE->DAC1_BYTE2 = sdd1_value >> 16;
    96ae:	f240 0300 	movw	r3, #0
    96b2:	f2c4 0302 	movt	r3, #16386	; 0x4002
    96b6:	68ba      	ldr	r2, [r7, #8]
    96b8:	ea4f 4212 	mov.w	r2, r2, lsr #16
    96bc:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
        ACE->SSE_DAC1_BYTES01 = sdd1_value;
    96c0:	f240 0300 	movw	r3, #0
    96c4:	f2c4 0302 	movt	r3, #16386	; 0x4002
    96c8:	68ba      	ldr	r2, [r7, #8]
    96ca:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
        dac_sync_ctrl |= DAC1_SYNC_UPDATE;
    96ce:	697b      	ldr	r3, [r7, #20]
    96d0:	f043 0302 	orr.w	r3, r3, #2
    96d4:	617b      	str	r3, [r7, #20]
    }

    if ( SDD_NO_UPDATE != sdd2_value )
    96d6:	687b      	ldr	r3, [r7, #4]
    96d8:	f1b3 3fff 	cmp.w	r3, #4294967295
    96dc:	d01c      	beq.n	9718 <ACE_set_sdd_value_sync+0xb8>
    {
        ACE->DAC2_BYTE2 = sdd2_value >> 16;
    96de:	f240 0300 	movw	r3, #0
    96e2:	f2c4 0302 	movt	r3, #16386	; 0x4002
    96e6:	687a      	ldr	r2, [r7, #4]
    96e8:	ea4f 4212 	mov.w	r2, r2, lsr #16
    96ec:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
        ACE->DAC2_BYTE1 = sdd2_value >> 8;
    96f0:	f240 0300 	movw	r3, #0
    96f4:	f2c4 0302 	movt	r3, #16386	; 0x4002
    96f8:	687a      	ldr	r2, [r7, #4]
    96fa:	ea4f 2212 	mov.w	r2, r2, lsr #8
    96fe:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
        ACE->SSE_DAC2_BYTES01 = sdd2_value;
    9702:	f240 0300 	movw	r3, #0
    9706:	f2c4 0302 	movt	r3, #16386	; 0x4002
    970a:	687a      	ldr	r2, [r7, #4]
    970c:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
        dac_sync_ctrl |= DAC2_SYNC_UPDATE;
    9710:	697b      	ldr	r3, [r7, #20]
    9712:	f043 0304 	orr.w	r3, r3, #4
    9716:	617b      	str	r3, [r7, #20]
    }
    
    ACE->DAC_SYNC_CTRL = dac_sync_ctrl;
    9718:	f240 0300 	movw	r3, #0
    971c:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9720:	697a      	ldr	r2, [r7, #20]
    9722:	611a      	str	r2, [r3, #16]
}
    9724:	f107 071c 	add.w	r7, r7, #28
    9728:	46bd      	mov	sp, r7
    972a:	bc80      	pop	{r7}
    972c:	4770      	bx	lr
    972e:	bf00      	nop

00009730 <ACE_set_comp_reference>:
void ACE_set_comp_reference
(
    comparator_id_t     comp_id,
    comp_reference_t    reference
)
{
    9730:	b480      	push	{r7}
    9732:	b087      	sub	sp, #28
    9734:	af00      	add	r7, sp, #0
    9736:	4602      	mov	r2, r0
    9738:	460b      	mov	r3, r1
    973a:	71fa      	strb	r2, [r7, #7]
    973c:	71bb      	strb	r3, [r7, #6]
    uint8_t scb_id;
    uint32_t odd;
    
    odd = (uint32_t)comp_id & 0x01u;
    973e:	79fb      	ldrb	r3, [r7, #7]
    9740:	f003 0301 	and.w	r3, r3, #1
    9744:	613b      	str	r3, [r7, #16]
    
    ASSERT( comp_id < NB_OF_COMPARATORS );
    9746:	79fb      	ldrb	r3, [r7, #7]
    9748:	2b09      	cmp	r3, #9
    974a:	d900      	bls.n	974e <ACE_set_comp_reference+0x1e>
    974c:	be00      	bkpt	0x0000
    ASSERT( reference < NB_OF_COMP_REF );
    974e:	79bb      	ldrb	r3, [r7, #6]
    9750:	2b03      	cmp	r3, #3
    9752:	d900      	bls.n	9756 <ACE_set_comp_reference+0x26>
    9754:	be00      	bkpt	0x0000
    ASSERT( odd );    /* Only Temperature block comparators have configurable reference input. */
    9756:	693b      	ldr	r3, [r7, #16]
    9758:	2b00      	cmp	r3, #0
    975a:	d100      	bne.n	975e <ACE_set_comp_reference+0x2e>
    975c:	be00      	bkpt	0x0000
    
    if ( (comp_id < NB_OF_COMPARATORS) && (reference < NB_OF_COMP_REF) && (odd) )
    975e:	79fb      	ldrb	r3, [r7, #7]
    9760:	2b09      	cmp	r3, #9
    9762:	f200 80b9 	bhi.w	98d8 <ACE_set_comp_reference+0x1a8>
    9766:	79bb      	ldrb	r3, [r7, #6]
    9768:	2b03      	cmp	r3, #3
    976a:	f200 80b5 	bhi.w	98d8 <ACE_set_comp_reference+0x1a8>
    976e:	693b      	ldr	r3, [r7, #16]
    9770:	2b00      	cmp	r3, #0
    9772:	f000 80b1 	beq.w	98d8 <ACE_set_comp_reference+0x1a8>
    {
        uint32_t saved_pc2_ctrl;
        
        scb_id = comp_id_2_scb_lut[comp_id];
    9776:	79fa      	ldrb	r2, [r7, #7]
    9778:	f24d 03e0 	movw	r3, #53472	; 0xd0e0
    977c:	f2c0 0301 	movt	r3, #1
    9780:	5c9b      	ldrb	r3, [r3, r2]
    9782:	73fb      	strb	r3, [r7, #15]
        
        /* Pause the SSE PC2 while accesses to ACB from APB3 are taking place. */
        saved_pc2_ctrl = ACE->PC2_CTRL;
    9784:	f240 0300 	movw	r3, #0
    9788:	f2c4 0302 	movt	r3, #16386	; 0x4002
    978c:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
    9790:	617b      	str	r3, [r7, #20]
        ACE->PC2_CTRL = 0u;
    9792:	f240 0300 	movw	r3, #0
    9796:	f2c4 0302 	movt	r3, #16386	; 0x4002
    979a:	f04f 0200 	mov.w	r2, #0
    979e:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    
        if ( ADC_IN_COMP_REF == reference )
    97a2:	79bb      	ldrb	r3, [r7, #6]
    97a4:	2b03      	cmp	r3, #3
    97a6:	d146      	bne.n	9836 <ACE_set_comp_reference+0x106>
        {
            ACE->ACB_DATA[scb_id].b10 &= (uint8_t)~B10_COMP_VREF_SW_MASK;
    97a8:	f240 0100 	movw	r1, #0
    97ac:	f2c4 0102 	movt	r1, #16386	; 0x4002
    97b0:	7bf8      	ldrb	r0, [r7, #15]
    97b2:	f240 0200 	movw	r2, #0
    97b6:	f2c4 0202 	movt	r2, #16386	; 0x4002
    97ba:	f897 c00f 	ldrb.w	ip, [r7, #15]
    97be:	4663      	mov	r3, ip
    97c0:	ea4f 0343 	mov.w	r3, r3, lsl #1
    97c4:	4463      	add	r3, ip
    97c6:	ea4f 1303 	mov.w	r3, r3, lsl #4
    97ca:	4413      	add	r3, r2
    97cc:	f503 730a 	add.w	r3, r3, #552	; 0x228
    97d0:	791b      	ldrb	r3, [r3, #4]
    97d2:	b2db      	uxtb	r3, r3
    97d4:	461a      	mov	r2, r3
    97d6:	f002 02df 	and.w	r2, r2, #223	; 0xdf
    97da:	4603      	mov	r3, r0
    97dc:	ea4f 0343 	mov.w	r3, r3, lsl #1
    97e0:	4403      	add	r3, r0
    97e2:	ea4f 1303 	mov.w	r3, r3, lsl #4
    97e6:	440b      	add	r3, r1
    97e8:	f503 730a 	add.w	r3, r3, #552	; 0x228
    97ec:	711a      	strb	r2, [r3, #4]
            ACE->ACB_DATA[scb_id].b11 &= (uint8_t)~B11_DAC_MUXSEL_MASK;
    97ee:	f240 0100 	movw	r1, #0
    97f2:	f2c4 0102 	movt	r1, #16386	; 0x4002
    97f6:	7bf8      	ldrb	r0, [r7, #15]
    97f8:	f240 0200 	movw	r2, #0
    97fc:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9800:	f897 c00f 	ldrb.w	ip, [r7, #15]
    9804:	4663      	mov	r3, ip
    9806:	ea4f 0343 	mov.w	r3, r3, lsl #1
    980a:	4463      	add	r3, ip
    980c:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9810:	4413      	add	r3, r2
    9812:	f503 730a 	add.w	r3, r3, #552	; 0x228
    9816:	7a1b      	ldrb	r3, [r3, #8]
    9818:	b2db      	uxtb	r3, r3
    981a:	461a      	mov	r2, r3
    981c:	f002 02fc 	and.w	r2, r2, #252	; 0xfc
    9820:	4603      	mov	r3, r0
    9822:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9826:	4403      	add	r3, r0
    9828:	ea4f 1303 	mov.w	r3, r3, lsl #4
    982c:	440b      	add	r3, r1
    982e:	f503 730a 	add.w	r3, r3, #552	; 0x228
    9832:	721a      	strb	r2, [r3, #8]
    9834:	e049      	b.n	98ca <ACE_set_comp_reference+0x19a>
        }
        else
        {
            ACE->ACB_DATA[scb_id].b10 |= (uint8_t)B10_COMP_VREF_SW_MASK;
    9836:	f240 0200 	movw	r2, #0
    983a:	f2c4 0202 	movt	r2, #16386	; 0x4002
    983e:	7bf8      	ldrb	r0, [r7, #15]
    9840:	f240 0100 	movw	r1, #0
    9844:	f2c4 0102 	movt	r1, #16386	; 0x4002
    9848:	f897 c00f 	ldrb.w	ip, [r7, #15]
    984c:	4663      	mov	r3, ip
    984e:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9852:	4463      	add	r3, ip
    9854:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9858:	440b      	add	r3, r1
    985a:	f503 730a 	add.w	r3, r3, #552	; 0x228
    985e:	791b      	ldrb	r3, [r3, #4]
    9860:	b2db      	uxtb	r3, r3
    9862:	f043 0320 	orr.w	r3, r3, #32
    9866:	b2d9      	uxtb	r1, r3
    9868:	4603      	mov	r3, r0
    986a:	ea4f 0343 	mov.w	r3, r3, lsl #1
    986e:	4403      	add	r3, r0
    9870:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9874:	4413      	add	r3, r2
    9876:	f503 730a 	add.w	r3, r3, #552	; 0x228
    987a:	460a      	mov	r2, r1
    987c:	711a      	strb	r2, [r3, #4]
            ACE->ACB_DATA[scb_id].b11 = (ACE->ACB_DATA[scb_id].b11 & (uint8_t)~B11_DAC_MUXSEL_MASK) + (uint8_t)reference;
    987e:	f240 0200 	movw	r2, #0
    9882:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9886:	7bf8      	ldrb	r0, [r7, #15]
    9888:	f240 0100 	movw	r1, #0
    988c:	f2c4 0102 	movt	r1, #16386	; 0x4002
    9890:	f897 c00f 	ldrb.w	ip, [r7, #15]
    9894:	4663      	mov	r3, ip
    9896:	ea4f 0343 	mov.w	r3, r3, lsl #1
    989a:	4463      	add	r3, ip
    989c:	ea4f 1303 	mov.w	r3, r3, lsl #4
    98a0:	440b      	add	r3, r1
    98a2:	f503 730a 	add.w	r3, r3, #552	; 0x228
    98a6:	7a1b      	ldrb	r3, [r3, #8]
    98a8:	b2db      	uxtb	r3, r3
    98aa:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
    98ae:	79b9      	ldrb	r1, [r7, #6]
    98b0:	440b      	add	r3, r1
    98b2:	b2d9      	uxtb	r1, r3
    98b4:	4603      	mov	r3, r0
    98b6:	ea4f 0343 	mov.w	r3, r3, lsl #1
    98ba:	4403      	add	r3, r0
    98bc:	ea4f 1303 	mov.w	r3, r3, lsl #4
    98c0:	4413      	add	r3, r2
    98c2:	f503 730a 	add.w	r3, r3, #552	; 0x228
    98c6:	460a      	mov	r2, r1
    98c8:	721a      	strb	r2, [r3, #8]
        }
    
        /* Restore SSE PC2 operations since no ACB accesses should take place
         * beyond this point. */
        ACE->PC2_CTRL = saved_pc2_ctrl;
    98ca:	f240 0300 	movw	r3, #0
    98ce:	f2c4 0302 	movt	r3, #16386	; 0x4002
    98d2:	697a      	ldr	r2, [r7, #20]
    98d4:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    }
}
    98d8:	f107 071c 	add.w	r7, r7, #28
    98dc:	46bd      	mov	sp, r7
    98de:	bc80      	pop	{r7}
    98e0:	4770      	bx	lr
    98e2:	bf00      	nop

000098e4 <ACE_set_comp_hysteresis>:
void ACE_set_comp_hysteresis
(
	comparator_id_t     comp_id,
    comp_hysteresis_t   hysteresis
)
{
    98e4:	b480      	push	{r7}
    98e6:	b087      	sub	sp, #28
    98e8:	af00      	add	r7, sp, #0
    98ea:	4602      	mov	r2, r0
    98ec:	460b      	mov	r3, r1
    98ee:	71fa      	strb	r2, [r7, #7]
    98f0:	71bb      	strb	r3, [r7, #6]
    uint8_t scb_id;
    
    ASSERT( comp_id < NB_OF_COMPARATORS );
    98f2:	79fb      	ldrb	r3, [r7, #7]
    98f4:	2b09      	cmp	r3, #9
    98f6:	d900      	bls.n	98fa <ACE_set_comp_hysteresis+0x16>
    98f8:	be00      	bkpt	0x0000
    ASSERT( hysteresis < NB_OF_HYSTERESIS );
    98fa:	79bb      	ldrb	r3, [r7, #6]
    98fc:	2b03      	cmp	r3, #3
    98fe:	d900      	bls.n	9902 <ACE_set_comp_hysteresis+0x1e>
    9900:	be00      	bkpt	0x0000
    
    if ( (comp_id < NB_OF_COMPARATORS) && (hysteresis < NB_OF_HYSTERESIS) )
    9902:	79fb      	ldrb	r3, [r7, #7]
    9904:	2b09      	cmp	r3, #9
    9906:	d87b      	bhi.n	9a00 <ACE_set_comp_hysteresis+0x11c>
    9908:	79bb      	ldrb	r3, [r7, #6]
    990a:	2b03      	cmp	r3, #3
    990c:	d878      	bhi.n	9a00 <ACE_set_comp_hysteresis+0x11c>
    {
        uint32_t odd;
        uint32_t saved_pc2_ctrl;
        
        scb_id = comp_id_2_scb_lut[comp_id];
    990e:	79fa      	ldrb	r2, [r7, #7]
    9910:	f24d 03e0 	movw	r3, #53472	; 0xd0e0
    9914:	f2c0 0301 	movt	r3, #1
    9918:	5c9b      	ldrb	r3, [r3, r2]
    991a:	73fb      	strb	r3, [r7, #15]
        odd = (uint32_t)comp_id & 0x01u;
    991c:	79fb      	ldrb	r3, [r7, #7]
    991e:	f003 0301 	and.w	r3, r3, #1
    9922:	613b      	str	r3, [r7, #16]
        
        /* Pause the SSE PC2 while accesses to ACB from APB3 are taking place. */
        saved_pc2_ctrl = ACE->PC2_CTRL;
    9924:	f240 0300 	movw	r3, #0
    9928:	f2c4 0302 	movt	r3, #16386	; 0x4002
    992c:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
    9930:	617b      	str	r3, [r7, #20]
        ACE->PC2_CTRL = 0u;
    9932:	f240 0300 	movw	r3, #0
    9936:	f2c4 0302 	movt	r3, #16386	; 0x4002
    993a:	f04f 0200 	mov.w	r2, #0
    993e:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    
        if ( odd )
    9942:	693b      	ldr	r3, [r7, #16]
    9944:	2b00      	cmp	r3, #0
    9946:	d02a      	beq.n	999e <ACE_set_comp_hysteresis+0xba>
        {
            /* Temperature monitor block comparator. */
            ACE->ACB_DATA[scb_id].b10 = (ACE->ACB_DATA[scb_id].b10 & ~HYSTERESIS_MASK) | (uint8_t)((uint8_t)hysteresis << HYSTERESIS_SHIFT);
    9948:	f240 0200 	movw	r2, #0
    994c:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9950:	7bf8      	ldrb	r0, [r7, #15]
    9952:	f240 0100 	movw	r1, #0
    9956:	f2c4 0102 	movt	r1, #16386	; 0x4002
    995a:	f897 c00f 	ldrb.w	ip, [r7, #15]
    995e:	4663      	mov	r3, ip
    9960:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9964:	4463      	add	r3, ip
    9966:	ea4f 1303 	mov.w	r3, r3, lsl #4
    996a:	440b      	add	r3, r1
    996c:	f503 730a 	add.w	r3, r3, #552	; 0x228
    9970:	791b      	ldrb	r3, [r3, #4]
    9972:	b2db      	uxtb	r3, r3
    9974:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    9978:	79b9      	ldrb	r1, [r7, #6]
    997a:	ea4f 1181 	mov.w	r1, r1, lsl #6
    997e:	b2c9      	uxtb	r1, r1
    9980:	ea43 0301 	orr.w	r3, r3, r1
    9984:	b2d9      	uxtb	r1, r3
    9986:	4603      	mov	r3, r0
    9988:	ea4f 0343 	mov.w	r3, r3, lsl #1
    998c:	4403      	add	r3, r0
    998e:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9992:	4413      	add	r3, r2
    9994:	f503 730a 	add.w	r3, r3, #552	; 0x228
    9998:	460a      	mov	r2, r1
    999a:	711a      	strb	r2, [r3, #4]
    999c:	e029      	b.n	99f2 <ACE_set_comp_hysteresis+0x10e>
        }
        else
        {
            /* Current monitor block comparator. */
            ACE->ACB_DATA[scb_id].b9 = (ACE->ACB_DATA[scb_id].b9 & ~HYSTERESIS_MASK) | (uint8_t)((uint8_t)hysteresis << HYSTERESIS_SHIFT);
    999e:	f240 0200 	movw	r2, #0
    99a2:	f2c4 0202 	movt	r2, #16386	; 0x4002
    99a6:	7bf8      	ldrb	r0, [r7, #15]
    99a8:	f240 0100 	movw	r1, #0
    99ac:	f2c4 0102 	movt	r1, #16386	; 0x4002
    99b0:	f897 c00f 	ldrb.w	ip, [r7, #15]
    99b4:	4663      	mov	r3, ip
    99b6:	ea4f 0343 	mov.w	r3, r3, lsl #1
    99ba:	4463      	add	r3, ip
    99bc:	ea4f 1303 	mov.w	r3, r3, lsl #4
    99c0:	440b      	add	r3, r1
    99c2:	f503 7308 	add.w	r3, r3, #544	; 0x220
    99c6:	7a1b      	ldrb	r3, [r3, #8]
    99c8:	b2db      	uxtb	r3, r3
    99ca:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    99ce:	79b9      	ldrb	r1, [r7, #6]
    99d0:	ea4f 1181 	mov.w	r1, r1, lsl #6
    99d4:	b2c9      	uxtb	r1, r1
    99d6:	ea43 0301 	orr.w	r3, r3, r1
    99da:	b2d9      	uxtb	r1, r3
    99dc:	4603      	mov	r3, r0
    99de:	ea4f 0343 	mov.w	r3, r3, lsl #1
    99e2:	4403      	add	r3, r0
    99e4:	ea4f 1303 	mov.w	r3, r3, lsl #4
    99e8:	4413      	add	r3, r2
    99ea:	f503 7308 	add.w	r3, r3, #544	; 0x220
    99ee:	460a      	mov	r2, r1
    99f0:	721a      	strb	r2, [r3, #8]
        }
        
        /* Restore SSE PC2 operations since no ACB accesses should take place
         * beyond this point. */
        ACE->PC2_CTRL = saved_pc2_ctrl;
    99f2:	f240 0300 	movw	r3, #0
    99f6:	f2c4 0302 	movt	r3, #16386	; 0x4002
    99fa:	697a      	ldr	r2, [r7, #20]
    99fc:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    }
}
    9a00:	f107 071c 	add.w	r7, r7, #28
    9a04:	46bd      	mov	sp, r7
    9a06:	bc80      	pop	{r7}
    9a08:	4770      	bx	lr
    9a0a:	bf00      	nop

00009a0c <ACE_enable_comp>:
 */
void ACE_enable_comp
(
	comparator_id_t comp_id
)
{
    9a0c:	b480      	push	{r7}
    9a0e:	b087      	sub	sp, #28
    9a10:	af00      	add	r7, sp, #0
    9a12:	4603      	mov	r3, r0
    9a14:	71fb      	strb	r3, [r7, #7]
    uint8_t scb_id;
    
    ASSERT( comp_id < NB_OF_COMPARATORS );
    9a16:	79fb      	ldrb	r3, [r7, #7]
    9a18:	2b09      	cmp	r3, #9
    9a1a:	d900      	bls.n	9a1e <ACE_enable_comp+0x12>
    9a1c:	be00      	bkpt	0x0000
    
    if ( comp_id < NB_OF_COMPARATORS )
    9a1e:	79fb      	ldrb	r3, [r7, #7]
    9a20:	2b09      	cmp	r3, #9
    9a22:	d86c      	bhi.n	9afe <ACE_enable_comp+0xf2>
    {
        uint32_t odd;
        uint32_t saved_pc2_ctrl;
        
        scb_id = comp_id_2_scb_lut[comp_id];
    9a24:	79fa      	ldrb	r2, [r7, #7]
    9a26:	f24d 03e0 	movw	r3, #53472	; 0xd0e0
    9a2a:	f2c0 0301 	movt	r3, #1
    9a2e:	5c9b      	ldrb	r3, [r3, r2]
    9a30:	73fb      	strb	r3, [r7, #15]
        odd = (uint32_t)comp_id & 0x01u;
    9a32:	79fb      	ldrb	r3, [r7, #7]
    9a34:	f003 0301 	and.w	r3, r3, #1
    9a38:	613b      	str	r3, [r7, #16]
        
        /* Pause the SSE PC2 while accesses to ACB from APB3 are taking place. */
        saved_pc2_ctrl = ACE->PC2_CTRL;
    9a3a:	f240 0300 	movw	r3, #0
    9a3e:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9a42:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
    9a46:	617b      	str	r3, [r7, #20]
        ACE->PC2_CTRL = 0u;
    9a48:	f240 0300 	movw	r3, #0
    9a4c:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9a50:	f04f 0200 	mov.w	r2, #0
    9a54:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
        
        if ( odd )
    9a58:	693b      	ldr	r3, [r7, #16]
    9a5a:	2b00      	cmp	r3, #0
    9a5c:	d024      	beq.n	9aa8 <ACE_enable_comp+0x9c>
        {
            /* Temperature monitor block comparator. */
            ACE->ACB_DATA[scb_id].b10 |= COMPARATOR_ENABLE_MASK;
    9a5e:	f240 0200 	movw	r2, #0
    9a62:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9a66:	7bf8      	ldrb	r0, [r7, #15]
    9a68:	f240 0100 	movw	r1, #0
    9a6c:	f2c4 0102 	movt	r1, #16386	; 0x4002
    9a70:	f897 c00f 	ldrb.w	ip, [r7, #15]
    9a74:	4663      	mov	r3, ip
    9a76:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9a7a:	4463      	add	r3, ip
    9a7c:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9a80:	440b      	add	r3, r1
    9a82:	f503 730a 	add.w	r3, r3, #552	; 0x228
    9a86:	791b      	ldrb	r3, [r3, #4]
    9a88:	b2db      	uxtb	r3, r3
    9a8a:	f043 0310 	orr.w	r3, r3, #16
    9a8e:	b2d9      	uxtb	r1, r3
    9a90:	4603      	mov	r3, r0
    9a92:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9a96:	4403      	add	r3, r0
    9a98:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9a9c:	4413      	add	r3, r2
    9a9e:	f503 730a 	add.w	r3, r3, #552	; 0x228
    9aa2:	460a      	mov	r2, r1
    9aa4:	711a      	strb	r2, [r3, #4]
    9aa6:	e023      	b.n	9af0 <ACE_enable_comp+0xe4>
        }
        else
        {
            /* Current monitor block comparator. */
            ACE->ACB_DATA[scb_id].b9 |= COMPARATOR_ENABLE_MASK;
    9aa8:	f240 0200 	movw	r2, #0
    9aac:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9ab0:	7bf8      	ldrb	r0, [r7, #15]
    9ab2:	f240 0100 	movw	r1, #0
    9ab6:	f2c4 0102 	movt	r1, #16386	; 0x4002
    9aba:	f897 c00f 	ldrb.w	ip, [r7, #15]
    9abe:	4663      	mov	r3, ip
    9ac0:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9ac4:	4463      	add	r3, ip
    9ac6:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9aca:	440b      	add	r3, r1
    9acc:	f503 7308 	add.w	r3, r3, #544	; 0x220
    9ad0:	7a1b      	ldrb	r3, [r3, #8]
    9ad2:	b2db      	uxtb	r3, r3
    9ad4:	f043 0310 	orr.w	r3, r3, #16
    9ad8:	b2d9      	uxtb	r1, r3
    9ada:	4603      	mov	r3, r0
    9adc:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9ae0:	4403      	add	r3, r0
    9ae2:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9ae6:	4413      	add	r3, r2
    9ae8:	f503 7308 	add.w	r3, r3, #544	; 0x220
    9aec:	460a      	mov	r2, r1
    9aee:	721a      	strb	r2, [r3, #8]
        }
        
        /* Restore SSE PC2 operations since no ACB accesses should take place
         * beyond this point. */
        ACE->PC2_CTRL = saved_pc2_ctrl;
    9af0:	f240 0300 	movw	r3, #0
    9af4:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9af8:	697a      	ldr	r2, [r7, #20]
    9afa:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    }
}
    9afe:	f107 071c 	add.w	r7, r7, #28
    9b02:	46bd      	mov	sp, r7
    9b04:	bc80      	pop	{r7}
    9b06:	4770      	bx	lr

00009b08 <ACE_disable_comp>:
 */
void ACE_disable_comp
(
	comparator_id_t comp_id
)
{
    9b08:	b480      	push	{r7}
    9b0a:	b087      	sub	sp, #28
    9b0c:	af00      	add	r7, sp, #0
    9b0e:	4603      	mov	r3, r0
    9b10:	71fb      	strb	r3, [r7, #7]
    uint8_t scb_id;
    
    ASSERT( comp_id < NB_OF_COMPARATORS );
    9b12:	79fb      	ldrb	r3, [r7, #7]
    9b14:	2b09      	cmp	r3, #9
    9b16:	d900      	bls.n	9b1a <ACE_disable_comp+0x12>
    9b18:	be00      	bkpt	0x0000
    
    if ( comp_id < NB_OF_COMPARATORS )
    9b1a:	79fb      	ldrb	r3, [r7, #7]
    9b1c:	2b09      	cmp	r3, #9
    9b1e:	d86a      	bhi.n	9bf6 <ACE_disable_comp+0xee>
    {
        uint32_t odd;
        uint32_t saved_pc2_ctrl;
        
        scb_id = comp_id_2_scb_lut[comp_id];
    9b20:	79fa      	ldrb	r2, [r7, #7]
    9b22:	f24d 03e0 	movw	r3, #53472	; 0xd0e0
    9b26:	f2c0 0301 	movt	r3, #1
    9b2a:	5c9b      	ldrb	r3, [r3, r2]
    9b2c:	73fb      	strb	r3, [r7, #15]
        odd = (uint32_t)comp_id & 0x01u;
    9b2e:	79fb      	ldrb	r3, [r7, #7]
    9b30:	f003 0301 	and.w	r3, r3, #1
    9b34:	613b      	str	r3, [r7, #16]
        
        /* Pause the SSE PC2 while accesses to ACB from APB3 are taking place. */
        saved_pc2_ctrl = ACE->PC2_CTRL;
    9b36:	f240 0300 	movw	r3, #0
    9b3a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9b3e:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
    9b42:	617b      	str	r3, [r7, #20]
        ACE->PC2_CTRL = 0u;
    9b44:	f240 0300 	movw	r3, #0
    9b48:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9b4c:	f04f 0200 	mov.w	r2, #0
    9b50:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
        
        if ( odd )
    9b54:	693b      	ldr	r3, [r7, #16]
    9b56:	2b00      	cmp	r3, #0
    9b58:	d023      	beq.n	9ba2 <ACE_disable_comp+0x9a>
        {
            /* Temperature monitor block comparator. */
            ACE->ACB_DATA[scb_id].b10 &= (uint8_t)~COMPARATOR_ENABLE_MASK;
    9b5a:	f240 0100 	movw	r1, #0
    9b5e:	f2c4 0102 	movt	r1, #16386	; 0x4002
    9b62:	7bf8      	ldrb	r0, [r7, #15]
    9b64:	f240 0200 	movw	r2, #0
    9b68:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9b6c:	f897 c00f 	ldrb.w	ip, [r7, #15]
    9b70:	4663      	mov	r3, ip
    9b72:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9b76:	4463      	add	r3, ip
    9b78:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9b7c:	4413      	add	r3, r2
    9b7e:	f503 730a 	add.w	r3, r3, #552	; 0x228
    9b82:	791b      	ldrb	r3, [r3, #4]
    9b84:	b2db      	uxtb	r3, r3
    9b86:	461a      	mov	r2, r3
    9b88:	f002 02ef 	and.w	r2, r2, #239	; 0xef
    9b8c:	4603      	mov	r3, r0
    9b8e:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9b92:	4403      	add	r3, r0
    9b94:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9b98:	440b      	add	r3, r1
    9b9a:	f503 730a 	add.w	r3, r3, #552	; 0x228
    9b9e:	711a      	strb	r2, [r3, #4]
    9ba0:	e022      	b.n	9be8 <ACE_disable_comp+0xe0>
        }
        else
        {
            /* Current monitor block comparator. */
            ACE->ACB_DATA[scb_id].b9 &= (uint8_t)~COMPARATOR_ENABLE_MASK;
    9ba2:	f240 0100 	movw	r1, #0
    9ba6:	f2c4 0102 	movt	r1, #16386	; 0x4002
    9baa:	7bf8      	ldrb	r0, [r7, #15]
    9bac:	f240 0200 	movw	r2, #0
    9bb0:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9bb4:	f897 c00f 	ldrb.w	ip, [r7, #15]
    9bb8:	4663      	mov	r3, ip
    9bba:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9bbe:	4463      	add	r3, ip
    9bc0:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9bc4:	4413      	add	r3, r2
    9bc6:	f503 7308 	add.w	r3, r3, #544	; 0x220
    9bca:	7a1b      	ldrb	r3, [r3, #8]
    9bcc:	b2db      	uxtb	r3, r3
    9bce:	461a      	mov	r2, r3
    9bd0:	f002 02ef 	and.w	r2, r2, #239	; 0xef
    9bd4:	4603      	mov	r3, r0
    9bd6:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9bda:	4403      	add	r3, r0
    9bdc:	ea4f 1303 	mov.w	r3, r3, lsl #4
    9be0:	440b      	add	r3, r1
    9be2:	f503 7308 	add.w	r3, r3, #544	; 0x220
    9be6:	721a      	strb	r2, [r3, #8]
        }
        
        /* Restore SSE PC2 operations since no ACB accesses should take place
         * beyond this point. */
        ACE->PC2_CTRL = saved_pc2_ctrl;
    9be8:	f240 0300 	movw	r3, #0
    9bec:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9bf0:	697a      	ldr	r2, [r7, #20]
    9bf2:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    }
}
    9bf6:	f107 071c 	add.w	r7, r7, #28
    9bfa:	46bd      	mov	sp, r7
    9bfc:	bc80      	pop	{r7}
    9bfe:	4770      	bx	lr

00009c00 <ACE_enable_comp_rise_irq>:
 */
void ACE_enable_comp_rise_irq
(
	comparator_id_t comp_id
)
{
    9c00:	b480      	push	{r7}
    9c02:	b083      	sub	sp, #12
    9c04:	af00      	add	r7, sp, #0
    9c06:	4603      	mov	r3, r0
    9c08:	71fb      	strb	r3, [r7, #7]
    ASSERT( comp_id < NB_OF_COMPARATORS );
    9c0a:	79fb      	ldrb	r3, [r7, #7]
    9c0c:	2b09      	cmp	r3, #9
    9c0e:	d900      	bls.n	9c12 <ACE_enable_comp_rise_irq+0x12>
    9c10:	be00      	bkpt	0x0000
    
    ACE->COMP_IRQ_EN |= (uint32_t)(FIRST_RISE_IRQ_MASK << (uint32_t)comp_id);
    9c12:	f240 0300 	movw	r3, #0
    9c16:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9c1a:	f240 0200 	movw	r2, #0
    9c1e:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9c22:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    9c26:	f102 020c 	add.w	r2, r2, #12
    9c2a:	6811      	ldr	r1, [r2, #0]
    9c2c:	79fa      	ldrb	r2, [r7, #7]
    9c2e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    9c32:	fa00 f202 	lsl.w	r2, r0, r2
    9c36:	ea41 0202 	orr.w	r2, r1, r2
    9c3a:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    9c3e:	f103 030c 	add.w	r3, r3, #12
    9c42:	601a      	str	r2, [r3, #0]
}
    9c44:	f107 070c 	add.w	r7, r7, #12
    9c48:	46bd      	mov	sp, r7
    9c4a:	bc80      	pop	{r7}
    9c4c:	4770      	bx	lr
    9c4e:	bf00      	nop

00009c50 <ACE_disable_comp_rise_irq>:
 */
void ACE_disable_comp_rise_irq
(
	comparator_id_t comp_id
)
{
    9c50:	b480      	push	{r7}
    9c52:	b085      	sub	sp, #20
    9c54:	af00      	add	r7, sp, #0
    9c56:	4603      	mov	r3, r0
    9c58:	71fb      	strb	r3, [r7, #7]
    volatile uint32_t dummy_read;
    
    ASSERT( comp_id < NB_OF_COMPARATORS );
    9c5a:	79fb      	ldrb	r3, [r7, #7]
    9c5c:	2b09      	cmp	r3, #9
    9c5e:	d900      	bls.n	9c62 <ACE_disable_comp_rise_irq+0x12>
    9c60:	be00      	bkpt	0x0000
    
    ACE->COMP_IRQ_EN &= ~(FIRST_RISE_IRQ_MASK << (uint32_t)comp_id);
    9c62:	f240 0300 	movw	r3, #0
    9c66:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9c6a:	f240 0200 	movw	r2, #0
    9c6e:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9c72:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    9c76:	f102 020c 	add.w	r2, r2, #12
    9c7a:	6811      	ldr	r1, [r2, #0]
    9c7c:	79fa      	ldrb	r2, [r7, #7]
    9c7e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    9c82:	fa00 f202 	lsl.w	r2, r0, r2
    9c86:	ea6f 0202 	mvn.w	r2, r2
    9c8a:	ea01 0202 	and.w	r2, r1, r2
    9c8e:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    9c92:	f103 030c 	add.w	r3, r3, #12
    9c96:	601a      	str	r2, [r3, #0]
    /*
     * Ensure that the posted write to the COMP_IRQ_EN register completed before
     * returning from this function. Not doing this may result in the interrupt
     * only being disabled some time after this function returns.
     */
    dummy_read = ACE->COMP_IRQ_EN;
    9c98:	f240 0300 	movw	r3, #0
    9c9c:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9ca0:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    9ca4:	f103 030c 	add.w	r3, r3, #12
    9ca8:	681b      	ldr	r3, [r3, #0]
    9caa:	60fb      	str	r3, [r7, #12]
    ++dummy_read;
    9cac:	68fb      	ldr	r3, [r7, #12]
    9cae:	f103 0301 	add.w	r3, r3, #1
    9cb2:	60fb      	str	r3, [r7, #12]
}
    9cb4:	f107 0714 	add.w	r7, r7, #20
    9cb8:	46bd      	mov	sp, r7
    9cba:	bc80      	pop	{r7}
    9cbc:	4770      	bx	lr
    9cbe:	bf00      	nop

00009cc0 <ACE_clear_comp_rise_irq>:
 */
void ACE_clear_comp_rise_irq
(
	comparator_id_t comp_id
)
{
    9cc0:	b480      	push	{r7}
    9cc2:	b085      	sub	sp, #20
    9cc4:	af00      	add	r7, sp, #0
    9cc6:	4603      	mov	r3, r0
    9cc8:	71fb      	strb	r3, [r7, #7]
    volatile uint32_t dummy_read;
    
    ASSERT( comp_id < NB_OF_COMPARATORS );
    9cca:	79fb      	ldrb	r3, [r7, #7]
    9ccc:	2b09      	cmp	r3, #9
    9cce:	d900      	bls.n	9cd2 <ACE_clear_comp_rise_irq+0x12>
    9cd0:	be00      	bkpt	0x0000
    
    ACE->COMP_IRQ_CLR |= (FIRST_RISE_IRQ_MASK << (uint32_t)comp_id);
    9cd2:	f240 0300 	movw	r3, #0
    9cd6:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9cda:	f240 0200 	movw	r2, #0
    9cde:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9ce2:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    9ce6:	f102 0214 	add.w	r2, r2, #20
    9cea:	6811      	ldr	r1, [r2, #0]
    9cec:	79fa      	ldrb	r2, [r7, #7]
    9cee:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    9cf2:	fa00 f202 	lsl.w	r2, r0, r2
    9cf6:	ea41 0202 	orr.w	r2, r1, r2
    9cfa:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    9cfe:	f103 0314 	add.w	r3, r3, #20
    9d02:	601a      	str	r2, [r3, #0]
     * Ensure that the posted write to the COMP_IRQ_CLR register completed before
     * returning from this function. Not doing this may result in the interrupt
     * retriggering if the Cortex-M3 returns from interrupt before the posted
     * write completes.
     */
    dummy_read = ACE->COMP_IRQ_CLR;
    9d04:	f240 0300 	movw	r3, #0
    9d08:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9d0c:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    9d10:	f103 0314 	add.w	r3, r3, #20
    9d14:	681b      	ldr	r3, [r3, #0]
    9d16:	60fb      	str	r3, [r7, #12]
    ++dummy_read;
    9d18:	68fb      	ldr	r3, [r7, #12]
    9d1a:	f103 0301 	add.w	r3, r3, #1
    9d1e:	60fb      	str	r3, [r7, #12]
}
    9d20:	f107 0714 	add.w	r7, r7, #20
    9d24:	46bd      	mov	sp, r7
    9d26:	bc80      	pop	{r7}
    9d28:	4770      	bx	lr
    9d2a:	bf00      	nop

00009d2c <ACE_enable_comp_fall_irq>:
 */
void ACE_enable_comp_fall_irq
(
	comparator_id_t comp_id
)
{
    9d2c:	b480      	push	{r7}
    9d2e:	b083      	sub	sp, #12
    9d30:	af00      	add	r7, sp, #0
    9d32:	4603      	mov	r3, r0
    9d34:	71fb      	strb	r3, [r7, #7]
    ASSERT( comp_id < NB_OF_COMPARATORS );
    9d36:	79fb      	ldrb	r3, [r7, #7]
    9d38:	2b09      	cmp	r3, #9
    9d3a:	d900      	bls.n	9d3e <ACE_enable_comp_fall_irq+0x12>
    9d3c:	be00      	bkpt	0x0000
    
    ACE->COMP_IRQ_EN |= (uint32_t)(FIRST_FALL_IRQ_MASK << (uint32_t)comp_id);
    9d3e:	f240 0300 	movw	r3, #0
    9d42:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9d46:	f240 0200 	movw	r2, #0
    9d4a:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9d4e:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    9d52:	f102 020c 	add.w	r2, r2, #12
    9d56:	6811      	ldr	r1, [r2, #0]
    9d58:	79fa      	ldrb	r2, [r7, #7]
    9d5a:	f04f 0001 	mov.w	r0, #1
    9d5e:	fa00 f202 	lsl.w	r2, r0, r2
    9d62:	ea41 0202 	orr.w	r2, r1, r2
    9d66:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    9d6a:	f103 030c 	add.w	r3, r3, #12
    9d6e:	601a      	str	r2, [r3, #0]
}
    9d70:	f107 070c 	add.w	r7, r7, #12
    9d74:	46bd      	mov	sp, r7
    9d76:	bc80      	pop	{r7}
    9d78:	4770      	bx	lr
    9d7a:	bf00      	nop

00009d7c <ACE_disable_comp_fall_irq>:
 */
void ACE_disable_comp_fall_irq
(
	comparator_id_t comp_id
)
{
    9d7c:	b480      	push	{r7}
    9d7e:	b085      	sub	sp, #20
    9d80:	af00      	add	r7, sp, #0
    9d82:	4603      	mov	r3, r0
    9d84:	71fb      	strb	r3, [r7, #7]
    volatile uint32_t dummy_read;
    
    ASSERT( comp_id < NB_OF_COMPARATORS );
    9d86:	79fb      	ldrb	r3, [r7, #7]
    9d88:	2b09      	cmp	r3, #9
    9d8a:	d900      	bls.n	9d8e <ACE_disable_comp_fall_irq+0x12>
    9d8c:	be00      	bkpt	0x0000
    
    ACE->COMP_IRQ_EN &= ~(FIRST_FALL_IRQ_MASK << (uint32_t)comp_id);
    9d8e:	f240 0300 	movw	r3, #0
    9d92:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9d96:	f240 0200 	movw	r2, #0
    9d9a:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9d9e:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    9da2:	f102 020c 	add.w	r2, r2, #12
    9da6:	6811      	ldr	r1, [r2, #0]
    9da8:	79fa      	ldrb	r2, [r7, #7]
    9daa:	f04f 0001 	mov.w	r0, #1
    9dae:	fa00 f202 	lsl.w	r2, r0, r2
    9db2:	ea6f 0202 	mvn.w	r2, r2
    9db6:	ea01 0202 	and.w	r2, r1, r2
    9dba:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    9dbe:	f103 030c 	add.w	r3, r3, #12
    9dc2:	601a      	str	r2, [r3, #0]
    /*
     * Ensure that the posted write to the COMP_IRQ_EN register completed before
     * returning from this function. Not doing this may result in the interrupt
     * only being disabled some time after this function returns.
     */
    dummy_read = ACE->COMP_IRQ_EN;
    9dc4:	f240 0300 	movw	r3, #0
    9dc8:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9dcc:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    9dd0:	f103 030c 	add.w	r3, r3, #12
    9dd4:	681b      	ldr	r3, [r3, #0]
    9dd6:	60fb      	str	r3, [r7, #12]
    ++dummy_read;
    9dd8:	68fb      	ldr	r3, [r7, #12]
    9dda:	f103 0301 	add.w	r3, r3, #1
    9dde:	60fb      	str	r3, [r7, #12]
}
    9de0:	f107 0714 	add.w	r7, r7, #20
    9de4:	46bd      	mov	sp, r7
    9de6:	bc80      	pop	{r7}
    9de8:	4770      	bx	lr
    9dea:	bf00      	nop

00009dec <ACE_clear_comp_fall_irq>:
 */
void ACE_clear_comp_fall_irq
(
	comparator_id_t comp_id
)
{
    9dec:	b480      	push	{r7}
    9dee:	b085      	sub	sp, #20
    9df0:	af00      	add	r7, sp, #0
    9df2:	4603      	mov	r3, r0
    9df4:	71fb      	strb	r3, [r7, #7]
    volatile uint32_t dummy_read;
    
    ASSERT( comp_id < NB_OF_COMPARATORS );
    9df6:	79fb      	ldrb	r3, [r7, #7]
    9df8:	2b09      	cmp	r3, #9
    9dfa:	d900      	bls.n	9dfe <ACE_clear_comp_fall_irq+0x12>
    9dfc:	be00      	bkpt	0x0000
    
    ACE->COMP_IRQ_CLR |= (FIRST_FALL_IRQ_MASK << (uint32_t)comp_id);
    9dfe:	f240 0300 	movw	r3, #0
    9e02:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9e06:	f240 0200 	movw	r2, #0
    9e0a:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9e0e:	f502 5290 	add.w	r2, r2, #4608	; 0x1200
    9e12:	f102 0214 	add.w	r2, r2, #20
    9e16:	6811      	ldr	r1, [r2, #0]
    9e18:	79fa      	ldrb	r2, [r7, #7]
    9e1a:	f04f 0001 	mov.w	r0, #1
    9e1e:	fa00 f202 	lsl.w	r2, r0, r2
    9e22:	ea41 0202 	orr.w	r2, r1, r2
    9e26:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    9e2a:	f103 0314 	add.w	r3, r3, #20
    9e2e:	601a      	str	r2, [r3, #0]
     * Ensure that the posted write to the COMP_IRQ_CLR register completed before
     * returning from this function. Not doing this may result in the interrupt
     * retriggering if the Cortex-M3 returns from interrupt before the posted
     * write completes.
     */
    dummy_read = ACE->COMP_IRQ_CLR;
    9e30:	f240 0300 	movw	r3, #0
    9e34:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9e38:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    9e3c:	f103 0314 	add.w	r3, r3, #20
    9e40:	681b      	ldr	r3, [r3, #0]
    9e42:	60fb      	str	r3, [r7, #12]
    ++dummy_read;
    9e44:	68fb      	ldr	r3, [r7, #12]
    9e46:	f103 0301 	add.w	r3, r3, #1
    9e4a:	60fb      	str	r3, [r7, #12]
}
    9e4c:	f107 0714 	add.w	r7, r7, #20
    9e50:	46bd      	mov	sp, r7
    9e52:	bc80      	pop	{r7}
    9e54:	4770      	bx	lr
    9e56:	bf00      	nop

00009e58 <ACE_get_comp_status>:

/*-------------------------------------------------------------------------*//**
 * Returns the raw analog quad comparator status.
 */
uint32_t ACE_get_comp_status( void )
{
    9e58:	b480      	push	{r7}
    9e5a:	af00      	add	r7, sp, #0
    return ACE->COMP_IRQ;
    9e5c:	f240 0300 	movw	r3, #0
    9e60:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9e64:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
    9e68:	f103 0310 	add.w	r3, r3, #16
    9e6c:	681b      	ldr	r3, [r3, #0]
}
    9e6e:	4618      	mov	r0, r3
    9e70:	46bd      	mov	sp, r7
    9e72:	bc80      	pop	{r7}
    9e74:	4770      	bx	lr
    9e76:	bf00      	nop

00009e78 <ACE_get_channel_count>:
uint32_t
ACE_get_channel_count
(
    void
)
{
    9e78:	b480      	push	{r7}
    9e7a:	af00      	add	r7, sp, #0
    return (uint32_t)ACE_NB_OF_INPUT_CHANNELS;
    9e7c:	f04f 0307 	mov.w	r3, #7
}
    9e80:	4618      	mov	r0, r3
    9e82:	46bd      	mov	sp, r7
    9e84:	bc80      	pop	{r7}
    9e86:	4770      	bx	lr

00009e88 <ACE_get_first_channel>:
ace_channel_handle_t
ACE_get_first_channel
(
    void
)
{
    9e88:	b480      	push	{r7}
    9e8a:	b083      	sub	sp, #12
    9e8c:	af00      	add	r7, sp, #0
    ace_channel_handle_t channel_handle;
    
    channel_handle = (ace_channel_handle_t)0;
    9e8e:	f04f 0300 	mov.w	r3, #0
    9e92:	71fb      	strb	r3, [r7, #7]
    
    return channel_handle;
    9e94:	79fb      	ldrb	r3, [r7, #7]
}
    9e96:	4618      	mov	r0, r3
    9e98:	f107 070c 	add.w	r7, r7, #12
    9e9c:	46bd      	mov	sp, r7
    9e9e:	bc80      	pop	{r7}
    9ea0:	4770      	bx	lr
    9ea2:	bf00      	nop

00009ea4 <ACE_get_next_channel>:
ace_channel_handle_t
ACE_get_next_channel
(
    ace_channel_handle_t channel_handle
)
{
    9ea4:	b480      	push	{r7}
    9ea6:	b083      	sub	sp, #12
    9ea8:	af00      	add	r7, sp, #0
    9eaa:	4603      	mov	r3, r0
    9eac:	71fb      	strb	r3, [r7, #7]
    ++channel_handle;
    9eae:	79fb      	ldrb	r3, [r7, #7]
    9eb0:	f103 0301 	add.w	r3, r3, #1
    9eb4:	71fb      	strb	r3, [r7, #7]
    
    if ( channel_handle >= NB_OF_ACE_CHANNEL_HANDLES )
    9eb6:	79fb      	ldrb	r3, [r7, #7]
    9eb8:	2b06      	cmp	r3, #6
    9eba:	d902      	bls.n	9ec2 <ACE_get_next_channel+0x1e>
    {
         channel_handle = (ace_channel_handle_t)0;
    9ebc:	f04f 0300 	mov.w	r3, #0
    9ec0:	71fb      	strb	r3, [r7, #7]
    }
    
    return channel_handle;
    9ec2:	79fb      	ldrb	r3, [r7, #7]
}
    9ec4:	4618      	mov	r0, r3
    9ec6:	f107 070c 	add.w	r7, r7, #12
    9eca:	46bd      	mov	sp, r7
    9ecc:	bc80      	pop	{r7}
    9ece:	4770      	bx	lr

00009ed0 <ACE_get_channel_handle>:
ace_channel_handle_t
ACE_get_channel_handle
(
    const uint8_t * p_sz_channel_name
)
{
    9ed0:	b580      	push	{r7, lr}
    9ed2:	b084      	sub	sp, #16
    9ed4:	af00      	add	r7, sp, #0
    9ed6:	6078      	str	r0, [r7, #4]
    uint16_t channel_idx;
    ace_channel_handle_t channel_handle = INVALID_CHANNEL_HANDLE;
    9ed8:	f04f 0307 	mov.w	r3, #7
    9edc:	72fb      	strb	r3, [r7, #11]
    
    for ( channel_idx = 0u;  channel_idx < (uint16_t)ACE_NB_OF_INPUT_CHANNELS; ++channel_idx )
    9ede:	f04f 0300 	mov.w	r3, #0
    9ee2:	813b      	strh	r3, [r7, #8]
    9ee4:	e025      	b.n	9f32 <ACE_get_channel_handle+0x62>
    {
        if ( g_ace_channel_desc_table[channel_idx].p_sz_channel_name != 0 )
    9ee6:	893a      	ldrh	r2, [r7, #8]
    9ee8:	f240 0350 	movw	r3, #80	; 0x50
    9eec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9ef0:	ea4f 1202 	mov.w	r2, r2, lsl #4
    9ef4:	4413      	add	r3, r2
    9ef6:	681b      	ldr	r3, [r3, #0]
    9ef8:	2b00      	cmp	r3, #0
    9efa:	d016      	beq.n	9f2a <ACE_get_channel_handle+0x5a>
        {
            int32_t diff;
            diff = strncmp( (const char*)p_sz_channel_name, (const char*)g_ace_channel_desc_table[channel_idx].p_sz_channel_name, (size_t)MAX_CHANNEL_NAME_LENGTH );
    9efc:	893a      	ldrh	r2, [r7, #8]
    9efe:	f240 0350 	movw	r3, #80	; 0x50
    9f02:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9f06:	ea4f 1202 	mov.w	r2, r2, lsl #4
    9f0a:	4413      	add	r3, r2
    9f0c:	681b      	ldr	r3, [r3, #0]
    9f0e:	6878      	ldr	r0, [r7, #4]
    9f10:	4619      	mov	r1, r3
    9f12:	f04f 0214 	mov.w	r2, #20
    9f16:	f00b fd65 	bl	159e4 <strncmp>
    9f1a:	4603      	mov	r3, r0
    9f1c:	60fb      	str	r3, [r7, #12]
            if ( 0 == diff )
    9f1e:	68fb      	ldr	r3, [r7, #12]
    9f20:	2b00      	cmp	r3, #0
    9f22:	d102      	bne.n	9f2a <ACE_get_channel_handle+0x5a>
            {
                /* channel name found. */
                channel_handle = (ace_channel_handle_t)channel_idx;
    9f24:	893b      	ldrh	r3, [r7, #8]
    9f26:	72fb      	strb	r3, [r7, #11]
                break;
    9f28:	e006      	b.n	9f38 <ACE_get_channel_handle+0x68>
)
{
    uint16_t channel_idx;
    ace_channel_handle_t channel_handle = INVALID_CHANNEL_HANDLE;
    
    for ( channel_idx = 0u;  channel_idx < (uint16_t)ACE_NB_OF_INPUT_CHANNELS; ++channel_idx )
    9f2a:	893b      	ldrh	r3, [r7, #8]
    9f2c:	f103 0301 	add.w	r3, r3, #1
    9f30:	813b      	strh	r3, [r7, #8]
    9f32:	893b      	ldrh	r3, [r7, #8]
    9f34:	2b06      	cmp	r3, #6
    9f36:	d9d6      	bls.n	9ee6 <ACE_get_channel_handle+0x16>
                channel_handle = (ace_channel_handle_t)channel_idx;
                break;
            }
        }
    }
    return channel_handle;
    9f38:	7afb      	ldrb	r3, [r7, #11]
}
    9f3a:	4618      	mov	r0, r3
    9f3c:	f107 0710 	add.w	r7, r7, #16
    9f40:	46bd      	mov	sp, r7
    9f42:	bd80      	pop	{r7, pc}

00009f44 <ACE_get_input_channel_handle>:
ace_channel_handle_t
ACE_get_input_channel_handle
(
    adc_channel_id_t    channel_id
)
{
    9f44:	b480      	push	{r7}
    9f46:	b085      	sub	sp, #20
    9f48:	af00      	add	r7, sp, #0
    9f4a:	4603      	mov	r3, r0
    9f4c:	71fb      	strb	r3, [r7, #7]
    uint16_t channel_idx;
    ace_channel_handle_t channel_handle = INVALID_CHANNEL_HANDLE;
    9f4e:	f04f 0307 	mov.w	r3, #7
    9f52:	73fb      	strb	r3, [r7, #15]
    
    for ( channel_idx = 0u;  channel_idx < (uint16_t)ACE_NB_OF_INPUT_CHANNELS; ++channel_idx )
    9f54:	f04f 0300 	mov.w	r3, #0
    9f58:	81bb      	strh	r3, [r7, #12]
    9f5a:	e012      	b.n	9f82 <ACE_get_input_channel_handle+0x3e>
    {
        if ( g_ace_channel_desc_table[channel_idx].signal_id == channel_id )
    9f5c:	89ba      	ldrh	r2, [r7, #12]
    9f5e:	f240 0350 	movw	r3, #80	; 0x50
    9f62:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9f66:	ea4f 1202 	mov.w	r2, r2, lsl #4
    9f6a:	4413      	add	r3, r2
    9f6c:	791b      	ldrb	r3, [r3, #4]
    9f6e:	79fa      	ldrb	r2, [r7, #7]
    9f70:	429a      	cmp	r2, r3
    9f72:	d102      	bne.n	9f7a <ACE_get_input_channel_handle+0x36>
        {
            /* channel ID found. */
            channel_handle = (ace_channel_handle_t)channel_idx;
    9f74:	89bb      	ldrh	r3, [r7, #12]
    9f76:	73fb      	strb	r3, [r7, #15]
            break;
    9f78:	e006      	b.n	9f88 <ACE_get_input_channel_handle+0x44>
)
{
    uint16_t channel_idx;
    ace_channel_handle_t channel_handle = INVALID_CHANNEL_HANDLE;
    
    for ( channel_idx = 0u;  channel_idx < (uint16_t)ACE_NB_OF_INPUT_CHANNELS; ++channel_idx )
    9f7a:	89bb      	ldrh	r3, [r7, #12]
    9f7c:	f103 0301 	add.w	r3, r3, #1
    9f80:	81bb      	strh	r3, [r7, #12]
    9f82:	89bb      	ldrh	r3, [r7, #12]
    9f84:	2b06      	cmp	r3, #6
    9f86:	d9e9      	bls.n	9f5c <ACE_get_input_channel_handle+0x18>
            /* channel ID found. */
            channel_handle = (ace_channel_handle_t)channel_idx;
            break;
        }
    }
    return channel_handle;
    9f88:	7bfb      	ldrb	r3, [r7, #15]
}
    9f8a:	4618      	mov	r0, r3
    9f8c:	f107 0714 	add.w	r7, r7, #20
    9f90:	46bd      	mov	sp, r7
    9f92:	bc80      	pop	{r7}
    9f94:	4770      	bx	lr
    9f96:	bf00      	nop

00009f98 <ACE_get_ppe_sample>:
uint16_t
ACE_get_ppe_sample
(
    ace_channel_handle_t channel_handle
)
{
    9f98:	b480      	push	{r7}
    9f9a:	b085      	sub	sp, #20
    9f9c:	af00      	add	r7, sp, #0
    9f9e:	4603      	mov	r3, r0
    9fa0:	71fb      	strb	r3, [r7, #7]
    uint16_t sample;
    uint16_t ppe_offset;
    
    ppe_offset = g_ace_channel_desc_table[channel_handle].signal_ppe_offset;
    9fa2:	79fa      	ldrb	r2, [r7, #7]
    9fa4:	f240 0350 	movw	r3, #80	; 0x50
    9fa8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9fac:	ea4f 1202 	mov.w	r2, r2, lsl #4
    9fb0:	4413      	add	r3, r2
    9fb2:	88db      	ldrh	r3, [r3, #6]
    9fb4:	81fb      	strh	r3, [r7, #14]
    sample = (uint16_t)(ACE->PPE_RAM_DATA[ppe_offset] >> 16u);
    9fb6:	f240 0300 	movw	r3, #0
    9fba:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9fbe:	89fa      	ldrh	r2, [r7, #14]
    9fc0:	f502 62c0 	add.w	r2, r2, #1536	; 0x600
    9fc4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    9fc8:	ea4f 4313 	mov.w	r3, r3, lsr #16
    9fcc:	81bb      	strh	r3, [r7, #12]
    
    /* Check that the PPE processing did not result into a negative value.*/
    if((sample & 0x8000u) > 0u)
    9fce:	89bb      	ldrh	r3, [r7, #12]
    9fd0:	b21b      	sxth	r3, r3
    9fd2:	2b00      	cmp	r3, #0
    9fd4:	da02      	bge.n	9fdc <ACE_get_ppe_sample+0x44>
    {
        /* Normalize negative value to zero. */
        sample = 0u;
    9fd6:	f04f 0300 	mov.w	r3, #0
    9fda:	81bb      	strh	r3, [r7, #12]
    }
    
    return sample;
    9fdc:	89bb      	ldrh	r3, [r7, #12]
}
    9fde:	4618      	mov	r0, r3
    9fe0:	f107 0714 	add.w	r7, r7, #20
    9fe4:	46bd      	mov	sp, r7
    9fe6:	bc80      	pop	{r7}
    9fe8:	4770      	bx	lr
    9fea:	bf00      	nop

00009fec <BrownOut_1_5V_IRQHandler>:
#elif defined( __ICCARM__ )
__irq void BrownOut_1_5V_IRQHandler( void )
#else
void BrownOut_1_5V_IRQHandler( void )
#endif
{
    9fec:	4668      	mov	r0, sp
    9fee:	f020 0107 	bic.w	r1, r0, #7
    9ff2:	468d      	mov	sp, r1
    9ff4:	b481      	push	{r0, r7}
    9ff6:	b082      	sub	sp, #8
    9ff8:	af00      	add	r7, sp, #0
     * Reduce frequency to 3MHz.
     * 	1) Select RC oscillator as CLKC clock source.
     *  2) Set divider to maximum allowed value (divide by 28).
     *  3) Set glitchless mux to use CLKC as MSS clock source.
     */
    SYSREG->MSS_CCC_MUX_CR = (SYSREG->MSS_CCC_MUX_CR & ~CLKC_SOURCE_MASK) | CLKC_SOURCE_VALUE;
    9ffa:	f242 0300 	movw	r3, #8192	; 0x2000
    9ffe:	f2ce 0304 	movt	r3, #57348	; 0xe004
    a002:	f242 0200 	movw	r2, #8192	; 0x2000
    a006:	f2ce 0204 	movt	r2, #57348	; 0xe004
    a00a:	6d12      	ldr	r2, [r2, #80]	; 0x50
    a00c:	f442 22e0 	orr.w	r2, r2, #458752	; 0x70000
    a010:	651a      	str	r2, [r3, #80]	; 0x50
    SYSREG->MSS_CCC_DIV_CR = (SYSREG->MSS_CCC_DIV_CR & ~GLC_DIV_MASK) | GLC_DIV_VALUE;
    a012:	f242 0300 	movw	r3, #8192	; 0x2000
    a016:	f2ce 0304 	movt	r3, #57348	; 0xe004
    a01a:	f242 0200 	movw	r2, #8192	; 0x2000
    a01e:	f2ce 0204 	movt	r2, #57348	; 0xe004
    a022:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
    a024:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
    a028:	f442 1270 	orr.w	r2, r2, #3932160	; 0x3c0000
    a02c:	64da      	str	r2, [r3, #76]	; 0x4c
    SYSREG->MSS_CCC_MUX_CR = (SYSREG->MSS_CCC_MUX_CR & ~GLMUX_MASK) | GLMUX_VALUE;
    a02e:	f242 0300 	movw	r3, #8192	; 0x2000
    a032:	f2ce 0304 	movt	r3, #57348	; 0xe004
    a036:	f242 0200 	movw	r2, #8192	; 0x2000
    a03a:	f2ce 0204 	movt	r2, #57348	; 0xe004
    a03e:	6d12      	ldr	r2, [r2, #80]	; 0x50
    a040:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
    a044:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
    a048:	651a      	str	r2, [r3, #80]	; 0x50
	
    /*
     * Wait for supplies to become stable.
     */
    delay_count = STABLE_SUPPLY_DELAY;
    a04a:	f04f 0364 	mov.w	r3, #100	; 0x64
    a04e:	603b      	str	r3, [r7, #0]
    do
    {
        brownout_status = SYSREG->DEVICE_SR & BROWNOUT_SYNCN_MASK;
    a050:	f242 0300 	movw	r3, #8192	; 0x2000
    a054:	f2ce 0304 	movt	r3, #57348	; 0xe004
    a058:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    a05a:	f003 0303 	and.w	r3, r3, #3
    a05e:	607b      	str	r3, [r7, #4]
        if ( NO_BROWNOUT == brownout_status )
    a060:	687b      	ldr	r3, [r7, #4]
    a062:	2b03      	cmp	r3, #3
    a064:	d104      	bne.n	a070 <BrownOut_1_5V_IRQHandler+0x84>
        {
            --delay_count;
    a066:	683b      	ldr	r3, [r7, #0]
    a068:	f103 33ff 	add.w	r3, r3, #4294967295
    a06c:	603b      	str	r3, [r7, #0]
    a06e:	e002      	b.n	a076 <BrownOut_1_5V_IRQHandler+0x8a>
        }
        else
        {
            delay_count = STABLE_SUPPLY_DELAY;
    a070:	f04f 0364 	mov.w	r3, #100	; 0x64
    a074:	603b      	str	r3, [r7, #0]
        }
    } while ( delay_count != 0 );
    a076:	683b      	ldr	r3, [r7, #0]
    a078:	2b00      	cmp	r3, #0
    a07a:	d1e9      	bne.n	a050 <BrownOut_1_5V_IRQHandler+0x64>
	
    /*
     * Issue system reset request.
     */
    SCB->AIRCR = SYS_RESET_REQUEST;
    a07c:	f64e 5300 	movw	r3, #60672	; 0xed00
    a080:	f2ce 0300 	movt	r3, #57344	; 0xe000
    a084:	f240 0204 	movw	r2, #4
    a088:	f2c0 52fa 	movt	r2, #1530	; 0x5fa
    a08c:	60da      	str	r2, [r3, #12]
}
    a08e:	f107 0708 	add.w	r7, r7, #8
    a092:	46bd      	mov	sp, r7
    a094:	bc81      	pop	{r0, r7}
    a096:	4685      	mov	sp, r0
    a098:	4770      	bx	lr
    a09a:	bf00      	nop

0000a09c <__get_PSP>:
 * Return the actual process stack pointer
 */
uint32_t __get_PSP(void) __attribute__( ( naked ) );
uint32_t __get_PSP(void)
{
  uint32_t result=0;
    a09c:	f04f 0400 	mov.w	r4, #0

  __ASM volatile ("MRS %0, psp\n\t" 
    a0a0:	f3ef 8409 	mrs	r4, PSP
    a0a4:	4620      	mov	r0, r4
    a0a6:	4770      	bx	lr
                  "MOV r0, %0 \n\t"
                  "BX  lr     \n\t"  : "=r" (result) );
  return(result);
    a0a8:	4623      	mov	r3, r4
}
    a0aa:	4618      	mov	r0, r3

0000a0ac <__set_PSP>:
 * Assign the value ProcessStackPointer to the MSP 
 * (process stack pointer) Cortex processor register
 */
void __set_PSP(uint32_t topOfProcStack) __attribute__( ( naked ) );
void __set_PSP(uint32_t topOfProcStack)
{
    a0ac:	4603      	mov	r3, r0
  __ASM volatile ("MSR psp, %0\n\t"
    a0ae:	f383 8809 	msr	PSP, r3
    a0b2:	4770      	bx	lr

0000a0b4 <__get_MSP>:
 * Cortex processor register
 */
uint32_t __get_MSP(void) __attribute__( ( naked ) );
uint32_t __get_MSP(void)
{
  uint32_t result=0;
    a0b4:	f04f 0400 	mov.w	r4, #0

  __ASM volatile ("MRS %0, msp\n\t" 
    a0b8:	f3ef 8408 	mrs	r4, MSP
    a0bc:	4620      	mov	r0, r4
    a0be:	4770      	bx	lr
                  "MOV r0, %0 \n\t"
                  "BX  lr     \n\t"  : "=r" (result) );
  return(result);
    a0c0:	4623      	mov	r3, r4
}
    a0c2:	4618      	mov	r0, r3

0000a0c4 <__set_MSP>:
 * Assign the value mainStackPointer to the MSP 
 * (main stack pointer) Cortex processor register
 */
void __set_MSP(uint32_t topOfMainStack) __attribute__( ( naked ) );
void __set_MSP(uint32_t topOfMainStack)
{
    a0c4:	4603      	mov	r3, r0
  __ASM volatile ("MSR msp, %0\n\t"
    a0c6:	f383 8808 	msr	MSP, r3
    a0ca:	4770      	bx	lr

0000a0cc <__get_BASEPRI>:
 * @return BasePriority
 *
 * Return the content of the base priority register
 */
uint32_t __get_BASEPRI(void)
{
    a0cc:	b480      	push	{r7}
    a0ce:	b083      	sub	sp, #12
    a0d0:	af00      	add	r7, sp, #0
  uint32_t result=0;
    a0d2:	f04f 0300 	mov.w	r3, #0
    a0d6:	607b      	str	r3, [r7, #4]
  
  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
    a0d8:	f3ef 8312 	mrs	r3, BASEPRI_MASK
    a0dc:	607b      	str	r3, [r7, #4]
  return(result);
    a0de:	687b      	ldr	r3, [r7, #4]
}
    a0e0:	4618      	mov	r0, r3
    a0e2:	f107 070c 	add.w	r7, r7, #12
    a0e6:	46bd      	mov	sp, r7
    a0e8:	bc80      	pop	{r7}
    a0ea:	4770      	bx	lr

0000a0ec <__set_BASEPRI>:
 * @param  basePri  BasePriority
 *
 * Set the base priority register
 */
void __set_BASEPRI(uint32_t value)
{
    a0ec:	b480      	push	{r7}
    a0ee:	b083      	sub	sp, #12
    a0f0:	af00      	add	r7, sp, #0
    a0f2:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
    a0f4:	687b      	ldr	r3, [r7, #4]
    a0f6:	f383 8811 	msr	BASEPRI, r3
}
    a0fa:	f107 070c 	add.w	r7, r7, #12
    a0fe:	46bd      	mov	sp, r7
    a100:	bc80      	pop	{r7}
    a102:	4770      	bx	lr

0000a104 <__get_PRIMASK>:
 * @return PriMask
 *
 * Return state of the priority mask bit from the priority mask register
 */
uint32_t __get_PRIMASK(void)
{
    a104:	b480      	push	{r7}
    a106:	b083      	sub	sp, #12
    a108:	af00      	add	r7, sp, #0
  uint32_t result=0;
    a10a:	f04f 0300 	mov.w	r3, #0
    a10e:	607b      	str	r3, [r7, #4]

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    a110:	f3ef 8310 	mrs	r3, PRIMASK
    a114:	607b      	str	r3, [r7, #4]
  return(result);
    a116:	687b      	ldr	r3, [r7, #4]
}
    a118:	4618      	mov	r0, r3
    a11a:	f107 070c 	add.w	r7, r7, #12
    a11e:	46bd      	mov	sp, r7
    a120:	bc80      	pop	{r7}
    a122:	4770      	bx	lr

0000a124 <__set_PRIMASK>:
 * @param  priMask  PriMask
 *
 * Set the priority mask bit in the priority mask register
 */
void __set_PRIMASK(uint32_t priMask)
{
    a124:	b480      	push	{r7}
    a126:	b083      	sub	sp, #12
    a128:	af00      	add	r7, sp, #0
    a12a:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
    a12c:	687b      	ldr	r3, [r7, #4]
    a12e:	f383 8810 	msr	PRIMASK, r3
}
    a132:	f107 070c 	add.w	r7, r7, #12
    a136:	46bd      	mov	sp, r7
    a138:	bc80      	pop	{r7}
    a13a:	4770      	bx	lr

0000a13c <__get_FAULTMASK>:
 * @return FaultMask
 *
 * Return the content of the fault mask register
 */
uint32_t __get_FAULTMASK(void)
{
    a13c:	b480      	push	{r7}
    a13e:	b083      	sub	sp, #12
    a140:	af00      	add	r7, sp, #0
  uint32_t result=0;
    a142:	f04f 0300 	mov.w	r3, #0
    a146:	607b      	str	r3, [r7, #4]
  
  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
    a148:	f3ef 8313 	mrs	r3, FAULTMASK
    a14c:	607b      	str	r3, [r7, #4]
  return(result);
    a14e:	687b      	ldr	r3, [r7, #4]
}
    a150:	4618      	mov	r0, r3
    a152:	f107 070c 	add.w	r7, r7, #12
    a156:	46bd      	mov	sp, r7
    a158:	bc80      	pop	{r7}
    a15a:	4770      	bx	lr

0000a15c <__set_FAULTMASK>:
 * @param  faultMask  faultMask value
 *
 * Set the fault mask register
 */
void __set_FAULTMASK(uint32_t faultMask)
{
    a15c:	b480      	push	{r7}
    a15e:	b083      	sub	sp, #12
    a160:	af00      	add	r7, sp, #0
    a162:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
    a164:	687b      	ldr	r3, [r7, #4]
    a166:	f383 8813 	msr	FAULTMASK, r3
}
    a16a:	f107 070c 	add.w	r7, r7, #12
    a16e:	46bd      	mov	sp, r7
    a170:	bc80      	pop	{r7}
    a172:	4770      	bx	lr

0000a174 <__get_CONTROL>:
*  @return Control value
 *
 * Return the content of the control register
 */
uint32_t __get_CONTROL(void)
{
    a174:	b480      	push	{r7}
    a176:	b083      	sub	sp, #12
    a178:	af00      	add	r7, sp, #0
  uint32_t result=0;
    a17a:	f04f 0300 	mov.w	r3, #0
    a17e:	607b      	str	r3, [r7, #4]

  __ASM volatile ("MRS %0, control" : "=r" (result) );
    a180:	f3ef 8314 	mrs	r3, CONTROL
    a184:	607b      	str	r3, [r7, #4]
  return(result);
    a186:	687b      	ldr	r3, [r7, #4]
}
    a188:	4618      	mov	r0, r3
    a18a:	f107 070c 	add.w	r7, r7, #12
    a18e:	46bd      	mov	sp, r7
    a190:	bc80      	pop	{r7}
    a192:	4770      	bx	lr

0000a194 <__set_CONTROL>:
 * @param  control  Control value
 *
 * Set the control register
 */
void __set_CONTROL(uint32_t control)
{
    a194:	b480      	push	{r7}
    a196:	b083      	sub	sp, #12
    a198:	af00      	add	r7, sp, #0
    a19a:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR control, %0" : : "r" (control) );
    a19c:	687b      	ldr	r3, [r7, #4]
    a19e:	f383 8814 	msr	CONTROL, r3
}
    a1a2:	f107 070c 	add.w	r7, r7, #12
    a1a6:	46bd      	mov	sp, r7
    a1a8:	bc80      	pop	{r7}
    a1aa:	4770      	bx	lr

0000a1ac <__REV>:
 * @return        reversed value
 *
 * Reverse byte order in integer value
 */
uint32_t __REV(uint32_t value)
{
    a1ac:	b480      	push	{r7}
    a1ae:	b085      	sub	sp, #20
    a1b0:	af00      	add	r7, sp, #0
    a1b2:	6078      	str	r0, [r7, #4]
  uint32_t result=0;
    a1b4:	f04f 0300 	mov.w	r3, #0
    a1b8:	60fb      	str	r3, [r7, #12]
  
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
    a1ba:	687b      	ldr	r3, [r7, #4]
    a1bc:	ba1b      	rev	r3, r3
    a1be:	60fb      	str	r3, [r7, #12]
  return(result);
    a1c0:	68fb      	ldr	r3, [r7, #12]
}
    a1c2:	4618      	mov	r0, r3
    a1c4:	f107 0714 	add.w	r7, r7, #20
    a1c8:	46bd      	mov	sp, r7
    a1ca:	bc80      	pop	{r7}
    a1cc:	4770      	bx	lr
    a1ce:	bf00      	nop

0000a1d0 <__REV16>:
 * @return        reversed value
 *
 * Reverse byte order in unsigned short value
 */
uint32_t __REV16(uint16_t value)
{
    a1d0:	b480      	push	{r7}
    a1d2:	b085      	sub	sp, #20
    a1d4:	af00      	add	r7, sp, #0
    a1d6:	4603      	mov	r3, r0
    a1d8:	80fb      	strh	r3, [r7, #6]
  uint32_t result=0;
    a1da:	f04f 0300 	mov.w	r3, #0
    a1de:	60fb      	str	r3, [r7, #12]
  
  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
    a1e0:	88fb      	ldrh	r3, [r7, #6]
    a1e2:	ba5b      	rev16	r3, r3
    a1e4:	60fb      	str	r3, [r7, #12]
  return(result);
    a1e6:	68fb      	ldr	r3, [r7, #12]
}
    a1e8:	4618      	mov	r0, r3
    a1ea:	f107 0714 	add.w	r7, r7, #20
    a1ee:	46bd      	mov	sp, r7
    a1f0:	bc80      	pop	{r7}
    a1f2:	4770      	bx	lr

0000a1f4 <__REVSH>:
 * @return        reversed value
 *
 * Reverse byte order in signed short value with sign extension to integer
 */
int32_t __REVSH(int16_t value)
{
    a1f4:	b480      	push	{r7}
    a1f6:	b085      	sub	sp, #20
    a1f8:	af00      	add	r7, sp, #0
    a1fa:	4603      	mov	r3, r0
    a1fc:	80fb      	strh	r3, [r7, #6]
  uint32_t result=0;
    a1fe:	f04f 0300 	mov.w	r3, #0
    a202:	60fb      	str	r3, [r7, #12]
  
  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
    a204:	88fb      	ldrh	r3, [r7, #6]
    a206:	badb      	revsh	r3, r3
    a208:	60fb      	str	r3, [r7, #12]
  return(result);
    a20a:	68fb      	ldr	r3, [r7, #12]
}
    a20c:	4618      	mov	r0, r3
    a20e:	f107 0714 	add.w	r7, r7, #20
    a212:	46bd      	mov	sp, r7
    a214:	bc80      	pop	{r7}
    a216:	4770      	bx	lr

0000a218 <__RBIT>:
 * @return        reversed value
 *
 * Reverse bit order of value
 */
uint32_t __RBIT(uint32_t value)
{
    a218:	b480      	push	{r7}
    a21a:	b085      	sub	sp, #20
    a21c:	af00      	add	r7, sp, #0
    a21e:	6078      	str	r0, [r7, #4]
  uint32_t result=0;
    a220:	f04f 0300 	mov.w	r3, #0
    a224:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
    a226:	687b      	ldr	r3, [r7, #4]
    a228:	fa93 f3a3 	rbit	r3, r3
    a22c:	60fb      	str	r3, [r7, #12]
   return(result);
    a22e:	68fb      	ldr	r3, [r7, #12]
}
    a230:	4618      	mov	r0, r3
    a232:	f107 0714 	add.w	r7, r7, #20
    a236:	46bd      	mov	sp, r7
    a238:	bc80      	pop	{r7}
    a23a:	4770      	bx	lr

0000a23c <__LDREXB>:
 * @return        value of (*address)
 *
 * Exclusive LDR command for 8 bit value
 */
uint8_t __LDREXB(uint8_t *addr)
{
    a23c:	b480      	push	{r7}
    a23e:	b085      	sub	sp, #20
    a240:	af00      	add	r7, sp, #0
    a242:	6078      	str	r0, [r7, #4]
    uint8_t result=0;
    a244:	f04f 0300 	mov.w	r3, #0
    a248:	73fb      	strb	r3, [r7, #15]
  
   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
    a24a:	687b      	ldr	r3, [r7, #4]
    a24c:	e8d3 3f4f 	ldrexb	r3, [r3]
    a250:	73fb      	strb	r3, [r7, #15]
   return(result);
    a252:	7bfb      	ldrb	r3, [r7, #15]
}
    a254:	4618      	mov	r0, r3
    a256:	f107 0714 	add.w	r7, r7, #20
    a25a:	46bd      	mov	sp, r7
    a25c:	bc80      	pop	{r7}
    a25e:	4770      	bx	lr

0000a260 <__LDREXH>:
 * @return        value of (*address)
 *
 * Exclusive LDR command for 16 bit values
 */
uint16_t __LDREXH(uint16_t *addr)
{
    a260:	b480      	push	{r7}
    a262:	b085      	sub	sp, #20
    a264:	af00      	add	r7, sp, #0
    a266:	6078      	str	r0, [r7, #4]
    uint16_t result=0;
    a268:	f04f 0300 	mov.w	r3, #0
    a26c:	81fb      	strh	r3, [r7, #14]
  
   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
    a26e:	687b      	ldr	r3, [r7, #4]
    a270:	e8d3 3f5f 	ldrexh	r3, [r3]
    a274:	81fb      	strh	r3, [r7, #14]
   return(result);
    a276:	89fb      	ldrh	r3, [r7, #14]
}
    a278:	4618      	mov	r0, r3
    a27a:	f107 0714 	add.w	r7, r7, #20
    a27e:	46bd      	mov	sp, r7
    a280:	bc80      	pop	{r7}
    a282:	4770      	bx	lr

0000a284 <__LDREXW>:
 * @return        value of (*address)
 *
 * Exclusive LDR command for 32 bit values
 */
uint32_t __LDREXW(uint32_t *addr)
{
    a284:	b480      	push	{r7}
    a286:	b085      	sub	sp, #20
    a288:	af00      	add	r7, sp, #0
    a28a:	6078      	str	r0, [r7, #4]
    uint32_t result=0;
    a28c:	f04f 0300 	mov.w	r3, #0
    a290:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    a292:	687b      	ldr	r3, [r7, #4]
    a294:	e853 3f00 	ldrex	r3, [r3]
    a298:	60fb      	str	r3, [r7, #12]
   return(result);
    a29a:	68fb      	ldr	r3, [r7, #12]
}
    a29c:	4618      	mov	r0, r3
    a29e:	f107 0714 	add.w	r7, r7, #20
    a2a2:	46bd      	mov	sp, r7
    a2a4:	bc80      	pop	{r7}
    a2a6:	4770      	bx	lr

0000a2a8 <__STREXB>:
 * @return        successful / failed
 *
 * Exclusive STR command for 8 bit values
 */
uint32_t __STREXB(uint8_t value, uint8_t *addr)
{
    a2a8:	b480      	push	{r7}
    a2aa:	b085      	sub	sp, #20
    a2ac:	af00      	add	r7, sp, #0
    a2ae:	4603      	mov	r3, r0
    a2b0:	6039      	str	r1, [r7, #0]
    a2b2:	71fb      	strb	r3, [r7, #7]
   uint32_t result=0;
    a2b4:	f04f 0300 	mov.w	r3, #0
    a2b8:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("strexb %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    a2ba:	683b      	ldr	r3, [r7, #0]
    a2bc:	79fa      	ldrb	r2, [r7, #7]
    a2be:	e8c3 2f41 	strexb	r1, r2, [r3]
    a2c2:	460b      	mov	r3, r1
    a2c4:	60fb      	str	r3, [r7, #12]
   return(result);
    a2c6:	68fb      	ldr	r3, [r7, #12]
}
    a2c8:	4618      	mov	r0, r3
    a2ca:	f107 0714 	add.w	r7, r7, #20
    a2ce:	46bd      	mov	sp, r7
    a2d0:	bc80      	pop	{r7}
    a2d2:	4770      	bx	lr

0000a2d4 <__STREXH>:
 * @return        successful / failed
 *
 * Exclusive STR command for 16 bit values
 */
uint32_t __STREXH(uint16_t value, uint16_t *addr)
{
    a2d4:	b480      	push	{r7}
    a2d6:	b085      	sub	sp, #20
    a2d8:	af00      	add	r7, sp, #0
    a2da:	4603      	mov	r3, r0
    a2dc:	6039      	str	r1, [r7, #0]
    a2de:	80fb      	strh	r3, [r7, #6]
   uint32_t result=0;
    a2e0:	f04f 0300 	mov.w	r3, #0
    a2e4:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("strexh %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    a2e6:	683b      	ldr	r3, [r7, #0]
    a2e8:	88fa      	ldrh	r2, [r7, #6]
    a2ea:	e8c3 2f51 	strexh	r1, r2, [r3]
    a2ee:	460b      	mov	r3, r1
    a2f0:	60fb      	str	r3, [r7, #12]
   return(result);
    a2f2:	68fb      	ldr	r3, [r7, #12]
}
    a2f4:	4618      	mov	r0, r3
    a2f6:	f107 0714 	add.w	r7, r7, #20
    a2fa:	46bd      	mov	sp, r7
    a2fc:	bc80      	pop	{r7}
    a2fe:	4770      	bx	lr

0000a300 <__STREXW>:
 * @return        successful / failed
 *
 * Exclusive STR command for 32 bit values
 */
uint32_t __STREXW(uint32_t value, uint32_t *addr)
{
    a300:	b480      	push	{r7}
    a302:	b085      	sub	sp, #20
    a304:	af00      	add	r7, sp, #0
    a306:	6078      	str	r0, [r7, #4]
    a308:	6039      	str	r1, [r7, #0]
   uint32_t result=0;
    a30a:	f04f 0300 	mov.w	r3, #0
    a30e:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("strex %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
    a310:	683b      	ldr	r3, [r7, #0]
    a312:	687a      	ldr	r2, [r7, #4]
    a314:	e843 2300 	strex	r3, r2, [r3]
    a318:	60fb      	str	r3, [r7, #12]
   return(result);
    a31a:	68fb      	ldr	r3, [r7, #12]
}
    a31c:	4618      	mov	r0, r3
    a31e:	f107 0714 	add.w	r7, r7, #20
    a322:	46bd      	mov	sp, r7
    a324:	bc80      	pop	{r7}
    a326:	4770      	bx	lr

0000a328 <SystemInit>:

/***************************************************************************//**
 * See system_a2fxxxm3f.h for details.
 */
void SystemInit(void)
{
    a328:	b480      	push	{r7}
    a32a:	af00      	add	r7, sp, #0
    /*
     * Do not make use of global variables or make any asumptions regarding
     * memory content if modifying this function. The memory content has not been
     * initialised by the time this function is called by the start-up code.
     */
}
    a32c:	46bd      	mov	sp, r7
    a32e:	bc80      	pop	{r7}
    a330:	4770      	bx	lr
    a332:	bf00      	nop

0000a334 <SystemCoreClockUpdate>:

/***************************************************************************//**
 *
 */
void SystemCoreClockUpdate (void)
{
    a334:	b580      	push	{r7, lr}
    a336:	b08a      	sub	sp, #40	; 0x28
    a338:	af00      	add	r7, sp, #0
    uint32_t PclkDiv0;
    uint32_t PclkDiv1;
    uint32_t AceDiv;
    uint32_t FabDiv;

    const uint32_t pclk_div_lut[4] = { 1uL, 2uL, 4uL, 1uL };
    a33a:	f24d 03f0 	movw	r3, #53488	; 0xd0f0
    a33e:	f2c0 0301 	movt	r3, #1
    a342:	46bc      	mov	ip, r7
    a344:	cb0f      	ldmia	r3!, {r0, r1, r2, r3}
    a346:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}

    /* Read PCLK dividers from system registers. Multiply the value read from
     * system register by two to get actual divider value. */
    PclkDiv0 = pclk_div_lut[((SYSREG->MSS_CLK_CR >> PCLK0_DIV_SHIFT) & PCLK_DIV_MASK)];
    a34a:	f242 0300 	movw	r3, #8192	; 0x2000
    a34e:	f2ce 0304 	movt	r3, #57348	; 0xe004
    a352:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    a354:	ea4f 0393 	mov.w	r3, r3, lsr #2
    a358:	f003 0303 	and.w	r3, r3, #3
    a35c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    a360:	f107 0228 	add.w	r2, r7, #40	; 0x28
    a364:	4413      	add	r3, r2
    a366:	f853 3c28 	ldr.w	r3, [r3, #-40]
    a36a:	613b      	str	r3, [r7, #16]
    PclkDiv1 = pclk_div_lut[((SYSREG->MSS_CLK_CR >> PCLK1_DIV_SHIFT) & PCLK_DIV_MASK)];
    a36c:	f242 0300 	movw	r3, #8192	; 0x2000
    a370:	f2ce 0304 	movt	r3, #57348	; 0xe004
    a374:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    a376:	ea4f 1313 	mov.w	r3, r3, lsr #4
    a37a:	f003 0303 	and.w	r3, r3, #3
    a37e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    a382:	f107 0228 	add.w	r2, r7, #40	; 0x28
    a386:	4413      	add	r3, r2
    a388:	f853 3c28 	ldr.w	r3, [r3, #-40]
    a38c:	617b      	str	r3, [r7, #20]
    AceDiv = pclk_div_lut[((SYSREG->MSS_CLK_CR >> ACE_DIV_SHIFT) & PCLK_DIV_MASK)];
    a38e:	f242 0300 	movw	r3, #8192	; 0x2000
    a392:	f2ce 0304 	movt	r3, #57348	; 0xe004
    a396:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    a398:	ea4f 1393 	mov.w	r3, r3, lsr #6
    a39c:	f003 0303 	and.w	r3, r3, #3
    a3a0:	ea4f 0383 	mov.w	r3, r3, lsl #2
    a3a4:	f107 0228 	add.w	r2, r7, #40	; 0x28
    a3a8:	4413      	add	r3, r2
    a3aa:	f853 3c28 	ldr.w	r3, [r3, #-40]
    a3ae:	61bb      	str	r3, [r7, #24]
    {
        /* Compute the FPGA fabric frequency divider. */
        uint32_t obdiv;
        uint32_t obdivhalf;
        
        obdiv = (SYSREG->MSS_CCC_DIV_CR >> OBDIV_SHIFT) & OBDIV_MASK;
    a3b0:	f242 0300 	movw	r3, #8192	; 0x2000
    a3b4:	f2ce 0304 	movt	r3, #57348	; 0xe004
    a3b8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    a3ba:	ea4f 2313 	mov.w	r3, r3, lsr #8
    a3be:	f003 031f 	and.w	r3, r3, #31
    a3c2:	623b      	str	r3, [r7, #32]
        obdivhalf = (SYSREG->MSS_CCC_DIV_CR >> OBDIVHALF_SHIFT) & OBDIVHALF_MASK;
    a3c4:	f242 0300 	movw	r3, #8192	; 0x2000
    a3c8:	f2ce 0304 	movt	r3, #57348	; 0xe004
    a3cc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    a3ce:	ea4f 3353 	mov.w	r3, r3, lsr #13
    a3d2:	f003 0301 	and.w	r3, r3, #1
    a3d6:	627b      	str	r3, [r7, #36]	; 0x24
        FabDiv = obdiv + 1uL;
    a3d8:	6a3b      	ldr	r3, [r7, #32]
    a3da:	f103 0301 	add.w	r3, r3, #1
    a3de:	61fb      	str	r3, [r7, #28]
        if ( obdivhalf != 0uL )
    a3e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    a3e2:	2b00      	cmp	r3, #0
    a3e4:	d003      	beq.n	a3ee <SystemCoreClockUpdate+0xba>
        {
            FabDiv = FabDiv * 2uL;
    a3e6:	69fb      	ldr	r3, [r7, #28]
    a3e8:	ea4f 0343 	mov.w	r3, r3, lsl #1
    a3ec:	61fb      	str	r3, [r7, #28]
    }
    
    /* Retrieve FCLK from eNVM spare pages if Actel system boot programmed as part of the system. */
    
    /* Read system clock from eNVM spare pages. */
    SystemCoreClock = GetSystemClock();
    a3ee:	f000 f849 	bl	a484 <GetSystemClock>
    a3f2:	4602      	mov	r2, r0
    a3f4:	f240 03ec 	movw	r3, #236	; 0xec
    a3f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a3fc:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK0 = SystemCoreClock / PclkDiv0;
    a3fe:	f240 03ec 	movw	r3, #236	; 0xec
    a402:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a406:	681a      	ldr	r2, [r3, #0]
    a408:	693b      	ldr	r3, [r7, #16]
    a40a:	fbb2 f2f3 	udiv	r2, r2, r3
    a40e:	f240 03f0 	movw	r3, #240	; 0xf0
    a412:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a416:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK1 = SystemCoreClock / PclkDiv1;
    a418:	f240 03ec 	movw	r3, #236	; 0xec
    a41c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a420:	681a      	ldr	r2, [r3, #0]
    a422:	697b      	ldr	r3, [r7, #20]
    a424:	fbb2 f2f3 	udiv	r2, r2, r3
    a428:	f240 03f4 	movw	r3, #244	; 0xf4
    a42c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a430:	601a      	str	r2, [r3, #0]
    g_FrequencyACE = SystemCoreClock / AceDiv;
    a432:	f240 03ec 	movw	r3, #236	; 0xec
    a436:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a43a:	681a      	ldr	r2, [r3, #0]
    a43c:	69bb      	ldr	r3, [r7, #24]
    a43e:	fbb2 f2f3 	udiv	r2, r2, r3
    a442:	f240 03f8 	movw	r3, #248	; 0xf8
    a446:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a44a:	601a      	str	r2, [r3, #0]
    g_FrequencyFPGA = SystemCoreClock / FabDiv;
    a44c:	f240 03ec 	movw	r3, #236	; 0xec
    a450:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a454:	681a      	ldr	r2, [r3, #0]
    a456:	69fb      	ldr	r3, [r7, #28]
    a458:	fbb2 f2f3 	udiv	r2, r2, r3
    a45c:	f240 03fc 	movw	r3, #252	; 0xfc
    a460:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a464:	601a      	str	r2, [r3, #0]
    
    /* Keep SystemFrequency as well as SystemCoreClock for legacy reasons. */
    SystemFrequency = SystemCoreClock;
    a466:	f240 03ec 	movw	r3, #236	; 0xec
    a46a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a46e:	681a      	ldr	r2, [r3, #0]
    a470:	f240 03e8 	movw	r3, #232	; 0xe8
    a474:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a478:	601a      	str	r2, [r3, #0]
}
    a47a:	f107 0728 	add.w	r7, r7, #40	; 0x28
    a47e:	46bd      	mov	sp, r7
    a480:	bd80      	pop	{r7, pc}
    a482:	bf00      	nop

0000a484 <GetSystemClock>:
 * retrieved from eNVM spare pages.
 * The FCLK frequency value selected in the MSS Configurator software tool is
 * stored in eNVM spare pages as part of the Actel system boot configuration data.
 */
uint32_t GetSystemClock( void )
{
    a484:	b480      	push	{r7}
    a486:	b08b      	sub	sp, #44	; 0x2c
    a488:	af00      	add	r7, sp, #0
    uint32_t fclk = 0uL;
    a48a:	f04f 0300 	mov.w	r3, #0
    a48e:	607b      	str	r3, [r7, #4]
    
    uint32_t * p_sysboot_key = SYSBOOT_KEY_ADDR;
    a490:	f640 031c 	movw	r3, #2076	; 0x81c
    a494:	f2c6 0308 	movt	r3, #24584	; 0x6008
    a498:	60bb      	str	r3, [r7, #8]
    uint32_t * p_idcode = IDCODE_LOCATION;
    a49a:	f240 2330 	movw	r3, #560	; 0x230
    a49e:	f2c6 0308 	movt	r3, #24584	; 0x6008
    a4a2:	60fb      	str	r3, [r7, #12]
    uint32_t idcode;
	
    idcode = *p_idcode & ~IDCODE_DEV_REV_MASK;
    a4a4:	68fb      	ldr	r3, [r7, #12]
    a4a6:	681b      	ldr	r3, [r3, #0]
    a4a8:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
    a4ac:	613b      	str	r3, [r7, #16]
	
    if ( A2F060IFX_ID == idcode )
    a4ae:	693a      	ldr	r2, [r7, #16]
    a4b0:	f241 13cf 	movw	r3, #4559	; 0x11cf
    a4b4:	f2c0 53a1 	movt	r3, #1441	; 0x5a1
    a4b8:	429a      	cmp	r2, r3
    a4ba:	d108      	bne.n	a4ce <GetSystemClock+0x4a>
    {
        uint32_t *p_fclk = SYSBOOT_A2F060_FCLK_ADDR;
    a4bc:	f64e 732c 	movw	r3, #61228	; 0xef2c
    a4c0:	f2c6 0301 	movt	r3, #24577	; 0x6001
    a4c4:	617b      	str	r3, [r7, #20]
        fclk = *p_fclk;
    a4c6:	697b      	ldr	r3, [r7, #20]
    a4c8:	681b      	ldr	r3, [r3, #0]
    a4ca:	607b      	str	r3, [r7, #4]
    a4cc:	e03d      	b.n	a54a <GetSystemClock+0xc6>
    }
    else if ( SYSBOOT_KEY_VALUE == *p_sysboot_key )
    a4ce:	68bb      	ldr	r3, [r7, #8]
    a4d0:	681a      	ldr	r2, [r3, #0]
    a4d2:	f244 3341 	movw	r3, #17217	; 0x4341
    a4d6:	f6c4 4354 	movt	r3, #19540	; 0x4c54
    a4da:	429a      	cmp	r2, r3
    a4dc:	d135      	bne.n	a54a <GetSystemClock+0xc6>
    {
        /* Actel system boot programmed, check if it has the FCLK value stored. */
        uint32_t *p_sysboot_version = SYSBOOT_VERSION_ADDR;
    a4de:	f640 0340 	movw	r3, #2112	; 0x840
    a4e2:	f2c6 0308 	movt	r3, #24584	; 0x6008
    a4e6:	61bb      	str	r3, [r7, #24]
        uint32_t sysboot_version = *p_sysboot_version;
    a4e8:	69bb      	ldr	r3, [r7, #24]
    a4ea:	681b      	ldr	r3, [r3, #0]
    a4ec:	61fb      	str	r3, [r7, #28]
        
        sysboot_version &= SYSBOOT_VERSION_MASK;
    a4ee:	69fb      	ldr	r3, [r7, #28]
    a4f0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    a4f4:	61fb      	str	r3, [r7, #28]
        
        if ( sysboot_version >= MIN_SYSBOOT_VERSION )
    a4f6:	69fa      	ldr	r2, [r7, #28]
    a4f8:	f240 3300 	movw	r3, #768	; 0x300
    a4fc:	f2c0 0301 	movt	r3, #1
    a500:	429a      	cmp	r2, r3
    a502:	d922      	bls.n	a54a <GetSystemClock+0xc6>
        {
            /* Handle change of eNVM location of FCLK between 1.3.x and 2.x.x versions of the system boot. */
            if ( sysboot_version < SYSBOOT_VERSION_2_X )
    a504:	69fa      	ldr	r2, [r7, #28]
    a506:	f64f 73ff 	movw	r3, #65535	; 0xffff
    a50a:	f2c0 0301 	movt	r3, #1
    a50e:	429a      	cmp	r2, r3
    a510:	d808      	bhi.n	a524 <GetSystemClock+0xa0>
            {
                /* Read FCLK value from MSS configurator generated configuration
                 * data stored in eNVM spare pages as part of system boot version 1.3.x
                 * configuration tables. */
                uint32_t *p_fclk = SYSBOOT_1_3_FCLK_ADDR;
    a512:	f241 632c 	movw	r3, #5676	; 0x162c
    a516:	f2c6 0308 	movt	r3, #24584	; 0x6008
    a51a:	623b      	str	r3, [r7, #32]
                fclk = *p_fclk;
    a51c:	6a3b      	ldr	r3, [r7, #32]
    a51e:	681b      	ldr	r3, [r3, #0]
    a520:	607b      	str	r3, [r7, #4]
    a522:	e012      	b.n	a54a <GetSystemClock+0xc6>
            }
            else if ( sysboot_version < MAX_SYSBOOT_VERSION )
    a524:	69fa      	ldr	r2, [r7, #28]
    a526:	f64f 73ff 	movw	r3, #65535	; 0xffff
    a52a:	f2c0 0302 	movt	r3, #2
    a52e:	429a      	cmp	r2, r3
    a530:	d808      	bhi.n	a544 <GetSystemClock+0xc0>
            {
                /* Read FCLK value from MSS configurator generated configuration
                 * data stored in eNVM spare pages as part of system boot version 2.x.x
                 * configuration tables. */
                uint32_t *p_fclk = SYSBOOT_2_x_FCLK_ADDR;
    a532:	f641 63ac 	movw	r3, #7852	; 0x1eac
    a536:	f2c6 0308 	movt	r3, #24584	; 0x6008
    a53a:	627b      	str	r3, [r7, #36]	; 0x24
                fclk = *p_fclk;
    a53c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    a53e:	681b      	ldr	r3, [r3, #0]
    a540:	607b      	str	r3, [r7, #4]
    a542:	e002      	b.n	a54a <GetSystemClock+0xc6>
            }
            else
            {
                fclk = 0uL;
    a544:	f04f 0300 	mov.w	r3, #0
    a548:	607b      	str	r3, [r7, #4]
            }
        }
    }
    
    if ( 0uL == fclk )
    a54a:	687b      	ldr	r3, [r7, #4]
    a54c:	2b00      	cmp	r3, #0
    a54e:	d105      	bne.n	a55c <GetSystemClock+0xd8>
        /* 
         * Could not retrieve FCLK from system boot configuration data. Fall back
         * to using SMARTFUSION_FCLK_FREQ which must then be defined as part of
         * project settings.
         */
        ASSERT( SMARTFUSION_FCLK_FREQ_DEFINED );
    a550:	be00      	bkpt	0x0000
        fclk = SMARTFUSION_FCLK_FREQ;
    a552:	f647 0340 	movw	r3, #30784	; 0x7840
    a556:	f2c0 137d 	movt	r3, #381	; 0x17d
    a55a:	607b      	str	r3, [r7, #4]
    }
    
    return fclk;
    a55c:	687b      	ldr	r3, [r7, #4]
}
    a55e:	4618      	mov	r0, r3
    a560:	f107 072c 	add.w	r7, r7, #44	; 0x2c
    a564:	46bd      	mov	sp, r7
    a566:	bc80      	pop	{r7}
    a568:	4770      	bx	lr
    a56a:	bf00      	nop

0000a56c <_close>:

/*==============================================================================
 * Close a file.
 */
int _close(int file)
{
    a56c:	b480      	push	{r7}
    a56e:	b083      	sub	sp, #12
    a570:	af00      	add	r7, sp, #0
    a572:	6078      	str	r0, [r7, #4]
    return -1;
    a574:	f04f 33ff 	mov.w	r3, #4294967295
}
    a578:	4618      	mov	r0, r3
    a57a:	f107 070c 	add.w	r7, r7, #12
    a57e:	46bd      	mov	sp, r7
    a580:	bc80      	pop	{r7}
    a582:	4770      	bx	lr

0000a584 <_execve>:

/*==============================================================================
 * Transfer control to a new process.
 */
int _execve(char *name, char **argv, char **env)
{
    a584:	b580      	push	{r7, lr}
    a586:	b084      	sub	sp, #16
    a588:	af00      	add	r7, sp, #0
    a58a:	60f8      	str	r0, [r7, #12]
    a58c:	60b9      	str	r1, [r7, #8]
    a58e:	607a      	str	r2, [r7, #4]
    errno = ENOMEM;
    a590:	f00a ff22 	bl	153d8 <__errno>
    a594:	4603      	mov	r3, r0
    a596:	f04f 020c 	mov.w	r2, #12
    a59a:	601a      	str	r2, [r3, #0]
    return -1;
    a59c:	f04f 33ff 	mov.w	r3, #4294967295
}
    a5a0:	4618      	mov	r0, r3
    a5a2:	f107 0710 	add.w	r7, r7, #16
    a5a6:	46bd      	mov	sp, r7
    a5a8:	bd80      	pop	{r7, pc}
    a5aa:	bf00      	nop

0000a5ac <_exit>:
{
	/* Should we force a system reset? */
	while( 1 )
	{
		;
	}
    a5ac:	b480      	push	{r7}
    a5ae:	b083      	sub	sp, #12
    a5b0:	af00      	add	r7, sp, #0
    a5b2:	6078      	str	r0, [r7, #4]
    a5b4:	e7fe      	b.n	a5b4 <_exit+0x8>
    a5b6:	bf00      	nop

0000a5b8 <_fork>:

/*==============================================================================
 * Create a new process.
 */
int _fork(void)
{
    a5b8:	b580      	push	{r7, lr}
    a5ba:	af00      	add	r7, sp, #0
    errno = EAGAIN;
    a5bc:	f00a ff0c 	bl	153d8 <__errno>
    a5c0:	4603      	mov	r3, r0
    a5c2:	f04f 020b 	mov.w	r2, #11
    a5c6:	601a      	str	r2, [r3, #0]
    return -1;
    a5c8:	f04f 33ff 	mov.w	r3, #4294967295
}
    a5cc:	4618      	mov	r0, r3
    a5ce:	bd80      	pop	{r7, pc}

0000a5d0 <_fstat>:

/*==============================================================================
 * Status of an open file.
 */
int _fstat(int file, struct stat *st)
{
    a5d0:	b480      	push	{r7}
    a5d2:	b083      	sub	sp, #12
    a5d4:	af00      	add	r7, sp, #0
    a5d6:	6078      	str	r0, [r7, #4]
    a5d8:	6039      	str	r1, [r7, #0]
    st->st_mode = S_IFCHR;
    a5da:	683b      	ldr	r3, [r7, #0]
    a5dc:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    a5e0:	605a      	str	r2, [r3, #4]
    return 0;
    a5e2:	f04f 0300 	mov.w	r3, #0
}
    a5e6:	4618      	mov	r0, r3
    a5e8:	f107 070c 	add.w	r7, r7, #12
    a5ec:	46bd      	mov	sp, r7
    a5ee:	bc80      	pop	{r7}
    a5f0:	4770      	bx	lr
    a5f2:	bf00      	nop

0000a5f4 <_getpid>:

/*==============================================================================
 * Process-ID
 */
int _getpid(void)
{
    a5f4:	b480      	push	{r7}
    a5f6:	af00      	add	r7, sp, #0
    return 1;
    a5f8:	f04f 0301 	mov.w	r3, #1
}
    a5fc:	4618      	mov	r0, r3
    a5fe:	46bd      	mov	sp, r7
    a600:	bc80      	pop	{r7}
    a602:	4770      	bx	lr

0000a604 <_isatty>:

/*==============================================================================
 * Query whether output stream is a terminal.
 */
int _isatty(int file)
{
    a604:	b480      	push	{r7}
    a606:	b083      	sub	sp, #12
    a608:	af00      	add	r7, sp, #0
    a60a:	6078      	str	r0, [r7, #4]
    return 1;
    a60c:	f04f 0301 	mov.w	r3, #1
}
    a610:	4618      	mov	r0, r3
    a612:	f107 070c 	add.w	r7, r7, #12
    a616:	46bd      	mov	sp, r7
    a618:	bc80      	pop	{r7}
    a61a:	4770      	bx	lr

0000a61c <_kill>:

/*==============================================================================
 * Send a signal.
 */
int _kill(int pid, int sig)
{
    a61c:	b580      	push	{r7, lr}
    a61e:	b082      	sub	sp, #8
    a620:	af00      	add	r7, sp, #0
    a622:	6078      	str	r0, [r7, #4]
    a624:	6039      	str	r1, [r7, #0]
    errno = EINVAL;
    a626:	f00a fed7 	bl	153d8 <__errno>
    a62a:	4603      	mov	r3, r0
    a62c:	f04f 0216 	mov.w	r2, #22
    a630:	601a      	str	r2, [r3, #0]
    return -1;
    a632:	f04f 33ff 	mov.w	r3, #4294967295
}
    a636:	4618      	mov	r0, r3
    a638:	f107 0708 	add.w	r7, r7, #8
    a63c:	46bd      	mov	sp, r7
    a63e:	bd80      	pop	{r7, pc}

0000a640 <_link>:

/*==============================================================================
 * Establish a new name for an existing file.
 */
int _link(char *old, char *new)
{
    a640:	b580      	push	{r7, lr}
    a642:	b082      	sub	sp, #8
    a644:	af00      	add	r7, sp, #0
    a646:	6078      	str	r0, [r7, #4]
    a648:	6039      	str	r1, [r7, #0]
    errno = EMLINK;
    a64a:	f00a fec5 	bl	153d8 <__errno>
    a64e:	4603      	mov	r3, r0
    a650:	f04f 021f 	mov.w	r2, #31
    a654:	601a      	str	r2, [r3, #0]
    return -1;
    a656:	f04f 33ff 	mov.w	r3, #4294967295
}
    a65a:	4618      	mov	r0, r3
    a65c:	f107 0708 	add.w	r7, r7, #8
    a660:	46bd      	mov	sp, r7
    a662:	bd80      	pop	{r7, pc}

0000a664 <_lseek>:

/*==============================================================================
 * Set position in a file.
 */
int _lseek(int file, int ptr, int dir)
{
    a664:	b480      	push	{r7}
    a666:	b085      	sub	sp, #20
    a668:	af00      	add	r7, sp, #0
    a66a:	60f8      	str	r0, [r7, #12]
    a66c:	60b9      	str	r1, [r7, #8]
    a66e:	607a      	str	r2, [r7, #4]
    return 0;
    a670:	f04f 0300 	mov.w	r3, #0
}
    a674:	4618      	mov	r0, r3
    a676:	f107 0714 	add.w	r7, r7, #20
    a67a:	46bd      	mov	sp, r7
    a67c:	bc80      	pop	{r7}
    a67e:	4770      	bx	lr

0000a680 <_open>:

/*==============================================================================
 * Open a file.
 */
int _open(const char *name, int flags, int mode)
{
    a680:	b480      	push	{r7}
    a682:	b085      	sub	sp, #20
    a684:	af00      	add	r7, sp, #0
    a686:	60f8      	str	r0, [r7, #12]
    a688:	60b9      	str	r1, [r7, #8]
    a68a:	607a      	str	r2, [r7, #4]
    return -1;
    a68c:	f04f 33ff 	mov.w	r3, #4294967295
}
    a690:	4618      	mov	r0, r3
    a692:	f107 0714 	add.w	r7, r7, #20
    a696:	46bd      	mov	sp, r7
    a698:	bc80      	pop	{r7}
    a69a:	4770      	bx	lr

0000a69c <_read>:

/*==============================================================================
 * Read from a file.
 */
int _read(int file, char *ptr, int len)
{
    a69c:	b480      	push	{r7}
    a69e:	b085      	sub	sp, #20
    a6a0:	af00      	add	r7, sp, #0
    a6a2:	60f8      	str	r0, [r7, #12]
    a6a4:	60b9      	str	r1, [r7, #8]
    a6a6:	607a      	str	r2, [r7, #4]
    return 0;
    a6a8:	f04f 0300 	mov.w	r3, #0
}
    a6ac:	4618      	mov	r0, r3
    a6ae:	f107 0714 	add.w	r7, r7, #20
    a6b2:	46bd      	mov	sp, r7
    a6b4:	bc80      	pop	{r7}
    a6b6:	4770      	bx	lr

0000a6b8 <_write_r>:
 * all files, including stdoutso if you need to generate any output, for
 * example to a serial port for debugging, you should make your minimal write
 * capable of doing this.
 */
int _write_r( void * reent, int file, char * ptr, int len )
{
    a6b8:	b580      	push	{r7, lr}
    a6ba:	b084      	sub	sp, #16
    a6bc:	af00      	add	r7, sp, #0
    a6be:	60f8      	str	r0, [r7, #12]
    a6c0:	60b9      	str	r1, [r7, #8]
    a6c2:	607a      	str	r2, [r7, #4]
    a6c4:	603b      	str	r3, [r7, #0]
#ifdef ACTEL_STDIO_THRU_UART
    /*--------------------------------------------------------------------------
     * Initialize the UART driver if it is the first time this function is
     * called.
     */
    if ( !g_stdio_uart_init_done )
    a6c6:	f642 7340 	movw	r3, #12096	; 0x2f40
    a6ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a6ce:	681b      	ldr	r3, [r3, #0]
    a6d0:	2b00      	cmp	r3, #0
    a6d2:	d110      	bne.n	a6f6 <_write_r+0x3e>
    {
        MSS_UART_init( &g_mss_uart0, ACTEL_STDIO_BAUD_RATE, (MSS_UART_DATA_8_BITS | MSS_UART_NO_PARITY));
    a6d4:	f64a 10d0 	movw	r0, #43472	; 0xa9d0
    a6d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
    a6dc:	f44f 4161 	mov.w	r1, #57600	; 0xe100
    a6e0:	f04f 0203 	mov.w	r2, #3
    a6e4:	f7f7 fbde 	bl	1ea4 <MSS_UART_init>
        g_stdio_uart_init_done = 1;
    a6e8:	f642 7340 	movw	r3, #12096	; 0x2f40
    a6ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a6f0:	f04f 0201 	mov.w	r2, #1
    a6f4:	601a      	str	r2, [r3, #0]
    }
    
    /*--------------------------------------------------------------------------
     * Output text to the UART.
     */
    MSS_UART_polled_tx( &g_mss_uart0, (uint8_t *)ptr, len );
    a6f6:	683b      	ldr	r3, [r7, #0]
    a6f8:	f64a 10d0 	movw	r0, #43472	; 0xa9d0
    a6fc:	f2c2 0000 	movt	r0, #8192	; 0x2000
    a700:	6879      	ldr	r1, [r7, #4]
    a702:	461a      	mov	r2, r3
    a704:	f7f7 fcd0 	bl	20a8 <MSS_UART_polled_tx>
    
    return len;
    a708:	683b      	ldr	r3, [r7, #0]
#else   /* ACTEL_STDIO_THRU_UART */
    return 0;
#endif  /* ACTEL_STDIO_THRU_UART */
}
    a70a:	4618      	mov	r0, r3
    a70c:	f107 0710 	add.w	r7, r7, #16
    a710:	46bd      	mov	sp, r7
    a712:	bd80      	pop	{r7, pc}

0000a714 <_sbrk>:
 * it is useful to have a working implementation. The following suffices for a
 * standalone system; it exploits the symbol _end automatically defined by the
 * GNU linker. 
 */
caddr_t _sbrk(int incr)
{
    a714:	b580      	push	{r7, lr}
    a716:	b084      	sub	sp, #16
    a718:	af00      	add	r7, sp, #0
    a71a:	6078      	str	r0, [r7, #4]
    extern char _end;		/* Defined by the linker */
    static char *heap_end;
    char *prev_heap_end;
    char * stack_ptr;
    
    if (heap_end == 0)
    a71c:	f642 7348 	movw	r3, #12104	; 0x2f48
    a720:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a724:	681b      	ldr	r3, [r3, #0]
    a726:	2b00      	cmp	r3, #0
    a728:	d108      	bne.n	a73c <_sbrk+0x28>
    {
      heap_end = &_end;
    a72a:	f642 7348 	movw	r3, #12104	; 0x2f48
    a72e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a732:	f64c 42a8 	movw	r2, #52392	; 0xcca8
    a736:	f2c2 0200 	movt	r2, #8192	; 0x2000
    a73a:	601a      	str	r2, [r3, #0]
    }
    
    prev_heap_end = heap_end;
    a73c:	f642 7348 	movw	r3, #12104	; 0x2f48
    a740:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a744:	681b      	ldr	r3, [r3, #0]
    a746:	60bb      	str	r3, [r7, #8]
    asm volatile ("MRS %0, msp" : "=r" (stack_ptr) );
    a748:	f3ef 8308 	mrs	r3, MSP
    a74c:	60fb      	str	r3, [r7, #12]
    if (heap_end + incr > stack_ptr)
    a74e:	f642 7348 	movw	r3, #12104	; 0x2f48
    a752:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a756:	681a      	ldr	r2, [r3, #0]
    a758:	687b      	ldr	r3, [r7, #4]
    a75a:	441a      	add	r2, r3
    a75c:	68fb      	ldr	r3, [r7, #12]
    a75e:	429a      	cmp	r2, r3
    a760:	d90f      	bls.n	a782 <_sbrk+0x6e>
    {
      _write_r ((void *)0, 1, "Heap and stack collision\n", 25);
    a762:	f04f 0000 	mov.w	r0, #0
    a766:	f04f 0101 	mov.w	r1, #1
    a76a:	f24d 1200 	movw	r2, #53504	; 0xd100
    a76e:	f2c0 0201 	movt	r2, #1
    a772:	f04f 0319 	mov.w	r3, #25
    a776:	f7ff ff9f 	bl	a6b8 <_write_r>
      _exit (1);
    a77a:	f04f 0001 	mov.w	r0, #1
    a77e:	f7ff ff15 	bl	a5ac <_exit>
    }
  
    heap_end += incr;
    a782:	f642 7348 	movw	r3, #12104	; 0x2f48
    a786:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a78a:	681a      	ldr	r2, [r3, #0]
    a78c:	687b      	ldr	r3, [r7, #4]
    a78e:	441a      	add	r2, r3
    a790:	f642 7348 	movw	r3, #12104	; 0x2f48
    a794:	f2c2 0300 	movt	r3, #8192	; 0x2000
    a798:	601a      	str	r2, [r3, #0]
    return (caddr_t) prev_heap_end;
    a79a:	68bb      	ldr	r3, [r7, #8]
}
    a79c:	4618      	mov	r0, r3
    a79e:	f107 0710 	add.w	r7, r7, #16
    a7a2:	46bd      	mov	sp, r7
    a7a4:	bd80      	pop	{r7, pc}
    a7a6:	bf00      	nop

0000a7a8 <_stat>:

/*==============================================================================
 * Status of a file (by name).
 */
int _stat(char *file, struct stat *st)
{
    a7a8:	b480      	push	{r7}
    a7aa:	b083      	sub	sp, #12
    a7ac:	af00      	add	r7, sp, #0
    a7ae:	6078      	str	r0, [r7, #4]
    a7b0:	6039      	str	r1, [r7, #0]
    st->st_mode = S_IFCHR;
    a7b2:	683b      	ldr	r3, [r7, #0]
    a7b4:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    a7b8:	605a      	str	r2, [r3, #4]
    return 0;
    a7ba:	f04f 0300 	mov.w	r3, #0
}
    a7be:	4618      	mov	r0, r3
    a7c0:	f107 070c 	add.w	r7, r7, #12
    a7c4:	46bd      	mov	sp, r7
    a7c6:	bc80      	pop	{r7}
    a7c8:	4770      	bx	lr
    a7ca:	bf00      	nop

0000a7cc <_times>:

/*==============================================================================
 * Timing information for current process.
 */
int _times(struct tms *buf)
{
    a7cc:	b480      	push	{r7}
    a7ce:	b083      	sub	sp, #12
    a7d0:	af00      	add	r7, sp, #0
    a7d2:	6078      	str	r0, [r7, #4]
    return -1;
    a7d4:	f04f 33ff 	mov.w	r3, #4294967295
}
    a7d8:	4618      	mov	r0, r3
    a7da:	f107 070c 	add.w	r7, r7, #12
    a7de:	46bd      	mov	sp, r7
    a7e0:	bc80      	pop	{r7}
    a7e2:	4770      	bx	lr

0000a7e4 <_unlink>:

/*==============================================================================
 * Remove a file's directory entry.
 */
int _unlink(char *name)
{
    a7e4:	b580      	push	{r7, lr}
    a7e6:	b082      	sub	sp, #8
    a7e8:	af00      	add	r7, sp, #0
    a7ea:	6078      	str	r0, [r7, #4]
    errno = ENOENT;
    a7ec:	f00a fdf4 	bl	153d8 <__errno>
    a7f0:	4603      	mov	r3, r0
    a7f2:	f04f 0202 	mov.w	r2, #2
    a7f6:	601a      	str	r2, [r3, #0]
    return -1;
    a7f8:	f04f 33ff 	mov.w	r3, #4294967295
}
    a7fc:	4618      	mov	r0, r3
    a7fe:	f107 0708 	add.w	r7, r7, #8
    a802:	46bd      	mov	sp, r7
    a804:	bd80      	pop	{r7, pc}
    a806:	bf00      	nop

0000a808 <_wait>:

/*==============================================================================
 * Wait for a child process.
 */
int _wait(int *status)
{
    a808:	b580      	push	{r7, lr}
    a80a:	b082      	sub	sp, #8
    a80c:	af00      	add	r7, sp, #0
    a80e:	6078      	str	r0, [r7, #4]
    errno = ECHILD;
    a810:	f00a fde2 	bl	153d8 <__errno>
    a814:	4603      	mov	r3, r0
    a816:	f04f 020a 	mov.w	r2, #10
    a81a:	601a      	str	r2, [r3, #0]
    return -1;
    a81c:	f04f 33ff 	mov.w	r3, #4294967295
}
    a820:	4618      	mov	r0, r3
    a822:	f107 0708 	add.w	r7, r7, #8
    a826:	46bd      	mov	sp, r7
    a828:	bd80      	pop	{r7, pc}
    a82a:	bf00      	nop

0000a82c <uart_string_print>:
//Only uart 0 will be used in this project

mss_uart_instance_t * const uart_instance = &g_mss_uart0;


void uart_string_print(uint8_t * uart_string){
    a82c:	b580      	push	{r7, lr}
    a82e:	b082      	sub	sp, #8
    a830:	af00      	add	r7, sp, #0
    a832:	6078      	str	r0, [r7, #4]
	MSS_UART_polled_tx_string(uart_instance, uart_string);
    a834:	f24d 131c 	movw	r3, #53532	; 0xd11c
    a838:	f2c0 0301 	movt	r3, #1
    a83c:	681b      	ldr	r3, [r3, #0]
    a83e:	4618      	mov	r0, r3
    a840:	6879      	ldr	r1, [r7, #4]
    a842:	f7f7 fca3 	bl	218c <MSS_UART_polled_tx_string>
}
    a846:	f107 0708 	add.w	r7, r7, #8
    a84a:	46bd      	mov	sp, r7
    a84c:	bd80      	pop	{r7, pc}
    a84e:	bf00      	nop

0000a850 <buf_setup>:

/*---------------------------------------------------------------------------*/
static void
buf_setup(struct psock_buf *buf,
	  u8_t *bufptr, u16_t bufsize)
{
    a850:	b480      	push	{r7}
    a852:	b085      	sub	sp, #20
    a854:	af00      	add	r7, sp, #0
    a856:	60f8      	str	r0, [r7, #12]
    a858:	60b9      	str	r1, [r7, #8]
    a85a:	4613      	mov	r3, r2
    a85c:	80fb      	strh	r3, [r7, #6]
  buf->ptr = bufptr;
    a85e:	68fb      	ldr	r3, [r7, #12]
    a860:	68ba      	ldr	r2, [r7, #8]
    a862:	601a      	str	r2, [r3, #0]
  buf->left = bufsize;
    a864:	68fb      	ldr	r3, [r7, #12]
    a866:	88fa      	ldrh	r2, [r7, #6]
    a868:	809a      	strh	r2, [r3, #4]
}
    a86a:	f107 0714 	add.w	r7, r7, #20
    a86e:	46bd      	mov	sp, r7
    a870:	bc80      	pop	{r7}
    a872:	4770      	bx	lr

0000a874 <buf_bufdata>:
/*---------------------------------------------------------------------------*/
static u8_t
buf_bufdata(struct psock_buf *buf, u16_t len,
	    u8_t **dataptr, u16_t *datalen)
{
    a874:	b580      	push	{r7, lr}
    a876:	b084      	sub	sp, #16
    a878:	af00      	add	r7, sp, #0
    a87a:	60f8      	str	r0, [r7, #12]
    a87c:	607a      	str	r2, [r7, #4]
    a87e:	603b      	str	r3, [r7, #0]
    a880:	460b      	mov	r3, r1
    a882:	817b      	strh	r3, [r7, #10]
  ( void ) len;
  if(*datalen < buf->left) {
    a884:	683b      	ldr	r3, [r7, #0]
    a886:	881a      	ldrh	r2, [r3, #0]
    a888:	68fb      	ldr	r3, [r7, #12]
    a88a:	889b      	ldrh	r3, [r3, #4]
    a88c:	429a      	cmp	r2, r3
    a88e:	d228      	bcs.n	a8e2 <buf_bufdata+0x6e>
    memcpy(buf->ptr, *dataptr, *datalen);
    a890:	68fb      	ldr	r3, [r7, #12]
    a892:	6819      	ldr	r1, [r3, #0]
    a894:	687b      	ldr	r3, [r7, #4]
    a896:	681a      	ldr	r2, [r3, #0]
    a898:	683b      	ldr	r3, [r7, #0]
    a89a:	881b      	ldrh	r3, [r3, #0]
    a89c:	4608      	mov	r0, r1
    a89e:	4611      	mov	r1, r2
    a8a0:	461a      	mov	r2, r3
    a8a2:	f00a fdc7 	bl	15434 <memcpy>
    buf->ptr += *datalen;
    a8a6:	68fb      	ldr	r3, [r7, #12]
    a8a8:	681a      	ldr	r2, [r3, #0]
    a8aa:	683b      	ldr	r3, [r7, #0]
    a8ac:	881b      	ldrh	r3, [r3, #0]
    a8ae:	441a      	add	r2, r3
    a8b0:	68fb      	ldr	r3, [r7, #12]
    a8b2:	601a      	str	r2, [r3, #0]
    buf->left -= *datalen;
    a8b4:	68fb      	ldr	r3, [r7, #12]
    a8b6:	889a      	ldrh	r2, [r3, #4]
    a8b8:	683b      	ldr	r3, [r7, #0]
    a8ba:	881b      	ldrh	r3, [r3, #0]
    a8bc:	ebc3 0302 	rsb	r3, r3, r2
    a8c0:	b29a      	uxth	r2, r3
    a8c2:	68fb      	ldr	r3, [r7, #12]
    a8c4:	809a      	strh	r2, [r3, #4]
    *dataptr += *datalen;
    a8c6:	687b      	ldr	r3, [r7, #4]
    a8c8:	681a      	ldr	r2, [r3, #0]
    a8ca:	683b      	ldr	r3, [r7, #0]
    a8cc:	881b      	ldrh	r3, [r3, #0]
    a8ce:	441a      	add	r2, r3
    a8d0:	687b      	ldr	r3, [r7, #4]
    a8d2:	601a      	str	r2, [r3, #0]
    *datalen = 0;
    a8d4:	683b      	ldr	r3, [r7, #0]
    a8d6:	f04f 0200 	mov.w	r2, #0
    a8da:	801a      	strh	r2, [r3, #0]
    return BUF_NOT_FULL;
    a8dc:	f04f 0300 	mov.w	r3, #0
    a8e0:	e051      	b.n	a986 <buf_bufdata+0x112>
  } else if(*datalen == buf->left) {
    a8e2:	683b      	ldr	r3, [r7, #0]
    a8e4:	881a      	ldrh	r2, [r3, #0]
    a8e6:	68fb      	ldr	r3, [r7, #12]
    a8e8:	889b      	ldrh	r3, [r3, #4]
    a8ea:	429a      	cmp	r2, r3
    a8ec:	d123      	bne.n	a936 <buf_bufdata+0xc2>
    memcpy(buf->ptr, *dataptr, *datalen);
    a8ee:	68fb      	ldr	r3, [r7, #12]
    a8f0:	6819      	ldr	r1, [r3, #0]
    a8f2:	687b      	ldr	r3, [r7, #4]
    a8f4:	681a      	ldr	r2, [r3, #0]
    a8f6:	683b      	ldr	r3, [r7, #0]
    a8f8:	881b      	ldrh	r3, [r3, #0]
    a8fa:	4608      	mov	r0, r1
    a8fc:	4611      	mov	r1, r2
    a8fe:	461a      	mov	r2, r3
    a900:	f00a fd98 	bl	15434 <memcpy>
    buf->ptr += *datalen;
    a904:	68fb      	ldr	r3, [r7, #12]
    a906:	681a      	ldr	r2, [r3, #0]
    a908:	683b      	ldr	r3, [r7, #0]
    a90a:	881b      	ldrh	r3, [r3, #0]
    a90c:	441a      	add	r2, r3
    a90e:	68fb      	ldr	r3, [r7, #12]
    a910:	601a      	str	r2, [r3, #0]
    buf->left = 0;
    a912:	68fb      	ldr	r3, [r7, #12]
    a914:	f04f 0200 	mov.w	r2, #0
    a918:	809a      	strh	r2, [r3, #4]
    *dataptr += *datalen;
    a91a:	687b      	ldr	r3, [r7, #4]
    a91c:	681a      	ldr	r2, [r3, #0]
    a91e:	683b      	ldr	r3, [r7, #0]
    a920:	881b      	ldrh	r3, [r3, #0]
    a922:	441a      	add	r2, r3
    a924:	687b      	ldr	r3, [r7, #4]
    a926:	601a      	str	r2, [r3, #0]
    *datalen = 0;
    a928:	683b      	ldr	r3, [r7, #0]
    a92a:	f04f 0200 	mov.w	r2, #0
    a92e:	801a      	strh	r2, [r3, #0]
    return BUF_FULL;
    a930:	f04f 0301 	mov.w	r3, #1
    a934:	e027      	b.n	a986 <buf_bufdata+0x112>
  } else {
    memcpy(buf->ptr, *dataptr, buf->left);
    a936:	68fb      	ldr	r3, [r7, #12]
    a938:	6819      	ldr	r1, [r3, #0]
    a93a:	687b      	ldr	r3, [r7, #4]
    a93c:	681a      	ldr	r2, [r3, #0]
    a93e:	68fb      	ldr	r3, [r7, #12]
    a940:	889b      	ldrh	r3, [r3, #4]
    a942:	4608      	mov	r0, r1
    a944:	4611      	mov	r1, r2
    a946:	461a      	mov	r2, r3
    a948:	f00a fd74 	bl	15434 <memcpy>
    buf->ptr += buf->left;
    a94c:	68fb      	ldr	r3, [r7, #12]
    a94e:	681a      	ldr	r2, [r3, #0]
    a950:	68fb      	ldr	r3, [r7, #12]
    a952:	889b      	ldrh	r3, [r3, #4]
    a954:	441a      	add	r2, r3
    a956:	68fb      	ldr	r3, [r7, #12]
    a958:	601a      	str	r2, [r3, #0]
    *datalen -= buf->left;
    a95a:	683b      	ldr	r3, [r7, #0]
    a95c:	881a      	ldrh	r2, [r3, #0]
    a95e:	68fb      	ldr	r3, [r7, #12]
    a960:	889b      	ldrh	r3, [r3, #4]
    a962:	ebc3 0302 	rsb	r3, r3, r2
    a966:	b29a      	uxth	r2, r3
    a968:	683b      	ldr	r3, [r7, #0]
    a96a:	801a      	strh	r2, [r3, #0]
    *dataptr += buf->left;
    a96c:	687b      	ldr	r3, [r7, #4]
    a96e:	681a      	ldr	r2, [r3, #0]
    a970:	68fb      	ldr	r3, [r7, #12]
    a972:	889b      	ldrh	r3, [r3, #4]
    a974:	441a      	add	r2, r3
    a976:	687b      	ldr	r3, [r7, #4]
    a978:	601a      	str	r2, [r3, #0]
    buf->left = 0;
    a97a:	68fb      	ldr	r3, [r7, #12]
    a97c:	f04f 0200 	mov.w	r2, #0
    a980:	809a      	strh	r2, [r3, #4]
    return BUF_FULL;
    a982:	f04f 0301 	mov.w	r3, #1
  }
}
    a986:	4618      	mov	r0, r3
    a988:	f107 0710 	add.w	r7, r7, #16
    a98c:	46bd      	mov	sp, r7
    a98e:	bd80      	pop	{r7, pc}

0000a990 <buf_bufto>:
/*---------------------------------------------------------------------------*/
static u8_t
buf_bufto(register struct psock_buf *buf, u8_t endmarker,
	  register u8_t **dataptr, register u16_t *datalen)
{
    a990:	b480      	push	{r7}
    a992:	b085      	sub	sp, #20
    a994:	af00      	add	r7, sp, #0
    a996:	71f9      	strb	r1, [r7, #7]
  u8_t c;
  while(buf->left > 0 && *datalen > 0) {
    a998:	e022      	b.n	a9e0 <buf_bufto+0x50>
    c = *buf->ptr = **dataptr;
    a99a:	6801      	ldr	r1, [r0, #0]
    a99c:	f8d2 c000 	ldr.w	ip, [r2]
    a9a0:	f89c c000 	ldrb.w	ip, [ip]
    a9a4:	f881 c000 	strb.w	ip, [r1]
    a9a8:	7809      	ldrb	r1, [r1, #0]
    a9aa:	73f9      	strb	r1, [r7, #15]
    ++*dataptr;
    a9ac:	6811      	ldr	r1, [r2, #0]
    a9ae:	f101 0101 	add.w	r1, r1, #1
    a9b2:	6011      	str	r1, [r2, #0]
    ++buf->ptr;
    a9b4:	6801      	ldr	r1, [r0, #0]
    a9b6:	f101 0101 	add.w	r1, r1, #1
    a9ba:	6001      	str	r1, [r0, #0]
    --*datalen;
    a9bc:	8819      	ldrh	r1, [r3, #0]
    a9be:	f101 31ff 	add.w	r1, r1, #4294967295
    a9c2:	b289      	uxth	r1, r1
    a9c4:	8019      	strh	r1, [r3, #0]
    --buf->left;
    a9c6:	8881      	ldrh	r1, [r0, #4]
    a9c8:	f101 31ff 	add.w	r1, r1, #4294967295
    a9cc:	b289      	uxth	r1, r1
    a9ce:	8081      	strh	r1, [r0, #4]

    if(c == endmarker) {
    a9d0:	f897 c00f 	ldrb.w	ip, [r7, #15]
    a9d4:	79f9      	ldrb	r1, [r7, #7]
    a9d6:	458c      	cmp	ip, r1
    a9d8:	d102      	bne.n	a9e0 <buf_bufto+0x50>
      return BUF_FOUND;
    a9da:	f04f 0302 	mov.w	r3, #2
    a9de:	e024      	b.n	aa2a <buf_bufto+0x9a>
static u8_t
buf_bufto(register struct psock_buf *buf, u8_t endmarker,
	  register u8_t **dataptr, register u16_t *datalen)
{
  u8_t c;
  while(buf->left > 0 && *datalen > 0) {
    a9e0:	8881      	ldrh	r1, [r0, #4]
    a9e2:	2900      	cmp	r1, #0
    a9e4:	d002      	beq.n	a9ec <buf_bufto+0x5c>
    a9e6:	8819      	ldrh	r1, [r3, #0]
    a9e8:	2900      	cmp	r1, #0
    a9ea:	d1d6      	bne.n	a99a <buf_bufto+0xa>
    if(c == endmarker) {
      return BUF_FOUND;
    }
  }

  if(*datalen == 0) {
    a9ec:	8819      	ldrh	r1, [r3, #0]
    a9ee:	2900      	cmp	r1, #0
    a9f0:	d115      	bne.n	aa1e <buf_bufto+0x8e>
    return BUF_NOT_FOUND;
    a9f2:	f04f 0300 	mov.w	r3, #0
    a9f6:	e018      	b.n	aa2a <buf_bufto+0x9a>
  }

  while(*datalen > 0) {
    c = **dataptr;
    a9f8:	6811      	ldr	r1, [r2, #0]
    a9fa:	7809      	ldrb	r1, [r1, #0]
    a9fc:	73f9      	strb	r1, [r7, #15]
    --*datalen;
    a9fe:	8819      	ldrh	r1, [r3, #0]
    aa00:	f101 31ff 	add.w	r1, r1, #4294967295
    aa04:	b289      	uxth	r1, r1
    aa06:	8019      	strh	r1, [r3, #0]
    ++*dataptr;
    aa08:	6811      	ldr	r1, [r2, #0]
    aa0a:	f101 0101 	add.w	r1, r1, #1
    aa0e:	6011      	str	r1, [r2, #0]

    if(c == endmarker) {
    aa10:	7bf8      	ldrb	r0, [r7, #15]
    aa12:	79f9      	ldrb	r1, [r7, #7]
    aa14:	4288      	cmp	r0, r1
    aa16:	d103      	bne.n	aa20 <buf_bufto+0x90>
      return BUF_FOUND | BUF_FULL;
    aa18:	f04f 0303 	mov.w	r3, #3
    aa1c:	e005      	b.n	aa2a <buf_bufto+0x9a>

  if(*datalen == 0) {
    return BUF_NOT_FOUND;
  }

  while(*datalen > 0) {
    aa1e:	bf00      	nop
    aa20:	8819      	ldrh	r1, [r3, #0]
    aa22:	2900      	cmp	r1, #0
    aa24:	d1e8      	bne.n	a9f8 <buf_bufto+0x68>
    if(c == endmarker) {
      return BUF_FOUND | BUF_FULL;
    }
  }

  return BUF_FULL;
    aa26:	f04f 0301 	mov.w	r3, #1
}
    aa2a:	4618      	mov	r0, r3
    aa2c:	f107 0714 	add.w	r7, r7, #20
    aa30:	46bd      	mov	sp, r7
    aa32:	bc80      	pop	{r7}
    aa34:	4770      	bx	lr
    aa36:	bf00      	nop

0000aa38 <send_data>:
/*---------------------------------------------------------------------------*/
static char
send_data(register struct psock *s)
{
    aa38:	b598      	push	{r3, r4, r7, lr}
    aa3a:	af00      	add	r7, sp, #0
    aa3c:	4604      	mov	r4, r0
  if(s->state != STATE_DATA_SENT || uip_rexmit()) {
    aa3e:	f894 3020 	ldrb.w	r3, [r4, #32]
    aa42:	2b06      	cmp	r3, #6
    aa44:	d108      	bne.n	aa58 <send_data+0x20>
    aa46:	f64a 4320 	movw	r3, #44064	; 0xac20
    aa4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aa4e:	781b      	ldrb	r3, [r3, #0]
    aa50:	f003 0304 	and.w	r3, r3, #4
    aa54:	2b00      	cmp	r3, #0
    aa56:	d021      	beq.n	aa9c <send_data+0x64>
    if(s->sendlen > uip_mss()) {
    aa58:	8a22      	ldrh	r2, [r4, #16]
    aa5a:	f64a 4328 	movw	r3, #44072	; 0xac28
    aa5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aa62:	681b      	ldr	r3, [r3, #0]
    aa64:	8a5b      	ldrh	r3, [r3, #18]
    aa66:	429a      	cmp	r2, r3
    aa68:	d90b      	bls.n	aa82 <send_data+0x4a>
      uip_send(s->sendptr, uip_mss());
    aa6a:	6862      	ldr	r2, [r4, #4]
    aa6c:	f64a 4328 	movw	r3, #44072	; 0xac28
    aa70:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aa74:	681b      	ldr	r3, [r3, #0]
    aa76:	8a5b      	ldrh	r3, [r3, #18]
    aa78:	4610      	mov	r0, r2
    aa7a:	4619      	mov	r1, r3
    aa7c:	f002 ff60 	bl	d940 <uip_send>
    aa80:	e005      	b.n	aa8e <send_data+0x56>
    } else {
      uip_send(s->sendptr, s->sendlen);
    aa82:	6862      	ldr	r2, [r4, #4]
    aa84:	8a23      	ldrh	r3, [r4, #16]
    aa86:	4610      	mov	r0, r2
    aa88:	4619      	mov	r1, r3
    aa8a:	f002 ff59 	bl	d940 <uip_send>
    }
    s->state = STATE_DATA_SENT;
    aa8e:	f04f 0306 	mov.w	r3, #6
    aa92:	f884 3020 	strb.w	r3, [r4, #32]
    return 1;
    aa96:	f04f 0301 	mov.w	r3, #1
    aa9a:	e001      	b.n	aaa0 <send_data+0x68>
  }
  return 0;
    aa9c:	f04f 0300 	mov.w	r3, #0
}
    aaa0:	4618      	mov	r0, r3
    aaa2:	bd98      	pop	{r3, r4, r7, pc}

0000aaa4 <data_acked>:
/*---------------------------------------------------------------------------*/
static char
data_acked(register struct psock *s)
{
    aaa4:	b480      	push	{r7}
    aaa6:	af00      	add	r7, sp, #0
    aaa8:	4603      	mov	r3, r0
  if(s->state == STATE_DATA_SENT && uip_acked()) {
    aaaa:	f893 2020 	ldrb.w	r2, [r3, #32]
    aaae:	2a06      	cmp	r2, #6
    aab0:	d135      	bne.n	ab1e <data_acked+0x7a>
    aab2:	f64a 4220 	movw	r2, #44064	; 0xac20
    aab6:	f2c2 0200 	movt	r2, #8192	; 0x2000
    aaba:	7812      	ldrb	r2, [r2, #0]
    aabc:	f002 0201 	and.w	r2, r2, #1
    aac0:	b2d2      	uxtb	r2, r2
    aac2:	2a00      	cmp	r2, #0
    aac4:	d02b      	beq.n	ab1e <data_acked+0x7a>
    if(s->sendlen > uip_mss()) {
    aac6:	8a19      	ldrh	r1, [r3, #16]
    aac8:	f64a 4228 	movw	r2, #44072	; 0xac28
    aacc:	f2c2 0200 	movt	r2, #8192	; 0x2000
    aad0:	6812      	ldr	r2, [r2, #0]
    aad2:	8a52      	ldrh	r2, [r2, #18]
    aad4:	4291      	cmp	r1, r2
    aad6:	d914      	bls.n	ab02 <data_acked+0x5e>
      s->sendlen -= uip_mss();
    aad8:	8a19      	ldrh	r1, [r3, #16]
    aada:	f64a 4228 	movw	r2, #44072	; 0xac28
    aade:	f2c2 0200 	movt	r2, #8192	; 0x2000
    aae2:	6812      	ldr	r2, [r2, #0]
    aae4:	8a52      	ldrh	r2, [r2, #18]
    aae6:	ebc2 0201 	rsb	r2, r2, r1
    aaea:	b292      	uxth	r2, r2
    aaec:	821a      	strh	r2, [r3, #16]
      s->sendptr += uip_mss();
    aaee:	6859      	ldr	r1, [r3, #4]
    aaf0:	f64a 4228 	movw	r2, #44072	; 0xac28
    aaf4:	f2c2 0200 	movt	r2, #8192	; 0x2000
    aaf8:	6812      	ldr	r2, [r2, #0]
    aafa:	8a52      	ldrh	r2, [r2, #18]
    aafc:	440a      	add	r2, r1
    aafe:	605a      	str	r2, [r3, #4]
    ab00:	e006      	b.n	ab10 <data_acked+0x6c>
    } else {
      s->sendptr += s->sendlen;
    ab02:	6859      	ldr	r1, [r3, #4]
    ab04:	8a1a      	ldrh	r2, [r3, #16]
    ab06:	440a      	add	r2, r1
    ab08:	605a      	str	r2, [r3, #4]
      s->sendlen = 0;
    ab0a:	f04f 0200 	mov.w	r2, #0
    ab0e:	821a      	strh	r2, [r3, #16]
    }
    s->state = STATE_ACKED;
    ab10:	f04f 0201 	mov.w	r2, #1
    ab14:	f883 2020 	strb.w	r2, [r3, #32]
    return 1;
    ab18:	f04f 0301 	mov.w	r3, #1
    ab1c:	e001      	b.n	ab22 <data_acked+0x7e>
  }
  return 0;
    ab1e:	f04f 0300 	mov.w	r3, #0
}
    ab22:	4618      	mov	r0, r3
    ab24:	46bd      	mov	sp, r7
    ab26:	bc80      	pop	{r7}
    ab28:	4770      	bx	lr
    ab2a:	bf00      	nop

0000ab2c <psock_send>:
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_send(register struct psock *s, const char *buf,
		     unsigned int len))
{
    ab2c:	b5b0      	push	{r4, r5, r7, lr}
    ab2e:	b084      	sub	sp, #16
    ab30:	af00      	add	r7, sp, #0
    ab32:	4604      	mov	r4, r0
    ab34:	6079      	str	r1, [r7, #4]
    ab36:	603a      	str	r2, [r7, #0]
  PT_BEGIN(&s->psockpt);
    ab38:	f04f 0301 	mov.w	r3, #1
    ab3c:	73fb      	strb	r3, [r7, #15]
    ab3e:	8863      	ldrh	r3, [r4, #2]
    ab40:	2b00      	cmp	r3, #0
    ab42:	d002      	beq.n	ab4a <psock_send+0x1e>
    ab44:	2bd0      	cmp	r3, #208	; 0xd0
    ab46:	d016      	beq.n	ab76 <psock_send+0x4a>
    ab48:	e02d      	b.n	aba6 <psock_send+0x7a>
  ( void ) PT_YIELD_FLAG;
  /* If there is no data to send, we exit immediately. */
  if(len == 0) {
    ab4a:	683b      	ldr	r3, [r7, #0]
    ab4c:	2b00      	cmp	r3, #0
    ab4e:	d105      	bne.n	ab5c <psock_send+0x30>
    PT_EXIT(&s->psockpt);
    ab50:	f04f 0300 	mov.w	r3, #0
    ab54:	8063      	strh	r3, [r4, #2]
    ab56:	f04f 0301 	mov.w	r3, #1
    ab5a:	e02c      	b.n	abb6 <psock_send+0x8a>
  }

  /* Save the length of and a pointer to the data that is to be
     sent. */
  s->sendptr = (unsigned char*)buf;
    ab5c:	687b      	ldr	r3, [r7, #4]
    ab5e:	6063      	str	r3, [r4, #4]
  s->sendlen = (unsigned short)len;
    ab60:	683b      	ldr	r3, [r7, #0]
    ab62:	b29b      	uxth	r3, r3
    ab64:	8223      	strh	r3, [r4, #16]

  s->state = STATE_NONE;
    ab66:	f04f 0300 	mov.w	r3, #0
    ab6a:	f884 3020 	strb.w	r3, [r4, #32]

  /* We loop here until all data is sent. The s->sendlen variable is
     updated by the data_sent() function. */
  while(s->sendlen > 0) {
    ab6e:	e013      	b.n	ab98 <psock_send+0x6c>
     * send_data() must be called in succession to ensure that all
     * data is sent. Therefore the & operator is used instead of the
     * && operator, which would cause only the data_acked() function
     * to be called when it returns false.
     */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
    ab70:	f04f 03d0 	mov.w	r3, #208	; 0xd0
    ab74:	8063      	strh	r3, [r4, #2]
    ab76:	4620      	mov	r0, r4
    ab78:	f7ff ff94 	bl	aaa4 <data_acked>
    ab7c:	4603      	mov	r3, r0
    ab7e:	461d      	mov	r5, r3
    ab80:	4620      	mov	r0, r4
    ab82:	f7ff ff59 	bl	aa38 <send_data>
    ab86:	4603      	mov	r3, r0
    ab88:	ea05 0303 	and.w	r3, r5, r3
    ab8c:	b2db      	uxtb	r3, r3
    ab8e:	2b00      	cmp	r3, #0
    ab90:	d102      	bne.n	ab98 <psock_send+0x6c>
    ab92:	f04f 0300 	mov.w	r3, #0
    ab96:	e00e      	b.n	abb6 <psock_send+0x8a>

  s->state = STATE_NONE;

  /* We loop here until all data is sent. The s->sendlen variable is
     updated by the data_sent() function. */
  while(s->sendlen > 0) {
    ab98:	8a23      	ldrh	r3, [r4, #16]
    ab9a:	2b00      	cmp	r3, #0
    ab9c:	d1e8      	bne.n	ab70 <psock_send+0x44>
     * to be called when it returns false.
     */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
  }

  s->state = STATE_NONE;
    ab9e:	f04f 0300 	mov.w	r3, #0
    aba2:	f884 3020 	strb.w	r3, [r4, #32]

  PT_END(&s->psockpt);
    aba6:	f04f 0300 	mov.w	r3, #0
    abaa:	73fb      	strb	r3, [r7, #15]
    abac:	f04f 0300 	mov.w	r3, #0
    abb0:	8063      	strh	r3, [r4, #2]
    abb2:	f04f 0302 	mov.w	r3, #2
}
    abb6:	4618      	mov	r0, r3
    abb8:	f107 0710 	add.w	r7, r7, #16
    abbc:	46bd      	mov	sp, r7
    abbe:	bdb0      	pop	{r4, r5, r7, pc}

0000abc0 <psock_generator_send>:
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_generator_send(register struct psock *s,
			       unsigned short (*generate)(void *), void *arg))
{
    abc0:	b5b0      	push	{r4, r5, r7, lr}
    abc2:	b084      	sub	sp, #16
    abc4:	af00      	add	r7, sp, #0
    abc6:	4604      	mov	r4, r0
    abc8:	6079      	str	r1, [r7, #4]
    abca:	603a      	str	r2, [r7, #0]
  PT_BEGIN(&s->psockpt);
    abcc:	f04f 0301 	mov.w	r3, #1
    abd0:	73fb      	strb	r3, [r7, #15]
    abd2:	8863      	ldrh	r3, [r4, #2]
    abd4:	2b00      	cmp	r3, #0
    abd6:	d002      	beq.n	abde <psock_generator_send+0x1e>
    abd8:	2bef      	cmp	r3, #239	; 0xef
    abda:	d027      	beq.n	ac2c <psock_generator_send+0x6c>
    abdc:	e03e      	b.n	ac5c <psock_generator_send+0x9c>
  ( void ) PT_YIELD_FLAG;
  /* Ensure that there is a generator function to call. */
  if(generate == NULL) {
    abde:	687b      	ldr	r3, [r7, #4]
    abe0:	2b00      	cmp	r3, #0
    abe2:	d105      	bne.n	abf0 <psock_generator_send+0x30>
    PT_EXIT(&s->psockpt);
    abe4:	f04f 0300 	mov.w	r3, #0
    abe8:	8063      	strh	r3, [r4, #2]
    abea:	f04f 0301 	mov.w	r3, #1
    abee:	e03d      	b.n	ac6c <psock_generator_send+0xac>
  }

  /* Call the generator function to generate the data in the
     uip_appdata buffer. */
  s->sendlen = generate(arg);
    abf0:	687b      	ldr	r3, [r7, #4]
    abf2:	6838      	ldr	r0, [r7, #0]
    abf4:	4798      	blx	r3
    abf6:	4603      	mov	r3, r0
    abf8:	8223      	strh	r3, [r4, #16]
  s->sendptr = uip_appdata;
    abfa:	f64a 4324 	movw	r3, #44068	; 0xac24
    abfe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ac02:	681b      	ldr	r3, [r3, #0]
    ac04:	6063      	str	r3, [r4, #4]

  s->state = STATE_NONE;
    ac06:	f04f 0300 	mov.w	r3, #0
    ac0a:	f884 3020 	strb.w	r3, [r4, #32]
  do {
    /* Call the generator function again if we are called to perform a
       retransmission. */
    if(uip_rexmit()) {
    ac0e:	f64a 4320 	movw	r3, #44064	; 0xac20
    ac12:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ac16:	781b      	ldrb	r3, [r3, #0]
    ac18:	f003 0304 	and.w	r3, r3, #4
    ac1c:	2b00      	cmp	r3, #0
    ac1e:	d002      	beq.n	ac26 <psock_generator_send+0x66>
      generate(arg);
    ac20:	687b      	ldr	r3, [r7, #4]
    ac22:	6838      	ldr	r0, [r7, #0]
    ac24:	4798      	blx	r3
    }
    /* Wait until all data is sent and acknowledged. */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
    ac26:	f04f 03ef 	mov.w	r3, #239	; 0xef
    ac2a:	8063      	strh	r3, [r4, #2]
    ac2c:	4620      	mov	r0, r4
    ac2e:	f7ff ff39 	bl	aaa4 <data_acked>
    ac32:	4603      	mov	r3, r0
    ac34:	461d      	mov	r5, r3
    ac36:	4620      	mov	r0, r4
    ac38:	f7ff fefe 	bl	aa38 <send_data>
    ac3c:	4603      	mov	r3, r0
    ac3e:	ea05 0303 	and.w	r3, r5, r3
    ac42:	b2db      	uxtb	r3, r3
    ac44:	2b00      	cmp	r3, #0
    ac46:	d102      	bne.n	ac4e <psock_generator_send+0x8e>
    ac48:	f04f 0300 	mov.w	r3, #0
    ac4c:	e00e      	b.n	ac6c <psock_generator_send+0xac>
  } while(s->sendlen > 0);
    ac4e:	8a23      	ldrh	r3, [r4, #16]
    ac50:	2b00      	cmp	r3, #0
    ac52:	d1dc      	bne.n	ac0e <psock_generator_send+0x4e>

  s->state = STATE_NONE;
    ac54:	f04f 0300 	mov.w	r3, #0
    ac58:	f884 3020 	strb.w	r3, [r4, #32]

  PT_END(&s->psockpt);
    ac5c:	f04f 0300 	mov.w	r3, #0
    ac60:	73fb      	strb	r3, [r7, #15]
    ac62:	f04f 0300 	mov.w	r3, #0
    ac66:	8063      	strh	r3, [r4, #2]
    ac68:	f04f 0302 	mov.w	r3, #2
}
    ac6c:	4618      	mov	r0, r3
    ac6e:	f107 0710 	add.w	r7, r7, #16
    ac72:	46bd      	mov	sp, r7
    ac74:	bdb0      	pop	{r4, r5, r7, pc}
    ac76:	bf00      	nop

0000ac78 <psock_datalen>:
/*---------------------------------------------------------------------------*/
u16_t
psock_datalen(struct psock *psock)
{
    ac78:	b480      	push	{r7}
    ac7a:	b083      	sub	sp, #12
    ac7c:	af00      	add	r7, sp, #0
    ac7e:	6078      	str	r0, [r7, #4]
  return psock->bufsize - psock->buf.left;
    ac80:	687b      	ldr	r3, [r7, #4]
    ac82:	69db      	ldr	r3, [r3, #28]
    ac84:	b29a      	uxth	r2, r3
    ac86:	687b      	ldr	r3, [r7, #4]
    ac88:	8b1b      	ldrh	r3, [r3, #24]
    ac8a:	ebc3 0302 	rsb	r3, r3, r2
    ac8e:	b29b      	uxth	r3, r3
}
    ac90:	4618      	mov	r0, r3
    ac92:	f107 070c 	add.w	r7, r7, #12
    ac96:	46bd      	mov	sp, r7
    ac98:	bc80      	pop	{r7}
    ac9a:	4770      	bx	lr

0000ac9c <psock_newdata>:
/*---------------------------------------------------------------------------*/
char
psock_newdata(struct psock *s)
{
    ac9c:	b480      	push	{r7}
    ac9e:	b083      	sub	sp, #12
    aca0:	af00      	add	r7, sp, #0
    aca2:	6078      	str	r0, [r7, #4]
  if(s->readlen > 0) {
    aca4:	687b      	ldr	r3, [r7, #4]
    aca6:	8a5b      	ldrh	r3, [r3, #18]
    aca8:	2b00      	cmp	r3, #0
    acaa:	d002      	beq.n	acb2 <psock_newdata+0x16>
    /* There is data in the uip_appdata buffer that has not yet been
       read with the PSOCK_READ functions. */
    return 1;
    acac:	f04f 0301 	mov.w	r3, #1
    acb0:	e01a      	b.n	ace8 <psock_newdata+0x4c>
  } else if(s->state == STATE_READ) {
    acb2:	687b      	ldr	r3, [r7, #4]
    acb4:	f893 3020 	ldrb.w	r3, [r3, #32]
    acb8:	2b02      	cmp	r3, #2
    acba:	d107      	bne.n	accc <psock_newdata+0x30>
    /* All data in uip_appdata buffer already consumed. */
    s->state = STATE_BLOCKED_NEWDATA;
    acbc:	687b      	ldr	r3, [r7, #4]
    acbe:	f04f 0203 	mov.w	r2, #3
    acc2:	f883 2020 	strb.w	r2, [r3, #32]
    return 0;
    acc6:	f04f 0300 	mov.w	r3, #0
    acca:	e00d      	b.n	ace8 <psock_newdata+0x4c>
  } else if(uip_newdata()) {
    accc:	f64a 4320 	movw	r3, #44064	; 0xac20
    acd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    acd4:	781b      	ldrb	r3, [r3, #0]
    acd6:	f003 0302 	and.w	r3, r3, #2
    acda:	2b00      	cmp	r3, #0
    acdc:	d002      	beq.n	ace4 <psock_newdata+0x48>
    /* There is new data that has not been consumed. */
    return 1;
    acde:	f04f 0301 	mov.w	r3, #1
    ace2:	e001      	b.n	ace8 <psock_newdata+0x4c>
  } else {
    /* There is no new data. */
    return 0;
    ace4:	f04f 0300 	mov.w	r3, #0
  }
}
    ace8:	4618      	mov	r0, r3
    acea:	f107 070c 	add.w	r7, r7, #12
    acee:	46bd      	mov	sp, r7
    acf0:	bc80      	pop	{r7}
    acf2:	4770      	bx	lr

0000acf4 <psock_readto>:
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_readto(register struct psock *psock, unsigned char c))
{
    acf4:	b590      	push	{r4, r7, lr}
    acf6:	b085      	sub	sp, #20
    acf8:	af00      	add	r7, sp, #0
    acfa:	4604      	mov	r4, r0
    acfc:	460b      	mov	r3, r1
    acfe:	71fb      	strb	r3, [r7, #7]
  PT_BEGIN(&psock->psockpt);
    ad00:	f04f 0301 	mov.w	r3, #1
    ad04:	73fb      	strb	r3, [r7, #15]
    ad06:	8863      	ldrh	r3, [r4, #2]
    ad08:	2b00      	cmp	r3, #0
    ad0a:	d003      	beq.n	ad14 <psock_readto+0x20>
    ad0c:	f5b3 7f8e 	cmp.w	r3, #284	; 0x11c
    ad10:	d010      	beq.n	ad34 <psock_readto+0x40>
    ad12:	e046      	b.n	ada2 <psock_readto+0xae>
  ( void ) PT_YIELD_FLAG;
  buf_setup(&psock->buf, (unsigned char*)psock->bufptr, psock->bufsize);
    ad14:	f104 0114 	add.w	r1, r4, #20
    ad18:	68e2      	ldr	r2, [r4, #12]
    ad1a:	69e3      	ldr	r3, [r4, #28]
    ad1c:	b29b      	uxth	r3, r3
    ad1e:	4608      	mov	r0, r1
    ad20:	4611      	mov	r1, r2
    ad22:	461a      	mov	r2, r3
    ad24:	f7ff fd94 	bl	a850 <buf_setup>

  /* XXX: Should add buf_checkmarker() before do{} loop, if
     incoming data has been handled while waiting for a write. */

  do {
    if(psock->readlen == 0) {
    ad28:	8a63      	ldrh	r3, [r4, #18]
    ad2a:	2b00      	cmp	r3, #0
    ad2c:	d11b      	bne.n	ad66 <psock_readto+0x72>
      PT_WAIT_UNTIL(&psock->psockpt, psock_newdata(psock));
    ad2e:	f44f 738e 	mov.w	r3, #284	; 0x11c
    ad32:	8063      	strh	r3, [r4, #2]
    ad34:	4620      	mov	r0, r4
    ad36:	f7ff ffb1 	bl	ac9c <psock_newdata>
    ad3a:	4603      	mov	r3, r0
    ad3c:	2b00      	cmp	r3, #0
    ad3e:	d102      	bne.n	ad46 <psock_readto+0x52>
    ad40:	f04f 0300 	mov.w	r3, #0
    ad44:	e035      	b.n	adb2 <psock_readto+0xbe>
      psock->state = STATE_READ;
    ad46:	f04f 0302 	mov.w	r3, #2
    ad4a:	f884 3020 	strb.w	r3, [r4, #32]
      psock->readptr = (u8_t *)uip_appdata;
    ad4e:	f64a 4324 	movw	r3, #44068	; 0xac24
    ad52:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ad56:	681b      	ldr	r3, [r3, #0]
    ad58:	60a3      	str	r3, [r4, #8]
      psock->readlen = uip_datalen();
    ad5a:	f64a 4314 	movw	r3, #44052	; 0xac14
    ad5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ad62:	881b      	ldrh	r3, [r3, #0]
    ad64:	8263      	strh	r3, [r4, #18]
    }
  } while((buf_bufto(&psock->buf, c,
    ad66:	f104 0014 	add.w	r0, r4, #20
    ad6a:	f104 0208 	add.w	r2, r4, #8
    ad6e:	f104 0312 	add.w	r3, r4, #18
    ad72:	79f9      	ldrb	r1, [r7, #7]
    ad74:	f7ff fe0c 	bl	a990 <buf_bufto>
    ad78:	4603      	mov	r3, r0
    ad7a:	f003 0302 	and.w	r3, r3, #2
		     &psock->readptr,
		     &psock->readlen) & BUF_FOUND) == 0);
    ad7e:	2b00      	cmp	r3, #0
    ad80:	d0d2      	beq.n	ad28 <psock_readto+0x34>

  if(psock_datalen(psock) == 0) {
    ad82:	4620      	mov	r0, r4
    ad84:	f7ff ff78 	bl	ac78 <psock_datalen>
    ad88:	4603      	mov	r3, r0
    ad8a:	2b00      	cmp	r3, #0
    ad8c:	d109      	bne.n	ada2 <psock_readto+0xae>
    psock->state = STATE_NONE;
    ad8e:	f04f 0300 	mov.w	r3, #0
    ad92:	f884 3020 	strb.w	r3, [r4, #32]
    PT_RESTART(&psock->psockpt);
    ad96:	f04f 0300 	mov.w	r3, #0
    ad9a:	8063      	strh	r3, [r4, #2]
    ad9c:	f04f 0300 	mov.w	r3, #0
    ada0:	e007      	b.n	adb2 <psock_readto+0xbe>
  }
  PT_END(&psock->psockpt);
    ada2:	f04f 0300 	mov.w	r3, #0
    ada6:	73fb      	strb	r3, [r7, #15]
    ada8:	f04f 0300 	mov.w	r3, #0
    adac:	8063      	strh	r3, [r4, #2]
    adae:	f04f 0302 	mov.w	r3, #2
}
    adb2:	4618      	mov	r0, r3
    adb4:	f107 0714 	add.w	r7, r7, #20
    adb8:	46bd      	mov	sp, r7
    adba:	bd90      	pop	{r4, r7, pc}

0000adbc <psock_readbuf>:
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_readbuf(register struct psock *psock))
{
    adbc:	b590      	push	{r4, r7, lr}
    adbe:	b083      	sub	sp, #12
    adc0:	af00      	add	r7, sp, #0
    adc2:	4604      	mov	r4, r0
  PT_BEGIN(&psock->psockpt);
    adc4:	f04f 0301 	mov.w	r3, #1
    adc8:	71fb      	strb	r3, [r7, #7]
    adca:	8863      	ldrh	r3, [r4, #2]
    adcc:	2b00      	cmp	r3, #0
    adce:	d004      	beq.n	adda <psock_readbuf+0x1e>
    add0:	f240 1237 	movw	r2, #311	; 0x137
    add4:	4293      	cmp	r3, r2
    add6:	d010      	beq.n	adfa <psock_readbuf+0x3e>
    add8:	e045      	b.n	ae66 <psock_readbuf+0xaa>
  ( void ) PT_YIELD_FLAG;
  buf_setup(&psock->buf, (unsigned char * ) psock->bufptr, psock->bufsize);
    adda:	f104 0114 	add.w	r1, r4, #20
    adde:	68e2      	ldr	r2, [r4, #12]
    ade0:	69e3      	ldr	r3, [r4, #28]
    ade2:	b29b      	uxth	r3, r3
    ade4:	4608      	mov	r0, r1
    ade6:	4611      	mov	r1, r2
    ade8:	461a      	mov	r2, r3
    adea:	f7ff fd31 	bl	a850 <buf_setup>

  /* XXX: Should add buf_checkmarker() before do{} loop, if
     incoming data has been handled while waiting for a write. */

  do {
    if(psock->readlen == 0) {
    adee:	8a63      	ldrh	r3, [r4, #18]
    adf0:	2b00      	cmp	r3, #0
    adf2:	d11b      	bne.n	ae2c <psock_readbuf+0x70>
      PT_WAIT_UNTIL(&psock->psockpt, psock_newdata(psock));
    adf4:	f240 1337 	movw	r3, #311	; 0x137
    adf8:	8063      	strh	r3, [r4, #2]
    adfa:	4620      	mov	r0, r4
    adfc:	f7ff ff4e 	bl	ac9c <psock_newdata>
    ae00:	4603      	mov	r3, r0
    ae02:	2b00      	cmp	r3, #0
    ae04:	d102      	bne.n	ae0c <psock_readbuf+0x50>
    ae06:	f04f 0300 	mov.w	r3, #0
    ae0a:	e034      	b.n	ae76 <psock_readbuf+0xba>
      psock->state = STATE_READ;
    ae0c:	f04f 0302 	mov.w	r3, #2
    ae10:	f884 3020 	strb.w	r3, [r4, #32]
      psock->readptr = (u8_t *)uip_appdata;
    ae14:	f64a 4324 	movw	r3, #44068	; 0xac24
    ae18:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ae1c:	681b      	ldr	r3, [r3, #0]
    ae1e:	60a3      	str	r3, [r4, #8]
      psock->readlen = uip_datalen();
    ae20:	f64a 4314 	movw	r3, #44052	; 0xac14
    ae24:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ae28:	881b      	ldrh	r3, [r3, #0]
    ae2a:	8263      	strh	r3, [r4, #18]
    }
  } while(buf_bufdata(&psock->buf, psock->bufsize,
    ae2c:	f104 0014 	add.w	r0, r4, #20
    ae30:	69e3      	ldr	r3, [r4, #28]
    ae32:	b299      	uxth	r1, r3
    ae34:	f104 0208 	add.w	r2, r4, #8
    ae38:	f104 0312 	add.w	r3, r4, #18
    ae3c:	f7ff fd1a 	bl	a874 <buf_bufdata>
    ae40:	4603      	mov	r3, r0
			 &psock->readptr,
			 &psock->readlen) != BUF_FULL);
    ae42:	2b01      	cmp	r3, #1
    ae44:	d1d3      	bne.n	adee <psock_readbuf+0x32>

  if(psock_datalen(psock) == 0) {
    ae46:	4620      	mov	r0, r4
    ae48:	f7ff ff16 	bl	ac78 <psock_datalen>
    ae4c:	4603      	mov	r3, r0
    ae4e:	2b00      	cmp	r3, #0
    ae50:	d109      	bne.n	ae66 <psock_readbuf+0xaa>
    psock->state = STATE_NONE;
    ae52:	f04f 0300 	mov.w	r3, #0
    ae56:	f884 3020 	strb.w	r3, [r4, #32]
    PT_RESTART(&psock->psockpt);
    ae5a:	f04f 0300 	mov.w	r3, #0
    ae5e:	8063      	strh	r3, [r4, #2]
    ae60:	f04f 0300 	mov.w	r3, #0
    ae64:	e007      	b.n	ae76 <psock_readbuf+0xba>
  }
  PT_END(&psock->psockpt);
    ae66:	f04f 0300 	mov.w	r3, #0
    ae6a:	71fb      	strb	r3, [r7, #7]
    ae6c:	f04f 0300 	mov.w	r3, #0
    ae70:	8063      	strh	r3, [r4, #2]
    ae72:	f04f 0302 	mov.w	r3, #2
}
    ae76:	4618      	mov	r0, r3
    ae78:	f107 070c 	add.w	r7, r7, #12
    ae7c:	46bd      	mov	sp, r7
    ae7e:	bd90      	pop	{r4, r7, pc}

0000ae80 <psock_init>:
/*---------------------------------------------------------------------------*/
void
psock_init(register struct psock *psock, char *buffer, unsigned int buffersize)
{
    ae80:	b590      	push	{r4, r7, lr}
    ae82:	b083      	sub	sp, #12
    ae84:	af00      	add	r7, sp, #0
    ae86:	4604      	mov	r4, r0
    ae88:	6079      	str	r1, [r7, #4]
    ae8a:	603a      	str	r2, [r7, #0]
  psock->state = STATE_NONE;
    ae8c:	f04f 0300 	mov.w	r3, #0
    ae90:	f884 3020 	strb.w	r3, [r4, #32]
  psock->readlen = 0;
    ae94:	f04f 0300 	mov.w	r3, #0
    ae98:	8263      	strh	r3, [r4, #18]
  psock->bufptr = buffer;
    ae9a:	687b      	ldr	r3, [r7, #4]
    ae9c:	60e3      	str	r3, [r4, #12]
  psock->bufsize = buffersize;
    ae9e:	683b      	ldr	r3, [r7, #0]
    aea0:	61e3      	str	r3, [r4, #28]
  buf_setup(&psock->buf, (unsigned char*) buffer, buffersize);
    aea2:	f104 0214 	add.w	r2, r4, #20
    aea6:	683b      	ldr	r3, [r7, #0]
    aea8:	b29b      	uxth	r3, r3
    aeaa:	4610      	mov	r0, r2
    aeac:	6879      	ldr	r1, [r7, #4]
    aeae:	461a      	mov	r2, r3
    aeb0:	f7ff fcce 	bl	a850 <buf_setup>
  PT_INIT(&psock->pt);
    aeb4:	f04f 0300 	mov.w	r3, #0
    aeb8:	8023      	strh	r3, [r4, #0]
  PT_INIT(&psock->psockpt);
    aeba:	f04f 0300 	mov.w	r3, #0
    aebe:	8063      	strh	r3, [r4, #2]
}
    aec0:	f107 070c 	add.w	r7, r7, #12
    aec4:	46bd      	mov	sp, r7
    aec6:	bd90      	pop	{r4, r7, pc}

0000aec8 <timer_set>:
 * \param t A pointer to the timer
 * \param interval The interval before the timer expires.
 *
 */
void timer_set( struct timer *t, clock_time_t interval )
{
    aec8:	b580      	push	{r7, lr}
    aeca:	b082      	sub	sp, #8
    aecc:	af00      	add	r7, sp, #0
    aece:	6078      	str	r0, [r7, #4]
    aed0:	6039      	str	r1, [r7, #0]
	t->interval = interval;
    aed2:	687b      	ldr	r3, [r7, #4]
    aed4:	683a      	ldr	r2, [r7, #0]
    aed6:	605a      	str	r2, [r3, #4]
	t->start = clock_time();
    aed8:	f7f6 f984 	bl	11e4 <clock_time>
    aedc:	4602      	mov	r2, r0
    aede:	687b      	ldr	r3, [r7, #4]
    aee0:	601a      	str	r2, [r3, #0]
}
    aee2:	f107 0708 	add.w	r7, r7, #8
    aee6:	46bd      	mov	sp, r7
    aee8:	bd80      	pop	{r7, pc}
    aeea:	bf00      	nop

0000aeec <timer_reset>:
 * \param t A pointer to the timer.
 *
 * \sa timer_restart()
 */
void timer_reset( struct timer *t )
{
    aeec:	b480      	push	{r7}
    aeee:	b083      	sub	sp, #12
    aef0:	af00      	add	r7, sp, #0
    aef2:	6078      	str	r0, [r7, #4]
	t->start += t->interval;
    aef4:	687b      	ldr	r3, [r7, #4]
    aef6:	681a      	ldr	r2, [r3, #0]
    aef8:	687b      	ldr	r3, [r7, #4]
    aefa:	685b      	ldr	r3, [r3, #4]
    aefc:	441a      	add	r2, r3
    aefe:	687b      	ldr	r3, [r7, #4]
    af00:	601a      	str	r2, [r3, #0]
}
    af02:	f107 070c 	add.w	r7, r7, #12
    af06:	46bd      	mov	sp, r7
    af08:	bc80      	pop	{r7}
    af0a:	4770      	bx	lr

0000af0c <timer_restart>:
 * \param t A pointer to the timer.
 *
 * \sa timer_reset()
 */
void timer_restart( struct timer *t )
{
    af0c:	b580      	push	{r7, lr}
    af0e:	b082      	sub	sp, #8
    af10:	af00      	add	r7, sp, #0
    af12:	6078      	str	r0, [r7, #4]
	t->start = clock_time();
    af14:	f7f6 f966 	bl	11e4 <clock_time>
    af18:	4602      	mov	r2, r0
    af1a:	687b      	ldr	r3, [r7, #4]
    af1c:	601a      	str	r2, [r3, #0]
}
    af1e:	f107 0708 	add.w	r7, r7, #8
    af22:	46bd      	mov	sp, r7
    af24:	bd80      	pop	{r7, pc}
    af26:	bf00      	nop

0000af28 <timer_expired>:
 *
 * \return Non-zero if the timer has expired, zero otherwise.
 *
 */
int timer_expired( struct timer *t )
{
    af28:	b580      	push	{r7, lr}
    af2a:	b082      	sub	sp, #8
    af2c:	af00      	add	r7, sp, #0
    af2e:	6078      	str	r0, [r7, #4]
	return( clock_time_t ) ( clock_time() - t->start ) >= ( clock_time_t ) t->interval;
    af30:	f7f6 f958 	bl	11e4 <clock_time>
    af34:	4602      	mov	r2, r0
    af36:	687b      	ldr	r3, [r7, #4]
    af38:	681b      	ldr	r3, [r3, #0]
    af3a:	ebc3 0202 	rsb	r2, r3, r2
    af3e:	687b      	ldr	r3, [r7, #4]
    af40:	685b      	ldr	r3, [r3, #4]
    af42:	429a      	cmp	r2, r3
    af44:	bf34      	ite	cc
    af46:	2300      	movcc	r3, #0
    af48:	2301      	movcs	r3, #1
}
    af4a:	4618      	mov	r0, r3
    af4c:	f107 0708 	add.w	r7, r7, #8
    af50:	46bd      	mov	sp, r7
    af52:	bd80      	pop	{r7, pc}

0000af54 <timer_remaining>:
 *
 * \return The time until the timer expires
 *
 */
clock_time_t timer_remaining( struct timer *t )
{
    af54:	b590      	push	{r4, r7, lr}
    af56:	b083      	sub	sp, #12
    af58:	af00      	add	r7, sp, #0
    af5a:	6078      	str	r0, [r7, #4]
	return t->start + t->interval - clock_time();
    af5c:	687b      	ldr	r3, [r7, #4]
    af5e:	681a      	ldr	r2, [r3, #0]
    af60:	687b      	ldr	r3, [r7, #4]
    af62:	685b      	ldr	r3, [r3, #4]
    af64:	eb02 0403 	add.w	r4, r2, r3
    af68:	f7f6 f93c 	bl	11e4 <clock_time>
    af6c:	4603      	mov	r3, r0
    af6e:	ebc3 0304 	rsb	r3, r3, r4
}
    af72:	4618      	mov	r0, r3
    af74:	f107 070c 	add.w	r7, r7, #12
    af78:	46bd      	mov	sp, r7
    af7a:	bd90      	pop	{r4, r7, pc}

0000af7c <uip_setipid>:

/* Ths ipid variable is an increasing number that is used for the IP ID	field. */
static u16_t ipid;

void uip_setipid( u16_t id )
{
    af7c:	b480      	push	{r7}
    af7e:	b083      	sub	sp, #12
    af80:	af00      	add	r7, sp, #0
    af82:	4603      	mov	r3, r0
    af84:	80fb      	strh	r3, [r7, #6]
	ipid = id;
    af86:	f642 7354 	movw	r3, #12116	; 0x2f54
    af8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af8e:	88fa      	ldrh	r2, [r7, #6]
    af90:	801a      	strh	r2, [r3, #0]
}
    af92:	f107 070c 	add.w	r7, r7, #12
    af96:	46bd      	mov	sp, r7
    af98:	bc80      	pop	{r7}
    af9a:	4770      	bx	lr

0000af9c <uip_add32>:
	#define UIP_LOG( m )
#endif /* UIP_LOGGING == 1 */

#if !UIP_ARCH_ADD32
	void uip_add32( u8_t *op32, u16_t op16 )
	{
    af9c:	b480      	push	{r7}
    af9e:	b083      	sub	sp, #12
    afa0:	af00      	add	r7, sp, #0
    afa2:	6078      	str	r0, [r7, #4]
    afa4:	460b      	mov	r3, r1
    afa6:	807b      	strh	r3, [r7, #2]
		uip_acc32[3] = op32[3] + ( op16 & 0xff );
    afa8:	687b      	ldr	r3, [r7, #4]
    afaa:	f103 0303 	add.w	r3, r3, #3
    afae:	781a      	ldrb	r2, [r3, #0]
    afb0:	887b      	ldrh	r3, [r7, #2]
    afb2:	b2db      	uxtb	r3, r3
    afb4:	4413      	add	r3, r2
    afb6:	b2da      	uxtb	r2, r3
    afb8:	f64a 431c 	movw	r3, #44060	; 0xac1c
    afbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    afc0:	70da      	strb	r2, [r3, #3]
		uip_acc32[2] = op32[2] + ( op16 >> 8 );
    afc2:	687b      	ldr	r3, [r7, #4]
    afc4:	f103 0302 	add.w	r3, r3, #2
    afc8:	781a      	ldrb	r2, [r3, #0]
    afca:	887b      	ldrh	r3, [r7, #2]
    afcc:	ea4f 2313 	mov.w	r3, r3, lsr #8
    afd0:	b29b      	uxth	r3, r3
    afd2:	b2db      	uxtb	r3, r3
    afd4:	4413      	add	r3, r2
    afd6:	b2da      	uxtb	r2, r3
    afd8:	f64a 431c 	movw	r3, #44060	; 0xac1c
    afdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    afe0:	709a      	strb	r2, [r3, #2]
		uip_acc32[1] = op32[1];
    afe2:	687b      	ldr	r3, [r7, #4]
    afe4:	f103 0301 	add.w	r3, r3, #1
    afe8:	781a      	ldrb	r2, [r3, #0]
    afea:	f64a 431c 	movw	r3, #44060	; 0xac1c
    afee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aff2:	705a      	strb	r2, [r3, #1]
		uip_acc32[0] = op32[0];
    aff4:	687b      	ldr	r3, [r7, #4]
    aff6:	781a      	ldrb	r2, [r3, #0]
    aff8:	f64a 431c 	movw	r3, #44060	; 0xac1c
    affc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b000:	701a      	strb	r2, [r3, #0]

		if( uip_acc32[2] < (op16 >> 8) )
    b002:	f64a 431c 	movw	r3, #44060	; 0xac1c
    b006:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b00a:	789b      	ldrb	r3, [r3, #2]
    b00c:	461a      	mov	r2, r3
    b00e:	887b      	ldrh	r3, [r7, #2]
    b010:	ea4f 2313 	mov.w	r3, r3, lsr #8
    b014:	b29b      	uxth	r3, r3
    b016:	429a      	cmp	r2, r3
    b018:	d220      	bcs.n	b05c <uip_add32+0xc0>
		{
			++uip_acc32[1];
    b01a:	f64a 431c 	movw	r3, #44060	; 0xac1c
    b01e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b022:	785b      	ldrb	r3, [r3, #1]
    b024:	f103 0301 	add.w	r3, r3, #1
    b028:	b2da      	uxtb	r2, r3
    b02a:	f64a 431c 	movw	r3, #44060	; 0xac1c
    b02e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b032:	705a      	strb	r2, [r3, #1]
			if( uip_acc32[1] == 0 )
    b034:	f64a 431c 	movw	r3, #44060	; 0xac1c
    b038:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b03c:	785b      	ldrb	r3, [r3, #1]
    b03e:	2b00      	cmp	r3, #0
    b040:	d10c      	bne.n	b05c <uip_add32+0xc0>
			{
				++uip_acc32[0];
    b042:	f64a 431c 	movw	r3, #44060	; 0xac1c
    b046:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b04a:	781b      	ldrb	r3, [r3, #0]
    b04c:	f103 0301 	add.w	r3, r3, #1
    b050:	b2da      	uxtb	r2, r3
    b052:	f64a 431c 	movw	r3, #44060	; 0xac1c
    b056:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b05a:	701a      	strb	r2, [r3, #0]
			}
		}

		if( uip_acc32[3] < (op16 & 0xff) )
    b05c:	f64a 431c 	movw	r3, #44060	; 0xac1c
    b060:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b064:	78db      	ldrb	r3, [r3, #3]
    b066:	461a      	mov	r2, r3
    b068:	887b      	ldrh	r3, [r7, #2]
    b06a:	f003 03ff 	and.w	r3, r3, #255	; 0xff
    b06e:	429a      	cmp	r2, r3
    b070:	da34      	bge.n	b0dc <uip_add32+0x140>
		{
			++uip_acc32[2];
    b072:	f64a 431c 	movw	r3, #44060	; 0xac1c
    b076:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b07a:	789b      	ldrb	r3, [r3, #2]
    b07c:	f103 0301 	add.w	r3, r3, #1
    b080:	b2da      	uxtb	r2, r3
    b082:	f64a 431c 	movw	r3, #44060	; 0xac1c
    b086:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b08a:	709a      	strb	r2, [r3, #2]
			if( uip_acc32[2] == 0 )
    b08c:	f64a 431c 	movw	r3, #44060	; 0xac1c
    b090:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b094:	789b      	ldrb	r3, [r3, #2]
    b096:	2b00      	cmp	r3, #0
    b098:	d120      	bne.n	b0dc <uip_add32+0x140>
			{
				++uip_acc32[1];
    b09a:	f64a 431c 	movw	r3, #44060	; 0xac1c
    b09e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b0a2:	785b      	ldrb	r3, [r3, #1]
    b0a4:	f103 0301 	add.w	r3, r3, #1
    b0a8:	b2da      	uxtb	r2, r3
    b0aa:	f64a 431c 	movw	r3, #44060	; 0xac1c
    b0ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b0b2:	705a      	strb	r2, [r3, #1]
				if( uip_acc32[1] == 0 )
    b0b4:	f64a 431c 	movw	r3, #44060	; 0xac1c
    b0b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b0bc:	785b      	ldrb	r3, [r3, #1]
    b0be:	2b00      	cmp	r3, #0
    b0c0:	d10c      	bne.n	b0dc <uip_add32+0x140>
				{
					++uip_acc32[0];
    b0c2:	f64a 431c 	movw	r3, #44060	; 0xac1c
    b0c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b0ca:	781b      	ldrb	r3, [r3, #0]
    b0cc:	f103 0301 	add.w	r3, r3, #1
    b0d0:	b2da      	uxtb	r2, r3
    b0d2:	f64a 431c 	movw	r3, #44060	; 0xac1c
    b0d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b0da:	701a      	strb	r2, [r3, #0]
				}
			}
		}
	}
    b0dc:	f107 070c 	add.w	r7, r7, #12
    b0e0:	46bd      	mov	sp, r7
    b0e2:	bc80      	pop	{r7}
    b0e4:	4770      	bx	lr
    b0e6:	bf00      	nop

0000b0e8 <chksum>:
#endif /* UIP_ARCH_ADD32 */

#if !UIP_ARCH_CHKSUM

	static u16_t chksum( u16_t sum, const u8_t *data, u16_t len )
	{
    b0e8:	b480      	push	{r7}
    b0ea:	b089      	sub	sp, #36	; 0x24
    b0ec:	af00      	add	r7, sp, #0
    b0ee:	60b9      	str	r1, [r7, #8]
    b0f0:	4613      	mov	r3, r2
    b0f2:	4602      	mov	r2, r0
    b0f4:	81fa      	strh	r2, [r7, #14]
    b0f6:	80fb      	strh	r3, [r7, #6]
		u16_t		t;
		const u8_t	*dataptr;
		const u8_t	*last_byte;

		dataptr = data;
    b0f8:	68bb      	ldr	r3, [r7, #8]
    b0fa:	61bb      	str	r3, [r7, #24]
		last_byte = data + len - 1;
    b0fc:	88fb      	ldrh	r3, [r7, #6]
    b0fe:	f103 33ff 	add.w	r3, r3, #4294967295
    b102:	68ba      	ldr	r2, [r7, #8]
    b104:	4413      	add	r3, r2
    b106:	61fb      	str	r3, [r7, #28]

		while( dataptr < last_byte )
    b108:	e01a      	b.n	b140 <chksum+0x58>
		{
			/* At least two more bytes */
			t = ( dataptr[ 0 ] << 8 ) + dataptr[ 1 ];
    b10a:	69bb      	ldr	r3, [r7, #24]
    b10c:	781b      	ldrb	r3, [r3, #0]
    b10e:	ea4f 2303 	mov.w	r3, r3, lsl #8
    b112:	b29a      	uxth	r2, r3
    b114:	69bb      	ldr	r3, [r7, #24]
    b116:	f103 0301 	add.w	r3, r3, #1
    b11a:	781b      	ldrb	r3, [r3, #0]
    b11c:	4413      	add	r3, r2
    b11e:	82fb      	strh	r3, [r7, #22]
			sum += t;
    b120:	89fa      	ldrh	r2, [r7, #14]
    b122:	8afb      	ldrh	r3, [r7, #22]
    b124:	4413      	add	r3, r2
    b126:	81fb      	strh	r3, [r7, #14]
			if( sum < t )
    b128:	89fa      	ldrh	r2, [r7, #14]
    b12a:	8afb      	ldrh	r3, [r7, #22]
    b12c:	429a      	cmp	r2, r3
    b12e:	d203      	bcs.n	b138 <chksum+0x50>
			{
				sum++;	/* carry */
    b130:	89fb      	ldrh	r3, [r7, #14]
    b132:	f103 0301 	add.w	r3, r3, #1
    b136:	81fb      	strh	r3, [r7, #14]
			}

			dataptr += 2;
    b138:	69bb      	ldr	r3, [r7, #24]
    b13a:	f103 0302 	add.w	r3, r3, #2
    b13e:	61bb      	str	r3, [r7, #24]
		const u8_t	*last_byte;

		dataptr = data;
		last_byte = data + len - 1;

		while( dataptr < last_byte )
    b140:	69ba      	ldr	r2, [r7, #24]
    b142:	69fb      	ldr	r3, [r7, #28]
    b144:	429a      	cmp	r2, r3
    b146:	d3e0      	bcc.n	b10a <chksum+0x22>
			}

			dataptr += 2;
		}

		if( dataptr == last_byte )
    b148:	69ba      	ldr	r2, [r7, #24]
    b14a:	69fb      	ldr	r3, [r7, #28]
    b14c:	429a      	cmp	r2, r3
    b14e:	d110      	bne.n	b172 <chksum+0x8a>
		{
			t = ( dataptr[ 0 ] << 8 ) + 0;
    b150:	69bb      	ldr	r3, [r7, #24]
    b152:	781b      	ldrb	r3, [r3, #0]
    b154:	ea4f 2303 	mov.w	r3, r3, lsl #8
    b158:	82fb      	strh	r3, [r7, #22]
			sum += t;
    b15a:	89fa      	ldrh	r2, [r7, #14]
    b15c:	8afb      	ldrh	r3, [r7, #22]
    b15e:	4413      	add	r3, r2
    b160:	81fb      	strh	r3, [r7, #14]
			if( sum < t )
    b162:	89fa      	ldrh	r2, [r7, #14]
    b164:	8afb      	ldrh	r3, [r7, #22]
    b166:	429a      	cmp	r2, r3
    b168:	d203      	bcs.n	b172 <chksum+0x8a>
			{
				sum++;	/* carry */
    b16a:	89fb      	ldrh	r3, [r7, #14]
    b16c:	f103 0301 	add.w	r3, r3, #1
    b170:	81fb      	strh	r3, [r7, #14]
			}
		}

		/* Return sum in host byte order. */
		return sum;
    b172:	89fb      	ldrh	r3, [r7, #14]
	}
    b174:	4618      	mov	r0, r3
    b176:	f107 0724 	add.w	r7, r7, #36	; 0x24
    b17a:	46bd      	mov	sp, r7
    b17c:	bc80      	pop	{r7}
    b17e:	4770      	bx	lr

0000b180 <uip_chksum>:
	/*---------------------------------------------------------------------------*/

	u16_t uip_chksum( u16_t *data, u16_t len )
	{
    b180:	b580      	push	{r7, lr}
    b182:	b082      	sub	sp, #8
    b184:	af00      	add	r7, sp, #0
    b186:	6078      	str	r0, [r7, #4]
    b188:	460b      	mov	r3, r1
    b18a:	807b      	strh	r3, [r7, #2]
		return htons( chksum( 0, ( u8_t * ) data, len ) );
    b18c:	687a      	ldr	r2, [r7, #4]
    b18e:	887b      	ldrh	r3, [r7, #2]
    b190:	f04f 0000 	mov.w	r0, #0
    b194:	4611      	mov	r1, r2
    b196:	461a      	mov	r2, r3
    b198:	f7ff ffa6 	bl	b0e8 <chksum>
    b19c:	4603      	mov	r3, r0
    b19e:	4618      	mov	r0, r3
    b1a0:	f002 fb88 	bl	d8b4 <htons>
    b1a4:	4603      	mov	r3, r0
	}
    b1a6:	4618      	mov	r0, r3
    b1a8:	f107 0708 	add.w	r7, r7, #8
    b1ac:	46bd      	mov	sp, r7
    b1ae:	bd80      	pop	{r7, pc}

0000b1b0 <uip_ipchksum>:
	/*---------------------------------------------------------------------------*/

	#ifndef UIP_ARCH_IPCHKSUM
		u16_t uip_ipchksum( void )
		{
    b1b0:	b580      	push	{r7, lr}
    b1b2:	b082      	sub	sp, #8
    b1b4:	af00      	add	r7, sp, #0
			u16_t	sum;

			sum = chksum( 0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN );
    b1b6:	f240 6370 	movw	r3, #1648	; 0x670
    b1ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b1be:	681b      	ldr	r3, [r3, #0]
    b1c0:	f103 030e 	add.w	r3, r3, #14
    b1c4:	f04f 0000 	mov.w	r0, #0
    b1c8:	4619      	mov	r1, r3
    b1ca:	f04f 0214 	mov.w	r2, #20
    b1ce:	f7ff ff8b 	bl	b0e8 <chksum>
    b1d2:	4603      	mov	r3, r0
    b1d4:	80fb      	strh	r3, [r7, #6]

			//DEBUG_PRINTF( "uip_ipchksum: sum 0x%04x\n", sum );
			return( sum == 0 ) ? 0xffff : htons( sum );
    b1d6:	88fb      	ldrh	r3, [r7, #6]
    b1d8:	2b00      	cmp	r3, #0
    b1da:	d005      	beq.n	b1e8 <uip_ipchksum+0x38>
    b1dc:	88fb      	ldrh	r3, [r7, #6]
    b1de:	4618      	mov	r0, r3
    b1e0:	f002 fb68 	bl	d8b4 <htons>
    b1e4:	4603      	mov	r3, r0
    b1e6:	e001      	b.n	b1ec <uip_ipchksum+0x3c>
    b1e8:	f64f 73ff 	movw	r3, #65535	; 0xffff
		}
    b1ec:	4618      	mov	r0, r3
    b1ee:	f107 0708 	add.w	r7, r7, #8
    b1f2:	46bd      	mov	sp, r7
    b1f4:	bd80      	pop	{r7, pc}
    b1f6:	bf00      	nop

0000b1f8 <upper_layer_chksum>:
	#endif
	/*---------------------------------------------------------------------------*/

	static u16_t upper_layer_chksum( u8_t proto )
	{
    b1f8:	b580      	push	{r7, lr}
    b1fa:	b084      	sub	sp, #16
    b1fc:	af00      	add	r7, sp, #0
    b1fe:	4603      	mov	r3, r0
    b200:	71fb      	strb	r3, [r7, #7]
		u16_t	sum;

		#if UIP_CONF_IPV6
			upper_layer_len = ( ((u16_t) (BUF->len[ 0 ]) << 8) + BUF->len[ 1 ] );
		#else /* UIP_CONF_IPV6 */
			upper_layer_len = ( ((u16_t) (BUF->len[ 0 ]) << 8) + BUF->len[ 1 ] ) - UIP_IPH_LEN;
    b202:	f240 6370 	movw	r3, #1648	; 0x670
    b206:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b20a:	681b      	ldr	r3, [r3, #0]
    b20c:	f103 030e 	add.w	r3, r3, #14
    b210:	789b      	ldrb	r3, [r3, #2]
    b212:	ea4f 2303 	mov.w	r3, r3, lsl #8
    b216:	b29a      	uxth	r2, r3
    b218:	f240 6370 	movw	r3, #1648	; 0x670
    b21c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b220:	681b      	ldr	r3, [r3, #0]
    b222:	f103 030e 	add.w	r3, r3, #14
    b226:	78db      	ldrb	r3, [r3, #3]
    b228:	4413      	add	r3, r2
    b22a:	b29b      	uxth	r3, r3
    b22c:	f1a3 0314 	sub.w	r3, r3, #20
    b230:	81bb      	strh	r3, [r7, #12]
		#endif /* UIP_CONF_IPV6 */

		/* First sum pseudoheader. */

		/* IP protocol and length fields. This addition cannot carry. */
		sum = upper_layer_len + proto;
    b232:	79fa      	ldrb	r2, [r7, #7]
    b234:	89bb      	ldrh	r3, [r7, #12]
    b236:	4413      	add	r3, r2
    b238:	81fb      	strh	r3, [r7, #14]

		/* Sum IP source and destination addresses. */
		sum = chksum( sum, ( u8_t * ) &BUF->srcipaddr, 2 * sizeof(uip_ipaddr_t) );
    b23a:	f240 6370 	movw	r3, #1648	; 0x670
    b23e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b242:	681b      	ldr	r3, [r3, #0]
    b244:	f103 030e 	add.w	r3, r3, #14
    b248:	f103 030c 	add.w	r3, r3, #12
    b24c:	89fa      	ldrh	r2, [r7, #14]
    b24e:	4610      	mov	r0, r2
    b250:	4619      	mov	r1, r3
    b252:	f04f 0208 	mov.w	r2, #8
    b256:	f7ff ff47 	bl	b0e8 <chksum>
    b25a:	4603      	mov	r3, r0
    b25c:	81fb      	strh	r3, [r7, #14]

		/* Sum TCP header and data. */
		sum = chksum( sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN], upper_layer_len );
    b25e:	f240 6370 	movw	r3, #1648	; 0x670
    b262:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b266:	681b      	ldr	r3, [r3, #0]
    b268:	f103 0222 	add.w	r2, r3, #34	; 0x22
    b26c:	89f9      	ldrh	r1, [r7, #14]
    b26e:	89bb      	ldrh	r3, [r7, #12]
    b270:	4608      	mov	r0, r1
    b272:	4611      	mov	r1, r2
    b274:	461a      	mov	r2, r3
    b276:	f7ff ff37 	bl	b0e8 <chksum>
    b27a:	4603      	mov	r3, r0
    b27c:	81fb      	strh	r3, [r7, #14]

		return( sum == 0 ) ? 0xffff : htons( sum );
    b27e:	89fb      	ldrh	r3, [r7, #14]
    b280:	2b00      	cmp	r3, #0
    b282:	d005      	beq.n	b290 <upper_layer_chksum+0x98>
    b284:	89fb      	ldrh	r3, [r7, #14]
    b286:	4618      	mov	r0, r3
    b288:	f002 fb14 	bl	d8b4 <htons>
    b28c:	4603      	mov	r3, r0
    b28e:	e001      	b.n	b294 <upper_layer_chksum+0x9c>
    b290:	f64f 73ff 	movw	r3, #65535	; 0xffff
	}
    b294:	4618      	mov	r0, r3
    b296:	f107 0710 	add.w	r7, r7, #16
    b29a:	46bd      	mov	sp, r7
    b29c:	bd80      	pop	{r7, pc}
    b29e:	bf00      	nop

0000b2a0 <uip_tcpchksum>:
		}
	#endif /* UIP_CONF_IPV6 */
	/*---------------------------------------------------------------------------*/

	u16_t uip_tcpchksum( void )
	{
    b2a0:	b580      	push	{r7, lr}
    b2a2:	af00      	add	r7, sp, #0
		return upper_layer_chksum( UIP_PROTO_TCP );
    b2a4:	f04f 0006 	mov.w	r0, #6
    b2a8:	f7ff ffa6 	bl	b1f8 <upper_layer_chksum>
    b2ac:	4603      	mov	r3, r0
	}
    b2ae:	4618      	mov	r0, r3
    b2b0:	bd80      	pop	{r7, pc}
    b2b2:	bf00      	nop

0000b2b4 <uip_udpchksum>:
	/*---------------------------------------------------------------------------*/

	#if UIP_UDP_CHECKSUMS
		u16_t uip_udpchksum( void )
		{
    b2b4:	b580      	push	{r7, lr}
    b2b6:	af00      	add	r7, sp, #0
			return upper_layer_chksum( UIP_PROTO_UDP );
    b2b8:	f04f 0011 	mov.w	r0, #17
    b2bc:	f7ff ff9c 	bl	b1f8 <upper_layer_chksum>
    b2c0:	4603      	mov	r3, r0
		}
    b2c2:	4618      	mov	r0, r3
    b2c4:	bd80      	pop	{r7, pc}
    b2c6:	bf00      	nop

0000b2c8 <uip_init>:

#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/

void uip_init( void )
{
    b2c8:	b480      	push	{r7}
    b2ca:	af00      	add	r7, sp, #0
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    b2cc:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b2d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b2d4:	f04f 0200 	mov.w	r2, #0
    b2d8:	701a      	strb	r2, [r3, #0]
    b2da:	e01a      	b.n	b312 <uip_init+0x4a>
	{
		uip_listenports[ c ] = 0;
    b2dc:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b2e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b2e4:	781b      	ldrb	r3, [r3, #0]
    b2e6:	461a      	mov	r2, r3
    b2e8:	f64c 430c 	movw	r3, #52236	; 0xcc0c
    b2ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b2f0:	f04f 0100 	mov.w	r1, #0
    b2f4:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/

void uip_init( void )
{
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    b2f8:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b2fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b300:	781b      	ldrb	r3, [r3, #0]
    b302:	f103 0301 	add.w	r3, r3, #1
    b306:	b2da      	uxtb	r2, r3
    b308:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b30c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b310:	701a      	strb	r2, [r3, #0]
    b312:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b316:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b31a:	781b      	ldrb	r3, [r3, #0]
    b31c:	2b27      	cmp	r3, #39	; 0x27
    b31e:	d9dd      	bls.n	b2dc <uip_init+0x14>
	{
		uip_listenports[ c ] = 0;
	}

	for( c = 0; c < UIP_CONNS; ++c )
    b320:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b324:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b328:	f04f 0200 	mov.w	r2, #0
    b32c:	701a      	strb	r2, [r3, #0]
    b32e:	e020      	b.n	b372 <uip_init+0xaa>
	{
		uip_conns[ c ].tcpstateflags = UIP_CLOSED;
    b330:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b334:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b338:	781b      	ldrb	r3, [r3, #0]
    b33a:	461a      	mov	r2, r3
    b33c:	f64a 432c 	movw	r3, #44076	; 0xac2c
    b340:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b344:	f04f 01cc 	mov.w	r1, #204	; 0xcc
    b348:	fb01 f202 	mul.w	r2, r1, r2
    b34c:	4413      	add	r3, r2
    b34e:	f103 0318 	add.w	r3, r3, #24
    b352:	f04f 0200 	mov.w	r2, #0
    b356:	705a      	strb	r2, [r3, #1]
	for( c = 0; c < UIP_LISTENPORTS; ++c )
	{
		uip_listenports[ c ] = 0;
	}

	for( c = 0; c < UIP_CONNS; ++c )
    b358:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b35c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b360:	781b      	ldrb	r3, [r3, #0]
    b362:	f103 0301 	add.w	r3, r3, #1
    b366:	b2da      	uxtb	r2, r3
    b368:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b36c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b370:	701a      	strb	r2, [r3, #0]
    b372:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b376:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b37a:	781b      	ldrb	r3, [r3, #0]
    b37c:	2b27      	cmp	r3, #39	; 0x27
    b37e:	d9d7      	bls.n	b330 <uip_init+0x68>
	{
		uip_conns[ c ].tcpstateflags = UIP_CLOSED;
	}

	#if UIP_ACTIVE_OPEN
		lastport = 1024;
    b380:	f642 735c 	movw	r3, #12124	; 0x2f5c
    b384:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b388:	f44f 6280 	mov.w	r2, #1024	; 0x400
    b38c:	801a      	strh	r2, [r3, #0]

	/* IPv4 initialization. */
	#if UIP_FIXEDADDR == 0
		/*  uip_hostaddr[ 0 ] = uip_hostaddr[ 1 ] = 0;*/
	#endif /* UIP_FIXEDADDR */
}
    b38e:	46bd      	mov	sp, r7
    b390:	bc80      	pop	{r7}
    b392:	4770      	bx	lr

0000b394 <uip_connect>:
/*---------------------------------------------------------------------------*/

#if UIP_ACTIVE_OPEN
	struct uip_conn *uip_connect( uip_ipaddr_t *ripaddr, u16_t rport )
	{
    b394:	b5b0      	push	{r4, r5, r7, lr}
    b396:	b082      	sub	sp, #8
    b398:	af00      	add	r7, sp, #0
    b39a:	6078      	str	r0, [r7, #4]
    b39c:	460b      	mov	r3, r1
    b39e:	807b      	strh	r3, [r7, #2]
    b3a0:	e000      	b.n	b3a4 <uip_connect+0x10>
		for( c = 0; c < UIP_CONNS; ++c )
		{
			conn = &uip_conns[ c ];
			if( conn->tcpstateflags != UIP_CLOSED && conn->lport == htons(lastport) )
			{
				goto again;
    b3a2:	bf00      	nop
	{
		register struct uip_conn	*conn, *cconn;

		/* Find an unused local port. */
	again:
		++lastport;
    b3a4:	f642 735c 	movw	r3, #12124	; 0x2f5c
    b3a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b3ac:	881b      	ldrh	r3, [r3, #0]
    b3ae:	f103 0301 	add.w	r3, r3, #1
    b3b2:	b29a      	uxth	r2, r3
    b3b4:	f642 735c 	movw	r3, #12124	; 0x2f5c
    b3b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b3bc:	801a      	strh	r2, [r3, #0]

		if( lastport >= 32000 )
    b3be:	f642 735c 	movw	r3, #12124	; 0x2f5c
    b3c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b3c6:	881a      	ldrh	r2, [r3, #0]
    b3c8:	f647 43ff 	movw	r3, #31999	; 0x7cff
    b3cc:	429a      	cmp	r2, r3
    b3ce:	d906      	bls.n	b3de <uip_connect+0x4a>
		{
			lastport = 4096;
    b3d0:	f642 735c 	movw	r3, #12124	; 0x2f5c
    b3d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b3d8:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    b3dc:	801a      	strh	r2, [r3, #0]
		}

		/* Check if this port is already in use, and if so try to find
		 another one. */
		for( c = 0; c < UIP_CONNS; ++c )
    b3de:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b3e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b3e6:	f04f 0200 	mov.w	r2, #0
    b3ea:	701a      	strb	r2, [r3, #0]
    b3ec:	e02a      	b.n	b444 <uip_connect+0xb0>
		{
			conn = &uip_conns[ c ];
    b3ee:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b3f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b3f6:	781b      	ldrb	r3, [r3, #0]
    b3f8:	f04f 02cc 	mov.w	r2, #204	; 0xcc
    b3fc:	fb02 f203 	mul.w	r2, r2, r3
    b400:	f64a 432c 	movw	r3, #44076	; 0xac2c
    b404:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b408:	eb02 0403 	add.w	r4, r2, r3
			if( conn->tcpstateflags != UIP_CLOSED && conn->lport == htons(lastport) )
    b40c:	7e63      	ldrb	r3, [r4, #25]
    b40e:	2b00      	cmp	r3, #0
    b410:	d00b      	beq.n	b42a <uip_connect+0x96>
    b412:	88a4      	ldrh	r4, [r4, #4]
    b414:	f642 735c 	movw	r3, #12124	; 0x2f5c
    b418:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b41c:	881b      	ldrh	r3, [r3, #0]
    b41e:	4618      	mov	r0, r3
    b420:	f002 fa48 	bl	d8b4 <htons>
    b424:	4603      	mov	r3, r0
    b426:	429c      	cmp	r4, r3
    b428:	d0bb      	beq.n	b3a2 <uip_connect+0xe>
			lastport = 4096;
		}

		/* Check if this port is already in use, and if so try to find
		 another one. */
		for( c = 0; c < UIP_CONNS; ++c )
    b42a:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b42e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b432:	781b      	ldrb	r3, [r3, #0]
    b434:	f103 0301 	add.w	r3, r3, #1
    b438:	b2da      	uxtb	r2, r3
    b43a:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b43e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b442:	701a      	strb	r2, [r3, #0]
    b444:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b448:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b44c:	781b      	ldrb	r3, [r3, #0]
    b44e:	2b27      	cmp	r3, #39	; 0x27
    b450:	d9cd      	bls.n	b3ee <uip_connect+0x5a>
			{
				goto again;
			}
		}

		conn = 0;
    b452:	f04f 0400 	mov.w	r4, #0
		for( c = 0; c < UIP_CONNS; ++c )
    b456:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b45a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b45e:	f04f 0200 	mov.w	r2, #0
    b462:	701a      	strb	r2, [r3, #0]
    b464:	e02a      	b.n	b4bc <uip_connect+0x128>
		{
			cconn = &uip_conns[ c ];
    b466:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b46a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b46e:	781b      	ldrb	r3, [r3, #0]
    b470:	f04f 02cc 	mov.w	r2, #204	; 0xcc
    b474:	fb02 f203 	mul.w	r2, r2, r3
    b478:	f64a 432c 	movw	r3, #44076	; 0xac2c
    b47c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b480:	eb02 0503 	add.w	r5, r2, r3
			if( cconn->tcpstateflags == UIP_CLOSED )
    b484:	7e6b      	ldrb	r3, [r5, #25]
    b486:	2b00      	cmp	r3, #0
    b488:	d101      	bne.n	b48e <uip_connect+0xfa>
			{
				conn = cconn;
    b48a:	462c      	mov	r4, r5
				break;
    b48c:	e01d      	b.n	b4ca <uip_connect+0x136>
			}

			if( cconn->tcpstateflags == UIP_TIME_WAIT )
    b48e:	7e6b      	ldrb	r3, [r5, #25]
    b490:	2b07      	cmp	r3, #7
    b492:	d106      	bne.n	b4a2 <uip_connect+0x10e>
			{
				if( conn == 0 || cconn->timer > conn->timer )
    b494:	2c00      	cmp	r4, #0
    b496:	d003      	beq.n	b4a0 <uip_connect+0x10c>
    b498:	7eaa      	ldrb	r2, [r5, #26]
    b49a:	7ea3      	ldrb	r3, [r4, #26]
    b49c:	429a      	cmp	r2, r3
    b49e:	d900      	bls.n	b4a2 <uip_connect+0x10e>
				{
					conn = cconn;
    b4a0:	462c      	mov	r4, r5
				goto again;
			}
		}

		conn = 0;
		for( c = 0; c < UIP_CONNS; ++c )
    b4a2:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b4a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b4aa:	781b      	ldrb	r3, [r3, #0]
    b4ac:	f103 0301 	add.w	r3, r3, #1
    b4b0:	b2da      	uxtb	r2, r3
    b4b2:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b4b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b4ba:	701a      	strb	r2, [r3, #0]
    b4bc:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b4c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b4c4:	781b      	ldrb	r3, [r3, #0]
    b4c6:	2b27      	cmp	r3, #39	; 0x27
    b4c8:	d9cd      	bls.n	b466 <uip_connect+0xd2>
					conn = cconn;
				}
			}
		}

		if( conn == 0 )
    b4ca:	2c00      	cmp	r4, #0
    b4cc:	d102      	bne.n	b4d4 <uip_connect+0x140>
		{
			return 0;
    b4ce:	f04f 0300 	mov.w	r3, #0
    b4d2:	e04a      	b.n	b56a <uip_connect+0x1d6>
		}

		conn->tcpstateflags = UIP_SYN_SENT;
    b4d4:	f04f 0302 	mov.w	r3, #2
    b4d8:	7663      	strb	r3, [r4, #25]

		conn->snd_nxt[ 0 ] = iss[ 0 ];
    b4da:	f642 7358 	movw	r3, #12120	; 0x2f58
    b4de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b4e2:	781b      	ldrb	r3, [r3, #0]
    b4e4:	7323      	strb	r3, [r4, #12]
		conn->snd_nxt[ 1 ] = iss[ 1 ];
    b4e6:	f642 7358 	movw	r3, #12120	; 0x2f58
    b4ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b4ee:	785b      	ldrb	r3, [r3, #1]
    b4f0:	7363      	strb	r3, [r4, #13]
		conn->snd_nxt[ 2 ] = iss[ 2 ];
    b4f2:	f642 7358 	movw	r3, #12120	; 0x2f58
    b4f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b4fa:	789b      	ldrb	r3, [r3, #2]
    b4fc:	73a3      	strb	r3, [r4, #14]
		conn->snd_nxt[ 3 ] = iss[ 3 ];
    b4fe:	f642 7358 	movw	r3, #12120	; 0x2f58
    b502:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b506:	78db      	ldrb	r3, [r3, #3]
    b508:	73e3      	strb	r3, [r4, #15]

		conn->initialmss = conn->mss = UIP_TCP_MSS;
    b50a:	f240 5392 	movw	r3, #1426	; 0x592
    b50e:	8263      	strh	r3, [r4, #18]
    b510:	8a63      	ldrh	r3, [r4, #18]
    b512:	82a3      	strh	r3, [r4, #20]

		conn->len = 1;		/* TCP length of the SYN is one. */
    b514:	f04f 0301 	mov.w	r3, #1
    b518:	8223      	strh	r3, [r4, #16]
		conn->nrtx = 0;
    b51a:	f04f 0300 	mov.w	r3, #0
    b51e:	76e3      	strb	r3, [r4, #27]
		conn->timer = 1;	/* Send the SYN next time around. */
    b520:	f04f 0301 	mov.w	r3, #1
    b524:	76a3      	strb	r3, [r4, #26]
		conn->rto = UIP_RTO;
    b526:	f04f 0303 	mov.w	r3, #3
    b52a:	7623      	strb	r3, [r4, #24]
		conn->sa = 0;
    b52c:	f04f 0300 	mov.w	r3, #0
    b530:	75a3      	strb	r3, [r4, #22]
		conn->sv = 16;		/* Initial value of the RTT variance. */
    b532:	f04f 0310 	mov.w	r3, #16
    b536:	75e3      	strb	r3, [r4, #23]
		conn->lport = htons( lastport );
    b538:	f642 735c 	movw	r3, #12124	; 0x2f5c
    b53c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b540:	881b      	ldrh	r3, [r3, #0]
    b542:	4618      	mov	r0, r3
    b544:	f002 f9b6 	bl	d8b4 <htons>
    b548:	4603      	mov	r3, r0
    b54a:	80a3      	strh	r3, [r4, #4]
		conn->rport = rport;
    b54c:	887b      	ldrh	r3, [r7, #2]
    b54e:	80e3      	strh	r3, [r4, #6]
		uip_ipaddr_copy( &conn->ripaddr, ripaddr );
    b550:	687b      	ldr	r3, [r7, #4]
    b552:	781b      	ldrb	r3, [r3, #0]
    b554:	7023      	strb	r3, [r4, #0]
    b556:	687b      	ldr	r3, [r7, #4]
    b558:	785b      	ldrb	r3, [r3, #1]
    b55a:	7063      	strb	r3, [r4, #1]
    b55c:	687b      	ldr	r3, [r7, #4]
    b55e:	789b      	ldrb	r3, [r3, #2]
    b560:	70a3      	strb	r3, [r4, #2]
    b562:	687b      	ldr	r3, [r7, #4]
    b564:	78db      	ldrb	r3, [r3, #3]
    b566:	70e3      	strb	r3, [r4, #3]

		return conn;
    b568:	4623      	mov	r3, r4
	}
    b56a:	4618      	mov	r0, r3
    b56c:	f107 0708 	add.w	r7, r7, #8
    b570:	46bd      	mov	sp, r7
    b572:	bdb0      	pop	{r4, r5, r7, pc}

0000b574 <uip_unlisten>:
	}
/*---------------------------------------------------------------------------*/
#endif /* UIP_UDP */

void uip_unlisten( u16_t port )
{
    b574:	b480      	push	{r7}
    b576:	b083      	sub	sp, #12
    b578:	af00      	add	r7, sp, #0
    b57a:	4603      	mov	r3, r0
    b57c:	80fb      	strh	r3, [r7, #6]
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    b57e:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b582:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b586:	f04f 0200 	mov.w	r2, #0
    b58a:	701a      	strb	r2, [r3, #0]
    b58c:	e02a      	b.n	b5e4 <uip_unlisten+0x70>
	{
		if( uip_listenports[ c ] == port )
    b58e:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b592:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b596:	781b      	ldrb	r3, [r3, #0]
    b598:	461a      	mov	r2, r3
    b59a:	f64c 430c 	movw	r3, #52236	; 0xcc0c
    b59e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b5a2:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    b5a6:	88fa      	ldrh	r2, [r7, #6]
    b5a8:	429a      	cmp	r2, r3
    b5aa:	d10e      	bne.n	b5ca <uip_unlisten+0x56>
		{
			uip_listenports[ c ] = 0;
    b5ac:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b5b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b5b4:	781b      	ldrb	r3, [r3, #0]
    b5b6:	461a      	mov	r2, r3
    b5b8:	f64c 430c 	movw	r3, #52236	; 0xcc0c
    b5bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b5c0:	f04f 0100 	mov.w	r1, #0
    b5c4:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
			return;
    b5c8:	e013      	b.n	b5f2 <uip_unlisten+0x7e>
/*---------------------------------------------------------------------------*/
#endif /* UIP_UDP */

void uip_unlisten( u16_t port )
{
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    b5ca:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b5ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b5d2:	781b      	ldrb	r3, [r3, #0]
    b5d4:	f103 0301 	add.w	r3, r3, #1
    b5d8:	b2da      	uxtb	r2, r3
    b5da:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b5de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b5e2:	701a      	strb	r2, [r3, #0]
    b5e4:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b5e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b5ec:	781b      	ldrb	r3, [r3, #0]
    b5ee:	2b27      	cmp	r3, #39	; 0x27
    b5f0:	d9cd      	bls.n	b58e <uip_unlisten+0x1a>
		{
			uip_listenports[ c ] = 0;
			return;
		}
	}
}
    b5f2:	f107 070c 	add.w	r7, r7, #12
    b5f6:	46bd      	mov	sp, r7
    b5f8:	bc80      	pop	{r7}
    b5fa:	4770      	bx	lr

0000b5fc <uip_listen>:
/*---------------------------------------------------------------------------*/

void uip_listen( u16_t port )
{
    b5fc:	b480      	push	{r7}
    b5fe:	b083      	sub	sp, #12
    b600:	af00      	add	r7, sp, #0
    b602:	4603      	mov	r3, r0
    b604:	80fb      	strh	r3, [r7, #6]
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    b606:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b60a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b60e:	f04f 0200 	mov.w	r2, #0
    b612:	701a      	strb	r2, [r3, #0]
    b614:	e028      	b.n	b668 <uip_listen+0x6c>
	{
		if( uip_listenports[ c ] == 0 )
    b616:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b61a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b61e:	781b      	ldrb	r3, [r3, #0]
    b620:	461a      	mov	r2, r3
    b622:	f64c 430c 	movw	r3, #52236	; 0xcc0c
    b626:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b62a:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    b62e:	2b00      	cmp	r3, #0
    b630:	d10d      	bne.n	b64e <uip_listen+0x52>
		{
			uip_listenports[ c ] = port;
    b632:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b636:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b63a:	781b      	ldrb	r3, [r3, #0]
    b63c:	461a      	mov	r2, r3
    b63e:	f64c 430c 	movw	r3, #52236	; 0xcc0c
    b642:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b646:	88f9      	ldrh	r1, [r7, #6]
    b648:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
			return;
    b64c:	e013      	b.n	b676 <uip_listen+0x7a>
}
/*---------------------------------------------------------------------------*/

void uip_listen( u16_t port )
{
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    b64e:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b652:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b656:	781b      	ldrb	r3, [r3, #0]
    b658:	f103 0301 	add.w	r3, r3, #1
    b65c:	b2da      	uxtb	r2, r3
    b65e:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b662:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b666:	701a      	strb	r2, [r3, #0]
    b668:	f642 735e 	movw	r3, #12126	; 0x2f5e
    b66c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b670:	781b      	ldrb	r3, [r3, #0]
    b672:	2b27      	cmp	r3, #39	; 0x27
    b674:	d9cf      	bls.n	b616 <uip_listen+0x1a>
		{
			uip_listenports[ c ] = port;
			return;
		}
	}
}
    b676:	f107 070c 	add.w	r7, r7, #12
    b67a:	46bd      	mov	sp, r7
    b67c:	bc80      	pop	{r7}
    b67e:	4770      	bx	lr

0000b680 <uip_add_rcv_nxt>:
/*---------------------------------------------------------------------------*/
#endif /* UIP_REASSEMBLY */


static void uip_add_rcv_nxt( u16_t n )
{
    b680:	b580      	push	{r7, lr}
    b682:	b082      	sub	sp, #8
    b684:	af00      	add	r7, sp, #0
    b686:	4603      	mov	r3, r0
    b688:	80fb      	strh	r3, [r7, #6]
	uip_add32( uip_conn->rcv_nxt, n );
    b68a:	f64a 4328 	movw	r3, #44072	; 0xac28
    b68e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b692:	681b      	ldr	r3, [r3, #0]
    b694:	f103 0208 	add.w	r2, r3, #8
    b698:	88fb      	ldrh	r3, [r7, #6]
    b69a:	4610      	mov	r0, r2
    b69c:	4619      	mov	r1, r3
    b69e:	f7ff fc7d 	bl	af9c <uip_add32>
	uip_conn->rcv_nxt[ 0 ] = uip_acc32[ 0 ];
    b6a2:	f64a 4328 	movw	r3, #44072	; 0xac28
    b6a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b6aa:	681a      	ldr	r2, [r3, #0]
    b6ac:	f64a 431c 	movw	r3, #44060	; 0xac1c
    b6b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b6b4:	781b      	ldrb	r3, [r3, #0]
    b6b6:	7213      	strb	r3, [r2, #8]
	uip_conn->rcv_nxt[ 1 ] = uip_acc32[ 1 ];
    b6b8:	f64a 4328 	movw	r3, #44072	; 0xac28
    b6bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b6c0:	681a      	ldr	r2, [r3, #0]
    b6c2:	f64a 431c 	movw	r3, #44060	; 0xac1c
    b6c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b6ca:	785b      	ldrb	r3, [r3, #1]
    b6cc:	7253      	strb	r3, [r2, #9]
	uip_conn->rcv_nxt[ 2 ] = uip_acc32[ 2 ];
    b6ce:	f64a 4328 	movw	r3, #44072	; 0xac28
    b6d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b6d6:	681a      	ldr	r2, [r3, #0]
    b6d8:	f64a 431c 	movw	r3, #44060	; 0xac1c
    b6dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b6e0:	789b      	ldrb	r3, [r3, #2]
    b6e2:	7293      	strb	r3, [r2, #10]
	uip_conn->rcv_nxt[ 3 ] = uip_acc32[ 3 ];
    b6e4:	f64a 4328 	movw	r3, #44072	; 0xac28
    b6e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b6ec:	681a      	ldr	r2, [r3, #0]
    b6ee:	f64a 431c 	movw	r3, #44060	; 0xac1c
    b6f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b6f6:	78db      	ldrb	r3, [r3, #3]
    b6f8:	72d3      	strb	r3, [r2, #11]
}
    b6fa:	f107 0708 	add.w	r7, r7, #8
    b6fe:	46bd      	mov	sp, r7
    b700:	bd80      	pop	{r7, pc}
    b702:	bf00      	nop

0000b704 <uip_process>:
/*---------------------------------------------------------------------------*/

void uip_process( u8_t flag )
{
    b704:	b590      	push	{r4, r7, lr}
    b706:	b085      	sub	sp, #20
    b708:	af00      	add	r7, sp, #0
    b70a:	4603      	mov	r3, r0
    b70c:	71fb      	strb	r3, [r7, #7]
	register struct uip_conn	*uip_connr = uip_conn;
    b70e:	f64a 4328 	movw	r3, #44072	; 0xac28
    b712:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b716:	681c      	ldr	r4, [r3, #0]
		{
			goto udp_send;
		}
	#endif /* UIP_UDP */

	uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
    b718:	f240 6370 	movw	r3, #1648	; 0x670
    b71c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b720:	681b      	ldr	r3, [r3, #0]
    b722:	f103 0236 	add.w	r2, r3, #54	; 0x36
    b726:	f64a 4324 	movw	r3, #44068	; 0xac24
    b72a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b72e:	601a      	str	r2, [r3, #0]
    b730:	f64a 4324 	movw	r3, #44068	; 0xac24
    b734:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b738:	681a      	ldr	r2, [r3, #0]
    b73a:	f64a 4318 	movw	r3, #44056	; 0xac18
    b73e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b742:	601a      	str	r2, [r3, #0]

	/* Check if we were invoked because of a poll request for a
	 particular connection. */
	if( flag == UIP_POLL_REQUEST )
    b744:	79fb      	ldrb	r3, [r7, #7]
    b746:	2b03      	cmp	r3, #3
    b748:	d114      	bne.n	b774 <uip_process+0x70>
	{
		if( (uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED && !uip_outstanding(uip_connr) )
    b74a:	7e63      	ldrb	r3, [r4, #25]
    b74c:	f003 030f 	and.w	r3, r3, #15
    b750:	2b03      	cmp	r3, #3
    b752:	f042 807c 	bne.w	d84e <uip_process+0x214a>
    b756:	8a23      	ldrh	r3, [r4, #16]
    b758:	2b00      	cmp	r3, #0
    b75a:	f042 807a 	bne.w	d852 <uip_process+0x214e>
		{
			uip_flags = UIP_POLL;
    b75e:	f64a 4320 	movw	r3, #44064	; 0xac20
    b762:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b766:	f04f 0208 	mov.w	r2, #8
    b76a:	701a      	strb	r2, [r3, #0]
			UIP_APPCALL();
    b76c:	f003 fcd0 	bl	f110 <httpd_appcall>
			goto appsend;
    b770:	f001 bcbc 	b.w	d0ec <uip_process+0x19e8>

		goto drop;

		/* Check if we were invoked because of the perodic timer fireing. */
	}
	else if( flag == UIP_TIMER )
    b774:	79fb      	ldrb	r3, [r7, #7]
    b776:	2b02      	cmp	r3, #2
    b778:	f040 8109 	bne.w	b98e <uip_process+0x28a>
				--uip_reasstmr;
			}
		#endif /* UIP_REASSEMBLY */

		/* Increase the initial sequence number. */
		if( ++iss[ 3 ] == 0 )
    b77c:	f642 7358 	movw	r3, #12120	; 0x2f58
    b780:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b784:	78db      	ldrb	r3, [r3, #3]
    b786:	f103 0301 	add.w	r3, r3, #1
    b78a:	b2da      	uxtb	r2, r3
    b78c:	f642 7358 	movw	r3, #12120	; 0x2f58
    b790:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b794:	70da      	strb	r2, [r3, #3]
    b796:	f642 7358 	movw	r3, #12120	; 0x2f58
    b79a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b79e:	78db      	ldrb	r3, [r3, #3]
    b7a0:	2b00      	cmp	r3, #0
    b7a2:	d134      	bne.n	b80e <uip_process+0x10a>
		{
			if( ++iss[ 2 ] == 0 )
    b7a4:	f642 7358 	movw	r3, #12120	; 0x2f58
    b7a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b7ac:	789b      	ldrb	r3, [r3, #2]
    b7ae:	f103 0301 	add.w	r3, r3, #1
    b7b2:	b2da      	uxtb	r2, r3
    b7b4:	f642 7358 	movw	r3, #12120	; 0x2f58
    b7b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b7bc:	709a      	strb	r2, [r3, #2]
    b7be:	f642 7358 	movw	r3, #12120	; 0x2f58
    b7c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b7c6:	789b      	ldrb	r3, [r3, #2]
    b7c8:	2b00      	cmp	r3, #0
    b7ca:	d120      	bne.n	b80e <uip_process+0x10a>
			{
				if( ++iss[ 1 ] == 0 )
    b7cc:	f642 7358 	movw	r3, #12120	; 0x2f58
    b7d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b7d4:	785b      	ldrb	r3, [r3, #1]
    b7d6:	f103 0301 	add.w	r3, r3, #1
    b7da:	b2da      	uxtb	r2, r3
    b7dc:	f642 7358 	movw	r3, #12120	; 0x2f58
    b7e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b7e4:	705a      	strb	r2, [r3, #1]
    b7e6:	f642 7358 	movw	r3, #12120	; 0x2f58
    b7ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b7ee:	785b      	ldrb	r3, [r3, #1]
    b7f0:	2b00      	cmp	r3, #0
    b7f2:	d10c      	bne.n	b80e <uip_process+0x10a>
				{
					++iss[ 0 ];
    b7f4:	f642 7358 	movw	r3, #12120	; 0x2f58
    b7f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b7fc:	781b      	ldrb	r3, [r3, #0]
    b7fe:	f103 0301 	add.w	r3, r3, #1
    b802:	b2da      	uxtb	r2, r3
    b804:	f642 7358 	movw	r3, #12120	; 0x2f58
    b808:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b80c:	701a      	strb	r2, [r3, #0]
				}
			}
		}

		/* Reset the length variables. */
		uip_len = 0;
    b80e:	f64a 4314 	movw	r3, #44052	; 0xac14
    b812:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b816:	f04f 0200 	mov.w	r2, #0
    b81a:	801a      	strh	r2, [r3, #0]
		uip_slen = 0;
    b81c:	f64c 43a0 	movw	r3, #52384	; 0xcca0
    b820:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b824:	f04f 0200 	mov.w	r2, #0
    b828:	801a      	strh	r2, [r3, #0]

		/* Check if the connection is in a state in which we simply wait
		for the connection to time out. If so, we increase the
		connection's timer and remove the connection if it times
		out. */
		if( uip_connr->tcpstateflags == UIP_TIME_WAIT || uip_connr->tcpstateflags == UIP_FIN_WAIT_2 )
    b82a:	7e63      	ldrb	r3, [r4, #25]
    b82c:	2b07      	cmp	r3, #7
    b82e:	d002      	beq.n	b836 <uip_process+0x132>
    b830:	7e63      	ldrb	r3, [r4, #25]
    b832:	2b05      	cmp	r3, #5
    b834:	d10d      	bne.n	b852 <uip_process+0x14e>
		{
			++( uip_connr->timer );
    b836:	7ea3      	ldrb	r3, [r4, #26]
    b838:	f103 0301 	add.w	r3, r3, #1
    b83c:	b2db      	uxtb	r3, r3
    b83e:	76a3      	strb	r3, [r4, #26]
			if( uip_connr->timer == UIP_TIME_WAIT_TIMEOUT )
    b840:	7ea3      	ldrb	r3, [r4, #26]
    b842:	2b78      	cmp	r3, #120	; 0x78
    b844:	d102      	bne.n	b84c <uip_process+0x148>
			{
				uip_connr->tcpstateflags = UIP_CLOSED;
    b846:	f04f 0300 	mov.w	r3, #0
    b84a:	7663      	strb	r3, [r4, #25]

		/* Check if the connection is in a state in which we simply wait
		for the connection to time out. If so, we increase the
		connection's timer and remove the connection if it times
		out. */
		if( uip_connr->tcpstateflags == UIP_TIME_WAIT || uip_connr->tcpstateflags == UIP_FIN_WAIT_2 )
    b84c:	bf00      	nop
				UIP_APPCALL();
				goto appsend;
			}
		}

		goto drop;
    b84e:	f002 b81d 	b.w	d88c <uip_process+0x2188>
			if( uip_connr->timer == UIP_TIME_WAIT_TIMEOUT )
			{
				uip_connr->tcpstateflags = UIP_CLOSED;
			}
		}
		else if( uip_connr->tcpstateflags != UIP_CLOSED )
    b852:	7e63      	ldrb	r3, [r4, #25]
    b854:	2b00      	cmp	r3, #0
    b856:	f001 87fe 	beq.w	d856 <uip_process+0x2152>
		{
			/* If the connection has outstanding data, we increase the
			connection's timer and see if it has reached the RTO value
			in which case we retransmit. */
			if( uip_outstanding(uip_connr) )
    b85a:	8a23      	ldrh	r3, [r4, #16]
    b85c:	2b00      	cmp	r3, #0
    b85e:	f000 8085 	beq.w	b96c <uip_process+0x268>
			{
				if( uip_connr->timer-- == 0 )
    b862:	7ea3      	ldrb	r3, [r4, #26]
    b864:	2b00      	cmp	r3, #0
    b866:	bf14      	ite	ne
    b868:	2200      	movne	r2, #0
    b86a:	2201      	moveq	r2, #1
    b86c:	b2d2      	uxtb	r2, r2
    b86e:	f103 33ff 	add.w	r3, r3, #4294967295
    b872:	b2db      	uxtb	r3, r3
    b874:	76a3      	strb	r3, [r4, #26]
    b876:	2a00      	cmp	r2, #0
    b878:	f001 87ef 	beq.w	d85a <uip_process+0x2156>
				{
					if
					(
						uip_connr->nrtx == UIP_MAXRTX ||
    b87c:	7ee3      	ldrb	r3, [r4, #27]
			if( uip_outstanding(uip_connr) )
			{
				if( uip_connr->timer-- == 0 )
				{
					if
					(
    b87e:	2b08      	cmp	r3, #8
    b880:	d008      	beq.n	b894 <uip_process+0x190>
						uip_connr->nrtx == UIP_MAXRTX ||
						(
							(uip_connr->tcpstateflags == UIP_SYN_SENT || uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
    b882:	7e63      	ldrb	r3, [r4, #25]
			if( uip_outstanding(uip_connr) )
			{
				if( uip_connr->timer-- == 0 )
				{
					if
					(
    b884:	2b02      	cmp	r3, #2
    b886:	d002      	beq.n	b88e <uip_process+0x18a>
						uip_connr->nrtx == UIP_MAXRTX ||
						(
							(uip_connr->tcpstateflags == UIP_SYN_SENT || uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
    b888:	7e63      	ldrb	r3, [r4, #25]
			if( uip_outstanding(uip_connr) )
			{
				if( uip_connr->timer-- == 0 )
				{
					if
					(
    b88a:	2b01      	cmp	r3, #1
    b88c:	d11b      	bne.n	b8c6 <uip_process+0x1c2>
						uip_connr->nrtx == UIP_MAXRTX ||
						(
							(uip_connr->tcpstateflags == UIP_SYN_SENT || uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
							uip_connr->nrtx == UIP_MAXSYNRTX
    b88e:	7ee3      	ldrb	r3, [r4, #27]
			if( uip_outstanding(uip_connr) )
			{
				if( uip_connr->timer-- == 0 )
				{
					if
					(
    b890:	2b05      	cmp	r3, #5
    b892:	d118      	bne.n	b8c6 <uip_process+0x1c2>
							(uip_connr->tcpstateflags == UIP_SYN_SENT || uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
							uip_connr->nrtx == UIP_MAXSYNRTX
						)
					)
					{
						uip_connr->tcpstateflags = UIP_CLOSED;
    b894:	f04f 0300 	mov.w	r3, #0
    b898:	7663      	strb	r3, [r4, #25]

						/* We call UIP_APPCALL() with uip_flags set to
						UIP_TIMEDOUT to inform the application that the
						connection has timed out. */
						uip_flags = UIP_TIMEDOUT;
    b89a:	f64a 4320 	movw	r3, #44064	; 0xac20
    b89e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b8a2:	f06f 027f 	mvn.w	r2, #127	; 0x7f
    b8a6:	701a      	strb	r2, [r3, #0]
						UIP_APPCALL();
    b8a8:	f003 fc32 	bl	f110 <httpd_appcall>

						/* We also send a reset packet to the remote host. */
						BUF->flags = TCP_RST | TCP_ACK;
    b8ac:	f240 6370 	movw	r3, #1648	; 0x670
    b8b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b8b4:	681b      	ldr	r3, [r3, #0]
    b8b6:	f103 030e 	add.w	r3, r3, #14
    b8ba:	f04f 0214 	mov.w	r2, #20
    b8be:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
						goto tcp_send_nodata;
    b8c2:	f001 bd9e 	b.w	d402 <uip_process+0x1cfe>
					}

					/* Exponential backoff. */
					uip_connr->timer = UIP_RTO << ( uip_connr->nrtx > 4 ? 4 : uip_connr->nrtx );
    b8c6:	7ee3      	ldrb	r3, [r4, #27]
    b8c8:	2b04      	cmp	r3, #4
    b8ca:	d806      	bhi.n	b8da <uip_process+0x1d6>
    b8cc:	7ee3      	ldrb	r3, [r4, #27]
    b8ce:	f04f 0203 	mov.w	r2, #3
    b8d2:	fa02 f303 	lsl.w	r3, r2, r3
    b8d6:	b2db      	uxtb	r3, r3
    b8d8:	e001      	b.n	b8de <uip_process+0x1da>
    b8da:	f04f 0330 	mov.w	r3, #48	; 0x30
    b8de:	76a3      	strb	r3, [r4, #26]
					++( uip_connr->nrtx );
    b8e0:	7ee3      	ldrb	r3, [r4, #27]
    b8e2:	f103 0301 	add.w	r3, r3, #1
    b8e6:	b2db      	uxtb	r3, r3
    b8e8:	76e3      	strb	r3, [r4, #27]
					depending on which state we are in. In ESTABLISHED, we
					call upon the application so that it may prepare the
					data for the retransmit. In SYN_RCVD, we resend the
					SYNACK that we sent earlier and in LAST_ACK we have to
					retransmit our FINACK. */
							UIP_STAT( ++uip_stat.tcp.rexmit );
    b8ea:	f64c 4360 	movw	r3, #52320	; 0xcc60
    b8ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b8f2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    b8f4:	f103 0301 	add.w	r3, r3, #1
    b8f8:	b29a      	uxth	r2, r3
    b8fa:	f64c 4360 	movw	r3, #52320	; 0xcc60
    b8fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b902:	855a      	strh	r2, [r3, #42]	; 0x2a
					switch( uip_connr->tcpstateflags & UIP_TS_MASK )
    b904:	7e63      	ldrb	r3, [r4, #25]
    b906:	f003 030f 	and.w	r3, r3, #15
    b90a:	f103 33ff 	add.w	r3, r3, #4294967295
    b90e:	2b07      	cmp	r3, #7
    b910:	f201 87a5 	bhi.w	d85e <uip_process+0x215a>
    b914:	a201      	add	r2, pc, #4	; (adr r2, b91c <uip_process+0x218>)
    b916:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    b91a:	bf00      	nop
    b91c:	0000c7f3 	.word	0x0000c7f3
    b920:	0000b93d 	.word	0x0000b93d
    b924:	0000b957 	.word	0x0000b957
    b928:	0000cf55 	.word	0x0000cf55
    b92c:	0000d85f 	.word	0x0000d85f
    b930:	0000cf55 	.word	0x0000cf55
    b934:	0000d85f 	.word	0x0000d85f
    b938:	0000cf55 	.word	0x0000cf55
							goto tcp_send_synack;

						#if UIP_ACTIVE_OPEN
							case UIP_SYN_SENT:
								/* In the SYN_SENT state, we retransmit out SYN. */
								BUF->flags = 0;
    b93c:	f240 6370 	movw	r3, #1648	; 0x670
    b940:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b944:	681b      	ldr	r3, [r3, #0]
    b946:	f103 030e 	add.w	r3, r3, #14
    b94a:	f04f 0200 	mov.w	r2, #0
    b94e:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
								goto tcp_send_syn;
    b952:	f000 bf5e 	b.w	c812 <uip_process+0x110e>
						case UIP_ESTABLISHED:
							/* In the ESTABLISHED state, we call upon the application
							to do the actual retransmit after which we jump into
							the code for sending out the packet (the apprexmit
							label). */
							uip_flags = UIP_REXMIT;
    b956:	f64a 4320 	movw	r3, #44064	; 0xac20
    b95a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b95e:	f04f 0204 	mov.w	r2, #4
    b962:	701a      	strb	r2, [r3, #0]
							UIP_APPCALL();
    b964:	f003 fbd4 	bl	f110 <httpd_appcall>
							goto apprexmit;
    b968:	f001 bc39 	b.w	d1de <uip_process+0x1ada>
							/* In all these states we should retransmit a FINACK. */
							goto tcp_send_finack;
					}
				}
			}
			else if( (uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED )
    b96c:	7e63      	ldrb	r3, [r4, #25]
    b96e:	f003 030f 	and.w	r3, r3, #15
    b972:	2b03      	cmp	r3, #3
    b974:	f041 8775 	bne.w	d862 <uip_process+0x215e>
			{
				/* If there was no need for a retransmission, we poll the
				application for new data. */
				uip_flags = UIP_POLL;
    b978:	f64a 4320 	movw	r3, #44064	; 0xac20
    b97c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b980:	f04f 0208 	mov.w	r2, #8
    b984:	701a      	strb	r2, [r3, #0]
				UIP_APPCALL();
    b986:	f003 fbc3 	bl	f110 <httpd_appcall>
				goto appsend;
    b98a:	f001 bbaf 	b.w	d0ec <uip_process+0x19e8>
			}
		}
	#endif

	/* This is where the input processing starts. */
	UIP_STAT( ++uip_stat.ip.recv );
    b98e:	f64c 4360 	movw	r3, #52320	; 0xcc60
    b992:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b996:	881b      	ldrh	r3, [r3, #0]
    b998:	f103 0301 	add.w	r3, r3, #1
    b99c:	b29a      	uxth	r2, r3
    b99e:	f64c 4360 	movw	r3, #52320	; 0xcc60
    b9a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b9a6:	801a      	strh	r2, [r3, #0]
			goto drop;
		}

	#else /* UIP_CONF_IPV6 */
		/* Check validity of the IP header. */
		if( BUF->vhl != 0x45 )
    b9a8:	f240 6370 	movw	r3, #1648	; 0x670
    b9ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b9b0:	681b      	ldr	r3, [r3, #0]
    b9b2:	f103 030e 	add.w	r3, r3, #14
    b9b6:	781b      	ldrb	r3, [r3, #0]
    b9b8:	2b45      	cmp	r3, #69	; 0x45
    b9ba:	d01b      	beq.n	b9f4 <uip_process+0x2f0>
		{					/* IP version and header length. */
			UIP_STAT( ++uip_stat.ip.drop );
    b9bc:	f64c 4360 	movw	r3, #52320	; 0xcc60
    b9c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b9c4:	88db      	ldrh	r3, [r3, #6]
    b9c6:	f103 0301 	add.w	r3, r3, #1
    b9ca:	b29a      	uxth	r2, r3
    b9cc:	f64c 4360 	movw	r3, #52320	; 0xcc60
    b9d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b9d4:	80da      	strh	r2, [r3, #6]
			UIP_STAT( ++uip_stat.ip.vhlerr );
    b9d6:	f64c 4360 	movw	r3, #52320	; 0xcc60
    b9da:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b9de:	891b      	ldrh	r3, [r3, #8]
    b9e0:	f103 0301 	add.w	r3, r3, #1
    b9e4:	b29a      	uxth	r2, r3
    b9e6:	f64c 4360 	movw	r3, #52320	; 0xcc60
    b9ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b9ee:	811a      	strh	r2, [r3, #8]
			UIP_LOG( "ip: invalid version or header length." );
			goto drop;
    b9f0:	f001 bf4c 	b.w	d88c <uip_process+0x2188>
	uip_len is smaller the size reported in the IP header, we assume
	that the packet has been corrupted in transit. If the size of
	uip_len is larger than the size reported in the IP packet header,
	the packet has been padded and we set uip_len to the correct
	value.. */
	if( (BUF->len[ 0 ] << 8) + BUF->len[ 1 ] <= uip_len )
    b9f4:	f240 6370 	movw	r3, #1648	; 0x670
    b9f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b9fc:	681b      	ldr	r3, [r3, #0]
    b9fe:	f103 030e 	add.w	r3, r3, #14
    ba02:	789b      	ldrb	r3, [r3, #2]
    ba04:	ea4f 2203 	mov.w	r2, r3, lsl #8
    ba08:	f240 6370 	movw	r3, #1648	; 0x670
    ba0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ba10:	681b      	ldr	r3, [r3, #0]
    ba12:	f103 030e 	add.w	r3, r3, #14
    ba16:	78db      	ldrb	r3, [r3, #3]
    ba18:	441a      	add	r2, r3
    ba1a:	f64a 4314 	movw	r3, #44052	; 0xac14
    ba1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ba22:	881b      	ldrh	r3, [r3, #0]
    ba24:	429a      	cmp	r2, r3
    ba26:	f301 871e 	bgt.w	d866 <uip_process+0x2162>
	{
		uip_len = ( BUF->len[ 0 ] << 8 ) + BUF->len[ 1 ];
    ba2a:	f240 6370 	movw	r3, #1648	; 0x670
    ba2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ba32:	681b      	ldr	r3, [r3, #0]
    ba34:	f103 030e 	add.w	r3, r3, #14
    ba38:	789b      	ldrb	r3, [r3, #2]
    ba3a:	ea4f 2303 	mov.w	r3, r3, lsl #8
    ba3e:	b29a      	uxth	r2, r3
    ba40:	f240 6370 	movw	r3, #1648	; 0x670
    ba44:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ba48:	681b      	ldr	r3, [r3, #0]
    ba4a:	f103 030e 	add.w	r3, r3, #14
    ba4e:	78db      	ldrb	r3, [r3, #3]
    ba50:	4413      	add	r3, r2
    ba52:	b29a      	uxth	r2, r3
    ba54:	f64a 4314 	movw	r3, #44052	; 0xac14
    ba58:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ba5c:	801a      	strh	r2, [r3, #0]
		goto drop;
	}

	#if !UIP_CONF_IPV6
		/* Check the fragment flag. */
		if( (BUF->ipoffset[ 0 ] & 0x3f) != 0 || BUF->ipoffset[ 1 ] != 0 )
    ba5e:	f240 6370 	movw	r3, #1648	; 0x670
    ba62:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ba66:	681b      	ldr	r3, [r3, #0]
    ba68:	f103 030e 	add.w	r3, r3, #14
    ba6c:	799b      	ldrb	r3, [r3, #6]
    ba6e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    ba72:	2b00      	cmp	r3, #0
    ba74:	d109      	bne.n	ba8a <uip_process+0x386>
    ba76:	f240 6370 	movw	r3, #1648	; 0x670
    ba7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ba7e:	681b      	ldr	r3, [r3, #0]
    ba80:	f103 030e 	add.w	r3, r3, #14
    ba84:	79db      	ldrb	r3, [r3, #7]
    ba86:	2b00      	cmp	r3, #0
    ba88:	d01b      	beq.n	bac2 <uip_process+0x3be>
				if( uip_len == 0 )
				{
					goto drop;
				}
			#else /* UIP_REASSEMBLY */
				UIP_STAT( ++uip_stat.ip.drop );
    ba8a:	f64c 4360 	movw	r3, #52320	; 0xcc60
    ba8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ba92:	88db      	ldrh	r3, [r3, #6]
    ba94:	f103 0301 	add.w	r3, r3, #1
    ba98:	b29a      	uxth	r2, r3
    ba9a:	f64c 4360 	movw	r3, #52320	; 0xcc60
    ba9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    baa2:	80da      	strh	r2, [r3, #6]
				UIP_STAT( ++uip_stat.ip.fragerr );
    baa4:	f64c 4360 	movw	r3, #52320	; 0xcc60
    baa8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    baac:	89db      	ldrh	r3, [r3, #14]
    baae:	f103 0301 	add.w	r3, r3, #1
    bab2:	b29a      	uxth	r2, r3
    bab4:	f64c 4360 	movw	r3, #52320	; 0xcc60
    bab8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    babc:	81da      	strh	r2, [r3, #14]
				UIP_LOG( "ip: fragment dropped." );
				goto drop;
    babe:	f001 bee5 	b.w	d88c <uip_process+0x2188>
			#endif /* UIP_REASSEMBLY */
		}
	#endif /* UIP_CONF_IPV6 */

	if( uip_ipaddr_cmp(&uip_hostaddr, &uip_all_zeroes_addr) )
    bac2:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    bac6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    baca:	881a      	ldrh	r2, [r3, #0]
    bacc:	f24d 1324 	movw	r3, #53540	; 0xd124
    bad0:	f2c0 0301 	movt	r3, #1
    bad4:	881b      	ldrh	r3, [r3, #0]
    bad6:	429a      	cmp	r2, r3
    bad8:	d10b      	bne.n	baf2 <uip_process+0x3ee>
    bada:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    bade:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bae2:	885a      	ldrh	r2, [r3, #2]
    bae4:	f24d 1324 	movw	r3, #53540	; 0xd124
    bae8:	f2c0 0301 	movt	r3, #1
    baec:	885b      	ldrh	r3, [r3, #2]
    baee:	429a      	cmp	r2, r3
    baf0:	d038      	beq.n	bb64 <uip_process+0x460>
			}
		#endif /* UIP_BROADCAST */

		/* Check if the packet is destined for our IP address. */
		#if !UIP_CONF_IPV6
			if( !uip_ipaddr_cmp(&BUF->destipaddr, &uip_hostaddr) )
    baf2:	f240 6370 	movw	r3, #1648	; 0x670
    baf6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bafa:	681b      	ldr	r3, [r3, #0]
    bafc:	f103 030e 	add.w	r3, r3, #14
    bb00:	7c1a      	ldrb	r2, [r3, #16]
    bb02:	7c5b      	ldrb	r3, [r3, #17]
    bb04:	ea4f 2303 	mov.w	r3, r3, lsl #8
    bb08:	ea43 0302 	orr.w	r3, r3, r2
    bb0c:	b29a      	uxth	r2, r3
    bb0e:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    bb12:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bb16:	881b      	ldrh	r3, [r3, #0]
    bb18:	429a      	cmp	r2, r3
    bb1a:	d114      	bne.n	bb46 <uip_process+0x442>
    bb1c:	f240 6370 	movw	r3, #1648	; 0x670
    bb20:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bb24:	681b      	ldr	r3, [r3, #0]
    bb26:	f103 030e 	add.w	r3, r3, #14
    bb2a:	7c9a      	ldrb	r2, [r3, #18]
    bb2c:	7cdb      	ldrb	r3, [r3, #19]
    bb2e:	ea4f 2303 	mov.w	r3, r3, lsl #8
    bb32:	ea43 0302 	orr.w	r3, r3, r2
    bb36:	b29a      	uxth	r2, r3
    bb38:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    bb3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bb40:	885b      	ldrh	r3, [r3, #2]
    bb42:	429a      	cmp	r2, r3
    bb44:	d00e      	beq.n	bb64 <uip_process+0x460>
			{
				UIP_STAT( ++uip_stat.ip.drop );
    bb46:	f64c 4360 	movw	r3, #52320	; 0xcc60
    bb4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bb4e:	88db      	ldrh	r3, [r3, #6]
    bb50:	f103 0301 	add.w	r3, r3, #1
    bb54:	b29a      	uxth	r2, r3
    bb56:	f64c 4360 	movw	r3, #52320	; 0xcc60
    bb5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bb5e:	80da      	strh	r2, [r3, #6]
				goto drop;
    bb60:	f001 be94 	b.w	d88c <uip_process+0x2188>
			}
		#endif /* UIP_CONF_IPV6 */
	}

	#if !UIP_CONF_IPV6
		if( uip_ipchksum() != 0xffff )
    bb64:	f7ff fb24 	bl	b1b0 <uip_ipchksum>
    bb68:	4603      	mov	r3, r0
    bb6a:	461a      	mov	r2, r3
    bb6c:	f64f 73ff 	movw	r3, #65535	; 0xffff
    bb70:	429a      	cmp	r2, r3
    bb72:	d01b      	beq.n	bbac <uip_process+0x4a8>
		{
			/* Compute and check the IP header checksum. */
			UIP_STAT( ++uip_stat.ip.drop );
    bb74:	f64c 4360 	movw	r3, #52320	; 0xcc60
    bb78:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bb7c:	88db      	ldrh	r3, [r3, #6]
    bb7e:	f103 0301 	add.w	r3, r3, #1
    bb82:	b29a      	uxth	r2, r3
    bb84:	f64c 4360 	movw	r3, #52320	; 0xcc60
    bb88:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bb8c:	80da      	strh	r2, [r3, #6]
			UIP_STAT( ++uip_stat.ip.chkerr );
    bb8e:	f64c 4360 	movw	r3, #52320	; 0xcc60
    bb92:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bb96:	8a1b      	ldrh	r3, [r3, #16]
    bb98:	f103 0301 	add.w	r3, r3, #1
    bb9c:	b29a      	uxth	r2, r3
    bb9e:	f64c 4360 	movw	r3, #52320	; 0xcc60
    bba2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bba6:	821a      	strh	r2, [r3, #16]
			UIP_LOG( "ip: bad checksum." );
			goto drop;
    bba8:	f001 be70 	b.w	d88c <uip_process+0x2188>
		}
	#endif /* UIP_CONF_IPV6 */

	if( BUF->proto == UIP_PROTO_TCP )
    bbac:	f240 6370 	movw	r3, #1648	; 0x670
    bbb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bbb4:	681b      	ldr	r3, [r3, #0]
    bbb6:	f103 030e 	add.w	r3, r3, #14
    bbba:	7a5b      	ldrb	r3, [r3, #9]
    bbbc:	2b06      	cmp	r3, #6
    bbbe:	f000 8151 	beq.w	be64 <uip_process+0x760>
		}
	#endif /* UIP_UDP */

	#if !UIP_CONF_IPV6
		/* ICMPv4 processing code follows. */
		if( BUF->proto != UIP_PROTO_ICMP )
    bbc2:	f240 6370 	movw	r3, #1648	; 0x670
    bbc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bbca:	681b      	ldr	r3, [r3, #0]
    bbcc:	f103 030e 	add.w	r3, r3, #14
    bbd0:	7a5b      	ldrb	r3, [r3, #9]
    bbd2:	2b01      	cmp	r3, #1
    bbd4:	d01b      	beq.n	bc0e <uip_process+0x50a>
		{
			/* We only allow ICMP packets from here. */
			UIP_STAT( ++uip_stat.ip.drop );
    bbd6:	f64c 4360 	movw	r3, #52320	; 0xcc60
    bbda:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bbde:	88db      	ldrh	r3, [r3, #6]
    bbe0:	f103 0301 	add.w	r3, r3, #1
    bbe4:	b29a      	uxth	r2, r3
    bbe6:	f64c 4360 	movw	r3, #52320	; 0xcc60
    bbea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bbee:	80da      	strh	r2, [r3, #6]
			UIP_STAT( ++uip_stat.ip.protoerr );
    bbf0:	f64c 4360 	movw	r3, #52320	; 0xcc60
    bbf4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bbf8:	8a5b      	ldrh	r3, [r3, #18]
    bbfa:	f103 0301 	add.w	r3, r3, #1
    bbfe:	b29a      	uxth	r2, r3
    bc00:	f64c 4360 	movw	r3, #52320	; 0xcc60
    bc04:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bc08:	825a      	strh	r2, [r3, #18]
			UIP_LOG( "ip: neither tcp nor icmp." );
			goto drop;
    bc0a:	f001 be3f 	b.w	d88c <uip_process+0x2188>

		#if UIP_PINGADDRCONF
			icmp_input :
		#endif /* UIP_PINGADDRCONF */

		UIP_STAT( ++uip_stat.icmp.recv );
    bc0e:	f64c 4360 	movw	r3, #52320	; 0xcc60
    bc12:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bc16:	8a9b      	ldrh	r3, [r3, #20]
    bc18:	f103 0301 	add.w	r3, r3, #1
    bc1c:	b29a      	uxth	r2, r3
    bc1e:	f64c 4360 	movw	r3, #52320	; 0xcc60
    bc22:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bc26:	829a      	strh	r2, [r3, #20]

		/* ICMP echo (i.e., ping) processing. This is simple, we only change
		 the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
		 checksum before we return the packet. */
		if( ICMPBUF->type != ICMP_ECHO )
    bc28:	f240 6370 	movw	r3, #1648	; 0x670
    bc2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bc30:	681b      	ldr	r3, [r3, #0]
    bc32:	f103 030e 	add.w	r3, r3, #14
    bc36:	7d1b      	ldrb	r3, [r3, #20]
    bc38:	2b08      	cmp	r3, #8
    bc3a:	d01b      	beq.n	bc74 <uip_process+0x570>
		{
			UIP_STAT( ++uip_stat.icmp.drop );
    bc3c:	f64c 4360 	movw	r3, #52320	; 0xcc60
    bc40:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bc44:	8b1b      	ldrh	r3, [r3, #24]
    bc46:	f103 0301 	add.w	r3, r3, #1
    bc4a:	b29a      	uxth	r2, r3
    bc4c:	f64c 4360 	movw	r3, #52320	; 0xcc60
    bc50:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bc54:	831a      	strh	r2, [r3, #24]
			UIP_STAT( ++uip_stat.icmp.typeerr );
    bc56:	f64c 4360 	movw	r3, #52320	; 0xcc60
    bc5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bc5e:	8b5b      	ldrh	r3, [r3, #26]
    bc60:	f103 0301 	add.w	r3, r3, #1
    bc64:	b29a      	uxth	r2, r3
    bc66:	f64c 4360 	movw	r3, #52320	; 0xcc60
    bc6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bc6e:	835a      	strh	r2, [r3, #26]
			UIP_LOG( "icmp: not icmp echo." );
			goto drop;
    bc70:	f001 be0c 	b.w	d88c <uip_process+0x2188>
			{
				uip_hostaddr = BUF->destipaddr;
			}
		#endif /* UIP_PINGADDRCONF */

		ICMPBUF->type = ICMP_ECHO_REPLY;
    bc74:	f240 6370 	movw	r3, #1648	; 0x670
    bc78:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bc7c:	681b      	ldr	r3, [r3, #0]
    bc7e:	f103 030e 	add.w	r3, r3, #14
    bc82:	f04f 0200 	mov.w	r2, #0
    bc86:	751a      	strb	r2, [r3, #20]

		if( ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8)) )
    bc88:	f240 6370 	movw	r3, #1648	; 0x670
    bc8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bc90:	681b      	ldr	r3, [r3, #0]
    bc92:	f103 030e 	add.w	r3, r3, #14
    bc96:	7d9a      	ldrb	r2, [r3, #22]
    bc98:	7ddb      	ldrb	r3, [r3, #23]
    bc9a:	ea4f 2303 	mov.w	r3, r3, lsl #8
    bc9e:	ea43 0302 	orr.w	r3, r3, r2
    bca2:	b29a      	uxth	r2, r3
    bca4:	f64f 73f6 	movw	r3, #65526	; 0xfff6
    bca8:	429a      	cmp	r2, r3
    bcaa:	d927      	bls.n	bcfc <uip_process+0x5f8>
		{
			ICMPBUF->icmpchksum += HTONS( ICMP_ECHO << 8 ) + 1;
    bcac:	f240 6370 	movw	r3, #1648	; 0x670
    bcb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bcb4:	681b      	ldr	r3, [r3, #0]
    bcb6:	f103 020e 	add.w	r2, r3, #14
    bcba:	f240 6370 	movw	r3, #1648	; 0x670
    bcbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bcc2:	681b      	ldr	r3, [r3, #0]
    bcc4:	f103 030e 	add.w	r3, r3, #14
    bcc8:	7d99      	ldrb	r1, [r3, #22]
    bcca:	7ddb      	ldrb	r3, [r3, #23]
    bccc:	ea4f 2303 	mov.w	r3, r3, lsl #8
    bcd0:	ea43 0301 	orr.w	r3, r3, r1
    bcd4:	b29b      	uxth	r3, r3
    bcd6:	f103 0309 	add.w	r3, r3, #9
    bcda:	b29b      	uxth	r3, r3
    bcdc:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    bce0:	f04f 0000 	mov.w	r0, #0
    bce4:	ea40 0101 	orr.w	r1, r0, r1
    bce8:	7591      	strb	r1, [r2, #22]
    bcea:	ea4f 2313 	mov.w	r3, r3, lsr #8
    bcee:	b29b      	uxth	r3, r3
    bcf0:	f04f 0100 	mov.w	r1, #0
    bcf4:	ea41 0303 	orr.w	r3, r1, r3
    bcf8:	75d3      	strb	r3, [r2, #23]
    bcfa:	e026      	b.n	bd4a <uip_process+0x646>
		}
		else
		{
			ICMPBUF->icmpchksum += HTONS( ICMP_ECHO << 8 );
    bcfc:	f240 6370 	movw	r3, #1648	; 0x670
    bd00:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bd04:	681b      	ldr	r3, [r3, #0]
    bd06:	f103 020e 	add.w	r2, r3, #14
    bd0a:	f240 6370 	movw	r3, #1648	; 0x670
    bd0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bd12:	681b      	ldr	r3, [r3, #0]
    bd14:	f103 030e 	add.w	r3, r3, #14
    bd18:	7d99      	ldrb	r1, [r3, #22]
    bd1a:	7ddb      	ldrb	r3, [r3, #23]
    bd1c:	ea4f 2303 	mov.w	r3, r3, lsl #8
    bd20:	ea43 0301 	orr.w	r3, r3, r1
    bd24:	b29b      	uxth	r3, r3
    bd26:	f103 0308 	add.w	r3, r3, #8
    bd2a:	b29b      	uxth	r3, r3
    bd2c:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    bd30:	f04f 0000 	mov.w	r0, #0
    bd34:	ea40 0101 	orr.w	r1, r0, r1
    bd38:	7591      	strb	r1, [r2, #22]
    bd3a:	ea4f 2313 	mov.w	r3, r3, lsr #8
    bd3e:	b29b      	uxth	r3, r3
    bd40:	f04f 0100 	mov.w	r1, #0
    bd44:	ea41 0303 	orr.w	r3, r1, r3
    bd48:	75d3      	strb	r3, [r2, #23]
		}

		/* Swap IP addresses. */
		uip_ipaddr_copy( &BUF->destipaddr, &BUF->srcipaddr );
    bd4a:	f240 6370 	movw	r3, #1648	; 0x670
    bd4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bd52:	681b      	ldr	r3, [r3, #0]
    bd54:	f103 020e 	add.w	r2, r3, #14
    bd58:	f240 6370 	movw	r3, #1648	; 0x670
    bd5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bd60:	681b      	ldr	r3, [r3, #0]
    bd62:	f103 030e 	add.w	r3, r3, #14
    bd66:	7b1b      	ldrb	r3, [r3, #12]
    bd68:	7413      	strb	r3, [r2, #16]
    bd6a:	f240 6370 	movw	r3, #1648	; 0x670
    bd6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bd72:	681b      	ldr	r3, [r3, #0]
    bd74:	f103 020e 	add.w	r2, r3, #14
    bd78:	f240 6370 	movw	r3, #1648	; 0x670
    bd7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bd80:	681b      	ldr	r3, [r3, #0]
    bd82:	f103 030e 	add.w	r3, r3, #14
    bd86:	7b5b      	ldrb	r3, [r3, #13]
    bd88:	7453      	strb	r3, [r2, #17]
    bd8a:	f240 6370 	movw	r3, #1648	; 0x670
    bd8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bd92:	681b      	ldr	r3, [r3, #0]
    bd94:	f103 020e 	add.w	r2, r3, #14
    bd98:	f240 6370 	movw	r3, #1648	; 0x670
    bd9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bda0:	681b      	ldr	r3, [r3, #0]
    bda2:	f103 030e 	add.w	r3, r3, #14
    bda6:	7b9b      	ldrb	r3, [r3, #14]
    bda8:	7493      	strb	r3, [r2, #18]
    bdaa:	f240 6370 	movw	r3, #1648	; 0x670
    bdae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bdb2:	681b      	ldr	r3, [r3, #0]
    bdb4:	f103 020e 	add.w	r2, r3, #14
    bdb8:	f240 6370 	movw	r3, #1648	; 0x670
    bdbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bdc0:	681b      	ldr	r3, [r3, #0]
    bdc2:	f103 030e 	add.w	r3, r3, #14
    bdc6:	7bdb      	ldrb	r3, [r3, #15]
    bdc8:	74d3      	strb	r3, [r2, #19]
		uip_ipaddr_copy( &BUF->srcipaddr, &uip_hostaddr );
    bdca:	f240 6370 	movw	r3, #1648	; 0x670
    bdce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bdd2:	681b      	ldr	r3, [r3, #0]
    bdd4:	f103 020e 	add.w	r2, r3, #14
    bdd8:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    bddc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bde0:	781b      	ldrb	r3, [r3, #0]
    bde2:	7313      	strb	r3, [r2, #12]
    bde4:	f240 6370 	movw	r3, #1648	; 0x670
    bde8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bdec:	681b      	ldr	r3, [r3, #0]
    bdee:	f103 020e 	add.w	r2, r3, #14
    bdf2:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    bdf6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bdfa:	785b      	ldrb	r3, [r3, #1]
    bdfc:	7353      	strb	r3, [r2, #13]
    bdfe:	f240 6370 	movw	r3, #1648	; 0x670
    be02:	f2c2 0300 	movt	r3, #8192	; 0x2000
    be06:	681b      	ldr	r3, [r3, #0]
    be08:	f103 020e 	add.w	r2, r3, #14
    be0c:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    be10:	f2c2 0300 	movt	r3, #8192	; 0x2000
    be14:	789b      	ldrb	r3, [r3, #2]
    be16:	7393      	strb	r3, [r2, #14]
    be18:	f240 6370 	movw	r3, #1648	; 0x670
    be1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    be20:	681b      	ldr	r3, [r3, #0]
    be22:	f103 020e 	add.w	r2, r3, #14
    be26:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    be2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    be2e:	78db      	ldrb	r3, [r3, #3]
    be30:	73d3      	strb	r3, [r2, #15]

		UIP_STAT( ++uip_stat.icmp.sent );
    be32:	f64c 4360 	movw	r3, #52320	; 0xcc60
    be36:	f2c2 0300 	movt	r3, #8192	; 0x2000
    be3a:	8adb      	ldrh	r3, [r3, #22]
    be3c:	f103 0301 	add.w	r3, r3, #1
    be40:	b29a      	uxth	r2, r3
    be42:	f64c 4360 	movw	r3, #52320	; 0xcc60
    be46:	f2c2 0300 	movt	r3, #8192	; 0x2000
    be4a:	82da      	strh	r2, [r3, #22]
		BUF->ttl = UIP_TTL;
    be4c:	f240 6370 	movw	r3, #1648	; 0x670
    be50:	f2c2 0300 	movt	r3, #8192	; 0x2000
    be54:	681b      	ldr	r3, [r3, #0]
    be56:	f103 030e 	add.w	r3, r3, #14
    be5a:	f04f 0240 	mov.w	r2, #64	; 0x40
    be5e:	721a      	strb	r2, [r3, #8]
		goto ip_send_nolen;
    be60:	f001 bc57 	b.w	d712 <uip_process+0x200e>
	#endif /* UIP_CONF_IPV6 */

	if( BUF->proto == UIP_PROTO_TCP )
	{
		/* Check for TCP packet. If so, proceed with TCP input processing. */
		goto tcp_input;
    be64:	bf00      	nop
	#endif /* UIP_UDP_CHECKSUMS */
		goto ip_send_nolen;
	#endif /* UIP_UDP */

	/* TCP input processing. */
	tcp_input : UIP_STAT( ++uip_stat.tcp.recv );
    be66:	f64c 4360 	movw	r3, #52320	; 0xcc60
    be6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    be6e:	8bdb      	ldrh	r3, [r3, #30]
    be70:	f103 0301 	add.w	r3, r3, #1
    be74:	b29a      	uxth	r2, r3
    be76:	f64c 4360 	movw	r3, #52320	; 0xcc60
    be7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    be7e:	83da      	strh	r2, [r3, #30]

	/* Start of TCP input header processing code. */
	if( uip_tcpchksum() != 0xffff )
    be80:	f7ff fa0e 	bl	b2a0 <uip_tcpchksum>
    be84:	4603      	mov	r3, r0
    be86:	461a      	mov	r2, r3
    be88:	f64f 73ff 	movw	r3, #65535	; 0xffff
    be8c:	429a      	cmp	r2, r3
    be8e:	d01b      	beq.n	bec8 <uip_process+0x7c4>
	{
		/* Compute and check the TCP checksum. */
		UIP_STAT( ++uip_stat.tcp.drop );
    be90:	f64c 4360 	movw	r3, #52320	; 0xcc60
    be94:	f2c2 0300 	movt	r3, #8192	; 0x2000
    be98:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
    be9a:	f103 0301 	add.w	r3, r3, #1
    be9e:	b29a      	uxth	r2, r3
    bea0:	f64c 4360 	movw	r3, #52320	; 0xcc60
    bea4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bea8:	845a      	strh	r2, [r3, #34]	; 0x22
		UIP_STAT( ++uip_stat.tcp.chkerr );
    beaa:	f64c 4360 	movw	r3, #52320	; 0xcc60
    beae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    beb2:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    beb4:	f103 0301 	add.w	r3, r3, #1
    beb8:	b29a      	uxth	r2, r3
    beba:	f64c 4360 	movw	r3, #52320	; 0xcc60
    bebe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bec2:	849a      	strh	r2, [r3, #36]	; 0x24
		UIP_LOG( "tcp: bad checksum." );
		goto drop;
    bec4:	f001 bce2 	b.w	d88c <uip_process+0x2188>
	}

	/* Demultiplex this segment. */

	/* First check any active connections. */
	for( uip_connr = &uip_conns[ 0 ]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr )
    bec8:	f64a 442c 	movw	r4, #44076	; 0xac2c
    becc:	f2c2 0400 	movt	r4, #8192	; 0x2000
    bed0:	e049      	b.n	bf66 <uip_process+0x862>
	{
		if
		(
			uip_connr->tcpstateflags != UIP_CLOSED &&
    bed2:	7e63      	ldrb	r3, [r4, #25]

	/* First check any active connections. */
	for( uip_connr = &uip_conns[ 0 ]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr )
	{
		if
		(
    bed4:	2b00      	cmp	r3, #0
    bed6:	d044      	beq.n	bf62 <uip_process+0x85e>
			uip_connr->tcpstateflags != UIP_CLOSED &&
			BUF->destport == uip_connr->lport &&
    bed8:	f240 6370 	movw	r3, #1648	; 0x670
    bedc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bee0:	681b      	ldr	r3, [r3, #0]
    bee2:	f103 030e 	add.w	r3, r3, #14
    bee6:	7d9a      	ldrb	r2, [r3, #22]
    bee8:	7ddb      	ldrb	r3, [r3, #23]
    beea:	ea4f 2303 	mov.w	r3, r3, lsl #8
    beee:	ea43 0302 	orr.w	r3, r3, r2
    bef2:	b29a      	uxth	r2, r3
    bef4:	88a3      	ldrh	r3, [r4, #4]

	/* First check any active connections. */
	for( uip_connr = &uip_conns[ 0 ]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr )
	{
		if
		(
    bef6:	429a      	cmp	r2, r3
    bef8:	d133      	bne.n	bf62 <uip_process+0x85e>
			uip_connr->tcpstateflags != UIP_CLOSED &&
			BUF->destport == uip_connr->lport &&
			BUF->srcport == uip_connr->rport &&
    befa:	f240 6370 	movw	r3, #1648	; 0x670
    befe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bf02:	681b      	ldr	r3, [r3, #0]
    bf04:	f103 030e 	add.w	r3, r3, #14
    bf08:	7d1a      	ldrb	r2, [r3, #20]
    bf0a:	7d5b      	ldrb	r3, [r3, #21]
    bf0c:	ea4f 2303 	mov.w	r3, r3, lsl #8
    bf10:	ea43 0302 	orr.w	r3, r3, r2
    bf14:	b29a      	uxth	r2, r3
    bf16:	88e3      	ldrh	r3, [r4, #6]

	/* First check any active connections. */
	for( uip_connr = &uip_conns[ 0 ]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr )
	{
		if
		(
    bf18:	429a      	cmp	r2, r3
    bf1a:	d122      	bne.n	bf62 <uip_process+0x85e>
			uip_connr->tcpstateflags != UIP_CLOSED &&
			BUF->destport == uip_connr->lport &&
			BUF->srcport == uip_connr->rport &&
			uip_ipaddr_cmp(&BUF->srcipaddr, &uip_connr->ripaddr)
    bf1c:	f240 6370 	movw	r3, #1648	; 0x670
    bf20:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bf24:	681b      	ldr	r3, [r3, #0]
    bf26:	f103 030e 	add.w	r3, r3, #14
    bf2a:	7b1a      	ldrb	r2, [r3, #12]
    bf2c:	7b5b      	ldrb	r3, [r3, #13]
    bf2e:	ea4f 2303 	mov.w	r3, r3, lsl #8
    bf32:	ea43 0302 	orr.w	r3, r3, r2
    bf36:	b29a      	uxth	r2, r3
    bf38:	8823      	ldrh	r3, [r4, #0]

	/* First check any active connections. */
	for( uip_connr = &uip_conns[ 0 ]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr )
	{
		if
		(
    bf3a:	429a      	cmp	r2, r3
    bf3c:	d111      	bne.n	bf62 <uip_process+0x85e>
			uip_connr->tcpstateflags != UIP_CLOSED &&
			BUF->destport == uip_connr->lport &&
			BUF->srcport == uip_connr->rport &&
			uip_ipaddr_cmp(&BUF->srcipaddr, &uip_connr->ripaddr)
    bf3e:	f240 6370 	movw	r3, #1648	; 0x670
    bf42:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bf46:	681b      	ldr	r3, [r3, #0]
    bf48:	f103 030e 	add.w	r3, r3, #14
    bf4c:	7b9a      	ldrb	r2, [r3, #14]
    bf4e:	7bdb      	ldrb	r3, [r3, #15]
    bf50:	ea4f 2303 	mov.w	r3, r3, lsl #8
    bf54:	ea43 0302 	orr.w	r3, r3, r2
    bf58:	b29a      	uxth	r2, r3
    bf5a:	8863      	ldrh	r3, [r4, #2]

	/* First check any active connections. */
	for( uip_connr = &uip_conns[ 0 ]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr )
	{
		if
		(
    bf5c:	429a      	cmp	r2, r3
    bf5e:	f000 84ad 	beq.w	c8bc <uip_process+0x11b8>
	}

	/* Demultiplex this segment. */

	/* First check any active connections. */
	for( uip_connr = &uip_conns[ 0 ]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr )
    bf62:	f104 04cc 	add.w	r4, r4, #204	; 0xcc
    bf66:	4b30      	ldr	r3, [pc, #192]	; (c028 <uip_process+0x924>)
    bf68:	429c      	cmp	r4, r3
    bf6a:	d9b2      	bls.n	bed2 <uip_process+0x7ce>

	/* If we didn't find and active connection that expected the packet,
	either this packet is an old duplicate, or this is a SYN packet
	destined for a connection in LISTEN. If the SYN flag isn't set,
	it is an old packet and we send a RST. */
	if( (BUF->flags & TCP_CTL) != TCP_SYN )
    bf6c:	f240 6370 	movw	r3, #1648	; 0x670
    bf70:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bf74:	681b      	ldr	r3, [r3, #0]
    bf76:	f103 030e 	add.w	r3, r3, #14
    bf7a:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    bf7e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    bf82:	2b02      	cmp	r3, #2
    bf84:	d152      	bne.n	c02c <uip_process+0x928>
	{
		goto reset;
	}

	tmp16 = BUF->destport;
    bf86:	f240 6370 	movw	r3, #1648	; 0x670
    bf8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bf8e:	681b      	ldr	r3, [r3, #0]
    bf90:	f103 030e 	add.w	r3, r3, #14
    bf94:	7d9a      	ldrb	r2, [r3, #22]
    bf96:	7ddb      	ldrb	r3, [r3, #23]
    bf98:	ea4f 2303 	mov.w	r3, r3, lsl #8
    bf9c:	ea43 0302 	orr.w	r3, r3, r2
    bfa0:	b29a      	uxth	r2, r3
    bfa2:	f642 7360 	movw	r3, #12128	; 0x2f60
    bfa6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bfaa:	801a      	strh	r2, [r3, #0]

	/* Next, check listening connections. */
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    bfac:	f642 735e 	movw	r3, #12126	; 0x2f5e
    bfb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bfb4:	f04f 0200 	mov.w	r2, #0
    bfb8:	701a      	strb	r2, [r3, #0]
    bfba:	e020      	b.n	bffe <uip_process+0x8fa>
	{
		if( tmp16 == uip_listenports[ c ] )
    bfbc:	f642 735e 	movw	r3, #12126	; 0x2f5e
    bfc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bfc4:	781b      	ldrb	r3, [r3, #0]
    bfc6:	461a      	mov	r2, r3
    bfc8:	f64c 430c 	movw	r3, #52236	; 0xcc0c
    bfcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bfd0:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
    bfd4:	f642 7360 	movw	r3, #12128	; 0x2f60
    bfd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bfdc:	881b      	ldrh	r3, [r3, #0]
    bfde:	429a      	cmp	r2, r3
    bfe0:	f000 8206 	beq.w	c3f0 <uip_process+0xcec>
	}

	tmp16 = BUF->destport;

	/* Next, check listening connections. */
	for( c = 0; c < UIP_LISTENPORTS; ++c )
    bfe4:	f642 735e 	movw	r3, #12126	; 0x2f5e
    bfe8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bfec:	781b      	ldrb	r3, [r3, #0]
    bfee:	f103 0301 	add.w	r3, r3, #1
    bff2:	b2da      	uxtb	r2, r3
    bff4:	f642 735e 	movw	r3, #12126	; 0x2f5e
    bff8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    bffc:	701a      	strb	r2, [r3, #0]
    bffe:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c002:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c006:	781b      	ldrb	r3, [r3, #0]
    c008:	2b27      	cmp	r3, #39	; 0x27
    c00a:	d9d7      	bls.n	bfbc <uip_process+0x8b8>
			goto found_listen;
		}
	}

	/* No matching connection found, so we send a RST packet. */
	UIP_STAT( ++uip_stat.tcp.synrst );
    c00c:	f64c 4360 	movw	r3, #52320	; 0xcc60
    c010:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c014:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
    c016:	f103 0301 	add.w	r3, r3, #1
    c01a:	b29a      	uxth	r2, r3
    c01c:	f64c 4360 	movw	r3, #52320	; 0xcc60
    c020:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c024:	85da      	strh	r2, [r3, #46]	; 0x2e
    c026:	e002      	b.n	c02e <uip_process+0x92a>
    c028:	2000cb40 	.word	0x2000cb40
	either this packet is an old duplicate, or this is a SYN packet
	destined for a connection in LISTEN. If the SYN flag isn't set,
	it is an old packet and we send a RST. */
	if( (BUF->flags & TCP_CTL) != TCP_SYN )
	{
		goto reset;
    c02c:	bf00      	nop
	/* No matching connection found, so we send a RST packet. */
	UIP_STAT( ++uip_stat.tcp.synrst );

reset:
	/* We do not send resets in response to resets. */
	if( BUF->flags & TCP_RST )
    c02e:	f240 6370 	movw	r3, #1648	; 0x670
    c032:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c036:	681b      	ldr	r3, [r3, #0]
    c038:	f103 030e 	add.w	r3, r3, #14
    c03c:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    c040:	f003 0304 	and.w	r3, r3, #4
    c044:	2b00      	cmp	r3, #0
    c046:	f041 8410 	bne.w	d86a <uip_process+0x2166>
	{
		goto drop;
	}

	UIP_STAT( ++uip_stat.tcp.rst );
    c04a:	f64c 4360 	movw	r3, #52320	; 0xcc60
    c04e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c052:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    c054:	f103 0301 	add.w	r3, r3, #1
    c058:	b29a      	uxth	r2, r3
    c05a:	f64c 4360 	movw	r3, #52320	; 0xcc60
    c05e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c062:	851a      	strh	r2, [r3, #40]	; 0x28

	BUF->flags = TCP_RST | TCP_ACK;
    c064:	f240 6370 	movw	r3, #1648	; 0x670
    c068:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c06c:	681b      	ldr	r3, [r3, #0]
    c06e:	f103 030e 	add.w	r3, r3, #14
    c072:	f04f 0214 	mov.w	r2, #20
    c076:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
	uip_len = UIP_IPTCPH_LEN;
    c07a:	f64a 4314 	movw	r3, #44052	; 0xac14
    c07e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c082:	f04f 0228 	mov.w	r2, #40	; 0x28
    c086:	801a      	strh	r2, [r3, #0]
	BUF->tcpoffset = 5 << 4;
    c088:	f240 6370 	movw	r3, #1648	; 0x670
    c08c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c090:	681b      	ldr	r3, [r3, #0]
    c092:	f103 030e 	add.w	r3, r3, #14
    c096:	f04f 0250 	mov.w	r2, #80	; 0x50
    c09a:	f883 2020 	strb.w	r2, [r3, #32]

	/* Flip the seqno and ackno fields in the TCP header. */
	c = BUF->seqno[ 3 ];
    c09e:	f240 6370 	movw	r3, #1648	; 0x670
    c0a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c0a6:	681b      	ldr	r3, [r3, #0]
    c0a8:	f103 030e 	add.w	r3, r3, #14
    c0ac:	7eda      	ldrb	r2, [r3, #27]
    c0ae:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c0b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c0b6:	701a      	strb	r2, [r3, #0]
	BUF->seqno[ 3 ] = BUF->ackno[ 3 ];
    c0b8:	f240 6370 	movw	r3, #1648	; 0x670
    c0bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c0c0:	681b      	ldr	r3, [r3, #0]
    c0c2:	f103 020e 	add.w	r2, r3, #14
    c0c6:	f240 6370 	movw	r3, #1648	; 0x670
    c0ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c0ce:	681b      	ldr	r3, [r3, #0]
    c0d0:	f103 030e 	add.w	r3, r3, #14
    c0d4:	7fdb      	ldrb	r3, [r3, #31]
    c0d6:	76d3      	strb	r3, [r2, #27]
	BUF->ackno[ 3 ] = c;
    c0d8:	f240 6370 	movw	r3, #1648	; 0x670
    c0dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c0e0:	681b      	ldr	r3, [r3, #0]
    c0e2:	f103 020e 	add.w	r2, r3, #14
    c0e6:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c0ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c0ee:	781b      	ldrb	r3, [r3, #0]
    c0f0:	77d3      	strb	r3, [r2, #31]

	c = BUF->seqno[ 2 ];
    c0f2:	f240 6370 	movw	r3, #1648	; 0x670
    c0f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c0fa:	681b      	ldr	r3, [r3, #0]
    c0fc:	f103 030e 	add.w	r3, r3, #14
    c100:	7e9a      	ldrb	r2, [r3, #26]
    c102:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c106:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c10a:	701a      	strb	r2, [r3, #0]
	BUF->seqno[ 2 ] = BUF->ackno[ 2 ];
    c10c:	f240 6370 	movw	r3, #1648	; 0x670
    c110:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c114:	681b      	ldr	r3, [r3, #0]
    c116:	f103 020e 	add.w	r2, r3, #14
    c11a:	f240 6370 	movw	r3, #1648	; 0x670
    c11e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c122:	681b      	ldr	r3, [r3, #0]
    c124:	f103 030e 	add.w	r3, r3, #14
    c128:	7f9b      	ldrb	r3, [r3, #30]
    c12a:	7693      	strb	r3, [r2, #26]
	BUF->ackno[ 2 ] = c;
    c12c:	f240 6370 	movw	r3, #1648	; 0x670
    c130:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c134:	681b      	ldr	r3, [r3, #0]
    c136:	f103 020e 	add.w	r2, r3, #14
    c13a:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c13e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c142:	781b      	ldrb	r3, [r3, #0]
    c144:	7793      	strb	r3, [r2, #30]

	c = BUF->seqno[ 1 ];
    c146:	f240 6370 	movw	r3, #1648	; 0x670
    c14a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c14e:	681b      	ldr	r3, [r3, #0]
    c150:	f103 030e 	add.w	r3, r3, #14
    c154:	7e5a      	ldrb	r2, [r3, #25]
    c156:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c15a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c15e:	701a      	strb	r2, [r3, #0]
	BUF->seqno[ 1 ] = BUF->ackno[ 1 ];
    c160:	f240 6370 	movw	r3, #1648	; 0x670
    c164:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c168:	681b      	ldr	r3, [r3, #0]
    c16a:	f103 020e 	add.w	r2, r3, #14
    c16e:	f240 6370 	movw	r3, #1648	; 0x670
    c172:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c176:	681b      	ldr	r3, [r3, #0]
    c178:	f103 030e 	add.w	r3, r3, #14
    c17c:	7f5b      	ldrb	r3, [r3, #29]
    c17e:	7653      	strb	r3, [r2, #25]
	BUF->ackno[ 1 ] = c;
    c180:	f240 6370 	movw	r3, #1648	; 0x670
    c184:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c188:	681b      	ldr	r3, [r3, #0]
    c18a:	f103 020e 	add.w	r2, r3, #14
    c18e:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c192:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c196:	781b      	ldrb	r3, [r3, #0]
    c198:	7753      	strb	r3, [r2, #29]

	c = BUF->seqno[ 0 ];
    c19a:	f240 6370 	movw	r3, #1648	; 0x670
    c19e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c1a2:	681b      	ldr	r3, [r3, #0]
    c1a4:	f103 030e 	add.w	r3, r3, #14
    c1a8:	7e1a      	ldrb	r2, [r3, #24]
    c1aa:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c1ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c1b2:	701a      	strb	r2, [r3, #0]
	BUF->seqno[ 0 ] = BUF->ackno[ 0 ];
    c1b4:	f240 6370 	movw	r3, #1648	; 0x670
    c1b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c1bc:	681b      	ldr	r3, [r3, #0]
    c1be:	f103 020e 	add.w	r2, r3, #14
    c1c2:	f240 6370 	movw	r3, #1648	; 0x670
    c1c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c1ca:	681b      	ldr	r3, [r3, #0]
    c1cc:	f103 030e 	add.w	r3, r3, #14
    c1d0:	7f1b      	ldrb	r3, [r3, #28]
    c1d2:	7613      	strb	r3, [r2, #24]
	BUF->ackno[ 0 ] = c;
    c1d4:	f240 6370 	movw	r3, #1648	; 0x670
    c1d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c1dc:	681b      	ldr	r3, [r3, #0]
    c1de:	f103 020e 	add.w	r2, r3, #14
    c1e2:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c1e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c1ea:	781b      	ldrb	r3, [r3, #0]
    c1ec:	7713      	strb	r3, [r2, #28]

	/* We also have to increase the sequence number we are
	acknowledging. If the least significant byte overflowed, we need
	to propagate the carry to the other bytes as well. */
	if( ++BUF->ackno[ 3 ] == 0 )
    c1ee:	f240 6370 	movw	r3, #1648	; 0x670
    c1f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c1f6:	681b      	ldr	r3, [r3, #0]
    c1f8:	f103 030e 	add.w	r3, r3, #14
    c1fc:	7fda      	ldrb	r2, [r3, #31]
    c1fe:	f102 0201 	add.w	r2, r2, #1
    c202:	b2d2      	uxtb	r2, r2
    c204:	77da      	strb	r2, [r3, #31]
    c206:	7fdb      	ldrb	r3, [r3, #31]
    c208:	2b00      	cmp	r3, #0
    c20a:	d129      	bne.n	c260 <uip_process+0xb5c>
	{
		if( ++BUF->ackno[ 2 ] == 0 )
    c20c:	f240 6370 	movw	r3, #1648	; 0x670
    c210:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c214:	681b      	ldr	r3, [r3, #0]
    c216:	f103 030e 	add.w	r3, r3, #14
    c21a:	7f9a      	ldrb	r2, [r3, #30]
    c21c:	f102 0201 	add.w	r2, r2, #1
    c220:	b2d2      	uxtb	r2, r2
    c222:	779a      	strb	r2, [r3, #30]
    c224:	7f9b      	ldrb	r3, [r3, #30]
    c226:	2b00      	cmp	r3, #0
    c228:	d11a      	bne.n	c260 <uip_process+0xb5c>
		{
			if( ++BUF->ackno[ 1 ] == 0 )
    c22a:	f240 6370 	movw	r3, #1648	; 0x670
    c22e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c232:	681b      	ldr	r3, [r3, #0]
    c234:	f103 030e 	add.w	r3, r3, #14
    c238:	7f5a      	ldrb	r2, [r3, #29]
    c23a:	f102 0201 	add.w	r2, r2, #1
    c23e:	b2d2      	uxtb	r2, r2
    c240:	775a      	strb	r2, [r3, #29]
    c242:	7f5b      	ldrb	r3, [r3, #29]
    c244:	2b00      	cmp	r3, #0
    c246:	d10b      	bne.n	c260 <uip_process+0xb5c>
			{
				++BUF->ackno[ 0 ];
    c248:	f240 6370 	movw	r3, #1648	; 0x670
    c24c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c250:	681b      	ldr	r3, [r3, #0]
    c252:	f103 030e 	add.w	r3, r3, #14
    c256:	7f1a      	ldrb	r2, [r3, #28]
    c258:	f102 0201 	add.w	r2, r2, #1
    c25c:	b2d2      	uxtb	r2, r2
    c25e:	771a      	strb	r2, [r3, #28]
			}
		}
	}

	/* Swap port numbers. */
	tmp16 = BUF->srcport;
    c260:	f240 6370 	movw	r3, #1648	; 0x670
    c264:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c268:	681b      	ldr	r3, [r3, #0]
    c26a:	f103 030e 	add.w	r3, r3, #14
    c26e:	7d1a      	ldrb	r2, [r3, #20]
    c270:	7d5b      	ldrb	r3, [r3, #21]
    c272:	ea4f 2303 	mov.w	r3, r3, lsl #8
    c276:	ea43 0302 	orr.w	r3, r3, r2
    c27a:	b29a      	uxth	r2, r3
    c27c:	f642 7360 	movw	r3, #12128	; 0x2f60
    c280:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c284:	801a      	strh	r2, [r3, #0]
	BUF->srcport = BUF->destport;
    c286:	f240 6370 	movw	r3, #1648	; 0x670
    c28a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c28e:	681b      	ldr	r3, [r3, #0]
    c290:	f103 020e 	add.w	r2, r3, #14
    c294:	f240 6370 	movw	r3, #1648	; 0x670
    c298:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c29c:	681b      	ldr	r3, [r3, #0]
    c29e:	f103 030e 	add.w	r3, r3, #14
    c2a2:	7d99      	ldrb	r1, [r3, #22]
    c2a4:	7ddb      	ldrb	r3, [r3, #23]
    c2a6:	ea4f 2303 	mov.w	r3, r3, lsl #8
    c2aa:	ea43 0301 	orr.w	r3, r3, r1
    c2ae:	b29b      	uxth	r3, r3
    c2b0:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    c2b4:	f04f 0000 	mov.w	r0, #0
    c2b8:	ea40 0101 	orr.w	r1, r0, r1
    c2bc:	7511      	strb	r1, [r2, #20]
    c2be:	ea4f 2313 	mov.w	r3, r3, lsr #8
    c2c2:	b29b      	uxth	r3, r3
    c2c4:	f04f 0100 	mov.w	r1, #0
    c2c8:	ea41 0303 	orr.w	r3, r1, r3
    c2cc:	7553      	strb	r3, [r2, #21]
	BUF->destport = tmp16;
    c2ce:	f240 6370 	movw	r3, #1648	; 0x670
    c2d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c2d6:	681b      	ldr	r3, [r3, #0]
    c2d8:	f103 020e 	add.w	r2, r3, #14
    c2dc:	f642 7360 	movw	r3, #12128	; 0x2f60
    c2e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c2e4:	881b      	ldrh	r3, [r3, #0]
    c2e6:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    c2ea:	f04f 0000 	mov.w	r0, #0
    c2ee:	ea40 0101 	orr.w	r1, r0, r1
    c2f2:	7591      	strb	r1, [r2, #22]
    c2f4:	ea4f 2313 	mov.w	r3, r3, lsr #8
    c2f8:	b29b      	uxth	r3, r3
    c2fa:	f04f 0100 	mov.w	r1, #0
    c2fe:	ea41 0303 	orr.w	r3, r1, r3
    c302:	75d3      	strb	r3, [r2, #23]

	/* Swap IP addresses. */
	uip_ipaddr_copy( &BUF->destipaddr, &BUF->srcipaddr );
    c304:	f240 6370 	movw	r3, #1648	; 0x670
    c308:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c30c:	681b      	ldr	r3, [r3, #0]
    c30e:	f103 020e 	add.w	r2, r3, #14
    c312:	f240 6370 	movw	r3, #1648	; 0x670
    c316:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c31a:	681b      	ldr	r3, [r3, #0]
    c31c:	f103 030e 	add.w	r3, r3, #14
    c320:	7b1b      	ldrb	r3, [r3, #12]
    c322:	7413      	strb	r3, [r2, #16]
    c324:	f240 6370 	movw	r3, #1648	; 0x670
    c328:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c32c:	681b      	ldr	r3, [r3, #0]
    c32e:	f103 020e 	add.w	r2, r3, #14
    c332:	f240 6370 	movw	r3, #1648	; 0x670
    c336:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c33a:	681b      	ldr	r3, [r3, #0]
    c33c:	f103 030e 	add.w	r3, r3, #14
    c340:	7b5b      	ldrb	r3, [r3, #13]
    c342:	7453      	strb	r3, [r2, #17]
    c344:	f240 6370 	movw	r3, #1648	; 0x670
    c348:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c34c:	681b      	ldr	r3, [r3, #0]
    c34e:	f103 020e 	add.w	r2, r3, #14
    c352:	f240 6370 	movw	r3, #1648	; 0x670
    c356:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c35a:	681b      	ldr	r3, [r3, #0]
    c35c:	f103 030e 	add.w	r3, r3, #14
    c360:	7b9b      	ldrb	r3, [r3, #14]
    c362:	7493      	strb	r3, [r2, #18]
    c364:	f240 6370 	movw	r3, #1648	; 0x670
    c368:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c36c:	681b      	ldr	r3, [r3, #0]
    c36e:	f103 020e 	add.w	r2, r3, #14
    c372:	f240 6370 	movw	r3, #1648	; 0x670
    c376:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c37a:	681b      	ldr	r3, [r3, #0]
    c37c:	f103 030e 	add.w	r3, r3, #14
    c380:	7bdb      	ldrb	r3, [r3, #15]
    c382:	74d3      	strb	r3, [r2, #19]
	uip_ipaddr_copy( &BUF->srcipaddr, &uip_hostaddr );
    c384:	f240 6370 	movw	r3, #1648	; 0x670
    c388:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c38c:	681b      	ldr	r3, [r3, #0]
    c38e:	f103 020e 	add.w	r2, r3, #14
    c392:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    c396:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c39a:	781b      	ldrb	r3, [r3, #0]
    c39c:	7313      	strb	r3, [r2, #12]
    c39e:	f240 6370 	movw	r3, #1648	; 0x670
    c3a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c3a6:	681b      	ldr	r3, [r3, #0]
    c3a8:	f103 020e 	add.w	r2, r3, #14
    c3ac:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    c3b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c3b4:	785b      	ldrb	r3, [r3, #1]
    c3b6:	7353      	strb	r3, [r2, #13]
    c3b8:	f240 6370 	movw	r3, #1648	; 0x670
    c3bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c3c0:	681b      	ldr	r3, [r3, #0]
    c3c2:	f103 020e 	add.w	r2, r3, #14
    c3c6:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    c3ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c3ce:	789b      	ldrb	r3, [r3, #2]
    c3d0:	7393      	strb	r3, [r2, #14]
    c3d2:	f240 6370 	movw	r3, #1648	; 0x670
    c3d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c3da:	681b      	ldr	r3, [r3, #0]
    c3dc:	f103 020e 	add.w	r2, r3, #14
    c3e0:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    c3e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c3e8:	78db      	ldrb	r3, [r3, #3]
    c3ea:	73d3      	strb	r3, [r2, #15]

	/* And send out the RST packet! */
	goto tcp_send_noconn;
    c3ec:	f001 b925 	b.w	d63a <uip_process+0x1f36>
	/* Next, check listening connections. */
	for( c = 0; c < UIP_LISTENPORTS; ++c )
	{
		if( tmp16 == uip_listenports[ c ] )
		{
			goto found_listen;
    c3f0:	bf00      	nop
	connections are kept in the same table as used connections, but
	unused ones have the tcpstate set to CLOSED. Also, connections in
	TIME_WAIT are kept track of and we'll use the oldest one if no
	CLOSED connections are found. Thanks to Eddie C. Dost for a very
	nice algorithm for the TIME_WAIT search. */
	uip_connr = 0;
    c3f2:	f04f 0400 	mov.w	r4, #0
	for( c = 0; c < UIP_CONNS; ++c )
    c3f6:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c3fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c3fe:	f04f 0200 	mov.w	r2, #0
    c402:	701a      	strb	r2, [r3, #0]
    c404:	e06a      	b.n	c4dc <uip_process+0xdd8>
	{
		if( uip_conns[ c ].tcpstateflags == UIP_CLOSED )
    c406:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c40a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c40e:	781b      	ldrb	r3, [r3, #0]
    c410:	461a      	mov	r2, r3
    c412:	f64a 432c 	movw	r3, #44076	; 0xac2c
    c416:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c41a:	f04f 01cc 	mov.w	r1, #204	; 0xcc
    c41e:	fb01 f202 	mul.w	r2, r1, r2
    c422:	4413      	add	r3, r2
    c424:	f103 0318 	add.w	r3, r3, #24
    c428:	785b      	ldrb	r3, [r3, #1]
    c42a:	2b00      	cmp	r3, #0
    c42c:	d10f      	bne.n	c44e <uip_process+0xd4a>
		{
			uip_connr = &uip_conns[ c ];
    c42e:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c432:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c436:	781b      	ldrb	r3, [r3, #0]
    c438:	f04f 02cc 	mov.w	r2, #204	; 0xcc
    c43c:	fb02 f203 	mul.w	r2, r2, r3
    c440:	f64a 432c 	movw	r3, #44076	; 0xac2c
    c444:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c448:	eb02 0403 	add.w	r4, r2, r3
			break;
    c44c:	e04d      	b.n	c4ea <uip_process+0xde6>
		}

		if( uip_conns[ c ].tcpstateflags == UIP_TIME_WAIT )
    c44e:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c452:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c456:	781b      	ldrb	r3, [r3, #0]
    c458:	461a      	mov	r2, r3
    c45a:	f64a 432c 	movw	r3, #44076	; 0xac2c
    c45e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c462:	f04f 01cc 	mov.w	r1, #204	; 0xcc
    c466:	fb01 f202 	mul.w	r2, r1, r2
    c46a:	4413      	add	r3, r2
    c46c:	f103 0318 	add.w	r3, r3, #24
    c470:	785b      	ldrb	r3, [r3, #1]
    c472:	2b07      	cmp	r3, #7
    c474:	d125      	bne.n	c4c2 <uip_process+0xdbe>
		{
			if( uip_connr == 0 || uip_conns[ c ].timer > uip_connr->timer )
    c476:	2c00      	cmp	r4, #0
    c478:	d014      	beq.n	c4a4 <uip_process+0xda0>
    c47a:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c47e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c482:	781b      	ldrb	r3, [r3, #0]
    c484:	461a      	mov	r2, r3
    c486:	f64a 432c 	movw	r3, #44076	; 0xac2c
    c48a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c48e:	f04f 01cc 	mov.w	r1, #204	; 0xcc
    c492:	fb01 f202 	mul.w	r2, r1, r2
    c496:	4413      	add	r3, r2
    c498:	f103 0318 	add.w	r3, r3, #24
    c49c:	789a      	ldrb	r2, [r3, #2]
    c49e:	7ea3      	ldrb	r3, [r4, #26]
    c4a0:	429a      	cmp	r2, r3
    c4a2:	d90e      	bls.n	c4c2 <uip_process+0xdbe>
			{
				uip_connr = &uip_conns[ c ];
    c4a4:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c4a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c4ac:	781b      	ldrb	r3, [r3, #0]
    c4ae:	f04f 02cc 	mov.w	r2, #204	; 0xcc
    c4b2:	fb02 f203 	mul.w	r2, r2, r3
    c4b6:	f64a 432c 	movw	r3, #44076	; 0xac2c
    c4ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c4be:	eb02 0403 	add.w	r4, r2, r3
	unused ones have the tcpstate set to CLOSED. Also, connections in
	TIME_WAIT are kept track of and we'll use the oldest one if no
	CLOSED connections are found. Thanks to Eddie C. Dost for a very
	nice algorithm for the TIME_WAIT search. */
	uip_connr = 0;
	for( c = 0; c < UIP_CONNS; ++c )
    c4c2:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c4c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c4ca:	781b      	ldrb	r3, [r3, #0]
    c4cc:	f103 0301 	add.w	r3, r3, #1
    c4d0:	b2da      	uxtb	r2, r3
    c4d2:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c4d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c4da:	701a      	strb	r2, [r3, #0]
    c4dc:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c4e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c4e4:	781b      	ldrb	r3, [r3, #0]
    c4e6:	2b27      	cmp	r3, #39	; 0x27
    c4e8:	d98d      	bls.n	c406 <uip_process+0xd02>
				uip_connr = &uip_conns[ c ];
			}
		}
	}

	if( uip_connr == 0 )
    c4ea:	2c00      	cmp	r4, #0
    c4ec:	d10e      	bne.n	c50c <uip_process+0xe08>
	{
		/* All connections are used already, we drop packet and hope that
		the remote end will retransmit the packet at a time when we
		have more spare connections. */
		UIP_STAT( ++uip_stat.tcp.syndrop );
    c4ee:	f64c 4360 	movw	r3, #52320	; 0xcc60
    c4f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c4f6:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
    c4f8:	f103 0301 	add.w	r3, r3, #1
    c4fc:	b29a      	uxth	r2, r3
    c4fe:	f64c 4360 	movw	r3, #52320	; 0xcc60
    c502:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c506:	859a      	strh	r2, [r3, #44]	; 0x2c
		UIP_LOG( "tcp: found no unused connections." );
		goto drop;
    c508:	f001 b9c0 	b.w	d88c <uip_process+0x2188>
	}

	uip_conn = uip_connr;
    c50c:	f64a 4328 	movw	r3, #44072	; 0xac28
    c510:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c514:	601c      	str	r4, [r3, #0]

	/* Fill in the necessary fields for the new connection. */
	uip_connr->rto = uip_connr->timer = UIP_RTO;
    c516:	f04f 0303 	mov.w	r3, #3
    c51a:	76a3      	strb	r3, [r4, #26]
    c51c:	7ea3      	ldrb	r3, [r4, #26]
    c51e:	7623      	strb	r3, [r4, #24]
	uip_connr->sa = 0;
    c520:	f04f 0300 	mov.w	r3, #0
    c524:	75a3      	strb	r3, [r4, #22]
	uip_connr->sv = 4;
    c526:	f04f 0304 	mov.w	r3, #4
    c52a:	75e3      	strb	r3, [r4, #23]
	uip_connr->nrtx = 0;
    c52c:	f04f 0300 	mov.w	r3, #0
    c530:	76e3      	strb	r3, [r4, #27]
	uip_connr->lport = BUF->destport;
    c532:	f240 6370 	movw	r3, #1648	; 0x670
    c536:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c53a:	681b      	ldr	r3, [r3, #0]
    c53c:	f103 030e 	add.w	r3, r3, #14
    c540:	7d9a      	ldrb	r2, [r3, #22]
    c542:	7ddb      	ldrb	r3, [r3, #23]
    c544:	ea4f 2303 	mov.w	r3, r3, lsl #8
    c548:	ea43 0302 	orr.w	r3, r3, r2
    c54c:	b29b      	uxth	r3, r3
    c54e:	80a3      	strh	r3, [r4, #4]
	uip_connr->rport = BUF->srcport;
    c550:	f240 6370 	movw	r3, #1648	; 0x670
    c554:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c558:	681b      	ldr	r3, [r3, #0]
    c55a:	f103 030e 	add.w	r3, r3, #14
    c55e:	7d1a      	ldrb	r2, [r3, #20]
    c560:	7d5b      	ldrb	r3, [r3, #21]
    c562:	ea4f 2303 	mov.w	r3, r3, lsl #8
    c566:	ea43 0302 	orr.w	r3, r3, r2
    c56a:	b29b      	uxth	r3, r3
    c56c:	80e3      	strh	r3, [r4, #6]
	uip_ipaddr_copy( &uip_connr->ripaddr, &BUF->srcipaddr );
    c56e:	f240 6370 	movw	r3, #1648	; 0x670
    c572:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c576:	681b      	ldr	r3, [r3, #0]
    c578:	f103 030e 	add.w	r3, r3, #14
    c57c:	7b1b      	ldrb	r3, [r3, #12]
    c57e:	7023      	strb	r3, [r4, #0]
    c580:	f240 6370 	movw	r3, #1648	; 0x670
    c584:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c588:	681b      	ldr	r3, [r3, #0]
    c58a:	f103 030e 	add.w	r3, r3, #14
    c58e:	7b5b      	ldrb	r3, [r3, #13]
    c590:	7063      	strb	r3, [r4, #1]
    c592:	f240 6370 	movw	r3, #1648	; 0x670
    c596:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c59a:	681b      	ldr	r3, [r3, #0]
    c59c:	f103 030e 	add.w	r3, r3, #14
    c5a0:	7b9b      	ldrb	r3, [r3, #14]
    c5a2:	70a3      	strb	r3, [r4, #2]
    c5a4:	f240 6370 	movw	r3, #1648	; 0x670
    c5a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c5ac:	681b      	ldr	r3, [r3, #0]
    c5ae:	f103 030e 	add.w	r3, r3, #14
    c5b2:	7bdb      	ldrb	r3, [r3, #15]
    c5b4:	70e3      	strb	r3, [r4, #3]
	uip_connr->tcpstateflags = UIP_SYN_RCVD;
    c5b6:	f04f 0301 	mov.w	r3, #1
    c5ba:	7663      	strb	r3, [r4, #25]

	uip_connr->snd_nxt[ 0 ] = iss[ 0 ];
    c5bc:	f642 7358 	movw	r3, #12120	; 0x2f58
    c5c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c5c4:	781b      	ldrb	r3, [r3, #0]
    c5c6:	7323      	strb	r3, [r4, #12]
	uip_connr->snd_nxt[ 1 ] = iss[ 1 ];
    c5c8:	f642 7358 	movw	r3, #12120	; 0x2f58
    c5cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c5d0:	785b      	ldrb	r3, [r3, #1]
    c5d2:	7363      	strb	r3, [r4, #13]
	uip_connr->snd_nxt[ 2 ] = iss[ 2 ];
    c5d4:	f642 7358 	movw	r3, #12120	; 0x2f58
    c5d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c5dc:	789b      	ldrb	r3, [r3, #2]
    c5de:	73a3      	strb	r3, [r4, #14]
	uip_connr->snd_nxt[ 3 ] = iss[ 3 ];
    c5e0:	f642 7358 	movw	r3, #12120	; 0x2f58
    c5e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c5e8:	78db      	ldrb	r3, [r3, #3]
    c5ea:	73e3      	strb	r3, [r4, #15]
	uip_connr->len = 1;
    c5ec:	f04f 0301 	mov.w	r3, #1
    c5f0:	8223      	strh	r3, [r4, #16]

	/* rcv_nxt should be the seqno from the incoming packet + 1. */
	uip_connr->rcv_nxt[ 3 ] = BUF->seqno[ 3 ];
    c5f2:	f240 6370 	movw	r3, #1648	; 0x670
    c5f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c5fa:	681b      	ldr	r3, [r3, #0]
    c5fc:	f103 030e 	add.w	r3, r3, #14
    c600:	7edb      	ldrb	r3, [r3, #27]
    c602:	72e3      	strb	r3, [r4, #11]
	uip_connr->rcv_nxt[ 2 ] = BUF->seqno[ 2 ];
    c604:	f240 6370 	movw	r3, #1648	; 0x670
    c608:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c60c:	681b      	ldr	r3, [r3, #0]
    c60e:	f103 030e 	add.w	r3, r3, #14
    c612:	7e9b      	ldrb	r3, [r3, #26]
    c614:	72a3      	strb	r3, [r4, #10]
	uip_connr->rcv_nxt[ 1 ] = BUF->seqno[ 1 ];
    c616:	f240 6370 	movw	r3, #1648	; 0x670
    c61a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c61e:	681b      	ldr	r3, [r3, #0]
    c620:	f103 030e 	add.w	r3, r3, #14
    c624:	7e5b      	ldrb	r3, [r3, #25]
    c626:	7263      	strb	r3, [r4, #9]
	uip_connr->rcv_nxt[ 0 ] = BUF->seqno[ 0 ];
    c628:	f240 6370 	movw	r3, #1648	; 0x670
    c62c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c630:	681b      	ldr	r3, [r3, #0]
    c632:	f103 030e 	add.w	r3, r3, #14
    c636:	7e1b      	ldrb	r3, [r3, #24]
    c638:	7223      	strb	r3, [r4, #8]
	uip_add_rcv_nxt( 1 );
    c63a:	f04f 0001 	mov.w	r0, #1
    c63e:	f7ff f81f 	bl	b680 <uip_add_rcv_nxt>

	/* Parse the TCP MSS option, if present. */
	if( (BUF->tcpoffset & 0xf0) > 0x50 )
    c642:	f240 6370 	movw	r3, #1648	; 0x670
    c646:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c64a:	681b      	ldr	r3, [r3, #0]
    c64c:	f103 030e 	add.w	r3, r3, #14
    c650:	f893 3020 	ldrb.w	r3, [r3, #32]
    c654:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    c658:	2b50      	cmp	r3, #80	; 0x50
    c65a:	f340 80cf 	ble.w	c7fc <uip_process+0x10f8>
	{
		for( c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2; )
    c65e:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c662:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c666:	f04f 0200 	mov.w	r2, #0
    c66a:	701a      	strb	r2, [r3, #0]
    c66c:	e0a7      	b.n	c7be <uip_process+0x10ba>
		{
			opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
    c66e:	f240 6370 	movw	r3, #1648	; 0x670
    c672:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c676:	681a      	ldr	r2, [r3, #0]
    c678:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c67c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c680:	781b      	ldrb	r3, [r3, #0]
    c682:	f103 0336 	add.w	r3, r3, #54	; 0x36
    c686:	4413      	add	r3, r2
    c688:	781a      	ldrb	r2, [r3, #0]
    c68a:	f642 735f 	movw	r3, #12127	; 0x2f5f
    c68e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c692:	701a      	strb	r2, [r3, #0]
			if( opt == TCP_OPT_END )
    c694:	f642 735f 	movw	r3, #12127	; 0x2f5f
    c698:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c69c:	781b      	ldrb	r3, [r3, #0]
    c69e:	2b00      	cmp	r3, #0
    c6a0:	f000 80a9 	beq.w	c7f6 <uip_process+0x10f2>
			{
				/* End of options. */
				break;
			}
			else if( opt == TCP_OPT_NOOP )
    c6a4:	f642 735f 	movw	r3, #12127	; 0x2f5f
    c6a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c6ac:	781b      	ldrb	r3, [r3, #0]
    c6ae:	2b01      	cmp	r3, #1
    c6b0:	d10d      	bne.n	c6ce <uip_process+0xfca>
			{
				++c;
    c6b2:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c6b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c6ba:	781b      	ldrb	r3, [r3, #0]
    c6bc:	f103 0301 	add.w	r3, r3, #1
    c6c0:	b2da      	uxtb	r2, r3
    c6c2:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c6c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c6ca:	701a      	strb	r2, [r3, #0]
    c6cc:	e077      	b.n	c7be <uip_process+0x10ba>

				/* NOP option. */
			}
			else if( opt == TCP_OPT_MSS && uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN )
    c6ce:	f642 735f 	movw	r3, #12127	; 0x2f5f
    c6d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c6d6:	781b      	ldrb	r3, [r3, #0]
    c6d8:	2b02      	cmp	r3, #2
    c6da:	d146      	bne.n	c76a <uip_process+0x1066>
    c6dc:	f240 6370 	movw	r3, #1648	; 0x670
    c6e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c6e4:	681a      	ldr	r2, [r3, #0]
    c6e6:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c6ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c6ee:	781b      	ldrb	r3, [r3, #0]
    c6f0:	f103 0337 	add.w	r3, r3, #55	; 0x37
    c6f4:	4413      	add	r3, r2
    c6f6:	781b      	ldrb	r3, [r3, #0]
    c6f8:	2b04      	cmp	r3, #4
    c6fa:	d136      	bne.n	c76a <uip_process+0x1066>
			{
				/* An MSS option with the right option length. */
				tmp16 = ( (u16_t) uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8 ) | ( u16_t ) uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
    c6fc:	f240 6370 	movw	r3, #1648	; 0x670
    c700:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c704:	681a      	ldr	r2, [r3, #0]
    c706:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c70a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c70e:	781b      	ldrb	r3, [r3, #0]
    c710:	f103 0338 	add.w	r3, r3, #56	; 0x38
    c714:	4413      	add	r3, r2
    c716:	781b      	ldrb	r3, [r3, #0]
    c718:	ea4f 2303 	mov.w	r3, r3, lsl #8
    c71c:	b29a      	uxth	r2, r3
    c71e:	f240 6370 	movw	r3, #1648	; 0x670
    c722:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c726:	6819      	ldr	r1, [r3, #0]
    c728:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c72c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c730:	781b      	ldrb	r3, [r3, #0]
    c732:	f103 0339 	add.w	r3, r3, #57	; 0x39
    c736:	440b      	add	r3, r1
    c738:	781b      	ldrb	r3, [r3, #0]
    c73a:	ea42 0303 	orr.w	r3, r2, r3
    c73e:	b29b      	uxth	r3, r3
    c740:	b29a      	uxth	r2, r3
    c742:	f642 7360 	movw	r3, #12128	; 0x2f60
    c746:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c74a:	801a      	strh	r2, [r3, #0]
				uip_connr->initialmss = uip_connr->mss = tmp16 > UIP_TCP_MSS ? UIP_TCP_MSS : tmp16;
    c74c:	f642 7360 	movw	r3, #12128	; 0x2f60
    c750:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c754:	881a      	ldrh	r2, [r3, #0]
    c756:	f240 5392 	movw	r3, #1426	; 0x592
    c75a:	429a      	cmp	r2, r3
    c75c:	bf38      	it	cc
    c75e:	4613      	movcc	r3, r2
    c760:	b29b      	uxth	r3, r3
    c762:	8263      	strh	r3, [r4, #18]
    c764:	8a63      	ldrh	r3, [r4, #18]
    c766:	82a3      	strh	r3, [r4, #20]

				/* And we are done processing options. */
				break;
    c768:	e048      	b.n	c7fc <uip_process+0x10f8>
			}
			else
			{
				/* All other options have a length field, so that we easily
				can skip past them. */
				if( uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0 )
    c76a:	f240 6370 	movw	r3, #1648	; 0x670
    c76e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c772:	681a      	ldr	r2, [r3, #0]
    c774:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c778:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c77c:	781b      	ldrb	r3, [r3, #0]
    c77e:	f103 0337 	add.w	r3, r3, #55	; 0x37
    c782:	4413      	add	r3, r2
    c784:	781b      	ldrb	r3, [r3, #0]
    c786:	2b00      	cmp	r3, #0
    c788:	d037      	beq.n	c7fa <uip_process+0x10f6>
					/* If the length field is zero, the options are malformed
					and we don't process them further. */
					break;
				}

				c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    c78a:	f240 6370 	movw	r3, #1648	; 0x670
    c78e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c792:	681a      	ldr	r2, [r3, #0]
    c794:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c798:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c79c:	781b      	ldrb	r3, [r3, #0]
    c79e:	f103 0337 	add.w	r3, r3, #55	; 0x37
    c7a2:	4413      	add	r3, r2
    c7a4:	781a      	ldrb	r2, [r3, #0]
    c7a6:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c7aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c7ae:	781b      	ldrb	r3, [r3, #0]
    c7b0:	4413      	add	r3, r2
    c7b2:	b2da      	uxtb	r2, r3
    c7b4:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c7b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c7bc:	701a      	strb	r2, [r3, #0]
	uip_add_rcv_nxt( 1 );

	/* Parse the TCP MSS option, if present. */
	if( (BUF->tcpoffset & 0xf0) > 0x50 )
	{
		for( c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2; )
    c7be:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c7c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c7c6:	781b      	ldrb	r3, [r3, #0]
    c7c8:	461a      	mov	r2, r3
    c7ca:	f240 6370 	movw	r3, #1648	; 0x670
    c7ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c7d2:	681b      	ldr	r3, [r3, #0]
    c7d4:	f103 030e 	add.w	r3, r3, #14
    c7d8:	f893 3020 	ldrb.w	r3, [r3, #32]
    c7dc:	ea4f 1313 	mov.w	r3, r3, lsr #4
    c7e0:	b2db      	uxtb	r3, r3
    c7e2:	f1a3 0305 	sub.w	r3, r3, #5
    c7e6:	ea4f 0383 	mov.w	r3, r3, lsl #2
    c7ea:	429a      	cmp	r2, r3
    c7ec:	f6ff af3f 	blt.w	c66e <uip_process+0xf6a>
    c7f0:	e004      	b.n	c7fc <uip_process+0x10f8>
					switch( uip_connr->tcpstateflags & UIP_TS_MASK )
					{
						case UIP_SYN_RCVD:
							/* In the SYN_RCVD state, we should retransmit our
			   				SYNACK. */
							goto tcp_send_synack;
    c7f2:	bf00      	nop
    c7f4:	e002      	b.n	c7fc <uip_process+0x10f8>
		{
			opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
			if( opt == TCP_OPT_END )
			{
				/* End of options. */
				break;
    c7f6:	bf00      	nop
    c7f8:	e000      	b.n	c7fc <uip_process+0x10f8>
				can skip past them. */
				if( uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0 )
				{
					/* If the length field is zero, the options are malformed
					and we don't process them further. */
					break;
    c7fa:	bf00      	nop
		}
	}

	/* Our response will be a SYNACK. */
	#if UIP_ACTIVE_OPEN
		tcp_send_synack : BUF->flags = TCP_ACK;
    c7fc:	f240 6370 	movw	r3, #1648	; 0x670
    c800:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c804:	681b      	ldr	r3, [r3, #0]
    c806:	f103 030e 	add.w	r3, r3, #14
    c80a:	f04f 0210 	mov.w	r2, #16
    c80e:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
tcp_send_syn:
		BUF->flags |= TCP_SYN;
    c812:	f240 6370 	movw	r3, #1648	; 0x670
    c816:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c81a:	681b      	ldr	r3, [r3, #0]
    c81c:	f103 020e 	add.w	r2, r3, #14
    c820:	f240 6370 	movw	r3, #1648	; 0x670
    c824:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c828:	681b      	ldr	r3, [r3, #0]
    c82a:	f103 030e 	add.w	r3, r3, #14
    c82e:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    c832:	f043 0302 	orr.w	r3, r3, #2
    c836:	b2db      	uxtb	r3, r3
    c838:	f882 3021 	strb.w	r3, [r2, #33]	; 0x21
		tcp_send_synack : BUF->flags = TCP_SYN | TCP_ACK;
	#endif /* UIP_ACTIVE_OPEN */

	/* We send out the TCP Maximum Segment Size option with our
	SYNACK. */
	BUF->optdata[ 0 ] = TCP_OPT_MSS;
    c83c:	f240 6370 	movw	r3, #1648	; 0x670
    c840:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c844:	681b      	ldr	r3, [r3, #0]
    c846:	f103 030e 	add.w	r3, r3, #14
    c84a:	f04f 0202 	mov.w	r2, #2
    c84e:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
	BUF->optdata[ 1 ] = TCP_OPT_MSS_LEN;
    c852:	f240 6370 	movw	r3, #1648	; 0x670
    c856:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c85a:	681b      	ldr	r3, [r3, #0]
    c85c:	f103 030e 	add.w	r3, r3, #14
    c860:	f04f 0204 	mov.w	r2, #4
    c864:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
	BUF->optdata[ 2 ] = ( UIP_TCP_MSS ) / 256;
    c868:	f240 6370 	movw	r3, #1648	; 0x670
    c86c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c870:	681b      	ldr	r3, [r3, #0]
    c872:	f103 030e 	add.w	r3, r3, #14
    c876:	f04f 0205 	mov.w	r2, #5
    c87a:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
	BUF->optdata[ 3 ] = ( UIP_TCP_MSS ) & 255;
    c87e:	f240 6370 	movw	r3, #1648	; 0x670
    c882:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c886:	681b      	ldr	r3, [r3, #0]
    c888:	f103 030e 	add.w	r3, r3, #14
    c88c:	f06f 026d 	mvn.w	r2, #109	; 0x6d
    c890:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
	uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
    c894:	f64a 4314 	movw	r3, #44052	; 0xac14
    c898:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c89c:	f04f 022c 	mov.w	r2, #44	; 0x2c
    c8a0:	801a      	strh	r2, [r3, #0]
	BUF->tcpoffset = ( (UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4 ) << 4;
    c8a2:	f240 6370 	movw	r3, #1648	; 0x670
    c8a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c8aa:	681b      	ldr	r3, [r3, #0]
    c8ac:	f103 030e 	add.w	r3, r3, #14
    c8b0:	f04f 0260 	mov.w	r2, #96	; 0x60
    c8b4:	f883 2020 	strb.w	r2, [r3, #32]
	goto tcp_send;
    c8b8:	f000 bdb5 	b.w	d426 <uip_process+0x1d22>
			BUF->destport == uip_connr->lport &&
			BUF->srcport == uip_connr->rport &&
			uip_ipaddr_cmp(&BUF->srcipaddr, &uip_connr->ripaddr)
		)
		{
			goto found;
    c8bc:	bf00      	nop
	BUF->tcpoffset = ( (UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4 ) << 4;
	goto tcp_send;

	/* This label will be jumped to if we found an active connection. */
found:
	uip_conn = uip_connr;
    c8be:	f64a 4328 	movw	r3, #44072	; 0xac28
    c8c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c8c6:	601c      	str	r4, [r3, #0]
	uip_flags = 0;
    c8c8:	f64a 4320 	movw	r3, #44064	; 0xac20
    c8cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c8d0:	f04f 0200 	mov.w	r2, #0
    c8d4:	701a      	strb	r2, [r3, #0]

	/* We do a very naive form of TCP reset processing; we just accept
	any RST and kill our connection. We should in fact check if the
	sequence number of this reset is wihtin our advertised window
	before we accept the reset. */
	if( BUF->flags & TCP_RST )
    c8d6:	f240 6370 	movw	r3, #1648	; 0x670
    c8da:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c8de:	681b      	ldr	r3, [r3, #0]
    c8e0:	f103 030e 	add.w	r3, r3, #14
    c8e4:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    c8e8:	f003 0304 	and.w	r3, r3, #4
    c8ec:	2b00      	cmp	r3, #0
    c8ee:	d00d      	beq.n	c90c <uip_process+0x1208>
	{
		uip_connr->tcpstateflags = UIP_CLOSED;
    c8f0:	f04f 0300 	mov.w	r3, #0
    c8f4:	7663      	strb	r3, [r4, #25]
		UIP_LOG( "tcp: got reset, aborting connection." );
		uip_flags = UIP_ABORT;
    c8f6:	f64a 4320 	movw	r3, #44064	; 0xac20
    c8fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c8fe:	f04f 0220 	mov.w	r2, #32
    c902:	701a      	strb	r2, [r3, #0]
		UIP_APPCALL();
    c904:	f002 fc04 	bl	f110 <httpd_appcall>
		goto drop;
    c908:	f000 bfc0 	b.w	d88c <uip_process+0x2188>
	}

	/* Calculate the length of the data, if the application has sent
	any data to us. */
	c = ( BUF->tcpoffset >> 4 ) << 2;
    c90c:	f240 6370 	movw	r3, #1648	; 0x670
    c910:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c914:	681b      	ldr	r3, [r3, #0]
    c916:	f103 030e 	add.w	r3, r3, #14
    c91a:	f893 3020 	ldrb.w	r3, [r3, #32]
    c91e:	ea4f 1313 	mov.w	r3, r3, lsr #4
    c922:	b2db      	uxtb	r3, r3
    c924:	ea4f 0383 	mov.w	r3, r3, lsl #2
    c928:	b2da      	uxtb	r2, r3
    c92a:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c92e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c932:	701a      	strb	r2, [r3, #0]

	/* uip_len will contain the length of the actual TCP data. This is
	calculated by subtracing the length of the TCP header (in
	c) and the length of the IP header (20 bytes). */
	uip_len = uip_len - c - UIP_IPH_LEN;
    c934:	f64a 4314 	movw	r3, #44052	; 0xac14
    c938:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c93c:	881a      	ldrh	r2, [r3, #0]
    c93e:	f642 735e 	movw	r3, #12126	; 0x2f5e
    c942:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c946:	781b      	ldrb	r3, [r3, #0]
    c948:	ebc3 0302 	rsb	r3, r3, r2
    c94c:	b29b      	uxth	r3, r3
    c94e:	f1a3 0314 	sub.w	r3, r3, #20
    c952:	b29a      	uxth	r2, r3
    c954:	f64a 4314 	movw	r3, #44052	; 0xac14
    c958:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c95c:	801a      	strh	r2, [r3, #0]

	/* First, check if the sequence number of the incoming packet is
	what we're expecting next. If not, we send out an ACK with the
	correct numbers in. */
	if( !(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) )
    c95e:	7e63      	ldrb	r3, [r4, #25]
    c960:	f003 030f 	and.w	r3, r3, #15
    c964:	2b02      	cmp	r3, #2
    c966:	d10c      	bne.n	c982 <uip_process+0x127e>
    c968:	f240 6370 	movw	r3, #1648	; 0x670
    c96c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c970:	681b      	ldr	r3, [r3, #0]
    c972:	f103 030e 	add.w	r3, r3, #14
    c976:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    c97a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    c97e:	2b12      	cmp	r3, #18
    c980:	d043      	beq.n	ca0a <uip_process+0x1306>
	{
		if
		(
			(uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
    c982:	f64a 4314 	movw	r3, #44052	; 0xac14
    c986:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c98a:	881b      	ldrh	r3, [r3, #0]
	what we're expecting next. If not, we send out an ACK with the
	correct numbers in. */
	if( !(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) )
	{
		if
		(
    c98c:	2b00      	cmp	r3, #0
    c98e:	d10c      	bne.n	c9aa <uip_process+0x12a6>
			(uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
    c990:	f240 6370 	movw	r3, #1648	; 0x670
    c994:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c998:	681b      	ldr	r3, [r3, #0]
    c99a:	f103 030e 	add.w	r3, r3, #14
    c99e:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    c9a2:	f003 0303 	and.w	r3, r3, #3
	what we're expecting next. If not, we send out an ACK with the
	correct numbers in. */
	if( !(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) )
	{
		if
		(
    c9a6:	2b00      	cmp	r3, #0
    c9a8:	d02f      	beq.n	ca0a <uip_process+0x1306>
			(uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
			(
				BUF->seqno[ 0 ] != uip_connr->rcv_nxt[ 0 ] ||
    c9aa:	f240 6370 	movw	r3, #1648	; 0x670
    c9ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c9b2:	681b      	ldr	r3, [r3, #0]
    c9b4:	f103 030e 	add.w	r3, r3, #14
    c9b8:	7e1a      	ldrb	r2, [r3, #24]
    c9ba:	7a23      	ldrb	r3, [r4, #8]
	what we're expecting next. If not, we send out an ACK with the
	correct numbers in. */
	if( !(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) )
	{
		if
		(
    c9bc:	429a      	cmp	r2, r3
    c9be:	f040 8515 	bne.w	d3ec <uip_process+0x1ce8>
			(uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
			(
				BUF->seqno[ 0 ] != uip_connr->rcv_nxt[ 0 ] ||
				BUF->seqno[ 1 ] != uip_connr->rcv_nxt[ 1 ] ||
    c9c2:	f240 6370 	movw	r3, #1648	; 0x670
    c9c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c9ca:	681b      	ldr	r3, [r3, #0]
    c9cc:	f103 030e 	add.w	r3, r3, #14
    c9d0:	7e5a      	ldrb	r2, [r3, #25]
    c9d2:	7a63      	ldrb	r3, [r4, #9]
	what we're expecting next. If not, we send out an ACK with the
	correct numbers in. */
	if( !(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) )
	{
		if
		(
    c9d4:	429a      	cmp	r2, r3
    c9d6:	f040 8509 	bne.w	d3ec <uip_process+0x1ce8>
			(uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
			(
				BUF->seqno[ 0 ] != uip_connr->rcv_nxt[ 0 ] ||
				BUF->seqno[ 1 ] != uip_connr->rcv_nxt[ 1 ] ||
				BUF->seqno[ 2 ] != uip_connr->rcv_nxt[ 2 ] ||
    c9da:	f240 6370 	movw	r3, #1648	; 0x670
    c9de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c9e2:	681b      	ldr	r3, [r3, #0]
    c9e4:	f103 030e 	add.w	r3, r3, #14
    c9e8:	7e9a      	ldrb	r2, [r3, #26]
    c9ea:	7aa3      	ldrb	r3, [r4, #10]
	what we're expecting next. If not, we send out an ACK with the
	correct numbers in. */
	if( !(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) )
	{
		if
		(
    c9ec:	429a      	cmp	r2, r3
    c9ee:	f040 84fd 	bne.w	d3ec <uip_process+0x1ce8>
			(uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
			(
				BUF->seqno[ 0 ] != uip_connr->rcv_nxt[ 0 ] ||
				BUF->seqno[ 1 ] != uip_connr->rcv_nxt[ 1 ] ||
				BUF->seqno[ 2 ] != uip_connr->rcv_nxt[ 2 ] ||
				BUF->seqno[ 3 ] != uip_connr->rcv_nxt[ 3 ]
    c9f2:	f240 6370 	movw	r3, #1648	; 0x670
    c9f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    c9fa:	681b      	ldr	r3, [r3, #0]
    c9fc:	f103 030e 	add.w	r3, r3, #14
    ca00:	7eda      	ldrb	r2, [r3, #27]
    ca02:	7ae3      	ldrb	r3, [r4, #11]
	what we're expecting next. If not, we send out an ACK with the
	correct numbers in. */
	if( !(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) )
	{
		if
		(
    ca04:	429a      	cmp	r2, r3
    ca06:	f040 84f1 	bne.w	d3ec <uip_process+0x1ce8>

	/* Next, check if the incoming segment acknowledges any outstanding
	data. If so, we update the sequence number, reset the length of
	the outstanding data, calculate RTT estimations, and reset the
	retransmission timer. */
	if( (BUF->flags & TCP_ACK) && uip_outstanding(uip_connr) )
    ca0a:	f240 6370 	movw	r3, #1648	; 0x670
    ca0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ca12:	681b      	ldr	r3, [r3, #0]
    ca14:	f103 030e 	add.w	r3, r3, #14
    ca18:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    ca1c:	f003 0310 	and.w	r3, r3, #16
    ca20:	2b00      	cmp	r3, #0
    ca22:	f000 80a1 	beq.w	cb68 <uip_process+0x1464>
    ca26:	8a23      	ldrh	r3, [r4, #16]
    ca28:	2b00      	cmp	r3, #0
    ca2a:	f000 809d 	beq.w	cb68 <uip_process+0x1464>
	{
		uip_add32( uip_connr->snd_nxt, uip_connr->len );
    ca2e:	f104 020c 	add.w	r2, r4, #12
    ca32:	8a23      	ldrh	r3, [r4, #16]
    ca34:	4610      	mov	r0, r2
    ca36:	4619      	mov	r1, r3
    ca38:	f7fe fab0 	bl	af9c <uip_add32>

		if
		(
			BUF->ackno[ 0 ] == uip_acc32[ 0 ] &&
    ca3c:	f240 6370 	movw	r3, #1648	; 0x670
    ca40:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ca44:	681b      	ldr	r3, [r3, #0]
    ca46:	f103 030e 	add.w	r3, r3, #14
    ca4a:	7f1a      	ldrb	r2, [r3, #28]
    ca4c:	f64a 431c 	movw	r3, #44060	; 0xac1c
    ca50:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ca54:	781b      	ldrb	r3, [r3, #0]
	if( (BUF->flags & TCP_ACK) && uip_outstanding(uip_connr) )
	{
		uip_add32( uip_connr->snd_nxt, uip_connr->len );

		if
		(
    ca56:	429a      	cmp	r2, r3
    ca58:	f040 8086 	bne.w	cb68 <uip_process+0x1464>
			BUF->ackno[ 0 ] == uip_acc32[ 0 ] &&
			BUF->ackno[ 1 ] == uip_acc32[ 1 ] &&
    ca5c:	f240 6370 	movw	r3, #1648	; 0x670
    ca60:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ca64:	681b      	ldr	r3, [r3, #0]
    ca66:	f103 030e 	add.w	r3, r3, #14
    ca6a:	7f5a      	ldrb	r2, [r3, #29]
    ca6c:	f64a 431c 	movw	r3, #44060	; 0xac1c
    ca70:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ca74:	785b      	ldrb	r3, [r3, #1]
	if( (BUF->flags & TCP_ACK) && uip_outstanding(uip_connr) )
	{
		uip_add32( uip_connr->snd_nxt, uip_connr->len );

		if
		(
    ca76:	429a      	cmp	r2, r3
    ca78:	d176      	bne.n	cb68 <uip_process+0x1464>
			BUF->ackno[ 0 ] == uip_acc32[ 0 ] &&
			BUF->ackno[ 1 ] == uip_acc32[ 1 ] &&
			BUF->ackno[ 2 ] == uip_acc32[ 2 ] &&
    ca7a:	f240 6370 	movw	r3, #1648	; 0x670
    ca7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ca82:	681b      	ldr	r3, [r3, #0]
    ca84:	f103 030e 	add.w	r3, r3, #14
    ca88:	7f9a      	ldrb	r2, [r3, #30]
    ca8a:	f64a 431c 	movw	r3, #44060	; 0xac1c
    ca8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ca92:	789b      	ldrb	r3, [r3, #2]
	if( (BUF->flags & TCP_ACK) && uip_outstanding(uip_connr) )
	{
		uip_add32( uip_connr->snd_nxt, uip_connr->len );

		if
		(
    ca94:	429a      	cmp	r2, r3
    ca96:	d167      	bne.n	cb68 <uip_process+0x1464>
			BUF->ackno[ 0 ] == uip_acc32[ 0 ] &&
			BUF->ackno[ 1 ] == uip_acc32[ 1 ] &&
			BUF->ackno[ 2 ] == uip_acc32[ 2 ] &&
			BUF->ackno[ 3 ] == uip_acc32[ 3 ]
    ca98:	f240 6370 	movw	r3, #1648	; 0x670
    ca9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    caa0:	681b      	ldr	r3, [r3, #0]
    caa2:	f103 030e 	add.w	r3, r3, #14
    caa6:	7fda      	ldrb	r2, [r3, #31]
    caa8:	f64a 431c 	movw	r3, #44060	; 0xac1c
    caac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cab0:	78db      	ldrb	r3, [r3, #3]
	if( (BUF->flags & TCP_ACK) && uip_outstanding(uip_connr) )
	{
		uip_add32( uip_connr->snd_nxt, uip_connr->len );

		if
		(
    cab2:	429a      	cmp	r2, r3
    cab4:	d158      	bne.n	cb68 <uip_process+0x1464>
			BUF->ackno[ 2 ] == uip_acc32[ 2 ] &&
			BUF->ackno[ 3 ] == uip_acc32[ 3 ]
		)
		{
			/* Update sequence number. */
			uip_connr->snd_nxt[ 0 ] = uip_acc32[ 0 ];
    cab6:	f64a 431c 	movw	r3, #44060	; 0xac1c
    caba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cabe:	781b      	ldrb	r3, [r3, #0]
    cac0:	7323      	strb	r3, [r4, #12]
			uip_connr->snd_nxt[ 1 ] = uip_acc32[ 1 ];
    cac2:	f64a 431c 	movw	r3, #44060	; 0xac1c
    cac6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    caca:	785b      	ldrb	r3, [r3, #1]
    cacc:	7363      	strb	r3, [r4, #13]
			uip_connr->snd_nxt[ 2 ] = uip_acc32[ 2 ];
    cace:	f64a 431c 	movw	r3, #44060	; 0xac1c
    cad2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cad6:	789b      	ldrb	r3, [r3, #2]
    cad8:	73a3      	strb	r3, [r4, #14]
			uip_connr->snd_nxt[ 3 ] = uip_acc32[ 3 ];
    cada:	f64a 431c 	movw	r3, #44060	; 0xac1c
    cade:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cae2:	78db      	ldrb	r3, [r3, #3]
    cae4:	73e3      	strb	r3, [r4, #15]

			/* Do RTT estimation, unless we have done retransmissions. */
			if( uip_connr->nrtx == 0 )
    cae6:	7ee3      	ldrb	r3, [r4, #27]
    cae8:	2b00      	cmp	r3, #0
    caea:	d131      	bne.n	cb50 <uip_process+0x144c>
			{
				signed char m;
				m = uip_connr->rto - uip_connr->timer;
    caec:	7e22      	ldrb	r2, [r4, #24]
    caee:	7ea3      	ldrb	r3, [r4, #26]
    caf0:	ebc3 0302 	rsb	r3, r3, r2
    caf4:	b2db      	uxtb	r3, r3
    caf6:	73fb      	strb	r3, [r7, #15]

				/* This is taken directly from VJs original code in his paper */
				m = m - ( uip_connr->sa >> 3 );
    caf8:	7bfa      	ldrb	r2, [r7, #15]
    cafa:	7da3      	ldrb	r3, [r4, #22]
    cafc:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    cb00:	b2db      	uxtb	r3, r3
    cb02:	ebc3 0302 	rsb	r3, r3, r2
    cb06:	b2db      	uxtb	r3, r3
    cb08:	73fb      	strb	r3, [r7, #15]
				uip_connr->sa += m;
    cb0a:	7da2      	ldrb	r2, [r4, #22]
    cb0c:	7bfb      	ldrb	r3, [r7, #15]
    cb0e:	4413      	add	r3, r2
    cb10:	b2db      	uxtb	r3, r3
    cb12:	75a3      	strb	r3, [r4, #22]
				if( m < 0 )
    cb14:	f997 300f 	ldrsb.w	r3, [r7, #15]
    cb18:	2b00      	cmp	r3, #0
    cb1a:	da03      	bge.n	cb24 <uip_process+0x1420>
				{
					m = -m;
    cb1c:	7bfb      	ldrb	r3, [r7, #15]
    cb1e:	f1c3 0300 	rsb	r3, r3, #0
    cb22:	73fb      	strb	r3, [r7, #15]
				}

				m = m - ( uip_connr->sv >> 2 );
    cb24:	7bfa      	ldrb	r2, [r7, #15]
    cb26:	7de3      	ldrb	r3, [r4, #23]
    cb28:	ea4f 0393 	mov.w	r3, r3, lsr #2
    cb2c:	b2db      	uxtb	r3, r3
    cb2e:	ebc3 0302 	rsb	r3, r3, r2
    cb32:	b2db      	uxtb	r3, r3
    cb34:	73fb      	strb	r3, [r7, #15]
				uip_connr->sv += m;
    cb36:	7de2      	ldrb	r2, [r4, #23]
    cb38:	7bfb      	ldrb	r3, [r7, #15]
    cb3a:	4413      	add	r3, r2
    cb3c:	b2db      	uxtb	r3, r3
    cb3e:	75e3      	strb	r3, [r4, #23]
				uip_connr->rto = ( uip_connr->sa >> 3 ) + uip_connr->sv;
    cb40:	7da3      	ldrb	r3, [r4, #22]
    cb42:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    cb46:	b2da      	uxtb	r2, r3
    cb48:	7de3      	ldrb	r3, [r4, #23]
    cb4a:	4413      	add	r3, r2
    cb4c:	b2db      	uxtb	r3, r3
    cb4e:	7623      	strb	r3, [r4, #24]
			}

			/* Set the acknowledged flag. */
			uip_flags = UIP_ACKDATA;
    cb50:	f64a 4320 	movw	r3, #44064	; 0xac20
    cb54:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cb58:	f04f 0201 	mov.w	r2, #1
    cb5c:	701a      	strb	r2, [r3, #0]

			/* Reset the retransmission timer. */
			uip_connr->timer = uip_connr->rto;
    cb5e:	7e23      	ldrb	r3, [r4, #24]
    cb60:	76a3      	strb	r3, [r4, #26]

			/* Reset length of outstanding data. */
			uip_connr->len = 0;
    cb62:	f04f 0300 	mov.w	r3, #0
    cb66:	8223      	strh	r3, [r4, #16]
		}
	}

	/* Do different things depending on in what state the connection is. */
	switch( uip_connr->tcpstateflags & UIP_TS_MASK )
    cb68:	7e63      	ldrb	r3, [r4, #25]
    cb6a:	f003 030f 	and.w	r3, r3, #15
    cb6e:	f103 33ff 	add.w	r3, r3, #4294967295
    cb72:	2b07      	cmp	r3, #7
    cb74:	f200 867b 	bhi.w	d86e <uip_process+0x216a>
    cb78:	a201      	add	r2, pc, #4	; (adr r2, cb80 <uip_process+0x147c>)
    cb7a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    cb7e:	bf00      	nop
    cb80:	0000cba1 	.word	0x0000cba1
    cb84:	0000cc1d 	.word	0x0000cc1d
    cb88:	0000ceb7 	.word	0x0000ceb7
    cb8c:	0000d29b 	.word	0x0000d29b
    cb90:	0000d353 	.word	0x0000d353
    cb94:	0000d3c7 	.word	0x0000d3c7
    cb98:	0000d3eb 	.word	0x0000d3eb
    cb9c:	0000d26b 	.word	0x0000d26b
		case UIP_SYN_RCVD:
			/* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
	   		we are waiting for an ACK that acknowledges the data we sent
	   		out the last time. Therefore, we want to have the UIP_ACKDATA
	   		flag set. If so, we enter the ESTABLISHED state. */
			if( uip_flags & UIP_ACKDATA )
    cba0:	f64a 4320 	movw	r3, #44064	; 0xac20
    cba4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cba8:	781b      	ldrb	r3, [r3, #0]
    cbaa:	f003 0301 	and.w	r3, r3, #1
    cbae:	b2db      	uxtb	r3, r3
    cbb0:	2b00      	cmp	r3, #0
    cbb2:	f000 865e 	beq.w	d872 <uip_process+0x216e>
			{
				uip_connr->tcpstateflags = UIP_ESTABLISHED;
    cbb6:	f04f 0303 	mov.w	r3, #3
    cbba:	7663      	strb	r3, [r4, #25]
				uip_flags = UIP_CONNECTED;
    cbbc:	f64a 4320 	movw	r3, #44064	; 0xac20
    cbc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cbc4:	f04f 0240 	mov.w	r2, #64	; 0x40
    cbc8:	701a      	strb	r2, [r3, #0]
				uip_connr->len = 0;
    cbca:	f04f 0300 	mov.w	r3, #0
    cbce:	8223      	strh	r3, [r4, #16]
				if( uip_len > 0 )
    cbd0:	f64a 4314 	movw	r3, #44052	; 0xac14
    cbd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cbd8:	881b      	ldrh	r3, [r3, #0]
    cbda:	2b00      	cmp	r3, #0
    cbdc:	d014      	beq.n	cc08 <uip_process+0x1504>
				{
					uip_flags |= UIP_NEWDATA;
    cbde:	f64a 4320 	movw	r3, #44064	; 0xac20
    cbe2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cbe6:	781b      	ldrb	r3, [r3, #0]
    cbe8:	f043 0302 	orr.w	r3, r3, #2
    cbec:	b2da      	uxtb	r2, r3
    cbee:	f64a 4320 	movw	r3, #44064	; 0xac20
    cbf2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cbf6:	701a      	strb	r2, [r3, #0]
					uip_add_rcv_nxt( uip_len );
    cbf8:	f64a 4314 	movw	r3, #44052	; 0xac14
    cbfc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cc00:	881b      	ldrh	r3, [r3, #0]
    cc02:	4618      	mov	r0, r3
    cc04:	f7fe fd3c 	bl	b680 <uip_add_rcv_nxt>
				}

				uip_slen = 0;
    cc08:	f64c 43a0 	movw	r3, #52384	; 0xcca0
    cc0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cc10:	f04f 0200 	mov.w	r2, #0
    cc14:	801a      	strh	r2, [r3, #0]
				UIP_APPCALL();
    cc16:	f002 fa7b 	bl	f110 <httpd_appcall>
				goto appsend;
    cc1a:	e267      	b.n	d0ec <uip_process+0x19e8>
			case UIP_SYN_SENT:
				/* In SYN_SENT, we wait for a SYNACK that is sent in response to
				our SYN. The rcv_nxt is set to sequence number in the SYNACK
				plus one, and we send an ACK. We move into the ESTABLISHED
				state. */
				if( (uip_flags & UIP_ACKDATA) && (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK) )
    cc1c:	f64a 4320 	movw	r3, #44064	; 0xac20
    cc20:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cc24:	781b      	ldrb	r3, [r3, #0]
    cc26:	f003 0301 	and.w	r3, r3, #1
    cc2a:	b2db      	uxtb	r3, r3
    cc2c:	2b00      	cmp	r3, #0
    cc2e:	f000 812f 	beq.w	ce90 <uip_process+0x178c>
    cc32:	f240 6370 	movw	r3, #1648	; 0x670
    cc36:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cc3a:	681b      	ldr	r3, [r3, #0]
    cc3c:	f103 030e 	add.w	r3, r3, #14
    cc40:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    cc44:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    cc48:	2b12      	cmp	r3, #18
    cc4a:	f040 8121 	bne.w	ce90 <uip_process+0x178c>
				{
					/* Parse the TCP MSS option, if present. */
					if( (BUF->tcpoffset & 0xf0) > 0x50 )
    cc4e:	f240 6370 	movw	r3, #1648	; 0x670
    cc52:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cc56:	681b      	ldr	r3, [r3, #0]
    cc58:	f103 030e 	add.w	r3, r3, #14
    cc5c:	f893 3020 	ldrb.w	r3, [r3, #32]
    cc60:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    cc64:	2b50      	cmp	r3, #80	; 0x50
    cc66:	f340 80cd 	ble.w	ce04 <uip_process+0x1700>
					{
						for( c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2; )
    cc6a:	f642 735e 	movw	r3, #12126	; 0x2f5e
    cc6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cc72:	f04f 0200 	mov.w	r2, #0
    cc76:	701a      	strb	r2, [r3, #0]
    cc78:	e0a7      	b.n	cdca <uip_process+0x16c6>
						{
							opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
    cc7a:	f240 6370 	movw	r3, #1648	; 0x670
    cc7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cc82:	681a      	ldr	r2, [r3, #0]
    cc84:	f642 735e 	movw	r3, #12126	; 0x2f5e
    cc88:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cc8c:	781b      	ldrb	r3, [r3, #0]
    cc8e:	f103 0336 	add.w	r3, r3, #54	; 0x36
    cc92:	4413      	add	r3, r2
    cc94:	781a      	ldrb	r2, [r3, #0]
    cc96:	f642 735f 	movw	r3, #12127	; 0x2f5f
    cc9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cc9e:	701a      	strb	r2, [r3, #0]
							if( opt == TCP_OPT_END )
    cca0:	f642 735f 	movw	r3, #12127	; 0x2f5f
    cca4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cca8:	781b      	ldrb	r3, [r3, #0]
    ccaa:	2b00      	cmp	r3, #0
    ccac:	f000 80a7 	beq.w	cdfe <uip_process+0x16fa>
							{
								/* End of options. */
								break;
							}
							else if( opt == TCP_OPT_NOOP )
    ccb0:	f642 735f 	movw	r3, #12127	; 0x2f5f
    ccb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ccb8:	781b      	ldrb	r3, [r3, #0]
    ccba:	2b01      	cmp	r3, #1
    ccbc:	d10d      	bne.n	ccda <uip_process+0x15d6>
							{
								++c;
    ccbe:	f642 735e 	movw	r3, #12126	; 0x2f5e
    ccc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ccc6:	781b      	ldrb	r3, [r3, #0]
    ccc8:	f103 0301 	add.w	r3, r3, #1
    cccc:	b2da      	uxtb	r2, r3
    ccce:	f642 735e 	movw	r3, #12126	; 0x2f5e
    ccd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ccd6:	701a      	strb	r2, [r3, #0]
    ccd8:	e077      	b.n	cdca <uip_process+0x16c6>

								/* NOP option. */
							}
							else if( opt == TCP_OPT_MSS && uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN )
    ccda:	f642 735f 	movw	r3, #12127	; 0x2f5f
    ccde:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cce2:	781b      	ldrb	r3, [r3, #0]
    cce4:	2b02      	cmp	r3, #2
    cce6:	d146      	bne.n	cd76 <uip_process+0x1672>
    cce8:	f240 6370 	movw	r3, #1648	; 0x670
    ccec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ccf0:	681a      	ldr	r2, [r3, #0]
    ccf2:	f642 735e 	movw	r3, #12126	; 0x2f5e
    ccf6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ccfa:	781b      	ldrb	r3, [r3, #0]
    ccfc:	f103 0337 	add.w	r3, r3, #55	; 0x37
    cd00:	4413      	add	r3, r2
    cd02:	781b      	ldrb	r3, [r3, #0]
    cd04:	2b04      	cmp	r3, #4
    cd06:	d136      	bne.n	cd76 <uip_process+0x1672>
							{
								/* An MSS option with the right option length. */
								tmp16 = ( uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8 ) | uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
    cd08:	f240 6370 	movw	r3, #1648	; 0x670
    cd0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cd10:	681a      	ldr	r2, [r3, #0]
    cd12:	f642 735e 	movw	r3, #12126	; 0x2f5e
    cd16:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cd1a:	781b      	ldrb	r3, [r3, #0]
    cd1c:	f103 0338 	add.w	r3, r3, #56	; 0x38
    cd20:	4413      	add	r3, r2
    cd22:	781b      	ldrb	r3, [r3, #0]
    cd24:	ea4f 2303 	mov.w	r3, r3, lsl #8
    cd28:	b29a      	uxth	r2, r3
    cd2a:	f240 6370 	movw	r3, #1648	; 0x670
    cd2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cd32:	6819      	ldr	r1, [r3, #0]
    cd34:	f642 735e 	movw	r3, #12126	; 0x2f5e
    cd38:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cd3c:	781b      	ldrb	r3, [r3, #0]
    cd3e:	f103 0339 	add.w	r3, r3, #57	; 0x39
    cd42:	440b      	add	r3, r1
    cd44:	781b      	ldrb	r3, [r3, #0]
    cd46:	ea42 0303 	orr.w	r3, r2, r3
    cd4a:	b29b      	uxth	r3, r3
    cd4c:	b29a      	uxth	r2, r3
    cd4e:	f642 7360 	movw	r3, #12128	; 0x2f60
    cd52:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cd56:	801a      	strh	r2, [r3, #0]
								uip_connr->initialmss = uip_connr->mss = tmp16 > UIP_TCP_MSS ? UIP_TCP_MSS : tmp16;
    cd58:	f642 7360 	movw	r3, #12128	; 0x2f60
    cd5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cd60:	881a      	ldrh	r2, [r3, #0]
    cd62:	f240 5392 	movw	r3, #1426	; 0x592
    cd66:	429a      	cmp	r2, r3
    cd68:	bf38      	it	cc
    cd6a:	4613      	movcc	r3, r2
    cd6c:	b29b      	uxth	r3, r3
    cd6e:	8263      	strh	r3, [r4, #18]
    cd70:	8a63      	ldrh	r3, [r4, #18]
    cd72:	82a3      	strh	r3, [r4, #20]

								/* And we are done processing options. */
								break;
    cd74:	e046      	b.n	ce04 <uip_process+0x1700>
							}
							else
							{
								/* All other options have a length field, so that we easily
								can skip past them. */
								if( uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0 )
    cd76:	f240 6370 	movw	r3, #1648	; 0x670
    cd7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cd7e:	681a      	ldr	r2, [r3, #0]
    cd80:	f642 735e 	movw	r3, #12126	; 0x2f5e
    cd84:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cd88:	781b      	ldrb	r3, [r3, #0]
    cd8a:	f103 0337 	add.w	r3, r3, #55	; 0x37
    cd8e:	4413      	add	r3, r2
    cd90:	781b      	ldrb	r3, [r3, #0]
    cd92:	2b00      	cmp	r3, #0
    cd94:	d035      	beq.n	ce02 <uip_process+0x16fe>
									/* If the length field is zero, the options are malformed
									and we don't process them further. */
									break;
								}

								c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    cd96:	f240 6370 	movw	r3, #1648	; 0x670
    cd9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cd9e:	681a      	ldr	r2, [r3, #0]
    cda0:	f642 735e 	movw	r3, #12126	; 0x2f5e
    cda4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cda8:	781b      	ldrb	r3, [r3, #0]
    cdaa:	f103 0337 	add.w	r3, r3, #55	; 0x37
    cdae:	4413      	add	r3, r2
    cdb0:	781a      	ldrb	r2, [r3, #0]
    cdb2:	f642 735e 	movw	r3, #12126	; 0x2f5e
    cdb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cdba:	781b      	ldrb	r3, [r3, #0]
    cdbc:	4413      	add	r3, r2
    cdbe:	b2da      	uxtb	r2, r3
    cdc0:	f642 735e 	movw	r3, #12126	; 0x2f5e
    cdc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cdc8:	701a      	strb	r2, [r3, #0]
				if( (uip_flags & UIP_ACKDATA) && (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK) )
				{
					/* Parse the TCP MSS option, if present. */
					if( (BUF->tcpoffset & 0xf0) > 0x50 )
					{
						for( c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2; )
    cdca:	f642 735e 	movw	r3, #12126	; 0x2f5e
    cdce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cdd2:	781b      	ldrb	r3, [r3, #0]
    cdd4:	461a      	mov	r2, r3
    cdd6:	f240 6370 	movw	r3, #1648	; 0x670
    cdda:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cdde:	681b      	ldr	r3, [r3, #0]
    cde0:	f103 030e 	add.w	r3, r3, #14
    cde4:	f893 3020 	ldrb.w	r3, [r3, #32]
    cde8:	ea4f 1313 	mov.w	r3, r3, lsr #4
    cdec:	b2db      	uxtb	r3, r3
    cdee:	f1a3 0305 	sub.w	r3, r3, #5
    cdf2:	ea4f 0383 	mov.w	r3, r3, lsl #2
    cdf6:	429a      	cmp	r2, r3
    cdf8:	f6ff af3f 	blt.w	cc7a <uip_process+0x1576>
    cdfc:	e002      	b.n	ce04 <uip_process+0x1700>
						{
							opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
							if( opt == TCP_OPT_END )
							{
								/* End of options. */
								break;
    cdfe:	bf00      	nop
    ce00:	e000      	b.n	ce04 <uip_process+0x1700>
								can skip past them. */
								if( uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0 )
								{
									/* If the length field is zero, the options are malformed
									and we don't process them further. */
									break;
    ce02:	bf00      	nop
								c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
							}
						}
					}

					uip_connr->tcpstateflags = UIP_ESTABLISHED;
    ce04:	f04f 0303 	mov.w	r3, #3
    ce08:	7663      	strb	r3, [r4, #25]
					uip_connr->rcv_nxt[ 0 ] = BUF->seqno[ 0 ];
    ce0a:	f240 6370 	movw	r3, #1648	; 0x670
    ce0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ce12:	681b      	ldr	r3, [r3, #0]
    ce14:	f103 030e 	add.w	r3, r3, #14
    ce18:	7e1b      	ldrb	r3, [r3, #24]
    ce1a:	7223      	strb	r3, [r4, #8]
					uip_connr->rcv_nxt[ 1 ] = BUF->seqno[ 1 ];
    ce1c:	f240 6370 	movw	r3, #1648	; 0x670
    ce20:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ce24:	681b      	ldr	r3, [r3, #0]
    ce26:	f103 030e 	add.w	r3, r3, #14
    ce2a:	7e5b      	ldrb	r3, [r3, #25]
    ce2c:	7263      	strb	r3, [r4, #9]
					uip_connr->rcv_nxt[ 2 ] = BUF->seqno[ 2 ];
    ce2e:	f240 6370 	movw	r3, #1648	; 0x670
    ce32:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ce36:	681b      	ldr	r3, [r3, #0]
    ce38:	f103 030e 	add.w	r3, r3, #14
    ce3c:	7e9b      	ldrb	r3, [r3, #26]
    ce3e:	72a3      	strb	r3, [r4, #10]
					uip_connr->rcv_nxt[ 3 ] = BUF->seqno[ 3 ];
    ce40:	f240 6370 	movw	r3, #1648	; 0x670
    ce44:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ce48:	681b      	ldr	r3, [r3, #0]
    ce4a:	f103 030e 	add.w	r3, r3, #14
    ce4e:	7edb      	ldrb	r3, [r3, #27]
    ce50:	72e3      	strb	r3, [r4, #11]
					uip_add_rcv_nxt( 1 );
    ce52:	f04f 0001 	mov.w	r0, #1
    ce56:	f7fe fc13 	bl	b680 <uip_add_rcv_nxt>
					uip_flags = UIP_CONNECTED | UIP_NEWDATA;
    ce5a:	f64a 4320 	movw	r3, #44064	; 0xac20
    ce5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ce62:	f04f 0242 	mov.w	r2, #66	; 0x42
    ce66:	701a      	strb	r2, [r3, #0]
					uip_connr->len = 0;
    ce68:	f04f 0300 	mov.w	r3, #0
    ce6c:	8223      	strh	r3, [r4, #16]
					uip_len = 0;
    ce6e:	f64a 4314 	movw	r3, #44052	; 0xac14
    ce72:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ce76:	f04f 0200 	mov.w	r2, #0
    ce7a:	801a      	strh	r2, [r3, #0]
					uip_slen = 0;
    ce7c:	f64c 43a0 	movw	r3, #52384	; 0xcca0
    ce80:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ce84:	f04f 0200 	mov.w	r2, #0
    ce88:	801a      	strh	r2, [r3, #0]
					UIP_APPCALL();
    ce8a:	f002 f941 	bl	f110 <httpd_appcall>
					goto appsend;
    ce8e:	e12d      	b.n	d0ec <uip_process+0x19e8>
				}

				/* Inform the application that the connection failed */
				uip_flags = UIP_ABORT;
    ce90:	f64a 4320 	movw	r3, #44064	; 0xac20
    ce94:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ce98:	f04f 0220 	mov.w	r2, #32
    ce9c:	701a      	strb	r2, [r3, #0]
				UIP_APPCALL();
    ce9e:	f002 f937 	bl	f110 <httpd_appcall>

				/* The connection is closed after we send the RST */
				uip_conn->tcpstateflags = UIP_CLOSED;
    cea2:	f64a 4328 	movw	r3, #44072	; 0xac28
    cea6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ceaa:	681b      	ldr	r3, [r3, #0]
    ceac:	f04f 0200 	mov.w	r2, #0
    ceb0:	765a      	strb	r2, [r3, #25]
				goto reset;
    ceb2:	f7ff b8bc 	b.w	c02e <uip_process+0x92a>

			If the incoming packet is a FIN, we should close the connection on
			this side as well, and we send out a FIN and enter the LAST_ACK
			state. We require that there is no outstanding data; otherwise the
			sequence numbers will be screwed up. */
			if( BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED) )
    ceb6:	f240 6370 	movw	r3, #1648	; 0x670
    ceba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cebe:	681b      	ldr	r3, [r3, #0]
    cec0:	f103 030e 	add.w	r3, r3, #14
    cec4:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    cec8:	f003 0301 	and.w	r3, r3, #1
    cecc:	b2db      	uxtb	r3, r3
    cece:	2b00      	cmp	r3, #0
    ced0:	d04d      	beq.n	cf6e <uip_process+0x186a>
    ced2:	7e63      	ldrb	r3, [r4, #25]
    ced4:	f003 0310 	and.w	r3, r3, #16
    ced8:	2b00      	cmp	r3, #0
    ceda:	d148      	bne.n	cf6e <uip_process+0x186a>
			{
				if( uip_outstanding(uip_connr) )
    cedc:	8a23      	ldrh	r3, [r4, #16]
    cede:	2b00      	cmp	r3, #0
    cee0:	f040 84c9 	bne.w	d876 <uip_process+0x2172>
				{
					goto drop;
				}

				uip_add_rcv_nxt( 1 + uip_len );
    cee4:	f64a 4314 	movw	r3, #44052	; 0xac14
    cee8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ceec:	881b      	ldrh	r3, [r3, #0]
    ceee:	f103 0301 	add.w	r3, r3, #1
    cef2:	b29b      	uxth	r3, r3
    cef4:	4618      	mov	r0, r3
    cef6:	f7fe fbc3 	bl	b680 <uip_add_rcv_nxt>
				uip_flags |= UIP_CLOSE;
    cefa:	f64a 4320 	movw	r3, #44064	; 0xac20
    cefe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cf02:	781b      	ldrb	r3, [r3, #0]
    cf04:	f043 0310 	orr.w	r3, r3, #16
    cf08:	b2da      	uxtb	r2, r3
    cf0a:	f64a 4320 	movw	r3, #44064	; 0xac20
    cf0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cf12:	701a      	strb	r2, [r3, #0]
				if( uip_len > 0 )
    cf14:	f64a 4314 	movw	r3, #44052	; 0xac14
    cf18:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cf1c:	881b      	ldrh	r3, [r3, #0]
    cf1e:	2b00      	cmp	r3, #0
    cf20:	d00c      	beq.n	cf3c <uip_process+0x1838>
				{
					uip_flags |= UIP_NEWDATA;
    cf22:	f64a 4320 	movw	r3, #44064	; 0xac20
    cf26:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cf2a:	781b      	ldrb	r3, [r3, #0]
    cf2c:	f043 0302 	orr.w	r3, r3, #2
    cf30:	b2da      	uxtb	r2, r3
    cf32:	f64a 4320 	movw	r3, #44064	; 0xac20
    cf36:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cf3a:	701a      	strb	r2, [r3, #0]
				}

				UIP_APPCALL();
    cf3c:	f002 f8e8 	bl	f110 <httpd_appcall>
				uip_connr->len = 1;
    cf40:	f04f 0301 	mov.w	r3, #1
    cf44:	8223      	strh	r3, [r4, #16]
				uip_connr->tcpstateflags = UIP_LAST_ACK;
    cf46:	f04f 0308 	mov.w	r3, #8
    cf4a:	7663      	strb	r3, [r4, #25]
				uip_connr->nrtx = 0;
    cf4c:	f04f 0300 	mov.w	r3, #0
    cf50:	76e3      	strb	r3, [r4, #27]
    cf52:	e000      	b.n	cf56 <uip_process+0x1852>

						case UIP_FIN_WAIT_1:
						case UIP_CLOSING:
						case UIP_LAST_ACK:
							/* In all these states we should retransmit a FINACK. */
							goto tcp_send_finack;
    cf54:	bf00      	nop
				UIP_APPCALL();
				uip_connr->len = 1;
				uip_connr->tcpstateflags = UIP_LAST_ACK;
				uip_connr->nrtx = 0;
	tcp_send_finack:
				BUF->flags = TCP_FIN | TCP_ACK;
    cf56:	f240 6370 	movw	r3, #1648	; 0x670
    cf5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cf5e:	681b      	ldr	r3, [r3, #0]
    cf60:	f103 030e 	add.w	r3, r3, #14
    cf64:	f04f 0211 	mov.w	r2, #17
    cf68:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
				goto tcp_send_nodata;
    cf6c:	e249      	b.n	d402 <uip_process+0x1cfe>
			}

			/* Check the URG flag. If this is set, the segment carries urgent
			data that we must pass to the application. */
			if( (BUF->flags & TCP_URG) != 0 )
    cf6e:	f240 6370 	movw	r3, #1648	; 0x670
    cf72:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cf76:	681b      	ldr	r3, [r3, #0]
    cf78:	f103 030e 	add.w	r3, r3, #14
    cf7c:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    cf80:	f003 0320 	and.w	r3, r3, #32
    cf84:	2b00      	cmp	r3, #0
    cf86:	d046      	beq.n	d016 <uip_process+0x1912>
					}
					else
					{
					uip_urglen = 0;
				#else /* UIP_URGDATA > 0 */
					uip_appdata = ( ( char * ) uip_appdata ) + ( (BUF->urgp[ 0 ] << 8) | BUF->urgp[ 1 ] );
    cf88:	f64a 4324 	movw	r3, #44068	; 0xac24
    cf8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cf90:	681a      	ldr	r2, [r3, #0]
    cf92:	f240 6370 	movw	r3, #1648	; 0x670
    cf96:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cf9a:	681b      	ldr	r3, [r3, #0]
    cf9c:	f103 030e 	add.w	r3, r3, #14
    cfa0:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
    cfa4:	ea4f 2103 	mov.w	r1, r3, lsl #8
    cfa8:	f240 6370 	movw	r3, #1648	; 0x670
    cfac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cfb0:	681b      	ldr	r3, [r3, #0]
    cfb2:	f103 030e 	add.w	r3, r3, #14
    cfb6:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
    cfba:	ea41 0303 	orr.w	r3, r1, r3
    cfbe:	441a      	add	r2, r3
    cfc0:	f64a 4324 	movw	r3, #44068	; 0xac24
    cfc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cfc8:	601a      	str	r2, [r3, #0]
					uip_len -= ( BUF->urgp[ 0 ] << 8 ) | BUF->urgp[ 1 ];
    cfca:	f64a 4314 	movw	r3, #44052	; 0xac14
    cfce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cfd2:	881a      	ldrh	r2, [r3, #0]
    cfd4:	f240 6370 	movw	r3, #1648	; 0x670
    cfd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cfdc:	681b      	ldr	r3, [r3, #0]
    cfde:	f103 030e 	add.w	r3, r3, #14
    cfe2:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
    cfe6:	ea4f 2303 	mov.w	r3, r3, lsl #8
    cfea:	b299      	uxth	r1, r3
    cfec:	f240 6370 	movw	r3, #1648	; 0x670
    cff0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cff4:	681b      	ldr	r3, [r3, #0]
    cff6:	f103 030e 	add.w	r3, r3, #14
    cffa:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
    cffe:	ea41 0303 	orr.w	r3, r1, r3
    d002:	b29b      	uxth	r3, r3
    d004:	b29b      	uxth	r3, r3
    d006:	ebc3 0302 	rsb	r3, r3, r2
    d00a:	b29a      	uxth	r2, r3
    d00c:	f64a 4314 	movw	r3, #44052	; 0xac14
    d010:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d014:	801a      	strh	r2, [r3, #0]
			/* If uip_len > 0 we have TCP data in the packet, and we flag this
			by setting the UIP_NEWDATA flag and update the sequence number
			we acknowledge. If the application has stopped the dataflow
			using uip_stop(), we must not accept any data packets from the
			remote host. */
			if( uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED) )
    d016:	f64a 4314 	movw	r3, #44052	; 0xac14
    d01a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d01e:	881b      	ldrh	r3, [r3, #0]
    d020:	2b00      	cmp	r3, #0
    d022:	d019      	beq.n	d058 <uip_process+0x1954>
    d024:	7e63      	ldrb	r3, [r4, #25]
    d026:	f003 0310 	and.w	r3, r3, #16
    d02a:	2b00      	cmp	r3, #0
    d02c:	d114      	bne.n	d058 <uip_process+0x1954>
			{
				uip_flags |= UIP_NEWDATA;
    d02e:	f64a 4320 	movw	r3, #44064	; 0xac20
    d032:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d036:	781b      	ldrb	r3, [r3, #0]
    d038:	f043 0302 	orr.w	r3, r3, #2
    d03c:	b2da      	uxtb	r2, r3
    d03e:	f64a 4320 	movw	r3, #44064	; 0xac20
    d042:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d046:	701a      	strb	r2, [r3, #0]
				uip_add_rcv_nxt( uip_len );
    d048:	f64a 4314 	movw	r3, #44052	; 0xac14
    d04c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d050:	881b      	ldrh	r3, [r3, #0]
    d052:	4618      	mov	r0, r3
    d054:	f7fe fb14 	bl	b680 <uip_add_rcv_nxt>
			the initial MSS so that the application will send an entire MSS
			of data. This data will not be acknowledged by the receiver,
			and the application will retransmit it. This is called the
			"persistent timer" and uses the retransmission mechanim.
			*/
			tmp16 = ( (u16_t) BUF->wnd[ 0 ] << 8 ) + ( u16_t ) BUF->wnd[ 1 ];
    d058:	f240 6370 	movw	r3, #1648	; 0x670
    d05c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d060:	681b      	ldr	r3, [r3, #0]
    d062:	f103 030e 	add.w	r3, r3, #14
    d066:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
    d06a:	ea4f 2303 	mov.w	r3, r3, lsl #8
    d06e:	b29a      	uxth	r2, r3
    d070:	f240 6370 	movw	r3, #1648	; 0x670
    d074:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d078:	681b      	ldr	r3, [r3, #0]
    d07a:	f103 030e 	add.w	r3, r3, #14
    d07e:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
    d082:	4413      	add	r3, r2
    d084:	b29a      	uxth	r2, r3
    d086:	f642 7360 	movw	r3, #12128	; 0x2f60
    d08a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d08e:	801a      	strh	r2, [r3, #0]
			if( tmp16 > uip_connr->initialmss || tmp16 == 0 )
    d090:	8aa2      	ldrh	r2, [r4, #20]
    d092:	f642 7360 	movw	r3, #12128	; 0x2f60
    d096:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d09a:	881b      	ldrh	r3, [r3, #0]
    d09c:	429a      	cmp	r2, r3
    d09e:	d306      	bcc.n	d0ae <uip_process+0x19aa>
    d0a0:	f642 7360 	movw	r3, #12128	; 0x2f60
    d0a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d0a8:	881b      	ldrh	r3, [r3, #0]
    d0aa:	2b00      	cmp	r3, #0
    d0ac:	d105      	bne.n	d0ba <uip_process+0x19b6>
			{
				tmp16 = uip_connr->initialmss;
    d0ae:	8aa2      	ldrh	r2, [r4, #20]
    d0b0:	f642 7360 	movw	r3, #12128	; 0x2f60
    d0b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d0b8:	801a      	strh	r2, [r3, #0]
			}

			uip_connr->mss = tmp16;
    d0ba:	f642 7360 	movw	r3, #12128	; 0x2f60
    d0be:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d0c2:	881b      	ldrh	r3, [r3, #0]
    d0c4:	8263      	strh	r3, [r4, #18]

			If the application wishes to send any data, this data should be
			put into the uip_appdata and the length of the data should be
			put into uip_len. If the application don't have any data to
			send, uip_len must be set to 0. */
			if( uip_flags & (UIP_NEWDATA | UIP_ACKDATA) )
    d0c6:	f64a 4320 	movw	r3, #44064	; 0xac20
    d0ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d0ce:	781b      	ldrb	r3, [r3, #0]
    d0d0:	f003 0303 	and.w	r3, r3, #3
    d0d4:	2b00      	cmp	r3, #0
    d0d6:	f000 83d0 	beq.w	d87a <uip_process+0x2176>
			{
				uip_slen = 0;
    d0da:	f64c 43a0 	movw	r3, #52384	; 0xcca0
    d0de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d0e2:	f04f 0200 	mov.w	r2, #0
    d0e6:	801a      	strh	r2, [r3, #0]
				UIP_APPCALL();
    d0e8:	f002 f812 	bl	f110 <httpd_appcall>

appsend:
				if( uip_flags & UIP_ABORT )
    d0ec:	f64a 4320 	movw	r3, #44064	; 0xac20
    d0f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d0f4:	781b      	ldrb	r3, [r3, #0]
    d0f6:	f003 0320 	and.w	r3, r3, #32
    d0fa:	2b00      	cmp	r3, #0
    d0fc:	d015      	beq.n	d12a <uip_process+0x1a26>
				{
					uip_slen = 0;
    d0fe:	f64c 43a0 	movw	r3, #52384	; 0xcca0
    d102:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d106:	f04f 0200 	mov.w	r2, #0
    d10a:	801a      	strh	r2, [r3, #0]
					uip_connr->tcpstateflags = UIP_CLOSED;
    d10c:	f04f 0300 	mov.w	r3, #0
    d110:	7663      	strb	r3, [r4, #25]
					BUF->flags = TCP_RST | TCP_ACK;
    d112:	f240 6370 	movw	r3, #1648	; 0x670
    d116:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d11a:	681b      	ldr	r3, [r3, #0]
    d11c:	f103 030e 	add.w	r3, r3, #14
    d120:	f04f 0214 	mov.w	r2, #20
    d124:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
					goto tcp_send_nodata;
    d128:	e16b      	b.n	d402 <uip_process+0x1cfe>
				}

				if( uip_flags & UIP_CLOSE )
    d12a:	f64a 4320 	movw	r3, #44064	; 0xac20
    d12e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d132:	781b      	ldrb	r3, [r3, #0]
    d134:	f003 0310 	and.w	r3, r3, #16
    d138:	2b00      	cmp	r3, #0
    d13a:	d01b      	beq.n	d174 <uip_process+0x1a70>
				{
					uip_slen = 0;
    d13c:	f64c 43a0 	movw	r3, #52384	; 0xcca0
    d140:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d144:	f04f 0200 	mov.w	r2, #0
    d148:	801a      	strh	r2, [r3, #0]
					uip_connr->len = 1;
    d14a:	f04f 0301 	mov.w	r3, #1
    d14e:	8223      	strh	r3, [r4, #16]
					uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
    d150:	f04f 0304 	mov.w	r3, #4
    d154:	7663      	strb	r3, [r4, #25]
					uip_connr->nrtx = 0;
    d156:	f04f 0300 	mov.w	r3, #0
    d15a:	76e3      	strb	r3, [r4, #27]
					BUF->flags = TCP_FIN | TCP_ACK;
    d15c:	f240 6370 	movw	r3, #1648	; 0x670
    d160:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d164:	681b      	ldr	r3, [r3, #0]
    d166:	f103 030e 	add.w	r3, r3, #14
    d16a:	f04f 0211 	mov.w	r2, #17
    d16e:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
					goto tcp_send_nodata;
    d172:	e146      	b.n	d402 <uip_process+0x1cfe>
				}

				/* If uip_slen > 0, the application has data to be sent. */
				if( uip_slen > 0 )
    d174:	f64c 43a0 	movw	r3, #52384	; 0xcca0
    d178:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d17c:	881b      	ldrh	r3, [r3, #0]
    d17e:	2b00      	cmp	r3, #0
    d180:	d02a      	beq.n	d1d8 <uip_process+0x1ad4>
				{
					/* If the connection has acknowledged data, the contents of
	   				the ->len variable should be discarded. */
					if( (uip_flags & UIP_ACKDATA) != 0 )
    d182:	f64a 4320 	movw	r3, #44064	; 0xac20
    d186:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d18a:	781b      	ldrb	r3, [r3, #0]
    d18c:	f003 0301 	and.w	r3, r3, #1
    d190:	b2db      	uxtb	r3, r3
    d192:	2b00      	cmp	r3, #0
    d194:	d002      	beq.n	d19c <uip_process+0x1a98>
					{
						uip_connr->len = 0;
    d196:	f04f 0300 	mov.w	r3, #0
    d19a:	8223      	strh	r3, [r4, #16]
					}

					/* If the ->len variable is non-zero the connection has
	   				already data in transit and cannot send anymore right
	   				now. */
					if( uip_connr->len == 0 )
    d19c:	8a23      	ldrh	r3, [r4, #16]
    d19e:	2b00      	cmp	r3, #0
    d1a0:	d114      	bne.n	d1cc <uip_process+0x1ac8>
					{
						/* The application cannot send more than what is allowed by
		 				the mss (the minumum of the MSS and the available
		 				window). */
						if( uip_slen > uip_connr->mss )
    d1a2:	8a62      	ldrh	r2, [r4, #18]
    d1a4:	f64c 43a0 	movw	r3, #52384	; 0xcca0
    d1a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d1ac:	881b      	ldrh	r3, [r3, #0]
    d1ae:	429a      	cmp	r2, r3
    d1b0:	d205      	bcs.n	d1be <uip_process+0x1aba>
						{
							uip_slen = uip_connr->mss;
    d1b2:	8a62      	ldrh	r2, [r4, #18]
    d1b4:	f64c 43a0 	movw	r3, #52384	; 0xcca0
    d1b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d1bc:	801a      	strh	r2, [r3, #0]
						}

						/* Remember how much data we send out now so that we know
		 				when everything has been acknowledged. */
						uip_connr->len = uip_slen;
    d1be:	f64c 43a0 	movw	r3, #52384	; 0xcca0
    d1c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d1c6:	881b      	ldrh	r3, [r3, #0]
    d1c8:	8223      	strh	r3, [r4, #16]
    d1ca:	e005      	b.n	d1d8 <uip_process+0x1ad4>
					else
					{
						/* If the application already had unacknowledged data, we
		 				make sure that the application does not send (i.e.,
		 				retransmit) out more than it previously sent out. */
						uip_slen = uip_connr->len;
    d1cc:	8a22      	ldrh	r2, [r4, #16]
    d1ce:	f64c 43a0 	movw	r3, #52384	; 0xcca0
    d1d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d1d6:	801a      	strh	r2, [r3, #0]
					}
				}

				uip_connr->nrtx = 0;
    d1d8:	f04f 0300 	mov.w	r3, #0
    d1dc:	76e3      	strb	r3, [r4, #27]
apprexmit:
				uip_appdata = uip_sappdata;
    d1de:	f64a 4318 	movw	r3, #44056	; 0xac18
    d1e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d1e6:	681a      	ldr	r2, [r3, #0]
    d1e8:	f64a 4324 	movw	r3, #44068	; 0xac24
    d1ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d1f0:	601a      	str	r2, [r3, #0]

				/* If the application has data to be sent, or if the incoming
		 		packet had new data in it, we must send out a packet. */
				if( uip_slen > 0 && uip_connr->len > 0 )
    d1f2:	f64c 43a0 	movw	r3, #52384	; 0xcca0
    d1f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d1fa:	881b      	ldrh	r3, [r3, #0]
    d1fc:	2b00      	cmp	r3, #0
    d1fe:	d017      	beq.n	d230 <uip_process+0x1b2c>
    d200:	8a23      	ldrh	r3, [r4, #16]
    d202:	2b00      	cmp	r3, #0
    d204:	d014      	beq.n	d230 <uip_process+0x1b2c>
				{
					/* Add the length of the IP and TCP headers. */
					uip_len = uip_connr->len + UIP_TCPIP_HLEN;
    d206:	8a23      	ldrh	r3, [r4, #16]
    d208:	f103 0328 	add.w	r3, r3, #40	; 0x28
    d20c:	b29a      	uxth	r2, r3
    d20e:	f64a 4314 	movw	r3, #44052	; 0xac14
    d212:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d216:	801a      	strh	r2, [r3, #0]

					/* We always set the ACK flag in response packets. */
					BUF->flags = TCP_ACK | TCP_PSH;
    d218:	f240 6370 	movw	r3, #1648	; 0x670
    d21c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d220:	681b      	ldr	r3, [r3, #0]
    d222:	f103 030e 	add.w	r3, r3, #14
    d226:	f04f 0218 	mov.w	r2, #24
    d22a:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

					/* Send the packet. */
					goto tcp_send_noopts;
    d22e:	e0ef      	b.n	d410 <uip_process+0x1d0c>
				}

				/* If there is no data to send, just send out a pure ACK if
				there is newdata. */
				if( uip_flags & UIP_NEWDATA )
    d230:	f64a 4320 	movw	r3, #44064	; 0xac20
    d234:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d238:	781b      	ldrb	r3, [r3, #0]
    d23a:	f003 0302 	and.w	r3, r3, #2
    d23e:	2b00      	cmp	r3, #0
    d240:	f000 831d 	beq.w	d87e <uip_process+0x217a>
				{
					uip_len = UIP_TCPIP_HLEN;
    d244:	f64a 4314 	movw	r3, #44052	; 0xac14
    d248:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d24c:	f04f 0228 	mov.w	r2, #40	; 0x28
    d250:	801a      	strh	r2, [r3, #0]
					BUF->flags = TCP_ACK;
    d252:	f240 6370 	movw	r3, #1648	; 0x670
    d256:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d25a:	681b      	ldr	r3, [r3, #0]
    d25c:	f103 030e 	add.w	r3, r3, #14
    d260:	f04f 0210 	mov.w	r2, #16
    d264:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
					goto tcp_send_noopts;
    d268:	e0d2      	b.n	d410 <uip_process+0x1d0c>
			goto drop;

		case UIP_LAST_ACK:
			/* We can close this connection if the peer has acknowledged our
			FIN. This is indicated by the UIP_ACKDATA flag. */
			if( uip_flags & UIP_ACKDATA )
    d26a:	f64a 4320 	movw	r3, #44064	; 0xac20
    d26e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d272:	781b      	ldrb	r3, [r3, #0]
    d274:	f003 0301 	and.w	r3, r3, #1
    d278:	b2db      	uxtb	r3, r3
    d27a:	2b00      	cmp	r3, #0
    d27c:	d00b      	beq.n	d296 <uip_process+0x1b92>
			{
				uip_connr->tcpstateflags = UIP_CLOSED;
    d27e:	f04f 0300 	mov.w	r3, #0
    d282:	7663      	strb	r3, [r4, #25]
				uip_flags = UIP_CLOSE;
    d284:	f64a 4320 	movw	r3, #44064	; 0xac20
    d288:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d28c:	f04f 0210 	mov.w	r2, #16
    d290:	701a      	strb	r2, [r3, #0]
				UIP_APPCALL();
    d292:	f001 ff3d 	bl	f110 <httpd_appcall>
			}

			break;
    d296:	bf00      	nop
				uip_connr->tcpstateflags = UIP_TIME_WAIT;
				uip_connr->timer = 0;
			}
	}

	goto drop;
    d298:	e2f8      	b.n	d88c <uip_process+0x2188>

		case UIP_FIN_WAIT_1:
			/* The application has closed the connection, but the remote host
			hasn't closed its end yet. Thus we do nothing but wait for a
			FIN from the other side. */
			if( uip_len > 0 )
    d29a:	f64a 4314 	movw	r3, #44052	; 0xac14
    d29e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d2a2:	881b      	ldrh	r3, [r3, #0]
    d2a4:	2b00      	cmp	r3, #0
    d2a6:	d007      	beq.n	d2b8 <uip_process+0x1bb4>
			{
				uip_add_rcv_nxt( uip_len );
    d2a8:	f64a 4314 	movw	r3, #44052	; 0xac14
    d2ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d2b0:	881b      	ldrh	r3, [r3, #0]
    d2b2:	4618      	mov	r0, r3
    d2b4:	f7fe f9e4 	bl	b680 <uip_add_rcv_nxt>
			}

			if( BUF->flags & TCP_FIN )
    d2b8:	f240 6370 	movw	r3, #1648	; 0x670
    d2bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d2c0:	681b      	ldr	r3, [r3, #0]
    d2c2:	f103 030e 	add.w	r3, r3, #14
    d2c6:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    d2ca:	f003 0301 	and.w	r3, r3, #1
    d2ce:	b2db      	uxtb	r3, r3
    d2d0:	2b00      	cmp	r3, #0
    d2d2:	d024      	beq.n	d31e <uip_process+0x1c1a>
			{
				if( uip_flags & UIP_ACKDATA )
    d2d4:	f64a 4320 	movw	r3, #44064	; 0xac20
    d2d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d2dc:	781b      	ldrb	r3, [r3, #0]
    d2de:	f003 0301 	and.w	r3, r3, #1
    d2e2:	b2db      	uxtb	r3, r3
    d2e4:	2b00      	cmp	r3, #0
    d2e6:	d009      	beq.n	d2fc <uip_process+0x1bf8>
				{
					uip_connr->tcpstateflags = UIP_TIME_WAIT;
    d2e8:	f04f 0307 	mov.w	r3, #7
    d2ec:	7663      	strb	r3, [r4, #25]
					uip_connr->timer = 0;
    d2ee:	f04f 0300 	mov.w	r3, #0
    d2f2:	76a3      	strb	r3, [r4, #26]
					uip_connr->len = 0;
    d2f4:	f04f 0300 	mov.w	r3, #0
    d2f8:	8223      	strh	r3, [r4, #16]
    d2fa:	e002      	b.n	d302 <uip_process+0x1bfe>
				}
				else
				{
					uip_connr->tcpstateflags = UIP_CLOSING;
    d2fc:	f04f 0306 	mov.w	r3, #6
    d300:	7663      	strb	r3, [r4, #25]
				}

				uip_add_rcv_nxt( 1 );
    d302:	f04f 0001 	mov.w	r0, #1
    d306:	f7fe f9bb 	bl	b680 <uip_add_rcv_nxt>
				uip_flags = UIP_CLOSE;
    d30a:	f64a 4320 	movw	r3, #44064	; 0xac20
    d30e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d312:	f04f 0210 	mov.w	r2, #16
    d316:	701a      	strb	r2, [r3, #0]
				UIP_APPCALL();
    d318:	f001 fefa 	bl	f110 <httpd_appcall>
				goto tcp_send_ack;
    d31c:	e066      	b.n	d3ec <uip_process+0x1ce8>
			}
			else if( uip_flags & UIP_ACKDATA )
    d31e:	f64a 4320 	movw	r3, #44064	; 0xac20
    d322:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d326:	781b      	ldrb	r3, [r3, #0]
    d328:	f003 0301 	and.w	r3, r3, #1
    d32c:	b2db      	uxtb	r3, r3
    d32e:	2b00      	cmp	r3, #0
    d330:	d006      	beq.n	d340 <uip_process+0x1c3c>
			{
				uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
    d332:	f04f 0305 	mov.w	r3, #5
    d336:	7663      	strb	r3, [r4, #25]
				uip_connr->len = 0;
    d338:	f04f 0300 	mov.w	r3, #0
    d33c:	8223      	strh	r3, [r4, #16]
				goto drop;
    d33e:	e2a5      	b.n	d88c <uip_process+0x2188>
			}

			if( uip_len > 0 )
    d340:	f64a 4314 	movw	r3, #44052	; 0xac14
    d344:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d348:	881b      	ldrh	r3, [r3, #0]
    d34a:	2b00      	cmp	r3, #0
    d34c:	f000 8299 	beq.w	d882 <uip_process+0x217e>
			{
				goto tcp_send_ack;
    d350:	e04c      	b.n	d3ec <uip_process+0x1ce8>
			}

			goto drop;

		case UIP_FIN_WAIT_2:
			if( uip_len > 0 )
    d352:	f64a 4314 	movw	r3, #44052	; 0xac14
    d356:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d35a:	881b      	ldrh	r3, [r3, #0]
    d35c:	2b00      	cmp	r3, #0
    d35e:	d007      	beq.n	d370 <uip_process+0x1c6c>
			{
				uip_add_rcv_nxt( uip_len );
    d360:	f64a 4314 	movw	r3, #44052	; 0xac14
    d364:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d368:	881b      	ldrh	r3, [r3, #0]
    d36a:	4618      	mov	r0, r3
    d36c:	f7fe f988 	bl	b680 <uip_add_rcv_nxt>
			}

			if( BUF->flags & TCP_FIN )
    d370:	f240 6370 	movw	r3, #1648	; 0x670
    d374:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d378:	681b      	ldr	r3, [r3, #0]
    d37a:	f103 030e 	add.w	r3, r3, #14
    d37e:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    d382:	f003 0301 	and.w	r3, r3, #1
    d386:	b2db      	uxtb	r3, r3
    d388:	2b00      	cmp	r3, #0
    d38a:	d013      	beq.n	d3b4 <uip_process+0x1cb0>
			{
				uip_connr->tcpstateflags = UIP_TIME_WAIT;
    d38c:	f04f 0307 	mov.w	r3, #7
    d390:	7663      	strb	r3, [r4, #25]
				uip_connr->timer = 0;
    d392:	f04f 0300 	mov.w	r3, #0
    d396:	76a3      	strb	r3, [r4, #26]
				uip_add_rcv_nxt( 1 );
    d398:	f04f 0001 	mov.w	r0, #1
    d39c:	f7fe f970 	bl	b680 <uip_add_rcv_nxt>
				uip_flags = UIP_CLOSE;
    d3a0:	f64a 4320 	movw	r3, #44064	; 0xac20
    d3a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d3a8:	f04f 0210 	mov.w	r2, #16
    d3ac:	701a      	strb	r2, [r3, #0]
				UIP_APPCALL();
    d3ae:	f001 feaf 	bl	f110 <httpd_appcall>
				goto tcp_send_ack;
    d3b2:	e01b      	b.n	d3ec <uip_process+0x1ce8>
			}

			if( uip_len > 0 )
    d3b4:	f64a 4314 	movw	r3, #44052	; 0xac14
    d3b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d3bc:	881b      	ldrh	r3, [r3, #0]
    d3be:	2b00      	cmp	r3, #0
    d3c0:	f000 8261 	beq.w	d886 <uip_process+0x2182>
			{
				goto tcp_send_ack;
    d3c4:	e012      	b.n	d3ec <uip_process+0x1ce8>

		case UIP_TIME_WAIT:
			goto tcp_send_ack;

		case UIP_CLOSING:
			if( uip_flags & UIP_ACKDATA )
    d3c6:	f64a 4320 	movw	r3, #44064	; 0xac20
    d3ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d3ce:	781b      	ldrb	r3, [r3, #0]
    d3d0:	f003 0301 	and.w	r3, r3, #1
    d3d4:	b2db      	uxtb	r3, r3
    d3d6:	2b00      	cmp	r3, #0
    d3d8:	f000 8257 	beq.w	d88a <uip_process+0x2186>
			{
				uip_connr->tcpstateflags = UIP_TIME_WAIT;
    d3dc:	f04f 0307 	mov.w	r3, #7
    d3e0:	7663      	strb	r3, [r4, #25]
				uip_connr->timer = 0;
    d3e2:	f04f 0300 	mov.w	r3, #0
    d3e6:	76a3      	strb	r3, [r4, #26]
			}
	}

	goto drop;
    d3e8:	e250      	b.n	d88c <uip_process+0x2188>
			}

			goto drop;

		case UIP_TIME_WAIT:
			goto tcp_send_ack;
    d3ea:	bf00      	nop
	goto drop;

	/* We jump here when we are ready to send the packet, and just want
	 to set the appropriate TCP sequence numbers in the TCP header. */
tcp_send_ack:
	BUF->flags = TCP_ACK;
    d3ec:	f240 6370 	movw	r3, #1648	; 0x670
    d3f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d3f4:	681b      	ldr	r3, [r3, #0]
    d3f6:	f103 030e 	add.w	r3, r3, #14
    d3fa:	f04f 0210 	mov.w	r2, #16
    d3fe:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

tcp_send_nodata:
	uip_len = UIP_IPTCPH_LEN;
    d402:	f64a 4314 	movw	r3, #44052	; 0xac14
    d406:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d40a:	f04f 0228 	mov.w	r2, #40	; 0x28
    d40e:	801a      	strh	r2, [r3, #0]

tcp_send_noopts:
	BUF->tcpoffset = ( UIP_TCPH_LEN / 4 ) << 4;
    d410:	f240 6370 	movw	r3, #1648	; 0x670
    d414:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d418:	681b      	ldr	r3, [r3, #0]
    d41a:	f103 030e 	add.w	r3, r3, #14
    d41e:	f04f 0250 	mov.w	r2, #80	; 0x50
    d422:	f883 2020 	strb.w	r2, [r3, #32]
	/* We're done with the input processing. We are now ready to send a
	reply. Our job is to fill in all the fields of the TCP and IP
	headers before calculating the checksum and finally send the
	packet. */
tcp_send:
	BUF->ackno[ 0 ] = uip_connr->rcv_nxt[ 0 ];
    d426:	f240 6370 	movw	r3, #1648	; 0x670
    d42a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d42e:	681b      	ldr	r3, [r3, #0]
    d430:	f103 030e 	add.w	r3, r3, #14
    d434:	7a22      	ldrb	r2, [r4, #8]
    d436:	771a      	strb	r2, [r3, #28]
	BUF->ackno[ 1 ] = uip_connr->rcv_nxt[ 1 ];
    d438:	f240 6370 	movw	r3, #1648	; 0x670
    d43c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d440:	681b      	ldr	r3, [r3, #0]
    d442:	f103 030e 	add.w	r3, r3, #14
    d446:	7a62      	ldrb	r2, [r4, #9]
    d448:	775a      	strb	r2, [r3, #29]
	BUF->ackno[ 2 ] = uip_connr->rcv_nxt[ 2 ];
    d44a:	f240 6370 	movw	r3, #1648	; 0x670
    d44e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d452:	681b      	ldr	r3, [r3, #0]
    d454:	f103 030e 	add.w	r3, r3, #14
    d458:	7aa2      	ldrb	r2, [r4, #10]
    d45a:	779a      	strb	r2, [r3, #30]
	BUF->ackno[ 3 ] = uip_connr->rcv_nxt[ 3 ];
    d45c:	f240 6370 	movw	r3, #1648	; 0x670
    d460:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d464:	681b      	ldr	r3, [r3, #0]
    d466:	f103 030e 	add.w	r3, r3, #14
    d46a:	7ae2      	ldrb	r2, [r4, #11]
    d46c:	77da      	strb	r2, [r3, #31]

	BUF->seqno[ 0 ] = uip_connr->snd_nxt[ 0 ];
    d46e:	f240 6370 	movw	r3, #1648	; 0x670
    d472:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d476:	681b      	ldr	r3, [r3, #0]
    d478:	f103 030e 	add.w	r3, r3, #14
    d47c:	7b22      	ldrb	r2, [r4, #12]
    d47e:	761a      	strb	r2, [r3, #24]
	BUF->seqno[ 1 ] = uip_connr->snd_nxt[ 1 ];
    d480:	f240 6370 	movw	r3, #1648	; 0x670
    d484:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d488:	681b      	ldr	r3, [r3, #0]
    d48a:	f103 030e 	add.w	r3, r3, #14
    d48e:	7b62      	ldrb	r2, [r4, #13]
    d490:	765a      	strb	r2, [r3, #25]
	BUF->seqno[ 2 ] = uip_connr->snd_nxt[ 2 ];
    d492:	f240 6370 	movw	r3, #1648	; 0x670
    d496:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d49a:	681b      	ldr	r3, [r3, #0]
    d49c:	f103 030e 	add.w	r3, r3, #14
    d4a0:	7ba2      	ldrb	r2, [r4, #14]
    d4a2:	769a      	strb	r2, [r3, #26]
	BUF->seqno[ 3 ] = uip_connr->snd_nxt[ 3 ];
    d4a4:	f240 6370 	movw	r3, #1648	; 0x670
    d4a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d4ac:	681b      	ldr	r3, [r3, #0]
    d4ae:	f103 030e 	add.w	r3, r3, #14
    d4b2:	7be2      	ldrb	r2, [r4, #15]
    d4b4:	76da      	strb	r2, [r3, #27]

	BUF->proto = UIP_PROTO_TCP;
    d4b6:	f240 6370 	movw	r3, #1648	; 0x670
    d4ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d4be:	681b      	ldr	r3, [r3, #0]
    d4c0:	f103 030e 	add.w	r3, r3, #14
    d4c4:	f04f 0206 	mov.w	r2, #6
    d4c8:	725a      	strb	r2, [r3, #9]

	BUF->srcport = uip_connr->lport;
    d4ca:	f240 6370 	movw	r3, #1648	; 0x670
    d4ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d4d2:	681b      	ldr	r3, [r3, #0]
    d4d4:	f103 030e 	add.w	r3, r3, #14
    d4d8:	88a2      	ldrh	r2, [r4, #4]
    d4da:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    d4de:	f04f 0000 	mov.w	r0, #0
    d4e2:	ea40 0101 	orr.w	r1, r0, r1
    d4e6:	7519      	strb	r1, [r3, #20]
    d4e8:	ea4f 2212 	mov.w	r2, r2, lsr #8
    d4ec:	b292      	uxth	r2, r2
    d4ee:	f04f 0100 	mov.w	r1, #0
    d4f2:	ea41 0202 	orr.w	r2, r1, r2
    d4f6:	755a      	strb	r2, [r3, #21]
	BUF->destport = uip_connr->rport;
    d4f8:	f240 6370 	movw	r3, #1648	; 0x670
    d4fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d500:	681b      	ldr	r3, [r3, #0]
    d502:	f103 030e 	add.w	r3, r3, #14
    d506:	88e2      	ldrh	r2, [r4, #6]
    d508:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    d50c:	f04f 0000 	mov.w	r0, #0
    d510:	ea40 0101 	orr.w	r1, r0, r1
    d514:	7599      	strb	r1, [r3, #22]
    d516:	ea4f 2212 	mov.w	r2, r2, lsr #8
    d51a:	b292      	uxth	r2, r2
    d51c:	f04f 0100 	mov.w	r1, #0
    d520:	ea41 0202 	orr.w	r2, r1, r2
    d524:	75da      	strb	r2, [r3, #23]

	uip_ipaddr_copy( &BUF->srcipaddr, &uip_hostaddr );
    d526:	f240 6370 	movw	r3, #1648	; 0x670
    d52a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d52e:	681b      	ldr	r3, [r3, #0]
    d530:	f103 020e 	add.w	r2, r3, #14
    d534:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    d538:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d53c:	781b      	ldrb	r3, [r3, #0]
    d53e:	7313      	strb	r3, [r2, #12]
    d540:	f240 6370 	movw	r3, #1648	; 0x670
    d544:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d548:	681b      	ldr	r3, [r3, #0]
    d54a:	f103 020e 	add.w	r2, r3, #14
    d54e:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    d552:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d556:	785b      	ldrb	r3, [r3, #1]
    d558:	7353      	strb	r3, [r2, #13]
    d55a:	f240 6370 	movw	r3, #1648	; 0x670
    d55e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d562:	681b      	ldr	r3, [r3, #0]
    d564:	f103 020e 	add.w	r2, r3, #14
    d568:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    d56c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d570:	789b      	ldrb	r3, [r3, #2]
    d572:	7393      	strb	r3, [r2, #14]
    d574:	f240 6370 	movw	r3, #1648	; 0x670
    d578:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d57c:	681b      	ldr	r3, [r3, #0]
    d57e:	f103 020e 	add.w	r2, r3, #14
    d582:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    d586:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d58a:	78db      	ldrb	r3, [r3, #3]
    d58c:	73d3      	strb	r3, [r2, #15]
	uip_ipaddr_copy( &BUF->destipaddr, &uip_connr->ripaddr );
    d58e:	f240 6370 	movw	r3, #1648	; 0x670
    d592:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d596:	681b      	ldr	r3, [r3, #0]
    d598:	f103 030e 	add.w	r3, r3, #14
    d59c:	7822      	ldrb	r2, [r4, #0]
    d59e:	741a      	strb	r2, [r3, #16]
    d5a0:	f240 6370 	movw	r3, #1648	; 0x670
    d5a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d5a8:	681b      	ldr	r3, [r3, #0]
    d5aa:	f103 030e 	add.w	r3, r3, #14
    d5ae:	7862      	ldrb	r2, [r4, #1]
    d5b0:	745a      	strb	r2, [r3, #17]
    d5b2:	f240 6370 	movw	r3, #1648	; 0x670
    d5b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d5ba:	681b      	ldr	r3, [r3, #0]
    d5bc:	f103 030e 	add.w	r3, r3, #14
    d5c0:	78a2      	ldrb	r2, [r4, #2]
    d5c2:	749a      	strb	r2, [r3, #18]
    d5c4:	f240 6370 	movw	r3, #1648	; 0x670
    d5c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d5cc:	681b      	ldr	r3, [r3, #0]
    d5ce:	f103 030e 	add.w	r3, r3, #14
    d5d2:	78e2      	ldrb	r2, [r4, #3]
    d5d4:	74da      	strb	r2, [r3, #19]

	if( uip_connr->tcpstateflags & UIP_STOPPED )
    d5d6:	7e63      	ldrb	r3, [r4, #25]
    d5d8:	f003 0310 	and.w	r3, r3, #16
    d5dc:	2b00      	cmp	r3, #0
    d5de:	d016      	beq.n	d60e <uip_process+0x1f0a>
	{
		/* If the connection has issued uip_stop(), we advertise a zero
		window so that the remote host will stop sending data. */
		BUF->wnd[ 0 ] = BUF->wnd[ 1 ] = 0;
    d5e0:	f240 6370 	movw	r3, #1648	; 0x670
    d5e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d5e8:	681b      	ldr	r3, [r3, #0]
    d5ea:	f103 020e 	add.w	r2, r3, #14
    d5ee:	f240 6370 	movw	r3, #1648	; 0x670
    d5f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d5f6:	681b      	ldr	r3, [r3, #0]
    d5f8:	f103 030e 	add.w	r3, r3, #14
    d5fc:	f04f 0100 	mov.w	r1, #0
    d600:	f883 1023 	strb.w	r1, [r3, #35]	; 0x23
    d604:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
    d608:	f882 3022 	strb.w	r3, [r2, #34]	; 0x22
    d60c:	e015      	b.n	d63a <uip_process+0x1f36>
	}
	else
	{
		BUF->wnd[ 0 ] = ( (UIP_RECEIVE_WINDOW) >> 8 );
    d60e:	f240 6370 	movw	r3, #1648	; 0x670
    d612:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d616:	681b      	ldr	r3, [r3, #0]
    d618:	f103 030e 	add.w	r3, r3, #14
    d61c:	f04f 0205 	mov.w	r2, #5
    d620:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
		BUF->wnd[ 1 ] = ( (UIP_RECEIVE_WINDOW) & 0xff );
    d624:	f240 6370 	movw	r3, #1648	; 0x670
    d628:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d62c:	681b      	ldr	r3, [r3, #0]
    d62e:	f103 030e 	add.w	r3, r3, #14
    d632:	f06f 026d 	mvn.w	r2, #109	; 0x6d
    d636:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
	}

tcp_send_noconn:

	BUF->ttl = UIP_TTL;
    d63a:	f240 6370 	movw	r3, #1648	; 0x670
    d63e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d642:	681b      	ldr	r3, [r3, #0]
    d644:	f103 030e 	add.w	r3, r3, #14
    d648:	f04f 0240 	mov.w	r2, #64	; 0x40
    d64c:	721a      	strb	r2, [r3, #8]
		/* For IPv6, the IP length field does not include the IPv6 IP header
		 length. */
		BUF->len[ 0 ] = ( (uip_len - UIP_IPH_LEN) >> 8 );
		BUF->len[ 1 ] = ( (uip_len - UIP_IPH_LEN) & 0xff );
	#else /* UIP_CONF_IPV6 */
		BUF->len[ 0 ] = ( uip_len >> 8 );
    d64e:	f240 6370 	movw	r3, #1648	; 0x670
    d652:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d656:	681b      	ldr	r3, [r3, #0]
    d658:	f103 020e 	add.w	r2, r3, #14
    d65c:	f64a 4314 	movw	r3, #44052	; 0xac14
    d660:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d664:	881b      	ldrh	r3, [r3, #0]
    d666:	ea4f 2313 	mov.w	r3, r3, lsr #8
    d66a:	b29b      	uxth	r3, r3
    d66c:	b2db      	uxtb	r3, r3
    d66e:	7093      	strb	r3, [r2, #2]
		BUF->len[ 1 ] = ( uip_len & 0xff );
    d670:	f240 6370 	movw	r3, #1648	; 0x670
    d674:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d678:	681b      	ldr	r3, [r3, #0]
    d67a:	f103 020e 	add.w	r2, r3, #14
    d67e:	f64a 4314 	movw	r3, #44052	; 0xac14
    d682:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d686:	881b      	ldrh	r3, [r3, #0]
    d688:	b2db      	uxtb	r3, r3
    d68a:	70d3      	strb	r3, [r2, #3]
	#endif /* UIP_CONF_IPV6 */

	BUF->urgp[ 0 ] = BUF->urgp[ 1 ] = 0;
    d68c:	f240 6370 	movw	r3, #1648	; 0x670
    d690:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d694:	681b      	ldr	r3, [r3, #0]
    d696:	f103 020e 	add.w	r2, r3, #14
    d69a:	f240 6370 	movw	r3, #1648	; 0x670
    d69e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d6a2:	681b      	ldr	r3, [r3, #0]
    d6a4:	f103 030e 	add.w	r3, r3, #14
    d6a8:	f04f 0100 	mov.w	r1, #0
    d6ac:	f883 1027 	strb.w	r1, [r3, #39]	; 0x27
    d6b0:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
    d6b4:	f882 3026 	strb.w	r3, [r2, #38]	; 0x26

	/* Calculate TCP checksum. */
	BUF->tcpchksum = 0;
    d6b8:	f240 6370 	movw	r3, #1648	; 0x670
    d6bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d6c0:	681b      	ldr	r3, [r3, #0]
    d6c2:	f103 030e 	add.w	r3, r3, #14
    d6c6:	f04f 0200 	mov.w	r2, #0
    d6ca:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
    d6ce:	f04f 0200 	mov.w	r2, #0
    d6d2:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
	BUF->tcpchksum = ~( uip_tcpchksum() );
    d6d6:	f240 6370 	movw	r3, #1648	; 0x670
    d6da:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d6de:	681b      	ldr	r3, [r3, #0]
    d6e0:	f103 040e 	add.w	r4, r3, #14
    d6e4:	f7fd fddc 	bl	b2a0 <uip_tcpchksum>
    d6e8:	4603      	mov	r3, r0
    d6ea:	ea6f 0303 	mvn.w	r3, r3
    d6ee:	b29b      	uxth	r3, r3
    d6f0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    d6f4:	f04f 0100 	mov.w	r1, #0
    d6f8:	ea41 0202 	orr.w	r2, r1, r2
    d6fc:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
    d700:	ea4f 2313 	mov.w	r3, r3, lsr #8
    d704:	b29b      	uxth	r3, r3
    d706:	f04f 0200 	mov.w	r2, #0
    d70a:	ea42 0303 	orr.w	r3, r2, r3
    d70e:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
	#if UIP_CONF_IPV6
		BUF->vtc = 0x60;
		BUF->tcflow = 0x00;
		BUF->flow = 0x00;
	#else /* UIP_CONF_IPV6 */
		BUF->vhl = 0x45;
    d712:	f240 6370 	movw	r3, #1648	; 0x670
    d716:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d71a:	681b      	ldr	r3, [r3, #0]
    d71c:	f103 030e 	add.w	r3, r3, #14
    d720:	f04f 0245 	mov.w	r2, #69	; 0x45
    d724:	701a      	strb	r2, [r3, #0]
		BUF->tos = 0;
    d726:	f240 6370 	movw	r3, #1648	; 0x670
    d72a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d72e:	681b      	ldr	r3, [r3, #0]
    d730:	f103 030e 	add.w	r3, r3, #14
    d734:	f04f 0200 	mov.w	r2, #0
    d738:	705a      	strb	r2, [r3, #1]
		BUF->ipoffset[ 0 ] = BUF->ipoffset[ 1 ] = 0;
    d73a:	f240 6370 	movw	r3, #1648	; 0x670
    d73e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d742:	681b      	ldr	r3, [r3, #0]
    d744:	f103 020e 	add.w	r2, r3, #14
    d748:	f240 6370 	movw	r3, #1648	; 0x670
    d74c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d750:	681b      	ldr	r3, [r3, #0]
    d752:	f103 030e 	add.w	r3, r3, #14
    d756:	f04f 0100 	mov.w	r1, #0
    d75a:	71d9      	strb	r1, [r3, #7]
    d75c:	79db      	ldrb	r3, [r3, #7]
    d75e:	7193      	strb	r3, [r2, #6]
		++ipid;
    d760:	f642 7354 	movw	r3, #12116	; 0x2f54
    d764:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d768:	881b      	ldrh	r3, [r3, #0]
    d76a:	f103 0301 	add.w	r3, r3, #1
    d76e:	b29a      	uxth	r2, r3
    d770:	f642 7354 	movw	r3, #12116	; 0x2f54
    d774:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d778:	801a      	strh	r2, [r3, #0]
		BUF->ipid[ 0 ] = ipid >> 8;
    d77a:	f240 6370 	movw	r3, #1648	; 0x670
    d77e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d782:	681b      	ldr	r3, [r3, #0]
    d784:	f103 020e 	add.w	r2, r3, #14
    d788:	f642 7354 	movw	r3, #12116	; 0x2f54
    d78c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d790:	881b      	ldrh	r3, [r3, #0]
    d792:	ea4f 2313 	mov.w	r3, r3, lsr #8
    d796:	b29b      	uxth	r3, r3
    d798:	b2db      	uxtb	r3, r3
    d79a:	7113      	strb	r3, [r2, #4]
		BUF->ipid[ 1 ] = ipid & 0xff;
    d79c:	f240 6370 	movw	r3, #1648	; 0x670
    d7a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d7a4:	681b      	ldr	r3, [r3, #0]
    d7a6:	f103 020e 	add.w	r2, r3, #14
    d7aa:	f642 7354 	movw	r3, #12116	; 0x2f54
    d7ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d7b2:	881b      	ldrh	r3, [r3, #0]
    d7b4:	b2db      	uxtb	r3, r3
    d7b6:	7153      	strb	r3, [r2, #5]

		/* Calculate IP checksum. */
		BUF->ipchksum = 0;
    d7b8:	f240 6370 	movw	r3, #1648	; 0x670
    d7bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d7c0:	681b      	ldr	r3, [r3, #0]
    d7c2:	f103 030e 	add.w	r3, r3, #14
    d7c6:	f04f 0200 	mov.w	r2, #0
    d7ca:	729a      	strb	r2, [r3, #10]
    d7cc:	f04f 0200 	mov.w	r2, #0
    d7d0:	72da      	strb	r2, [r3, #11]
		BUF->ipchksum = ~( uip_ipchksum() );
    d7d2:	f240 6370 	movw	r3, #1648	; 0x670
    d7d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d7da:	681b      	ldr	r3, [r3, #0]
    d7dc:	f103 040e 	add.w	r4, r3, #14
    d7e0:	f7fd fce6 	bl	b1b0 <uip_ipchksum>
    d7e4:	4603      	mov	r3, r0
    d7e6:	ea6f 0303 	mvn.w	r3, r3
    d7ea:	b29b      	uxth	r3, r3
    d7ec:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    d7f0:	f04f 0100 	mov.w	r1, #0
    d7f4:	ea41 0202 	orr.w	r2, r1, r2
    d7f8:	72a2      	strb	r2, [r4, #10]
    d7fa:	ea4f 2313 	mov.w	r3, r3, lsr #8
    d7fe:	b29b      	uxth	r3, r3
    d800:	f04f 0200 	mov.w	r2, #0
    d804:	ea42 0303 	orr.w	r3, r2, r3
    d808:	72e3      	strb	r3, [r4, #11]

		//DEBUG_PRINTF( "uip ip_send_nolen: chkecum 0x%04x\n", uip_ipchksum() );
	#endif /* UIP_CONF_IPV6 */

	UIP_STAT( ++uip_stat.tcp.sent );
    d80a:	f64c 4360 	movw	r3, #52320	; 0xcc60
    d80e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d812:	8c1b      	ldrh	r3, [r3, #32]
    d814:	f103 0301 	add.w	r3, r3, #1
    d818:	b29a      	uxth	r2, r3
    d81a:	f64c 4360 	movw	r3, #52320	; 0xcc60
    d81e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d822:	841a      	strh	r2, [r3, #32]
	#if UIP_CONF_IPV6
send :
	#endif /* UIP_CONF_IPV6 */

	//DEBUG_PRINTF( "Sending packet with length %d (%d)\n", uip_len, (BUF->len[ 0 ] << 8) | BUF->len[ 1 ] );
	UIP_STAT( ++uip_stat.ip.sent );
    d824:	f64c 4360 	movw	r3, #52320	; 0xcc60
    d828:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d82c:	885b      	ldrh	r3, [r3, #2]
    d82e:	f103 0301 	add.w	r3, r3, #1
    d832:	b29a      	uxth	r2, r3
    d834:	f64c 4360 	movw	r3, #52320	; 0xcc60
    d838:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d83c:	805a      	strh	r2, [r3, #2]

	/* Return and let the caller do the actual transmission. */
	uip_flags = 0;
    d83e:	f64a 4320 	movw	r3, #44064	; 0xac20
    d842:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d846:	f04f 0200 	mov.w	r2, #0
    d84a:	701a      	strb	r2, [r3, #0]
	return;
    d84c:	e02d      	b.n	d8aa <uip_process+0x21a6>
			uip_flags = UIP_POLL;
			UIP_APPCALL();
			goto appsend;
		}

		goto drop;
    d84e:	bf00      	nop
    d850:	e01c      	b.n	d88c <uip_process+0x2188>
    d852:	bf00      	nop
    d854:	e01a      	b.n	d88c <uip_process+0x2188>
				UIP_APPCALL();
				goto appsend;
			}
		}

		goto drop;
    d856:	bf00      	nop
    d858:	e018      	b.n	d88c <uip_process+0x2188>
    d85a:	bf00      	nop
    d85c:	e016      	b.n	d88c <uip_process+0x2188>
    d85e:	bf00      	nop
    d860:	e014      	b.n	d88c <uip_process+0x2188>
    d862:	bf00      	nop
    d864:	e012      	b.n	d88c <uip_process+0x2188>
		#endif /* UIP_CONF_IPV6 */
	}
	else
	{
		UIP_LOG( "ip: packet shorter than reported in IP header." );
		goto drop;
    d866:	bf00      	nop
    d868:	e010      	b.n	d88c <uip_process+0x2188>

reset:
	/* We do not send resets in response to resets. */
	if( BUF->flags & TCP_RST )
	{
		goto drop;
    d86a:	bf00      	nop
    d86c:	e00e      	b.n	d88c <uip_process+0x2188>
				uip_connr->tcpstateflags = UIP_TIME_WAIT;
				uip_connr->timer = 0;
			}
	}

	goto drop;
    d86e:	bf00      	nop
    d870:	e00c      	b.n	d88c <uip_process+0x2188>
				uip_slen = 0;
				UIP_APPCALL();
				goto appsend;
			}

			goto drop;
    d872:	bf00      	nop
    d874:	e00a      	b.n	d88c <uip_process+0x2188>
			sequence numbers will be screwed up. */
			if( BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED) )
			{
				if( uip_outstanding(uip_connr) )
				{
					goto drop;
    d876:	bf00      	nop
    d878:	e008      	b.n	d88c <uip_process+0x2188>
					BUF->flags = TCP_ACK;
					goto tcp_send_noopts;
				}
			}

			goto drop;
    d87a:	bf00      	nop
    d87c:	e006      	b.n	d88c <uip_process+0x2188>
    d87e:	bf00      	nop
    d880:	e004      	b.n	d88c <uip_process+0x2188>
			if( uip_len > 0 )
			{
				goto tcp_send_ack;
			}

			goto drop;
    d882:	bf00      	nop
    d884:	e002      	b.n	d88c <uip_process+0x2188>
			if( uip_len > 0 )
			{
				goto tcp_send_ack;
			}

			goto drop;
    d886:	bf00      	nop
    d888:	e000      	b.n	d88c <uip_process+0x2188>
				uip_connr->tcpstateflags = UIP_TIME_WAIT;
				uip_connr->timer = 0;
			}
	}

	goto drop;
    d88a:	bf00      	nop
	/* Return and let the caller do the actual transmission. */
	uip_flags = 0;
	return;

drop:
	uip_len = 0;
    d88c:	f64a 4314 	movw	r3, #44052	; 0xac14
    d890:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d894:	f04f 0200 	mov.w	r2, #0
    d898:	801a      	strh	r2, [r3, #0]
	uip_flags = 0;
    d89a:	f64a 4320 	movw	r3, #44064	; 0xac20
    d89e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d8a2:	f04f 0200 	mov.w	r2, #0
    d8a6:	701a      	strb	r2, [r3, #0]
	return;
    d8a8:	bf00      	nop
}
    d8aa:	f107 0714 	add.w	r7, r7, #20
    d8ae:	46bd      	mov	sp, r7
    d8b0:	bd90      	pop	{r4, r7, pc}
    d8b2:	bf00      	nop

0000d8b4 <htons>:
/*---------------------------------------------------------------------------*/

u16_t htons( u16_t val )
{
    d8b4:	b480      	push	{r7}
    d8b6:	b083      	sub	sp, #12
    d8b8:	af00      	add	r7, sp, #0
    d8ba:	4603      	mov	r3, r0
    d8bc:	80fb      	strh	r3, [r7, #6]
	return HTONS( val );
    d8be:	88fb      	ldrh	r3, [r7, #6]
    d8c0:	ea4f 2303 	mov.w	r3, r3, lsl #8
    d8c4:	b29a      	uxth	r2, r3
    d8c6:	88fb      	ldrh	r3, [r7, #6]
    d8c8:	ea4f 2313 	mov.w	r3, r3, lsr #8
    d8cc:	b29b      	uxth	r3, r3
    d8ce:	ea42 0303 	orr.w	r3, r2, r3
    d8d2:	b29b      	uxth	r3, r3
    d8d4:	b29b      	uxth	r3, r3
}
    d8d6:	4618      	mov	r0, r3
    d8d8:	f107 070c 	add.w	r7, r7, #12
    d8dc:	46bd      	mov	sp, r7
    d8de:	bc80      	pop	{r7}
    d8e0:	4770      	bx	lr
    d8e2:	bf00      	nop

0000d8e4 <htonl>:

u32_t htonl( u32_t val )
{
    d8e4:	b480      	push	{r7}
    d8e6:	b083      	sub	sp, #12
    d8e8:	af00      	add	r7, sp, #0
    d8ea:	6078      	str	r0, [r7, #4]
	return HTONL( val );
    d8ec:	687b      	ldr	r3, [r7, #4]
    d8ee:	b29b      	uxth	r3, r3
    d8f0:	ea4f 2303 	mov.w	r3, r3, lsl #8
    d8f4:	b29a      	uxth	r2, r3
    d8f6:	687b      	ldr	r3, [r7, #4]
    d8f8:	b29b      	uxth	r3, r3
    d8fa:	ea4f 2313 	mov.w	r3, r3, lsr #8
    d8fe:	b29b      	uxth	r3, r3
    d900:	ea42 0303 	orr.w	r3, r2, r3
    d904:	b29b      	uxth	r3, r3
    d906:	b29b      	uxth	r3, r3
    d908:	ea4f 4203 	mov.w	r2, r3, lsl #16
    d90c:	687b      	ldr	r3, [r7, #4]
    d90e:	ea4f 4313 	mov.w	r3, r3, lsr #16
    d912:	b29b      	uxth	r3, r3
    d914:	ea4f 2303 	mov.w	r3, r3, lsl #8
    d918:	b299      	uxth	r1, r3
    d91a:	687b      	ldr	r3, [r7, #4]
    d91c:	ea4f 4313 	mov.w	r3, r3, lsr #16
    d920:	b29b      	uxth	r3, r3
    d922:	ea4f 2313 	mov.w	r3, r3, lsr #8
    d926:	b29b      	uxth	r3, r3
    d928:	ea41 0303 	orr.w	r3, r1, r3
    d92c:	b29b      	uxth	r3, r3
    d92e:	b29b      	uxth	r3, r3
    d930:	ea42 0303 	orr.w	r3, r2, r3
}
    d934:	4618      	mov	r0, r3
    d936:	f107 070c 	add.w	r7, r7, #12
    d93a:	46bd      	mov	sp, r7
    d93c:	bc80      	pop	{r7}
    d93e:	4770      	bx	lr

0000d940 <uip_send>:
/*---------------------------------------------------------------------------*/

void uip_send( const void *data, int len )
{
    d940:	b580      	push	{r7, lr}
    d942:	b084      	sub	sp, #16
    d944:	af00      	add	r7, sp, #0
    d946:	6078      	str	r0, [r7, #4]
    d948:	6039      	str	r1, [r7, #0]
	int copylen;

	#define MIN( a, b ) ( (a) < (b) ? (a) : (b) )

	copylen = MIN( len, UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN - ( int )
    d94a:	f240 6370 	movw	r3, #1648	; 0x670
    d94e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d952:	681b      	ldr	r3, [r3, #0]
    d954:	f103 0336 	add.w	r3, r3, #54	; 0x36
    d958:	461a      	mov	r2, r3
    d95a:	f64a 4318 	movw	r3, #44056	; 0xac18
    d95e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d962:	681b      	ldr	r3, [r3, #0]
    d964:	ebc3 0302 	rsb	r3, r3, r2
    d968:	f503 63b2 	add.w	r3, r3, #1424	; 0x590
    d96c:	f103 0302 	add.w	r3, r3, #2
    d970:	683a      	ldr	r2, [r7, #0]
    d972:	4293      	cmp	r3, r2
    d974:	bfa8      	it	ge
    d976:	4613      	movge	r3, r2
    d978:	60fb      	str	r3, [r7, #12]
					   (( char * ) uip_sappdata - ( char * ) &uip_buf[UIP_LLH_LEN + UIP_TCPIP_HLEN]) );
	if( copylen > 0 )
    d97a:	68fb      	ldr	r3, [r7, #12]
    d97c:	2b00      	cmp	r3, #0
    d97e:	dd1d      	ble.n	d9bc <uip_send+0x7c>
	{
		uip_slen = copylen;
    d980:	68fb      	ldr	r3, [r7, #12]
    d982:	b29a      	uxth	r2, r3
    d984:	f64c 43a0 	movw	r3, #52384	; 0xcca0
    d988:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d98c:	801a      	strh	r2, [r3, #0]
		if( data != uip_sappdata )
    d98e:	f64a 4318 	movw	r3, #44056	; 0xac18
    d992:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d996:	681b      	ldr	r3, [r3, #0]
    d998:	687a      	ldr	r2, [r7, #4]
    d99a:	429a      	cmp	r2, r3
    d99c:	d00e      	beq.n	d9bc <uip_send+0x7c>
		{
			memcpy( uip_sappdata, (data), uip_slen );
    d99e:	f64a 4318 	movw	r3, #44056	; 0xac18
    d9a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d9a6:	681a      	ldr	r2, [r3, #0]
    d9a8:	f64c 43a0 	movw	r3, #52384	; 0xcca0
    d9ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d9b0:	881b      	ldrh	r3, [r3, #0]
    d9b2:	4610      	mov	r0, r2
    d9b4:	6879      	ldr	r1, [r7, #4]
    d9b6:	461a      	mov	r2, r3
    d9b8:	f007 fd3c 	bl	15434 <memcpy>
		}
	}
}
    d9bc:	f107 0710 	add.w	r7, r7, #16
    d9c0:	46bd      	mov	sp, r7
    d9c2:	bd80      	pop	{r7, pc}

0000d9c4 <uip_arp_init>:
 *
 */

/*-----------------------------------------------------------------------------------*/
void uip_arp_init( void )
{
    d9c4:	b580      	push	{r7, lr}
    d9c6:	af00      	add	r7, sp, #0
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    d9c8:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    d9cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d9d0:	f04f 0200 	mov.w	r2, #0
    d9d4:	701a      	strb	r2, [r3, #0]
    d9d6:	e024      	b.n	da22 <uip_arp_init+0x5e>
	{
		memset( &arp_table[i].ipaddr, 0, 4 );
    d9d8:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    d9dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d9e0:	781b      	ldrb	r3, [r3, #0]
    d9e2:	461a      	mov	r2, r3
    d9e4:	4613      	mov	r3, r2
    d9e6:	ea4f 0343 	mov.w	r3, r3, lsl #1
    d9ea:	4413      	add	r3, r2
    d9ec:	ea4f 0283 	mov.w	r2, r3, lsl #2
    d9f0:	f642 7364 	movw	r3, #12132	; 0x2f64
    d9f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    d9f8:	4413      	add	r3, r2
    d9fa:	4618      	mov	r0, r3
    d9fc:	f04f 0100 	mov.w	r1, #0
    da00:	f04f 0204 	mov.w	r2, #4
    da04:	f007 fdde 	bl	155c4 <memset>
 */

/*-----------------------------------------------------------------------------------*/
void uip_arp_init( void )
{
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    da08:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    da0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    da10:	781b      	ldrb	r3, [r3, #0]
    da12:	f103 0301 	add.w	r3, r3, #1
    da16:	b2da      	uxtb	r2, r3
    da18:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    da1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    da20:	701a      	strb	r2, [r3, #0]
    da22:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    da26:	f2c2 0300 	movt	r3, #8192	; 0x2000
    da2a:	781b      	ldrb	r3, [r3, #0]
    da2c:	2b07      	cmp	r3, #7
    da2e:	d9d3      	bls.n	d9d8 <uip_arp_init+0x14>
	{
		memset( &arp_table[i].ipaddr, 0, 4 );
	}
}
    da30:	bd80      	pop	{r7, pc}
    da32:	bf00      	nop

0000da34 <uip_arp_timer>:
 *
 */

/*-----------------------------------------------------------------------------------*/
void uip_arp_timer( void )
{
    da34:	b580      	push	{r7, lr}
    da36:	b082      	sub	sp, #8
    da38:	af00      	add	r7, sp, #0
	struct arp_entry	*tabptr;

	++arptime;
    da3a:	f642 73ca 	movw	r3, #12234	; 0x2fca
    da3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    da42:	781b      	ldrb	r3, [r3, #0]
    da44:	f103 0301 	add.w	r3, r3, #1
    da48:	b2da      	uxtb	r2, r3
    da4a:	f642 73ca 	movw	r3, #12234	; 0x2fca
    da4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    da52:	701a      	strb	r2, [r3, #0]
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    da54:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    da58:	f2c2 0300 	movt	r3, #8192	; 0x2000
    da5c:	f04f 0200 	mov.w	r2, #0
    da60:	701a      	strb	r2, [r3, #0]
    da62:	e045      	b.n	daf0 <uip_arp_timer+0xbc>
	{
		tabptr = &arp_table[i];
    da64:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    da68:	f2c2 0300 	movt	r3, #8192	; 0x2000
    da6c:	781b      	ldrb	r3, [r3, #0]
    da6e:	461a      	mov	r2, r3
    da70:	4613      	mov	r3, r2
    da72:	ea4f 0343 	mov.w	r3, r3, lsl #1
    da76:	4413      	add	r3, r2
    da78:	ea4f 0383 	mov.w	r3, r3, lsl #2
    da7c:	461a      	mov	r2, r3
    da7e:	f642 7364 	movw	r3, #12132	; 0x2f64
    da82:	f2c2 0300 	movt	r3, #8192	; 0x2000
    da86:	4413      	add	r3, r2
    da88:	607b      	str	r3, [r7, #4]
		if( uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) && arptime - tabptr->time >= UIP_ARP_MAXAGE )
    da8a:	687b      	ldr	r3, [r7, #4]
    da8c:	881a      	ldrh	r2, [r3, #0]
    da8e:	f24d 1324 	movw	r3, #53540	; 0xd124
    da92:	f2c0 0301 	movt	r3, #1
    da96:	881b      	ldrh	r3, [r3, #0]
    da98:	429a      	cmp	r2, r3
    da9a:	d11c      	bne.n	dad6 <uip_arp_timer+0xa2>
    da9c:	687b      	ldr	r3, [r7, #4]
    da9e:	885a      	ldrh	r2, [r3, #2]
    daa0:	f24d 1324 	movw	r3, #53540	; 0xd124
    daa4:	f2c0 0301 	movt	r3, #1
    daa8:	885b      	ldrh	r3, [r3, #2]
    daaa:	429a      	cmp	r2, r3
    daac:	d113      	bne.n	dad6 <uip_arp_timer+0xa2>
    daae:	f642 73ca 	movw	r3, #12234	; 0x2fca
    dab2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dab6:	781b      	ldrb	r3, [r3, #0]
    dab8:	461a      	mov	r2, r3
    daba:	687b      	ldr	r3, [r7, #4]
    dabc:	7a9b      	ldrb	r3, [r3, #10]
    dabe:	ebc3 0302 	rsb	r3, r3, r2
    dac2:	2b77      	cmp	r3, #119	; 0x77
    dac4:	dd07      	ble.n	dad6 <uip_arp_timer+0xa2>
		{
			memset( &tabptr->ipaddr, 0, 4 );
    dac6:	687b      	ldr	r3, [r7, #4]
    dac8:	4618      	mov	r0, r3
    daca:	f04f 0100 	mov.w	r1, #0
    dace:	f04f 0204 	mov.w	r2, #4
    dad2:	f007 fd77 	bl	155c4 <memset>
void uip_arp_timer( void )
{
	struct arp_entry	*tabptr;

	++arptime;
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    dad6:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    dada:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dade:	781b      	ldrb	r3, [r3, #0]
    dae0:	f103 0301 	add.w	r3, r3, #1
    dae4:	b2da      	uxtb	r2, r3
    dae6:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    daea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    daee:	701a      	strb	r2, [r3, #0]
    daf0:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    daf4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    daf8:	781b      	ldrb	r3, [r3, #0]
    dafa:	2b07      	cmp	r3, #7
    dafc:	d9b2      	bls.n	da64 <uip_arp_timer+0x30>
		if( uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) && arptime - tabptr->time >= UIP_ARP_MAXAGE )
		{
			memset( &tabptr->ipaddr, 0, 4 );
		}
	}
}
    dafe:	f107 0708 	add.w	r7, r7, #8
    db02:	46bd      	mov	sp, r7
    db04:	bd80      	pop	{r7, pc}
    db06:	bf00      	nop

0000db08 <uip_arp_update>:

/*-----------------------------------------------------------------------------------*/
static void uip_arp_update( uip_ipaddr_t *ipaddr, struct uip_eth_addr *ethaddr )
{
    db08:	b590      	push	{r4, r7, lr}
    db0a:	b083      	sub	sp, #12
    db0c:	af00      	add	r7, sp, #0
    db0e:	6078      	str	r0, [r7, #4]
    db10:	6039      	str	r1, [r7, #0]
	register struct arp_entry	*tabptr;

	/* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    db12:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    db16:	f2c2 0300 	movt	r3, #8192	; 0x2000
    db1a:	f04f 0200 	mov.w	r2, #0
    db1e:	701a      	strb	r2, [r3, #0]
    db20:	e049      	b.n	dbb6 <uip_arp_update+0xae>
	{
		tabptr = &arp_table[i];
    db22:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    db26:	f2c2 0300 	movt	r3, #8192	; 0x2000
    db2a:	781b      	ldrb	r3, [r3, #0]
    db2c:	461a      	mov	r2, r3
    db2e:	4613      	mov	r3, r2
    db30:	ea4f 0343 	mov.w	r3, r3, lsl #1
    db34:	4413      	add	r3, r2
    db36:	ea4f 0383 	mov.w	r3, r3, lsl #2
    db3a:	461a      	mov	r2, r3
    db3c:	f642 7364 	movw	r3, #12132	; 0x2f64
    db40:	f2c2 0300 	movt	r3, #8192	; 0x2000
    db44:	eb02 0403 	add.w	r4, r2, r3

		/* Only check those entries that are actually in use. */
		if( !uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) )
    db48:	8822      	ldrh	r2, [r4, #0]
    db4a:	f24d 1324 	movw	r3, #53540	; 0xd124
    db4e:	f2c0 0301 	movt	r3, #1
    db52:	881b      	ldrh	r3, [r3, #0]
    db54:	429a      	cmp	r2, r3
    db56:	d107      	bne.n	db68 <uip_arp_update+0x60>
    db58:	8862      	ldrh	r2, [r4, #2]
    db5a:	f24d 1324 	movw	r3, #53540	; 0xd124
    db5e:	f2c0 0301 	movt	r3, #1
    db62:	885b      	ldrh	r3, [r3, #2]
    db64:	429a      	cmp	r2, r3
    db66:	d019      	beq.n	db9c <uip_arp_update+0x94>
		{
			/* Check if the source IP address of the incoming packet matches
         the IP address in this ARP table entry. */
			if( uip_ipaddr_cmp(ipaddr, &tabptr->ipaddr) )
    db68:	687b      	ldr	r3, [r7, #4]
    db6a:	881a      	ldrh	r2, [r3, #0]
    db6c:	8823      	ldrh	r3, [r4, #0]
    db6e:	429a      	cmp	r2, r3
    db70:	d114      	bne.n	db9c <uip_arp_update+0x94>
    db72:	687b      	ldr	r3, [r7, #4]
    db74:	885a      	ldrh	r2, [r3, #2]
    db76:	8863      	ldrh	r3, [r4, #2]
    db78:	429a      	cmp	r2, r3
    db7a:	d10f      	bne.n	db9c <uip_arp_update+0x94>
			{
				/* An old entry found, update this and return. */
				memcpy( tabptr->ethaddr.addr, ethaddr->addr, 6 );
    db7c:	f104 0204 	add.w	r2, r4, #4
    db80:	683b      	ldr	r3, [r7, #0]
    db82:	4610      	mov	r0, r2
    db84:	4619      	mov	r1, r3
    db86:	f04f 0206 	mov.w	r2, #6
    db8a:	f007 fc53 	bl	15434 <memcpy>
				tabptr->time = arptime;
    db8e:	f642 73ca 	movw	r3, #12234	; 0x2fca
    db92:	f2c2 0300 	movt	r3, #8192	; 0x2000
    db96:	781b      	ldrb	r3, [r3, #0]
    db98:	72a3      	strb	r3, [r4, #10]

				return;
    db9a:	e0f9      	b.n	dd90 <uip_arp_update+0x288>
	register struct arp_entry	*tabptr;

	/* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    db9c:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    dba0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dba4:	781b      	ldrb	r3, [r3, #0]
    dba6:	f103 0301 	add.w	r3, r3, #1
    dbaa:	b2da      	uxtb	r2, r3
    dbac:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    dbb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dbb4:	701a      	strb	r2, [r3, #0]
    dbb6:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    dbba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dbbe:	781b      	ldrb	r3, [r3, #0]
    dbc0:	2b07      	cmp	r3, #7
    dbc2:	d9ae      	bls.n	db22 <uip_arp_update+0x1a>

	/* If we get here, no existing ARP table entry was found, so we
     create one. */

	/* First, we try to find an unused entry in the ARP table. */
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    dbc4:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    dbc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dbcc:	f04f 0200 	mov.w	r2, #0
    dbd0:	701a      	strb	r2, [r3, #0]
    dbd2:	e02f      	b.n	dc34 <uip_arp_update+0x12c>
	{
		tabptr = &arp_table[i];
    dbd4:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    dbd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dbdc:	781b      	ldrb	r3, [r3, #0]
    dbde:	461a      	mov	r2, r3
    dbe0:	4613      	mov	r3, r2
    dbe2:	ea4f 0343 	mov.w	r3, r3, lsl #1
    dbe6:	4413      	add	r3, r2
    dbe8:	ea4f 0383 	mov.w	r3, r3, lsl #2
    dbec:	461a      	mov	r2, r3
    dbee:	f642 7364 	movw	r3, #12132	; 0x2f64
    dbf2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dbf6:	eb02 0403 	add.w	r4, r2, r3
		if( uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) )
    dbfa:	8822      	ldrh	r2, [r4, #0]
    dbfc:	f24d 1324 	movw	r3, #53540	; 0xd124
    dc00:	f2c0 0301 	movt	r3, #1
    dc04:	881b      	ldrh	r3, [r3, #0]
    dc06:	429a      	cmp	r2, r3
    dc08:	d107      	bne.n	dc1a <uip_arp_update+0x112>
    dc0a:	8862      	ldrh	r2, [r4, #2]
    dc0c:	f24d 1324 	movw	r3, #53540	; 0xd124
    dc10:	f2c0 0301 	movt	r3, #1
    dc14:	885b      	ldrh	r3, [r3, #2]
    dc16:	429a      	cmp	r2, r3
    dc18:	d014      	beq.n	dc44 <uip_arp_update+0x13c>

	/* If we get here, no existing ARP table entry was found, so we
     create one. */

	/* First, we try to find an unused entry in the ARP table. */
	for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    dc1a:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    dc1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dc22:	781b      	ldrb	r3, [r3, #0]
    dc24:	f103 0301 	add.w	r3, r3, #1
    dc28:	b2da      	uxtb	r2, r3
    dc2a:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    dc2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dc32:	701a      	strb	r2, [r3, #0]
    dc34:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    dc38:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dc3c:	781b      	ldrb	r3, [r3, #0]
    dc3e:	2b07      	cmp	r3, #7
    dc40:	d9c8      	bls.n	dbd4 <uip_arp_update+0xcc>
    dc42:	e000      	b.n	dc46 <uip_arp_update+0x13e>
	{
		tabptr = &arp_table[i];
		if( uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) )
		{
			break;
    dc44:	bf00      	nop
		}
	}

	/* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
	if( i == UIP_ARPTAB_SIZE )
    dc46:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    dc4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dc4e:	781b      	ldrb	r3, [r3, #0]
    dc50:	2b08      	cmp	r3, #8
    dc52:	f040 8082 	bne.w	dd5a <uip_arp_update+0x252>
	{
		tmpage = 0;
    dc56:	f642 73cb 	movw	r3, #12235	; 0x2fcb
    dc5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dc5e:	f04f 0200 	mov.w	r2, #0
    dc62:	701a      	strb	r2, [r3, #0]
		c = 0;
    dc64:	f642 73c9 	movw	r3, #12233	; 0x2fc9
    dc68:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dc6c:	f04f 0200 	mov.w	r2, #0
    dc70:	701a      	strb	r2, [r3, #0]
		for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    dc72:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    dc76:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dc7a:	f04f 0200 	mov.w	r2, #0
    dc7e:	701a      	strb	r2, [r3, #0]
    dc80:	e047      	b.n	dd12 <uip_arp_update+0x20a>
		{
			tabptr = &arp_table[i];
    dc82:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    dc86:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dc8a:	781b      	ldrb	r3, [r3, #0]
    dc8c:	461a      	mov	r2, r3
    dc8e:	4613      	mov	r3, r2
    dc90:	ea4f 0343 	mov.w	r3, r3, lsl #1
    dc94:	4413      	add	r3, r2
    dc96:	ea4f 0383 	mov.w	r3, r3, lsl #2
    dc9a:	461a      	mov	r2, r3
    dc9c:	f642 7364 	movw	r3, #12132	; 0x2f64
    dca0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dca4:	eb02 0403 	add.w	r4, r2, r3
			if( arptime - tabptr->time > tmpage )
    dca8:	f642 73ca 	movw	r3, #12234	; 0x2fca
    dcac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dcb0:	781b      	ldrb	r3, [r3, #0]
    dcb2:	461a      	mov	r2, r3
    dcb4:	7aa3      	ldrb	r3, [r4, #10]
    dcb6:	ebc3 0202 	rsb	r2, r3, r2
    dcba:	f642 73cb 	movw	r3, #12235	; 0x2fcb
    dcbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dcc2:	781b      	ldrb	r3, [r3, #0]
    dcc4:	429a      	cmp	r2, r3
    dcc6:	dd17      	ble.n	dcf8 <uip_arp_update+0x1f0>
			{
				tmpage = arptime - tabptr->time;
    dcc8:	f642 73ca 	movw	r3, #12234	; 0x2fca
    dccc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dcd0:	781a      	ldrb	r2, [r3, #0]
    dcd2:	7aa3      	ldrb	r3, [r4, #10]
    dcd4:	ebc3 0302 	rsb	r3, r3, r2
    dcd8:	b2da      	uxtb	r2, r3
    dcda:	f642 73cb 	movw	r3, #12235	; 0x2fcb
    dcde:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dce2:	701a      	strb	r2, [r3, #0]
				c = i;
    dce4:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    dce8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dcec:	781a      	ldrb	r2, [r3, #0]
    dcee:	f642 73c9 	movw	r3, #12233	; 0x2fc9
    dcf2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dcf6:	701a      	strb	r2, [r3, #0]
     throw it away. */
	if( i == UIP_ARPTAB_SIZE )
	{
		tmpage = 0;
		c = 0;
		for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    dcf8:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    dcfc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dd00:	781b      	ldrb	r3, [r3, #0]
    dd02:	f103 0301 	add.w	r3, r3, #1
    dd06:	b2da      	uxtb	r2, r3
    dd08:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    dd0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dd10:	701a      	strb	r2, [r3, #0]
    dd12:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    dd16:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dd1a:	781b      	ldrb	r3, [r3, #0]
    dd1c:	2b07      	cmp	r3, #7
    dd1e:	d9b0      	bls.n	dc82 <uip_arp_update+0x17a>
				tmpage = arptime - tabptr->time;
				c = i;
			}
		}

		i = c;
    dd20:	f642 73c9 	movw	r3, #12233	; 0x2fc9
    dd24:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dd28:	781a      	ldrb	r2, [r3, #0]
    dd2a:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    dd2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dd32:	701a      	strb	r2, [r3, #0]
		tabptr = &arp_table[i];
    dd34:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    dd38:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dd3c:	781b      	ldrb	r3, [r3, #0]
    dd3e:	461a      	mov	r2, r3
    dd40:	4613      	mov	r3, r2
    dd42:	ea4f 0343 	mov.w	r3, r3, lsl #1
    dd46:	4413      	add	r3, r2
    dd48:	ea4f 0383 	mov.w	r3, r3, lsl #2
    dd4c:	461a      	mov	r2, r3
    dd4e:	f642 7364 	movw	r3, #12132	; 0x2f64
    dd52:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dd56:	eb02 0403 	add.w	r4, r2, r3
	}

	/* Now, i is the ARP table entry which we will fill with the new
     information. */
	uip_ipaddr_copy( &tabptr->ipaddr, ipaddr );
    dd5a:	687b      	ldr	r3, [r7, #4]
    dd5c:	781b      	ldrb	r3, [r3, #0]
    dd5e:	7023      	strb	r3, [r4, #0]
    dd60:	687b      	ldr	r3, [r7, #4]
    dd62:	785b      	ldrb	r3, [r3, #1]
    dd64:	7063      	strb	r3, [r4, #1]
    dd66:	687b      	ldr	r3, [r7, #4]
    dd68:	789b      	ldrb	r3, [r3, #2]
    dd6a:	70a3      	strb	r3, [r4, #2]
    dd6c:	687b      	ldr	r3, [r7, #4]
    dd6e:	78db      	ldrb	r3, [r3, #3]
    dd70:	70e3      	strb	r3, [r4, #3]
	memcpy( tabptr->ethaddr.addr, ethaddr->addr, 6 );
    dd72:	f104 0204 	add.w	r2, r4, #4
    dd76:	683b      	ldr	r3, [r7, #0]
    dd78:	4610      	mov	r0, r2
    dd7a:	4619      	mov	r1, r3
    dd7c:	f04f 0206 	mov.w	r2, #6
    dd80:	f007 fb58 	bl	15434 <memcpy>
	tabptr->time = arptime;
    dd84:	f642 73ca 	movw	r3, #12234	; 0x2fca
    dd88:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dd8c:	781b      	ldrb	r3, [r3, #0]
    dd8e:	72a3      	strb	r3, [r4, #10]
}
    dd90:	f107 070c 	add.w	r7, r7, #12
    dd94:	46bd      	mov	sp, r7
    dd96:	bd90      	pop	{r4, r7, pc}

0000dd98 <uip_arp_arpin>:
 * global variable uip_len.
 */

/*-----------------------------------------------------------------------------------*/
void uip_arp_arpin( void )
{
    dd98:	b580      	push	{r7, lr}
    dd9a:	af00      	add	r7, sp, #0
	if( uip_len < sizeof(struct arp_hdr) )
    dd9c:	f64a 4314 	movw	r3, #44052	; 0xac14
    dda0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dda4:	881b      	ldrh	r3, [r3, #0]
    dda6:	2b29      	cmp	r3, #41	; 0x29
    dda8:	d807      	bhi.n	ddba <uip_arp_arpin+0x22>
	{
		uip_len = 0;
    ddaa:	f64a 4314 	movw	r3, #44052	; 0xac14
    ddae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ddb2:	f04f 0200 	mov.w	r2, #0
    ddb6:	801a      	strh	r2, [r3, #0]
		return;
    ddb8:	e170      	b.n	e09c <uip_arp_arpin+0x304>
	}

	uip_len = 0;
    ddba:	f64a 4314 	movw	r3, #44052	; 0xac14
    ddbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ddc2:	f04f 0200 	mov.w	r2, #0
    ddc6:	801a      	strh	r2, [r3, #0]

	switch( BUF->opcode )
    ddc8:	f240 6370 	movw	r3, #1648	; 0x670
    ddcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ddd0:	681b      	ldr	r3, [r3, #0]
    ddd2:	7d1a      	ldrb	r2, [r3, #20]
    ddd4:	7d5b      	ldrb	r3, [r3, #21]
    ddd6:	ea4f 2303 	mov.w	r3, r3, lsl #8
    ddda:	ea43 0302 	orr.w	r3, r3, r2
    ddde:	b29b      	uxth	r3, r3
    dde0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    dde4:	d004      	beq.n	ddf0 <uip_arp_arpin+0x58>
    dde6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    ddea:	f000 8112 	beq.w	e012 <uip_arp_arpin+0x27a>
			}

			break;
	}

	return;
    ddee:	e155      	b.n	e09c <uip_arp_arpin+0x304>
			/*    if(BUF->dipaddr[0] == uip_hostaddr[0] &&
	  		BUF->dipaddr[1] == uip_hostaddr[1]) {*/

			//PRINTF( "uip_arp_arpin: request for %d.%d.%d.%d (we are %d.%d.%d.%d)\n", BUF->dipaddr.u8[0], BUF->dipaddr.u8[1], BUF->dipaddr.u8[2],			
			//BUF->dipaddr.u8[3], uip_hostaddr.u8[0], uip_hostaddr.u8[1], uip_hostaddr.u8[2], uip_hostaddr.u8[3] );
			if( uip_ipaddr_cmp(&BUF->dipaddr, &uip_hostaddr) )
    ddf0:	f240 6370 	movw	r3, #1648	; 0x670
    ddf4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ddf8:	681b      	ldr	r3, [r3, #0]
    ddfa:	f893 2026 	ldrb.w	r2, [r3, #38]	; 0x26
    ddfe:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
    de02:	ea4f 2303 	mov.w	r3, r3, lsl #8
    de06:	ea43 0302 	orr.w	r3, r3, r2
    de0a:	b29a      	uxth	r2, r3
    de0c:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    de10:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de14:	881b      	ldrh	r3, [r3, #0]
    de16:	429a      	cmp	r2, r3
    de18:	f040 8138 	bne.w	e08c <uip_arp_arpin+0x2f4>
    de1c:	f240 6370 	movw	r3, #1648	; 0x670
    de20:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de24:	681b      	ldr	r3, [r3, #0]
    de26:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
    de2a:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
    de2e:	ea4f 2303 	mov.w	r3, r3, lsl #8
    de32:	ea43 0302 	orr.w	r3, r3, r2
    de36:	b29a      	uxth	r2, r3
    de38:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    de3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de40:	885b      	ldrh	r3, [r3, #2]
    de42:	429a      	cmp	r2, r3
    de44:	f040 8124 	bne.w	e090 <uip_arp_arpin+0x2f8>
			{
				/* First, we register the one who made the request in our ARP
				table, since it is likely that we will do more communication
				with this host in the future. */
				uip_arp_update( &BUF->sipaddr, &BUF->shwaddr );
    de48:	f240 6370 	movw	r3, #1648	; 0x670
    de4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de50:	681b      	ldr	r3, [r3, #0]
    de52:	f103 021c 	add.w	r2, r3, #28
    de56:	f240 6370 	movw	r3, #1648	; 0x670
    de5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de5e:	681b      	ldr	r3, [r3, #0]
    de60:	f103 0316 	add.w	r3, r3, #22
    de64:	4610      	mov	r0, r2
    de66:	4619      	mov	r1, r3
    de68:	f7ff fe4e 	bl	db08 <uip_arp_update>

				BUF->opcode = HTONS( ARP_REPLY );
    de6c:	f240 6370 	movw	r3, #1648	; 0x670
    de70:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de74:	681b      	ldr	r3, [r3, #0]
    de76:	f04f 0200 	mov.w	r2, #0
    de7a:	751a      	strb	r2, [r3, #20]
    de7c:	f04f 0200 	mov.w	r2, #0
    de80:	f042 0202 	orr.w	r2, r2, #2
    de84:	755a      	strb	r2, [r3, #21]

				memcpy( BUF->dhwaddr.addr, BUF->shwaddr.addr, 6 );
    de86:	f240 6370 	movw	r3, #1648	; 0x670
    de8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de8e:	681b      	ldr	r3, [r3, #0]
    de90:	f103 0220 	add.w	r2, r3, #32
    de94:	f240 6370 	movw	r3, #1648	; 0x670
    de98:	f2c2 0300 	movt	r3, #8192	; 0x2000
    de9c:	681b      	ldr	r3, [r3, #0]
    de9e:	f103 0316 	add.w	r3, r3, #22
    dea2:	4610      	mov	r0, r2
    dea4:	4619      	mov	r1, r3
    dea6:	f04f 0206 	mov.w	r2, #6
    deaa:	f007 fac3 	bl	15434 <memcpy>
				memcpy( BUF->shwaddr.addr, uip_ethaddr.addr, 6 );
    deae:	f240 6370 	movw	r3, #1648	; 0x670
    deb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    deb6:	681b      	ldr	r3, [r3, #0]
    deb8:	f103 0316 	add.w	r3, r3, #22
    debc:	4618      	mov	r0, r3
    debe:	f642 714c 	movw	r1, #12108	; 0x2f4c
    dec2:	f2c2 0100 	movt	r1, #8192	; 0x2000
    dec6:	f04f 0206 	mov.w	r2, #6
    deca:	f007 fab3 	bl	15434 <memcpy>
				memcpy( BUF->ethhdr.src.addr, uip_ethaddr.addr, 6 );
    dece:	f240 6370 	movw	r3, #1648	; 0x670
    ded2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ded6:	681b      	ldr	r3, [r3, #0]
    ded8:	f103 0306 	add.w	r3, r3, #6
    dedc:	4618      	mov	r0, r3
    dede:	f642 714c 	movw	r1, #12108	; 0x2f4c
    dee2:	f2c2 0100 	movt	r1, #8192	; 0x2000
    dee6:	f04f 0206 	mov.w	r2, #6
    deea:	f007 faa3 	bl	15434 <memcpy>
				memcpy( BUF->ethhdr.dest.addr, BUF->dhwaddr.addr, 6 );
    deee:	f240 6370 	movw	r3, #1648	; 0x670
    def2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    def6:	681b      	ldr	r3, [r3, #0]
    def8:	461a      	mov	r2, r3
    defa:	f240 6370 	movw	r3, #1648	; 0x670
    defe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    df02:	681b      	ldr	r3, [r3, #0]
    df04:	f103 0320 	add.w	r3, r3, #32
    df08:	4610      	mov	r0, r2
    df0a:	4619      	mov	r1, r3
    df0c:	f04f 0206 	mov.w	r2, #6
    df10:	f007 fa90 	bl	15434 <memcpy>

				uip_ipaddr_copy( &BUF->dipaddr, &BUF->sipaddr );
    df14:	f240 6370 	movw	r3, #1648	; 0x670
    df18:	f2c2 0300 	movt	r3, #8192	; 0x2000
    df1c:	681b      	ldr	r3, [r3, #0]
    df1e:	461a      	mov	r2, r3
    df20:	f240 6370 	movw	r3, #1648	; 0x670
    df24:	f2c2 0300 	movt	r3, #8192	; 0x2000
    df28:	681b      	ldr	r3, [r3, #0]
    df2a:	7f1b      	ldrb	r3, [r3, #28]
    df2c:	f882 3026 	strb.w	r3, [r2, #38]	; 0x26
    df30:	f240 6370 	movw	r3, #1648	; 0x670
    df34:	f2c2 0300 	movt	r3, #8192	; 0x2000
    df38:	681b      	ldr	r3, [r3, #0]
    df3a:	461a      	mov	r2, r3
    df3c:	f240 6370 	movw	r3, #1648	; 0x670
    df40:	f2c2 0300 	movt	r3, #8192	; 0x2000
    df44:	681b      	ldr	r3, [r3, #0]
    df46:	7f5b      	ldrb	r3, [r3, #29]
    df48:	f882 3027 	strb.w	r3, [r2, #39]	; 0x27
    df4c:	f240 6370 	movw	r3, #1648	; 0x670
    df50:	f2c2 0300 	movt	r3, #8192	; 0x2000
    df54:	681b      	ldr	r3, [r3, #0]
    df56:	461a      	mov	r2, r3
    df58:	f240 6370 	movw	r3, #1648	; 0x670
    df5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    df60:	681b      	ldr	r3, [r3, #0]
    df62:	7f9b      	ldrb	r3, [r3, #30]
    df64:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
    df68:	f240 6370 	movw	r3, #1648	; 0x670
    df6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    df70:	681b      	ldr	r3, [r3, #0]
    df72:	461a      	mov	r2, r3
    df74:	f240 6370 	movw	r3, #1648	; 0x670
    df78:	f2c2 0300 	movt	r3, #8192	; 0x2000
    df7c:	681b      	ldr	r3, [r3, #0]
    df7e:	7fdb      	ldrb	r3, [r3, #31]
    df80:	f882 3029 	strb.w	r3, [r2, #41]	; 0x29
				uip_ipaddr_copy( &BUF->sipaddr, &uip_hostaddr );
    df84:	f240 6370 	movw	r3, #1648	; 0x670
    df88:	f2c2 0300 	movt	r3, #8192	; 0x2000
    df8c:	681b      	ldr	r3, [r3, #0]
    df8e:	461a      	mov	r2, r3
    df90:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    df94:	f2c2 0300 	movt	r3, #8192	; 0x2000
    df98:	781b      	ldrb	r3, [r3, #0]
    df9a:	7713      	strb	r3, [r2, #28]
    df9c:	f240 6370 	movw	r3, #1648	; 0x670
    dfa0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dfa4:	681b      	ldr	r3, [r3, #0]
    dfa6:	461a      	mov	r2, r3
    dfa8:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    dfac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dfb0:	785b      	ldrb	r3, [r3, #1]
    dfb2:	7753      	strb	r3, [r2, #29]
    dfb4:	f240 6370 	movw	r3, #1648	; 0x670
    dfb8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dfbc:	681b      	ldr	r3, [r3, #0]
    dfbe:	461a      	mov	r2, r3
    dfc0:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    dfc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dfc8:	789b      	ldrb	r3, [r3, #2]
    dfca:	7793      	strb	r3, [r2, #30]
    dfcc:	f240 6370 	movw	r3, #1648	; 0x670
    dfd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dfd4:	681b      	ldr	r3, [r3, #0]
    dfd6:	461a      	mov	r2, r3
    dfd8:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    dfdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dfe0:	78db      	ldrb	r3, [r3, #3]
    dfe2:	77d3      	strb	r3, [r2, #31]

				BUF->ethhdr.type = HTONS( UIP_ETHTYPE_ARP );
    dfe4:	f240 6370 	movw	r3, #1648	; 0x670
    dfe8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    dfec:	681b      	ldr	r3, [r3, #0]
    dfee:	f04f 0200 	mov.w	r2, #0
    dff2:	f042 0208 	orr.w	r2, r2, #8
    dff6:	731a      	strb	r2, [r3, #12]
    dff8:	f04f 0200 	mov.w	r2, #0
    dffc:	f042 0206 	orr.w	r2, r2, #6
    e000:	735a      	strb	r2, [r3, #13]
				uip_len = sizeof( struct arp_hdr );
    e002:	f64a 4314 	movw	r3, #44052	; 0xac14
    e006:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e00a:	f04f 022a 	mov.w	r2, #42	; 0x2a
    e00e:	801a      	strh	r2, [r3, #0]
			}

			break;
    e010:	e03f      	b.n	e092 <uip_arp_arpin+0x2fa>

		case HTONS( ARP_REPLY ):
			/* ARP reply. We insert or update the ARP table if it was meant
			for us. */
			if( uip_ipaddr_cmp(&BUF->dipaddr, &uip_hostaddr) )
    e012:	f240 6370 	movw	r3, #1648	; 0x670
    e016:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e01a:	681b      	ldr	r3, [r3, #0]
    e01c:	f893 2026 	ldrb.w	r2, [r3, #38]	; 0x26
    e020:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
    e024:	ea4f 2303 	mov.w	r3, r3, lsl #8
    e028:	ea43 0302 	orr.w	r3, r3, r2
    e02c:	b29a      	uxth	r2, r3
    e02e:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    e032:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e036:	881b      	ldrh	r3, [r3, #0]
    e038:	429a      	cmp	r2, r3
    e03a:	d12c      	bne.n	e096 <uip_arp_arpin+0x2fe>
    e03c:	f240 6370 	movw	r3, #1648	; 0x670
    e040:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e044:	681b      	ldr	r3, [r3, #0]
    e046:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
    e04a:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
    e04e:	ea4f 2303 	mov.w	r3, r3, lsl #8
    e052:	ea43 0302 	orr.w	r3, r3, r2
    e056:	b29a      	uxth	r2, r3
    e058:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    e05c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e060:	885b      	ldrh	r3, [r3, #2]
    e062:	429a      	cmp	r2, r3
    e064:	d119      	bne.n	e09a <uip_arp_arpin+0x302>
			{
				uip_arp_update( &BUF->sipaddr, &BUF->shwaddr );
    e066:	f240 6370 	movw	r3, #1648	; 0x670
    e06a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e06e:	681b      	ldr	r3, [r3, #0]
    e070:	f103 021c 	add.w	r2, r3, #28
    e074:	f240 6370 	movw	r3, #1648	; 0x670
    e078:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e07c:	681b      	ldr	r3, [r3, #0]
    e07e:	f103 0316 	add.w	r3, r3, #22
    e082:	4610      	mov	r0, r2
    e084:	4619      	mov	r1, r3
    e086:	f7ff fd3f 	bl	db08 <uip_arp_update>
			}

			break;
	}

	return;
    e08a:	e007      	b.n	e09c <uip_arp_arpin+0x304>

				BUF->ethhdr.type = HTONS( UIP_ETHTYPE_ARP );
				uip_len = sizeof( struct arp_hdr );
			}

			break;
    e08c:	bf00      	nop
    e08e:	e000      	b.n	e092 <uip_arp_arpin+0x2fa>
    e090:	bf00      	nop
			}

			break;
	}

	return;
    e092:	bf00      	nop
    e094:	e002      	b.n	e09c <uip_arp_arpin+0x304>
    e096:	bf00      	nop
    e098:	e000      	b.n	e09c <uip_arp_arpin+0x304>
    e09a:	bf00      	nop
}
    e09c:	bd80      	pop	{r7, pc}
    e09e:	bf00      	nop

0000e0a0 <uip_arp_out>:
 * uip_len.
 */

/*-----------------------------------------------------------------------------------*/
void uip_arp_out( void )
{
    e0a0:	b580      	push	{r7, lr}
    e0a2:	b082      	sub	sp, #8
    e0a4:	af00      	add	r7, sp, #0

     If not ARP table entry is found, we overwrite the original IP
     packet with an ARP request for the IP address. */

	/* First check if destination is a local broadcast. */
	if( uip_ipaddr_cmp(&IPBUF->destipaddr, &uip_broadcast_addr) )
    e0a6:	f240 6370 	movw	r3, #1648	; 0x670
    e0aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e0ae:	681b      	ldr	r3, [r3, #0]
    e0b0:	7f9a      	ldrb	r2, [r3, #30]
    e0b2:	7fdb      	ldrb	r3, [r3, #31]
    e0b4:	ea4f 2303 	mov.w	r3, r3, lsl #8
    e0b8:	ea43 0302 	orr.w	r3, r3, r2
    e0bc:	b29a      	uxth	r2, r3
    e0be:	f24d 1320 	movw	r3, #53536	; 0xd120
    e0c2:	f2c0 0301 	movt	r3, #1
    e0c6:	881b      	ldrh	r3, [r3, #0]
    e0c8:	429a      	cmp	r2, r3
    e0ca:	d123      	bne.n	e114 <uip_arp_out+0x74>
    e0cc:	f240 6370 	movw	r3, #1648	; 0x670
    e0d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e0d4:	681b      	ldr	r3, [r3, #0]
    e0d6:	f893 2020 	ldrb.w	r2, [r3, #32]
    e0da:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    e0de:	ea4f 2303 	mov.w	r3, r3, lsl #8
    e0e2:	ea43 0302 	orr.w	r3, r3, r2
    e0e6:	b29a      	uxth	r2, r3
    e0e8:	f24d 1320 	movw	r3, #53536	; 0xd120
    e0ec:	f2c0 0301 	movt	r3, #1
    e0f0:	885b      	ldrh	r3, [r3, #2]
    e0f2:	429a      	cmp	r2, r3
    e0f4:	d10e      	bne.n	e114 <uip_arp_out+0x74>
	{
		memcpy( IPBUF->ethhdr.dest.addr, broadcast_ethaddr.addr, 6 );
    e0f6:	f240 6370 	movw	r3, #1648	; 0x670
    e0fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e0fe:	681b      	ldr	r3, [r3, #0]
    e100:	4618      	mov	r0, r3
    e102:	f24d 1128 	movw	r1, #53544	; 0xd128
    e106:	f2c0 0101 	movt	r1, #1
    e10a:	f04f 0206 	mov.w	r2, #6
    e10e:	f007 f991 	bl	15434 <memcpy>

     If not ARP table entry is found, we overwrite the original IP
     packet with an ARP request for the IP address. */

	/* First check if destination is a local broadcast. */
	if( uip_ipaddr_cmp(&IPBUF->destipaddr, &uip_broadcast_addr) )
    e112:	e1db      	b.n	e4cc <uip_arp_out+0x42c>
		memcpy( IPBUF->ethhdr.dest.addr, broadcast_ethaddr.addr, 6 );
	}
	else
	{
		/* Check if the destination address is on the local network. */
		if( !uip_ipaddr_maskcmp(&IPBUF->destipaddr, &uip_hostaddr, &uip_netmask) )
    e114:	f240 6370 	movw	r3, #1648	; 0x670
    e118:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e11c:	681b      	ldr	r3, [r3, #0]
    e11e:	f103 031e 	add.w	r3, r3, #30
    e122:	881a      	ldrh	r2, [r3, #0]
    e124:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    e128:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e12c:	881b      	ldrh	r3, [r3, #0]
    e12e:	ea82 0303 	eor.w	r3, r2, r3
    e132:	b29a      	uxth	r2, r3
    e134:	f64c 4398 	movw	r3, #52376	; 0xcc98
    e138:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e13c:	881b      	ldrh	r3, [r3, #0]
    e13e:	ea02 0303 	and.w	r3, r2, r3
    e142:	b29b      	uxth	r3, r3
    e144:	2b00      	cmp	r3, #0
    e146:	d113      	bne.n	e170 <uip_arp_out+0xd0>
    e148:	f240 6370 	movw	r3, #1648	; 0x670
    e14c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e150:	681b      	ldr	r3, [r3, #0]
    e152:	f103 0320 	add.w	r3, r3, #32
    e156:	881a      	ldrh	r2, [r3, #0]
    e158:	4b52      	ldr	r3, [pc, #328]	; (e2a4 <uip_arp_out+0x204>)
    e15a:	881b      	ldrh	r3, [r3, #0]
    e15c:	ea82 0303 	eor.w	r3, r2, r3
    e160:	b29a      	uxth	r2, r3
    e162:	4b51      	ldr	r3, [pc, #324]	; (e2a8 <uip_arp_out+0x208>)
    e164:	881b      	ldrh	r3, [r3, #0]
    e166:	ea02 0303 	and.w	r3, r2, r3
    e16a:	b29b      	uxth	r3, r3
    e16c:	2b00      	cmp	r3, #0
    e16e:	d028      	beq.n	e1c2 <uip_arp_out+0x122>
		{
			/* Destination address was not on the local network, so we need to
	 use the default router's IP address instead of the destination
	 address when determining the MAC address. */
			uip_ipaddr_copy( &ipaddr, &uip_draddr );
    e170:	f64c 435c 	movw	r3, #52316	; 0xcc5c
    e174:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e178:	781a      	ldrb	r2, [r3, #0]
    e17a:	f642 73c4 	movw	r3, #12228	; 0x2fc4
    e17e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e182:	701a      	strb	r2, [r3, #0]
    e184:	f64c 435c 	movw	r3, #52316	; 0xcc5c
    e188:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e18c:	785a      	ldrb	r2, [r3, #1]
    e18e:	f642 73c4 	movw	r3, #12228	; 0x2fc4
    e192:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e196:	705a      	strb	r2, [r3, #1]
    e198:	f64c 435c 	movw	r3, #52316	; 0xcc5c
    e19c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e1a0:	789a      	ldrb	r2, [r3, #2]
    e1a2:	f642 73c4 	movw	r3, #12228	; 0x2fc4
    e1a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e1aa:	709a      	strb	r2, [r3, #2]
    e1ac:	f64c 435c 	movw	r3, #52316	; 0xcc5c
    e1b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e1b4:	78da      	ldrb	r2, [r3, #3]
    e1b6:	f642 73c4 	movw	r3, #12228	; 0x2fc4
    e1ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e1be:	70da      	strb	r2, [r3, #3]
		memcpy( IPBUF->ethhdr.dest.addr, broadcast_ethaddr.addr, 6 );
	}
	else
	{
		/* Check if the destination address is on the local network. */
		if( !uip_ipaddr_maskcmp(&IPBUF->destipaddr, &uip_hostaddr, &uip_netmask) )
    e1c0:	e02d      	b.n	e21e <uip_arp_out+0x17e>
			uip_ipaddr_copy( &ipaddr, &uip_draddr );
		}
		else
		{
			/* Else, we use the destination IP address. */
			uip_ipaddr_copy( &ipaddr, &IPBUF->destipaddr );
    e1c2:	f240 6370 	movw	r3, #1648	; 0x670
    e1c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e1ca:	681b      	ldr	r3, [r3, #0]
    e1cc:	7f9a      	ldrb	r2, [r3, #30]
    e1ce:	f642 73c4 	movw	r3, #12228	; 0x2fc4
    e1d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e1d6:	701a      	strb	r2, [r3, #0]
    e1d8:	f240 6370 	movw	r3, #1648	; 0x670
    e1dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e1e0:	681b      	ldr	r3, [r3, #0]
    e1e2:	7fda      	ldrb	r2, [r3, #31]
    e1e4:	f642 73c4 	movw	r3, #12228	; 0x2fc4
    e1e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e1ec:	705a      	strb	r2, [r3, #1]
    e1ee:	f240 6370 	movw	r3, #1648	; 0x670
    e1f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e1f6:	681b      	ldr	r3, [r3, #0]
    e1f8:	f893 2020 	ldrb.w	r2, [r3, #32]
    e1fc:	f642 73c4 	movw	r3, #12228	; 0x2fc4
    e200:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e204:	709a      	strb	r2, [r3, #2]
    e206:	f240 6370 	movw	r3, #1648	; 0x670
    e20a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e20e:	681b      	ldr	r3, [r3, #0]
    e210:	f893 2021 	ldrb.w	r2, [r3, #33]	; 0x21
    e214:	f642 73c4 	movw	r3, #12228	; 0x2fc4
    e218:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e21c:	70da      	strb	r2, [r3, #3]
		}

		for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    e21e:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    e222:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e226:	f04f 0200 	mov.w	r2, #0
    e22a:	701a      	strb	r2, [r3, #0]
    e22c:	e031      	b.n	e292 <uip_arp_out+0x1f2>
		{
			tabptr = &arp_table[i];
    e22e:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    e232:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e236:	781b      	ldrb	r3, [r3, #0]
    e238:	461a      	mov	r2, r3
    e23a:	4613      	mov	r3, r2
    e23c:	ea4f 0343 	mov.w	r3, r3, lsl #1
    e240:	4413      	add	r3, r2
    e242:	ea4f 0383 	mov.w	r3, r3, lsl #2
    e246:	461a      	mov	r2, r3
    e248:	f642 7364 	movw	r3, #12132	; 0x2f64
    e24c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e250:	4413      	add	r3, r2
    e252:	607b      	str	r3, [r7, #4]
			if( uip_ipaddr_cmp(&ipaddr, &tabptr->ipaddr) )
    e254:	f642 73c4 	movw	r3, #12228	; 0x2fc4
    e258:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e25c:	881a      	ldrh	r2, [r3, #0]
    e25e:	687b      	ldr	r3, [r7, #4]
    e260:	881b      	ldrh	r3, [r3, #0]
    e262:	429a      	cmp	r2, r3
    e264:	d108      	bne.n	e278 <uip_arp_out+0x1d8>
    e266:	f642 73c4 	movw	r3, #12228	; 0x2fc4
    e26a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e26e:	885a      	ldrh	r2, [r3, #2]
    e270:	687b      	ldr	r3, [r7, #4]
    e272:	885b      	ldrh	r3, [r3, #2]
    e274:	429a      	cmp	r2, r3
    e276:	d019      	beq.n	e2ac <uip_arp_out+0x20c>
		{
			/* Else, we use the destination IP address. */
			uip_ipaddr_copy( &ipaddr, &IPBUF->destipaddr );
		}

		for( i = 0; i < UIP_ARPTAB_SIZE; ++i )
    e278:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    e27c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e280:	781b      	ldrb	r3, [r3, #0]
    e282:	f103 0301 	add.w	r3, r3, #1
    e286:	b2da      	uxtb	r2, r3
    e288:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    e28c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e290:	701a      	strb	r2, [r3, #0]
    e292:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    e296:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e29a:	781b      	ldrb	r3, [r3, #0]
    e29c:	2b07      	cmp	r3, #7
    e29e:	d9c6      	bls.n	e22e <uip_arp_out+0x18e>
    e2a0:	e005      	b.n	e2ae <uip_arp_out+0x20e>
    e2a2:	bf00      	nop
    e2a4:	2000cc9e 	.word	0x2000cc9e
    e2a8:	2000cc9a 	.word	0x2000cc9a
		{
			tabptr = &arp_table[i];
			if( uip_ipaddr_cmp(&ipaddr, &tabptr->ipaddr) )
			{
				break;
    e2ac:	bf00      	nop
			}
		}

		if( i == UIP_ARPTAB_SIZE )
    e2ae:	f642 73c8 	movw	r3, #12232	; 0x2fc8
    e2b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e2b6:	781b      	ldrb	r3, [r3, #0]
    e2b8:	2b08      	cmp	r3, #8
    e2ba:	f040 80f8 	bne.w	e4ae <uip_arp_out+0x40e>
		{
			/* The destination address was not in our ARP table, so we
	 overwrite the IP packet with an ARP request. */
			memset( BUF->ethhdr.dest.addr, 0xff, 6 );
    e2be:	f240 6370 	movw	r3, #1648	; 0x670
    e2c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e2c6:	681b      	ldr	r3, [r3, #0]
    e2c8:	4618      	mov	r0, r3
    e2ca:	f04f 01ff 	mov.w	r1, #255	; 0xff
    e2ce:	f04f 0206 	mov.w	r2, #6
    e2d2:	f007 f977 	bl	155c4 <memset>
			memset( BUF->dhwaddr.addr, 0x00, 6 );
    e2d6:	f240 6370 	movw	r3, #1648	; 0x670
    e2da:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e2de:	681b      	ldr	r3, [r3, #0]
    e2e0:	f103 0320 	add.w	r3, r3, #32
    e2e4:	4618      	mov	r0, r3
    e2e6:	f04f 0100 	mov.w	r1, #0
    e2ea:	f04f 0206 	mov.w	r2, #6
    e2ee:	f007 f969 	bl	155c4 <memset>
			memcpy( BUF->ethhdr.src.addr, uip_ethaddr.addr, 6 );
    e2f2:	f240 6370 	movw	r3, #1648	; 0x670
    e2f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e2fa:	681b      	ldr	r3, [r3, #0]
    e2fc:	f103 0306 	add.w	r3, r3, #6
    e300:	4618      	mov	r0, r3
    e302:	f642 714c 	movw	r1, #12108	; 0x2f4c
    e306:	f2c2 0100 	movt	r1, #8192	; 0x2000
    e30a:	f04f 0206 	mov.w	r2, #6
    e30e:	f007 f891 	bl	15434 <memcpy>
			memcpy( BUF->shwaddr.addr, uip_ethaddr.addr, 6 );
    e312:	f240 6370 	movw	r3, #1648	; 0x670
    e316:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e31a:	681b      	ldr	r3, [r3, #0]
    e31c:	f103 0316 	add.w	r3, r3, #22
    e320:	4618      	mov	r0, r3
    e322:	f642 714c 	movw	r1, #12108	; 0x2f4c
    e326:	f2c2 0100 	movt	r1, #8192	; 0x2000
    e32a:	f04f 0206 	mov.w	r2, #6
    e32e:	f007 f881 	bl	15434 <memcpy>

			uip_ipaddr_copy( &BUF->dipaddr, &ipaddr );
    e332:	f240 6370 	movw	r3, #1648	; 0x670
    e336:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e33a:	681b      	ldr	r3, [r3, #0]
    e33c:	461a      	mov	r2, r3
    e33e:	f642 73c4 	movw	r3, #12228	; 0x2fc4
    e342:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e346:	781b      	ldrb	r3, [r3, #0]
    e348:	f882 3026 	strb.w	r3, [r2, #38]	; 0x26
    e34c:	f240 6370 	movw	r3, #1648	; 0x670
    e350:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e354:	681b      	ldr	r3, [r3, #0]
    e356:	461a      	mov	r2, r3
    e358:	f642 73c4 	movw	r3, #12228	; 0x2fc4
    e35c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e360:	785b      	ldrb	r3, [r3, #1]
    e362:	f882 3027 	strb.w	r3, [r2, #39]	; 0x27
    e366:	f240 6370 	movw	r3, #1648	; 0x670
    e36a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e36e:	681b      	ldr	r3, [r3, #0]
    e370:	461a      	mov	r2, r3
    e372:	f642 73c4 	movw	r3, #12228	; 0x2fc4
    e376:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e37a:	789b      	ldrb	r3, [r3, #2]
    e37c:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
    e380:	f240 6370 	movw	r3, #1648	; 0x670
    e384:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e388:	681b      	ldr	r3, [r3, #0]
    e38a:	461a      	mov	r2, r3
    e38c:	f642 73c4 	movw	r3, #12228	; 0x2fc4
    e390:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e394:	78db      	ldrb	r3, [r3, #3]
    e396:	f882 3029 	strb.w	r3, [r2, #41]	; 0x29
			uip_ipaddr_copy( &BUF->sipaddr, &uip_hostaddr );
    e39a:	f240 6370 	movw	r3, #1648	; 0x670
    e39e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e3a2:	681b      	ldr	r3, [r3, #0]
    e3a4:	461a      	mov	r2, r3
    e3a6:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    e3aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e3ae:	781b      	ldrb	r3, [r3, #0]
    e3b0:	7713      	strb	r3, [r2, #28]
    e3b2:	f240 6370 	movw	r3, #1648	; 0x670
    e3b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e3ba:	681b      	ldr	r3, [r3, #0]
    e3bc:	461a      	mov	r2, r3
    e3be:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    e3c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e3c6:	785b      	ldrb	r3, [r3, #1]
    e3c8:	7753      	strb	r3, [r2, #29]
    e3ca:	f240 6370 	movw	r3, #1648	; 0x670
    e3ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e3d2:	681b      	ldr	r3, [r3, #0]
    e3d4:	461a      	mov	r2, r3
    e3d6:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    e3da:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e3de:	789b      	ldrb	r3, [r3, #2]
    e3e0:	7793      	strb	r3, [r2, #30]
    e3e2:	f240 6370 	movw	r3, #1648	; 0x670
    e3e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e3ea:	681b      	ldr	r3, [r3, #0]
    e3ec:	461a      	mov	r2, r3
    e3ee:	f64c 439c 	movw	r3, #52380	; 0xcc9c
    e3f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e3f6:	78db      	ldrb	r3, [r3, #3]
    e3f8:	77d3      	strb	r3, [r2, #31]
			BUF->opcode = HTONS( ARP_REQUEST ); /* ARP request. */
    e3fa:	f240 6370 	movw	r3, #1648	; 0x670
    e3fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e402:	681b      	ldr	r3, [r3, #0]
    e404:	f04f 0200 	mov.w	r2, #0
    e408:	751a      	strb	r2, [r3, #20]
    e40a:	f04f 0200 	mov.w	r2, #0
    e40e:	f042 0201 	orr.w	r2, r2, #1
    e412:	755a      	strb	r2, [r3, #21]
			BUF->hwtype = HTONS( ARP_HWTYPE_ETH );
    e414:	f240 6370 	movw	r3, #1648	; 0x670
    e418:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e41c:	681b      	ldr	r3, [r3, #0]
    e41e:	f04f 0200 	mov.w	r2, #0
    e422:	739a      	strb	r2, [r3, #14]
    e424:	f04f 0200 	mov.w	r2, #0
    e428:	f042 0201 	orr.w	r2, r2, #1
    e42c:	73da      	strb	r2, [r3, #15]
			BUF->protocol = HTONS( UIP_ETHTYPE_IP );
    e42e:	f240 6370 	movw	r3, #1648	; 0x670
    e432:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e436:	681b      	ldr	r3, [r3, #0]
    e438:	f04f 0200 	mov.w	r2, #0
    e43c:	f042 0208 	orr.w	r2, r2, #8
    e440:	741a      	strb	r2, [r3, #16]
    e442:	f04f 0200 	mov.w	r2, #0
    e446:	745a      	strb	r2, [r3, #17]
			BUF->hwlen = 6;
    e448:	f240 6370 	movw	r3, #1648	; 0x670
    e44c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e450:	681b      	ldr	r3, [r3, #0]
    e452:	f04f 0206 	mov.w	r2, #6
    e456:	749a      	strb	r2, [r3, #18]
			BUF->protolen = 4;
    e458:	f240 6370 	movw	r3, #1648	; 0x670
    e45c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e460:	681b      	ldr	r3, [r3, #0]
    e462:	f04f 0204 	mov.w	r2, #4
    e466:	74da      	strb	r2, [r3, #19]
			BUF->ethhdr.type = HTONS( UIP_ETHTYPE_ARP );
    e468:	f240 6370 	movw	r3, #1648	; 0x670
    e46c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e470:	681b      	ldr	r3, [r3, #0]
    e472:	f04f 0200 	mov.w	r2, #0
    e476:	f042 0208 	orr.w	r2, r2, #8
    e47a:	731a      	strb	r2, [r3, #12]
    e47c:	f04f 0200 	mov.w	r2, #0
    e480:	f042 0206 	orr.w	r2, r2, #6
    e484:	735a      	strb	r2, [r3, #13]

			uip_appdata = &uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN];
    e486:	f240 6370 	movw	r3, #1648	; 0x670
    e48a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e48e:	681b      	ldr	r3, [r3, #0]
    e490:	f103 0236 	add.w	r2, r3, #54	; 0x36
    e494:	f64a 4324 	movw	r3, #44068	; 0xac24
    e498:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e49c:	601a      	str	r2, [r3, #0]

			uip_len = sizeof( struct arp_hdr );
    e49e:	f64a 4314 	movw	r3, #44052	; 0xac14
    e4a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e4a6:	f04f 022a 	mov.w	r2, #42	; 0x2a
    e4aa:	801a      	strh	r2, [r3, #0]
			return;
    e4ac:	e038      	b.n	e520 <uip_arp_out+0x480>
		}

		/* Build an ethernet header. */
		memcpy( IPBUF->ethhdr.dest.addr, tabptr->ethaddr.addr, 6 );
    e4ae:	f240 6370 	movw	r3, #1648	; 0x670
    e4b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e4b6:	681b      	ldr	r3, [r3, #0]
    e4b8:	461a      	mov	r2, r3
    e4ba:	687b      	ldr	r3, [r7, #4]
    e4bc:	f103 0304 	add.w	r3, r3, #4
    e4c0:	4610      	mov	r0, r2
    e4c2:	4619      	mov	r1, r3
    e4c4:	f04f 0206 	mov.w	r2, #6
    e4c8:	f006 ffb4 	bl	15434 <memcpy>
	}

	memcpy( IPBUF->ethhdr.src.addr, uip_ethaddr.addr, 6 );
    e4cc:	f240 6370 	movw	r3, #1648	; 0x670
    e4d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e4d4:	681b      	ldr	r3, [r3, #0]
    e4d6:	f103 0306 	add.w	r3, r3, #6
    e4da:	4618      	mov	r0, r3
    e4dc:	f642 714c 	movw	r1, #12108	; 0x2f4c
    e4e0:	f2c2 0100 	movt	r1, #8192	; 0x2000
    e4e4:	f04f 0206 	mov.w	r2, #6
    e4e8:	f006 ffa4 	bl	15434 <memcpy>

	IPBUF->ethhdr.type = HTONS( UIP_ETHTYPE_IP );
    e4ec:	f240 6370 	movw	r3, #1648	; 0x670
    e4f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e4f4:	681b      	ldr	r3, [r3, #0]
    e4f6:	f04f 0200 	mov.w	r2, #0
    e4fa:	f042 0208 	orr.w	r2, r2, #8
    e4fe:	731a      	strb	r2, [r3, #12]
    e500:	f04f 0200 	mov.w	r2, #0
    e504:	735a      	strb	r2, [r3, #13]

	uip_len += sizeof( struct uip_eth_hdr );
    e506:	f64a 4314 	movw	r3, #44052	; 0xac14
    e50a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e50e:	881b      	ldrh	r3, [r3, #0]
    e510:	f103 030e 	add.w	r3, r3, #14
    e514:	b29a      	uxth	r2, r3
    e516:	f64a 4314 	movw	r3, #44052	; 0xac14
    e51a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e51e:	801a      	strh	r2, [r3, #0]
}
    e520:	f107 0708 	add.w	r7, r7, #8
    e524:	46bd      	mov	sp, r7
    e526:	bd80      	pop	{r7, pc}

0000e528 <httpd_fs_strcmp>:
static u16_t	count[HTTPD_FS_NUMFILES];
#endif /* HTTPD_FS_STATISTICS */

/*-----------------------------------------------------------------------------------*/
static u8_t httpd_fs_strcmp( const char *str1, const char *str2 )
{
    e528:	b480      	push	{r7}
    e52a:	b085      	sub	sp, #20
    e52c:	af00      	add	r7, sp, #0
    e52e:	6078      	str	r0, [r7, #4]
    e530:	6039      	str	r1, [r7, #0]
	u8_t	i;
	i = 0;
    e532:	f04f 0300 	mov.w	r3, #0
    e536:	73fb      	strb	r3, [r7, #15]
loop:
	if( str2[i] == 0 || str1[i] == '\r' || str1[i] == '\n' )
    e538:	7bfa      	ldrb	r2, [r7, #15]
    e53a:	683b      	ldr	r3, [r7, #0]
    e53c:	4413      	add	r3, r2
    e53e:	781b      	ldrb	r3, [r3, #0]
    e540:	2b00      	cmp	r3, #0
    e542:	d00b      	beq.n	e55c <httpd_fs_strcmp+0x34>
    e544:	7bfa      	ldrb	r2, [r7, #15]
    e546:	687b      	ldr	r3, [r7, #4]
    e548:	4413      	add	r3, r2
    e54a:	781b      	ldrb	r3, [r3, #0]
    e54c:	2b0d      	cmp	r3, #13
    e54e:	d005      	beq.n	e55c <httpd_fs_strcmp+0x34>
    e550:	7bfa      	ldrb	r2, [r7, #15]
    e552:	687b      	ldr	r3, [r7, #4]
    e554:	4413      	add	r3, r2
    e556:	781b      	ldrb	r3, [r3, #0]
    e558:	2b0a      	cmp	r3, #10
    e55a:	d102      	bne.n	e562 <httpd_fs_strcmp+0x3a>
	{
		return 0;
    e55c:	f04f 0300 	mov.w	r3, #0
    e560:	e011      	b.n	e586 <httpd_fs_strcmp+0x5e>
	}

	if( str1[i] != str2[i] )
    e562:	7bfa      	ldrb	r2, [r7, #15]
    e564:	687b      	ldr	r3, [r7, #4]
    e566:	4413      	add	r3, r2
    e568:	781a      	ldrb	r2, [r3, #0]
    e56a:	7bf9      	ldrb	r1, [r7, #15]
    e56c:	683b      	ldr	r3, [r7, #0]
    e56e:	440b      	add	r3, r1
    e570:	781b      	ldrb	r3, [r3, #0]
    e572:	429a      	cmp	r2, r3
    e574:	d002      	beq.n	e57c <httpd_fs_strcmp+0x54>
	{
		return 1;
    e576:	f04f 0301 	mov.w	r3, #1
    e57a:	e004      	b.n	e586 <httpd_fs_strcmp+0x5e>
	}

	++i;
    e57c:	7bfb      	ldrb	r3, [r7, #15]
    e57e:	f103 0301 	add.w	r3, r3, #1
    e582:	73fb      	strb	r3, [r7, #15]
	goto loop;
    e584:	e7d8      	b.n	e538 <httpd_fs_strcmp+0x10>
}
    e586:	4618      	mov	r0, r3
    e588:	f107 0714 	add.w	r7, r7, #20
    e58c:	46bd      	mov	sp, r7
    e58e:	bc80      	pop	{r7}
    e590:	4770      	bx	lr
    e592:	bf00      	nop

0000e594 <httpd_fs_open>:

/*-----------------------------------------------------------------------------------*/
int httpd_fs_open( const char *name, struct httpd_fs_file *file )
{
    e594:	b580      	push	{r7, lr}
    e596:	b084      	sub	sp, #16
    e598:	af00      	add	r7, sp, #0
    e59a:	6078      	str	r0, [r7, #4]
    e59c:	6039      	str	r1, [r7, #0]
#if HTTPD_FS_STATISTICS
	u16_t								i = 0;
    e59e:	f04f 0300 	mov.w	r3, #0
    e5a2:	817b      	strh	r3, [r7, #10]
#endif /* HTTPD_FS_STATISTICS */
	struct httpd_fsdata_file_noconst	*f;

	for( f = ( struct httpd_fsdata_file_noconst * ) HTTPD_FS_ROOT; f != NULL; f = ( struct httpd_fsdata_file_noconst * ) f->next )
    e5a4:	f64f 03f4 	movw	r3, #63732	; 0xf8f4
    e5a8:	f2c0 0302 	movt	r3, #2
    e5ac:	60fb      	str	r3, [r7, #12]
    e5ae:	e02a      	b.n	e606 <httpd_fs_open+0x72>
	{
		if( httpd_fs_strcmp(name, f->name) == 0 )
    e5b0:	68fb      	ldr	r3, [r7, #12]
    e5b2:	685b      	ldr	r3, [r3, #4]
    e5b4:	6878      	ldr	r0, [r7, #4]
    e5b6:	4619      	mov	r1, r3
    e5b8:	f7ff ffb6 	bl	e528 <httpd_fs_strcmp>
    e5bc:	4603      	mov	r3, r0
    e5be:	2b00      	cmp	r3, #0
    e5c0:	d11a      	bne.n	e5f8 <httpd_fs_open+0x64>
		{
			file->data = f->data;
    e5c2:	68fb      	ldr	r3, [r7, #12]
    e5c4:	689a      	ldr	r2, [r3, #8]
    e5c6:	683b      	ldr	r3, [r7, #0]
    e5c8:	601a      	str	r2, [r3, #0]
			file->len = f->len;
    e5ca:	68fb      	ldr	r3, [r7, #12]
    e5cc:	68da      	ldr	r2, [r3, #12]
    e5ce:	683b      	ldr	r3, [r7, #0]
    e5d0:	605a      	str	r2, [r3, #4]
#if HTTPD_FS_STATISTICS
			++count[i];
    e5d2:	897a      	ldrh	r2, [r7, #10]
    e5d4:	f642 73cc 	movw	r3, #12236	; 0x2fcc
    e5d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e5dc:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    e5e0:	f103 0301 	add.w	r3, r3, #1
    e5e4:	b299      	uxth	r1, r3
    e5e6:	f642 73cc 	movw	r3, #12236	; 0x2fcc
    e5ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e5ee:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
#endif /* HTTPD_FS_STATISTICS */
			return 1;
    e5f2:	f04f 0301 	mov.w	r3, #1
    e5f6:	e00b      	b.n	e610 <httpd_fs_open+0x7c>
		}

#if HTTPD_FS_STATISTICS
		++i;
    e5f8:	897b      	ldrh	r3, [r7, #10]
    e5fa:	f103 0301 	add.w	r3, r3, #1
    e5fe:	817b      	strh	r3, [r7, #10]
#if HTTPD_FS_STATISTICS
	u16_t								i = 0;
#endif /* HTTPD_FS_STATISTICS */
	struct httpd_fsdata_file_noconst	*f;

	for( f = ( struct httpd_fsdata_file_noconst * ) HTTPD_FS_ROOT; f != NULL; f = ( struct httpd_fsdata_file_noconst * ) f->next )
    e600:	68fb      	ldr	r3, [r7, #12]
    e602:	681b      	ldr	r3, [r3, #0]
    e604:	60fb      	str	r3, [r7, #12]
    e606:	68fb      	ldr	r3, [r7, #12]
    e608:	2b00      	cmp	r3, #0
    e60a:	d1d1      	bne.n	e5b0 <httpd_fs_open+0x1c>
#if HTTPD_FS_STATISTICS
		++i;
#endif /* HTTPD_FS_STATISTICS */
	}

	return 0;
    e60c:	f04f 0300 	mov.w	r3, #0
}
    e610:	4618      	mov	r0, r3
    e612:	f107 0710 	add.w	r7, r7, #16
    e616:	46bd      	mov	sp, r7
    e618:	bd80      	pop	{r7, pc}
    e61a:	bf00      	nop

0000e61c <httpd_fs_init>:

/*-----------------------------------------------------------------------------------*/
void httpd_fs_init( void )
{
    e61c:	b480      	push	{r7}
    e61e:	b083      	sub	sp, #12
    e620:	af00      	add	r7, sp, #0
#if HTTPD_FS_STATISTICS
	u16_t	i;
	for( i = 0; i < HTTPD_FS_NUMFILES; i++ )
    e622:	f04f 0300 	mov.w	r3, #0
    e626:	80fb      	strh	r3, [r7, #6]
    e628:	e00c      	b.n	e644 <httpd_fs_init+0x28>
	{
		count[i] = 0;
    e62a:	88fa      	ldrh	r2, [r7, #6]
    e62c:	f642 73cc 	movw	r3, #12236	; 0x2fcc
    e630:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e634:	f04f 0100 	mov.w	r1, #0
    e638:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
/*-----------------------------------------------------------------------------------*/
void httpd_fs_init( void )
{
#if HTTPD_FS_STATISTICS
	u16_t	i;
	for( i = 0; i < HTTPD_FS_NUMFILES; i++ )
    e63c:	88fb      	ldrh	r3, [r7, #6]
    e63e:	f103 0301 	add.w	r3, r3, #1
    e642:	80fb      	strh	r3, [r7, #6]
    e644:	88fb      	ldrh	r3, [r7, #6]
    e646:	2b12      	cmp	r3, #18
    e648:	d9ef      	bls.n	e62a <httpd_fs_init+0xe>
	{
		count[i] = 0;
	}

#endif /* HTTPD_FS_STATISTICS */
}
    e64a:	f107 070c 	add.w	r7, r7, #12
    e64e:	46bd      	mov	sp, r7
    e650:	bc80      	pop	{r7}
    e652:	4770      	bx	lr

0000e654 <httpd_fs_count>:

/*-----------------------------------------------------------------------------------*/
#if HTTPD_FS_STATISTICS
u16_t httpd_fs_count( char *name )
{
    e654:	b580      	push	{r7, lr}
    e656:	b084      	sub	sp, #16
    e658:	af00      	add	r7, sp, #0
    e65a:	6078      	str	r0, [r7, #4]
	struct httpd_fsdata_file_noconst	*f;
	u16_t								i;

	i = 0;
    e65c:	f04f 0300 	mov.w	r3, #0
    e660:	81fb      	strh	r3, [r7, #14]
	for( f = ( struct httpd_fsdata_file_noconst * ) HTTPD_FS_ROOT; f != NULL; f = ( struct httpd_fsdata_file_noconst * ) f->next )
    e662:	f64f 03f4 	movw	r3, #63732	; 0xf8f4
    e666:	f2c0 0302 	movt	r3, #2
    e66a:	60bb      	str	r3, [r7, #8]
    e66c:	e017      	b.n	e69e <httpd_fs_count+0x4a>
	{
		if( httpd_fs_strcmp(name, f->name) == 0 )
    e66e:	68bb      	ldr	r3, [r7, #8]
    e670:	685b      	ldr	r3, [r3, #4]
    e672:	6878      	ldr	r0, [r7, #4]
    e674:	4619      	mov	r1, r3
    e676:	f7ff ff57 	bl	e528 <httpd_fs_strcmp>
    e67a:	4603      	mov	r3, r0
    e67c:	2b00      	cmp	r3, #0
    e67e:	d107      	bne.n	e690 <httpd_fs_count+0x3c>
		{
			return count[i];
    e680:	89fa      	ldrh	r2, [r7, #14]
    e682:	f642 73cc 	movw	r3, #12236	; 0x2fcc
    e686:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e68a:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    e68e:	e00b      	b.n	e6a8 <httpd_fs_count+0x54>
		}

		++i;
    e690:	89fb      	ldrh	r3, [r7, #14]
    e692:	f103 0301 	add.w	r3, r3, #1
    e696:	81fb      	strh	r3, [r7, #14]
{
	struct httpd_fsdata_file_noconst	*f;
	u16_t								i;

	i = 0;
	for( f = ( struct httpd_fsdata_file_noconst * ) HTTPD_FS_ROOT; f != NULL; f = ( struct httpd_fsdata_file_noconst * ) f->next )
    e698:	68bb      	ldr	r3, [r7, #8]
    e69a:	681b      	ldr	r3, [r3, #0]
    e69c:	60bb      	str	r3, [r7, #8]
    e69e:	68bb      	ldr	r3, [r7, #8]
    e6a0:	2b00      	cmp	r3, #0
    e6a2:	d1e4      	bne.n	e66e <httpd_fs_count+0x1a>
		}

		++i;
	}

	return 0;
    e6a4:	f04f 0300 	mov.w	r3, #0
}
    e6a8:	4618      	mov	r0, r3
    e6aa:	f107 0710 	add.w	r7, r7, #16
    e6ae:	46bd      	mov	sp, r7
    e6b0:	bd80      	pop	{r7, pc}
    e6b2:	bf00      	nop

0000e6b4 <generate_part_of_file>:
#define ISO_slash		0x2f
#define ISO_colon		0x3a

/*---------------------------------------------------------------------------*/
static unsigned short generate_part_of_file( void *state )
{
    e6b4:	b580      	push	{r7, lr}
    e6b6:	b084      	sub	sp, #16
    e6b8:	af00      	add	r7, sp, #0
    e6ba:	6078      	str	r0, [r7, #4]
	struct httpd_state	*s = ( struct httpd_state * ) state;
    e6bc:	687b      	ldr	r3, [r7, #4]
    e6be:	60fb      	str	r3, [r7, #12]

	if( s->file.len > uip_mss() )
    e6c0:	68fb      	ldr	r3, [r7, #12]
    e6c2:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
    e6c6:	f64a 4328 	movw	r3, #44072	; 0xac28
    e6ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e6ce:	681b      	ldr	r3, [r3, #0]
    e6d0:	8a5b      	ldrh	r3, [r3, #18]
    e6d2:	429a      	cmp	r2, r3
    e6d4:	dd0a      	ble.n	e6ec <generate_part_of_file+0x38>
	{
		s->len = uip_mss();
    e6d6:	f64a 4328 	movw	r3, #44072	; 0xac28
    e6da:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e6de:	681b      	ldr	r3, [r3, #0]
    e6e0:	8a5b      	ldrh	r3, [r3, #18]
    e6e2:	461a      	mov	r2, r3
    e6e4:	68fb      	ldr	r3, [r7, #12]
    e6e6:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    e6ea:	e005      	b.n	e6f8 <generate_part_of_file+0x44>
	}
	else
	{
		s->len = s->file.len;
    e6ec:	68fb      	ldr	r3, [r7, #12]
    e6ee:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
    e6f2:	68fb      	ldr	r3, [r7, #12]
    e6f4:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	}

	memcpy( uip_appdata, s->file.data, s->len );
    e6f8:	f64a 4324 	movw	r3, #44068	; 0xac24
    e6fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e700:	6819      	ldr	r1, [r3, #0]
    e702:	68fb      	ldr	r3, [r7, #12]
    e704:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
    e708:	68fb      	ldr	r3, [r7, #12]
    e70a:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    e70e:	4608      	mov	r0, r1
    e710:	4611      	mov	r1, r2
    e712:	461a      	mov	r2, r3
    e714:	f006 fe8e 	bl	15434 <memcpy>

	return s->len;
    e718:	68fb      	ldr	r3, [r7, #12]
    e71a:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    e71e:	b29b      	uxth	r3, r3
}
    e720:	4618      	mov	r0, r3
    e722:	f107 0710 	add.w	r7, r7, #16
    e726:	46bd      	mov	sp, r7
    e728:	bd80      	pop	{r7, pc}
    e72a:	bf00      	nop

0000e72c <send_file>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( send_file ( struct httpd_state *s ) )
{
    e72c:	b580      	push	{r7, lr}
    e72e:	b084      	sub	sp, #16
    e730:	af00      	add	r7, sp, #0
    e732:	6078      	str	r0, [r7, #4]
	PSOCK_BEGIN( &s->sout );
    e734:	f04f 0301 	mov.w	r3, #1
    e738:	73fb      	strb	r3, [r7, #15]
    e73a:	687b      	ldr	r3, [r7, #4]
    e73c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    e73e:	2b00      	cmp	r3, #0
    e740:	d002      	beq.n	e748 <send_file+0x1c>
    e742:	2b67      	cmp	r3, #103	; 0x67
    e744:	d004      	beq.n	e750 <send_file+0x24>
    e746:	e02e      	b.n	e7a6 <send_file+0x7a>

	( void ) PT_YIELD_FLAG;
	
	do
	{
		PSOCK_GENERATOR_SEND( &s->sout, generate_part_of_file, s );
    e748:	687b      	ldr	r3, [r7, #4]
    e74a:	f04f 0267 	mov.w	r2, #103	; 0x67
    e74e:	851a      	strh	r2, [r3, #40]	; 0x28
    e750:	687b      	ldr	r3, [r7, #4]
    e752:	f103 0328 	add.w	r3, r3, #40	; 0x28
    e756:	4618      	mov	r0, r3
    e758:	f24e 61b5 	movw	r1, #59061	; 0xe6b5
    e75c:	f2c0 0100 	movt	r1, #0
    e760:	687a      	ldr	r2, [r7, #4]
    e762:	f7fc fa2d 	bl	abc0 <psock_generator_send>
    e766:	4603      	mov	r3, r0
    e768:	2b00      	cmp	r3, #0
    e76a:	d102      	bne.n	e772 <send_file+0x46>
    e76c:	f04f 0300 	mov.w	r3, #0
    e770:	e022      	b.n	e7b8 <send_file+0x8c>
		s->file.len -= s->len;
    e772:	687b      	ldr	r3, [r7, #4]
    e774:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
    e778:	687b      	ldr	r3, [r7, #4]
    e77a:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    e77e:	ebc3 0202 	rsb	r2, r3, r2
    e782:	687b      	ldr	r3, [r7, #4]
    e784:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
		s->file.data += s->len;
    e788:	687b      	ldr	r3, [r7, #4]
    e78a:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
    e78e:	687b      	ldr	r3, [r7, #4]
    e790:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    e794:	441a      	add	r2, r3
    e796:	687b      	ldr	r3, [r7, #4]
    e798:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
	} while( s->file.len > 0 );
    e79c:	687b      	ldr	r3, [r7, #4]
    e79e:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
    e7a2:	2b00      	cmp	r3, #0
    e7a4:	dcd0      	bgt.n	e748 <send_file+0x1c>

	PSOCK_END( &s->sout );
    e7a6:	f04f 0300 	mov.w	r3, #0
    e7aa:	73fb      	strb	r3, [r7, #15]
    e7ac:	687b      	ldr	r3, [r7, #4]
    e7ae:	f04f 0200 	mov.w	r2, #0
    e7b2:	851a      	strh	r2, [r3, #40]	; 0x28
    e7b4:	f04f 0302 	mov.w	r3, #2
}
    e7b8:	4618      	mov	r0, r3
    e7ba:	f107 0710 	add.w	r7, r7, #16
    e7be:	46bd      	mov	sp, r7
    e7c0:	bd80      	pop	{r7, pc}
    e7c2:	bf00      	nop

0000e7c4 <send_part_of_file>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( send_part_of_file ( struct httpd_state *s ) )
{
    e7c4:	b580      	push	{r7, lr}
    e7c6:	b084      	sub	sp, #16
    e7c8:	af00      	add	r7, sp, #0
    e7ca:	6078      	str	r0, [r7, #4]
	PSOCK_BEGIN( &s->sout );
    e7cc:	f04f 0301 	mov.w	r3, #1
    e7d0:	73fb      	strb	r3, [r7, #15]
    e7d2:	687b      	ldr	r3, [r7, #4]
    e7d4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    e7d6:	2b00      	cmp	r3, #0
    e7d8:	d002      	beq.n	e7e0 <send_part_of_file+0x1c>
    e7da:	2b75      	cmp	r3, #117	; 0x75
    e7dc:	d004      	beq.n	e7e8 <send_part_of_file+0x24>
    e7de:	e017      	b.n	e810 <send_part_of_file+0x4c>
	( void ) PT_YIELD_FLAG;
	
	PSOCK_SEND( &s->sout, s->file.data, s->len );
    e7e0:	687b      	ldr	r3, [r7, #4]
    e7e2:	f04f 0275 	mov.w	r2, #117	; 0x75
    e7e6:	851a      	strh	r2, [r3, #40]	; 0x28
    e7e8:	687b      	ldr	r3, [r7, #4]
    e7ea:	f103 0128 	add.w	r1, r3, #40	; 0x28
    e7ee:	687b      	ldr	r3, [r7, #4]
    e7f0:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
    e7f4:	687b      	ldr	r3, [r7, #4]
    e7f6:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    e7fa:	4608      	mov	r0, r1
    e7fc:	4611      	mov	r1, r2
    e7fe:	461a      	mov	r2, r3
    e800:	f7fc f994 	bl	ab2c <psock_send>
    e804:	4603      	mov	r3, r0
    e806:	2b00      	cmp	r3, #0
    e808:	d102      	bne.n	e810 <send_part_of_file+0x4c>
    e80a:	f04f 0300 	mov.w	r3, #0
    e80e:	e008      	b.n	e822 <send_part_of_file+0x5e>

	PSOCK_END( &s->sout );
    e810:	f04f 0300 	mov.w	r3, #0
    e814:	73fb      	strb	r3, [r7, #15]
    e816:	687b      	ldr	r3, [r7, #4]
    e818:	f04f 0200 	mov.w	r2, #0
    e81c:	851a      	strh	r2, [r3, #40]	; 0x28
    e81e:	f04f 0302 	mov.w	r3, #2
}
    e822:	4618      	mov	r0, r3
    e824:	f107 0710 	add.w	r7, r7, #16
    e828:	46bd      	mov	sp, r7
    e82a:	bd80      	pop	{r7, pc}

0000e82c <next_scriptstate>:

/*---------------------------------------------------------------------------*/
static void next_scriptstate( struct httpd_state *s )
{
    e82c:	b580      	push	{r7, lr}
    e82e:	b084      	sub	sp, #16
    e830:	af00      	add	r7, sp, #0
    e832:	6078      	str	r0, [r7, #4]
	char	*p;
	p = strchr( s->scriptptr, ISO_nl ) + 1;
    e834:	687b      	ldr	r3, [r7, #4]
    e836:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
    e83a:	4618      	mov	r0, r3
    e83c:	f04f 010a 	mov.w	r1, #10
    e840:	f006 ffe2 	bl	15808 <strchr>
    e844:	4603      	mov	r3, r0
    e846:	f103 0301 	add.w	r3, r3, #1
    e84a:	60fb      	str	r3, [r7, #12]
	s->scriptlen -= ( unsigned short ) ( p - s->scriptptr );
    e84c:	687b      	ldr	r3, [r7, #4]
    e84e:	f8d3 20a8 	ldr.w	r2, [r3, #168]	; 0xa8
    e852:	68fb      	ldr	r3, [r7, #12]
    e854:	b299      	uxth	r1, r3
    e856:	687b      	ldr	r3, [r7, #4]
    e858:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
    e85c:	b29b      	uxth	r3, r3
    e85e:	ebc3 0301 	rsb	r3, r3, r1
    e862:	b29b      	uxth	r3, r3
    e864:	ebc3 0202 	rsb	r2, r3, r2
    e868:	687b      	ldr	r3, [r7, #4]
    e86a:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	s->scriptptr = p;
    e86e:	687b      	ldr	r3, [r7, #4]
    e870:	68fa      	ldr	r2, [r7, #12]
    e872:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
}
    e876:	f107 0710 	add.w	r7, r7, #16
    e87a:	46bd      	mov	sp, r7
    e87c:	bd80      	pop	{r7, pc}
    e87e:	bf00      	nop

0000e880 <handle_script>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( handle_script ( struct httpd_state *s ) )
{
    e880:	b580      	push	{r7, lr}
    e882:	b084      	sub	sp, #16
    e884:	af00      	add	r7, sp, #0
    e886:	6078      	str	r0, [r7, #4]
	char	*ptr;

	PT_BEGIN( &s->scriptpt );
    e888:	f04f 0301 	mov.w	r3, #1
    e88c:	73fb      	strb	r3, [r7, #15]
    e88e:	687b      	ldr	r3, [r7, #4]
    e890:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
    e894:	2b94      	cmp	r3, #148	; 0x94
    e896:	d042      	beq.n	e91e <handle_script+0x9e>
    e898:	2b94      	cmp	r3, #148	; 0x94
    e89a:	dc03      	bgt.n	e8a4 <handle_script+0x24>
    e89c:	2b00      	cmp	r3, #0
    e89e:	f000 80f3 	beq.w	ea88 <handle_script+0x208>
    e8a2:	e0f8      	b.n	ea96 <handle_script+0x216>
    e8a4:	2b98      	cmp	r3, #152	; 0x98
    e8a6:	d048      	beq.n	e93a <handle_script+0xba>
    e8a8:	2bc1      	cmp	r3, #193	; 0xc1
    e8aa:	f000 80ce 	beq.w	ea4a <handle_script+0x1ca>
    e8ae:	e0f2      	b.n	ea96 <handle_script+0x216>
	( void ) PT_YIELD_FLAG;
	while( s->file.len > 0 )
	{
		/* Check if we should start executing a script. */
		if( *s->file.data == ISO_percent && *(s->file.data + 1) == ISO_bang )
    e8b0:	687b      	ldr	r3, [r7, #4]
    e8b2:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    e8b6:	781b      	ldrb	r3, [r3, #0]
    e8b8:	2b25      	cmp	r3, #37	; 0x25
    e8ba:	d161      	bne.n	e980 <handle_script+0x100>
    e8bc:	687b      	ldr	r3, [r7, #4]
    e8be:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    e8c2:	f103 0301 	add.w	r3, r3, #1
    e8c6:	781b      	ldrb	r3, [r3, #0]
    e8c8:	2b21      	cmp	r3, #33	; 0x21
    e8ca:	d159      	bne.n	e980 <handle_script+0x100>
		{
			s->scriptptr = s->file.data + 3;
    e8cc:	687b      	ldr	r3, [r7, #4]
    e8ce:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    e8d2:	f103 0203 	add.w	r2, r3, #3
    e8d6:	687b      	ldr	r3, [r7, #4]
    e8d8:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
			s->scriptlen = s->file.len - 3;
    e8dc:	687b      	ldr	r3, [r7, #4]
    e8de:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
    e8e2:	f1a3 0203 	sub.w	r2, r3, #3
    e8e6:	687b      	ldr	r3, [r7, #4]
    e8e8:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
			if( *(s->scriptptr - 1) == ISO_colon )
    e8ec:	687b      	ldr	r3, [r7, #4]
    e8ee:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
    e8f2:	f103 33ff 	add.w	r3, r3, #4294967295
    e8f6:	781b      	ldrb	r3, [r3, #0]
    e8f8:	2b3a      	cmp	r3, #58	; 0x3a
    e8fa:	d119      	bne.n	e930 <handle_script+0xb0>
			{
				httpd_fs_open( s->scriptptr + 1, &s->file );
    e8fc:	687b      	ldr	r3, [r7, #4]
    e8fe:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
    e902:	f103 0201 	add.w	r2, r3, #1
    e906:	687b      	ldr	r3, [r7, #4]
    e908:	f103 0398 	add.w	r3, r3, #152	; 0x98
    e90c:	4610      	mov	r0, r2
    e90e:	4619      	mov	r1, r3
    e910:	f7ff fe40 	bl	e594 <httpd_fs_open>
				PT_WAIT_THREAD( &s->scriptpt, send_file(s) );
    e914:	687b      	ldr	r3, [r7, #4]
    e916:	f04f 0294 	mov.w	r2, #148	; 0x94
    e91a:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    e91e:	6878      	ldr	r0, [r7, #4]
    e920:	f7ff ff04 	bl	e72c <send_file>
    e924:	4603      	mov	r3, r0
    e926:	2b00      	cmp	r3, #0
    e928:	d11a      	bne.n	e960 <handle_script+0xe0>
    e92a:	f04f 0300 	mov.w	r3, #0
    e92e:	e0bc      	b.n	eaaa <handle_script+0x22a>
			}
			else
			{
				PT_WAIT_THREAD( &s->scriptpt, httpd_cgi(s->scriptptr) (s, s->scriptptr) );
    e930:	687b      	ldr	r3, [r7, #4]
    e932:	f04f 0298 	mov.w	r2, #152	; 0x98
    e936:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    e93a:	687b      	ldr	r3, [r7, #4]
    e93c:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
    e940:	4618      	mov	r0, r3
    e942:	f7f2 ff4b 	bl	17dc <httpd_cgi>
    e946:	4603      	mov	r3, r0
    e948:	687a      	ldr	r2, [r7, #4]
    e94a:	f8d2 20a4 	ldr.w	r2, [r2, #164]	; 0xa4
    e94e:	6878      	ldr	r0, [r7, #4]
    e950:	4611      	mov	r1, r2
    e952:	4798      	blx	r3
    e954:	4603      	mov	r3, r0
    e956:	2b00      	cmp	r3, #0
    e958:	d102      	bne.n	e960 <handle_script+0xe0>
    e95a:	f04f 0300 	mov.w	r3, #0
    e95e:	e0a4      	b.n	eaaa <handle_script+0x22a>
			}

			next_scriptstate( s );
    e960:	6878      	ldr	r0, [r7, #4]
    e962:	f7ff ff63 	bl	e82c <next_scriptstate>

			/* The script is over, so we reset the pointers and continue
	 		sending the rest of the file. */
			s->file.data = s->scriptptr;
    e966:	687b      	ldr	r3, [r7, #4]
    e968:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
    e96c:	687b      	ldr	r3, [r7, #4]
    e96e:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
			s->file.len = s->scriptlen;
    e972:	687b      	ldr	r3, [r7, #4]
    e974:	f8d3 20a8 	ldr.w	r2, [r3, #168]	; 0xa8
    e978:	687b      	ldr	r3, [r7, #4]
    e97a:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
	PT_BEGIN( &s->scriptpt );
	( void ) PT_YIELD_FLAG;
	while( s->file.len > 0 )
	{
		/* Check if we should start executing a script. */
		if( *s->file.data == ISO_percent && *(s->file.data + 1) == ISO_bang )
    e97e:	e084      	b.n	ea8a <handle_script+0x20a>
		}
		else
		{
			/* See if we find the start of script marker in the block of HTML
	 to be sent. */
			if( s->file.len > uip_mss() )
    e980:	687b      	ldr	r3, [r7, #4]
    e982:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
    e986:	f64a 4328 	movw	r3, #44072	; 0xac28
    e98a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e98e:	681b      	ldr	r3, [r3, #0]
    e990:	8a5b      	ldrh	r3, [r3, #18]
    e992:	429a      	cmp	r2, r3
    e994:	dd0a      	ble.n	e9ac <handle_script+0x12c>
			{
				s->len = uip_mss();
    e996:	f64a 4328 	movw	r3, #44072	; 0xac28
    e99a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    e99e:	681b      	ldr	r3, [r3, #0]
    e9a0:	8a5b      	ldrh	r3, [r3, #18]
    e9a2:	461a      	mov	r2, r3
    e9a4:	687b      	ldr	r3, [r7, #4]
    e9a6:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    e9aa:	e005      	b.n	e9b8 <handle_script+0x138>
			}
			else
			{
				s->len = s->file.len;
    e9ac:	687b      	ldr	r3, [r7, #4]
    e9ae:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
    e9b2:	687b      	ldr	r3, [r7, #4]
    e9b4:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
			}

			if( *s->file.data == ISO_percent )
    e9b8:	687b      	ldr	r3, [r7, #4]
    e9ba:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    e9be:	781b      	ldrb	r3, [r3, #0]
    e9c0:	2b25      	cmp	r3, #37	; 0x25
    e9c2:	d10c      	bne.n	e9de <handle_script+0x15e>
			{
				ptr = strchr( s->file.data + 1, ISO_percent );
    e9c4:	687b      	ldr	r3, [r7, #4]
    e9c6:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    e9ca:	f103 0301 	add.w	r3, r3, #1
    e9ce:	4618      	mov	r0, r3
    e9d0:	f04f 0125 	mov.w	r1, #37	; 0x25
    e9d4:	f006 ff18 	bl	15808 <strchr>
    e9d8:	4603      	mov	r3, r0
    e9da:	60bb      	str	r3, [r7, #8]
    e9dc:	e009      	b.n	e9f2 <handle_script+0x172>
			}
			else
			{
				ptr = strchr( s->file.data, ISO_percent );
    e9de:	687b      	ldr	r3, [r7, #4]
    e9e0:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    e9e4:	4618      	mov	r0, r3
    e9e6:	f04f 0125 	mov.w	r1, #37	; 0x25
    e9ea:	f006 ff0d 	bl	15808 <strchr>
    e9ee:	4603      	mov	r3, r0
    e9f0:	60bb      	str	r3, [r7, #8]
			}

			if( ptr != NULL && ptr != s->file.data )
    e9f2:	68bb      	ldr	r3, [r7, #8]
    e9f4:	2b00      	cmp	r3, #0
    e9f6:	d023      	beq.n	ea40 <handle_script+0x1c0>
    e9f8:	687b      	ldr	r3, [r7, #4]
    e9fa:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
    e9fe:	68bb      	ldr	r3, [r7, #8]
    ea00:	429a      	cmp	r2, r3
    ea02:	d01d      	beq.n	ea40 <handle_script+0x1c0>
			{
				s->len = ( int ) ( ptr - s->file.data );
    ea04:	68ba      	ldr	r2, [r7, #8]
    ea06:	687b      	ldr	r3, [r7, #4]
    ea08:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    ea0c:	ebc3 0202 	rsb	r2, r3, r2
    ea10:	687b      	ldr	r3, [r7, #4]
    ea12:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
				if( s->len >= uip_mss() )
    ea16:	687b      	ldr	r3, [r7, #4]
    ea18:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
    ea1c:	f64a 4328 	movw	r3, #44072	; 0xac28
    ea20:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ea24:	681b      	ldr	r3, [r3, #0]
    ea26:	8a5b      	ldrh	r3, [r3, #18]
    ea28:	429a      	cmp	r2, r3
    ea2a:	db09      	blt.n	ea40 <handle_script+0x1c0>
				{
					s->len = uip_mss();
    ea2c:	f64a 4328 	movw	r3, #44072	; 0xac28
    ea30:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ea34:	681b      	ldr	r3, [r3, #0]
    ea36:	8a5b      	ldrh	r3, [r3, #18]
    ea38:	461a      	mov	r2, r3
    ea3a:	687b      	ldr	r3, [r7, #4]
    ea3c:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
				}
			}

			PT_WAIT_THREAD( &s->scriptpt, send_part_of_file(s) );
    ea40:	687b      	ldr	r3, [r7, #4]
    ea42:	f04f 02c1 	mov.w	r2, #193	; 0xc1
    ea46:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    ea4a:	6878      	ldr	r0, [r7, #4]
    ea4c:	f7ff feba 	bl	e7c4 <send_part_of_file>
    ea50:	4603      	mov	r3, r0
    ea52:	2b00      	cmp	r3, #0
    ea54:	d102      	bne.n	ea5c <handle_script+0x1dc>
    ea56:	f04f 0300 	mov.w	r3, #0
    ea5a:	e026      	b.n	eaaa <handle_script+0x22a>
			s->file.data += s->len;
    ea5c:	687b      	ldr	r3, [r7, #4]
    ea5e:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
    ea62:	687b      	ldr	r3, [r7, #4]
    ea64:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    ea68:	441a      	add	r2, r3
    ea6a:	687b      	ldr	r3, [r7, #4]
    ea6c:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
			s->file.len -= s->len;
    ea70:	687b      	ldr	r3, [r7, #4]
    ea72:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
    ea76:	687b      	ldr	r3, [r7, #4]
    ea78:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    ea7c:	ebc3 0202 	rsb	r2, r3, r2
    ea80:	687b      	ldr	r3, [r7, #4]
    ea82:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
    ea86:	e000      	b.n	ea8a <handle_script+0x20a>
{
	char	*ptr;

	PT_BEGIN( &s->scriptpt );
	( void ) PT_YIELD_FLAG;
	while( s->file.len > 0 )
    ea88:	bf00      	nop
    ea8a:	687b      	ldr	r3, [r7, #4]
    ea8c:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
    ea90:	2b00      	cmp	r3, #0
    ea92:	f73f af0d 	bgt.w	e8b0 <handle_script+0x30>
			s->file.data += s->len;
			s->file.len -= s->len;
		}
	}

	PT_END( &s->scriptpt );
    ea96:	f04f 0300 	mov.w	r3, #0
    ea9a:	73fb      	strb	r3, [r7, #15]
    ea9c:	687b      	ldr	r3, [r7, #4]
    ea9e:	f04f 0200 	mov.w	r2, #0
    eaa2:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    eaa6:	f04f 0302 	mov.w	r3, #2
}
    eaaa:	4618      	mov	r0, r3
    eaac:	f107 0710 	add.w	r7, r7, #16
    eab0:	46bd      	mov	sp, r7
    eab2:	bd80      	pop	{r7, pc}

0000eab4 <send_headers>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( send_headers ( struct httpd_state *s, const char *statushdr ) )
{
    eab4:	b590      	push	{r4, r7, lr}
    eab6:	b085      	sub	sp, #20
    eab8:	af00      	add	r7, sp, #0
    eaba:	6078      	str	r0, [r7, #4]
    eabc:	6039      	str	r1, [r7, #0]
	char	*ptr;

	PSOCK_BEGIN( &s->sout );
    eabe:	f04f 0301 	mov.w	r3, #1
    eac2:	73fb      	strb	r3, [r7, #15]
    eac4:	687b      	ldr	r3, [r7, #4]
    eac6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    eac8:	2bde      	cmp	r3, #222	; 0xde
    eaca:	f000 80a3 	beq.w	ec14 <send_headers+0x160>
    eace:	2bde      	cmp	r3, #222	; 0xde
    ead0:	dc0b      	bgt.n	eaea <send_headers+0x36>
    ead2:	2bd1      	cmp	r3, #209	; 0xd1
    ead4:	d01d      	beq.n	eb12 <send_headers+0x5e>
    ead6:	2bd1      	cmp	r3, #209	; 0xd1
    ead8:	dc02      	bgt.n	eae0 <send_headers+0x2c>
    eada:	2b00      	cmp	r3, #0
    eadc:	d015      	beq.n	eb0a <send_headers+0x56>
    eade:	e147      	b.n	ed70 <send_headers+0x2bc>
    eae0:	2bd6      	cmp	r3, #214	; 0xd6
    eae2:	d039      	beq.n	eb58 <send_headers+0xa4>
    eae4:	2bda      	cmp	r3, #218	; 0xda
    eae6:	d06c      	beq.n	ebc2 <send_headers+0x10e>
    eae8:	e142      	b.n	ed70 <send_headers+0x2bc>
    eaea:	2be6      	cmp	r3, #230	; 0xe6
    eaec:	f000 80e3 	beq.w	ecb6 <send_headers+0x202>
    eaf0:	2be6      	cmp	r3, #230	; 0xe6
    eaf2:	dc03      	bgt.n	eafc <send_headers+0x48>
    eaf4:	2be2      	cmp	r3, #226	; 0xe2
    eaf6:	f000 80b6 	beq.w	ec66 <send_headers+0x1b2>
    eafa:	e139      	b.n	ed70 <send_headers+0x2bc>
    eafc:	2bea      	cmp	r3, #234	; 0xea
    eafe:	f000 8102 	beq.w	ed06 <send_headers+0x252>
    eb02:	2bee      	cmp	r3, #238	; 0xee
    eb04:	f000 811b 	beq.w	ed3e <send_headers+0x28a>
    eb08:	e132      	b.n	ed70 <send_headers+0x2bc>
	( void ) PT_YIELD_FLAG;
	PSOCK_SEND_STR( &s->sout, statushdr );
    eb0a:	687b      	ldr	r3, [r7, #4]
    eb0c:	f04f 02d1 	mov.w	r2, #209	; 0xd1
    eb10:	851a      	strh	r2, [r3, #40]	; 0x28
    eb12:	687b      	ldr	r3, [r7, #4]
    eb14:	f103 0428 	add.w	r4, r3, #40	; 0x28
    eb18:	6838      	ldr	r0, [r7, #0]
    eb1a:	f006 ff33 	bl	15984 <strlen>
    eb1e:	4603      	mov	r3, r0
    eb20:	4620      	mov	r0, r4
    eb22:	6839      	ldr	r1, [r7, #0]
    eb24:	461a      	mov	r2, r3
    eb26:	f7fc f801 	bl	ab2c <psock_send>
    eb2a:	4603      	mov	r3, r0
    eb2c:	2b00      	cmp	r3, #0
    eb2e:	d102      	bne.n	eb36 <send_headers+0x82>
    eb30:	f04f 0300 	mov.w	r3, #0
    eb34:	e125      	b.n	ed82 <send_headers+0x2ce>

	ptr = strrchr( s->filename, ISO_period );
    eb36:	687b      	ldr	r3, [r7, #4]
    eb38:	f103 0382 	add.w	r3, r3, #130	; 0x82
    eb3c:	4618      	mov	r0, r3
    eb3e:	f04f 012e 	mov.w	r1, #46	; 0x2e
    eb42:	f006 ffdf 	bl	15b04 <strrchr>
    eb46:	4603      	mov	r3, r0
    eb48:	60bb      	str	r3, [r7, #8]
	if( ptr == NULL )
    eb4a:	68bb      	ldr	r3, [r7, #8]
    eb4c:	2b00      	cmp	r3, #0
    eb4e:	d11c      	bne.n	eb8a <send_headers+0xd6>
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_binary );
    eb50:	687b      	ldr	r3, [r7, #4]
    eb52:	f04f 02d6 	mov.w	r2, #214	; 0xd6
    eb56:	851a      	strh	r2, [r3, #40]	; 0x28
    eb58:	687b      	ldr	r3, [r7, #4]
    eb5a:	f103 0428 	add.w	r4, r3, #40	; 0x28
    eb5e:	f24d 3044 	movw	r0, #54084	; 0xd344
    eb62:	f2c0 0001 	movt	r0, #1
    eb66:	f006 ff0d 	bl	15984 <strlen>
    eb6a:	4603      	mov	r3, r0
    eb6c:	4620      	mov	r0, r4
    eb6e:	f24d 3144 	movw	r1, #54084	; 0xd344
    eb72:	f2c0 0101 	movt	r1, #1
    eb76:	461a      	mov	r2, r3
    eb78:	f7fb ffd8 	bl	ab2c <psock_send>
    eb7c:	4603      	mov	r3, r0
    eb7e:	2b00      	cmp	r3, #0
    eb80:	f040 80f6 	bne.w	ed70 <send_headers+0x2bc>
    eb84:	f04f 0300 	mov.w	r3, #0
    eb88:	e0fb      	b.n	ed82 <send_headers+0x2ce>
	}
	else if( strncmp(http_html, ptr, 5) == 0 || strncmp(http_shtml, ptr, 6) == 0 )
    eb8a:	f24d 3070 	movw	r0, #54128	; 0xd370
    eb8e:	f2c0 0001 	movt	r0, #1
    eb92:	68b9      	ldr	r1, [r7, #8]
    eb94:	f04f 0205 	mov.w	r2, #5
    eb98:	f006 ff24 	bl	159e4 <strncmp>
    eb9c:	4603      	mov	r3, r0
    eb9e:	2b00      	cmp	r3, #0
    eba0:	d00b      	beq.n	ebba <send_headers+0x106>
    eba2:	f24d 3078 	movw	r0, #54136	; 0xd378
    eba6:	f2c0 0001 	movt	r0, #1
    ebaa:	68b9      	ldr	r1, [r7, #8]
    ebac:	f04f 0206 	mov.w	r2, #6
    ebb0:	f006 ff18 	bl	159e4 <strncmp>
    ebb4:	4603      	mov	r3, r0
    ebb6:	2b00      	cmp	r3, #0
    ebb8:	d11c      	bne.n	ebf4 <send_headers+0x140>
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_html );
    ebba:	687b      	ldr	r3, [r7, #4]
    ebbc:	f04f 02da 	mov.w	r2, #218	; 0xda
    ebc0:	851a      	strh	r2, [r3, #40]	; 0x28
    ebc2:	687b      	ldr	r3, [r7, #4]
    ebc4:	f103 0428 	add.w	r4, r3, #40	; 0x28
    ebc8:	f24d 2098 	movw	r0, #53912	; 0xd298
    ebcc:	f2c0 0001 	movt	r0, #1
    ebd0:	f006 fed8 	bl	15984 <strlen>
    ebd4:	4603      	mov	r3, r0
    ebd6:	4620      	mov	r0, r4
    ebd8:	f24d 2198 	movw	r1, #53912	; 0xd298
    ebdc:	f2c0 0101 	movt	r1, #1
    ebe0:	461a      	mov	r2, r3
    ebe2:	f7fb ffa3 	bl	ab2c <psock_send>
    ebe6:	4603      	mov	r3, r0
    ebe8:	2b00      	cmp	r3, #0
    ebea:	f040 80c0 	bne.w	ed6e <send_headers+0x2ba>
    ebee:	f04f 0300 	mov.w	r3, #0
    ebf2:	e0c6      	b.n	ed82 <send_headers+0x2ce>
	}
	else if( strncmp(http_css, ptr, 4) == 0 )
    ebf4:	f24d 3088 	movw	r0, #54152	; 0xd388
    ebf8:	f2c0 0001 	movt	r0, #1
    ebfc:	68b9      	ldr	r1, [r7, #8]
    ebfe:	f04f 0204 	mov.w	r2, #4
    ec02:	f006 feef 	bl	159e4 <strncmp>
    ec06:	4603      	mov	r3, r0
    ec08:	2b00      	cmp	r3, #0
    ec0a:	d11c      	bne.n	ec46 <send_headers+0x192>
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_css );
    ec0c:	687b      	ldr	r3, [r7, #4]
    ec0e:	f04f 02de 	mov.w	r2, #222	; 0xde
    ec12:	851a      	strh	r2, [r3, #40]	; 0x28
    ec14:	687b      	ldr	r3, [r7, #4]
    ec16:	f103 0428 	add.w	r4, r3, #40	; 0x28
    ec1a:	f24d 20b4 	movw	r0, #53940	; 0xd2b4
    ec1e:	f2c0 0001 	movt	r0, #1
    ec22:	f006 feaf 	bl	15984 <strlen>
    ec26:	4603      	mov	r3, r0
    ec28:	4620      	mov	r0, r4
    ec2a:	f24d 21b4 	movw	r1, #53940	; 0xd2b4
    ec2e:	f2c0 0101 	movt	r1, #1
    ec32:	461a      	mov	r2, r3
    ec34:	f7fb ff7a 	bl	ab2c <psock_send>
    ec38:	4603      	mov	r3, r0
    ec3a:	2b00      	cmp	r3, #0
    ec3c:	f040 8098 	bne.w	ed70 <send_headers+0x2bc>
    ec40:	f04f 0300 	mov.w	r3, #0
    ec44:	e09d      	b.n	ed82 <send_headers+0x2ce>
	}
	else if( strncmp(http_png, ptr, 4) == 0 )
    ec46:	f24d 3090 	movw	r0, #54160	; 0xd390
    ec4a:	f2c0 0001 	movt	r0, #1
    ec4e:	68b9      	ldr	r1, [r7, #8]
    ec50:	f04f 0204 	mov.w	r2, #4
    ec54:	f006 fec6 	bl	159e4 <strncmp>
    ec58:	4603      	mov	r3, r0
    ec5a:	2b00      	cmp	r3, #0
    ec5c:	d11b      	bne.n	ec96 <send_headers+0x1e2>
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_png );
    ec5e:	687b      	ldr	r3, [r7, #4]
    ec60:	f04f 02e2 	mov.w	r2, #226	; 0xe2
    ec64:	851a      	strh	r2, [r3, #40]	; 0x28
    ec66:	687b      	ldr	r3, [r7, #4]
    ec68:	f103 0428 	add.w	r4, r3, #40	; 0x28
    ec6c:	f24d 20ec 	movw	r0, #53996	; 0xd2ec
    ec70:	f2c0 0001 	movt	r0, #1
    ec74:	f006 fe86 	bl	15984 <strlen>
    ec78:	4603      	mov	r3, r0
    ec7a:	4620      	mov	r0, r4
    ec7c:	f24d 21ec 	movw	r1, #53996	; 0xd2ec
    ec80:	f2c0 0101 	movt	r1, #1
    ec84:	461a      	mov	r2, r3
    ec86:	f7fb ff51 	bl	ab2c <psock_send>
    ec8a:	4603      	mov	r3, r0
    ec8c:	2b00      	cmp	r3, #0
    ec8e:	d16f      	bne.n	ed70 <send_headers+0x2bc>
    ec90:	f04f 0300 	mov.w	r3, #0
    ec94:	e075      	b.n	ed82 <send_headers+0x2ce>
	}
	else if( strncmp(http_gif, ptr, 4) == 0 )
    ec96:	f24d 3098 	movw	r0, #54168	; 0xd398
    ec9a:	f2c0 0001 	movt	r0, #1
    ec9e:	68b9      	ldr	r1, [r7, #8]
    eca0:	f04f 0204 	mov.w	r2, #4
    eca4:	f006 fe9e 	bl	159e4 <strncmp>
    eca8:	4603      	mov	r3, r0
    ecaa:	2b00      	cmp	r3, #0
    ecac:	d11b      	bne.n	ece6 <send_headers+0x232>
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_gif );
    ecae:	687b      	ldr	r3, [r7, #4]
    ecb0:	f04f 02e6 	mov.w	r2, #230	; 0xe6
    ecb4:	851a      	strh	r2, [r3, #40]	; 0x28
    ecb6:	687b      	ldr	r3, [r7, #4]
    ecb8:	f103 0428 	add.w	r4, r3, #40	; 0x28
    ecbc:	f24d 3008 	movw	r0, #54024	; 0xd308
    ecc0:	f2c0 0001 	movt	r0, #1
    ecc4:	f006 fe5e 	bl	15984 <strlen>
    ecc8:	4603      	mov	r3, r0
    ecca:	4620      	mov	r0, r4
    eccc:	f24d 3108 	movw	r1, #54024	; 0xd308
    ecd0:	f2c0 0101 	movt	r1, #1
    ecd4:	461a      	mov	r2, r3
    ecd6:	f7fb ff29 	bl	ab2c <psock_send>
    ecda:	4603      	mov	r3, r0
    ecdc:	2b00      	cmp	r3, #0
    ecde:	d147      	bne.n	ed70 <send_headers+0x2bc>
    ece0:	f04f 0300 	mov.w	r3, #0
    ece4:	e04d      	b.n	ed82 <send_headers+0x2ce>
	}
	else if( strncmp(http_jpg, ptr, 4) == 0 )
    ece6:	f24d 30a0 	movw	r0, #54176	; 0xd3a0
    ecea:	f2c0 0001 	movt	r0, #1
    ecee:	68b9      	ldr	r1, [r7, #8]
    ecf0:	f04f 0204 	mov.w	r2, #4
    ecf4:	f006 fe76 	bl	159e4 <strncmp>
    ecf8:	4603      	mov	r3, r0
    ecfa:	2b00      	cmp	r3, #0
    ecfc:	d11b      	bne.n	ed36 <send_headers+0x282>
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_jpg );
    ecfe:	687b      	ldr	r3, [r7, #4]
    ed00:	f04f 02ea 	mov.w	r2, #234	; 0xea
    ed04:	851a      	strh	r2, [r3, #40]	; 0x28
    ed06:	687b      	ldr	r3, [r7, #4]
    ed08:	f103 0428 	add.w	r4, r3, #40	; 0x28
    ed0c:	f24d 3024 	movw	r0, #54052	; 0xd324
    ed10:	f2c0 0001 	movt	r0, #1
    ed14:	f006 fe36 	bl	15984 <strlen>
    ed18:	4603      	mov	r3, r0
    ed1a:	4620      	mov	r0, r4
    ed1c:	f24d 3124 	movw	r1, #54052	; 0xd324
    ed20:	f2c0 0101 	movt	r1, #1
    ed24:	461a      	mov	r2, r3
    ed26:	f7fb ff01 	bl	ab2c <psock_send>
    ed2a:	4603      	mov	r3, r0
    ed2c:	2b00      	cmp	r3, #0
    ed2e:	d11f      	bne.n	ed70 <send_headers+0x2bc>
    ed30:	f04f 0300 	mov.w	r3, #0
    ed34:	e025      	b.n	ed82 <send_headers+0x2ce>
	}
	else
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_plain );
    ed36:	687b      	ldr	r3, [r7, #4]
    ed38:	f04f 02ee 	mov.w	r2, #238	; 0xee
    ed3c:	851a      	strh	r2, [r3, #40]	; 0x28
    ed3e:	687b      	ldr	r3, [r7, #4]
    ed40:	f103 0428 	add.w	r4, r3, #40	; 0x28
    ed44:	f24d 2078 	movw	r0, #53880	; 0xd278
    ed48:	f2c0 0001 	movt	r0, #1
    ed4c:	f006 fe1a 	bl	15984 <strlen>
    ed50:	4603      	mov	r3, r0
    ed52:	4620      	mov	r0, r4
    ed54:	f24d 2178 	movw	r1, #53880	; 0xd278
    ed58:	f2c0 0101 	movt	r1, #1
    ed5c:	461a      	mov	r2, r3
    ed5e:	f7fb fee5 	bl	ab2c <psock_send>
    ed62:	4603      	mov	r3, r0
    ed64:	2b00      	cmp	r3, #0
    ed66:	d103      	bne.n	ed70 <send_headers+0x2bc>
    ed68:	f04f 0300 	mov.w	r3, #0
    ed6c:	e009      	b.n	ed82 <send_headers+0x2ce>
	ptr = strrchr( s->filename, ISO_period );
	if( ptr == NULL )
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_binary );
	}
	else if( strncmp(http_html, ptr, 5) == 0 || strncmp(http_shtml, ptr, 6) == 0 )
    ed6e:	bf00      	nop
	else
	{
		PSOCK_SEND_STR( &s->sout, http_content_type_plain );
	}

	PSOCK_END( &s->sout );
    ed70:	f04f 0300 	mov.w	r3, #0
    ed74:	73fb      	strb	r3, [r7, #15]
    ed76:	687b      	ldr	r3, [r7, #4]
    ed78:	f04f 0200 	mov.w	r2, #0
    ed7c:	851a      	strh	r2, [r3, #40]	; 0x28
    ed7e:	f04f 0302 	mov.w	r3, #2
}
    ed82:	4618      	mov	r0, r3
    ed84:	f107 0714 	add.w	r7, r7, #20
    ed88:	46bd      	mov	sp, r7
    ed8a:	bd90      	pop	{r4, r7, pc}

0000ed8c <handle_output>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( handle_output ( struct httpd_state *s ) )
{
    ed8c:	b580      	push	{r7, lr}
    ed8e:	b084      	sub	sp, #16
    ed90:	af00      	add	r7, sp, #0
    ed92:	6078      	str	r0, [r7, #4]
	char	*ptr;

	PT_BEGIN( &s->outputpt );
    ed94:	f04f 0301 	mov.w	r3, #1
    ed98:	73fb      	strb	r3, [r7, #15]
    ed9a:	687b      	ldr	r3, [r7, #4]
    ed9c:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
    eda0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    eda4:	d04c      	beq.n	ee40 <handle_output+0xb4>
    eda6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    edaa:	dc04      	bgt.n	edb6 <handle_output+0x2a>
    edac:	2b00      	cmp	r3, #0
    edae:	d00f      	beq.n	edd0 <handle_output+0x44>
    edb0:	2bff      	cmp	r3, #255	; 0xff
    edb2:	d033      	beq.n	ee1c <handle_output+0x90>
    edb4:	e0a1      	b.n	eefa <handle_output+0x16e>
    edb6:	f240 1209 	movw	r2, #265	; 0x109
    edba:	4293      	cmp	r3, r2
    edbc:	d07e      	beq.n	eebc <handle_output+0x130>
    edbe:	f240 120d 	movw	r2, #269	; 0x10d
    edc2:	4293      	cmp	r3, r2
    edc4:	f000 8088 	beq.w	eed8 <handle_output+0x14c>
    edc8:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
    edcc:	d046      	beq.n	ee5c <handle_output+0xd0>
    edce:	e094      	b.n	eefa <handle_output+0x16e>
	( void ) PT_YIELD_FLAG;
	if( !httpd_fs_open(s->filename, &s->file) )
    edd0:	687b      	ldr	r3, [r7, #4]
    edd2:	f103 0282 	add.w	r2, r3, #130	; 0x82
    edd6:	687b      	ldr	r3, [r7, #4]
    edd8:	f103 0398 	add.w	r3, r3, #152	; 0x98
    eddc:	4610      	mov	r0, r2
    edde:	4619      	mov	r1, r3
    ede0:	f7ff fbd8 	bl	e594 <httpd_fs_open>
    ede4:	4603      	mov	r3, r0
    ede6:	2b00      	cmp	r3, #0
    ede8:	d133      	bne.n	ee52 <handle_output+0xc6>
	{
		httpd_fs_open( http_404_html, &s->file );
    edea:	687b      	ldr	r3, [r7, #4]
    edec:	f103 0398 	add.w	r3, r3, #152	; 0x98
    edf0:	f24d 10b0 	movw	r0, #53680	; 0xd1b0
    edf4:	f2c0 0001 	movt	r0, #1
    edf8:	4619      	mov	r1, r3
    edfa:	f7ff fbcb 	bl	e594 <httpd_fs_open>
		strcpy( s->filename, http_404_html );
    edfe:	687b      	ldr	r3, [r7, #4]
    ee00:	f103 0382 	add.w	r3, r3, #130	; 0x82
    ee04:	4618      	mov	r0, r3
    ee06:	f24d 11b0 	movw	r1, #53680	; 0xd1b0
    ee0a:	f2c0 0101 	movt	r1, #1
    ee0e:	f006 fd5b 	bl	158c8 <strcpy>
		PT_WAIT_THREAD( &s->outputpt, send_headers(s, http_header_404) );
    ee12:	687b      	ldr	r3, [r7, #4]
    ee14:	f04f 02ff 	mov.w	r2, #255	; 0xff
    ee18:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    ee1c:	6878      	ldr	r0, [r7, #4]
    ee1e:	f24d 211c 	movw	r1, #53788	; 0xd21c
    ee22:	f2c0 0101 	movt	r1, #1
    ee26:	f7ff fe45 	bl	eab4 <send_headers>
    ee2a:	4603      	mov	r3, r0
    ee2c:	2b00      	cmp	r3, #0
    ee2e:	d102      	bne.n	ee36 <handle_output+0xaa>
    ee30:	f04f 0300 	mov.w	r3, #0
    ee34:	e06b      	b.n	ef0e <handle_output+0x182>
		PT_WAIT_THREAD( &s->outputpt, send_file(s) );
    ee36:	687b      	ldr	r3, [r7, #4]
    ee38:	f44f 7280 	mov.w	r2, #256	; 0x100
    ee3c:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    ee40:	6878      	ldr	r0, [r7, #4]
    ee42:	f7ff fc73 	bl	e72c <send_file>
    ee46:	4603      	mov	r3, r0
    ee48:	2b00      	cmp	r3, #0
    ee4a:	d14f      	bne.n	eeec <handle_output+0x160>
    ee4c:	f04f 0300 	mov.w	r3, #0
    ee50:	e05d      	b.n	ef0e <handle_output+0x182>
	}
	else
	{
		PT_WAIT_THREAD( &s->outputpt, send_headers(s, http_header_200) );
    ee52:	687b      	ldr	r3, [r7, #4]
    ee54:	f44f 7282 	mov.w	r2, #260	; 0x104
    ee58:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    ee5c:	6878      	ldr	r0, [r7, #4]
    ee5e:	f24d 11c8 	movw	r1, #53704	; 0xd1c8
    ee62:	f2c0 0101 	movt	r1, #1
    ee66:	f7ff fe25 	bl	eab4 <send_headers>
    ee6a:	4603      	mov	r3, r0
    ee6c:	2b00      	cmp	r3, #0
    ee6e:	d102      	bne.n	ee76 <handle_output+0xea>
    ee70:	f04f 0300 	mov.w	r3, #0
    ee74:	e04b      	b.n	ef0e <handle_output+0x182>
		ptr = strchr( s->filename, ISO_period );
    ee76:	687b      	ldr	r3, [r7, #4]
    ee78:	f103 0382 	add.w	r3, r3, #130	; 0x82
    ee7c:	4618      	mov	r0, r3
    ee7e:	f04f 012e 	mov.w	r1, #46	; 0x2e
    ee82:	f006 fcc1 	bl	15808 <strchr>
    ee86:	4603      	mov	r3, r0
    ee88:	60bb      	str	r3, [r7, #8]
		if( ptr != NULL && strncmp(ptr, http_shtml, 6) == 0 )
    ee8a:	68bb      	ldr	r3, [r7, #8]
    ee8c:	2b00      	cmp	r3, #0
    ee8e:	d01e      	beq.n	eece <handle_output+0x142>
    ee90:	68b8      	ldr	r0, [r7, #8]
    ee92:	f24d 3178 	movw	r1, #54136	; 0xd378
    ee96:	f2c0 0101 	movt	r1, #1
    ee9a:	f04f 0206 	mov.w	r2, #6
    ee9e:	f006 fda1 	bl	159e4 <strncmp>
    eea2:	4603      	mov	r3, r0
    eea4:	2b00      	cmp	r3, #0
    eea6:	d112      	bne.n	eece <handle_output+0x142>
		{
			PT_INIT( &s->scriptpt );
    eea8:	687b      	ldr	r3, [r7, #4]
    eeaa:	f04f 0200 	mov.w	r2, #0
    eeae:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
			PT_WAIT_THREAD( &s->outputpt, handle_script(s) );
    eeb2:	687b      	ldr	r3, [r7, #4]
    eeb4:	f240 1209 	movw	r2, #265	; 0x109
    eeb8:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    eebc:	6878      	ldr	r0, [r7, #4]
    eebe:	f7ff fcdf 	bl	e880 <handle_script>
    eec2:	4603      	mov	r3, r0
    eec4:	2b00      	cmp	r3, #0
    eec6:	d110      	bne.n	eeea <handle_output+0x15e>
    eec8:	f04f 0300 	mov.w	r3, #0
    eecc:	e01f      	b.n	ef0e <handle_output+0x182>
		}
		else
		{
			PT_WAIT_THREAD( &s->outputpt, send_file(s) );
    eece:	687b      	ldr	r3, [r7, #4]
    eed0:	f240 120d 	movw	r2, #269	; 0x10d
    eed4:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    eed8:	6878      	ldr	r0, [r7, #4]
    eeda:	f7ff fc27 	bl	e72c <send_file>
    eede:	4603      	mov	r3, r0
    eee0:	2b00      	cmp	r3, #0
    eee2:	d103      	bne.n	eeec <handle_output+0x160>
    eee4:	f04f 0300 	mov.w	r3, #0
    eee8:	e011      	b.n	ef0e <handle_output+0x182>
	}
	else
	{
		PT_WAIT_THREAD( &s->outputpt, send_headers(s, http_header_200) );
		ptr = strchr( s->filename, ISO_period );
		if( ptr != NULL && strncmp(ptr, http_shtml, 6) == 0 )
    eeea:	bf00      	nop
		{
			PT_WAIT_THREAD( &s->outputpt, send_file(s) );
		}
	}

	PSOCK_CLOSE( &s->sout );
    eeec:	f64a 4320 	movw	r3, #44064	; 0xac20
    eef0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    eef4:	f04f 0210 	mov.w	r2, #16
    eef8:	701a      	strb	r2, [r3, #0]
	PT_END( &s->outputpt );
    eefa:	f04f 0300 	mov.w	r3, #0
    eefe:	73fb      	strb	r3, [r7, #15]
    ef00:	687b      	ldr	r3, [r7, #4]
    ef02:	f04f 0200 	mov.w	r2, #0
    ef06:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    ef0a:	f04f 0302 	mov.w	r3, #2
}
    ef0e:	4618      	mov	r0, r3
    ef10:	f107 0710 	add.w	r7, r7, #16
    ef14:	46bd      	mov	sp, r7
    ef16:	bd80      	pop	{r7, pc}

0000ef18 <handle_input>:

/*---------------------------------------------------------------------------*/
static PT_THREAD( handle_input ( struct httpd_state *s ) )
{
    ef18:	b580      	push	{r7, lr}
    ef1a:	b084      	sub	sp, #16
    ef1c:	af00      	add	r7, sp, #0
    ef1e:	6078      	str	r0, [r7, #4]
	PSOCK_BEGIN( &s->sin );
    ef20:	f04f 0301 	mov.w	r3, #1
    ef24:	73fb      	strb	r3, [r7, #15]
    ef26:	687b      	ldr	r3, [r7, #4]
    ef28:	889b      	ldrh	r3, [r3, #4]
    ef2a:	f5b3 7f8d 	cmp.w	r3, #282	; 0x11a
    ef2e:	d012      	beq.n	ef56 <handle_input+0x3e>
    ef30:	f5b3 7f8d 	cmp.w	r3, #282	; 0x11a
    ef34:	dc02      	bgt.n	ef3c <handle_input+0x24>
    ef36:	2b00      	cmp	r3, #0
    ef38:	d009      	beq.n	ef4e <handle_input+0x36>
    ef3a:	e0c7      	b.n	f0cc <handle_input+0x1b4>
    ef3c:	f240 1221 	movw	r2, #289	; 0x121
    ef40:	4293      	cmp	r3, r2
    ef42:	d037      	beq.n	efb4 <handle_input+0x9c>
    ef44:	f5b3 7fa0 	cmp.w	r3, #320	; 0x140
    ef48:	f000 8093 	beq.w	f072 <handle_input+0x15a>
    ef4c:	e0be      	b.n	f0cc <handle_input+0x1b4>
	( void ) PT_YIELD_FLAG;
	PSOCK_READTO( &s->sin, ISO_space );
    ef4e:	687b      	ldr	r3, [r7, #4]
    ef50:	f44f 728d 	mov.w	r2, #282	; 0x11a
    ef54:	809a      	strh	r2, [r3, #4]
    ef56:	687b      	ldr	r3, [r7, #4]
    ef58:	f103 0304 	add.w	r3, r3, #4
    ef5c:	4618      	mov	r0, r3
    ef5e:	f04f 0120 	mov.w	r1, #32
    ef62:	f7fb fec7 	bl	acf4 <psock_readto>
    ef66:	4603      	mov	r3, r0
    ef68:	2b00      	cmp	r3, #0
    ef6a:	d102      	bne.n	ef72 <handle_input+0x5a>
    ef6c:	f04f 0300 	mov.w	r3, #0
    ef70:	e0b5      	b.n	f0de <handle_input+0x1c6>

	if( strncmp(s->inputbuf, http_get, 4) != 0 )
    ef72:	687b      	ldr	r3, [r7, #4]
    ef74:	f103 0350 	add.w	r3, r3, #80	; 0x50
    ef78:	4618      	mov	r0, r3
    ef7a:	f24d 1150 	movw	r1, #53584	; 0xd150
    ef7e:	f2c0 0101 	movt	r1, #1
    ef82:	f04f 0204 	mov.w	r2, #4
    ef86:	f006 fd2d 	bl	159e4 <strncmp>
    ef8a:	4603      	mov	r3, r0
    ef8c:	2b00      	cmp	r3, #0
    ef8e:	d00d      	beq.n	efac <handle_input+0x94>
	{
		PSOCK_CLOSE_EXIT( &s->sin );
    ef90:	f64a 4320 	movw	r3, #44064	; 0xac20
    ef94:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ef98:	f04f 0210 	mov.w	r2, #16
    ef9c:	701a      	strb	r2, [r3, #0]
    ef9e:	687b      	ldr	r3, [r7, #4]
    efa0:	f04f 0200 	mov.w	r2, #0
    efa4:	809a      	strh	r2, [r3, #4]
    efa6:	f04f 0301 	mov.w	r3, #1
    efaa:	e098      	b.n	f0de <handle_input+0x1c6>
	}

	PSOCK_READTO( &s->sin, ISO_space );
    efac:	687b      	ldr	r3, [r7, #4]
    efae:	f240 1221 	movw	r2, #289	; 0x121
    efb2:	809a      	strh	r2, [r3, #4]
    efb4:	687b      	ldr	r3, [r7, #4]
    efb6:	f103 0304 	add.w	r3, r3, #4
    efba:	4618      	mov	r0, r3
    efbc:	f04f 0120 	mov.w	r1, #32
    efc0:	f7fb fe98 	bl	acf4 <psock_readto>
    efc4:	4603      	mov	r3, r0
    efc6:	2b00      	cmp	r3, #0
    efc8:	d102      	bne.n	efd0 <handle_input+0xb8>
    efca:	f04f 0300 	mov.w	r3, #0
    efce:	e086      	b.n	f0de <handle_input+0x1c6>

	if( s->inputbuf[0] != ISO_slash )
    efd0:	687b      	ldr	r3, [r7, #4]
    efd2:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
    efd6:	2b2f      	cmp	r3, #47	; 0x2f
    efd8:	d00d      	beq.n	eff6 <handle_input+0xde>
	{
		PSOCK_CLOSE_EXIT( &s->sin );
    efda:	f64a 4320 	movw	r3, #44064	; 0xac20
    efde:	f2c2 0300 	movt	r3, #8192	; 0x2000
    efe2:	f04f 0210 	mov.w	r2, #16
    efe6:	701a      	strb	r2, [r3, #0]
    efe8:	687b      	ldr	r3, [r7, #4]
    efea:	f04f 0200 	mov.w	r2, #0
    efee:	809a      	strh	r2, [r3, #4]
    eff0:	f04f 0301 	mov.w	r3, #1
    eff4:	e073      	b.n	f0de <handle_input+0x1c6>
	}

	if( s->inputbuf[1] == ISO_space )
    eff6:	687b      	ldr	r3, [r7, #4]
    eff8:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
    effc:	2b20      	cmp	r3, #32
    effe:	d10c      	bne.n	f01a <handle_input+0x102>
	{
		strncpy( s->filename, http_index_html, sizeof(s->filename) );
    f000:	687b      	ldr	r3, [r7, #4]
    f002:	f103 0382 	add.w	r3, r3, #130	; 0x82
    f006:	4618      	mov	r0, r3
    f008:	f24d 11a4 	movw	r1, #53668	; 0xd1a4
    f00c:	f2c0 0101 	movt	r1, #1
    f010:	f04f 0214 	mov.w	r2, #20
    f014:	f006 fd3a 	bl	15a8c <strncpy>
    f018:	e020      	b.n	f05c <handle_input+0x144>
	}
	else
	{
		s->inputbuf[PSOCK_DATALEN( &s->sin ) - 1] = 0;
    f01a:	687b      	ldr	r3, [r7, #4]
    f01c:	f103 0304 	add.w	r3, r3, #4
    f020:	4618      	mov	r0, r3
    f022:	f7fb fe29 	bl	ac78 <psock_datalen>
    f026:	4603      	mov	r3, r0
    f028:	f103 32ff 	add.w	r2, r3, #4294967295
    f02c:	687b      	ldr	r3, [r7, #4]
    f02e:	4413      	add	r3, r2
    f030:	f04f 0200 	mov.w	r2, #0
    f034:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
		
		/* Process any form input being sent to the server. */
		#if UIP_CONF_PROCESS_HTTPD_FORMS == 1
		{
			extern void vApplicationProcessFormInput( char *pcInputString );
			vApplicationProcessFormInput( s->inputbuf );
    f038:	687b      	ldr	r3, [r7, #4]
    f03a:	f103 0350 	add.w	r3, r3, #80	; 0x50
    f03e:	4618      	mov	r0, r3
    f040:	f7f2 fb66 	bl	1710 <vApplicationProcessFormInput>
		}
		#endif
		
		strncpy( s->filename, &s->inputbuf[0], sizeof(s->filename) );
    f044:	687b      	ldr	r3, [r7, #4]
    f046:	f103 0282 	add.w	r2, r3, #130	; 0x82
    f04a:	687b      	ldr	r3, [r7, #4]
    f04c:	f103 0350 	add.w	r3, r3, #80	; 0x50
    f050:	4610      	mov	r0, r2
    f052:	4619      	mov	r1, r3
    f054:	f04f 0214 	mov.w	r2, #20
    f058:	f006 fd18 	bl	15a8c <strncpy>
	}

	/*  httpd_log_file(uip_conn->ripaddr, s->filename);*/
	s->state = STATE_OUTPUT;
    f05c:	687b      	ldr	r3, [r7, #4]
    f05e:	f04f 0201 	mov.w	r2, #1
    f062:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
    f066:	e000      	b.n	f06a <handle_input+0x152>
		{
			s->inputbuf[PSOCK_DATALEN( &s->sin ) - 2] = 0;

			/*      httpd_log(&s->inputbuf[9]);*/
		}
	}
    f068:	bf00      	nop
	/*  httpd_log_file(uip_conn->ripaddr, s->filename);*/
	s->state = STATE_OUTPUT;

	while( 1 )
	{
		PSOCK_READTO( &s->sin, ISO_nl );
    f06a:	687b      	ldr	r3, [r7, #4]
    f06c:	f44f 72a0 	mov.w	r2, #320	; 0x140
    f070:	809a      	strh	r2, [r3, #4]
    f072:	687b      	ldr	r3, [r7, #4]
    f074:	f103 0304 	add.w	r3, r3, #4
    f078:	4618      	mov	r0, r3
    f07a:	f04f 010a 	mov.w	r1, #10
    f07e:	f7fb fe39 	bl	acf4 <psock_readto>
    f082:	4603      	mov	r3, r0
    f084:	2b00      	cmp	r3, #0
    f086:	d102      	bne.n	f08e <handle_input+0x176>
    f088:	f04f 0300 	mov.w	r3, #0
    f08c:	e027      	b.n	f0de <handle_input+0x1c6>

		if( strncmp(s->inputbuf, http_referer, 8) == 0 )
    f08e:	687b      	ldr	r3, [r7, #4]
    f090:	f103 0350 	add.w	r3, r3, #80	; 0x50
    f094:	4618      	mov	r0, r3
    f096:	f24d 11bc 	movw	r1, #53692	; 0xd1bc
    f09a:	f2c0 0101 	movt	r1, #1
    f09e:	f04f 0208 	mov.w	r2, #8
    f0a2:	f006 fc9f 	bl	159e4 <strncmp>
    f0a6:	4603      	mov	r3, r0
    f0a8:	2b00      	cmp	r3, #0
    f0aa:	d1dd      	bne.n	f068 <handle_input+0x150>
		{
			s->inputbuf[PSOCK_DATALEN( &s->sin ) - 2] = 0;
    f0ac:	687b      	ldr	r3, [r7, #4]
    f0ae:	f103 0304 	add.w	r3, r3, #4
    f0b2:	4618      	mov	r0, r3
    f0b4:	f7fb fde0 	bl	ac78 <psock_datalen>
    f0b8:	4603      	mov	r3, r0
    f0ba:	f1a3 0202 	sub.w	r2, r3, #2
    f0be:	687b      	ldr	r3, [r7, #4]
    f0c0:	4413      	add	r3, r2
    f0c2:	f04f 0200 	mov.w	r2, #0
    f0c6:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

			/*      httpd_log(&s->inputbuf[9]);*/
		}
	}
    f0ca:	e7ce      	b.n	f06a <handle_input+0x152>

	PSOCK_END( &s->sin );
    f0cc:	f04f 0300 	mov.w	r3, #0
    f0d0:	73fb      	strb	r3, [r7, #15]
    f0d2:	687b      	ldr	r3, [r7, #4]
    f0d4:	f04f 0200 	mov.w	r2, #0
    f0d8:	809a      	strh	r2, [r3, #4]
    f0da:	f04f 0302 	mov.w	r3, #2
}
    f0de:	4618      	mov	r0, r3
    f0e0:	f107 0710 	add.w	r7, r7, #16
    f0e4:	46bd      	mov	sp, r7
    f0e6:	bd80      	pop	{r7, pc}

0000f0e8 <handle_connection>:

/*---------------------------------------------------------------------------*/
static void handle_connection( struct httpd_state *s )
{
    f0e8:	b580      	push	{r7, lr}
    f0ea:	b082      	sub	sp, #8
    f0ec:	af00      	add	r7, sp, #0
    f0ee:	6078      	str	r0, [r7, #4]
	handle_input( s );
    f0f0:	6878      	ldr	r0, [r7, #4]
    f0f2:	f7ff ff11 	bl	ef18 <handle_input>
	if( s->state == STATE_OUTPUT )
    f0f6:	687b      	ldr	r3, [r7, #4]
    f0f8:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
    f0fc:	2b01      	cmp	r3, #1
    f0fe:	d102      	bne.n	f106 <handle_connection+0x1e>
	{
		handle_output( s );
    f100:	6878      	ldr	r0, [r7, #4]
    f102:	f7ff fe43 	bl	ed8c <handle_output>
	}
}
    f106:	f107 0708 	add.w	r7, r7, #8
    f10a:	46bd      	mov	sp, r7
    f10c:	bd80      	pop	{r7, pc}
    f10e:	bf00      	nop

0000f110 <httpd_appcall>:

/*---------------------------------------------------------------------------*/
void httpd_appcall( void )
{
    f110:	b580      	push	{r7, lr}
    f112:	b082      	sub	sp, #8
    f114:	af00      	add	r7, sp, #0
	struct httpd_state	*s = ( struct httpd_state * ) &( uip_conn->appstate );
    f116:	f64a 4328 	movw	r3, #44072	; 0xac28
    f11a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f11e:	681b      	ldr	r3, [r3, #0]
    f120:	f103 031c 	add.w	r3, r3, #28
    f124:	607b      	str	r3, [r7, #4]

	if( uip_closed() || uip_aborted() || uip_timedout() )
    f126:	f64a 4320 	movw	r3, #44064	; 0xac20
    f12a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f12e:	781b      	ldrb	r3, [r3, #0]
    f130:	f003 0310 	and.w	r3, r3, #16
    f134:	2b00      	cmp	r3, #0
    f136:	d173      	bne.n	f220 <httpd_appcall+0x110>
    f138:	f64a 4320 	movw	r3, #44064	; 0xac20
    f13c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f140:	781b      	ldrb	r3, [r3, #0]
    f142:	f003 0320 	and.w	r3, r3, #32
    f146:	2b00      	cmp	r3, #0
    f148:	d16a      	bne.n	f220 <httpd_appcall+0x110>
    f14a:	f64a 4320 	movw	r3, #44064	; 0xac20
    f14e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f152:	781b      	ldrb	r3, [r3, #0]
    f154:	b25b      	sxtb	r3, r3
    f156:	2b00      	cmp	r3, #0
    f158:	db62      	blt.n	f220 <httpd_appcall+0x110>
	{
	}
	else if( uip_connected() )
    f15a:	f64a 4320 	movw	r3, #44064	; 0xac20
    f15e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f162:	781b      	ldrb	r3, [r3, #0]
    f164:	f003 0340 	and.w	r3, r3, #64	; 0x40
    f168:	2b00      	cmp	r3, #0
    f16a:	d029      	beq.n	f1c0 <httpd_appcall+0xb0>
	{
		PSOCK_INIT( &s->sin, s->inputbuf, sizeof(s->inputbuf) - 1 );
    f16c:	687b      	ldr	r3, [r7, #4]
    f16e:	f103 0204 	add.w	r2, r3, #4
    f172:	687b      	ldr	r3, [r7, #4]
    f174:	f103 0350 	add.w	r3, r3, #80	; 0x50
    f178:	4610      	mov	r0, r2
    f17a:	4619      	mov	r1, r3
    f17c:	f04f 0231 	mov.w	r2, #49	; 0x31
    f180:	f7fb fe7e 	bl	ae80 <psock_init>
		PSOCK_INIT( &s->sout, s->inputbuf, sizeof(s->inputbuf) - 1 );
    f184:	687b      	ldr	r3, [r7, #4]
    f186:	f103 0228 	add.w	r2, r3, #40	; 0x28
    f18a:	687b      	ldr	r3, [r7, #4]
    f18c:	f103 0350 	add.w	r3, r3, #80	; 0x50
    f190:	4610      	mov	r0, r2
    f192:	4619      	mov	r1, r3
    f194:	f04f 0231 	mov.w	r2, #49	; 0x31
    f198:	f7fb fe72 	bl	ae80 <psock_init>
		PT_INIT( &s->outputpt );
    f19c:	687b      	ldr	r3, [r7, #4]
    f19e:	f04f 0200 	mov.w	r2, #0
    f1a2:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
		s->state = STATE_WAITING;
    f1a6:	687b      	ldr	r3, [r7, #4]
    f1a8:	f04f 0200 	mov.w	r2, #0
    f1ac:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96

		/*    timer_set(&s->timer, CLOCK_SECOND * 100);*/
		s->timer = 0;
    f1b0:	687b      	ldr	r3, [r7, #4]
    f1b2:	f04f 0200 	mov.w	r2, #0
    f1b6:	701a      	strb	r2, [r3, #0]
		handle_connection( s );
    f1b8:	6878      	ldr	r0, [r7, #4]
    f1ba:	f7ff ff95 	bl	f0e8 <handle_connection>
    f1be:	e02f      	b.n	f220 <httpd_appcall+0x110>
	}
	else if( s != NULL )
    f1c0:	687b      	ldr	r3, [r7, #4]
    f1c2:	2b00      	cmp	r3, #0
    f1c4:	d025      	beq.n	f212 <httpd_appcall+0x102>
	{
		if( uip_poll() )
    f1c6:	f64a 4320 	movw	r3, #44064	; 0xac20
    f1ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f1ce:	781b      	ldrb	r3, [r3, #0]
    f1d0:	f003 0308 	and.w	r3, r3, #8
    f1d4:	2b00      	cmp	r3, #0
    f1d6:	d012      	beq.n	f1fe <httpd_appcall+0xee>
		{
			++s->timer;
    f1d8:	687b      	ldr	r3, [r7, #4]
    f1da:	781b      	ldrb	r3, [r3, #0]
    f1dc:	f103 0301 	add.w	r3, r3, #1
    f1e0:	b2da      	uxtb	r2, r3
    f1e2:	687b      	ldr	r3, [r7, #4]
    f1e4:	701a      	strb	r2, [r3, #0]
			if( s->timer >= 20 )
    f1e6:	687b      	ldr	r3, [r7, #4]
    f1e8:	781b      	ldrb	r3, [r3, #0]
    f1ea:	2b13      	cmp	r3, #19
    f1ec:	d90c      	bls.n	f208 <httpd_appcall+0xf8>
			{
				uip_abort();
    f1ee:	f64a 4320 	movw	r3, #44064	; 0xac20
    f1f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f1f6:	f04f 0220 	mov.w	r2, #32
    f1fa:	701a      	strb	r2, [r3, #0]
    f1fc:	e005      	b.n	f20a <httpd_appcall+0xfa>
			}
		}
		else
		{
			s->timer = 0;
    f1fe:	687b      	ldr	r3, [r7, #4]
    f200:	f04f 0200 	mov.w	r2, #0
    f204:	701a      	strb	r2, [r3, #0]
    f206:	e000      	b.n	f20a <httpd_appcall+0xfa>
		if( uip_poll() )
		{
			++s->timer;
			if( s->timer >= 20 )
			{
				uip_abort();
    f208:	bf00      	nop
		else
		{
			s->timer = 0;
		}

		handle_connection( s );
    f20a:	6878      	ldr	r0, [r7, #4]
    f20c:	f7ff ff6c 	bl	f0e8 <handle_connection>
    f210:	e006      	b.n	f220 <httpd_appcall+0x110>
	}
	else
	{
		uip_abort();
    f212:	f64a 4320 	movw	r3, #44064	; 0xac20
    f216:	f2c2 0300 	movt	r3, #8192	; 0x2000
    f21a:	f04f 0220 	mov.w	r2, #32
    f21e:	701a      	strb	r2, [r3, #0]
	}
}
    f220:	f107 0708 	add.w	r7, r7, #8
    f224:	46bd      	mov	sp, r7
    f226:	bd80      	pop	{r7, pc}

0000f228 <httpd_init>:
 *
 *             This function initializes the web server and should be
 *             called at system boot-up.
 */
void httpd_init( void )
{
    f228:	b580      	push	{r7, lr}
    f22a:	af00      	add	r7, sp, #0
	uip_listen( HTONS(80) );
    f22c:	f44f 40a0 	mov.w	r0, #20480	; 0x5000
    f230:	f7fc f9e4 	bl	b5fc <uip_listen>
}
    f234:	bd80      	pop	{r7, pc}
    f236:	bf00      	nop

0000f238 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    f238:	b480      	push	{r7}
    f23a:	b083      	sub	sp, #12
    f23c:	af00      	add	r7, sp, #0
    f23e:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    f240:	687b      	ldr	r3, [r7, #4]
    f242:	f103 0308 	add.w	r3, r3, #8
    f246:	461a      	mov	r2, r3
    f248:	687b      	ldr	r3, [r7, #4]
    f24a:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    f24c:	687b      	ldr	r3, [r7, #4]
    f24e:	f04f 32ff 	mov.w	r2, #4294967295
    f252:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    f254:	687b      	ldr	r3, [r7, #4]
    f256:	f103 0308 	add.w	r3, r3, #8
    f25a:	461a      	mov	r2, r3
    f25c:	687b      	ldr	r3, [r7, #4]
    f25e:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    f260:	687b      	ldr	r3, [r7, #4]
    f262:	f103 0308 	add.w	r3, r3, #8
    f266:	461a      	mov	r2, r3
    f268:	687b      	ldr	r3, [r7, #4]
    f26a:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    f26c:	687b      	ldr	r3, [r7, #4]
    f26e:	f04f 0200 	mov.w	r2, #0
    f272:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    f274:	f107 070c 	add.w	r7, r7, #12
    f278:	46bd      	mov	sp, r7
    f27a:	bc80      	pop	{r7}
    f27c:	4770      	bx	lr
    f27e:	bf00      	nop

0000f280 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    f280:	b480      	push	{r7}
    f282:	b083      	sub	sp, #12
    f284:	af00      	add	r7, sp, #0
    f286:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    f288:	687b      	ldr	r3, [r7, #4]
    f28a:	f04f 0200 	mov.w	r2, #0
    f28e:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    f290:	f107 070c 	add.w	r7, r7, #12
    f294:	46bd      	mov	sp, r7
    f296:	bc80      	pop	{r7}
    f298:	4770      	bx	lr
    f29a:	bf00      	nop

0000f29c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    f29c:	b480      	push	{r7}
    f29e:	b085      	sub	sp, #20
    f2a0:	af00      	add	r7, sp, #0
    f2a2:	6078      	str	r0, [r7, #4]
    f2a4:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
    f2a6:	687b      	ldr	r3, [r7, #4]
    f2a8:	685b      	ldr	r3, [r3, #4]
    f2aa:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    f2ac:	683b      	ldr	r3, [r7, #0]
    f2ae:	68fa      	ldr	r2, [r7, #12]
    f2b0:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    f2b2:	68fb      	ldr	r3, [r7, #12]
    f2b4:	689a      	ldr	r2, [r3, #8]
    f2b6:	683b      	ldr	r3, [r7, #0]
    f2b8:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    f2ba:	68fb      	ldr	r3, [r7, #12]
    f2bc:	689b      	ldr	r3, [r3, #8]
    f2be:	683a      	ldr	r2, [r7, #0]
    f2c0:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
    f2c2:	68fb      	ldr	r3, [r7, #12]
    f2c4:	683a      	ldr	r2, [r7, #0]
    f2c6:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    f2c8:	683b      	ldr	r3, [r7, #0]
    f2ca:	687a      	ldr	r2, [r7, #4]
    f2cc:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
    f2ce:	687b      	ldr	r3, [r7, #4]
    f2d0:	681b      	ldr	r3, [r3, #0]
    f2d2:	f103 0201 	add.w	r2, r3, #1
    f2d6:	687b      	ldr	r3, [r7, #4]
    f2d8:	601a      	str	r2, [r3, #0]
}
    f2da:	f107 0714 	add.w	r7, r7, #20
    f2de:	46bd      	mov	sp, r7
    f2e0:	bc80      	pop	{r7}
    f2e2:	4770      	bx	lr

0000f2e4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    f2e4:	b480      	push	{r7}
    f2e6:	b085      	sub	sp, #20
    f2e8:	af00      	add	r7, sp, #0
    f2ea:	6078      	str	r0, [r7, #4]
    f2ec:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    f2ee:	683b      	ldr	r3, [r7, #0]
    f2f0:	681b      	ldr	r3, [r3, #0]
    f2f2:	60fb      	str	r3, [r7, #12]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    f2f4:	68fb      	ldr	r3, [r7, #12]
    f2f6:	f1b3 3fff 	cmp.w	r3, #4294967295
    f2fa:	d103      	bne.n	f304 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    f2fc:	687b      	ldr	r3, [r7, #4]
    f2fe:	691b      	ldr	r3, [r3, #16]
    f300:	60bb      	str	r3, [r7, #8]
    f302:	e00d      	b.n	f320 <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    f304:	687b      	ldr	r3, [r7, #4]
    f306:	f103 0308 	add.w	r3, r3, #8
    f30a:	60bb      	str	r3, [r7, #8]
    f30c:	e002      	b.n	f314 <vListInsert+0x30>
    f30e:	68bb      	ldr	r3, [r7, #8]
    f310:	685b      	ldr	r3, [r3, #4]
    f312:	60bb      	str	r3, [r7, #8]
    f314:	68bb      	ldr	r3, [r7, #8]
    f316:	685b      	ldr	r3, [r3, #4]
    f318:	681a      	ldr	r2, [r3, #0]
    f31a:	68fb      	ldr	r3, [r7, #12]
    f31c:	429a      	cmp	r2, r3
    f31e:	d9f6      	bls.n	f30e <vListInsert+0x2a>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    f320:	68bb      	ldr	r3, [r7, #8]
    f322:	685a      	ldr	r2, [r3, #4]
    f324:	683b      	ldr	r3, [r7, #0]
    f326:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    f328:	683b      	ldr	r3, [r7, #0]
    f32a:	685b      	ldr	r3, [r3, #4]
    f32c:	683a      	ldr	r2, [r7, #0]
    f32e:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
    f330:	683b      	ldr	r3, [r7, #0]
    f332:	68ba      	ldr	r2, [r7, #8]
    f334:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
    f336:	68bb      	ldr	r3, [r7, #8]
    f338:	683a      	ldr	r2, [r7, #0]
    f33a:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    f33c:	683b      	ldr	r3, [r7, #0]
    f33e:	687a      	ldr	r2, [r7, #4]
    f340:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
    f342:	687b      	ldr	r3, [r7, #4]
    f344:	681b      	ldr	r3, [r3, #0]
    f346:	f103 0201 	add.w	r2, r3, #1
    f34a:	687b      	ldr	r3, [r7, #4]
    f34c:	601a      	str	r2, [r3, #0]
}
    f34e:	f107 0714 	add.w	r7, r7, #20
    f352:	46bd      	mov	sp, r7
    f354:	bc80      	pop	{r7}
    f356:	4770      	bx	lr

0000f358 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    f358:	b480      	push	{r7}
    f35a:	b085      	sub	sp, #20
    f35c:	af00      	add	r7, sp, #0
    f35e:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    f360:	687b      	ldr	r3, [r7, #4]
    f362:	691b      	ldr	r3, [r3, #16]
    f364:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    f366:	687b      	ldr	r3, [r7, #4]
    f368:	685b      	ldr	r3, [r3, #4]
    f36a:	687a      	ldr	r2, [r7, #4]
    f36c:	6892      	ldr	r2, [r2, #8]
    f36e:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    f370:	687b      	ldr	r3, [r7, #4]
    f372:	689b      	ldr	r3, [r3, #8]
    f374:	687a      	ldr	r2, [r7, #4]
    f376:	6852      	ldr	r2, [r2, #4]
    f378:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    f37a:	68fb      	ldr	r3, [r7, #12]
    f37c:	685a      	ldr	r2, [r3, #4]
    f37e:	687b      	ldr	r3, [r7, #4]
    f380:	429a      	cmp	r2, r3
    f382:	d103      	bne.n	f38c <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    f384:	687b      	ldr	r3, [r7, #4]
    f386:	689a      	ldr	r2, [r3, #8]
    f388:	68fb      	ldr	r3, [r7, #12]
    f38a:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    f38c:	687b      	ldr	r3, [r7, #4]
    f38e:	f04f 0200 	mov.w	r2, #0
    f392:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
    f394:	68fb      	ldr	r3, [r7, #12]
    f396:	681b      	ldr	r3, [r3, #0]
    f398:	f103 32ff 	add.w	r2, r3, #4294967295
    f39c:	68fb      	ldr	r3, [r7, #12]
    f39e:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
    f3a0:	68fb      	ldr	r3, [r7, #12]
    f3a2:	681b      	ldr	r3, [r3, #0]
}
    f3a4:	4618      	mov	r0, r3
    f3a6:	f107 0714 	add.w	r7, r7, #20
    f3aa:	46bd      	mov	sp, r7
    f3ac:	bc80      	pop	{r7}
    f3ae:	4770      	bx	lr

0000f3b0 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    f3b0:	b580      	push	{r7, lr}
    f3b2:	b084      	sub	sp, #16
    f3b4:	af00      	add	r7, sp, #0
    f3b6:	6078      	str	r0, [r7, #4]
    f3b8:	6039      	str	r1, [r7, #0]
Queue_t * const pxQueue = xQueue;
    f3ba:	687b      	ldr	r3, [r7, #4]
    f3bc:	60bb      	str	r3, [r7, #8]

	configASSERT( pxQueue );
    f3be:	68bb      	ldr	r3, [r7, #8]
    f3c0:	2b00      	cmp	r3, #0
    f3c2:	d109      	bne.n	f3d8 <xQueueGenericReset+0x28>
    f3c4:	f04f 0328 	mov.w	r3, #40	; 0x28
    f3c8:	f383 8811 	msr	BASEPRI, r3
    f3cc:	f3bf 8f6f 	isb	sy
    f3d0:	f3bf 8f4f 	dsb	sy
    f3d4:	60fb      	str	r3, [r7, #12]
    f3d6:	e7fe      	b.n	f3d6 <xQueueGenericReset+0x26>

	taskENTER_CRITICAL();
    f3d8:	f004 fffe 	bl	143d8 <vPortEnterCritical>
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    f3dc:	68bb      	ldr	r3, [r7, #8]
    f3de:	681a      	ldr	r2, [r3, #0]
    f3e0:	68bb      	ldr	r3, [r7, #8]
    f3e2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    f3e4:	68b9      	ldr	r1, [r7, #8]
    f3e6:	6c09      	ldr	r1, [r1, #64]	; 0x40
    f3e8:	fb01 f303 	mul.w	r3, r1, r3
    f3ec:	441a      	add	r2, r3
    f3ee:	68bb      	ldr	r3, [r7, #8]
    f3f0:	609a      	str	r2, [r3, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    f3f2:	68bb      	ldr	r3, [r7, #8]
    f3f4:	f04f 0200 	mov.w	r2, #0
    f3f8:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
    f3fa:	68bb      	ldr	r3, [r7, #8]
    f3fc:	681a      	ldr	r2, [r3, #0]
    f3fe:	68bb      	ldr	r3, [r7, #8]
    f400:	605a      	str	r2, [r3, #4]
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    f402:	68bb      	ldr	r3, [r7, #8]
    f404:	681a      	ldr	r2, [r3, #0]
    f406:	68bb      	ldr	r3, [r7, #8]
    f408:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    f40a:	f103 33ff 	add.w	r3, r3, #4294967295
    f40e:	68b9      	ldr	r1, [r7, #8]
    f410:	6c09      	ldr	r1, [r1, #64]	; 0x40
    f412:	fb01 f303 	mul.w	r3, r1, r3
    f416:	441a      	add	r2, r3
    f418:	68bb      	ldr	r3, [r7, #8]
    f41a:	60da      	str	r2, [r3, #12]
		pxQueue->cRxLock = queueUNLOCKED;
    f41c:	68bb      	ldr	r3, [r7, #8]
    f41e:	f04f 32ff 	mov.w	r2, #4294967295
    f422:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
    f426:	68bb      	ldr	r3, [r7, #8]
    f428:	f04f 32ff 	mov.w	r2, #4294967295
    f42c:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

		if( xNewQueue == pdFALSE )
    f430:	683b      	ldr	r3, [r7, #0]
    f432:	2b00      	cmp	r3, #0
    f434:	d118      	bne.n	f468 <xQueueGenericReset+0xb8>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    f436:	68bb      	ldr	r3, [r7, #8]
    f438:	691b      	ldr	r3, [r3, #16]
    f43a:	2b00      	cmp	r3, #0
    f43c:	d021      	beq.n	f482 <xQueueGenericReset+0xd2>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    f43e:	68bb      	ldr	r3, [r7, #8]
    f440:	f103 0310 	add.w	r3, r3, #16
    f444:	4618      	mov	r0, r3
    f446:	f002 fd37 	bl	11eb8 <xTaskRemoveFromEventList>
    f44a:	4603      	mov	r3, r0
    f44c:	2b00      	cmp	r3, #0
    f44e:	d01a      	beq.n	f486 <xQueueGenericReset+0xd6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    f450:	f64e 5304 	movw	r3, #60676	; 0xed04
    f454:	f2ce 0300 	movt	r3, #57344	; 0xe000
    f458:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    f45c:	601a      	str	r2, [r3, #0]
    f45e:	f3bf 8f4f 	dsb	sy
    f462:	f3bf 8f6f 	isb	sy
    f466:	e00f      	b.n	f488 <xQueueGenericReset+0xd8>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    f468:	68bb      	ldr	r3, [r7, #8]
    f46a:	f103 0310 	add.w	r3, r3, #16
    f46e:	4618      	mov	r0, r3
    f470:	f7ff fee2 	bl	f238 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    f474:	68bb      	ldr	r3, [r7, #8]
    f476:	f103 0324 	add.w	r3, r3, #36	; 0x24
    f47a:	4618      	mov	r0, r3
    f47c:	f7ff fedc 	bl	f238 <vListInitialise>
    f480:	e002      	b.n	f488 <xQueueGenericReset+0xd8>
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
				{
					queueYIELD_IF_USING_PREEMPTION();
    f482:	bf00      	nop
    f484:	e000      	b.n	f488 <xQueueGenericReset+0xd8>
    f486:	bf00      	nop
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
		}
	}
	taskEXIT_CRITICAL();
    f488:	f004 ffde 	bl	14448 <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    f48c:	f04f 0301 	mov.w	r3, #1
}
    f490:	4618      	mov	r0, r3
    f492:	f107 0710 	add.w	r7, r7, #16
    f496:	46bd      	mov	sp, r7
    f498:	bd80      	pop	{r7, pc}
    f49a:	bf00      	nop

0000f49c <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    f49c:	b580      	push	{r7, lr}
    f49e:	b08a      	sub	sp, #40	; 0x28
    f4a0:	af02      	add	r7, sp, #8
    f4a2:	60f8      	str	r0, [r7, #12]
    f4a4:	60b9      	str	r1, [r7, #8]
    f4a6:	4613      	mov	r3, r2
    f4a8:	71fb      	strb	r3, [r7, #7]
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
    f4aa:	68fb      	ldr	r3, [r7, #12]
    f4ac:	2b00      	cmp	r3, #0
    f4ae:	d109      	bne.n	f4c4 <xQueueGenericCreate+0x28>
    f4b0:	f04f 0328 	mov.w	r3, #40	; 0x28
    f4b4:	f383 8811 	msr	BASEPRI, r3
    f4b8:	f3bf 8f6f 	isb	sy
    f4bc:	f3bf 8f4f 	dsb	sy
    f4c0:	61fb      	str	r3, [r7, #28]
    f4c2:	e7fe      	b.n	f4c2 <xQueueGenericCreate+0x26>

		if( uxItemSize == ( UBaseType_t ) 0 )
    f4c4:	68bb      	ldr	r3, [r7, #8]
    f4c6:	2b00      	cmp	r3, #0
    f4c8:	d103      	bne.n	f4d2 <xQueueGenericCreate+0x36>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    f4ca:	f04f 0300 	mov.w	r3, #0
    f4ce:	617b      	str	r3, [r7, #20]
    f4d0:	e004      	b.n	f4dc <xQueueGenericCreate+0x40>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    f4d2:	68fb      	ldr	r3, [r7, #12]
    f4d4:	68ba      	ldr	r2, [r7, #8]
    f4d6:	fb02 f303 	mul.w	r3, r2, r3
    f4da:	617b      	str	r3, [r7, #20]
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    f4dc:	697b      	ldr	r3, [r7, #20]
    f4de:	f103 0350 	add.w	r3, r3, #80	; 0x50
    f4e2:	4618      	mov	r0, r3
    f4e4:	f004 fcfa 	bl	13edc <pvPortMalloc>
    f4e8:	4603      	mov	r3, r0
    f4ea:	613b      	str	r3, [r7, #16]

		if( pxNewQueue != NULL )
    f4ec:	693b      	ldr	r3, [r7, #16]
    f4ee:	2b00      	cmp	r3, #0
    f4f0:	d00d      	beq.n	f50e <xQueueGenericCreate+0x72>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    f4f2:	693b      	ldr	r3, [r7, #16]
    f4f4:	61bb      	str	r3, [r7, #24]
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    f4f6:	69bb      	ldr	r3, [r7, #24]
    f4f8:	f103 0350 	add.w	r3, r3, #80	; 0x50
    f4fc:	61bb      	str	r3, [r7, #24]
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    f4fe:	79fb      	ldrb	r3, [r7, #7]
    f500:	693a      	ldr	r2, [r7, #16]
    f502:	9200      	str	r2, [sp, #0]
    f504:	68f8      	ldr	r0, [r7, #12]
    f506:	68b9      	ldr	r1, [r7, #8]
    f508:	69ba      	ldr	r2, [r7, #24]
    f50a:	f000 f807 	bl	f51c <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    f50e:	693b      	ldr	r3, [r7, #16]
	}
    f510:	4618      	mov	r0, r3
    f512:	f107 0720 	add.w	r7, r7, #32
    f516:	46bd      	mov	sp, r7
    f518:	bd80      	pop	{r7, pc}
    f51a:	bf00      	nop

0000f51c <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    f51c:	b580      	push	{r7, lr}
    f51e:	b084      	sub	sp, #16
    f520:	af00      	add	r7, sp, #0
    f522:	60f8      	str	r0, [r7, #12]
    f524:	60b9      	str	r1, [r7, #8]
    f526:	607a      	str	r2, [r7, #4]
    f528:	70fb      	strb	r3, [r7, #3]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    f52a:	68bb      	ldr	r3, [r7, #8]
    f52c:	2b00      	cmp	r3, #0
    f52e:	d103      	bne.n	f538 <prvInitialiseNewQueue+0x1c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    f530:	69ba      	ldr	r2, [r7, #24]
    f532:	69bb      	ldr	r3, [r7, #24]
    f534:	601a      	str	r2, [r3, #0]
    f536:	e002      	b.n	f53e <prvInitialiseNewQueue+0x22>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    f538:	687a      	ldr	r2, [r7, #4]
    f53a:	69bb      	ldr	r3, [r7, #24]
    f53c:	601a      	str	r2, [r3, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    f53e:	69bb      	ldr	r3, [r7, #24]
    f540:	68fa      	ldr	r2, [r7, #12]
    f542:	63da      	str	r2, [r3, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
    f544:	69bb      	ldr	r3, [r7, #24]
    f546:	68ba      	ldr	r2, [r7, #8]
    f548:	641a      	str	r2, [r3, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    f54a:	69b8      	ldr	r0, [r7, #24]
    f54c:	f04f 0101 	mov.w	r1, #1
    f550:	f7ff ff2e 	bl	f3b0 <xQueueGenericReset>

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
    f554:	69bb      	ldr	r3, [r7, #24]
    f556:	78fa      	ldrb	r2, [r7, #3]
    f558:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    f55c:	f107 0710 	add.w	r7, r7, #16
    f560:	46bd      	mov	sp, r7
    f562:	bd80      	pop	{r7, pc}

0000f564 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
    f564:	b580      	push	{r7, lr}
    f566:	b082      	sub	sp, #8
    f568:	af00      	add	r7, sp, #0
    f56a:	6078      	str	r0, [r7, #4]
		if( pxNewQueue != NULL )
    f56c:	687b      	ldr	r3, [r7, #4]
    f56e:	2b00      	cmp	r3, #0
    f570:	d014      	beq.n	f59c <prvInitialiseMutex+0x38>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
    f572:	687b      	ldr	r3, [r7, #4]
    f574:	f04f 0200 	mov.w	r2, #0
    f578:	609a      	str	r2, [r3, #8]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    f57a:	687b      	ldr	r3, [r7, #4]
    f57c:	f04f 0200 	mov.w	r2, #0
    f580:	601a      	str	r2, [r3, #0]

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
    f582:	687b      	ldr	r3, [r7, #4]
    f584:	f04f 0200 	mov.w	r2, #0
    f588:	60da      	str	r2, [r3, #12]

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    f58a:	6878      	ldr	r0, [r7, #4]
    f58c:	f04f 0100 	mov.w	r1, #0
    f590:	f04f 0200 	mov.w	r2, #0
    f594:	f04f 0300 	mov.w	r3, #0
    f598:	f000 f894 	bl	f6c4 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
    f59c:	f107 0708 	add.w	r7, r7, #8
    f5a0:	46bd      	mov	sp, r7
    f5a2:	bd80      	pop	{r7, pc}

0000f5a4 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    f5a4:	b580      	push	{r7, lr}
    f5a6:	b086      	sub	sp, #24
    f5a8:	af00      	add	r7, sp, #0
    f5aa:	4603      	mov	r3, r0
    f5ac:	71fb      	strb	r3, [r7, #7]
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    f5ae:	f04f 0301 	mov.w	r3, #1
    f5b2:	613b      	str	r3, [r7, #16]
    f5b4:	f04f 0300 	mov.w	r3, #0
    f5b8:	617b      	str	r3, [r7, #20]

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    f5ba:	79fb      	ldrb	r3, [r7, #7]
    f5bc:	6938      	ldr	r0, [r7, #16]
    f5be:	6979      	ldr	r1, [r7, #20]
    f5c0:	461a      	mov	r2, r3
    f5c2:	f7ff ff6b 	bl	f49c <xQueueGenericCreate>
    f5c6:	4603      	mov	r3, r0
    f5c8:	60fb      	str	r3, [r7, #12]
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
    f5ca:	68f8      	ldr	r0, [r7, #12]
    f5cc:	f7ff ffca 	bl	f564 <prvInitialiseMutex>

		return xNewQueue;
    f5d0:	68fb      	ldr	r3, [r7, #12]
	}
    f5d2:	4618      	mov	r0, r3
    f5d4:	f107 0718 	add.w	r7, r7, #24
    f5d8:	46bd      	mov	sp, r7
    f5da:	bd80      	pop	{r7, pc}

0000f5dc <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
	{
    f5dc:	b590      	push	{r4, r7, lr}
    f5de:	b087      	sub	sp, #28
    f5e0:	af00      	add	r7, sp, #0
    f5e2:	6078      	str	r0, [r7, #4]
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
    f5e4:	687b      	ldr	r3, [r7, #4]
    f5e6:	613b      	str	r3, [r7, #16]

		configASSERT( pxMutex );
    f5e8:	693b      	ldr	r3, [r7, #16]
    f5ea:	2b00      	cmp	r3, #0
    f5ec:	d109      	bne.n	f602 <xQueueGiveMutexRecursive+0x26>
    f5ee:	f04f 0328 	mov.w	r3, #40	; 0x28
    f5f2:	f383 8811 	msr	BASEPRI, r3
    f5f6:	f3bf 8f6f 	isb	sy
    f5fa:	f3bf 8f4f 	dsb	sy
    f5fe:	617b      	str	r3, [r7, #20]
    f600:	e7fe      	b.n	f600 <xQueueGiveMutexRecursive+0x24>
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
    f602:	693b      	ldr	r3, [r7, #16]
    f604:	689c      	ldr	r4, [r3, #8]
    f606:	f002 ffed 	bl	125e4 <xTaskGetCurrentTaskHandle>
    f60a:	4603      	mov	r3, r0
    f60c:	429c      	cmp	r4, r3
    f60e:	d116      	bne.n	f63e <xQueueGiveMutexRecursive+0x62>
			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
    f610:	693b      	ldr	r3, [r7, #16]
    f612:	68db      	ldr	r3, [r3, #12]
    f614:	f103 32ff 	add.w	r2, r3, #4294967295
    f618:	693b      	ldr	r3, [r7, #16]
    f61a:	60da      	str	r2, [r3, #12]

			/* Has the recursive call count unwound to 0? */
			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
    f61c:	693b      	ldr	r3, [r7, #16]
    f61e:	68db      	ldr	r3, [r3, #12]
    f620:	2b00      	cmp	r3, #0
    f622:	d108      	bne.n	f636 <xQueueGiveMutexRecursive+0x5a>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
    f624:	6938      	ldr	r0, [r7, #16]
    f626:	f04f 0100 	mov.w	r1, #0
    f62a:	f04f 0200 	mov.w	r2, #0
    f62e:	f04f 0300 	mov.w	r3, #0
    f632:	f000 f847 	bl	f6c4 <xQueueGenericSend>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    f636:	f04f 0301 	mov.w	r3, #1
    f63a:	60fb      	str	r3, [r7, #12]
    f63c:	e002      	b.n	f644 <xQueueGiveMutexRecursive+0x68>
		}
		else
		{
			/* The mutex cannot be given because the calling task is not the
			holder. */
			xReturn = pdFAIL;
    f63e:	f04f 0300 	mov.w	r3, #0
    f642:	60fb      	str	r3, [r7, #12]

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
    f644:	68fb      	ldr	r3, [r7, #12]
	}
    f646:	4618      	mov	r0, r3
    f648:	f107 071c 	add.w	r7, r7, #28
    f64c:	46bd      	mov	sp, r7
    f64e:	bd90      	pop	{r4, r7, pc}

0000f650 <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
	{
    f650:	b590      	push	{r4, r7, lr}
    f652:	b087      	sub	sp, #28
    f654:	af00      	add	r7, sp, #0
    f656:	6078      	str	r0, [r7, #4]
    f658:	6039      	str	r1, [r7, #0]
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
    f65a:	687b      	ldr	r3, [r7, #4]
    f65c:	613b      	str	r3, [r7, #16]

		configASSERT( pxMutex );
    f65e:	693b      	ldr	r3, [r7, #16]
    f660:	2b00      	cmp	r3, #0
    f662:	d109      	bne.n	f678 <xQueueTakeMutexRecursive+0x28>
    f664:	f04f 0328 	mov.w	r3, #40	; 0x28
    f668:	f383 8811 	msr	BASEPRI, r3
    f66c:	f3bf 8f6f 	isb	sy
    f670:	f3bf 8f4f 	dsb	sy
    f674:	617b      	str	r3, [r7, #20]
    f676:	e7fe      	b.n	f676 <xQueueTakeMutexRecursive+0x26>
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
    f678:	693b      	ldr	r3, [r7, #16]
    f67a:	689c      	ldr	r4, [r3, #8]
    f67c:	f002 ffb2 	bl	125e4 <xTaskGetCurrentTaskHandle>
    f680:	4603      	mov	r3, r0
    f682:	429c      	cmp	r4, r3
    f684:	d109      	bne.n	f69a <xQueueTakeMutexRecursive+0x4a>
		{
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
    f686:	693b      	ldr	r3, [r7, #16]
    f688:	68db      	ldr	r3, [r3, #12]
    f68a:	f103 0201 	add.w	r2, r3, #1
    f68e:	693b      	ldr	r3, [r7, #16]
    f690:	60da      	str	r2, [r3, #12]
			xReturn = pdPASS;
    f692:	f04f 0301 	mov.w	r3, #1
    f696:	60fb      	str	r3, [r7, #12]
    f698:	e00e      	b.n	f6b8 <xQueueTakeMutexRecursive+0x68>
		}
		else
		{
			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
    f69a:	6938      	ldr	r0, [r7, #16]
    f69c:	6839      	ldr	r1, [r7, #0]
    f69e:	f000 fb57 	bl	fd50 <xQueueSemaphoreTake>
    f6a2:	4603      	mov	r3, r0
    f6a4:	60fb      	str	r3, [r7, #12]

			/* pdPASS will only be returned if the mutex was successfully
			obtained.  The calling task may have entered the Blocked state
			before reaching here. */
			if( xReturn != pdFAIL )
    f6a6:	68fb      	ldr	r3, [r7, #12]
    f6a8:	2b00      	cmp	r3, #0
    f6aa:	d005      	beq.n	f6b8 <xQueueTakeMutexRecursive+0x68>
			{
				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
    f6ac:	693b      	ldr	r3, [r7, #16]
    f6ae:	68db      	ldr	r3, [r3, #12]
    f6b0:	f103 0201 	add.w	r2, r3, #1
    f6b4:	693b      	ldr	r3, [r7, #16]
    f6b6:	60da      	str	r2, [r3, #12]
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
    f6b8:	68fb      	ldr	r3, [r7, #12]
	}
    f6ba:	4618      	mov	r0, r3
    f6bc:	f107 071c 	add.w	r7, r7, #28
    f6c0:	46bd      	mov	sp, r7
    f6c2:	bd90      	pop	{r4, r7, pc}

0000f6c4 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    f6c4:	b580      	push	{r7, lr}
    f6c6:	b08e      	sub	sp, #56	; 0x38
    f6c8:	af00      	add	r7, sp, #0
    f6ca:	60f8      	str	r0, [r7, #12]
    f6cc:	60b9      	str	r1, [r7, #8]
    f6ce:	607a      	str	r2, [r7, #4]
    f6d0:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    f6d2:	f04f 0300 	mov.w	r3, #0
    f6d6:	61fb      	str	r3, [r7, #28]
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    f6d8:	68fb      	ldr	r3, [r7, #12]
    f6da:	627b      	str	r3, [r7, #36]	; 0x24

	configASSERT( pxQueue );
    f6dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f6de:	2b00      	cmp	r3, #0
    f6e0:	d109      	bne.n	f6f6 <xQueueGenericSend+0x32>
    f6e2:	f04f 0328 	mov.w	r3, #40	; 0x28
    f6e6:	f383 8811 	msr	BASEPRI, r3
    f6ea:	f3bf 8f6f 	isb	sy
    f6ee:	f3bf 8f4f 	dsb	sy
    f6f2:	62bb      	str	r3, [r7, #40]	; 0x28
    f6f4:	e7fe      	b.n	f6f4 <xQueueGenericSend+0x30>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    f6f6:	68bb      	ldr	r3, [r7, #8]
    f6f8:	2b00      	cmp	r3, #0
    f6fa:	d103      	bne.n	f704 <xQueueGenericSend+0x40>
    f6fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f6fe:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    f700:	2b00      	cmp	r3, #0
    f702:	d102      	bne.n	f70a <xQueueGenericSend+0x46>
    f704:	f04f 0301 	mov.w	r3, #1
    f708:	e001      	b.n	f70e <xQueueGenericSend+0x4a>
    f70a:	f04f 0300 	mov.w	r3, #0
    f70e:	2b00      	cmp	r3, #0
    f710:	d109      	bne.n	f726 <xQueueGenericSend+0x62>
    f712:	f04f 0328 	mov.w	r3, #40	; 0x28
    f716:	f383 8811 	msr	BASEPRI, r3
    f71a:	f3bf 8f6f 	isb	sy
    f71e:	f3bf 8f4f 	dsb	sy
    f722:	62fb      	str	r3, [r7, #44]	; 0x2c
    f724:	e7fe      	b.n	f724 <xQueueGenericSend+0x60>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    f726:	683b      	ldr	r3, [r7, #0]
    f728:	2b02      	cmp	r3, #2
    f72a:	d103      	bne.n	f734 <xQueueGenericSend+0x70>
    f72c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f72e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    f730:	2b01      	cmp	r3, #1
    f732:	d102      	bne.n	f73a <xQueueGenericSend+0x76>
    f734:	f04f 0301 	mov.w	r3, #1
    f738:	e001      	b.n	f73e <xQueueGenericSend+0x7a>
    f73a:	f04f 0300 	mov.w	r3, #0
    f73e:	2b00      	cmp	r3, #0
    f740:	d109      	bne.n	f756 <xQueueGenericSend+0x92>
    f742:	f04f 0328 	mov.w	r3, #40	; 0x28
    f746:	f383 8811 	msr	BASEPRI, r3
    f74a:	f3bf 8f6f 	isb	sy
    f74e:	f3bf 8f4f 	dsb	sy
    f752:	633b      	str	r3, [r7, #48]	; 0x30
    f754:	e7fe      	b.n	f754 <xQueueGenericSend+0x90>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    f756:	f002 ff55 	bl	12604 <xTaskGetSchedulerState>
    f75a:	4603      	mov	r3, r0
    f75c:	2b00      	cmp	r3, #0
    f75e:	d102      	bne.n	f766 <xQueueGenericSend+0xa2>
    f760:	687b      	ldr	r3, [r7, #4]
    f762:	2b00      	cmp	r3, #0
    f764:	d102      	bne.n	f76c <xQueueGenericSend+0xa8>
    f766:	f04f 0301 	mov.w	r3, #1
    f76a:	e001      	b.n	f770 <xQueueGenericSend+0xac>
    f76c:	f04f 0300 	mov.w	r3, #0
    f770:	2b00      	cmp	r3, #0
    f772:	d10a      	bne.n	f78a <xQueueGenericSend+0xc6>
    f774:	f04f 0328 	mov.w	r3, #40	; 0x28
    f778:	f383 8811 	msr	BASEPRI, r3
    f77c:	f3bf 8f6f 	isb	sy
    f780:	f3bf 8f4f 	dsb	sy
    f784:	637b      	str	r3, [r7, #52]	; 0x34
    f786:	e7fe      	b.n	f786 <xQueueGenericSend+0xc2>
			( void ) xTaskResumeAll();

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	} /*lint -restore */
    f788:	bf00      	nop
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    f78a:	f004 fe25 	bl	143d8 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    f78e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f790:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    f792:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f794:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    f796:	429a      	cmp	r2, r3
    f798:	d302      	bcc.n	f7a0 <xQueueGenericSend+0xdc>
    f79a:	683b      	ldr	r3, [r7, #0]
    f79c:	2b02      	cmp	r3, #2
    f79e:	d134      	bne.n	f80a <xQueueGenericSend+0x146>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    f7a0:	6a78      	ldr	r0, [r7, #36]	; 0x24
    f7a2:	68b9      	ldr	r1, [r7, #8]
    f7a4:	683a      	ldr	r2, [r7, #0]
    f7a6:	f000 fe9d 	bl	104e4 <prvCopyDataToQueue>
    f7aa:	4603      	mov	r3, r0
    f7ac:	623b      	str	r3, [r7, #32]

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    f7ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f7b0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    f7b2:	2b00      	cmp	r3, #0
    f7b4:	d014      	beq.n	f7e0 <xQueueGenericSend+0x11c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    f7b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f7b8:	f103 0324 	add.w	r3, r3, #36	; 0x24
    f7bc:	4618      	mov	r0, r3
    f7be:	f002 fb7b 	bl	11eb8 <xTaskRemoveFromEventList>
    f7c2:	4603      	mov	r3, r0
    f7c4:	2b00      	cmp	r3, #0
    f7c6:	d01a      	beq.n	f7fe <xQueueGenericSend+0x13a>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    f7c8:	f64e 5304 	movw	r3, #60676	; 0xed04
    f7cc:	f2ce 0300 	movt	r3, #57344	; 0xe000
    f7d0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    f7d4:	601a      	str	r2, [r3, #0]
    f7d6:	f3bf 8f4f 	dsb	sy
    f7da:	f3bf 8f6f 	isb	sy
    f7de:	e00f      	b.n	f800 <xQueueGenericSend+0x13c>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    f7e0:	6a3b      	ldr	r3, [r7, #32]
    f7e2:	2b00      	cmp	r3, #0
    f7e4:	d00c      	beq.n	f800 <xQueueGenericSend+0x13c>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    f7e6:	f64e 5304 	movw	r3, #60676	; 0xed04
    f7ea:	f2ce 0300 	movt	r3, #57344	; 0xe000
    f7ee:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    f7f2:	601a      	str	r2, [r3, #0]
    f7f4:	f3bf 8f4f 	dsb	sy
    f7f8:	f3bf 8f6f 	isb	sy
    f7fc:	e000      	b.n	f800 <xQueueGenericSend+0x13c>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    f7fe:	bf00      	nop
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    f800:	f004 fe22 	bl	14448 <vPortExitCritical>
				return pdPASS;
    f804:	f04f 0301 	mov.w	r3, #1
    f808:	e06f      	b.n	f8ea <xQueueGenericSend+0x226>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    f80a:	687b      	ldr	r3, [r7, #4]
    f80c:	2b00      	cmp	r3, #0
    f80e:	d104      	bne.n	f81a <xQueueGenericSend+0x156>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    f810:	f004 fe1a 	bl	14448 <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    f814:	f04f 0300 	mov.w	r3, #0
    f818:	e067      	b.n	f8ea <xQueueGenericSend+0x226>
				}
				else if( xEntryTimeSet == pdFALSE )
    f81a:	69fb      	ldr	r3, [r7, #28]
    f81c:	2b00      	cmp	r3, #0
    f81e:	d107      	bne.n	f830 <xQueueGenericSend+0x16c>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    f820:	f107 0314 	add.w	r3, r7, #20
    f824:	4618      	mov	r0, r3
    f826:	f002 fc57 	bl	120d8 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    f82a:	f04f 0301 	mov.w	r3, #1
    f82e:	61fb      	str	r3, [r7, #28]
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    f830:	f004 fe0a 	bl	14448 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    f834:	f001 feee 	bl	11614 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    f838:	f004 fdce 	bl	143d8 <vPortEnterCritical>
    f83c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f83e:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
    f842:	b2db      	uxtb	r3, r3
    f844:	b25b      	sxtb	r3, r3
    f846:	f1b3 3fff 	cmp.w	r3, #4294967295
    f84a:	d104      	bne.n	f856 <xQueueGenericSend+0x192>
    f84c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f84e:	f04f 0200 	mov.w	r2, #0
    f852:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    f856:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f858:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
    f85c:	b2db      	uxtb	r3, r3
    f85e:	b25b      	sxtb	r3, r3
    f860:	f1b3 3fff 	cmp.w	r3, #4294967295
    f864:	d104      	bne.n	f870 <xQueueGenericSend+0x1ac>
    f866:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f868:	f04f 0200 	mov.w	r2, #0
    f86c:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
    f870:	f004 fdea 	bl	14448 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    f874:	f107 0214 	add.w	r2, r7, #20
    f878:	f107 0304 	add.w	r3, r7, #4
    f87c:	4610      	mov	r0, r2
    f87e:	4619      	mov	r1, r3
    f880:	f002 fc42 	bl	12108 <xTaskCheckForTimeOut>
    f884:	4603      	mov	r3, r0
    f886:	2b00      	cmp	r3, #0
    f888:	d128      	bne.n	f8dc <xQueueGenericSend+0x218>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    f88a:	6a78      	ldr	r0, [r7, #36]	; 0x24
    f88c:	f000 ff60 	bl	10750 <prvIsQueueFull>
    f890:	4603      	mov	r3, r0
    f892:	2b00      	cmp	r3, #0
    f894:	d01c      	beq.n	f8d0 <xQueueGenericSend+0x20c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    f896:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f898:	f103 0210 	add.w	r2, r3, #16
    f89c:	687b      	ldr	r3, [r7, #4]
    f89e:	4610      	mov	r0, r2
    f8a0:	4619      	mov	r1, r3
    f8a2:	f002 fa75 	bl	11d90 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    f8a6:	6a78      	ldr	r0, [r7, #36]	; 0x24
    f8a8:	f000 febc 	bl	10624 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    f8ac:	f001 fec4 	bl	11638 <xTaskResumeAll>
    f8b0:	4603      	mov	r3, r0
    f8b2:	2b00      	cmp	r3, #0
    f8b4:	f47f af68 	bne.w	f788 <xQueueGenericSend+0xc4>
				{
					portYIELD_WITHIN_API();
    f8b8:	f64e 5304 	movw	r3, #60676	; 0xed04
    f8bc:	f2ce 0300 	movt	r3, #57344	; 0xe000
    f8c0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    f8c4:	601a      	str	r2, [r3, #0]
    f8c6:	f3bf 8f4f 	dsb	sy
    f8ca:	f3bf 8f6f 	isb	sy
			( void ) xTaskResumeAll();

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	} /*lint -restore */
    f8ce:	e75c      	b.n	f78a <xQueueGenericSend+0xc6>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    f8d0:	6a78      	ldr	r0, [r7, #36]	; 0x24
    f8d2:	f000 fea7 	bl	10624 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    f8d6:	f001 feaf 	bl	11638 <xTaskResumeAll>
			( void ) xTaskResumeAll();

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	} /*lint -restore */
    f8da:	e756      	b.n	f78a <xQueueGenericSend+0xc6>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    f8dc:	6a78      	ldr	r0, [r7, #36]	; 0x24
    f8de:	f000 fea1 	bl	10624 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    f8e2:	f001 fea9 	bl	11638 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    f8e6:	f04f 0300 	mov.w	r3, #0
		}
	} /*lint -restore */
}
    f8ea:	4618      	mov	r0, r3
    f8ec:	f107 0738 	add.w	r7, r7, #56	; 0x38
    f8f0:	46bd      	mov	sp, r7
    f8f2:	bd80      	pop	{r7, pc}

0000f8f4 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    f8f4:	b580      	push	{r7, lr}
    f8f6:	b08e      	sub	sp, #56	; 0x38
    f8f8:	af00      	add	r7, sp, #0
    f8fa:	60f8      	str	r0, [r7, #12]
    f8fc:	60b9      	str	r1, [r7, #8]
    f8fe:	607a      	str	r2, [r7, #4]
    f900:	603b      	str	r3, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    f902:	68fb      	ldr	r3, [r7, #12]
    f904:	61bb      	str	r3, [r7, #24]

	configASSERT( pxQueue );
    f906:	69bb      	ldr	r3, [r7, #24]
    f908:	2b00      	cmp	r3, #0
    f90a:	d109      	bne.n	f920 <xQueueGenericSendFromISR+0x2c>
    f90c:	f04f 0328 	mov.w	r3, #40	; 0x28
    f910:	f383 8811 	msr	BASEPRI, r3
    f914:	f3bf 8f6f 	isb	sy
    f918:	f3bf 8f4f 	dsb	sy
    f91c:	623b      	str	r3, [r7, #32]
    f91e:	e7fe      	b.n	f91e <xQueueGenericSendFromISR+0x2a>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    f920:	68bb      	ldr	r3, [r7, #8]
    f922:	2b00      	cmp	r3, #0
    f924:	d103      	bne.n	f92e <xQueueGenericSendFromISR+0x3a>
    f926:	69bb      	ldr	r3, [r7, #24]
    f928:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    f92a:	2b00      	cmp	r3, #0
    f92c:	d102      	bne.n	f934 <xQueueGenericSendFromISR+0x40>
    f92e:	f04f 0301 	mov.w	r3, #1
    f932:	e001      	b.n	f938 <xQueueGenericSendFromISR+0x44>
    f934:	f04f 0300 	mov.w	r3, #0
    f938:	2b00      	cmp	r3, #0
    f93a:	d109      	bne.n	f950 <xQueueGenericSendFromISR+0x5c>
    f93c:	f04f 0328 	mov.w	r3, #40	; 0x28
    f940:	f383 8811 	msr	BASEPRI, r3
    f944:	f3bf 8f6f 	isb	sy
    f948:	f3bf 8f4f 	dsb	sy
    f94c:	627b      	str	r3, [r7, #36]	; 0x24
    f94e:	e7fe      	b.n	f94e <xQueueGenericSendFromISR+0x5a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    f950:	683b      	ldr	r3, [r7, #0]
    f952:	2b02      	cmp	r3, #2
    f954:	d103      	bne.n	f95e <xQueueGenericSendFromISR+0x6a>
    f956:	69bb      	ldr	r3, [r7, #24]
    f958:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    f95a:	2b01      	cmp	r3, #1
    f95c:	d102      	bne.n	f964 <xQueueGenericSendFromISR+0x70>
    f95e:	f04f 0301 	mov.w	r3, #1
    f962:	e001      	b.n	f968 <xQueueGenericSendFromISR+0x74>
    f964:	f04f 0300 	mov.w	r3, #0
    f968:	2b00      	cmp	r3, #0
    f96a:	d109      	bne.n	f980 <xQueueGenericSendFromISR+0x8c>
    f96c:	f04f 0328 	mov.w	r3, #40	; 0x28
    f970:	f383 8811 	msr	BASEPRI, r3
    f974:	f3bf 8f6f 	isb	sy
    f978:	f3bf 8f4f 	dsb	sy
    f97c:	62bb      	str	r3, [r7, #40]	; 0x28
    f97e:	e7fe      	b.n	f97e <xQueueGenericSendFromISR+0x8a>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    f980:	f004 fe0e 	bl	145a0 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
    f984:	f3ef 8211 	mrs	r2, BASEPRI
    f988:	f04f 0328 	mov.w	r3, #40	; 0x28
    f98c:	f383 8811 	msr	BASEPRI, r3
    f990:	f3bf 8f6f 	isb	sy
    f994:	f3bf 8f4f 	dsb	sy
    f998:	633a      	str	r2, [r7, #48]	; 0x30
    f99a:	62fb      	str	r3, [r7, #44]	; 0x2c
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
    f99c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    f99e:	617b      	str	r3, [r7, #20]
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    f9a0:	69bb      	ldr	r3, [r7, #24]
    f9a2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    f9a4:	69bb      	ldr	r3, [r7, #24]
    f9a6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    f9a8:	429a      	cmp	r2, r3
    f9aa:	d302      	bcc.n	f9b2 <xQueueGenericSendFromISR+0xbe>
    f9ac:	683b      	ldr	r3, [r7, #0]
    f9ae:	2b02      	cmp	r3, #2
    f9b0:	d134      	bne.n	fa1c <xQueueGenericSendFromISR+0x128>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    f9b2:	69bb      	ldr	r3, [r7, #24]
    f9b4:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
    f9b8:	77fb      	strb	r3, [r7, #31]
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    f9ba:	69b8      	ldr	r0, [r7, #24]
    f9bc:	68b9      	ldr	r1, [r7, #8]
    f9be:	683a      	ldr	r2, [r7, #0]
    f9c0:	f000 fd90 	bl	104e4 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    f9c4:	f997 301f 	ldrsb.w	r3, [r7, #31]
    f9c8:	f1b3 3fff 	cmp.w	r3, #4294967295
    f9cc:	d114      	bne.n	f9f8 <xQueueGenericSendFromISR+0x104>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    f9ce:	69bb      	ldr	r3, [r7, #24]
    f9d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    f9d2:	2b00      	cmp	r3, #0
    f9d4:	d019      	beq.n	fa0a <xQueueGenericSendFromISR+0x116>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    f9d6:	69bb      	ldr	r3, [r7, #24]
    f9d8:	f103 0324 	add.w	r3, r3, #36	; 0x24
    f9dc:	4618      	mov	r0, r3
    f9de:	f002 fa6b 	bl	11eb8 <xTaskRemoveFromEventList>
    f9e2:	4603      	mov	r3, r0
    f9e4:	2b00      	cmp	r3, #0
    f9e6:	d012      	beq.n	fa0e <xQueueGenericSendFromISR+0x11a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    f9e8:	687b      	ldr	r3, [r7, #4]
    f9ea:	2b00      	cmp	r3, #0
    f9ec:	d011      	beq.n	fa12 <xQueueGenericSendFromISR+0x11e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    f9ee:	687b      	ldr	r3, [r7, #4]
    f9f0:	f04f 0201 	mov.w	r2, #1
    f9f4:	601a      	str	r2, [r3, #0]
    f9f6:	e00d      	b.n	fa14 <xQueueGenericSendFromISR+0x120>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    f9f8:	7ffb      	ldrb	r3, [r7, #31]
    f9fa:	f103 0301 	add.w	r3, r3, #1
    f9fe:	b2db      	uxtb	r3, r3
    fa00:	461a      	mov	r2, r3
    fa02:	69bb      	ldr	r3, [r7, #24]
    fa04:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
    fa08:	e004      	b.n	fa14 <xQueueGenericSendFromISR+0x120>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    fa0a:	bf00      	nop
    fa0c:	e002      	b.n	fa14 <xQueueGenericSendFromISR+0x120>
    fa0e:	bf00      	nop
    fa10:	e000      	b.n	fa14 <xQueueGenericSendFromISR+0x120>
    fa12:	bf00      	nop
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    fa14:	f04f 0301 	mov.w	r3, #1
    fa18:	613b      	str	r3, [r7, #16]
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    fa1a:	e002      	b.n	fa22 <xQueueGenericSendFromISR+0x12e>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    fa1c:	f04f 0300 	mov.w	r3, #0
    fa20:	613b      	str	r3, [r7, #16]
    fa22:	697b      	ldr	r3, [r7, #20]
    fa24:	637b      	str	r3, [r7, #52]	; 0x34
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
    fa26:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    fa28:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    fa2c:	693b      	ldr	r3, [r7, #16]
}
    fa2e:	4618      	mov	r0, r3
    fa30:	f107 0738 	add.w	r7, r7, #56	; 0x38
    fa34:	46bd      	mov	sp, r7
    fa36:	bd80      	pop	{r7, pc}

0000fa38 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    fa38:	b580      	push	{r7, lr}
    fa3a:	b08e      	sub	sp, #56	; 0x38
    fa3c:	af00      	add	r7, sp, #0
    fa3e:	6078      	str	r0, [r7, #4]
    fa40:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    fa42:	687b      	ldr	r3, [r7, #4]
    fa44:	617b      	str	r3, [r7, #20]
	item size is 0.  Don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */

	configASSERT( pxQueue );
    fa46:	697b      	ldr	r3, [r7, #20]
    fa48:	2b00      	cmp	r3, #0
    fa4a:	d109      	bne.n	fa60 <xQueueGiveFromISR+0x28>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
    fa4c:	f04f 0328 	mov.w	r3, #40	; 0x28
    fa50:	f383 8811 	msr	BASEPRI, r3
    fa54:	f3bf 8f6f 	isb	sy
    fa58:	f3bf 8f4f 	dsb	sy
    fa5c:	623b      	str	r3, [r7, #32]
    fa5e:	e7fe      	b.n	fa5e <xQueueGiveFromISR+0x26>

	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
	if the item size is not 0. */
	configASSERT( pxQueue->uxItemSize == 0 );
    fa60:	697b      	ldr	r3, [r7, #20]
    fa62:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    fa64:	2b00      	cmp	r3, #0
    fa66:	d009      	beq.n	fa7c <xQueueGiveFromISR+0x44>
    fa68:	f04f 0328 	mov.w	r3, #40	; 0x28
    fa6c:	f383 8811 	msr	BASEPRI, r3
    fa70:	f3bf 8f6f 	isb	sy
    fa74:	f3bf 8f4f 	dsb	sy
    fa78:	627b      	str	r3, [r7, #36]	; 0x24
    fa7a:	e7fe      	b.n	fa7a <xQueueGiveFromISR+0x42>

	/* Normally a mutex would not be given from an interrupt, especially if
	there is a mutex holder, as priority inheritance makes no sense for an
	interrupts, only tasks. */
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
    fa7c:	697b      	ldr	r3, [r7, #20]
    fa7e:	681b      	ldr	r3, [r3, #0]
    fa80:	2b00      	cmp	r3, #0
    fa82:	d103      	bne.n	fa8c <xQueueGiveFromISR+0x54>
    fa84:	697b      	ldr	r3, [r7, #20]
    fa86:	689b      	ldr	r3, [r3, #8]
    fa88:	2b00      	cmp	r3, #0
    fa8a:	d102      	bne.n	fa92 <xQueueGiveFromISR+0x5a>
    fa8c:	f04f 0301 	mov.w	r3, #1
    fa90:	e001      	b.n	fa96 <xQueueGiveFromISR+0x5e>
    fa92:	f04f 0300 	mov.w	r3, #0
    fa96:	2b00      	cmp	r3, #0
    fa98:	d109      	bne.n	faae <xQueueGiveFromISR+0x76>
    fa9a:	f04f 0328 	mov.w	r3, #40	; 0x28
    fa9e:	f383 8811 	msr	BASEPRI, r3
    faa2:	f3bf 8f6f 	isb	sy
    faa6:	f3bf 8f4f 	dsb	sy
    faaa:	62bb      	str	r3, [r7, #40]	; 0x28
    faac:	e7fe      	b.n	faac <xQueueGiveFromISR+0x74>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    faae:	f004 fd77 	bl	145a0 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
    fab2:	f3ef 8211 	mrs	r2, BASEPRI
    fab6:	f04f 0328 	mov.w	r3, #40	; 0x28
    faba:	f383 8811 	msr	BASEPRI, r3
    fabe:	f3bf 8f6f 	isb	sy
    fac2:	f3bf 8f4f 	dsb	sy
    fac6:	633a      	str	r2, [r7, #48]	; 0x30
    fac8:	62fb      	str	r3, [r7, #44]	; 0x2c
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
    faca:	6b3b      	ldr	r3, [r7, #48]	; 0x30

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    facc:	613b      	str	r3, [r7, #16]
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    face:	697b      	ldr	r3, [r7, #20]
    fad0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    fad2:	61bb      	str	r3, [r7, #24]

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    fad4:	697b      	ldr	r3, [r7, #20]
    fad6:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    fad8:	69bb      	ldr	r3, [r7, #24]
    fada:	429a      	cmp	r2, r3
    fadc:	d934      	bls.n	fb48 <xQueueGiveFromISR+0x110>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    fade:	697b      	ldr	r3, [r7, #20]
    fae0:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
    fae4:	77fb      	strb	r3, [r7, #31]
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    fae6:	69bb      	ldr	r3, [r7, #24]
    fae8:	f103 0201 	add.w	r2, r3, #1
    faec:	697b      	ldr	r3, [r7, #20]
    faee:	639a      	str	r2, [r3, #56]	; 0x38

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    faf0:	f997 301f 	ldrsb.w	r3, [r7, #31]
    faf4:	f1b3 3fff 	cmp.w	r3, #4294967295
    faf8:	d114      	bne.n	fb24 <xQueueGiveFromISR+0xec>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    fafa:	697b      	ldr	r3, [r7, #20]
    fafc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    fafe:	2b00      	cmp	r3, #0
    fb00:	d019      	beq.n	fb36 <xQueueGiveFromISR+0xfe>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    fb02:	697b      	ldr	r3, [r7, #20]
    fb04:	f103 0324 	add.w	r3, r3, #36	; 0x24
    fb08:	4618      	mov	r0, r3
    fb0a:	f002 f9d5 	bl	11eb8 <xTaskRemoveFromEventList>
    fb0e:	4603      	mov	r3, r0
    fb10:	2b00      	cmp	r3, #0
    fb12:	d012      	beq.n	fb3a <xQueueGiveFromISR+0x102>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    fb14:	683b      	ldr	r3, [r7, #0]
    fb16:	2b00      	cmp	r3, #0
    fb18:	d011      	beq.n	fb3e <xQueueGiveFromISR+0x106>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    fb1a:	683b      	ldr	r3, [r7, #0]
    fb1c:	f04f 0201 	mov.w	r2, #1
    fb20:	601a      	str	r2, [r3, #0]
    fb22:	e00d      	b.n	fb40 <xQueueGiveFromISR+0x108>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    fb24:	7ffb      	ldrb	r3, [r7, #31]
    fb26:	f103 0301 	add.w	r3, r3, #1
    fb2a:	b2db      	uxtb	r3, r3
    fb2c:	461a      	mov	r2, r3
    fb2e:	697b      	ldr	r3, [r7, #20]
    fb30:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
    fb34:	e004      	b.n	fb40 <xQueueGiveFromISR+0x108>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    fb36:	bf00      	nop
    fb38:	e002      	b.n	fb40 <xQueueGiveFromISR+0x108>
    fb3a:	bf00      	nop
    fb3c:	e000      	b.n	fb40 <xQueueGiveFromISR+0x108>
    fb3e:	bf00      	nop
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    fb40:	f04f 0301 	mov.w	r3, #1
    fb44:	60fb      	str	r3, [r7, #12]
    fb46:	e002      	b.n	fb4e <xQueueGiveFromISR+0x116>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    fb48:	f04f 0300 	mov.w	r3, #0
    fb4c:	60fb      	str	r3, [r7, #12]
    fb4e:	693b      	ldr	r3, [r7, #16]
    fb50:	637b      	str	r3, [r7, #52]	; 0x34
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
    fb52:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    fb54:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    fb58:	68fb      	ldr	r3, [r7, #12]
}
    fb5a:	4618      	mov	r0, r3
    fb5c:	f107 0738 	add.w	r7, r7, #56	; 0x38
    fb60:	46bd      	mov	sp, r7
    fb62:	bd80      	pop	{r7, pc}

0000fb64 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    fb64:	b580      	push	{r7, lr}
    fb66:	b08c      	sub	sp, #48	; 0x30
    fb68:	af00      	add	r7, sp, #0
    fb6a:	60f8      	str	r0, [r7, #12]
    fb6c:	60b9      	str	r1, [r7, #8]
    fb6e:	607a      	str	r2, [r7, #4]
BaseType_t xEntryTimeSet = pdFALSE;
    fb70:	f04f 0300 	mov.w	r3, #0
    fb74:	61bb      	str	r3, [r7, #24]
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    fb76:	68fb      	ldr	r3, [r7, #12]
    fb78:	61fb      	str	r3, [r7, #28]

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
    fb7a:	69fb      	ldr	r3, [r7, #28]
    fb7c:	2b00      	cmp	r3, #0
    fb7e:	d109      	bne.n	fb94 <xQueueReceive+0x30>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
    fb80:	f04f 0328 	mov.w	r3, #40	; 0x28
    fb84:	f383 8811 	msr	BASEPRI, r3
    fb88:	f3bf 8f6f 	isb	sy
    fb8c:	f3bf 8f4f 	dsb	sy
    fb90:	627b      	str	r3, [r7, #36]	; 0x24
    fb92:	e7fe      	b.n	fb92 <xQueueReceive+0x2e>

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    fb94:	68bb      	ldr	r3, [r7, #8]
    fb96:	2b00      	cmp	r3, #0
    fb98:	d103      	bne.n	fba2 <xQueueReceive+0x3e>
    fb9a:	69fb      	ldr	r3, [r7, #28]
    fb9c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    fb9e:	2b00      	cmp	r3, #0
    fba0:	d102      	bne.n	fba8 <xQueueReceive+0x44>
    fba2:	f04f 0301 	mov.w	r3, #1
    fba6:	e001      	b.n	fbac <xQueueReceive+0x48>
    fba8:	f04f 0300 	mov.w	r3, #0
    fbac:	2b00      	cmp	r3, #0
    fbae:	d109      	bne.n	fbc4 <xQueueReceive+0x60>
    fbb0:	f04f 0328 	mov.w	r3, #40	; 0x28
    fbb4:	f383 8811 	msr	BASEPRI, r3
    fbb8:	f3bf 8f6f 	isb	sy
    fbbc:	f3bf 8f4f 	dsb	sy
    fbc0:	62bb      	str	r3, [r7, #40]	; 0x28
    fbc2:	e7fe      	b.n	fbc2 <xQueueReceive+0x5e>

	/* Cannot block if the scheduler is suspended. */
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    fbc4:	f002 fd1e 	bl	12604 <xTaskGetSchedulerState>
    fbc8:	4603      	mov	r3, r0
    fbca:	2b00      	cmp	r3, #0
    fbcc:	d102      	bne.n	fbd4 <xQueueReceive+0x70>
    fbce:	687b      	ldr	r3, [r7, #4]
    fbd0:	2b00      	cmp	r3, #0
    fbd2:	d102      	bne.n	fbda <xQueueReceive+0x76>
    fbd4:	f04f 0301 	mov.w	r3, #1
    fbd8:	e001      	b.n	fbde <xQueueReceive+0x7a>
    fbda:	f04f 0300 	mov.w	r3, #0
    fbde:	2b00      	cmp	r3, #0
    fbe0:	d10c      	bne.n	fbfc <xQueueReceive+0x98>
    fbe2:	f04f 0328 	mov.w	r3, #40	; 0x28
    fbe6:	f383 8811 	msr	BASEPRI, r3
    fbea:	f3bf 8f6f 	isb	sy
    fbee:	f3bf 8f4f 	dsb	sy
    fbf2:	62fb      	str	r3, [r7, #44]	; 0x2c
    fbf4:	e7fe      	b.n	fbf4 <xQueueReceive+0x90>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    fbf6:	bf00      	nop
    fbf8:	e000      	b.n	fbfc <xQueueReceive+0x98>
    fbfa:	bf00      	nop
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    fbfc:	f004 fbec 	bl	143d8 <vPortEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    fc00:	69fb      	ldr	r3, [r7, #28]
    fc02:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    fc04:	623b      	str	r3, [r7, #32]

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    fc06:	6a3b      	ldr	r3, [r7, #32]
    fc08:	2b00      	cmp	r3, #0
    fc0a:	d025      	beq.n	fc58 <xQueueReceive+0xf4>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    fc0c:	69f8      	ldr	r0, [r7, #28]
    fc0e:	68b9      	ldr	r1, [r7, #8]
    fc10:	f000 fce0 	bl	105d4 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    fc14:	6a3b      	ldr	r3, [r7, #32]
    fc16:	f103 32ff 	add.w	r2, r3, #4294967295
    fc1a:	69fb      	ldr	r3, [r7, #28]
    fc1c:	639a      	str	r2, [r3, #56]	; 0x38

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    fc1e:	69fb      	ldr	r3, [r7, #28]
    fc20:	691b      	ldr	r3, [r3, #16]
    fc22:	2b00      	cmp	r3, #0
    fc24:	d013      	beq.n	fc4e <xQueueReceive+0xea>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    fc26:	69fb      	ldr	r3, [r7, #28]
    fc28:	f103 0310 	add.w	r3, r3, #16
    fc2c:	4618      	mov	r0, r3
    fc2e:	f002 f943 	bl	11eb8 <xTaskRemoveFromEventList>
    fc32:	4603      	mov	r3, r0
    fc34:	2b00      	cmp	r3, #0
    fc36:	d00a      	beq.n	fc4e <xQueueReceive+0xea>
					{
						queueYIELD_IF_USING_PREEMPTION();
    fc38:	f64e 5304 	movw	r3, #60676	; 0xed04
    fc3c:	f2ce 0300 	movt	r3, #57344	; 0xe000
    fc40:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    fc44:	601a      	str	r2, [r3, #0]
    fc46:	f3bf 8f4f 	dsb	sy
    fc4a:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    fc4e:	f004 fbfb 	bl	14448 <vPortExitCritical>
				return pdPASS;
    fc52:	f04f 0301 	mov.w	r3, #1
    fc56:	e076      	b.n	fd46 <xQueueReceive+0x1e2>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    fc58:	687b      	ldr	r3, [r7, #4]
    fc5a:	2b00      	cmp	r3, #0
    fc5c:	d104      	bne.n	fc68 <xQueueReceive+0x104>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    fc5e:	f004 fbf3 	bl	14448 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    fc62:	f04f 0300 	mov.w	r3, #0
    fc66:	e06e      	b.n	fd46 <xQueueReceive+0x1e2>
				}
				else if( xEntryTimeSet == pdFALSE )
    fc68:	69bb      	ldr	r3, [r7, #24]
    fc6a:	2b00      	cmp	r3, #0
    fc6c:	d107      	bne.n	fc7e <xQueueReceive+0x11a>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    fc6e:	f107 0310 	add.w	r3, r7, #16
    fc72:	4618      	mov	r0, r3
    fc74:	f002 fa30 	bl	120d8 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    fc78:	f04f 0301 	mov.w	r3, #1
    fc7c:	61bb      	str	r3, [r7, #24]
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    fc7e:	f004 fbe3 	bl	14448 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    fc82:	f001 fcc7 	bl	11614 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    fc86:	f004 fba7 	bl	143d8 <vPortEnterCritical>
    fc8a:	69fb      	ldr	r3, [r7, #28]
    fc8c:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
    fc90:	b2db      	uxtb	r3, r3
    fc92:	b25b      	sxtb	r3, r3
    fc94:	f1b3 3fff 	cmp.w	r3, #4294967295
    fc98:	d104      	bne.n	fca4 <xQueueReceive+0x140>
    fc9a:	69fb      	ldr	r3, [r7, #28]
    fc9c:	f04f 0200 	mov.w	r2, #0
    fca0:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    fca4:	69fb      	ldr	r3, [r7, #28]
    fca6:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
    fcaa:	b2db      	uxtb	r3, r3
    fcac:	b25b      	sxtb	r3, r3
    fcae:	f1b3 3fff 	cmp.w	r3, #4294967295
    fcb2:	d104      	bne.n	fcbe <xQueueReceive+0x15a>
    fcb4:	69fb      	ldr	r3, [r7, #28]
    fcb6:	f04f 0200 	mov.w	r2, #0
    fcba:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
    fcbe:	f004 fbc3 	bl	14448 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    fcc2:	f107 0210 	add.w	r2, r7, #16
    fcc6:	f107 0304 	add.w	r3, r7, #4
    fcca:	4610      	mov	r0, r2
    fccc:	4619      	mov	r1, r3
    fcce:	f002 fa1b 	bl	12108 <xTaskCheckForTimeOut>
    fcd2:	4603      	mov	r3, r0
    fcd4:	2b00      	cmp	r3, #0
    fcd6:	d128      	bne.n	fd2a <xQueueReceive+0x1c6>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    fcd8:	69f8      	ldr	r0, [r7, #28]
    fcda:	f000 fcf9 	bl	106d0 <prvIsQueueEmpty>
    fcde:	4603      	mov	r3, r0
    fce0:	2b00      	cmp	r3, #0
    fce2:	d01c      	beq.n	fd1e <xQueueReceive+0x1ba>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    fce4:	69fb      	ldr	r3, [r7, #28]
    fce6:	f103 0224 	add.w	r2, r3, #36	; 0x24
    fcea:	687b      	ldr	r3, [r7, #4]
    fcec:	4610      	mov	r0, r2
    fcee:	4619      	mov	r1, r3
    fcf0:	f002 f84e 	bl	11d90 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    fcf4:	69f8      	ldr	r0, [r7, #28]
    fcf6:	f000 fc95 	bl	10624 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    fcfa:	f001 fc9d 	bl	11638 <xTaskResumeAll>
    fcfe:	4603      	mov	r3, r0
    fd00:	2b00      	cmp	r3, #0
    fd02:	f47f af78 	bne.w	fbf6 <xQueueReceive+0x92>
				{
					portYIELD_WITHIN_API();
    fd06:	f64e 5304 	movw	r3, #60676	; 0xed04
    fd0a:	f2ce 0300 	movt	r3, #57344	; 0xe000
    fd0e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    fd12:	601a      	str	r2, [r3, #0]
    fd14:	f3bf 8f4f 	dsb	sy
    fd18:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    fd1c:	e76e      	b.n	fbfc <xQueueReceive+0x98>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    fd1e:	69f8      	ldr	r0, [r7, #28]
    fd20:	f000 fc80 	bl	10624 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    fd24:	f001 fc88 	bl	11638 <xTaskResumeAll>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    fd28:	e768      	b.n	fbfc <xQueueReceive+0x98>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    fd2a:	69f8      	ldr	r0, [r7, #28]
    fd2c:	f000 fc7a 	bl	10624 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    fd30:	f001 fc82 	bl	11638 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    fd34:	69f8      	ldr	r0, [r7, #28]
    fd36:	f000 fccb 	bl	106d0 <prvIsQueueEmpty>
    fd3a:	4603      	mov	r3, r0
    fd3c:	2b00      	cmp	r3, #0
    fd3e:	f43f af5c 	beq.w	fbfa <xQueueReceive+0x96>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    fd42:	f04f 0300 	mov.w	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    fd46:	4618      	mov	r0, r3
    fd48:	f107 0730 	add.w	r7, r7, #48	; 0x30
    fd4c:	46bd      	mov	sp, r7
    fd4e:	bd80      	pop	{r7, pc}

0000fd50 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    fd50:	b580      	push	{r7, lr}
    fd52:	b08e      	sub	sp, #56	; 0x38
    fd54:	af00      	add	r7, sp, #0
    fd56:	6078      	str	r0, [r7, #4]
    fd58:	6039      	str	r1, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE;
    fd5a:	f04f 0300 	mov.w	r3, #0
    fd5e:	617b      	str	r3, [r7, #20]
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    fd60:	687b      	ldr	r3, [r7, #4]
    fd62:	61bb      	str	r3, [r7, #24]

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
    fd64:	f04f 0300 	mov.w	r3, #0
    fd68:	61fb      	str	r3, [r7, #28]
#endif

	/* Check the queue pointer is not NULL. */
	configASSERT( ( pxQueue ) );
    fd6a:	69bb      	ldr	r3, [r7, #24]
    fd6c:	2b00      	cmp	r3, #0
    fd6e:	d109      	bne.n	fd84 <xQueueSemaphoreTake+0x34>
    fd70:	f04f 0328 	mov.w	r3, #40	; 0x28
    fd74:	f383 8811 	msr	BASEPRI, r3
    fd78:	f3bf 8f6f 	isb	sy
    fd7c:	f3bf 8f4f 	dsb	sy
    fd80:	62bb      	str	r3, [r7, #40]	; 0x28
    fd82:	e7fe      	b.n	fd82 <xQueueSemaphoreTake+0x32>

	/* Check this really is a semaphore, in which case the item size will be
	0. */
	configASSERT( pxQueue->uxItemSize == 0 );
    fd84:	69bb      	ldr	r3, [r7, #24]
    fd86:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    fd88:	2b00      	cmp	r3, #0
    fd8a:	d009      	beq.n	fda0 <xQueueSemaphoreTake+0x50>
    fd8c:	f04f 0328 	mov.w	r3, #40	; 0x28
    fd90:	f383 8811 	msr	BASEPRI, r3
    fd94:	f3bf 8f6f 	isb	sy
    fd98:	f3bf 8f4f 	dsb	sy
    fd9c:	62fb      	str	r3, [r7, #44]	; 0x2c
    fd9e:	e7fe      	b.n	fd9e <xQueueSemaphoreTake+0x4e>

	/* Cannot block if the scheduler is suspended. */
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    fda0:	f002 fc30 	bl	12604 <xTaskGetSchedulerState>
    fda4:	4603      	mov	r3, r0
    fda6:	2b00      	cmp	r3, #0
    fda8:	d102      	bne.n	fdb0 <xQueueSemaphoreTake+0x60>
    fdaa:	683b      	ldr	r3, [r7, #0]
    fdac:	2b00      	cmp	r3, #0
    fdae:	d102      	bne.n	fdb6 <xQueueSemaphoreTake+0x66>
    fdb0:	f04f 0301 	mov.w	r3, #1
    fdb4:	e001      	b.n	fdba <xQueueSemaphoreTake+0x6a>
    fdb6:	f04f 0300 	mov.w	r3, #0
    fdba:	2b00      	cmp	r3, #0
    fdbc:	d10c      	bne.n	fdd8 <xQueueSemaphoreTake+0x88>
    fdbe:	f04f 0328 	mov.w	r3, #40	; 0x28
    fdc2:	f383 8811 	msr	BASEPRI, r3
    fdc6:	f3bf 8f6f 	isb	sy
    fdca:	f3bf 8f4f 	dsb	sy
    fdce:	633b      	str	r3, [r7, #48]	; 0x30
    fdd0:	e7fe      	b.n	fdd0 <xQueueSemaphoreTake+0x80>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    fdd2:	bf00      	nop
    fdd4:	e000      	b.n	fdd8 <xQueueSemaphoreTake+0x88>
    fdd6:	bf00      	nop
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    fdd8:	f004 fafe 	bl	143d8 <vPortEnterCritical>
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    fddc:	69bb      	ldr	r3, [r7, #24]
    fdde:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    fde0:	623b      	str	r3, [r7, #32]

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    fde2:	6a3b      	ldr	r3, [r7, #32]
    fde4:	2b00      	cmp	r3, #0
    fde6:	d02a      	beq.n	fe3e <xQueueSemaphoreTake+0xee>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    fde8:	6a3b      	ldr	r3, [r7, #32]
    fdea:	f103 32ff 	add.w	r2, r3, #4294967295
    fdee:	69bb      	ldr	r3, [r7, #24]
    fdf0:	639a      	str	r2, [r3, #56]	; 0x38

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    fdf2:	69bb      	ldr	r3, [r7, #24]
    fdf4:	681b      	ldr	r3, [r3, #0]
    fdf6:	2b00      	cmp	r3, #0
    fdf8:	d104      	bne.n	fe04 <xQueueSemaphoreTake+0xb4>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    fdfa:	f002 ffdf 	bl	12dbc <pvTaskIncrementMutexHeldCount>
    fdfe:	4602      	mov	r2, r0
    fe00:	69bb      	ldr	r3, [r7, #24]
    fe02:	609a      	str	r2, [r3, #8]
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    fe04:	69bb      	ldr	r3, [r7, #24]
    fe06:	691b      	ldr	r3, [r3, #16]
    fe08:	2b00      	cmp	r3, #0
    fe0a:	d013      	beq.n	fe34 <xQueueSemaphoreTake+0xe4>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    fe0c:	69bb      	ldr	r3, [r7, #24]
    fe0e:	f103 0310 	add.w	r3, r3, #16
    fe12:	4618      	mov	r0, r3
    fe14:	f002 f850 	bl	11eb8 <xTaskRemoveFromEventList>
    fe18:	4603      	mov	r3, r0
    fe1a:	2b00      	cmp	r3, #0
    fe1c:	d00a      	beq.n	fe34 <xQueueSemaphoreTake+0xe4>
					{
						queueYIELD_IF_USING_PREEMPTION();
    fe1e:	f64e 5304 	movw	r3, #60676	; 0xed04
    fe22:	f2ce 0300 	movt	r3, #57344	; 0xe000
    fe26:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    fe2a:	601a      	str	r2, [r3, #0]
    fe2c:	f3bf 8f4f 	dsb	sy
    fe30:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    fe34:	f004 fb08 	bl	14448 <vPortExitCritical>
				return pdPASS;
    fe38:	f04f 0301 	mov.w	r3, #1
    fe3c:	e0a3      	b.n	ff86 <xQueueSemaphoreTake+0x236>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    fe3e:	683b      	ldr	r3, [r7, #0]
    fe40:	2b00      	cmp	r3, #0
    fe42:	d111      	bne.n	fe68 <xQueueSemaphoreTake+0x118>
					/* For inheritance to have occurred there must have been an
					initial timeout, and an adjusted timeout cannot become 0, as
					if it were 0 the function would have exited. */
					#if( configUSE_MUTEXES == 1 )
					{
						configASSERT( xInheritanceOccurred == pdFALSE );
    fe44:	69fb      	ldr	r3, [r7, #28]
    fe46:	2b00      	cmp	r3, #0
    fe48:	d009      	beq.n	fe5e <xQueueSemaphoreTake+0x10e>
    fe4a:	f04f 0328 	mov.w	r3, #40	; 0x28
    fe4e:	f383 8811 	msr	BASEPRI, r3
    fe52:	f3bf 8f6f 	isb	sy
    fe56:	f3bf 8f4f 	dsb	sy
    fe5a:	637b      	str	r3, [r7, #52]	; 0x34
    fe5c:	e7fe      	b.n	fe5c <xQueueSemaphoreTake+0x10c>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    fe5e:	f004 faf3 	bl	14448 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    fe62:	f04f 0300 	mov.w	r3, #0
    fe66:	e08e      	b.n	ff86 <xQueueSemaphoreTake+0x236>
				}
				else if( xEntryTimeSet == pdFALSE )
    fe68:	697b      	ldr	r3, [r7, #20]
    fe6a:	2b00      	cmp	r3, #0
    fe6c:	d107      	bne.n	fe7e <xQueueSemaphoreTake+0x12e>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    fe6e:	f107 030c 	add.w	r3, r7, #12
    fe72:	4618      	mov	r0, r3
    fe74:	f002 f930 	bl	120d8 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    fe78:	f04f 0301 	mov.w	r3, #1
    fe7c:	617b      	str	r3, [r7, #20]
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    fe7e:	f004 fae3 	bl	14448 <vPortExitCritical>

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    fe82:	f001 fbc7 	bl	11614 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    fe86:	f004 faa7 	bl	143d8 <vPortEnterCritical>
    fe8a:	69bb      	ldr	r3, [r7, #24]
    fe8c:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
    fe90:	b2db      	uxtb	r3, r3
    fe92:	b25b      	sxtb	r3, r3
    fe94:	f1b3 3fff 	cmp.w	r3, #4294967295
    fe98:	d104      	bne.n	fea4 <xQueueSemaphoreTake+0x154>
    fe9a:	69bb      	ldr	r3, [r7, #24]
    fe9c:	f04f 0200 	mov.w	r2, #0
    fea0:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    fea4:	69bb      	ldr	r3, [r7, #24]
    fea6:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
    feaa:	b2db      	uxtb	r3, r3
    feac:	b25b      	sxtb	r3, r3
    feae:	f1b3 3fff 	cmp.w	r3, #4294967295
    feb2:	d104      	bne.n	febe <xQueueSemaphoreTake+0x16e>
    feb4:	69bb      	ldr	r3, [r7, #24]
    feb6:	f04f 0200 	mov.w	r2, #0
    feba:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
    febe:	f004 fac3 	bl	14448 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    fec2:	f107 020c 	add.w	r2, r7, #12
    fec6:	463b      	mov	r3, r7
    fec8:	4610      	mov	r0, r2
    feca:	4619      	mov	r1, r3
    fecc:	f002 f91c 	bl	12108 <xTaskCheckForTimeOut>
    fed0:	4603      	mov	r3, r0
    fed2:	2b00      	cmp	r3, #0
    fed4:	d137      	bne.n	ff46 <xQueueSemaphoreTake+0x1f6>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    fed6:	69b8      	ldr	r0, [r7, #24]
    fed8:	f000 fbfa 	bl	106d0 <prvIsQueueEmpty>
    fedc:	4603      	mov	r3, r0
    fede:	2b00      	cmp	r3, #0
    fee0:	d02b      	beq.n	ff3a <xQueueSemaphoreTake+0x1ea>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    fee2:	69bb      	ldr	r3, [r7, #24]
    fee4:	681b      	ldr	r3, [r3, #0]
    fee6:	2b00      	cmp	r3, #0
    fee8:	d10a      	bne.n	ff00 <xQueueSemaphoreTake+0x1b0>
					{
						taskENTER_CRITICAL();
    feea:	f004 fa75 	bl	143d8 <vPortEnterCritical>
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    feee:	69bb      	ldr	r3, [r7, #24]
    fef0:	689b      	ldr	r3, [r3, #8]
    fef2:	4618      	mov	r0, r3
    fef4:	f002 fbaa 	bl	1264c <xTaskPriorityInherit>
    fef8:	4603      	mov	r3, r0
    fefa:	61fb      	str	r3, [r7, #28]
						}
						taskEXIT_CRITICAL();
    fefc:	f004 faa4 	bl	14448 <vPortExitCritical>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    ff00:	69bb      	ldr	r3, [r7, #24]
    ff02:	f103 0224 	add.w	r2, r3, #36	; 0x24
    ff06:	683b      	ldr	r3, [r7, #0]
    ff08:	4610      	mov	r0, r2
    ff0a:	4619      	mov	r1, r3
    ff0c:	f001 ff40 	bl	11d90 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    ff10:	69b8      	ldr	r0, [r7, #24]
    ff12:	f000 fb87 	bl	10624 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    ff16:	f001 fb8f 	bl	11638 <xTaskResumeAll>
    ff1a:	4603      	mov	r3, r0
    ff1c:	2b00      	cmp	r3, #0
    ff1e:	f47f af58 	bne.w	fdd2 <xQueueSemaphoreTake+0x82>
				{
					portYIELD_WITHIN_API();
    ff22:	f64e 5304 	movw	r3, #60676	; 0xed04
    ff26:	f2ce 0300 	movt	r3, #57344	; 0xe000
    ff2a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    ff2e:	601a      	str	r2, [r3, #0]
    ff30:	f3bf 8f4f 	dsb	sy
    ff34:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    ff38:	e74e      	b.n	fdd8 <xQueueSemaphoreTake+0x88>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    ff3a:	69b8      	ldr	r0, [r7, #24]
    ff3c:	f000 fb72 	bl	10624 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    ff40:	f001 fb7a 	bl	11638 <xTaskResumeAll>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    ff44:	e748      	b.n	fdd8 <xQueueSemaphoreTake+0x88>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    ff46:	69b8      	ldr	r0, [r7, #24]
    ff48:	f000 fb6c 	bl	10624 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    ff4c:	f001 fb74 	bl	11638 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    ff50:	69b8      	ldr	r0, [r7, #24]
    ff52:	f000 fbbd 	bl	106d0 <prvIsQueueEmpty>
    ff56:	4603      	mov	r3, r0
    ff58:	2b00      	cmp	r3, #0
    ff5a:	f43f af3c 	beq.w	fdd6 <xQueueSemaphoreTake+0x86>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
    ff5e:	69fb      	ldr	r3, [r7, #28]
    ff60:	2b00      	cmp	r3, #0
    ff62:	d00e      	beq.n	ff82 <xQueueSemaphoreTake+0x232>
					{
						taskENTER_CRITICAL();
    ff64:	f004 fa38 	bl	143d8 <vPortEnterCritical>
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
    ff68:	69b8      	ldr	r0, [r7, #24]
    ff6a:	f000 faa1 	bl	104b0 <prvGetDisinheritPriorityAfterTimeout>
    ff6e:	4603      	mov	r3, r0
    ff70:	627b      	str	r3, [r7, #36]	; 0x24
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    ff72:	69bb      	ldr	r3, [r7, #24]
    ff74:	689b      	ldr	r3, [r3, #8]
    ff76:	4618      	mov	r0, r3
    ff78:	6a79      	ldr	r1, [r7, #36]	; 0x24
    ff7a:	f002 fcc3 	bl	12904 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
    ff7e:	f004 fa63 	bl	14448 <vPortExitCritical>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    ff82:	f04f 0300 	mov.w	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    ff86:	4618      	mov	r0, r3
    ff88:	f107 0738 	add.w	r7, r7, #56	; 0x38
    ff8c:	46bd      	mov	sp, r7
    ff8e:	bd80      	pop	{r7, pc}

0000ff90 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    ff90:	b580      	push	{r7, lr}
    ff92:	b08e      	sub	sp, #56	; 0x38
    ff94:	af00      	add	r7, sp, #0
    ff96:	60f8      	str	r0, [r7, #12]
    ff98:	60b9      	str	r1, [r7, #8]
    ff9a:	607a      	str	r2, [r7, #4]
BaseType_t xEntryTimeSet = pdFALSE;
    ff9c:	f04f 0300 	mov.w	r3, #0
    ffa0:	61fb      	str	r3, [r7, #28]
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    ffa2:	68fb      	ldr	r3, [r7, #12]
    ffa4:	627b      	str	r3, [r7, #36]	; 0x24

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
    ffa6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    ffa8:	2b00      	cmp	r3, #0
    ffaa:	d109      	bne.n	ffc0 <xQueuePeek+0x30>
    ffac:	f04f 0328 	mov.w	r3, #40	; 0x28
    ffb0:	f383 8811 	msr	BASEPRI, r3
    ffb4:	f3bf 8f6f 	isb	sy
    ffb8:	f3bf 8f4f 	dsb	sy
    ffbc:	62fb      	str	r3, [r7, #44]	; 0x2c
    ffbe:	e7fe      	b.n	ffbe <xQueuePeek+0x2e>

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    ffc0:	68bb      	ldr	r3, [r7, #8]
    ffc2:	2b00      	cmp	r3, #0
    ffc4:	d103      	bne.n	ffce <xQueuePeek+0x3e>
    ffc6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    ffc8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    ffca:	2b00      	cmp	r3, #0
    ffcc:	d102      	bne.n	ffd4 <xQueuePeek+0x44>
    ffce:	f04f 0301 	mov.w	r3, #1
    ffd2:	e001      	b.n	ffd8 <xQueuePeek+0x48>
    ffd4:	f04f 0300 	mov.w	r3, #0
    ffd8:	2b00      	cmp	r3, #0
    ffda:	d109      	bne.n	fff0 <xQueuePeek+0x60>
    ffdc:	f04f 0328 	mov.w	r3, #40	; 0x28
    ffe0:	f383 8811 	msr	BASEPRI, r3
    ffe4:	f3bf 8f6f 	isb	sy
    ffe8:	f3bf 8f4f 	dsb	sy
    ffec:	633b      	str	r3, [r7, #48]	; 0x30
    ffee:	e7fe      	b.n	ffee <xQueuePeek+0x5e>

	/* Cannot block if the scheduler is suspended. */
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    fff0:	f002 fb08 	bl	12604 <xTaskGetSchedulerState>
    fff4:	4603      	mov	r3, r0
    fff6:	2b00      	cmp	r3, #0
    fff8:	d102      	bne.n	10000 <RAM_SIZE>
    fffa:	687b      	ldr	r3, [r7, #4]
    fffc:	2b00      	cmp	r3, #0
    fffe:	d102      	bne.n	10006 <RAM_SIZE+0x6>
   10000:	f04f 0301 	mov.w	r3, #1
   10004:	e001      	b.n	1000a <RAM_SIZE+0xa>
   10006:	f04f 0300 	mov.w	r3, #0
   1000a:	2b00      	cmp	r3, #0
   1000c:	d10c      	bne.n	10028 <RAM_SIZE+0x28>
   1000e:	f04f 0328 	mov.w	r3, #40	; 0x28
   10012:	f383 8811 	msr	BASEPRI, r3
   10016:	f3bf 8f6f 	isb	sy
   1001a:	f3bf 8f4f 	dsb	sy
   1001e:	637b      	str	r3, [r7, #52]	; 0x34
   10020:	e7fe      	b.n	10020 <RAM_SIZE+0x20>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
   10022:	bf00      	nop
   10024:	e000      	b.n	10028 <RAM_SIZE+0x28>
   10026:	bf00      	nop
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
   10028:	f004 f9d6 	bl	143d8 <vPortEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   1002c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1002e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   10030:	62bb      	str	r3, [r7, #40]	; 0x28

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   10032:	6abb      	ldr	r3, [r7, #40]	; 0x28
   10034:	2b00      	cmp	r3, #0
   10036:	d026      	beq.n	10086 <RAM_SIZE+0x86>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
   10038:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1003a:	68db      	ldr	r3, [r3, #12]
   1003c:	623b      	str	r3, [r7, #32]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
   1003e:	6a78      	ldr	r0, [r7, #36]	; 0x24
   10040:	68b9      	ldr	r1, [r7, #8]
   10042:	f000 fac7 	bl	105d4 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
   10046:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   10048:	6a3a      	ldr	r2, [r7, #32]
   1004a:	60da      	str	r2, [r3, #12]

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1004c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1004e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   10050:	2b00      	cmp	r3, #0
   10052:	d013      	beq.n	1007c <RAM_SIZE+0x7c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   10054:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   10056:	f103 0324 	add.w	r3, r3, #36	; 0x24
   1005a:	4618      	mov	r0, r3
   1005c:	f001 ff2c 	bl	11eb8 <xTaskRemoveFromEventList>
   10060:	4603      	mov	r3, r0
   10062:	2b00      	cmp	r3, #0
   10064:	d00a      	beq.n	1007c <RAM_SIZE+0x7c>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
   10066:	f64e 5304 	movw	r3, #60676	; 0xed04
   1006a:	f2ce 0300 	movt	r3, #57344	; 0xe000
   1006e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   10072:	601a      	str	r2, [r3, #0]
   10074:	f3bf 8f4f 	dsb	sy
   10078:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
   1007c:	f004 f9e4 	bl	14448 <vPortExitCritical>
				return pdPASS;
   10080:	f04f 0301 	mov.w	r3, #1
   10084:	e076      	b.n	10174 <RAM_SIZE+0x174>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
   10086:	687b      	ldr	r3, [r7, #4]
   10088:	2b00      	cmp	r3, #0
   1008a:	d104      	bne.n	10096 <RAM_SIZE+0x96>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
   1008c:	f004 f9dc 	bl	14448 <vPortExitCritical>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
   10090:	f04f 0300 	mov.w	r3, #0
   10094:	e06e      	b.n	10174 <RAM_SIZE+0x174>
				}
				else if( xEntryTimeSet == pdFALSE )
   10096:	69fb      	ldr	r3, [r7, #28]
   10098:	2b00      	cmp	r3, #0
   1009a:	d107      	bne.n	100ac <RAM_SIZE+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
   1009c:	f107 0314 	add.w	r3, r7, #20
   100a0:	4618      	mov	r0, r3
   100a2:	f002 f819 	bl	120d8 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
   100a6:	f04f 0301 	mov.w	r3, #1
   100aa:	61fb      	str	r3, [r7, #28]
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
   100ac:	f004 f9cc 	bl	14448 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
   100b0:	f001 fab0 	bl	11614 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
   100b4:	f004 f990 	bl	143d8 <vPortEnterCritical>
   100b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   100ba:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
   100be:	b2db      	uxtb	r3, r3
   100c0:	b25b      	sxtb	r3, r3
   100c2:	f1b3 3fff 	cmp.w	r3, #4294967295
   100c6:	d104      	bne.n	100d2 <RAM_SIZE+0xd2>
   100c8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   100ca:	f04f 0200 	mov.w	r2, #0
   100ce:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
   100d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   100d4:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   100d8:	b2db      	uxtb	r3, r3
   100da:	b25b      	sxtb	r3, r3
   100dc:	f1b3 3fff 	cmp.w	r3, #4294967295
   100e0:	d104      	bne.n	100ec <RAM_SIZE+0xec>
   100e2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   100e4:	f04f 0200 	mov.w	r2, #0
   100e8:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
   100ec:	f004 f9ac 	bl	14448 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   100f0:	f107 0214 	add.w	r2, r7, #20
   100f4:	f107 0304 	add.w	r3, r7, #4
   100f8:	4610      	mov	r0, r2
   100fa:	4619      	mov	r1, r3
   100fc:	f002 f804 	bl	12108 <xTaskCheckForTimeOut>
   10100:	4603      	mov	r3, r0
   10102:	2b00      	cmp	r3, #0
   10104:	d128      	bne.n	10158 <RAM_SIZE+0x158>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   10106:	6a78      	ldr	r0, [r7, #36]	; 0x24
   10108:	f000 fae2 	bl	106d0 <prvIsQueueEmpty>
   1010c:	4603      	mov	r3, r0
   1010e:	2b00      	cmp	r3, #0
   10110:	d01c      	beq.n	1014c <RAM_SIZE+0x14c>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   10112:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   10114:	f103 0224 	add.w	r2, r3, #36	; 0x24
   10118:	687b      	ldr	r3, [r7, #4]
   1011a:	4610      	mov	r0, r2
   1011c:	4619      	mov	r1, r3
   1011e:	f001 fe37 	bl	11d90 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
   10122:	6a78      	ldr	r0, [r7, #36]	; 0x24
   10124:	f000 fa7e 	bl	10624 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
   10128:	f001 fa86 	bl	11638 <xTaskResumeAll>
   1012c:	4603      	mov	r3, r0
   1012e:	2b00      	cmp	r3, #0
   10130:	f47f af77 	bne.w	10022 <RAM_SIZE+0x22>
				{
					portYIELD_WITHIN_API();
   10134:	f64e 5304 	movw	r3, #60676	; 0xed04
   10138:	f2ce 0300 	movt	r3, #57344	; 0xe000
   1013c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   10140:	601a      	str	r2, [r3, #0]
   10142:	f3bf 8f4f 	dsb	sy
   10146:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
   1014a:	e76d      	b.n	10028 <RAM_SIZE+0x28>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
   1014c:	6a78      	ldr	r0, [r7, #36]	; 0x24
   1014e:	f000 fa69 	bl	10624 <prvUnlockQueue>
				( void ) xTaskResumeAll();
   10152:	f001 fa71 	bl	11638 <xTaskResumeAll>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
   10156:	e767      	b.n	10028 <RAM_SIZE+0x28>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
   10158:	6a78      	ldr	r0, [r7, #36]	; 0x24
   1015a:	f000 fa63 	bl	10624 <prvUnlockQueue>
			( void ) xTaskResumeAll();
   1015e:	f001 fa6b 	bl	11638 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   10162:	6a78      	ldr	r0, [r7, #36]	; 0x24
   10164:	f000 fab4 	bl	106d0 <prvIsQueueEmpty>
   10168:	4603      	mov	r3, r0
   1016a:	2b00      	cmp	r3, #0
   1016c:	f43f af5b 	beq.w	10026 <RAM_SIZE+0x26>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
   10170:	f04f 0300 	mov.w	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
   10174:	4618      	mov	r0, r3
   10176:	f107 0738 	add.w	r7, r7, #56	; 0x38
   1017a:	46bd      	mov	sp, r7
   1017c:	bd80      	pop	{r7, pc}
   1017e:	bf00      	nop

00010180 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
   10180:	b580      	push	{r7, lr}
   10182:	b08e      	sub	sp, #56	; 0x38
   10184:	af00      	add	r7, sp, #0
   10186:	60f8      	str	r0, [r7, #12]
   10188:	60b9      	str	r1, [r7, #8]
   1018a:	607a      	str	r2, [r7, #4]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
   1018c:	68fb      	ldr	r3, [r7, #12]
   1018e:	61bb      	str	r3, [r7, #24]

	configASSERT( pxQueue );
   10190:	69bb      	ldr	r3, [r7, #24]
   10192:	2b00      	cmp	r3, #0
   10194:	d109      	bne.n	101aa <xQueueReceiveFromISR+0x2a>
   10196:	f04f 0328 	mov.w	r3, #40	; 0x28
   1019a:	f383 8811 	msr	BASEPRI, r3
   1019e:	f3bf 8f6f 	isb	sy
   101a2:	f3bf 8f4f 	dsb	sy
   101a6:	627b      	str	r3, [r7, #36]	; 0x24
   101a8:	e7fe      	b.n	101a8 <xQueueReceiveFromISR+0x28>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   101aa:	68bb      	ldr	r3, [r7, #8]
   101ac:	2b00      	cmp	r3, #0
   101ae:	d103      	bne.n	101b8 <xQueueReceiveFromISR+0x38>
   101b0:	69bb      	ldr	r3, [r7, #24]
   101b2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   101b4:	2b00      	cmp	r3, #0
   101b6:	d102      	bne.n	101be <xQueueReceiveFromISR+0x3e>
   101b8:	f04f 0301 	mov.w	r3, #1
   101bc:	e001      	b.n	101c2 <xQueueReceiveFromISR+0x42>
   101be:	f04f 0300 	mov.w	r3, #0
   101c2:	2b00      	cmp	r3, #0
   101c4:	d109      	bne.n	101da <xQueueReceiveFromISR+0x5a>
   101c6:	f04f 0328 	mov.w	r3, #40	; 0x28
   101ca:	f383 8811 	msr	BASEPRI, r3
   101ce:	f3bf 8f6f 	isb	sy
   101d2:	f3bf 8f4f 	dsb	sy
   101d6:	62bb      	str	r3, [r7, #40]	; 0x28
   101d8:	e7fe      	b.n	101d8 <xQueueReceiveFromISR+0x58>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   101da:	f004 f9e1 	bl	145a0 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
   101de:	f3ef 8211 	mrs	r2, BASEPRI
   101e2:	f04f 0328 	mov.w	r3, #40	; 0x28
   101e6:	f383 8811 	msr	BASEPRI, r3
   101ea:	f3bf 8f6f 	isb	sy
   101ee:	f3bf 8f4f 	dsb	sy
   101f2:	633a      	str	r2, [r7, #48]	; 0x30
   101f4:	62fb      	str	r3, [r7, #44]	; 0x2c
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
   101f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   101f8:	617b      	str	r3, [r7, #20]
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   101fa:	69bb      	ldr	r3, [r7, #24]
   101fc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   101fe:	61fb      	str	r3, [r7, #28]

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   10200:	69fb      	ldr	r3, [r7, #28]
   10202:	2b00      	cmp	r3, #0
   10204:	d03a      	beq.n	1027c <xQueueReceiveFromISR+0xfc>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
   10206:	69bb      	ldr	r3, [r7, #24]
   10208:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
   1020c:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
   10210:	69b8      	ldr	r0, [r7, #24]
   10212:	68b9      	ldr	r1, [r7, #8]
   10214:	f000 f9de 	bl	105d4 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
   10218:	69fb      	ldr	r3, [r7, #28]
   1021a:	f103 32ff 	add.w	r2, r3, #4294967295
   1021e:	69bb      	ldr	r3, [r7, #24]
   10220:	639a      	str	r2, [r3, #56]	; 0x38

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
   10222:	f997 3023 	ldrsb.w	r3, [r7, #35]	; 0x23
   10226:	f1b3 3fff 	cmp.w	r3, #4294967295
   1022a:	d114      	bne.n	10256 <xQueueReceiveFromISR+0xd6>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1022c:	69bb      	ldr	r3, [r7, #24]
   1022e:	691b      	ldr	r3, [r3, #16]
   10230:	2b00      	cmp	r3, #0
   10232:	d01a      	beq.n	1026a <xQueueReceiveFromISR+0xea>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   10234:	69bb      	ldr	r3, [r7, #24]
   10236:	f103 0310 	add.w	r3, r3, #16
   1023a:	4618      	mov	r0, r3
   1023c:	f001 fe3c 	bl	11eb8 <xTaskRemoveFromEventList>
   10240:	4603      	mov	r3, r0
   10242:	2b00      	cmp	r3, #0
   10244:	d013      	beq.n	1026e <xQueueReceiveFromISR+0xee>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
   10246:	687b      	ldr	r3, [r7, #4]
   10248:	2b00      	cmp	r3, #0
   1024a:	d012      	beq.n	10272 <xQueueReceiveFromISR+0xf2>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
   1024c:	687b      	ldr	r3, [r7, #4]
   1024e:	f04f 0201 	mov.w	r2, #1
   10252:	601a      	str	r2, [r3, #0]
   10254:	e00e      	b.n	10274 <xQueueReceiveFromISR+0xf4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
   10256:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   1025a:	f103 0301 	add.w	r3, r3, #1
   1025e:	b2db      	uxtb	r3, r3
   10260:	461a      	mov	r2, r3
   10262:	69bb      	ldr	r3, [r7, #24]
   10264:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
   10268:	e004      	b.n	10274 <xQueueReceiveFromISR+0xf4>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
   1026a:	bf00      	nop
   1026c:	e002      	b.n	10274 <xQueueReceiveFromISR+0xf4>
   1026e:	bf00      	nop
   10270:	e000      	b.n	10274 <xQueueReceiveFromISR+0xf4>
   10272:	bf00      	nop
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
			}

			xReturn = pdPASS;
   10274:	f04f 0301 	mov.w	r3, #1
   10278:	613b      	str	r3, [r7, #16]
   1027a:	e002      	b.n	10282 <xQueueReceiveFromISR+0x102>
		}
		else
		{
			xReturn = pdFAIL;
   1027c:	f04f 0300 	mov.w	r3, #0
   10280:	613b      	str	r3, [r7, #16]
   10282:	697b      	ldr	r3, [r7, #20]
   10284:	637b      	str	r3, [r7, #52]	; 0x34
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   10286:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   10288:	f383 8811 	msr	BASEPRI, r3
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
   1028c:	693b      	ldr	r3, [r7, #16]
}
   1028e:	4618      	mov	r0, r3
   10290:	f107 0738 	add.w	r7, r7, #56	; 0x38
   10294:	46bd      	mov	sp, r7
   10296:	bd80      	pop	{r7, pc}

00010298 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
   10298:	b580      	push	{r7, lr}
   1029a:	b08c      	sub	sp, #48	; 0x30
   1029c:	af00      	add	r7, sp, #0
   1029e:	6078      	str	r0, [r7, #4]
   102a0:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
   102a2:	687b      	ldr	r3, [r7, #4]
   102a4:	617b      	str	r3, [r7, #20]

	configASSERT( pxQueue );
   102a6:	697b      	ldr	r3, [r7, #20]
   102a8:	2b00      	cmp	r3, #0
   102aa:	d109      	bne.n	102c0 <xQueuePeekFromISR+0x28>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   102ac:	f04f 0328 	mov.w	r3, #40	; 0x28
   102b0:	f383 8811 	msr	BASEPRI, r3
   102b4:	f3bf 8f6f 	isb	sy
   102b8:	f3bf 8f4f 	dsb	sy
   102bc:	61bb      	str	r3, [r7, #24]
   102be:	e7fe      	b.n	102be <xQueuePeekFromISR+0x26>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   102c0:	683b      	ldr	r3, [r7, #0]
   102c2:	2b00      	cmp	r3, #0
   102c4:	d103      	bne.n	102ce <xQueuePeekFromISR+0x36>
   102c6:	697b      	ldr	r3, [r7, #20]
   102c8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   102ca:	2b00      	cmp	r3, #0
   102cc:	d102      	bne.n	102d4 <xQueuePeekFromISR+0x3c>
   102ce:	f04f 0301 	mov.w	r3, #1
   102d2:	e001      	b.n	102d8 <xQueuePeekFromISR+0x40>
   102d4:	f04f 0300 	mov.w	r3, #0
   102d8:	2b00      	cmp	r3, #0
   102da:	d109      	bne.n	102f0 <xQueuePeekFromISR+0x58>
   102dc:	f04f 0328 	mov.w	r3, #40	; 0x28
   102e0:	f383 8811 	msr	BASEPRI, r3
   102e4:	f3bf 8f6f 	isb	sy
   102e8:	f3bf 8f4f 	dsb	sy
   102ec:	61fb      	str	r3, [r7, #28]
   102ee:	e7fe      	b.n	102ee <xQueuePeekFromISR+0x56>
	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
   102f0:	697b      	ldr	r3, [r7, #20]
   102f2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   102f4:	2b00      	cmp	r3, #0
   102f6:	d109      	bne.n	1030c <xQueuePeekFromISR+0x74>
   102f8:	f04f 0328 	mov.w	r3, #40	; 0x28
   102fc:	f383 8811 	msr	BASEPRI, r3
   10300:	f3bf 8f6f 	isb	sy
   10304:	f3bf 8f4f 	dsb	sy
   10308:	623b      	str	r3, [r7, #32]
   1030a:	e7fe      	b.n	1030a <xQueuePeekFromISR+0x72>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1030c:	f004 f948 	bl	145a0 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
   10310:	f3ef 8211 	mrs	r2, BASEPRI
   10314:	f04f 0328 	mov.w	r3, #40	; 0x28
   10318:	f383 8811 	msr	BASEPRI, r3
   1031c:	f3bf 8f6f 	isb	sy
   10320:	f3bf 8f4f 	dsb	sy
   10324:	62ba      	str	r2, [r7, #40]	; 0x28
   10326:	627b      	str	r3, [r7, #36]	; 0x24
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
   10328:	6abb      	ldr	r3, [r7, #40]	; 0x28

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   1032a:	60fb      	str	r3, [r7, #12]
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
   1032c:	697b      	ldr	r3, [r7, #20]
   1032e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   10330:	2b00      	cmp	r3, #0
   10332:	d00d      	beq.n	10350 <xQueuePeekFromISR+0xb8>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
   10334:	697b      	ldr	r3, [r7, #20]
   10336:	68db      	ldr	r3, [r3, #12]
   10338:	613b      	str	r3, [r7, #16]
			prvCopyDataFromQueue( pxQueue, pvBuffer );
   1033a:	6978      	ldr	r0, [r7, #20]
   1033c:	6839      	ldr	r1, [r7, #0]
   1033e:	f000 f949 	bl	105d4 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
   10342:	697b      	ldr	r3, [r7, #20]
   10344:	693a      	ldr	r2, [r7, #16]
   10346:	60da      	str	r2, [r3, #12]

			xReturn = pdPASS;
   10348:	f04f 0301 	mov.w	r3, #1
   1034c:	60bb      	str	r3, [r7, #8]
   1034e:	e002      	b.n	10356 <xQueuePeekFromISR+0xbe>
		}
		else
		{
			xReturn = pdFAIL;
   10350:	f04f 0300 	mov.w	r3, #0
   10354:	60bb      	str	r3, [r7, #8]
   10356:	68fb      	ldr	r3, [r7, #12]
   10358:	62fb      	str	r3, [r7, #44]	; 0x2c
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   1035a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1035c:	f383 8811 	msr	BASEPRI, r3
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
   10360:	68bb      	ldr	r3, [r7, #8]
}
   10362:	4618      	mov	r0, r3
   10364:	f107 0730 	add.w	r7, r7, #48	; 0x30
   10368:	46bd      	mov	sp, r7
   1036a:	bd80      	pop	{r7, pc}

0001036c <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
   1036c:	b580      	push	{r7, lr}
   1036e:	b084      	sub	sp, #16
   10370:	af00      	add	r7, sp, #0
   10372:	6078      	str	r0, [r7, #4]
UBaseType_t uxReturn;

	configASSERT( xQueue );
   10374:	687b      	ldr	r3, [r7, #4]
   10376:	2b00      	cmp	r3, #0
   10378:	d109      	bne.n	1038e <uxQueueMessagesWaiting+0x22>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   1037a:	f04f 0328 	mov.w	r3, #40	; 0x28
   1037e:	f383 8811 	msr	BASEPRI, r3
   10382:	f3bf 8f6f 	isb	sy
   10386:	f3bf 8f4f 	dsb	sy
   1038a:	60fb      	str	r3, [r7, #12]
   1038c:	e7fe      	b.n	1038c <uxQueueMessagesWaiting+0x20>

	taskENTER_CRITICAL();
   1038e:	f004 f823 	bl	143d8 <vPortEnterCritical>
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
   10392:	687b      	ldr	r3, [r7, #4]
   10394:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   10396:	60bb      	str	r3, [r7, #8]
	}
	taskEXIT_CRITICAL();
   10398:	f004 f856 	bl	14448 <vPortExitCritical>

	return uxReturn;
   1039c:	68bb      	ldr	r3, [r7, #8]
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   1039e:	4618      	mov	r0, r3
   103a0:	f107 0710 	add.w	r7, r7, #16
   103a4:	46bd      	mov	sp, r7
   103a6:	bd80      	pop	{r7, pc}

000103a8 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
   103a8:	b580      	push	{r7, lr}
   103aa:	b086      	sub	sp, #24
   103ac:	af00      	add	r7, sp, #0
   103ae:	6078      	str	r0, [r7, #4]
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
   103b0:	687b      	ldr	r3, [r7, #4]
   103b2:	613b      	str	r3, [r7, #16]

	configASSERT( pxQueue );
   103b4:	693b      	ldr	r3, [r7, #16]
   103b6:	2b00      	cmp	r3, #0
   103b8:	d109      	bne.n	103ce <uxQueueSpacesAvailable+0x26>
   103ba:	f04f 0328 	mov.w	r3, #40	; 0x28
   103be:	f383 8811 	msr	BASEPRI, r3
   103c2:	f3bf 8f6f 	isb	sy
   103c6:	f3bf 8f4f 	dsb	sy
   103ca:	617b      	str	r3, [r7, #20]
   103cc:	e7fe      	b.n	103cc <uxQueueSpacesAvailable+0x24>

	taskENTER_CRITICAL();
   103ce:	f004 f803 	bl	143d8 <vPortEnterCritical>
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
   103d2:	693b      	ldr	r3, [r7, #16]
   103d4:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   103d6:	693b      	ldr	r3, [r7, #16]
   103d8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   103da:	ebc3 0302 	rsb	r3, r3, r2
   103de:	60fb      	str	r3, [r7, #12]
	}
	taskEXIT_CRITICAL();
   103e0:	f004 f832 	bl	14448 <vPortExitCritical>

	return uxReturn;
   103e4:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   103e6:	4618      	mov	r0, r3
   103e8:	f107 0718 	add.w	r7, r7, #24
   103ec:	46bd      	mov	sp, r7
   103ee:	bd80      	pop	{r7, pc}

000103f0 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
   103f0:	b480      	push	{r7}
   103f2:	b087      	sub	sp, #28
   103f4:	af00      	add	r7, sp, #0
   103f6:	6078      	str	r0, [r7, #4]
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
   103f8:	687b      	ldr	r3, [r7, #4]
   103fa:	613b      	str	r3, [r7, #16]

	configASSERT( pxQueue );
   103fc:	693b      	ldr	r3, [r7, #16]
   103fe:	2b00      	cmp	r3, #0
   10400:	d109      	bne.n	10416 <uxQueueMessagesWaitingFromISR+0x26>
   10402:	f04f 0328 	mov.w	r3, #40	; 0x28
   10406:	f383 8811 	msr	BASEPRI, r3
   1040a:	f3bf 8f6f 	isb	sy
   1040e:	f3bf 8f4f 	dsb	sy
   10412:	617b      	str	r3, [r7, #20]
   10414:	e7fe      	b.n	10414 <uxQueueMessagesWaitingFromISR+0x24>
	uxReturn = pxQueue->uxMessagesWaiting;
   10416:	693b      	ldr	r3, [r7, #16]
   10418:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   1041a:	60fb      	str	r3, [r7, #12]

	return uxReturn;
   1041c:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   1041e:	4618      	mov	r0, r3
   10420:	f107 071c 	add.w	r7, r7, #28
   10424:	46bd      	mov	sp, r7
   10426:	bc80      	pop	{r7}
   10428:	4770      	bx	lr
   1042a:	bf00      	nop

0001042c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
   1042c:	b580      	push	{r7, lr}
   1042e:	b084      	sub	sp, #16
   10430:	af00      	add	r7, sp, #0
   10432:	6078      	str	r0, [r7, #4]
Queue_t * const pxQueue = xQueue;
   10434:	687b      	ldr	r3, [r7, #4]
   10436:	60bb      	str	r3, [r7, #8]

	configASSERT( pxQueue );
   10438:	68bb      	ldr	r3, [r7, #8]
   1043a:	2b00      	cmp	r3, #0
   1043c:	d109      	bne.n	10452 <vQueueDelete+0x26>
   1043e:	f04f 0328 	mov.w	r3, #40	; 0x28
   10442:	f383 8811 	msr	BASEPRI, r3
   10446:	f3bf 8f6f 	isb	sy
   1044a:	f3bf 8f4f 	dsb	sy
   1044e:	60fb      	str	r3, [r7, #12]
   10450:	e7fe      	b.n	10450 <vQueueDelete+0x24>

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
   10452:	68b8      	ldr	r0, [r7, #8]
   10454:	f003 fdf8 	bl	14048 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
   10458:	f107 0710 	add.w	r7, r7, #16
   1045c:	46bd      	mov	sp, r7
   1045e:	bd80      	pop	{r7, pc}

00010460 <uxQueueGetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
	{
   10460:	b480      	push	{r7}
   10462:	b083      	sub	sp, #12
   10464:	af00      	add	r7, sp, #0
   10466:	6078      	str	r0, [r7, #4]
		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
   10468:	687b      	ldr	r3, [r7, #4]
   1046a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
	}
   1046c:	4618      	mov	r0, r3
   1046e:	f107 070c 	add.w	r7, r7, #12
   10472:	46bd      	mov	sp, r7
   10474:	bc80      	pop	{r7}
   10476:	4770      	bx	lr

00010478 <vQueueSetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
	{
   10478:	b480      	push	{r7}
   1047a:	b083      	sub	sp, #12
   1047c:	af00      	add	r7, sp, #0
   1047e:	6078      	str	r0, [r7, #4]
   10480:	6039      	str	r1, [r7, #0]
		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
   10482:	687b      	ldr	r3, [r7, #4]
   10484:	683a      	ldr	r2, [r7, #0]
   10486:	649a      	str	r2, [r3, #72]	; 0x48
	}
   10488:	f107 070c 	add.w	r7, r7, #12
   1048c:	46bd      	mov	sp, r7
   1048e:	bc80      	pop	{r7}
   10490:	4770      	bx	lr
   10492:	bf00      	nop

00010494 <ucQueueGetQueueType>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
	{
   10494:	b480      	push	{r7}
   10496:	b083      	sub	sp, #12
   10498:	af00      	add	r7, sp, #0
   1049a:	6078      	str	r0, [r7, #4]
		return ( ( Queue_t * ) xQueue )->ucQueueType;
   1049c:	687b      	ldr	r3, [r7, #4]
   1049e:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
	}
   104a2:	4618      	mov	r0, r3
   104a4:	f107 070c 	add.w	r7, r7, #12
   104a8:	46bd      	mov	sp, r7
   104aa:	bc80      	pop	{r7}
   104ac:	4770      	bx	lr
   104ae:	bf00      	nop

000104b0 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
   104b0:	b480      	push	{r7}
   104b2:	b085      	sub	sp, #20
   104b4:	af00      	add	r7, sp, #0
   104b6:	6078      	str	r0, [r7, #4]
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
   104b8:	687b      	ldr	r3, [r7, #4]
   104ba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   104bc:	2b00      	cmp	r3, #0
   104be:	d006      	beq.n	104ce <prvGetDisinheritPriorityAfterTimeout+0x1e>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
   104c0:	687b      	ldr	r3, [r7, #4]
   104c2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   104c4:	681b      	ldr	r3, [r3, #0]
   104c6:	f1c3 0305 	rsb	r3, r3, #5
   104ca:	60fb      	str	r3, [r7, #12]
   104cc:	e002      	b.n	104d4 <prvGetDisinheritPriorityAfterTimeout+0x24>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
   104ce:	f04f 0300 	mov.w	r3, #0
   104d2:	60fb      	str	r3, [r7, #12]
		}

		return uxHighestPriorityOfWaitingTasks;
   104d4:	68fb      	ldr	r3, [r7, #12]
	}
   104d6:	4618      	mov	r0, r3
   104d8:	f107 0714 	add.w	r7, r7, #20
   104dc:	46bd      	mov	sp, r7
   104de:	bc80      	pop	{r7}
   104e0:	4770      	bx	lr
   104e2:	bf00      	nop

000104e4 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
   104e4:	b580      	push	{r7, lr}
   104e6:	b086      	sub	sp, #24
   104e8:	af00      	add	r7, sp, #0
   104ea:	60f8      	str	r0, [r7, #12]
   104ec:	60b9      	str	r1, [r7, #8]
   104ee:	607a      	str	r2, [r7, #4]
BaseType_t xReturn = pdFALSE;
   104f0:	f04f 0300 	mov.w	r3, #0
   104f4:	613b      	str	r3, [r7, #16]
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   104f6:	68fb      	ldr	r3, [r7, #12]
   104f8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   104fa:	617b      	str	r3, [r7, #20]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
   104fc:	68fb      	ldr	r3, [r7, #12]
   104fe:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   10500:	2b00      	cmp	r3, #0
   10502:	d10f      	bne.n	10524 <prvCopyDataToQueue+0x40>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   10504:	68fb      	ldr	r3, [r7, #12]
   10506:	681b      	ldr	r3, [r3, #0]
   10508:	2b00      	cmp	r3, #0
   1050a:	d155      	bne.n	105b8 <prvCopyDataToQueue+0xd4>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
   1050c:	68fb      	ldr	r3, [r7, #12]
   1050e:	689b      	ldr	r3, [r3, #8]
   10510:	4618      	mov	r0, r3
   10512:	f002 f951 	bl	127b8 <xTaskPriorityDisinherit>
   10516:	4603      	mov	r3, r0
   10518:	613b      	str	r3, [r7, #16]
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
   1051a:	68fb      	ldr	r3, [r7, #12]
   1051c:	f04f 0200 	mov.w	r2, #0
   10520:	609a      	str	r2, [r3, #8]
   10522:	e04c      	b.n	105be <prvCopyDataToQueue+0xda>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
   10524:	687b      	ldr	r3, [r7, #4]
   10526:	2b00      	cmp	r3, #0
   10528:	d11a      	bne.n	10560 <prvCopyDataToQueue+0x7c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
   1052a:	68fb      	ldr	r3, [r7, #12]
   1052c:	685a      	ldr	r2, [r3, #4]
   1052e:	68fb      	ldr	r3, [r7, #12]
   10530:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   10532:	4610      	mov	r0, r2
   10534:	68b9      	ldr	r1, [r7, #8]
   10536:	461a      	mov	r2, r3
   10538:	f004 ff7c 	bl	15434 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
   1053c:	68fb      	ldr	r3, [r7, #12]
   1053e:	685a      	ldr	r2, [r3, #4]
   10540:	68fb      	ldr	r3, [r7, #12]
   10542:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   10544:	441a      	add	r2, r3
   10546:	68fb      	ldr	r3, [r7, #12]
   10548:	605a      	str	r2, [r3, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   1054a:	68fb      	ldr	r3, [r7, #12]
   1054c:	685a      	ldr	r2, [r3, #4]
   1054e:	68fb      	ldr	r3, [r7, #12]
   10550:	689b      	ldr	r3, [r3, #8]
   10552:	429a      	cmp	r2, r3
   10554:	d332      	bcc.n	105bc <prvCopyDataToQueue+0xd8>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
   10556:	68fb      	ldr	r3, [r7, #12]
   10558:	681a      	ldr	r2, [r3, #0]
   1055a:	68fb      	ldr	r3, [r7, #12]
   1055c:	605a      	str	r2, [r3, #4]
   1055e:	e02e      	b.n	105be <prvCopyDataToQueue+0xda>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
   10560:	68fb      	ldr	r3, [r7, #12]
   10562:	68da      	ldr	r2, [r3, #12]
   10564:	68fb      	ldr	r3, [r7, #12]
   10566:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   10568:	4610      	mov	r0, r2
   1056a:	68b9      	ldr	r1, [r7, #8]
   1056c:	461a      	mov	r2, r3
   1056e:	f004 ff61 	bl	15434 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
   10572:	68fb      	ldr	r3, [r7, #12]
   10574:	68da      	ldr	r2, [r3, #12]
   10576:	68fb      	ldr	r3, [r7, #12]
   10578:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   1057a:	f1c3 0300 	rsb	r3, r3, #0
   1057e:	441a      	add	r2, r3
   10580:	68fb      	ldr	r3, [r7, #12]
   10582:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   10584:	68fb      	ldr	r3, [r7, #12]
   10586:	68da      	ldr	r2, [r3, #12]
   10588:	68fb      	ldr	r3, [r7, #12]
   1058a:	681b      	ldr	r3, [r3, #0]
   1058c:	429a      	cmp	r2, r3
   1058e:	d208      	bcs.n	105a2 <prvCopyDataToQueue+0xbe>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
   10590:	68fb      	ldr	r3, [r7, #12]
   10592:	689a      	ldr	r2, [r3, #8]
   10594:	68fb      	ldr	r3, [r7, #12]
   10596:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   10598:	f1c3 0300 	rsb	r3, r3, #0
   1059c:	441a      	add	r2, r3
   1059e:	68fb      	ldr	r3, [r7, #12]
   105a0:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
   105a2:	687b      	ldr	r3, [r7, #4]
   105a4:	2b02      	cmp	r3, #2
   105a6:	d10a      	bne.n	105be <prvCopyDataToQueue+0xda>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   105a8:	697b      	ldr	r3, [r7, #20]
   105aa:	2b00      	cmp	r3, #0
   105ac:	d007      	beq.n	105be <prvCopyDataToQueue+0xda>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
   105ae:	697b      	ldr	r3, [r7, #20]
   105b0:	f103 33ff 	add.w	r3, r3, #4294967295
   105b4:	617b      	str	r3, [r7, #20]
   105b6:	e002      	b.n	105be <prvCopyDataToQueue+0xda>
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
   105b8:	bf00      	nop
   105ba:	e000      	b.n	105be <prvCopyDataToQueue+0xda>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
   105bc:	bf00      	nop
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   105be:	697b      	ldr	r3, [r7, #20]
   105c0:	f103 0201 	add.w	r2, r3, #1
   105c4:	68fb      	ldr	r3, [r7, #12]
   105c6:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
   105c8:	693b      	ldr	r3, [r7, #16]
}
   105ca:	4618      	mov	r0, r3
   105cc:	f107 0718 	add.w	r7, r7, #24
   105d0:	46bd      	mov	sp, r7
   105d2:	bd80      	pop	{r7, pc}

000105d4 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
   105d4:	b580      	push	{r7, lr}
   105d6:	b082      	sub	sp, #8
   105d8:	af00      	add	r7, sp, #0
   105da:	6078      	str	r0, [r7, #4]
   105dc:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
   105de:	687b      	ldr	r3, [r7, #4]
   105e0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   105e2:	2b00      	cmp	r3, #0
   105e4:	d019      	beq.n	1061a <prvCopyDataFromQueue+0x46>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
   105e6:	687b      	ldr	r3, [r7, #4]
   105e8:	68da      	ldr	r2, [r3, #12]
   105ea:	687b      	ldr	r3, [r7, #4]
   105ec:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   105ee:	441a      	add	r2, r3
   105f0:	687b      	ldr	r3, [r7, #4]
   105f2:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
   105f4:	687b      	ldr	r3, [r7, #4]
   105f6:	68da      	ldr	r2, [r3, #12]
   105f8:	687b      	ldr	r3, [r7, #4]
   105fa:	689b      	ldr	r3, [r3, #8]
   105fc:	429a      	cmp	r2, r3
   105fe:	d303      	bcc.n	10608 <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
   10600:	687b      	ldr	r3, [r7, #4]
   10602:	681a      	ldr	r2, [r3, #0]
   10604:	687b      	ldr	r3, [r7, #4]
   10606:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
   10608:	687b      	ldr	r3, [r7, #4]
   1060a:	68da      	ldr	r2, [r3, #12]
   1060c:	687b      	ldr	r3, [r7, #4]
   1060e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   10610:	6838      	ldr	r0, [r7, #0]
   10612:	4611      	mov	r1, r2
   10614:	461a      	mov	r2, r3
   10616:	f004 ff0d 	bl	15434 <memcpy>
	}
}
   1061a:	f107 0708 	add.w	r7, r7, #8
   1061e:	46bd      	mov	sp, r7
   10620:	bd80      	pop	{r7, pc}
   10622:	bf00      	nop

00010624 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
   10624:	b580      	push	{r7, lr}
   10626:	b084      	sub	sp, #16
   10628:	af00      	add	r7, sp, #0
   1062a:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
   1062c:	f003 fed4 	bl	143d8 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
   10630:	687b      	ldr	r3, [r7, #4]
   10632:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   10636:	73bb      	strb	r3, [r7, #14]

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
   10638:	e012      	b.n	10660 <prvUnlockQueue+0x3c>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1063a:	687b      	ldr	r3, [r7, #4]
   1063c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1063e:	2b00      	cmp	r3, #0
   10640:	d013      	beq.n	1066a <prvUnlockQueue+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   10642:	687b      	ldr	r3, [r7, #4]
   10644:	f103 0324 	add.w	r3, r3, #36	; 0x24
   10648:	4618      	mov	r0, r3
   1064a:	f001 fc35 	bl	11eb8 <xTaskRemoveFromEventList>
   1064e:	4603      	mov	r3, r0
   10650:	2b00      	cmp	r3, #0
   10652:	d001      	beq.n	10658 <prvUnlockQueue+0x34>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
   10654:	f001 fdc2 	bl	121dc <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
   10658:	7bbb      	ldrb	r3, [r7, #14]
   1065a:	f103 33ff 	add.w	r3, r3, #4294967295
   1065e:	73bb      	strb	r3, [r7, #14]
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
   10660:	f997 300e 	ldrsb.w	r3, [r7, #14]
   10664:	2b00      	cmp	r3, #0
   10666:	dce8      	bgt.n	1063a <prvUnlockQueue+0x16>
   10668:	e000      	b.n	1066c <prvUnlockQueue+0x48>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
   1066a:	bf00      	nop
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
   1066c:	687b      	ldr	r3, [r7, #4]
   1066e:	f04f 32ff 	mov.w	r2, #4294967295
   10672:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
   10676:	f003 fee7 	bl	14448 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
   1067a:	f003 fead 	bl	143d8 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
   1067e:	687b      	ldr	r3, [r7, #4]
   10680:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
   10684:	73fb      	strb	r3, [r7, #15]

		while( cRxLock > queueLOCKED_UNMODIFIED )
   10686:	e012      	b.n	106ae <prvUnlockQueue+0x8a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   10688:	687b      	ldr	r3, [r7, #4]
   1068a:	691b      	ldr	r3, [r3, #16]
   1068c:	2b00      	cmp	r3, #0
   1068e:	d013      	beq.n	106b8 <prvUnlockQueue+0x94>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   10690:	687b      	ldr	r3, [r7, #4]
   10692:	f103 0310 	add.w	r3, r3, #16
   10696:	4618      	mov	r0, r3
   10698:	f001 fc0e 	bl	11eb8 <xTaskRemoveFromEventList>
   1069c:	4603      	mov	r3, r0
   1069e:	2b00      	cmp	r3, #0
   106a0:	d001      	beq.n	106a6 <prvUnlockQueue+0x82>
				{
					vTaskMissedYield();
   106a2:	f001 fd9b 	bl	121dc <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
   106a6:	7bfb      	ldrb	r3, [r7, #15]
   106a8:	f103 33ff 	add.w	r3, r3, #4294967295
   106ac:	73fb      	strb	r3, [r7, #15]
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
   106ae:	f997 300f 	ldrsb.w	r3, [r7, #15]
   106b2:	2b00      	cmp	r3, #0
   106b4:	dce8      	bgt.n	10688 <prvUnlockQueue+0x64>
   106b6:	e000      	b.n	106ba <prvUnlockQueue+0x96>

				--cRxLock;
			}
			else
			{
				break;
   106b8:	bf00      	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
   106ba:	687b      	ldr	r3, [r7, #4]
   106bc:	f04f 32ff 	mov.w	r2, #4294967295
   106c0:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
   106c4:	f003 fec0 	bl	14448 <vPortExitCritical>
}
   106c8:	f107 0710 	add.w	r7, r7, #16
   106cc:	46bd      	mov	sp, r7
   106ce:	bd80      	pop	{r7, pc}

000106d0 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
   106d0:	b580      	push	{r7, lr}
   106d2:	b084      	sub	sp, #16
   106d4:	af00      	add	r7, sp, #0
   106d6:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
   106d8:	f003 fe7e 	bl	143d8 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
   106dc:	687b      	ldr	r3, [r7, #4]
   106de:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   106e0:	2b00      	cmp	r3, #0
   106e2:	d103      	bne.n	106ec <prvIsQueueEmpty+0x1c>
		{
			xReturn = pdTRUE;
   106e4:	f04f 0301 	mov.w	r3, #1
   106e8:	60fb      	str	r3, [r7, #12]
   106ea:	e002      	b.n	106f2 <prvIsQueueEmpty+0x22>
		}
		else
		{
			xReturn = pdFALSE;
   106ec:	f04f 0300 	mov.w	r3, #0
   106f0:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
   106f2:	f003 fea9 	bl	14448 <vPortExitCritical>

	return xReturn;
   106f6:	68fb      	ldr	r3, [r7, #12]
}
   106f8:	4618      	mov	r0, r3
   106fa:	f107 0710 	add.w	r7, r7, #16
   106fe:	46bd      	mov	sp, r7
   10700:	bd80      	pop	{r7, pc}
   10702:	bf00      	nop

00010704 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
   10704:	b480      	push	{r7}
   10706:	b087      	sub	sp, #28
   10708:	af00      	add	r7, sp, #0
   1070a:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
   1070c:	687b      	ldr	r3, [r7, #4]
   1070e:	613b      	str	r3, [r7, #16]

	configASSERT( pxQueue );
   10710:	693b      	ldr	r3, [r7, #16]
   10712:	2b00      	cmp	r3, #0
   10714:	d109      	bne.n	1072a <xQueueIsQueueEmptyFromISR+0x26>
   10716:	f04f 0328 	mov.w	r3, #40	; 0x28
   1071a:	f383 8811 	msr	BASEPRI, r3
   1071e:	f3bf 8f6f 	isb	sy
   10722:	f3bf 8f4f 	dsb	sy
   10726:	617b      	str	r3, [r7, #20]
   10728:	e7fe      	b.n	10728 <xQueueIsQueueEmptyFromISR+0x24>
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
   1072a:	693b      	ldr	r3, [r7, #16]
   1072c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   1072e:	2b00      	cmp	r3, #0
   10730:	d103      	bne.n	1073a <xQueueIsQueueEmptyFromISR+0x36>
	{
		xReturn = pdTRUE;
   10732:	f04f 0301 	mov.w	r3, #1
   10736:	60fb      	str	r3, [r7, #12]
   10738:	e002      	b.n	10740 <xQueueIsQueueEmptyFromISR+0x3c>
	}
	else
	{
		xReturn = pdFALSE;
   1073a:	f04f 0300 	mov.w	r3, #0
   1073e:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
   10740:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
   10742:	4618      	mov	r0, r3
   10744:	f107 071c 	add.w	r7, r7, #28
   10748:	46bd      	mov	sp, r7
   1074a:	bc80      	pop	{r7}
   1074c:	4770      	bx	lr
   1074e:	bf00      	nop

00010750 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
   10750:	b580      	push	{r7, lr}
   10752:	b084      	sub	sp, #16
   10754:	af00      	add	r7, sp, #0
   10756:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
   10758:	f003 fe3e 	bl	143d8 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   1075c:	687b      	ldr	r3, [r7, #4]
   1075e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   10760:	687b      	ldr	r3, [r7, #4]
   10762:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   10764:	429a      	cmp	r2, r3
   10766:	d103      	bne.n	10770 <prvIsQueueFull+0x20>
		{
			xReturn = pdTRUE;
   10768:	f04f 0301 	mov.w	r3, #1
   1076c:	60fb      	str	r3, [r7, #12]
   1076e:	e002      	b.n	10776 <prvIsQueueFull+0x26>
		}
		else
		{
			xReturn = pdFALSE;
   10770:	f04f 0300 	mov.w	r3, #0
   10774:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
   10776:	f003 fe67 	bl	14448 <vPortExitCritical>

	return xReturn;
   1077a:	68fb      	ldr	r3, [r7, #12]
}
   1077c:	4618      	mov	r0, r3
   1077e:	f107 0710 	add.w	r7, r7, #16
   10782:	46bd      	mov	sp, r7
   10784:	bd80      	pop	{r7, pc}
   10786:	bf00      	nop

00010788 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
   10788:	b480      	push	{r7}
   1078a:	b087      	sub	sp, #28
   1078c:	af00      	add	r7, sp, #0
   1078e:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
   10790:	687b      	ldr	r3, [r7, #4]
   10792:	613b      	str	r3, [r7, #16]

	configASSERT( pxQueue );
   10794:	693b      	ldr	r3, [r7, #16]
   10796:	2b00      	cmp	r3, #0
   10798:	d109      	bne.n	107ae <xQueueIsQueueFullFromISR+0x26>
   1079a:	f04f 0328 	mov.w	r3, #40	; 0x28
   1079e:	f383 8811 	msr	BASEPRI, r3
   107a2:	f3bf 8f6f 	isb	sy
   107a6:	f3bf 8f4f 	dsb	sy
   107aa:	617b      	str	r3, [r7, #20]
   107ac:	e7fe      	b.n	107ac <xQueueIsQueueFullFromISR+0x24>
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   107ae:	693b      	ldr	r3, [r7, #16]
   107b0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   107b2:	693b      	ldr	r3, [r7, #16]
   107b4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   107b6:	429a      	cmp	r2, r3
   107b8:	d103      	bne.n	107c2 <xQueueIsQueueFullFromISR+0x3a>
	{
		xReturn = pdTRUE;
   107ba:	f04f 0301 	mov.w	r3, #1
   107be:	60fb      	str	r3, [r7, #12]
   107c0:	e002      	b.n	107c8 <xQueueIsQueueFullFromISR+0x40>
	}
	else
	{
		xReturn = pdFALSE;
   107c2:	f04f 0300 	mov.w	r3, #0
   107c6:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
   107c8:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
   107ca:	4618      	mov	r0, r3
   107cc:	f107 071c 	add.w	r7, r7, #28
   107d0:	46bd      	mov	sp, r7
   107d2:	bc80      	pop	{r7}
   107d4:	4770      	bx	lr
   107d6:	bf00      	nop

000107d8 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
   107d8:	b580      	push	{r7, lr}
   107da:	b086      	sub	sp, #24
   107dc:	af00      	add	r7, sp, #0
   107de:	60f8      	str	r0, [r7, #12]
   107e0:	60b9      	str	r1, [r7, #8]
   107e2:	607a      	str	r2, [r7, #4]
	Queue_t * const pxQueue = xQueue;
   107e4:	68fb      	ldr	r3, [r7, #12]
   107e6:	617b      	str	r3, [r7, #20]
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
   107e8:	f003 fdf6 	bl	143d8 <vPortEnterCritical>
   107ec:	697b      	ldr	r3, [r7, #20]
   107ee:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
   107f2:	b2db      	uxtb	r3, r3
   107f4:	b25b      	sxtb	r3, r3
   107f6:	f1b3 3fff 	cmp.w	r3, #4294967295
   107fa:	d104      	bne.n	10806 <vQueueWaitForMessageRestricted+0x2e>
   107fc:	697b      	ldr	r3, [r7, #20]
   107fe:	f04f 0200 	mov.w	r2, #0
   10802:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
   10806:	697b      	ldr	r3, [r7, #20]
   10808:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   1080c:	b2db      	uxtb	r3, r3
   1080e:	b25b      	sxtb	r3, r3
   10810:	f1b3 3fff 	cmp.w	r3, #4294967295
   10814:	d104      	bne.n	10820 <vQueueWaitForMessageRestricted+0x48>
   10816:	697b      	ldr	r3, [r7, #20]
   10818:	f04f 0200 	mov.w	r2, #0
   1081c:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
   10820:	f003 fe12 	bl	14448 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
   10824:	697b      	ldr	r3, [r7, #20]
   10826:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   10828:	2b00      	cmp	r3, #0
   1082a:	d107      	bne.n	1083c <vQueueWaitForMessageRestricted+0x64>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
   1082c:	697b      	ldr	r3, [r7, #20]
   1082e:	f103 0324 	add.w	r3, r3, #36	; 0x24
   10832:	4618      	mov	r0, r3
   10834:	68b9      	ldr	r1, [r7, #8]
   10836:	687a      	ldr	r2, [r7, #4]
   10838:	f001 fb12 	bl	11e60 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
   1083c:	6978      	ldr	r0, [r7, #20]
   1083e:	f7ff fef1 	bl	10624 <prvUnlockQueue>
	}
   10842:	f107 0718 	add.w	r7, r7, #24
   10846:	46bd      	mov	sp, r7
   10848:	bd80      	pop	{r7, pc}
   1084a:	bf00      	nop

0001084c <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
   1084c:	b580      	push	{r7, lr}
   1084e:	b08c      	sub	sp, #48	; 0x30
   10850:	af04      	add	r7, sp, #16
   10852:	60f8      	str	r0, [r7, #12]
   10854:	60b9      	str	r1, [r7, #8]
   10856:	603b      	str	r3, [r7, #0]
   10858:	4613      	mov	r3, r2
   1085a:	80fb      	strh	r3, [r7, #6]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
   1085c:	88fb      	ldrh	r3, [r7, #6]
   1085e:	ea4f 0383 	mov.w	r3, r3, lsl #2
   10862:	4618      	mov	r0, r3
   10864:	f003 fb3a 	bl	13edc <pvPortMalloc>
   10868:	4603      	mov	r3, r0
   1086a:	61fb      	str	r3, [r7, #28]

			if( pxStack != NULL )
   1086c:	69fb      	ldr	r3, [r7, #28]
   1086e:	2b00      	cmp	r3, #0
   10870:	d010      	beq.n	10894 <xTaskCreate+0x48>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
   10872:	f04f 005c 	mov.w	r0, #92	; 0x5c
   10876:	f003 fb31 	bl	13edc <pvPortMalloc>
   1087a:	4603      	mov	r3, r0
   1087c:	617b      	str	r3, [r7, #20]

				if( pxNewTCB != NULL )
   1087e:	697b      	ldr	r3, [r7, #20]
   10880:	2b00      	cmp	r3, #0
   10882:	d003      	beq.n	1088c <xTaskCreate+0x40>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
   10884:	697b      	ldr	r3, [r7, #20]
   10886:	69fa      	ldr	r2, [r7, #28]
   10888:	631a      	str	r2, [r3, #48]	; 0x30
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
   1088a:	e006      	b.n	1089a <xTaskCreate+0x4e>
   1088c:	69f8      	ldr	r0, [r7, #28]
   1088e:	f003 fbdb 	bl	14048 <vPortFree>
   10892:	e002      	b.n	1089a <xTaskCreate+0x4e>
				}
			}
			else
			{
				pxNewTCB = NULL;
   10894:	f04f 0300 	mov.w	r3, #0
   10898:	617b      	str	r3, [r7, #20]
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
   1089a:	697b      	ldr	r3, [r7, #20]
   1089c:	2b00      	cmp	r3, #0
   1089e:	d016      	beq.n	108ce <xTaskCreate+0x82>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
   108a0:	88fb      	ldrh	r3, [r7, #6]
   108a2:	6aba      	ldr	r2, [r7, #40]	; 0x28
   108a4:	9200      	str	r2, [sp, #0]
   108a6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   108a8:	9201      	str	r2, [sp, #4]
   108aa:	697a      	ldr	r2, [r7, #20]
   108ac:	9202      	str	r2, [sp, #8]
   108ae:	f04f 0200 	mov.w	r2, #0
   108b2:	9203      	str	r2, [sp, #12]
   108b4:	68f8      	ldr	r0, [r7, #12]
   108b6:	68b9      	ldr	r1, [r7, #8]
   108b8:	461a      	mov	r2, r3
   108ba:	683b      	ldr	r3, [r7, #0]
   108bc:	f000 f810 	bl	108e0 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
   108c0:	6978      	ldr	r0, [r7, #20]
   108c2:	f000 f8b1 	bl	10a28 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
   108c6:	f04f 0301 	mov.w	r3, #1
   108ca:	61bb      	str	r3, [r7, #24]
   108cc:	e002      	b.n	108d4 <xTaskCreate+0x88>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   108ce:	f04f 33ff 	mov.w	r3, #4294967295
   108d2:	61bb      	str	r3, [r7, #24]
		}

		return xReturn;
   108d4:	69bb      	ldr	r3, [r7, #24]
	}
   108d6:	4618      	mov	r0, r3
   108d8:	f107 0720 	add.w	r7, r7, #32
   108dc:	46bd      	mov	sp, r7
   108de:	bd80      	pop	{r7, pc}

000108e0 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
   108e0:	b580      	push	{r7, lr}
   108e2:	b088      	sub	sp, #32
   108e4:	af00      	add	r7, sp, #0
   108e6:	60f8      	str	r0, [r7, #12]
   108e8:	60b9      	str	r1, [r7, #8]
   108ea:	607a      	str	r2, [r7, #4]
   108ec:	603b      	str	r3, [r7, #0]
			xRunPrivileged = pdFALSE;
		}
		uxPriority &= ~portPRIVILEGE_BIT;
	#endif /* portUSING_MPU_WRAPPERS == 1 */

	configASSERT( pcName );
   108ee:	68bb      	ldr	r3, [r7, #8]
   108f0:	2b00      	cmp	r3, #0
   108f2:	d109      	bne.n	10908 <prvInitialiseNewTask+0x28>
   108f4:	f04f 0328 	mov.w	r3, #40	; 0x28
   108f8:	f383 8811 	msr	BASEPRI, r3
   108fc:	f3bf 8f6f 	isb	sy
   10900:	f3bf 8f4f 	dsb	sy
   10904:	61bb      	str	r3, [r7, #24]
   10906:	e7fe      	b.n	10906 <prvInitialiseNewTask+0x26>

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
   10908:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1090a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   1090c:	687b      	ldr	r3, [r7, #4]
   1090e:	ea4f 0383 	mov.w	r3, r3, lsl #2
   10912:	4610      	mov	r0, r2
   10914:	f04f 01a5 	mov.w	r1, #165	; 0xa5
   10918:	461a      	mov	r2, r3
   1091a:	f004 fe53 	bl	155c4 <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
   1091e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   10920:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   10922:	687b      	ldr	r3, [r7, #4]
   10924:	f103 33ff 	add.w	r3, r3, #4294967295
   10928:	ea4f 0383 	mov.w	r3, r3, lsl #2
   1092c:	4413      	add	r3, r2
   1092e:	613b      	str	r3, [r7, #16]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
   10930:	693b      	ldr	r3, [r7, #16]
   10932:	f023 0307 	bic.w	r3, r3, #7
   10936:	613b      	str	r3, [r7, #16]

		/* Check the alignment of the calculated top of stack is correct. */
		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
   10938:	693b      	ldr	r3, [r7, #16]
   1093a:	f003 0307 	and.w	r3, r3, #7
   1093e:	2b00      	cmp	r3, #0
   10940:	d009      	beq.n	10956 <prvInitialiseNewTask+0x76>
   10942:	f04f 0328 	mov.w	r3, #40	; 0x28
   10946:	f383 8811 	msr	BASEPRI, r3
   1094a:	f3bf 8f6f 	isb	sy
   1094e:	f3bf 8f4f 	dsb	sy
   10952:	61fb      	str	r3, [r7, #28]
   10954:	e7fe      	b.n	10954 <prvInitialiseNewTask+0x74>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   10956:	f04f 0300 	mov.w	r3, #0
   1095a:	617b      	str	r3, [r7, #20]
   1095c:	e012      	b.n	10984 <prvInitialiseNewTask+0xa4>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
   1095e:	6979      	ldr	r1, [r7, #20]
   10960:	68ba      	ldr	r2, [r7, #8]
   10962:	697b      	ldr	r3, [r7, #20]
   10964:	4413      	add	r3, r2
   10966:	781a      	ldrb	r2, [r3, #0]
   10968:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1096a:	440b      	add	r3, r1
   1096c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == ( char ) 0x00 )
   10970:	68ba      	ldr	r2, [r7, #8]
   10972:	697b      	ldr	r3, [r7, #20]
   10974:	4413      	add	r3, r2
   10976:	781b      	ldrb	r3, [r3, #0]
   10978:	2b00      	cmp	r3, #0
   1097a:	d007      	beq.n	1098c <prvInitialiseNewTask+0xac>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   1097c:	697b      	ldr	r3, [r7, #20]
   1097e:	f103 0301 	add.w	r3, r3, #1
   10982:	617b      	str	r3, [r7, #20]
   10984:	697b      	ldr	r3, [r7, #20]
   10986:	2b09      	cmp	r3, #9
   10988:	d9e9      	bls.n	1095e <prvInitialiseNewTask+0x7e>
   1098a:	e000      	b.n	1098e <prvInitialiseNewTask+0xae>
		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == ( char ) 0x00 )
		{
			break;
   1098c:	bf00      	nop
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
   1098e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   10990:	f04f 0200 	mov.w	r2, #0
   10994:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   10998:	6abb      	ldr	r3, [r7, #40]	; 0x28
   1099a:	2b04      	cmp	r3, #4
   1099c:	d902      	bls.n	109a4 <prvInitialiseNewTask+0xc4>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   1099e:	f04f 0304 	mov.w	r3, #4
   109a2:	62bb      	str	r3, [r7, #40]	; 0x28
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
   109a4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   109a6:	6aba      	ldr	r2, [r7, #40]	; 0x28
   109a8:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
   109aa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   109ac:	6aba      	ldr	r2, [r7, #40]	; 0x28
   109ae:	649a      	str	r2, [r3, #72]	; 0x48
		pxNewTCB->uxMutexesHeld = 0;
   109b0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   109b2:	f04f 0200 	mov.w	r2, #0
   109b6:	64da      	str	r2, [r3, #76]	; 0x4c
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
   109b8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   109ba:	f103 0304 	add.w	r3, r3, #4
   109be:	4618      	mov	r0, r3
   109c0:	f7fe fc5e 	bl	f280 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
   109c4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   109c6:	f103 0318 	add.w	r3, r3, #24
   109ca:	4618      	mov	r0, r3
   109cc:	f7fe fc58 	bl	f280 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
   109d0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   109d2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   109d4:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   109d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
   109d8:	f1c3 0205 	rsb	r2, r3, #5
   109dc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   109de:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
   109e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   109e2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   109e4:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif /* configUSE_APPLICATION_TASK_TAG */

	#if ( configGENERATE_RUN_TIME_STATS == 1 )
	{
		pxNewTCB->ulRunTimeCounter = 0UL;
   109e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   109e8:	f04f 0200 	mov.w	r2, #0
   109ec:	651a      	str	r2, [r3, #80]	; 0x50
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
   109ee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   109f0:	f04f 0200 	mov.w	r2, #0
   109f4:	655a      	str	r2, [r3, #84]	; 0x54
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   109f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   109f8:	f04f 0200 	mov.w	r2, #0
   109fc:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   10a00:	6938      	ldr	r0, [r7, #16]
   10a02:	68f9      	ldr	r1, [r7, #12]
   10a04:	683a      	ldr	r2, [r7, #0]
   10a06:	f003 fbab 	bl	14160 <pxPortInitialiseStack>
   10a0a:	4603      	mov	r3, r0
   10a0c:	461a      	mov	r2, r3
   10a0e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   10a10:	601a      	str	r2, [r3, #0]
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
   10a12:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   10a14:	2b00      	cmp	r3, #0
   10a16:	d002      	beq.n	10a1e <prvInitialiseNewTask+0x13e>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
   10a18:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   10a1a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   10a1c:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   10a1e:	f107 0720 	add.w	r7, r7, #32
   10a22:	46bd      	mov	sp, r7
   10a24:	bd80      	pop	{r7, pc}
   10a26:	bf00      	nop

00010a28 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
   10a28:	b580      	push	{r7, lr}
   10a2a:	b082      	sub	sp, #8
   10a2c:	af00      	add	r7, sp, #0
   10a2e:	6078      	str	r0, [r7, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
   10a30:	f003 fcd2 	bl	143d8 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
   10a34:	f243 03cc 	movw	r3, #12492	; 0x30cc
   10a38:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10a3c:	681b      	ldr	r3, [r3, #0]
   10a3e:	f103 0201 	add.w	r2, r3, #1
   10a42:	f243 03cc 	movw	r3, #12492	; 0x30cc
   10a46:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10a4a:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
   10a4c:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10a50:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10a54:	681b      	ldr	r3, [r3, #0]
   10a56:	2b00      	cmp	r3, #0
   10a58:	d10f      	bne.n	10a7a <prvAddNewTaskToReadyList+0x52>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
   10a5a:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10a5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10a62:	687a      	ldr	r2, [r7, #4]
   10a64:	601a      	str	r2, [r3, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
   10a66:	f243 03cc 	movw	r3, #12492	; 0x30cc
   10a6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10a6e:	681b      	ldr	r3, [r3, #0]
   10a70:	2b01      	cmp	r3, #1
   10a72:	d11a      	bne.n	10aaa <prvAddNewTaskToReadyList+0x82>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
   10a74:	f001 fc04 	bl	12280 <prvInitialiseTaskLists>
   10a78:	e018      	b.n	10aac <prvAddNewTaskToReadyList+0x84>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
   10a7a:	f243 03d8 	movw	r3, #12504	; 0x30d8
   10a7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10a82:	681b      	ldr	r3, [r3, #0]
   10a84:	2b00      	cmp	r3, #0
   10a86:	d111      	bne.n	10aac <prvAddNewTaskToReadyList+0x84>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
   10a88:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10a8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10a90:	681b      	ldr	r3, [r3, #0]
   10a92:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10a94:	687b      	ldr	r3, [r7, #4]
   10a96:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   10a98:	429a      	cmp	r2, r3
   10a9a:	d807      	bhi.n	10aac <prvAddNewTaskToReadyList+0x84>
				{
					pxCurrentTCB = pxNewTCB;
   10a9c:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10aa0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10aa4:	687a      	ldr	r2, [r7, #4]
   10aa6:	601a      	str	r2, [r3, #0]
   10aa8:	e000      	b.n	10aac <prvAddNewTaskToReadyList+0x84>
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
   10aaa:	bf00      	nop
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
   10aac:	f243 03e8 	movw	r3, #12520	; 0x30e8
   10ab0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10ab4:	681b      	ldr	r3, [r3, #0]
   10ab6:	f103 0201 	add.w	r2, r3, #1
   10aba:	f243 03e8 	movw	r3, #12520	; 0x30e8
   10abe:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10ac2:	601a      	str	r2, [r3, #0]

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			/* Add a counter into the TCB for tracing only. */
			pxNewTCB->uxTCBNumber = uxTaskNumber;
   10ac4:	f243 03e8 	movw	r3, #12520	; 0x30e8
   10ac8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10acc:	681a      	ldr	r2, [r3, #0]
   10ace:	687b      	ldr	r3, [r7, #4]
   10ad0:	641a      	str	r2, [r3, #64]	; 0x40
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
   10ad2:	687b      	ldr	r3, [r7, #4]
   10ad4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   10ad6:	f04f 0201 	mov.w	r2, #1
   10ada:	fa02 f203 	lsl.w	r2, r2, r3
   10ade:	f243 03d4 	movw	r3, #12500	; 0x30d4
   10ae2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10ae6:	681b      	ldr	r3, [r3, #0]
   10ae8:	ea42 0203 	orr.w	r2, r2, r3
   10aec:	f243 03d4 	movw	r3, #12500	; 0x30d4
   10af0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10af4:	601a      	str	r2, [r3, #0]
   10af6:	687b      	ldr	r3, [r7, #4]
   10af8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10afa:	4613      	mov	r3, r2
   10afc:	ea4f 0383 	mov.w	r3, r3, lsl #2
   10b00:	4413      	add	r3, r2
   10b02:	ea4f 0383 	mov.w	r3, r3, lsl #2
   10b06:	461a      	mov	r2, r3
   10b08:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   10b0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10b10:	441a      	add	r2, r3
   10b12:	687b      	ldr	r3, [r7, #4]
   10b14:	f103 0304 	add.w	r3, r3, #4
   10b18:	4610      	mov	r0, r2
   10b1a:	4619      	mov	r1, r3
   10b1c:	f7fe fbbe 	bl	f29c <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
   10b20:	f003 fc92 	bl	14448 <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
   10b24:	f243 03d8 	movw	r3, #12504	; 0x30d8
   10b28:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10b2c:	681b      	ldr	r3, [r3, #0]
   10b2e:	2b00      	cmp	r3, #0
   10b30:	d014      	beq.n	10b5c <prvAddNewTaskToReadyList+0x134>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
   10b32:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10b36:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10b3a:	681b      	ldr	r3, [r3, #0]
   10b3c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10b3e:	687b      	ldr	r3, [r7, #4]
   10b40:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   10b42:	429a      	cmp	r2, r3
   10b44:	d20a      	bcs.n	10b5c <prvAddNewTaskToReadyList+0x134>
		{
			taskYIELD_IF_USING_PREEMPTION();
   10b46:	f64e 5304 	movw	r3, #60676	; 0xed04
   10b4a:	f2ce 0300 	movt	r3, #57344	; 0xe000
   10b4e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   10b52:	601a      	str	r2, [r3, #0]
   10b54:	f3bf 8f4f 	dsb	sy
   10b58:	f3bf 8f6f 	isb	sy
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   10b5c:	f107 0708 	add.w	r7, r7, #8
   10b60:	46bd      	mov	sp, r7
   10b62:	bd80      	pop	{r7, pc}

00010b64 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
   10b64:	b580      	push	{r7, lr}
   10b66:	b084      	sub	sp, #16
   10b68:	af00      	add	r7, sp, #0
   10b6a:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
   10b6c:	f003 fc34 	bl	143d8 <vPortEnterCritical>
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
   10b70:	687b      	ldr	r3, [r7, #4]
   10b72:	2b00      	cmp	r3, #0
   10b74:	d105      	bne.n	10b82 <vTaskDelete+0x1e>
   10b76:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10b7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10b7e:	681b      	ldr	r3, [r3, #0]
   10b80:	e000      	b.n	10b84 <vTaskDelete+0x20>
   10b82:	687b      	ldr	r3, [r7, #4]
   10b84:	60bb      	str	r3, [r7, #8]

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   10b86:	68bb      	ldr	r3, [r7, #8]
   10b88:	f103 0304 	add.w	r3, r3, #4
   10b8c:	4618      	mov	r0, r3
   10b8e:	f7fe fbe3 	bl	f358 <uxListRemove>
   10b92:	4603      	mov	r3, r0
   10b94:	2b00      	cmp	r3, #0
   10b96:	d124      	bne.n	10be2 <vTaskDelete+0x7e>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   10b98:	68bb      	ldr	r3, [r7, #8]
   10b9a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10b9c:	4613      	mov	r3, r2
   10b9e:	ea4f 0383 	mov.w	r3, r3, lsl #2
   10ba2:	4413      	add	r3, r2
   10ba4:	ea4f 0383 	mov.w	r3, r3, lsl #2
   10ba8:	461a      	mov	r2, r3
   10baa:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   10bae:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10bb2:	4413      	add	r3, r2
   10bb4:	681b      	ldr	r3, [r3, #0]
   10bb6:	2b00      	cmp	r3, #0
   10bb8:	d113      	bne.n	10be2 <vTaskDelete+0x7e>
   10bba:	68bb      	ldr	r3, [r7, #8]
   10bbc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   10bbe:	f04f 0201 	mov.w	r2, #1
   10bc2:	fa02 f303 	lsl.w	r3, r2, r3
   10bc6:	ea6f 0203 	mvn.w	r2, r3
   10bca:	f243 03d4 	movw	r3, #12500	; 0x30d4
   10bce:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10bd2:	681b      	ldr	r3, [r3, #0]
   10bd4:	ea02 0203 	and.w	r2, r2, r3
   10bd8:	f243 03d4 	movw	r3, #12500	; 0x30d4
   10bdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10be0:	601a      	str	r2, [r3, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   10be2:	68bb      	ldr	r3, [r7, #8]
   10be4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   10be6:	2b00      	cmp	r3, #0
   10be8:	d005      	beq.n	10bf6 <vTaskDelete+0x92>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   10bea:	68bb      	ldr	r3, [r7, #8]
   10bec:	f103 0318 	add.w	r3, r3, #24
   10bf0:	4618      	mov	r0, r3
   10bf2:	f7fe fbb1 	bl	f358 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
   10bf6:	f243 03e8 	movw	r3, #12520	; 0x30e8
   10bfa:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10bfe:	681b      	ldr	r3, [r3, #0]
   10c00:	f103 0201 	add.w	r2, r3, #1
   10c04:	f243 03e8 	movw	r3, #12520	; 0x30e8
   10c08:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10c0c:	601a      	str	r2, [r3, #0]

			if( pxTCB == pxCurrentTCB )
   10c0e:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10c12:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10c16:	681b      	ldr	r3, [r3, #0]
   10c18:	68ba      	ldr	r2, [r7, #8]
   10c1a:	429a      	cmp	r2, r3
   10c1c:	d116      	bne.n	10c4c <vTaskDelete+0xe8>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
   10c1e:	68bb      	ldr	r3, [r7, #8]
   10c20:	f103 0304 	add.w	r3, r3, #4
   10c24:	f243 00a0 	movw	r0, #12448	; 0x30a0
   10c28:	f2c2 0000 	movt	r0, #8192	; 0x2000
   10c2c:	4619      	mov	r1, r3
   10c2e:	f7fe fb35 	bl	f29c <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
   10c32:	f243 03b4 	movw	r3, #12468	; 0x30b4
   10c36:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10c3a:	681b      	ldr	r3, [r3, #0]
   10c3c:	f103 0201 	add.w	r2, r3, #1
   10c40:	f243 03b4 	movw	r3, #12468	; 0x30b4
   10c44:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10c48:	601a      	str	r2, [r3, #0]
   10c4a:	e010      	b.n	10c6e <vTaskDelete+0x10a>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
   10c4c:	f243 03cc 	movw	r3, #12492	; 0x30cc
   10c50:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10c54:	681b      	ldr	r3, [r3, #0]
   10c56:	f103 32ff 	add.w	r2, r3, #4294967295
   10c5a:	f243 03cc 	movw	r3, #12492	; 0x30cc
   10c5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10c62:	601a      	str	r2, [r3, #0]
				prvDeleteTCB( pxTCB );
   10c64:	68b8      	ldr	r0, [r7, #8]
   10c66:	f001 fc85 	bl	12574 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
   10c6a:	f001 fc93 	bl	12594 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
   10c6e:	f003 fbeb 	bl	14448 <vPortExitCritical>

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
   10c72:	f243 03d8 	movw	r3, #12504	; 0x30d8
   10c76:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10c7a:	681b      	ldr	r3, [r3, #0]
   10c7c:	2b00      	cmp	r3, #0
   10c7e:	d023      	beq.n	10cc8 <vTaskDelete+0x164>
		{
			if( pxTCB == pxCurrentTCB )
   10c80:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10c84:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10c88:	681b      	ldr	r3, [r3, #0]
   10c8a:	68ba      	ldr	r2, [r7, #8]
   10c8c:	429a      	cmp	r2, r3
   10c8e:	d11b      	bne.n	10cc8 <vTaskDelete+0x164>
			{
				configASSERT( uxSchedulerSuspended == 0 );
   10c90:	f243 03f4 	movw	r3, #12532	; 0x30f4
   10c94:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10c98:	681b      	ldr	r3, [r3, #0]
   10c9a:	2b00      	cmp	r3, #0
   10c9c:	d009      	beq.n	10cb2 <vTaskDelete+0x14e>
   10c9e:	f04f 0328 	mov.w	r3, #40	; 0x28
   10ca2:	f383 8811 	msr	BASEPRI, r3
   10ca6:	f3bf 8f6f 	isb	sy
   10caa:	f3bf 8f4f 	dsb	sy
   10cae:	60fb      	str	r3, [r7, #12]
   10cb0:	e7fe      	b.n	10cb0 <vTaskDelete+0x14c>
				portYIELD_WITHIN_API();
   10cb2:	f64e 5304 	movw	r3, #60676	; 0xed04
   10cb6:	f2ce 0300 	movt	r3, #57344	; 0xe000
   10cba:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   10cbe:	601a      	str	r2, [r3, #0]
   10cc0:	f3bf 8f4f 	dsb	sy
   10cc4:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
   10cc8:	f107 0710 	add.w	r7, r7, #16
   10ccc:	46bd      	mov	sp, r7
   10cce:	bd80      	pop	{r7, pc}

00010cd0 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
   10cd0:	b580      	push	{r7, lr}
   10cd2:	b08a      	sub	sp, #40	; 0x28
   10cd4:	af00      	add	r7, sp, #0
   10cd6:	6078      	str	r0, [r7, #4]
   10cd8:	6039      	str	r1, [r7, #0]
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
   10cda:	f04f 0300 	mov.w	r3, #0
   10cde:	617b      	str	r3, [r7, #20]

		configASSERT( pxPreviousWakeTime );
   10ce0:	687b      	ldr	r3, [r7, #4]
   10ce2:	2b00      	cmp	r3, #0
   10ce4:	d109      	bne.n	10cfa <vTaskDelayUntil+0x2a>
   10ce6:	f04f 0328 	mov.w	r3, #40	; 0x28
   10cea:	f383 8811 	msr	BASEPRI, r3
   10cee:	f3bf 8f6f 	isb	sy
   10cf2:	f3bf 8f4f 	dsb	sy
   10cf6:	61fb      	str	r3, [r7, #28]
   10cf8:	e7fe      	b.n	10cf8 <vTaskDelayUntil+0x28>
		configASSERT( ( xTimeIncrement > 0U ) );
   10cfa:	683b      	ldr	r3, [r7, #0]
   10cfc:	2b00      	cmp	r3, #0
   10cfe:	d109      	bne.n	10d14 <vTaskDelayUntil+0x44>
   10d00:	f04f 0328 	mov.w	r3, #40	; 0x28
   10d04:	f383 8811 	msr	BASEPRI, r3
   10d08:	f3bf 8f6f 	isb	sy
   10d0c:	f3bf 8f4f 	dsb	sy
   10d10:	623b      	str	r3, [r7, #32]
   10d12:	e7fe      	b.n	10d12 <vTaskDelayUntil+0x42>
		configASSERT( uxSchedulerSuspended == 0 );
   10d14:	f243 03f4 	movw	r3, #12532	; 0x30f4
   10d18:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10d1c:	681b      	ldr	r3, [r3, #0]
   10d1e:	2b00      	cmp	r3, #0
   10d20:	d009      	beq.n	10d36 <vTaskDelayUntil+0x66>
   10d22:	f04f 0328 	mov.w	r3, #40	; 0x28
   10d26:	f383 8811 	msr	BASEPRI, r3
   10d2a:	f3bf 8f6f 	isb	sy
   10d2e:	f3bf 8f4f 	dsb	sy
   10d32:	627b      	str	r3, [r7, #36]	; 0x24
   10d34:	e7fe      	b.n	10d34 <vTaskDelayUntil+0x64>

		vTaskSuspendAll();
   10d36:	f000 fc6d 	bl	11614 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
   10d3a:	f243 03d0 	movw	r3, #12496	; 0x30d0
   10d3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10d42:	681b      	ldr	r3, [r3, #0]
   10d44:	61bb      	str	r3, [r7, #24]

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
   10d46:	687b      	ldr	r3, [r7, #4]
   10d48:	681a      	ldr	r2, [r3, #0]
   10d4a:	683b      	ldr	r3, [r7, #0]
   10d4c:	4413      	add	r3, r2
   10d4e:	60fb      	str	r3, [r7, #12]

			if( xConstTickCount < *pxPreviousWakeTime )
   10d50:	687b      	ldr	r3, [r7, #4]
   10d52:	681a      	ldr	r2, [r3, #0]
   10d54:	69bb      	ldr	r3, [r7, #24]
   10d56:	429a      	cmp	r2, r3
   10d58:	d90c      	bls.n	10d74 <vTaskDelayUntil+0xa4>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
   10d5a:	687b      	ldr	r3, [r7, #4]
   10d5c:	681a      	ldr	r2, [r3, #0]
   10d5e:	68fb      	ldr	r3, [r7, #12]
   10d60:	429a      	cmp	r2, r3
   10d62:	d914      	bls.n	10d8e <vTaskDelayUntil+0xbe>
   10d64:	68fa      	ldr	r2, [r7, #12]
   10d66:	69bb      	ldr	r3, [r7, #24]
   10d68:	429a      	cmp	r2, r3
   10d6a:	d912      	bls.n	10d92 <vTaskDelayUntil+0xc2>
				{
					xShouldDelay = pdTRUE;
   10d6c:	f04f 0301 	mov.w	r3, #1
   10d70:	617b      	str	r3, [r7, #20]
   10d72:	e00f      	b.n	10d94 <vTaskDelayUntil+0xc4>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
   10d74:	687b      	ldr	r3, [r7, #4]
   10d76:	681a      	ldr	r2, [r3, #0]
   10d78:	68fb      	ldr	r3, [r7, #12]
   10d7a:	429a      	cmp	r2, r3
   10d7c:	d803      	bhi.n	10d86 <vTaskDelayUntil+0xb6>
   10d7e:	68fa      	ldr	r2, [r7, #12]
   10d80:	69bb      	ldr	r3, [r7, #24]
   10d82:	429a      	cmp	r2, r3
   10d84:	d906      	bls.n	10d94 <vTaskDelayUntil+0xc4>
				{
					xShouldDelay = pdTRUE;
   10d86:	f04f 0301 	mov.w	r3, #1
   10d8a:	617b      	str	r3, [r7, #20]
   10d8c:	e002      	b.n	10d94 <vTaskDelayUntil+0xc4>
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
   10d8e:	bf00      	nop
   10d90:	e000      	b.n	10d94 <vTaskDelayUntil+0xc4>
   10d92:	bf00      	nop
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
   10d94:	687b      	ldr	r3, [r7, #4]
   10d96:	68fa      	ldr	r2, [r7, #12]
   10d98:	601a      	str	r2, [r3, #0]

			if( xShouldDelay != pdFALSE )
   10d9a:	697b      	ldr	r3, [r7, #20]
   10d9c:	2b00      	cmp	r3, #0
   10d9e:	d008      	beq.n	10db2 <vTaskDelayUntil+0xe2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
   10da0:	68fa      	ldr	r2, [r7, #12]
   10da2:	69bb      	ldr	r3, [r7, #24]
   10da4:	ebc3 0302 	rsb	r3, r3, r2
   10da8:	4618      	mov	r0, r3
   10daa:	f04f 0100 	mov.w	r1, #0
   10dae:	f002 fb7b 	bl	134a8 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
   10db2:	f000 fc41 	bl	11638 <xTaskResumeAll>
   10db6:	4603      	mov	r3, r0
   10db8:	613b      	str	r3, [r7, #16]

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
   10dba:	693b      	ldr	r3, [r7, #16]
   10dbc:	2b00      	cmp	r3, #0
   10dbe:	d10a      	bne.n	10dd6 <vTaskDelayUntil+0x106>
		{
			portYIELD_WITHIN_API();
   10dc0:	f64e 5304 	movw	r3, #60676	; 0xed04
   10dc4:	f2ce 0300 	movt	r3, #57344	; 0xe000
   10dc8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   10dcc:	601a      	str	r2, [r3, #0]
   10dce:	f3bf 8f4f 	dsb	sy
   10dd2:	f3bf 8f6f 	isb	sy
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   10dd6:	f107 0728 	add.w	r7, r7, #40	; 0x28
   10dda:	46bd      	mov	sp, r7
   10ddc:	bd80      	pop	{r7, pc}
   10dde:	bf00      	nop

00010de0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
   10de0:	b580      	push	{r7, lr}
   10de2:	b084      	sub	sp, #16
   10de4:	af00      	add	r7, sp, #0
   10de6:	6078      	str	r0, [r7, #4]
	BaseType_t xAlreadyYielded = pdFALSE;
   10de8:	f04f 0300 	mov.w	r3, #0
   10dec:	60bb      	str	r3, [r7, #8]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
   10dee:	687b      	ldr	r3, [r7, #4]
   10df0:	2b00      	cmp	r3, #0
   10df2:	d01b      	beq.n	10e2c <vTaskDelay+0x4c>
		{
			configASSERT( uxSchedulerSuspended == 0 );
   10df4:	f243 03f4 	movw	r3, #12532	; 0x30f4
   10df8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10dfc:	681b      	ldr	r3, [r3, #0]
   10dfe:	2b00      	cmp	r3, #0
   10e00:	d009      	beq.n	10e16 <vTaskDelay+0x36>
   10e02:	f04f 0328 	mov.w	r3, #40	; 0x28
   10e06:	f383 8811 	msr	BASEPRI, r3
   10e0a:	f3bf 8f6f 	isb	sy
   10e0e:	f3bf 8f4f 	dsb	sy
   10e12:	60fb      	str	r3, [r7, #12]
   10e14:	e7fe      	b.n	10e14 <vTaskDelay+0x34>
			vTaskSuspendAll();
   10e16:	f000 fbfd 	bl	11614 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
   10e1a:	6878      	ldr	r0, [r7, #4]
   10e1c:	f04f 0100 	mov.w	r1, #0
   10e20:	f002 fb42 	bl	134a8 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
   10e24:	f000 fc08 	bl	11638 <xTaskResumeAll>
   10e28:	4603      	mov	r3, r0
   10e2a:	60bb      	str	r3, [r7, #8]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
   10e2c:	68bb      	ldr	r3, [r7, #8]
   10e2e:	2b00      	cmp	r3, #0
   10e30:	d10a      	bne.n	10e48 <vTaskDelay+0x68>
		{
			portYIELD_WITHIN_API();
   10e32:	f64e 5304 	movw	r3, #60676	; 0xed04
   10e36:	f2ce 0300 	movt	r3, #57344	; 0xe000
   10e3a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   10e3e:	601a      	str	r2, [r3, #0]
   10e40:	f3bf 8f4f 	dsb	sy
   10e44:	f3bf 8f6f 	isb	sy
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   10e48:	f107 0710 	add.w	r7, r7, #16
   10e4c:	46bd      	mov	sp, r7
   10e4e:	bd80      	pop	{r7, pc}

00010e50 <eTaskGetState>:
/*-----------------------------------------------------------*/

#if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )

	eTaskState eTaskGetState( TaskHandle_t xTask )
	{
   10e50:	b580      	push	{r7, lr}
   10e52:	b088      	sub	sp, #32
   10e54:	af00      	add	r7, sp, #0
   10e56:	6078      	str	r0, [r7, #4]
	eTaskState eReturn;
	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
	const TCB_t * const pxTCB = xTask;
   10e58:	687b      	ldr	r3, [r7, #4]
   10e5a:	61bb      	str	r3, [r7, #24]

		configASSERT( pxTCB );
   10e5c:	69bb      	ldr	r3, [r7, #24]
   10e5e:	2b00      	cmp	r3, #0
   10e60:	d109      	bne.n	10e76 <eTaskGetState+0x26>
   10e62:	f04f 0328 	mov.w	r3, #40	; 0x28
   10e66:	f383 8811 	msr	BASEPRI, r3
   10e6a:	f3bf 8f6f 	isb	sy
   10e6e:	f3bf 8f4f 	dsb	sy
   10e72:	61fb      	str	r3, [r7, #28]
   10e74:	e7fe      	b.n	10e74 <eTaskGetState+0x24>

		if( pxTCB == pxCurrentTCB )
   10e76:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10e7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10e7e:	681b      	ldr	r3, [r3, #0]
   10e80:	69ba      	ldr	r2, [r7, #24]
   10e82:	429a      	cmp	r2, r3
   10e84:	d103      	bne.n	10e8e <eTaskGetState+0x3e>
		{
			/* The task calling this function is querying its own state. */
			eReturn = eRunning;
   10e86:	f04f 0300 	mov.w	r3, #0
   10e8a:	72fb      	strb	r3, [r7, #11]
   10e8c:	e04c      	b.n	10f28 <eTaskGetState+0xd8>
		}
		else
		{
			taskENTER_CRITICAL();
   10e8e:	f003 faa3 	bl	143d8 <vPortEnterCritical>
			{
				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
   10e92:	69bb      	ldr	r3, [r7, #24]
   10e94:	695b      	ldr	r3, [r3, #20]
   10e96:	60fb      	str	r3, [r7, #12]
				pxDelayedList = pxDelayedTaskList;
   10e98:	f243 0384 	movw	r3, #12420	; 0x3084
   10e9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10ea0:	681b      	ldr	r3, [r3, #0]
   10ea2:	613b      	str	r3, [r7, #16]
				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
   10ea4:	f243 0388 	movw	r3, #12424	; 0x3088
   10ea8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10eac:	681b      	ldr	r3, [r3, #0]
   10eae:	617b      	str	r3, [r7, #20]
			}
			taskEXIT_CRITICAL();
   10eb0:	f003 faca 	bl	14448 <vPortExitCritical>

			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
   10eb4:	68fa      	ldr	r2, [r7, #12]
   10eb6:	693b      	ldr	r3, [r7, #16]
   10eb8:	429a      	cmp	r2, r3
   10eba:	d003      	beq.n	10ec4 <eTaskGetState+0x74>
   10ebc:	68fa      	ldr	r2, [r7, #12]
   10ebe:	697b      	ldr	r3, [r7, #20]
   10ec0:	429a      	cmp	r2, r3
   10ec2:	d103      	bne.n	10ecc <eTaskGetState+0x7c>
			{
				/* The task being queried is referenced from one of the Blocked
				lists. */
				eReturn = eBlocked;
   10ec4:	f04f 0302 	mov.w	r3, #2
   10ec8:	72fb      	strb	r3, [r7, #11]
				pxDelayedList = pxDelayedTaskList;
				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
			}
			taskEXIT_CRITICAL();

			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
   10eca:	e02d      	b.n	10f28 <eTaskGetState+0xd8>
				lists. */
				eReturn = eBlocked;
			}

			#if ( INCLUDE_vTaskSuspend == 1 )
				else if( pxStateList == &xSuspendedTaskList )
   10ecc:	68fa      	ldr	r2, [r7, #12]
   10ece:	f243 03b8 	movw	r3, #12472	; 0x30b8
   10ed2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10ed6:	429a      	cmp	r2, r3
   10ed8:	d115      	bne.n	10f06 <eTaskGetState+0xb6>
				{
					/* The task being queried is referenced from the suspended
					list.  Is it genuinely suspended or is it blocked
					indefinitely? */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
   10eda:	69bb      	ldr	r3, [r7, #24]
   10edc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   10ede:	2b00      	cmp	r3, #0
   10ee0:	d10d      	bne.n	10efe <eTaskGetState+0xae>
						{
							/* The task does not appear on the event list item of
							and of the RTOS objects, but could still be in the
							blocked state if it is waiting on its notification
							rather than waiting on an object. */
							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
   10ee2:	69bb      	ldr	r3, [r7, #24]
   10ee4:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
   10ee8:	b2db      	uxtb	r3, r3
   10eea:	2b01      	cmp	r3, #1
   10eec:	d103      	bne.n	10ef6 <eTaskGetState+0xa6>
							{
								eReturn = eBlocked;
   10eee:	f04f 0302 	mov.w	r3, #2
   10ef2:	72fb      	strb	r3, [r7, #11]
						}
						#endif
					}
					else
					{
						eReturn = eBlocked;
   10ef4:	e018      	b.n	10f28 <eTaskGetState+0xd8>
							{
								eReturn = eBlocked;
							}
							else
							{
								eReturn = eSuspended;
   10ef6:	f04f 0303 	mov.w	r3, #3
   10efa:	72fb      	strb	r3, [r7, #11]
						}
						#endif
					}
					else
					{
						eReturn = eBlocked;
   10efc:	e014      	b.n	10f28 <eTaskGetState+0xd8>
   10efe:	f04f 0302 	mov.w	r3, #2
   10f02:	72fb      	strb	r3, [r7, #11]
   10f04:	e010      	b.n	10f28 <eTaskGetState+0xd8>
					}
				}
			#endif

			#if ( INCLUDE_vTaskDelete == 1 )
				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
   10f06:	68fa      	ldr	r2, [r7, #12]
   10f08:	f243 03a0 	movw	r3, #12448	; 0x30a0
   10f0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10f10:	429a      	cmp	r2, r3
   10f12:	d002      	beq.n	10f1a <eTaskGetState+0xca>
   10f14:	68fb      	ldr	r3, [r7, #12]
   10f16:	2b00      	cmp	r3, #0
   10f18:	d103      	bne.n	10f22 <eTaskGetState+0xd2>
				{
					/* The task being queried is referenced from the deleted
					tasks list, or it is not referenced from any lists at
					all. */
					eReturn = eDeleted;
   10f1a:	f04f 0304 	mov.w	r3, #4
   10f1e:	72fb      	strb	r3, [r7, #11]
					}
				}
			#endif

			#if ( INCLUDE_vTaskDelete == 1 )
				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
   10f20:	e002      	b.n	10f28 <eTaskGetState+0xd8>

			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
			{
				/* If the task is not in any other state, it must be in the
				Ready (including pending ready) state. */
				eReturn = eReady;
   10f22:	f04f 0301 	mov.w	r3, #1
   10f26:	72fb      	strb	r3, [r7, #11]
			}
		}

		return eReturn;
   10f28:	7afb      	ldrb	r3, [r7, #11]
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   10f2a:	4618      	mov	r0, r3
   10f2c:	f107 0720 	add.w	r7, r7, #32
   10f30:	46bd      	mov	sp, r7
   10f32:	bd80      	pop	{r7, pc}

00010f34 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
	{
   10f34:	b580      	push	{r7, lr}
   10f36:	b084      	sub	sp, #16
   10f38:	af00      	add	r7, sp, #0
   10f3a:	6078      	str	r0, [r7, #4]
	TCB_t const *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
   10f3c:	f003 fa4c 	bl	143d8 <vPortEnterCritical>
		{
			/* If null is passed in here then it is the priority of the task
			that called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
   10f40:	687b      	ldr	r3, [r7, #4]
   10f42:	2b00      	cmp	r3, #0
   10f44:	d105      	bne.n	10f52 <uxTaskPriorityGet+0x1e>
   10f46:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10f4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10f4e:	681b      	ldr	r3, [r3, #0]
   10f50:	e000      	b.n	10f54 <uxTaskPriorityGet+0x20>
   10f52:	687b      	ldr	r3, [r7, #4]
   10f54:	60bb      	str	r3, [r7, #8]
			uxReturn = pxTCB->uxPriority;
   10f56:	68bb      	ldr	r3, [r7, #8]
   10f58:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   10f5a:	60fb      	str	r3, [r7, #12]
		}
		taskEXIT_CRITICAL();
   10f5c:	f003 fa74 	bl	14448 <vPortExitCritical>

		return uxReturn;
   10f60:	68fb      	ldr	r3, [r7, #12]
	}
   10f62:	4618      	mov	r0, r3
   10f64:	f107 0710 	add.w	r7, r7, #16
   10f68:	46bd      	mov	sp, r7
   10f6a:	bd80      	pop	{r7, pc}

00010f6c <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
	{
   10f6c:	b580      	push	{r7, lr}
   10f6e:	b088      	sub	sp, #32
   10f70:	af00      	add	r7, sp, #0
   10f72:	6078      	str	r0, [r7, #4]
		below the maximum system call interrupt priority.  FreeRTOS maintains a
		separate interrupt safe API to ensure interrupt entry is as fast and as
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   10f74:	f003 fb14 	bl	145a0 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
   10f78:	f3ef 8211 	mrs	r2, BASEPRI
   10f7c:	f04f 0328 	mov.w	r3, #40	; 0x28
   10f80:	f383 8811 	msr	BASEPRI, r3
   10f84:	f3bf 8f6f 	isb	sy
   10f88:	f3bf 8f4f 	dsb	sy
   10f8c:	61ba      	str	r2, [r7, #24]
   10f8e:	617b      	str	r3, [r7, #20]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
   10f90:	69bb      	ldr	r3, [r7, #24]

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
   10f92:	613b      	str	r3, [r7, #16]
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
   10f94:	687b      	ldr	r3, [r7, #4]
   10f96:	2b00      	cmp	r3, #0
   10f98:	d105      	bne.n	10fa6 <uxTaskPriorityGetFromISR+0x3a>
   10f9a:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   10f9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   10fa2:	681b      	ldr	r3, [r3, #0]
   10fa4:	e000      	b.n	10fa8 <uxTaskPriorityGetFromISR+0x3c>
   10fa6:	687b      	ldr	r3, [r7, #4]
   10fa8:	60bb      	str	r3, [r7, #8]
			uxReturn = pxTCB->uxPriority;
   10faa:	68bb      	ldr	r3, [r7, #8]
   10fac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   10fae:	60fb      	str	r3, [r7, #12]
   10fb0:	693b      	ldr	r3, [r7, #16]
   10fb2:	61fb      	str	r3, [r7, #28]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   10fb4:	69fb      	ldr	r3, [r7, #28]
   10fb6:	f383 8811 	msr	BASEPRI, r3
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
   10fba:	68fb      	ldr	r3, [r7, #12]
	}
   10fbc:	4618      	mov	r0, r3
   10fbe:	f107 0720 	add.w	r7, r7, #32
   10fc2:	46bd      	mov	sp, r7
   10fc4:	bd80      	pop	{r7, pc}
   10fc6:	bf00      	nop

00010fc8 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
   10fc8:	b580      	push	{r7, lr}
   10fca:	b088      	sub	sp, #32
   10fcc:	af00      	add	r7, sp, #0
   10fce:	6078      	str	r0, [r7, #4]
   10fd0:	6039      	str	r1, [r7, #0]
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
   10fd2:	f04f 0300 	mov.w	r3, #0
   10fd6:	61bb      	str	r3, [r7, #24]

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
   10fd8:	683b      	ldr	r3, [r7, #0]
   10fda:	2b04      	cmp	r3, #4
   10fdc:	d909      	bls.n	10ff2 <vTaskPrioritySet+0x2a>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   10fde:	f04f 0328 	mov.w	r3, #40	; 0x28
   10fe2:	f383 8811 	msr	BASEPRI, r3
   10fe6:	f3bf 8f6f 	isb	sy
   10fea:	f3bf 8f4f 	dsb	sy
   10fee:	61fb      	str	r3, [r7, #28]
   10ff0:	e7fe      	b.n	10ff0 <vTaskPrioritySet+0x28>

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   10ff2:	683b      	ldr	r3, [r7, #0]
   10ff4:	2b04      	cmp	r3, #4
   10ff6:	d902      	bls.n	10ffe <vTaskPrioritySet+0x36>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   10ff8:	f04f 0304 	mov.w	r3, #4
   10ffc:	603b      	str	r3, [r7, #0]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
   10ffe:	f003 f9eb 	bl	143d8 <vPortEnterCritical>
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
   11002:	687b      	ldr	r3, [r7, #4]
   11004:	2b00      	cmp	r3, #0
   11006:	d105      	bne.n	11014 <vTaskPrioritySet+0x4c>
   11008:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   1100c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11010:	681b      	ldr	r3, [r3, #0]
   11012:	e000      	b.n	11016 <vTaskPrioritySet+0x4e>
   11014:	687b      	ldr	r3, [r7, #4]
   11016:	60fb      	str	r3, [r7, #12]

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
   11018:	68fb      	ldr	r3, [r7, #12]
   1101a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   1101c:	613b      	str	r3, [r7, #16]
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
   1101e:	693a      	ldr	r2, [r7, #16]
   11020:	683b      	ldr	r3, [r7, #0]
   11022:	429a      	cmp	r2, r3
   11024:	f000 80a2 	beq.w	1116c <vTaskPrioritySet+0x1a4>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
   11028:	683a      	ldr	r2, [r7, #0]
   1102a:	693b      	ldr	r3, [r7, #16]
   1102c:	429a      	cmp	r2, r3
   1102e:	d914      	bls.n	1105a <vTaskPrioritySet+0x92>
				{
					if( pxTCB != pxCurrentTCB )
   11030:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   11034:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11038:	681b      	ldr	r3, [r3, #0]
   1103a:	68fa      	ldr	r2, [r7, #12]
   1103c:	429a      	cmp	r2, r3
   1103e:	d018      	beq.n	11072 <vTaskPrioritySet+0xaa>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
   11040:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   11044:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11048:	681b      	ldr	r3, [r3, #0]
   1104a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1104c:	683b      	ldr	r3, [r7, #0]
   1104e:	429a      	cmp	r2, r3
   11050:	d811      	bhi.n	11076 <vTaskPrioritySet+0xae>
						{
							xYieldRequired = pdTRUE;
   11052:	f04f 0301 	mov.w	r3, #1
   11056:	61bb      	str	r3, [r7, #24]
   11058:	e00e      	b.n	11078 <vTaskPrioritySet+0xb0>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
   1105a:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   1105e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11062:	681b      	ldr	r3, [r3, #0]
   11064:	68fa      	ldr	r2, [r7, #12]
   11066:	429a      	cmp	r2, r3
   11068:	d106      	bne.n	11078 <vTaskPrioritySet+0xb0>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
   1106a:	f04f 0301 	mov.w	r3, #1
   1106e:	61bb      	str	r3, [r7, #24]
   11070:	e002      	b.n	11078 <vTaskPrioritySet+0xb0>
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
						{
							xYieldRequired = pdTRUE;
   11072:	bf00      	nop
   11074:	e000      	b.n	11078 <vTaskPrioritySet+0xb0>
   11076:	bf00      	nop
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
   11078:	68fb      	ldr	r3, [r7, #12]
   1107a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1107c:	617b      	str	r3, [r7, #20]

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
   1107e:	68fb      	ldr	r3, [r7, #12]
   11080:	6c9a      	ldr	r2, [r3, #72]	; 0x48
   11082:	68fb      	ldr	r3, [r7, #12]
   11084:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11086:	429a      	cmp	r2, r3
   11088:	d102      	bne.n	11090 <vTaskPrioritySet+0xc8>
					{
						pxTCB->uxPriority = uxNewPriority;
   1108a:	68fb      	ldr	r3, [r7, #12]
   1108c:	683a      	ldr	r2, [r7, #0]
   1108e:	62da      	str	r2, [r3, #44]	; 0x2c
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
   11090:	68fb      	ldr	r3, [r7, #12]
   11092:	683a      	ldr	r2, [r7, #0]
   11094:	649a      	str	r2, [r3, #72]	; 0x48
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   11096:	68fb      	ldr	r3, [r7, #12]
   11098:	699b      	ldr	r3, [r3, #24]
   1109a:	2b00      	cmp	r3, #0
   1109c:	db04      	blt.n	110a8 <vTaskPrioritySet+0xe0>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1109e:	683b      	ldr	r3, [r7, #0]
   110a0:	f1c3 0205 	rsb	r2, r3, #5
   110a4:	68fb      	ldr	r3, [r7, #12]
   110a6:	619a      	str	r2, [r3, #24]

				/* If the task is in the blocked or suspended list we need do
				nothing more than change its priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
   110a8:	68fb      	ldr	r3, [r7, #12]
   110aa:	6959      	ldr	r1, [r3, #20]
   110ac:	697a      	ldr	r2, [r7, #20]
   110ae:	4613      	mov	r3, r2
   110b0:	ea4f 0383 	mov.w	r3, r3, lsl #2
   110b4:	4413      	add	r3, r2
   110b6:	ea4f 0383 	mov.w	r3, r3, lsl #2
   110ba:	461a      	mov	r2, r3
   110bc:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   110c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   110c4:	4413      	add	r3, r2
   110c6:	4299      	cmp	r1, r3
   110c8:	d142      	bne.n	11150 <vTaskPrioritySet+0x188>
				{
					/* The task is currently in its ready list - remove before
					adding it to it's new ready list.  As we are in a critical
					section we can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   110ca:	68fb      	ldr	r3, [r7, #12]
   110cc:	f103 0304 	add.w	r3, r3, #4
   110d0:	4618      	mov	r0, r3
   110d2:	f7fe f941 	bl	f358 <uxListRemove>
   110d6:	4603      	mov	r3, r0
   110d8:	2b00      	cmp	r3, #0
   110da:	d112      	bne.n	11102 <vTaskPrioritySet+0x13a>
					{
						/* It is known that the task is in its ready list so
						there is no need to check again and the port level
						reset macro can be called directly. */
						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
   110dc:	697b      	ldr	r3, [r7, #20]
   110de:	f04f 0201 	mov.w	r2, #1
   110e2:	fa02 f303 	lsl.w	r3, r2, r3
   110e6:	ea6f 0203 	mvn.w	r2, r3
   110ea:	f243 03d4 	movw	r3, #12500	; 0x30d4
   110ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
   110f2:	681b      	ldr	r3, [r3, #0]
   110f4:	ea02 0203 	and.w	r2, r2, r3
   110f8:	f243 03d4 	movw	r3, #12500	; 0x30d4
   110fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11100:	601a      	str	r2, [r3, #0]
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
   11102:	68fb      	ldr	r3, [r7, #12]
   11104:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11106:	f04f 0201 	mov.w	r2, #1
   1110a:	fa02 f203 	lsl.w	r2, r2, r3
   1110e:	f243 03d4 	movw	r3, #12500	; 0x30d4
   11112:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11116:	681b      	ldr	r3, [r3, #0]
   11118:	ea42 0203 	orr.w	r2, r2, r3
   1111c:	f243 03d4 	movw	r3, #12500	; 0x30d4
   11120:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11124:	601a      	str	r2, [r3, #0]
   11126:	68fb      	ldr	r3, [r7, #12]
   11128:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1112a:	4613      	mov	r3, r2
   1112c:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11130:	4413      	add	r3, r2
   11132:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11136:	461a      	mov	r2, r3
   11138:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   1113c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11140:	441a      	add	r2, r3
   11142:	68fb      	ldr	r3, [r7, #12]
   11144:	f103 0304 	add.w	r3, r3, #4
   11148:	4610      	mov	r0, r2
   1114a:	4619      	mov	r1, r3
   1114c:	f7fe f8a6 	bl	f29c <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
   11150:	69bb      	ldr	r3, [r7, #24]
   11152:	2b00      	cmp	r3, #0
   11154:	d00a      	beq.n	1116c <vTaskPrioritySet+0x1a4>
				{
					taskYIELD_IF_USING_PREEMPTION();
   11156:	f64e 5304 	movw	r3, #60676	; 0xed04
   1115a:	f2ce 0300 	movt	r3, #57344	; 0xe000
   1115e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   11162:	601a      	str	r2, [r3, #0]
   11164:	f3bf 8f4f 	dsb	sy
   11168:	f3bf 8f6f 	isb	sy
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
   1116c:	f003 f96c 	bl	14448 <vPortExitCritical>
	}
   11170:	f107 0720 	add.w	r7, r7, #32
   11174:	46bd      	mov	sp, r7
   11176:	bd80      	pop	{r7, pc}

00011178 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
   11178:	b580      	push	{r7, lr}
   1117a:	b084      	sub	sp, #16
   1117c:	af00      	add	r7, sp, #0
   1117e:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
   11180:	f003 f92a 	bl	143d8 <vPortEnterCritical>
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
   11184:	687b      	ldr	r3, [r7, #4]
   11186:	2b00      	cmp	r3, #0
   11188:	d105      	bne.n	11196 <vTaskSuspend+0x1e>
   1118a:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   1118e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11192:	681b      	ldr	r3, [r3, #0]
   11194:	e000      	b.n	11198 <vTaskSuspend+0x20>
   11196:	687b      	ldr	r3, [r7, #4]
   11198:	60bb      	str	r3, [r7, #8]

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   1119a:	68bb      	ldr	r3, [r7, #8]
   1119c:	f103 0304 	add.w	r3, r3, #4
   111a0:	4618      	mov	r0, r3
   111a2:	f7fe f8d9 	bl	f358 <uxListRemove>
   111a6:	4603      	mov	r3, r0
   111a8:	2b00      	cmp	r3, #0
   111aa:	d124      	bne.n	111f6 <vTaskSuspend+0x7e>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   111ac:	68bb      	ldr	r3, [r7, #8]
   111ae:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   111b0:	4613      	mov	r3, r2
   111b2:	ea4f 0383 	mov.w	r3, r3, lsl #2
   111b6:	4413      	add	r3, r2
   111b8:	ea4f 0383 	mov.w	r3, r3, lsl #2
   111bc:	461a      	mov	r2, r3
   111be:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   111c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   111c6:	4413      	add	r3, r2
   111c8:	681b      	ldr	r3, [r3, #0]
   111ca:	2b00      	cmp	r3, #0
   111cc:	d113      	bne.n	111f6 <vTaskSuspend+0x7e>
   111ce:	68bb      	ldr	r3, [r7, #8]
   111d0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   111d2:	f04f 0201 	mov.w	r2, #1
   111d6:	fa02 f303 	lsl.w	r3, r2, r3
   111da:	ea6f 0203 	mvn.w	r2, r3
   111de:	f243 03d4 	movw	r3, #12500	; 0x30d4
   111e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   111e6:	681b      	ldr	r3, [r3, #0]
   111e8:	ea02 0203 	and.w	r2, r2, r3
   111ec:	f243 03d4 	movw	r3, #12500	; 0x30d4
   111f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   111f4:	601a      	str	r2, [r3, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   111f6:	68bb      	ldr	r3, [r7, #8]
   111f8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   111fa:	2b00      	cmp	r3, #0
   111fc:	d005      	beq.n	1120a <vTaskSuspend+0x92>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   111fe:	68bb      	ldr	r3, [r7, #8]
   11200:	f103 0318 	add.w	r3, r3, #24
   11204:	4618      	mov	r0, r3
   11206:	f7fe f8a7 	bl	f358 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
   1120a:	68bb      	ldr	r3, [r7, #8]
   1120c:	f103 0304 	add.w	r3, r3, #4
   11210:	f243 00b8 	movw	r0, #12472	; 0x30b8
   11214:	f2c2 0000 	movt	r0, #8192	; 0x2000
   11218:	4619      	mov	r1, r3
   1121a:	f7fe f83f 	bl	f29c <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
   1121e:	68bb      	ldr	r3, [r7, #8]
   11220:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
   11224:	b2db      	uxtb	r3, r3
   11226:	2b01      	cmp	r3, #1
   11228:	d104      	bne.n	11234 <vTaskSuspend+0xbc>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   1122a:	68bb      	ldr	r3, [r7, #8]
   1122c:	f04f 0200 	mov.w	r2, #0
   11230:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
   11234:	f003 f908 	bl	14448 <vPortExitCritical>

		if( xSchedulerRunning != pdFALSE )
   11238:	f243 03d8 	movw	r3, #12504	; 0x30d8
   1123c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11240:	681b      	ldr	r3, [r3, #0]
   11242:	2b00      	cmp	r3, #0
   11244:	d005      	beq.n	11252 <vTaskSuspend+0xda>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
   11246:	f003 f8c7 	bl	143d8 <vPortEnterCritical>
			{
				prvResetNextTaskUnblockTime();
   1124a:	f001 f9a3 	bl	12594 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
   1124e:	f003 f8fb 	bl	14448 <vPortExitCritical>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
   11252:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   11256:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1125a:	681b      	ldr	r3, [r3, #0]
   1125c:	68ba      	ldr	r2, [r7, #8]
   1125e:	429a      	cmp	r2, r3
   11260:	d139      	bne.n	112d6 <vTaskSuspend+0x15e>
		{
			if( xSchedulerRunning != pdFALSE )
   11262:	f243 03d8 	movw	r3, #12504	; 0x30d8
   11266:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1126a:	681b      	ldr	r3, [r3, #0]
   1126c:	2b00      	cmp	r3, #0
   1126e:	d01c      	beq.n	112aa <vTaskSuspend+0x132>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
   11270:	f243 03f4 	movw	r3, #12532	; 0x30f4
   11274:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11278:	681b      	ldr	r3, [r3, #0]
   1127a:	2b00      	cmp	r3, #0
   1127c:	d009      	beq.n	11292 <vTaskSuspend+0x11a>
   1127e:	f04f 0328 	mov.w	r3, #40	; 0x28
   11282:	f383 8811 	msr	BASEPRI, r3
   11286:	f3bf 8f6f 	isb	sy
   1128a:	f3bf 8f4f 	dsb	sy
   1128e:	60fb      	str	r3, [r7, #12]
   11290:	e7fe      	b.n	11290 <vTaskSuspend+0x118>
				portYIELD_WITHIN_API();
   11292:	f64e 5304 	movw	r3, #60676	; 0xed04
   11296:	f2ce 0300 	movt	r3, #57344	; 0xe000
   1129a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1129e:	601a      	str	r2, [r3, #0]
   112a0:	f3bf 8f4f 	dsb	sy
   112a4:	f3bf 8f6f 	isb	sy
   112a8:	e015      	b.n	112d6 <vTaskSuspend+0x15e>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
   112aa:	f243 03b8 	movw	r3, #12472	; 0x30b8
   112ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
   112b2:	681a      	ldr	r2, [r3, #0]
   112b4:	f243 03cc 	movw	r3, #12492	; 0x30cc
   112b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   112bc:	681b      	ldr	r3, [r3, #0]
   112be:	429a      	cmp	r2, r3
   112c0:	d107      	bne.n	112d2 <vTaskSuspend+0x15a>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
   112c2:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   112c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   112ca:	f04f 0200 	mov.w	r2, #0
   112ce:	601a      	str	r2, [r3, #0]
   112d0:	e001      	b.n	112d6 <vTaskSuspend+0x15e>
				}
				else
				{
					vTaskSwitchContext();
   112d2:	f000 fc89 	bl	11be8 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   112d6:	f107 0710 	add.w	r7, r7, #16
   112da:	46bd      	mov	sp, r7
   112dc:	bd80      	pop	{r7, pc}
   112de:	bf00      	nop

000112e0 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
   112e0:	b480      	push	{r7}
   112e2:	b087      	sub	sp, #28
   112e4:	af00      	add	r7, sp, #0
   112e6:	6078      	str	r0, [r7, #4]
	BaseType_t xReturn = pdFALSE;
   112e8:	f04f 0300 	mov.w	r3, #0
   112ec:	60fb      	str	r3, [r7, #12]
	const TCB_t * const pxTCB = xTask;
   112ee:	687b      	ldr	r3, [r7, #4]
   112f0:	613b      	str	r3, [r7, #16]

		/* Accesses xPendingReadyList so must be called from a critical
		section. */

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );
   112f2:	687b      	ldr	r3, [r7, #4]
   112f4:	2b00      	cmp	r3, #0
   112f6:	d109      	bne.n	1130c <prvTaskIsTaskSuspended+0x2c>
   112f8:	f04f 0328 	mov.w	r3, #40	; 0x28
   112fc:	f383 8811 	msr	BASEPRI, r3
   11300:	f3bf 8f6f 	isb	sy
   11304:	f3bf 8f4f 	dsb	sy
   11308:	617b      	str	r3, [r7, #20]
   1130a:	e7fe      	b.n	1130a <prvTaskIsTaskSuspended+0x2a>

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
   1130c:	693b      	ldr	r3, [r7, #16]
   1130e:	695a      	ldr	r2, [r3, #20]
   11310:	f243 03b8 	movw	r3, #12472	; 0x30b8
   11314:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11318:	429a      	cmp	r2, r3
   1131a:	d10e      	bne.n	1133a <prvTaskIsTaskSuspended+0x5a>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
   1131c:	693b      	ldr	r3, [r7, #16]
   1131e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   11320:	f243 038c 	movw	r3, #12428	; 0x308c
   11324:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11328:	429a      	cmp	r2, r3
   1132a:	d006      	beq.n	1133a <prvTaskIsTaskSuspended+0x5a>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
   1132c:	693b      	ldr	r3, [r7, #16]
   1132e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   11330:	2b00      	cmp	r3, #0
   11332:	d102      	bne.n	1133a <prvTaskIsTaskSuspended+0x5a>
				{
					xReturn = pdTRUE;
   11334:	f04f 0301 	mov.w	r3, #1
   11338:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
   1133a:	68fb      	ldr	r3, [r7, #12]
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   1133c:	4618      	mov	r0, r3
   1133e:	f107 071c 	add.w	r7, r7, #28
   11342:	46bd      	mov	sp, r7
   11344:	bc80      	pop	{r7}
   11346:	4770      	bx	lr

00011348 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
   11348:	b580      	push	{r7, lr}
   1134a:	b084      	sub	sp, #16
   1134c:	af00      	add	r7, sp, #0
   1134e:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = xTaskToResume;
   11350:	687b      	ldr	r3, [r7, #4]
   11352:	60bb      	str	r3, [r7, #8]

		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );
   11354:	687b      	ldr	r3, [r7, #4]
   11356:	2b00      	cmp	r3, #0
   11358:	d109      	bne.n	1136e <vTaskResume+0x26>
   1135a:	f04f 0328 	mov.w	r3, #40	; 0x28
   1135e:	f383 8811 	msr	BASEPRI, r3
   11362:	f3bf 8f6f 	isb	sy
   11366:	f3bf 8f4f 	dsb	sy
   1136a:	60fb      	str	r3, [r7, #12]
   1136c:	e7fe      	b.n	1136c <vTaskResume+0x24>

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
   1136e:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   11372:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11376:	681b      	ldr	r3, [r3, #0]
   11378:	68ba      	ldr	r2, [r7, #8]
   1137a:	429a      	cmp	r2, r3
   1137c:	d04e      	beq.n	1141c <vTaskResume+0xd4>
   1137e:	68bb      	ldr	r3, [r7, #8]
   11380:	2b00      	cmp	r3, #0
   11382:	d04b      	beq.n	1141c <vTaskResume+0xd4>
		{
			taskENTER_CRITICAL();
   11384:	f003 f828 	bl	143d8 <vPortEnterCritical>
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
   11388:	68b8      	ldr	r0, [r7, #8]
   1138a:	f7ff ffa9 	bl	112e0 <prvTaskIsTaskSuspended>
   1138e:	4603      	mov	r3, r0
   11390:	2b00      	cmp	r3, #0
   11392:	d041      	beq.n	11418 <vTaskResume+0xd0>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
   11394:	68bb      	ldr	r3, [r7, #8]
   11396:	f103 0304 	add.w	r3, r3, #4
   1139a:	4618      	mov	r0, r3
   1139c:	f7fd ffdc 	bl	f358 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   113a0:	68bb      	ldr	r3, [r7, #8]
   113a2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   113a4:	f04f 0201 	mov.w	r2, #1
   113a8:	fa02 f203 	lsl.w	r2, r2, r3
   113ac:	f243 03d4 	movw	r3, #12500	; 0x30d4
   113b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   113b4:	681b      	ldr	r3, [r3, #0]
   113b6:	ea42 0203 	orr.w	r2, r2, r3
   113ba:	f243 03d4 	movw	r3, #12500	; 0x30d4
   113be:	f2c2 0300 	movt	r3, #8192	; 0x2000
   113c2:	601a      	str	r2, [r3, #0]
   113c4:	68bb      	ldr	r3, [r7, #8]
   113c6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   113c8:	4613      	mov	r3, r2
   113ca:	ea4f 0383 	mov.w	r3, r3, lsl #2
   113ce:	4413      	add	r3, r2
   113d0:	ea4f 0383 	mov.w	r3, r3, lsl #2
   113d4:	461a      	mov	r2, r3
   113d6:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   113da:	f2c2 0300 	movt	r3, #8192	; 0x2000
   113de:	441a      	add	r2, r3
   113e0:	68bb      	ldr	r3, [r7, #8]
   113e2:	f103 0304 	add.w	r3, r3, #4
   113e6:	4610      	mov	r0, r2
   113e8:	4619      	mov	r1, r3
   113ea:	f7fd ff57 	bl	f29c <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   113ee:	68bb      	ldr	r3, [r7, #8]
   113f0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   113f2:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   113f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   113fa:	681b      	ldr	r3, [r3, #0]
   113fc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   113fe:	429a      	cmp	r2, r3
   11400:	d30a      	bcc.n	11418 <vTaskResume+0xd0>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
   11402:	f64e 5304 	movw	r3, #60676	; 0xed04
   11406:	f2ce 0300 	movt	r3, #57344	; 0xe000
   1140a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1140e:	601a      	str	r2, [r3, #0]
   11410:	f3bf 8f4f 	dsb	sy
   11414:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
   11418:	f003 f816 	bl	14448 <vPortExitCritical>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   1141c:	f107 0710 	add.w	r7, r7, #16
   11420:	46bd      	mov	sp, r7
   11422:	bd80      	pop	{r7, pc}

00011424 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
   11424:	b580      	push	{r7, lr}
   11426:	b08a      	sub	sp, #40	; 0x28
   11428:	af00      	add	r7, sp, #0
   1142a:	6078      	str	r0, [r7, #4]
	BaseType_t xYieldRequired = pdFALSE;
   1142c:	f04f 0300 	mov.w	r3, #0
   11430:	60fb      	str	r3, [r7, #12]
	TCB_t * const pxTCB = xTaskToResume;
   11432:	687b      	ldr	r3, [r7, #4]
   11434:	613b      	str	r3, [r7, #16]
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToResume );
   11436:	687b      	ldr	r3, [r7, #4]
   11438:	2b00      	cmp	r3, #0
   1143a:	d109      	bne.n	11450 <xTaskResumeFromISR+0x2c>
   1143c:	f04f 0328 	mov.w	r3, #40	; 0x28
   11440:	f383 8811 	msr	BASEPRI, r3
   11444:	f3bf 8f6f 	isb	sy
   11448:	f3bf 8f4f 	dsb	sy
   1144c:	61bb      	str	r3, [r7, #24]
   1144e:	e7fe      	b.n	1144e <xTaskResumeFromISR+0x2a>
		below the maximum system call interrupt priority.  FreeRTOS maintains a
		separate interrupt safe API to ensure interrupt entry is as fast and as
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   11450:	f003 f8a6 	bl	145a0 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
   11454:	f3ef 8211 	mrs	r2, BASEPRI
   11458:	f04f 0328 	mov.w	r3, #40	; 0x28
   1145c:	f383 8811 	msr	BASEPRI, r3
   11460:	f3bf 8f6f 	isb	sy
   11464:	f3bf 8f4f 	dsb	sy
   11468:	623a      	str	r2, [r7, #32]
   1146a:	61fb      	str	r3, [r7, #28]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
   1146c:	6a3b      	ldr	r3, [r7, #32]

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   1146e:	617b      	str	r3, [r7, #20]
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
   11470:	6938      	ldr	r0, [r7, #16]
   11472:	f7ff ff35 	bl	112e0 <prvTaskIsTaskSuspended>
   11476:	4603      	mov	r3, r0
   11478:	2b00      	cmp	r3, #0
   1147a:	d04b      	beq.n	11514 <xTaskResumeFromISR+0xf0>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   1147c:	f243 03f4 	movw	r3, #12532	; 0x30f4
   11480:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11484:	681b      	ldr	r3, [r3, #0]
   11486:	2b00      	cmp	r3, #0
   11488:	d13a      	bne.n	11500 <xTaskResumeFromISR+0xdc>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1148a:	693b      	ldr	r3, [r7, #16]
   1148c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1148e:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   11492:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11496:	681b      	ldr	r3, [r3, #0]
   11498:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1149a:	429a      	cmp	r2, r3
   1149c:	d302      	bcc.n	114a4 <xTaskResumeFromISR+0x80>
					{
						xYieldRequired = pdTRUE;
   1149e:	f04f 0301 	mov.w	r3, #1
   114a2:	60fb      	str	r3, [r7, #12]
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   114a4:	693b      	ldr	r3, [r7, #16]
   114a6:	f103 0304 	add.w	r3, r3, #4
   114aa:	4618      	mov	r0, r3
   114ac:	f7fd ff54 	bl	f358 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   114b0:	693b      	ldr	r3, [r7, #16]
   114b2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   114b4:	f04f 0201 	mov.w	r2, #1
   114b8:	fa02 f203 	lsl.w	r2, r2, r3
   114bc:	f243 03d4 	movw	r3, #12500	; 0x30d4
   114c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   114c4:	681b      	ldr	r3, [r3, #0]
   114c6:	ea42 0203 	orr.w	r2, r2, r3
   114ca:	f243 03d4 	movw	r3, #12500	; 0x30d4
   114ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
   114d2:	601a      	str	r2, [r3, #0]
   114d4:	693b      	ldr	r3, [r7, #16]
   114d6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   114d8:	4613      	mov	r3, r2
   114da:	ea4f 0383 	mov.w	r3, r3, lsl #2
   114de:	4413      	add	r3, r2
   114e0:	ea4f 0383 	mov.w	r3, r3, lsl #2
   114e4:	461a      	mov	r2, r3
   114e6:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   114ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
   114ee:	441a      	add	r2, r3
   114f0:	693b      	ldr	r3, [r7, #16]
   114f2:	f103 0304 	add.w	r3, r3, #4
   114f6:	4610      	mov	r0, r2
   114f8:	4619      	mov	r1, r3
   114fa:	f7fd fecf 	bl	f29c <vListInsertEnd>
   114fe:	e009      	b.n	11514 <xTaskResumeFromISR+0xf0>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   11500:	693b      	ldr	r3, [r7, #16]
   11502:	f103 0318 	add.w	r3, r3, #24
   11506:	f243 008c 	movw	r0, #12428	; 0x308c
   1150a:	f2c2 0000 	movt	r0, #8192	; 0x2000
   1150e:	4619      	mov	r1, r3
   11510:	f7fd fec4 	bl	f29c <vListInsertEnd>
   11514:	697b      	ldr	r3, [r7, #20]
   11516:	627b      	str	r3, [r7, #36]	; 0x24
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   11518:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1151a:	f383 8811 	msr	BASEPRI, r3
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
   1151e:	68fb      	ldr	r3, [r7, #12]
	}
   11520:	4618      	mov	r0, r3
   11522:	f107 0728 	add.w	r7, r7, #40	; 0x28
   11526:	46bd      	mov	sp, r7
   11528:	bd80      	pop	{r7, pc}
   1152a:	bf00      	nop

0001152c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
   1152c:	b580      	push	{r7, lr}
   1152e:	b086      	sub	sp, #24
   11530:	af02      	add	r7, sp, #8
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
   11532:	f04f 0300 	mov.w	r3, #0
   11536:	9300      	str	r3, [sp, #0]
   11538:	f243 03f0 	movw	r3, #12528	; 0x30f0
   1153c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11540:	9301      	str	r3, [sp, #4]
   11542:	f242 2049 	movw	r0, #8777	; 0x2249
   11546:	f2c0 0001 	movt	r0, #1
   1154a:	f64f 1108 	movw	r1, #63752	; 0xf908
   1154e:	f2c0 0102 	movt	r1, #2
   11552:	f04f 025a 	mov.w	r2, #90	; 0x5a
   11556:	f04f 0300 	mov.w	r3, #0
   1155a:	f7ff f977 	bl	1084c <xTaskCreate>
   1155e:	4603      	mov	r3, r0
   11560:	607b      	str	r3, [r7, #4]
	}
	#endif /* configSUPPORT_STATIC_ALLOCATION */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
   11562:	687b      	ldr	r3, [r7, #4]
   11564:	2b01      	cmp	r3, #1
   11566:	d103      	bne.n	11570 <vTaskStartScheduler+0x44>
		{
			xReturn = xTimerCreateTimerTask();
   11568:	f002 f826 	bl	135b8 <xTimerCreateTimerTask>
   1156c:	4603      	mov	r3, r0
   1156e:	607b      	str	r3, [r7, #4]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
   11570:	687b      	ldr	r3, [r7, #4]
   11572:	2b01      	cmp	r3, #1
   11574:	d122      	bne.n	115bc <vTaskStartScheduler+0x90>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   11576:	f04f 0328 	mov.w	r3, #40	; 0x28
   1157a:	f383 8811 	msr	BASEPRI, r3
   1157e:	f3bf 8f6f 	isb	sy
   11582:	f3bf 8f4f 	dsb	sy
   11586:	60bb      	str	r3, [r7, #8]
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
   11588:	f243 03ec 	movw	r3, #12524	; 0x30ec
   1158c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11590:	f04f 32ff 	mov.w	r2, #4294967295
   11594:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
   11596:	f243 03d8 	movw	r3, #12504	; 0x30d8
   1159a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1159e:	f04f 0201 	mov.w	r2, #1
   115a2:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
   115a4:	f243 03d0 	movw	r3, #12496	; 0x30d0
   115a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   115ac:	f04f 0200 	mov.w	r2, #0
   115b0:	601a      	str	r2, [r3, #0]
		macro must be defined to configure the timer/counter used to generate
		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
		is set to 0 and the following line fails to build then ensure you do not
		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
		FreeRTOSConfig.h file. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
   115b2:	f7ef fb1b 	bl	bec <vMainConfigureTimerForRunTimeStats>

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
   115b6:	f002 fe5b 	bl	14270 <xPortStartScheduler>
   115ba:	e00d      	b.n	115d8 <vTaskStartScheduler+0xac>
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
   115bc:	687b      	ldr	r3, [r7, #4]
   115be:	f1b3 3fff 	cmp.w	r3, #4294967295
   115c2:	d109      	bne.n	115d8 <vTaskStartScheduler+0xac>
   115c4:	f04f 0328 	mov.w	r3, #40	; 0x28
   115c8:	f383 8811 	msr	BASEPRI, r3
   115cc:	f3bf 8f6f 	isb	sy
   115d0:	f3bf 8f4f 	dsb	sy
   115d4:	60fb      	str	r3, [r7, #12]
   115d6:	e7fe      	b.n	115d6 <vTaskStartScheduler+0xaa>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
   115d8:	f107 0710 	add.w	r7, r7, #16
   115dc:	46bd      	mov	sp, r7
   115de:	bd80      	pop	{r7, pc}

000115e0 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
   115e0:	b580      	push	{r7, lr}
   115e2:	b082      	sub	sp, #8
   115e4:	af00      	add	r7, sp, #0
   115e6:	f04f 0328 	mov.w	r3, #40	; 0x28
   115ea:	f383 8811 	msr	BASEPRI, r3
   115ee:	f3bf 8f6f 	isb	sy
   115f2:	f3bf 8f4f 	dsb	sy
   115f6:	607b      	str	r3, [r7, #4]
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
	xSchedulerRunning = pdFALSE;
   115f8:	f243 03d8 	movw	r3, #12504	; 0x30d8
   115fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11600:	f04f 0200 	mov.w	r2, #0
   11604:	601a      	str	r2, [r3, #0]
	vPortEndScheduler();
   11606:	f002 fecd 	bl	143a4 <vPortEndScheduler>
}
   1160a:	f107 0708 	add.w	r7, r7, #8
   1160e:	46bd      	mov	sp, r7
   11610:	bd80      	pop	{r7, pc}
   11612:	bf00      	nop

00011614 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
   11614:	b480      	push	{r7}
   11616:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
   11618:	f243 03f4 	movw	r3, #12532	; 0x30f4
   1161c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11620:	681b      	ldr	r3, [r3, #0]
   11622:	f103 0201 	add.w	r2, r3, #1
   11626:	f243 03f4 	movw	r3, #12532	; 0x30f4
   1162a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1162e:	601a      	str	r2, [r3, #0]
}
   11630:	46bd      	mov	sp, r7
   11632:	bc80      	pop	{r7}
   11634:	4770      	bx	lr
   11636:	bf00      	nop

00011638 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
   11638:	b580      	push	{r7, lr}
   1163a:	b084      	sub	sp, #16
   1163c:	af00      	add	r7, sp, #0
TCB_t *pxTCB = NULL;
   1163e:	f04f 0300 	mov.w	r3, #0
   11642:	603b      	str	r3, [r7, #0]
BaseType_t xAlreadyYielded = pdFALSE;
   11644:	f04f 0300 	mov.w	r3, #0
   11648:	607b      	str	r3, [r7, #4]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
   1164a:	f243 03f4 	movw	r3, #12532	; 0x30f4
   1164e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11652:	681b      	ldr	r3, [r3, #0]
   11654:	2b00      	cmp	r3, #0
   11656:	d109      	bne.n	1166c <xTaskResumeAll+0x34>
   11658:	f04f 0328 	mov.w	r3, #40	; 0x28
   1165c:	f383 8811 	msr	BASEPRI, r3
   11660:	f3bf 8f6f 	isb	sy
   11664:	f3bf 8f4f 	dsb	sy
   11668:	60fb      	str	r3, [r7, #12]
   1166a:	e7fe      	b.n	1166a <xTaskResumeAll+0x32>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
   1166c:	f002 feb4 	bl	143d8 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
   11670:	f243 03f4 	movw	r3, #12532	; 0x30f4
   11674:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11678:	681b      	ldr	r3, [r3, #0]
   1167a:	f103 32ff 	add.w	r2, r3, #4294967295
   1167e:	f243 03f4 	movw	r3, #12532	; 0x30f4
   11682:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11686:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   11688:	f243 03f4 	movw	r3, #12532	; 0x30f4
   1168c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11690:	681b      	ldr	r3, [r3, #0]
   11692:	2b00      	cmp	r3, #0
   11694:	f040 8098 	bne.w	117c8 <xTaskResumeAll+0x190>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   11698:	f243 03cc 	movw	r3, #12492	; 0x30cc
   1169c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   116a0:	681b      	ldr	r3, [r3, #0]
   116a2:	2b00      	cmp	r3, #0
   116a4:	f000 8090 	beq.w	117c8 <xTaskResumeAll+0x190>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   116a8:	e04a      	b.n	11740 <xTaskResumeAll+0x108>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   116aa:	f243 038c 	movw	r3, #12428	; 0x308c
   116ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
   116b2:	68db      	ldr	r3, [r3, #12]
   116b4:	68db      	ldr	r3, [r3, #12]
   116b6:	603b      	str	r3, [r7, #0]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   116b8:	683b      	ldr	r3, [r7, #0]
   116ba:	f103 0318 	add.w	r3, r3, #24
   116be:	4618      	mov	r0, r3
   116c0:	f7fd fe4a 	bl	f358 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   116c4:	683b      	ldr	r3, [r7, #0]
   116c6:	f103 0304 	add.w	r3, r3, #4
   116ca:	4618      	mov	r0, r3
   116cc:	f7fd fe44 	bl	f358 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   116d0:	683b      	ldr	r3, [r7, #0]
   116d2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   116d4:	f04f 0201 	mov.w	r2, #1
   116d8:	fa02 f203 	lsl.w	r2, r2, r3
   116dc:	f243 03d4 	movw	r3, #12500	; 0x30d4
   116e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   116e4:	681b      	ldr	r3, [r3, #0]
   116e6:	ea42 0203 	orr.w	r2, r2, r3
   116ea:	f243 03d4 	movw	r3, #12500	; 0x30d4
   116ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
   116f2:	601a      	str	r2, [r3, #0]
   116f4:	683b      	ldr	r3, [r7, #0]
   116f6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   116f8:	4613      	mov	r3, r2
   116fa:	ea4f 0383 	mov.w	r3, r3, lsl #2
   116fe:	4413      	add	r3, r2
   11700:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11704:	461a      	mov	r2, r3
   11706:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   1170a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1170e:	441a      	add	r2, r3
   11710:	683b      	ldr	r3, [r7, #0]
   11712:	f103 0304 	add.w	r3, r3, #4
   11716:	4610      	mov	r0, r2
   11718:	4619      	mov	r1, r3
   1171a:	f7fd fdbf 	bl	f29c <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1171e:	683b      	ldr	r3, [r7, #0]
   11720:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11722:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   11726:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1172a:	681b      	ldr	r3, [r3, #0]
   1172c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1172e:	429a      	cmp	r2, r3
   11730:	d306      	bcc.n	11740 <xTaskResumeAll+0x108>
					{
						xYieldPending = pdTRUE;
   11732:	f243 03e0 	movw	r3, #12512	; 0x30e0
   11736:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1173a:	f04f 0201 	mov.w	r2, #1
   1173e:	601a      	str	r2, [r3, #0]
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   11740:	f243 038c 	movw	r3, #12428	; 0x308c
   11744:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11748:	681b      	ldr	r3, [r3, #0]
   1174a:	2b00      	cmp	r3, #0
   1174c:	d1ad      	bne.n	116aa <xTaskResumeAll+0x72>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
   1174e:	683b      	ldr	r3, [r7, #0]
   11750:	2b00      	cmp	r3, #0
   11752:	d001      	beq.n	11758 <xTaskResumeAll+0x120>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
   11754:	f000 ff1e 	bl	12594 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
   11758:	f243 03dc 	movw	r3, #12508	; 0x30dc
   1175c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11760:	681b      	ldr	r3, [r3, #0]
   11762:	60bb      	str	r3, [r7, #8]

					if( uxPendedCounts > ( UBaseType_t ) 0U )
   11764:	68bb      	ldr	r3, [r7, #8]
   11766:	2b00      	cmp	r3, #0
   11768:	d019      	beq.n	1179e <xTaskResumeAll+0x166>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
   1176a:	f000 f93b 	bl	119e4 <xTaskIncrementTick>
   1176e:	4603      	mov	r3, r0
   11770:	2b00      	cmp	r3, #0
   11772:	d006      	beq.n	11782 <xTaskResumeAll+0x14a>
							{
								xYieldPending = pdTRUE;
   11774:	f243 03e0 	movw	r3, #12512	; 0x30e0
   11778:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1177c:	f04f 0201 	mov.w	r2, #1
   11780:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
   11782:	68bb      	ldr	r3, [r7, #8]
   11784:	f103 33ff 	add.w	r3, r3, #4294967295
   11788:	60bb      	str	r3, [r7, #8]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
   1178a:	68bb      	ldr	r3, [r7, #8]
   1178c:	2b00      	cmp	r3, #0
   1178e:	d1ec      	bne.n	1176a <xTaskResumeAll+0x132>

						uxPendedTicks = 0;
   11790:	f243 03dc 	movw	r3, #12508	; 0x30dc
   11794:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11798:	f04f 0200 	mov.w	r2, #0
   1179c:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
   1179e:	f243 03e0 	movw	r3, #12512	; 0x30e0
   117a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   117a6:	681b      	ldr	r3, [r3, #0]
   117a8:	2b00      	cmp	r3, #0
   117aa:	d00d      	beq.n	117c8 <xTaskResumeAll+0x190>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
   117ac:	f04f 0301 	mov.w	r3, #1
   117b0:	607b      	str	r3, [r7, #4]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
   117b2:	f64e 5304 	movw	r3, #60676	; 0xed04
   117b6:	f2ce 0300 	movt	r3, #57344	; 0xe000
   117ba:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   117be:	601a      	str	r2, [r3, #0]
   117c0:	f3bf 8f4f 	dsb	sy
   117c4:	f3bf 8f6f 	isb	sy
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
   117c8:	f002 fe3e 	bl	14448 <vPortExitCritical>

	return xAlreadyYielded;
   117cc:	687b      	ldr	r3, [r7, #4]
}
   117ce:	4618      	mov	r0, r3
   117d0:	f107 0710 	add.w	r7, r7, #16
   117d4:	46bd      	mov	sp, r7
   117d6:	bd80      	pop	{r7, pc}

000117d8 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
   117d8:	b480      	push	{r7}
   117da:	b083      	sub	sp, #12
   117dc:	af00      	add	r7, sp, #0
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
   117de:	f243 03d0 	movw	r3, #12496	; 0x30d0
   117e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   117e6:	681b      	ldr	r3, [r3, #0]
   117e8:	607b      	str	r3, [r7, #4]
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
   117ea:	687b      	ldr	r3, [r7, #4]
}
   117ec:	4618      	mov	r0, r3
   117ee:	f107 070c 	add.w	r7, r7, #12
   117f2:	46bd      	mov	sp, r7
   117f4:	bc80      	pop	{r7}
   117f6:	4770      	bx	lr

000117f8 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
   117f8:	b580      	push	{r7, lr}
   117fa:	b082      	sub	sp, #8
   117fc:	af00      	add	r7, sp, #0
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   117fe:	f002 fecf 	bl	145a0 <vPortValidateInterruptPriority>

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
   11802:	f04f 0300 	mov.w	r3, #0
   11806:	607b      	str	r3, [r7, #4]
	{
		xReturn = xTickCount;
   11808:	f243 03d0 	movw	r3, #12496	; 0x30d0
   1180c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11810:	681b      	ldr	r3, [r3, #0]
   11812:	603b      	str	r3, [r7, #0]
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
   11814:	683b      	ldr	r3, [r7, #0]
}
   11816:	4618      	mov	r0, r3
   11818:	f107 0708 	add.w	r7, r7, #8
   1181c:	46bd      	mov	sp, r7
   1181e:	bd80      	pop	{r7, pc}

00011820 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
   11820:	b480      	push	{r7}
   11822:	af00      	add	r7, sp, #0
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
   11824:	f243 03cc 	movw	r3, #12492	; 0x30cc
   11828:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1182c:	681b      	ldr	r3, [r3, #0]
}
   1182e:	4618      	mov	r0, r3
   11830:	46bd      	mov	sp, r7
   11832:	bc80      	pop	{r7}
   11834:	4770      	bx	lr
   11836:	bf00      	nop

00011838 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
   11838:	b480      	push	{r7}
   1183a:	b085      	sub	sp, #20
   1183c:	af00      	add	r7, sp, #0
   1183e:	6078      	str	r0, [r7, #4]
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
   11840:	687b      	ldr	r3, [r7, #4]
   11842:	2b00      	cmp	r3, #0
   11844:	d105      	bne.n	11852 <pcTaskGetName+0x1a>
   11846:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   1184a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1184e:	681b      	ldr	r3, [r3, #0]
   11850:	e000      	b.n	11854 <pcTaskGetName+0x1c>
   11852:	687b      	ldr	r3, [r7, #4]
   11854:	60bb      	str	r3, [r7, #8]
	configASSERT( pxTCB );
   11856:	68bb      	ldr	r3, [r7, #8]
   11858:	2b00      	cmp	r3, #0
   1185a:	d109      	bne.n	11870 <pcTaskGetName+0x38>
   1185c:	f04f 0328 	mov.w	r3, #40	; 0x28
   11860:	f383 8811 	msr	BASEPRI, r3
   11864:	f3bf 8f6f 	isb	sy
   11868:	f3bf 8f4f 	dsb	sy
   1186c:	60fb      	str	r3, [r7, #12]
   1186e:	e7fe      	b.n	1186e <pcTaskGetName+0x36>
	return &( pxTCB->pcTaskName[ 0 ] );
   11870:	68bb      	ldr	r3, [r7, #8]
   11872:	f103 0334 	add.w	r3, r3, #52	; 0x34
}
   11876:	4618      	mov	r0, r3
   11878:	f107 0714 	add.w	r7, r7, #20
   1187c:	46bd      	mov	sp, r7
   1187e:	bc80      	pop	{r7}
   11880:	4770      	bx	lr
   11882:	bf00      	nop

00011884 <uxTaskGetSystemState>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
	{
   11884:	b580      	push	{r7, lr}
   11886:	b086      	sub	sp, #24
   11888:	af00      	add	r7, sp, #0
   1188a:	60f8      	str	r0, [r7, #12]
   1188c:	60b9      	str	r1, [r7, #8]
   1188e:	607a      	str	r2, [r7, #4]
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
   11890:	f04f 0300 	mov.w	r3, #0
   11894:	613b      	str	r3, [r7, #16]
   11896:	f04f 0305 	mov.w	r3, #5
   1189a:	617b      	str	r3, [r7, #20]

		vTaskSuspendAll();
   1189c:	f7ff feba 	bl	11614 <vTaskSuspendAll>
		{
			/* Is there a space in the array for each task in the system? */
			if( uxArraySize >= uxCurrentNumberOfTasks )
   118a0:	f243 03cc 	movw	r3, #12492	; 0x30cc
   118a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   118a8:	681b      	ldr	r3, [r3, #0]
   118aa:	68ba      	ldr	r2, [r7, #8]
   118ac:	429a      	cmp	r2, r3
   118ae:	f0c0 8091 	bcc.w	119d4 <uxTaskGetSystemState+0x150>
			{
				/* Fill in an TaskStatus_t structure with information on each
				task in the Ready state. */
				do
				{
					uxQueue--;
   118b2:	697b      	ldr	r3, [r7, #20]
   118b4:	f103 33ff 	add.w	r3, r3, #4294967295
   118b8:	617b      	str	r3, [r7, #20]
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
   118ba:	693a      	ldr	r2, [r7, #16]
   118bc:	4613      	mov	r3, r2
   118be:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   118c2:	4413      	add	r3, r2
   118c4:	ea4f 0383 	mov.w	r3, r3, lsl #2
   118c8:	461a      	mov	r2, r3
   118ca:	68fb      	ldr	r3, [r7, #12]
   118cc:	eb02 0103 	add.w	r1, r2, r3
   118d0:	697a      	ldr	r2, [r7, #20]
   118d2:	4613      	mov	r3, r2
   118d4:	ea4f 0383 	mov.w	r3, r3, lsl #2
   118d8:	4413      	add	r3, r2
   118da:	ea4f 0383 	mov.w	r3, r3, lsl #2
   118de:	461a      	mov	r2, r3
   118e0:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   118e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   118e8:	4413      	add	r3, r2
   118ea:	4608      	mov	r0, r1
   118ec:	4619      	mov	r1, r3
   118ee:	f04f 0201 	mov.w	r2, #1
   118f2:	f000 fdc3 	bl	1247c <prvListTasksWithinSingleList>
   118f6:	4603      	mov	r3, r0
   118f8:	693a      	ldr	r2, [r7, #16]
   118fa:	4413      	add	r3, r2
   118fc:	613b      	str	r3, [r7, #16]

				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   118fe:	697b      	ldr	r3, [r7, #20]
   11900:	2b00      	cmp	r3, #0
   11902:	d1d6      	bne.n	118b2 <uxTaskGetSystemState+0x2e>

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
   11904:	693a      	ldr	r2, [r7, #16]
   11906:	4613      	mov	r3, r2
   11908:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   1190c:	4413      	add	r3, r2
   1190e:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11912:	461a      	mov	r2, r3
   11914:	68fb      	ldr	r3, [r7, #12]
   11916:	441a      	add	r2, r3
   11918:	f243 0384 	movw	r3, #12420	; 0x3084
   1191c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11920:	681b      	ldr	r3, [r3, #0]
   11922:	4610      	mov	r0, r2
   11924:	4619      	mov	r1, r3
   11926:	f04f 0202 	mov.w	r2, #2
   1192a:	f000 fda7 	bl	1247c <prvListTasksWithinSingleList>
   1192e:	4603      	mov	r3, r0
   11930:	693a      	ldr	r2, [r7, #16]
   11932:	4413      	add	r3, r2
   11934:	613b      	str	r3, [r7, #16]
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
   11936:	693a      	ldr	r2, [r7, #16]
   11938:	4613      	mov	r3, r2
   1193a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   1193e:	4413      	add	r3, r2
   11940:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11944:	461a      	mov	r2, r3
   11946:	68fb      	ldr	r3, [r7, #12]
   11948:	441a      	add	r2, r3
   1194a:	f243 0388 	movw	r3, #12424	; 0x3088
   1194e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11952:	681b      	ldr	r3, [r3, #0]
   11954:	4610      	mov	r0, r2
   11956:	4619      	mov	r1, r3
   11958:	f04f 0202 	mov.w	r2, #2
   1195c:	f000 fd8e 	bl	1247c <prvListTasksWithinSingleList>
   11960:	4603      	mov	r3, r0
   11962:	693a      	ldr	r2, [r7, #16]
   11964:	4413      	add	r3, r2
   11966:	613b      	str	r3, [r7, #16]

				#if( INCLUDE_vTaskDelete == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task that has been deleted but not yet cleaned up. */
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
   11968:	693a      	ldr	r2, [r7, #16]
   1196a:	4613      	mov	r3, r2
   1196c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   11970:	4413      	add	r3, r2
   11972:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11976:	461a      	mov	r2, r3
   11978:	68fb      	ldr	r3, [r7, #12]
   1197a:	4413      	add	r3, r2
   1197c:	4618      	mov	r0, r3
   1197e:	f243 01a0 	movw	r1, #12448	; 0x30a0
   11982:	f2c2 0100 	movt	r1, #8192	; 0x2000
   11986:	f04f 0204 	mov.w	r2, #4
   1198a:	f000 fd77 	bl	1247c <prvListTasksWithinSingleList>
   1198e:	4603      	mov	r3, r0
   11990:	693a      	ldr	r2, [r7, #16]
   11992:	4413      	add	r3, r2
   11994:	613b      	str	r3, [r7, #16]

				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task in the Suspended state. */
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
   11996:	693a      	ldr	r2, [r7, #16]
   11998:	4613      	mov	r3, r2
   1199a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   1199e:	4413      	add	r3, r2
   119a0:	ea4f 0383 	mov.w	r3, r3, lsl #2
   119a4:	461a      	mov	r2, r3
   119a6:	68fb      	ldr	r3, [r7, #12]
   119a8:	4413      	add	r3, r2
   119aa:	4618      	mov	r0, r3
   119ac:	f243 01b8 	movw	r1, #12472	; 0x30b8
   119b0:	f2c2 0100 	movt	r1, #8192	; 0x2000
   119b4:	f04f 0203 	mov.w	r2, #3
   119b8:	f000 fd60 	bl	1247c <prvListTasksWithinSingleList>
   119bc:	4603      	mov	r3, r0
   119be:	693a      	ldr	r2, [r7, #16]
   119c0:	4413      	add	r3, r2
   119c2:	613b      	str	r3, [r7, #16]
				}
				#endif

				#if ( configGENERATE_RUN_TIME_STATS == 1)
				{
					if( pulTotalRunTime != NULL )
   119c4:	687b      	ldr	r3, [r7, #4]
   119c6:	2b00      	cmp	r3, #0
   119c8:	d004      	beq.n	119d4 <uxTaskGetSystemState+0x150>
					{
						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
						#else
							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   119ca:	f7ef f923 	bl	c14 <ulGetRunTimeCounterValue>
   119ce:	4602      	mov	r2, r0
   119d0:	687b      	ldr	r3, [r7, #4]
   119d2:	601a      	str	r2, [r3, #0]
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		( void ) xTaskResumeAll();
   119d4:	f7ff fe30 	bl	11638 <xTaskResumeAll>

		return uxTask;
   119d8:	693b      	ldr	r3, [r7, #16]
	}
   119da:	4618      	mov	r0, r3
   119dc:	f107 0718 	add.w	r7, r7, #24
   119e0:	46bd      	mov	sp, r7
   119e2:	bd80      	pop	{r7, pc}

000119e4 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
   119e4:	b580      	push	{r7, lr}
   119e6:	b086      	sub	sp, #24
   119e8:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
   119ea:	f04f 0300 	mov.w	r3, #0
   119ee:	60bb      	str	r3, [r7, #8]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   119f0:	f243 03f4 	movw	r3, #12532	; 0x30f4
   119f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   119f8:	681b      	ldr	r3, [r3, #0]
   119fa:	2b00      	cmp	r3, #0
   119fc:	f040 80d5 	bne.w	11baa <xTaskIncrementTick+0x1c6>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
   11a00:	f243 03d0 	movw	r3, #12496	; 0x30d0
   11a04:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11a08:	681b      	ldr	r3, [r3, #0]
   11a0a:	f103 0301 	add.w	r3, r3, #1
   11a0e:	60fb      	str	r3, [r7, #12]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
   11a10:	f243 03d0 	movw	r3, #12496	; 0x30d0
   11a14:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11a18:	68fa      	ldr	r2, [r7, #12]
   11a1a:	601a      	str	r2, [r3, #0]

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
   11a1c:	68fb      	ldr	r3, [r7, #12]
   11a1e:	2b00      	cmp	r3, #0
   11a20:	d135      	bne.n	11a8e <xTaskIncrementTick+0xaa>
		{
			taskSWITCH_DELAYED_LISTS();
   11a22:	f243 0384 	movw	r3, #12420	; 0x3084
   11a26:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11a2a:	681b      	ldr	r3, [r3, #0]
   11a2c:	681b      	ldr	r3, [r3, #0]
   11a2e:	2b00      	cmp	r3, #0
   11a30:	d009      	beq.n	11a46 <xTaskIncrementTick+0x62>
   11a32:	f04f 0328 	mov.w	r3, #40	; 0x28
   11a36:	f383 8811 	msr	BASEPRI, r3
   11a3a:	f3bf 8f6f 	isb	sy
   11a3e:	f3bf 8f4f 	dsb	sy
   11a42:	617b      	str	r3, [r7, #20]
   11a44:	e7fe      	b.n	11a44 <xTaskIncrementTick+0x60>
   11a46:	f243 0384 	movw	r3, #12420	; 0x3084
   11a4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11a4e:	681b      	ldr	r3, [r3, #0]
   11a50:	613b      	str	r3, [r7, #16]
   11a52:	f243 0388 	movw	r3, #12424	; 0x3088
   11a56:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11a5a:	681a      	ldr	r2, [r3, #0]
   11a5c:	f243 0384 	movw	r3, #12420	; 0x3084
   11a60:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11a64:	601a      	str	r2, [r3, #0]
   11a66:	f243 0388 	movw	r3, #12424	; 0x3088
   11a6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11a6e:	693a      	ldr	r2, [r7, #16]
   11a70:	601a      	str	r2, [r3, #0]
   11a72:	f243 03e4 	movw	r3, #12516	; 0x30e4
   11a76:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11a7a:	681b      	ldr	r3, [r3, #0]
   11a7c:	f103 0201 	add.w	r2, r3, #1
   11a80:	f243 03e4 	movw	r3, #12516	; 0x30e4
   11a84:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11a88:	601a      	str	r2, [r3, #0]
   11a8a:	f000 fd83 	bl	12594 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
   11a8e:	f243 03ec 	movw	r3, #12524	; 0x30ec
   11a92:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11a96:	681b      	ldr	r3, [r3, #0]
   11a98:	68fa      	ldr	r2, [r7, #12]
   11a9a:	429a      	cmp	r2, r3
   11a9c:	d36c      	bcc.n	11b78 <xTaskIncrementTick+0x194>
   11a9e:	e000      	b.n	11aa2 <xTaskIncrementTick+0xbe>
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
   11aa0:	bf00      	nop
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   11aa2:	f243 0384 	movw	r3, #12420	; 0x3084
   11aa6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11aaa:	681b      	ldr	r3, [r3, #0]
   11aac:	681b      	ldr	r3, [r3, #0]
   11aae:	2b00      	cmp	r3, #0
   11ab0:	d107      	bne.n	11ac2 <xTaskIncrementTick+0xde>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   11ab2:	f243 03ec 	movw	r3, #12524	; 0x30ec
   11ab6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11aba:	f04f 32ff 	mov.w	r2, #4294967295
   11abe:	601a      	str	r2, [r3, #0]
					break;
   11ac0:	e05a      	b.n	11b78 <xTaskIncrementTick+0x194>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   11ac2:	f243 0384 	movw	r3, #12420	; 0x3084
   11ac6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11aca:	681b      	ldr	r3, [r3, #0]
   11acc:	68db      	ldr	r3, [r3, #12]
   11ace:	68db      	ldr	r3, [r3, #12]
   11ad0:	603b      	str	r3, [r7, #0]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
   11ad2:	683b      	ldr	r3, [r7, #0]
   11ad4:	685b      	ldr	r3, [r3, #4]
   11ad6:	607b      	str	r3, [r7, #4]

					if( xConstTickCount < xItemValue )
   11ad8:	68fa      	ldr	r2, [r7, #12]
   11ada:	687b      	ldr	r3, [r7, #4]
   11adc:	429a      	cmp	r2, r3
   11ade:	d206      	bcs.n	11aee <xTaskIncrementTick+0x10a>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
   11ae0:	f243 03ec 	movw	r3, #12524	; 0x30ec
   11ae4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11ae8:	687a      	ldr	r2, [r7, #4]
   11aea:	601a      	str	r2, [r3, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
   11aec:	e044      	b.n	11b78 <xTaskIncrementTick+0x194>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   11aee:	683b      	ldr	r3, [r7, #0]
   11af0:	f103 0304 	add.w	r3, r3, #4
   11af4:	4618      	mov	r0, r3
   11af6:	f7fd fc2f 	bl	f358 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   11afa:	683b      	ldr	r3, [r7, #0]
   11afc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   11afe:	2b00      	cmp	r3, #0
   11b00:	d005      	beq.n	11b0e <xTaskIncrementTick+0x12a>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   11b02:	683b      	ldr	r3, [r7, #0]
   11b04:	f103 0318 	add.w	r3, r3, #24
   11b08:	4618      	mov	r0, r3
   11b0a:	f7fd fc25 	bl	f358 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
   11b0e:	683b      	ldr	r3, [r7, #0]
   11b10:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11b12:	f04f 0201 	mov.w	r2, #1
   11b16:	fa02 f203 	lsl.w	r2, r2, r3
   11b1a:	f243 03d4 	movw	r3, #12500	; 0x30d4
   11b1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11b22:	681b      	ldr	r3, [r3, #0]
   11b24:	ea42 0203 	orr.w	r2, r2, r3
   11b28:	f243 03d4 	movw	r3, #12500	; 0x30d4
   11b2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11b30:	601a      	str	r2, [r3, #0]
   11b32:	683b      	ldr	r3, [r7, #0]
   11b34:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11b36:	4613      	mov	r3, r2
   11b38:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11b3c:	4413      	add	r3, r2
   11b3e:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11b42:	461a      	mov	r2, r3
   11b44:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   11b48:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11b4c:	441a      	add	r2, r3
   11b4e:	683b      	ldr	r3, [r7, #0]
   11b50:	f103 0304 	add.w	r3, r3, #4
   11b54:	4610      	mov	r0, r2
   11b56:	4619      	mov	r1, r3
   11b58:	f7fd fba0 	bl	f29c <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   11b5c:	683b      	ldr	r3, [r7, #0]
   11b5e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11b60:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   11b64:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11b68:	681b      	ldr	r3, [r3, #0]
   11b6a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11b6c:	429a      	cmp	r2, r3
   11b6e:	d397      	bcc.n	11aa0 <xTaskIncrementTick+0xbc>
						{
							xSwitchRequired = pdTRUE;
   11b70:	f04f 0301 	mov.w	r3, #1
   11b74:	60bb      	str	r3, [r7, #8]
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
   11b76:	e794      	b.n	11aa2 <xTaskIncrementTick+0xbe>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   11b78:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   11b7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11b80:	681b      	ldr	r3, [r3, #0]
   11b82:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11b84:	4613      	mov	r3, r2
   11b86:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11b8a:	4413      	add	r3, r2
   11b8c:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11b90:	461a      	mov	r2, r3
   11b92:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   11b96:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11b9a:	4413      	add	r3, r2
   11b9c:	681b      	ldr	r3, [r3, #0]
   11b9e:	2b01      	cmp	r3, #1
   11ba0:	d910      	bls.n	11bc4 <xTaskIncrementTick+0x1e0>
			{
				xSwitchRequired = pdTRUE;
   11ba2:	f04f 0301 	mov.w	r3, #1
   11ba6:	60bb      	str	r3, [r7, #8]
   11ba8:	e00d      	b.n	11bc6 <xTaskIncrementTick+0x1e2>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
   11baa:	f243 03dc 	movw	r3, #12508	; 0x30dc
   11bae:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11bb2:	681b      	ldr	r3, [r3, #0]
   11bb4:	f103 0201 	add.w	r2, r3, #1
   11bb8:	f243 03dc 	movw	r3, #12508	; 0x30dc
   11bbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11bc0:	601a      	str	r2, [r3, #0]
   11bc2:	e000      	b.n	11bc6 <xTaskIncrementTick+0x1e2>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
   11bc4:	bf00      	nop
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
   11bc6:	f243 03e0 	movw	r3, #12512	; 0x30e0
   11bca:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11bce:	681b      	ldr	r3, [r3, #0]
   11bd0:	2b00      	cmp	r3, #0
   11bd2:	d002      	beq.n	11bda <xTaskIncrementTick+0x1f6>
		{
			xSwitchRequired = pdTRUE;
   11bd4:	f04f 0301 	mov.w	r3, #1
   11bd8:	60bb      	str	r3, [r7, #8]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
   11bda:	68bb      	ldr	r3, [r7, #8]
}
   11bdc:	4618      	mov	r0, r3
   11bde:	f107 0718 	add.w	r7, r7, #24
   11be2:	46bd      	mov	sp, r7
   11be4:	bd80      	pop	{r7, pc}
   11be6:	bf00      	nop

00011be8 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
   11be8:	b580      	push	{r7, lr}
   11bea:	b088      	sub	sp, #32
   11bec:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   11bee:	f243 03f4 	movw	r3, #12532	; 0x30f4
   11bf2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11bf6:	681b      	ldr	r3, [r3, #0]
   11bf8:	2b00      	cmp	r3, #0
   11bfa:	d007      	beq.n	11c0c <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
   11bfc:	f243 03e0 	movw	r3, #12512	; 0x30e0
   11c00:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11c04:	f04f 0201 	mov.w	r2, #1
   11c08:	601a      	str	r2, [r3, #0]
   11c0a:	e0bc      	b.n	11d86 <vTaskSwitchContext+0x19e>
	}
	else
	{
		xYieldPending = pdFALSE;
   11c0c:	f243 03e0 	movw	r3, #12512	; 0x30e0
   11c10:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11c14:	f04f 0200 	mov.w	r2, #0
   11c18:	601a      	str	r2, [r3, #0]
		#if ( configGENERATE_RUN_TIME_STATS == 1 )
		{
				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
				#else
					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   11c1a:	f7ee fffb 	bl	c14 <ulGetRunTimeCounterValue>
   11c1e:	4602      	mov	r2, r0
   11c20:	f243 03fc 	movw	r3, #12540	; 0x30fc
   11c24:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11c28:	601a      	str	r2, [r3, #0]
				stored in ulTaskSwitchedInTime.  Note that there is no overflow
				protection here so count values are only valid until the timer
				overflows.  The guard against negative values is to protect
				against suspect run time stat counter implementations - which
				are provided by the application, not the kernel. */
				if( ulTotalRunTime > ulTaskSwitchedInTime )
   11c2a:	f243 03fc 	movw	r3, #12540	; 0x30fc
   11c2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11c32:	681a      	ldr	r2, [r3, #0]
   11c34:	f243 03f8 	movw	r3, #12536	; 0x30f8
   11c38:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11c3c:	681b      	ldr	r3, [r3, #0]
   11c3e:	429a      	cmp	r2, r3
   11c40:	d913      	bls.n	11c6a <vTaskSwitchContext+0x82>
				{
					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
   11c42:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   11c46:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11c4a:	681a      	ldr	r2, [r3, #0]
   11c4c:	6d11      	ldr	r1, [r2, #80]	; 0x50
   11c4e:	f243 03fc 	movw	r3, #12540	; 0x30fc
   11c52:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11c56:	6818      	ldr	r0, [r3, #0]
   11c58:	f243 03f8 	movw	r3, #12536	; 0x30f8
   11c5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11c60:	681b      	ldr	r3, [r3, #0]
   11c62:	ebc3 0300 	rsb	r3, r3, r0
   11c66:	440b      	add	r3, r1
   11c68:	6513      	str	r3, [r2, #80]	; 0x50
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				ulTaskSwitchedInTime = ulTotalRunTime;
   11c6a:	f243 03fc 	movw	r3, #12540	; 0x30fc
   11c6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11c72:	681a      	ldr	r2, [r3, #0]
   11c74:	f243 03f8 	movw	r3, #12536	; 0x30f8
   11c78:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11c7c:	601a      	str	r2, [r3, #0]
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();
   11c7e:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   11c82:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11c86:	681b      	ldr	r3, [r3, #0]
   11c88:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   11c8a:	607b      	str	r3, [r7, #4]
   11c8c:	f04f 33a5 	mov.w	r3, #2779096485	; 0xa5a5a5a5
   11c90:	60bb      	str	r3, [r7, #8]
   11c92:	687b      	ldr	r3, [r7, #4]
   11c94:	681a      	ldr	r2, [r3, #0]
   11c96:	68bb      	ldr	r3, [r7, #8]
   11c98:	429a      	cmp	r2, r3
   11c9a:	d114      	bne.n	11cc6 <vTaskSwitchContext+0xde>
   11c9c:	687b      	ldr	r3, [r7, #4]
   11c9e:	f103 0304 	add.w	r3, r3, #4
   11ca2:	681a      	ldr	r2, [r3, #0]
   11ca4:	68bb      	ldr	r3, [r7, #8]
   11ca6:	429a      	cmp	r2, r3
   11ca8:	d10d      	bne.n	11cc6 <vTaskSwitchContext+0xde>
   11caa:	687b      	ldr	r3, [r7, #4]
   11cac:	f103 0308 	add.w	r3, r3, #8
   11cb0:	681a      	ldr	r2, [r3, #0]
   11cb2:	68bb      	ldr	r3, [r7, #8]
   11cb4:	429a      	cmp	r2, r3
   11cb6:	d106      	bne.n	11cc6 <vTaskSwitchContext+0xde>
   11cb8:	687b      	ldr	r3, [r7, #4]
   11cba:	f103 030c 	add.w	r3, r3, #12
   11cbe:	681a      	ldr	r2, [r3, #0]
   11cc0:	68bb      	ldr	r3, [r7, #8]
   11cc2:	429a      	cmp	r2, r3
   11cc4:	d00f      	beq.n	11ce6 <vTaskSwitchContext+0xfe>
   11cc6:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   11cca:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11cce:	681a      	ldr	r2, [r3, #0]
   11cd0:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   11cd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11cd8:	681b      	ldr	r3, [r3, #0]
   11cda:	f103 0334 	add.w	r3, r3, #52	; 0x34
   11cde:	4610      	mov	r0, r2
   11ce0:	4619      	mov	r1, r3
   11ce2:	f7ee ff4f 	bl	b84 <vApplicationStackOverflowHook>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   11ce6:	f243 03d4 	movw	r3, #12500	; 0x30d4
   11cea:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11cee:	681b      	ldr	r3, [r3, #0]
   11cf0:	617b      	str	r3, [r7, #20]
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
	{
	uint8_t ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
   11cf2:	697b      	ldr	r3, [r7, #20]
   11cf4:	fab3 f383 	clz	r3, r3
   11cf8:	76fb      	strb	r3, [r7, #27]
		return ucReturn;
   11cfa:	7efb      	ldrb	r3, [r7, #27]
   11cfc:	f1c3 031f 	rsb	r3, r3, #31
   11d00:	60fb      	str	r3, [r7, #12]
   11d02:	68fa      	ldr	r2, [r7, #12]
   11d04:	4613      	mov	r3, r2
   11d06:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11d0a:	4413      	add	r3, r2
   11d0c:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11d10:	461a      	mov	r2, r3
   11d12:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   11d16:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11d1a:	4413      	add	r3, r2
   11d1c:	681b      	ldr	r3, [r3, #0]
   11d1e:	2b00      	cmp	r3, #0
   11d20:	d109      	bne.n	11d36 <vTaskSwitchContext+0x14e>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   11d22:	f04f 0328 	mov.w	r3, #40	; 0x28
   11d26:	f383 8811 	msr	BASEPRI, r3
   11d2a:	f3bf 8f6f 	isb	sy
   11d2e:	f3bf 8f4f 	dsb	sy
   11d32:	61fb      	str	r3, [r7, #28]
   11d34:	e7fe      	b.n	11d34 <vTaskSwitchContext+0x14c>
   11d36:	68fa      	ldr	r2, [r7, #12]
   11d38:	4613      	mov	r3, r2
   11d3a:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11d3e:	4413      	add	r3, r2
   11d40:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11d44:	461a      	mov	r2, r3
   11d46:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   11d4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11d4e:	4413      	add	r3, r2
   11d50:	613b      	str	r3, [r7, #16]
   11d52:	693b      	ldr	r3, [r7, #16]
   11d54:	685b      	ldr	r3, [r3, #4]
   11d56:	685a      	ldr	r2, [r3, #4]
   11d58:	693b      	ldr	r3, [r7, #16]
   11d5a:	605a      	str	r2, [r3, #4]
   11d5c:	693b      	ldr	r3, [r7, #16]
   11d5e:	685a      	ldr	r2, [r3, #4]
   11d60:	693b      	ldr	r3, [r7, #16]
   11d62:	f103 0308 	add.w	r3, r3, #8
   11d66:	429a      	cmp	r2, r3
   11d68:	d104      	bne.n	11d74 <vTaskSwitchContext+0x18c>
   11d6a:	693b      	ldr	r3, [r7, #16]
   11d6c:	685b      	ldr	r3, [r3, #4]
   11d6e:	685a      	ldr	r2, [r3, #4]
   11d70:	693b      	ldr	r3, [r7, #16]
   11d72:	605a      	str	r2, [r3, #4]
   11d74:	693b      	ldr	r3, [r7, #16]
   11d76:	685b      	ldr	r3, [r3, #4]
   11d78:	68db      	ldr	r3, [r3, #12]
   11d7a:	461a      	mov	r2, r3
   11d7c:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   11d80:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11d84:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
   11d86:	f107 0720 	add.w	r7, r7, #32
   11d8a:	46bd      	mov	sp, r7
   11d8c:	bd80      	pop	{r7, pc}
   11d8e:	bf00      	nop

00011d90 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
   11d90:	b580      	push	{r7, lr}
   11d92:	b084      	sub	sp, #16
   11d94:	af00      	add	r7, sp, #0
   11d96:	6078      	str	r0, [r7, #4]
   11d98:	6039      	str	r1, [r7, #0]
	configASSERT( pxEventList );
   11d9a:	687b      	ldr	r3, [r7, #4]
   11d9c:	2b00      	cmp	r3, #0
   11d9e:	d109      	bne.n	11db4 <vTaskPlaceOnEventList+0x24>
   11da0:	f04f 0328 	mov.w	r3, #40	; 0x28
   11da4:	f383 8811 	msr	BASEPRI, r3
   11da8:	f3bf 8f6f 	isb	sy
   11dac:	f3bf 8f4f 	dsb	sy
   11db0:	60fb      	str	r3, [r7, #12]
   11db2:	e7fe      	b.n	11db2 <vTaskPlaceOnEventList+0x22>

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   11db4:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   11db8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11dbc:	681b      	ldr	r3, [r3, #0]
   11dbe:	f103 0318 	add.w	r3, r3, #24
   11dc2:	6878      	ldr	r0, [r7, #4]
   11dc4:	4619      	mov	r1, r3
   11dc6:	f7fd fa8d 	bl	f2e4 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   11dca:	6838      	ldr	r0, [r7, #0]
   11dcc:	f04f 0101 	mov.w	r1, #1
   11dd0:	f001 fb6a 	bl	134a8 <prvAddCurrentTaskToDelayedList>
}
   11dd4:	f107 0710 	add.w	r7, r7, #16
   11dd8:	46bd      	mov	sp, r7
   11dda:	bd80      	pop	{r7, pc}

00011ddc <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
   11ddc:	b580      	push	{r7, lr}
   11dde:	b086      	sub	sp, #24
   11de0:	af00      	add	r7, sp, #0
   11de2:	60f8      	str	r0, [r7, #12]
   11de4:	60b9      	str	r1, [r7, #8]
   11de6:	607a      	str	r2, [r7, #4]
	configASSERT( pxEventList );
   11de8:	68fb      	ldr	r3, [r7, #12]
   11dea:	2b00      	cmp	r3, #0
   11dec:	d109      	bne.n	11e02 <vTaskPlaceOnUnorderedEventList+0x26>
   11dee:	f04f 0328 	mov.w	r3, #40	; 0x28
   11df2:	f383 8811 	msr	BASEPRI, r3
   11df6:	f3bf 8f6f 	isb	sy
   11dfa:	f3bf 8f4f 	dsb	sy
   11dfe:	613b      	str	r3, [r7, #16]
   11e00:	e7fe      	b.n	11e00 <vTaskPlaceOnUnorderedEventList+0x24>

	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event groups implementation. */
	configASSERT( uxSchedulerSuspended != 0 );
   11e02:	f243 03f4 	movw	r3, #12532	; 0x30f4
   11e06:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11e0a:	681b      	ldr	r3, [r3, #0]
   11e0c:	2b00      	cmp	r3, #0
   11e0e:	d109      	bne.n	11e24 <vTaskPlaceOnUnorderedEventList+0x48>
   11e10:	f04f 0328 	mov.w	r3, #40	; 0x28
   11e14:	f383 8811 	msr	BASEPRI, r3
   11e18:	f3bf 8f6f 	isb	sy
   11e1c:	f3bf 8f4f 	dsb	sy
   11e20:	617b      	str	r3, [r7, #20]
   11e22:	e7fe      	b.n	11e22 <vTaskPlaceOnUnorderedEventList+0x46>

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   11e24:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   11e28:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11e2c:	681b      	ldr	r3, [r3, #0]
   11e2e:	68ba      	ldr	r2, [r7, #8]
   11e30:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
   11e34:	619a      	str	r2, [r3, #24]
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   11e36:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   11e3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11e3e:	681b      	ldr	r3, [r3, #0]
   11e40:	f103 0318 	add.w	r3, r3, #24
   11e44:	68f8      	ldr	r0, [r7, #12]
   11e46:	4619      	mov	r1, r3
   11e48:	f7fd fa28 	bl	f29c <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   11e4c:	6878      	ldr	r0, [r7, #4]
   11e4e:	f04f 0101 	mov.w	r1, #1
   11e52:	f001 fb29 	bl	134a8 <prvAddCurrentTaskToDelayedList>
}
   11e56:	f107 0718 	add.w	r7, r7, #24
   11e5a:	46bd      	mov	sp, r7
   11e5c:	bd80      	pop	{r7, pc}
   11e5e:	bf00      	nop

00011e60 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if( configUSE_TIMERS == 1 )

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
   11e60:	b580      	push	{r7, lr}
   11e62:	b086      	sub	sp, #24
   11e64:	af00      	add	r7, sp, #0
   11e66:	60f8      	str	r0, [r7, #12]
   11e68:	60b9      	str	r1, [r7, #8]
   11e6a:	607a      	str	r2, [r7, #4]
		configASSERT( pxEventList );
   11e6c:	68fb      	ldr	r3, [r7, #12]
   11e6e:	2b00      	cmp	r3, #0
   11e70:	d109      	bne.n	11e86 <vTaskPlaceOnEventListRestricted+0x26>
   11e72:	f04f 0328 	mov.w	r3, #40	; 0x28
   11e76:	f383 8811 	msr	BASEPRI, r3
   11e7a:	f3bf 8f6f 	isb	sy
   11e7e:	f3bf 8f4f 	dsb	sy
   11e82:	617b      	str	r3, [r7, #20]
   11e84:	e7fe      	b.n	11e84 <vTaskPlaceOnEventListRestricted+0x24>

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   11e86:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   11e8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11e8e:	681b      	ldr	r3, [r3, #0]
   11e90:	f103 0318 	add.w	r3, r3, #24
   11e94:	68f8      	ldr	r0, [r7, #12]
   11e96:	4619      	mov	r1, r3
   11e98:	f7fd fa00 	bl	f29c <vListInsertEnd>

		/* If the task should block indefinitely then set the block time to a
		value that will be recognised as an indefinite delay inside the
		prvAddCurrentTaskToDelayedList() function. */
		if( xWaitIndefinitely != pdFALSE )
   11e9c:	687b      	ldr	r3, [r7, #4]
   11e9e:	2b00      	cmp	r3, #0
   11ea0:	d002      	beq.n	11ea8 <vTaskPlaceOnEventListRestricted+0x48>
		{
			xTicksToWait = portMAX_DELAY;
   11ea2:	f04f 33ff 	mov.w	r3, #4294967295
   11ea6:	60bb      	str	r3, [r7, #8]
		}

		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
   11ea8:	68b8      	ldr	r0, [r7, #8]
   11eaa:	6879      	ldr	r1, [r7, #4]
   11eac:	f001 fafc 	bl	134a8 <prvAddCurrentTaskToDelayedList>
	}
   11eb0:	f107 0718 	add.w	r7, r7, #24
   11eb4:	46bd      	mov	sp, r7
   11eb6:	bd80      	pop	{r7, pc}

00011eb8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
   11eb8:	b580      	push	{r7, lr}
   11eba:	b086      	sub	sp, #24
   11ebc:	af00      	add	r7, sp, #0
   11ebe:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   11ec0:	687b      	ldr	r3, [r7, #4]
   11ec2:	68db      	ldr	r3, [r3, #12]
   11ec4:	68db      	ldr	r3, [r3, #12]
   11ec6:	60fb      	str	r3, [r7, #12]
	configASSERT( pxUnblockedTCB );
   11ec8:	68fb      	ldr	r3, [r7, #12]
   11eca:	2b00      	cmp	r3, #0
   11ecc:	d109      	bne.n	11ee2 <xTaskRemoveFromEventList+0x2a>
   11ece:	f04f 0328 	mov.w	r3, #40	; 0x28
   11ed2:	f383 8811 	msr	BASEPRI, r3
   11ed6:	f3bf 8f6f 	isb	sy
   11eda:	f3bf 8f4f 	dsb	sy
   11ede:	617b      	str	r3, [r7, #20]
   11ee0:	e7fe      	b.n	11ee0 <xTaskRemoveFromEventList+0x28>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   11ee2:	68fb      	ldr	r3, [r7, #12]
   11ee4:	f103 0318 	add.w	r3, r3, #24
   11ee8:	4618      	mov	r0, r3
   11eea:	f7fd fa35 	bl	f358 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   11eee:	f243 03f4 	movw	r3, #12532	; 0x30f4
   11ef2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11ef6:	681b      	ldr	r3, [r3, #0]
   11ef8:	2b00      	cmp	r3, #0
   11efa:	d12d      	bne.n	11f58 <xTaskRemoveFromEventList+0xa0>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   11efc:	68fb      	ldr	r3, [r7, #12]
   11efe:	f103 0304 	add.w	r3, r3, #4
   11f02:	4618      	mov	r0, r3
   11f04:	f7fd fa28 	bl	f358 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
   11f08:	68fb      	ldr	r3, [r7, #12]
   11f0a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11f0c:	f04f 0201 	mov.w	r2, #1
   11f10:	fa02 f203 	lsl.w	r2, r2, r3
   11f14:	f243 03d4 	movw	r3, #12500	; 0x30d4
   11f18:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11f1c:	681b      	ldr	r3, [r3, #0]
   11f1e:	ea42 0203 	orr.w	r2, r2, r3
   11f22:	f243 03d4 	movw	r3, #12500	; 0x30d4
   11f26:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11f2a:	601a      	str	r2, [r3, #0]
   11f2c:	68fb      	ldr	r3, [r7, #12]
   11f2e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11f30:	4613      	mov	r3, r2
   11f32:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11f36:	4413      	add	r3, r2
   11f38:	ea4f 0383 	mov.w	r3, r3, lsl #2
   11f3c:	461a      	mov	r2, r3
   11f3e:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   11f42:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11f46:	441a      	add	r2, r3
   11f48:	68fb      	ldr	r3, [r7, #12]
   11f4a:	f103 0304 	add.w	r3, r3, #4
   11f4e:	4610      	mov	r0, r2
   11f50:	4619      	mov	r1, r3
   11f52:	f7fd f9a3 	bl	f29c <vListInsertEnd>
   11f56:	e009      	b.n	11f6c <xTaskRemoveFromEventList+0xb4>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   11f58:	68fb      	ldr	r3, [r7, #12]
   11f5a:	f103 0318 	add.w	r3, r3, #24
   11f5e:	f243 008c 	movw	r0, #12428	; 0x308c
   11f62:	f2c2 0000 	movt	r0, #8192	; 0x2000
   11f66:	4619      	mov	r1, r3
   11f68:	f7fd f998 	bl	f29c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   11f6c:	68fb      	ldr	r3, [r7, #12]
   11f6e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11f70:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   11f74:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11f78:	681b      	ldr	r3, [r3, #0]
   11f7a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11f7c:	429a      	cmp	r2, r3
   11f7e:	d90a      	bls.n	11f96 <xTaskRemoveFromEventList+0xde>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
   11f80:	f04f 0301 	mov.w	r3, #1
   11f84:	613b      	str	r3, [r7, #16]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
   11f86:	f243 03e0 	movw	r3, #12512	; 0x30e0
   11f8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11f8e:	f04f 0201 	mov.w	r2, #1
   11f92:	601a      	str	r2, [r3, #0]
   11f94:	e002      	b.n	11f9c <xTaskRemoveFromEventList+0xe4>
	}
	else
	{
		xReturn = pdFALSE;
   11f96:	f04f 0300 	mov.w	r3, #0
   11f9a:	613b      	str	r3, [r7, #16]
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
   11f9c:	693b      	ldr	r3, [r7, #16]
}
   11f9e:	4618      	mov	r0, r3
   11fa0:	f107 0718 	add.w	r7, r7, #24
   11fa4:	46bd      	mov	sp, r7
   11fa6:	bd80      	pop	{r7, pc}

00011fa8 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
   11fa8:	b580      	push	{r7, lr}
   11faa:	b086      	sub	sp, #24
   11fac:	af00      	add	r7, sp, #0
   11fae:	6078      	str	r0, [r7, #4]
   11fb0:	6039      	str	r1, [r7, #0]
TCB_t *pxUnblockedTCB;

	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );
   11fb2:	f243 03f4 	movw	r3, #12532	; 0x30f4
   11fb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   11fba:	681b      	ldr	r3, [r3, #0]
   11fbc:	2b00      	cmp	r3, #0
   11fbe:	d109      	bne.n	11fd4 <vTaskRemoveFromUnorderedEventList+0x2c>
   11fc0:	f04f 0328 	mov.w	r3, #40	; 0x28
   11fc4:	f383 8811 	msr	BASEPRI, r3
   11fc8:	f3bf 8f6f 	isb	sy
   11fcc:	f3bf 8f4f 	dsb	sy
   11fd0:	613b      	str	r3, [r7, #16]
   11fd2:	e7fe      	b.n	11fd2 <vTaskRemoveFromUnorderedEventList+0x2a>

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   11fd4:	683b      	ldr	r3, [r7, #0]
   11fd6:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
   11fda:	687b      	ldr	r3, [r7, #4]
   11fdc:	601a      	str	r2, [r3, #0]

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   11fde:	687b      	ldr	r3, [r7, #4]
   11fe0:	68db      	ldr	r3, [r3, #12]
   11fe2:	60fb      	str	r3, [r7, #12]
	configASSERT( pxUnblockedTCB );
   11fe4:	68fb      	ldr	r3, [r7, #12]
   11fe6:	2b00      	cmp	r3, #0
   11fe8:	d109      	bne.n	11ffe <vTaskRemoveFromUnorderedEventList+0x56>
   11fea:	f04f 0328 	mov.w	r3, #40	; 0x28
   11fee:	f383 8811 	msr	BASEPRI, r3
   11ff2:	f3bf 8f6f 	isb	sy
   11ff6:	f3bf 8f4f 	dsb	sy
   11ffa:	617b      	str	r3, [r7, #20]
   11ffc:	e7fe      	b.n	11ffc <vTaskRemoveFromUnorderedEventList+0x54>
	( void ) uxListRemove( pxEventListItem );
   11ffe:	6878      	ldr	r0, [r7, #4]
   12000:	f7fd f9aa 	bl	f358 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   12004:	68fb      	ldr	r3, [r7, #12]
   12006:	f103 0304 	add.w	r3, r3, #4
   1200a:	4618      	mov	r0, r3
   1200c:	f7fd f9a4 	bl	f358 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
   12010:	68fb      	ldr	r3, [r7, #12]
   12012:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   12014:	f04f 0201 	mov.w	r2, #1
   12018:	fa02 f203 	lsl.w	r2, r2, r3
   1201c:	f243 03d4 	movw	r3, #12500	; 0x30d4
   12020:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12024:	681b      	ldr	r3, [r3, #0]
   12026:	ea42 0203 	orr.w	r2, r2, r3
   1202a:	f243 03d4 	movw	r3, #12500	; 0x30d4
   1202e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12032:	601a      	str	r2, [r3, #0]
   12034:	68fb      	ldr	r3, [r7, #12]
   12036:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12038:	4613      	mov	r3, r2
   1203a:	ea4f 0383 	mov.w	r3, r3, lsl #2
   1203e:	4413      	add	r3, r2
   12040:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12044:	461a      	mov	r2, r3
   12046:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   1204a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1204e:	441a      	add	r2, r3
   12050:	68fb      	ldr	r3, [r7, #12]
   12052:	f103 0304 	add.w	r3, r3, #4
   12056:	4610      	mov	r0, r2
   12058:	4619      	mov	r1, r3
   1205a:	f7fd f91f 	bl	f29c <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   1205e:	68fb      	ldr	r3, [r7, #12]
   12060:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12062:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   12066:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1206a:	681b      	ldr	r3, [r3, #0]
   1206c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1206e:	429a      	cmp	r2, r3
   12070:	d906      	bls.n	12080 <vTaskRemoveFromUnorderedEventList+0xd8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
   12072:	f243 03e0 	movw	r3, #12512	; 0x30e0
   12076:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1207a:	f04f 0201 	mov.w	r2, #1
   1207e:	601a      	str	r2, [r3, #0]
	}
}
   12080:	f107 0718 	add.w	r7, r7, #24
   12084:	46bd      	mov	sp, r7
   12086:	bd80      	pop	{r7, pc}

00012088 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
   12088:	b580      	push	{r7, lr}
   1208a:	b084      	sub	sp, #16
   1208c:	af00      	add	r7, sp, #0
   1208e:	6078      	str	r0, [r7, #4]
	configASSERT( pxTimeOut );
   12090:	687b      	ldr	r3, [r7, #4]
   12092:	2b00      	cmp	r3, #0
   12094:	d109      	bne.n	120aa <vTaskSetTimeOutState+0x22>
   12096:	f04f 0328 	mov.w	r3, #40	; 0x28
   1209a:	f383 8811 	msr	BASEPRI, r3
   1209e:	f3bf 8f6f 	isb	sy
   120a2:	f3bf 8f4f 	dsb	sy
   120a6:	60fb      	str	r3, [r7, #12]
   120a8:	e7fe      	b.n	120a8 <vTaskSetTimeOutState+0x20>
	taskENTER_CRITICAL();
   120aa:	f002 f995 	bl	143d8 <vPortEnterCritical>
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
   120ae:	f243 03e4 	movw	r3, #12516	; 0x30e4
   120b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   120b6:	681a      	ldr	r2, [r3, #0]
   120b8:	687b      	ldr	r3, [r7, #4]
   120ba:	601a      	str	r2, [r3, #0]
		pxTimeOut->xTimeOnEntering = xTickCount;
   120bc:	f243 03d0 	movw	r3, #12496	; 0x30d0
   120c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   120c4:	681a      	ldr	r2, [r3, #0]
   120c6:	687b      	ldr	r3, [r7, #4]
   120c8:	605a      	str	r2, [r3, #4]
	}
	taskEXIT_CRITICAL();
   120ca:	f002 f9bd 	bl	14448 <vPortExitCritical>
}
   120ce:	f107 0710 	add.w	r7, r7, #16
   120d2:	46bd      	mov	sp, r7
   120d4:	bd80      	pop	{r7, pc}
   120d6:	bf00      	nop

000120d8 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
   120d8:	b480      	push	{r7}
   120da:	b083      	sub	sp, #12
   120dc:	af00      	add	r7, sp, #0
   120de:	6078      	str	r0, [r7, #4]
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
   120e0:	f243 03e4 	movw	r3, #12516	; 0x30e4
   120e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   120e8:	681a      	ldr	r2, [r3, #0]
   120ea:	687b      	ldr	r3, [r7, #4]
   120ec:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
   120ee:	f243 03d0 	movw	r3, #12496	; 0x30d0
   120f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   120f6:	681a      	ldr	r2, [r3, #0]
   120f8:	687b      	ldr	r3, [r7, #4]
   120fa:	605a      	str	r2, [r3, #4]
}
   120fc:	f107 070c 	add.w	r7, r7, #12
   12100:	46bd      	mov	sp, r7
   12102:	bc80      	pop	{r7}
   12104:	4770      	bx	lr
   12106:	bf00      	nop

00012108 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
   12108:	b580      	push	{r7, lr}
   1210a:	b088      	sub	sp, #32
   1210c:	af00      	add	r7, sp, #0
   1210e:	6078      	str	r0, [r7, #4]
   12110:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
   12112:	687b      	ldr	r3, [r7, #4]
   12114:	2b00      	cmp	r3, #0
   12116:	d109      	bne.n	1212c <xTaskCheckForTimeOut+0x24>
   12118:	f04f 0328 	mov.w	r3, #40	; 0x28
   1211c:	f383 8811 	msr	BASEPRI, r3
   12120:	f3bf 8f6f 	isb	sy
   12124:	f3bf 8f4f 	dsb	sy
   12128:	61bb      	str	r3, [r7, #24]
   1212a:	e7fe      	b.n	1212a <xTaskCheckForTimeOut+0x22>
	configASSERT( pxTicksToWait );
   1212c:	683b      	ldr	r3, [r7, #0]
   1212e:	2b00      	cmp	r3, #0
   12130:	d109      	bne.n	12146 <xTaskCheckForTimeOut+0x3e>
   12132:	f04f 0328 	mov.w	r3, #40	; 0x28
   12136:	f383 8811 	msr	BASEPRI, r3
   1213a:	f3bf 8f6f 	isb	sy
   1213e:	f3bf 8f4f 	dsb	sy
   12142:	61fb      	str	r3, [r7, #28]
   12144:	e7fe      	b.n	12144 <xTaskCheckForTimeOut+0x3c>

	taskENTER_CRITICAL();
   12146:	f002 f947 	bl	143d8 <vPortEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
   1214a:	f243 03d0 	movw	r3, #12496	; 0x30d0
   1214e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12152:	681b      	ldr	r3, [r3, #0]
   12154:	613b      	str	r3, [r7, #16]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
   12156:	687b      	ldr	r3, [r7, #4]
   12158:	685b      	ldr	r3, [r3, #4]
   1215a:	693a      	ldr	r2, [r7, #16]
   1215c:	ebc3 0302 	rsb	r3, r3, r2
   12160:	617b      	str	r3, [r7, #20]
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
   12162:	683b      	ldr	r3, [r7, #0]
   12164:	681b      	ldr	r3, [r3, #0]
   12166:	f1b3 3fff 	cmp.w	r3, #4294967295
   1216a:	d103      	bne.n	12174 <xTaskCheckForTimeOut+0x6c>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
   1216c:	f04f 0300 	mov.w	r3, #0
   12170:	60fb      	str	r3, [r7, #12]
   12172:	e02b      	b.n	121cc <xTaskCheckForTimeOut+0xc4>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   12174:	687b      	ldr	r3, [r7, #4]
   12176:	681a      	ldr	r2, [r3, #0]
   12178:	f243 03e4 	movw	r3, #12516	; 0x30e4
   1217c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12180:	681b      	ldr	r3, [r3, #0]
   12182:	429a      	cmp	r2, r3
   12184:	d008      	beq.n	12198 <xTaskCheckForTimeOut+0x90>
   12186:	687b      	ldr	r3, [r7, #4]
   12188:	685a      	ldr	r2, [r3, #4]
   1218a:	693b      	ldr	r3, [r7, #16]
   1218c:	429a      	cmp	r2, r3
   1218e:	d803      	bhi.n	12198 <xTaskCheckForTimeOut+0x90>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
   12190:	f04f 0301 	mov.w	r3, #1
   12194:	60fb      	str	r3, [r7, #12]
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   12196:	e019      	b.n	121cc <xTaskCheckForTimeOut+0xc4>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
   12198:	683b      	ldr	r3, [r7, #0]
   1219a:	681a      	ldr	r2, [r3, #0]
   1219c:	697b      	ldr	r3, [r7, #20]
   1219e:	429a      	cmp	r2, r3
   121a0:	d90d      	bls.n	121be <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
   121a2:	683b      	ldr	r3, [r7, #0]
   121a4:	681a      	ldr	r2, [r3, #0]
   121a6:	697b      	ldr	r3, [r7, #20]
   121a8:	ebc3 0202 	rsb	r2, r3, r2
   121ac:	683b      	ldr	r3, [r7, #0]
   121ae:	601a      	str	r2, [r3, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
   121b0:	6878      	ldr	r0, [r7, #4]
   121b2:	f7ff ff91 	bl	120d8 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
   121b6:	f04f 0300 	mov.w	r3, #0
   121ba:	60fb      	str	r3, [r7, #12]
   121bc:	e006      	b.n	121cc <xTaskCheckForTimeOut+0xc4>
		}
		else
		{
			*pxTicksToWait = 0;
   121be:	683b      	ldr	r3, [r7, #0]
   121c0:	f04f 0200 	mov.w	r2, #0
   121c4:	601a      	str	r2, [r3, #0]
			xReturn = pdTRUE;
   121c6:	f04f 0301 	mov.w	r3, #1
   121ca:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
   121cc:	f002 f93c 	bl	14448 <vPortExitCritical>

	return xReturn;
   121d0:	68fb      	ldr	r3, [r7, #12]
}
   121d2:	4618      	mov	r0, r3
   121d4:	f107 0720 	add.w	r7, r7, #32
   121d8:	46bd      	mov	sp, r7
   121da:	bd80      	pop	{r7, pc}

000121dc <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
   121dc:	b480      	push	{r7}
   121de:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
   121e0:	f243 03e0 	movw	r3, #12512	; 0x30e0
   121e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   121e8:	f04f 0201 	mov.w	r2, #1
   121ec:	601a      	str	r2, [r3, #0]
}
   121ee:	46bd      	mov	sp, r7
   121f0:	bc80      	pop	{r7}
   121f2:	4770      	bx	lr

000121f4 <uxTaskGetTaskNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
	{
   121f4:	b480      	push	{r7}
   121f6:	b085      	sub	sp, #20
   121f8:	af00      	add	r7, sp, #0
   121fa:	6078      	str	r0, [r7, #4]
	UBaseType_t uxReturn;
	TCB_t const *pxTCB;

		if( xTask != NULL )
   121fc:	687b      	ldr	r3, [r7, #4]
   121fe:	2b00      	cmp	r3, #0
   12200:	d005      	beq.n	1220e <uxTaskGetTaskNumber+0x1a>
		{
			pxTCB = xTask;
   12202:	687b      	ldr	r3, [r7, #4]
   12204:	60fb      	str	r3, [r7, #12]
			uxReturn = pxTCB->uxTaskNumber;
   12206:	68fb      	ldr	r3, [r7, #12]
   12208:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   1220a:	60bb      	str	r3, [r7, #8]
   1220c:	e002      	b.n	12214 <uxTaskGetTaskNumber+0x20>
		}
		else
		{
			uxReturn = 0U;
   1220e:	f04f 0300 	mov.w	r3, #0
   12212:	60bb      	str	r3, [r7, #8]
		}

		return uxReturn;
   12214:	68bb      	ldr	r3, [r7, #8]
	}
   12216:	4618      	mov	r0, r3
   12218:	f107 0714 	add.w	r7, r7, #20
   1221c:	46bd      	mov	sp, r7
   1221e:	bc80      	pop	{r7}
   12220:	4770      	bx	lr
   12222:	bf00      	nop

00012224 <vTaskSetTaskNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
	{
   12224:	b480      	push	{r7}
   12226:	b085      	sub	sp, #20
   12228:	af00      	add	r7, sp, #0
   1222a:	6078      	str	r0, [r7, #4]
   1222c:	6039      	str	r1, [r7, #0]
	TCB_t * pxTCB;

		if( xTask != NULL )
   1222e:	687b      	ldr	r3, [r7, #4]
   12230:	2b00      	cmp	r3, #0
   12232:	d004      	beq.n	1223e <vTaskSetTaskNumber+0x1a>
		{
			pxTCB = xTask;
   12234:	687b      	ldr	r3, [r7, #4]
   12236:	60fb      	str	r3, [r7, #12]
			pxTCB->uxTaskNumber = uxHandle;
   12238:	68fb      	ldr	r3, [r7, #12]
   1223a:	683a      	ldr	r2, [r7, #0]
   1223c:	645a      	str	r2, [r3, #68]	; 0x44
		}
	}
   1223e:	f107 0714 	add.w	r7, r7, #20
   12242:	46bd      	mov	sp, r7
   12244:	bc80      	pop	{r7}
   12246:	4770      	bx	lr

00012248 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
   12248:	b580      	push	{r7, lr}
   1224a:	b082      	sub	sp, #8
   1224c:	af00      	add	r7, sp, #0
   1224e:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
   12250:	f000 f868 	bl	12324 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
   12254:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   12258:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1225c:	681b      	ldr	r3, [r3, #0]
   1225e:	2b01      	cmp	r3, #1
   12260:	d90a      	bls.n	12278 <prvIdleTask+0x30>
			{
				taskYIELD();
   12262:	f64e 5304 	movw	r3, #60676	; 0xed04
   12266:	f2ce 0300 	movt	r3, #57344	; 0xe000
   1226a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1226e:	601a      	str	r2, [r3, #0]
   12270:	f3bf 8f4f 	dsb	sy
   12274:	f3bf 8f6f 	isb	sy
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
   12278:	f7ee fc94 	bl	ba4 <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
   1227c:	e7e8      	b.n	12250 <prvIdleTask+0x8>
   1227e:	bf00      	nop

00012280 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
   12280:	b580      	push	{r7, lr}
   12282:	b082      	sub	sp, #8
   12284:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   12286:	f04f 0300 	mov.w	r3, #0
   1228a:	607b      	str	r3, [r7, #4]
   1228c:	e013      	b.n	122b6 <prvInitialiseTaskLists+0x36>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   1228e:	687a      	ldr	r2, [r7, #4]
   12290:	4613      	mov	r3, r2
   12292:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12296:	4413      	add	r3, r2
   12298:	ea4f 0383 	mov.w	r3, r3, lsl #2
   1229c:	461a      	mov	r2, r3
   1229e:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   122a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   122a6:	4413      	add	r3, r2
   122a8:	4618      	mov	r0, r3
   122aa:	f7fc ffc5 	bl	f238 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   122ae:	687b      	ldr	r3, [r7, #4]
   122b0:	f103 0301 	add.w	r3, r3, #1
   122b4:	607b      	str	r3, [r7, #4]
   122b6:	687b      	ldr	r3, [r7, #4]
   122b8:	2b04      	cmp	r3, #4
   122ba:	d9e8      	bls.n	1228e <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
   122bc:	f243 005c 	movw	r0, #12380	; 0x305c
   122c0:	f2c2 0000 	movt	r0, #8192	; 0x2000
   122c4:	f7fc ffb8 	bl	f238 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
   122c8:	f243 0070 	movw	r0, #12400	; 0x3070
   122cc:	f2c2 0000 	movt	r0, #8192	; 0x2000
   122d0:	f7fc ffb2 	bl	f238 <vListInitialise>
	vListInitialise( &xPendingReadyList );
   122d4:	f243 008c 	movw	r0, #12428	; 0x308c
   122d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
   122dc:	f7fc ffac 	bl	f238 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
   122e0:	f243 00a0 	movw	r0, #12448	; 0x30a0
   122e4:	f2c2 0000 	movt	r0, #8192	; 0x2000
   122e8:	f7fc ffa6 	bl	f238 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
   122ec:	f243 00b8 	movw	r0, #12472	; 0x30b8
   122f0:	f2c2 0000 	movt	r0, #8192	; 0x2000
   122f4:	f7fc ffa0 	bl	f238 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
   122f8:	f243 0384 	movw	r3, #12420	; 0x3084
   122fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12300:	f243 025c 	movw	r2, #12380	; 0x305c
   12304:	f2c2 0200 	movt	r2, #8192	; 0x2000
   12308:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   1230a:	f243 0388 	movw	r3, #12424	; 0x3088
   1230e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12312:	f243 0270 	movw	r2, #12400	; 0x3070
   12316:	f2c2 0200 	movt	r2, #8192	; 0x2000
   1231a:	601a      	str	r2, [r3, #0]
}
   1231c:	f107 0708 	add.w	r7, r7, #8
   12320:	46bd      	mov	sp, r7
   12322:	bd80      	pop	{r7, pc}

00012324 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
   12324:	b580      	push	{r7, lr}
   12326:	b082      	sub	sp, #8
   12328:	af00      	add	r7, sp, #0
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   1232a:	e02b      	b.n	12384 <prvCheckTasksWaitingTermination+0x60>
		{
			taskENTER_CRITICAL();
   1232c:	f002 f854 	bl	143d8 <vPortEnterCritical>
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   12330:	f243 03a0 	movw	r3, #12448	; 0x30a0
   12334:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12338:	68db      	ldr	r3, [r3, #12]
   1233a:	68db      	ldr	r3, [r3, #12]
   1233c:	607b      	str	r3, [r7, #4]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   1233e:	687b      	ldr	r3, [r7, #4]
   12340:	f103 0304 	add.w	r3, r3, #4
   12344:	4618      	mov	r0, r3
   12346:	f7fd f807 	bl	f358 <uxListRemove>
				--uxCurrentNumberOfTasks;
   1234a:	f243 03cc 	movw	r3, #12492	; 0x30cc
   1234e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12352:	681b      	ldr	r3, [r3, #0]
   12354:	f103 32ff 	add.w	r2, r3, #4294967295
   12358:	f243 03cc 	movw	r3, #12492	; 0x30cc
   1235c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12360:	601a      	str	r2, [r3, #0]
				--uxDeletedTasksWaitingCleanUp;
   12362:	f243 03b4 	movw	r3, #12468	; 0x30b4
   12366:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1236a:	681b      	ldr	r3, [r3, #0]
   1236c:	f103 32ff 	add.w	r2, r3, #4294967295
   12370:	f243 03b4 	movw	r3, #12468	; 0x30b4
   12374:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12378:	601a      	str	r2, [r3, #0]
			}
			taskEXIT_CRITICAL();
   1237a:	f002 f865 	bl	14448 <vPortExitCritical>

			prvDeleteTCB( pxTCB );
   1237e:	6878      	ldr	r0, [r7, #4]
   12380:	f000 f8f8 	bl	12574 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   12384:	f243 03b4 	movw	r3, #12468	; 0x30b4
   12388:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1238c:	681b      	ldr	r3, [r3, #0]
   1238e:	2b00      	cmp	r3, #0
   12390:	d1cc      	bne.n	1232c <prvCheckTasksWaitingTermination+0x8>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
   12392:	f107 0708 	add.w	r7, r7, #8
   12396:	46bd      	mov	sp, r7
   12398:	bd80      	pop	{r7, pc}
   1239a:	bf00      	nop

0001239c <vTaskGetInfo>:
/*-----------------------------------------------------------*/

#if( configUSE_TRACE_FACILITY == 1 )

	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
	{
   1239c:	b580      	push	{r7, lr}
   1239e:	b086      	sub	sp, #24
   123a0:	af00      	add	r7, sp, #0
   123a2:	60f8      	str	r0, [r7, #12]
   123a4:	60b9      	str	r1, [r7, #8]
   123a6:	607a      	str	r2, [r7, #4]
   123a8:	70fb      	strb	r3, [r7, #3]
	TCB_t *pxTCB;

		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );
   123aa:	68fb      	ldr	r3, [r7, #12]
   123ac:	2b00      	cmp	r3, #0
   123ae:	d105      	bne.n	123bc <vTaskGetInfo+0x20>
   123b0:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   123b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   123b8:	681b      	ldr	r3, [r3, #0]
   123ba:	e000      	b.n	123be <vTaskGetInfo+0x22>
   123bc:	68fb      	ldr	r3, [r7, #12]
   123be:	617b      	str	r3, [r7, #20]

		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
   123c0:	68bb      	ldr	r3, [r7, #8]
   123c2:	697a      	ldr	r2, [r7, #20]
   123c4:	601a      	str	r2, [r3, #0]
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
   123c6:	697b      	ldr	r3, [r7, #20]
   123c8:	f103 0234 	add.w	r2, r3, #52	; 0x34
   123cc:	68bb      	ldr	r3, [r7, #8]
   123ce:	605a      	str	r2, [r3, #4]
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
   123d0:	697b      	ldr	r3, [r7, #20]
   123d2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   123d4:	68bb      	ldr	r3, [r7, #8]
   123d6:	611a      	str	r2, [r3, #16]
		pxTaskStatus->pxStackBase = pxTCB->pxStack;
   123d8:	697b      	ldr	r3, [r7, #20]
   123da:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   123dc:	68bb      	ldr	r3, [r7, #8]
   123de:	61da      	str	r2, [r3, #28]
		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
   123e0:	697b      	ldr	r3, [r7, #20]
   123e2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
   123e4:	68bb      	ldr	r3, [r7, #8]
   123e6:	609a      	str	r2, [r3, #8]

		#if ( configUSE_MUTEXES == 1 )
		{
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
   123e8:	697b      	ldr	r3, [r7, #20]
   123ea:	6c9a      	ldr	r2, [r3, #72]	; 0x48
   123ec:	68bb      	ldr	r3, [r7, #8]
   123ee:	615a      	str	r2, [r3, #20]
		}
		#endif

		#if ( configGENERATE_RUN_TIME_STATS == 1 )
		{
			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
   123f0:	697b      	ldr	r3, [r7, #20]
   123f2:	6d1a      	ldr	r2, [r3, #80]	; 0x50
   123f4:	68bb      	ldr	r3, [r7, #8]
   123f6:	619a      	str	r2, [r3, #24]
		#endif

		/* Obtaining the task state is a little fiddly, so is only done if the
		value of eState passed into this function is eInvalid - otherwise the
		state is just set to whatever is passed in. */
		if( eState != eInvalid )
   123f8:	78fb      	ldrb	r3, [r7, #3]
   123fa:	2b05      	cmp	r3, #5
   123fc:	d01f      	beq.n	1243e <vTaskGetInfo+0xa2>
		{
			if( pxTCB == pxCurrentTCB )
   123fe:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   12402:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12406:	681b      	ldr	r3, [r3, #0]
   12408:	697a      	ldr	r2, [r7, #20]
   1240a:	429a      	cmp	r2, r3
   1240c:	d104      	bne.n	12418 <vTaskGetInfo+0x7c>
			{
				pxTaskStatus->eCurrentState = eRunning;
   1240e:	68bb      	ldr	r3, [r7, #8]
   12410:	f04f 0200 	mov.w	r2, #0
   12414:	731a      	strb	r2, [r3, #12]
							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
							{
								pxTaskStatus->eCurrentState = eBlocked;
							}
						}
						( void ) xTaskResumeAll();
   12416:	e01b      	b.n	12450 <vTaskGetInfo+0xb4>
			{
				pxTaskStatus->eCurrentState = eRunning;
			}
			else
			{
				pxTaskStatus->eCurrentState = eState;
   12418:	68bb      	ldr	r3, [r7, #8]
   1241a:	78fa      	ldrb	r2, [r7, #3]
   1241c:	731a      	strb	r2, [r3, #12]
				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* If the task is in the suspended list then there is a
					chance it is actually just blocked indefinitely - so really
					it should be reported as being in the Blocked state. */
					if( eState == eSuspended )
   1241e:	78fb      	ldrb	r3, [r7, #3]
   12420:	2b03      	cmp	r3, #3
   12422:	d114      	bne.n	1244e <vTaskGetInfo+0xb2>
					{
						vTaskSuspendAll();
   12424:	f7ff f8f6 	bl	11614 <vTaskSuspendAll>
						{
							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   12428:	697b      	ldr	r3, [r7, #20]
   1242a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1242c:	2b00      	cmp	r3, #0
   1242e:	d003      	beq.n	12438 <vTaskGetInfo+0x9c>
							{
								pxTaskStatus->eCurrentState = eBlocked;
   12430:	68bb      	ldr	r3, [r7, #8]
   12432:	f04f 0202 	mov.w	r2, #2
   12436:	731a      	strb	r2, [r3, #12]
							}
						}
						( void ) xTaskResumeAll();
   12438:	f7ff f8fe 	bl	11638 <xTaskResumeAll>
   1243c:	e008      	b.n	12450 <vTaskGetInfo+0xb4>
				#endif /* INCLUDE_vTaskSuspend */
			}
		}
		else
		{
			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
   1243e:	6978      	ldr	r0, [r7, #20]
   12440:	f7fe fd06 	bl	10e50 <eTaskGetState>
   12444:	4603      	mov	r3, r0
   12446:	461a      	mov	r2, r3
   12448:	68bb      	ldr	r3, [r7, #8]
   1244a:	731a      	strb	r2, [r3, #12]
   1244c:	e000      	b.n	12450 <vTaskGetInfo+0xb4>
							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
							{
								pxTaskStatus->eCurrentState = eBlocked;
							}
						}
						( void ) xTaskResumeAll();
   1244e:	bf00      	nop
			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
		}

		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
		parameter is provided to allow it to be skipped. */
		if( xGetFreeStackSpace != pdFALSE )
   12450:	687b      	ldr	r3, [r7, #4]
   12452:	2b00      	cmp	r3, #0
   12454:	d009      	beq.n	1246a <vTaskGetInfo+0xce>
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
			}
			#else
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
   12456:	697b      	ldr	r3, [r7, #20]
   12458:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   1245a:	4618      	mov	r0, r3
   1245c:	f000 f86a 	bl	12534 <prvTaskCheckFreeStackSpace>
   12460:	4603      	mov	r3, r0
   12462:	461a      	mov	r2, r3
   12464:	68bb      	ldr	r3, [r7, #8]
   12466:	841a      	strh	r2, [r3, #32]
   12468:	e003      	b.n	12472 <vTaskGetInfo+0xd6>
			}
			#endif
		}
		else
		{
			pxTaskStatus->usStackHighWaterMark = 0;
   1246a:	68bb      	ldr	r3, [r7, #8]
   1246c:	f04f 0200 	mov.w	r2, #0
   12470:	841a      	strh	r2, [r3, #32]
		}
	}
   12472:	f107 0718 	add.w	r7, r7, #24
   12476:	46bd      	mov	sp, r7
   12478:	bd80      	pop	{r7, pc}
   1247a:	bf00      	nop

0001247c <prvListTasksWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
   1247c:	b580      	push	{r7, lr}
   1247e:	b08a      	sub	sp, #40	; 0x28
   12480:	af00      	add	r7, sp, #0
   12482:	60f8      	str	r0, [r7, #12]
   12484:	60b9      	str	r1, [r7, #8]
   12486:	4613      	mov	r3, r2
   12488:	71fb      	strb	r3, [r7, #7]
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
   1248a:	f04f 0300 	mov.w	r3, #0
   1248e:	61fb      	str	r3, [r7, #28]

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
   12490:	68bb      	ldr	r3, [r7, #8]
   12492:	681b      	ldr	r3, [r3, #0]
   12494:	2b00      	cmp	r3, #0
   12496:	d046      	beq.n	12526 <prvListTasksWithinSingleList+0xaa>
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   12498:	68bb      	ldr	r3, [r7, #8]
   1249a:	623b      	str	r3, [r7, #32]
   1249c:	6a3b      	ldr	r3, [r7, #32]
   1249e:	685b      	ldr	r3, [r3, #4]
   124a0:	685a      	ldr	r2, [r3, #4]
   124a2:	6a3b      	ldr	r3, [r7, #32]
   124a4:	605a      	str	r2, [r3, #4]
   124a6:	6a3b      	ldr	r3, [r7, #32]
   124a8:	685a      	ldr	r2, [r3, #4]
   124aa:	6a3b      	ldr	r3, [r7, #32]
   124ac:	f103 0308 	add.w	r3, r3, #8
   124b0:	429a      	cmp	r2, r3
   124b2:	d104      	bne.n	124be <prvListTasksWithinSingleList+0x42>
   124b4:	6a3b      	ldr	r3, [r7, #32]
   124b6:	685b      	ldr	r3, [r3, #4]
   124b8:	685a      	ldr	r2, [r3, #4]
   124ba:	6a3b      	ldr	r3, [r7, #32]
   124bc:	605a      	str	r2, [r3, #4]
   124be:	6a3b      	ldr	r3, [r7, #32]
   124c0:	685b      	ldr	r3, [r3, #4]
   124c2:	68db      	ldr	r3, [r3, #12]
   124c4:	61bb      	str	r3, [r7, #24]
			pxTaskStatusArray array for each task that is referenced from
			pxList.  See the definition of TaskStatus_t in task.h for the
			meaning of each TaskStatus_t structure member. */
			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   124c6:	68bb      	ldr	r3, [r7, #8]
   124c8:	627b      	str	r3, [r7, #36]	; 0x24
   124ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   124cc:	685b      	ldr	r3, [r3, #4]
   124ce:	685a      	ldr	r2, [r3, #4]
   124d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   124d2:	605a      	str	r2, [r3, #4]
   124d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   124d6:	685a      	ldr	r2, [r3, #4]
   124d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   124da:	f103 0308 	add.w	r3, r3, #8
   124de:	429a      	cmp	r2, r3
   124e0:	d104      	bne.n	124ec <prvListTasksWithinSingleList+0x70>
   124e2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   124e4:	685b      	ldr	r3, [r3, #4]
   124e6:	685a      	ldr	r2, [r3, #4]
   124e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   124ea:	605a      	str	r2, [r3, #4]
   124ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   124ee:	685b      	ldr	r3, [r3, #4]
   124f0:	68db      	ldr	r3, [r3, #12]
   124f2:	617b      	str	r3, [r7, #20]
				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
   124f4:	69fa      	ldr	r2, [r7, #28]
   124f6:	4613      	mov	r3, r2
   124f8:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   124fc:	4413      	add	r3, r2
   124fe:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12502:	461a      	mov	r2, r3
   12504:	68fb      	ldr	r3, [r7, #12]
   12506:	441a      	add	r2, r3
   12508:	79fb      	ldrb	r3, [r7, #7]
   1250a:	6978      	ldr	r0, [r7, #20]
   1250c:	4611      	mov	r1, r2
   1250e:	f04f 0201 	mov.w	r2, #1
   12512:	f7ff ff43 	bl	1239c <vTaskGetInfo>
				uxTask++;
   12516:	69fb      	ldr	r3, [r7, #28]
   12518:	f103 0301 	add.w	r3, r3, #1
   1251c:	61fb      	str	r3, [r7, #28]
			} while( pxNextTCB != pxFirstTCB );
   1251e:	697a      	ldr	r2, [r7, #20]
   12520:	69bb      	ldr	r3, [r7, #24]
   12522:	429a      	cmp	r2, r3
   12524:	d1cf      	bne.n	124c6 <prvListTasksWithinSingleList+0x4a>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return uxTask;
   12526:	69fb      	ldr	r3, [r7, #28]
	}
   12528:	4618      	mov	r0, r3
   1252a:	f107 0728 	add.w	r7, r7, #40	; 0x28
   1252e:	46bd      	mov	sp, r7
   12530:	bd80      	pop	{r7, pc}
   12532:	bf00      	nop

00012534 <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
   12534:	b480      	push	{r7}
   12536:	b085      	sub	sp, #20
   12538:	af00      	add	r7, sp, #0
   1253a:	6078      	str	r0, [r7, #4]
	uint32_t ulCount = 0U;
   1253c:	f04f 0300 	mov.w	r3, #0
   12540:	60fb      	str	r3, [r7, #12]

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
   12542:	e007      	b.n	12554 <prvTaskCheckFreeStackSpace+0x20>
		{
			pucStackByte -= portSTACK_GROWTH;
   12544:	687b      	ldr	r3, [r7, #4]
   12546:	f103 0301 	add.w	r3, r3, #1
   1254a:	607b      	str	r3, [r7, #4]
			ulCount++;
   1254c:	68fb      	ldr	r3, [r7, #12]
   1254e:	f103 0301 	add.w	r3, r3, #1
   12552:	60fb      	str	r3, [r7, #12]

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
   12554:	687b      	ldr	r3, [r7, #4]
   12556:	781b      	ldrb	r3, [r3, #0]
   12558:	2ba5      	cmp	r3, #165	; 0xa5
   1255a:	d0f3      	beq.n	12544 <prvTaskCheckFreeStackSpace+0x10>
		{
			pucStackByte -= portSTACK_GROWTH;
			ulCount++;
		}

		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
   1255c:	68fb      	ldr	r3, [r7, #12]
   1255e:	ea4f 0393 	mov.w	r3, r3, lsr #2
   12562:	60fb      	str	r3, [r7, #12]

		return ( configSTACK_DEPTH_TYPE ) ulCount;
   12564:	68fb      	ldr	r3, [r7, #12]
   12566:	b29b      	uxth	r3, r3
	}
   12568:	4618      	mov	r0, r3
   1256a:	f107 0714 	add.w	r7, r7, #20
   1256e:	46bd      	mov	sp, r7
   12570:	bc80      	pop	{r7}
   12572:	4770      	bx	lr

00012574 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
   12574:	b580      	push	{r7, lr}
   12576:	b082      	sub	sp, #8
   12578:	af00      	add	r7, sp, #0
   1257a:	6078      	str	r0, [r7, #4]

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
   1257c:	687b      	ldr	r3, [r7, #4]
   1257e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   12580:	4618      	mov	r0, r3
   12582:	f001 fd61 	bl	14048 <vPortFree>
			vPortFree( pxTCB );
   12586:	6878      	ldr	r0, [r7, #4]
   12588:	f001 fd5e 	bl	14048 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
   1258c:	f107 0708 	add.w	r7, r7, #8
   12590:	46bd      	mov	sp, r7
   12592:	bd80      	pop	{r7, pc}

00012594 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
   12594:	b480      	push	{r7}
   12596:	b083      	sub	sp, #12
   12598:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   1259a:	f243 0384 	movw	r3, #12420	; 0x3084
   1259e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   125a2:	681b      	ldr	r3, [r3, #0]
   125a4:	681b      	ldr	r3, [r3, #0]
   125a6:	2b00      	cmp	r3, #0
   125a8:	d107      	bne.n	125ba <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
   125aa:	f243 03ec 	movw	r3, #12524	; 0x30ec
   125ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
   125b2:	f04f 32ff 	mov.w	r2, #4294967295
   125b6:	601a      	str	r2, [r3, #0]
   125b8:	e00e      	b.n	125d8 <prvResetNextTaskUnblockTime+0x44>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   125ba:	f243 0384 	movw	r3, #12420	; 0x3084
   125be:	f2c2 0300 	movt	r3, #8192	; 0x2000
   125c2:	681b      	ldr	r3, [r3, #0]
   125c4:	68db      	ldr	r3, [r3, #12]
   125c6:	68db      	ldr	r3, [r3, #12]
   125c8:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
   125ca:	687b      	ldr	r3, [r7, #4]
   125cc:	685a      	ldr	r2, [r3, #4]
   125ce:	f243 03ec 	movw	r3, #12524	; 0x30ec
   125d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   125d6:	601a      	str	r2, [r3, #0]
	}
}
   125d8:	f107 070c 	add.w	r7, r7, #12
   125dc:	46bd      	mov	sp, r7
   125de:	bc80      	pop	{r7}
   125e0:	4770      	bx	lr
   125e2:	bf00      	nop

000125e4 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
   125e4:	b480      	push	{r7}
   125e6:	b083      	sub	sp, #12
   125e8:	af00      	add	r7, sp, #0
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
   125ea:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   125ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
   125f2:	681b      	ldr	r3, [r3, #0]
   125f4:	607b      	str	r3, [r7, #4]

		return xReturn;
   125f6:	687b      	ldr	r3, [r7, #4]
	}
   125f8:	4618      	mov	r0, r3
   125fa:	f107 070c 	add.w	r7, r7, #12
   125fe:	46bd      	mov	sp, r7
   12600:	bc80      	pop	{r7}
   12602:	4770      	bx	lr

00012604 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
   12604:	b480      	push	{r7}
   12606:	b083      	sub	sp, #12
   12608:	af00      	add	r7, sp, #0
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
   1260a:	f243 03d8 	movw	r3, #12504	; 0x30d8
   1260e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12612:	681b      	ldr	r3, [r3, #0]
   12614:	2b00      	cmp	r3, #0
   12616:	d103      	bne.n	12620 <xTaskGetSchedulerState+0x1c>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
   12618:	f04f 0301 	mov.w	r3, #1
   1261c:	607b      	str	r3, [r7, #4]
   1261e:	e00d      	b.n	1263c <xTaskGetSchedulerState+0x38>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   12620:	f243 03f4 	movw	r3, #12532	; 0x30f4
   12624:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12628:	681b      	ldr	r3, [r3, #0]
   1262a:	2b00      	cmp	r3, #0
   1262c:	d103      	bne.n	12636 <xTaskGetSchedulerState+0x32>
			{
				xReturn = taskSCHEDULER_RUNNING;
   1262e:	f04f 0302 	mov.w	r3, #2
   12632:	607b      	str	r3, [r7, #4]
   12634:	e002      	b.n	1263c <xTaskGetSchedulerState+0x38>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
   12636:	f04f 0300 	mov.w	r3, #0
   1263a:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
   1263c:	687b      	ldr	r3, [r7, #4]
	}
   1263e:	4618      	mov	r0, r3
   12640:	f107 070c 	add.w	r7, r7, #12
   12644:	46bd      	mov	sp, r7
   12646:	bc80      	pop	{r7}
   12648:	4770      	bx	lr
   1264a:	bf00      	nop

0001264c <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
   1264c:	b580      	push	{r7, lr}
   1264e:	b084      	sub	sp, #16
   12650:	af00      	add	r7, sp, #0
   12652:	6078      	str	r0, [r7, #4]
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
   12654:	687b      	ldr	r3, [r7, #4]
   12656:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn = pdFALSE;
   12658:	f04f 0300 	mov.w	r3, #0
   1265c:	60fb      	str	r3, [r7, #12]

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
   1265e:	687b      	ldr	r3, [r7, #4]
   12660:	2b00      	cmp	r3, #0
   12662:	f000 80a2 	beq.w	127aa <xTaskPriorityInherit+0x15e>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
   12666:	68bb      	ldr	r3, [r7, #8]
   12668:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1266a:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   1266e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12672:	681b      	ldr	r3, [r3, #0]
   12674:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   12676:	429a      	cmp	r2, r3
   12678:	f080 808a 	bcs.w	12790 <xTaskPriorityInherit+0x144>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   1267c:	68bb      	ldr	r3, [r7, #8]
   1267e:	699b      	ldr	r3, [r3, #24]
   12680:	2b00      	cmp	r3, #0
   12682:	db09      	blt.n	12698 <xTaskPriorityInherit+0x4c>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   12684:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   12688:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1268c:	681b      	ldr	r3, [r3, #0]
   1268e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   12690:	f1c3 0205 	rsb	r2, r3, #5
   12694:	68bb      	ldr	r3, [r7, #8]
   12696:	619a      	str	r2, [r3, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
   12698:	68bb      	ldr	r3, [r7, #8]
   1269a:	6959      	ldr	r1, [r3, #20]
   1269c:	68bb      	ldr	r3, [r7, #8]
   1269e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   126a0:	4613      	mov	r3, r2
   126a2:	ea4f 0383 	mov.w	r3, r3, lsl #2
   126a6:	4413      	add	r3, r2
   126a8:	ea4f 0383 	mov.w	r3, r3, lsl #2
   126ac:	461a      	mov	r2, r3
   126ae:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   126b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   126b6:	4413      	add	r3, r2
   126b8:	4299      	cmp	r1, r3
   126ba:	d15d      	bne.n	12778 <xTaskPriorityInherit+0x12c>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   126bc:	68bb      	ldr	r3, [r7, #8]
   126be:	f103 0304 	add.w	r3, r3, #4
   126c2:	4618      	mov	r0, r3
   126c4:	f7fc fe48 	bl	f358 <uxListRemove>
   126c8:	4603      	mov	r3, r0
   126ca:	2b00      	cmp	r3, #0
   126cc:	d124      	bne.n	12718 <xTaskPriorityInherit+0xcc>
					{
						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
   126ce:	68bb      	ldr	r3, [r7, #8]
   126d0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   126d2:	4613      	mov	r3, r2
   126d4:	ea4f 0383 	mov.w	r3, r3, lsl #2
   126d8:	4413      	add	r3, r2
   126da:	ea4f 0383 	mov.w	r3, r3, lsl #2
   126de:	461a      	mov	r2, r3
   126e0:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   126e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   126e8:	4413      	add	r3, r2
   126ea:	681b      	ldr	r3, [r3, #0]
   126ec:	2b00      	cmp	r3, #0
   126ee:	d113      	bne.n	12718 <xTaskPriorityInherit+0xcc>
   126f0:	68bb      	ldr	r3, [r7, #8]
   126f2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   126f4:	f04f 0201 	mov.w	r2, #1
   126f8:	fa02 f303 	lsl.w	r3, r2, r3
   126fc:	ea6f 0203 	mvn.w	r2, r3
   12700:	f243 03d4 	movw	r3, #12500	; 0x30d4
   12704:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12708:	681b      	ldr	r3, [r3, #0]
   1270a:	ea02 0203 	and.w	r2, r2, r3
   1270e:	f243 03d4 	movw	r3, #12500	; 0x30d4
   12712:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12716:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   12718:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   1271c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12720:	681b      	ldr	r3, [r3, #0]
   12722:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12724:	68bb      	ldr	r3, [r7, #8]
   12726:	62da      	str	r2, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
   12728:	68bb      	ldr	r3, [r7, #8]
   1272a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1272c:	f04f 0201 	mov.w	r2, #1
   12730:	fa02 f203 	lsl.w	r2, r2, r3
   12734:	f243 03d4 	movw	r3, #12500	; 0x30d4
   12738:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1273c:	681b      	ldr	r3, [r3, #0]
   1273e:	ea42 0203 	orr.w	r2, r2, r3
   12742:	f243 03d4 	movw	r3, #12500	; 0x30d4
   12746:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1274a:	601a      	str	r2, [r3, #0]
   1274c:	68bb      	ldr	r3, [r7, #8]
   1274e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12750:	4613      	mov	r3, r2
   12752:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12756:	4413      	add	r3, r2
   12758:	ea4f 0383 	mov.w	r3, r3, lsl #2
   1275c:	461a      	mov	r2, r3
   1275e:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   12762:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12766:	441a      	add	r2, r3
   12768:	68bb      	ldr	r3, [r7, #8]
   1276a:	f103 0304 	add.w	r3, r3, #4
   1276e:	4610      	mov	r0, r2
   12770:	4619      	mov	r1, r3
   12772:	f7fc fd93 	bl	f29c <vListInsertEnd>
   12776:	e007      	b.n	12788 <xTaskPriorityInherit+0x13c>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   12778:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   1277c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12780:	681b      	ldr	r3, [r3, #0]
   12782:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12784:	68bb      	ldr	r3, [r7, #8]
   12786:	62da      	str	r2, [r3, #44]	; 0x2c
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
   12788:	f04f 0301 	mov.w	r3, #1
   1278c:	60fb      	str	r3, [r7, #12]
   1278e:	e00c      	b.n	127aa <xTaskPriorityInherit+0x15e>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
   12790:	68bb      	ldr	r3, [r7, #8]
   12792:	6c9a      	ldr	r2, [r3, #72]	; 0x48
   12794:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   12798:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1279c:	681b      	ldr	r3, [r3, #0]
   1279e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   127a0:	429a      	cmp	r2, r3
   127a2:	d202      	bcs.n	127aa <xTaskPriorityInherit+0x15e>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
   127a4:	f04f 0301 	mov.w	r3, #1
   127a8:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
   127aa:	68fb      	ldr	r3, [r7, #12]
	}
   127ac:	4618      	mov	r0, r3
   127ae:	f107 0710 	add.w	r7, r7, #16
   127b2:	46bd      	mov	sp, r7
   127b4:	bd80      	pop	{r7, pc}
   127b6:	bf00      	nop

000127b8 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
   127b8:	b580      	push	{r7, lr}
   127ba:	b086      	sub	sp, #24
   127bc:	af00      	add	r7, sp, #0
   127be:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = pxMutexHolder;
   127c0:	687b      	ldr	r3, [r7, #4]
   127c2:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn = pdFALSE;
   127c4:	f04f 0300 	mov.w	r3, #0
   127c8:	60fb      	str	r3, [r7, #12]

		if( pxMutexHolder != NULL )
   127ca:	687b      	ldr	r3, [r7, #4]
   127cc:	2b00      	cmp	r3, #0
   127ce:	f000 8092 	beq.w	128f6 <xTaskPriorityDisinherit+0x13e>
		{
			/* A task can only have an inherited priority if it holds the mutex.
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
   127d2:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   127d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   127da:	681b      	ldr	r3, [r3, #0]
   127dc:	68ba      	ldr	r2, [r7, #8]
   127de:	429a      	cmp	r2, r3
   127e0:	d009      	beq.n	127f6 <xTaskPriorityDisinherit+0x3e>
   127e2:	f04f 0328 	mov.w	r3, #40	; 0x28
   127e6:	f383 8811 	msr	BASEPRI, r3
   127ea:	f3bf 8f6f 	isb	sy
   127ee:	f3bf 8f4f 	dsb	sy
   127f2:	613b      	str	r3, [r7, #16]
   127f4:	e7fe      	b.n	127f4 <xTaskPriorityDisinherit+0x3c>
			configASSERT( pxTCB->uxMutexesHeld );
   127f6:	68bb      	ldr	r3, [r7, #8]
   127f8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   127fa:	2b00      	cmp	r3, #0
   127fc:	d109      	bne.n	12812 <xTaskPriorityDisinherit+0x5a>
   127fe:	f04f 0328 	mov.w	r3, #40	; 0x28
   12802:	f383 8811 	msr	BASEPRI, r3
   12806:	f3bf 8f6f 	isb	sy
   1280a:	f3bf 8f4f 	dsb	sy
   1280e:	617b      	str	r3, [r7, #20]
   12810:	e7fe      	b.n	12810 <xTaskPriorityDisinherit+0x58>
			( pxTCB->uxMutexesHeld )--;
   12812:	68bb      	ldr	r3, [r7, #8]
   12814:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   12816:	f103 32ff 	add.w	r2, r3, #4294967295
   1281a:	68bb      	ldr	r3, [r7, #8]
   1281c:	64da      	str	r2, [r3, #76]	; 0x4c

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   1281e:	68bb      	ldr	r3, [r7, #8]
   12820:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12822:	68bb      	ldr	r3, [r7, #8]
   12824:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   12826:	429a      	cmp	r2, r3
   12828:	d065      	beq.n	128f6 <xTaskPriorityDisinherit+0x13e>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
   1282a:	68bb      	ldr	r3, [r7, #8]
   1282c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   1282e:	2b00      	cmp	r3, #0
   12830:	d161      	bne.n	128f6 <xTaskPriorityDisinherit+0x13e>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   12832:	68bb      	ldr	r3, [r7, #8]
   12834:	f103 0304 	add.w	r3, r3, #4
   12838:	4618      	mov	r0, r3
   1283a:	f7fc fd8d 	bl	f358 <uxListRemove>
   1283e:	4603      	mov	r3, r0
   12840:	2b00      	cmp	r3, #0
   12842:	d124      	bne.n	1288e <xTaskPriorityDisinherit+0xd6>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   12844:	68bb      	ldr	r3, [r7, #8]
   12846:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12848:	4613      	mov	r3, r2
   1284a:	ea4f 0383 	mov.w	r3, r3, lsl #2
   1284e:	4413      	add	r3, r2
   12850:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12854:	461a      	mov	r2, r3
   12856:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   1285a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1285e:	4413      	add	r3, r2
   12860:	681b      	ldr	r3, [r3, #0]
   12862:	2b00      	cmp	r3, #0
   12864:	d113      	bne.n	1288e <xTaskPriorityDisinherit+0xd6>
   12866:	68bb      	ldr	r3, [r7, #8]
   12868:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1286a:	f04f 0201 	mov.w	r2, #1
   1286e:	fa02 f303 	lsl.w	r3, r2, r3
   12872:	ea6f 0203 	mvn.w	r2, r3
   12876:	f243 03d4 	movw	r3, #12500	; 0x30d4
   1287a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1287e:	681b      	ldr	r3, [r3, #0]
   12880:	ea02 0203 	and.w	r2, r2, r3
   12884:	f243 03d4 	movw	r3, #12500	; 0x30d4
   12888:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1288c:	601a      	str	r2, [r3, #0]
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
   1288e:	68bb      	ldr	r3, [r7, #8]
   12890:	6c9a      	ldr	r2, [r3, #72]	; 0x48
   12892:	68bb      	ldr	r3, [r7, #8]
   12894:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   12896:	68bb      	ldr	r3, [r7, #8]
   12898:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1289a:	f1c3 0205 	rsb	r2, r3, #5
   1289e:	68bb      	ldr	r3, [r7, #8]
   128a0:	619a      	str	r2, [r3, #24]
					prvAddTaskToReadyList( pxTCB );
   128a2:	68bb      	ldr	r3, [r7, #8]
   128a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   128a6:	f04f 0201 	mov.w	r2, #1
   128aa:	fa02 f203 	lsl.w	r2, r2, r3
   128ae:	f243 03d4 	movw	r3, #12500	; 0x30d4
   128b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   128b6:	681b      	ldr	r3, [r3, #0]
   128b8:	ea42 0203 	orr.w	r2, r2, r3
   128bc:	f243 03d4 	movw	r3, #12500	; 0x30d4
   128c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   128c4:	601a      	str	r2, [r3, #0]
   128c6:	68bb      	ldr	r3, [r7, #8]
   128c8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   128ca:	4613      	mov	r3, r2
   128cc:	ea4f 0383 	mov.w	r3, r3, lsl #2
   128d0:	4413      	add	r3, r2
   128d2:	ea4f 0383 	mov.w	r3, r3, lsl #2
   128d6:	461a      	mov	r2, r3
   128d8:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   128dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   128e0:	441a      	add	r2, r3
   128e2:	68bb      	ldr	r3, [r7, #8]
   128e4:	f103 0304 	add.w	r3, r3, #4
   128e8:	4610      	mov	r0, r2
   128ea:	4619      	mov	r1, r3
   128ec:	f7fc fcd6 	bl	f29c <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
   128f0:	f04f 0301 	mov.w	r3, #1
   128f4:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
   128f6:	68fb      	ldr	r3, [r7, #12]
	}
   128f8:	4618      	mov	r0, r3
   128fa:	f107 0718 	add.w	r7, r7, #24
   128fe:	46bd      	mov	sp, r7
   12900:	bd80      	pop	{r7, pc}
   12902:	bf00      	nop

00012904 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
   12904:	b580      	push	{r7, lr}
   12906:	b088      	sub	sp, #32
   12908:	af00      	add	r7, sp, #0
   1290a:	6078      	str	r0, [r7, #4]
   1290c:	6039      	str	r1, [r7, #0]
	TCB_t * const pxTCB = pxMutexHolder;
   1290e:	687b      	ldr	r3, [r7, #4]
   12910:	60bb      	str	r3, [r7, #8]
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
   12912:	f04f 0301 	mov.w	r3, #1
   12916:	617b      	str	r3, [r7, #20]

		if( pxMutexHolder != NULL )
   12918:	687b      	ldr	r3, [r7, #4]
   1291a:	2b00      	cmp	r3, #0
   1291c:	f000 80ac 	beq.w	12a78 <vTaskPriorityDisinheritAfterTimeout+0x174>
		{
			/* If pxMutexHolder is not NULL then the holder must hold at least
			one mutex. */
			configASSERT( pxTCB->uxMutexesHeld );
   12920:	68bb      	ldr	r3, [r7, #8]
   12922:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   12924:	2b00      	cmp	r3, #0
   12926:	d109      	bne.n	1293c <vTaskPriorityDisinheritAfterTimeout+0x38>
   12928:	f04f 0328 	mov.w	r3, #40	; 0x28
   1292c:	f383 8811 	msr	BASEPRI, r3
   12930:	f3bf 8f6f 	isb	sy
   12934:	f3bf 8f4f 	dsb	sy
   12938:	61bb      	str	r3, [r7, #24]
   1293a:	e7fe      	b.n	1293a <vTaskPriorityDisinheritAfterTimeout+0x36>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
   1293c:	68bb      	ldr	r3, [r7, #8]
   1293e:	6c9a      	ldr	r2, [r3, #72]	; 0x48
   12940:	683b      	ldr	r3, [r7, #0]
   12942:	429a      	cmp	r2, r3
   12944:	d202      	bcs.n	1294c <vTaskPriorityDisinheritAfterTimeout+0x48>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
   12946:	683b      	ldr	r3, [r7, #0]
   12948:	613b      	str	r3, [r7, #16]
   1294a:	e002      	b.n	12952 <vTaskPriorityDisinheritAfterTimeout+0x4e>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
   1294c:	68bb      	ldr	r3, [r7, #8]
   1294e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   12950:	613b      	str	r3, [r7, #16]
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
   12952:	68bb      	ldr	r3, [r7, #8]
   12954:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12956:	693b      	ldr	r3, [r7, #16]
   12958:	429a      	cmp	r2, r3
   1295a:	f000 808d 	beq.w	12a78 <vTaskPriorityDisinheritAfterTimeout+0x174>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
   1295e:	68bb      	ldr	r3, [r7, #8]
   12960:	6cda      	ldr	r2, [r3, #76]	; 0x4c
   12962:	697b      	ldr	r3, [r7, #20]
   12964:	429a      	cmp	r2, r3
   12966:	f040 8087 	bne.w	12a78 <vTaskPriorityDisinheritAfterTimeout+0x174>
				{
					/* If a task has timed out because it already holds the
					mutex it was trying to obtain then it cannot of inherited
					its own priority. */
					configASSERT( pxTCB != pxCurrentTCB );
   1296a:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   1296e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12972:	681b      	ldr	r3, [r3, #0]
   12974:	68ba      	ldr	r2, [r7, #8]
   12976:	429a      	cmp	r2, r3
   12978:	d109      	bne.n	1298e <vTaskPriorityDisinheritAfterTimeout+0x8a>
   1297a:	f04f 0328 	mov.w	r3, #40	; 0x28
   1297e:	f383 8811 	msr	BASEPRI, r3
   12982:	f3bf 8f6f 	isb	sy
   12986:	f3bf 8f4f 	dsb	sy
   1298a:	61fb      	str	r3, [r7, #28]
   1298c:	e7fe      	b.n	1298c <vTaskPriorityDisinheritAfterTimeout+0x88>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
   1298e:	68bb      	ldr	r3, [r7, #8]
   12990:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   12992:	60fb      	str	r3, [r7, #12]
					pxTCB->uxPriority = uxPriorityToUse;
   12994:	68bb      	ldr	r3, [r7, #8]
   12996:	693a      	ldr	r2, [r7, #16]
   12998:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   1299a:	68bb      	ldr	r3, [r7, #8]
   1299c:	699b      	ldr	r3, [r3, #24]
   1299e:	2b00      	cmp	r3, #0
   129a0:	db04      	blt.n	129ac <vTaskPriorityDisinheritAfterTimeout+0xa8>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   129a2:	693b      	ldr	r3, [r7, #16]
   129a4:	f1c3 0205 	rsb	r2, r3, #5
   129a8:	68bb      	ldr	r3, [r7, #8]
   129aa:	619a      	str	r2, [r3, #24]
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
   129ac:	68bb      	ldr	r3, [r7, #8]
   129ae:	6959      	ldr	r1, [r3, #20]
   129b0:	68fa      	ldr	r2, [r7, #12]
   129b2:	4613      	mov	r3, r2
   129b4:	ea4f 0383 	mov.w	r3, r3, lsl #2
   129b8:	4413      	add	r3, r2
   129ba:	ea4f 0383 	mov.w	r3, r3, lsl #2
   129be:	461a      	mov	r2, r3
   129c0:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   129c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   129c8:	4413      	add	r3, r2
   129ca:	4299      	cmp	r1, r3
   129cc:	d154      	bne.n	12a78 <vTaskPriorityDisinheritAfterTimeout+0x174>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   129ce:	68bb      	ldr	r3, [r7, #8]
   129d0:	f103 0304 	add.w	r3, r3, #4
   129d4:	4618      	mov	r0, r3
   129d6:	f7fc fcbf 	bl	f358 <uxListRemove>
   129da:	4603      	mov	r3, r0
   129dc:	2b00      	cmp	r3, #0
   129de:	d124      	bne.n	12a2a <vTaskPriorityDisinheritAfterTimeout+0x126>
						{
							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   129e0:	68bb      	ldr	r3, [r7, #8]
   129e2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   129e4:	4613      	mov	r3, r2
   129e6:	ea4f 0383 	mov.w	r3, r3, lsl #2
   129ea:	4413      	add	r3, r2
   129ec:	ea4f 0383 	mov.w	r3, r3, lsl #2
   129f0:	461a      	mov	r2, r3
   129f2:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   129f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   129fa:	4413      	add	r3, r2
   129fc:	681b      	ldr	r3, [r3, #0]
   129fe:	2b00      	cmp	r3, #0
   12a00:	d113      	bne.n	12a2a <vTaskPriorityDisinheritAfterTimeout+0x126>
   12a02:	68bb      	ldr	r3, [r7, #8]
   12a04:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   12a06:	f04f 0201 	mov.w	r2, #1
   12a0a:	fa02 f303 	lsl.w	r3, r2, r3
   12a0e:	ea6f 0203 	mvn.w	r2, r3
   12a12:	f243 03d4 	movw	r3, #12500	; 0x30d4
   12a16:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12a1a:	681b      	ldr	r3, [r3, #0]
   12a1c:	ea02 0203 	and.w	r2, r2, r3
   12a20:	f243 03d4 	movw	r3, #12500	; 0x30d4
   12a24:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12a28:	601a      	str	r2, [r3, #0]
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
   12a2a:	68bb      	ldr	r3, [r7, #8]
   12a2c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   12a2e:	f04f 0201 	mov.w	r2, #1
   12a32:	fa02 f203 	lsl.w	r2, r2, r3
   12a36:	f243 03d4 	movw	r3, #12500	; 0x30d4
   12a3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12a3e:	681b      	ldr	r3, [r3, #0]
   12a40:	ea42 0203 	orr.w	r2, r2, r3
   12a44:	f243 03d4 	movw	r3, #12500	; 0x30d4
   12a48:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12a4c:	601a      	str	r2, [r3, #0]
   12a4e:	68bb      	ldr	r3, [r7, #8]
   12a50:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12a52:	4613      	mov	r3, r2
   12a54:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12a58:	4413      	add	r3, r2
   12a5a:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12a5e:	461a      	mov	r2, r3
   12a60:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   12a64:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12a68:	441a      	add	r2, r3
   12a6a:	68bb      	ldr	r3, [r7, #8]
   12a6c:	f103 0304 	add.w	r3, r3, #4
   12a70:	4610      	mov	r0, r2
   12a72:	4619      	mov	r1, r3
   12a74:	f7fc fc12 	bl	f29c <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   12a78:	f107 0720 	add.w	r7, r7, #32
   12a7c:	46bd      	mov	sp, r7
   12a7e:	bd80      	pop	{r7, pc}

00012a80 <prvWriteNameToBuffer>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )

	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
	{
   12a80:	b580      	push	{r7, lr}
   12a82:	b084      	sub	sp, #16
   12a84:	af00      	add	r7, sp, #0
   12a86:	6078      	str	r0, [r7, #4]
   12a88:	6039      	str	r1, [r7, #0]
	size_t x;

		/* Start by copying the entire string. */
		strcpy( pcBuffer, pcTaskName );
   12a8a:	6878      	ldr	r0, [r7, #4]
   12a8c:	6839      	ldr	r1, [r7, #0]
   12a8e:	f002 ff1b 	bl	158c8 <strcpy>

		/* Pad the end of the string with spaces to ensure columns line up when
		printed out. */
		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
   12a92:	6878      	ldr	r0, [r7, #4]
   12a94:	f002 ff76 	bl	15984 <strlen>
   12a98:	4603      	mov	r3, r0
   12a9a:	60fb      	str	r3, [r7, #12]
   12a9c:	e009      	b.n	12ab2 <prvWriteNameToBuffer+0x32>
		{
			pcBuffer[ x ] = ' ';
   12a9e:	687a      	ldr	r2, [r7, #4]
   12aa0:	68fb      	ldr	r3, [r7, #12]
   12aa2:	4413      	add	r3, r2
   12aa4:	f04f 0220 	mov.w	r2, #32
   12aa8:	701a      	strb	r2, [r3, #0]
		/* Start by copying the entire string. */
		strcpy( pcBuffer, pcTaskName );

		/* Pad the end of the string with spaces to ensure columns line up when
		printed out. */
		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
   12aaa:	68fb      	ldr	r3, [r7, #12]
   12aac:	f103 0301 	add.w	r3, r3, #1
   12ab0:	60fb      	str	r3, [r7, #12]
   12ab2:	68fb      	ldr	r3, [r7, #12]
   12ab4:	2b08      	cmp	r3, #8
   12ab6:	d9f2      	bls.n	12a9e <prvWriteNameToBuffer+0x1e>
		{
			pcBuffer[ x ] = ' ';
		}

		/* Terminate. */
		pcBuffer[ x ] = ( char ) 0x00;
   12ab8:	687a      	ldr	r2, [r7, #4]
   12aba:	68fb      	ldr	r3, [r7, #12]
   12abc:	4413      	add	r3, r2
   12abe:	f04f 0200 	mov.w	r2, #0
   12ac2:	701a      	strb	r2, [r3, #0]

		/* Return the new end of string. */
		return &( pcBuffer[ x ] );
   12ac4:	687a      	ldr	r2, [r7, #4]
   12ac6:	68fb      	ldr	r3, [r7, #12]
   12ac8:	4413      	add	r3, r2
	}
   12aca:	4618      	mov	r0, r3
   12acc:	f107 0710 	add.w	r7, r7, #16
   12ad0:	46bd      	mov	sp, r7
   12ad2:	bd80      	pop	{r7, pc}

00012ad4 <vTaskList>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	void vTaskList( char * pcWriteBuffer )
	{
   12ad4:	b580      	push	{r7, lr}
   12ad6:	b088      	sub	sp, #32
   12ad8:	af02      	add	r7, sp, #8
   12ada:	6078      	str	r0, [r7, #4]
		 * through a call to vTaskList().
		 */


		/* Make sure the write buffer does not contain a string. */
		*pcWriteBuffer = ( char ) 0x00;
   12adc:	687b      	ldr	r3, [r7, #4]
   12ade:	f04f 0200 	mov.w	r2, #0
   12ae2:	701a      	strb	r2, [r3, #0]

		/* Take a snapshot of the number of tasks in case it changes while this
		function is executing. */
		uxArraySize = uxCurrentNumberOfTasks;
   12ae4:	f243 03cc 	movw	r3, #12492	; 0x30cc
   12ae8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12aec:	681b      	ldr	r3, [r3, #0]
   12aee:	60fb      	str	r3, [r7, #12]

		/* Allocate an array index for each task.  NOTE!  if
		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
		equate to NULL. */
		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */
   12af0:	f243 03cc 	movw	r3, #12492	; 0x30cc
   12af4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12af8:	681a      	ldr	r2, [r3, #0]
   12afa:	4613      	mov	r3, r2
   12afc:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   12b00:	4413      	add	r3, r2
   12b02:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12b06:	4618      	mov	r0, r3
   12b08:	f001 f9e8 	bl	13edc <pvPortMalloc>
   12b0c:	4603      	mov	r3, r0
   12b0e:	60bb      	str	r3, [r7, #8]

		if( pxTaskStatusArray != NULL )
   12b10:	68bb      	ldr	r3, [r7, #8]
   12b12:	2b00      	cmp	r3, #0
   12b14:	f000 8091 	beq.w	12c3a <vTaskList+0x166>
		{
			/* Generate the (binary) data. */
			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
   12b18:	68b8      	ldr	r0, [r7, #8]
   12b1a:	68f9      	ldr	r1, [r7, #12]
   12b1c:	f04f 0200 	mov.w	r2, #0
   12b20:	f7fe feb0 	bl	11884 <uxTaskGetSystemState>
   12b24:	4603      	mov	r3, r0
   12b26:	60fb      	str	r3, [r7, #12]

			/* Create a human readable table from the binary data. */
			for( x = 0; x < uxArraySize; x++ )
   12b28:	f04f 0300 	mov.w	r3, #0
   12b2c:	613b      	str	r3, [r7, #16]
   12b2e:	e07c      	b.n	12c2a <vTaskList+0x156>
			{
				switch( pxTaskStatusArray[ x ].eCurrentState )
   12b30:	693a      	ldr	r2, [r7, #16]
   12b32:	4613      	mov	r3, r2
   12b34:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   12b38:	4413      	add	r3, r2
   12b3a:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12b3e:	461a      	mov	r2, r3
   12b40:	68bb      	ldr	r3, [r7, #8]
   12b42:	4413      	add	r3, r2
   12b44:	7b1b      	ldrb	r3, [r3, #12]
   12b46:	2b04      	cmp	r3, #4
   12b48:	d820      	bhi.n	12b8c <vTaskList+0xb8>
   12b4a:	a201      	add	r2, pc, #4	; (adr r2, 12b50 <vTaskList+0x7c>)
   12b4c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   12b50:	00012b65 	.word	0x00012b65
   12b54:	00012b6d 	.word	0x00012b6d
   12b58:	00012b75 	.word	0x00012b75
   12b5c:	00012b7d 	.word	0x00012b7d
   12b60:	00012b85 	.word	0x00012b85
				{
					case eRunning:		cStatus = tskRUNNING_CHAR;
   12b64:	f04f 0358 	mov.w	r3, #88	; 0x58
   12b68:	75fb      	strb	r3, [r7, #23]
										break;
   12b6a:	e012      	b.n	12b92 <vTaskList+0xbe>

					case eReady:		cStatus = tskREADY_CHAR;
   12b6c:	f04f 0352 	mov.w	r3, #82	; 0x52
   12b70:	75fb      	strb	r3, [r7, #23]
										break;
   12b72:	e00e      	b.n	12b92 <vTaskList+0xbe>

					case eBlocked:		cStatus = tskBLOCKED_CHAR;
   12b74:	f04f 0342 	mov.w	r3, #66	; 0x42
   12b78:	75fb      	strb	r3, [r7, #23]
										break;
   12b7a:	e00a      	b.n	12b92 <vTaskList+0xbe>

					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
   12b7c:	f04f 0353 	mov.w	r3, #83	; 0x53
   12b80:	75fb      	strb	r3, [r7, #23]
										break;
   12b82:	e006      	b.n	12b92 <vTaskList+0xbe>

					case eDeleted:		cStatus = tskDELETED_CHAR;
   12b84:	f04f 0344 	mov.w	r3, #68	; 0x44
   12b88:	75fb      	strb	r3, [r7, #23]
										break;
   12b8a:	e002      	b.n	12b92 <vTaskList+0xbe>

					case eInvalid:		/* Fall through. */
					default:			/* Should not get here, but it is included
										to prevent static checking errors. */
										cStatus = ( char ) 0x00;
   12b8c:	f04f 0300 	mov.w	r3, #0
   12b90:	75fb      	strb	r3, [r7, #23]
										break;
				}

				/* Write the task name to the string, padding with spaces so it
				can be printed in tabular form more easily. */
				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
   12b92:	693a      	ldr	r2, [r7, #16]
   12b94:	4613      	mov	r3, r2
   12b96:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   12b9a:	4413      	add	r3, r2
   12b9c:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12ba0:	461a      	mov	r2, r3
   12ba2:	68bb      	ldr	r3, [r7, #8]
   12ba4:	4413      	add	r3, r2
   12ba6:	685b      	ldr	r3, [r3, #4]
   12ba8:	6878      	ldr	r0, [r7, #4]
   12baa:	4619      	mov	r1, r3
   12bac:	f7ff ff68 	bl	12a80 <prvWriteNameToBuffer>
   12bb0:	4603      	mov	r3, r0
   12bb2:	607b      	str	r3, [r7, #4]

				/* Write the rest of the string. */
				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
   12bb4:	f897 e017 	ldrb.w	lr, [r7, #23]
   12bb8:	693a      	ldr	r2, [r7, #16]
   12bba:	4613      	mov	r3, r2
   12bbc:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   12bc0:	4413      	add	r3, r2
   12bc2:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12bc6:	461a      	mov	r2, r3
   12bc8:	68bb      	ldr	r3, [r7, #8]
   12bca:	4413      	add	r3, r2
   12bcc:	f8d3 c010 	ldr.w	ip, [r3, #16]
   12bd0:	693a      	ldr	r2, [r7, #16]
   12bd2:	4613      	mov	r3, r2
   12bd4:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   12bd8:	4413      	add	r3, r2
   12bda:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12bde:	461a      	mov	r2, r3
   12be0:	68bb      	ldr	r3, [r7, #8]
   12be2:	4413      	add	r3, r2
   12be4:	8c1b      	ldrh	r3, [r3, #32]
   12be6:	4619      	mov	r1, r3
   12be8:	693a      	ldr	r2, [r7, #16]
   12bea:	4613      	mov	r3, r2
   12bec:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   12bf0:	4413      	add	r3, r2
   12bf2:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12bf6:	461a      	mov	r2, r3
   12bf8:	68bb      	ldr	r3, [r7, #8]
   12bfa:	4413      	add	r3, r2
   12bfc:	689b      	ldr	r3, [r3, #8]
   12bfe:	9100      	str	r1, [sp, #0]
   12c00:	9301      	str	r3, [sp, #4]
   12c02:	6878      	ldr	r0, [r7, #4]
   12c04:	f64f 1110 	movw	r1, #63760	; 0xf910
   12c08:	f2c0 0102 	movt	r1, #2
   12c0c:	4672      	mov	r2, lr
   12c0e:	4663      	mov	r3, ip
   12c10:	f002 fdb0 	bl	15774 <sprintf>
				pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
   12c14:	6878      	ldr	r0, [r7, #4]
   12c16:	f002 feb5 	bl	15984 <strlen>
   12c1a:	4603      	mov	r3, r0
   12c1c:	687a      	ldr	r2, [r7, #4]
   12c1e:	4413      	add	r3, r2
   12c20:	607b      	str	r3, [r7, #4]
		{
			/* Generate the (binary) data. */
			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );

			/* Create a human readable table from the binary data. */
			for( x = 0; x < uxArraySize; x++ )
   12c22:	693b      	ldr	r3, [r7, #16]
   12c24:	f103 0301 	add.w	r3, r3, #1
   12c28:	613b      	str	r3, [r7, #16]
   12c2a:	693a      	ldr	r2, [r7, #16]
   12c2c:	68fb      	ldr	r3, [r7, #12]
   12c2e:	429a      	cmp	r2, r3
   12c30:	f4ff af7e 	bcc.w	12b30 <vTaskList+0x5c>
				pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
			}

			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
			is 0 then vPortFree() will be #defined to nothing. */
			vPortFree( pxTaskStatusArray );
   12c34:	68b8      	ldr	r0, [r7, #8]
   12c36:	f001 fa07 	bl	14048 <vPortFree>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   12c3a:	f107 0718 	add.w	r7, r7, #24
   12c3e:	46bd      	mov	sp, r7
   12c40:	bd80      	pop	{r7, pc}
   12c42:	bf00      	nop

00012c44 <vTaskGetRunTimeStats>:
/*----------------------------------------------------------*/

#if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	void vTaskGetRunTimeStats( char *pcWriteBuffer )
	{
   12c44:	b580      	push	{r7, lr}
   12c46:	b088      	sub	sp, #32
   12c48:	af00      	add	r7, sp, #0
   12c4a:	6078      	str	r0, [r7, #4]
		 * directly to get access to raw stats data, rather than indirectly
		 * through a call to vTaskGetRunTimeStats().
		 */

		/* Make sure the write buffer does not contain a string. */
		*pcWriteBuffer = ( char ) 0x00;
   12c4c:	687b      	ldr	r3, [r7, #4]
   12c4e:	f04f 0200 	mov.w	r2, #0
   12c52:	701a      	strb	r2, [r3, #0]

		/* Take a snapshot of the number of tasks in case it changes while this
		function is executing. */
		uxArraySize = uxCurrentNumberOfTasks;
   12c54:	f243 03cc 	movw	r3, #12492	; 0x30cc
   12c58:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12c5c:	681b      	ldr	r3, [r3, #0]
   12c5e:	617b      	str	r3, [r7, #20]

		/* Allocate an array index for each task.  NOTE!  If
		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
		equate to NULL. */
		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */
   12c60:	f243 03cc 	movw	r3, #12492	; 0x30cc
   12c64:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12c68:	681a      	ldr	r2, [r3, #0]
   12c6a:	4613      	mov	r3, r2
   12c6c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   12c70:	4413      	add	r3, r2
   12c72:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12c76:	4618      	mov	r0, r3
   12c78:	f001 f930 	bl	13edc <pvPortMalloc>
   12c7c:	4603      	mov	r3, r0
   12c7e:	613b      	str	r3, [r7, #16]

		if( pxTaskStatusArray != NULL )
   12c80:	693b      	ldr	r3, [r7, #16]
   12c82:	2b00      	cmp	r3, #0
   12c84:	d076      	beq.n	12d74 <vTaskGetRunTimeStats+0x130>
		{
			/* Generate the (binary) data. */
			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
   12c86:	f107 030c 	add.w	r3, r7, #12
   12c8a:	6938      	ldr	r0, [r7, #16]
   12c8c:	6979      	ldr	r1, [r7, #20]
   12c8e:	461a      	mov	r2, r3
   12c90:	f7fe fdf8 	bl	11884 <uxTaskGetSystemState>
   12c94:	4603      	mov	r3, r0
   12c96:	617b      	str	r3, [r7, #20]

			/* For percentage calculations. */
			ulTotalTime /= 100UL;
   12c98:	68fa      	ldr	r2, [r7, #12]
   12c9a:	f248 531f 	movw	r3, #34079	; 0x851f
   12c9e:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
   12ca2:	fba3 1302 	umull	r1, r3, r3, r2
   12ca6:	ea4f 1353 	mov.w	r3, r3, lsr #5
   12caa:	60fb      	str	r3, [r7, #12]

			/* Avoid divide by zero errors. */
			if( ulTotalTime > 0UL )
   12cac:	68fb      	ldr	r3, [r7, #12]
   12cae:	2b00      	cmp	r3, #0
   12cb0:	d05d      	beq.n	12d6e <vTaskGetRunTimeStats+0x12a>
			{
				/* Create a human readable table from the binary data. */
				for( x = 0; x < uxArraySize; x++ )
   12cb2:	f04f 0300 	mov.w	r3, #0
   12cb6:	61bb      	str	r3, [r7, #24]
   12cb8:	e055      	b.n	12d66 <vTaskGetRunTimeStats+0x122>
				{
					/* What percentage of the total run time has the task used?
					This will always be rounded down to the nearest integer.
					ulTotalRunTimeDiv100 has already been divided by 100. */
					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
   12cba:	69ba      	ldr	r2, [r7, #24]
   12cbc:	4613      	mov	r3, r2
   12cbe:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   12cc2:	4413      	add	r3, r2
   12cc4:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12cc8:	461a      	mov	r2, r3
   12cca:	693b      	ldr	r3, [r7, #16]
   12ccc:	4413      	add	r3, r2
   12cce:	699a      	ldr	r2, [r3, #24]
   12cd0:	68fb      	ldr	r3, [r7, #12]
   12cd2:	fbb2 f3f3 	udiv	r3, r2, r3
   12cd6:	61fb      	str	r3, [r7, #28]

					/* Write the task name to the string, padding with
					spaces so it can be printed in tabular form more
					easily. */
					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
   12cd8:	69ba      	ldr	r2, [r7, #24]
   12cda:	4613      	mov	r3, r2
   12cdc:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   12ce0:	4413      	add	r3, r2
   12ce2:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12ce6:	461a      	mov	r2, r3
   12ce8:	693b      	ldr	r3, [r7, #16]
   12cea:	4413      	add	r3, r2
   12cec:	685b      	ldr	r3, [r3, #4]
   12cee:	6878      	ldr	r0, [r7, #4]
   12cf0:	4619      	mov	r1, r3
   12cf2:	f7ff fec5 	bl	12a80 <prvWriteNameToBuffer>
   12cf6:	4603      	mov	r3, r0
   12cf8:	607b      	str	r3, [r7, #4]

					if( ulStatsAsPercentage > 0UL )
   12cfa:	69fb      	ldr	r3, [r7, #28]
   12cfc:	2b00      	cmp	r3, #0
   12cfe:	d014      	beq.n	12d2a <vTaskGetRunTimeStats+0xe6>
						}
						#else
						{
							/* sizeof( int ) == sizeof( long ) so a smaller
							printf() library can be used. */
							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
   12d00:	69ba      	ldr	r2, [r7, #24]
   12d02:	4613      	mov	r3, r2
   12d04:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   12d08:	4413      	add	r3, r2
   12d0a:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12d0e:	461a      	mov	r2, r3
   12d10:	693b      	ldr	r3, [r7, #16]
   12d12:	4413      	add	r3, r2
   12d14:	699b      	ldr	r3, [r3, #24]
   12d16:	6878      	ldr	r0, [r7, #4]
   12d18:	f64f 1120 	movw	r1, #63776	; 0xf920
   12d1c:	f2c0 0102 	movt	r1, #2
   12d20:	461a      	mov	r2, r3
   12d22:	69fb      	ldr	r3, [r7, #28]
   12d24:	f002 fd26 	bl	15774 <sprintf>
   12d28:	e012      	b.n	12d50 <vTaskGetRunTimeStats+0x10c>
						}
						#else
						{
							/* sizeof( int ) == sizeof( long ) so a smaller
							printf() library can be used. */
							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
   12d2a:	69ba      	ldr	r2, [r7, #24]
   12d2c:	4613      	mov	r3, r2
   12d2e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   12d32:	4413      	add	r3, r2
   12d34:	ea4f 0383 	mov.w	r3, r3, lsl #2
   12d38:	461a      	mov	r2, r3
   12d3a:	693b      	ldr	r3, [r7, #16]
   12d3c:	4413      	add	r3, r2
   12d3e:	699b      	ldr	r3, [r3, #24]
   12d40:	6878      	ldr	r0, [r7, #4]
   12d42:	f64f 112c 	movw	r1, #63788	; 0xf92c
   12d46:	f2c0 0102 	movt	r1, #2
   12d4a:	461a      	mov	r2, r3
   12d4c:	f002 fd12 	bl	15774 <sprintf>
						}
						#endif
					}

					pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
   12d50:	6878      	ldr	r0, [r7, #4]
   12d52:	f002 fe17 	bl	15984 <strlen>
   12d56:	4603      	mov	r3, r0
   12d58:	687a      	ldr	r2, [r7, #4]
   12d5a:	4413      	add	r3, r2
   12d5c:	607b      	str	r3, [r7, #4]

			/* Avoid divide by zero errors. */
			if( ulTotalTime > 0UL )
			{
				/* Create a human readable table from the binary data. */
				for( x = 0; x < uxArraySize; x++ )
   12d5e:	69bb      	ldr	r3, [r7, #24]
   12d60:	f103 0301 	add.w	r3, r3, #1
   12d64:	61bb      	str	r3, [r7, #24]
   12d66:	69ba      	ldr	r2, [r7, #24]
   12d68:	697b      	ldr	r3, [r7, #20]
   12d6a:	429a      	cmp	r2, r3
   12d6c:	d3a5      	bcc.n	12cba <vTaskGetRunTimeStats+0x76>
				mtCOVERAGE_TEST_MARKER();
			}

			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
			is 0 then vPortFree() will be #defined to nothing. */
			vPortFree( pxTaskStatusArray );
   12d6e:	6938      	ldr	r0, [r7, #16]
   12d70:	f001 f96a 	bl	14048 <vPortFree>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   12d74:	f107 0720 	add.w	r7, r7, #32
   12d78:	46bd      	mov	sp, r7
   12d7a:	bd80      	pop	{r7, pc}

00012d7c <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
   12d7c:	b480      	push	{r7}
   12d7e:	b083      	sub	sp, #12
   12d80:	af00      	add	r7, sp, #0
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
   12d82:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   12d86:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12d8a:	681b      	ldr	r3, [r3, #0]
   12d8c:	699b      	ldr	r3, [r3, #24]
   12d8e:	607b      	str	r3, [r7, #4]

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   12d90:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   12d94:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12d98:	681a      	ldr	r2, [r3, #0]
   12d9a:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   12d9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12da2:	681b      	ldr	r3, [r3, #0]
   12da4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   12da6:	f1c3 0305 	rsb	r3, r3, #5
   12daa:	6193      	str	r3, [r2, #24]

	return uxReturn;
   12dac:	687b      	ldr	r3, [r7, #4]
}
   12dae:	4618      	mov	r0, r3
   12db0:	f107 070c 	add.w	r7, r7, #12
   12db4:	46bd      	mov	sp, r7
   12db6:	bc80      	pop	{r7}
   12db8:	4770      	bx	lr
   12dba:	bf00      	nop

00012dbc <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
   12dbc:	b480      	push	{r7}
   12dbe:	af00      	add	r7, sp, #0
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
   12dc0:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   12dc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12dc8:	681b      	ldr	r3, [r3, #0]
   12dca:	2b00      	cmp	r3, #0
   12dcc:	d008      	beq.n	12de0 <pvTaskIncrementMutexHeldCount+0x24>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
   12dce:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   12dd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12dd6:	681b      	ldr	r3, [r3, #0]
   12dd8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
   12dda:	f102 0201 	add.w	r2, r2, #1
   12dde:	64da      	str	r2, [r3, #76]	; 0x4c
		}

		return pxCurrentTCB;
   12de0:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   12de4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12de8:	681b      	ldr	r3, [r3, #0]
	}
   12dea:	4618      	mov	r0, r3
   12dec:	46bd      	mov	sp, r7
   12dee:	bc80      	pop	{r7}
   12df0:	4770      	bx	lr
   12df2:	bf00      	nop

00012df4 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
   12df4:	b580      	push	{r7, lr}
   12df6:	b084      	sub	sp, #16
   12df8:	af00      	add	r7, sp, #0
   12dfa:	6078      	str	r0, [r7, #4]
   12dfc:	6039      	str	r1, [r7, #0]
	uint32_t ulReturn;

		taskENTER_CRITICAL();
   12dfe:	f001 faeb 	bl	143d8 <vPortEnterCritical>
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
   12e02:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   12e06:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12e0a:	681b      	ldr	r3, [r3, #0]
   12e0c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   12e0e:	2b00      	cmp	r3, #0
   12e10:	d11b      	bne.n	12e4a <ulTaskNotifyTake+0x56>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
   12e12:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   12e16:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12e1a:	681b      	ldr	r3, [r3, #0]
   12e1c:	f04f 0201 	mov.w	r2, #1
   12e20:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

				if( xTicksToWait > ( TickType_t ) 0 )
   12e24:	683b      	ldr	r3, [r7, #0]
   12e26:	2b00      	cmp	r3, #0
   12e28:	d00f      	beq.n	12e4a <ulTaskNotifyTake+0x56>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   12e2a:	6838      	ldr	r0, [r7, #0]
   12e2c:	f04f 0101 	mov.w	r1, #1
   12e30:	f000 fb3a 	bl	134a8 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
   12e34:	f64e 5304 	movw	r3, #60676	; 0xed04
   12e38:	f2ce 0300 	movt	r3, #57344	; 0xe000
   12e3c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   12e40:	601a      	str	r2, [r3, #0]
   12e42:	f3bf 8f4f 	dsb	sy
   12e46:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
   12e4a:	f001 fafd 	bl	14448 <vPortExitCritical>

		taskENTER_CRITICAL();
   12e4e:	f001 fac3 	bl	143d8 <vPortEnterCritical>
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
   12e52:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   12e56:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12e5a:	681b      	ldr	r3, [r3, #0]
   12e5c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   12e5e:	60fb      	str	r3, [r7, #12]

			if( ulReturn != 0UL )
   12e60:	68fb      	ldr	r3, [r7, #12]
   12e62:	2b00      	cmp	r3, #0
   12e64:	d014      	beq.n	12e90 <ulTaskNotifyTake+0x9c>
			{
				if( xClearCountOnExit != pdFALSE )
   12e66:	687b      	ldr	r3, [r7, #4]
   12e68:	2b00      	cmp	r3, #0
   12e6a:	d008      	beq.n	12e7e <ulTaskNotifyTake+0x8a>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
   12e6c:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   12e70:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12e74:	681b      	ldr	r3, [r3, #0]
   12e76:	f04f 0200 	mov.w	r2, #0
   12e7a:	655a      	str	r2, [r3, #84]	; 0x54
   12e7c:	e008      	b.n	12e90 <ulTaskNotifyTake+0x9c>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
   12e7e:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   12e82:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12e86:	681b      	ldr	r3, [r3, #0]
   12e88:	68fa      	ldr	r2, [r7, #12]
   12e8a:	f102 32ff 	add.w	r2, r2, #4294967295
   12e8e:	655a      	str	r2, [r3, #84]	; 0x54
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   12e90:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   12e94:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12e98:	681b      	ldr	r3, [r3, #0]
   12e9a:	f04f 0200 	mov.w	r2, #0
   12e9e:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
		}
		taskEXIT_CRITICAL();
   12ea2:	f001 fad1 	bl	14448 <vPortExitCritical>

		return ulReturn;
   12ea6:	68fb      	ldr	r3, [r7, #12]
	}
   12ea8:	4618      	mov	r0, r3
   12eaa:	f107 0710 	add.w	r7, r7, #16
   12eae:	46bd      	mov	sp, r7
   12eb0:	bd80      	pop	{r7, pc}
   12eb2:	bf00      	nop

00012eb4 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
   12eb4:	b580      	push	{r7, lr}
   12eb6:	b086      	sub	sp, #24
   12eb8:	af00      	add	r7, sp, #0
   12eba:	60f8      	str	r0, [r7, #12]
   12ebc:	60b9      	str	r1, [r7, #8]
   12ebe:	607a      	str	r2, [r7, #4]
   12ec0:	603b      	str	r3, [r7, #0]
	BaseType_t xReturn;

		taskENTER_CRITICAL();
   12ec2:	f001 fa89 	bl	143d8 <vPortEnterCritical>
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
   12ec6:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   12eca:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12ece:	681b      	ldr	r3, [r3, #0]
   12ed0:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
   12ed4:	b2db      	uxtb	r3, r3
   12ed6:	2b02      	cmp	r3, #2
   12ed8:	d027      	beq.n	12f2a <xTaskNotifyWait+0x76>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
   12eda:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   12ede:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12ee2:	681b      	ldr	r3, [r3, #0]
   12ee4:	6d59      	ldr	r1, [r3, #84]	; 0x54
   12ee6:	68fa      	ldr	r2, [r7, #12]
   12ee8:	ea6f 0202 	mvn.w	r2, r2
   12eec:	ea01 0202 	and.w	r2, r1, r2
   12ef0:	655a      	str	r2, [r3, #84]	; 0x54

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
   12ef2:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   12ef6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12efa:	681b      	ldr	r3, [r3, #0]
   12efc:	f04f 0201 	mov.w	r2, #1
   12f00:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

				if( xTicksToWait > ( TickType_t ) 0 )
   12f04:	683b      	ldr	r3, [r7, #0]
   12f06:	2b00      	cmp	r3, #0
   12f08:	d00f      	beq.n	12f2a <xTaskNotifyWait+0x76>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   12f0a:	6838      	ldr	r0, [r7, #0]
   12f0c:	f04f 0101 	mov.w	r1, #1
   12f10:	f000 faca 	bl	134a8 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
   12f14:	f64e 5304 	movw	r3, #60676	; 0xed04
   12f18:	f2ce 0300 	movt	r3, #57344	; 0xe000
   12f1c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   12f20:	601a      	str	r2, [r3, #0]
   12f22:	f3bf 8f4f 	dsb	sy
   12f26:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
   12f2a:	f001 fa8d 	bl	14448 <vPortExitCritical>

		taskENTER_CRITICAL();
   12f2e:	f001 fa53 	bl	143d8 <vPortEnterCritical>
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
   12f32:	687b      	ldr	r3, [r7, #4]
   12f34:	2b00      	cmp	r3, #0
   12f36:	d007      	beq.n	12f48 <xTaskNotifyWait+0x94>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
   12f38:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   12f3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12f40:	681b      	ldr	r3, [r3, #0]
   12f42:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   12f44:	687b      	ldr	r3, [r7, #4]
   12f46:	601a      	str	r2, [r3, #0]

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
   12f48:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   12f4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12f50:	681b      	ldr	r3, [r3, #0]
   12f52:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
   12f56:	b2db      	uxtb	r3, r3
   12f58:	2b02      	cmp	r3, #2
   12f5a:	d003      	beq.n	12f64 <xTaskNotifyWait+0xb0>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
   12f5c:	f04f 0300 	mov.w	r3, #0
   12f60:	617b      	str	r3, [r7, #20]
   12f62:	e00e      	b.n	12f82 <xTaskNotifyWait+0xce>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
   12f64:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   12f68:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12f6c:	681b      	ldr	r3, [r3, #0]
   12f6e:	6d59      	ldr	r1, [r3, #84]	; 0x54
   12f70:	68ba      	ldr	r2, [r7, #8]
   12f72:	ea6f 0202 	mvn.w	r2, r2
   12f76:	ea01 0202 	and.w	r2, r1, r2
   12f7a:	655a      	str	r2, [r3, #84]	; 0x54
				xReturn = pdTRUE;
   12f7c:	f04f 0301 	mov.w	r3, #1
   12f80:	617b      	str	r3, [r7, #20]
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   12f82:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   12f86:	f2c2 0300 	movt	r3, #8192	; 0x2000
   12f8a:	681b      	ldr	r3, [r3, #0]
   12f8c:	f04f 0200 	mov.w	r2, #0
   12f90:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
		}
		taskEXIT_CRITICAL();
   12f94:	f001 fa58 	bl	14448 <vPortExitCritical>

		return xReturn;
   12f98:	697b      	ldr	r3, [r7, #20]
	}
   12f9a:	4618      	mov	r0, r3
   12f9c:	f107 0718 	add.w	r7, r7, #24
   12fa0:	46bd      	mov	sp, r7
   12fa2:	bd80      	pop	{r7, pc}

00012fa4 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
   12fa4:	b580      	push	{r7, lr}
   12fa6:	b08a      	sub	sp, #40	; 0x28
   12fa8:	af00      	add	r7, sp, #0
   12faa:	60f8      	str	r0, [r7, #12]
   12fac:	60b9      	str	r1, [r7, #8]
   12fae:	603b      	str	r3, [r7, #0]
   12fb0:	4613      	mov	r3, r2
   12fb2:	71fb      	strb	r3, [r7, #7]
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
   12fb4:	f04f 0301 	mov.w	r3, #1
   12fb8:	617b      	str	r3, [r7, #20]
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
   12fba:	68fb      	ldr	r3, [r7, #12]
   12fbc:	2b00      	cmp	r3, #0
   12fbe:	d109      	bne.n	12fd4 <xTaskGenericNotify+0x30>
   12fc0:	f04f 0328 	mov.w	r3, #40	; 0x28
   12fc4:	f383 8811 	msr	BASEPRI, r3
   12fc8:	f3bf 8f6f 	isb	sy
   12fcc:	f3bf 8f4f 	dsb	sy
   12fd0:	61fb      	str	r3, [r7, #28]
   12fd2:	e7fe      	b.n	12fd2 <xTaskGenericNotify+0x2e>
		pxTCB = xTaskToNotify;
   12fd4:	68fb      	ldr	r3, [r7, #12]
   12fd6:	613b      	str	r3, [r7, #16]

		taskENTER_CRITICAL();
   12fd8:	f001 f9fe 	bl	143d8 <vPortEnterCritical>
		{
			if( pulPreviousNotificationValue != NULL )
   12fdc:	683b      	ldr	r3, [r7, #0]
   12fde:	2b00      	cmp	r3, #0
   12fe0:	d003      	beq.n	12fea <xTaskGenericNotify+0x46>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
   12fe2:	693b      	ldr	r3, [r7, #16]
   12fe4:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   12fe6:	683b      	ldr	r3, [r7, #0]
   12fe8:	601a      	str	r2, [r3, #0]
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
   12fea:	693b      	ldr	r3, [r7, #16]
   12fec:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
   12ff0:	76fb      	strb	r3, [r7, #27]

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   12ff2:	693b      	ldr	r3, [r7, #16]
   12ff4:	f04f 0202 	mov.w	r2, #2
   12ff8:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

			switch( eAction )
   12ffc:	79fb      	ldrb	r3, [r7, #7]
   12ffe:	2b04      	cmp	r3, #4
   13000:	d82a      	bhi.n	13058 <xTaskGenericNotify+0xb4>
   13002:	a201      	add	r2, pc, #4	; (adr r2, 13008 <xTaskGenericNotify+0x64>)
   13004:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   13008:	00013077 	.word	0x00013077
   1300c:	0001301d 	.word	0x0001301d
   13010:	0001302d 	.word	0x0001302d
   13014:	0001303b 	.word	0x0001303b
   13018:	00013043 	.word	0x00013043
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
   1301c:	693b      	ldr	r3, [r7, #16]
   1301e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   13020:	68bb      	ldr	r3, [r7, #8]
   13022:	ea42 0203 	orr.w	r2, r2, r3
   13026:	693b      	ldr	r3, [r7, #16]
   13028:	655a      	str	r2, [r3, #84]	; 0x54
					break;
   1302a:	e025      	b.n	13078 <xTaskGenericNotify+0xd4>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
   1302c:	693b      	ldr	r3, [r7, #16]
   1302e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   13030:	f103 0201 	add.w	r2, r3, #1
   13034:	693b      	ldr	r3, [r7, #16]
   13036:	655a      	str	r2, [r3, #84]	; 0x54
					break;
   13038:	e01e      	b.n	13078 <xTaskGenericNotify+0xd4>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
   1303a:	693b      	ldr	r3, [r7, #16]
   1303c:	68ba      	ldr	r2, [r7, #8]
   1303e:	655a      	str	r2, [r3, #84]	; 0x54
					break;
   13040:	e01a      	b.n	13078 <xTaskGenericNotify+0xd4>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
   13042:	7efb      	ldrb	r3, [r7, #27]
   13044:	2b02      	cmp	r3, #2
   13046:	d003      	beq.n	13050 <xTaskGenericNotify+0xac>
					{
						pxTCB->ulNotifiedValue = ulValue;
   13048:	693b      	ldr	r3, [r7, #16]
   1304a:	68ba      	ldr	r2, [r7, #8]
   1304c:	655a      	str	r2, [r3, #84]	; 0x54
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
   1304e:	e013      	b.n	13078 <xTaskGenericNotify+0xd4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
   13050:	f04f 0300 	mov.w	r3, #0
   13054:	617b      	str	r3, [r7, #20]
					}
					break;
   13056:	e00f      	b.n	13078 <xTaskGenericNotify+0xd4>

				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
   13058:	693b      	ldr	r3, [r7, #16]
   1305a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   1305c:	f1b3 3fff 	cmp.w	r3, #4294967295
   13060:	d00a      	beq.n	13078 <xTaskGenericNotify+0xd4>
   13062:	f04f 0328 	mov.w	r3, #40	; 0x28
   13066:	f383 8811 	msr	BASEPRI, r3
   1306a:	f3bf 8f6f 	isb	sy
   1306e:	f3bf 8f4f 	dsb	sy
   13072:	623b      	str	r3, [r7, #32]
   13074:	e7fe      	b.n	13074 <xTaskGenericNotify+0xd0>
					break;

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
   13076:	bf00      	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   13078:	7efb      	ldrb	r3, [r7, #27]
   1307a:	2b01      	cmp	r3, #1
   1307c:	d14f      	bne.n	1311e <xTaskGenericNotify+0x17a>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   1307e:	693b      	ldr	r3, [r7, #16]
   13080:	f103 0304 	add.w	r3, r3, #4
   13084:	4618      	mov	r0, r3
   13086:	f7fc f967 	bl	f358 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
   1308a:	693b      	ldr	r3, [r7, #16]
   1308c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1308e:	f04f 0201 	mov.w	r2, #1
   13092:	fa02 f203 	lsl.w	r2, r2, r3
   13096:	f243 03d4 	movw	r3, #12500	; 0x30d4
   1309a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1309e:	681b      	ldr	r3, [r3, #0]
   130a0:	ea42 0203 	orr.w	r2, r2, r3
   130a4:	f243 03d4 	movw	r3, #12500	; 0x30d4
   130a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   130ac:	601a      	str	r2, [r3, #0]
   130ae:	693b      	ldr	r3, [r7, #16]
   130b0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   130b2:	4613      	mov	r3, r2
   130b4:	ea4f 0383 	mov.w	r3, r3, lsl #2
   130b8:	4413      	add	r3, r2
   130ba:	ea4f 0383 	mov.w	r3, r3, lsl #2
   130be:	461a      	mov	r2, r3
   130c0:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   130c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   130c8:	441a      	add	r2, r3
   130ca:	693b      	ldr	r3, [r7, #16]
   130cc:	f103 0304 	add.w	r3, r3, #4
   130d0:	4610      	mov	r0, r2
   130d2:	4619      	mov	r1, r3
   130d4:	f7fc f8e2 	bl	f29c <vListInsertEnd>

				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   130d8:	693b      	ldr	r3, [r7, #16]
   130da:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   130dc:	2b00      	cmp	r3, #0
   130de:	d009      	beq.n	130f4 <xTaskGenericNotify+0x150>
   130e0:	f04f 0328 	mov.w	r3, #40	; 0x28
   130e4:	f383 8811 	msr	BASEPRI, r3
   130e8:	f3bf 8f6f 	isb	sy
   130ec:	f3bf 8f4f 	dsb	sy
   130f0:	627b      	str	r3, [r7, #36]	; 0x24
   130f2:	e7fe      	b.n	130f2 <xTaskGenericNotify+0x14e>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   130f4:	693b      	ldr	r3, [r7, #16]
   130f6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   130f8:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   130fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13100:	681b      	ldr	r3, [r3, #0]
   13102:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13104:	429a      	cmp	r2, r3
   13106:	d90a      	bls.n	1311e <xTaskGenericNotify+0x17a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
   13108:	f64e 5304 	movw	r3, #60676	; 0xed04
   1310c:	f2ce 0300 	movt	r3, #57344	; 0xe000
   13110:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   13114:	601a      	str	r2, [r3, #0]
   13116:	f3bf 8f4f 	dsb	sy
   1311a:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
   1311e:	f001 f993 	bl	14448 <vPortExitCritical>

		return xReturn;
   13122:	697b      	ldr	r3, [r7, #20]
	}
   13124:	4618      	mov	r0, r3
   13126:	f107 0728 	add.w	r7, r7, #40	; 0x28
   1312a:	46bd      	mov	sp, r7
   1312c:	bd80      	pop	{r7, pc}
   1312e:	bf00      	nop

00013130 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
   13130:	b580      	push	{r7, lr}
   13132:	b08e      	sub	sp, #56	; 0x38
   13134:	af00      	add	r7, sp, #0
   13136:	60f8      	str	r0, [r7, #12]
   13138:	60b9      	str	r1, [r7, #8]
   1313a:	603b      	str	r3, [r7, #0]
   1313c:	4613      	mov	r3, r2
   1313e:	71fb      	strb	r3, [r7, #7]
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
   13140:	f04f 0301 	mov.w	r3, #1
   13144:	61bb      	str	r3, [r7, #24]
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
   13146:	68fb      	ldr	r3, [r7, #12]
   13148:	2b00      	cmp	r3, #0
   1314a:	d109      	bne.n	13160 <xTaskGenericNotifyFromISR+0x30>
   1314c:	f04f 0328 	mov.w	r3, #40	; 0x28
   13150:	f383 8811 	msr	BASEPRI, r3
   13154:	f3bf 8f6f 	isb	sy
   13158:	f3bf 8f4f 	dsb	sy
   1315c:	623b      	str	r3, [r7, #32]
   1315e:	e7fe      	b.n	1315e <xTaskGenericNotifyFromISR+0x2e>
		below the maximum system call interrupt priority.  FreeRTOS maintains a
		separate interrupt safe API to ensure interrupt entry is as fast and as
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   13160:	f001 fa1e 	bl	145a0 <vPortValidateInterruptPriority>

		pxTCB = xTaskToNotify;
   13164:	68fb      	ldr	r3, [r7, #12]
   13166:	613b      	str	r3, [r7, #16]

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
   13168:	f3ef 8211 	mrs	r2, BASEPRI
   1316c:	f04f 0328 	mov.w	r3, #40	; 0x28
   13170:	f383 8811 	msr	BASEPRI, r3
   13174:	f3bf 8f6f 	isb	sy
   13178:	f3bf 8f4f 	dsb	sy
   1317c:	62ba      	str	r2, [r7, #40]	; 0x28
   1317e:	627b      	str	r3, [r7, #36]	; 0x24
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
   13180:	6abb      	ldr	r3, [r7, #40]	; 0x28

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   13182:	61fb      	str	r3, [r7, #28]
		{
			if( pulPreviousNotificationValue != NULL )
   13184:	683b      	ldr	r3, [r7, #0]
   13186:	2b00      	cmp	r3, #0
   13188:	d003      	beq.n	13192 <xTaskGenericNotifyFromISR+0x62>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
   1318a:	693b      	ldr	r3, [r7, #16]
   1318c:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   1318e:	683b      	ldr	r3, [r7, #0]
   13190:	601a      	str	r2, [r3, #0]
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
   13192:	693b      	ldr	r3, [r7, #16]
   13194:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
   13198:	75fb      	strb	r3, [r7, #23]
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   1319a:	693b      	ldr	r3, [r7, #16]
   1319c:	f04f 0202 	mov.w	r2, #2
   131a0:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

			switch( eAction )
   131a4:	79fb      	ldrb	r3, [r7, #7]
   131a6:	2b04      	cmp	r3, #4
   131a8:	d82a      	bhi.n	13200 <xTaskGenericNotifyFromISR+0xd0>
   131aa:	a201      	add	r2, pc, #4	; (adr r2, 131b0 <xTaskGenericNotifyFromISR+0x80>)
   131ac:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   131b0:	0001321f 	.word	0x0001321f
   131b4:	000131c5 	.word	0x000131c5
   131b8:	000131d5 	.word	0x000131d5
   131bc:	000131e3 	.word	0x000131e3
   131c0:	000131eb 	.word	0x000131eb
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
   131c4:	693b      	ldr	r3, [r7, #16]
   131c6:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   131c8:	68bb      	ldr	r3, [r7, #8]
   131ca:	ea42 0203 	orr.w	r2, r2, r3
   131ce:	693b      	ldr	r3, [r7, #16]
   131d0:	655a      	str	r2, [r3, #84]	; 0x54
					break;
   131d2:	e025      	b.n	13220 <xTaskGenericNotifyFromISR+0xf0>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
   131d4:	693b      	ldr	r3, [r7, #16]
   131d6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   131d8:	f103 0201 	add.w	r2, r3, #1
   131dc:	693b      	ldr	r3, [r7, #16]
   131de:	655a      	str	r2, [r3, #84]	; 0x54
					break;
   131e0:	e01e      	b.n	13220 <xTaskGenericNotifyFromISR+0xf0>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
   131e2:	693b      	ldr	r3, [r7, #16]
   131e4:	68ba      	ldr	r2, [r7, #8]
   131e6:	655a      	str	r2, [r3, #84]	; 0x54
					break;
   131e8:	e01a      	b.n	13220 <xTaskGenericNotifyFromISR+0xf0>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
   131ea:	7dfb      	ldrb	r3, [r7, #23]
   131ec:	2b02      	cmp	r3, #2
   131ee:	d003      	beq.n	131f8 <xTaskGenericNotifyFromISR+0xc8>
					{
						pxTCB->ulNotifiedValue = ulValue;
   131f0:	693b      	ldr	r3, [r7, #16]
   131f2:	68ba      	ldr	r2, [r7, #8]
   131f4:	655a      	str	r2, [r3, #84]	; 0x54
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
   131f6:	e013      	b.n	13220 <xTaskGenericNotifyFromISR+0xf0>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
   131f8:	f04f 0300 	mov.w	r3, #0
   131fc:	61bb      	str	r3, [r7, #24]
					}
					break;
   131fe:	e00f      	b.n	13220 <xTaskGenericNotifyFromISR+0xf0>

				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
   13200:	693b      	ldr	r3, [r7, #16]
   13202:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   13204:	f1b3 3fff 	cmp.w	r3, #4294967295
   13208:	d00a      	beq.n	13220 <xTaskGenericNotifyFromISR+0xf0>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   1320a:	f04f 0328 	mov.w	r3, #40	; 0x28
   1320e:	f383 8811 	msr	BASEPRI, r3
   13212:	f3bf 8f6f 	isb	sy
   13216:	f3bf 8f4f 	dsb	sy
   1321a:	62fb      	str	r3, [r7, #44]	; 0x2c
   1321c:	e7fe      	b.n	1321c <xTaskGenericNotifyFromISR+0xec>
					break;

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
   1321e:	bf00      	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   13220:	7dfb      	ldrb	r3, [r7, #23]
   13222:	2b01      	cmp	r3, #1
   13224:	d164      	bne.n	132f0 <xTaskGenericNotifyFromISR+0x1c0>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   13226:	693b      	ldr	r3, [r7, #16]
   13228:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1322a:	2b00      	cmp	r3, #0
   1322c:	d009      	beq.n	13242 <xTaskGenericNotifyFromISR+0x112>
   1322e:	f04f 0328 	mov.w	r3, #40	; 0x28
   13232:	f383 8811 	msr	BASEPRI, r3
   13236:	f3bf 8f6f 	isb	sy
   1323a:	f3bf 8f4f 	dsb	sy
   1323e:	633b      	str	r3, [r7, #48]	; 0x30
   13240:	e7fe      	b.n	13240 <xTaskGenericNotifyFromISR+0x110>

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   13242:	f243 03f4 	movw	r3, #12532	; 0x30f4
   13246:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1324a:	681b      	ldr	r3, [r3, #0]
   1324c:	2b00      	cmp	r3, #0
   1324e:	d12d      	bne.n	132ac <xTaskGenericNotifyFromISR+0x17c>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   13250:	693b      	ldr	r3, [r7, #16]
   13252:	f103 0304 	add.w	r3, r3, #4
   13256:	4618      	mov	r0, r3
   13258:	f7fc f87e 	bl	f358 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   1325c:	693b      	ldr	r3, [r7, #16]
   1325e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13260:	f04f 0201 	mov.w	r2, #1
   13264:	fa02 f203 	lsl.w	r2, r2, r3
   13268:	f243 03d4 	movw	r3, #12500	; 0x30d4
   1326c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13270:	681b      	ldr	r3, [r3, #0]
   13272:	ea42 0203 	orr.w	r2, r2, r3
   13276:	f243 03d4 	movw	r3, #12500	; 0x30d4
   1327a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1327e:	601a      	str	r2, [r3, #0]
   13280:	693b      	ldr	r3, [r7, #16]
   13282:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13284:	4613      	mov	r3, r2
   13286:	ea4f 0383 	mov.w	r3, r3, lsl #2
   1328a:	4413      	add	r3, r2
   1328c:	ea4f 0383 	mov.w	r3, r3, lsl #2
   13290:	461a      	mov	r2, r3
   13292:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   13296:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1329a:	441a      	add	r2, r3
   1329c:	693b      	ldr	r3, [r7, #16]
   1329e:	f103 0304 	add.w	r3, r3, #4
   132a2:	4610      	mov	r0, r2
   132a4:	4619      	mov	r1, r3
   132a6:	f7fb fff9 	bl	f29c <vListInsertEnd>
   132aa:	e009      	b.n	132c0 <xTaskGenericNotifyFromISR+0x190>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   132ac:	693b      	ldr	r3, [r7, #16]
   132ae:	f103 0318 	add.w	r3, r3, #24
   132b2:	f243 008c 	movw	r0, #12428	; 0x308c
   132b6:	f2c2 0000 	movt	r0, #8192	; 0x2000
   132ba:	4619      	mov	r1, r3
   132bc:	f7fb ffee 	bl	f29c <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   132c0:	693b      	ldr	r3, [r7, #16]
   132c2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   132c4:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   132c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   132cc:	681b      	ldr	r3, [r3, #0]
   132ce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   132d0:	429a      	cmp	r2, r3
   132d2:	d90d      	bls.n	132f0 <xTaskGenericNotifyFromISR+0x1c0>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
   132d4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   132d6:	2b00      	cmp	r3, #0
   132d8:	d003      	beq.n	132e2 <xTaskGenericNotifyFromISR+0x1b2>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
   132da:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   132dc:	f04f 0201 	mov.w	r2, #1
   132e0:	601a      	str	r2, [r3, #0]
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
   132e2:	f243 03e0 	movw	r3, #12512	; 0x30e0
   132e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   132ea:	f04f 0201 	mov.w	r2, #1
   132ee:	601a      	str	r2, [r3, #0]
   132f0:	69fb      	ldr	r3, [r7, #28]
   132f2:	637b      	str	r3, [r7, #52]	; 0x34
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   132f4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   132f6:	f383 8811 	msr	BASEPRI, r3
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
   132fa:	69bb      	ldr	r3, [r7, #24]
	}
   132fc:	4618      	mov	r0, r3
   132fe:	f107 0738 	add.w	r7, r7, #56	; 0x38
   13302:	46bd      	mov	sp, r7
   13304:	bd80      	pop	{r7, pc}
   13306:	bf00      	nop

00013308 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
   13308:	b580      	push	{r7, lr}
   1330a:	b08a      	sub	sp, #40	; 0x28
   1330c:	af00      	add	r7, sp, #0
   1330e:	6078      	str	r0, [r7, #4]
   13310:	6039      	str	r1, [r7, #0]
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
   13312:	687b      	ldr	r3, [r7, #4]
   13314:	2b00      	cmp	r3, #0
   13316:	d109      	bne.n	1332c <vTaskNotifyGiveFromISR+0x24>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   13318:	f04f 0328 	mov.w	r3, #40	; 0x28
   1331c:	f383 8811 	msr	BASEPRI, r3
   13320:	f3bf 8f6f 	isb	sy
   13324:	f3bf 8f4f 	dsb	sy
   13328:	617b      	str	r3, [r7, #20]
   1332a:	e7fe      	b.n	1332a <vTaskNotifyGiveFromISR+0x22>
		below the maximum system call interrupt priority.  FreeRTOS maintains a
		separate interrupt safe API to ensure interrupt entry is as fast and as
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1332c:	f001 f938 	bl	145a0 <vPortValidateInterruptPriority>

		pxTCB = xTaskToNotify;
   13330:	687b      	ldr	r3, [r7, #4]
   13332:	60bb      	str	r3, [r7, #8]

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
   13334:	f3ef 8211 	mrs	r2, BASEPRI
   13338:	f04f 0328 	mov.w	r3, #40	; 0x28
   1333c:	f383 8811 	msr	BASEPRI, r3
   13340:	f3bf 8f6f 	isb	sy
   13344:	f3bf 8f4f 	dsb	sy
   13348:	61fa      	str	r2, [r7, #28]
   1334a:	61bb      	str	r3, [r7, #24]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
   1334c:	69fb      	ldr	r3, [r7, #28]

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   1334e:	613b      	str	r3, [r7, #16]
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
   13350:	68bb      	ldr	r3, [r7, #8]
   13352:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
   13356:	73fb      	strb	r3, [r7, #15]
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   13358:	68bb      	ldr	r3, [r7, #8]
   1335a:	f04f 0202 	mov.w	r2, #2
   1335e:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
   13362:	68bb      	ldr	r3, [r7, #8]
   13364:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   13366:	f103 0201 	add.w	r2, r3, #1
   1336a:	68bb      	ldr	r3, [r7, #8]
   1336c:	655a      	str	r2, [r3, #84]	; 0x54

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   1336e:	7bfb      	ldrb	r3, [r7, #15]
   13370:	2b01      	cmp	r3, #1
   13372:	d164      	bne.n	1343e <vTaskNotifyGiveFromISR+0x136>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   13374:	68bb      	ldr	r3, [r7, #8]
   13376:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   13378:	2b00      	cmp	r3, #0
   1337a:	d009      	beq.n	13390 <vTaskNotifyGiveFromISR+0x88>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   1337c:	f04f 0328 	mov.w	r3, #40	; 0x28
   13380:	f383 8811 	msr	BASEPRI, r3
   13384:	f3bf 8f6f 	isb	sy
   13388:	f3bf 8f4f 	dsb	sy
   1338c:	623b      	str	r3, [r7, #32]
   1338e:	e7fe      	b.n	1338e <vTaskNotifyGiveFromISR+0x86>

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   13390:	f243 03f4 	movw	r3, #12532	; 0x30f4
   13394:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13398:	681b      	ldr	r3, [r3, #0]
   1339a:	2b00      	cmp	r3, #0
   1339c:	d12d      	bne.n	133fa <vTaskNotifyGiveFromISR+0xf2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   1339e:	68bb      	ldr	r3, [r7, #8]
   133a0:	f103 0304 	add.w	r3, r3, #4
   133a4:	4618      	mov	r0, r3
   133a6:	f7fb ffd7 	bl	f358 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   133aa:	68bb      	ldr	r3, [r7, #8]
   133ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   133ae:	f04f 0201 	mov.w	r2, #1
   133b2:	fa02 f203 	lsl.w	r2, r2, r3
   133b6:	f243 03d4 	movw	r3, #12500	; 0x30d4
   133ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
   133be:	681b      	ldr	r3, [r3, #0]
   133c0:	ea42 0203 	orr.w	r2, r2, r3
   133c4:	f243 03d4 	movw	r3, #12500	; 0x30d4
   133c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   133cc:	601a      	str	r2, [r3, #0]
   133ce:	68bb      	ldr	r3, [r7, #8]
   133d0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   133d2:	4613      	mov	r3, r2
   133d4:	ea4f 0383 	mov.w	r3, r3, lsl #2
   133d8:	4413      	add	r3, r2
   133da:	ea4f 0383 	mov.w	r3, r3, lsl #2
   133de:	461a      	mov	r2, r3
   133e0:	f642 73f8 	movw	r3, #12280	; 0x2ff8
   133e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   133e8:	441a      	add	r2, r3
   133ea:	68bb      	ldr	r3, [r7, #8]
   133ec:	f103 0304 	add.w	r3, r3, #4
   133f0:	4610      	mov	r0, r2
   133f2:	4619      	mov	r1, r3
   133f4:	f7fb ff52 	bl	f29c <vListInsertEnd>
   133f8:	e009      	b.n	1340e <vTaskNotifyGiveFromISR+0x106>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   133fa:	68bb      	ldr	r3, [r7, #8]
   133fc:	f103 0318 	add.w	r3, r3, #24
   13400:	f243 008c 	movw	r0, #12428	; 0x308c
   13404:	f2c2 0000 	movt	r0, #8192	; 0x2000
   13408:	4619      	mov	r1, r3
   1340a:	f7fb ff47 	bl	f29c <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   1340e:	68bb      	ldr	r3, [r7, #8]
   13410:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13412:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   13416:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1341a:	681b      	ldr	r3, [r3, #0]
   1341c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1341e:	429a      	cmp	r2, r3
   13420:	d90d      	bls.n	1343e <vTaskNotifyGiveFromISR+0x136>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
   13422:	683b      	ldr	r3, [r7, #0]
   13424:	2b00      	cmp	r3, #0
   13426:	d003      	beq.n	13430 <vTaskNotifyGiveFromISR+0x128>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
   13428:	683b      	ldr	r3, [r7, #0]
   1342a:	f04f 0201 	mov.w	r2, #1
   1342e:	601a      	str	r2, [r3, #0]
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
   13430:	f243 03e0 	movw	r3, #12512	; 0x30e0
   13434:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13438:	f04f 0201 	mov.w	r2, #1
   1343c:	601a      	str	r2, [r3, #0]
   1343e:	693b      	ldr	r3, [r7, #16]
   13440:	627b      	str	r3, [r7, #36]	; 0x24
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   13442:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   13444:	f383 8811 	msr	BASEPRI, r3
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
   13448:	f107 0728 	add.w	r7, r7, #40	; 0x28
   1344c:	46bd      	mov	sp, r7
   1344e:	bd80      	pop	{r7, pc}

00013450 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
   13450:	b580      	push	{r7, lr}
   13452:	b084      	sub	sp, #16
   13454:	af00      	add	r7, sp, #0
   13456:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
   13458:	687b      	ldr	r3, [r7, #4]
   1345a:	2b00      	cmp	r3, #0
   1345c:	d105      	bne.n	1346a <xTaskNotifyStateClear+0x1a>
   1345e:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   13462:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13466:	681b      	ldr	r3, [r3, #0]
   13468:	e000      	b.n	1346c <xTaskNotifyStateClear+0x1c>
   1346a:	687b      	ldr	r3, [r7, #4]
   1346c:	60bb      	str	r3, [r7, #8]

		taskENTER_CRITICAL();
   1346e:	f000 ffb3 	bl	143d8 <vPortEnterCritical>
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
   13472:	68bb      	ldr	r3, [r7, #8]
   13474:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
   13478:	b2db      	uxtb	r3, r3
   1347a:	2b02      	cmp	r3, #2
   1347c:	d108      	bne.n	13490 <xTaskNotifyStateClear+0x40>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   1347e:	68bb      	ldr	r3, [r7, #8]
   13480:	f04f 0200 	mov.w	r2, #0
   13484:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
				xReturn = pdPASS;
   13488:	f04f 0301 	mov.w	r3, #1
   1348c:	60fb      	str	r3, [r7, #12]
   1348e:	e002      	b.n	13496 <xTaskNotifyStateClear+0x46>
			}
			else
			{
				xReturn = pdFAIL;
   13490:	f04f 0300 	mov.w	r3, #0
   13494:	60fb      	str	r3, [r7, #12]
			}
		}
		taskEXIT_CRITICAL();
   13496:	f000 ffd7 	bl	14448 <vPortExitCritical>

		return xReturn;
   1349a:	68fb      	ldr	r3, [r7, #12]
	}
   1349c:	4618      	mov	r0, r3
   1349e:	f107 0710 	add.w	r7, r7, #16
   134a2:	46bd      	mov	sp, r7
   134a4:	bd80      	pop	{r7, pc}
   134a6:	bf00      	nop

000134a8 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
   134a8:	b580      	push	{r7, lr}
   134aa:	b084      	sub	sp, #16
   134ac:	af00      	add	r7, sp, #0
   134ae:	6078      	str	r0, [r7, #4]
   134b0:	6039      	str	r1, [r7, #0]
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
   134b2:	f243 03d0 	movw	r3, #12496	; 0x30d0
   134b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   134ba:	681b      	ldr	r3, [r3, #0]
   134bc:	60fb      	str	r3, [r7, #12]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   134be:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   134c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   134c6:	681b      	ldr	r3, [r3, #0]
   134c8:	f103 0304 	add.w	r3, r3, #4
   134cc:	4618      	mov	r0, r3
   134ce:	f7fb ff43 	bl	f358 <uxListRemove>
   134d2:	4603      	mov	r3, r0
   134d4:	2b00      	cmp	r3, #0
   134d6:	d117      	bne.n	13508 <prvAddCurrentTaskToDelayedList+0x60>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
   134d8:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   134dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   134e0:	681b      	ldr	r3, [r3, #0]
   134e2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   134e4:	f04f 0201 	mov.w	r2, #1
   134e8:	fa02 f303 	lsl.w	r3, r2, r3
   134ec:	ea6f 0203 	mvn.w	r2, r3
   134f0:	f243 03d4 	movw	r3, #12500	; 0x30d4
   134f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   134f8:	681b      	ldr	r3, [r3, #0]
   134fa:	ea02 0203 	and.w	r2, r2, r3
   134fe:	f243 03d4 	movw	r3, #12500	; 0x30d4
   13502:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13506:	601a      	str	r2, [r3, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   13508:	687b      	ldr	r3, [r7, #4]
   1350a:	f1b3 3fff 	cmp.w	r3, #4294967295
   1350e:	d111      	bne.n	13534 <prvAddCurrentTaskToDelayedList+0x8c>
   13510:	683b      	ldr	r3, [r7, #0]
   13512:	2b00      	cmp	r3, #0
   13514:	d00e      	beq.n	13534 <prvAddCurrentTaskToDelayedList+0x8c>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
   13516:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   1351a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1351e:	681b      	ldr	r3, [r3, #0]
   13520:	f103 0304 	add.w	r3, r3, #4
   13524:	f243 00b8 	movw	r0, #12472	; 0x30b8
   13528:	f2c2 0000 	movt	r0, #8192	; 0x2000
   1352c:	4619      	mov	r1, r3
   1352e:	f7fb feb5 	bl	f29c <vListInsertEnd>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   13532:	e03d      	b.n	135b0 <prvAddCurrentTaskToDelayedList+0x108>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
   13534:	68fa      	ldr	r2, [r7, #12]
   13536:	687b      	ldr	r3, [r7, #4]
   13538:	4413      	add	r3, r2
   1353a:	60bb      	str	r3, [r7, #8]

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   1353c:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   13540:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13544:	681b      	ldr	r3, [r3, #0]
   13546:	68ba      	ldr	r2, [r7, #8]
   13548:	605a      	str	r2, [r3, #4]

			if( xTimeToWake < xConstTickCount )
   1354a:	68ba      	ldr	r2, [r7, #8]
   1354c:	68fb      	ldr	r3, [r7, #12]
   1354e:	429a      	cmp	r2, r3
   13550:	d210      	bcs.n	13574 <prvAddCurrentTaskToDelayedList+0xcc>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   13552:	f243 0388 	movw	r3, #12424	; 0x3088
   13556:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1355a:	681a      	ldr	r2, [r3, #0]
   1355c:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   13560:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13564:	681b      	ldr	r3, [r3, #0]
   13566:	f103 0304 	add.w	r3, r3, #4
   1356a:	4610      	mov	r0, r2
   1356c:	4619      	mov	r1, r3
   1356e:	f7fb feb9 	bl	f2e4 <vListInsert>
   13572:	e01d      	b.n	135b0 <prvAddCurrentTaskToDelayedList+0x108>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   13574:	f243 0384 	movw	r3, #12420	; 0x3084
   13578:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1357c:	681a      	ldr	r2, [r3, #0]
   1357e:	f642 73f4 	movw	r3, #12276	; 0x2ff4
   13582:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13586:	681b      	ldr	r3, [r3, #0]
   13588:	f103 0304 	add.w	r3, r3, #4
   1358c:	4610      	mov	r0, r2
   1358e:	4619      	mov	r1, r3
   13590:	f7fb fea8 	bl	f2e4 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
   13594:	f243 03ec 	movw	r3, #12524	; 0x30ec
   13598:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1359c:	681b      	ldr	r3, [r3, #0]
   1359e:	68ba      	ldr	r2, [r7, #8]
   135a0:	429a      	cmp	r2, r3
   135a2:	d205      	bcs.n	135b0 <prvAddCurrentTaskToDelayedList+0x108>
				{
					xNextTaskUnblockTime = xTimeToWake;
   135a4:	f243 03ec 	movw	r3, #12524	; 0x30ec
   135a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   135ac:	68ba      	ldr	r2, [r7, #8]
   135ae:	601a      	str	r2, [r3, #0]

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
   135b0:	f107 0710 	add.w	r7, r7, #16
   135b4:	46bd      	mov	sp, r7
   135b6:	bd80      	pop	{r7, pc}

000135b8 <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
   135b8:	b580      	push	{r7, lr}
   135ba:	b084      	sub	sp, #16
   135bc:	af02      	add	r7, sp, #8
BaseType_t xReturn = pdFAIL;
   135be:	f04f 0300 	mov.w	r3, #0
   135c2:	603b      	str	r3, [r7, #0]

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
   135c4:	f000 fbce 	bl	13d64 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
   135c8:	f243 1330 	movw	r3, #12592	; 0x3130
   135cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   135d0:	681b      	ldr	r3, [r3, #0]
   135d2:	2b00      	cmp	r3, #0
   135d4:	d017      	beq.n	13606 <xTimerCreateTimerTask+0x4e>
				xReturn = pdPASS;
			}
		}
		#else
		{
			xReturn = xTaskCreate(	prvTimerTask,
   135d6:	f04f 0302 	mov.w	r3, #2
   135da:	9300      	str	r3, [sp, #0]
   135dc:	f243 1334 	movw	r3, #12596	; 0x3134
   135e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   135e4:	9301      	str	r3, [sp, #4]
   135e6:	f643 1015 	movw	r0, #14613	; 0x3915
   135ea:	f2c0 0001 	movt	r0, #1
   135ee:	f64f 1138 	movw	r1, #63800	; 0xf938
   135f2:	f2c0 0102 	movt	r1, #2
   135f6:	f04f 02b4 	mov.w	r2, #180	; 0xb4
   135fa:	f04f 0300 	mov.w	r3, #0
   135fe:	f7fd f925 	bl	1084c <xTaskCreate>
   13602:	4603      	mov	r3, r0
   13604:	603b      	str	r3, [r7, #0]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
   13606:	683b      	ldr	r3, [r7, #0]
   13608:	2b00      	cmp	r3, #0
   1360a:	d109      	bne.n	13620 <xTimerCreateTimerTask+0x68>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   1360c:	f04f 0328 	mov.w	r3, #40	; 0x28
   13610:	f383 8811 	msr	BASEPRI, r3
   13614:	f3bf 8f6f 	isb	sy
   13618:	f3bf 8f4f 	dsb	sy
   1361c:	607b      	str	r3, [r7, #4]
   1361e:	e7fe      	b.n	1361e <xTimerCreateTimerTask+0x66>
	return xReturn;
   13620:	683b      	ldr	r3, [r7, #0]
}
   13622:	4618      	mov	r0, r3
   13624:	f107 0708 	add.w	r7, r7, #8
   13628:	46bd      	mov	sp, r7
   1362a:	bd80      	pop	{r7, pc}

0001362c <xTimerCreate>:
	TimerHandle_t xTimerCreate(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
								const TickType_t xTimerPeriodInTicks,
								const UBaseType_t uxAutoReload,
								void * const pvTimerID,
								TimerCallbackFunction_t pxCallbackFunction )
	{
   1362c:	b580      	push	{r7, lr}
   1362e:	b088      	sub	sp, #32
   13630:	af02      	add	r7, sp, #8
   13632:	60f8      	str	r0, [r7, #12]
   13634:	60b9      	str	r1, [r7, #8]
   13636:	607a      	str	r2, [r7, #4]
   13638:	603b      	str	r3, [r7, #0]
	Timer_t *pxNewTimer;

		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
   1363a:	f04f 002c 	mov.w	r0, #44	; 0x2c
   1363e:	f000 fc4d 	bl	13edc <pvPortMalloc>
   13642:	4603      	mov	r3, r0
   13644:	617b      	str	r3, [r7, #20]

		if( pxNewTimer != NULL )
   13646:	697b      	ldr	r3, [r7, #20]
   13648:	2b00      	cmp	r3, #0
   1364a:	d009      	beq.n	13660 <xTimerCreate+0x34>
		{
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
   1364c:	6a3b      	ldr	r3, [r7, #32]
   1364e:	9300      	str	r3, [sp, #0]
   13650:	697b      	ldr	r3, [r7, #20]
   13652:	9301      	str	r3, [sp, #4]
   13654:	68f8      	ldr	r0, [r7, #12]
   13656:	68b9      	ldr	r1, [r7, #8]
   13658:	687a      	ldr	r2, [r7, #4]
   1365a:	683b      	ldr	r3, [r7, #0]
   1365c:	f000 f806 	bl	1366c <prvInitialiseNewTimer>
				pxNewTimer->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */
		}

		return pxNewTimer;
   13660:	697b      	ldr	r3, [r7, #20]
	}
   13662:	4618      	mov	r0, r3
   13664:	f107 0718 	add.w	r7, r7, #24
   13668:	46bd      	mov	sp, r7
   1366a:	bd80      	pop	{r7, pc}

0001366c <prvInitialiseNewTimer>:
									const TickType_t xTimerPeriodInTicks,
									const UBaseType_t uxAutoReload,
									void * const pvTimerID,
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer )
{
   1366c:	b580      	push	{r7, lr}
   1366e:	b086      	sub	sp, #24
   13670:	af00      	add	r7, sp, #0
   13672:	60f8      	str	r0, [r7, #12]
   13674:	60b9      	str	r1, [r7, #8]
   13676:	607a      	str	r2, [r7, #4]
   13678:	603b      	str	r3, [r7, #0]
	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );
   1367a:	68bb      	ldr	r3, [r7, #8]
   1367c:	2b00      	cmp	r3, #0
   1367e:	d109      	bne.n	13694 <prvInitialiseNewTimer+0x28>
   13680:	f04f 0328 	mov.w	r3, #40	; 0x28
   13684:	f383 8811 	msr	BASEPRI, r3
   13688:	f3bf 8f6f 	isb	sy
   1368c:	f3bf 8f4f 	dsb	sy
   13690:	617b      	str	r3, [r7, #20]
   13692:	e7fe      	b.n	13692 <prvInitialiseNewTimer+0x26>

	if( pxNewTimer != NULL )
   13694:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   13696:	2b00      	cmp	r3, #0
   13698:	d016      	beq.n	136c8 <prvInitialiseNewTimer+0x5c>
	{
		/* Ensure the infrastructure used by the timer service task has been
		created/initialised. */
		prvCheckForValidListAndQueue();
   1369a:	f000 fb63 	bl	13d64 <prvCheckForValidListAndQueue>

		/* Initialise the timer structure members using the function
		parameters. */
		pxNewTimer->pcTimerName = pcTimerName;
   1369e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   136a0:	68fa      	ldr	r2, [r7, #12]
   136a2:	601a      	str	r2, [r3, #0]
		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
   136a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   136a6:	68ba      	ldr	r2, [r7, #8]
   136a8:	619a      	str	r2, [r3, #24]
		pxNewTimer->uxAutoReload = uxAutoReload;
   136aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   136ac:	687a      	ldr	r2, [r7, #4]
   136ae:	61da      	str	r2, [r3, #28]
		pxNewTimer->pvTimerID = pvTimerID;
   136b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   136b2:	683a      	ldr	r2, [r7, #0]
   136b4:	621a      	str	r2, [r3, #32]
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
   136b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   136b8:	6a3a      	ldr	r2, [r7, #32]
   136ba:	625a      	str	r2, [r3, #36]	; 0x24
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
   136bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   136be:	f103 0304 	add.w	r3, r3, #4
   136c2:	4618      	mov	r0, r3
   136c4:	f7fb fddc 	bl	f280 <vListInitialiseItem>
		traceTIMER_CREATE( pxNewTimer );
	}
}
   136c8:	f107 0718 	add.w	r7, r7, #24
   136cc:	46bd      	mov	sp, r7
   136ce:	bd80      	pop	{r7, pc}

000136d0 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
   136d0:	b580      	push	{r7, lr}
   136d2:	b08a      	sub	sp, #40	; 0x28
   136d4:	af00      	add	r7, sp, #0
   136d6:	60f8      	str	r0, [r7, #12]
   136d8:	60b9      	str	r1, [r7, #8]
   136da:	607a      	str	r2, [r7, #4]
   136dc:	603b      	str	r3, [r7, #0]
BaseType_t xReturn = pdFAIL;
   136de:	f04f 0300 	mov.w	r3, #0
   136e2:	623b      	str	r3, [r7, #32]
DaemonTaskMessage_t xMessage;

	configASSERT( xTimer );
   136e4:	68fb      	ldr	r3, [r7, #12]
   136e6:	2b00      	cmp	r3, #0
   136e8:	d109      	bne.n	136fe <xTimerGenericCommand+0x2e>
   136ea:	f04f 0328 	mov.w	r3, #40	; 0x28
   136ee:	f383 8811 	msr	BASEPRI, r3
   136f2:	f3bf 8f6f 	isb	sy
   136f6:	f3bf 8f4f 	dsb	sy
   136fa:	627b      	str	r3, [r7, #36]	; 0x24
   136fc:	e7fe      	b.n	136fc <xTimerGenericCommand+0x2c>

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
   136fe:	f243 1330 	movw	r3, #12592	; 0x3130
   13702:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13706:	681b      	ldr	r3, [r3, #0]
   13708:	2b00      	cmp	r3, #0
   1370a:	d040      	beq.n	1378e <xTimerGenericCommand+0xbe>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
   1370c:	68bb      	ldr	r3, [r7, #8]
   1370e:	617b      	str	r3, [r7, #20]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
   13710:	687b      	ldr	r3, [r7, #4]
   13712:	61bb      	str	r3, [r7, #24]
		xMessage.u.xTimerParameters.pxTimer = xTimer;
   13714:	68fb      	ldr	r3, [r7, #12]
   13716:	61fb      	str	r3, [r7, #28]

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
   13718:	68bb      	ldr	r3, [r7, #8]
   1371a:	2b05      	cmp	r3, #5
   1371c:	dc27      	bgt.n	1376e <xTimerGenericCommand+0x9e>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
   1371e:	f7fe ff71 	bl	12604 <xTaskGetSchedulerState>
   13722:	4603      	mov	r3, r0
   13724:	2b02      	cmp	r3, #2
   13726:	d110      	bne.n	1374a <xTimerGenericCommand+0x7a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
   13728:	f243 1330 	movw	r3, #12592	; 0x3130
   1372c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13730:	681a      	ldr	r2, [r3, #0]
   13732:	f107 0314 	add.w	r3, r7, #20
   13736:	4610      	mov	r0, r2
   13738:	4619      	mov	r1, r3
   1373a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   1373c:	f04f 0300 	mov.w	r3, #0
   13740:	f7fb ffc0 	bl	f6c4 <xQueueGenericSend>
   13744:	4603      	mov	r3, r0
   13746:	623b      	str	r3, [r7, #32]
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
   13748:	e021      	b.n	1378e <xTimerGenericCommand+0xbe>
   1374a:	f243 1330 	movw	r3, #12592	; 0x3130
   1374e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13752:	681a      	ldr	r2, [r3, #0]
   13754:	f107 0314 	add.w	r3, r7, #20
   13758:	4610      	mov	r0, r2
   1375a:	4619      	mov	r1, r3
   1375c:	f04f 0200 	mov.w	r2, #0
   13760:	f04f 0300 	mov.w	r3, #0
   13764:	f7fb ffae 	bl	f6c4 <xQueueGenericSend>
   13768:	4603      	mov	r3, r0
   1376a:	623b      	str	r3, [r7, #32]
   1376c:	e00f      	b.n	1378e <xTimerGenericCommand+0xbe>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
   1376e:	f243 1330 	movw	r3, #12592	; 0x3130
   13772:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13776:	681a      	ldr	r2, [r3, #0]
   13778:	f107 0314 	add.w	r3, r7, #20
   1377c:	4610      	mov	r0, r2
   1377e:	4619      	mov	r1, r3
   13780:	683a      	ldr	r2, [r7, #0]
   13782:	f04f 0300 	mov.w	r3, #0
   13786:	f7fc f8b5 	bl	f8f4 <xQueueGenericSendFromISR>
   1378a:	4603      	mov	r3, r0
   1378c:	623b      	str	r3, [r7, #32]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
   1378e:	6a3b      	ldr	r3, [r7, #32]
}
   13790:	4618      	mov	r0, r3
   13792:	f107 0728 	add.w	r7, r7, #40	; 0x28
   13796:	46bd      	mov	sp, r7
   13798:	bd80      	pop	{r7, pc}
   1379a:	bf00      	nop

0001379c <xTimerGetTimerDaemonTaskHandle>:
/*-----------------------------------------------------------*/

TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
{
   1379c:	b480      	push	{r7}
   1379e:	b083      	sub	sp, #12
   137a0:	af00      	add	r7, sp, #0
	/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
	started, then xTimerTaskHandle will be NULL. */
	configASSERT( ( xTimerTaskHandle != NULL ) );
   137a2:	f243 1334 	movw	r3, #12596	; 0x3134
   137a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   137aa:	681b      	ldr	r3, [r3, #0]
   137ac:	2b00      	cmp	r3, #0
   137ae:	d109      	bne.n	137c4 <xTimerGetTimerDaemonTaskHandle+0x28>
   137b0:	f04f 0328 	mov.w	r3, #40	; 0x28
   137b4:	f383 8811 	msr	BASEPRI, r3
   137b8:	f3bf 8f6f 	isb	sy
   137bc:	f3bf 8f4f 	dsb	sy
   137c0:	607b      	str	r3, [r7, #4]
   137c2:	e7fe      	b.n	137c2 <xTimerGetTimerDaemonTaskHandle+0x26>
	return xTimerTaskHandle;
   137c4:	f243 1334 	movw	r3, #12596	; 0x3134
   137c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   137cc:	681b      	ldr	r3, [r3, #0]
}
   137ce:	4618      	mov	r0, r3
   137d0:	f107 070c 	add.w	r7, r7, #12
   137d4:	46bd      	mov	sp, r7
   137d6:	bc80      	pop	{r7}
   137d8:	4770      	bx	lr
   137da:	bf00      	nop

000137dc <xTimerGetPeriod>:
/*-----------------------------------------------------------*/

TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
{
   137dc:	b480      	push	{r7}
   137de:	b085      	sub	sp, #20
   137e0:	af00      	add	r7, sp, #0
   137e2:	6078      	str	r0, [r7, #4]
Timer_t *pxTimer = xTimer;
   137e4:	687b      	ldr	r3, [r7, #4]
   137e6:	60bb      	str	r3, [r7, #8]

	configASSERT( xTimer );
   137e8:	687b      	ldr	r3, [r7, #4]
   137ea:	2b00      	cmp	r3, #0
   137ec:	d109      	bne.n	13802 <xTimerGetPeriod+0x26>
   137ee:	f04f 0328 	mov.w	r3, #40	; 0x28
   137f2:	f383 8811 	msr	BASEPRI, r3
   137f6:	f3bf 8f6f 	isb	sy
   137fa:	f3bf 8f4f 	dsb	sy
   137fe:	60fb      	str	r3, [r7, #12]
   13800:	e7fe      	b.n	13800 <xTimerGetPeriod+0x24>
	return pxTimer->xTimerPeriodInTicks;
   13802:	68bb      	ldr	r3, [r7, #8]
   13804:	699b      	ldr	r3, [r3, #24]
}
   13806:	4618      	mov	r0, r3
   13808:	f107 0714 	add.w	r7, r7, #20
   1380c:	46bd      	mov	sp, r7
   1380e:	bc80      	pop	{r7}
   13810:	4770      	bx	lr
   13812:	bf00      	nop

00013814 <xTimerGetExpiryTime>:
/*-----------------------------------------------------------*/

TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
{
   13814:	b480      	push	{r7}
   13816:	b087      	sub	sp, #28
   13818:	af00      	add	r7, sp, #0
   1381a:	6078      	str	r0, [r7, #4]
Timer_t * pxTimer =  xTimer;
   1381c:	687b      	ldr	r3, [r7, #4]
   1381e:	60fb      	str	r3, [r7, #12]
TickType_t xReturn;

	configASSERT( xTimer );
   13820:	687b      	ldr	r3, [r7, #4]
   13822:	2b00      	cmp	r3, #0
   13824:	d109      	bne.n	1383a <xTimerGetExpiryTime+0x26>
   13826:	f04f 0328 	mov.w	r3, #40	; 0x28
   1382a:	f383 8811 	msr	BASEPRI, r3
   1382e:	f3bf 8f6f 	isb	sy
   13832:	f3bf 8f4f 	dsb	sy
   13836:	617b      	str	r3, [r7, #20]
   13838:	e7fe      	b.n	13838 <xTimerGetExpiryTime+0x24>
	xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
   1383a:	68fb      	ldr	r3, [r7, #12]
   1383c:	685b      	ldr	r3, [r3, #4]
   1383e:	613b      	str	r3, [r7, #16]
	return xReturn;
   13840:	693b      	ldr	r3, [r7, #16]
}
   13842:	4618      	mov	r0, r3
   13844:	f107 071c 	add.w	r7, r7, #28
   13848:	46bd      	mov	sp, r7
   1384a:	bc80      	pop	{r7}
   1384c:	4770      	bx	lr
   1384e:	bf00      	nop

00013850 <pcTimerGetName>:
/*-----------------------------------------------------------*/

const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
   13850:	b480      	push	{r7}
   13852:	b085      	sub	sp, #20
   13854:	af00      	add	r7, sp, #0
   13856:	6078      	str	r0, [r7, #4]
Timer_t *pxTimer = xTimer;
   13858:	687b      	ldr	r3, [r7, #4]
   1385a:	60bb      	str	r3, [r7, #8]

	configASSERT( xTimer );
   1385c:	687b      	ldr	r3, [r7, #4]
   1385e:	2b00      	cmp	r3, #0
   13860:	d109      	bne.n	13876 <pcTimerGetName+0x26>
   13862:	f04f 0328 	mov.w	r3, #40	; 0x28
   13866:	f383 8811 	msr	BASEPRI, r3
   1386a:	f3bf 8f6f 	isb	sy
   1386e:	f3bf 8f4f 	dsb	sy
   13872:	60fb      	str	r3, [r7, #12]
   13874:	e7fe      	b.n	13874 <pcTimerGetName+0x24>
	return pxTimer->pcTimerName;
   13876:	68bb      	ldr	r3, [r7, #8]
   13878:	681b      	ldr	r3, [r3, #0]
}
   1387a:	4618      	mov	r0, r3
   1387c:	f107 0714 	add.w	r7, r7, #20
   13880:	46bd      	mov	sp, r7
   13882:	bc80      	pop	{r7}
   13884:	4770      	bx	lr
   13886:	bf00      	nop

00013888 <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
   13888:	b580      	push	{r7, lr}
   1388a:	b088      	sub	sp, #32
   1388c:	af02      	add	r7, sp, #8
   1388e:	6078      	str	r0, [r7, #4]
   13890:	6039      	str	r1, [r7, #0]
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   13892:	f243 1328 	movw	r3, #12584	; 0x3128
   13896:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1389a:	681b      	ldr	r3, [r3, #0]
   1389c:	68db      	ldr	r3, [r3, #12]
   1389e:	68db      	ldr	r3, [r3, #12]
   138a0:	613b      	str	r3, [r7, #16]

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   138a2:	693b      	ldr	r3, [r7, #16]
   138a4:	f103 0304 	add.w	r3, r3, #4
   138a8:	4618      	mov	r0, r3
   138aa:	f7fb fd55 	bl	f358 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   138ae:	693b      	ldr	r3, [r7, #16]
   138b0:	69db      	ldr	r3, [r3, #28]
   138b2:	2b01      	cmp	r3, #1
   138b4:	d126      	bne.n	13904 <prvProcessExpiredTimer+0x7c>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
   138b6:	693b      	ldr	r3, [r7, #16]
   138b8:	699a      	ldr	r2, [r3, #24]
   138ba:	687b      	ldr	r3, [r7, #4]
   138bc:	4413      	add	r3, r2
   138be:	6938      	ldr	r0, [r7, #16]
   138c0:	4619      	mov	r1, r3
   138c2:	683a      	ldr	r2, [r7, #0]
   138c4:	687b      	ldr	r3, [r7, #4]
   138c6:	f000 f8e3 	bl	13a90 <prvInsertTimerInActiveList>
   138ca:	4603      	mov	r3, r0
   138cc:	2b00      	cmp	r3, #0
   138ce:	d019      	beq.n	13904 <prvProcessExpiredTimer+0x7c>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
   138d0:	f04f 0300 	mov.w	r3, #0
   138d4:	9300      	str	r3, [sp, #0]
   138d6:	6938      	ldr	r0, [r7, #16]
   138d8:	f04f 0100 	mov.w	r1, #0
   138dc:	687a      	ldr	r2, [r7, #4]
   138de:	f04f 0300 	mov.w	r3, #0
   138e2:	f7ff fef5 	bl	136d0 <xTimerGenericCommand>
   138e6:	4603      	mov	r3, r0
   138e8:	60fb      	str	r3, [r7, #12]
			configASSERT( xResult );
   138ea:	68fb      	ldr	r3, [r7, #12]
   138ec:	2b00      	cmp	r3, #0
   138ee:	d109      	bne.n	13904 <prvProcessExpiredTimer+0x7c>
   138f0:	f04f 0328 	mov.w	r3, #40	; 0x28
   138f4:	f383 8811 	msr	BASEPRI, r3
   138f8:	f3bf 8f6f 	isb	sy
   138fc:	f3bf 8f4f 	dsb	sy
   13900:	617b      	str	r3, [r7, #20]
   13902:	e7fe      	b.n	13902 <prvProcessExpiredTimer+0x7a>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   13904:	693b      	ldr	r3, [r7, #16]
   13906:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   13908:	6938      	ldr	r0, [r7, #16]
   1390a:	4798      	blx	r3
}
   1390c:	f107 0718 	add.w	r7, r7, #24
   13910:	46bd      	mov	sp, r7
   13912:	bd80      	pop	{r7, pc}

00013914 <prvTimerTask>:
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
   13914:	b580      	push	{r7, lr}
   13916:	b084      	sub	sp, #16
   13918:	af00      	add	r7, sp, #0
   1391a:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
   1391c:	f107 0308 	add.w	r3, r7, #8
   13920:	4618      	mov	r0, r3
   13922:	f000 f863 	bl	139ec <prvGetNextExpireTime>
   13926:	4603      	mov	r3, r0
   13928:	60fb      	str	r3, [r7, #12]

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
   1392a:	68bb      	ldr	r3, [r7, #8]
   1392c:	68f8      	ldr	r0, [r7, #12]
   1392e:	4619      	mov	r1, r3
   13930:	f000 f804 	bl	1393c <prvProcessTimerOrBlockTask>

		/* Empty the command queue. */
		prvProcessReceivedCommands();
   13934:	f000 f8f8 	bl	13b28 <prvProcessReceivedCommands>
	}
   13938:	e7f0      	b.n	1391c <prvTimerTask+0x8>
   1393a:	bf00      	nop

0001393c <prvProcessTimerOrBlockTask>:
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
   1393c:	b580      	push	{r7, lr}
   1393e:	b084      	sub	sp, #16
   13940:	af00      	add	r7, sp, #0
   13942:	6078      	str	r0, [r7, #4]
   13944:	6039      	str	r1, [r7, #0]
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
   13946:	f7fd fe65 	bl	11614 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   1394a:	f107 0308 	add.w	r3, r7, #8
   1394e:	4618      	mov	r0, r3
   13950:	f000 f876 	bl	13a40 <prvSampleTimeNow>
   13954:	4603      	mov	r3, r0
   13956:	60fb      	str	r3, [r7, #12]
		if( xTimerListsWereSwitched == pdFALSE )
   13958:	68bb      	ldr	r3, [r7, #8]
   1395a:	2b00      	cmp	r3, #0
   1395c:	d13e      	bne.n	139dc <prvProcessTimerOrBlockTask+0xa0>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
   1395e:	683b      	ldr	r3, [r7, #0]
   13960:	2b00      	cmp	r3, #0
   13962:	d10b      	bne.n	1397c <prvProcessTimerOrBlockTask+0x40>
   13964:	687a      	ldr	r2, [r7, #4]
   13966:	68fb      	ldr	r3, [r7, #12]
   13968:	429a      	cmp	r2, r3
   1396a:	d807      	bhi.n	1397c <prvProcessTimerOrBlockTask+0x40>
			{
				( void ) xTaskResumeAll();
   1396c:	f7fd fe64 	bl	11638 <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
   13970:	6878      	ldr	r0, [r7, #4]
   13972:	68f9      	ldr	r1, [r7, #12]
   13974:	f7ff ff88 	bl	13888 <prvProcessExpiredTimer>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
   13978:	bf00      	nop
   1397a:	e033      	b.n	139e4 <prvProcessTimerOrBlockTask+0xa8>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
   1397c:	683b      	ldr	r3, [r7, #0]
   1397e:	2b00      	cmp	r3, #0
   13980:	d00d      	beq.n	1399e <prvProcessTimerOrBlockTask+0x62>
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
   13982:	f243 132c 	movw	r3, #12588	; 0x312c
   13986:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1398a:	681b      	ldr	r3, [r3, #0]
   1398c:	681b      	ldr	r3, [r3, #0]
   1398e:	2b00      	cmp	r3, #0
   13990:	d102      	bne.n	13998 <prvProcessTimerOrBlockTask+0x5c>
   13992:	f04f 0301 	mov.w	r3, #1
   13996:	e001      	b.n	1399c <prvProcessTimerOrBlockTask+0x60>
   13998:	f04f 0300 	mov.w	r3, #0
   1399c:	603b      	str	r3, [r7, #0]
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
   1399e:	f243 1330 	movw	r3, #12592	; 0x3130
   139a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   139a6:	681a      	ldr	r2, [r3, #0]
   139a8:	6879      	ldr	r1, [r7, #4]
   139aa:	68fb      	ldr	r3, [r7, #12]
   139ac:	ebc3 0301 	rsb	r3, r3, r1
   139b0:	4610      	mov	r0, r2
   139b2:	4619      	mov	r1, r3
   139b4:	683a      	ldr	r2, [r7, #0]
   139b6:	f7fc ff0f 	bl	107d8 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
   139ba:	f7fd fe3d 	bl	11638 <xTaskResumeAll>
   139be:	4603      	mov	r3, r0
   139c0:	2b00      	cmp	r3, #0
   139c2:	d10e      	bne.n	139e2 <prvProcessTimerOrBlockTask+0xa6>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
   139c4:	f64e 5304 	movw	r3, #60676	; 0xed04
   139c8:	f2ce 0300 	movt	r3, #57344	; 0xe000
   139cc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   139d0:	601a      	str	r2, [r3, #0]
   139d2:	f3bf 8f4f 	dsb	sy
   139d6:	f3bf 8f6f 	isb	sy
   139da:	e003      	b.n	139e4 <prvProcessTimerOrBlockTask+0xa8>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
   139dc:	f7fd fe2c 	bl	11638 <xTaskResumeAll>
   139e0:	e000      	b.n	139e4 <prvProcessTimerOrBlockTask+0xa8>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
   139e2:	bf00      	nop
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
   139e4:	f107 0710 	add.w	r7, r7, #16
   139e8:	46bd      	mov	sp, r7
   139ea:	bd80      	pop	{r7, pc}

000139ec <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
{
   139ec:	b480      	push	{r7}
   139ee:	b085      	sub	sp, #20
   139f0:	af00      	add	r7, sp, #0
   139f2:	6078      	str	r0, [r7, #4]
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
   139f4:	f243 1328 	movw	r3, #12584	; 0x3128
   139f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   139fc:	681b      	ldr	r3, [r3, #0]
   139fe:	681b      	ldr	r3, [r3, #0]
   13a00:	2b00      	cmp	r3, #0
   13a02:	d102      	bne.n	13a0a <prvGetNextExpireTime+0x1e>
   13a04:	f04f 0301 	mov.w	r3, #1
   13a08:	e001      	b.n	13a0e <prvGetNextExpireTime+0x22>
   13a0a:	f04f 0300 	mov.w	r3, #0
   13a0e:	687a      	ldr	r2, [r7, #4]
   13a10:	6013      	str	r3, [r2, #0]
	if( *pxListWasEmpty == pdFALSE )
   13a12:	687b      	ldr	r3, [r7, #4]
   13a14:	681b      	ldr	r3, [r3, #0]
   13a16:	2b00      	cmp	r3, #0
   13a18:	d108      	bne.n	13a2c <prvGetNextExpireTime+0x40>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   13a1a:	f243 1328 	movw	r3, #12584	; 0x3128
   13a1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13a22:	681b      	ldr	r3, [r3, #0]
   13a24:	68db      	ldr	r3, [r3, #12]
   13a26:	681b      	ldr	r3, [r3, #0]
   13a28:	60fb      	str	r3, [r7, #12]
   13a2a:	e002      	b.n	13a32 <prvGetNextExpireTime+0x46>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
   13a2c:	f04f 0300 	mov.w	r3, #0
   13a30:	60fb      	str	r3, [r7, #12]
	}

	return xNextExpireTime;
   13a32:	68fb      	ldr	r3, [r7, #12]
}
   13a34:	4618      	mov	r0, r3
   13a36:	f107 0714 	add.w	r7, r7, #20
   13a3a:	46bd      	mov	sp, r7
   13a3c:	bc80      	pop	{r7}
   13a3e:	4770      	bx	lr

00013a40 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
   13a40:	b580      	push	{r7, lr}
   13a42:	b084      	sub	sp, #16
   13a44:	af00      	add	r7, sp, #0
   13a46:	6078      	str	r0, [r7, #4]
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
   13a48:	f7fd fec6 	bl	117d8 <xTaskGetTickCount>
   13a4c:	4603      	mov	r3, r0
   13a4e:	60fb      	str	r3, [r7, #12]

	if( xTimeNow < xLastTime )
   13a50:	f243 1338 	movw	r3, #12600	; 0x3138
   13a54:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13a58:	681b      	ldr	r3, [r3, #0]
   13a5a:	68fa      	ldr	r2, [r7, #12]
   13a5c:	429a      	cmp	r2, r3
   13a5e:	d206      	bcs.n	13a6e <prvSampleTimeNow+0x2e>
	{
		prvSwitchTimerLists();
   13a60:	f000 f906 	bl	13c70 <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
   13a64:	687b      	ldr	r3, [r7, #4]
   13a66:	f04f 0201 	mov.w	r2, #1
   13a6a:	601a      	str	r2, [r3, #0]
   13a6c:	e003      	b.n	13a76 <prvSampleTimeNow+0x36>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
   13a6e:	687b      	ldr	r3, [r7, #4]
   13a70:	f04f 0200 	mov.w	r2, #0
   13a74:	601a      	str	r2, [r3, #0]
	}

	xLastTime = xTimeNow;
   13a76:	f243 1338 	movw	r3, #12600	; 0x3138
   13a7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13a7e:	68fa      	ldr	r2, [r7, #12]
   13a80:	601a      	str	r2, [r3, #0]

	return xTimeNow;
   13a82:	68fb      	ldr	r3, [r7, #12]
}
   13a84:	4618      	mov	r0, r3
   13a86:	f107 0710 	add.w	r7, r7, #16
   13a8a:	46bd      	mov	sp, r7
   13a8c:	bd80      	pop	{r7, pc}
   13a8e:	bf00      	nop

00013a90 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
   13a90:	b580      	push	{r7, lr}
   13a92:	b086      	sub	sp, #24
   13a94:	af00      	add	r7, sp, #0
   13a96:	60f8      	str	r0, [r7, #12]
   13a98:	60b9      	str	r1, [r7, #8]
   13a9a:	607a      	str	r2, [r7, #4]
   13a9c:	603b      	str	r3, [r7, #0]
BaseType_t xProcessTimerNow = pdFALSE;
   13a9e:	f04f 0300 	mov.w	r3, #0
   13aa2:	617b      	str	r3, [r7, #20]

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
   13aa4:	68fb      	ldr	r3, [r7, #12]
   13aa6:	68ba      	ldr	r2, [r7, #8]
   13aa8:	605a      	str	r2, [r3, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   13aaa:	68fb      	ldr	r3, [r7, #12]
   13aac:	68fa      	ldr	r2, [r7, #12]
   13aae:	611a      	str	r2, [r3, #16]

	if( xNextExpiryTime <= xTimeNow )
   13ab0:	68ba      	ldr	r2, [r7, #8]
   13ab2:	687b      	ldr	r3, [r7, #4]
   13ab4:	429a      	cmp	r2, r3
   13ab6:	d818      	bhi.n	13aea <prvInsertTimerInActiveList+0x5a>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   13ab8:	687a      	ldr	r2, [r7, #4]
   13aba:	683b      	ldr	r3, [r7, #0]
   13abc:	ebc3 0202 	rsb	r2, r3, r2
   13ac0:	68fb      	ldr	r3, [r7, #12]
   13ac2:	699b      	ldr	r3, [r3, #24]
   13ac4:	429a      	cmp	r2, r3
   13ac6:	d303      	bcc.n	13ad0 <prvInsertTimerInActiveList+0x40>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
   13ac8:	f04f 0301 	mov.w	r3, #1
   13acc:	617b      	str	r3, [r7, #20]
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
   13ace:	e024      	b.n	13b1a <prvInsertTimerInActiveList+0x8a>
   13ad0:	f243 132c 	movw	r3, #12588	; 0x312c
   13ad4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13ad8:	681a      	ldr	r2, [r3, #0]
   13ada:	68fb      	ldr	r3, [r7, #12]
   13adc:	f103 0304 	add.w	r3, r3, #4
   13ae0:	4610      	mov	r0, r2
   13ae2:	4619      	mov	r1, r3
   13ae4:	f7fb fbfe 	bl	f2e4 <vListInsert>
   13ae8:	e017      	b.n	13b1a <prvInsertTimerInActiveList+0x8a>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
   13aea:	687a      	ldr	r2, [r7, #4]
   13aec:	683b      	ldr	r3, [r7, #0]
   13aee:	429a      	cmp	r2, r3
   13af0:	d207      	bcs.n	13b02 <prvInsertTimerInActiveList+0x72>
   13af2:	68ba      	ldr	r2, [r7, #8]
   13af4:	683b      	ldr	r3, [r7, #0]
   13af6:	429a      	cmp	r2, r3
   13af8:	d303      	bcc.n	13b02 <prvInsertTimerInActiveList+0x72>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
   13afa:	f04f 0301 	mov.w	r3, #1
   13afe:	617b      	str	r3, [r7, #20]
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
   13b00:	e00b      	b.n	13b1a <prvInsertTimerInActiveList+0x8a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   13b02:	f243 1328 	movw	r3, #12584	; 0x3128
   13b06:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13b0a:	681a      	ldr	r2, [r3, #0]
   13b0c:	68fb      	ldr	r3, [r7, #12]
   13b0e:	f103 0304 	add.w	r3, r3, #4
   13b12:	4610      	mov	r0, r2
   13b14:	4619      	mov	r1, r3
   13b16:	f7fb fbe5 	bl	f2e4 <vListInsert>
		}
	}

	return xProcessTimerNow;
   13b1a:	697b      	ldr	r3, [r7, #20]
}
   13b1c:	4618      	mov	r0, r3
   13b1e:	f107 0718 	add.w	r7, r7, #24
   13b22:	46bd      	mov	sp, r7
   13b24:	bd80      	pop	{r7, pc}
   13b26:	bf00      	nop

00013b28 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
   13b28:	b580      	push	{r7, lr}
   13b2a:	b08c      	sub	sp, #48	; 0x30
   13b2c:	af02      	add	r7, sp, #8
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
   13b2e:	e089      	b.n	13c44 <prvProcessReceivedCommands+0x11c>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
   13b30:	68bb      	ldr	r3, [r7, #8]
   13b32:	2b00      	cmp	r3, #0
   13b34:	f2c0 8086 	blt.w	13c44 <prvProcessReceivedCommands+0x11c>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
   13b38:	693b      	ldr	r3, [r7, #16]
   13b3a:	617b      	str	r3, [r7, #20]

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
   13b3c:	697b      	ldr	r3, [r7, #20]
   13b3e:	695b      	ldr	r3, [r3, #20]
   13b40:	2b00      	cmp	r3, #0
   13b42:	d005      	beq.n	13b50 <prvProcessReceivedCommands+0x28>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   13b44:	697b      	ldr	r3, [r7, #20]
   13b46:	f103 0304 	add.w	r3, r3, #4
   13b4a:	4618      	mov	r0, r3
   13b4c:	f7fb fc04 	bl	f358 <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   13b50:	f107 0304 	add.w	r3, r7, #4
   13b54:	4618      	mov	r0, r3
   13b56:	f7ff ff73 	bl	13a40 <prvSampleTimeNow>
   13b5a:	4603      	mov	r3, r0
   13b5c:	61fb      	str	r3, [r7, #28]

			switch( xMessage.xMessageID )
   13b5e:	68bb      	ldr	r3, [r7, #8]
   13b60:	2b09      	cmp	r3, #9
   13b62:	d86f      	bhi.n	13c44 <prvProcessReceivedCommands+0x11c>
   13b64:	a201      	add	r2, pc, #4	; (adr r2, 13b6c <prvProcessReceivedCommands+0x44>)
   13b66:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   13b6a:	bf00      	nop
   13b6c:	00013b95 	.word	0x00013b95
   13b70:	00013b95 	.word	0x00013b95
   13b74:	00013b95 	.word	0x00013b95
   13b78:	00013c45 	.word	0x00013c45
   13b7c:	00013bfb 	.word	0x00013bfb
   13b80:	00013c33 	.word	0x00013c33
   13b84:	00013b95 	.word	0x00013b95
   13b88:	00013b95 	.word	0x00013b95
   13b8c:	00013c45 	.word	0x00013c45
   13b90:	00013bfb 	.word	0x00013bfb
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
   13b94:	68fa      	ldr	r2, [r7, #12]
   13b96:	697b      	ldr	r3, [r7, #20]
   13b98:	699b      	ldr	r3, [r3, #24]
   13b9a:	441a      	add	r2, r3
   13b9c:	68fb      	ldr	r3, [r7, #12]
   13b9e:	6978      	ldr	r0, [r7, #20]
   13ba0:	4611      	mov	r1, r2
   13ba2:	69fa      	ldr	r2, [r7, #28]
   13ba4:	f7ff ff74 	bl	13a90 <prvInsertTimerInActiveList>
   13ba8:	4603      	mov	r3, r0
   13baa:	2b00      	cmp	r3, #0
   13bac:	d045      	beq.n	13c3a <prvProcessReceivedCommands+0x112>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   13bae:	697b      	ldr	r3, [r7, #20]
   13bb0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   13bb2:	6978      	ldr	r0, [r7, #20]
   13bb4:	4798      	blx	r3
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   13bb6:	697b      	ldr	r3, [r7, #20]
   13bb8:	69db      	ldr	r3, [r3, #28]
   13bba:	2b01      	cmp	r3, #1
   13bbc:	d13f      	bne.n	13c3e <prvProcessReceivedCommands+0x116>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
   13bbe:	68fa      	ldr	r2, [r7, #12]
   13bc0:	697b      	ldr	r3, [r7, #20]
   13bc2:	699b      	ldr	r3, [r3, #24]
   13bc4:	4413      	add	r3, r2
   13bc6:	f04f 0200 	mov.w	r2, #0
   13bca:	9200      	str	r2, [sp, #0]
   13bcc:	6978      	ldr	r0, [r7, #20]
   13bce:	f04f 0100 	mov.w	r1, #0
   13bd2:	461a      	mov	r2, r3
   13bd4:	f04f 0300 	mov.w	r3, #0
   13bd8:	f7ff fd7a 	bl	136d0 <xTimerGenericCommand>
   13bdc:	4603      	mov	r3, r0
   13bde:	61bb      	str	r3, [r7, #24]
							configASSERT( xResult );
   13be0:	69bb      	ldr	r3, [r7, #24]
   13be2:	2b00      	cmp	r3, #0
   13be4:	d12d      	bne.n	13c42 <prvProcessReceivedCommands+0x11a>
   13be6:	f04f 0328 	mov.w	r3, #40	; 0x28
   13bea:	f383 8811 	msr	BASEPRI, r3
   13bee:	f3bf 8f6f 	isb	sy
   13bf2:	f3bf 8f4f 	dsb	sy
   13bf6:	623b      	str	r3, [r7, #32]
   13bf8:	e7fe      	b.n	13bf8 <prvProcessReceivedCommands+0xd0>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
   13bfa:	68fa      	ldr	r2, [r7, #12]
   13bfc:	697b      	ldr	r3, [r7, #20]
   13bfe:	619a      	str	r2, [r3, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
   13c00:	697b      	ldr	r3, [r7, #20]
   13c02:	699b      	ldr	r3, [r3, #24]
   13c04:	2b00      	cmp	r3, #0
   13c06:	d109      	bne.n	13c1c <prvProcessReceivedCommands+0xf4>
   13c08:	f04f 0328 	mov.w	r3, #40	; 0x28
   13c0c:	f383 8811 	msr	BASEPRI, r3
   13c10:	f3bf 8f6f 	isb	sy
   13c14:	f3bf 8f4f 	dsb	sy
   13c18:	627b      	str	r3, [r7, #36]	; 0x24
   13c1a:	e7fe      	b.n	13c1a <prvProcessReceivedCommands+0xf2>
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
   13c1c:	697b      	ldr	r3, [r7, #20]
   13c1e:	699a      	ldr	r2, [r3, #24]
   13c20:	69fb      	ldr	r3, [r7, #28]
   13c22:	4413      	add	r3, r2
   13c24:	6978      	ldr	r0, [r7, #20]
   13c26:	4619      	mov	r1, r3
   13c28:	69fa      	ldr	r2, [r7, #28]
   13c2a:	69fb      	ldr	r3, [r7, #28]
   13c2c:	f7ff ff30 	bl	13a90 <prvInsertTimerInActiveList>
					break;
   13c30:	e008      	b.n	13c44 <prvProcessReceivedCommands+0x11c>
					allocated. */
					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
					{
						/* The timer can only have been allocated dynamically -
						free it again. */
						vPortFree( pxTimer );
   13c32:	6978      	ldr	r0, [r7, #20]
   13c34:	f000 fa08 	bl	14048 <vPortFree>
   13c38:	e004      	b.n	13c44 <prvProcessReceivedCommands+0x11c>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					break;
   13c3a:	bf00      	nop
   13c3c:	e002      	b.n	13c44 <prvProcessReceivedCommands+0x11c>
   13c3e:	bf00      	nop
   13c40:	e000      	b.n	13c44 <prvProcessReceivedCommands+0x11c>
   13c42:	bf00      	nop
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
   13c44:	f243 1330 	movw	r3, #12592	; 0x3130
   13c48:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13c4c:	681a      	ldr	r2, [r3, #0]
   13c4e:	f107 0308 	add.w	r3, r7, #8
   13c52:	4610      	mov	r0, r2
   13c54:	4619      	mov	r1, r3
   13c56:	f04f 0200 	mov.w	r2, #0
   13c5a:	f7fb ff83 	bl	fb64 <xQueueReceive>
   13c5e:	4603      	mov	r3, r0
   13c60:	2b00      	cmp	r3, #0
   13c62:	f47f af65 	bne.w	13b30 <prvProcessReceivedCommands+0x8>
					/* Don't expect to get here. */
					break;
			}
		}
	}
}
   13c66:	f107 0728 	add.w	r7, r7, #40	; 0x28
   13c6a:	46bd      	mov	sp, r7
   13c6c:	bd80      	pop	{r7, pc}
   13c6e:	bf00      	nop

00013c70 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
   13c70:	b580      	push	{r7, lr}
   13c72:	b088      	sub	sp, #32
   13c74:	af02      	add	r7, sp, #8

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
   13c76:	e053      	b.n	13d20 <prvSwitchTimerLists+0xb0>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   13c78:	f243 1328 	movw	r3, #12584	; 0x3128
   13c7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13c80:	681b      	ldr	r3, [r3, #0]
   13c82:	68db      	ldr	r3, [r3, #12]
   13c84:	681b      	ldr	r3, [r3, #0]
   13c86:	603b      	str	r3, [r7, #0]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   13c88:	f243 1328 	movw	r3, #12584	; 0x3128
   13c8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13c90:	681b      	ldr	r3, [r3, #0]
   13c92:	68db      	ldr	r3, [r3, #12]
   13c94:	68db      	ldr	r3, [r3, #12]
   13c96:	60fb      	str	r3, [r7, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   13c98:	68fb      	ldr	r3, [r7, #12]
   13c9a:	f103 0304 	add.w	r3, r3, #4
   13c9e:	4618      	mov	r0, r3
   13ca0:	f7fb fb5a 	bl	f358 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   13ca4:	68fb      	ldr	r3, [r7, #12]
   13ca6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   13ca8:	68f8      	ldr	r0, [r7, #12]
   13caa:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   13cac:	68fb      	ldr	r3, [r7, #12]
   13cae:	69db      	ldr	r3, [r3, #28]
   13cb0:	2b01      	cmp	r3, #1
   13cb2:	d135      	bne.n	13d20 <prvSwitchTimerLists+0xb0>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
   13cb4:	68fb      	ldr	r3, [r7, #12]
   13cb6:	699a      	ldr	r2, [r3, #24]
   13cb8:	683b      	ldr	r3, [r7, #0]
   13cba:	4413      	add	r3, r2
   13cbc:	607b      	str	r3, [r7, #4]
			if( xReloadTime > xNextExpireTime )
   13cbe:	687a      	ldr	r2, [r7, #4]
   13cc0:	683b      	ldr	r3, [r7, #0]
   13cc2:	429a      	cmp	r2, r3
   13cc4:	d912      	bls.n	13cec <prvSwitchTimerLists+0x7c>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
   13cc6:	68fb      	ldr	r3, [r7, #12]
   13cc8:	687a      	ldr	r2, [r7, #4]
   13cca:	605a      	str	r2, [r3, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   13ccc:	68fb      	ldr	r3, [r7, #12]
   13cce:	68fa      	ldr	r2, [r7, #12]
   13cd0:	611a      	str	r2, [r3, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   13cd2:	f243 1328 	movw	r3, #12584	; 0x3128
   13cd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13cda:	681a      	ldr	r2, [r3, #0]
   13cdc:	68fb      	ldr	r3, [r7, #12]
   13cde:	f103 0304 	add.w	r3, r3, #4
   13ce2:	4610      	mov	r0, r2
   13ce4:	4619      	mov	r1, r3
   13ce6:	f7fb fafd 	bl	f2e4 <vListInsert>
   13cea:	e019      	b.n	13d20 <prvSwitchTimerLists+0xb0>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
   13cec:	f04f 0300 	mov.w	r3, #0
   13cf0:	9300      	str	r3, [sp, #0]
   13cf2:	68f8      	ldr	r0, [r7, #12]
   13cf4:	f04f 0100 	mov.w	r1, #0
   13cf8:	683a      	ldr	r2, [r7, #0]
   13cfa:	f04f 0300 	mov.w	r3, #0
   13cfe:	f7ff fce7 	bl	136d0 <xTimerGenericCommand>
   13d02:	4603      	mov	r3, r0
   13d04:	613b      	str	r3, [r7, #16]
				configASSERT( xResult );
   13d06:	693b      	ldr	r3, [r7, #16]
   13d08:	2b00      	cmp	r3, #0
   13d0a:	d109      	bne.n	13d20 <prvSwitchTimerLists+0xb0>
   13d0c:	f04f 0328 	mov.w	r3, #40	; 0x28
   13d10:	f383 8811 	msr	BASEPRI, r3
   13d14:	f3bf 8f6f 	isb	sy
   13d18:	f3bf 8f4f 	dsb	sy
   13d1c:	617b      	str	r3, [r7, #20]
   13d1e:	e7fe      	b.n	13d1e <prvSwitchTimerLists+0xae>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
   13d20:	f243 1328 	movw	r3, #12584	; 0x3128
   13d24:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13d28:	681b      	ldr	r3, [r3, #0]
   13d2a:	681b      	ldr	r3, [r3, #0]
   13d2c:	2b00      	cmp	r3, #0
   13d2e:	d1a3      	bne.n	13c78 <prvSwitchTimerLists+0x8>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
   13d30:	f243 1328 	movw	r3, #12584	; 0x3128
   13d34:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13d38:	681b      	ldr	r3, [r3, #0]
   13d3a:	60bb      	str	r3, [r7, #8]
	pxCurrentTimerList = pxOverflowTimerList;
   13d3c:	f243 132c 	movw	r3, #12588	; 0x312c
   13d40:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13d44:	681a      	ldr	r2, [r3, #0]
   13d46:	f243 1328 	movw	r3, #12584	; 0x3128
   13d4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13d4e:	601a      	str	r2, [r3, #0]
	pxOverflowTimerList = pxTemp;
   13d50:	f243 132c 	movw	r3, #12588	; 0x312c
   13d54:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13d58:	68ba      	ldr	r2, [r7, #8]
   13d5a:	601a      	str	r2, [r3, #0]
}
   13d5c:	f107 0718 	add.w	r7, r7, #24
   13d60:	46bd      	mov	sp, r7
   13d62:	bd80      	pop	{r7, pc}

00013d64 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
   13d64:	b580      	push	{r7, lr}
   13d66:	af00      	add	r7, sp, #0
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
   13d68:	f000 fb36 	bl	143d8 <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
   13d6c:	f243 1330 	movw	r3, #12592	; 0x3130
   13d70:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13d74:	681b      	ldr	r3, [r3, #0]
   13d76:	2b00      	cmp	r3, #0
   13d78:	d12b      	bne.n	13dd2 <prvCheckForValidListAndQueue+0x6e>
		{
			vListInitialise( &xActiveTimerList1 );
   13d7a:	f243 1000 	movw	r0, #12544	; 0x3100
   13d7e:	f2c2 0000 	movt	r0, #8192	; 0x2000
   13d82:	f7fb fa59 	bl	f238 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
   13d86:	f243 1014 	movw	r0, #12564	; 0x3114
   13d8a:	f2c2 0000 	movt	r0, #8192	; 0x2000
   13d8e:	f7fb fa53 	bl	f238 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
   13d92:	f243 1328 	movw	r3, #12584	; 0x3128
   13d96:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13d9a:	f243 1200 	movw	r2, #12544	; 0x3100
   13d9e:	f2c2 0200 	movt	r2, #8192	; 0x2000
   13da2:	601a      	str	r2, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
   13da4:	f243 132c 	movw	r3, #12588	; 0x312c
   13da8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13dac:	f243 1214 	movw	r2, #12564	; 0x3114
   13db0:	f2c2 0200 	movt	r2, #8192	; 0x2000
   13db4:	601a      	str	r2, [r3, #0]

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
   13db6:	f04f 000a 	mov.w	r0, #10
   13dba:	f04f 010c 	mov.w	r1, #12
   13dbe:	f04f 0200 	mov.w	r2, #0
   13dc2:	f7fb fb6b 	bl	f49c <xQueueGenericCreate>
   13dc6:	4602      	mov	r2, r0
   13dc8:	f243 1330 	movw	r3, #12592	; 0x3130
   13dcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13dd0:	601a      	str	r2, [r3, #0]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
   13dd2:	f000 fb39 	bl	14448 <vPortExitCritical>
}
   13dd6:	bd80      	pop	{r7, pc}

00013dd8 <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
{
   13dd8:	b580      	push	{r7, lr}
   13dda:	b086      	sub	sp, #24
   13ddc:	af00      	add	r7, sp, #0
   13dde:	6078      	str	r0, [r7, #4]
BaseType_t xTimerIsInActiveList;
Timer_t *pxTimer = xTimer;
   13de0:	687b      	ldr	r3, [r7, #4]
   13de2:	613b      	str	r3, [r7, #16]

	configASSERT( xTimer );
   13de4:	687b      	ldr	r3, [r7, #4]
   13de6:	2b00      	cmp	r3, #0
   13de8:	d109      	bne.n	13dfe <xTimerIsTimerActive+0x26>
   13dea:	f04f 0328 	mov.w	r3, #40	; 0x28
   13dee:	f383 8811 	msr	BASEPRI, r3
   13df2:	f3bf 8f6f 	isb	sy
   13df6:	f3bf 8f4f 	dsb	sy
   13dfa:	617b      	str	r3, [r7, #20]
   13dfc:	e7fe      	b.n	13dfc <xTimerIsTimerActive+0x24>

	/* Is the timer in the list of active timers? */
	taskENTER_CRITICAL();
   13dfe:	f000 faeb 	bl	143d8 <vPortEnterCritical>
	{
		/* Checking to see if it is in the NULL list in effect checks to see if
		it is referenced from either the current or the overflow timer lists in
		one go, but the logic has to be reversed, hence the '!'. */
		if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdTRUE )
   13e02:	693b      	ldr	r3, [r7, #16]
   13e04:	695b      	ldr	r3, [r3, #20]
   13e06:	2b00      	cmp	r3, #0
   13e08:	d103      	bne.n	13e12 <xTimerIsTimerActive+0x3a>
		{
			xTimerIsInActiveList = pdFALSE;
   13e0a:	f04f 0300 	mov.w	r3, #0
   13e0e:	60fb      	str	r3, [r7, #12]
   13e10:	e002      	b.n	13e18 <xTimerIsTimerActive+0x40>
		}
		else
		{
			xTimerIsInActiveList = pdTRUE;
   13e12:	f04f 0301 	mov.w	r3, #1
   13e16:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
   13e18:	f000 fb16 	bl	14448 <vPortExitCritical>

	return xTimerIsInActiveList;
   13e1c:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 Can't be pointer to const due to the typedef. */
   13e1e:	4618      	mov	r0, r3
   13e20:	f107 0718 	add.w	r7, r7, #24
   13e24:	46bd      	mov	sp, r7
   13e26:	bd80      	pop	{r7, pc}

00013e28 <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

void *pvTimerGetTimerID( const TimerHandle_t xTimer )
{
   13e28:	b580      	push	{r7, lr}
   13e2a:	b086      	sub	sp, #24
   13e2c:	af00      	add	r7, sp, #0
   13e2e:	6078      	str	r0, [r7, #4]
Timer_t * const pxTimer = xTimer;
   13e30:	687b      	ldr	r3, [r7, #4]
   13e32:	60fb      	str	r3, [r7, #12]
void *pvReturn;

	configASSERT( xTimer );
   13e34:	687b      	ldr	r3, [r7, #4]
   13e36:	2b00      	cmp	r3, #0
   13e38:	d109      	bne.n	13e4e <pvTimerGetTimerID+0x26>
   13e3a:	f04f 0328 	mov.w	r3, #40	; 0x28
   13e3e:	f383 8811 	msr	BASEPRI, r3
   13e42:	f3bf 8f6f 	isb	sy
   13e46:	f3bf 8f4f 	dsb	sy
   13e4a:	617b      	str	r3, [r7, #20]
   13e4c:	e7fe      	b.n	13e4c <pvTimerGetTimerID+0x24>

	taskENTER_CRITICAL();
   13e4e:	f000 fac3 	bl	143d8 <vPortEnterCritical>
	{
		pvReturn = pxTimer->pvTimerID;
   13e52:	68fb      	ldr	r3, [r7, #12]
   13e54:	6a1b      	ldr	r3, [r3, #32]
   13e56:	613b      	str	r3, [r7, #16]
	}
	taskEXIT_CRITICAL();
   13e58:	f000 faf6 	bl	14448 <vPortExitCritical>

	return pvReturn;
   13e5c:	693b      	ldr	r3, [r7, #16]
}
   13e5e:	4618      	mov	r0, r3
   13e60:	f107 0718 	add.w	r7, r7, #24
   13e64:	46bd      	mov	sp, r7
   13e66:	bd80      	pop	{r7, pc}

00013e68 <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
{
   13e68:	b580      	push	{r7, lr}
   13e6a:	b084      	sub	sp, #16
   13e6c:	af00      	add	r7, sp, #0
   13e6e:	6078      	str	r0, [r7, #4]
   13e70:	6039      	str	r1, [r7, #0]
Timer_t * const pxTimer = xTimer;
   13e72:	687b      	ldr	r3, [r7, #4]
   13e74:	60bb      	str	r3, [r7, #8]

	configASSERT( xTimer );
   13e76:	687b      	ldr	r3, [r7, #4]
   13e78:	2b00      	cmp	r3, #0
   13e7a:	d109      	bne.n	13e90 <vTimerSetTimerID+0x28>
   13e7c:	f04f 0328 	mov.w	r3, #40	; 0x28
   13e80:	f383 8811 	msr	BASEPRI, r3
   13e84:	f3bf 8f6f 	isb	sy
   13e88:	f3bf 8f4f 	dsb	sy
   13e8c:	60fb      	str	r3, [r7, #12]
   13e8e:	e7fe      	b.n	13e8e <vTimerSetTimerID+0x26>

	taskENTER_CRITICAL();
   13e90:	f000 faa2 	bl	143d8 <vPortEnterCritical>
	{
		pxTimer->pvTimerID = pvNewID;
   13e94:	68bb      	ldr	r3, [r7, #8]
   13e96:	683a      	ldr	r2, [r7, #0]
   13e98:	621a      	str	r2, [r3, #32]
	}
	taskEXIT_CRITICAL();
   13e9a:	f000 fad5 	bl	14448 <vPortExitCritical>
}
   13e9e:	f107 0710 	add.w	r7, r7, #16
   13ea2:	46bd      	mov	sp, r7
   13ea4:	bd80      	pop	{r7, pc}
   13ea6:	bf00      	nop

00013ea8 <uxTimerGetTimerNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTimerGetTimerNumber( TimerHandle_t xTimer )
	{
   13ea8:	b480      	push	{r7}
   13eaa:	b083      	sub	sp, #12
   13eac:	af00      	add	r7, sp, #0
   13eae:	6078      	str	r0, [r7, #4]
		return ( ( Timer_t * ) xTimer )->uxTimerNumber;
   13eb0:	687b      	ldr	r3, [r7, #4]
   13eb2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	}
   13eb4:	4618      	mov	r0, r3
   13eb6:	f107 070c 	add.w	r7, r7, #12
   13eba:	46bd      	mov	sp, r7
   13ebc:	bc80      	pop	{r7}
   13ebe:	4770      	bx	lr

00013ec0 <vTimerSetTimerNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTimerSetTimerNumber( TimerHandle_t xTimer, UBaseType_t uxTimerNumber )
	{
   13ec0:	b480      	push	{r7}
   13ec2:	b083      	sub	sp, #12
   13ec4:	af00      	add	r7, sp, #0
   13ec6:	6078      	str	r0, [r7, #4]
   13ec8:	6039      	str	r1, [r7, #0]
		( ( Timer_t * ) xTimer )->uxTimerNumber = uxTimerNumber;
   13eca:	687b      	ldr	r3, [r7, #4]
   13ecc:	683a      	ldr	r2, [r7, #0]
   13ece:	629a      	str	r2, [r3, #40]	; 0x28
	}
   13ed0:	f107 070c 	add.w	r7, r7, #12
   13ed4:	46bd      	mov	sp, r7
   13ed6:	bc80      	pop	{r7}
   13ed8:	4770      	bx	lr
   13eda:	bf00      	nop

00013edc <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
   13edc:	b580      	push	{r7, lr}
   13ede:	b088      	sub	sp, #32
   13ee0:	af00      	add	r7, sp, #0
   13ee2:	6078      	str	r0, [r7, #4]
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
   13ee4:	f04f 0300 	mov.w	r3, #0
   13ee8:	617b      	str	r3, [r7, #20]

	vTaskSuspendAll();
   13eea:	f7fd fb93 	bl	11614 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
   13eee:	f64a 134c 	movw	r3, #43340	; 0xa94c
   13ef2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13ef6:	681b      	ldr	r3, [r3, #0]
   13ef8:	2b00      	cmp	r3, #0
   13efa:	d108      	bne.n	13f0e <pvPortMalloc+0x32>
		{
			prvHeapInit();
   13efc:	f000 f8fa 	bl	140f4 <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
   13f00:	f64a 134c 	movw	r3, #43340	; 0xa94c
   13f04:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13f08:	f04f 0201 	mov.w	r2, #1
   13f0c:	601a      	str	r2, [r3, #0]
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
   13f0e:	687b      	ldr	r3, [r7, #4]
   13f10:	2b00      	cmp	r3, #0
   13f12:	d012      	beq.n	13f3a <pvPortMalloc+0x5e>
		{
			xWantedSize += heapSTRUCT_SIZE;
   13f14:	f64f 1340 	movw	r3, #63808	; 0xf940
   13f18:	f2c0 0302 	movt	r3, #2
   13f1c:	881b      	ldrh	r3, [r3, #0]
   13f1e:	687a      	ldr	r2, [r7, #4]
   13f20:	4413      	add	r3, r2
   13f22:	607b      	str	r3, [r7, #4]

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
   13f24:	687b      	ldr	r3, [r7, #4]
   13f26:	f003 0307 	and.w	r3, r3, #7
   13f2a:	2b00      	cmp	r3, #0
   13f2c:	d005      	beq.n	13f3a <pvPortMalloc+0x5e>
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
   13f2e:	687b      	ldr	r3, [r7, #4]
   13f30:	f023 0307 	bic.w	r3, r3, #7
   13f34:	f103 0308 	add.w	r3, r3, #8
   13f38:	607b      	str	r3, [r7, #4]
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
   13f3a:	687b      	ldr	r3, [r7, #4]
   13f3c:	2b00      	cmp	r3, #0
   13f3e:	d075      	beq.n	1402c <pvPortMalloc+0x150>
   13f40:	687a      	ldr	r2, [r7, #4]
   13f42:	f247 73f7 	movw	r3, #30711	; 0x77f7
   13f46:	429a      	cmp	r2, r3
   13f48:	d870      	bhi.n	1402c <pvPortMalloc+0x150>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
   13f4a:	f64a 133c 	movw	r3, #43324	; 0xa93c
   13f4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13f52:	60fb      	str	r3, [r7, #12]
			pxBlock = xStart.pxNextFreeBlock;
   13f54:	f64a 133c 	movw	r3, #43324	; 0xa93c
   13f58:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13f5c:	681b      	ldr	r3, [r3, #0]
   13f5e:	60bb      	str	r3, [r7, #8]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
   13f60:	e004      	b.n	13f6c <pvPortMalloc+0x90>
			{
				pxPreviousBlock = pxBlock;
   13f62:	68bb      	ldr	r3, [r7, #8]
   13f64:	60fb      	str	r3, [r7, #12]
				pxBlock = pxBlock->pxNextFreeBlock;
   13f66:	68bb      	ldr	r3, [r7, #8]
   13f68:	681b      	ldr	r3, [r3, #0]
   13f6a:	60bb      	str	r3, [r7, #8]
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
   13f6c:	68bb      	ldr	r3, [r7, #8]
   13f6e:	685a      	ldr	r2, [r3, #4]
   13f70:	687b      	ldr	r3, [r7, #4]
   13f72:	429a      	cmp	r2, r3
   13f74:	d203      	bcs.n	13f7e <pvPortMalloc+0xa2>
   13f76:	68bb      	ldr	r3, [r7, #8]
   13f78:	681b      	ldr	r3, [r3, #0]
   13f7a:	2b00      	cmp	r3, #0
   13f7c:	d1f1      	bne.n	13f62 <pvPortMalloc+0x86>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
   13f7e:	68ba      	ldr	r2, [r7, #8]
   13f80:	f64a 1344 	movw	r3, #43332	; 0xa944
   13f84:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13f88:	429a      	cmp	r2, r3
   13f8a:	d04f      	beq.n	1402c <pvPortMalloc+0x150>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
   13f8c:	68fb      	ldr	r3, [r7, #12]
   13f8e:	681a      	ldr	r2, [r3, #0]
   13f90:	f64f 1340 	movw	r3, #63808	; 0xf940
   13f94:	f2c0 0302 	movt	r3, #2
   13f98:	881b      	ldrh	r3, [r3, #0]
   13f9a:	4413      	add	r3, r2
   13f9c:	617b      	str	r3, [r7, #20]

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
   13f9e:	68bb      	ldr	r3, [r7, #8]
   13fa0:	681a      	ldr	r2, [r3, #0]
   13fa2:	68fb      	ldr	r3, [r7, #12]
   13fa4:	601a      	str	r2, [r3, #0]

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
   13fa6:	68bb      	ldr	r3, [r7, #8]
   13fa8:	685a      	ldr	r2, [r3, #4]
   13faa:	687b      	ldr	r3, [r7, #4]
   13fac:	ebc3 0202 	rsb	r2, r3, r2
   13fb0:	f64f 1340 	movw	r3, #63808	; 0xf940
   13fb4:	f2c0 0302 	movt	r3, #2
   13fb8:	881b      	ldrh	r3, [r3, #0]
   13fba:	ea4f 0343 	mov.w	r3, r3, lsl #1
   13fbe:	429a      	cmp	r2, r3
   13fc0:	d926      	bls.n	14010 <pvPortMalloc+0x134>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
   13fc2:	68ba      	ldr	r2, [r7, #8]
   13fc4:	687b      	ldr	r3, [r7, #4]
   13fc6:	4413      	add	r3, r2
   13fc8:	613b      	str	r3, [r7, #16]

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
   13fca:	68bb      	ldr	r3, [r7, #8]
   13fcc:	685a      	ldr	r2, [r3, #4]
   13fce:	687b      	ldr	r3, [r7, #4]
   13fd0:	ebc3 0202 	rsb	r2, r3, r2
   13fd4:	693b      	ldr	r3, [r7, #16]
   13fd6:	605a      	str	r2, [r3, #4]
					pxBlock->xBlockSize = xWantedSize;
   13fd8:	68bb      	ldr	r3, [r7, #8]
   13fda:	687a      	ldr	r2, [r7, #4]
   13fdc:	605a      	str	r2, [r3, #4]

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
   13fde:	693b      	ldr	r3, [r7, #16]
   13fe0:	685b      	ldr	r3, [r3, #4]
   13fe2:	61fb      	str	r3, [r7, #28]
   13fe4:	f64a 133c 	movw	r3, #43324	; 0xa93c
   13fe8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   13fec:	61bb      	str	r3, [r7, #24]
   13fee:	e002      	b.n	13ff6 <pvPortMalloc+0x11a>
   13ff0:	69bb      	ldr	r3, [r7, #24]
   13ff2:	681b      	ldr	r3, [r3, #0]
   13ff4:	61bb      	str	r3, [r7, #24]
   13ff6:	69bb      	ldr	r3, [r7, #24]
   13ff8:	681b      	ldr	r3, [r3, #0]
   13ffa:	685a      	ldr	r2, [r3, #4]
   13ffc:	69fb      	ldr	r3, [r7, #28]
   13ffe:	429a      	cmp	r2, r3
   14000:	d3f6      	bcc.n	13ff0 <pvPortMalloc+0x114>
   14002:	69bb      	ldr	r3, [r7, #24]
   14004:	681a      	ldr	r2, [r3, #0]
   14006:	693b      	ldr	r3, [r7, #16]
   14008:	601a      	str	r2, [r3, #0]
   1400a:	69bb      	ldr	r3, [r7, #24]
   1400c:	693a      	ldr	r2, [r7, #16]
   1400e:	601a      	str	r2, [r3, #0]
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
   14010:	f240 1304 	movw	r3, #260	; 0x104
   14014:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14018:	681a      	ldr	r2, [r3, #0]
   1401a:	68bb      	ldr	r3, [r7, #8]
   1401c:	685b      	ldr	r3, [r3, #4]
   1401e:	ebc3 0202 	rsb	r2, r3, r2
   14022:	f240 1304 	movw	r3, #260	; 0x104
   14026:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1402a:	601a      	str	r2, [r3, #0]
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
   1402c:	f7fd fb04 	bl	11638 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
   14030:	697b      	ldr	r3, [r7, #20]
   14032:	2b00      	cmp	r3, #0
   14034:	d101      	bne.n	1403a <pvPortMalloc+0x15e>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
   14036:	f7ec fda1 	bl	b7c <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
   1403a:	697b      	ldr	r3, [r7, #20]
}
   1403c:	4618      	mov	r0, r3
   1403e:	f107 0720 	add.w	r7, r7, #32
   14042:	46bd      	mov	sp, r7
   14044:	bd80      	pop	{r7, pc}
   14046:	bf00      	nop

00014048 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
   14048:	b580      	push	{r7, lr}
   1404a:	b086      	sub	sp, #24
   1404c:	af00      	add	r7, sp, #0
   1404e:	6078      	str	r0, [r7, #4]
uint8_t *puc = ( uint8_t * ) pv;
   14050:	687b      	ldr	r3, [r7, #4]
   14052:	60bb      	str	r3, [r7, #8]
BlockLink_t *pxLink;

	if( pv != NULL )
   14054:	687b      	ldr	r3, [r7, #4]
   14056:	2b00      	cmp	r3, #0
   14058:	d035      	beq.n	140c6 <vPortFree+0x7e>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
   1405a:	f64f 1340 	movw	r3, #63808	; 0xf940
   1405e:	f2c0 0302 	movt	r3, #2
   14062:	881b      	ldrh	r3, [r3, #0]
   14064:	f1c3 0300 	rsb	r3, r3, #0
   14068:	68ba      	ldr	r2, [r7, #8]
   1406a:	4413      	add	r3, r2
   1406c:	60bb      	str	r3, [r7, #8]

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
   1406e:	68bb      	ldr	r3, [r7, #8]
   14070:	60fb      	str	r3, [r7, #12]

		vTaskSuspendAll();
   14072:	f7fd facf 	bl	11614 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
   14076:	68fb      	ldr	r3, [r7, #12]
   14078:	685b      	ldr	r3, [r3, #4]
   1407a:	617b      	str	r3, [r7, #20]
   1407c:	f64a 133c 	movw	r3, #43324	; 0xa93c
   14080:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14084:	613b      	str	r3, [r7, #16]
   14086:	e002      	b.n	1408e <vPortFree+0x46>
   14088:	693b      	ldr	r3, [r7, #16]
   1408a:	681b      	ldr	r3, [r3, #0]
   1408c:	613b      	str	r3, [r7, #16]
   1408e:	693b      	ldr	r3, [r7, #16]
   14090:	681b      	ldr	r3, [r3, #0]
   14092:	685a      	ldr	r2, [r3, #4]
   14094:	697b      	ldr	r3, [r7, #20]
   14096:	429a      	cmp	r2, r3
   14098:	d3f6      	bcc.n	14088 <vPortFree+0x40>
   1409a:	693b      	ldr	r3, [r7, #16]
   1409c:	681a      	ldr	r2, [r3, #0]
   1409e:	68fb      	ldr	r3, [r7, #12]
   140a0:	601a      	str	r2, [r3, #0]
   140a2:	693b      	ldr	r3, [r7, #16]
   140a4:	68fa      	ldr	r2, [r7, #12]
   140a6:	601a      	str	r2, [r3, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
   140a8:	68fb      	ldr	r3, [r7, #12]
   140aa:	685a      	ldr	r2, [r3, #4]
   140ac:	f240 1304 	movw	r3, #260	; 0x104
   140b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   140b4:	681b      	ldr	r3, [r3, #0]
   140b6:	441a      	add	r2, r3
   140b8:	f240 1304 	movw	r3, #260	; 0x104
   140bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   140c0:	601a      	str	r2, [r3, #0]
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
   140c2:	f7fd fab9 	bl	11638 <xTaskResumeAll>
	}
}
   140c6:	f107 0718 	add.w	r7, r7, #24
   140ca:	46bd      	mov	sp, r7
   140cc:	bd80      	pop	{r7, pc}
   140ce:	bf00      	nop

000140d0 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
   140d0:	b480      	push	{r7}
   140d2:	af00      	add	r7, sp, #0
	return xFreeBytesRemaining;
   140d4:	f240 1304 	movw	r3, #260	; 0x104
   140d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   140dc:	681b      	ldr	r3, [r3, #0]
}
   140de:	4618      	mov	r0, r3
   140e0:	46bd      	mov	sp, r7
   140e2:	bc80      	pop	{r7}
   140e4:	4770      	bx	lr
   140e6:	bf00      	nop

000140e8 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
   140e8:	b480      	push	{r7}
   140ea:	af00      	add	r7, sp, #0
	/* This just exists to keep the linker quiet. */
}
   140ec:	46bd      	mov	sp, r7
   140ee:	bc80      	pop	{r7}
   140f0:	4770      	bx	lr
   140f2:	bf00      	nop

000140f4 <prvHeapInit>:
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
   140f4:	b480      	push	{r7}
   140f6:	b083      	sub	sp, #12
   140f8:	af00      	add	r7, sp, #0
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
   140fa:	4b18      	ldr	r3, [pc, #96]	; (1415c <prvHeapInit+0x68>)
   140fc:	f023 0307 	bic.w	r3, r3, #7
   14100:	607b      	str	r3, [r7, #4]

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
   14102:	687a      	ldr	r2, [r7, #4]
   14104:	f64a 133c 	movw	r3, #43324	; 0xa93c
   14108:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1410c:	601a      	str	r2, [r3, #0]
	xStart.xBlockSize = ( size_t ) 0;
   1410e:	f64a 133c 	movw	r3, #43324	; 0xa93c
   14112:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14116:	f04f 0200 	mov.w	r2, #0
   1411a:	605a      	str	r2, [r3, #4]

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
   1411c:	f64a 1344 	movw	r3, #43332	; 0xa944
   14120:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14124:	f247 72f8 	movw	r2, #30712	; 0x77f8
   14128:	605a      	str	r2, [r3, #4]
	xEnd.pxNextFreeBlock = NULL;
   1412a:	f64a 1344 	movw	r3, #43332	; 0xa944
   1412e:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14132:	f04f 0200 	mov.w	r2, #0
   14136:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
   14138:	687b      	ldr	r3, [r7, #4]
   1413a:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
   1413c:	683b      	ldr	r3, [r7, #0]
   1413e:	f247 72f8 	movw	r2, #30712	; 0x77f8
   14142:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
   14144:	683a      	ldr	r2, [r7, #0]
   14146:	f64a 1344 	movw	r3, #43332	; 0xa944
   1414a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1414e:	6013      	str	r3, [r2, #0]
}
   14150:	f107 070c 	add.w	r7, r7, #12
   14154:	46bd      	mov	sp, r7
   14156:	bc80      	pop	{r7}
   14158:	4770      	bx	lr
   1415a:	bf00      	nop
   1415c:	20003144 	.word	0x20003144

00014160 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
   14160:	b480      	push	{r7}
   14162:	b085      	sub	sp, #20
   14164:	af00      	add	r7, sp, #0
   14166:	60f8      	str	r0, [r7, #12]
   14168:	60b9      	str	r1, [r7, #8]
   1416a:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
   1416c:	68fb      	ldr	r3, [r7, #12]
   1416e:	f1a3 0304 	sub.w	r3, r3, #4
   14172:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
   14174:	68fb      	ldr	r3, [r7, #12]
   14176:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   1417a:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   1417c:	68fb      	ldr	r3, [r7, #12]
   1417e:	f1a3 0304 	sub.w	r3, r3, #4
   14182:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
   14184:	68bb      	ldr	r3, [r7, #8]
   14186:	f023 0201 	bic.w	r2, r3, #1
   1418a:	68fb      	ldr	r3, [r7, #12]
   1418c:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   1418e:	68fb      	ldr	r3, [r7, #12]
   14190:	f1a3 0304 	sub.w	r3, r3, #4
   14194:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
   14196:	f244 13c9 	movw	r3, #16841	; 0x41c9
   1419a:	f2c0 0301 	movt	r3, #1
   1419e:	68fa      	ldr	r2, [r7, #12]
   141a0:	6013      	str	r3, [r2, #0]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
   141a2:	68fb      	ldr	r3, [r7, #12]
   141a4:	f1a3 0314 	sub.w	r3, r3, #20
   141a8:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
   141aa:	687a      	ldr	r2, [r7, #4]
   141ac:	68fb      	ldr	r3, [r7, #12]
   141ae:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
   141b0:	68fb      	ldr	r3, [r7, #12]
   141b2:	f1a3 0320 	sub.w	r3, r3, #32
   141b6:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
   141b8:	68fb      	ldr	r3, [r7, #12]
}
   141ba:	4618      	mov	r0, r3
   141bc:	f107 0714 	add.w	r7, r7, #20
   141c0:	46bd      	mov	sp, r7
   141c2:	bc80      	pop	{r7}
   141c4:	4770      	bx	lr
   141c6:	bf00      	nop

000141c8 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
   141c8:	b480      	push	{r7}
   141ca:	b085      	sub	sp, #20
   141cc:	af00      	add	r7, sp, #0
volatile uint32_t ulDummy = 0UL;
   141ce:	f04f 0300 	mov.w	r3, #0
   141d2:	607b      	str	r3, [r7, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
   141d4:	f240 1308 	movw	r3, #264	; 0x108
   141d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   141dc:	681b      	ldr	r3, [r3, #0]
   141de:	f1b3 3fff 	cmp.w	r3, #4294967295
   141e2:	d009      	beq.n	141f8 <prvTaskExitError+0x30>
   141e4:	f04f 0328 	mov.w	r3, #40	; 0x28
   141e8:	f383 8811 	msr	BASEPRI, r3
   141ec:	f3bf 8f6f 	isb	sy
   141f0:	f3bf 8f4f 	dsb	sy
   141f4:	60bb      	str	r3, [r7, #8]
   141f6:	e7fe      	b.n	141f6 <prvTaskExitError+0x2e>
   141f8:	f04f 0328 	mov.w	r3, #40	; 0x28
   141fc:	f383 8811 	msr	BASEPRI, r3
   14200:	f3bf 8f6f 	isb	sy
   14204:	f3bf 8f4f 	dsb	sy
   14208:	60fb      	str	r3, [r7, #12]
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
   1420a:	687b      	ldr	r3, [r7, #4]
   1420c:	2b00      	cmp	r3, #0
   1420e:	d0fc      	beq.n	1420a <prvTaskExitError+0x42>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
   14210:	f107 0714 	add.w	r7, r7, #20
   14214:	46bd      	mov	sp, r7
   14216:	bc80      	pop	{r7}
   14218:	4770      	bx	lr
   1421a:	bf00      	nop
   1421c:	0000      	lsls	r0, r0, #0
	...

00014220 <SVC_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
   14220:	4b07      	ldr	r3, [pc, #28]	; (14240 <pxCurrentTCBConst2>)
   14222:	6819      	ldr	r1, [r3, #0]
   14224:	6808      	ldr	r0, [r1, #0]
   14226:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   1422a:	f380 8809 	msr	PSP, r0
   1422e:	f3bf 8f6f 	isb	sy
   14232:	f04f 0000 	mov.w	r0, #0
   14236:	f380 8811 	msr	BASEPRI, r0
   1423a:	f04e 0e0d 	orr.w	lr, lr, #13
   1423e:	4770      	bx	lr

00014240 <pxCurrentTCBConst2>:
   14240:	20002ff4 	.word	0x20002ff4
   14244:	f3af 8000 	nop.w
   14248:	f3af 8000 	nop.w
   1424c:	f3af 8000 	nop.w

00014250 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
   14250:	4806      	ldr	r0, [pc, #24]	; (1426c <prvPortStartFirstTask+0x1c>)
   14252:	6800      	ldr	r0, [r0, #0]
   14254:	6800      	ldr	r0, [r0, #0]
   14256:	f380 8808 	msr	MSP, r0
   1425a:	b662      	cpsie	i
   1425c:	b661      	cpsie	f
   1425e:	f3bf 8f4f 	dsb	sy
   14262:	f3bf 8f6f 	isb	sy
   14266:	df00      	svc	0
   14268:	bf00      	nop
   1426a:	0000      	.short	0x0000
   1426c:	e000ed08 	.word	0xe000ed08

00014270 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
   14270:	b580      	push	{r7, lr}
   14272:	b084      	sub	sp, #16
   14274:	af00      	add	r7, sp, #0
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	#if( configASSERT_DEFINED == 1 )
	{
		volatile uint32_t ulOriginalPriority;
		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
   14276:	f24e 4300 	movw	r3, #58368	; 0xe400
   1427a:	f2ce 0300 	movt	r3, #57344	; 0xe000
   1427e:	60bb      	str	r3, [r7, #8]
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
   14280:	68bb      	ldr	r3, [r7, #8]
   14282:	781b      	ldrb	r3, [r3, #0]
   14284:	b2db      	uxtb	r3, r3
   14286:	607b      	str	r3, [r7, #4]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
   14288:	68bb      	ldr	r3, [r7, #8]
   1428a:	f04f 32ff 	mov.w	r2, #4294967295
   1428e:	701a      	strb	r2, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
   14290:	68bb      	ldr	r3, [r7, #8]
   14292:	781b      	ldrb	r3, [r3, #0]
   14294:	b2db      	uxtb	r3, r3
   14296:	70fb      	strb	r3, [r7, #3]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
   14298:	78fb      	ldrb	r3, [r7, #3]
   1429a:	b2db      	uxtb	r3, r3
   1429c:	461a      	mov	r2, r3
   1429e:	f002 0228 	and.w	r2, r2, #40	; 0x28
   142a2:	f64a 1350 	movw	r3, #43344	; 0xa950
   142a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
   142aa:	701a      	strb	r2, [r3, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
   142ac:	f64a 1354 	movw	r3, #43348	; 0xa954
   142b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   142b4:	f04f 0207 	mov.w	r2, #7
   142b8:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
   142ba:	e011      	b.n	142e0 <xPortStartScheduler+0x70>
		{
			ulMaxPRIGROUPValue--;
   142bc:	f64a 1354 	movw	r3, #43348	; 0xa954
   142c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   142c4:	681b      	ldr	r3, [r3, #0]
   142c6:	f103 32ff 	add.w	r2, r3, #4294967295
   142ca:	f64a 1354 	movw	r3, #43348	; 0xa954
   142ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
   142d2:	601a      	str	r2, [r3, #0]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
   142d4:	78fb      	ldrb	r3, [r7, #3]
   142d6:	b2db      	uxtb	r3, r3
   142d8:	ea4f 0343 	mov.w	r3, r3, lsl #1
   142dc:	b2db      	uxtb	r3, r3
   142de:	70fb      	strb	r3, [r7, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
   142e0:	78fb      	ldrb	r3, [r7, #3]
   142e2:	b2db      	uxtb	r3, r3
   142e4:	b25b      	sxtb	r3, r3
   142e6:	2b00      	cmp	r3, #0
   142e8:	dbe8      	blt.n	142bc <xPortStartScheduler+0x4c>
		#ifdef configPRIO_BITS
		{
			/* Check the FreeRTOS configuration that defines the number of
			priority bits matches the number of priority bits actually queried
			from the hardware. */
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
   142ea:	f64a 1354 	movw	r3, #43348	; 0xa954
   142ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
   142f2:	681b      	ldr	r3, [r3, #0]
   142f4:	f1c3 0307 	rsb	r3, r3, #7
   142f8:	2b05      	cmp	r3, #5
   142fa:	d009      	beq.n	14310 <xPortStartScheduler+0xa0>
   142fc:	f04f 0328 	mov.w	r3, #40	; 0x28
   14300:	f383 8811 	msr	BASEPRI, r3
   14304:	f3bf 8f6f 	isb	sy
   14308:	f3bf 8f4f 	dsb	sy
   1430c:	60fb      	str	r3, [r7, #12]
   1430e:	e7fe      	b.n	1430e <xPortStartScheduler+0x9e>
		}
		#endif

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
   14310:	f64a 1354 	movw	r3, #43348	; 0xa954
   14314:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14318:	681b      	ldr	r3, [r3, #0]
   1431a:	ea4f 2203 	mov.w	r2, r3, lsl #8
   1431e:	f64a 1354 	movw	r3, #43348	; 0xa954
   14322:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14326:	601a      	str	r2, [r3, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
   14328:	f64a 1354 	movw	r3, #43348	; 0xa954
   1432c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14330:	681b      	ldr	r3, [r3, #0]
   14332:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
   14336:	f64a 1354 	movw	r3, #43348	; 0xa954
   1433a:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1433e:	601a      	str	r2, [r3, #0]

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pucFirstUserPriorityRegister = ulOriginalPriority;
   14340:	687b      	ldr	r3, [r7, #4]
   14342:	b2da      	uxtb	r2, r3
   14344:	68bb      	ldr	r3, [r7, #8]
   14346:	701a      	strb	r2, [r3, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
   14348:	f64e 5320 	movw	r3, #60704	; 0xed20
   1434c:	f2ce 0300 	movt	r3, #57344	; 0xe000
   14350:	f64e 5220 	movw	r2, #60704	; 0xed20
   14354:	f2ce 0200 	movt	r2, #57344	; 0xe000
   14358:	6812      	ldr	r2, [r2, #0]
   1435a:	f442 0278 	orr.w	r2, r2, #16252928	; 0xf80000
   1435e:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
   14360:	f64e 5320 	movw	r3, #60704	; 0xed20
   14364:	f2ce 0300 	movt	r3, #57344	; 0xe000
   14368:	f64e 5220 	movw	r2, #60704	; 0xed20
   1436c:	f2ce 0200 	movt	r2, #57344	; 0xe000
   14370:	6812      	ldr	r2, [r2, #0]
   14372:	f042 4278 	orr.w	r2, r2, #4160749568	; 0xf8000000
   14376:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
   14378:	f000 f8e4 	bl	14544 <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
   1437c:	f240 1308 	movw	r3, #264	; 0x108
   14380:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14384:	f04f 0200 	mov.w	r2, #0
   14388:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
   1438a:	f7ff ff61 	bl	14250 <prvPortStartFirstTask>
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS.  Call
	vTaskSwitchContext() so link time optimisation does not remove the
	symbol. */
	vTaskSwitchContext();
   1438e:	f7fd fc2b 	bl	11be8 <vTaskSwitchContext>
	prvTaskExitError();
   14392:	f7ff ff19 	bl	141c8 <prvTaskExitError>

	/* Should not get here! */
	return 0;
   14396:	f04f 0300 	mov.w	r3, #0
}
   1439a:	4618      	mov	r0, r3
   1439c:	f107 0710 	add.w	r7, r7, #16
   143a0:	46bd      	mov	sp, r7
   143a2:	bd80      	pop	{r7, pc}

000143a4 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
   143a4:	b480      	push	{r7}
   143a6:	b083      	sub	sp, #12
   143a8:	af00      	add	r7, sp, #0
	/* Not implemented in ports where there is nothing to return to.
	Artificially force an assert. */
	configASSERT( uxCriticalNesting == 1000UL );
   143aa:	f240 1308 	movw	r3, #264	; 0x108
   143ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
   143b2:	681b      	ldr	r3, [r3, #0]
   143b4:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
   143b8:	d009      	beq.n	143ce <vPortEndScheduler+0x2a>
   143ba:	f04f 0328 	mov.w	r3, #40	; 0x28
   143be:	f383 8811 	msr	BASEPRI, r3
   143c2:	f3bf 8f6f 	isb	sy
   143c6:	f3bf 8f4f 	dsb	sy
   143ca:	607b      	str	r3, [r7, #4]
   143cc:	e7fe      	b.n	143cc <vPortEndScheduler+0x28>
}
   143ce:	f107 070c 	add.w	r7, r7, #12
   143d2:	46bd      	mov	sp, r7
   143d4:	bc80      	pop	{r7}
   143d6:	4770      	bx	lr

000143d8 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
   143d8:	b480      	push	{r7}
   143da:	b083      	sub	sp, #12
   143dc:	af00      	add	r7, sp, #0
   143de:	f04f 0328 	mov.w	r3, #40	; 0x28
   143e2:	f383 8811 	msr	BASEPRI, r3
   143e6:	f3bf 8f6f 	isb	sy
   143ea:	f3bf 8f4f 	dsb	sy
   143ee:	603b      	str	r3, [r7, #0]
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
   143f0:	f240 1308 	movw	r3, #264	; 0x108
   143f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   143f8:	681b      	ldr	r3, [r3, #0]
   143fa:	f103 0201 	add.w	r2, r3, #1
   143fe:	f240 1308 	movw	r3, #264	; 0x108
   14402:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14406:	601a      	str	r2, [r3, #0]
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
   14408:	f240 1308 	movw	r3, #264	; 0x108
   1440c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14410:	681b      	ldr	r3, [r3, #0]
   14412:	2b01      	cmp	r3, #1
   14414:	d112      	bne.n	1443c <vPortEnterCritical+0x64>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
   14416:	f64e 5304 	movw	r3, #60676	; 0xed04
   1441a:	f2ce 0300 	movt	r3, #57344	; 0xe000
   1441e:	681b      	ldr	r3, [r3, #0]
   14420:	f003 03ff 	and.w	r3, r3, #255	; 0xff
   14424:	2b00      	cmp	r3, #0
   14426:	d009      	beq.n	1443c <vPortEnterCritical+0x64>
   14428:	f04f 0328 	mov.w	r3, #40	; 0x28
   1442c:	f383 8811 	msr	BASEPRI, r3
   14430:	f3bf 8f6f 	isb	sy
   14434:	f3bf 8f4f 	dsb	sy
   14438:	607b      	str	r3, [r7, #4]
   1443a:	e7fe      	b.n	1443a <vPortEnterCritical+0x62>
	}
}
   1443c:	f107 070c 	add.w	r7, r7, #12
   14440:	46bd      	mov	sp, r7
   14442:	bc80      	pop	{r7}
   14444:	4770      	bx	lr
   14446:	bf00      	nop

00014448 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
   14448:	b480      	push	{r7}
   1444a:	b083      	sub	sp, #12
   1444c:	af00      	add	r7, sp, #0
	configASSERT( uxCriticalNesting );
   1444e:	f240 1308 	movw	r3, #264	; 0x108
   14452:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14456:	681b      	ldr	r3, [r3, #0]
   14458:	2b00      	cmp	r3, #0
   1445a:	d109      	bne.n	14470 <vPortExitCritical+0x28>
   1445c:	f04f 0328 	mov.w	r3, #40	; 0x28
   14460:	f383 8811 	msr	BASEPRI, r3
   14464:	f3bf 8f6f 	isb	sy
   14468:	f3bf 8f4f 	dsb	sy
   1446c:	603b      	str	r3, [r7, #0]
   1446e:	e7fe      	b.n	1446e <vPortExitCritical+0x26>
	uxCriticalNesting--;
   14470:	f240 1308 	movw	r3, #264	; 0x108
   14474:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14478:	681b      	ldr	r3, [r3, #0]
   1447a:	f103 32ff 	add.w	r2, r3, #4294967295
   1447e:	f240 1308 	movw	r3, #264	; 0x108
   14482:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14486:	601a      	str	r2, [r3, #0]
	if( uxCriticalNesting == 0 )
   14488:	f240 1308 	movw	r3, #264	; 0x108
   1448c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   14490:	681b      	ldr	r3, [r3, #0]
   14492:	2b00      	cmp	r3, #0
   14494:	d105      	bne.n	144a2 <vPortExitCritical+0x5a>
   14496:	f04f 0300 	mov.w	r3, #0
   1449a:	607b      	str	r3, [r7, #4]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   1449c:	687b      	ldr	r3, [r7, #4]
   1449e:	f383 8811 	msr	BASEPRI, r3
	{
		portENABLE_INTERRUPTS();
	}
}
   144a2:	f107 070c 	add.w	r7, r7, #12
   144a6:	46bd      	mov	sp, r7
   144a8:	bc80      	pop	{r7}
   144aa:	4770      	bx	lr
   144ac:	0000      	lsls	r0, r0, #0
	...

000144b0 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
   144b0:	f3ef 8009 	mrs	r0, PSP
   144b4:	f3bf 8f6f 	isb	sy
   144b8:	4b0d      	ldr	r3, [pc, #52]	; (144f0 <pxCurrentTCBConst>)
   144ba:	681a      	ldr	r2, [r3, #0]
   144bc:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   144c0:	6010      	str	r0, [r2, #0]
   144c2:	e92d 4008 	stmdb	sp!, {r3, lr}
   144c6:	f04f 0028 	mov.w	r0, #40	; 0x28
   144ca:	f380 8811 	msr	BASEPRI, r0
   144ce:	f7fd fb8b 	bl	11be8 <vTaskSwitchContext>
   144d2:	f04f 0000 	mov.w	r0, #0
   144d6:	f380 8811 	msr	BASEPRI, r0
   144da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   144de:	6819      	ldr	r1, [r3, #0]
   144e0:	6808      	ldr	r0, [r1, #0]
   144e2:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   144e6:	f380 8809 	msr	PSP, r0
   144ea:	f3bf 8f6f 	isb	sy
   144ee:	4770      	bx	lr

000144f0 <pxCurrentTCBConst>:
   144f0:	20002ff4 	.word	0x20002ff4
   144f4:	f3af 8000 	nop.w
   144f8:	f3af 8000 	nop.w
   144fc:	f3af 8000 	nop.w

00014500 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
   14500:	b580      	push	{r7, lr}
   14502:	b082      	sub	sp, #8
   14504:	af00      	add	r7, sp, #0

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   14506:	f04f 0328 	mov.w	r3, #40	; 0x28
   1450a:	f383 8811 	msr	BASEPRI, r3
   1450e:	f3bf 8f6f 	isb	sy
   14512:	f3bf 8f4f 	dsb	sy
   14516:	603b      	str	r3, [r7, #0]
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
   14518:	f7fd fa64 	bl	119e4 <xTaskIncrementTick>
   1451c:	4603      	mov	r3, r0
   1451e:	2b00      	cmp	r3, #0
   14520:	d006      	beq.n	14530 <SysTick_Handler+0x30>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   14522:	f64e 5304 	movw	r3, #60676	; 0xed04
   14526:	f2ce 0300 	movt	r3, #57344	; 0xe000
   1452a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1452e:	601a      	str	r2, [r3, #0]
   14530:	f04f 0300 	mov.w	r3, #0
   14534:	607b      	str	r3, [r7, #4]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   14536:	687b      	ldr	r3, [r7, #4]
   14538:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
   1453c:	f107 0708 	add.w	r7, r7, #8
   14540:	46bd      	mov	sp, r7
   14542:	bd80      	pop	{r7, pc}

00014544 <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
   14544:	b480      	push	{r7}
   14546:	af00      	add	r7, sp, #0
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Stop and clear the SysTick. */
	portNVIC_SYSTICK_CTRL_REG = 0UL;
   14548:	f24e 0310 	movw	r3, #57360	; 0xe010
   1454c:	f2ce 0300 	movt	r3, #57344	; 0xe000
   14550:	f04f 0200 	mov.w	r2, #0
   14554:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
   14556:	f24e 0318 	movw	r3, #57368	; 0xe018
   1455a:	f2ce 0300 	movt	r3, #57344	; 0xe000
   1455e:	f04f 0200 	mov.w	r2, #0
   14562:	601a      	str	r2, [r3, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
   14564:	f24e 0314 	movw	r3, #57364	; 0xe014
   14568:	f2ce 0300 	movt	r3, #57344	; 0xe000
   1456c:	f240 02e8 	movw	r2, #232	; 0xe8
   14570:	f2c2 0200 	movt	r2, #8192	; 0x2000
   14574:	6811      	ldr	r1, [r2, #0]
   14576:	f644 52d3 	movw	r2, #19923	; 0x4dd3
   1457a:	f2c1 0262 	movt	r2, #4194	; 0x1062
   1457e:	fba2 0201 	umull	r0, r2, r2, r1
   14582:	ea4f 1292 	mov.w	r2, r2, lsr #6
   14586:	f102 32ff 	add.w	r2, r2, #4294967295
   1458a:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
   1458c:	f24e 0310 	movw	r3, #57360	; 0xe010
   14590:	f2ce 0300 	movt	r3, #57344	; 0xe000
   14594:	f04f 0207 	mov.w	r2, #7
   14598:	601a      	str	r2, [r3, #0]
}
   1459a:	46bd      	mov	sp, r7
   1459c:	bc80      	pop	{r7}
   1459e:	4770      	bx	lr

000145a0 <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
   145a0:	b480      	push	{r7}
   145a2:	b085      	sub	sp, #20
   145a4:	af00      	add	r7, sp, #0
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
   145a6:	f3ef 8305 	mrs	r3, IPSR
   145aa:	603b      	str	r3, [r7, #0]

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
   145ac:	683b      	ldr	r3, [r7, #0]
   145ae:	2b0f      	cmp	r3, #15
   145b0:	d91a      	bls.n	145e8 <vPortValidateInterruptPriority+0x48>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
   145b2:	f64f 1344 	movw	r3, #63812	; 0xf944
   145b6:	f2c0 0302 	movt	r3, #2
   145ba:	681a      	ldr	r2, [r3, #0]
   145bc:	683b      	ldr	r3, [r7, #0]
   145be:	4413      	add	r3, r2
   145c0:	781b      	ldrb	r3, [r3, #0]
   145c2:	71fb      	strb	r3, [r7, #7]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
   145c4:	f64a 1350 	movw	r3, #43344	; 0xa950
   145c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
   145cc:	781b      	ldrb	r3, [r3, #0]
   145ce:	79fa      	ldrb	r2, [r7, #7]
   145d0:	429a      	cmp	r2, r3
   145d2:	d209      	bcs.n	145e8 <vPortValidateInterruptPriority+0x48>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   145d4:	f04f 0328 	mov.w	r3, #40	; 0x28
   145d8:	f383 8811 	msr	BASEPRI, r3
   145dc:	f3bf 8f6f 	isb	sy
   145e0:	f3bf 8f4f 	dsb	sy
   145e4:	60bb      	str	r3, [r7, #8]
   145e6:	e7fe      	b.n	145e6 <vPortValidateInterruptPriority+0x46>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
   145e8:	f64e 530c 	movw	r3, #60684	; 0xed0c
   145ec:	f2ce 0300 	movt	r3, #57344	; 0xe000
   145f0:	681b      	ldr	r3, [r3, #0]
   145f2:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
   145f6:	f64a 1354 	movw	r3, #43348	; 0xa954
   145fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
   145fe:	681b      	ldr	r3, [r3, #0]
   14600:	429a      	cmp	r2, r3
   14602:	d909      	bls.n	14618 <vPortValidateInterruptPriority+0x78>
   14604:	f04f 0328 	mov.w	r3, #40	; 0x28
   14608:	f383 8811 	msr	BASEPRI, r3
   1460c:	f3bf 8f6f 	isb	sy
   14610:	f3bf 8f4f 	dsb	sy
   14614:	60fb      	str	r3, [r7, #12]
   14616:	e7fe      	b.n	14616 <vPortValidateInterruptPriority+0x76>
	}
   14618:	f107 0714 	add.w	r7, r7, #20
   1461c:	46bd      	mov	sp, r7
   1461e:	bc80      	pop	{r7}
   14620:	4770      	bx	lr
   14622:	bf00      	nop

00014624 <__aeabi_drsub>:
   14624:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
   14628:	e002      	b.n	14630 <__adddf3>
   1462a:	bf00      	nop

0001462c <__aeabi_dsub>:
   1462c:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

00014630 <__adddf3>:
   14630:	b530      	push	{r4, r5, lr}
   14632:	ea4f 0441 	mov.w	r4, r1, lsl #1
   14636:	ea4f 0543 	mov.w	r5, r3, lsl #1
   1463a:	ea94 0f05 	teq	r4, r5
   1463e:	bf08      	it	eq
   14640:	ea90 0f02 	teqeq	r0, r2
   14644:	bf1f      	itttt	ne
   14646:	ea54 0c00 	orrsne.w	ip, r4, r0
   1464a:	ea55 0c02 	orrsne.w	ip, r5, r2
   1464e:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
   14652:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   14656:	f000 80e2 	beq.w	1481e <__adddf3+0x1ee>
   1465a:	ea4f 5454 	mov.w	r4, r4, lsr #21
   1465e:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
   14662:	bfb8      	it	lt
   14664:	426d      	neglt	r5, r5
   14666:	dd0c      	ble.n	14682 <__adddf3+0x52>
   14668:	442c      	add	r4, r5
   1466a:	ea80 0202 	eor.w	r2, r0, r2
   1466e:	ea81 0303 	eor.w	r3, r1, r3
   14672:	ea82 0000 	eor.w	r0, r2, r0
   14676:	ea83 0101 	eor.w	r1, r3, r1
   1467a:	ea80 0202 	eor.w	r2, r0, r2
   1467e:	ea81 0303 	eor.w	r3, r1, r3
   14682:	2d36      	cmp	r5, #54	; 0x36
   14684:	bf88      	it	hi
   14686:	bd30      	pophi	{r4, r5, pc}
   14688:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   1468c:	ea4f 3101 	mov.w	r1, r1, lsl #12
   14690:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
   14694:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
   14698:	d002      	beq.n	146a0 <__adddf3+0x70>
   1469a:	4240      	negs	r0, r0
   1469c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   146a0:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
   146a4:	ea4f 3303 	mov.w	r3, r3, lsl #12
   146a8:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
   146ac:	d002      	beq.n	146b4 <__adddf3+0x84>
   146ae:	4252      	negs	r2, r2
   146b0:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   146b4:	ea94 0f05 	teq	r4, r5
   146b8:	f000 80a7 	beq.w	1480a <__adddf3+0x1da>
   146bc:	f1a4 0401 	sub.w	r4, r4, #1
   146c0:	f1d5 0e20 	rsbs	lr, r5, #32
   146c4:	db0d      	blt.n	146e2 <__adddf3+0xb2>
   146c6:	fa02 fc0e 	lsl.w	ip, r2, lr
   146ca:	fa22 f205 	lsr.w	r2, r2, r5
   146ce:	1880      	adds	r0, r0, r2
   146d0:	f141 0100 	adc.w	r1, r1, #0
   146d4:	fa03 f20e 	lsl.w	r2, r3, lr
   146d8:	1880      	adds	r0, r0, r2
   146da:	fa43 f305 	asr.w	r3, r3, r5
   146de:	4159      	adcs	r1, r3
   146e0:	e00e      	b.n	14700 <__adddf3+0xd0>
   146e2:	f1a5 0520 	sub.w	r5, r5, #32
   146e6:	f10e 0e20 	add.w	lr, lr, #32
   146ea:	2a01      	cmp	r2, #1
   146ec:	fa03 fc0e 	lsl.w	ip, r3, lr
   146f0:	bf28      	it	cs
   146f2:	f04c 0c02 	orrcs.w	ip, ip, #2
   146f6:	fa43 f305 	asr.w	r3, r3, r5
   146fa:	18c0      	adds	r0, r0, r3
   146fc:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
   14700:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   14704:	d507      	bpl.n	14716 <__adddf3+0xe6>
   14706:	f04f 0e00 	mov.w	lr, #0
   1470a:	f1dc 0c00 	rsbs	ip, ip, #0
   1470e:	eb7e 0000 	sbcs.w	r0, lr, r0
   14712:	eb6e 0101 	sbc.w	r1, lr, r1
   14716:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
   1471a:	d31b      	bcc.n	14754 <__adddf3+0x124>
   1471c:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
   14720:	d30c      	bcc.n	1473c <__adddf3+0x10c>
   14722:	0849      	lsrs	r1, r1, #1
   14724:	ea5f 0030 	movs.w	r0, r0, rrx
   14728:	ea4f 0c3c 	mov.w	ip, ip, rrx
   1472c:	f104 0401 	add.w	r4, r4, #1
   14730:	ea4f 5244 	mov.w	r2, r4, lsl #21
   14734:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
   14738:	f080 809a 	bcs.w	14870 <__adddf3+0x240>
   1473c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   14740:	bf08      	it	eq
   14742:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   14746:	f150 0000 	adcs.w	r0, r0, #0
   1474a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   1474e:	ea41 0105 	orr.w	r1, r1, r5
   14752:	bd30      	pop	{r4, r5, pc}
   14754:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
   14758:	4140      	adcs	r0, r0
   1475a:	eb41 0101 	adc.w	r1, r1, r1
   1475e:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   14762:	f1a4 0401 	sub.w	r4, r4, #1
   14766:	d1e9      	bne.n	1473c <__adddf3+0x10c>
   14768:	f091 0f00 	teq	r1, #0
   1476c:	bf04      	itt	eq
   1476e:	4601      	moveq	r1, r0
   14770:	2000      	moveq	r0, #0
   14772:	fab1 f381 	clz	r3, r1
   14776:	bf08      	it	eq
   14778:	3320      	addeq	r3, #32
   1477a:	f1a3 030b 	sub.w	r3, r3, #11
   1477e:	f1b3 0220 	subs.w	r2, r3, #32
   14782:	da0c      	bge.n	1479e <__adddf3+0x16e>
   14784:	320c      	adds	r2, #12
   14786:	dd08      	ble.n	1479a <__adddf3+0x16a>
   14788:	f102 0c14 	add.w	ip, r2, #20
   1478c:	f1c2 020c 	rsb	r2, r2, #12
   14790:	fa01 f00c 	lsl.w	r0, r1, ip
   14794:	fa21 f102 	lsr.w	r1, r1, r2
   14798:	e00c      	b.n	147b4 <__adddf3+0x184>
   1479a:	f102 0214 	add.w	r2, r2, #20
   1479e:	bfd8      	it	le
   147a0:	f1c2 0c20 	rsble	ip, r2, #32
   147a4:	fa01 f102 	lsl.w	r1, r1, r2
   147a8:	fa20 fc0c 	lsr.w	ip, r0, ip
   147ac:	bfdc      	itt	le
   147ae:	ea41 010c 	orrle.w	r1, r1, ip
   147b2:	4090      	lslle	r0, r2
   147b4:	1ae4      	subs	r4, r4, r3
   147b6:	bfa2      	ittt	ge
   147b8:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
   147bc:	4329      	orrge	r1, r5
   147be:	bd30      	popge	{r4, r5, pc}
   147c0:	ea6f 0404 	mvn.w	r4, r4
   147c4:	3c1f      	subs	r4, #31
   147c6:	da1c      	bge.n	14802 <__adddf3+0x1d2>
   147c8:	340c      	adds	r4, #12
   147ca:	dc0e      	bgt.n	147ea <__adddf3+0x1ba>
   147cc:	f104 0414 	add.w	r4, r4, #20
   147d0:	f1c4 0220 	rsb	r2, r4, #32
   147d4:	fa20 f004 	lsr.w	r0, r0, r4
   147d8:	fa01 f302 	lsl.w	r3, r1, r2
   147dc:	ea40 0003 	orr.w	r0, r0, r3
   147e0:	fa21 f304 	lsr.w	r3, r1, r4
   147e4:	ea45 0103 	orr.w	r1, r5, r3
   147e8:	bd30      	pop	{r4, r5, pc}
   147ea:	f1c4 040c 	rsb	r4, r4, #12
   147ee:	f1c4 0220 	rsb	r2, r4, #32
   147f2:	fa20 f002 	lsr.w	r0, r0, r2
   147f6:	fa01 f304 	lsl.w	r3, r1, r4
   147fa:	ea40 0003 	orr.w	r0, r0, r3
   147fe:	4629      	mov	r1, r5
   14800:	bd30      	pop	{r4, r5, pc}
   14802:	fa21 f004 	lsr.w	r0, r1, r4
   14806:	4629      	mov	r1, r5
   14808:	bd30      	pop	{r4, r5, pc}
   1480a:	f094 0f00 	teq	r4, #0
   1480e:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
   14812:	bf06      	itte	eq
   14814:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
   14818:	3401      	addeq	r4, #1
   1481a:	3d01      	subne	r5, #1
   1481c:	e74e      	b.n	146bc <__adddf3+0x8c>
   1481e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   14822:	bf18      	it	ne
   14824:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   14828:	d029      	beq.n	1487e <__adddf3+0x24e>
   1482a:	ea94 0f05 	teq	r4, r5
   1482e:	bf08      	it	eq
   14830:	ea90 0f02 	teqeq	r0, r2
   14834:	d005      	beq.n	14842 <__adddf3+0x212>
   14836:	ea54 0c00 	orrs.w	ip, r4, r0
   1483a:	bf04      	itt	eq
   1483c:	4619      	moveq	r1, r3
   1483e:	4610      	moveq	r0, r2
   14840:	bd30      	pop	{r4, r5, pc}
   14842:	ea91 0f03 	teq	r1, r3
   14846:	bf1e      	ittt	ne
   14848:	2100      	movne	r1, #0
   1484a:	2000      	movne	r0, #0
   1484c:	bd30      	popne	{r4, r5, pc}
   1484e:	ea5f 5c54 	movs.w	ip, r4, lsr #21
   14852:	d105      	bne.n	14860 <__adddf3+0x230>
   14854:	0040      	lsls	r0, r0, #1
   14856:	4149      	adcs	r1, r1
   14858:	bf28      	it	cs
   1485a:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
   1485e:	bd30      	pop	{r4, r5, pc}
   14860:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
   14864:	bf3c      	itt	cc
   14866:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
   1486a:	bd30      	popcc	{r4, r5, pc}
   1486c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   14870:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
   14874:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   14878:	f04f 0000 	mov.w	r0, #0
   1487c:	bd30      	pop	{r4, r5, pc}
   1487e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   14882:	bf1a      	itte	ne
   14884:	4619      	movne	r1, r3
   14886:	4610      	movne	r0, r2
   14888:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
   1488c:	bf1c      	itt	ne
   1488e:	460b      	movne	r3, r1
   14890:	4602      	movne	r2, r0
   14892:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   14896:	bf06      	itte	eq
   14898:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
   1489c:	ea91 0f03 	teqeq	r1, r3
   148a0:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
   148a4:	bd30      	pop	{r4, r5, pc}
   148a6:	bf00      	nop

000148a8 <__aeabi_ui2d>:
   148a8:	f090 0f00 	teq	r0, #0
   148ac:	bf04      	itt	eq
   148ae:	2100      	moveq	r1, #0
   148b0:	4770      	bxeq	lr
   148b2:	b530      	push	{r4, r5, lr}
   148b4:	f44f 6480 	mov.w	r4, #1024	; 0x400
   148b8:	f104 0432 	add.w	r4, r4, #50	; 0x32
   148bc:	f04f 0500 	mov.w	r5, #0
   148c0:	f04f 0100 	mov.w	r1, #0
   148c4:	e750      	b.n	14768 <__adddf3+0x138>
   148c6:	bf00      	nop

000148c8 <__aeabi_i2d>:
   148c8:	f090 0f00 	teq	r0, #0
   148cc:	bf04      	itt	eq
   148ce:	2100      	moveq	r1, #0
   148d0:	4770      	bxeq	lr
   148d2:	b530      	push	{r4, r5, lr}
   148d4:	f44f 6480 	mov.w	r4, #1024	; 0x400
   148d8:	f104 0432 	add.w	r4, r4, #50	; 0x32
   148dc:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
   148e0:	bf48      	it	mi
   148e2:	4240      	negmi	r0, r0
   148e4:	f04f 0100 	mov.w	r1, #0
   148e8:	e73e      	b.n	14768 <__adddf3+0x138>
   148ea:	bf00      	nop

000148ec <__aeabi_f2d>:
   148ec:	0042      	lsls	r2, r0, #1
   148ee:	ea4f 01e2 	mov.w	r1, r2, asr #3
   148f2:	ea4f 0131 	mov.w	r1, r1, rrx
   148f6:	ea4f 7002 	mov.w	r0, r2, lsl #28
   148fa:	bf1f      	itttt	ne
   148fc:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
   14900:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   14904:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
   14908:	4770      	bxne	lr
   1490a:	f092 0f00 	teq	r2, #0
   1490e:	bf14      	ite	ne
   14910:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   14914:	4770      	bxeq	lr
   14916:	b530      	push	{r4, r5, lr}
   14918:	f44f 7460 	mov.w	r4, #896	; 0x380
   1491c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   14920:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   14924:	e720      	b.n	14768 <__adddf3+0x138>
   14926:	bf00      	nop

00014928 <__aeabi_ul2d>:
   14928:	ea50 0201 	orrs.w	r2, r0, r1
   1492c:	bf08      	it	eq
   1492e:	4770      	bxeq	lr
   14930:	b530      	push	{r4, r5, lr}
   14932:	f04f 0500 	mov.w	r5, #0
   14936:	e00a      	b.n	1494e <__aeabi_l2d+0x16>

00014938 <__aeabi_l2d>:
   14938:	ea50 0201 	orrs.w	r2, r0, r1
   1493c:	bf08      	it	eq
   1493e:	4770      	bxeq	lr
   14940:	b530      	push	{r4, r5, lr}
   14942:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
   14946:	d502      	bpl.n	1494e <__aeabi_l2d+0x16>
   14948:	4240      	negs	r0, r0
   1494a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   1494e:	f44f 6480 	mov.w	r4, #1024	; 0x400
   14952:	f104 0432 	add.w	r4, r4, #50	; 0x32
   14956:	ea5f 5c91 	movs.w	ip, r1, lsr #22
   1495a:	f43f aedc 	beq.w	14716 <__adddf3+0xe6>
   1495e:	f04f 0203 	mov.w	r2, #3
   14962:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   14966:	bf18      	it	ne
   14968:	3203      	addne	r2, #3
   1496a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   1496e:	bf18      	it	ne
   14970:	3203      	addne	r2, #3
   14972:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
   14976:	f1c2 0320 	rsb	r3, r2, #32
   1497a:	fa00 fc03 	lsl.w	ip, r0, r3
   1497e:	fa20 f002 	lsr.w	r0, r0, r2
   14982:	fa01 fe03 	lsl.w	lr, r1, r3
   14986:	ea40 000e 	orr.w	r0, r0, lr
   1498a:	fa21 f102 	lsr.w	r1, r1, r2
   1498e:	4414      	add	r4, r2
   14990:	e6c1      	b.n	14716 <__adddf3+0xe6>
   14992:	bf00      	nop

00014994 <__aeabi_dmul>:
   14994:	b570      	push	{r4, r5, r6, lr}
   14996:	f04f 0cff 	mov.w	ip, #255	; 0xff
   1499a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   1499e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   149a2:	bf1d      	ittte	ne
   149a4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   149a8:	ea94 0f0c 	teqne	r4, ip
   149ac:	ea95 0f0c 	teqne	r5, ip
   149b0:	f000 f8de 	bleq	14b70 <__aeabi_dmul+0x1dc>
   149b4:	442c      	add	r4, r5
   149b6:	ea81 0603 	eor.w	r6, r1, r3
   149ba:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
   149be:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
   149c2:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
   149c6:	bf18      	it	ne
   149c8:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
   149cc:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   149d0:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   149d4:	d038      	beq.n	14a48 <__aeabi_dmul+0xb4>
   149d6:	fba0 ce02 	umull	ip, lr, r0, r2
   149da:	f04f 0500 	mov.w	r5, #0
   149de:	fbe1 e502 	umlal	lr, r5, r1, r2
   149e2:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
   149e6:	fbe0 e503 	umlal	lr, r5, r0, r3
   149ea:	f04f 0600 	mov.w	r6, #0
   149ee:	fbe1 5603 	umlal	r5, r6, r1, r3
   149f2:	f09c 0f00 	teq	ip, #0
   149f6:	bf18      	it	ne
   149f8:	f04e 0e01 	orrne.w	lr, lr, #1
   149fc:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
   14a00:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
   14a04:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
   14a08:	d204      	bcs.n	14a14 <__aeabi_dmul+0x80>
   14a0a:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
   14a0e:	416d      	adcs	r5, r5
   14a10:	eb46 0606 	adc.w	r6, r6, r6
   14a14:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
   14a18:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
   14a1c:	ea4f 20c5 	mov.w	r0, r5, lsl #11
   14a20:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
   14a24:	ea4f 2ece 	mov.w	lr, lr, lsl #11
   14a28:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   14a2c:	bf88      	it	hi
   14a2e:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   14a32:	d81e      	bhi.n	14a72 <__aeabi_dmul+0xde>
   14a34:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
   14a38:	bf08      	it	eq
   14a3a:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
   14a3e:	f150 0000 	adcs.w	r0, r0, #0
   14a42:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   14a46:	bd70      	pop	{r4, r5, r6, pc}
   14a48:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
   14a4c:	ea46 0101 	orr.w	r1, r6, r1
   14a50:	ea40 0002 	orr.w	r0, r0, r2
   14a54:	ea81 0103 	eor.w	r1, r1, r3
   14a58:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
   14a5c:	bfc2      	ittt	gt
   14a5e:	ebd4 050c 	rsbsgt	r5, r4, ip
   14a62:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   14a66:	bd70      	popgt	{r4, r5, r6, pc}
   14a68:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   14a6c:	f04f 0e00 	mov.w	lr, #0
   14a70:	3c01      	subs	r4, #1
   14a72:	f300 80ab 	bgt.w	14bcc <__aeabi_dmul+0x238>
   14a76:	f114 0f36 	cmn.w	r4, #54	; 0x36
   14a7a:	bfde      	ittt	le
   14a7c:	2000      	movle	r0, #0
   14a7e:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
   14a82:	bd70      	pople	{r4, r5, r6, pc}
   14a84:	f1c4 0400 	rsb	r4, r4, #0
   14a88:	3c20      	subs	r4, #32
   14a8a:	da35      	bge.n	14af8 <__aeabi_dmul+0x164>
   14a8c:	340c      	adds	r4, #12
   14a8e:	dc1b      	bgt.n	14ac8 <__aeabi_dmul+0x134>
   14a90:	f104 0414 	add.w	r4, r4, #20
   14a94:	f1c4 0520 	rsb	r5, r4, #32
   14a98:	fa00 f305 	lsl.w	r3, r0, r5
   14a9c:	fa20 f004 	lsr.w	r0, r0, r4
   14aa0:	fa01 f205 	lsl.w	r2, r1, r5
   14aa4:	ea40 0002 	orr.w	r0, r0, r2
   14aa8:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
   14aac:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   14ab0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   14ab4:	fa21 f604 	lsr.w	r6, r1, r4
   14ab8:	eb42 0106 	adc.w	r1, r2, r6
   14abc:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   14ac0:	bf08      	it	eq
   14ac2:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   14ac6:	bd70      	pop	{r4, r5, r6, pc}
   14ac8:	f1c4 040c 	rsb	r4, r4, #12
   14acc:	f1c4 0520 	rsb	r5, r4, #32
   14ad0:	fa00 f304 	lsl.w	r3, r0, r4
   14ad4:	fa20 f005 	lsr.w	r0, r0, r5
   14ad8:	fa01 f204 	lsl.w	r2, r1, r4
   14adc:	ea40 0002 	orr.w	r0, r0, r2
   14ae0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   14ae4:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   14ae8:	f141 0100 	adc.w	r1, r1, #0
   14aec:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   14af0:	bf08      	it	eq
   14af2:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   14af6:	bd70      	pop	{r4, r5, r6, pc}
   14af8:	f1c4 0520 	rsb	r5, r4, #32
   14afc:	fa00 f205 	lsl.w	r2, r0, r5
   14b00:	ea4e 0e02 	orr.w	lr, lr, r2
   14b04:	fa20 f304 	lsr.w	r3, r0, r4
   14b08:	fa01 f205 	lsl.w	r2, r1, r5
   14b0c:	ea43 0302 	orr.w	r3, r3, r2
   14b10:	fa21 f004 	lsr.w	r0, r1, r4
   14b14:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   14b18:	fa21 f204 	lsr.w	r2, r1, r4
   14b1c:	ea20 0002 	bic.w	r0, r0, r2
   14b20:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
   14b24:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   14b28:	bf08      	it	eq
   14b2a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   14b2e:	bd70      	pop	{r4, r5, r6, pc}
   14b30:	f094 0f00 	teq	r4, #0
   14b34:	d10f      	bne.n	14b56 <__aeabi_dmul+0x1c2>
   14b36:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
   14b3a:	0040      	lsls	r0, r0, #1
   14b3c:	eb41 0101 	adc.w	r1, r1, r1
   14b40:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   14b44:	bf08      	it	eq
   14b46:	3c01      	subeq	r4, #1
   14b48:	d0f7      	beq.n	14b3a <__aeabi_dmul+0x1a6>
   14b4a:	ea41 0106 	orr.w	r1, r1, r6
   14b4e:	f095 0f00 	teq	r5, #0
   14b52:	bf18      	it	ne
   14b54:	4770      	bxne	lr
   14b56:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
   14b5a:	0052      	lsls	r2, r2, #1
   14b5c:	eb43 0303 	adc.w	r3, r3, r3
   14b60:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
   14b64:	bf08      	it	eq
   14b66:	3d01      	subeq	r5, #1
   14b68:	d0f7      	beq.n	14b5a <__aeabi_dmul+0x1c6>
   14b6a:	ea43 0306 	orr.w	r3, r3, r6
   14b6e:	4770      	bx	lr
   14b70:	ea94 0f0c 	teq	r4, ip
   14b74:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   14b78:	bf18      	it	ne
   14b7a:	ea95 0f0c 	teqne	r5, ip
   14b7e:	d00c      	beq.n	14b9a <__aeabi_dmul+0x206>
   14b80:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   14b84:	bf18      	it	ne
   14b86:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   14b8a:	d1d1      	bne.n	14b30 <__aeabi_dmul+0x19c>
   14b8c:	ea81 0103 	eor.w	r1, r1, r3
   14b90:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   14b94:	f04f 0000 	mov.w	r0, #0
   14b98:	bd70      	pop	{r4, r5, r6, pc}
   14b9a:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   14b9e:	bf06      	itte	eq
   14ba0:	4610      	moveq	r0, r2
   14ba2:	4619      	moveq	r1, r3
   14ba4:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   14ba8:	d019      	beq.n	14bde <__aeabi_dmul+0x24a>
   14baa:	ea94 0f0c 	teq	r4, ip
   14bae:	d102      	bne.n	14bb6 <__aeabi_dmul+0x222>
   14bb0:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
   14bb4:	d113      	bne.n	14bde <__aeabi_dmul+0x24a>
   14bb6:	ea95 0f0c 	teq	r5, ip
   14bba:	d105      	bne.n	14bc8 <__aeabi_dmul+0x234>
   14bbc:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
   14bc0:	bf1c      	itt	ne
   14bc2:	4610      	movne	r0, r2
   14bc4:	4619      	movne	r1, r3
   14bc6:	d10a      	bne.n	14bde <__aeabi_dmul+0x24a>
   14bc8:	ea81 0103 	eor.w	r1, r1, r3
   14bcc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   14bd0:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   14bd4:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   14bd8:	f04f 0000 	mov.w	r0, #0
   14bdc:	bd70      	pop	{r4, r5, r6, pc}
   14bde:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   14be2:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
   14be6:	bd70      	pop	{r4, r5, r6, pc}

00014be8 <__aeabi_ddiv>:
   14be8:	b570      	push	{r4, r5, r6, lr}
   14bea:	f04f 0cff 	mov.w	ip, #255	; 0xff
   14bee:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   14bf2:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   14bf6:	bf1d      	ittte	ne
   14bf8:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   14bfc:	ea94 0f0c 	teqne	r4, ip
   14c00:	ea95 0f0c 	teqne	r5, ip
   14c04:	f000 f8a7 	bleq	14d56 <__aeabi_ddiv+0x16e>
   14c08:	eba4 0405 	sub.w	r4, r4, r5
   14c0c:	ea81 0e03 	eor.w	lr, r1, r3
   14c10:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   14c14:	ea4f 3101 	mov.w	r1, r1, lsl #12
   14c18:	f000 8088 	beq.w	14d2c <__aeabi_ddiv+0x144>
   14c1c:	ea4f 3303 	mov.w	r3, r3, lsl #12
   14c20:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   14c24:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
   14c28:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
   14c2c:	ea4f 2202 	mov.w	r2, r2, lsl #8
   14c30:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
   14c34:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
   14c38:	ea4f 2600 	mov.w	r6, r0, lsl #8
   14c3c:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
   14c40:	429d      	cmp	r5, r3
   14c42:	bf08      	it	eq
   14c44:	4296      	cmpeq	r6, r2
   14c46:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
   14c4a:	f504 7440 	add.w	r4, r4, #768	; 0x300
   14c4e:	d202      	bcs.n	14c56 <__aeabi_ddiv+0x6e>
   14c50:	085b      	lsrs	r3, r3, #1
   14c52:	ea4f 0232 	mov.w	r2, r2, rrx
   14c56:	1ab6      	subs	r6, r6, r2
   14c58:	eb65 0503 	sbc.w	r5, r5, r3
   14c5c:	085b      	lsrs	r3, r3, #1
   14c5e:	ea4f 0232 	mov.w	r2, r2, rrx
   14c62:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
   14c66:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
   14c6a:	ebb6 0e02 	subs.w	lr, r6, r2
   14c6e:	eb75 0e03 	sbcs.w	lr, r5, r3
   14c72:	bf22      	ittt	cs
   14c74:	1ab6      	subcs	r6, r6, r2
   14c76:	4675      	movcs	r5, lr
   14c78:	ea40 000c 	orrcs.w	r0, r0, ip
   14c7c:	085b      	lsrs	r3, r3, #1
   14c7e:	ea4f 0232 	mov.w	r2, r2, rrx
   14c82:	ebb6 0e02 	subs.w	lr, r6, r2
   14c86:	eb75 0e03 	sbcs.w	lr, r5, r3
   14c8a:	bf22      	ittt	cs
   14c8c:	1ab6      	subcs	r6, r6, r2
   14c8e:	4675      	movcs	r5, lr
   14c90:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
   14c94:	085b      	lsrs	r3, r3, #1
   14c96:	ea4f 0232 	mov.w	r2, r2, rrx
   14c9a:	ebb6 0e02 	subs.w	lr, r6, r2
   14c9e:	eb75 0e03 	sbcs.w	lr, r5, r3
   14ca2:	bf22      	ittt	cs
   14ca4:	1ab6      	subcs	r6, r6, r2
   14ca6:	4675      	movcs	r5, lr
   14ca8:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
   14cac:	085b      	lsrs	r3, r3, #1
   14cae:	ea4f 0232 	mov.w	r2, r2, rrx
   14cb2:	ebb6 0e02 	subs.w	lr, r6, r2
   14cb6:	eb75 0e03 	sbcs.w	lr, r5, r3
   14cba:	bf22      	ittt	cs
   14cbc:	1ab6      	subcs	r6, r6, r2
   14cbe:	4675      	movcs	r5, lr
   14cc0:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
   14cc4:	ea55 0e06 	orrs.w	lr, r5, r6
   14cc8:	d018      	beq.n	14cfc <__aeabi_ddiv+0x114>
   14cca:	ea4f 1505 	mov.w	r5, r5, lsl #4
   14cce:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
   14cd2:	ea4f 1606 	mov.w	r6, r6, lsl #4
   14cd6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   14cda:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
   14cde:	ea4f 02c2 	mov.w	r2, r2, lsl #3
   14ce2:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
   14ce6:	d1c0      	bne.n	14c6a <__aeabi_ddiv+0x82>
   14ce8:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   14cec:	d10b      	bne.n	14d06 <__aeabi_ddiv+0x11e>
   14cee:	ea41 0100 	orr.w	r1, r1, r0
   14cf2:	f04f 0000 	mov.w	r0, #0
   14cf6:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
   14cfa:	e7b6      	b.n	14c6a <__aeabi_ddiv+0x82>
   14cfc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   14d00:	bf04      	itt	eq
   14d02:	4301      	orreq	r1, r0
   14d04:	2000      	moveq	r0, #0
   14d06:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   14d0a:	bf88      	it	hi
   14d0c:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   14d10:	f63f aeaf 	bhi.w	14a72 <__aeabi_dmul+0xde>
   14d14:	ebb5 0c03 	subs.w	ip, r5, r3
   14d18:	bf04      	itt	eq
   14d1a:	ebb6 0c02 	subseq.w	ip, r6, r2
   14d1e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   14d22:	f150 0000 	adcs.w	r0, r0, #0
   14d26:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   14d2a:	bd70      	pop	{r4, r5, r6, pc}
   14d2c:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
   14d30:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
   14d34:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
   14d38:	bfc2      	ittt	gt
   14d3a:	ebd4 050c 	rsbsgt	r5, r4, ip
   14d3e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   14d42:	bd70      	popgt	{r4, r5, r6, pc}
   14d44:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   14d48:	f04f 0e00 	mov.w	lr, #0
   14d4c:	3c01      	subs	r4, #1
   14d4e:	e690      	b.n	14a72 <__aeabi_dmul+0xde>
   14d50:	ea45 0e06 	orr.w	lr, r5, r6
   14d54:	e68d      	b.n	14a72 <__aeabi_dmul+0xde>
   14d56:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   14d5a:	ea94 0f0c 	teq	r4, ip
   14d5e:	bf08      	it	eq
   14d60:	ea95 0f0c 	teqeq	r5, ip
   14d64:	f43f af3b 	beq.w	14bde <__aeabi_dmul+0x24a>
   14d68:	ea94 0f0c 	teq	r4, ip
   14d6c:	d10a      	bne.n	14d84 <__aeabi_ddiv+0x19c>
   14d6e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   14d72:	f47f af34 	bne.w	14bde <__aeabi_dmul+0x24a>
   14d76:	ea95 0f0c 	teq	r5, ip
   14d7a:	f47f af25 	bne.w	14bc8 <__aeabi_dmul+0x234>
   14d7e:	4610      	mov	r0, r2
   14d80:	4619      	mov	r1, r3
   14d82:	e72c      	b.n	14bde <__aeabi_dmul+0x24a>
   14d84:	ea95 0f0c 	teq	r5, ip
   14d88:	d106      	bne.n	14d98 <__aeabi_ddiv+0x1b0>
   14d8a:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   14d8e:	f43f aefd 	beq.w	14b8c <__aeabi_dmul+0x1f8>
   14d92:	4610      	mov	r0, r2
   14d94:	4619      	mov	r1, r3
   14d96:	e722      	b.n	14bde <__aeabi_dmul+0x24a>
   14d98:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   14d9c:	bf18      	it	ne
   14d9e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   14da2:	f47f aec5 	bne.w	14b30 <__aeabi_dmul+0x19c>
   14da6:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
   14daa:	f47f af0d 	bne.w	14bc8 <__aeabi_dmul+0x234>
   14dae:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
   14db2:	f47f aeeb 	bne.w	14b8c <__aeabi_dmul+0x1f8>
   14db6:	e712      	b.n	14bde <__aeabi_dmul+0x24a>

00014db8 <__aeabi_d2f>:
   14db8:	ea4f 0241 	mov.w	r2, r1, lsl #1
   14dbc:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
   14dc0:	bf24      	itt	cs
   14dc2:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
   14dc6:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
   14dca:	d90d      	bls.n	14de8 <__aeabi_d2f+0x30>
   14dcc:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   14dd0:	ea4f 02c0 	mov.w	r2, r0, lsl #3
   14dd4:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
   14dd8:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
   14ddc:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
   14de0:	bf08      	it	eq
   14de2:	f020 0001 	biceq.w	r0, r0, #1
   14de6:	4770      	bx	lr
   14de8:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
   14dec:	d121      	bne.n	14e32 <__aeabi_d2f+0x7a>
   14dee:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
   14df2:	bfbc      	itt	lt
   14df4:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
   14df8:	4770      	bxlt	lr
   14dfa:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   14dfe:	ea4f 5252 	mov.w	r2, r2, lsr #21
   14e02:	f1c2 0218 	rsb	r2, r2, #24
   14e06:	f1c2 0c20 	rsb	ip, r2, #32
   14e0a:	fa10 f30c 	lsls.w	r3, r0, ip
   14e0e:	fa20 f002 	lsr.w	r0, r0, r2
   14e12:	bf18      	it	ne
   14e14:	f040 0001 	orrne.w	r0, r0, #1
   14e18:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   14e1c:	ea4f 23d3 	mov.w	r3, r3, lsr #11
   14e20:	fa03 fc0c 	lsl.w	ip, r3, ip
   14e24:	ea40 000c 	orr.w	r0, r0, ip
   14e28:	fa23 f302 	lsr.w	r3, r3, r2
   14e2c:	ea4f 0343 	mov.w	r3, r3, lsl #1
   14e30:	e7cc      	b.n	14dcc <__aeabi_d2f+0x14>
   14e32:	ea7f 5362 	mvns.w	r3, r2, asr #21
   14e36:	d107      	bne.n	14e48 <__aeabi_d2f+0x90>
   14e38:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
   14e3c:	bf1e      	ittt	ne
   14e3e:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
   14e42:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
   14e46:	4770      	bxne	lr
   14e48:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
   14e4c:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   14e50:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   14e54:	4770      	bx	lr
   14e56:	bf00      	nop

00014e58 <__aeabi_frsub>:
   14e58:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
   14e5c:	e002      	b.n	14e64 <__addsf3>
   14e5e:	bf00      	nop

00014e60 <__aeabi_fsub>:
   14e60:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

00014e64 <__addsf3>:
   14e64:	0042      	lsls	r2, r0, #1
   14e66:	bf1f      	itttt	ne
   14e68:	ea5f 0341 	movsne.w	r3, r1, lsl #1
   14e6c:	ea92 0f03 	teqne	r2, r3
   14e70:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
   14e74:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
   14e78:	d06a      	beq.n	14f50 <__addsf3+0xec>
   14e7a:	ea4f 6212 	mov.w	r2, r2, lsr #24
   14e7e:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
   14e82:	bfc1      	itttt	gt
   14e84:	18d2      	addgt	r2, r2, r3
   14e86:	4041      	eorgt	r1, r0
   14e88:	4048      	eorgt	r0, r1
   14e8a:	4041      	eorgt	r1, r0
   14e8c:	bfb8      	it	lt
   14e8e:	425b      	neglt	r3, r3
   14e90:	2b19      	cmp	r3, #25
   14e92:	bf88      	it	hi
   14e94:	4770      	bxhi	lr
   14e96:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
   14e9a:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   14e9e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   14ea2:	bf18      	it	ne
   14ea4:	4240      	negne	r0, r0
   14ea6:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   14eaa:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
   14eae:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
   14eb2:	bf18      	it	ne
   14eb4:	4249      	negne	r1, r1
   14eb6:	ea92 0f03 	teq	r2, r3
   14eba:	d03f      	beq.n	14f3c <__addsf3+0xd8>
   14ebc:	f1a2 0201 	sub.w	r2, r2, #1
   14ec0:	fa41 fc03 	asr.w	ip, r1, r3
   14ec4:	eb10 000c 	adds.w	r0, r0, ip
   14ec8:	f1c3 0320 	rsb	r3, r3, #32
   14ecc:	fa01 f103 	lsl.w	r1, r1, r3
   14ed0:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
   14ed4:	d502      	bpl.n	14edc <__addsf3+0x78>
   14ed6:	4249      	negs	r1, r1
   14ed8:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
   14edc:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   14ee0:	d313      	bcc.n	14f0a <__addsf3+0xa6>
   14ee2:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
   14ee6:	d306      	bcc.n	14ef6 <__addsf3+0x92>
   14ee8:	0840      	lsrs	r0, r0, #1
   14eea:	ea4f 0131 	mov.w	r1, r1, rrx
   14eee:	f102 0201 	add.w	r2, r2, #1
   14ef2:	2afe      	cmp	r2, #254	; 0xfe
   14ef4:	d251      	bcs.n	14f9a <__addsf3+0x136>
   14ef6:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
   14efa:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
   14efe:	bf08      	it	eq
   14f00:	f020 0001 	biceq.w	r0, r0, #1
   14f04:	ea40 0003 	orr.w	r0, r0, r3
   14f08:	4770      	bx	lr
   14f0a:	0049      	lsls	r1, r1, #1
   14f0c:	eb40 0000 	adc.w	r0, r0, r0
   14f10:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
   14f14:	f1a2 0201 	sub.w	r2, r2, #1
   14f18:	d1ed      	bne.n	14ef6 <__addsf3+0x92>
   14f1a:	fab0 fc80 	clz	ip, r0
   14f1e:	f1ac 0c08 	sub.w	ip, ip, #8
   14f22:	ebb2 020c 	subs.w	r2, r2, ip
   14f26:	fa00 f00c 	lsl.w	r0, r0, ip
   14f2a:	bfaa      	itet	ge
   14f2c:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
   14f30:	4252      	neglt	r2, r2
   14f32:	4318      	orrge	r0, r3
   14f34:	bfbc      	itt	lt
   14f36:	40d0      	lsrlt	r0, r2
   14f38:	4318      	orrlt	r0, r3
   14f3a:	4770      	bx	lr
   14f3c:	f092 0f00 	teq	r2, #0
   14f40:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
   14f44:	bf06      	itte	eq
   14f46:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
   14f4a:	3201      	addeq	r2, #1
   14f4c:	3b01      	subne	r3, #1
   14f4e:	e7b5      	b.n	14ebc <__addsf3+0x58>
   14f50:	ea4f 0341 	mov.w	r3, r1, lsl #1
   14f54:	ea7f 6c22 	mvns.w	ip, r2, asr #24
   14f58:	bf18      	it	ne
   14f5a:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
   14f5e:	d021      	beq.n	14fa4 <__addsf3+0x140>
   14f60:	ea92 0f03 	teq	r2, r3
   14f64:	d004      	beq.n	14f70 <__addsf3+0x10c>
   14f66:	f092 0f00 	teq	r2, #0
   14f6a:	bf08      	it	eq
   14f6c:	4608      	moveq	r0, r1
   14f6e:	4770      	bx	lr
   14f70:	ea90 0f01 	teq	r0, r1
   14f74:	bf1c      	itt	ne
   14f76:	2000      	movne	r0, #0
   14f78:	4770      	bxne	lr
   14f7a:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
   14f7e:	d104      	bne.n	14f8a <__addsf3+0x126>
   14f80:	0040      	lsls	r0, r0, #1
   14f82:	bf28      	it	cs
   14f84:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
   14f88:	4770      	bx	lr
   14f8a:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
   14f8e:	bf3c      	itt	cc
   14f90:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
   14f94:	4770      	bxcc	lr
   14f96:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
   14f9a:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
   14f9e:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   14fa2:	4770      	bx	lr
   14fa4:	ea7f 6222 	mvns.w	r2, r2, asr #24
   14fa8:	bf16      	itet	ne
   14faa:	4608      	movne	r0, r1
   14fac:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
   14fb0:	4601      	movne	r1, r0
   14fb2:	0242      	lsls	r2, r0, #9
   14fb4:	bf06      	itte	eq
   14fb6:	ea5f 2341 	movseq.w	r3, r1, lsl #9
   14fba:	ea90 0f01 	teqeq	r0, r1
   14fbe:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
   14fc2:	4770      	bx	lr

00014fc4 <__aeabi_ui2f>:
   14fc4:	f04f 0300 	mov.w	r3, #0
   14fc8:	e004      	b.n	14fd4 <__aeabi_i2f+0x8>
   14fca:	bf00      	nop

00014fcc <__aeabi_i2f>:
   14fcc:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
   14fd0:	bf48      	it	mi
   14fd2:	4240      	negmi	r0, r0
   14fd4:	ea5f 0c00 	movs.w	ip, r0
   14fd8:	bf08      	it	eq
   14fda:	4770      	bxeq	lr
   14fdc:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
   14fe0:	4601      	mov	r1, r0
   14fe2:	f04f 0000 	mov.w	r0, #0
   14fe6:	e01c      	b.n	15022 <__aeabi_l2f+0x2a>

00014fe8 <__aeabi_ul2f>:
   14fe8:	ea50 0201 	orrs.w	r2, r0, r1
   14fec:	bf08      	it	eq
   14fee:	4770      	bxeq	lr
   14ff0:	f04f 0300 	mov.w	r3, #0
   14ff4:	e00a      	b.n	1500c <__aeabi_l2f+0x14>
   14ff6:	bf00      	nop

00014ff8 <__aeabi_l2f>:
   14ff8:	ea50 0201 	orrs.w	r2, r0, r1
   14ffc:	bf08      	it	eq
   14ffe:	4770      	bxeq	lr
   15000:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
   15004:	d502      	bpl.n	1500c <__aeabi_l2f+0x14>
   15006:	4240      	negs	r0, r0
   15008:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   1500c:	ea5f 0c01 	movs.w	ip, r1
   15010:	bf02      	ittt	eq
   15012:	4684      	moveq	ip, r0
   15014:	4601      	moveq	r1, r0
   15016:	2000      	moveq	r0, #0
   15018:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
   1501c:	bf08      	it	eq
   1501e:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
   15022:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
   15026:	fabc f28c 	clz	r2, ip
   1502a:	3a08      	subs	r2, #8
   1502c:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
   15030:	db10      	blt.n	15054 <__aeabi_l2f+0x5c>
   15032:	fa01 fc02 	lsl.w	ip, r1, r2
   15036:	4463      	add	r3, ip
   15038:	fa00 fc02 	lsl.w	ip, r0, r2
   1503c:	f1c2 0220 	rsb	r2, r2, #32
   15040:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   15044:	fa20 f202 	lsr.w	r2, r0, r2
   15048:	eb43 0002 	adc.w	r0, r3, r2
   1504c:	bf08      	it	eq
   1504e:	f020 0001 	biceq.w	r0, r0, #1
   15052:	4770      	bx	lr
   15054:	f102 0220 	add.w	r2, r2, #32
   15058:	fa01 fc02 	lsl.w	ip, r1, r2
   1505c:	f1c2 0220 	rsb	r2, r2, #32
   15060:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
   15064:	fa21 f202 	lsr.w	r2, r1, r2
   15068:	eb43 0002 	adc.w	r0, r3, r2
   1506c:	bf08      	it	eq
   1506e:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
   15072:	4770      	bx	lr

00015074 <__aeabi_fmul>:
   15074:	f04f 0cff 	mov.w	ip, #255	; 0xff
   15078:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
   1507c:	bf1e      	ittt	ne
   1507e:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
   15082:	ea92 0f0c 	teqne	r2, ip
   15086:	ea93 0f0c 	teqne	r3, ip
   1508a:	d06f      	beq.n	1516c <__aeabi_fmul+0xf8>
   1508c:	441a      	add	r2, r3
   1508e:	ea80 0c01 	eor.w	ip, r0, r1
   15092:	0240      	lsls	r0, r0, #9
   15094:	bf18      	it	ne
   15096:	ea5f 2141 	movsne.w	r1, r1, lsl #9
   1509a:	d01e      	beq.n	150da <__aeabi_fmul+0x66>
   1509c:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
   150a0:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
   150a4:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
   150a8:	fba0 3101 	umull	r3, r1, r0, r1
   150ac:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
   150b0:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
   150b4:	bf3e      	ittt	cc
   150b6:	0049      	lslcc	r1, r1, #1
   150b8:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
   150bc:	005b      	lslcc	r3, r3, #1
   150be:	ea40 0001 	orr.w	r0, r0, r1
   150c2:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
   150c6:	2afd      	cmp	r2, #253	; 0xfd
   150c8:	d81d      	bhi.n	15106 <__aeabi_fmul+0x92>
   150ca:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
   150ce:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
   150d2:	bf08      	it	eq
   150d4:	f020 0001 	biceq.w	r0, r0, #1
   150d8:	4770      	bx	lr
   150da:	f090 0f00 	teq	r0, #0
   150de:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
   150e2:	bf08      	it	eq
   150e4:	0249      	lsleq	r1, r1, #9
   150e6:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
   150ea:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
   150ee:	3a7f      	subs	r2, #127	; 0x7f
   150f0:	bfc2      	ittt	gt
   150f2:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
   150f6:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
   150fa:	4770      	bxgt	lr
   150fc:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   15100:	f04f 0300 	mov.w	r3, #0
   15104:	3a01      	subs	r2, #1
   15106:	dc5d      	bgt.n	151c4 <__aeabi_fmul+0x150>
   15108:	f112 0f19 	cmn.w	r2, #25
   1510c:	bfdc      	itt	le
   1510e:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
   15112:	4770      	bxle	lr
   15114:	f1c2 0200 	rsb	r2, r2, #0
   15118:	0041      	lsls	r1, r0, #1
   1511a:	fa21 f102 	lsr.w	r1, r1, r2
   1511e:	f1c2 0220 	rsb	r2, r2, #32
   15122:	fa00 fc02 	lsl.w	ip, r0, r2
   15126:	ea5f 0031 	movs.w	r0, r1, rrx
   1512a:	f140 0000 	adc.w	r0, r0, #0
   1512e:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
   15132:	bf08      	it	eq
   15134:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
   15138:	4770      	bx	lr
   1513a:	f092 0f00 	teq	r2, #0
   1513e:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
   15142:	bf02      	ittt	eq
   15144:	0040      	lsleq	r0, r0, #1
   15146:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
   1514a:	3a01      	subeq	r2, #1
   1514c:	d0f9      	beq.n	15142 <__aeabi_fmul+0xce>
   1514e:	ea40 000c 	orr.w	r0, r0, ip
   15152:	f093 0f00 	teq	r3, #0
   15156:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   1515a:	bf02      	ittt	eq
   1515c:	0049      	lsleq	r1, r1, #1
   1515e:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
   15162:	3b01      	subeq	r3, #1
   15164:	d0f9      	beq.n	1515a <__aeabi_fmul+0xe6>
   15166:	ea41 010c 	orr.w	r1, r1, ip
   1516a:	e78f      	b.n	1508c <__aeabi_fmul+0x18>
   1516c:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
   15170:	ea92 0f0c 	teq	r2, ip
   15174:	bf18      	it	ne
   15176:	ea93 0f0c 	teqne	r3, ip
   1517a:	d00a      	beq.n	15192 <__aeabi_fmul+0x11e>
   1517c:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
   15180:	bf18      	it	ne
   15182:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
   15186:	d1d8      	bne.n	1513a <__aeabi_fmul+0xc6>
   15188:	ea80 0001 	eor.w	r0, r0, r1
   1518c:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
   15190:	4770      	bx	lr
   15192:	f090 0f00 	teq	r0, #0
   15196:	bf17      	itett	ne
   15198:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
   1519c:	4608      	moveq	r0, r1
   1519e:	f091 0f00 	teqne	r1, #0
   151a2:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
   151a6:	d014      	beq.n	151d2 <__aeabi_fmul+0x15e>
   151a8:	ea92 0f0c 	teq	r2, ip
   151ac:	d101      	bne.n	151b2 <__aeabi_fmul+0x13e>
   151ae:	0242      	lsls	r2, r0, #9
   151b0:	d10f      	bne.n	151d2 <__aeabi_fmul+0x15e>
   151b2:	ea93 0f0c 	teq	r3, ip
   151b6:	d103      	bne.n	151c0 <__aeabi_fmul+0x14c>
   151b8:	024b      	lsls	r3, r1, #9
   151ba:	bf18      	it	ne
   151bc:	4608      	movne	r0, r1
   151be:	d108      	bne.n	151d2 <__aeabi_fmul+0x15e>
   151c0:	ea80 0001 	eor.w	r0, r0, r1
   151c4:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
   151c8:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   151cc:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   151d0:	4770      	bx	lr
   151d2:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   151d6:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
   151da:	4770      	bx	lr

000151dc <__aeabi_fdiv>:
   151dc:	f04f 0cff 	mov.w	ip, #255	; 0xff
   151e0:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
   151e4:	bf1e      	ittt	ne
   151e6:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
   151ea:	ea92 0f0c 	teqne	r2, ip
   151ee:	ea93 0f0c 	teqne	r3, ip
   151f2:	d069      	beq.n	152c8 <__aeabi_fdiv+0xec>
   151f4:	eba2 0203 	sub.w	r2, r2, r3
   151f8:	ea80 0c01 	eor.w	ip, r0, r1
   151fc:	0249      	lsls	r1, r1, #9
   151fe:	ea4f 2040 	mov.w	r0, r0, lsl #9
   15202:	d037      	beq.n	15274 <__aeabi_fdiv+0x98>
   15204:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   15208:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
   1520c:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
   15210:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
   15214:	428b      	cmp	r3, r1
   15216:	bf38      	it	cc
   15218:	005b      	lslcc	r3, r3, #1
   1521a:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
   1521e:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
   15222:	428b      	cmp	r3, r1
   15224:	bf24      	itt	cs
   15226:	1a5b      	subcs	r3, r3, r1
   15228:	ea40 000c 	orrcs.w	r0, r0, ip
   1522c:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
   15230:	bf24      	itt	cs
   15232:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
   15236:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
   1523a:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
   1523e:	bf24      	itt	cs
   15240:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
   15244:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
   15248:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
   1524c:	bf24      	itt	cs
   1524e:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
   15252:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
   15256:	011b      	lsls	r3, r3, #4
   15258:	bf18      	it	ne
   1525a:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
   1525e:	d1e0      	bne.n	15222 <__aeabi_fdiv+0x46>
   15260:	2afd      	cmp	r2, #253	; 0xfd
   15262:	f63f af50 	bhi.w	15106 <__aeabi_fmul+0x92>
   15266:	428b      	cmp	r3, r1
   15268:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
   1526c:	bf08      	it	eq
   1526e:	f020 0001 	biceq.w	r0, r0, #1
   15272:	4770      	bx	lr
   15274:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
   15278:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
   1527c:	327f      	adds	r2, #127	; 0x7f
   1527e:	bfc2      	ittt	gt
   15280:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
   15284:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
   15288:	4770      	bxgt	lr
   1528a:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   1528e:	f04f 0300 	mov.w	r3, #0
   15292:	3a01      	subs	r2, #1
   15294:	e737      	b.n	15106 <__aeabi_fmul+0x92>
   15296:	f092 0f00 	teq	r2, #0
   1529a:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
   1529e:	bf02      	ittt	eq
   152a0:	0040      	lsleq	r0, r0, #1
   152a2:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
   152a6:	3a01      	subeq	r2, #1
   152a8:	d0f9      	beq.n	1529e <__aeabi_fdiv+0xc2>
   152aa:	ea40 000c 	orr.w	r0, r0, ip
   152ae:	f093 0f00 	teq	r3, #0
   152b2:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   152b6:	bf02      	ittt	eq
   152b8:	0049      	lsleq	r1, r1, #1
   152ba:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
   152be:	3b01      	subeq	r3, #1
   152c0:	d0f9      	beq.n	152b6 <__aeabi_fdiv+0xda>
   152c2:	ea41 010c 	orr.w	r1, r1, ip
   152c6:	e795      	b.n	151f4 <__aeabi_fdiv+0x18>
   152c8:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
   152cc:	ea92 0f0c 	teq	r2, ip
   152d0:	d108      	bne.n	152e4 <__aeabi_fdiv+0x108>
   152d2:	0242      	lsls	r2, r0, #9
   152d4:	f47f af7d 	bne.w	151d2 <__aeabi_fmul+0x15e>
   152d8:	ea93 0f0c 	teq	r3, ip
   152dc:	f47f af70 	bne.w	151c0 <__aeabi_fmul+0x14c>
   152e0:	4608      	mov	r0, r1
   152e2:	e776      	b.n	151d2 <__aeabi_fmul+0x15e>
   152e4:	ea93 0f0c 	teq	r3, ip
   152e8:	d104      	bne.n	152f4 <__aeabi_fdiv+0x118>
   152ea:	024b      	lsls	r3, r1, #9
   152ec:	f43f af4c 	beq.w	15188 <__aeabi_fmul+0x114>
   152f0:	4608      	mov	r0, r1
   152f2:	e76e      	b.n	151d2 <__aeabi_fmul+0x15e>
   152f4:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
   152f8:	bf18      	it	ne
   152fa:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
   152fe:	d1ca      	bne.n	15296 <__aeabi_fdiv+0xba>
   15300:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
   15304:	f47f af5c 	bne.w	151c0 <__aeabi_fmul+0x14c>
   15308:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
   1530c:	f47f af3c 	bne.w	15188 <__aeabi_fmul+0x114>
   15310:	e75f      	b.n	151d2 <__aeabi_fmul+0x15e>
   15312:	bf00      	nop

00015314 <gcvt>:
   15314:	b5f0      	push	{r4, r5, r6, r7, lr}
   15316:	4615      	mov	r5, r2
   15318:	461c      	mov	r4, r3
   1531a:	b085      	sub	sp, #20
   1531c:	2200      	movs	r2, #0
   1531e:	2300      	movs	r3, #0
   15320:	4606      	mov	r6, r0
   15322:	460f      	mov	r7, r1
   15324:	f005 fbb2 	bl	1aa8c <__aeabi_dcmplt>
   15328:	b9a8      	cbnz	r0, 15356 <gcvt+0x42>
   1532a:	4620      	mov	r0, r4
   1532c:	f240 110c 	movw	r1, #268	; 0x10c
   15330:	9500      	str	r5, [sp, #0]
   15332:	f2c2 0100 	movt	r1, #8192	; 0x2000
   15336:	9001      	str	r0, [sp, #4]
   15338:	4632      	mov	r2, r6
   1533a:	463b      	mov	r3, r7
   1533c:	6808      	ldr	r0, [r1, #0]
   1533e:	2167      	movs	r1, #103	; 0x67
   15340:	9102      	str	r1, [sp, #8]
   15342:	2100      	movs	r1, #0
   15344:	9103      	str	r1, [sp, #12]
   15346:	f003 f9df 	bl	18708 <_gcvt>
   1534a:	2800      	cmp	r0, #0
   1534c:	bf14      	ite	ne
   1534e:	4620      	movne	r0, r4
   15350:	2000      	moveq	r0, #0
   15352:	b005      	add	sp, #20
   15354:	bdf0      	pop	{r4, r5, r6, r7, pc}
   15356:	4620      	mov	r0, r4
   15358:	232d      	movs	r3, #45	; 0x2d
   1535a:	3d01      	subs	r5, #1
   1535c:	f800 3b01 	strb.w	r3, [r0], #1
   15360:	e7e4      	b.n	1532c <gcvt+0x18>
   15362:	bf00      	nop

00015364 <gcvtf>:
   15364:	b570      	push	{r4, r5, r6, lr}
   15366:	4614      	mov	r4, r2
   15368:	460d      	mov	r5, r1
   1536a:	f7ff fabf 	bl	148ec <__aeabi_f2d>
   1536e:	462a      	mov	r2, r5
   15370:	4623      	mov	r3, r4
   15372:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   15376:	e7cd      	b.n	15314 <gcvt>

00015378 <ecvt>:
   15378:	b510      	push	{r4, lr}
   1537a:	b082      	sub	sp, #8
   1537c:	2400      	movs	r4, #0
   1537e:	9401      	str	r4, [sp, #4]
   15380:	9c04      	ldr	r4, [sp, #16]
   15382:	9400      	str	r4, [sp, #0]
   15384:	f003 fac4 	bl	18910 <ecvtbuf>
   15388:	b002      	add	sp, #8
   1538a:	bd10      	pop	{r4, pc}

0001538c <ecvtf>:
   1538c:	b570      	push	{r4, r5, r6, lr}
   1538e:	4615      	mov	r5, r2
   15390:	b082      	sub	sp, #8
   15392:	460e      	mov	r6, r1
   15394:	461c      	mov	r4, r3
   15396:	f7ff faa9 	bl	148ec <__aeabi_f2d>
   1539a:	4632      	mov	r2, r6
   1539c:	462b      	mov	r3, r5
   1539e:	9400      	str	r4, [sp, #0]
   153a0:	f7ff ffea 	bl	15378 <ecvt>
   153a4:	b002      	add	sp, #8
   153a6:	bd70      	pop	{r4, r5, r6, pc}

000153a8 <fcvt>:
   153a8:	b510      	push	{r4, lr}
   153aa:	b082      	sub	sp, #8
   153ac:	2400      	movs	r4, #0
   153ae:	9401      	str	r4, [sp, #4]
   153b0:	9c04      	ldr	r4, [sp, #16]
   153b2:	9400      	str	r4, [sp, #0]
   153b4:	f003 fb06 	bl	189c4 <fcvtbuf>
   153b8:	b002      	add	sp, #8
   153ba:	bd10      	pop	{r4, pc}

000153bc <fcvtf>:
   153bc:	b570      	push	{r4, r5, r6, lr}
   153be:	4615      	mov	r5, r2
   153c0:	b082      	sub	sp, #8
   153c2:	460e      	mov	r6, r1
   153c4:	461c      	mov	r4, r3
   153c6:	f7ff fa91 	bl	148ec <__aeabi_f2d>
   153ca:	4632      	mov	r2, r6
   153cc:	462b      	mov	r3, r5
   153ce:	9400      	str	r4, [sp, #0]
   153d0:	f7ff ffea 	bl	153a8 <fcvt>
   153d4:	b002      	add	sp, #8
   153d6:	bd70      	pop	{r4, r5, r6, pc}

000153d8 <__errno>:
   153d8:	f240 130c 	movw	r3, #268	; 0x10c
   153dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   153e0:	6818      	ldr	r0, [r3, #0]
   153e2:	4770      	bx	lr

000153e4 <__libc_init_array>:
   153e4:	b570      	push	{r4, r5, r6, lr}
   153e6:	f64f 3690 	movw	r6, #64400	; 0xfb90
   153ea:	f64f 3590 	movw	r5, #64400	; 0xfb90
   153ee:	f2c0 0602 	movt	r6, #2
   153f2:	f2c0 0502 	movt	r5, #2
   153f6:	1b76      	subs	r6, r6, r5
   153f8:	10b6      	asrs	r6, r6, #2
   153fa:	d006      	beq.n	1540a <__libc_init_array+0x26>
   153fc:	2400      	movs	r4, #0
   153fe:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   15402:	3401      	adds	r4, #1
   15404:	4798      	blx	r3
   15406:	42a6      	cmp	r6, r4
   15408:	d8f9      	bhi.n	153fe <__libc_init_array+0x1a>
   1540a:	f64f 3590 	movw	r5, #64400	; 0xfb90
   1540e:	f64f 3694 	movw	r6, #64404	; 0xfb94
   15412:	f2c0 0502 	movt	r5, #2
   15416:	f2c0 0602 	movt	r6, #2
   1541a:	1b76      	subs	r6, r6, r5
   1541c:	f01a fbac 	bl	2fb78 <_init>
   15420:	10b6      	asrs	r6, r6, #2
   15422:	d006      	beq.n	15432 <__libc_init_array+0x4e>
   15424:	2400      	movs	r4, #0
   15426:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   1542a:	3401      	adds	r4, #1
   1542c:	4798      	blx	r3
   1542e:	42a6      	cmp	r6, r4
   15430:	d8f9      	bhi.n	15426 <__libc_init_array+0x42>
   15432:	bd70      	pop	{r4, r5, r6, pc}

00015434 <memcpy>:
   15434:	2a03      	cmp	r2, #3
   15436:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
   1543a:	d80b      	bhi.n	15454 <memcpy+0x20>
   1543c:	b13a      	cbz	r2, 1544e <memcpy+0x1a>
   1543e:	2300      	movs	r3, #0
   15440:	f811 c003 	ldrb.w	ip, [r1, r3]
   15444:	f800 c003 	strb.w	ip, [r0, r3]
   15448:	3301      	adds	r3, #1
   1544a:	4293      	cmp	r3, r2
   1544c:	d1f8      	bne.n	15440 <memcpy+0xc>
   1544e:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
   15452:	4770      	bx	lr
   15454:	1882      	adds	r2, r0, r2
   15456:	460c      	mov	r4, r1
   15458:	4603      	mov	r3, r0
   1545a:	e003      	b.n	15464 <memcpy+0x30>
   1545c:	f814 1c01 	ldrb.w	r1, [r4, #-1]
   15460:	f803 1c01 	strb.w	r1, [r3, #-1]
   15464:	f003 0603 	and.w	r6, r3, #3
   15468:	4619      	mov	r1, r3
   1546a:	46a4      	mov	ip, r4
   1546c:	3301      	adds	r3, #1
   1546e:	3401      	adds	r4, #1
   15470:	2e00      	cmp	r6, #0
   15472:	d1f3      	bne.n	1545c <memcpy+0x28>
   15474:	f01c 0403 	ands.w	r4, ip, #3
   15478:	4663      	mov	r3, ip
   1547a:	bf08      	it	eq
   1547c:	ebc1 0c02 	rsbeq	ip, r1, r2
   15480:	d068      	beq.n	15554 <memcpy+0x120>
   15482:	4265      	negs	r5, r4
   15484:	f1c4 0a04 	rsb	sl, r4, #4
   15488:	eb0c 0705 	add.w	r7, ip, r5
   1548c:	4633      	mov	r3, r6
   1548e:	ea4f 0aca 	mov.w	sl, sl, lsl #3
   15492:	f85c 6005 	ldr.w	r6, [ip, r5]
   15496:	ea4f 08c4 	mov.w	r8, r4, lsl #3
   1549a:	1a55      	subs	r5, r2, r1
   1549c:	e008      	b.n	154b0 <memcpy+0x7c>
   1549e:	f857 4f04 	ldr.w	r4, [r7, #4]!
   154a2:	4626      	mov	r6, r4
   154a4:	fa04 f40a 	lsl.w	r4, r4, sl
   154a8:	ea49 0404 	orr.w	r4, r9, r4
   154ac:	50cc      	str	r4, [r1, r3]
   154ae:	3304      	adds	r3, #4
   154b0:	185c      	adds	r4, r3, r1
   154b2:	2d03      	cmp	r5, #3
   154b4:	fa26 f908 	lsr.w	r9, r6, r8
   154b8:	f1a5 0504 	sub.w	r5, r5, #4
   154bc:	eb0c 0603 	add.w	r6, ip, r3
   154c0:	dced      	bgt.n	1549e <memcpy+0x6a>
   154c2:	2300      	movs	r3, #0
   154c4:	e002      	b.n	154cc <memcpy+0x98>
   154c6:	5cf1      	ldrb	r1, [r6, r3]
   154c8:	54e1      	strb	r1, [r4, r3]
   154ca:	3301      	adds	r3, #1
   154cc:	1919      	adds	r1, r3, r4
   154ce:	4291      	cmp	r1, r2
   154d0:	d3f9      	bcc.n	154c6 <memcpy+0x92>
   154d2:	e7bc      	b.n	1544e <memcpy+0x1a>
   154d4:	f853 4c40 	ldr.w	r4, [r3, #-64]
   154d8:	f841 4c40 	str.w	r4, [r1, #-64]
   154dc:	f853 4c3c 	ldr.w	r4, [r3, #-60]
   154e0:	f841 4c3c 	str.w	r4, [r1, #-60]
   154e4:	f853 4c38 	ldr.w	r4, [r3, #-56]
   154e8:	f841 4c38 	str.w	r4, [r1, #-56]
   154ec:	f853 4c34 	ldr.w	r4, [r3, #-52]
   154f0:	f841 4c34 	str.w	r4, [r1, #-52]
   154f4:	f853 4c30 	ldr.w	r4, [r3, #-48]
   154f8:	f841 4c30 	str.w	r4, [r1, #-48]
   154fc:	f853 4c2c 	ldr.w	r4, [r3, #-44]
   15500:	f841 4c2c 	str.w	r4, [r1, #-44]
   15504:	f853 4c28 	ldr.w	r4, [r3, #-40]
   15508:	f841 4c28 	str.w	r4, [r1, #-40]
   1550c:	f853 4c24 	ldr.w	r4, [r3, #-36]
   15510:	f841 4c24 	str.w	r4, [r1, #-36]
   15514:	f853 4c20 	ldr.w	r4, [r3, #-32]
   15518:	f841 4c20 	str.w	r4, [r1, #-32]
   1551c:	f853 4c1c 	ldr.w	r4, [r3, #-28]
   15520:	f841 4c1c 	str.w	r4, [r1, #-28]
   15524:	f853 4c18 	ldr.w	r4, [r3, #-24]
   15528:	f841 4c18 	str.w	r4, [r1, #-24]
   1552c:	f853 4c14 	ldr.w	r4, [r3, #-20]
   15530:	f841 4c14 	str.w	r4, [r1, #-20]
   15534:	f853 4c10 	ldr.w	r4, [r3, #-16]
   15538:	f841 4c10 	str.w	r4, [r1, #-16]
   1553c:	f853 4c0c 	ldr.w	r4, [r3, #-12]
   15540:	f841 4c0c 	str.w	r4, [r1, #-12]
   15544:	f853 4c08 	ldr.w	r4, [r3, #-8]
   15548:	f841 4c08 	str.w	r4, [r1, #-8]
   1554c:	f853 4c04 	ldr.w	r4, [r3, #-4]
   15550:	f841 4c04 	str.w	r4, [r1, #-4]
   15554:	461c      	mov	r4, r3
   15556:	460d      	mov	r5, r1
   15558:	3340      	adds	r3, #64	; 0x40
   1555a:	3140      	adds	r1, #64	; 0x40
   1555c:	f1bc 0f3f 	cmp.w	ip, #63	; 0x3f
   15560:	f1ac 0c40 	sub.w	ip, ip, #64	; 0x40
   15564:	dcb6      	bgt.n	154d4 <memcpy+0xa0>
   15566:	4621      	mov	r1, r4
   15568:	462b      	mov	r3, r5
   1556a:	1b54      	subs	r4, r2, r5
   1556c:	e00f      	b.n	1558e <memcpy+0x15a>
   1556e:	f851 5c10 	ldr.w	r5, [r1, #-16]
   15572:	f843 5c10 	str.w	r5, [r3, #-16]
   15576:	f851 5c0c 	ldr.w	r5, [r1, #-12]
   1557a:	f843 5c0c 	str.w	r5, [r3, #-12]
   1557e:	f851 5c08 	ldr.w	r5, [r1, #-8]
   15582:	f843 5c08 	str.w	r5, [r3, #-8]
   15586:	f851 5c04 	ldr.w	r5, [r1, #-4]
   1558a:	f843 5c04 	str.w	r5, [r3, #-4]
   1558e:	2c0f      	cmp	r4, #15
   15590:	460d      	mov	r5, r1
   15592:	469c      	mov	ip, r3
   15594:	f101 0110 	add.w	r1, r1, #16
   15598:	f103 0310 	add.w	r3, r3, #16
   1559c:	f1a4 0410 	sub.w	r4, r4, #16
   155a0:	dce5      	bgt.n	1556e <memcpy+0x13a>
   155a2:	ebcc 0102 	rsb	r1, ip, r2
   155a6:	2300      	movs	r3, #0
   155a8:	e003      	b.n	155b2 <memcpy+0x17e>
   155aa:	58ec      	ldr	r4, [r5, r3]
   155ac:	f84c 4003 	str.w	r4, [ip, r3]
   155b0:	3304      	adds	r3, #4
   155b2:	195e      	adds	r6, r3, r5
   155b4:	2903      	cmp	r1, #3
   155b6:	eb03 040c 	add.w	r4, r3, ip
   155ba:	f1a1 0104 	sub.w	r1, r1, #4
   155be:	dcf4      	bgt.n	155aa <memcpy+0x176>
   155c0:	e77f      	b.n	154c2 <memcpy+0x8e>
   155c2:	bf00      	nop

000155c4 <memset>:
   155c4:	2a03      	cmp	r2, #3
   155c6:	b2c9      	uxtb	r1, r1
   155c8:	b430      	push	{r4, r5}
   155ca:	d807      	bhi.n	155dc <memset+0x18>
   155cc:	b122      	cbz	r2, 155d8 <memset+0x14>
   155ce:	2300      	movs	r3, #0
   155d0:	54c1      	strb	r1, [r0, r3]
   155d2:	3301      	adds	r3, #1
   155d4:	4293      	cmp	r3, r2
   155d6:	d1fb      	bne.n	155d0 <memset+0xc>
   155d8:	bc30      	pop	{r4, r5}
   155da:	4770      	bx	lr
   155dc:	eb00 0c02 	add.w	ip, r0, r2
   155e0:	4603      	mov	r3, r0
   155e2:	e001      	b.n	155e8 <memset+0x24>
   155e4:	f803 1c01 	strb.w	r1, [r3, #-1]
   155e8:	f003 0403 	and.w	r4, r3, #3
   155ec:	461a      	mov	r2, r3
   155ee:	3301      	adds	r3, #1
   155f0:	2c00      	cmp	r4, #0
   155f2:	d1f7      	bne.n	155e4 <memset+0x20>
   155f4:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
   155f8:	ebc2 040c 	rsb	r4, r2, ip
   155fc:	fb03 f301 	mul.w	r3, r3, r1
   15600:	e01f      	b.n	15642 <memset+0x7e>
   15602:	f842 3c40 	str.w	r3, [r2, #-64]
   15606:	f842 3c3c 	str.w	r3, [r2, #-60]
   1560a:	f842 3c38 	str.w	r3, [r2, #-56]
   1560e:	f842 3c34 	str.w	r3, [r2, #-52]
   15612:	f842 3c30 	str.w	r3, [r2, #-48]
   15616:	f842 3c2c 	str.w	r3, [r2, #-44]
   1561a:	f842 3c28 	str.w	r3, [r2, #-40]
   1561e:	f842 3c24 	str.w	r3, [r2, #-36]
   15622:	f842 3c20 	str.w	r3, [r2, #-32]
   15626:	f842 3c1c 	str.w	r3, [r2, #-28]
   1562a:	f842 3c18 	str.w	r3, [r2, #-24]
   1562e:	f842 3c14 	str.w	r3, [r2, #-20]
   15632:	f842 3c10 	str.w	r3, [r2, #-16]
   15636:	f842 3c0c 	str.w	r3, [r2, #-12]
   1563a:	f842 3c08 	str.w	r3, [r2, #-8]
   1563e:	f842 3c04 	str.w	r3, [r2, #-4]
   15642:	4615      	mov	r5, r2
   15644:	3240      	adds	r2, #64	; 0x40
   15646:	2c3f      	cmp	r4, #63	; 0x3f
   15648:	f1a4 0440 	sub.w	r4, r4, #64	; 0x40
   1564c:	dcd9      	bgt.n	15602 <memset+0x3e>
   1564e:	462a      	mov	r2, r5
   15650:	ebc5 040c 	rsb	r4, r5, ip
   15654:	e007      	b.n	15666 <memset+0xa2>
   15656:	f842 3c10 	str.w	r3, [r2, #-16]
   1565a:	f842 3c0c 	str.w	r3, [r2, #-12]
   1565e:	f842 3c08 	str.w	r3, [r2, #-8]
   15662:	f842 3c04 	str.w	r3, [r2, #-4]
   15666:	4615      	mov	r5, r2
   15668:	3210      	adds	r2, #16
   1566a:	2c0f      	cmp	r4, #15
   1566c:	f1a4 0410 	sub.w	r4, r4, #16
   15670:	dcf1      	bgt.n	15656 <memset+0x92>
   15672:	462a      	mov	r2, r5
   15674:	ebc5 050c 	rsb	r5, r5, ip
   15678:	e001      	b.n	1567e <memset+0xba>
   1567a:	f842 3c04 	str.w	r3, [r2, #-4]
   1567e:	4614      	mov	r4, r2
   15680:	3204      	adds	r2, #4
   15682:	2d03      	cmp	r5, #3
   15684:	f1a5 0504 	sub.w	r5, r5, #4
   15688:	dcf7      	bgt.n	1567a <memset+0xb6>
   1568a:	e001      	b.n	15690 <memset+0xcc>
   1568c:	f804 1b01 	strb.w	r1, [r4], #1
   15690:	4564      	cmp	r4, ip
   15692:	d3fb      	bcc.n	1568c <memset+0xc8>
   15694:	e7a0      	b.n	155d8 <memset+0x14>
   15696:	bf00      	nop

00015698 <snprintf>:
   15698:	b40c      	push	{r2, r3}
   1569a:	f240 130c 	movw	r3, #268	; 0x10c
   1569e:	b5f0      	push	{r4, r5, r6, r7, lr}
   156a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   156a4:	1e0c      	subs	r4, r1, #0
   156a6:	b09d      	sub	sp, #116	; 0x74
   156a8:	4605      	mov	r5, r0
   156aa:	681e      	ldr	r6, [r3, #0]
   156ac:	db28      	blt.n	15700 <snprintf+0x68>
   156ae:	af23      	add	r7, sp, #140	; 0x8c
   156b0:	9a22      	ldr	r2, [sp, #136]	; 0x88
   156b2:	463b      	mov	r3, r7
   156b4:	4630      	mov	r0, r6
   156b6:	a901      	add	r1, sp, #4
   156b8:	bf0c      	ite	eq
   156ba:	46a4      	moveq	ip, r4
   156bc:	f104 3cff 	addne.w	ip, r4, #4294967295
   156c0:	f44f 7e02 	mov.w	lr, #520	; 0x208
   156c4:	9505      	str	r5, [sp, #20]
   156c6:	f8ad e010 	strh.w	lr, [sp, #16]
   156ca:	f04f 3eff 	mov.w	lr, #4294967295
   156ce:	f8cd c018 	str.w	ip, [sp, #24]
   156d2:	9501      	str	r5, [sp, #4]
   156d4:	f8ad e012 	strh.w	lr, [sp, #18]
   156d8:	f8cd c00c 	str.w	ip, [sp, #12]
   156dc:	971b      	str	r7, [sp, #108]	; 0x6c
   156de:	f000 fd59 	bl	16194 <_svfprintf_r>
   156e2:	f1b0 3fff 	cmp.w	r0, #4294967295
   156e6:	db08      	blt.n	156fa <snprintf+0x62>
   156e8:	b114      	cbz	r4, 156f0 <snprintf+0x58>
   156ea:	9b01      	ldr	r3, [sp, #4]
   156ec:	2200      	movs	r2, #0
   156ee:	701a      	strb	r2, [r3, #0]
   156f0:	b01d      	add	sp, #116	; 0x74
   156f2:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   156f6:	b002      	add	sp, #8
   156f8:	4770      	bx	lr
   156fa:	238b      	movs	r3, #139	; 0x8b
   156fc:	6033      	str	r3, [r6, #0]
   156fe:	e7f3      	b.n	156e8 <snprintf+0x50>
   15700:	238b      	movs	r3, #139	; 0x8b
   15702:	f04f 30ff 	mov.w	r0, #4294967295
   15706:	6033      	str	r3, [r6, #0]
   15708:	e7f2      	b.n	156f0 <snprintf+0x58>
   1570a:	bf00      	nop

0001570c <_snprintf_r>:
   1570c:	b408      	push	{r3}
   1570e:	b5f0      	push	{r4, r5, r6, r7, lr}
   15710:	1e14      	subs	r4, r2, #0
   15712:	b09c      	sub	sp, #112	; 0x70
   15714:	4606      	mov	r6, r0
   15716:	460d      	mov	r5, r1
   15718:	db27      	blt.n	1576a <_snprintf_r+0x5e>
   1571a:	af22      	add	r7, sp, #136	; 0x88
   1571c:	9a21      	ldr	r2, [sp, #132]	; 0x84
   1571e:	463b      	mov	r3, r7
   15720:	a901      	add	r1, sp, #4
   15722:	bf0c      	ite	eq
   15724:	46a4      	moveq	ip, r4
   15726:	f104 3cff 	addne.w	ip, r4, #4294967295
   1572a:	f44f 7e02 	mov.w	lr, #520	; 0x208
   1572e:	9505      	str	r5, [sp, #20]
   15730:	f8ad e010 	strh.w	lr, [sp, #16]
   15734:	f04f 3eff 	mov.w	lr, #4294967295
   15738:	f8cd c018 	str.w	ip, [sp, #24]
   1573c:	9501      	str	r5, [sp, #4]
   1573e:	f8ad e012 	strh.w	lr, [sp, #18]
   15742:	f8cd c00c 	str.w	ip, [sp, #12]
   15746:	971b      	str	r7, [sp, #108]	; 0x6c
   15748:	f000 fd24 	bl	16194 <_svfprintf_r>
   1574c:	f1b0 3fff 	cmp.w	r0, #4294967295
   15750:	db08      	blt.n	15764 <_snprintf_r+0x58>
   15752:	b114      	cbz	r4, 1575a <_snprintf_r+0x4e>
   15754:	9b01      	ldr	r3, [sp, #4]
   15756:	2200      	movs	r2, #0
   15758:	701a      	strb	r2, [r3, #0]
   1575a:	b01c      	add	sp, #112	; 0x70
   1575c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   15760:	b001      	add	sp, #4
   15762:	4770      	bx	lr
   15764:	238b      	movs	r3, #139	; 0x8b
   15766:	6033      	str	r3, [r6, #0]
   15768:	e7f3      	b.n	15752 <_snprintf_r+0x46>
   1576a:	238b      	movs	r3, #139	; 0x8b
   1576c:	6003      	str	r3, [r0, #0]
   1576e:	f04f 30ff 	mov.w	r0, #4294967295
   15772:	e7f2      	b.n	1575a <_snprintf_r+0x4e>

00015774 <sprintf>:
   15774:	b40e      	push	{r1, r2, r3}
   15776:	f240 130c 	movw	r3, #268	; 0x10c
   1577a:	b530      	push	{r4, r5, lr}
   1577c:	b09c      	sub	sp, #112	; 0x70
   1577e:	ac1f      	add	r4, sp, #124	; 0x7c
   15780:	f2c2 0300 	movt	r3, #8192	; 0x2000
   15784:	4605      	mov	r5, r0
   15786:	a901      	add	r1, sp, #4
   15788:	f854 2b04 	ldr.w	r2, [r4], #4
   1578c:	f04f 3cff 	mov.w	ip, #4294967295
   15790:	6818      	ldr	r0, [r3, #0]
   15792:	f44f 7302 	mov.w	r3, #520	; 0x208
   15796:	f8ad 3010 	strh.w	r3, [sp, #16]
   1579a:	4623      	mov	r3, r4
   1579c:	9505      	str	r5, [sp, #20]
   1579e:	9501      	str	r5, [sp, #4]
   157a0:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
   157a4:	f8ad c012 	strh.w	ip, [sp, #18]
   157a8:	9506      	str	r5, [sp, #24]
   157aa:	9503      	str	r5, [sp, #12]
   157ac:	941b      	str	r4, [sp, #108]	; 0x6c
   157ae:	f000 fcf1 	bl	16194 <_svfprintf_r>
   157b2:	9b01      	ldr	r3, [sp, #4]
   157b4:	2200      	movs	r2, #0
   157b6:	701a      	strb	r2, [r3, #0]
   157b8:	b01c      	add	sp, #112	; 0x70
   157ba:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   157be:	b003      	add	sp, #12
   157c0:	4770      	bx	lr
   157c2:	bf00      	nop

000157c4 <_sprintf_r>:
   157c4:	b40c      	push	{r2, r3}
   157c6:	460b      	mov	r3, r1
   157c8:	b510      	push	{r4, lr}
   157ca:	b09c      	sub	sp, #112	; 0x70
   157cc:	ac1e      	add	r4, sp, #120	; 0x78
   157ce:	a901      	add	r1, sp, #4
   157d0:	9305      	str	r3, [sp, #20]
   157d2:	f44f 7c02 	mov.w	ip, #520	; 0x208
   157d6:	f854 2b04 	ldr.w	r2, [r4], #4
   157da:	9301      	str	r3, [sp, #4]
   157dc:	f04f 33ff 	mov.w	r3, #4294967295
   157e0:	f8ad 3012 	strh.w	r3, [sp, #18]
   157e4:	4623      	mov	r3, r4
   157e6:	941b      	str	r4, [sp, #108]	; 0x6c
   157e8:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
   157ec:	f8ad c010 	strh.w	ip, [sp, #16]
   157f0:	9406      	str	r4, [sp, #24]
   157f2:	9403      	str	r4, [sp, #12]
   157f4:	f000 fcce 	bl	16194 <_svfprintf_r>
   157f8:	9b01      	ldr	r3, [sp, #4]
   157fa:	2200      	movs	r2, #0
   157fc:	701a      	strb	r2, [r3, #0]
   157fe:	b01c      	add	sp, #112	; 0x70
   15800:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   15804:	b002      	add	sp, #8
   15806:	4770      	bx	lr

00015808 <strchr>:
   15808:	b2c9      	uxtb	r1, r1
   1580a:	b430      	push	{r4, r5}
   1580c:	b119      	cbz	r1, 15816 <strchr+0xe>
   1580e:	e024      	b.n	1585a <strchr+0x52>
   15810:	7803      	ldrb	r3, [r0, #0]
   15812:	b1d3      	cbz	r3, 1584a <strchr+0x42>
   15814:	3001      	adds	r0, #1
   15816:	f010 0f03 	tst.w	r0, #3
   1581a:	d1f9      	bne.n	15810 <strchr+0x8>
   1581c:	6803      	ldr	r3, [r0, #0]
   1581e:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   15822:	ea22 0303 	bic.w	r3, r2, r3
   15826:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   1582a:	d108      	bne.n	1583e <strchr+0x36>
   1582c:	f850 3f04 	ldr.w	r3, [r0, #4]!
   15830:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   15834:	ea22 0303 	bic.w	r3, r2, r3
   15838:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   1583c:	d0f6      	beq.n	1582c <strchr+0x24>
   1583e:	7803      	ldrb	r3, [r0, #0]
   15840:	b11b      	cbz	r3, 1584a <strchr+0x42>
   15842:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   15846:	2b00      	cmp	r3, #0
   15848:	d1fb      	bne.n	15842 <strchr+0x3a>
   1584a:	bc30      	pop	{r4, r5}
   1584c:	4770      	bx	lr
   1584e:	7803      	ldrb	r3, [r0, #0]
   15850:	2b00      	cmp	r3, #0
   15852:	d036      	beq.n	158c2 <strchr+0xba>
   15854:	4299      	cmp	r1, r3
   15856:	d0f8      	beq.n	1584a <strchr+0x42>
   15858:	3001      	adds	r0, #1
   1585a:	f010 0f03 	tst.w	r0, #3
   1585e:	d1f6      	bne.n	1584e <strchr+0x46>
   15860:	6803      	ldr	r3, [r0, #0]
   15862:	ea41 2501 	orr.w	r5, r1, r1, lsl #8
   15866:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   1586a:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
   1586e:	ea22 0203 	bic.w	r2, r2, r3
   15872:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   15876:	d11b      	bne.n	158b0 <strchr+0xa8>
   15878:	ea85 0303 	eor.w	r3, r5, r3
   1587c:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   15880:	ea22 0303 	bic.w	r3, r2, r3
   15884:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   15888:	d003      	beq.n	15892 <strchr+0x8a>
   1588a:	e011      	b.n	158b0 <strchr+0xa8>
   1588c:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   15890:	d10e      	bne.n	158b0 <strchr+0xa8>
   15892:	f850 3f04 	ldr.w	r3, [r0, #4]!
   15896:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
   1589a:	ea85 0203 	eor.w	r2, r5, r3
   1589e:	ea24 0303 	bic.w	r3, r4, r3
   158a2:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
   158a6:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   158aa:	ea2c 0202 	bic.w	r2, ip, r2
   158ae:	d0ed      	beq.n	1588c <strchr+0x84>
   158b0:	7803      	ldrb	r3, [r0, #0]
   158b2:	b91b      	cbnz	r3, 158bc <strchr+0xb4>
   158b4:	e005      	b.n	158c2 <strchr+0xba>
   158b6:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   158ba:	b113      	cbz	r3, 158c2 <strchr+0xba>
   158bc:	4299      	cmp	r1, r3
   158be:	d1fa      	bne.n	158b6 <strchr+0xae>
   158c0:	e7c3      	b.n	1584a <strchr+0x42>
   158c2:	2000      	movs	r0, #0
   158c4:	e7c1      	b.n	1584a <strchr+0x42>
   158c6:	bf00      	nop

000158c8 <strcpy>:
   158c8:	ea80 0201 	eor.w	r2, r0, r1
   158cc:	4684      	mov	ip, r0
   158ce:	f012 0f03 	tst.w	r2, #3
   158d2:	d14f      	bne.n	15974 <strcpy+0xac>
   158d4:	f011 0f03 	tst.w	r1, #3
   158d8:	d132      	bne.n	15940 <strcpy+0x78>
   158da:	f84d 4d04 	str.w	r4, [sp, #-4]!
   158de:	f011 0f04 	tst.w	r1, #4
   158e2:	f851 3b04 	ldr.w	r3, [r1], #4
   158e6:	d00b      	beq.n	15900 <strcpy+0x38>
   158e8:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   158ec:	439a      	bics	r2, r3
   158ee:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   158f2:	bf04      	itt	eq
   158f4:	f84c 3b04 	streq.w	r3, [ip], #4
   158f8:	f851 3b04 	ldreq.w	r3, [r1], #4
   158fc:	d116      	bne.n	1592c <strcpy+0x64>
   158fe:	bf00      	nop
   15900:	f851 4b04 	ldr.w	r4, [r1], #4
   15904:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   15908:	439a      	bics	r2, r3
   1590a:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   1590e:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
   15912:	d10b      	bne.n	1592c <strcpy+0x64>
   15914:	f84c 3b04 	str.w	r3, [ip], #4
   15918:	43a2      	bics	r2, r4
   1591a:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   1591e:	bf04      	itt	eq
   15920:	f851 3b04 	ldreq.w	r3, [r1], #4
   15924:	f84c 4b04 	streq.w	r4, [ip], #4
   15928:	d0ea      	beq.n	15900 <strcpy+0x38>
   1592a:	4623      	mov	r3, r4
   1592c:	f80c 3b01 	strb.w	r3, [ip], #1
   15930:	f013 0fff 	tst.w	r3, #255	; 0xff
   15934:	ea4f 2333 	mov.w	r3, r3, ror #8
   15938:	d1f8      	bne.n	1592c <strcpy+0x64>
   1593a:	f85d 4b04 	ldr.w	r4, [sp], #4
   1593e:	4770      	bx	lr
   15940:	f011 0f01 	tst.w	r1, #1
   15944:	d006      	beq.n	15954 <strcpy+0x8c>
   15946:	f811 2b01 	ldrb.w	r2, [r1], #1
   1594a:	f80c 2b01 	strb.w	r2, [ip], #1
   1594e:	2a00      	cmp	r2, #0
   15950:	bf08      	it	eq
   15952:	4770      	bxeq	lr
   15954:	f011 0f02 	tst.w	r1, #2
   15958:	d0bf      	beq.n	158da <strcpy+0x12>
   1595a:	f831 2b02 	ldrh.w	r2, [r1], #2
   1595e:	f012 0fff 	tst.w	r2, #255	; 0xff
   15962:	bf16      	itet	ne
   15964:	f82c 2b02 	strhne.w	r2, [ip], #2
   15968:	f88c 2000 	strbeq.w	r2, [ip]
   1596c:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
   15970:	d1b3      	bne.n	158da <strcpy+0x12>
   15972:	4770      	bx	lr
   15974:	f811 2b01 	ldrb.w	r2, [r1], #1
   15978:	f80c 2b01 	strb.w	r2, [ip], #1
   1597c:	2a00      	cmp	r2, #0
   1597e:	d1f9      	bne.n	15974 <strcpy+0xac>
   15980:	4770      	bx	lr
   15982:	bf00      	nop

00015984 <strlen>:
   15984:	f020 0103 	bic.w	r1, r0, #3
   15988:	f010 0003 	ands.w	r0, r0, #3
   1598c:	f1c0 0000 	rsb	r0, r0, #0
   15990:	f851 3b04 	ldr.w	r3, [r1], #4
   15994:	f100 0c04 	add.w	ip, r0, #4
   15998:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
   1599c:	f06f 0200 	mvn.w	r2, #0
   159a0:	bf1c      	itt	ne
   159a2:	fa22 f20c 	lsrne.w	r2, r2, ip
   159a6:	4313      	orrne	r3, r2
   159a8:	f04f 0c01 	mov.w	ip, #1
   159ac:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
   159b0:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
   159b4:	eba3 020c 	sub.w	r2, r3, ip
   159b8:	ea22 0203 	bic.w	r2, r2, r3
   159bc:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
   159c0:	bf04      	itt	eq
   159c2:	f851 3b04 	ldreq.w	r3, [r1], #4
   159c6:	3004      	addeq	r0, #4
   159c8:	d0f4      	beq.n	159b4 <strlen+0x30>
   159ca:	f013 0fff 	tst.w	r3, #255	; 0xff
   159ce:	bf1f      	itttt	ne
   159d0:	3001      	addne	r0, #1
   159d2:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
   159d6:	3001      	addne	r0, #1
   159d8:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
   159dc:	bf18      	it	ne
   159de:	3001      	addne	r0, #1
   159e0:	4770      	bx	lr
   159e2:	bf00      	nop

000159e4 <strncmp>:
   159e4:	b430      	push	{r4, r5}
   159e6:	4613      	mov	r3, r2
   159e8:	2a00      	cmp	r2, #0
   159ea:	d043      	beq.n	15a74 <strncmp+0x90>
   159ec:	ea41 0200 	orr.w	r2, r1, r0
   159f0:	f012 0f03 	tst.w	r2, #3
   159f4:	d125      	bne.n	15a42 <strncmp+0x5e>
   159f6:	2b03      	cmp	r3, #3
   159f8:	4604      	mov	r4, r0
   159fa:	460d      	mov	r5, r1
   159fc:	d93d      	bls.n	15a7a <strncmp+0x96>
   159fe:	6802      	ldr	r2, [r0, #0]
   15a00:	6809      	ldr	r1, [r1, #0]
   15a02:	428a      	cmp	r2, r1
   15a04:	d139      	bne.n	15a7a <strncmp+0x96>
   15a06:	3b04      	subs	r3, #4
   15a08:	d034      	beq.n	15a74 <strncmp+0x90>
   15a0a:	f1a2 3101 	sub.w	r1, r2, #16843009	; 0x1010101
   15a0e:	ea21 0202 	bic.w	r2, r1, r2
   15a12:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   15a16:	d00d      	beq.n	15a34 <strncmp+0x50>
   15a18:	e02c      	b.n	15a74 <strncmp+0x90>
   15a1a:	6822      	ldr	r2, [r4, #0]
   15a1c:	6829      	ldr	r1, [r5, #0]
   15a1e:	f1a2 3001 	sub.w	r0, r2, #16843009	; 0x1010101
   15a22:	428a      	cmp	r2, r1
   15a24:	ea20 0002 	bic.w	r0, r0, r2
   15a28:	d127      	bne.n	15a7a <strncmp+0x96>
   15a2a:	3b04      	subs	r3, #4
   15a2c:	d022      	beq.n	15a74 <strncmp+0x90>
   15a2e:	f010 3f80 	tst.w	r0, #2155905152	; 0x80808080
   15a32:	d11f      	bne.n	15a74 <strncmp+0x90>
   15a34:	3404      	adds	r4, #4
   15a36:	3504      	adds	r5, #4
   15a38:	2b03      	cmp	r3, #3
   15a3a:	d8ee      	bhi.n	15a1a <strncmp+0x36>
   15a3c:	4620      	mov	r0, r4
   15a3e:	4629      	mov	r1, r5
   15a40:	b1f3      	cbz	r3, 15a80 <strncmp+0x9c>
   15a42:	7804      	ldrb	r4, [r0, #0]
   15a44:	3b01      	subs	r3, #1
   15a46:	f891 c000 	ldrb.w	ip, [r1]
   15a4a:	4564      	cmp	r4, ip
   15a4c:	d10f      	bne.n	15a6e <strncmp+0x8a>
   15a4e:	b18b      	cbz	r3, 15a74 <strncmp+0x90>
   15a50:	b184      	cbz	r4, 15a74 <strncmp+0x90>
   15a52:	3b01      	subs	r3, #1
   15a54:	2200      	movs	r2, #0
   15a56:	e002      	b.n	15a5e <strncmp+0x7a>
   15a58:	b163      	cbz	r3, 15a74 <strncmp+0x90>
   15a5a:	b15c      	cbz	r4, 15a74 <strncmp+0x90>
   15a5c:	3b01      	subs	r3, #1
   15a5e:	1884      	adds	r4, r0, r2
   15a60:	188d      	adds	r5, r1, r2
   15a62:	3201      	adds	r2, #1
   15a64:	7864      	ldrb	r4, [r4, #1]
   15a66:	f895 c001 	ldrb.w	ip, [r5, #1]
   15a6a:	4564      	cmp	r4, ip
   15a6c:	d0f4      	beq.n	15a58 <strncmp+0x74>
   15a6e:	ebcc 0004 	rsb	r0, ip, r4
   15a72:	e000      	b.n	15a76 <strncmp+0x92>
   15a74:	2000      	movs	r0, #0
   15a76:	bc30      	pop	{r4, r5}
   15a78:	4770      	bx	lr
   15a7a:	4620      	mov	r0, r4
   15a7c:	4629      	mov	r1, r5
   15a7e:	e7e0      	b.n	15a42 <strncmp+0x5e>
   15a80:	7824      	ldrb	r4, [r4, #0]
   15a82:	f895 c000 	ldrb.w	ip, [r5]
   15a86:	ebcc 0004 	rsb	r0, ip, r4
   15a8a:	e7f4      	b.n	15a76 <strncmp+0x92>

00015a8c <strncpy>:
   15a8c:	ea41 0300 	orr.w	r3, r1, r0
   15a90:	f013 0f03 	tst.w	r3, #3
   15a94:	bf14      	ite	ne
   15a96:	2300      	movne	r3, #0
   15a98:	2301      	moveq	r3, #1
   15a9a:	2a03      	cmp	r2, #3
   15a9c:	bf94      	ite	ls
   15a9e:	2300      	movls	r3, #0
   15aa0:	f003 0301 	andhi.w	r3, r3, #1
   15aa4:	b430      	push	{r4, r5}
   15aa6:	2b00      	cmp	r3, #0
   15aa8:	d02a      	beq.n	15b00 <strncpy+0x74>
   15aaa:	4604      	mov	r4, r0
   15aac:	680b      	ldr	r3, [r1, #0]
   15aae:	f1a3 3c01 	sub.w	ip, r3, #16843009	; 0x1010101
   15ab2:	ea2c 0c03 	bic.w	ip, ip, r3
   15ab6:	f01c 3f80 	tst.w	ip, #2155905152	; 0x80808080
   15aba:	d105      	bne.n	15ac8 <strncpy+0x3c>
   15abc:	3a04      	subs	r2, #4
   15abe:	3104      	adds	r1, #4
   15ac0:	2a03      	cmp	r2, #3
   15ac2:	f844 3b04 	str.w	r3, [r4], #4
   15ac6:	d8f1      	bhi.n	15aac <strncpy+0x20>
   15ac8:	4623      	mov	r3, r4
   15aca:	b1ba      	cbz	r2, 15afc <strncpy+0x70>
   15acc:	780d      	ldrb	r5, [r1, #0]
   15ace:	461c      	mov	r4, r3
   15ad0:	3a01      	subs	r2, #1
   15ad2:	f804 5b01 	strb.w	r5, [r4], #1
   15ad6:	b155      	cbz	r5, 15aee <strncpy+0x62>
   15ad8:	3302      	adds	r3, #2
   15ada:	b17a      	cbz	r2, 15afc <strncpy+0x70>
   15adc:	f811 5f01 	ldrb.w	r5, [r1, #1]!
   15ae0:	461c      	mov	r4, r3
   15ae2:	3a01      	subs	r2, #1
   15ae4:	f803 5c01 	strb.w	r5, [r3, #-1]
   15ae8:	3301      	adds	r3, #1
   15aea:	2d00      	cmp	r5, #0
   15aec:	d1f5      	bne.n	15ada <strncpy+0x4e>
   15aee:	b12a      	cbz	r2, 15afc <strncpy+0x70>
   15af0:	2300      	movs	r3, #0
   15af2:	4619      	mov	r1, r3
   15af4:	54e1      	strb	r1, [r4, r3]
   15af6:	3301      	adds	r3, #1
   15af8:	4293      	cmp	r3, r2
   15afa:	d1fb      	bne.n	15af4 <strncpy+0x68>
   15afc:	bc30      	pop	{r4, r5}
   15afe:	4770      	bx	lr
   15b00:	4603      	mov	r3, r0
   15b02:	e7e2      	b.n	15aca <strncpy+0x3e>

00015b04 <strrchr>:
   15b04:	b570      	push	{r4, r5, r6, lr}
   15b06:	4603      	mov	r3, r0
   15b08:	460c      	mov	r4, r1
   15b0a:	b161      	cbz	r1, 15b26 <strrchr+0x22>
   15b0c:	2500      	movs	r5, #0
   15b0e:	e000      	b.n	15b12 <strrchr+0xe>
   15b10:	4615      	mov	r5, r2
   15b12:	4618      	mov	r0, r3
   15b14:	4621      	mov	r1, r4
   15b16:	f7ff fe77 	bl	15808 <strchr>
   15b1a:	4602      	mov	r2, r0
   15b1c:	1c43      	adds	r3, r0, #1
   15b1e:	2800      	cmp	r0, #0
   15b20:	d1f6      	bne.n	15b10 <strrchr+0xc>
   15b22:	4628      	mov	r0, r5
   15b24:	bd70      	pop	{r4, r5, r6, pc}
   15b26:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   15b2a:	f7ff be6d 	b.w	15808 <strchr>
   15b2e:	bf00      	nop

00015b30 <critical_factorization>:
   15b30:	2301      	movs	r3, #1
   15b32:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
   15b36:	461c      	mov	r4, r3
   15b38:	2500      	movs	r5, #0
   15b3a:	f04f 36ff 	mov.w	r6, #4294967295
   15b3e:	eb04 0c05 	add.w	ip, r4, r5
   15b42:	19a7      	adds	r7, r4, r6
   15b44:	458c      	cmp	ip, r1
   15b46:	d20d      	bcs.n	15b64 <critical_factorization+0x34>
   15b48:	5c3f      	ldrb	r7, [r7, r0]
   15b4a:	f810 800c 	ldrb.w	r8, [r0, ip]
   15b4e:	45b8      	cmp	r8, r7
   15b50:	d22f      	bcs.n	15bb2 <critical_factorization+0x82>
   15b52:	ebc6 030c 	rsb	r3, r6, ip
   15b56:	2401      	movs	r4, #1
   15b58:	4665      	mov	r5, ip
   15b5a:	eb04 0c05 	add.w	ip, r4, r5
   15b5e:	19a7      	adds	r7, r4, r6
   15b60:	458c      	cmp	ip, r1
   15b62:	d3f1      	bcc.n	15b48 <critical_factorization+0x18>
   15b64:	f04f 0a01 	mov.w	sl, #1
   15b68:	2500      	movs	r5, #0
   15b6a:	4654      	mov	r4, sl
   15b6c:	f04f 37ff 	mov.w	r7, #4294967295
   15b70:	eb04 0c05 	add.w	ip, r4, r5
   15b74:	6013      	str	r3, [r2, #0]
   15b76:	4561      	cmp	r1, ip
   15b78:	eb04 0807 	add.w	r8, r4, r7
   15b7c:	d90f      	bls.n	15b9e <critical_factorization+0x6e>
   15b7e:	f818 8000 	ldrb.w	r8, [r8, r0]
   15b82:	f810 900c 	ldrb.w	r9, [r0, ip]
   15b86:	45c1      	cmp	r9, r8
   15b88:	d924      	bls.n	15bd4 <critical_factorization+0xa4>
   15b8a:	ebc7 0a0c 	rsb	sl, r7, ip
   15b8e:	2401      	movs	r4, #1
   15b90:	4665      	mov	r5, ip
   15b92:	eb04 0c05 	add.w	ip, r4, r5
   15b96:	eb04 0807 	add.w	r8, r4, r7
   15b9a:	4561      	cmp	r1, ip
   15b9c:	d8ef      	bhi.n	15b7e <critical_factorization+0x4e>
   15b9e:	3701      	adds	r7, #1
   15ba0:	1c70      	adds	r0, r6, #1
   15ba2:	4287      	cmp	r7, r0
   15ba4:	bf24      	itt	cs
   15ba6:	4653      	movcs	r3, sl
   15ba8:	4638      	movcs	r0, r7
   15baa:	6013      	str	r3, [r2, #0]
   15bac:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
   15bb0:	4770      	bx	lr
   15bb2:	d006      	beq.n	15bc2 <critical_factorization+0x92>
   15bb4:	2301      	movs	r3, #1
   15bb6:	462e      	mov	r6, r5
   15bb8:	eb05 0c03 	add.w	ip, r5, r3
   15bbc:	461c      	mov	r4, r3
   15bbe:	4665      	mov	r5, ip
   15bc0:	e7cb      	b.n	15b5a <critical_factorization+0x2a>
   15bc2:	429c      	cmp	r4, r3
   15bc4:	f104 0401 	add.w	r4, r4, #1
   15bc8:	bf18      	it	ne
   15bca:	46ac      	movne	ip, r5
   15bcc:	d1c4      	bne.n	15b58 <critical_factorization+0x28>
   15bce:	2401      	movs	r4, #1
   15bd0:	4665      	mov	r5, ip
   15bd2:	e7c2      	b.n	15b5a <critical_factorization+0x2a>
   15bd4:	d007      	beq.n	15be6 <critical_factorization+0xb6>
   15bd6:	f04f 0a01 	mov.w	sl, #1
   15bda:	462f      	mov	r7, r5
   15bdc:	eb05 0c0a 	add.w	ip, r5, sl
   15be0:	4654      	mov	r4, sl
   15be2:	4665      	mov	r5, ip
   15be4:	e7d5      	b.n	15b92 <critical_factorization+0x62>
   15be6:	4554      	cmp	r4, sl
   15be8:	f104 0401 	add.w	r4, r4, #1
   15bec:	bf18      	it	ne
   15bee:	46ac      	movne	ip, r5
   15bf0:	d1ce      	bne.n	15b90 <critical_factorization+0x60>
   15bf2:	2401      	movs	r4, #1
   15bf4:	4665      	mov	r5, ip
   15bf6:	e7cc      	b.n	15b92 <critical_factorization+0x62>

00015bf8 <two_way_long_needle>:
   15bf8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15bfc:	f5ad 6d84 	sub.w	sp, sp, #1056	; 0x420
   15c00:	b081      	sub	sp, #4
   15c02:	4606      	mov	r6, r0
   15c04:	4610      	mov	r0, r2
   15c06:	4689      	mov	r9, r1
   15c08:	9203      	str	r2, [sp, #12]
   15c0a:	f50d 6282 	add.w	r2, sp, #1040	; 0x410
   15c0e:	4619      	mov	r1, r3
   15c10:	320c      	adds	r2, #12
   15c12:	461c      	mov	r4, r3
   15c14:	f7ff ff8c 	bl	15b30 <critical_factorization>
   15c18:	2300      	movs	r3, #0
   15c1a:	aa07      	add	r2, sp, #28
   15c1c:	4680      	mov	r8, r0
   15c1e:	50d4      	str	r4, [r2, r3]
   15c20:	3304      	adds	r3, #4
   15c22:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
   15c26:	d1fa      	bne.n	15c1e <two_way_long_needle+0x26>
   15c28:	b164      	cbz	r4, 15c44 <two_way_long_needle+0x4c>
   15c2a:	f8dd c00c 	ldr.w	ip, [sp, #12]
   15c2e:	1e62      	subs	r2, r4, #1
   15c30:	2300      	movs	r3, #0
   15c32:	a807      	add	r0, sp, #28
   15c34:	f81c 1003 	ldrb.w	r1, [ip, r3]
   15c38:	3301      	adds	r3, #1
   15c3a:	f840 2021 	str.w	r2, [r0, r1, lsl #2]
   15c3e:	3a01      	subs	r2, #1
   15c40:	429c      	cmp	r4, r3
   15c42:	d8f7      	bhi.n	15c34 <two_way_long_needle+0x3c>
   15c44:	9803      	ldr	r0, [sp, #12]
   15c46:	4642      	mov	r2, r8
   15c48:	f8dd 141c 	ldr.w	r1, [sp, #1052]	; 0x41c
   15c4c:	1841      	adds	r1, r0, r1
   15c4e:	f003 fc91 	bl	19574 <memcmp>
   15c52:	4605      	mov	r5, r0
   15c54:	2800      	cmp	r0, #0
   15c56:	f040 808b 	bne.w	15d70 <two_way_long_needle+0x178>
   15c5a:	9402      	str	r4, [sp, #8]
   15c5c:	4682      	mov	sl, r0
   15c5e:	9b02      	ldr	r3, [sp, #8]
   15c60:	f1c8 0201 	rsb	r2, r8, #1
   15c64:	9903      	ldr	r1, [sp, #12]
   15c66:	1e67      	subs	r7, r4, #1
   15c68:	9205      	str	r2, [sp, #20]
   15c6a:	eb0a 0403 	add.w	r4, sl, r3
   15c6e:	464a      	mov	r2, r9
   15c70:	f108 30ff 	add.w	r0, r8, #4294967295
   15c74:	4441      	add	r1, r8
   15c76:	9001      	str	r0, [sp, #4]
   15c78:	9104      	str	r1, [sp, #16]
   15c7a:	18b0      	adds	r0, r6, r2
   15c7c:	2100      	movs	r1, #0
   15c7e:	1aa2      	subs	r2, r4, r2
   15c80:	f8dd b00c 	ldr.w	fp, [sp, #12]
   15c84:	f003 fc3c 	bl	19500 <memchr>
   15c88:	4603      	mov	r3, r0
   15c8a:	2800      	cmp	r0, #0
   15c8c:	d159      	bne.n	15d42 <two_way_long_needle+0x14a>
   15c8e:	2c00      	cmp	r4, #0
   15c90:	d057      	beq.n	15d42 <two_way_long_needle+0x14a>
   15c92:	19a2      	adds	r2, r4, r6
   15c94:	a807      	add	r0, sp, #28
   15c96:	f812 2c01 	ldrb.w	r2, [r2, #-1]
   15c9a:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
   15c9e:	2a00      	cmp	r2, #0
   15ca0:	d15b      	bne.n	15d5a <two_way_long_needle+0x162>
   15ca2:	4545      	cmp	r5, r8
   15ca4:	bf2c      	ite	cs
   15ca6:	462b      	movcs	r3, r5
   15ca8:	4643      	movcc	r3, r8
   15caa:	42bb      	cmp	r3, r7
   15cac:	d213      	bcs.n	15cd6 <two_way_long_needle+0xde>
   15cae:	eb03 000a 	add.w	r0, r3, sl
   15cb2:	f81b c003 	ldrb.w	ip, [fp, r3]
   15cb6:	1832      	adds	r2, r6, r0
   15cb8:	eb0b 0103 	add.w	r1, fp, r3
   15cbc:	5c30      	ldrb	r0, [r6, r0]
   15cbe:	4584      	cmp	ip, r0
   15cc0:	d006      	beq.n	15cd0 <two_way_long_needle+0xd8>
   15cc2:	e044      	b.n	15d4e <two_way_long_needle+0x156>
   15cc4:	f811 cf01 	ldrb.w	ip, [r1, #1]!
   15cc8:	f812 0f01 	ldrb.w	r0, [r2, #1]!
   15ccc:	4584      	cmp	ip, r0
   15cce:	d13e      	bne.n	15d4e <two_way_long_needle+0x156>
   15cd0:	3301      	adds	r3, #1
   15cd2:	42bb      	cmp	r3, r7
   15cd4:	d3f6      	bcc.n	15cc4 <two_way_long_needle+0xcc>
   15cd6:	4545      	cmp	r5, r8
   15cd8:	f080 80b0 	bcs.w	15e3c <two_way_long_needle+0x244>
   15cdc:	9901      	ldr	r1, [sp, #4]
   15cde:	9b01      	ldr	r3, [sp, #4]
   15ce0:	eb01 020a 	add.w	r2, r1, sl
   15ce4:	f81b 1001 	ldrb.w	r1, [fp, r1]
   15ce8:	5d92      	ldrb	r2, [r2, r6]
   15cea:	4291      	cmp	r1, r2
   15cec:	f040 80a6 	bne.w	15e3c <two_way_long_needle+0x244>
   15cf0:	eb0a 0208 	add.w	r2, sl, r8
   15cf4:	9904      	ldr	r1, [sp, #16]
   15cf6:	18b2      	adds	r2, r6, r2
   15cf8:	46a1      	mov	r9, r4
   15cfa:	e008      	b.n	15d0e <two_way_long_needle+0x116>
   15cfc:	f811 4c02 	ldrb.w	r4, [r1, #-2]
   15d00:	3901      	subs	r1, #1
   15d02:	f812 cc02 	ldrb.w	ip, [r2, #-2]
   15d06:	3a01      	subs	r2, #1
   15d08:	4564      	cmp	r4, ip
   15d0a:	d104      	bne.n	15d16 <two_way_long_needle+0x11e>
   15d0c:	4603      	mov	r3, r0
   15d0e:	429d      	cmp	r5, r3
   15d10:	f103 30ff 	add.w	r0, r3, #4294967295
   15d14:	d3f2      	bcc.n	15cfc <two_way_long_needle+0x104>
   15d16:	3501      	adds	r5, #1
   15d18:	464c      	mov	r4, r9
   15d1a:	429d      	cmp	r5, r3
   15d1c:	f200 8093 	bhi.w	15e46 <two_way_long_needle+0x24e>
   15d20:	f8dd 541c 	ldr.w	r5, [sp, #1052]	; 0x41c
   15d24:	9a02      	ldr	r2, [sp, #8]
   15d26:	44aa      	add	sl, r5
   15d28:	1b55      	subs	r5, r2, r5
   15d2a:	4622      	mov	r2, r4
   15d2c:	9b02      	ldr	r3, [sp, #8]
   15d2e:	18b0      	adds	r0, r6, r2
   15d30:	2100      	movs	r1, #0
   15d32:	eb0a 0403 	add.w	r4, sl, r3
   15d36:	1aa2      	subs	r2, r4, r2
   15d38:	f003 fbe2 	bl	19500 <memchr>
   15d3c:	4603      	mov	r3, r0
   15d3e:	2800      	cmp	r0, #0
   15d40:	d0a5      	beq.n	15c8e <two_way_long_needle+0x96>
   15d42:	2000      	movs	r0, #0
   15d44:	b009      	add	sp, #36	; 0x24
   15d46:	f50d 6d80 	add.w	sp, sp, #1024	; 0x400
   15d4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15d4e:	9905      	ldr	r1, [sp, #20]
   15d50:	2500      	movs	r5, #0
   15d52:	4622      	mov	r2, r4
   15d54:	448a      	add	sl, r1
   15d56:	449a      	add	sl, r3
   15d58:	e7e8      	b.n	15d2c <two_way_long_needle+0x134>
   15d5a:	b135      	cbz	r5, 15d6a <two_way_long_needle+0x172>
   15d5c:	f8dd 141c 	ldr.w	r1, [sp, #1052]	; 0x41c
   15d60:	428a      	cmp	r2, r1
   15d62:	d202      	bcs.n	15d6a <two_way_long_needle+0x172>
   15d64:	9802      	ldr	r0, [sp, #8]
   15d66:	461d      	mov	r5, r3
   15d68:	1a42      	subs	r2, r0, r1
   15d6a:	4492      	add	sl, r2
   15d6c:	4622      	mov	r2, r4
   15d6e:	e7dd      	b.n	15d2c <two_way_long_needle+0x134>
   15d70:	9803      	ldr	r0, [sp, #12]
   15d72:	ebc8 0304 	rsb	r3, r8, r4
   15d76:	464a      	mov	r2, r9
   15d78:	2700      	movs	r7, #0
   15d7a:	1e65      	subs	r5, r4, #1
   15d7c:	f108 3aff 	add.w	sl, r8, #4294967295
   15d80:	eb00 0b08 	add.w	fp, r0, r8
   15d84:	46a1      	mov	r9, r4
   15d86:	4543      	cmp	r3, r8
   15d88:	bf38      	it	cc
   15d8a:	4643      	movcc	r3, r8
   15d8c:	f1c8 0101 	rsb	r1, r8, #1
   15d90:	3301      	adds	r3, #1
   15d92:	9101      	str	r1, [sp, #4]
   15d94:	f8cd 341c 	str.w	r3, [sp, #1052]	; 0x41c
   15d98:	eb07 0409 	add.w	r4, r7, r9
   15d9c:	18b0      	adds	r0, r6, r2
   15d9e:	2100      	movs	r1, #0
   15da0:	1aa2      	subs	r2, r4, r2
   15da2:	f003 fbad 	bl	19500 <memchr>
   15da6:	2800      	cmp	r0, #0
   15da8:	d1cb      	bne.n	15d42 <two_way_long_needle+0x14a>
   15daa:	2c00      	cmp	r4, #0
   15dac:	d0c9      	beq.n	15d42 <two_way_long_needle+0x14a>
   15dae:	19a3      	adds	r3, r4, r6
   15db0:	aa07      	add	r2, sp, #28
   15db2:	f813 3c01 	ldrb.w	r3, [r3, #-1]
   15db6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15dba:	2b00      	cmp	r3, #0
   15dbc:	d135      	bne.n	15e2a <two_way_long_needle+0x232>
   15dbe:	45a8      	cmp	r8, r5
   15dc0:	d214      	bcs.n	15dec <two_way_long_needle+0x1f4>
   15dc2:	eb07 0308 	add.w	r3, r7, r8
   15dc6:	f89b 2000 	ldrb.w	r2, [fp]
   15dca:	18f1      	adds	r1, r6, r3
   15dcc:	5cf3      	ldrb	r3, [r6, r3]
   15dce:	429a      	cmp	r2, r3
   15dd0:	bf04      	itt	eq
   15dd2:	465a      	moveq	r2, fp
   15dd4:	4643      	moveq	r3, r8
   15dd6:	d006      	beq.n	15de6 <two_way_long_needle+0x1ee>
   15dd8:	e02a      	b.n	15e30 <two_way_long_needle+0x238>
   15dda:	f812 cf01 	ldrb.w	ip, [r2, #1]!
   15dde:	f811 0f01 	ldrb.w	r0, [r1, #1]!
   15de2:	4584      	cmp	ip, r0
   15de4:	d125      	bne.n	15e32 <two_way_long_needle+0x23a>
   15de6:	3301      	adds	r3, #1
   15de8:	42ab      	cmp	r3, r5
   15dea:	d3f6      	bcc.n	15dda <two_way_long_needle+0x1e2>
   15dec:	f1ba 3fff 	cmp.w	sl, #4294967295
   15df0:	4653      	mov	r3, sl
   15df2:	d016      	beq.n	15e22 <two_way_long_needle+0x22a>
   15df4:	9803      	ldr	r0, [sp, #12]
   15df6:	eb0a 0207 	add.w	r2, sl, r7
   15dfa:	5d92      	ldrb	r2, [r2, r6]
   15dfc:	f810 100a 	ldrb.w	r1, [r0, sl]
   15e00:	4291      	cmp	r1, r2
   15e02:	d110      	bne.n	15e26 <two_way_long_needle+0x22e>
   15e04:	eb07 0208 	add.w	r2, r7, r8
   15e08:	4659      	mov	r1, fp
   15e0a:	18b2      	adds	r2, r6, r2
   15e0c:	e007      	b.n	15e1e <two_way_long_needle+0x226>
   15e0e:	f811 cc02 	ldrb.w	ip, [r1, #-2]
   15e12:	3901      	subs	r1, #1
   15e14:	f812 0c02 	ldrb.w	r0, [r2, #-2]
   15e18:	3a01      	subs	r2, #1
   15e1a:	4584      	cmp	ip, r0
   15e1c:	d103      	bne.n	15e26 <two_way_long_needle+0x22e>
   15e1e:	3b01      	subs	r3, #1
   15e20:	d2f5      	bcs.n	15e0e <two_way_long_needle+0x216>
   15e22:	19f0      	adds	r0, r6, r7
   15e24:	e78e      	b.n	15d44 <two_way_long_needle+0x14c>
   15e26:	f8dd 341c 	ldr.w	r3, [sp, #1052]	; 0x41c
   15e2a:	18ff      	adds	r7, r7, r3
   15e2c:	4622      	mov	r2, r4
   15e2e:	e7b3      	b.n	15d98 <two_way_long_needle+0x1a0>
   15e30:	4643      	mov	r3, r8
   15e32:	9a01      	ldr	r2, [sp, #4]
   15e34:	19d7      	adds	r7, r2, r7
   15e36:	4622      	mov	r2, r4
   15e38:	18ff      	adds	r7, r7, r3
   15e3a:	e7ad      	b.n	15d98 <two_way_long_needle+0x1a0>
   15e3c:	4643      	mov	r3, r8
   15e3e:	3501      	adds	r5, #1
   15e40:	429d      	cmp	r5, r3
   15e42:	f67f af6d 	bls.w	15d20 <two_way_long_needle+0x128>
   15e46:	eb06 000a 	add.w	r0, r6, sl
   15e4a:	e77b      	b.n	15d44 <two_way_long_needle+0x14c>

00015e4c <strstr>:
   15e4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15e50:	7803      	ldrb	r3, [r0, #0]
   15e52:	b087      	sub	sp, #28
   15e54:	4606      	mov	r6, r0
   15e56:	460d      	mov	r5, r1
   15e58:	2b00      	cmp	r3, #0
   15e5a:	f000 8104 	beq.w	16066 <strstr+0x21a>
   15e5e:	780a      	ldrb	r2, [r1, #0]
   15e60:	b192      	cbz	r2, 15e88 <strstr+0x3c>
   15e62:	4601      	mov	r1, r0
   15e64:	462c      	mov	r4, r5
   15e66:	2001      	movs	r0, #1
   15e68:	e001      	b.n	15e6e <strstr+0x22>
   15e6a:	7822      	ldrb	r2, [r4, #0]
   15e6c:	b182      	cbz	r2, 15e90 <strstr+0x44>
   15e6e:	4293      	cmp	r3, r2
   15e70:	bf14      	ite	ne
   15e72:	2000      	movne	r0, #0
   15e74:	f000 0001 	andeq.w	r0, r0, #1
   15e78:	784b      	ldrb	r3, [r1, #1]
   15e7a:	3401      	adds	r4, #1
   15e7c:	3101      	adds	r1, #1
   15e7e:	2b00      	cmp	r3, #0
   15e80:	d1f3      	bne.n	15e6a <strstr+0x1e>
   15e82:	7823      	ldrb	r3, [r4, #0]
   15e84:	b123      	cbz	r3, 15e90 <strstr+0x44>
   15e86:	2600      	movs	r6, #0
   15e88:	4630      	mov	r0, r6
   15e8a:	b007      	add	sp, #28
   15e8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15e90:	2800      	cmp	r0, #0
   15e92:	d1f9      	bne.n	15e88 <strstr+0x3c>
   15e94:	1c70      	adds	r0, r6, #1
   15e96:	7829      	ldrb	r1, [r5, #0]
   15e98:	f7ff fcb6 	bl	15808 <strchr>
   15e9c:	1b64      	subs	r4, r4, r5
   15e9e:	2c01      	cmp	r4, #1
   15ea0:	bf14      	ite	ne
   15ea2:	2300      	movne	r3, #0
   15ea4:	2301      	moveq	r3, #1
   15ea6:	2800      	cmp	r0, #0
   15ea8:	bf08      	it	eq
   15eaa:	f043 0301 	orreq.w	r3, r3, #1
   15eae:	4607      	mov	r7, r0
   15eb0:	b97b      	cbnz	r3, 15ed2 <strstr+0x86>
   15eb2:	1936      	adds	r6, r6, r4
   15eb4:	42b0      	cmp	r0, r6
   15eb6:	bf8c      	ite	hi
   15eb8:	f04f 0a01 	movhi.w	sl, #1
   15ebc:	ebc0 0a06 	rsbls	sl, r0, r6
   15ec0:	2c1f      	cmp	r4, #31
   15ec2:	d908      	bls.n	15ed6 <strstr+0x8a>
   15ec4:	4651      	mov	r1, sl
   15ec6:	462a      	mov	r2, r5
   15ec8:	4623      	mov	r3, r4
   15eca:	f7ff fe95 	bl	15bf8 <two_way_long_needle>
   15ece:	4606      	mov	r6, r0
   15ed0:	e7da      	b.n	15e88 <strstr+0x3c>
   15ed2:	4606      	mov	r6, r0
   15ed4:	e7d8      	b.n	15e88 <strstr+0x3c>
   15ed6:	4621      	mov	r1, r4
   15ed8:	aa05      	add	r2, sp, #20
   15eda:	4628      	mov	r0, r5
   15edc:	f7ff fe28 	bl	15b30 <critical_factorization>
   15ee0:	9905      	ldr	r1, [sp, #20]
   15ee2:	1869      	adds	r1, r5, r1
   15ee4:	4680      	mov	r8, r0
   15ee6:	4628      	mov	r0, r5
   15ee8:	4642      	mov	r2, r8
   15eea:	f003 fb43 	bl	19574 <memcmp>
   15eee:	4606      	mov	r6, r0
   15ef0:	2800      	cmp	r0, #0
   15ef2:	d158      	bne.n	15fa6 <strstr+0x15a>
   15ef4:	f108 32ff 	add.w	r2, r8, #4294967295
   15ef8:	eb05 0308 	add.w	r3, r5, r8
   15efc:	9201      	str	r2, [sp, #4]
   15efe:	46c3      	mov	fp, r8
   15f00:	f1c8 0201 	rsb	r2, r8, #1
   15f04:	4681      	mov	r9, r0
   15f06:	9203      	str	r2, [sp, #12]
   15f08:	46a8      	mov	r8, r5
   15f0a:	4652      	mov	r2, sl
   15f0c:	9302      	str	r3, [sp, #8]
   15f0e:	eb09 0504 	add.w	r5, r9, r4
   15f12:	18b8      	adds	r0, r7, r2
   15f14:	2100      	movs	r1, #0
   15f16:	1aaa      	subs	r2, r5, r2
   15f18:	f003 faf2 	bl	19500 <memchr>
   15f1c:	2800      	cmp	r0, #0
   15f1e:	d1b2      	bne.n	15e86 <strstr+0x3a>
   15f20:	2d00      	cmp	r5, #0
   15f22:	d0b0      	beq.n	15e86 <strstr+0x3a>
   15f24:	455e      	cmp	r6, fp
   15f26:	bf2c      	ite	cs
   15f28:	4633      	movcs	r3, r6
   15f2a:	465b      	movcc	r3, fp
   15f2c:	429c      	cmp	r4, r3
   15f2e:	d913      	bls.n	15f58 <strstr+0x10c>
   15f30:	eb03 0009 	add.w	r0, r3, r9
   15f34:	f818 c003 	ldrb.w	ip, [r8, r3]
   15f38:	183a      	adds	r2, r7, r0
   15f3a:	eb08 0103 	add.w	r1, r8, r3
   15f3e:	5c38      	ldrb	r0, [r7, r0]
   15f40:	4584      	cmp	ip, r0
   15f42:	d006      	beq.n	15f52 <strstr+0x106>
   15f44:	e085      	b.n	16052 <strstr+0x206>
   15f46:	f811 cf01 	ldrb.w	ip, [r1, #1]!
   15f4a:	f812 0f01 	ldrb.w	r0, [r2, #1]!
   15f4e:	4584      	cmp	ip, r0
   15f50:	d17f      	bne.n	16052 <strstr+0x206>
   15f52:	3301      	adds	r3, #1
   15f54:	429c      	cmp	r4, r3
   15f56:	d8f6      	bhi.n	15f46 <strstr+0xfa>
   15f58:	45b3      	cmp	fp, r6
   15f5a:	f240 8087 	bls.w	1606c <strstr+0x220>
   15f5e:	9b01      	ldr	r3, [sp, #4]
   15f60:	eb03 0209 	add.w	r2, r3, r9
   15f64:	f818 1003 	ldrb.w	r1, [r8, r3]
   15f68:	5dd2      	ldrb	r2, [r2, r7]
   15f6a:	4291      	cmp	r1, r2
   15f6c:	d17e      	bne.n	1606c <strstr+0x220>
   15f6e:	eb09 020b 	add.w	r2, r9, fp
   15f72:	9902      	ldr	r1, [sp, #8]
   15f74:	18ba      	adds	r2, r7, r2
   15f76:	46aa      	mov	sl, r5
   15f78:	e008      	b.n	15f8c <strstr+0x140>
   15f7a:	f811 5c02 	ldrb.w	r5, [r1, #-2]
   15f7e:	3901      	subs	r1, #1
   15f80:	f812 cc02 	ldrb.w	ip, [r2, #-2]
   15f84:	3a01      	subs	r2, #1
   15f86:	4565      	cmp	r5, ip
   15f88:	d104      	bne.n	15f94 <strstr+0x148>
   15f8a:	4603      	mov	r3, r0
   15f8c:	429e      	cmp	r6, r3
   15f8e:	f103 30ff 	add.w	r0, r3, #4294967295
   15f92:	d3f2      	bcc.n	15f7a <strstr+0x12e>
   15f94:	4655      	mov	r5, sl
   15f96:	3601      	adds	r6, #1
   15f98:	429e      	cmp	r6, r3
   15f9a:	d869      	bhi.n	16070 <strstr+0x224>
   15f9c:	9e05      	ldr	r6, [sp, #20]
   15f9e:	462a      	mov	r2, r5
   15fa0:	44b1      	add	r9, r6
   15fa2:	1ba6      	subs	r6, r4, r6
   15fa4:	e7b3      	b.n	15f0e <strstr+0xc2>
   15fa6:	f1c8 0201 	rsb	r2, r8, #1
   15faa:	ebc8 0304 	rsb	r3, r8, r4
   15fae:	9201      	str	r2, [sp, #4]
   15fb0:	2600      	movs	r6, #0
   15fb2:	4652      	mov	r2, sl
   15fb4:	eb05 0908 	add.w	r9, r5, r8
   15fb8:	f108 3bff 	add.w	fp, r8, #4294967295
   15fbc:	46aa      	mov	sl, r5
   15fbe:	4543      	cmp	r3, r8
   15fc0:	bf38      	it	cc
   15fc2:	4643      	movcc	r3, r8
   15fc4:	3301      	adds	r3, #1
   15fc6:	9305      	str	r3, [sp, #20]
   15fc8:	1935      	adds	r5, r6, r4
   15fca:	18b8      	adds	r0, r7, r2
   15fcc:	2100      	movs	r1, #0
   15fce:	1aaa      	subs	r2, r5, r2
   15fd0:	f003 fa96 	bl	19500 <memchr>
   15fd4:	2800      	cmp	r0, #0
   15fd6:	f47f af56 	bne.w	15e86 <strstr+0x3a>
   15fda:	2d00      	cmp	r5, #0
   15fdc:	f43f af53 	beq.w	15e86 <strstr+0x3a>
   15fe0:	4544      	cmp	r4, r8
   15fe2:	d915      	bls.n	16010 <strstr+0x1c4>
   15fe4:	eb06 0308 	add.w	r3, r6, r8
   15fe8:	f899 2000 	ldrb.w	r2, [r9]
   15fec:	18f9      	adds	r1, r7, r3
   15fee:	5cfb      	ldrb	r3, [r7, r3]
   15ff0:	429a      	cmp	r2, r3
   15ff2:	bf12      	itee	ne
   15ff4:	4643      	movne	r3, r8
   15ff6:	464a      	moveq	r2, r9
   15ff8:	4643      	moveq	r3, r8
   15ffa:	d006      	beq.n	1600a <strstr+0x1be>
   15ffc:	e024      	b.n	16048 <strstr+0x1fc>
   15ffe:	f812 cf01 	ldrb.w	ip, [r2, #1]!
   16002:	f811 0f01 	ldrb.w	r0, [r1, #1]!
   16006:	4584      	cmp	ip, r0
   16008:	d11e      	bne.n	16048 <strstr+0x1fc>
   1600a:	3301      	adds	r3, #1
   1600c:	429c      	cmp	r4, r3
   1600e:	d8f6      	bhi.n	15ffe <strstr+0x1b2>
   16010:	f1bb 3fff 	cmp.w	fp, #4294967295
   16014:	465b      	mov	r3, fp
   16016:	d015      	beq.n	16044 <strstr+0x1f8>
   16018:	eb06 020b 	add.w	r2, r6, fp
   1601c:	f81a 100b 	ldrb.w	r1, [sl, fp]
   16020:	5dd2      	ldrb	r2, [r2, r7]
   16022:	4291      	cmp	r1, r2
   16024:	d11b      	bne.n	1605e <strstr+0x212>
   16026:	eb06 0208 	add.w	r2, r6, r8
   1602a:	4649      	mov	r1, r9
   1602c:	18ba      	adds	r2, r7, r2
   1602e:	e007      	b.n	16040 <strstr+0x1f4>
   16030:	f811 cc02 	ldrb.w	ip, [r1, #-2]
   16034:	3901      	subs	r1, #1
   16036:	f812 0c02 	ldrb.w	r0, [r2, #-2]
   1603a:	3a01      	subs	r2, #1
   1603c:	4584      	cmp	ip, r0
   1603e:	d10e      	bne.n	1605e <strstr+0x212>
   16040:	3b01      	subs	r3, #1
   16042:	d2f5      	bcs.n	16030 <strstr+0x1e4>
   16044:	19be      	adds	r6, r7, r6
   16046:	e71f      	b.n	15e88 <strstr+0x3c>
   16048:	9a01      	ldr	r2, [sp, #4]
   1604a:	1996      	adds	r6, r2, r6
   1604c:	462a      	mov	r2, r5
   1604e:	18f6      	adds	r6, r6, r3
   16050:	e7ba      	b.n	15fc8 <strstr+0x17c>
   16052:	9a03      	ldr	r2, [sp, #12]
   16054:	2600      	movs	r6, #0
   16056:	4491      	add	r9, r2
   16058:	462a      	mov	r2, r5
   1605a:	4499      	add	r9, r3
   1605c:	e757      	b.n	15f0e <strstr+0xc2>
   1605e:	9b05      	ldr	r3, [sp, #20]
   16060:	462a      	mov	r2, r5
   16062:	18f6      	adds	r6, r6, r3
   16064:	e7b0      	b.n	15fc8 <strstr+0x17c>
   16066:	460c      	mov	r4, r1
   16068:	2001      	movs	r0, #1
   1606a:	e70a      	b.n	15e82 <strstr+0x36>
   1606c:	465b      	mov	r3, fp
   1606e:	e792      	b.n	15f96 <strstr+0x14a>
   16070:	eb07 0609 	add.w	r6, r7, r9
   16074:	e708      	b.n	15e88 <strstr+0x3c>
   16076:	bf00      	nop

00016078 <__sprint_r>:
   16078:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1607c:	b085      	sub	sp, #20
   1607e:	4692      	mov	sl, r2
   16080:	460c      	mov	r4, r1
   16082:	9003      	str	r0, [sp, #12]
   16084:	6890      	ldr	r0, [r2, #8]
   16086:	6817      	ldr	r7, [r2, #0]
   16088:	2800      	cmp	r0, #0
   1608a:	f000 8081 	beq.w	16190 <__sprint_r+0x118>
   1608e:	f04f 0900 	mov.w	r9, #0
   16092:	680b      	ldr	r3, [r1, #0]
   16094:	464d      	mov	r5, r9
   16096:	2d00      	cmp	r5, #0
   16098:	d054      	beq.n	16144 <__sprint_r+0xcc>
   1609a:	68a6      	ldr	r6, [r4, #8]
   1609c:	42b5      	cmp	r5, r6
   1609e:	46b0      	mov	r8, r6
   160a0:	bf3e      	ittt	cc
   160a2:	4618      	movcc	r0, r3
   160a4:	462e      	movcc	r6, r5
   160a6:	46a8      	movcc	r8, r5
   160a8:	d33c      	bcc.n	16124 <__sprint_r+0xac>
   160aa:	89a0      	ldrh	r0, [r4, #12]
   160ac:	f410 6f90 	tst.w	r0, #1152	; 0x480
   160b0:	bf08      	it	eq
   160b2:	4618      	moveq	r0, r3
   160b4:	d036      	beq.n	16124 <__sprint_r+0xac>
   160b6:	6962      	ldr	r2, [r4, #20]
   160b8:	6921      	ldr	r1, [r4, #16]
   160ba:	eb02 0b42 	add.w	fp, r2, r2, lsl #1
   160be:	1a5b      	subs	r3, r3, r1
   160c0:	f103 0c01 	add.w	ip, r3, #1
   160c4:	eb0b 7bdb 	add.w	fp, fp, fp, lsr #31
   160c8:	44ac      	add	ip, r5
   160ca:	ea4f 0b6b 	mov.w	fp, fp, asr #1
   160ce:	45e3      	cmp	fp, ip
   160d0:	465a      	mov	r2, fp
   160d2:	bf3c      	itt	cc
   160d4:	46e3      	movcc	fp, ip
   160d6:	465a      	movcc	r2, fp
   160d8:	f410 6f80 	tst.w	r0, #1024	; 0x400
   160dc:	d037      	beq.n	1614e <__sprint_r+0xd6>
   160de:	4611      	mov	r1, r2
   160e0:	9803      	ldr	r0, [sp, #12]
   160e2:	9301      	str	r3, [sp, #4]
   160e4:	f002 ff3a 	bl	18f5c <_malloc_r>
   160e8:	9b01      	ldr	r3, [sp, #4]
   160ea:	2800      	cmp	r0, #0
   160ec:	d03b      	beq.n	16166 <__sprint_r+0xee>
   160ee:	461a      	mov	r2, r3
   160f0:	6921      	ldr	r1, [r4, #16]
   160f2:	9301      	str	r3, [sp, #4]
   160f4:	9002      	str	r0, [sp, #8]
   160f6:	f7ff f99d 	bl	15434 <memcpy>
   160fa:	89a2      	ldrh	r2, [r4, #12]
   160fc:	9b01      	ldr	r3, [sp, #4]
   160fe:	f8dd c008 	ldr.w	ip, [sp, #8]
   16102:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
   16106:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   1610a:	81a2      	strh	r2, [r4, #12]
   1610c:	462e      	mov	r6, r5
   1610e:	46a8      	mov	r8, r5
   16110:	ebc3 020b 	rsb	r2, r3, fp
   16114:	eb0c 0003 	add.w	r0, ip, r3
   16118:	60a2      	str	r2, [r4, #8]
   1611a:	f8c4 c010 	str.w	ip, [r4, #16]
   1611e:	6020      	str	r0, [r4, #0]
   16120:	f8c4 b014 	str.w	fp, [r4, #20]
   16124:	4642      	mov	r2, r8
   16126:	4649      	mov	r1, r9
   16128:	f003 fa56 	bl	195d8 <memmove>
   1612c:	68a2      	ldr	r2, [r4, #8]
   1612e:	6823      	ldr	r3, [r4, #0]
   16130:	1b96      	subs	r6, r2, r6
   16132:	60a6      	str	r6, [r4, #8]
   16134:	f8da 2008 	ldr.w	r2, [sl, #8]
   16138:	4443      	add	r3, r8
   1613a:	6023      	str	r3, [r4, #0]
   1613c:	1b55      	subs	r5, r2, r5
   1613e:	f8ca 5008 	str.w	r5, [sl, #8]
   16142:	b1fd      	cbz	r5, 16184 <__sprint_r+0x10c>
   16144:	f8d7 9000 	ldr.w	r9, [r7]
   16148:	687d      	ldr	r5, [r7, #4]
   1614a:	3708      	adds	r7, #8
   1614c:	e7a3      	b.n	16096 <__sprint_r+0x1e>
   1614e:	9803      	ldr	r0, [sp, #12]
   16150:	9301      	str	r3, [sp, #4]
   16152:	f003 ff4d 	bl	19ff0 <_realloc_r>
   16156:	9b01      	ldr	r3, [sp, #4]
   16158:	4684      	mov	ip, r0
   1615a:	2800      	cmp	r0, #0
   1615c:	d1d6      	bne.n	1610c <__sprint_r+0x94>
   1615e:	9803      	ldr	r0, [sp, #12]
   16160:	6921      	ldr	r1, [r4, #16]
   16162:	f002 fdd1 	bl	18d08 <_free_r>
   16166:	9a03      	ldr	r2, [sp, #12]
   16168:	230c      	movs	r3, #12
   1616a:	f04f 30ff 	mov.w	r0, #4294967295
   1616e:	6013      	str	r3, [r2, #0]
   16170:	2300      	movs	r3, #0
   16172:	89a2      	ldrh	r2, [r4, #12]
   16174:	f8ca 3004 	str.w	r3, [sl, #4]
   16178:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   1617c:	f8ca 3008 	str.w	r3, [sl, #8]
   16180:	81a2      	strh	r2, [r4, #12]
   16182:	e002      	b.n	1618a <__sprint_r+0x112>
   16184:	4628      	mov	r0, r5
   16186:	f8ca 5004 	str.w	r5, [sl, #4]
   1618a:	b005      	add	sp, #20
   1618c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   16190:	6050      	str	r0, [r2, #4]
   16192:	e7fa      	b.n	1618a <__sprint_r+0x112>

00016194 <_svfprintf_r>:
   16194:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16198:	b0c5      	sub	sp, #276	; 0x114
   1619a:	460e      	mov	r6, r1
   1619c:	469a      	mov	sl, r3
   1619e:	4615      	mov	r5, r2
   161a0:	9009      	str	r0, [sp, #36]	; 0x24
   161a2:	f002 fe97 	bl	18ed4 <_localeconv_r>
   161a6:	89b3      	ldrh	r3, [r6, #12]
   161a8:	f013 0f80 	tst.w	r3, #128	; 0x80
   161ac:	6800      	ldr	r0, [r0, #0]
   161ae:	901b      	str	r0, [sp, #108]	; 0x6c
   161b0:	d003      	beq.n	161ba <_svfprintf_r+0x26>
   161b2:	6933      	ldr	r3, [r6, #16]
   161b4:	2b00      	cmp	r3, #0
   161b6:	f001 808c 	beq.w	172d2 <_svfprintf_r+0x113e>
   161ba:	f10d 0974 	add.w	r9, sp, #116	; 0x74
   161be:	46b3      	mov	fp, r6
   161c0:	464c      	mov	r4, r9
   161c2:	2200      	movs	r2, #0
   161c4:	9210      	str	r2, [sp, #64]	; 0x40
   161c6:	2300      	movs	r3, #0
   161c8:	9218      	str	r2, [sp, #96]	; 0x60
   161ca:	9217      	str	r2, [sp, #92]	; 0x5c
   161cc:	921a      	str	r2, [sp, #104]	; 0x68
   161ce:	920d      	str	r2, [sp, #52]	; 0x34
   161d0:	aa2d      	add	r2, sp, #180	; 0xb4
   161d2:	9319      	str	r3, [sp, #100]	; 0x64
   161d4:	3228      	adds	r2, #40	; 0x28
   161d6:	f10d 03f7 	add.w	r3, sp, #247	; 0xf7
   161da:	9216      	str	r2, [sp, #88]	; 0x58
   161dc:	9307      	str	r3, [sp, #28]
   161de:	2300      	movs	r3, #0
   161e0:	f8cd 90dc 	str.w	r9, [sp, #220]	; 0xdc
   161e4:	9338      	str	r3, [sp, #224]	; 0xe0
   161e6:	9339      	str	r3, [sp, #228]	; 0xe4
   161e8:	782b      	ldrb	r3, [r5, #0]
   161ea:	f1b3 0225 	subs.w	r2, r3, #37	; 0x25
   161ee:	bf18      	it	ne
   161f0:	2201      	movne	r2, #1
   161f2:	2b00      	cmp	r3, #0
   161f4:	bf0c      	ite	eq
   161f6:	2200      	moveq	r2, #0
   161f8:	f002 0201 	andne.w	r2, r2, #1
   161fc:	b302      	cbz	r2, 16240 <_svfprintf_r+0xac>
   161fe:	462e      	mov	r6, r5
   16200:	f816 3f01 	ldrb.w	r3, [r6, #1]!
   16204:	1e1a      	subs	r2, r3, #0
   16206:	bf18      	it	ne
   16208:	2201      	movne	r2, #1
   1620a:	2b25      	cmp	r3, #37	; 0x25
   1620c:	bf0c      	ite	eq
   1620e:	2200      	moveq	r2, #0
   16210:	f002 0201 	andne.w	r2, r2, #1
   16214:	2a00      	cmp	r2, #0
   16216:	d1f3      	bne.n	16200 <_svfprintf_r+0x6c>
   16218:	1b77      	subs	r7, r6, r5
   1621a:	bf08      	it	eq
   1621c:	4635      	moveq	r5, r6
   1621e:	d00f      	beq.n	16240 <_svfprintf_r+0xac>
   16220:	6067      	str	r7, [r4, #4]
   16222:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   16224:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   16226:	3301      	adds	r3, #1
   16228:	6025      	str	r5, [r4, #0]
   1622a:	19d2      	adds	r2, r2, r7
   1622c:	2b07      	cmp	r3, #7
   1622e:	9239      	str	r2, [sp, #228]	; 0xe4
   16230:	9338      	str	r3, [sp, #224]	; 0xe0
   16232:	dc79      	bgt.n	16328 <_svfprintf_r+0x194>
   16234:	3408      	adds	r4, #8
   16236:	980d      	ldr	r0, [sp, #52]	; 0x34
   16238:	4635      	mov	r5, r6
   1623a:	19c0      	adds	r0, r0, r7
   1623c:	900d      	str	r0, [sp, #52]	; 0x34
   1623e:	7833      	ldrb	r3, [r6, #0]
   16240:	2b00      	cmp	r3, #0
   16242:	f000 8737 	beq.w	170b4 <_svfprintf_r+0xf20>
   16246:	2100      	movs	r1, #0
   16248:	f04f 0200 	mov.w	r2, #0
   1624c:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
   16250:	1c6b      	adds	r3, r5, #1
   16252:	910c      	str	r1, [sp, #48]	; 0x30
   16254:	f04f 38ff 	mov.w	r8, #4294967295
   16258:	f88d 210f 	strb.w	r2, [sp, #271]	; 0x10f
   1625c:	468a      	mov	sl, r1
   1625e:	786a      	ldrb	r2, [r5, #1]
   16260:	202b      	movs	r0, #43	; 0x2b
   16262:	f04f 0c20 	mov.w	ip, #32
   16266:	1c5d      	adds	r5, r3, #1
   16268:	f1a2 0320 	sub.w	r3, r2, #32
   1626c:	2b58      	cmp	r3, #88	; 0x58
   1626e:	f200 8219 	bhi.w	166a4 <_svfprintf_r+0x510>
   16272:	e8df f013 	tbh	[pc, r3, lsl #1]
   16276:	0229      	.short	0x0229
   16278:	02170217 	.word	0x02170217
   1627c:	02170235 	.word	0x02170235
   16280:	02170217 	.word	0x02170217
   16284:	02170217 	.word	0x02170217
   16288:	023c0217 	.word	0x023c0217
   1628c:	02170248 	.word	0x02170248
   16290:	02cf02c8 	.word	0x02cf02c8
   16294:	02ef0217 	.word	0x02ef0217
   16298:	02f602f6 	.word	0x02f602f6
   1629c:	02f602f6 	.word	0x02f602f6
   162a0:	02f602f6 	.word	0x02f602f6
   162a4:	02f602f6 	.word	0x02f602f6
   162a8:	021702f6 	.word	0x021702f6
   162ac:	02170217 	.word	0x02170217
   162b0:	02170217 	.word	0x02170217
   162b4:	02170217 	.word	0x02170217
   162b8:	02170217 	.word	0x02170217
   162bc:	024f0217 	.word	0x024f0217
   162c0:	02170288 	.word	0x02170288
   162c4:	02170288 	.word	0x02170288
   162c8:	02170217 	.word	0x02170217
   162cc:	02c10217 	.word	0x02c10217
   162d0:	02170217 	.word	0x02170217
   162d4:	021703ee 	.word	0x021703ee
   162d8:	02170217 	.word	0x02170217
   162dc:	02170217 	.word	0x02170217
   162e0:	02170393 	.word	0x02170393
   162e4:	03ad0217 	.word	0x03ad0217
   162e8:	02170217 	.word	0x02170217
   162ec:	02170217 	.word	0x02170217
   162f0:	02170217 	.word	0x02170217
   162f4:	02170217 	.word	0x02170217
   162f8:	02170217 	.word	0x02170217
   162fc:	03d803c7 	.word	0x03d803c7
   16300:	02880288 	.word	0x02880288
   16304:	030b0288 	.word	0x030b0288
   16308:	021703d8 	.word	0x021703d8
   1630c:	030f0217 	.word	0x030f0217
   16310:	03190217 	.word	0x03190217
   16314:	033e0329 	.word	0x033e0329
   16318:	0217038c 	.word	0x0217038c
   1631c:	02170359 	.word	0x02170359
   16320:	02170384 	.word	0x02170384
   16324:	00ea0217 	.word	0x00ea0217
   16328:	9809      	ldr	r0, [sp, #36]	; 0x24
   1632a:	4659      	mov	r1, fp
   1632c:	aa37      	add	r2, sp, #220	; 0xdc
   1632e:	f7ff fea3 	bl	16078 <__sprint_r>
   16332:	2800      	cmp	r0, #0
   16334:	d17c      	bne.n	16430 <_svfprintf_r+0x29c>
   16336:	464c      	mov	r4, r9
   16338:	e77d      	b.n	16236 <_svfprintf_r+0xa2>
   1633a:	9918      	ldr	r1, [sp, #96]	; 0x60
   1633c:	2901      	cmp	r1, #1
   1633e:	f340 8452 	ble.w	16be6 <_svfprintf_r+0xa52>
   16342:	9a11      	ldr	r2, [sp, #68]	; 0x44
   16344:	2301      	movs	r3, #1
   16346:	6063      	str	r3, [r4, #4]
   16348:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   1634a:	6022      	str	r2, [r4, #0]
   1634c:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   1634e:	3301      	adds	r3, #1
   16350:	9338      	str	r3, [sp, #224]	; 0xe0
   16352:	3201      	adds	r2, #1
   16354:	2b07      	cmp	r3, #7
   16356:	9239      	str	r2, [sp, #228]	; 0xe4
   16358:	f300 8596 	bgt.w	16e88 <_svfprintf_r+0xcf4>
   1635c:	3408      	adds	r4, #8
   1635e:	2301      	movs	r3, #1
   16360:	6063      	str	r3, [r4, #4]
   16362:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   16364:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   16366:	3301      	adds	r3, #1
   16368:	981b      	ldr	r0, [sp, #108]	; 0x6c
   1636a:	3201      	adds	r2, #1
   1636c:	2b07      	cmp	r3, #7
   1636e:	9239      	str	r2, [sp, #228]	; 0xe4
   16370:	6020      	str	r0, [r4, #0]
   16372:	9338      	str	r3, [sp, #224]	; 0xe0
   16374:	f300 857d 	bgt.w	16e72 <_svfprintf_r+0xcde>
   16378:	3408      	adds	r4, #8
   1637a:	9810      	ldr	r0, [sp, #64]	; 0x40
   1637c:	2200      	movs	r2, #0
   1637e:	2300      	movs	r3, #0
   16380:	9919      	ldr	r1, [sp, #100]	; 0x64
   16382:	f004 fb79 	bl	1aa78 <__aeabi_dcmpeq>
   16386:	2800      	cmp	r0, #0
   16388:	f040 8503 	bne.w	16d92 <_svfprintf_r+0xbfe>
   1638c:	9918      	ldr	r1, [sp, #96]	; 0x60
   1638e:	9b11      	ldr	r3, [sp, #68]	; 0x44
   16390:	1e4a      	subs	r2, r1, #1
   16392:	6062      	str	r2, [r4, #4]
   16394:	1c59      	adds	r1, r3, #1
   16396:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   16398:	6021      	str	r1, [r4, #0]
   1639a:	9939      	ldr	r1, [sp, #228]	; 0xe4
   1639c:	3301      	adds	r3, #1
   1639e:	9338      	str	r3, [sp, #224]	; 0xe0
   163a0:	188a      	adds	r2, r1, r2
   163a2:	2b07      	cmp	r3, #7
   163a4:	9239      	str	r2, [sp, #228]	; 0xe4
   163a6:	f300 842f 	bgt.w	16c08 <_svfprintf_r+0xa74>
   163aa:	3408      	adds	r4, #8
   163ac:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   163ae:	981a      	ldr	r0, [sp, #104]	; 0x68
   163b0:	6062      	str	r2, [r4, #4]
   163b2:	aa3e      	add	r2, sp, #248	; 0xf8
   163b4:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   163b6:	6022      	str	r2, [r4, #0]
   163b8:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   163ba:	3301      	adds	r3, #1
   163bc:	9338      	str	r3, [sp, #224]	; 0xe0
   163be:	1812      	adds	r2, r2, r0
   163c0:	2b07      	cmp	r3, #7
   163c2:	9239      	str	r2, [sp, #228]	; 0xe4
   163c4:	f300 814f 	bgt.w	16666 <_svfprintf_r+0x4d2>
   163c8:	f104 0308 	add.w	r3, r4, #8
   163cc:	f01a 0f04 	tst.w	sl, #4
   163d0:	f000 8156 	beq.w	16680 <_svfprintf_r+0x4ec>
   163d4:	990c      	ldr	r1, [sp, #48]	; 0x30
   163d6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   163d8:	1a8e      	subs	r6, r1, r2
   163da:	2e00      	cmp	r6, #0
   163dc:	f340 8150 	ble.w	16680 <_svfprintf_r+0x4ec>
   163e0:	2e10      	cmp	r6, #16
   163e2:	f64f 1750 	movw	r7, #63824	; 0xf950
   163e6:	bfd8      	it	le
   163e8:	f2c0 0702 	movtle	r7, #2
   163ec:	f340 83de 	ble.w	16bac <_svfprintf_r+0xa18>
   163f0:	2410      	movs	r4, #16
   163f2:	f2c0 0702 	movt	r7, #2
   163f6:	f10d 08dc 	add.w	r8, sp, #220	; 0xdc
   163fa:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
   163fe:	e003      	b.n	16408 <_svfprintf_r+0x274>
   16400:	3e10      	subs	r6, #16
   16402:	2e10      	cmp	r6, #16
   16404:	f340 83d2 	ble.w	16bac <_svfprintf_r+0xa18>
   16408:	605c      	str	r4, [r3, #4]
   1640a:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   1640c:	9939      	ldr	r1, [sp, #228]	; 0xe4
   1640e:	3201      	adds	r2, #1
   16410:	601f      	str	r7, [r3, #0]
   16412:	3110      	adds	r1, #16
   16414:	2a07      	cmp	r2, #7
   16416:	9139      	str	r1, [sp, #228]	; 0xe4
   16418:	f103 0308 	add.w	r3, r3, #8
   1641c:	9238      	str	r2, [sp, #224]	; 0xe0
   1641e:	ddef      	ble.n	16400 <_svfprintf_r+0x26c>
   16420:	4650      	mov	r0, sl
   16422:	4659      	mov	r1, fp
   16424:	4642      	mov	r2, r8
   16426:	f7ff fe27 	bl	16078 <__sprint_r>
   1642a:	464b      	mov	r3, r9
   1642c:	2800      	cmp	r0, #0
   1642e:	d0e7      	beq.n	16400 <_svfprintf_r+0x26c>
   16430:	465e      	mov	r6, fp
   16432:	89b3      	ldrh	r3, [r6, #12]
   16434:	980d      	ldr	r0, [sp, #52]	; 0x34
   16436:	f013 0f40 	tst.w	r3, #64	; 0x40
   1643a:	bf18      	it	ne
   1643c:	f04f 30ff 	movne.w	r0, #4294967295
   16440:	900d      	str	r0, [sp, #52]	; 0x34
   16442:	980d      	ldr	r0, [sp, #52]	; 0x34
   16444:	b045      	add	sp, #276	; 0x114
   16446:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1644a:	f01a 0f20 	tst.w	sl, #32
   1644e:	f64f 1094 	movw	r0, #63892	; 0xf994
   16452:	f2c0 0002 	movt	r0, #2
   16456:	9214      	str	r2, [sp, #80]	; 0x50
   16458:	9017      	str	r0, [sp, #92]	; 0x5c
   1645a:	f000 82c3 	beq.w	169e4 <_svfprintf_r+0x850>
   1645e:	990a      	ldr	r1, [sp, #40]	; 0x28
   16460:	1dcb      	adds	r3, r1, #7
   16462:	f023 0307 	bic.w	r3, r3, #7
   16466:	f103 0208 	add.w	r2, r3, #8
   1646a:	920a      	str	r2, [sp, #40]	; 0x28
   1646c:	e9d3 6700 	ldrd	r6, r7, [r3]
   16470:	ea56 0107 	orrs.w	r1, r6, r7
   16474:	bf0c      	ite	eq
   16476:	2200      	moveq	r2, #0
   16478:	2201      	movne	r2, #1
   1647a:	ea1a 0f02 	tst.w	sl, r2
   1647e:	f040 84bc 	bne.w	16dfa <_svfprintf_r+0xc66>
   16482:	2302      	movs	r3, #2
   16484:	f04f 0100 	mov.w	r1, #0
   16488:	f88d 110f 	strb.w	r1, [sp, #271]	; 0x10f
   1648c:	f1b8 0f00 	cmp.w	r8, #0
   16490:	bfa8      	it	ge
   16492:	f02a 0a80 	bicge.w	sl, sl, #128	; 0x80
   16496:	f1b8 0f00 	cmp.w	r8, #0
   1649a:	bf18      	it	ne
   1649c:	f042 0201 	orrne.w	r2, r2, #1
   164a0:	2a00      	cmp	r2, #0
   164a2:	f000 8160 	beq.w	16766 <_svfprintf_r+0x5d2>
   164a6:	2b01      	cmp	r3, #1
   164a8:	f000 8434 	beq.w	16d14 <_svfprintf_r+0xb80>
   164ac:	2b02      	cmp	r3, #2
   164ae:	f000 8417 	beq.w	16ce0 <_svfprintf_r+0xb4c>
   164b2:	9916      	ldr	r1, [sp, #88]	; 0x58
   164b4:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
   164b8:	9111      	str	r1, [sp, #68]	; 0x44
   164ba:	ea4f 08d6 	mov.w	r8, r6, lsr #3
   164be:	ea4f 0cd7 	mov.w	ip, r7, lsr #3
   164c2:	ea48 7847 	orr.w	r8, r8, r7, lsl #29
   164c6:	f006 0007 	and.w	r0, r6, #7
   164ca:	4667      	mov	r7, ip
   164cc:	4646      	mov	r6, r8
   164ce:	3030      	adds	r0, #48	; 0x30
   164d0:	ea56 0207 	orrs.w	r2, r6, r7
   164d4:	f801 0d01 	strb.w	r0, [r1, #-1]!
   164d8:	d1ef      	bne.n	164ba <_svfprintf_r+0x326>
   164da:	f01a 0f01 	tst.w	sl, #1
   164de:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
   164e2:	9111      	str	r1, [sp, #68]	; 0x44
   164e4:	f040 84db 	bne.w	16e9e <_svfprintf_r+0xd0a>
   164e8:	9b16      	ldr	r3, [sp, #88]	; 0x58
   164ea:	1a5b      	subs	r3, r3, r1
   164ec:	930e      	str	r3, [sp, #56]	; 0x38
   164ee:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   164f0:	f8cd 8054 	str.w	r8, [sp, #84]	; 0x54
   164f4:	4543      	cmp	r3, r8
   164f6:	bfb8      	it	lt
   164f8:	4643      	movlt	r3, r8
   164fa:	930b      	str	r3, [sp, #44]	; 0x2c
   164fc:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
   16500:	b113      	cbz	r3, 16508 <_svfprintf_r+0x374>
   16502:	990b      	ldr	r1, [sp, #44]	; 0x2c
   16504:	3101      	adds	r1, #1
   16506:	910b      	str	r1, [sp, #44]	; 0x2c
   16508:	f01a 0202 	ands.w	r2, sl, #2
   1650c:	9213      	str	r2, [sp, #76]	; 0x4c
   1650e:	d002      	beq.n	16516 <_svfprintf_r+0x382>
   16510:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   16512:	3302      	adds	r3, #2
   16514:	930b      	str	r3, [sp, #44]	; 0x2c
   16516:	f01a 0084 	ands.w	r0, sl, #132	; 0x84
   1651a:	9012      	str	r0, [sp, #72]	; 0x48
   1651c:	d138      	bne.n	16590 <_svfprintf_r+0x3fc>
   1651e:	990c      	ldr	r1, [sp, #48]	; 0x30
   16520:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   16522:	1a8e      	subs	r6, r1, r2
   16524:	2e00      	cmp	r6, #0
   16526:	dd33      	ble.n	16590 <_svfprintf_r+0x3fc>
   16528:	2e10      	cmp	r6, #16
   1652a:	f64f 1750 	movw	r7, #63824	; 0xf950
   1652e:	bfd8      	it	le
   16530:	f2c0 0702 	movtle	r7, #2
   16534:	dd20      	ble.n	16578 <_svfprintf_r+0x3e4>
   16536:	f04f 0810 	mov.w	r8, #16
   1653a:	f2c0 0702 	movt	r7, #2
   1653e:	e002      	b.n	16546 <_svfprintf_r+0x3b2>
   16540:	3e10      	subs	r6, #16
   16542:	2e10      	cmp	r6, #16
   16544:	dd18      	ble.n	16578 <_svfprintf_r+0x3e4>
   16546:	f8c4 8004 	str.w	r8, [r4, #4]
   1654a:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   1654c:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   1654e:	3301      	adds	r3, #1
   16550:	6027      	str	r7, [r4, #0]
   16552:	3210      	adds	r2, #16
   16554:	2b07      	cmp	r3, #7
   16556:	9239      	str	r2, [sp, #228]	; 0xe4
   16558:	f104 0408 	add.w	r4, r4, #8
   1655c:	9338      	str	r3, [sp, #224]	; 0xe0
   1655e:	ddef      	ble.n	16540 <_svfprintf_r+0x3ac>
   16560:	9809      	ldr	r0, [sp, #36]	; 0x24
   16562:	4659      	mov	r1, fp
   16564:	aa37      	add	r2, sp, #220	; 0xdc
   16566:	464c      	mov	r4, r9
   16568:	f7ff fd86 	bl	16078 <__sprint_r>
   1656c:	2800      	cmp	r0, #0
   1656e:	f47f af5f 	bne.w	16430 <_svfprintf_r+0x29c>
   16572:	3e10      	subs	r6, #16
   16574:	2e10      	cmp	r6, #16
   16576:	dce6      	bgt.n	16546 <_svfprintf_r+0x3b2>
   16578:	6066      	str	r6, [r4, #4]
   1657a:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   1657c:	6027      	str	r7, [r4, #0]
   1657e:	1c5a      	adds	r2, r3, #1
   16580:	9b39      	ldr	r3, [sp, #228]	; 0xe4
   16582:	9238      	str	r2, [sp, #224]	; 0xe0
   16584:	199b      	adds	r3, r3, r6
   16586:	2a07      	cmp	r2, #7
   16588:	9339      	str	r3, [sp, #228]	; 0xe4
   1658a:	f300 83f7 	bgt.w	16d7c <_svfprintf_r+0xbe8>
   1658e:	3408      	adds	r4, #8
   16590:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
   16594:	b173      	cbz	r3, 165b4 <_svfprintf_r+0x420>
   16596:	2301      	movs	r3, #1
   16598:	6063      	str	r3, [r4, #4]
   1659a:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   1659c:	aa43      	add	r2, sp, #268	; 0x10c
   1659e:	3203      	adds	r2, #3
   165a0:	6022      	str	r2, [r4, #0]
   165a2:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   165a4:	3301      	adds	r3, #1
   165a6:	9338      	str	r3, [sp, #224]	; 0xe0
   165a8:	3201      	adds	r2, #1
   165aa:	2b07      	cmp	r3, #7
   165ac:	9239      	str	r2, [sp, #228]	; 0xe4
   165ae:	f300 8340 	bgt.w	16c32 <_svfprintf_r+0xa9e>
   165b2:	3408      	adds	r4, #8
   165b4:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   165b6:	b16b      	cbz	r3, 165d4 <_svfprintf_r+0x440>
   165b8:	2302      	movs	r3, #2
   165ba:	6063      	str	r3, [r4, #4]
   165bc:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   165be:	aa43      	add	r2, sp, #268	; 0x10c
   165c0:	6022      	str	r2, [r4, #0]
   165c2:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   165c4:	3301      	adds	r3, #1
   165c6:	9338      	str	r3, [sp, #224]	; 0xe0
   165c8:	3202      	adds	r2, #2
   165ca:	2b07      	cmp	r3, #7
   165cc:	9239      	str	r2, [sp, #228]	; 0xe4
   165ce:	f300 833a 	bgt.w	16c46 <_svfprintf_r+0xab2>
   165d2:	3408      	adds	r4, #8
   165d4:	9812      	ldr	r0, [sp, #72]	; 0x48
   165d6:	2880      	cmp	r0, #128	; 0x80
   165d8:	f000 82b2 	beq.w	16b40 <_svfprintf_r+0x9ac>
   165dc:	9815      	ldr	r0, [sp, #84]	; 0x54
   165de:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   165e0:	1ac6      	subs	r6, r0, r3
   165e2:	2e00      	cmp	r6, #0
   165e4:	dd2e      	ble.n	16644 <_svfprintf_r+0x4b0>
   165e6:	2e10      	cmp	r6, #16
   165e8:	4fa7      	ldr	r7, [pc, #668]	; (16888 <_svfprintf_r+0x6f4>)
   165ea:	bfc8      	it	gt
   165ec:	f04f 0810 	movgt.w	r8, #16
   165f0:	dc03      	bgt.n	165fa <_svfprintf_r+0x466>
   165f2:	e01b      	b.n	1662c <_svfprintf_r+0x498>
   165f4:	3e10      	subs	r6, #16
   165f6:	2e10      	cmp	r6, #16
   165f8:	dd18      	ble.n	1662c <_svfprintf_r+0x498>
   165fa:	f8c4 8004 	str.w	r8, [r4, #4]
   165fe:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   16600:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   16602:	3301      	adds	r3, #1
   16604:	6027      	str	r7, [r4, #0]
   16606:	3210      	adds	r2, #16
   16608:	2b07      	cmp	r3, #7
   1660a:	9239      	str	r2, [sp, #228]	; 0xe4
   1660c:	f104 0408 	add.w	r4, r4, #8
   16610:	9338      	str	r3, [sp, #224]	; 0xe0
   16612:	ddef      	ble.n	165f4 <_svfprintf_r+0x460>
   16614:	9809      	ldr	r0, [sp, #36]	; 0x24
   16616:	4659      	mov	r1, fp
   16618:	aa37      	add	r2, sp, #220	; 0xdc
   1661a:	464c      	mov	r4, r9
   1661c:	f7ff fd2c 	bl	16078 <__sprint_r>
   16620:	2800      	cmp	r0, #0
   16622:	f47f af05 	bne.w	16430 <_svfprintf_r+0x29c>
   16626:	3e10      	subs	r6, #16
   16628:	2e10      	cmp	r6, #16
   1662a:	dce6      	bgt.n	165fa <_svfprintf_r+0x466>
   1662c:	6066      	str	r6, [r4, #4]
   1662e:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   16630:	6027      	str	r7, [r4, #0]
   16632:	1c5a      	adds	r2, r3, #1
   16634:	9b39      	ldr	r3, [sp, #228]	; 0xe4
   16636:	9238      	str	r2, [sp, #224]	; 0xe0
   16638:	199b      	adds	r3, r3, r6
   1663a:	2a07      	cmp	r2, #7
   1663c:	9339      	str	r3, [sp, #228]	; 0xe4
   1663e:	f300 82ee 	bgt.w	16c1e <_svfprintf_r+0xa8a>
   16642:	3408      	adds	r4, #8
   16644:	f41a 7f80 	tst.w	sl, #256	; 0x100
   16648:	f040 8219 	bne.w	16a7e <_svfprintf_r+0x8ea>
   1664c:	990e      	ldr	r1, [sp, #56]	; 0x38
   1664e:	9a11      	ldr	r2, [sp, #68]	; 0x44
   16650:	6061      	str	r1, [r4, #4]
   16652:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   16654:	6022      	str	r2, [r4, #0]
   16656:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   16658:	3301      	adds	r3, #1
   1665a:	9338      	str	r3, [sp, #224]	; 0xe0
   1665c:	1852      	adds	r2, r2, r1
   1665e:	2b07      	cmp	r3, #7
   16660:	9239      	str	r2, [sp, #228]	; 0xe4
   16662:	f77f aeb1 	ble.w	163c8 <_svfprintf_r+0x234>
   16666:	9809      	ldr	r0, [sp, #36]	; 0x24
   16668:	4659      	mov	r1, fp
   1666a:	aa37      	add	r2, sp, #220	; 0xdc
   1666c:	f7ff fd04 	bl	16078 <__sprint_r>
   16670:	2800      	cmp	r0, #0
   16672:	f47f aedd 	bne.w	16430 <_svfprintf_r+0x29c>
   16676:	f01a 0f04 	tst.w	sl, #4
   1667a:	464b      	mov	r3, r9
   1667c:	f47f aeaa 	bne.w	163d4 <_svfprintf_r+0x240>
   16680:	9b39      	ldr	r3, [sp, #228]	; 0xe4
   16682:	980d      	ldr	r0, [sp, #52]	; 0x34
   16684:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   16686:	990c      	ldr	r1, [sp, #48]	; 0x30
   16688:	428a      	cmp	r2, r1
   1668a:	bfac      	ite	ge
   1668c:	1880      	addge	r0, r0, r2
   1668e:	1840      	addlt	r0, r0, r1
   16690:	900d      	str	r0, [sp, #52]	; 0x34
   16692:	2b00      	cmp	r3, #0
   16694:	f040 829e 	bne.w	16bd4 <_svfprintf_r+0xa40>
   16698:	2300      	movs	r3, #0
   1669a:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
   1669e:	9338      	str	r3, [sp, #224]	; 0xe0
   166a0:	464c      	mov	r4, r9
   166a2:	e5a1      	b.n	161e8 <_svfprintf_r+0x54>
   166a4:	9214      	str	r2, [sp, #80]	; 0x50
   166a6:	2a00      	cmp	r2, #0
   166a8:	f000 8504 	beq.w	170b4 <_svfprintf_r+0xf20>
   166ac:	2001      	movs	r0, #1
   166ae:	f88d 20b4 	strb.w	r2, [sp, #180]	; 0xb4
   166b2:	f04f 0100 	mov.w	r1, #0
   166b6:	aa2d      	add	r2, sp, #180	; 0xb4
   166b8:	900b      	str	r0, [sp, #44]	; 0x2c
   166ba:	f88d 110f 	strb.w	r1, [sp, #271]	; 0x10f
   166be:	9211      	str	r2, [sp, #68]	; 0x44
   166c0:	900e      	str	r0, [sp, #56]	; 0x38
   166c2:	2100      	movs	r1, #0
   166c4:	9115      	str	r1, [sp, #84]	; 0x54
   166c6:	e71f      	b.n	16508 <_svfprintf_r+0x374>
   166c8:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
   166cc:	2b00      	cmp	r3, #0
   166ce:	f040 840c 	bne.w	16eea <_svfprintf_r+0xd56>
   166d2:	990a      	ldr	r1, [sp, #40]	; 0x28
   166d4:	462b      	mov	r3, r5
   166d6:	f88d c10f 	strb.w	ip, [sp, #271]	; 0x10f
   166da:	782a      	ldrb	r2, [r5, #0]
   166dc:	910a      	str	r1, [sp, #40]	; 0x28
   166de:	e5c2      	b.n	16266 <_svfprintf_r+0xd2>
   166e0:	990a      	ldr	r1, [sp, #40]	; 0x28
   166e2:	f04a 0a01 	orr.w	sl, sl, #1
   166e6:	782a      	ldrb	r2, [r5, #0]
   166e8:	462b      	mov	r3, r5
   166ea:	910a      	str	r1, [sp, #40]	; 0x28
   166ec:	e5bb      	b.n	16266 <_svfprintf_r+0xd2>
   166ee:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   166f0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   166f2:	681b      	ldr	r3, [r3, #0]
   166f4:	1d11      	adds	r1, r2, #4
   166f6:	2b00      	cmp	r3, #0
   166f8:	930c      	str	r3, [sp, #48]	; 0x30
   166fa:	f2c0 85b2 	blt.w	17262 <_svfprintf_r+0x10ce>
   166fe:	782a      	ldrb	r2, [r5, #0]
   16700:	462b      	mov	r3, r5
   16702:	910a      	str	r1, [sp, #40]	; 0x28
   16704:	e5af      	b.n	16266 <_svfprintf_r+0xd2>
   16706:	990a      	ldr	r1, [sp, #40]	; 0x28
   16708:	462b      	mov	r3, r5
   1670a:	f88d 010f 	strb.w	r0, [sp, #271]	; 0x10f
   1670e:	782a      	ldrb	r2, [r5, #0]
   16710:	910a      	str	r1, [sp, #40]	; 0x28
   16712:	e5a8      	b.n	16266 <_svfprintf_r+0xd2>
   16714:	f04a 0a10 	orr.w	sl, sl, #16
   16718:	9214      	str	r2, [sp, #80]	; 0x50
   1671a:	f01a 0f20 	tst.w	sl, #32
   1671e:	f000 8187 	beq.w	16a30 <_svfprintf_r+0x89c>
   16722:	980a      	ldr	r0, [sp, #40]	; 0x28
   16724:	1dc3      	adds	r3, r0, #7
   16726:	f023 0307 	bic.w	r3, r3, #7
   1672a:	f103 0108 	add.w	r1, r3, #8
   1672e:	910a      	str	r1, [sp, #40]	; 0x28
   16730:	e9d3 6700 	ldrd	r6, r7, [r3]
   16734:	2e00      	cmp	r6, #0
   16736:	f177 0000 	sbcs.w	r0, r7, #0
   1673a:	f2c0 8376 	blt.w	16e2a <_svfprintf_r+0xc96>
   1673e:	ea56 0107 	orrs.w	r1, r6, r7
   16742:	f04f 0301 	mov.w	r3, #1
   16746:	bf0c      	ite	eq
   16748:	2200      	moveq	r2, #0
   1674a:	2201      	movne	r2, #1
   1674c:	f1b8 0f00 	cmp.w	r8, #0
   16750:	bfa8      	it	ge
   16752:	f02a 0a80 	bicge.w	sl, sl, #128	; 0x80
   16756:	f1b8 0f00 	cmp.w	r8, #0
   1675a:	bf18      	it	ne
   1675c:	f042 0201 	orrne.w	r2, r2, #1
   16760:	2a00      	cmp	r2, #0
   16762:	f47f aea0 	bne.w	164a6 <_svfprintf_r+0x312>
   16766:	2b00      	cmp	r3, #0
   16768:	f040 81e5 	bne.w	16b36 <_svfprintf_r+0x9a2>
   1676c:	f01a 0f01 	tst.w	sl, #1
   16770:	f000 81e1 	beq.w	16b36 <_svfprintf_r+0x9a2>
   16774:	2330      	movs	r3, #48	; 0x30
   16776:	f88d 30db 	strb.w	r3, [sp, #219]	; 0xdb
   1677a:	ab2d      	add	r3, sp, #180	; 0xb4
   1677c:	2001      	movs	r0, #1
   1677e:	3327      	adds	r3, #39	; 0x27
   16780:	900e      	str	r0, [sp, #56]	; 0x38
   16782:	9311      	str	r3, [sp, #68]	; 0x44
   16784:	e6b3      	b.n	164ee <_svfprintf_r+0x35a>
   16786:	f01a 0f08 	tst.w	sl, #8
   1678a:	9214      	str	r2, [sp, #80]	; 0x50
   1678c:	f000 83bf 	beq.w	16f0e <_svfprintf_r+0xd7a>
   16790:	980a      	ldr	r0, [sp, #40]	; 0x28
   16792:	1dc3      	adds	r3, r0, #7
   16794:	f023 0307 	bic.w	r3, r3, #7
   16798:	f103 0108 	add.w	r1, r3, #8
   1679c:	910a      	str	r1, [sp, #40]	; 0x28
   1679e:	685e      	ldr	r6, [r3, #4]
   167a0:	681f      	ldr	r7, [r3, #0]
   167a2:	9619      	str	r6, [sp, #100]	; 0x64
   167a4:	9710      	str	r7, [sp, #64]	; 0x40
   167a6:	4638      	mov	r0, r7
   167a8:	4631      	mov	r1, r6
   167aa:	f003 fdfb 	bl	1a3a4 <__isinfd>
   167ae:	4603      	mov	r3, r0
   167b0:	2800      	cmp	r0, #0
   167b2:	f000 8493 	beq.w	170dc <_svfprintf_r+0xf48>
   167b6:	4638      	mov	r0, r7
   167b8:	2200      	movs	r2, #0
   167ba:	2300      	movs	r3, #0
   167bc:	4631      	mov	r1, r6
   167be:	f004 f965 	bl	1aa8c <__aeabi_dcmplt>
   167c2:	2800      	cmp	r0, #0
   167c4:	f040 8415 	bne.w	16ff2 <_svfprintf_r+0xe5e>
   167c8:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
   167cc:	2003      	movs	r0, #3
   167ce:	f64f 1288 	movw	r2, #63880	; 0xf988
   167d2:	f64f 1184 	movw	r1, #63876	; 0xf984
   167d6:	900b      	str	r0, [sp, #44]	; 0x2c
   167d8:	9814      	ldr	r0, [sp, #80]	; 0x50
   167da:	f2c0 0102 	movt	r1, #2
   167de:	f2c0 0202 	movt	r2, #2
   167e2:	f02a 0a80 	bic.w	sl, sl, #128	; 0x80
   167e6:	2847      	cmp	r0, #71	; 0x47
   167e8:	bfd8      	it	le
   167ea:	460a      	movle	r2, r1
   167ec:	2103      	movs	r1, #3
   167ee:	9211      	str	r2, [sp, #68]	; 0x44
   167f0:	2200      	movs	r2, #0
   167f2:	910e      	str	r1, [sp, #56]	; 0x38
   167f4:	9215      	str	r2, [sp, #84]	; 0x54
   167f6:	e683      	b.n	16500 <_svfprintf_r+0x36c>
   167f8:	990a      	ldr	r1, [sp, #40]	; 0x28
   167fa:	f04a 0a08 	orr.w	sl, sl, #8
   167fe:	782a      	ldrb	r2, [r5, #0]
   16800:	462b      	mov	r3, r5
   16802:	910a      	str	r1, [sp, #40]	; 0x28
   16804:	e52f      	b.n	16266 <_svfprintf_r+0xd2>
   16806:	990a      	ldr	r1, [sp, #40]	; 0x28
   16808:	782a      	ldrb	r2, [r5, #0]
   1680a:	f04a 0a04 	orr.w	sl, sl, #4
   1680e:	462b      	mov	r3, r5
   16810:	910a      	str	r1, [sp, #40]	; 0x28
   16812:	e528      	b.n	16266 <_svfprintf_r+0xd2>
   16814:	462b      	mov	r3, r5
   16816:	f813 2b01 	ldrb.w	r2, [r3], #1
   1681a:	2a2a      	cmp	r2, #42	; 0x2a
   1681c:	f000 86cf 	beq.w	175be <_svfprintf_r+0x142a>
   16820:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
   16824:	2909      	cmp	r1, #9
   16826:	bf88      	it	hi
   16828:	f04f 0800 	movhi.w	r8, #0
   1682c:	d810      	bhi.n	16850 <_svfprintf_r+0x6bc>
   1682e:	3502      	adds	r5, #2
   16830:	f04f 0800 	mov.w	r8, #0
   16834:	f815 2c01 	ldrb.w	r2, [r5, #-1]
   16838:	eb08 0888 	add.w	r8, r8, r8, lsl #2
   1683c:	462b      	mov	r3, r5
   1683e:	3501      	adds	r5, #1
   16840:	eb01 0848 	add.w	r8, r1, r8, lsl #1
   16844:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
   16848:	2909      	cmp	r1, #9
   1684a:	d9f3      	bls.n	16834 <_svfprintf_r+0x6a0>
   1684c:	ea48 78e8 	orr.w	r8, r8, r8, asr #31
   16850:	461d      	mov	r5, r3
   16852:	e509      	b.n	16268 <_svfprintf_r+0xd4>
   16854:	990a      	ldr	r1, [sp, #40]	; 0x28
   16856:	f04a 0a80 	orr.w	sl, sl, #128	; 0x80
   1685a:	782a      	ldrb	r2, [r5, #0]
   1685c:	462b      	mov	r3, r5
   1685e:	910a      	str	r1, [sp, #40]	; 0x28
   16860:	e501      	b.n	16266 <_svfprintf_r+0xd2>
   16862:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
   16866:	2600      	movs	r6, #0
   16868:	462b      	mov	r3, r5
   1686a:	eb06 0686 	add.w	r6, r6, r6, lsl #2
   1686e:	f813 2b01 	ldrb.w	r2, [r3], #1
   16872:	eb01 0646 	add.w	r6, r1, r6, lsl #1
   16876:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
   1687a:	461d      	mov	r5, r3
   1687c:	2909      	cmp	r1, #9
   1687e:	d9f3      	bls.n	16868 <_svfprintf_r+0x6d4>
   16880:	960c      	str	r6, [sp, #48]	; 0x30
   16882:	461d      	mov	r5, r3
   16884:	e4f0      	b.n	16268 <_svfprintf_r+0xd4>
   16886:	bf00      	nop
   16888:	0002f960 	.word	0x0002f960
   1688c:	f04a 0a40 	orr.w	sl, sl, #64	; 0x40
   16890:	990a      	ldr	r1, [sp, #40]	; 0x28
   16892:	e734      	b.n	166fe <_svfprintf_r+0x56a>
   16894:	782a      	ldrb	r2, [r5, #0]
   16896:	2a6c      	cmp	r2, #108	; 0x6c
   16898:	f000 8418 	beq.w	170cc <_svfprintf_r+0xf38>
   1689c:	990a      	ldr	r1, [sp, #40]	; 0x28
   1689e:	f04a 0a10 	orr.w	sl, sl, #16
   168a2:	462b      	mov	r3, r5
   168a4:	910a      	str	r1, [sp, #40]	; 0x28
   168a6:	e4de      	b.n	16266 <_svfprintf_r+0xd2>
   168a8:	f01a 0f20 	tst.w	sl, #32
   168ac:	f000 8323 	beq.w	16ef6 <_svfprintf_r+0xd62>
   168b0:	990a      	ldr	r1, [sp, #40]	; 0x28
   168b2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   168b4:	680b      	ldr	r3, [r1, #0]
   168b6:	4610      	mov	r0, r2
   168b8:	ea4f 71e0 	mov.w	r1, r0, asr #31
   168bc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   168be:	e9c3 0100 	strd	r0, r1, [r3]
   168c2:	f102 0a04 	add.w	sl, r2, #4
   168c6:	e48f      	b.n	161e8 <_svfprintf_r+0x54>
   168c8:	f01a 0320 	ands.w	r3, sl, #32
   168cc:	9214      	str	r2, [sp, #80]	; 0x50
   168ce:	f000 80c7 	beq.w	16a60 <_svfprintf_r+0x8cc>
   168d2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   168d4:	1dda      	adds	r2, r3, #7
   168d6:	2300      	movs	r3, #0
   168d8:	f022 0207 	bic.w	r2, r2, #7
   168dc:	f102 0008 	add.w	r0, r2, #8
   168e0:	900a      	str	r0, [sp, #40]	; 0x28
   168e2:	e9d2 6700 	ldrd	r6, r7, [r2]
   168e6:	ea56 0107 	orrs.w	r1, r6, r7
   168ea:	bf0c      	ite	eq
   168ec:	2200      	moveq	r2, #0
   168ee:	2201      	movne	r2, #1
   168f0:	e5c8      	b.n	16484 <_svfprintf_r+0x2f0>
   168f2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   168f4:	f64f 1094 	movw	r0, #63892	; 0xf994
   168f8:	990a      	ldr	r1, [sp, #40]	; 0x28
   168fa:	2378      	movs	r3, #120	; 0x78
   168fc:	f2c0 0002 	movt	r0, #2
   16900:	9314      	str	r3, [sp, #80]	; 0x50
   16902:	6816      	ldr	r6, [r2, #0]
   16904:	3104      	adds	r1, #4
   16906:	f88d 310d 	strb.w	r3, [sp, #269]	; 0x10d
   1690a:	f04a 0a02 	orr.w	sl, sl, #2
   1690e:	2330      	movs	r3, #48	; 0x30
   16910:	1e32      	subs	r2, r6, #0
   16912:	bf18      	it	ne
   16914:	2201      	movne	r2, #1
   16916:	f88d 310c 	strb.w	r3, [sp, #268]	; 0x10c
   1691a:	4636      	mov	r6, r6
   1691c:	f04f 0700 	mov.w	r7, #0
   16920:	9017      	str	r0, [sp, #92]	; 0x5c
   16922:	2302      	movs	r3, #2
   16924:	910a      	str	r1, [sp, #40]	; 0x28
   16926:	e5ad      	b.n	16484 <_svfprintf_r+0x2f0>
   16928:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1692a:	9214      	str	r2, [sp, #80]	; 0x50
   1692c:	f04f 0200 	mov.w	r2, #0
   16930:	1d18      	adds	r0, r3, #4
   16932:	f88d 210f 	strb.w	r2, [sp, #271]	; 0x10f
   16936:	681b      	ldr	r3, [r3, #0]
   16938:	900a      	str	r0, [sp, #40]	; 0x28
   1693a:	9311      	str	r3, [sp, #68]	; 0x44
   1693c:	2b00      	cmp	r3, #0
   1693e:	f000 854d 	beq.w	173dc <_svfprintf_r+0x1248>
   16942:	f1b8 0f00 	cmp.w	r8, #0
   16946:	9811      	ldr	r0, [sp, #68]	; 0x44
   16948:	f2c0 852a 	blt.w	173a0 <_svfprintf_r+0x120c>
   1694c:	2100      	movs	r1, #0
   1694e:	4642      	mov	r2, r8
   16950:	f002 fdd6 	bl	19500 <memchr>
   16954:	4603      	mov	r3, r0
   16956:	2800      	cmp	r0, #0
   16958:	f000 856e 	beq.w	17438 <_svfprintf_r+0x12a4>
   1695c:	9811      	ldr	r0, [sp, #68]	; 0x44
   1695e:	1a1b      	subs	r3, r3, r0
   16960:	930e      	str	r3, [sp, #56]	; 0x38
   16962:	4543      	cmp	r3, r8
   16964:	f340 8482 	ble.w	1726c <_svfprintf_r+0x10d8>
   16968:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
   1696c:	2100      	movs	r1, #0
   1696e:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
   16972:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
   16976:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
   1697a:	9115      	str	r1, [sp, #84]	; 0x54
   1697c:	e5c0      	b.n	16500 <_svfprintf_r+0x36c>
   1697e:	f01a 0f20 	tst.w	sl, #32
   16982:	9214      	str	r2, [sp, #80]	; 0x50
   16984:	d010      	beq.n	169a8 <_svfprintf_r+0x814>
   16986:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16988:	1dda      	adds	r2, r3, #7
   1698a:	2301      	movs	r3, #1
   1698c:	e7a4      	b.n	168d8 <_svfprintf_r+0x744>
   1698e:	990a      	ldr	r1, [sp, #40]	; 0x28
   16990:	f04a 0a20 	orr.w	sl, sl, #32
   16994:	782a      	ldrb	r2, [r5, #0]
   16996:	462b      	mov	r3, r5
   16998:	910a      	str	r1, [sp, #40]	; 0x28
   1699a:	e464      	b.n	16266 <_svfprintf_r+0xd2>
   1699c:	f04a 0a10 	orr.w	sl, sl, #16
   169a0:	9214      	str	r2, [sp, #80]	; 0x50
   169a2:	f01a 0f20 	tst.w	sl, #32
   169a6:	d1ee      	bne.n	16986 <_svfprintf_r+0x7f2>
   169a8:	f01a 0f10 	tst.w	sl, #16
   169ac:	f040 8254 	bne.w	16e58 <_svfprintf_r+0xcc4>
   169b0:	f01a 0f40 	tst.w	sl, #64	; 0x40
   169b4:	f000 8250 	beq.w	16e58 <_svfprintf_r+0xcc4>
   169b8:	980a      	ldr	r0, [sp, #40]	; 0x28
   169ba:	2301      	movs	r3, #1
   169bc:	1d01      	adds	r1, r0, #4
   169be:	910a      	str	r1, [sp, #40]	; 0x28
   169c0:	8806      	ldrh	r6, [r0, #0]
   169c2:	1e32      	subs	r2, r6, #0
   169c4:	bf18      	it	ne
   169c6:	2201      	movne	r2, #1
   169c8:	4636      	mov	r6, r6
   169ca:	f04f 0700 	mov.w	r7, #0
   169ce:	e559      	b.n	16484 <_svfprintf_r+0x2f0>
   169d0:	f01a 0f20 	tst.w	sl, #32
   169d4:	9214      	str	r2, [sp, #80]	; 0x50
   169d6:	f64f 1270 	movw	r2, #63856	; 0xf970
   169da:	f2c0 0202 	movt	r2, #2
   169de:	9217      	str	r2, [sp, #92]	; 0x5c
   169e0:	f47f ad3d 	bne.w	1645e <_svfprintf_r+0x2ca>
   169e4:	f01a 0f10 	tst.w	sl, #16
   169e8:	f040 822d 	bne.w	16e46 <_svfprintf_r+0xcb2>
   169ec:	f01a 0f40 	tst.w	sl, #64	; 0x40
   169f0:	f000 8229 	beq.w	16e46 <_svfprintf_r+0xcb2>
   169f4:	990a      	ldr	r1, [sp, #40]	; 0x28
   169f6:	1d0a      	adds	r2, r1, #4
   169f8:	920a      	str	r2, [sp, #40]	; 0x28
   169fa:	880e      	ldrh	r6, [r1, #0]
   169fc:	4636      	mov	r6, r6
   169fe:	f04f 0700 	mov.w	r7, #0
   16a02:	e535      	b.n	16470 <_svfprintf_r+0x2dc>
   16a04:	9214      	str	r2, [sp, #80]	; 0x50
   16a06:	2001      	movs	r0, #1
   16a08:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   16a0a:	f04f 0100 	mov.w	r1, #0
   16a0e:	900b      	str	r0, [sp, #44]	; 0x2c
   16a10:	900e      	str	r0, [sp, #56]	; 0x38
   16a12:	6813      	ldr	r3, [r2, #0]
   16a14:	3204      	adds	r2, #4
   16a16:	f88d 110f 	strb.w	r1, [sp, #271]	; 0x10f
   16a1a:	920a      	str	r2, [sp, #40]	; 0x28
   16a1c:	aa2d      	add	r2, sp, #180	; 0xb4
   16a1e:	f88d 30b4 	strb.w	r3, [sp, #180]	; 0xb4
   16a22:	9211      	str	r2, [sp, #68]	; 0x44
   16a24:	e64d      	b.n	166c2 <_svfprintf_r+0x52e>
   16a26:	f01a 0f20 	tst.w	sl, #32
   16a2a:	9214      	str	r2, [sp, #80]	; 0x50
   16a2c:	f47f ae79 	bne.w	16722 <_svfprintf_r+0x58e>
   16a30:	f01a 0f10 	tst.w	sl, #16
   16a34:	f040 81ed 	bne.w	16e12 <_svfprintf_r+0xc7e>
   16a38:	f01a 0f40 	tst.w	sl, #64	; 0x40
   16a3c:	f000 81e9 	beq.w	16e12 <_svfprintf_r+0xc7e>
   16a40:	980a      	ldr	r0, [sp, #40]	; 0x28
   16a42:	1d01      	adds	r1, r0, #4
   16a44:	910a      	str	r1, [sp, #40]	; 0x28
   16a46:	f9b0 6000 	ldrsh.w	r6, [r0]
   16a4a:	4636      	mov	r6, r6
   16a4c:	ea4f 77e6 	mov.w	r7, r6, asr #31
   16a50:	e670      	b.n	16734 <_svfprintf_r+0x5a0>
   16a52:	f04a 0a10 	orr.w	sl, sl, #16
   16a56:	9214      	str	r2, [sp, #80]	; 0x50
   16a58:	f01a 0320 	ands.w	r3, sl, #32
   16a5c:	f47f af39 	bne.w	168d2 <_svfprintf_r+0x73e>
   16a60:	f01a 0210 	ands.w	r2, sl, #16
   16a64:	f000 825f 	beq.w	16f26 <_svfprintf_r+0xd92>
   16a68:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   16a6a:	1d10      	adds	r0, r2, #4
   16a6c:	900a      	str	r0, [sp, #40]	; 0x28
   16a6e:	6816      	ldr	r6, [r2, #0]
   16a70:	1e32      	subs	r2, r6, #0
   16a72:	bf18      	it	ne
   16a74:	2201      	movne	r2, #1
   16a76:	4636      	mov	r6, r6
   16a78:	f04f 0700 	mov.w	r7, #0
   16a7c:	e502      	b.n	16484 <_svfprintf_r+0x2f0>
   16a7e:	9b14      	ldr	r3, [sp, #80]	; 0x50
   16a80:	2b65      	cmp	r3, #101	; 0x65
   16a82:	f77f ac5a 	ble.w	1633a <_svfprintf_r+0x1a6>
   16a86:	9810      	ldr	r0, [sp, #64]	; 0x40
   16a88:	2200      	movs	r2, #0
   16a8a:	2300      	movs	r3, #0
   16a8c:	9919      	ldr	r1, [sp, #100]	; 0x64
   16a8e:	f003 fff3 	bl	1aa78 <__aeabi_dcmpeq>
   16a92:	2800      	cmp	r0, #0
   16a94:	f000 80e1 	beq.w	16c5a <_svfprintf_r+0xac6>
   16a98:	2301      	movs	r3, #1
   16a9a:	6063      	str	r3, [r4, #4]
   16a9c:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   16a9e:	f64f 13b0 	movw	r3, #63920	; 0xf9b0
   16aa2:	f2c0 0302 	movt	r3, #2
   16aa6:	6023      	str	r3, [r4, #0]
   16aa8:	9b39      	ldr	r3, [sp, #228]	; 0xe4
   16aaa:	3201      	adds	r2, #1
   16aac:	9238      	str	r2, [sp, #224]	; 0xe0
   16aae:	3301      	adds	r3, #1
   16ab0:	2a07      	cmp	r2, #7
   16ab2:	9339      	str	r3, [sp, #228]	; 0xe4
   16ab4:	bfd8      	it	le
   16ab6:	f104 0308 	addle.w	r3, r4, #8
   16aba:	f300 829f 	bgt.w	16ffc <_svfprintf_r+0xe68>
   16abe:	9a42      	ldr	r2, [sp, #264]	; 0x108
   16ac0:	9818      	ldr	r0, [sp, #96]	; 0x60
   16ac2:	4282      	cmp	r2, r0
   16ac4:	db03      	blt.n	16ace <_svfprintf_r+0x93a>
   16ac6:	f01a 0f01 	tst.w	sl, #1
   16aca:	f43f ac7f 	beq.w	163cc <_svfprintf_r+0x238>
   16ace:	991b      	ldr	r1, [sp, #108]	; 0x6c
   16ad0:	2201      	movs	r2, #1
   16ad2:	605a      	str	r2, [r3, #4]
   16ad4:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   16ad6:	6019      	str	r1, [r3, #0]
   16ad8:	9939      	ldr	r1, [sp, #228]	; 0xe4
   16ada:	3201      	adds	r2, #1
   16adc:	9238      	str	r2, [sp, #224]	; 0xe0
   16ade:	3101      	adds	r1, #1
   16ae0:	2a07      	cmp	r2, #7
   16ae2:	9139      	str	r1, [sp, #228]	; 0xe4
   16ae4:	f300 83eb 	bgt.w	172be <_svfprintf_r+0x112a>
   16ae8:	3308      	adds	r3, #8
   16aea:	9a18      	ldr	r2, [sp, #96]	; 0x60
   16aec:	1e56      	subs	r6, r2, #1
   16aee:	2e00      	cmp	r6, #0
   16af0:	f77f ac6c 	ble.w	163cc <_svfprintf_r+0x238>
   16af4:	2e10      	cmp	r6, #16
   16af6:	4fa0      	ldr	r7, [pc, #640]	; (16d78 <_svfprintf_r+0xbe4>)
   16af8:	f340 81e9 	ble.w	16ece <_svfprintf_r+0xd3a>
   16afc:	2410      	movs	r4, #16
   16afe:	f10d 08dc 	add.w	r8, sp, #220	; 0xdc
   16b02:	e003      	b.n	16b0c <_svfprintf_r+0x978>
   16b04:	3e10      	subs	r6, #16
   16b06:	2e10      	cmp	r6, #16
   16b08:	f340 81e1 	ble.w	16ece <_svfprintf_r+0xd3a>
   16b0c:	605c      	str	r4, [r3, #4]
   16b0e:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   16b10:	9939      	ldr	r1, [sp, #228]	; 0xe4
   16b12:	3201      	adds	r2, #1
   16b14:	601f      	str	r7, [r3, #0]
   16b16:	3110      	adds	r1, #16
   16b18:	2a07      	cmp	r2, #7
   16b1a:	9139      	str	r1, [sp, #228]	; 0xe4
   16b1c:	f103 0308 	add.w	r3, r3, #8
   16b20:	9238      	str	r2, [sp, #224]	; 0xe0
   16b22:	ddef      	ble.n	16b04 <_svfprintf_r+0x970>
   16b24:	9809      	ldr	r0, [sp, #36]	; 0x24
   16b26:	4659      	mov	r1, fp
   16b28:	4642      	mov	r2, r8
   16b2a:	f7ff faa5 	bl	16078 <__sprint_r>
   16b2e:	464b      	mov	r3, r9
   16b30:	2800      	cmp	r0, #0
   16b32:	d0e7      	beq.n	16b04 <_svfprintf_r+0x970>
   16b34:	e47c      	b.n	16430 <_svfprintf_r+0x29c>
   16b36:	9916      	ldr	r1, [sp, #88]	; 0x58
   16b38:	2200      	movs	r2, #0
   16b3a:	920e      	str	r2, [sp, #56]	; 0x38
   16b3c:	9111      	str	r1, [sp, #68]	; 0x44
   16b3e:	e4d6      	b.n	164ee <_svfprintf_r+0x35a>
   16b40:	990c      	ldr	r1, [sp, #48]	; 0x30
   16b42:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   16b44:	1a8e      	subs	r6, r1, r2
   16b46:	2e00      	cmp	r6, #0
   16b48:	f77f ad48 	ble.w	165dc <_svfprintf_r+0x448>
   16b4c:	2e10      	cmp	r6, #16
   16b4e:	4f8a      	ldr	r7, [pc, #552]	; (16d78 <_svfprintf_r+0xbe4>)
   16b50:	bfc8      	it	gt
   16b52:	f04f 0810 	movgt.w	r8, #16
   16b56:	dc03      	bgt.n	16b60 <_svfprintf_r+0x9cc>
   16b58:	e01b      	b.n	16b92 <_svfprintf_r+0x9fe>
   16b5a:	3e10      	subs	r6, #16
   16b5c:	2e10      	cmp	r6, #16
   16b5e:	dd18      	ble.n	16b92 <_svfprintf_r+0x9fe>
   16b60:	f8c4 8004 	str.w	r8, [r4, #4]
   16b64:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   16b66:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   16b68:	3301      	adds	r3, #1
   16b6a:	6027      	str	r7, [r4, #0]
   16b6c:	3210      	adds	r2, #16
   16b6e:	2b07      	cmp	r3, #7
   16b70:	9239      	str	r2, [sp, #228]	; 0xe4
   16b72:	f104 0408 	add.w	r4, r4, #8
   16b76:	9338      	str	r3, [sp, #224]	; 0xe0
   16b78:	ddef      	ble.n	16b5a <_svfprintf_r+0x9c6>
   16b7a:	9809      	ldr	r0, [sp, #36]	; 0x24
   16b7c:	4659      	mov	r1, fp
   16b7e:	aa37      	add	r2, sp, #220	; 0xdc
   16b80:	464c      	mov	r4, r9
   16b82:	f7ff fa79 	bl	16078 <__sprint_r>
   16b86:	2800      	cmp	r0, #0
   16b88:	f47f ac52 	bne.w	16430 <_svfprintf_r+0x29c>
   16b8c:	3e10      	subs	r6, #16
   16b8e:	2e10      	cmp	r6, #16
   16b90:	dce6      	bgt.n	16b60 <_svfprintf_r+0x9cc>
   16b92:	6066      	str	r6, [r4, #4]
   16b94:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   16b96:	6027      	str	r7, [r4, #0]
   16b98:	1c5a      	adds	r2, r3, #1
   16b9a:	9b39      	ldr	r3, [sp, #228]	; 0xe4
   16b9c:	9238      	str	r2, [sp, #224]	; 0xe0
   16b9e:	199b      	adds	r3, r3, r6
   16ba0:	2a07      	cmp	r2, #7
   16ba2:	9339      	str	r3, [sp, #228]	; 0xe4
   16ba4:	f300 8188 	bgt.w	16eb8 <_svfprintf_r+0xd24>
   16ba8:	3408      	adds	r4, #8
   16baa:	e517      	b.n	165dc <_svfprintf_r+0x448>
   16bac:	605e      	str	r6, [r3, #4]
   16bae:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   16bb0:	601f      	str	r7, [r3, #0]
   16bb2:	9b39      	ldr	r3, [sp, #228]	; 0xe4
   16bb4:	3201      	adds	r2, #1
   16bb6:	9238      	str	r2, [sp, #224]	; 0xe0
   16bb8:	18f3      	adds	r3, r6, r3
   16bba:	2a07      	cmp	r2, #7
   16bbc:	9339      	str	r3, [sp, #228]	; 0xe4
   16bbe:	f77f ad60 	ble.w	16682 <_svfprintf_r+0x4ee>
   16bc2:	9809      	ldr	r0, [sp, #36]	; 0x24
   16bc4:	4659      	mov	r1, fp
   16bc6:	aa37      	add	r2, sp, #220	; 0xdc
   16bc8:	f7ff fa56 	bl	16078 <__sprint_r>
   16bcc:	2800      	cmp	r0, #0
   16bce:	f43f ad57 	beq.w	16680 <_svfprintf_r+0x4ec>
   16bd2:	e42d      	b.n	16430 <_svfprintf_r+0x29c>
   16bd4:	9809      	ldr	r0, [sp, #36]	; 0x24
   16bd6:	4659      	mov	r1, fp
   16bd8:	aa37      	add	r2, sp, #220	; 0xdc
   16bda:	f7ff fa4d 	bl	16078 <__sprint_r>
   16bde:	2800      	cmp	r0, #0
   16be0:	f43f ad5a 	beq.w	16698 <_svfprintf_r+0x504>
   16be4:	e424      	b.n	16430 <_svfprintf_r+0x29c>
   16be6:	f01a 0f01 	tst.w	sl, #1
   16bea:	f47f abaa 	bne.w	16342 <_svfprintf_r+0x1ae>
   16bee:	2301      	movs	r3, #1
   16bf0:	6063      	str	r3, [r4, #4]
   16bf2:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   16bf4:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   16bf6:	3301      	adds	r3, #1
   16bf8:	9911      	ldr	r1, [sp, #68]	; 0x44
   16bfa:	3201      	adds	r2, #1
   16bfc:	2b07      	cmp	r3, #7
   16bfe:	9239      	str	r2, [sp, #228]	; 0xe4
   16c00:	6021      	str	r1, [r4, #0]
   16c02:	9338      	str	r3, [sp, #224]	; 0xe0
   16c04:	f77f abd1 	ble.w	163aa <_svfprintf_r+0x216>
   16c08:	9809      	ldr	r0, [sp, #36]	; 0x24
   16c0a:	4659      	mov	r1, fp
   16c0c:	aa37      	add	r2, sp, #220	; 0xdc
   16c0e:	f7ff fa33 	bl	16078 <__sprint_r>
   16c12:	2800      	cmp	r0, #0
   16c14:	f47f ac0c 	bne.w	16430 <_svfprintf_r+0x29c>
   16c18:	464c      	mov	r4, r9
   16c1a:	f7ff bbc7 	b.w	163ac <_svfprintf_r+0x218>
   16c1e:	9809      	ldr	r0, [sp, #36]	; 0x24
   16c20:	4659      	mov	r1, fp
   16c22:	aa37      	add	r2, sp, #220	; 0xdc
   16c24:	f7ff fa28 	bl	16078 <__sprint_r>
   16c28:	2800      	cmp	r0, #0
   16c2a:	f47f ac01 	bne.w	16430 <_svfprintf_r+0x29c>
   16c2e:	464c      	mov	r4, r9
   16c30:	e508      	b.n	16644 <_svfprintf_r+0x4b0>
   16c32:	9809      	ldr	r0, [sp, #36]	; 0x24
   16c34:	4659      	mov	r1, fp
   16c36:	aa37      	add	r2, sp, #220	; 0xdc
   16c38:	f7ff fa1e 	bl	16078 <__sprint_r>
   16c3c:	2800      	cmp	r0, #0
   16c3e:	f47f abf7 	bne.w	16430 <_svfprintf_r+0x29c>
   16c42:	464c      	mov	r4, r9
   16c44:	e4b6      	b.n	165b4 <_svfprintf_r+0x420>
   16c46:	9809      	ldr	r0, [sp, #36]	; 0x24
   16c48:	4659      	mov	r1, fp
   16c4a:	aa37      	add	r2, sp, #220	; 0xdc
   16c4c:	f7ff fa14 	bl	16078 <__sprint_r>
   16c50:	2800      	cmp	r0, #0
   16c52:	f47f abed 	bne.w	16430 <_svfprintf_r+0x29c>
   16c56:	464c      	mov	r4, r9
   16c58:	e4bc      	b.n	165d4 <_svfprintf_r+0x440>
   16c5a:	9b42      	ldr	r3, [sp, #264]	; 0x108
   16c5c:	2b00      	cmp	r3, #0
   16c5e:	f340 81d9 	ble.w	17014 <_svfprintf_r+0xe80>
   16c62:	9918      	ldr	r1, [sp, #96]	; 0x60
   16c64:	428b      	cmp	r3, r1
   16c66:	f2c0 816f 	blt.w	16f48 <_svfprintf_r+0xdb4>
   16c6a:	9a11      	ldr	r2, [sp, #68]	; 0x44
   16c6c:	6061      	str	r1, [r4, #4]
   16c6e:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   16c70:	6022      	str	r2, [r4, #0]
   16c72:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   16c74:	3301      	adds	r3, #1
   16c76:	9338      	str	r3, [sp, #224]	; 0xe0
   16c78:	1852      	adds	r2, r2, r1
   16c7a:	2b07      	cmp	r3, #7
   16c7c:	9239      	str	r2, [sp, #228]	; 0xe4
   16c7e:	bfd8      	it	le
   16c80:	f104 0308 	addle.w	r3, r4, #8
   16c84:	f300 83ba 	bgt.w	173fc <_svfprintf_r+0x1268>
   16c88:	9c42      	ldr	r4, [sp, #264]	; 0x108
   16c8a:	9818      	ldr	r0, [sp, #96]	; 0x60
   16c8c:	1a24      	subs	r4, r4, r0
   16c8e:	2c00      	cmp	r4, #0
   16c90:	f340 819b 	ble.w	16fca <_svfprintf_r+0xe36>
   16c94:	2c10      	cmp	r4, #16
   16c96:	4f38      	ldr	r7, [pc, #224]	; (16d78 <_svfprintf_r+0xbe4>)
   16c98:	f340 818b 	ble.w	16fb2 <_svfprintf_r+0xe1e>
   16c9c:	f8cd a038 	str.w	sl, [sp, #56]	; 0x38
   16ca0:	2610      	movs	r6, #16
   16ca2:	46aa      	mov	sl, r5
   16ca4:	f10d 08dc 	add.w	r8, sp, #220	; 0xdc
   16ca8:	9d09      	ldr	r5, [sp, #36]	; 0x24
   16caa:	e003      	b.n	16cb4 <_svfprintf_r+0xb20>
   16cac:	3c10      	subs	r4, #16
   16cae:	2c10      	cmp	r4, #16
   16cb0:	f340 817c 	ble.w	16fac <_svfprintf_r+0xe18>
   16cb4:	605e      	str	r6, [r3, #4]
   16cb6:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   16cb8:	9939      	ldr	r1, [sp, #228]	; 0xe4
   16cba:	3201      	adds	r2, #1
   16cbc:	601f      	str	r7, [r3, #0]
   16cbe:	3110      	adds	r1, #16
   16cc0:	2a07      	cmp	r2, #7
   16cc2:	9139      	str	r1, [sp, #228]	; 0xe4
   16cc4:	f103 0308 	add.w	r3, r3, #8
   16cc8:	9238      	str	r2, [sp, #224]	; 0xe0
   16cca:	ddef      	ble.n	16cac <_svfprintf_r+0xb18>
   16ccc:	4628      	mov	r0, r5
   16cce:	4659      	mov	r1, fp
   16cd0:	4642      	mov	r2, r8
   16cd2:	f7ff f9d1 	bl	16078 <__sprint_r>
   16cd6:	464b      	mov	r3, r9
   16cd8:	2800      	cmp	r0, #0
   16cda:	d0e7      	beq.n	16cac <_svfprintf_r+0xb18>
   16cdc:	f7ff bba8 	b.w	16430 <_svfprintf_r+0x29c>
   16ce0:	9816      	ldr	r0, [sp, #88]	; 0x58
   16ce2:	f8dd c05c 	ldr.w	ip, [sp, #92]	; 0x5c
   16ce6:	4603      	mov	r3, r0
   16ce8:	9011      	str	r0, [sp, #68]	; 0x44
   16cea:	0931      	lsrs	r1, r6, #4
   16cec:	f006 020f 	and.w	r2, r6, #15
   16cf0:	ea41 7107 	orr.w	r1, r1, r7, lsl #28
   16cf4:	0938      	lsrs	r0, r7, #4
   16cf6:	f81c 2002 	ldrb.w	r2, [ip, r2]
   16cfa:	460e      	mov	r6, r1
   16cfc:	4607      	mov	r7, r0
   16cfe:	ea56 0107 	orrs.w	r1, r6, r7
   16d02:	f803 2d01 	strb.w	r2, [r3, #-1]!
   16d06:	d1f0      	bne.n	16cea <_svfprintf_r+0xb56>
   16d08:	9a16      	ldr	r2, [sp, #88]	; 0x58
   16d0a:	9311      	str	r3, [sp, #68]	; 0x44
   16d0c:	1ad2      	subs	r2, r2, r3
   16d0e:	920e      	str	r2, [sp, #56]	; 0x38
   16d10:	f7ff bbed 	b.w	164ee <_svfprintf_r+0x35a>
   16d14:	2300      	movs	r3, #0
   16d16:	2209      	movs	r2, #9
   16d18:	42b2      	cmp	r2, r6
   16d1a:	eb73 0007 	sbcs.w	r0, r3, r7
   16d1e:	9b16      	ldr	r3, [sp, #88]	; 0x58
   16d20:	bf3e      	ittt	cc
   16d22:	f8cd 802c 	strcc.w	r8, [sp, #44]	; 0x2c
   16d26:	46a0      	movcc	r8, r4
   16d28:	461c      	movcc	r4, r3
   16d2a:	d21a      	bcs.n	16d62 <_svfprintf_r+0xbce>
   16d2c:	4630      	mov	r0, r6
   16d2e:	4639      	mov	r1, r7
   16d30:	220a      	movs	r2, #10
   16d32:	2300      	movs	r3, #0
   16d34:	f003 fefa 	bl	1ab2c <__aeabi_uldivmod>
   16d38:	4630      	mov	r0, r6
   16d3a:	4639      	mov	r1, r7
   16d3c:	2300      	movs	r3, #0
   16d3e:	f102 0c30 	add.w	ip, r2, #48	; 0x30
   16d42:	220a      	movs	r2, #10
   16d44:	f804 cd01 	strb.w	ip, [r4, #-1]!
   16d48:	f003 fef0 	bl	1ab2c <__aeabi_uldivmod>
   16d4c:	4606      	mov	r6, r0
   16d4e:	460f      	mov	r7, r1
   16d50:	2009      	movs	r0, #9
   16d52:	2100      	movs	r1, #0
   16d54:	42b0      	cmp	r0, r6
   16d56:	41b9      	sbcs	r1, r7
   16d58:	d3e8      	bcc.n	16d2c <_svfprintf_r+0xb98>
   16d5a:	4623      	mov	r3, r4
   16d5c:	4644      	mov	r4, r8
   16d5e:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
   16d62:	1e5a      	subs	r2, r3, #1
   16d64:	3630      	adds	r6, #48	; 0x30
   16d66:	9211      	str	r2, [sp, #68]	; 0x44
   16d68:	f803 6c01 	strb.w	r6, [r3, #-1]
   16d6c:	9b16      	ldr	r3, [sp, #88]	; 0x58
   16d6e:	1a9b      	subs	r3, r3, r2
   16d70:	930e      	str	r3, [sp, #56]	; 0x38
   16d72:	f7ff bbbc 	b.w	164ee <_svfprintf_r+0x35a>
   16d76:	bf00      	nop
   16d78:	0002f960 	.word	0x0002f960
   16d7c:	9809      	ldr	r0, [sp, #36]	; 0x24
   16d7e:	4659      	mov	r1, fp
   16d80:	aa37      	add	r2, sp, #220	; 0xdc
   16d82:	f7ff f979 	bl	16078 <__sprint_r>
   16d86:	2800      	cmp	r0, #0
   16d88:	f47f ab52 	bne.w	16430 <_svfprintf_r+0x29c>
   16d8c:	464c      	mov	r4, r9
   16d8e:	f7ff bbff 	b.w	16590 <_svfprintf_r+0x3fc>
   16d92:	9818      	ldr	r0, [sp, #96]	; 0x60
   16d94:	1e46      	subs	r6, r0, #1
   16d96:	2e00      	cmp	r6, #0
   16d98:	f77f ab08 	ble.w	163ac <_svfprintf_r+0x218>
   16d9c:	2e10      	cmp	r6, #16
   16d9e:	4f9c      	ldr	r7, [pc, #624]	; (17010 <_svfprintf_r+0xe7c>)
   16da0:	bfc8      	it	gt
   16da2:	f04f 0810 	movgt.w	r8, #16
   16da6:	dc03      	bgt.n	16db0 <_svfprintf_r+0xc1c>
   16da8:	e01b      	b.n	16de2 <_svfprintf_r+0xc4e>
   16daa:	3e10      	subs	r6, #16
   16dac:	2e10      	cmp	r6, #16
   16dae:	dd18      	ble.n	16de2 <_svfprintf_r+0xc4e>
   16db0:	f8c4 8004 	str.w	r8, [r4, #4]
   16db4:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   16db6:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   16db8:	3301      	adds	r3, #1
   16dba:	6027      	str	r7, [r4, #0]
   16dbc:	3210      	adds	r2, #16
   16dbe:	2b07      	cmp	r3, #7
   16dc0:	9239      	str	r2, [sp, #228]	; 0xe4
   16dc2:	f104 0408 	add.w	r4, r4, #8
   16dc6:	9338      	str	r3, [sp, #224]	; 0xe0
   16dc8:	ddef      	ble.n	16daa <_svfprintf_r+0xc16>
   16dca:	9809      	ldr	r0, [sp, #36]	; 0x24
   16dcc:	4659      	mov	r1, fp
   16dce:	aa37      	add	r2, sp, #220	; 0xdc
   16dd0:	464c      	mov	r4, r9
   16dd2:	f7ff f951 	bl	16078 <__sprint_r>
   16dd6:	2800      	cmp	r0, #0
   16dd8:	f47f ab2a 	bne.w	16430 <_svfprintf_r+0x29c>
   16ddc:	3e10      	subs	r6, #16
   16dde:	2e10      	cmp	r6, #16
   16de0:	dce6      	bgt.n	16db0 <_svfprintf_r+0xc1c>
   16de2:	6066      	str	r6, [r4, #4]
   16de4:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   16de6:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   16de8:	3301      	adds	r3, #1
   16dea:	6027      	str	r7, [r4, #0]
   16dec:	1992      	adds	r2, r2, r6
   16dee:	2b07      	cmp	r3, #7
   16df0:	9239      	str	r2, [sp, #228]	; 0xe4
   16df2:	9338      	str	r3, [sp, #224]	; 0xe0
   16df4:	f77f aad9 	ble.w	163aa <_svfprintf_r+0x216>
   16df8:	e706      	b.n	16c08 <_svfprintf_r+0xa74>
   16dfa:	9814      	ldr	r0, [sp, #80]	; 0x50
   16dfc:	2130      	movs	r1, #48	; 0x30
   16dfe:	f04a 0a02 	orr.w	sl, sl, #2
   16e02:	2201      	movs	r2, #1
   16e04:	2302      	movs	r3, #2
   16e06:	f88d 110c 	strb.w	r1, [sp, #268]	; 0x10c
   16e0a:	f88d 010d 	strb.w	r0, [sp, #269]	; 0x10d
   16e0e:	f7ff bb39 	b.w	16484 <_svfprintf_r+0x2f0>
   16e12:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   16e14:	1d13      	adds	r3, r2, #4
   16e16:	6816      	ldr	r6, [r2, #0]
   16e18:	930a      	str	r3, [sp, #40]	; 0x28
   16e1a:	4636      	mov	r6, r6
   16e1c:	ea4f 77e6 	mov.w	r7, r6, asr #31
   16e20:	2e00      	cmp	r6, #0
   16e22:	f177 0000 	sbcs.w	r0, r7, #0
   16e26:	f6bf ac8a 	bge.w	1673e <_svfprintf_r+0x5aa>
   16e2a:	4276      	negs	r6, r6
   16e2c:	eb67 0747 	sbc.w	r7, r7, r7, lsl #1
   16e30:	232d      	movs	r3, #45	; 0x2d
   16e32:	ea56 0207 	orrs.w	r2, r6, r7
   16e36:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
   16e3a:	bf0c      	ite	eq
   16e3c:	2200      	moveq	r2, #0
   16e3e:	2201      	movne	r2, #1
   16e40:	2301      	movs	r3, #1
   16e42:	f7ff bb23 	b.w	1648c <_svfprintf_r+0x2f8>
   16e46:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16e48:	1d18      	adds	r0, r3, #4
   16e4a:	681e      	ldr	r6, [r3, #0]
   16e4c:	900a      	str	r0, [sp, #40]	; 0x28
   16e4e:	4636      	mov	r6, r6
   16e50:	f04f 0700 	mov.w	r7, #0
   16e54:	f7ff bb0c 	b.w	16470 <_svfprintf_r+0x2dc>
   16e58:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   16e5a:	1d13      	adds	r3, r2, #4
   16e5c:	6816      	ldr	r6, [r2, #0]
   16e5e:	930a      	str	r3, [sp, #40]	; 0x28
   16e60:	2301      	movs	r3, #1
   16e62:	1e32      	subs	r2, r6, #0
   16e64:	bf18      	it	ne
   16e66:	2201      	movne	r2, #1
   16e68:	4636      	mov	r6, r6
   16e6a:	f04f 0700 	mov.w	r7, #0
   16e6e:	f7ff bb09 	b.w	16484 <_svfprintf_r+0x2f0>
   16e72:	9809      	ldr	r0, [sp, #36]	; 0x24
   16e74:	4659      	mov	r1, fp
   16e76:	aa37      	add	r2, sp, #220	; 0xdc
   16e78:	f7ff f8fe 	bl	16078 <__sprint_r>
   16e7c:	2800      	cmp	r0, #0
   16e7e:	f47f aad7 	bne.w	16430 <_svfprintf_r+0x29c>
   16e82:	464c      	mov	r4, r9
   16e84:	f7ff ba79 	b.w	1637a <_svfprintf_r+0x1e6>
   16e88:	9809      	ldr	r0, [sp, #36]	; 0x24
   16e8a:	4659      	mov	r1, fp
   16e8c:	aa37      	add	r2, sp, #220	; 0xdc
   16e8e:	f7ff f8f3 	bl	16078 <__sprint_r>
   16e92:	2800      	cmp	r0, #0
   16e94:	f47f aacc 	bne.w	16430 <_svfprintf_r+0x29c>
   16e98:	464c      	mov	r4, r9
   16e9a:	f7ff ba60 	b.w	1635e <_svfprintf_r+0x1ca>
   16e9e:	2830      	cmp	r0, #48	; 0x30
   16ea0:	f000 8296 	beq.w	173d0 <_svfprintf_r+0x123c>
   16ea4:	9a11      	ldr	r2, [sp, #68]	; 0x44
   16ea6:	2330      	movs	r3, #48	; 0x30
   16ea8:	f802 3d01 	strb.w	r3, [r2, #-1]!
   16eac:	9b16      	ldr	r3, [sp, #88]	; 0x58
   16eae:	9211      	str	r2, [sp, #68]	; 0x44
   16eb0:	1a9b      	subs	r3, r3, r2
   16eb2:	930e      	str	r3, [sp, #56]	; 0x38
   16eb4:	f7ff bb1b 	b.w	164ee <_svfprintf_r+0x35a>
   16eb8:	9809      	ldr	r0, [sp, #36]	; 0x24
   16eba:	4659      	mov	r1, fp
   16ebc:	aa37      	add	r2, sp, #220	; 0xdc
   16ebe:	f7ff f8db 	bl	16078 <__sprint_r>
   16ec2:	2800      	cmp	r0, #0
   16ec4:	f47f aab4 	bne.w	16430 <_svfprintf_r+0x29c>
   16ec8:	464c      	mov	r4, r9
   16eca:	f7ff bb87 	b.w	165dc <_svfprintf_r+0x448>
   16ece:	605e      	str	r6, [r3, #4]
   16ed0:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   16ed2:	9939      	ldr	r1, [sp, #228]	; 0xe4
   16ed4:	3201      	adds	r2, #1
   16ed6:	601f      	str	r7, [r3, #0]
   16ed8:	1989      	adds	r1, r1, r6
   16eda:	2a07      	cmp	r2, #7
   16edc:	9139      	str	r1, [sp, #228]	; 0xe4
   16ede:	9238      	str	r2, [sp, #224]	; 0xe0
   16ee0:	f73f abc1 	bgt.w	16666 <_svfprintf_r+0x4d2>
   16ee4:	3308      	adds	r3, #8
   16ee6:	f7ff ba71 	b.w	163cc <_svfprintf_r+0x238>
   16eea:	990a      	ldr	r1, [sp, #40]	; 0x28
   16eec:	462b      	mov	r3, r5
   16eee:	782a      	ldrb	r2, [r5, #0]
   16ef0:	910a      	str	r1, [sp, #40]	; 0x28
   16ef2:	f7ff b9b8 	b.w	16266 <_svfprintf_r+0xd2>
   16ef6:	f01a 0f10 	tst.w	sl, #16
   16efa:	f000 81cd 	beq.w	17298 <_svfprintf_r+0x1104>
   16efe:	980a      	ldr	r0, [sp, #40]	; 0x28
   16f00:	990d      	ldr	r1, [sp, #52]	; 0x34
   16f02:	f100 0a04 	add.w	sl, r0, #4
   16f06:	6803      	ldr	r3, [r0, #0]
   16f08:	6019      	str	r1, [r3, #0]
   16f0a:	f7ff b96d 	b.w	161e8 <_svfprintf_r+0x54>
   16f0e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   16f10:	1dd3      	adds	r3, r2, #7
   16f12:	f023 0307 	bic.w	r3, r3, #7
   16f16:	f103 0008 	add.w	r0, r3, #8
   16f1a:	900a      	str	r0, [sp, #40]	; 0x28
   16f1c:	685e      	ldr	r6, [r3, #4]
   16f1e:	681f      	ldr	r7, [r3, #0]
   16f20:	9619      	str	r6, [sp, #100]	; 0x64
   16f22:	9710      	str	r7, [sp, #64]	; 0x40
   16f24:	e43f      	b.n	167a6 <_svfprintf_r+0x612>
   16f26:	f01a 0340 	ands.w	r3, sl, #64	; 0x40
   16f2a:	f000 81a9 	beq.w	17280 <_svfprintf_r+0x10ec>
   16f2e:	990a      	ldr	r1, [sp, #40]	; 0x28
   16f30:	4613      	mov	r3, r2
   16f32:	1d0a      	adds	r2, r1, #4
   16f34:	920a      	str	r2, [sp, #40]	; 0x28
   16f36:	880e      	ldrh	r6, [r1, #0]
   16f38:	1e32      	subs	r2, r6, #0
   16f3a:	bf18      	it	ne
   16f3c:	2201      	movne	r2, #1
   16f3e:	4636      	mov	r6, r6
   16f40:	f04f 0700 	mov.w	r7, #0
   16f44:	f7ff ba9e 	b.w	16484 <_svfprintf_r+0x2f0>
   16f48:	9a11      	ldr	r2, [sp, #68]	; 0x44
   16f4a:	6063      	str	r3, [r4, #4]
   16f4c:	9938      	ldr	r1, [sp, #224]	; 0xe0
   16f4e:	6022      	str	r2, [r4, #0]
   16f50:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   16f52:	3101      	adds	r1, #1
   16f54:	9138      	str	r1, [sp, #224]	; 0xe0
   16f56:	18d3      	adds	r3, r2, r3
   16f58:	2907      	cmp	r1, #7
   16f5a:	9339      	str	r3, [sp, #228]	; 0xe4
   16f5c:	f300 8262 	bgt.w	17424 <_svfprintf_r+0x1290>
   16f60:	3408      	adds	r4, #8
   16f62:	2301      	movs	r3, #1
   16f64:	9e42      	ldr	r6, [sp, #264]	; 0x108
   16f66:	6063      	str	r3, [r4, #4]
   16f68:	9b38      	ldr	r3, [sp, #224]	; 0xe0
   16f6a:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   16f6c:	3301      	adds	r3, #1
   16f6e:	981b      	ldr	r0, [sp, #108]	; 0x6c
   16f70:	3201      	adds	r2, #1
   16f72:	2b07      	cmp	r3, #7
   16f74:	9338      	str	r3, [sp, #224]	; 0xe0
   16f76:	bfd8      	it	le
   16f78:	f104 0308 	addle.w	r3, r4, #8
   16f7c:	6020      	str	r0, [r4, #0]
   16f7e:	9239      	str	r2, [sp, #228]	; 0xe4
   16f80:	f300 8246 	bgt.w	17410 <_svfprintf_r+0x127c>
   16f84:	9a42      	ldr	r2, [sp, #264]	; 0x108
   16f86:	9911      	ldr	r1, [sp, #68]	; 0x44
   16f88:	9818      	ldr	r0, [sp, #96]	; 0x60
   16f8a:	198e      	adds	r6, r1, r6
   16f8c:	601e      	str	r6, [r3, #0]
   16f8e:	1a81      	subs	r1, r0, r2
   16f90:	6059      	str	r1, [r3, #4]
   16f92:	9939      	ldr	r1, [sp, #228]	; 0xe4
   16f94:	1a8a      	subs	r2, r1, r2
   16f96:	9938      	ldr	r1, [sp, #224]	; 0xe0
   16f98:	1812      	adds	r2, r2, r0
   16f9a:	9239      	str	r2, [sp, #228]	; 0xe4
   16f9c:	3101      	adds	r1, #1
   16f9e:	9138      	str	r1, [sp, #224]	; 0xe0
   16fa0:	2907      	cmp	r1, #7
   16fa2:	f73f ab60 	bgt.w	16666 <_svfprintf_r+0x4d2>
   16fa6:	3308      	adds	r3, #8
   16fa8:	f7ff ba10 	b.w	163cc <_svfprintf_r+0x238>
   16fac:	4655      	mov	r5, sl
   16fae:	f8dd a038 	ldr.w	sl, [sp, #56]	; 0x38
   16fb2:	605c      	str	r4, [r3, #4]
   16fb4:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   16fb6:	9939      	ldr	r1, [sp, #228]	; 0xe4
   16fb8:	3201      	adds	r2, #1
   16fba:	601f      	str	r7, [r3, #0]
   16fbc:	1909      	adds	r1, r1, r4
   16fbe:	2a07      	cmp	r2, #7
   16fc0:	9139      	str	r1, [sp, #228]	; 0xe4
   16fc2:	9238      	str	r2, [sp, #224]	; 0xe0
   16fc4:	f300 827f 	bgt.w	174c6 <_svfprintf_r+0x1332>
   16fc8:	3308      	adds	r3, #8
   16fca:	f01a 0f01 	tst.w	sl, #1
   16fce:	f43f a9fd 	beq.w	163cc <_svfprintf_r+0x238>
   16fd2:	991b      	ldr	r1, [sp, #108]	; 0x6c
   16fd4:	2201      	movs	r2, #1
   16fd6:	605a      	str	r2, [r3, #4]
   16fd8:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   16fda:	6019      	str	r1, [r3, #0]
   16fdc:	9939      	ldr	r1, [sp, #228]	; 0xe4
   16fde:	3201      	adds	r2, #1
   16fe0:	9238      	str	r2, [sp, #224]	; 0xe0
   16fe2:	3101      	adds	r1, #1
   16fe4:	2a07      	cmp	r2, #7
   16fe6:	9139      	str	r1, [sp, #228]	; 0xe4
   16fe8:	f73f ab3d 	bgt.w	16666 <_svfprintf_r+0x4d2>
   16fec:	3308      	adds	r3, #8
   16fee:	f7ff b9ed 	b.w	163cc <_svfprintf_r+0x238>
   16ff2:	232d      	movs	r3, #45	; 0x2d
   16ff4:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
   16ff8:	f7ff bbe8 	b.w	167cc <_svfprintf_r+0x638>
   16ffc:	9809      	ldr	r0, [sp, #36]	; 0x24
   16ffe:	4659      	mov	r1, fp
   17000:	aa37      	add	r2, sp, #220	; 0xdc
   17002:	f7ff f839 	bl	16078 <__sprint_r>
   17006:	2800      	cmp	r0, #0
   17008:	f47f aa12 	bne.w	16430 <_svfprintf_r+0x29c>
   1700c:	464b      	mov	r3, r9
   1700e:	e556      	b.n	16abe <_svfprintf_r+0x92a>
   17010:	0002f960 	.word	0x0002f960
   17014:	2301      	movs	r3, #1
   17016:	6063      	str	r3, [r4, #4]
   17018:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   1701a:	f64f 13b0 	movw	r3, #63920	; 0xf9b0
   1701e:	f2c0 0302 	movt	r3, #2
   17022:	6023      	str	r3, [r4, #0]
   17024:	9b39      	ldr	r3, [sp, #228]	; 0xe4
   17026:	3201      	adds	r2, #1
   17028:	9238      	str	r2, [sp, #224]	; 0xe0
   1702a:	3301      	adds	r3, #1
   1702c:	2a07      	cmp	r2, #7
   1702e:	9339      	str	r3, [sp, #228]	; 0xe4
   17030:	bfd8      	it	le
   17032:	f104 0308 	addle.w	r3, r4, #8
   17036:	f300 8173 	bgt.w	17320 <_svfprintf_r+0x118c>
   1703a:	9a42      	ldr	r2, [sp, #264]	; 0x108
   1703c:	b92a      	cbnz	r2, 1704a <_svfprintf_r+0xeb6>
   1703e:	9818      	ldr	r0, [sp, #96]	; 0x60
   17040:	b918      	cbnz	r0, 1704a <_svfprintf_r+0xeb6>
   17042:	f01a 0f01 	tst.w	sl, #1
   17046:	f43f a9c1 	beq.w	163cc <_svfprintf_r+0x238>
   1704a:	991b      	ldr	r1, [sp, #108]	; 0x6c
   1704c:	2201      	movs	r2, #1
   1704e:	605a      	str	r2, [r3, #4]
   17050:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   17052:	6019      	str	r1, [r3, #0]
   17054:	9939      	ldr	r1, [sp, #228]	; 0xe4
   17056:	3201      	adds	r2, #1
   17058:	9238      	str	r2, [sp, #224]	; 0xe0
   1705a:	3101      	adds	r1, #1
   1705c:	2a07      	cmp	r2, #7
   1705e:	9139      	str	r1, [sp, #228]	; 0xe4
   17060:	f300 8168 	bgt.w	17334 <_svfprintf_r+0x11a0>
   17064:	3308      	adds	r3, #8
   17066:	9c42      	ldr	r4, [sp, #264]	; 0x108
   17068:	4264      	negs	r4, r4
   1706a:	2c00      	cmp	r4, #0
   1706c:	f340 8187 	ble.w	1737e <_svfprintf_r+0x11ea>
   17070:	2c10      	cmp	r4, #16
   17072:	4f9e      	ldr	r7, [pc, #632]	; (172ec <_svfprintf_r+0x1158>)
   17074:	f340 81a0 	ble.w	173b8 <_svfprintf_r+0x1224>
   17078:	2610      	movs	r6, #16
   1707a:	f10d 08dc 	add.w	r8, sp, #220	; 0xdc
   1707e:	e003      	b.n	17088 <_svfprintf_r+0xef4>
   17080:	3c10      	subs	r4, #16
   17082:	2c10      	cmp	r4, #16
   17084:	f340 8198 	ble.w	173b8 <_svfprintf_r+0x1224>
   17088:	605e      	str	r6, [r3, #4]
   1708a:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   1708c:	9939      	ldr	r1, [sp, #228]	; 0xe4
   1708e:	3201      	adds	r2, #1
   17090:	601f      	str	r7, [r3, #0]
   17092:	3110      	adds	r1, #16
   17094:	2a07      	cmp	r2, #7
   17096:	9139      	str	r1, [sp, #228]	; 0xe4
   17098:	f103 0308 	add.w	r3, r3, #8
   1709c:	9238      	str	r2, [sp, #224]	; 0xe0
   1709e:	ddef      	ble.n	17080 <_svfprintf_r+0xeec>
   170a0:	9809      	ldr	r0, [sp, #36]	; 0x24
   170a2:	4659      	mov	r1, fp
   170a4:	4642      	mov	r2, r8
   170a6:	f7fe ffe7 	bl	16078 <__sprint_r>
   170aa:	464b      	mov	r3, r9
   170ac:	2800      	cmp	r0, #0
   170ae:	d0e7      	beq.n	17080 <_svfprintf_r+0xeec>
   170b0:	f7ff b9be 	b.w	16430 <_svfprintf_r+0x29c>
   170b4:	9b39      	ldr	r3, [sp, #228]	; 0xe4
   170b6:	465e      	mov	r6, fp
   170b8:	2b00      	cmp	r3, #0
   170ba:	f43f a9ba 	beq.w	16432 <_svfprintf_r+0x29e>
   170be:	9809      	ldr	r0, [sp, #36]	; 0x24
   170c0:	4659      	mov	r1, fp
   170c2:	aa37      	add	r2, sp, #220	; 0xdc
   170c4:	f7fe ffd8 	bl	16078 <__sprint_r>
   170c8:	f7ff b9b3 	b.w	16432 <_svfprintf_r+0x29e>
   170cc:	990a      	ldr	r1, [sp, #40]	; 0x28
   170ce:	f04a 0a20 	orr.w	sl, sl, #32
   170d2:	786a      	ldrb	r2, [r5, #1]
   170d4:	1c6b      	adds	r3, r5, #1
   170d6:	910a      	str	r1, [sp, #40]	; 0x28
   170d8:	f7ff b8c5 	b.w	16266 <_svfprintf_r+0xd2>
   170dc:	4638      	mov	r0, r7
   170de:	4631      	mov	r1, r6
   170e0:	9308      	str	r3, [sp, #32]
   170e2:	f003 f971 	bl	1a3c8 <__isnand>
   170e6:	9b08      	ldr	r3, [sp, #32]
   170e8:	2800      	cmp	r0, #0
   170ea:	f040 8101 	bne.w	172f0 <_svfprintf_r+0x115c>
   170ee:	f1b8 3fff 	cmp.w	r8, #4294967295
   170f2:	bf08      	it	eq
   170f4:	f108 0807 	addeq.w	r8, r8, #7
   170f8:	d00e      	beq.n	17118 <_svfprintf_r+0xf84>
   170fa:	9a14      	ldr	r2, [sp, #80]	; 0x50
   170fc:	2a67      	cmp	r2, #103	; 0x67
   170fe:	bf14      	ite	ne
   17100:	2300      	movne	r3, #0
   17102:	2301      	moveq	r3, #1
   17104:	2a47      	cmp	r2, #71	; 0x47
   17106:	bf08      	it	eq
   17108:	f043 0301 	orreq.w	r3, r3, #1
   1710c:	b123      	cbz	r3, 17118 <_svfprintf_r+0xf84>
   1710e:	f1b8 0f00 	cmp.w	r8, #0
   17112:	bf08      	it	eq
   17114:	f04f 0801 	moveq.w	r8, #1
   17118:	4633      	mov	r3, r6
   1711a:	463a      	mov	r2, r7
   1711c:	e9cd 233a 	strd	r2, r3, [sp, #232]	; 0xe8
   17120:	f44a 7a80 	orr.w	sl, sl, #256	; 0x100
   17124:	9b3b      	ldr	r3, [sp, #236]	; 0xec
   17126:	2b00      	cmp	r3, #0
   17128:	f2c0 820a 	blt.w	17540 <_svfprintf_r+0x13ac>
   1712c:	2300      	movs	r3, #0
   1712e:	9315      	str	r3, [sp, #84]	; 0x54
   17130:	9914      	ldr	r1, [sp, #80]	; 0x50
   17132:	2966      	cmp	r1, #102	; 0x66
   17134:	bf14      	ite	ne
   17136:	2300      	movne	r3, #0
   17138:	2301      	moveq	r3, #1
   1713a:	2946      	cmp	r1, #70	; 0x46
   1713c:	bf08      	it	eq
   1713e:	f043 0301 	orreq.w	r3, r3, #1
   17142:	9312      	str	r3, [sp, #72]	; 0x48
   17144:	2b00      	cmp	r3, #0
   17146:	f000 818a 	beq.w	1745e <_svfprintf_r+0x12ca>
   1714a:	2303      	movs	r3, #3
   1714c:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
   17150:	990b      	ldr	r1, [sp, #44]	; 0x2c
   17152:	970e      	str	r7, [sp, #56]	; 0x38
   17154:	960f      	str	r6, [sp, #60]	; 0x3c
   17156:	9300      	str	r3, [sp, #0]
   17158:	9809      	ldr	r0, [sp, #36]	; 0x24
   1715a:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
   1715e:	9101      	str	r1, [sp, #4]
   17160:	a942      	add	r1, sp, #264	; 0x108
   17162:	9102      	str	r1, [sp, #8]
   17164:	a941      	add	r1, sp, #260	; 0x104
   17166:	9103      	str	r1, [sp, #12]
   17168:	a940      	add	r1, sp, #256	; 0x100
   1716a:	9104      	str	r1, [sp, #16]
   1716c:	f000 fae8 	bl	17740 <_dtoa_r>
   17170:	9a14      	ldr	r2, [sp, #80]	; 0x50
   17172:	f1b2 0367 	subs.w	r3, r2, #103	; 0x67
   17176:	bf18      	it	ne
   17178:	2301      	movne	r3, #1
   1717a:	2a47      	cmp	r2, #71	; 0x47
   1717c:	bf0c      	ite	eq
   1717e:	2300      	moveq	r3, #0
   17180:	f003 0301 	andne.w	r3, r3, #1
   17184:	9011      	str	r0, [sp, #68]	; 0x44
   17186:	b92b      	cbnz	r3, 17194 <_svfprintf_r+0x1000>
   17188:	f01a 0f01 	tst.w	sl, #1
   1718c:	bf08      	it	eq
   1718e:	f8dd c100 	ldreq.w	ip, [sp, #256]	; 0x100
   17192:	d01a      	beq.n	171ca <_svfprintf_r+0x1036>
   17194:	9b11      	ldr	r3, [sp, #68]	; 0x44
   17196:	980b      	ldr	r0, [sp, #44]	; 0x2c
   17198:	9912      	ldr	r1, [sp, #72]	; 0x48
   1719a:	eb03 0c00 	add.w	ip, r3, r0
   1719e:	b129      	cbz	r1, 171ac <_svfprintf_r+0x1018>
   171a0:	781b      	ldrb	r3, [r3, #0]
   171a2:	2b30      	cmp	r3, #48	; 0x30
   171a4:	f000 80d0 	beq.w	17348 <_svfprintf_r+0x11b4>
   171a8:	9b42      	ldr	r3, [sp, #264]	; 0x108
   171aa:	449c      	add	ip, r3
   171ac:	4638      	mov	r0, r7
   171ae:	2200      	movs	r2, #0
   171b0:	2300      	movs	r3, #0
   171b2:	4631      	mov	r1, r6
   171b4:	f8cd c020 	str.w	ip, [sp, #32]
   171b8:	f003 fc5e 	bl	1aa78 <__aeabi_dcmpeq>
   171bc:	f8dd c020 	ldr.w	ip, [sp, #32]
   171c0:	2800      	cmp	r0, #0
   171c2:	f000 8173 	beq.w	174ac <_svfprintf_r+0x1318>
   171c6:	f8cd c100 	str.w	ip, [sp, #256]	; 0x100
   171ca:	9814      	ldr	r0, [sp, #80]	; 0x50
   171cc:	9911      	ldr	r1, [sp, #68]	; 0x44
   171ce:	2867      	cmp	r0, #103	; 0x67
   171d0:	bf14      	ite	ne
   171d2:	2300      	movne	r3, #0
   171d4:	2301      	moveq	r3, #1
   171d6:	2847      	cmp	r0, #71	; 0x47
   171d8:	bf08      	it	eq
   171da:	f043 0301 	orreq.w	r3, r3, #1
   171de:	ebc1 010c 	rsb	r1, r1, ip
   171e2:	9118      	str	r1, [sp, #96]	; 0x60
   171e4:	2b00      	cmp	r3, #0
   171e6:	f000 814a 	beq.w	1747e <_svfprintf_r+0x12ea>
   171ea:	9a42      	ldr	r2, [sp, #264]	; 0x108
   171ec:	f112 0f03 	cmn.w	r2, #3
   171f0:	920e      	str	r2, [sp, #56]	; 0x38
   171f2:	db02      	blt.n	171fa <_svfprintf_r+0x1066>
   171f4:	4590      	cmp	r8, r2
   171f6:	f280 814b 	bge.w	17490 <_svfprintf_r+0x12fc>
   171fa:	9b14      	ldr	r3, [sp, #80]	; 0x50
   171fc:	3b02      	subs	r3, #2
   171fe:	9314      	str	r3, [sp, #80]	; 0x50
   17200:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   17202:	9814      	ldr	r0, [sp, #80]	; 0x50
   17204:	1e53      	subs	r3, r2, #1
   17206:	9342      	str	r3, [sp, #264]	; 0x108
   17208:	2b00      	cmp	r3, #0
   1720a:	f88d 00f8 	strb.w	r0, [sp, #248]	; 0xf8
   1720e:	f2c0 81d1 	blt.w	175b4 <_svfprintf_r+0x1420>
   17212:	222b      	movs	r2, #43	; 0x2b
   17214:	f88d 20f9 	strb.w	r2, [sp, #249]	; 0xf9
   17218:	2b09      	cmp	r3, #9
   1721a:	f300 8162 	bgt.w	174e2 <_svfprintf_r+0x134e>
   1721e:	a93f      	add	r1, sp, #252	; 0xfc
   17220:	3330      	adds	r3, #48	; 0x30
   17222:	f88d 30fb 	strb.w	r3, [sp, #251]	; 0xfb
   17226:	2330      	movs	r3, #48	; 0x30
   17228:	f88d 30fa 	strb.w	r3, [sp, #250]	; 0xfa
   1722c:	ab3e      	add	r3, sp, #248	; 0xf8
   1722e:	9a18      	ldr	r2, [sp, #96]	; 0x60
   17230:	1acb      	subs	r3, r1, r3
   17232:	9918      	ldr	r1, [sp, #96]	; 0x60
   17234:	931a      	str	r3, [sp, #104]	; 0x68
   17236:	1859      	adds	r1, r3, r1
   17238:	2a01      	cmp	r2, #1
   1723a:	910e      	str	r1, [sp, #56]	; 0x38
   1723c:	f340 81cc 	ble.w	175d8 <_svfprintf_r+0x1444>
   17240:	980e      	ldr	r0, [sp, #56]	; 0x38
   17242:	3001      	adds	r0, #1
   17244:	900e      	str	r0, [sp, #56]	; 0x38
   17246:	ea20 71e0 	bic.w	r1, r0, r0, asr #31
   1724a:	910b      	str	r1, [sp, #44]	; 0x2c
   1724c:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1724e:	2b00      	cmp	r3, #0
   17250:	f000 80fd 	beq.w	1744e <_svfprintf_r+0x12ba>
   17254:	232d      	movs	r3, #45	; 0x2d
   17256:	2000      	movs	r0, #0
   17258:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
   1725c:	9015      	str	r0, [sp, #84]	; 0x54
   1725e:	f7ff b950 	b.w	16502 <_svfprintf_r+0x36e>
   17262:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   17264:	425b      	negs	r3, r3
   17266:	930c      	str	r3, [sp, #48]	; 0x30
   17268:	f7ff bace 	b.w	16808 <_svfprintf_r+0x674>
   1726c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   1726e:	2000      	movs	r0, #0
   17270:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
   17274:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
   17278:	9015      	str	r0, [sp, #84]	; 0x54
   1727a:	920b      	str	r2, [sp, #44]	; 0x2c
   1727c:	f7ff b940 	b.w	16500 <_svfprintf_r+0x36c>
   17280:	980a      	ldr	r0, [sp, #40]	; 0x28
   17282:	1d01      	adds	r1, r0, #4
   17284:	910a      	str	r1, [sp, #40]	; 0x28
   17286:	6806      	ldr	r6, [r0, #0]
   17288:	1e32      	subs	r2, r6, #0
   1728a:	bf18      	it	ne
   1728c:	2201      	movne	r2, #1
   1728e:	4636      	mov	r6, r6
   17290:	f04f 0700 	mov.w	r7, #0
   17294:	f7ff b8f6 	b.w	16484 <_svfprintf_r+0x2f0>
   17298:	f01a 0f40 	tst.w	sl, #64	; 0x40
   1729c:	bf17      	itett	ne
   1729e:	9a0a      	ldrne	r2, [sp, #40]	; 0x28
   172a0:	990a      	ldreq	r1, [sp, #40]	; 0x28
   172a2:	980d      	ldrne	r0, [sp, #52]	; 0x34
   172a4:	f102 0a04 	addne.w	sl, r2, #4
   172a8:	bf11      	iteee	ne
   172aa:	6813      	ldrne	r3, [r2, #0]
   172ac:	f101 0a04 	addeq.w	sl, r1, #4
   172b0:	680b      	ldreq	r3, [r1, #0]
   172b2:	9a0d      	ldreq	r2, [sp, #52]	; 0x34
   172b4:	bf14      	ite	ne
   172b6:	8018      	strhne	r0, [r3, #0]
   172b8:	601a      	streq	r2, [r3, #0]
   172ba:	f7fe bf95 	b.w	161e8 <_svfprintf_r+0x54>
   172be:	9809      	ldr	r0, [sp, #36]	; 0x24
   172c0:	4659      	mov	r1, fp
   172c2:	aa37      	add	r2, sp, #220	; 0xdc
   172c4:	f7fe fed8 	bl	16078 <__sprint_r>
   172c8:	2800      	cmp	r0, #0
   172ca:	f47f a8b1 	bne.w	16430 <_svfprintf_r+0x29c>
   172ce:	464b      	mov	r3, r9
   172d0:	e40b      	b.n	16aea <_svfprintf_r+0x956>
   172d2:	9809      	ldr	r0, [sp, #36]	; 0x24
   172d4:	2140      	movs	r1, #64	; 0x40
   172d6:	f001 fe41 	bl	18f5c <_malloc_r>
   172da:	6030      	str	r0, [r6, #0]
   172dc:	6130      	str	r0, [r6, #16]
   172de:	2800      	cmp	r0, #0
   172e0:	f000 818d 	beq.w	175fe <_svfprintf_r+0x146a>
   172e4:	2340      	movs	r3, #64	; 0x40
   172e6:	6173      	str	r3, [r6, #20]
   172e8:	f7fe bf67 	b.w	161ba <_svfprintf_r+0x26>
   172ec:	0002f960 	.word	0x0002f960
   172f0:	2003      	movs	r0, #3
   172f2:	f64f 1290 	movw	r2, #63888	; 0xf990
   172f6:	f64f 118c 	movw	r1, #63884	; 0xf98c
   172fa:	900b      	str	r0, [sp, #44]	; 0x2c
   172fc:	9814      	ldr	r0, [sp, #80]	; 0x50
   172fe:	f2c0 0102 	movt	r1, #2
   17302:	f2c0 0202 	movt	r2, #2
   17306:	9315      	str	r3, [sp, #84]	; 0x54
   17308:	2847      	cmp	r0, #71	; 0x47
   1730a:	bfd8      	it	le
   1730c:	460a      	movle	r2, r1
   1730e:	f02a 0a80 	bic.w	sl, sl, #128	; 0x80
   17312:	2103      	movs	r1, #3
   17314:	9211      	str	r2, [sp, #68]	; 0x44
   17316:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
   1731a:	910e      	str	r1, [sp, #56]	; 0x38
   1731c:	f7ff b8f0 	b.w	16500 <_svfprintf_r+0x36c>
   17320:	9809      	ldr	r0, [sp, #36]	; 0x24
   17322:	4659      	mov	r1, fp
   17324:	aa37      	add	r2, sp, #220	; 0xdc
   17326:	f7fe fea7 	bl	16078 <__sprint_r>
   1732a:	2800      	cmp	r0, #0
   1732c:	f47f a880 	bne.w	16430 <_svfprintf_r+0x29c>
   17330:	464b      	mov	r3, r9
   17332:	e682      	b.n	1703a <_svfprintf_r+0xea6>
   17334:	9809      	ldr	r0, [sp, #36]	; 0x24
   17336:	4659      	mov	r1, fp
   17338:	aa37      	add	r2, sp, #220	; 0xdc
   1733a:	f7fe fe9d 	bl	16078 <__sprint_r>
   1733e:	2800      	cmp	r0, #0
   17340:	f47f a876 	bne.w	16430 <_svfprintf_r+0x29c>
   17344:	464b      	mov	r3, r9
   17346:	e68e      	b.n	17066 <_svfprintf_r+0xed2>
   17348:	4638      	mov	r0, r7
   1734a:	2200      	movs	r2, #0
   1734c:	2300      	movs	r3, #0
   1734e:	4631      	mov	r1, r6
   17350:	f8cd c020 	str.w	ip, [sp, #32]
   17354:	f003 fb90 	bl	1aa78 <__aeabi_dcmpeq>
   17358:	f8dd c020 	ldr.w	ip, [sp, #32]
   1735c:	2800      	cmp	r0, #0
   1735e:	f47f af23 	bne.w	171a8 <_svfprintf_r+0x1014>
   17362:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   17364:	f1c2 0301 	rsb	r3, r2, #1
   17368:	9342      	str	r3, [sp, #264]	; 0x108
   1736a:	e71e      	b.n	171aa <_svfprintf_r+0x1016>
   1736c:	9809      	ldr	r0, [sp, #36]	; 0x24
   1736e:	4659      	mov	r1, fp
   17370:	aa37      	add	r2, sp, #220	; 0xdc
   17372:	f7fe fe81 	bl	16078 <__sprint_r>
   17376:	2800      	cmp	r0, #0
   17378:	f47f a85a 	bne.w	16430 <_svfprintf_r+0x29c>
   1737c:	464b      	mov	r3, r9
   1737e:	9a18      	ldr	r2, [sp, #96]	; 0x60
   17380:	9811      	ldr	r0, [sp, #68]	; 0x44
   17382:	605a      	str	r2, [r3, #4]
   17384:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   17386:	9939      	ldr	r1, [sp, #228]	; 0xe4
   17388:	6018      	str	r0, [r3, #0]
   1738a:	3201      	adds	r2, #1
   1738c:	9818      	ldr	r0, [sp, #96]	; 0x60
   1738e:	9238      	str	r2, [sp, #224]	; 0xe0
   17390:	1809      	adds	r1, r1, r0
   17392:	2a07      	cmp	r2, #7
   17394:	9139      	str	r1, [sp, #228]	; 0xe4
   17396:	f73f a966 	bgt.w	16666 <_svfprintf_r+0x4d2>
   1739a:	3308      	adds	r3, #8
   1739c:	f7ff b816 	b.w	163cc <_svfprintf_r+0x238>
   173a0:	2100      	movs	r1, #0
   173a2:	9115      	str	r1, [sp, #84]	; 0x54
   173a4:	f7fe faee 	bl	15984 <strlen>
   173a8:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
   173ac:	ea20 72e0 	bic.w	r2, r0, r0, asr #31
   173b0:	900e      	str	r0, [sp, #56]	; 0x38
   173b2:	920b      	str	r2, [sp, #44]	; 0x2c
   173b4:	f7ff b8a4 	b.w	16500 <_svfprintf_r+0x36c>
   173b8:	605c      	str	r4, [r3, #4]
   173ba:	9a38      	ldr	r2, [sp, #224]	; 0xe0
   173bc:	601f      	str	r7, [r3, #0]
   173be:	1c51      	adds	r1, r2, #1
   173c0:	9a39      	ldr	r2, [sp, #228]	; 0xe4
   173c2:	9138      	str	r1, [sp, #224]	; 0xe0
   173c4:	1912      	adds	r2, r2, r4
   173c6:	2907      	cmp	r1, #7
   173c8:	9239      	str	r2, [sp, #228]	; 0xe4
   173ca:	dccf      	bgt.n	1736c <_svfprintf_r+0x11d8>
   173cc:	3308      	adds	r3, #8
   173ce:	e7d6      	b.n	1737e <_svfprintf_r+0x11ea>
   173d0:	9916      	ldr	r1, [sp, #88]	; 0x58
   173d2:	9811      	ldr	r0, [sp, #68]	; 0x44
   173d4:	1a08      	subs	r0, r1, r0
   173d6:	900e      	str	r0, [sp, #56]	; 0x38
   173d8:	f7ff b889 	b.w	164ee <_svfprintf_r+0x35a>
   173dc:	f1b8 0f06 	cmp.w	r8, #6
   173e0:	bf34      	ite	cc
   173e2:	4641      	movcc	r1, r8
   173e4:	2106      	movcs	r1, #6
   173e6:	f64f 12a8 	movw	r2, #63912	; 0xf9a8
   173ea:	f2c0 0202 	movt	r2, #2
   173ee:	ea21 73e1 	bic.w	r3, r1, r1, asr #31
   173f2:	910e      	str	r1, [sp, #56]	; 0x38
   173f4:	9211      	str	r2, [sp, #68]	; 0x44
   173f6:	930b      	str	r3, [sp, #44]	; 0x2c
   173f8:	f7ff b963 	b.w	166c2 <_svfprintf_r+0x52e>
   173fc:	9809      	ldr	r0, [sp, #36]	; 0x24
   173fe:	4659      	mov	r1, fp
   17400:	aa37      	add	r2, sp, #220	; 0xdc
   17402:	f7fe fe39 	bl	16078 <__sprint_r>
   17406:	2800      	cmp	r0, #0
   17408:	f47f a812 	bne.w	16430 <_svfprintf_r+0x29c>
   1740c:	464b      	mov	r3, r9
   1740e:	e43b      	b.n	16c88 <_svfprintf_r+0xaf4>
   17410:	9809      	ldr	r0, [sp, #36]	; 0x24
   17412:	4659      	mov	r1, fp
   17414:	aa37      	add	r2, sp, #220	; 0xdc
   17416:	f7fe fe2f 	bl	16078 <__sprint_r>
   1741a:	2800      	cmp	r0, #0
   1741c:	f47f a808 	bne.w	16430 <_svfprintf_r+0x29c>
   17420:	464b      	mov	r3, r9
   17422:	e5af      	b.n	16f84 <_svfprintf_r+0xdf0>
   17424:	9809      	ldr	r0, [sp, #36]	; 0x24
   17426:	4659      	mov	r1, fp
   17428:	aa37      	add	r2, sp, #220	; 0xdc
   1742a:	f7fe fe25 	bl	16078 <__sprint_r>
   1742e:	2800      	cmp	r0, #0
   17430:	f47e affe 	bne.w	16430 <_svfprintf_r+0x29c>
   17434:	464c      	mov	r4, r9
   17436:	e594      	b.n	16f62 <_svfprintf_r+0xdce>
   17438:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
   1743c:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
   17440:	9015      	str	r0, [sp, #84]	; 0x54
   17442:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
   17446:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
   1744a:	f7ff b859 	b.w	16500 <_svfprintf_r+0x36c>
   1744e:	980e      	ldr	r0, [sp, #56]	; 0x38
   17450:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
   17454:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   17458:	900b      	str	r0, [sp, #44]	; 0x2c
   1745a:	f7ff b851 	b.w	16500 <_svfprintf_r+0x36c>
   1745e:	9a14      	ldr	r2, [sp, #80]	; 0x50
   17460:	2a65      	cmp	r2, #101	; 0x65
   17462:	bf14      	ite	ne
   17464:	2300      	movne	r3, #0
   17466:	2301      	moveq	r3, #1
   17468:	2a45      	cmp	r2, #69	; 0x45
   1746a:	bf08      	it	eq
   1746c:	f043 0301 	orreq.w	r3, r3, #1
   17470:	2b00      	cmp	r3, #0
   17472:	d032      	beq.n	174da <_svfprintf_r+0x1346>
   17474:	f108 0301 	add.w	r3, r8, #1
   17478:	930b      	str	r3, [sp, #44]	; 0x2c
   1747a:	2302      	movs	r3, #2
   1747c:	e668      	b.n	17150 <_svfprintf_r+0xfbc>
   1747e:	9814      	ldr	r0, [sp, #80]	; 0x50
   17480:	2865      	cmp	r0, #101	; 0x65
   17482:	dd62      	ble.n	1754a <_svfprintf_r+0x13b6>
   17484:	9a14      	ldr	r2, [sp, #80]	; 0x50
   17486:	2a66      	cmp	r2, #102	; 0x66
   17488:	bf1c      	itt	ne
   1748a:	9b42      	ldrne	r3, [sp, #264]	; 0x108
   1748c:	930e      	strne	r3, [sp, #56]	; 0x38
   1748e:	d06f      	beq.n	17570 <_svfprintf_r+0x13dc>
   17490:	9a18      	ldr	r2, [sp, #96]	; 0x60
   17492:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   17494:	429a      	cmp	r2, r3
   17496:	dc5b      	bgt.n	17550 <_svfprintf_r+0x13bc>
   17498:	f01a 0f01 	tst.w	sl, #1
   1749c:	f040 8081 	bne.w	175a2 <_svfprintf_r+0x140e>
   174a0:	ea23 70e3 	bic.w	r0, r3, r3, asr #31
   174a4:	2167      	movs	r1, #103	; 0x67
   174a6:	900b      	str	r0, [sp, #44]	; 0x2c
   174a8:	9114      	str	r1, [sp, #80]	; 0x50
   174aa:	e6cf      	b.n	1724c <_svfprintf_r+0x10b8>
   174ac:	9b40      	ldr	r3, [sp, #256]	; 0x100
   174ae:	459c      	cmp	ip, r3
   174b0:	bf98      	it	ls
   174b2:	469c      	movls	ip, r3
   174b4:	f67f ae89 	bls.w	171ca <_svfprintf_r+0x1036>
   174b8:	2230      	movs	r2, #48	; 0x30
   174ba:	f803 2b01 	strb.w	r2, [r3], #1
   174be:	459c      	cmp	ip, r3
   174c0:	9340      	str	r3, [sp, #256]	; 0x100
   174c2:	d8fa      	bhi.n	174ba <_svfprintf_r+0x1326>
   174c4:	e681      	b.n	171ca <_svfprintf_r+0x1036>
   174c6:	9809      	ldr	r0, [sp, #36]	; 0x24
   174c8:	4659      	mov	r1, fp
   174ca:	aa37      	add	r2, sp, #220	; 0xdc
   174cc:	f7fe fdd4 	bl	16078 <__sprint_r>
   174d0:	2800      	cmp	r0, #0
   174d2:	f47e afad 	bne.w	16430 <_svfprintf_r+0x29c>
   174d6:	464b      	mov	r3, r9
   174d8:	e577      	b.n	16fca <_svfprintf_r+0xe36>
   174da:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
   174de:	3302      	adds	r3, #2
   174e0:	e636      	b.n	17150 <_svfprintf_r+0xfbc>
   174e2:	f246 6c67 	movw	ip, #26215	; 0x6667
   174e6:	f10d 00f7 	add.w	r0, sp, #247	; 0xf7
   174ea:	f2c6 6c66 	movt	ip, #26214	; 0x6666
   174ee:	fb8c 2103 	smull	r2, r1, ip, r3
   174f2:	17da      	asrs	r2, r3, #31
   174f4:	ebc2 02a1 	rsb	r2, r2, r1, asr #2
   174f8:	eb02 0182 	add.w	r1, r2, r2, lsl #2
   174fc:	eba3 0141 	sub.w	r1, r3, r1, lsl #1
   17500:	4613      	mov	r3, r2
   17502:	3130      	adds	r1, #48	; 0x30
   17504:	2a09      	cmp	r2, #9
   17506:	f800 1d01 	strb.w	r1, [r0, #-1]!
   1750a:	dcf0      	bgt.n	174ee <_svfprintf_r+0x135a>
   1750c:	3330      	adds	r3, #48	; 0x30
   1750e:	1e42      	subs	r2, r0, #1
   17510:	b2d9      	uxtb	r1, r3
   17512:	f800 1c01 	strb.w	r1, [r0, #-1]
   17516:	9b07      	ldr	r3, [sp, #28]
   17518:	4293      	cmp	r3, r2
   1751a:	bf98      	it	ls
   1751c:	f10d 01fa 	addls.w	r1, sp, #250	; 0xfa
   17520:	f67f ae84 	bls.w	1722c <_svfprintf_r+0x1098>
   17524:	4602      	mov	r2, r0
   17526:	f10d 03fb 	add.w	r3, sp, #251	; 0xfb
   1752a:	e001      	b.n	17530 <_svfprintf_r+0x139c>
   1752c:	f812 1b01 	ldrb.w	r1, [r2], #1
   17530:	f803 1c01 	strb.w	r1, [r3, #-1]
   17534:	4619      	mov	r1, r3
   17536:	9807      	ldr	r0, [sp, #28]
   17538:	3301      	adds	r3, #1
   1753a:	4290      	cmp	r0, r2
   1753c:	d8f6      	bhi.n	1752c <_svfprintf_r+0x1398>
   1753e:	e675      	b.n	1722c <_svfprintf_r+0x1098>
   17540:	202d      	movs	r0, #45	; 0x2d
   17542:	f106 4600 	add.w	r6, r6, #2147483648	; 0x80000000
   17546:	9015      	str	r0, [sp, #84]	; 0x54
   17548:	e5f2      	b.n	17130 <_svfprintf_r+0xf9c>
   1754a:	9942      	ldr	r1, [sp, #264]	; 0x108
   1754c:	910e      	str	r1, [sp, #56]	; 0x38
   1754e:	e657      	b.n	17200 <_svfprintf_r+0x106c>
   17550:	990e      	ldr	r1, [sp, #56]	; 0x38
   17552:	9818      	ldr	r0, [sp, #96]	; 0x60
   17554:	2900      	cmp	r1, #0
   17556:	bfda      	itte	le
   17558:	9a0e      	ldrle	r2, [sp, #56]	; 0x38
   1755a:	f1c2 0302 	rsble	r3, r2, #2
   1755e:	2301      	movgt	r3, #1
   17560:	181b      	adds	r3, r3, r0
   17562:	2167      	movs	r1, #103	; 0x67
   17564:	ea23 72e3 	bic.w	r2, r3, r3, asr #31
   17568:	930e      	str	r3, [sp, #56]	; 0x38
   1756a:	9114      	str	r1, [sp, #80]	; 0x50
   1756c:	920b      	str	r2, [sp, #44]	; 0x2c
   1756e:	e66d      	b.n	1724c <_svfprintf_r+0x10b8>
   17570:	9842      	ldr	r0, [sp, #264]	; 0x108
   17572:	2800      	cmp	r0, #0
   17574:	900e      	str	r0, [sp, #56]	; 0x38
   17576:	dd38      	ble.n	175ea <_svfprintf_r+0x1456>
   17578:	f1b8 0f00 	cmp.w	r8, #0
   1757c:	d107      	bne.n	1758e <_svfprintf_r+0x13fa>
   1757e:	f01a 0f01 	tst.w	sl, #1
   17582:	bf04      	itt	eq
   17584:	ea20 71e0 	biceq.w	r1, r0, r0, asr #31
   17588:	910b      	streq	r1, [sp, #44]	; 0x2c
   1758a:	f43f ae5f 	beq.w	1724c <_svfprintf_r+0x10b8>
   1758e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   17590:	2066      	movs	r0, #102	; 0x66
   17592:	9014      	str	r0, [sp, #80]	; 0x50
   17594:	1c53      	adds	r3, r2, #1
   17596:	4443      	add	r3, r8
   17598:	930e      	str	r3, [sp, #56]	; 0x38
   1759a:	ea23 71e3 	bic.w	r1, r3, r3, asr #31
   1759e:	910b      	str	r1, [sp, #44]	; 0x2c
   175a0:	e654      	b.n	1724c <_svfprintf_r+0x10b8>
   175a2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   175a4:	2367      	movs	r3, #103	; 0x67
   175a6:	9314      	str	r3, [sp, #80]	; 0x50
   175a8:	3201      	adds	r2, #1
   175aa:	920e      	str	r2, [sp, #56]	; 0x38
   175ac:	ea22 70e2 	bic.w	r0, r2, r2, asr #31
   175b0:	900b      	str	r0, [sp, #44]	; 0x2c
   175b2:	e64b      	b.n	1724c <_svfprintf_r+0x10b8>
   175b4:	222d      	movs	r2, #45	; 0x2d
   175b6:	425b      	negs	r3, r3
   175b8:	f88d 20f9 	strb.w	r2, [sp, #249]	; 0xf9
   175bc:	e62c      	b.n	17218 <_svfprintf_r+0x1084>
   175be:	990a      	ldr	r1, [sp, #40]	; 0x28
   175c0:	781a      	ldrb	r2, [r3, #0]
   175c2:	f8d1 8000 	ldr.w	r8, [r1]
   175c6:	3104      	adds	r1, #4
   175c8:	910a      	str	r1, [sp, #40]	; 0x28
   175ca:	f1b8 0f00 	cmp.w	r8, #0
   175ce:	bfb8      	it	lt
   175d0:	f04f 38ff 	movlt.w	r8, #4294967295
   175d4:	f7fe be47 	b.w	16266 <_svfprintf_r+0xd2>
   175d8:	f01a 0f01 	tst.w	sl, #1
   175dc:	bf04      	itt	eq
   175de:	ea21 73e1 	biceq.w	r3, r1, r1, asr #31
   175e2:	930b      	streq	r3, [sp, #44]	; 0x2c
   175e4:	f43f ae32 	beq.w	1724c <_svfprintf_r+0x10b8>
   175e8:	e62a      	b.n	17240 <_svfprintf_r+0x10ac>
   175ea:	f1b8 0f00 	cmp.w	r8, #0
   175ee:	d10e      	bne.n	1760e <_svfprintf_r+0x147a>
   175f0:	f01a 0f01 	tst.w	sl, #1
   175f4:	d10b      	bne.n	1760e <_svfprintf_r+0x147a>
   175f6:	2201      	movs	r2, #1
   175f8:	920b      	str	r2, [sp, #44]	; 0x2c
   175fa:	920e      	str	r2, [sp, #56]	; 0x38
   175fc:	e626      	b.n	1724c <_svfprintf_r+0x10b8>
   175fe:	9809      	ldr	r0, [sp, #36]	; 0x24
   17600:	230c      	movs	r3, #12
   17602:	f04f 31ff 	mov.w	r1, #4294967295
   17606:	910d      	str	r1, [sp, #52]	; 0x34
   17608:	6003      	str	r3, [r0, #0]
   1760a:	f7fe bf1a 	b.w	16442 <_svfprintf_r+0x2ae>
   1760e:	f108 0302 	add.w	r3, r8, #2
   17612:	2066      	movs	r0, #102	; 0x66
   17614:	ea23 71e3 	bic.w	r1, r3, r3, asr #31
   17618:	930e      	str	r3, [sp, #56]	; 0x38
   1761a:	9014      	str	r0, [sp, #80]	; 0x50
   1761c:	910b      	str	r1, [sp, #44]	; 0x2c
   1761e:	e615      	b.n	1724c <_svfprintf_r+0x10b8>

00017620 <quorem>:
   17620:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17624:	6903      	ldr	r3, [r0, #16]
   17626:	690e      	ldr	r6, [r1, #16]
   17628:	4682      	mov	sl, r0
   1762a:	4689      	mov	r9, r1
   1762c:	429e      	cmp	r6, r3
   1762e:	f300 8083 	bgt.w	17738 <quorem+0x118>
   17632:	1cf2      	adds	r2, r6, #3
   17634:	f101 0514 	add.w	r5, r1, #20
   17638:	f100 0414 	add.w	r4, r0, #20
   1763c:	3e01      	subs	r6, #1
   1763e:	0092      	lsls	r2, r2, #2
   17640:	188b      	adds	r3, r1, r2
   17642:	1812      	adds	r2, r2, r0
   17644:	f103 0804 	add.w	r8, r3, #4
   17648:	6859      	ldr	r1, [r3, #4]
   1764a:	6850      	ldr	r0, [r2, #4]
   1764c:	3101      	adds	r1, #1
   1764e:	f003 f87f 	bl	1a750 <__aeabi_uidiv>
   17652:	4607      	mov	r7, r0
   17654:	2800      	cmp	r0, #0
   17656:	d039      	beq.n	176cc <quorem+0xac>
   17658:	2300      	movs	r3, #0
   1765a:	469c      	mov	ip, r3
   1765c:	461a      	mov	r2, r3
   1765e:	58e9      	ldr	r1, [r5, r3]
   17660:	58e0      	ldr	r0, [r4, r3]
   17662:	fa1f fe81 	uxth.w	lr, r1
   17666:	ea4f 4b11 	mov.w	fp, r1, lsr #16
   1766a:	b281      	uxth	r1, r0
   1766c:	fb0e ce07 	mla	lr, lr, r7, ip
   17670:	1851      	adds	r1, r2, r1
   17672:	fb0b fc07 	mul.w	ip, fp, r7
   17676:	eb0c 4c1e 	add.w	ip, ip, lr, lsr #16
   1767a:	fa1f fe8e 	uxth.w	lr, lr
   1767e:	ebce 0101 	rsb	r1, lr, r1
   17682:	fa1f f28c 	uxth.w	r2, ip
   17686:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
   1768a:	ebc2 4210 	rsb	r2, r2, r0, lsr #16
   1768e:	fa1f fe81 	uxth.w	lr, r1
   17692:	eb02 4221 	add.w	r2, r2, r1, asr #16
   17696:	ea4e 4102 	orr.w	r1, lr, r2, lsl #16
   1769a:	50e1      	str	r1, [r4, r3]
   1769c:	3304      	adds	r3, #4
   1769e:	1412      	asrs	r2, r2, #16
   176a0:	1959      	adds	r1, r3, r5
   176a2:	4588      	cmp	r8, r1
   176a4:	d2db      	bcs.n	1765e <quorem+0x3e>
   176a6:	1d32      	adds	r2, r6, #4
   176a8:	eb0a 0382 	add.w	r3, sl, r2, lsl #2
   176ac:	6859      	ldr	r1, [r3, #4]
   176ae:	b969      	cbnz	r1, 176cc <quorem+0xac>
   176b0:	429c      	cmp	r4, r3
   176b2:	d209      	bcs.n	176c8 <quorem+0xa8>
   176b4:	f85a 2022 	ldr.w	r2, [sl, r2, lsl #2]
   176b8:	b112      	cbz	r2, 176c0 <quorem+0xa0>
   176ba:	e005      	b.n	176c8 <quorem+0xa8>
   176bc:	681a      	ldr	r2, [r3, #0]
   176be:	b91a      	cbnz	r2, 176c8 <quorem+0xa8>
   176c0:	3b04      	subs	r3, #4
   176c2:	3e01      	subs	r6, #1
   176c4:	429c      	cmp	r4, r3
   176c6:	d3f9      	bcc.n	176bc <quorem+0x9c>
   176c8:	f8ca 6010 	str.w	r6, [sl, #16]
   176cc:	4649      	mov	r1, r9
   176ce:	4650      	mov	r0, sl
   176d0:	f002 f834 	bl	1973c <__mcmp>
   176d4:	2800      	cmp	r0, #0
   176d6:	db2c      	blt.n	17732 <quorem+0x112>
   176d8:	2300      	movs	r3, #0
   176da:	3701      	adds	r7, #1
   176dc:	469c      	mov	ip, r3
   176de:	58ea      	ldr	r2, [r5, r3]
   176e0:	58e0      	ldr	r0, [r4, r3]
   176e2:	b291      	uxth	r1, r2
   176e4:	0c12      	lsrs	r2, r2, #16
   176e6:	fa1f f980 	uxth.w	r9, r0
   176ea:	ebc2 4210 	rsb	r2, r2, r0, lsr #16
   176ee:	ebc1 0109 	rsb	r1, r1, r9
   176f2:	4461      	add	r1, ip
   176f4:	eb02 4221 	add.w	r2, r2, r1, asr #16
   176f8:	b289      	uxth	r1, r1
   176fa:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
   176fe:	50e1      	str	r1, [r4, r3]
   17700:	3304      	adds	r3, #4
   17702:	ea4f 4c22 	mov.w	ip, r2, asr #16
   17706:	195a      	adds	r2, r3, r5
   17708:	4590      	cmp	r8, r2
   1770a:	d2e8      	bcs.n	176de <quorem+0xbe>
   1770c:	1d32      	adds	r2, r6, #4
   1770e:	eb0a 0382 	add.w	r3, sl, r2, lsl #2
   17712:	6859      	ldr	r1, [r3, #4]
   17714:	b969      	cbnz	r1, 17732 <quorem+0x112>
   17716:	429c      	cmp	r4, r3
   17718:	d209      	bcs.n	1772e <quorem+0x10e>
   1771a:	f85a 2022 	ldr.w	r2, [sl, r2, lsl #2]
   1771e:	b112      	cbz	r2, 17726 <quorem+0x106>
   17720:	e005      	b.n	1772e <quorem+0x10e>
   17722:	681a      	ldr	r2, [r3, #0]
   17724:	b91a      	cbnz	r2, 1772e <quorem+0x10e>
   17726:	3b04      	subs	r3, #4
   17728:	3e01      	subs	r6, #1
   1772a:	429c      	cmp	r4, r3
   1772c:	d3f9      	bcc.n	17722 <quorem+0x102>
   1772e:	f8ca 6010 	str.w	r6, [sl, #16]
   17732:	4638      	mov	r0, r7
   17734:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   17738:	2000      	movs	r0, #0
   1773a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1773e:	bf00      	nop

00017740 <_dtoa_r>:
   17740:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17744:	6a46      	ldr	r6, [r0, #36]	; 0x24
   17746:	b0a1      	sub	sp, #132	; 0x84
   17748:	4604      	mov	r4, r0
   1774a:	4690      	mov	r8, r2
   1774c:	4699      	mov	r9, r3
   1774e:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
   17750:	2e00      	cmp	r6, #0
   17752:	f000 8423 	beq.w	17f9c <_dtoa_r+0x85c>
   17756:	6832      	ldr	r2, [r6, #0]
   17758:	b182      	cbz	r2, 1777c <_dtoa_r+0x3c>
   1775a:	6a61      	ldr	r1, [r4, #36]	; 0x24
   1775c:	f04f 0c01 	mov.w	ip, #1
   17760:	6876      	ldr	r6, [r6, #4]
   17762:	4620      	mov	r0, r4
   17764:	680b      	ldr	r3, [r1, #0]
   17766:	6056      	str	r6, [r2, #4]
   17768:	684a      	ldr	r2, [r1, #4]
   1776a:	4619      	mov	r1, r3
   1776c:	fa0c f202 	lsl.w	r2, ip, r2
   17770:	609a      	str	r2, [r3, #8]
   17772:	f002 f91d 	bl	199b0 <_Bfree>
   17776:	6a63      	ldr	r3, [r4, #36]	; 0x24
   17778:	2200      	movs	r2, #0
   1777a:	601a      	str	r2, [r3, #0]
   1777c:	f1b9 0600 	subs.w	r6, r9, #0
   17780:	db38      	blt.n	177f4 <_dtoa_r+0xb4>
   17782:	2300      	movs	r3, #0
   17784:	602b      	str	r3, [r5, #0]
   17786:	f240 0300 	movw	r3, #0
   1778a:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
   1778e:	461a      	mov	r2, r3
   17790:	ea06 0303 	and.w	r3, r6, r3
   17794:	4293      	cmp	r3, r2
   17796:	d017      	beq.n	177c8 <_dtoa_r+0x88>
   17798:	2200      	movs	r2, #0
   1779a:	2300      	movs	r3, #0
   1779c:	4640      	mov	r0, r8
   1779e:	4649      	mov	r1, r9
   177a0:	e9cd 8906 	strd	r8, r9, [sp, #24]
   177a4:	f003 f968 	bl	1aa78 <__aeabi_dcmpeq>
   177a8:	2800      	cmp	r0, #0
   177aa:	d029      	beq.n	17800 <_dtoa_r+0xc0>
   177ac:	982c      	ldr	r0, [sp, #176]	; 0xb0
   177ae:	2301      	movs	r3, #1
   177b0:	992e      	ldr	r1, [sp, #184]	; 0xb8
   177b2:	6003      	str	r3, [r0, #0]
   177b4:	2900      	cmp	r1, #0
   177b6:	f000 80d0 	beq.w	1795a <_dtoa_r+0x21a>
   177ba:	4b79      	ldr	r3, [pc, #484]	; (179a0 <_dtoa_r+0x260>)
   177bc:	1e58      	subs	r0, r3, #1
   177be:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
   177c0:	6013      	str	r3, [r2, #0]
   177c2:	b021      	add	sp, #132	; 0x84
   177c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   177c8:	982c      	ldr	r0, [sp, #176]	; 0xb0
   177ca:	f242 730f 	movw	r3, #9999	; 0x270f
   177ce:	6003      	str	r3, [r0, #0]
   177d0:	f1b8 0f00 	cmp.w	r8, #0
   177d4:	f000 8095 	beq.w	17902 <_dtoa_r+0x1c2>
   177d8:	f64f 10c0 	movw	r0, #63936	; 0xf9c0
   177dc:	f2c0 0002 	movt	r0, #2
   177e0:	992e      	ldr	r1, [sp, #184]	; 0xb8
   177e2:	2900      	cmp	r1, #0
   177e4:	d0ed      	beq.n	177c2 <_dtoa_r+0x82>
   177e6:	78c2      	ldrb	r2, [r0, #3]
   177e8:	1cc3      	adds	r3, r0, #3
   177ea:	2a00      	cmp	r2, #0
   177ec:	d0e7      	beq.n	177be <_dtoa_r+0x7e>
   177ee:	f100 0308 	add.w	r3, r0, #8
   177f2:	e7e4      	b.n	177be <_dtoa_r+0x7e>
   177f4:	f026 4600 	bic.w	r6, r6, #2147483648	; 0x80000000
   177f8:	2301      	movs	r3, #1
   177fa:	46b1      	mov	r9, r6
   177fc:	602b      	str	r3, [r5, #0]
   177fe:	e7c2      	b.n	17786 <_dtoa_r+0x46>
   17800:	4620      	mov	r0, r4
   17802:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   17806:	a91e      	add	r1, sp, #120	; 0x78
   17808:	9100      	str	r1, [sp, #0]
   1780a:	a91f      	add	r1, sp, #124	; 0x7c
   1780c:	9101      	str	r1, [sp, #4]
   1780e:	f002 f921 	bl	19a54 <__d2b>
   17812:	f3c6 550a 	ubfx	r5, r6, #20, #11
   17816:	4683      	mov	fp, r0
   17818:	2d00      	cmp	r5, #0
   1781a:	d07e      	beq.n	1791a <_dtoa_r+0x1da>
   1781c:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
   17820:	f5a5 757e 	sub.w	r5, r5, #1016	; 0x3f8
   17824:	9f1f      	ldr	r7, [sp, #124]	; 0x7c
   17826:	3d07      	subs	r5, #7
   17828:	f021 437f 	bic.w	r3, r1, #4278190080	; 0xff000000
   1782c:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
   17830:	f043 517e 	orr.w	r1, r3, #1065353216	; 0x3f800000
   17834:	2300      	movs	r3, #0
   17836:	f441 01e0 	orr.w	r1, r1, #7340032	; 0x700000
   1783a:	9319      	str	r3, [sp, #100]	; 0x64
   1783c:	f240 0300 	movw	r3, #0
   17840:	2200      	movs	r2, #0
   17842:	f6c3 73f8 	movt	r3, #16376	; 0x3ff8
   17846:	f7fc fef1 	bl	1462c <__aeabi_dsub>
   1784a:	a34f      	add	r3, pc, #316	; (adr r3, 17988 <_dtoa_r+0x248>)
   1784c:	e9d3 2300 	ldrd	r2, r3, [r3]
   17850:	f7fd f8a0 	bl	14994 <__aeabi_dmul>
   17854:	a34e      	add	r3, pc, #312	; (adr r3, 17990 <_dtoa_r+0x250>)
   17856:	e9d3 2300 	ldrd	r2, r3, [r3]
   1785a:	f7fc fee9 	bl	14630 <__adddf3>
   1785e:	e9cd 0108 	strd	r0, r1, [sp, #32]
   17862:	4628      	mov	r0, r5
   17864:	f7fd f830 	bl	148c8 <__aeabi_i2d>
   17868:	a34b      	add	r3, pc, #300	; (adr r3, 17998 <_dtoa_r+0x258>)
   1786a:	e9d3 2300 	ldrd	r2, r3, [r3]
   1786e:	f7fd f891 	bl	14994 <__aeabi_dmul>
   17872:	4602      	mov	r2, r0
   17874:	460b      	mov	r3, r1
   17876:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   1787a:	f7fc fed9 	bl	14630 <__adddf3>
   1787e:	e9cd 0108 	strd	r0, r1, [sp, #32]
   17882:	f003 f92b 	bl	1aadc <__aeabi_d2iz>
   17886:	2200      	movs	r2, #0
   17888:	2300      	movs	r3, #0
   1788a:	4606      	mov	r6, r0
   1788c:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   17890:	f003 f8fc 	bl	1aa8c <__aeabi_dcmplt>
   17894:	b140      	cbz	r0, 178a8 <_dtoa_r+0x168>
   17896:	4630      	mov	r0, r6
   17898:	f7fd f816 	bl	148c8 <__aeabi_i2d>
   1789c:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
   178a0:	f003 f8ea 	bl	1aa78 <__aeabi_dcmpeq>
   178a4:	b900      	cbnz	r0, 178a8 <_dtoa_r+0x168>
   178a6:	3e01      	subs	r6, #1
   178a8:	2e16      	cmp	r6, #22
   178aa:	d95b      	bls.n	17964 <_dtoa_r+0x224>
   178ac:	2301      	movs	r3, #1
   178ae:	9318      	str	r3, [sp, #96]	; 0x60
   178b0:	3f01      	subs	r7, #1
   178b2:	ebb7 0a05 	subs.w	sl, r7, r5
   178b6:	bf42      	ittt	mi
   178b8:	f1ca 0a00 	rsbmi	sl, sl, #0
   178bc:	f8cd a03c 	strmi.w	sl, [sp, #60]	; 0x3c
   178c0:	f04f 0a00 	movmi.w	sl, #0
   178c4:	d401      	bmi.n	178ca <_dtoa_r+0x18a>
   178c6:	2200      	movs	r2, #0
   178c8:	920f      	str	r2, [sp, #60]	; 0x3c
   178ca:	2e00      	cmp	r6, #0
   178cc:	f2c0 8371 	blt.w	17fb2 <_dtoa_r+0x872>
   178d0:	44b2      	add	sl, r6
   178d2:	2300      	movs	r3, #0
   178d4:	9617      	str	r6, [sp, #92]	; 0x5c
   178d6:	9315      	str	r3, [sp, #84]	; 0x54
   178d8:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
   178da:	2b09      	cmp	r3, #9
   178dc:	d862      	bhi.n	179a4 <_dtoa_r+0x264>
   178de:	2b05      	cmp	r3, #5
   178e0:	f340 8677 	ble.w	185d2 <_dtoa_r+0xe92>
   178e4:	982a      	ldr	r0, [sp, #168]	; 0xa8
   178e6:	2700      	movs	r7, #0
   178e8:	3804      	subs	r0, #4
   178ea:	902a      	str	r0, [sp, #168]	; 0xa8
   178ec:	992a      	ldr	r1, [sp, #168]	; 0xa8
   178ee:	1e8b      	subs	r3, r1, #2
   178f0:	2b03      	cmp	r3, #3
   178f2:	f200 83dd 	bhi.w	180b0 <_dtoa_r+0x970>
   178f6:	e8df f013 	tbh	[pc, r3, lsl #1]
   178fa:	03a5      	.short	0x03a5
   178fc:	03d503d8 	.word	0x03d503d8
   17900:	03c4      	.short	0x03c4
   17902:	f026 467f 	bic.w	r6, r6, #4278190080	; 0xff000000
   17906:	f426 0670 	bic.w	r6, r6, #15728640	; 0xf00000
   1790a:	2e00      	cmp	r6, #0
   1790c:	f47f af64 	bne.w	177d8 <_dtoa_r+0x98>
   17910:	f64f 10b4 	movw	r0, #63924	; 0xf9b4
   17914:	f2c0 0002 	movt	r0, #2
   17918:	e762      	b.n	177e0 <_dtoa_r+0xa0>
   1791a:	9f1f      	ldr	r7, [sp, #124]	; 0x7c
   1791c:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   1791e:	18fb      	adds	r3, r7, r3
   17920:	f503 6386 	add.w	r3, r3, #1072	; 0x430
   17924:	1c9d      	adds	r5, r3, #2
   17926:	2d20      	cmp	r5, #32
   17928:	bfdc      	itt	le
   1792a:	f1c5 0020 	rsble	r0, r5, #32
   1792e:	fa08 f000 	lslle.w	r0, r8, r0
   17932:	dd08      	ble.n	17946 <_dtoa_r+0x206>
   17934:	3b1e      	subs	r3, #30
   17936:	f1c5 0240 	rsb	r2, r5, #64	; 0x40
   1793a:	fa16 f202 	lsls.w	r2, r6, r2
   1793e:	fa28 f303 	lsr.w	r3, r8, r3
   17942:	ea42 0003 	orr.w	r0, r2, r3
   17946:	f7fc ffaf 	bl	148a8 <__aeabi_ui2d>
   1794a:	f5a5 6586 	sub.w	r5, r5, #1072	; 0x430
   1794e:	2201      	movs	r2, #1
   17950:	3d03      	subs	r5, #3
   17952:	9219      	str	r2, [sp, #100]	; 0x64
   17954:	f1a1 71f8 	sub.w	r1, r1, #32505856	; 0x1f00000
   17958:	e770      	b.n	1783c <_dtoa_r+0xfc>
   1795a:	f64f 10b0 	movw	r0, #63920	; 0xf9b0
   1795e:	f2c0 0002 	movt	r0, #2
   17962:	e72e      	b.n	177c2 <_dtoa_r+0x82>
   17964:	f64f 2308 	movw	r3, #64008	; 0xfa08
   17968:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
   1796c:	f2c0 0302 	movt	r3, #2
   17970:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
   17974:	e9d3 2300 	ldrd	r2, r3, [r3]
   17978:	f003 f888 	bl	1aa8c <__aeabi_dcmplt>
   1797c:	2800      	cmp	r0, #0
   1797e:	f040 8320 	bne.w	17fc2 <_dtoa_r+0x882>
   17982:	9018      	str	r0, [sp, #96]	; 0x60
   17984:	e794      	b.n	178b0 <_dtoa_r+0x170>
   17986:	bf00      	nop
   17988:	636f4361 	.word	0x636f4361
   1798c:	3fd287a7 	.word	0x3fd287a7
   17990:	8b60c8b3 	.word	0x8b60c8b3
   17994:	3fc68a28 	.word	0x3fc68a28
   17998:	509f79fb 	.word	0x509f79fb
   1799c:	3fd34413 	.word	0x3fd34413
   179a0:	0002f9b1 	.word	0x0002f9b1
   179a4:	2300      	movs	r3, #0
   179a6:	f04f 30ff 	mov.w	r0, #4294967295
   179aa:	461f      	mov	r7, r3
   179ac:	2101      	movs	r1, #1
   179ae:	932a      	str	r3, [sp, #168]	; 0xa8
   179b0:	9011      	str	r0, [sp, #68]	; 0x44
   179b2:	9116      	str	r1, [sp, #88]	; 0x58
   179b4:	9008      	str	r0, [sp, #32]
   179b6:	932b      	str	r3, [sp, #172]	; 0xac
   179b8:	6a65      	ldr	r5, [r4, #36]	; 0x24
   179ba:	2300      	movs	r3, #0
   179bc:	606b      	str	r3, [r5, #4]
   179be:	4620      	mov	r0, r4
   179c0:	6869      	ldr	r1, [r5, #4]
   179c2:	f002 f811 	bl	199e8 <_Balloc>
   179c6:	6a63      	ldr	r3, [r4, #36]	; 0x24
   179c8:	6028      	str	r0, [r5, #0]
   179ca:	681b      	ldr	r3, [r3, #0]
   179cc:	9310      	str	r3, [sp, #64]	; 0x40
   179ce:	2f00      	cmp	r7, #0
   179d0:	f000 815b 	beq.w	17c8a <_dtoa_r+0x54a>
   179d4:	2e00      	cmp	r6, #0
   179d6:	f340 842a 	ble.w	1822e <_dtoa_r+0xaee>
   179da:	f64f 2308 	movw	r3, #64008	; 0xfa08
   179de:	f006 020f 	and.w	r2, r6, #15
   179e2:	f2c0 0302 	movt	r3, #2
   179e6:	1135      	asrs	r5, r6, #4
   179e8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   179ec:	f015 0f10 	tst.w	r5, #16
   179f0:	e9d3 0100 	ldrd	r0, r1, [r3]
   179f4:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   179f8:	f000 82e7 	beq.w	17fca <_dtoa_r+0x88a>
   179fc:	f64f 23e0 	movw	r3, #64224	; 0xfae0
   17a00:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
   17a04:	f2c0 0302 	movt	r3, #2
   17a08:	f005 050f 	and.w	r5, r5, #15
   17a0c:	f04f 0803 	mov.w	r8, #3
   17a10:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
   17a14:	f7fd f8e8 	bl	14be8 <__aeabi_ddiv>
   17a18:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
   17a1c:	b1bd      	cbz	r5, 17a4e <_dtoa_r+0x30e>
   17a1e:	f64f 27e0 	movw	r7, #64224	; 0xfae0
   17a22:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
   17a26:	f2c0 0702 	movt	r7, #2
   17a2a:	f015 0f01 	tst.w	r5, #1
   17a2e:	4610      	mov	r0, r2
   17a30:	4619      	mov	r1, r3
   17a32:	d007      	beq.n	17a44 <_dtoa_r+0x304>
   17a34:	e9d7 2300 	ldrd	r2, r3, [r7]
   17a38:	f108 0801 	add.w	r8, r8, #1
   17a3c:	f7fc ffaa 	bl	14994 <__aeabi_dmul>
   17a40:	4602      	mov	r2, r0
   17a42:	460b      	mov	r3, r1
   17a44:	3708      	adds	r7, #8
   17a46:	106d      	asrs	r5, r5, #1
   17a48:	d1ef      	bne.n	17a2a <_dtoa_r+0x2ea>
   17a4a:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
   17a4e:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
   17a52:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
   17a56:	f7fd f8c7 	bl	14be8 <__aeabi_ddiv>
   17a5a:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   17a5e:	9918      	ldr	r1, [sp, #96]	; 0x60
   17a60:	2900      	cmp	r1, #0
   17a62:	f000 80de 	beq.w	17c22 <_dtoa_r+0x4e2>
   17a66:	f240 0300 	movw	r3, #0
   17a6a:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   17a6e:	2200      	movs	r2, #0
   17a70:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
   17a74:	f04f 0500 	mov.w	r5, #0
   17a78:	f003 f808 	bl	1aa8c <__aeabi_dcmplt>
   17a7c:	b108      	cbz	r0, 17a82 <_dtoa_r+0x342>
   17a7e:	f04f 0501 	mov.w	r5, #1
   17a82:	9a08      	ldr	r2, [sp, #32]
   17a84:	2a00      	cmp	r2, #0
   17a86:	bfd4      	ite	le
   17a88:	2500      	movle	r5, #0
   17a8a:	f005 0501 	andgt.w	r5, r5, #1
   17a8e:	2d00      	cmp	r5, #0
   17a90:	f000 80c7 	beq.w	17c22 <_dtoa_r+0x4e2>
   17a94:	9b11      	ldr	r3, [sp, #68]	; 0x44
   17a96:	2b00      	cmp	r3, #0
   17a98:	f340 80f5 	ble.w	17c86 <_dtoa_r+0x546>
   17a9c:	f240 0300 	movw	r3, #0
   17aa0:	2200      	movs	r2, #0
   17aa2:	f2c4 0324 	movt	r3, #16420	; 0x4024
   17aa6:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   17aaa:	f7fc ff73 	bl	14994 <__aeabi_dmul>
   17aae:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   17ab2:	f108 0001 	add.w	r0, r8, #1
   17ab6:	1e71      	subs	r1, r6, #1
   17ab8:	9112      	str	r1, [sp, #72]	; 0x48
   17aba:	f7fc ff05 	bl	148c8 <__aeabi_i2d>
   17abe:	4602      	mov	r2, r0
   17ac0:	460b      	mov	r3, r1
   17ac2:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   17ac6:	f7fc ff65 	bl	14994 <__aeabi_dmul>
   17aca:	f240 0300 	movw	r3, #0
   17ace:	2200      	movs	r2, #0
   17ad0:	f2c4 031c 	movt	r3, #16412	; 0x401c
   17ad4:	f7fc fdac 	bl	14630 <__adddf3>
   17ad8:	f8dd c044 	ldr.w	ip, [sp, #68]	; 0x44
   17adc:	4680      	mov	r8, r0
   17ade:	f1a1 7950 	sub.w	r9, r1, #54525952	; 0x3400000
   17ae2:	9b16      	ldr	r3, [sp, #88]	; 0x58
   17ae4:	2b00      	cmp	r3, #0
   17ae6:	f000 83ad 	beq.w	18244 <_dtoa_r+0xb04>
   17aea:	f64f 2308 	movw	r3, #64008	; 0xfa08
   17aee:	f240 0100 	movw	r1, #0
   17af2:	f2c0 0302 	movt	r3, #2
   17af6:	2000      	movs	r0, #0
   17af8:	eb03 03cc 	add.w	r3, r3, ip, lsl #3
   17afc:	f6c3 71e0 	movt	r1, #16352	; 0x3fe0
   17b00:	f8cd c00c 	str.w	ip, [sp, #12]
   17b04:	e953 2302 	ldrd	r2, r3, [r3, #-8]
   17b08:	f7fd f86e 	bl	14be8 <__aeabi_ddiv>
   17b0c:	4642      	mov	r2, r8
   17b0e:	464b      	mov	r3, r9
   17b10:	9d10      	ldr	r5, [sp, #64]	; 0x40
   17b12:	f7fc fd8b 	bl	1462c <__aeabi_dsub>
   17b16:	4680      	mov	r8, r0
   17b18:	4689      	mov	r9, r1
   17b1a:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   17b1e:	f002 ffdd 	bl	1aadc <__aeabi_d2iz>
   17b22:	4607      	mov	r7, r0
   17b24:	f7fc fed0 	bl	148c8 <__aeabi_i2d>
   17b28:	4602      	mov	r2, r0
   17b2a:	460b      	mov	r3, r1
   17b2c:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   17b30:	f7fc fd7c 	bl	1462c <__aeabi_dsub>
   17b34:	f107 0330 	add.w	r3, r7, #48	; 0x30
   17b38:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   17b3c:	4640      	mov	r0, r8
   17b3e:	f805 3b01 	strb.w	r3, [r5], #1
   17b42:	4649      	mov	r1, r9
   17b44:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
   17b48:	f002 ffbe 	bl	1aac8 <__aeabi_dcmpgt>
   17b4c:	2800      	cmp	r0, #0
   17b4e:	f040 8213 	bne.w	17f78 <_dtoa_r+0x838>
   17b52:	f240 0100 	movw	r1, #0
   17b56:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
   17b5a:	2000      	movs	r0, #0
   17b5c:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
   17b60:	f7fc fd64 	bl	1462c <__aeabi_dsub>
   17b64:	4602      	mov	r2, r0
   17b66:	460b      	mov	r3, r1
   17b68:	4640      	mov	r0, r8
   17b6a:	4649      	mov	r1, r9
   17b6c:	f002 ffac 	bl	1aac8 <__aeabi_dcmpgt>
   17b70:	f8dd c00c 	ldr.w	ip, [sp, #12]
   17b74:	2800      	cmp	r0, #0
   17b76:	f040 83e7 	bne.w	18348 <_dtoa_r+0xc08>
   17b7a:	f1bc 0f01 	cmp.w	ip, #1
   17b7e:	f340 8082 	ble.w	17c86 <_dtoa_r+0x546>
   17b82:	f8cd b068 	str.w	fp, [sp, #104]	; 0x68
   17b86:	2701      	movs	r7, #1
   17b88:	f8cd a070 	str.w	sl, [sp, #112]	; 0x70
   17b8c:	961d      	str	r6, [sp, #116]	; 0x74
   17b8e:	4666      	mov	r6, ip
   17b90:	e9dd ab0c 	ldrd	sl, fp, [sp, #48]	; 0x30
   17b94:	940c      	str	r4, [sp, #48]	; 0x30
   17b96:	e010      	b.n	17bba <_dtoa_r+0x47a>
   17b98:	f240 0100 	movw	r1, #0
   17b9c:	2000      	movs	r0, #0
   17b9e:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
   17ba2:	f7fc fd43 	bl	1462c <__aeabi_dsub>
   17ba6:	4642      	mov	r2, r8
   17ba8:	464b      	mov	r3, r9
   17baa:	f002 ff6f 	bl	1aa8c <__aeabi_dcmplt>
   17bae:	2800      	cmp	r0, #0
   17bb0:	f040 83c7 	bne.w	18342 <_dtoa_r+0xc02>
   17bb4:	42b7      	cmp	r7, r6
   17bb6:	f280 848b 	bge.w	184d0 <_dtoa_r+0xd90>
   17bba:	f240 0300 	movw	r3, #0
   17bbe:	4640      	mov	r0, r8
   17bc0:	4649      	mov	r1, r9
   17bc2:	2200      	movs	r2, #0
   17bc4:	f2c4 0324 	movt	r3, #16420	; 0x4024
   17bc8:	3501      	adds	r5, #1
   17bca:	f7fc fee3 	bl	14994 <__aeabi_dmul>
   17bce:	f240 0300 	movw	r3, #0
   17bd2:	2200      	movs	r2, #0
   17bd4:	f2c4 0324 	movt	r3, #16420	; 0x4024
   17bd8:	4680      	mov	r8, r0
   17bda:	4689      	mov	r9, r1
   17bdc:	4650      	mov	r0, sl
   17bde:	4659      	mov	r1, fp
   17be0:	f7fc fed8 	bl	14994 <__aeabi_dmul>
   17be4:	468b      	mov	fp, r1
   17be6:	4682      	mov	sl, r0
   17be8:	f002 ff78 	bl	1aadc <__aeabi_d2iz>
   17bec:	4604      	mov	r4, r0
   17bee:	f7fc fe6b 	bl	148c8 <__aeabi_i2d>
   17bf2:	3430      	adds	r4, #48	; 0x30
   17bf4:	4602      	mov	r2, r0
   17bf6:	460b      	mov	r3, r1
   17bf8:	4650      	mov	r0, sl
   17bfa:	4659      	mov	r1, fp
   17bfc:	f7fc fd16 	bl	1462c <__aeabi_dsub>
   17c00:	9a10      	ldr	r2, [sp, #64]	; 0x40
   17c02:	464b      	mov	r3, r9
   17c04:	55d4      	strb	r4, [r2, r7]
   17c06:	4642      	mov	r2, r8
   17c08:	3701      	adds	r7, #1
   17c0a:	4682      	mov	sl, r0
   17c0c:	468b      	mov	fp, r1
   17c0e:	f002 ff3d 	bl	1aa8c <__aeabi_dcmplt>
   17c12:	4652      	mov	r2, sl
   17c14:	465b      	mov	r3, fp
   17c16:	2800      	cmp	r0, #0
   17c18:	d0be      	beq.n	17b98 <_dtoa_r+0x458>
   17c1a:	f8dd b068 	ldr.w	fp, [sp, #104]	; 0x68
   17c1e:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   17c20:	e1aa      	b.n	17f78 <_dtoa_r+0x838>
   17c22:	4640      	mov	r0, r8
   17c24:	f7fc fe50 	bl	148c8 <__aeabi_i2d>
   17c28:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
   17c2c:	f7fc feb2 	bl	14994 <__aeabi_dmul>
   17c30:	f240 0300 	movw	r3, #0
   17c34:	2200      	movs	r2, #0
   17c36:	f2c4 031c 	movt	r3, #16412	; 0x401c
   17c3a:	f7fc fcf9 	bl	14630 <__adddf3>
   17c3e:	9a08      	ldr	r2, [sp, #32]
   17c40:	f1a1 7550 	sub.w	r5, r1, #54525952	; 0x3400000
   17c44:	4680      	mov	r8, r0
   17c46:	46a9      	mov	r9, r5
   17c48:	2a00      	cmp	r2, #0
   17c4a:	f040 82ec 	bne.w	18226 <_dtoa_r+0xae6>
   17c4e:	f240 0300 	movw	r3, #0
   17c52:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   17c56:	2200      	movs	r2, #0
   17c58:	f2c4 0314 	movt	r3, #16404	; 0x4014
   17c5c:	f7fc fce6 	bl	1462c <__aeabi_dsub>
   17c60:	4642      	mov	r2, r8
   17c62:	462b      	mov	r3, r5
   17c64:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   17c68:	f002 ff2e 	bl	1aac8 <__aeabi_dcmpgt>
   17c6c:	2800      	cmp	r0, #0
   17c6e:	f040 824a 	bne.w	18106 <_dtoa_r+0x9c6>
   17c72:	4642      	mov	r2, r8
   17c74:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   17c78:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
   17c7c:	f002 ff06 	bl	1aa8c <__aeabi_dcmplt>
   17c80:	2800      	cmp	r0, #0
   17c82:	f040 81d5 	bne.w	18030 <_dtoa_r+0x8f0>
   17c86:	e9dd 8906 	ldrd	r8, r9, [sp, #24]
   17c8a:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   17c8c:	ea6f 0703 	mvn.w	r7, r3
   17c90:	ea4f 77d7 	mov.w	r7, r7, lsr #31
   17c94:	2e0e      	cmp	r6, #14
   17c96:	bfcc      	ite	gt
   17c98:	2700      	movgt	r7, #0
   17c9a:	f007 0701 	andle.w	r7, r7, #1
   17c9e:	2f00      	cmp	r7, #0
   17ca0:	f000 80b7 	beq.w	17e12 <_dtoa_r+0x6d2>
   17ca4:	982b      	ldr	r0, [sp, #172]	; 0xac
   17ca6:	f64f 2308 	movw	r3, #64008	; 0xfa08
   17caa:	f2c0 0302 	movt	r3, #2
   17cae:	9908      	ldr	r1, [sp, #32]
   17cb0:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
   17cb4:	0fc2      	lsrs	r2, r0, #31
   17cb6:	2900      	cmp	r1, #0
   17cb8:	bfcc      	ite	gt
   17cba:	2200      	movgt	r2, #0
   17cbc:	f002 0201 	andle.w	r2, r2, #1
   17cc0:	e9d3 0100 	ldrd	r0, r1, [r3]
   17cc4:	e9cd 0104 	strd	r0, r1, [sp, #16]
   17cc8:	2a00      	cmp	r2, #0
   17cca:	f040 81a0 	bne.w	1800e <_dtoa_r+0x8ce>
   17cce:	4602      	mov	r2, r0
   17cd0:	460b      	mov	r3, r1
   17cd2:	4640      	mov	r0, r8
   17cd4:	4649      	mov	r1, r9
   17cd6:	f7fc ff87 	bl	14be8 <__aeabi_ddiv>
   17cda:	9d10      	ldr	r5, [sp, #64]	; 0x40
   17cdc:	f002 fefe 	bl	1aadc <__aeabi_d2iz>
   17ce0:	4682      	mov	sl, r0
   17ce2:	f7fc fdf1 	bl	148c8 <__aeabi_i2d>
   17ce6:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   17cea:	f7fc fe53 	bl	14994 <__aeabi_dmul>
   17cee:	4602      	mov	r2, r0
   17cf0:	460b      	mov	r3, r1
   17cf2:	4640      	mov	r0, r8
   17cf4:	4649      	mov	r1, r9
   17cf6:	f7fc fc99 	bl	1462c <__aeabi_dsub>
   17cfa:	f10a 0330 	add.w	r3, sl, #48	; 0x30
   17cfe:	f805 3b01 	strb.w	r3, [r5], #1
   17d02:	9a08      	ldr	r2, [sp, #32]
   17d04:	2a01      	cmp	r2, #1
   17d06:	4680      	mov	r8, r0
   17d08:	4689      	mov	r9, r1
   17d0a:	d052      	beq.n	17db2 <_dtoa_r+0x672>
   17d0c:	f240 0300 	movw	r3, #0
   17d10:	2200      	movs	r2, #0
   17d12:	f2c4 0324 	movt	r3, #16420	; 0x4024
   17d16:	f7fc fe3d 	bl	14994 <__aeabi_dmul>
   17d1a:	2200      	movs	r2, #0
   17d1c:	2300      	movs	r3, #0
   17d1e:	e9cd 0106 	strd	r0, r1, [sp, #24]
   17d22:	f002 fea9 	bl	1aa78 <__aeabi_dcmpeq>
   17d26:	2800      	cmp	r0, #0
   17d28:	f040 81eb 	bne.w	18102 <_dtoa_r+0x9c2>
   17d2c:	9810      	ldr	r0, [sp, #64]	; 0x40
   17d2e:	f04f 0801 	mov.w	r8, #1
   17d32:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
   17d36:	46a3      	mov	fp, r4
   17d38:	1c87      	adds	r7, r0, #2
   17d3a:	960f      	str	r6, [sp, #60]	; 0x3c
   17d3c:	f8dd 9020 	ldr.w	r9, [sp, #32]
   17d40:	e9dd 4506 	ldrd	r4, r5, [sp, #24]
   17d44:	e00a      	b.n	17d5c <_dtoa_r+0x61c>
   17d46:	f7fc fe25 	bl	14994 <__aeabi_dmul>
   17d4a:	2200      	movs	r2, #0
   17d4c:	2300      	movs	r3, #0
   17d4e:	4604      	mov	r4, r0
   17d50:	460d      	mov	r5, r1
   17d52:	f002 fe91 	bl	1aa78 <__aeabi_dcmpeq>
   17d56:	2800      	cmp	r0, #0
   17d58:	f040 81ce 	bne.w	180f8 <_dtoa_r+0x9b8>
   17d5c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   17d60:	4620      	mov	r0, r4
   17d62:	4629      	mov	r1, r5
   17d64:	f108 0801 	add.w	r8, r8, #1
   17d68:	f7fc ff3e 	bl	14be8 <__aeabi_ddiv>
   17d6c:	463e      	mov	r6, r7
   17d6e:	f002 feb5 	bl	1aadc <__aeabi_d2iz>
   17d72:	4682      	mov	sl, r0
   17d74:	f7fc fda8 	bl	148c8 <__aeabi_i2d>
   17d78:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   17d7c:	f7fc fe0a 	bl	14994 <__aeabi_dmul>
   17d80:	4602      	mov	r2, r0
   17d82:	460b      	mov	r3, r1
   17d84:	4620      	mov	r0, r4
   17d86:	4629      	mov	r1, r5
   17d88:	f7fc fc50 	bl	1462c <__aeabi_dsub>
   17d8c:	2200      	movs	r2, #0
   17d8e:	f10a 0c30 	add.w	ip, sl, #48	; 0x30
   17d92:	f807 cc01 	strb.w	ip, [r7, #-1]
   17d96:	3701      	adds	r7, #1
   17d98:	45c1      	cmp	r9, r8
   17d9a:	f240 0300 	movw	r3, #0
   17d9e:	f2c4 0324 	movt	r3, #16420	; 0x4024
   17da2:	d1d0      	bne.n	17d46 <_dtoa_r+0x606>
   17da4:	4635      	mov	r5, r6
   17da6:	465c      	mov	r4, fp
   17da8:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
   17daa:	4680      	mov	r8, r0
   17dac:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
   17db0:	4689      	mov	r9, r1
   17db2:	4642      	mov	r2, r8
   17db4:	464b      	mov	r3, r9
   17db6:	4640      	mov	r0, r8
   17db8:	4649      	mov	r1, r9
   17dba:	f7fc fc39 	bl	14630 <__adddf3>
   17dbe:	4680      	mov	r8, r0
   17dc0:	4689      	mov	r9, r1
   17dc2:	4642      	mov	r2, r8
   17dc4:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   17dc8:	464b      	mov	r3, r9
   17dca:	f002 fe5f 	bl	1aa8c <__aeabi_dcmplt>
   17dce:	b960      	cbnz	r0, 17dea <_dtoa_r+0x6aa>
   17dd0:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   17dd4:	4642      	mov	r2, r8
   17dd6:	464b      	mov	r3, r9
   17dd8:	f002 fe4e 	bl	1aa78 <__aeabi_dcmpeq>
   17ddc:	2800      	cmp	r0, #0
   17dde:	f000 8190 	beq.w	18102 <_dtoa_r+0x9c2>
   17de2:	f01a 0f01 	tst.w	sl, #1
   17de6:	f000 818c 	beq.w	18102 <_dtoa_r+0x9c2>
   17dea:	9910      	ldr	r1, [sp, #64]	; 0x40
   17dec:	e000      	b.n	17df0 <_dtoa_r+0x6b0>
   17dee:	461d      	mov	r5, r3
   17df0:	f815 2c01 	ldrb.w	r2, [r5, #-1]
   17df4:	1e6b      	subs	r3, r5, #1
   17df6:	2a39      	cmp	r2, #57	; 0x39
   17df8:	f040 8367 	bne.w	184ca <_dtoa_r+0xd8a>
   17dfc:	428b      	cmp	r3, r1
   17dfe:	d1f6      	bne.n	17dee <_dtoa_r+0x6ae>
   17e00:	9910      	ldr	r1, [sp, #64]	; 0x40
   17e02:	2330      	movs	r3, #48	; 0x30
   17e04:	3601      	adds	r6, #1
   17e06:	2231      	movs	r2, #49	; 0x31
   17e08:	700b      	strb	r3, [r1, #0]
   17e0a:	9b10      	ldr	r3, [sp, #64]	; 0x40
   17e0c:	701a      	strb	r2, [r3, #0]
   17e0e:	9612      	str	r6, [sp, #72]	; 0x48
   17e10:	e0b2      	b.n	17f78 <_dtoa_r+0x838>
   17e12:	9a16      	ldr	r2, [sp, #88]	; 0x58
   17e14:	2a00      	cmp	r2, #0
   17e16:	f040 80df 	bne.w	17fd8 <_dtoa_r+0x898>
   17e1a:	9f15      	ldr	r7, [sp, #84]	; 0x54
   17e1c:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
   17e1e:	920c      	str	r2, [sp, #48]	; 0x30
   17e20:	2d00      	cmp	r5, #0
   17e22:	bfd4      	ite	le
   17e24:	2300      	movle	r3, #0
   17e26:	2301      	movgt	r3, #1
   17e28:	f1ba 0f00 	cmp.w	sl, #0
   17e2c:	bfd4      	ite	le
   17e2e:	2300      	movle	r3, #0
   17e30:	f003 0301 	andgt.w	r3, r3, #1
   17e34:	b14b      	cbz	r3, 17e4a <_dtoa_r+0x70a>
   17e36:	45aa      	cmp	sl, r5
   17e38:	bfb4      	ite	lt
   17e3a:	4653      	movlt	r3, sl
   17e3c:	462b      	movge	r3, r5
   17e3e:	980f      	ldr	r0, [sp, #60]	; 0x3c
   17e40:	ebc3 0a0a 	rsb	sl, r3, sl
   17e44:	1aed      	subs	r5, r5, r3
   17e46:	1ac0      	subs	r0, r0, r3
   17e48:	900f      	str	r0, [sp, #60]	; 0x3c
   17e4a:	9915      	ldr	r1, [sp, #84]	; 0x54
   17e4c:	2900      	cmp	r1, #0
   17e4e:	dd1c      	ble.n	17e8a <_dtoa_r+0x74a>
   17e50:	9a16      	ldr	r2, [sp, #88]	; 0x58
   17e52:	2a00      	cmp	r2, #0
   17e54:	f000 82e9 	beq.w	1842a <_dtoa_r+0xcea>
   17e58:	2f00      	cmp	r7, #0
   17e5a:	dd12      	ble.n	17e82 <_dtoa_r+0x742>
   17e5c:	990c      	ldr	r1, [sp, #48]	; 0x30
   17e5e:	463a      	mov	r2, r7
   17e60:	4620      	mov	r0, r4
   17e62:	f002 f821 	bl	19ea8 <__pow5mult>
   17e66:	465a      	mov	r2, fp
   17e68:	900c      	str	r0, [sp, #48]	; 0x30
   17e6a:	4620      	mov	r0, r4
   17e6c:	990c      	ldr	r1, [sp, #48]	; 0x30
   17e6e:	f001 ff33 	bl	19cd8 <__multiply>
   17e72:	4659      	mov	r1, fp
   17e74:	4603      	mov	r3, r0
   17e76:	4620      	mov	r0, r4
   17e78:	9303      	str	r3, [sp, #12]
   17e7a:	f001 fd99 	bl	199b0 <_Bfree>
   17e7e:	9b03      	ldr	r3, [sp, #12]
   17e80:	469b      	mov	fp, r3
   17e82:	9b15      	ldr	r3, [sp, #84]	; 0x54
   17e84:	1bda      	subs	r2, r3, r7
   17e86:	f040 8311 	bne.w	184ac <_dtoa_r+0xd6c>
   17e8a:	2101      	movs	r1, #1
   17e8c:	4620      	mov	r0, r4
   17e8e:	f001 ffbd 	bl	19e0c <__i2b>
   17e92:	9006      	str	r0, [sp, #24]
   17e94:	9817      	ldr	r0, [sp, #92]	; 0x5c
   17e96:	2800      	cmp	r0, #0
   17e98:	dd05      	ble.n	17ea6 <_dtoa_r+0x766>
   17e9a:	9906      	ldr	r1, [sp, #24]
   17e9c:	4620      	mov	r0, r4
   17e9e:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   17ea0:	f002 f802 	bl	19ea8 <__pow5mult>
   17ea4:	9006      	str	r0, [sp, #24]
   17ea6:	992a      	ldr	r1, [sp, #168]	; 0xa8
   17ea8:	2901      	cmp	r1, #1
   17eaa:	f340 810a 	ble.w	180c2 <_dtoa_r+0x982>
   17eae:	2700      	movs	r7, #0
   17eb0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   17eb2:	2b00      	cmp	r3, #0
   17eb4:	f040 8261 	bne.w	1837a <_dtoa_r+0xc3a>
   17eb8:	2301      	movs	r3, #1
   17eba:	4453      	add	r3, sl
   17ebc:	f013 031f 	ands.w	r3, r3, #31
   17ec0:	f040 812a 	bne.w	18118 <_dtoa_r+0x9d8>
   17ec4:	231c      	movs	r3, #28
   17ec6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   17ec8:	449a      	add	sl, r3
   17eca:	18ed      	adds	r5, r5, r3
   17ecc:	18d2      	adds	r2, r2, r3
   17ece:	920f      	str	r2, [sp, #60]	; 0x3c
   17ed0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   17ed2:	2b00      	cmp	r3, #0
   17ed4:	dd05      	ble.n	17ee2 <_dtoa_r+0x7a2>
   17ed6:	4659      	mov	r1, fp
   17ed8:	461a      	mov	r2, r3
   17eda:	4620      	mov	r0, r4
   17edc:	f001 fe9e 	bl	19c1c <__lshift>
   17ee0:	4683      	mov	fp, r0
   17ee2:	f1ba 0f00 	cmp.w	sl, #0
   17ee6:	dd05      	ble.n	17ef4 <_dtoa_r+0x7b4>
   17ee8:	9906      	ldr	r1, [sp, #24]
   17eea:	4652      	mov	r2, sl
   17eec:	4620      	mov	r0, r4
   17eee:	f001 fe95 	bl	19c1c <__lshift>
   17ef2:	9006      	str	r0, [sp, #24]
   17ef4:	9818      	ldr	r0, [sp, #96]	; 0x60
   17ef6:	2800      	cmp	r0, #0
   17ef8:	f040 8229 	bne.w	1834e <_dtoa_r+0xc0e>
   17efc:	982a      	ldr	r0, [sp, #168]	; 0xa8
   17efe:	9908      	ldr	r1, [sp, #32]
   17f00:	2802      	cmp	r0, #2
   17f02:	bfd4      	ite	le
   17f04:	2300      	movle	r3, #0
   17f06:	2301      	movgt	r3, #1
   17f08:	2900      	cmp	r1, #0
   17f0a:	bfcc      	ite	gt
   17f0c:	2300      	movgt	r3, #0
   17f0e:	f003 0301 	andle.w	r3, r3, #1
   17f12:	2b00      	cmp	r3, #0
   17f14:	f000 810c 	beq.w	18130 <_dtoa_r+0x9f0>
   17f18:	2900      	cmp	r1, #0
   17f1a:	f040 808c 	bne.w	18036 <_dtoa_r+0x8f6>
   17f1e:	2205      	movs	r2, #5
   17f20:	9906      	ldr	r1, [sp, #24]
   17f22:	9b08      	ldr	r3, [sp, #32]
   17f24:	4620      	mov	r0, r4
   17f26:	f001 ff7b 	bl	19e20 <__multadd>
   17f2a:	9006      	str	r0, [sp, #24]
   17f2c:	4658      	mov	r0, fp
   17f2e:	9906      	ldr	r1, [sp, #24]
   17f30:	f001 fc04 	bl	1973c <__mcmp>
   17f34:	2800      	cmp	r0, #0
   17f36:	dd7e      	ble.n	18036 <_dtoa_r+0x8f6>
   17f38:	9d10      	ldr	r5, [sp, #64]	; 0x40
   17f3a:	3601      	adds	r6, #1
   17f3c:	2700      	movs	r7, #0
   17f3e:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
   17f42:	2331      	movs	r3, #49	; 0x31
   17f44:	f805 3b01 	strb.w	r3, [r5], #1
   17f48:	9906      	ldr	r1, [sp, #24]
   17f4a:	4620      	mov	r0, r4
   17f4c:	f001 fd30 	bl	199b0 <_Bfree>
   17f50:	f1ba 0f00 	cmp.w	sl, #0
   17f54:	f000 80d5 	beq.w	18102 <_dtoa_r+0x9c2>
   17f58:	1e3b      	subs	r3, r7, #0
   17f5a:	bf18      	it	ne
   17f5c:	2301      	movne	r3, #1
   17f5e:	4557      	cmp	r7, sl
   17f60:	bf0c      	ite	eq
   17f62:	2300      	moveq	r3, #0
   17f64:	f003 0301 	andne.w	r3, r3, #1
   17f68:	2b00      	cmp	r3, #0
   17f6a:	f040 80d0 	bne.w	1810e <_dtoa_r+0x9ce>
   17f6e:	4651      	mov	r1, sl
   17f70:	4620      	mov	r0, r4
   17f72:	f001 fd1d 	bl	199b0 <_Bfree>
   17f76:	9612      	str	r6, [sp, #72]	; 0x48
   17f78:	4620      	mov	r0, r4
   17f7a:	4659      	mov	r1, fp
   17f7c:	f001 fd18 	bl	199b0 <_Bfree>
   17f80:	9a12      	ldr	r2, [sp, #72]	; 0x48
   17f82:	1c53      	adds	r3, r2, #1
   17f84:	2200      	movs	r2, #0
   17f86:	702a      	strb	r2, [r5, #0]
   17f88:	982c      	ldr	r0, [sp, #176]	; 0xb0
   17f8a:	992e      	ldr	r1, [sp, #184]	; 0xb8
   17f8c:	6003      	str	r3, [r0, #0]
   17f8e:	2900      	cmp	r1, #0
   17f90:	f000 81d4 	beq.w	1833c <_dtoa_r+0xbfc>
   17f94:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
   17f96:	9810      	ldr	r0, [sp, #64]	; 0x40
   17f98:	6015      	str	r5, [r2, #0]
   17f9a:	e412      	b.n	177c2 <_dtoa_r+0x82>
   17f9c:	2010      	movs	r0, #16
   17f9e:	f000 ffd5 	bl	18f4c <malloc>
   17fa2:	60c6      	str	r6, [r0, #12]
   17fa4:	6046      	str	r6, [r0, #4]
   17fa6:	6086      	str	r6, [r0, #8]
   17fa8:	6006      	str	r6, [r0, #0]
   17faa:	4606      	mov	r6, r0
   17fac:	6260      	str	r0, [r4, #36]	; 0x24
   17fae:	f7ff bbd2 	b.w	17756 <_dtoa_r+0x16>
   17fb2:	980f      	ldr	r0, [sp, #60]	; 0x3c
   17fb4:	4271      	negs	r1, r6
   17fb6:	2200      	movs	r2, #0
   17fb8:	9115      	str	r1, [sp, #84]	; 0x54
   17fba:	1b80      	subs	r0, r0, r6
   17fbc:	9217      	str	r2, [sp, #92]	; 0x5c
   17fbe:	900f      	str	r0, [sp, #60]	; 0x3c
   17fc0:	e48a      	b.n	178d8 <_dtoa_r+0x198>
   17fc2:	2100      	movs	r1, #0
   17fc4:	3e01      	subs	r6, #1
   17fc6:	9118      	str	r1, [sp, #96]	; 0x60
   17fc8:	e472      	b.n	178b0 <_dtoa_r+0x170>
   17fca:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   17fce:	f04f 0802 	mov.w	r8, #2
   17fd2:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
   17fd6:	e521      	b.n	17a1c <_dtoa_r+0x2dc>
   17fd8:	982a      	ldr	r0, [sp, #168]	; 0xa8
   17fda:	2801      	cmp	r0, #1
   17fdc:	f340 826c 	ble.w	184b8 <_dtoa_r+0xd78>
   17fe0:	9a08      	ldr	r2, [sp, #32]
   17fe2:	9815      	ldr	r0, [sp, #84]	; 0x54
   17fe4:	1e53      	subs	r3, r2, #1
   17fe6:	4298      	cmp	r0, r3
   17fe8:	f2c0 8258 	blt.w	1849c <_dtoa_r+0xd5c>
   17fec:	1ac7      	subs	r7, r0, r3
   17fee:	9b08      	ldr	r3, [sp, #32]
   17ff0:	2b00      	cmp	r3, #0
   17ff2:	bfa8      	it	ge
   17ff4:	9d0f      	ldrge	r5, [sp, #60]	; 0x3c
   17ff6:	f2c0 8273 	blt.w	184e0 <_dtoa_r+0xda0>
   17ffa:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   17ffc:	4620      	mov	r0, r4
   17ffe:	2101      	movs	r1, #1
   18000:	449a      	add	sl, r3
   18002:	18d2      	adds	r2, r2, r3
   18004:	920f      	str	r2, [sp, #60]	; 0x3c
   18006:	f001 ff01 	bl	19e0c <__i2b>
   1800a:	900c      	str	r0, [sp, #48]	; 0x30
   1800c:	e708      	b.n	17e20 <_dtoa_r+0x6e0>
   1800e:	9b08      	ldr	r3, [sp, #32]
   18010:	b973      	cbnz	r3, 18030 <_dtoa_r+0x8f0>
   18012:	f240 0300 	movw	r3, #0
   18016:	2200      	movs	r2, #0
   18018:	f2c4 0314 	movt	r3, #16404	; 0x4014
   1801c:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   18020:	f7fc fcb8 	bl	14994 <__aeabi_dmul>
   18024:	4642      	mov	r2, r8
   18026:	464b      	mov	r3, r9
   18028:	f002 fd44 	bl	1aab4 <__aeabi_dcmpge>
   1802c:	2800      	cmp	r0, #0
   1802e:	d06a      	beq.n	18106 <_dtoa_r+0x9c6>
   18030:	2200      	movs	r2, #0
   18032:	9206      	str	r2, [sp, #24]
   18034:	920c      	str	r2, [sp, #48]	; 0x30
   18036:	9b2b      	ldr	r3, [sp, #172]	; 0xac
   18038:	2700      	movs	r7, #0
   1803a:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
   1803e:	43de      	mvns	r6, r3
   18040:	9d10      	ldr	r5, [sp, #64]	; 0x40
   18042:	e781      	b.n	17f48 <_dtoa_r+0x808>
   18044:	2100      	movs	r1, #0
   18046:	9116      	str	r1, [sp, #88]	; 0x58
   18048:	982b      	ldr	r0, [sp, #172]	; 0xac
   1804a:	2800      	cmp	r0, #0
   1804c:	f340 819f 	ble.w	1838e <_dtoa_r+0xc4e>
   18050:	982b      	ldr	r0, [sp, #172]	; 0xac
   18052:	4601      	mov	r1, r0
   18054:	9011      	str	r0, [sp, #68]	; 0x44
   18056:	9008      	str	r0, [sp, #32]
   18058:	6a65      	ldr	r5, [r4, #36]	; 0x24
   1805a:	2200      	movs	r2, #0
   1805c:	2917      	cmp	r1, #23
   1805e:	606a      	str	r2, [r5, #4]
   18060:	f240 82ab 	bls.w	185ba <_dtoa_r+0xe7a>
   18064:	2304      	movs	r3, #4
   18066:	005b      	lsls	r3, r3, #1
   18068:	3201      	adds	r2, #1
   1806a:	f103 0014 	add.w	r0, r3, #20
   1806e:	4288      	cmp	r0, r1
   18070:	d9f9      	bls.n	18066 <_dtoa_r+0x926>
   18072:	9b08      	ldr	r3, [sp, #32]
   18074:	606a      	str	r2, [r5, #4]
   18076:	2b0e      	cmp	r3, #14
   18078:	bf8c      	ite	hi
   1807a:	2700      	movhi	r7, #0
   1807c:	f007 0701 	andls.w	r7, r7, #1
   18080:	e49d      	b.n	179be <_dtoa_r+0x27e>
   18082:	2201      	movs	r2, #1
   18084:	9216      	str	r2, [sp, #88]	; 0x58
   18086:	9b2b      	ldr	r3, [sp, #172]	; 0xac
   18088:	18f3      	adds	r3, r6, r3
   1808a:	9311      	str	r3, [sp, #68]	; 0x44
   1808c:	1c59      	adds	r1, r3, #1
   1808e:	2900      	cmp	r1, #0
   18090:	bfc8      	it	gt
   18092:	9108      	strgt	r1, [sp, #32]
   18094:	dce0      	bgt.n	18058 <_dtoa_r+0x918>
   18096:	290e      	cmp	r1, #14
   18098:	bf8c      	ite	hi
   1809a:	2700      	movhi	r7, #0
   1809c:	f007 0701 	andls.w	r7, r7, #1
   180a0:	9108      	str	r1, [sp, #32]
   180a2:	e489      	b.n	179b8 <_dtoa_r+0x278>
   180a4:	2301      	movs	r3, #1
   180a6:	9316      	str	r3, [sp, #88]	; 0x58
   180a8:	e7ce      	b.n	18048 <_dtoa_r+0x908>
   180aa:	2200      	movs	r2, #0
   180ac:	9216      	str	r2, [sp, #88]	; 0x58
   180ae:	e7ea      	b.n	18086 <_dtoa_r+0x946>
   180b0:	f04f 33ff 	mov.w	r3, #4294967295
   180b4:	2700      	movs	r7, #0
   180b6:	2001      	movs	r0, #1
   180b8:	9311      	str	r3, [sp, #68]	; 0x44
   180ba:	9016      	str	r0, [sp, #88]	; 0x58
   180bc:	9308      	str	r3, [sp, #32]
   180be:	972b      	str	r7, [sp, #172]	; 0xac
   180c0:	e47a      	b.n	179b8 <_dtoa_r+0x278>
   180c2:	f1b8 0f00 	cmp.w	r8, #0
   180c6:	f47f aef2 	bne.w	17eae <_dtoa_r+0x76e>
   180ca:	f029 437f 	bic.w	r3, r9, #4278190080	; 0xff000000
   180ce:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
   180d2:	2b00      	cmp	r3, #0
   180d4:	f47f aeeb 	bne.w	17eae <_dtoa_r+0x76e>
   180d8:	f240 0300 	movw	r3, #0
   180dc:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
   180e0:	ea09 0303 	and.w	r3, r9, r3
   180e4:	2b00      	cmp	r3, #0
   180e6:	f43f aee2 	beq.w	17eae <_dtoa_r+0x76e>
   180ea:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   180ec:	f10a 0a01 	add.w	sl, sl, #1
   180f0:	2701      	movs	r7, #1
   180f2:	3201      	adds	r2, #1
   180f4:	920f      	str	r2, [sp, #60]	; 0x3c
   180f6:	e6db      	b.n	17eb0 <_dtoa_r+0x770>
   180f8:	4635      	mov	r5, r6
   180fa:	465c      	mov	r4, fp
   180fc:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
   180fe:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
   18102:	9612      	str	r6, [sp, #72]	; 0x48
   18104:	e738      	b.n	17f78 <_dtoa_r+0x838>
   18106:	2000      	movs	r0, #0
   18108:	9006      	str	r0, [sp, #24]
   1810a:	900c      	str	r0, [sp, #48]	; 0x30
   1810c:	e714      	b.n	17f38 <_dtoa_r+0x7f8>
   1810e:	4639      	mov	r1, r7
   18110:	4620      	mov	r0, r4
   18112:	f001 fc4d 	bl	199b0 <_Bfree>
   18116:	e72a      	b.n	17f6e <_dtoa_r+0x82e>
   18118:	f1c3 0320 	rsb	r3, r3, #32
   1811c:	2b04      	cmp	r3, #4
   1811e:	f340 8254 	ble.w	185ca <_dtoa_r+0xe8a>
   18122:	990f      	ldr	r1, [sp, #60]	; 0x3c
   18124:	3b04      	subs	r3, #4
   18126:	449a      	add	sl, r3
   18128:	18ed      	adds	r5, r5, r3
   1812a:	18c9      	adds	r1, r1, r3
   1812c:	910f      	str	r1, [sp, #60]	; 0x3c
   1812e:	e6cf      	b.n	17ed0 <_dtoa_r+0x790>
   18130:	9916      	ldr	r1, [sp, #88]	; 0x58
   18132:	2900      	cmp	r1, #0
   18134:	f000 8131 	beq.w	1839a <_dtoa_r+0xc5a>
   18138:	2d00      	cmp	r5, #0
   1813a:	dd05      	ble.n	18148 <_dtoa_r+0xa08>
   1813c:	990c      	ldr	r1, [sp, #48]	; 0x30
   1813e:	462a      	mov	r2, r5
   18140:	4620      	mov	r0, r4
   18142:	f001 fd6b 	bl	19c1c <__lshift>
   18146:	900c      	str	r0, [sp, #48]	; 0x30
   18148:	2f00      	cmp	r7, #0
   1814a:	f040 81ea 	bne.w	18522 <_dtoa_r+0xde2>
   1814e:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
   18152:	9d10      	ldr	r5, [sp, #64]	; 0x40
   18154:	2301      	movs	r3, #1
   18156:	f008 0001 	and.w	r0, r8, #1
   1815a:	9f0c      	ldr	r7, [sp, #48]	; 0x30
   1815c:	9011      	str	r0, [sp, #68]	; 0x44
   1815e:	950f      	str	r5, [sp, #60]	; 0x3c
   18160:	461d      	mov	r5, r3
   18162:	960c      	str	r6, [sp, #48]	; 0x30
   18164:	9906      	ldr	r1, [sp, #24]
   18166:	4658      	mov	r0, fp
   18168:	f7ff fa5a 	bl	17620 <quorem>
   1816c:	4639      	mov	r1, r7
   1816e:	3030      	adds	r0, #48	; 0x30
   18170:	900b      	str	r0, [sp, #44]	; 0x2c
   18172:	4658      	mov	r0, fp
   18174:	f001 fae2 	bl	1973c <__mcmp>
   18178:	9906      	ldr	r1, [sp, #24]
   1817a:	4652      	mov	r2, sl
   1817c:	4606      	mov	r6, r0
   1817e:	4620      	mov	r0, r4
   18180:	f001 fcd0 	bl	19b24 <__mdiff>
   18184:	68c3      	ldr	r3, [r0, #12]
   18186:	4680      	mov	r8, r0
   18188:	2b00      	cmp	r3, #0
   1818a:	d03d      	beq.n	18208 <_dtoa_r+0xac8>
   1818c:	f04f 0901 	mov.w	r9, #1
   18190:	4641      	mov	r1, r8
   18192:	4620      	mov	r0, r4
   18194:	f001 fc0c 	bl	199b0 <_Bfree>
   18198:	992a      	ldr	r1, [sp, #168]	; 0xa8
   1819a:	ea59 0101 	orrs.w	r1, r9, r1
   1819e:	d103      	bne.n	181a8 <_dtoa_r+0xa68>
   181a0:	9a11      	ldr	r2, [sp, #68]	; 0x44
   181a2:	2a00      	cmp	r2, #0
   181a4:	f000 81eb 	beq.w	1857e <_dtoa_r+0xe3e>
   181a8:	2e00      	cmp	r6, #0
   181aa:	f2c0 819e 	blt.w	184ea <_dtoa_r+0xdaa>
   181ae:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
   181b0:	4332      	orrs	r2, r6
   181b2:	d103      	bne.n	181bc <_dtoa_r+0xa7c>
   181b4:	9b11      	ldr	r3, [sp, #68]	; 0x44
   181b6:	2b00      	cmp	r3, #0
   181b8:	f000 8197 	beq.w	184ea <_dtoa_r+0xdaa>
   181bc:	f1b9 0f00 	cmp.w	r9, #0
   181c0:	f300 81ce 	bgt.w	18560 <_dtoa_r+0xe20>
   181c4:	990f      	ldr	r1, [sp, #60]	; 0x3c
   181c6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   181c8:	f801 2b01 	strb.w	r2, [r1], #1
   181cc:	9b08      	ldr	r3, [sp, #32]
   181ce:	910f      	str	r1, [sp, #60]	; 0x3c
   181d0:	429d      	cmp	r5, r3
   181d2:	f000 81c2 	beq.w	1855a <_dtoa_r+0xe1a>
   181d6:	4659      	mov	r1, fp
   181d8:	220a      	movs	r2, #10
   181da:	2300      	movs	r3, #0
   181dc:	4620      	mov	r0, r4
   181de:	f001 fe1f 	bl	19e20 <__multadd>
   181e2:	4557      	cmp	r7, sl
   181e4:	4639      	mov	r1, r7
   181e6:	4683      	mov	fp, r0
   181e8:	d014      	beq.n	18214 <_dtoa_r+0xad4>
   181ea:	220a      	movs	r2, #10
   181ec:	2300      	movs	r3, #0
   181ee:	4620      	mov	r0, r4
   181f0:	3501      	adds	r5, #1
   181f2:	f001 fe15 	bl	19e20 <__multadd>
   181f6:	4651      	mov	r1, sl
   181f8:	220a      	movs	r2, #10
   181fa:	2300      	movs	r3, #0
   181fc:	4607      	mov	r7, r0
   181fe:	4620      	mov	r0, r4
   18200:	f001 fe0e 	bl	19e20 <__multadd>
   18204:	4682      	mov	sl, r0
   18206:	e7ad      	b.n	18164 <_dtoa_r+0xa24>
   18208:	4658      	mov	r0, fp
   1820a:	4641      	mov	r1, r8
   1820c:	f001 fa96 	bl	1973c <__mcmp>
   18210:	4681      	mov	r9, r0
   18212:	e7bd      	b.n	18190 <_dtoa_r+0xa50>
   18214:	4620      	mov	r0, r4
   18216:	220a      	movs	r2, #10
   18218:	2300      	movs	r3, #0
   1821a:	3501      	adds	r5, #1
   1821c:	f001 fe00 	bl	19e20 <__multadd>
   18220:	4607      	mov	r7, r0
   18222:	4682      	mov	sl, r0
   18224:	e79e      	b.n	18164 <_dtoa_r+0xa24>
   18226:	9612      	str	r6, [sp, #72]	; 0x48
   18228:	f8dd c020 	ldr.w	ip, [sp, #32]
   1822c:	e459      	b.n	17ae2 <_dtoa_r+0x3a2>
   1822e:	4275      	negs	r5, r6
   18230:	2d00      	cmp	r5, #0
   18232:	f040 8101 	bne.w	18438 <_dtoa_r+0xcf8>
   18236:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
   1823a:	f04f 0802 	mov.w	r8, #2
   1823e:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   18242:	e40c      	b.n	17a5e <_dtoa_r+0x31e>
   18244:	f64f 2108 	movw	r1, #64008	; 0xfa08
   18248:	4642      	mov	r2, r8
   1824a:	f2c0 0102 	movt	r1, #2
   1824e:	464b      	mov	r3, r9
   18250:	eb01 01cc 	add.w	r1, r1, ip, lsl #3
   18254:	f8cd c00c 	str.w	ip, [sp, #12]
   18258:	9d10      	ldr	r5, [sp, #64]	; 0x40
   1825a:	e951 0102 	ldrd	r0, r1, [r1, #-8]
   1825e:	f7fc fb99 	bl	14994 <__aeabi_dmul>
   18262:	e9cd 011a 	strd	r0, r1, [sp, #104]	; 0x68
   18266:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   1826a:	f002 fc37 	bl	1aadc <__aeabi_d2iz>
   1826e:	4607      	mov	r7, r0
   18270:	f7fc fb2a 	bl	148c8 <__aeabi_i2d>
   18274:	460b      	mov	r3, r1
   18276:	4602      	mov	r2, r0
   18278:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   1827c:	f7fc f9d6 	bl	1462c <__aeabi_dsub>
   18280:	f107 0330 	add.w	r3, r7, #48	; 0x30
   18284:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   18288:	f805 3b01 	strb.w	r3, [r5], #1
   1828c:	f8dd c00c 	ldr.w	ip, [sp, #12]
   18290:	f1bc 0f01 	cmp.w	ip, #1
   18294:	d029      	beq.n	182ea <_dtoa_r+0xbaa>
   18296:	46d1      	mov	r9, sl
   18298:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   1829c:	46b2      	mov	sl, r6
   1829e:	9e10      	ldr	r6, [sp, #64]	; 0x40
   182a0:	951c      	str	r5, [sp, #112]	; 0x70
   182a2:	2701      	movs	r7, #1
   182a4:	4665      	mov	r5, ip
   182a6:	46a0      	mov	r8, r4
   182a8:	f240 0300 	movw	r3, #0
   182ac:	2200      	movs	r2, #0
   182ae:	f2c4 0324 	movt	r3, #16420	; 0x4024
   182b2:	f7fc fb6f 	bl	14994 <__aeabi_dmul>
   182b6:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   182ba:	f002 fc0f 	bl	1aadc <__aeabi_d2iz>
   182be:	4604      	mov	r4, r0
   182c0:	f7fc fb02 	bl	148c8 <__aeabi_i2d>
   182c4:	3430      	adds	r4, #48	; 0x30
   182c6:	4602      	mov	r2, r0
   182c8:	460b      	mov	r3, r1
   182ca:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   182ce:	f7fc f9ad 	bl	1462c <__aeabi_dsub>
   182d2:	55f4      	strb	r4, [r6, r7]
   182d4:	3701      	adds	r7, #1
   182d6:	42af      	cmp	r7, r5
   182d8:	d1e6      	bne.n	182a8 <_dtoa_r+0xb68>
   182da:	9d1c      	ldr	r5, [sp, #112]	; 0x70
   182dc:	3f01      	subs	r7, #1
   182de:	4656      	mov	r6, sl
   182e0:	4644      	mov	r4, r8
   182e2:	46ca      	mov	sl, r9
   182e4:	19ed      	adds	r5, r5, r7
   182e6:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   182ea:	f240 0300 	movw	r3, #0
   182ee:	2200      	movs	r2, #0
   182f0:	f6c3 73e0 	movt	r3, #16352	; 0x3fe0
   182f4:	e9dd 011a 	ldrd	r0, r1, [sp, #104]	; 0x68
   182f8:	f7fc f99a 	bl	14630 <__adddf3>
   182fc:	4602      	mov	r2, r0
   182fe:	460b      	mov	r3, r1
   18300:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   18304:	f002 fbe0 	bl	1aac8 <__aeabi_dcmpgt>
   18308:	b9f0      	cbnz	r0, 18348 <_dtoa_r+0xc08>
   1830a:	f240 0100 	movw	r1, #0
   1830e:	e9dd 231a 	ldrd	r2, r3, [sp, #104]	; 0x68
   18312:	2000      	movs	r0, #0
   18314:	f6c3 71e0 	movt	r1, #16352	; 0x3fe0
   18318:	f7fc f988 	bl	1462c <__aeabi_dsub>
   1831c:	4602      	mov	r2, r0
   1831e:	460b      	mov	r3, r1
   18320:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   18324:	f002 fbb2 	bl	1aa8c <__aeabi_dcmplt>
   18328:	2800      	cmp	r0, #0
   1832a:	f43f acac 	beq.w	17c86 <_dtoa_r+0x546>
   1832e:	462b      	mov	r3, r5
   18330:	461d      	mov	r5, r3
   18332:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
   18336:	2a30      	cmp	r2, #48	; 0x30
   18338:	d0fa      	beq.n	18330 <_dtoa_r+0xbf0>
   1833a:	e61d      	b.n	17f78 <_dtoa_r+0x838>
   1833c:	9810      	ldr	r0, [sp, #64]	; 0x40
   1833e:	f7ff ba40 	b.w	177c2 <_dtoa_r+0x82>
   18342:	f8dd b068 	ldr.w	fp, [sp, #104]	; 0x68
   18346:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   18348:	9e12      	ldr	r6, [sp, #72]	; 0x48
   1834a:	9910      	ldr	r1, [sp, #64]	; 0x40
   1834c:	e550      	b.n	17df0 <_dtoa_r+0x6b0>
   1834e:	4658      	mov	r0, fp
   18350:	9906      	ldr	r1, [sp, #24]
   18352:	f001 f9f3 	bl	1973c <__mcmp>
   18356:	2800      	cmp	r0, #0
   18358:	f6bf add0 	bge.w	17efc <_dtoa_r+0x7bc>
   1835c:	4659      	mov	r1, fp
   1835e:	4620      	mov	r0, r4
   18360:	220a      	movs	r2, #10
   18362:	2300      	movs	r3, #0
   18364:	f001 fd5c 	bl	19e20 <__multadd>
   18368:	9916      	ldr	r1, [sp, #88]	; 0x58
   1836a:	3e01      	subs	r6, #1
   1836c:	4683      	mov	fp, r0
   1836e:	2900      	cmp	r1, #0
   18370:	f040 8119 	bne.w	185a6 <_dtoa_r+0xe66>
   18374:	9a11      	ldr	r2, [sp, #68]	; 0x44
   18376:	9208      	str	r2, [sp, #32]
   18378:	e5c0      	b.n	17efc <_dtoa_r+0x7bc>
   1837a:	9806      	ldr	r0, [sp, #24]
   1837c:	6903      	ldr	r3, [r0, #16]
   1837e:	eb00 0383 	add.w	r3, r0, r3, lsl #2
   18382:	6918      	ldr	r0, [r3, #16]
   18384:	f001 f988 	bl	19698 <__hi0bits>
   18388:	f1c0 0320 	rsb	r3, r0, #32
   1838c:	e595      	b.n	17eba <_dtoa_r+0x77a>
   1838e:	2101      	movs	r1, #1
   18390:	9111      	str	r1, [sp, #68]	; 0x44
   18392:	9108      	str	r1, [sp, #32]
   18394:	912b      	str	r1, [sp, #172]	; 0xac
   18396:	f7ff bb0f 	b.w	179b8 <_dtoa_r+0x278>
   1839a:	9d10      	ldr	r5, [sp, #64]	; 0x40
   1839c:	46b1      	mov	r9, r6
   1839e:	9f16      	ldr	r7, [sp, #88]	; 0x58
   183a0:	46aa      	mov	sl, r5
   183a2:	f8dd 8018 	ldr.w	r8, [sp, #24]
   183a6:	9e08      	ldr	r6, [sp, #32]
   183a8:	e002      	b.n	183b0 <_dtoa_r+0xc70>
   183aa:	f001 fd39 	bl	19e20 <__multadd>
   183ae:	4683      	mov	fp, r0
   183b0:	4641      	mov	r1, r8
   183b2:	4658      	mov	r0, fp
   183b4:	f7ff f934 	bl	17620 <quorem>
   183b8:	3501      	adds	r5, #1
   183ba:	220a      	movs	r2, #10
   183bc:	2300      	movs	r3, #0
   183be:	4659      	mov	r1, fp
   183c0:	f100 0c30 	add.w	ip, r0, #48	; 0x30
   183c4:	f80a c007 	strb.w	ip, [sl, r7]
   183c8:	3701      	adds	r7, #1
   183ca:	4620      	mov	r0, r4
   183cc:	42be      	cmp	r6, r7
   183ce:	dcec      	bgt.n	183aa <_dtoa_r+0xc6a>
   183d0:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
   183d4:	464e      	mov	r6, r9
   183d6:	2700      	movs	r7, #0
   183d8:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
   183dc:	4659      	mov	r1, fp
   183de:	2201      	movs	r2, #1
   183e0:	4620      	mov	r0, r4
   183e2:	f001 fc1b 	bl	19c1c <__lshift>
   183e6:	9906      	ldr	r1, [sp, #24]
   183e8:	4683      	mov	fp, r0
   183ea:	f001 f9a7 	bl	1973c <__mcmp>
   183ee:	2800      	cmp	r0, #0
   183f0:	dd0f      	ble.n	18412 <_dtoa_r+0xcd2>
   183f2:	9910      	ldr	r1, [sp, #64]	; 0x40
   183f4:	e000      	b.n	183f8 <_dtoa_r+0xcb8>
   183f6:	461d      	mov	r5, r3
   183f8:	f815 2c01 	ldrb.w	r2, [r5, #-1]
   183fc:	1e6b      	subs	r3, r5, #1
   183fe:	2a39      	cmp	r2, #57	; 0x39
   18400:	f040 808c 	bne.w	1851c <_dtoa_r+0xddc>
   18404:	428b      	cmp	r3, r1
   18406:	d1f6      	bne.n	183f6 <_dtoa_r+0xcb6>
   18408:	9910      	ldr	r1, [sp, #64]	; 0x40
   1840a:	2331      	movs	r3, #49	; 0x31
   1840c:	3601      	adds	r6, #1
   1840e:	700b      	strb	r3, [r1, #0]
   18410:	e59a      	b.n	17f48 <_dtoa_r+0x808>
   18412:	d103      	bne.n	1841c <_dtoa_r+0xcdc>
   18414:	980b      	ldr	r0, [sp, #44]	; 0x2c
   18416:	f010 0f01 	tst.w	r0, #1
   1841a:	d1ea      	bne.n	183f2 <_dtoa_r+0xcb2>
   1841c:	462b      	mov	r3, r5
   1841e:	461d      	mov	r5, r3
   18420:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
   18424:	2a30      	cmp	r2, #48	; 0x30
   18426:	d0fa      	beq.n	1841e <_dtoa_r+0xcde>
   18428:	e58e      	b.n	17f48 <_dtoa_r+0x808>
   1842a:	4659      	mov	r1, fp
   1842c:	9a15      	ldr	r2, [sp, #84]	; 0x54
   1842e:	4620      	mov	r0, r4
   18430:	f001 fd3a 	bl	19ea8 <__pow5mult>
   18434:	4683      	mov	fp, r0
   18436:	e528      	b.n	17e8a <_dtoa_r+0x74a>
   18438:	f005 030f 	and.w	r3, r5, #15
   1843c:	f64f 2208 	movw	r2, #64008	; 0xfa08
   18440:	f2c0 0202 	movt	r2, #2
   18444:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
   18448:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   1844c:	e9d3 2300 	ldrd	r2, r3, [r3]
   18450:	f7fc faa0 	bl	14994 <__aeabi_dmul>
   18454:	112d      	asrs	r5, r5, #4
   18456:	bf08      	it	eq
   18458:	f04f 0802 	moveq.w	r8, #2
   1845c:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   18460:	f43f aafd 	beq.w	17a5e <_dtoa_r+0x31e>
   18464:	f64f 27e0 	movw	r7, #64224	; 0xfae0
   18468:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
   1846c:	f04f 0802 	mov.w	r8, #2
   18470:	f2c0 0702 	movt	r7, #2
   18474:	f015 0f01 	tst.w	r5, #1
   18478:	4610      	mov	r0, r2
   1847a:	4619      	mov	r1, r3
   1847c:	d007      	beq.n	1848e <_dtoa_r+0xd4e>
   1847e:	e9d7 2300 	ldrd	r2, r3, [r7]
   18482:	f108 0801 	add.w	r8, r8, #1
   18486:	f7fc fa85 	bl	14994 <__aeabi_dmul>
   1848a:	4602      	mov	r2, r0
   1848c:	460b      	mov	r3, r1
   1848e:	3708      	adds	r7, #8
   18490:	106d      	asrs	r5, r5, #1
   18492:	d1ef      	bne.n	18474 <_dtoa_r+0xd34>
   18494:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
   18498:	f7ff bae1 	b.w	17a5e <_dtoa_r+0x31e>
   1849c:	9915      	ldr	r1, [sp, #84]	; 0x54
   1849e:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   184a0:	1a5b      	subs	r3, r3, r1
   184a2:	18c9      	adds	r1, r1, r3
   184a4:	18d2      	adds	r2, r2, r3
   184a6:	9115      	str	r1, [sp, #84]	; 0x54
   184a8:	9217      	str	r2, [sp, #92]	; 0x5c
   184aa:	e5a0      	b.n	17fee <_dtoa_r+0x8ae>
   184ac:	4659      	mov	r1, fp
   184ae:	4620      	mov	r0, r4
   184b0:	f001 fcfa 	bl	19ea8 <__pow5mult>
   184b4:	4683      	mov	fp, r0
   184b6:	e4e8      	b.n	17e8a <_dtoa_r+0x74a>
   184b8:	9919      	ldr	r1, [sp, #100]	; 0x64
   184ba:	2900      	cmp	r1, #0
   184bc:	d047      	beq.n	1854e <_dtoa_r+0xe0e>
   184be:	f503 6386 	add.w	r3, r3, #1072	; 0x430
   184c2:	9f15      	ldr	r7, [sp, #84]	; 0x54
   184c4:	3303      	adds	r3, #3
   184c6:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
   184c8:	e597      	b.n	17ffa <_dtoa_r+0x8ba>
   184ca:	3201      	adds	r2, #1
   184cc:	b2d2      	uxtb	r2, r2
   184ce:	e49d      	b.n	17e0c <_dtoa_r+0x6cc>
   184d0:	f8dd b068 	ldr.w	fp, [sp, #104]	; 0x68
   184d4:	f8dd a070 	ldr.w	sl, [sp, #112]	; 0x70
   184d8:	9e1d      	ldr	r6, [sp, #116]	; 0x74
   184da:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   184dc:	f7ff bbd3 	b.w	17c86 <_dtoa_r+0x546>
   184e0:	990f      	ldr	r1, [sp, #60]	; 0x3c
   184e2:	2300      	movs	r3, #0
   184e4:	9808      	ldr	r0, [sp, #32]
   184e6:	1a0d      	subs	r5, r1, r0
   184e8:	e587      	b.n	17ffa <_dtoa_r+0x8ba>
   184ea:	f1b9 0f00 	cmp.w	r9, #0
   184ee:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
   184f0:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   184f2:	dd0f      	ble.n	18514 <_dtoa_r+0xdd4>
   184f4:	4659      	mov	r1, fp
   184f6:	2201      	movs	r2, #1
   184f8:	4620      	mov	r0, r4
   184fa:	f001 fb8f 	bl	19c1c <__lshift>
   184fe:	9906      	ldr	r1, [sp, #24]
   18500:	4683      	mov	fp, r0
   18502:	f001 f91b 	bl	1973c <__mcmp>
   18506:	2800      	cmp	r0, #0
   18508:	dd47      	ble.n	1859a <_dtoa_r+0xe5a>
   1850a:	990b      	ldr	r1, [sp, #44]	; 0x2c
   1850c:	2939      	cmp	r1, #57	; 0x39
   1850e:	d031      	beq.n	18574 <_dtoa_r+0xe34>
   18510:	3101      	adds	r1, #1
   18512:	910b      	str	r1, [sp, #44]	; 0x2c
   18514:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   18516:	f805 2b01 	strb.w	r2, [r5], #1
   1851a:	e515      	b.n	17f48 <_dtoa_r+0x808>
   1851c:	3201      	adds	r2, #1
   1851e:	701a      	strb	r2, [r3, #0]
   18520:	e512      	b.n	17f48 <_dtoa_r+0x808>
   18522:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   18524:	4620      	mov	r0, r4
   18526:	6851      	ldr	r1, [r2, #4]
   18528:	f001 fa5e 	bl	199e8 <_Balloc>
   1852c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1852e:	f103 010c 	add.w	r1, r3, #12
   18532:	691a      	ldr	r2, [r3, #16]
   18534:	3202      	adds	r2, #2
   18536:	0092      	lsls	r2, r2, #2
   18538:	4605      	mov	r5, r0
   1853a:	300c      	adds	r0, #12
   1853c:	f7fc ff7a 	bl	15434 <memcpy>
   18540:	4620      	mov	r0, r4
   18542:	4629      	mov	r1, r5
   18544:	2201      	movs	r2, #1
   18546:	f001 fb69 	bl	19c1c <__lshift>
   1854a:	4682      	mov	sl, r0
   1854c:	e601      	b.n	18152 <_dtoa_r+0xa12>
   1854e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   18550:	9f15      	ldr	r7, [sp, #84]	; 0x54
   18552:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
   18554:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
   18558:	e54f      	b.n	17ffa <_dtoa_r+0x8ba>
   1855a:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
   1855c:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   1855e:	e73d      	b.n	183dc <_dtoa_r+0xc9c>
   18560:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   18562:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
   18564:	2b39      	cmp	r3, #57	; 0x39
   18566:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   18568:	d004      	beq.n	18574 <_dtoa_r+0xe34>
   1856a:	980b      	ldr	r0, [sp, #44]	; 0x2c
   1856c:	1c43      	adds	r3, r0, #1
   1856e:	f805 3b01 	strb.w	r3, [r5], #1
   18572:	e4e9      	b.n	17f48 <_dtoa_r+0x808>
   18574:	2339      	movs	r3, #57	; 0x39
   18576:	f805 3b01 	strb.w	r3, [r5], #1
   1857a:	9910      	ldr	r1, [sp, #64]	; 0x40
   1857c:	e73c      	b.n	183f8 <_dtoa_r+0xcb8>
   1857e:	980b      	ldr	r0, [sp, #44]	; 0x2c
   18580:	4633      	mov	r3, r6
   18582:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
   18584:	2839      	cmp	r0, #57	; 0x39
   18586:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   18588:	d0f4      	beq.n	18574 <_dtoa_r+0xe34>
   1858a:	2b00      	cmp	r3, #0
   1858c:	dd01      	ble.n	18592 <_dtoa_r+0xe52>
   1858e:	3001      	adds	r0, #1
   18590:	900b      	str	r0, [sp, #44]	; 0x2c
   18592:	990b      	ldr	r1, [sp, #44]	; 0x2c
   18594:	f805 1b01 	strb.w	r1, [r5], #1
   18598:	e4d6      	b.n	17f48 <_dtoa_r+0x808>
   1859a:	d1bb      	bne.n	18514 <_dtoa_r+0xdd4>
   1859c:	980b      	ldr	r0, [sp, #44]	; 0x2c
   1859e:	f010 0f01 	tst.w	r0, #1
   185a2:	d0b7      	beq.n	18514 <_dtoa_r+0xdd4>
   185a4:	e7b1      	b.n	1850a <_dtoa_r+0xdca>
   185a6:	2300      	movs	r3, #0
   185a8:	990c      	ldr	r1, [sp, #48]	; 0x30
   185aa:	4620      	mov	r0, r4
   185ac:	220a      	movs	r2, #10
   185ae:	f001 fc37 	bl	19e20 <__multadd>
   185b2:	9b11      	ldr	r3, [sp, #68]	; 0x44
   185b4:	9308      	str	r3, [sp, #32]
   185b6:	900c      	str	r0, [sp, #48]	; 0x30
   185b8:	e4a0      	b.n	17efc <_dtoa_r+0x7bc>
   185ba:	9908      	ldr	r1, [sp, #32]
   185bc:	290e      	cmp	r1, #14
   185be:	bf8c      	ite	hi
   185c0:	2700      	movhi	r7, #0
   185c2:	f007 0701 	andls.w	r7, r7, #1
   185c6:	f7ff b9fa 	b.w	179be <_dtoa_r+0x27e>
   185ca:	f43f ac81 	beq.w	17ed0 <_dtoa_r+0x790>
   185ce:	331c      	adds	r3, #28
   185d0:	e479      	b.n	17ec6 <_dtoa_r+0x786>
   185d2:	2701      	movs	r7, #1
   185d4:	f7ff b98a 	b.w	178ec <_dtoa_r+0x1ac>

000185d8 <print_e>:
   185d8:	b5f0      	push	{r4, r5, r6, r7, lr}
   185da:	b08b      	sub	sp, #44	; 0x2c
   185dc:	460e      	mov	r6, r1
   185de:	2102      	movs	r1, #2
   185e0:	9c10      	ldr	r4, [sp, #64]	; 0x40
   185e2:	9100      	str	r1, [sp, #0]
   185e4:	9f12      	ldr	r7, [sp, #72]	; 0x48
   185e6:	1c61      	adds	r1, r4, #1
   185e8:	f89d 5044 	ldrb.w	r5, [sp, #68]	; 0x44
   185ec:	9101      	str	r1, [sp, #4]
   185ee:	a907      	add	r1, sp, #28
   185f0:	9102      	str	r1, [sp, #8]
   185f2:	a909      	add	r1, sp, #36	; 0x24
   185f4:	9103      	str	r1, [sp, #12]
   185f6:	a908      	add	r1, sp, #32
   185f8:	9104      	str	r1, [sp, #16]
   185fa:	f7ff f8a1 	bl	17740 <_dtoa_r>
   185fe:	f242 730f 	movw	r3, #9999	; 0x270f
   18602:	4601      	mov	r1, r0
   18604:	9807      	ldr	r0, [sp, #28]
   18606:	4298      	cmp	r0, r3
   18608:	d079      	beq.n	186fe <print_e+0x126>
   1860a:	780a      	ldrb	r2, [r1, #0]
   1860c:	4633      	mov	r3, r6
   1860e:	4327      	orrs	r7, r4
   18610:	bf08      	it	eq
   18612:	463c      	moveq	r4, r7
   18614:	f803 2b01 	strb.w	r2, [r3], #1
   18618:	d020      	beq.n	1865c <print_e+0x84>
   1861a:	222e      	movs	r2, #46	; 0x2e
   1861c:	7072      	strb	r2, [r6, #1]
   1861e:	784a      	ldrb	r2, [r1, #1]
   18620:	2c00      	cmp	r4, #0
   18622:	bfd4      	ite	le
   18624:	2700      	movle	r7, #0
   18626:	2701      	movgt	r7, #1
   18628:	3301      	adds	r3, #1
   1862a:	2a00      	cmp	r2, #0
   1862c:	bf0c      	ite	eq
   1862e:	2700      	moveq	r7, #0
   18630:	f007 0701 	andne.w	r7, r7, #1
   18634:	b197      	cbz	r7, 1865c <print_e+0x84>
   18636:	3603      	adds	r6, #3
   18638:	f806 2c01 	strb.w	r2, [r6, #-1]
   1863c:	3c01      	subs	r4, #1
   1863e:	788a      	ldrb	r2, [r1, #2]
   18640:	4633      	mov	r3, r6
   18642:	3101      	adds	r1, #1
   18644:	3601      	adds	r6, #1
   18646:	1e10      	subs	r0, r2, #0
   18648:	bf18      	it	ne
   1864a:	2001      	movne	r0, #1
   1864c:	2c00      	cmp	r4, #0
   1864e:	bfd4      	ite	le
   18650:	2000      	movle	r0, #0
   18652:	f000 0001 	andgt.w	r0, r0, #1
   18656:	2800      	cmp	r0, #0
   18658:	d1ee      	bne.n	18638 <print_e+0x60>
   1865a:	9807      	ldr	r0, [sp, #28]
   1865c:	2d67      	cmp	r5, #103	; 0x67
   1865e:	d040      	beq.n	186e2 <print_e+0x10a>
   18660:	2d47      	cmp	r5, #71	; 0x47
   18662:	d04a      	beq.n	186fa <print_e+0x122>
   18664:	2c00      	cmp	r4, #0
   18666:	dd06      	ble.n	18676 <print_e+0x9e>
   18668:	2200      	movs	r2, #0
   1866a:	2130      	movs	r1, #48	; 0x30
   1866c:	5499      	strb	r1, [r3, r2]
   1866e:	3201      	adds	r2, #1
   18670:	42a2      	cmp	r2, r4
   18672:	d1fb      	bne.n	1866c <print_e+0x94>
   18674:	189b      	adds	r3, r3, r2
   18676:	461c      	mov	r4, r3
   18678:	3801      	subs	r0, #1
   1867a:	f804 5b01 	strb.w	r5, [r4], #1
   1867e:	d436      	bmi.n	186ee <print_e+0x116>
   18680:	3401      	adds	r4, #1
   18682:	4602      	mov	r2, r0
   18684:	212b      	movs	r1, #43	; 0x2b
   18686:	7059      	strb	r1, [r3, #1]
   18688:	2a63      	cmp	r2, #99	; 0x63
   1868a:	dd11      	ble.n	186b0 <print_e+0xd8>
   1868c:	f248 531f 	movw	r3, #34079	; 0x851f
   18690:	17d1      	asrs	r1, r2, #31
   18692:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
   18696:	fb83 5302 	smull	r5, r3, r3, r2
   1869a:	ebc1 1363 	rsb	r3, r1, r3, asr #5
   1869e:	f103 0230 	add.w	r2, r3, #48	; 0x30
   186a2:	f804 2b01 	strb.w	r2, [r4], #1
   186a6:	f06f 0263 	mvn.w	r2, #99	; 0x63
   186aa:	fb02 0203 	mla	r2, r2, r3, r0
   186ae:	4610      	mov	r0, r2
   186b0:	f246 6167 	movw	r1, #26215	; 0x6667
   186b4:	ea4f 7ce2 	mov.w	ip, r2, asr #31
   186b8:	f2c6 6166 	movt	r1, #26214	; 0x6666
   186bc:	4623      	mov	r3, r4
   186be:	fb81 5202 	smull	r5, r2, r1, r2
   186c2:	ebcc 02a2 	rsb	r2, ip, r2, asr #2
   186c6:	f102 0130 	add.w	r1, r2, #48	; 0x30
   186ca:	f803 1b01 	strb.w	r1, [r3], #1
   186ce:	f06f 0109 	mvn.w	r1, #9
   186d2:	fb01 0202 	mla	r2, r1, r2, r0
   186d6:	3230      	adds	r2, #48	; 0x30
   186d8:	7062      	strb	r2, [r4, #1]
   186da:	2200      	movs	r2, #0
   186dc:	705a      	strb	r2, [r3, #1]
   186de:	b00b      	add	sp, #44	; 0x2c
   186e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   186e2:	2565      	movs	r5, #101	; 0x65
   186e4:	461c      	mov	r4, r3
   186e6:	3801      	subs	r0, #1
   186e8:	f804 5b01 	strb.w	r5, [r4], #1
   186ec:	d5c8      	bpl.n	18680 <print_e+0xa8>
   186ee:	4242      	negs	r2, r0
   186f0:	212d      	movs	r1, #45	; 0x2d
   186f2:	3401      	adds	r4, #1
   186f4:	7059      	strb	r1, [r3, #1]
   186f6:	4610      	mov	r0, r2
   186f8:	e7c6      	b.n	18688 <print_e+0xb0>
   186fa:	2545      	movs	r5, #69	; 0x45
   186fc:	e7bb      	b.n	18676 <print_e+0x9e>
   186fe:	4630      	mov	r0, r6
   18700:	f7fd f8e2 	bl	158c8 <strcpy>
   18704:	e7eb      	b.n	186de <print_e+0x106>
   18706:	bf00      	nop

00018708 <_gcvt>:
   18708:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1870c:	4616      	mov	r6, r2
   1870e:	b08b      	sub	sp, #44	; 0x2c
   18710:	461d      	mov	r5, r3
   18712:	4680      	mov	r8, r0
   18714:	469b      	mov	fp, r3
   18716:	2200      	movs	r2, #0
   18718:	2300      	movs	r3, #0
   1871a:	4630      	mov	r0, r6
   1871c:	4629      	mov	r1, r5
   1871e:	9c14      	ldr	r4, [sp, #80]	; 0x50
   18720:	9f15      	ldr	r7, [sp, #84]	; 0x54
   18722:	f8dd 905c 	ldr.w	r9, [sp, #92]	; 0x5c
   18726:	f89d a058 	ldrb.w	sl, [sp, #88]	; 0x58
   1872a:	f002 f9af 	bl	1aa8c <__aeabi_dcmplt>
   1872e:	b108      	cbz	r0, 18734 <_gcvt+0x2c>
   18730:	f105 4500 	add.w	r5, r5, #2147483648	; 0x80000000
   18734:	4630      	mov	r0, r6
   18736:	2200      	movs	r2, #0
   18738:	2300      	movs	r3, #0
   1873a:	4629      	mov	r1, r5
   1873c:	f002 f99c 	bl	1aa78 <__aeabi_dcmpeq>
   18740:	2800      	cmp	r0, #0
   18742:	f040 80c5 	bne.w	188d0 <_gcvt+0x1c8>
   18746:	4630      	mov	r0, r6
   18748:	a36f      	add	r3, pc, #444	; (adr r3, 18908 <_gcvt+0x200>)
   1874a:	e9d3 2300 	ldrd	r2, r3, [r3]
   1874e:	4629      	mov	r1, r5
   18750:	f002 f9a6 	bl	1aaa0 <__aeabi_dcmple>
   18754:	2800      	cmp	r0, #0
   18756:	f040 80ab 	bne.w	188b0 <_gcvt+0x1a8>
   1875a:	4620      	mov	r0, r4
   1875c:	f001 f8b8 	bl	198d0 <_mprec_log10>
   18760:	4632      	mov	r2, r6
   18762:	462b      	mov	r3, r5
   18764:	f002 f99c 	bl	1aaa0 <__aeabi_dcmple>
   18768:	2800      	cmp	r0, #0
   1876a:	f040 80a1 	bne.w	188b0 <_gcvt+0x1a8>
   1876e:	f240 0300 	movw	r3, #0
   18772:	4630      	mov	r0, r6
   18774:	2200      	movs	r2, #0
   18776:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
   1877a:	4629      	mov	r1, r5
   1877c:	f002 f986 	bl	1aa8c <__aeabi_dcmplt>
   18780:	2800      	cmp	r0, #0
   18782:	f040 80aa 	bne.w	188da <_gcvt+0x1d2>
   18786:	4632      	mov	r2, r6
   18788:	4640      	mov	r0, r8
   1878a:	462b      	mov	r3, r5
   1878c:	2102      	movs	r1, #2
   1878e:	9401      	str	r4, [sp, #4]
   18790:	9100      	str	r1, [sp, #0]
   18792:	a909      	add	r1, sp, #36	; 0x24
   18794:	9102      	str	r1, [sp, #8]
   18796:	a908      	add	r1, sp, #32
   18798:	9103      	str	r1, [sp, #12]
   1879a:	a907      	add	r1, sp, #28
   1879c:	9104      	str	r1, [sp, #16]
   1879e:	f7fe ffcf 	bl	17740 <_dtoa_r>
   187a2:	9a09      	ldr	r2, [sp, #36]	; 0x24
   187a4:	f242 730f 	movw	r3, #9999	; 0x270f
   187a8:	429a      	cmp	r2, r3
   187aa:	f000 80a1 	beq.w	188f0 <_gcvt+0x1e8>
   187ae:	7805      	ldrb	r5, [r0, #0]
   187b0:	2d00      	cmp	r5, #0
   187b2:	f000 80a2 	beq.w	188fa <_gcvt+0x1f2>
   187b6:	2a00      	cmp	r2, #0
   187b8:	bfc8      	it	gt
   187ba:	463b      	movgt	r3, r7
   187bc:	dc02      	bgt.n	187c4 <_gcvt+0xbc>
   187be:	e09e      	b.n	188fe <_gcvt+0x1f6>
   187c0:	2a00      	cmp	r2, #0
   187c2:	dd25      	ble.n	18810 <_gcvt+0x108>
   187c4:	f803 5b01 	strb.w	r5, [r3], #1
   187c8:	3c01      	subs	r4, #1
   187ca:	9a09      	ldr	r2, [sp, #36]	; 0x24
   187cc:	3a01      	subs	r2, #1
   187ce:	9209      	str	r2, [sp, #36]	; 0x24
   187d0:	f810 5f01 	ldrb.w	r5, [r0, #1]!
   187d4:	2d00      	cmp	r5, #0
   187d6:	d1f3      	bne.n	187c0 <_gcvt+0xb8>
   187d8:	2a00      	cmp	r2, #0
   187da:	bfd4      	ite	le
   187dc:	2200      	movle	r2, #0
   187de:	2201      	movgt	r2, #1
   187e0:	2c00      	cmp	r4, #0
   187e2:	bfd4      	ite	le
   187e4:	2200      	movle	r2, #0
   187e6:	f002 0201 	andgt.w	r2, r2, #1
   187ea:	b18a      	cbz	r2, 18810 <_gcvt+0x108>
   187ec:	2130      	movs	r1, #48	; 0x30
   187ee:	f803 1b01 	strb.w	r1, [r3], #1
   187f2:	3c01      	subs	r4, #1
   187f4:	9a09      	ldr	r2, [sp, #36]	; 0x24
   187f6:	3a01      	subs	r2, #1
   187f8:	9209      	str	r2, [sp, #36]	; 0x24
   187fa:	2a00      	cmp	r2, #0
   187fc:	bfd4      	ite	le
   187fe:	2200      	movle	r2, #0
   18800:	2201      	movgt	r2, #1
   18802:	2c00      	cmp	r4, #0
   18804:	bfd4      	ite	le
   18806:	2200      	movle	r2, #0
   18808:	f002 0201 	andgt.w	r2, r2, #1
   1880c:	2a00      	cmp	r2, #0
   1880e:	d1ee      	bne.n	187ee <_gcvt+0xe6>
   18810:	f1b9 0f00 	cmp.w	r9, #0
   18814:	d102      	bne.n	1881c <_gcvt+0x114>
   18816:	7802      	ldrb	r2, [r0, #0]
   18818:	2a00      	cmp	r2, #0
   1881a:	d046      	beq.n	188aa <_gcvt+0x1a2>
   1881c:	42bb      	cmp	r3, r7
   1881e:	bf18      	it	ne
   18820:	461a      	movne	r2, r3
   18822:	d060      	beq.n	188e6 <_gcvt+0x1de>
   18824:	4613      	mov	r3, r2
   18826:	212e      	movs	r1, #46	; 0x2e
   18828:	2c00      	cmp	r4, #0
   1882a:	bfd4      	ite	le
   1882c:	f04f 0c00 	movle.w	ip, #0
   18830:	f04f 0c01 	movgt.w	ip, #1
   18834:	f803 1b01 	strb.w	r1, [r3], #1
   18838:	9909      	ldr	r1, [sp, #36]	; 0x24
   1883a:	ea1c 71d1 	ands.w	r1, ip, r1, lsr #31
   1883e:	d012      	beq.n	18866 <_gcvt+0x15e>
   18840:	3202      	adds	r2, #2
   18842:	2530      	movs	r5, #48	; 0x30
   18844:	f802 5c01 	strb.w	r5, [r2, #-1]
   18848:	3c01      	subs	r4, #1
   1884a:	9909      	ldr	r1, [sp, #36]	; 0x24
   1884c:	2c00      	cmp	r4, #0
   1884e:	bfd4      	ite	le
   18850:	f04f 0c00 	movle.w	ip, #0
   18854:	f04f 0c01 	movgt.w	ip, #1
   18858:	4613      	mov	r3, r2
   1885a:	3201      	adds	r2, #1
   1885c:	3101      	adds	r1, #1
   1885e:	9109      	str	r1, [sp, #36]	; 0x24
   18860:	ea1c 71d1 	ands.w	r1, ip, r1, lsr #31
   18864:	d1ee      	bne.n	18844 <_gcvt+0x13c>
   18866:	7802      	ldrb	r2, [r0, #0]
   18868:	2a00      	cmp	r2, #0
   1886a:	bf0c      	ite	eq
   1886c:	2100      	moveq	r1, #0
   1886e:	f00c 0101 	andne.w	r1, ip, #1
   18872:	b171      	cbz	r1, 18892 <_gcvt+0x18a>
   18874:	f803 2b01 	strb.w	r2, [r3], #1
   18878:	3c01      	subs	r4, #1
   1887a:	f810 2f01 	ldrb.w	r2, [r0, #1]!
   1887e:	1e11      	subs	r1, r2, #0
   18880:	bf18      	it	ne
   18882:	2101      	movne	r1, #1
   18884:	2c00      	cmp	r4, #0
   18886:	bfd4      	ite	le
   18888:	2100      	movle	r1, #0
   1888a:	f001 0101 	andgt.w	r1, r1, #1
   1888e:	2900      	cmp	r1, #0
   18890:	d1f0      	bne.n	18874 <_gcvt+0x16c>
   18892:	f1b9 0f00 	cmp.w	r9, #0
   18896:	d008      	beq.n	188aa <_gcvt+0x1a2>
   18898:	2c00      	cmp	r4, #0
   1889a:	dd06      	ble.n	188aa <_gcvt+0x1a2>
   1889c:	2200      	movs	r2, #0
   1889e:	2130      	movs	r1, #48	; 0x30
   188a0:	5499      	strb	r1, [r3, r2]
   188a2:	3201      	adds	r2, #1
   188a4:	42a2      	cmp	r2, r4
   188a6:	d1fb      	bne.n	188a0 <_gcvt+0x198>
   188a8:	189b      	adds	r3, r3, r2
   188aa:	2200      	movs	r2, #0
   188ac:	701a      	strb	r2, [r3, #0]
   188ae:	e00b      	b.n	188c8 <_gcvt+0x1c0>
   188b0:	4632      	mov	r2, r6
   188b2:	4640      	mov	r0, r8
   188b4:	462b      	mov	r3, r5
   188b6:	4639      	mov	r1, r7
   188b8:	3c01      	subs	r4, #1
   188ba:	f8cd a004 	str.w	sl, [sp, #4]
   188be:	f8cd 9008 	str.w	r9, [sp, #8]
   188c2:	9400      	str	r4, [sp, #0]
   188c4:	f7ff fe88 	bl	185d8 <print_e>
   188c8:	4638      	mov	r0, r7
   188ca:	b00b      	add	sp, #44	; 0x2c
   188cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   188d0:	2330      	movs	r3, #48	; 0x30
   188d2:	703b      	strb	r3, [r7, #0]
   188d4:	2300      	movs	r3, #0
   188d6:	707b      	strb	r3, [r7, #1]
   188d8:	e7f6      	b.n	188c8 <_gcvt+0x1c0>
   188da:	4632      	mov	r2, r6
   188dc:	4640      	mov	r0, r8
   188de:	462b      	mov	r3, r5
   188e0:	9401      	str	r4, [sp, #4]
   188e2:	2103      	movs	r1, #3
   188e4:	e754      	b.n	18790 <_gcvt+0x88>
   188e6:	463a      	mov	r2, r7
   188e8:	2330      	movs	r3, #48	; 0x30
   188ea:	f802 3b01 	strb.w	r3, [r2], #1
   188ee:	e799      	b.n	18824 <_gcvt+0x11c>
   188f0:	4601      	mov	r1, r0
   188f2:	4638      	mov	r0, r7
   188f4:	f7fc ffe8 	bl	158c8 <strcpy>
   188f8:	e7e6      	b.n	188c8 <_gcvt+0x1c0>
   188fa:	463b      	mov	r3, r7
   188fc:	e76c      	b.n	187d8 <_gcvt+0xd0>
   188fe:	463b      	mov	r3, r7
   18900:	e786      	b.n	18810 <_gcvt+0x108>
   18902:	bf00      	nop
   18904:	f3af 8000 	nop.w
   18908:	eb1c432d 	.word	0xeb1c432d
   1890c:	3f1a36e2 	.word	0x3f1a36e2

00018910 <ecvtbuf>:
   18910:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   18914:	b08b      	sub	sp, #44	; 0x2c
   18916:	4615      	mov	r5, r2
   18918:	461e      	mov	r6, r3
   1891a:	9c13      	ldr	r4, [sp, #76]	; 0x4c
   1891c:	4680      	mov	r8, r0
   1891e:	4689      	mov	r9, r1
   18920:	2c00      	cmp	r4, #0
   18922:	d033      	beq.n	1898c <ecvtbuf+0x7c>
   18924:	f240 130c 	movw	r3, #268	; 0x10c
   18928:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1892c:	6818      	ldr	r0, [r3, #0]
   1892e:	9912      	ldr	r1, [sp, #72]	; 0x48
   18930:	464b      	mov	r3, r9
   18932:	4642      	mov	r2, r8
   18934:	9602      	str	r6, [sp, #8]
   18936:	9501      	str	r5, [sp, #4]
   18938:	9103      	str	r1, [sp, #12]
   1893a:	2102      	movs	r1, #2
   1893c:	9100      	str	r1, [sp, #0]
   1893e:	a909      	add	r1, sp, #36	; 0x24
   18940:	9104      	str	r1, [sp, #16]
   18942:	f7fe fefd 	bl	17740 <_dtoa_r>
   18946:	9b09      	ldr	r3, [sp, #36]	; 0x24
   18948:	4298      	cmp	r0, r3
   1894a:	d237      	bcs.n	189bc <ecvtbuf+0xac>
   1894c:	4602      	mov	r2, r0
   1894e:	4621      	mov	r1, r4
   18950:	2300      	movs	r3, #0
   18952:	f810 c003 	ldrb.w	ip, [r0, r3]
   18956:	3201      	adds	r2, #1
   18958:	3101      	adds	r1, #1
   1895a:	f804 c003 	strb.w	ip, [r4, r3]
   1895e:	3301      	adds	r3, #1
   18960:	9e09      	ldr	r6, [sp, #36]	; 0x24
   18962:	4296      	cmp	r6, r2
   18964:	d8f5      	bhi.n	18952 <ecvtbuf+0x42>
   18966:	429d      	cmp	r5, r3
   18968:	dd0a      	ble.n	18980 <ecvtbuf+0x70>
   1896a:	2200      	movs	r2, #0
   1896c:	f04f 0c30 	mov.w	ip, #48	; 0x30
   18970:	f801 c002 	strb.w	ip, [r1, r2]
   18974:	3201      	adds	r2, #1
   18976:	18d0      	adds	r0, r2, r3
   18978:	4285      	cmp	r5, r0
   1897a:	dcf9      	bgt.n	18970 <ecvtbuf+0x60>
   1897c:	1aed      	subs	r5, r5, r3
   1897e:	1949      	adds	r1, r1, r5
   18980:	2300      	movs	r3, #0
   18982:	700b      	strb	r3, [r1, #0]
   18984:	4620      	mov	r0, r4
   18986:	b00b      	add	sp, #44	; 0x2c
   18988:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1898c:	f240 170c 	movw	r7, #268	; 0x10c
   18990:	f2c2 0700 	movt	r7, #8192	; 0x2000
   18994:	6838      	ldr	r0, [r7, #0]
   18996:	6b03      	ldr	r3, [r0, #48]	; 0x30
   18998:	4293      	cmp	r3, r2
   1899a:	bfc8      	it	gt
   1899c:	6b44      	ldrgt	r4, [r0, #52]	; 0x34
   1899e:	dcc6      	bgt.n	1892e <ecvtbuf+0x1e>
   189a0:	1c53      	adds	r3, r2, #1
   189a2:	6b41      	ldr	r1, [r0, #52]	; 0x34
   189a4:	461a      	mov	r2, r3
   189a6:	9307      	str	r3, [sp, #28]
   189a8:	f001 fb22 	bl	19ff0 <_realloc_r>
   189ac:	9b07      	ldr	r3, [sp, #28]
   189ae:	4604      	mov	r4, r0
   189b0:	2800      	cmp	r0, #0
   189b2:	d0e7      	beq.n	18984 <ecvtbuf+0x74>
   189b4:	6838      	ldr	r0, [r7, #0]
   189b6:	6303      	str	r3, [r0, #48]	; 0x30
   189b8:	6344      	str	r4, [r0, #52]	; 0x34
   189ba:	e7b8      	b.n	1892e <ecvtbuf+0x1e>
   189bc:	4621      	mov	r1, r4
   189be:	2300      	movs	r3, #0
   189c0:	e7d1      	b.n	18966 <ecvtbuf+0x56>
   189c2:	bf00      	nop

000189c4 <fcvtbuf>:
   189c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   189c8:	b08b      	sub	sp, #44	; 0x2c
   189ca:	4614      	mov	r4, r2
   189cc:	461e      	mov	r6, r3
   189ce:	9d15      	ldr	r5, [sp, #84]	; 0x54
   189d0:	4680      	mov	r8, r0
   189d2:	4689      	mov	r9, r1
   189d4:	f8dd a050 	ldr.w	sl, [sp, #80]	; 0x50
   189d8:	2d00      	cmp	r5, #0
   189da:	d04e      	beq.n	18a7a <fcvtbuf+0xb6>
   189dc:	f240 130c 	movw	r3, #268	; 0x10c
   189e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
   189e4:	681f      	ldr	r7, [r3, #0]
   189e6:	f240 0300 	movw	r3, #0
   189ea:	4640      	mov	r0, r8
   189ec:	4649      	mov	r1, r9
   189ee:	2200      	movs	r2, #0
   189f0:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
   189f4:	f002 f84a 	bl	1aa8c <__aeabi_dcmplt>
   189f8:	b150      	cbz	r0, 18a10 <fcvtbuf+0x4c>
   189fa:	f240 0300 	movw	r3, #0
   189fe:	4640      	mov	r0, r8
   18a00:	4649      	mov	r1, r9
   18a02:	2200      	movs	r2, #0
   18a04:	f6cb 73f0 	movt	r3, #49136	; 0xbff0
   18a08:	f002 f85e 	bl	1aac8 <__aeabi_dcmpgt>
   18a0c:	2800      	cmp	r0, #0
   18a0e:	d12d      	bne.n	18a6c <fcvtbuf+0xa8>
   18a10:	4638      	mov	r0, r7
   18a12:	4642      	mov	r2, r8
   18a14:	464b      	mov	r3, r9
   18a16:	2103      	movs	r1, #3
   18a18:	f8cd a00c 	str.w	sl, [sp, #12]
   18a1c:	9100      	str	r1, [sp, #0]
   18a1e:	a909      	add	r1, sp, #36	; 0x24
   18a20:	9401      	str	r4, [sp, #4]
   18a22:	9104      	str	r1, [sp, #16]
   18a24:	9602      	str	r6, [sp, #8]
   18a26:	f7fe fe8b 	bl	17740 <_dtoa_r>
   18a2a:	6831      	ldr	r1, [r6, #0]
   18a2c:	462a      	mov	r2, r5
   18a2e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   18a30:	4249      	negs	r1, r1
   18a32:	4298      	cmp	r0, r3
   18a34:	d207      	bcs.n	18a46 <fcvtbuf+0x82>
   18a36:	f810 3b01 	ldrb.w	r3, [r0], #1
   18a3a:	3101      	adds	r1, #1
   18a3c:	f802 3b01 	strb.w	r3, [r2], #1
   18a40:	9b09      	ldr	r3, [sp, #36]	; 0x24
   18a42:	4283      	cmp	r3, r0
   18a44:	d8f7      	bhi.n	18a36 <fcvtbuf+0x72>
   18a46:	428c      	cmp	r4, r1
   18a48:	dd0a      	ble.n	18a60 <fcvtbuf+0x9c>
   18a4a:	2300      	movs	r3, #0
   18a4c:	f04f 0c30 	mov.w	ip, #48	; 0x30
   18a50:	f802 c003 	strb.w	ip, [r2, r3]
   18a54:	3301      	adds	r3, #1
   18a56:	1858      	adds	r0, r3, r1
   18a58:	4284      	cmp	r4, r0
   18a5a:	dcf9      	bgt.n	18a50 <fcvtbuf+0x8c>
   18a5c:	1a64      	subs	r4, r4, r1
   18a5e:	1912      	adds	r2, r2, r4
   18a60:	2300      	movs	r3, #0
   18a62:	7013      	strb	r3, [r2, #0]
   18a64:	4628      	mov	r0, r5
   18a66:	b00b      	add	sp, #44	; 0x2c
   18a68:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   18a6c:	4638      	mov	r0, r7
   18a6e:	4642      	mov	r2, r8
   18a70:	464b      	mov	r3, r9
   18a72:	f8cd a00c 	str.w	sl, [sp, #12]
   18a76:	2102      	movs	r1, #2
   18a78:	e7d0      	b.n	18a1c <fcvtbuf+0x58>
   18a7a:	f240 130c 	movw	r3, #268	; 0x10c
   18a7e:	3223      	adds	r2, #35	; 0x23
   18a80:	f2c2 0300 	movt	r3, #8192	; 0x2000
   18a84:	681f      	ldr	r7, [r3, #0]
   18a86:	6b39      	ldr	r1, [r7, #48]	; 0x30
   18a88:	4291      	cmp	r1, r2
   18a8a:	bfc8      	it	gt
   18a8c:	6b7d      	ldrgt	r5, [r7, #52]	; 0x34
   18a8e:	dcaa      	bgt.n	189e6 <fcvtbuf+0x22>
   18a90:	f104 0b24 	add.w	fp, r4, #36	; 0x24
   18a94:	4638      	mov	r0, r7
   18a96:	465a      	mov	r2, fp
   18a98:	6b79      	ldr	r1, [r7, #52]	; 0x34
   18a9a:	9307      	str	r3, [sp, #28]
   18a9c:	f001 faa8 	bl	19ff0 <_realloc_r>
   18aa0:	9b07      	ldr	r3, [sp, #28]
   18aa2:	4605      	mov	r5, r0
   18aa4:	2800      	cmp	r0, #0
   18aa6:	d0dd      	beq.n	18a64 <fcvtbuf+0xa0>
   18aa8:	681f      	ldr	r7, [r3, #0]
   18aaa:	f8c7 b030 	str.w	fp, [r7, #48]	; 0x30
   18aae:	6378      	str	r0, [r7, #52]	; 0x34
   18ab0:	e799      	b.n	189e6 <fcvtbuf+0x22>
   18ab2:	bf00      	nop

00018ab4 <_dcvt>:
   18ab4:	b5f0      	push	{r4, r5, r6, r7, lr}
   18ab6:	b08b      	sub	sp, #44	; 0x2c
   18ab8:	460d      	mov	r5, r1
   18aba:	f89d 6048 	ldrb.w	r6, [sp, #72]	; 0x48
   18abe:	9c10      	ldr	r4, [sp, #64]	; 0x40
   18ac0:	f1a6 0145 	sub.w	r1, r6, #69	; 0x45
   18ac4:	9f13      	ldr	r7, [sp, #76]	; 0x4c
   18ac6:	2922      	cmp	r1, #34	; 0x22
   18ac8:	d86f      	bhi.n	18baa <_dcvt+0xf6>
   18aca:	e8df f011 	tbh	[pc, r1, lsl #1]
   18ace:	00b1      	.short	0x00b1
   18ad0:	0071007b 	.word	0x0071007b
   18ad4:	006e006e 	.word	0x006e006e
   18ad8:	006e006e 	.word	0x006e006e
   18adc:	006e006e 	.word	0x006e006e
   18ae0:	006e006e 	.word	0x006e006e
   18ae4:	006e006e 	.word	0x006e006e
   18ae8:	006e006e 	.word	0x006e006e
   18aec:	006e006e 	.word	0x006e006e
   18af0:	006e006e 	.word	0x006e006e
   18af4:	006e006e 	.word	0x006e006e
   18af8:	006e006e 	.word	0x006e006e
   18afc:	006e006e 	.word	0x006e006e
   18b00:	006e006e 	.word	0x006e006e
   18b04:	006e006e 	.word	0x006e006e
   18b08:	006e006e 	.word	0x006e006e
   18b0c:	00b1006e 	.word	0x00b1006e
   18b10:	0071007b 	.word	0x0071007b
   18b14:	4601      	mov	r1, r0
   18b16:	462b      	mov	r3, r5
   18b18:	2f00      	cmp	r7, #0
   18b1a:	f000 8090 	beq.w	18c3e <_dcvt+0x18a>
   18b1e:	4288      	cmp	r0, r1
   18b20:	461a      	mov	r2, r3
   18b22:	f000 8090 	beq.w	18c46 <_dcvt+0x192>
   18b26:	4613      	mov	r3, r2
   18b28:	202e      	movs	r0, #46	; 0x2e
   18b2a:	2c00      	cmp	r4, #0
   18b2c:	bfd4      	ite	le
   18b2e:	f04f 0c00 	movle.w	ip, #0
   18b32:	f04f 0c01 	movgt.w	ip, #1
   18b36:	f803 0b01 	strb.w	r0, [r3], #1
   18b3a:	9809      	ldr	r0, [sp, #36]	; 0x24
   18b3c:	ea1c 70d0 	ands.w	r0, ip, r0, lsr #31
   18b40:	d012      	beq.n	18b68 <_dcvt+0xb4>
   18b42:	3202      	adds	r2, #2
   18b44:	2630      	movs	r6, #48	; 0x30
   18b46:	f802 6c01 	strb.w	r6, [r2, #-1]
   18b4a:	3c01      	subs	r4, #1
   18b4c:	9809      	ldr	r0, [sp, #36]	; 0x24
   18b4e:	2c00      	cmp	r4, #0
   18b50:	bfd4      	ite	le
   18b52:	f04f 0c00 	movle.w	ip, #0
   18b56:	f04f 0c01 	movgt.w	ip, #1
   18b5a:	4613      	mov	r3, r2
   18b5c:	3201      	adds	r2, #1
   18b5e:	3001      	adds	r0, #1
   18b60:	9009      	str	r0, [sp, #36]	; 0x24
   18b62:	ea1c 70d0 	ands.w	r0, ip, r0, lsr #31
   18b66:	d1ee      	bne.n	18b46 <_dcvt+0x92>
   18b68:	780a      	ldrb	r2, [r1, #0]
   18b6a:	2a00      	cmp	r2, #0
   18b6c:	bf0c      	ite	eq
   18b6e:	2000      	moveq	r0, #0
   18b70:	f00c 0001 	andne.w	r0, ip, #1
   18b74:	b170      	cbz	r0, 18b94 <_dcvt+0xe0>
   18b76:	f803 2b01 	strb.w	r2, [r3], #1
   18b7a:	3c01      	subs	r4, #1
   18b7c:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   18b80:	1e10      	subs	r0, r2, #0
   18b82:	bf18      	it	ne
   18b84:	2001      	movne	r0, #1
   18b86:	2c00      	cmp	r4, #0
   18b88:	bfd4      	ite	le
   18b8a:	2000      	movle	r0, #0
   18b8c:	f000 0001 	andgt.w	r0, r0, #1
   18b90:	2800      	cmp	r0, #0
   18b92:	d1f0      	bne.n	18b76 <_dcvt+0xc2>
   18b94:	2c00      	cmp	r4, #0
   18b96:	dd06      	ble.n	18ba6 <_dcvt+0xf2>
   18b98:	2200      	movs	r2, #0
   18b9a:	2130      	movs	r1, #48	; 0x30
   18b9c:	5499      	strb	r1, [r3, r2]
   18b9e:	3201      	adds	r2, #1
   18ba0:	42a2      	cmp	r2, r4
   18ba2:	d1fb      	bne.n	18b9c <_dcvt+0xe8>
   18ba4:	189b      	adds	r3, r3, r2
   18ba6:	2200      	movs	r2, #0
   18ba8:	701a      	strb	r2, [r3, #0]
   18baa:	4628      	mov	r0, r5
   18bac:	b00b      	add	sp, #44	; 0x2c
   18bae:	bdf0      	pop	{r4, r5, r6, r7, pc}
   18bb0:	2c00      	cmp	r4, #0
   18bb2:	bf08      	it	eq
   18bb4:	2401      	moveq	r4, #1
   18bb6:	9602      	str	r6, [sp, #8]
   18bb8:	9703      	str	r7, [sp, #12]
   18bba:	9400      	str	r4, [sp, #0]
   18bbc:	9501      	str	r5, [sp, #4]
   18bbe:	f7ff fda3 	bl	18708 <_gcvt>
   18bc2:	e7f2      	b.n	18baa <_dcvt+0xf6>
   18bc4:	2103      	movs	r1, #3
   18bc6:	9401      	str	r4, [sp, #4]
   18bc8:	9100      	str	r1, [sp, #0]
   18bca:	a909      	add	r1, sp, #36	; 0x24
   18bcc:	9102      	str	r1, [sp, #8]
   18bce:	a908      	add	r1, sp, #32
   18bd0:	9103      	str	r1, [sp, #12]
   18bd2:	a907      	add	r1, sp, #28
   18bd4:	9104      	str	r1, [sp, #16]
   18bd6:	f7fe fdb3 	bl	17740 <_dtoa_r>
   18bda:	9a09      	ldr	r2, [sp, #36]	; 0x24
   18bdc:	f242 730f 	movw	r3, #9999	; 0x270f
   18be0:	2c00      	cmp	r4, #0
   18be2:	bf18      	it	ne
   18be4:	2701      	movne	r7, #1
   18be6:	429a      	cmp	r2, r3
   18be8:	d031      	beq.n	18c4e <_dcvt+0x19a>
   18bea:	7806      	ldrb	r6, [r0, #0]
   18bec:	2e00      	cmp	r6, #0
   18bee:	d033      	beq.n	18c58 <_dcvt+0x1a4>
   18bf0:	2a00      	cmp	r2, #0
   18bf2:	bfc4      	itt	gt
   18bf4:	462b      	movgt	r3, r5
   18bf6:	4601      	movgt	r1, r0
   18bf8:	dc02      	bgt.n	18c00 <_dcvt+0x14c>
   18bfa:	e78b      	b.n	18b14 <_dcvt+0x60>
   18bfc:	2a00      	cmp	r2, #0
   18bfe:	dd8b      	ble.n	18b18 <_dcvt+0x64>
   18c00:	f803 6b01 	strb.w	r6, [r3], #1
   18c04:	9a09      	ldr	r2, [sp, #36]	; 0x24
   18c06:	3a01      	subs	r2, #1
   18c08:	9209      	str	r2, [sp, #36]	; 0x24
   18c0a:	f811 6f01 	ldrb.w	r6, [r1, #1]!
   18c0e:	2e00      	cmp	r6, #0
   18c10:	d1f4      	bne.n	18bfc <_dcvt+0x148>
   18c12:	2a00      	cmp	r2, #0
   18c14:	dd80      	ble.n	18b18 <_dcvt+0x64>
   18c16:	f04f 0c30 	mov.w	ip, #48	; 0x30
   18c1a:	f803 cb01 	strb.w	ip, [r3], #1
   18c1e:	9a09      	ldr	r2, [sp, #36]	; 0x24
   18c20:	3a01      	subs	r2, #1
   18c22:	9209      	str	r2, [sp, #36]	; 0x24
   18c24:	2a00      	cmp	r2, #0
   18c26:	dcf8      	bgt.n	18c1a <_dcvt+0x166>
   18c28:	2f00      	cmp	r7, #0
   18c2a:	f47f af78 	bne.w	18b1e <_dcvt+0x6a>
   18c2e:	e006      	b.n	18c3e <_dcvt+0x18a>
   18c30:	4629      	mov	r1, r5
   18c32:	9400      	str	r4, [sp, #0]
   18c34:	9601      	str	r6, [sp, #4]
   18c36:	9702      	str	r7, [sp, #8]
   18c38:	f7ff fcce 	bl	185d8 <print_e>
   18c3c:	e7b5      	b.n	18baa <_dcvt+0xf6>
   18c3e:	780a      	ldrb	r2, [r1, #0]
   18c40:	2a00      	cmp	r2, #0
   18c42:	d0b0      	beq.n	18ba6 <_dcvt+0xf2>
   18c44:	e76b      	b.n	18b1e <_dcvt+0x6a>
   18c46:	2330      	movs	r3, #48	; 0x30
   18c48:	f802 3b01 	strb.w	r3, [r2], #1
   18c4c:	e76b      	b.n	18b26 <_dcvt+0x72>
   18c4e:	4601      	mov	r1, r0
   18c50:	4628      	mov	r0, r5
   18c52:	f7fc fe39 	bl	158c8 <strcpy>
   18c56:	e7a8      	b.n	18baa <_dcvt+0xf6>
   18c58:	4601      	mov	r1, r0
   18c5a:	462b      	mov	r3, r5
   18c5c:	e7d9      	b.n	18c12 <_dcvt+0x15e>
   18c5e:	bf00      	nop

00018c60 <_malloc_trim_r>:
   18c60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   18c62:	f240 2410 	movw	r4, #528	; 0x210
   18c66:	f2c2 0400 	movt	r4, #8192	; 0x2000
   18c6a:	460f      	mov	r7, r1
   18c6c:	4605      	mov	r5, r0
   18c6e:	f000 fd0f 	bl	19690 <__malloc_lock>
   18c72:	68a3      	ldr	r3, [r4, #8]
   18c74:	685e      	ldr	r6, [r3, #4]
   18c76:	f026 0603 	bic.w	r6, r6, #3
   18c7a:	f506 637e 	add.w	r3, r6, #4064	; 0xfe0
   18c7e:	330f      	adds	r3, #15
   18c80:	1bdf      	subs	r7, r3, r7
   18c82:	0b3f      	lsrs	r7, r7, #12
   18c84:	3f01      	subs	r7, #1
   18c86:	033f      	lsls	r7, r7, #12
   18c88:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
   18c8c:	db07      	blt.n	18c9e <_malloc_trim_r+0x3e>
   18c8e:	2100      	movs	r1, #0
   18c90:	4628      	mov	r0, r5
   18c92:	f001 fba7 	bl	1a3e4 <_sbrk_r>
   18c96:	68a3      	ldr	r3, [r4, #8]
   18c98:	18f3      	adds	r3, r6, r3
   18c9a:	4283      	cmp	r3, r0
   18c9c:	d004      	beq.n	18ca8 <_malloc_trim_r+0x48>
   18c9e:	4628      	mov	r0, r5
   18ca0:	f000 fcf8 	bl	19694 <__malloc_unlock>
   18ca4:	2000      	movs	r0, #0
   18ca6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   18ca8:	4279      	negs	r1, r7
   18caa:	4628      	mov	r0, r5
   18cac:	f001 fb9a 	bl	1a3e4 <_sbrk_r>
   18cb0:	f1b0 3fff 	cmp.w	r0, #4294967295
   18cb4:	d010      	beq.n	18cd8 <_malloc_trim_r+0x78>
   18cb6:	68a2      	ldr	r2, [r4, #8]
   18cb8:	f64a 1368 	movw	r3, #43368	; 0xa968
   18cbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
   18cc0:	1bf6      	subs	r6, r6, r7
   18cc2:	f046 0601 	orr.w	r6, r6, #1
   18cc6:	4628      	mov	r0, r5
   18cc8:	6056      	str	r6, [r2, #4]
   18cca:	681a      	ldr	r2, [r3, #0]
   18ccc:	1bd7      	subs	r7, r2, r7
   18cce:	601f      	str	r7, [r3, #0]
   18cd0:	f000 fce0 	bl	19694 <__malloc_unlock>
   18cd4:	2001      	movs	r0, #1
   18cd6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   18cd8:	2100      	movs	r1, #0
   18cda:	4628      	mov	r0, r5
   18cdc:	f001 fb82 	bl	1a3e4 <_sbrk_r>
   18ce0:	68a3      	ldr	r3, [r4, #8]
   18ce2:	1ac2      	subs	r2, r0, r3
   18ce4:	2a0f      	cmp	r2, #15
   18ce6:	ddda      	ble.n	18c9e <_malloc_trim_r+0x3e>
   18ce8:	f240 6418 	movw	r4, #1560	; 0x618
   18cec:	f64a 1168 	movw	r1, #43368	; 0xa968
   18cf0:	f2c2 0400 	movt	r4, #8192	; 0x2000
   18cf4:	f2c2 0100 	movt	r1, #8192	; 0x2000
   18cf8:	f042 0201 	orr.w	r2, r2, #1
   18cfc:	6824      	ldr	r4, [r4, #0]
   18cfe:	1b00      	subs	r0, r0, r4
   18d00:	6008      	str	r0, [r1, #0]
   18d02:	605a      	str	r2, [r3, #4]
   18d04:	e7cb      	b.n	18c9e <_malloc_trim_r+0x3e>
   18d06:	bf00      	nop

00018d08 <_free_r>:
   18d08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   18d0c:	4605      	mov	r5, r0
   18d0e:	460c      	mov	r4, r1
   18d10:	2900      	cmp	r1, #0
   18d12:	f000 8088 	beq.w	18e26 <_free_r+0x11e>
   18d16:	f000 fcbb 	bl	19690 <__malloc_lock>
   18d1a:	f1a4 0208 	sub.w	r2, r4, #8
   18d1e:	f240 2010 	movw	r0, #528	; 0x210
   18d22:	6856      	ldr	r6, [r2, #4]
   18d24:	f2c2 0000 	movt	r0, #8192	; 0x2000
   18d28:	f026 0301 	bic.w	r3, r6, #1
   18d2c:	f8d0 c008 	ldr.w	ip, [r0, #8]
   18d30:	18d1      	adds	r1, r2, r3
   18d32:	458c      	cmp	ip, r1
   18d34:	684f      	ldr	r7, [r1, #4]
   18d36:	f027 0703 	bic.w	r7, r7, #3
   18d3a:	f000 8095 	beq.w	18e68 <_free_r+0x160>
   18d3e:	f016 0601 	ands.w	r6, r6, #1
   18d42:	604f      	str	r7, [r1, #4]
   18d44:	d05f      	beq.n	18e06 <_free_r+0xfe>
   18d46:	2600      	movs	r6, #0
   18d48:	19cc      	adds	r4, r1, r7
   18d4a:	6864      	ldr	r4, [r4, #4]
   18d4c:	f014 0f01 	tst.w	r4, #1
   18d50:	d106      	bne.n	18d60 <_free_r+0x58>
   18d52:	19db      	adds	r3, r3, r7
   18d54:	2e00      	cmp	r6, #0
   18d56:	d07a      	beq.n	18e4e <_free_r+0x146>
   18d58:	688c      	ldr	r4, [r1, #8]
   18d5a:	68c9      	ldr	r1, [r1, #12]
   18d5c:	608c      	str	r4, [r1, #8]
   18d5e:	60e1      	str	r1, [r4, #12]
   18d60:	f043 0101 	orr.w	r1, r3, #1
   18d64:	50d3      	str	r3, [r2, r3]
   18d66:	6051      	str	r1, [r2, #4]
   18d68:	2e00      	cmp	r6, #0
   18d6a:	d147      	bne.n	18dfc <_free_r+0xf4>
   18d6c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   18d70:	d35b      	bcc.n	18e2a <_free_r+0x122>
   18d72:	0a59      	lsrs	r1, r3, #9
   18d74:	2904      	cmp	r1, #4
   18d76:	bf9e      	ittt	ls
   18d78:	ea4f 1c93 	movls.w	ip, r3, lsr #6
   18d7c:	f10c 0c38 	addls.w	ip, ip, #56	; 0x38
   18d80:	ea4f 04cc 	movls.w	r4, ip, lsl #3
   18d84:	d928      	bls.n	18dd8 <_free_r+0xd0>
   18d86:	2914      	cmp	r1, #20
   18d88:	bf9c      	itt	ls
   18d8a:	f101 0c5b 	addls.w	ip, r1, #91	; 0x5b
   18d8e:	ea4f 04cc 	movls.w	r4, ip, lsl #3
   18d92:	d921      	bls.n	18dd8 <_free_r+0xd0>
   18d94:	2954      	cmp	r1, #84	; 0x54
   18d96:	bf9e      	ittt	ls
   18d98:	ea4f 3c13 	movls.w	ip, r3, lsr #12
   18d9c:	f10c 0c6e 	addls.w	ip, ip, #110	; 0x6e
   18da0:	ea4f 04cc 	movls.w	r4, ip, lsl #3
   18da4:	d918      	bls.n	18dd8 <_free_r+0xd0>
   18da6:	f5b1 7faa 	cmp.w	r1, #340	; 0x154
   18daa:	bf9e      	ittt	ls
   18dac:	ea4f 3cd3 	movls.w	ip, r3, lsr #15
   18db0:	f10c 0c77 	addls.w	ip, ip, #119	; 0x77
   18db4:	ea4f 04cc 	movls.w	r4, ip, lsl #3
   18db8:	d90e      	bls.n	18dd8 <_free_r+0xd0>
   18dba:	f240 5c54 	movw	ip, #1364	; 0x554
   18dbe:	4561      	cmp	r1, ip
   18dc0:	bf95      	itete	ls
   18dc2:	ea4f 4c93 	movls.w	ip, r3, lsr #18
   18dc6:	f44f 747c 	movhi.w	r4, #1008	; 0x3f0
   18dca:	f10c 0c7c 	addls.w	ip, ip, #124	; 0x7c
   18dce:	f04f 0c7e 	movhi.w	ip, #126	; 0x7e
   18dd2:	bf98      	it	ls
   18dd4:	ea4f 04cc 	movls.w	r4, ip, lsl #3
   18dd8:	1904      	adds	r4, r0, r4
   18dda:	68a1      	ldr	r1, [r4, #8]
   18ddc:	42a1      	cmp	r1, r4
   18dde:	d103      	bne.n	18de8 <_free_r+0xe0>
   18de0:	e064      	b.n	18eac <_free_r+0x1a4>
   18de2:	6889      	ldr	r1, [r1, #8]
   18de4:	428c      	cmp	r4, r1
   18de6:	d004      	beq.n	18df2 <_free_r+0xea>
   18de8:	6848      	ldr	r0, [r1, #4]
   18dea:	f020 0003 	bic.w	r0, r0, #3
   18dee:	4283      	cmp	r3, r0
   18df0:	d3f7      	bcc.n	18de2 <_free_r+0xda>
   18df2:	68cb      	ldr	r3, [r1, #12]
   18df4:	60d3      	str	r3, [r2, #12]
   18df6:	6091      	str	r1, [r2, #8]
   18df8:	60ca      	str	r2, [r1, #12]
   18dfa:	609a      	str	r2, [r3, #8]
   18dfc:	4628      	mov	r0, r5
   18dfe:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   18e02:	f000 bc47 	b.w	19694 <__malloc_unlock>
   18e06:	f854 4c08 	ldr.w	r4, [r4, #-8]
   18e0a:	f100 0c08 	add.w	ip, r0, #8
   18e0e:	1b12      	subs	r2, r2, r4
   18e10:	191b      	adds	r3, r3, r4
   18e12:	6894      	ldr	r4, [r2, #8]
   18e14:	4564      	cmp	r4, ip
   18e16:	d047      	beq.n	18ea8 <_free_r+0x1a0>
   18e18:	f8d2 c00c 	ldr.w	ip, [r2, #12]
   18e1c:	f8cc 4008 	str.w	r4, [ip, #8]
   18e20:	f8c4 c00c 	str.w	ip, [r4, #12]
   18e24:	e790      	b.n	18d48 <_free_r+0x40>
   18e26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   18e2a:	08db      	lsrs	r3, r3, #3
   18e2c:	f04f 0c01 	mov.w	ip, #1
   18e30:	6846      	ldr	r6, [r0, #4]
   18e32:	eb00 01c3 	add.w	r1, r0, r3, lsl #3
   18e36:	109b      	asrs	r3, r3, #2
   18e38:	fa0c f303 	lsl.w	r3, ip, r3
   18e3c:	60d1      	str	r1, [r2, #12]
   18e3e:	688c      	ldr	r4, [r1, #8]
   18e40:	ea46 0303 	orr.w	r3, r6, r3
   18e44:	6043      	str	r3, [r0, #4]
   18e46:	6094      	str	r4, [r2, #8]
   18e48:	60e2      	str	r2, [r4, #12]
   18e4a:	608a      	str	r2, [r1, #8]
   18e4c:	e7d6      	b.n	18dfc <_free_r+0xf4>
   18e4e:	688c      	ldr	r4, [r1, #8]
   18e50:	4f1c      	ldr	r7, [pc, #112]	; (18ec4 <_free_r+0x1bc>)
   18e52:	42bc      	cmp	r4, r7
   18e54:	d181      	bne.n	18d5a <_free_r+0x52>
   18e56:	50d3      	str	r3, [r2, r3]
   18e58:	f043 0301 	orr.w	r3, r3, #1
   18e5c:	60e2      	str	r2, [r4, #12]
   18e5e:	60a2      	str	r2, [r4, #8]
   18e60:	6053      	str	r3, [r2, #4]
   18e62:	6094      	str	r4, [r2, #8]
   18e64:	60d4      	str	r4, [r2, #12]
   18e66:	e7c9      	b.n	18dfc <_free_r+0xf4>
   18e68:	18fb      	adds	r3, r7, r3
   18e6a:	f016 0f01 	tst.w	r6, #1
   18e6e:	d107      	bne.n	18e80 <_free_r+0x178>
   18e70:	f854 1c08 	ldr.w	r1, [r4, #-8]
   18e74:	1a52      	subs	r2, r2, r1
   18e76:	185b      	adds	r3, r3, r1
   18e78:	68d4      	ldr	r4, [r2, #12]
   18e7a:	6891      	ldr	r1, [r2, #8]
   18e7c:	60a1      	str	r1, [r4, #8]
   18e7e:	60cc      	str	r4, [r1, #12]
   18e80:	f240 611c 	movw	r1, #1564	; 0x61c
   18e84:	6082      	str	r2, [r0, #8]
   18e86:	f2c2 0100 	movt	r1, #8192	; 0x2000
   18e8a:	f043 0001 	orr.w	r0, r3, #1
   18e8e:	6050      	str	r0, [r2, #4]
   18e90:	680a      	ldr	r2, [r1, #0]
   18e92:	4293      	cmp	r3, r2
   18e94:	d3b2      	bcc.n	18dfc <_free_r+0xf4>
   18e96:	f64a 1364 	movw	r3, #43364	; 0xa964
   18e9a:	4628      	mov	r0, r5
   18e9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   18ea0:	6819      	ldr	r1, [r3, #0]
   18ea2:	f7ff fedd 	bl	18c60 <_malloc_trim_r>
   18ea6:	e7a9      	b.n	18dfc <_free_r+0xf4>
   18ea8:	2601      	movs	r6, #1
   18eaa:	e74d      	b.n	18d48 <_free_r+0x40>
   18eac:	2601      	movs	r6, #1
   18eae:	6844      	ldr	r4, [r0, #4]
   18eb0:	ea4f 0cac 	mov.w	ip, ip, asr #2
   18eb4:	460b      	mov	r3, r1
   18eb6:	fa06 fc0c 	lsl.w	ip, r6, ip
   18eba:	ea44 040c 	orr.w	r4, r4, ip
   18ebe:	6044      	str	r4, [r0, #4]
   18ec0:	e798      	b.n	18df4 <_free_r+0xec>
   18ec2:	bf00      	nop
   18ec4:	20000218 	.word	0x20000218

00018ec8 <__locale_charset>:
   18ec8:	f64f 13c4 	movw	r3, #63940	; 0xf9c4
   18ecc:	f2c0 0302 	movt	r3, #2
   18ed0:	6818      	ldr	r0, [r3, #0]
   18ed2:	4770      	bx	lr

00018ed4 <_localeconv_r>:
   18ed4:	4800      	ldr	r0, [pc, #0]	; (18ed8 <_localeconv_r+0x4>)
   18ed6:	4770      	bx	lr
   18ed8:	0002f9c8 	.word	0x0002f9c8

00018edc <localeconv>:
   18edc:	4800      	ldr	r0, [pc, #0]	; (18ee0 <localeconv+0x4>)
   18ede:	4770      	bx	lr
   18ee0:	0002f9c8 	.word	0x0002f9c8

00018ee4 <_setlocale_r>:
   18ee4:	b570      	push	{r4, r5, r6, lr}
   18ee6:	4605      	mov	r5, r0
   18ee8:	460e      	mov	r6, r1
   18eea:	4614      	mov	r4, r2
   18eec:	b172      	cbz	r2, 18f0c <_setlocale_r+0x28>
   18eee:	f64f 114c 	movw	r1, #63820	; 0xf94c
   18ef2:	4610      	mov	r0, r2
   18ef4:	f2c0 0102 	movt	r1, #2
   18ef8:	f001 fa88 	bl	1a40c <strcmp>
   18efc:	b958      	cbnz	r0, 18f16 <_setlocale_r+0x32>
   18efe:	f64f 104c 	movw	r0, #63820	; 0xf94c
   18f02:	622c      	str	r4, [r5, #32]
   18f04:	f2c0 0002 	movt	r0, #2
   18f08:	61ee      	str	r6, [r5, #28]
   18f0a:	bd70      	pop	{r4, r5, r6, pc}
   18f0c:	f64f 104c 	movw	r0, #63820	; 0xf94c
   18f10:	f2c0 0002 	movt	r0, #2
   18f14:	bd70      	pop	{r4, r5, r6, pc}
   18f16:	f64f 1180 	movw	r1, #63872	; 0xf980
   18f1a:	4620      	mov	r0, r4
   18f1c:	f2c0 0102 	movt	r1, #2
   18f20:	f001 fa74 	bl	1a40c <strcmp>
   18f24:	2800      	cmp	r0, #0
   18f26:	d0ea      	beq.n	18efe <_setlocale_r+0x1a>
   18f28:	2000      	movs	r0, #0
   18f2a:	bd70      	pop	{r4, r5, r6, pc}

00018f2c <setlocale>:
   18f2c:	f240 130c 	movw	r3, #268	; 0x10c
   18f30:	460a      	mov	r2, r1
   18f32:	f2c2 0300 	movt	r3, #8192	; 0x2000
   18f36:	4601      	mov	r1, r0
   18f38:	6818      	ldr	r0, [r3, #0]
   18f3a:	e7d3      	b.n	18ee4 <_setlocale_r>

00018f3c <free>:
   18f3c:	f240 130c 	movw	r3, #268	; 0x10c
   18f40:	4601      	mov	r1, r0
   18f42:	f2c2 0300 	movt	r3, #8192	; 0x2000
   18f46:	6818      	ldr	r0, [r3, #0]
   18f48:	f7ff bede 	b.w	18d08 <_free_r>

00018f4c <malloc>:
   18f4c:	f240 130c 	movw	r3, #268	; 0x10c
   18f50:	4601      	mov	r1, r0
   18f52:	f2c2 0300 	movt	r3, #8192	; 0x2000
   18f56:	6818      	ldr	r0, [r3, #0]
   18f58:	f000 b800 	b.w	18f5c <_malloc_r>

00018f5c <_malloc_r>:
   18f5c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18f60:	f101 040b 	add.w	r4, r1, #11
   18f64:	2c16      	cmp	r4, #22
   18f66:	b083      	sub	sp, #12
   18f68:	4606      	mov	r6, r0
   18f6a:	d82f      	bhi.n	18fcc <_malloc_r+0x70>
   18f6c:	2300      	movs	r3, #0
   18f6e:	2410      	movs	r4, #16
   18f70:	428c      	cmp	r4, r1
   18f72:	bf2c      	ite	cs
   18f74:	4619      	movcs	r1, r3
   18f76:	f043 0101 	orrcc.w	r1, r3, #1
   18f7a:	2900      	cmp	r1, #0
   18f7c:	d130      	bne.n	18fe0 <_malloc_r+0x84>
   18f7e:	4630      	mov	r0, r6
   18f80:	f000 fb86 	bl	19690 <__malloc_lock>
   18f84:	f5b4 7ffc 	cmp.w	r4, #504	; 0x1f8
   18f88:	d22e      	bcs.n	18fe8 <_malloc_r+0x8c>
   18f8a:	ea4f 0ed4 	mov.w	lr, r4, lsr #3
   18f8e:	f240 2510 	movw	r5, #528	; 0x210
   18f92:	f2c2 0500 	movt	r5, #8192	; 0x2000
   18f96:	eb05 02ce 	add.w	r2, r5, lr, lsl #3
   18f9a:	68d3      	ldr	r3, [r2, #12]
   18f9c:	4293      	cmp	r3, r2
   18f9e:	f000 8206 	beq.w	193ae <_malloc_r+0x452>
   18fa2:	685a      	ldr	r2, [r3, #4]
   18fa4:	f103 0508 	add.w	r5, r3, #8
   18fa8:	68d9      	ldr	r1, [r3, #12]
   18faa:	4630      	mov	r0, r6
   18fac:	f022 0c03 	bic.w	ip, r2, #3
   18fb0:	689a      	ldr	r2, [r3, #8]
   18fb2:	4463      	add	r3, ip
   18fb4:	685c      	ldr	r4, [r3, #4]
   18fb6:	608a      	str	r2, [r1, #8]
   18fb8:	f044 0401 	orr.w	r4, r4, #1
   18fbc:	60d1      	str	r1, [r2, #12]
   18fbe:	605c      	str	r4, [r3, #4]
   18fc0:	f000 fb68 	bl	19694 <__malloc_unlock>
   18fc4:	4628      	mov	r0, r5
   18fc6:	b003      	add	sp, #12
   18fc8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   18fcc:	f024 0407 	bic.w	r4, r4, #7
   18fd0:	0fe3      	lsrs	r3, r4, #31
   18fd2:	428c      	cmp	r4, r1
   18fd4:	bf2c      	ite	cs
   18fd6:	4619      	movcs	r1, r3
   18fd8:	f043 0101 	orrcc.w	r1, r3, #1
   18fdc:	2900      	cmp	r1, #0
   18fde:	d0ce      	beq.n	18f7e <_malloc_r+0x22>
   18fe0:	230c      	movs	r3, #12
   18fe2:	2500      	movs	r5, #0
   18fe4:	6033      	str	r3, [r6, #0]
   18fe6:	e7ed      	b.n	18fc4 <_malloc_r+0x68>
   18fe8:	ea5f 2e54 	movs.w	lr, r4, lsr #9
   18fec:	bf04      	itt	eq
   18fee:	ea4f 0ed4 	moveq.w	lr, r4, lsr #3
   18ff2:	ea4f 00ce 	moveq.w	r0, lr, lsl #3
   18ff6:	f040 8090 	bne.w	1911a <_malloc_r+0x1be>
   18ffa:	f240 2510 	movw	r5, #528	; 0x210
   18ffe:	f2c2 0500 	movt	r5, #8192	; 0x2000
   19002:	1828      	adds	r0, r5, r0
   19004:	68c3      	ldr	r3, [r0, #12]
   19006:	4298      	cmp	r0, r3
   19008:	d106      	bne.n	19018 <_malloc_r+0xbc>
   1900a:	e00d      	b.n	19028 <_malloc_r+0xcc>
   1900c:	2a00      	cmp	r2, #0
   1900e:	f280 816f 	bge.w	192f0 <_malloc_r+0x394>
   19012:	68db      	ldr	r3, [r3, #12]
   19014:	4298      	cmp	r0, r3
   19016:	d007      	beq.n	19028 <_malloc_r+0xcc>
   19018:	6859      	ldr	r1, [r3, #4]
   1901a:	f021 0103 	bic.w	r1, r1, #3
   1901e:	1b0a      	subs	r2, r1, r4
   19020:	2a0f      	cmp	r2, #15
   19022:	ddf3      	ble.n	1900c <_malloc_r+0xb0>
   19024:	f10e 3eff 	add.w	lr, lr, #4294967295
   19028:	f10e 0e01 	add.w	lr, lr, #1
   1902c:	f240 2710 	movw	r7, #528	; 0x210
   19030:	f2c2 0700 	movt	r7, #8192	; 0x2000
   19034:	f107 0108 	add.w	r1, r7, #8
   19038:	688b      	ldr	r3, [r1, #8]
   1903a:	4299      	cmp	r1, r3
   1903c:	bf08      	it	eq
   1903e:	687a      	ldreq	r2, [r7, #4]
   19040:	d026      	beq.n	19090 <_malloc_r+0x134>
   19042:	685a      	ldr	r2, [r3, #4]
   19044:	f022 0c03 	bic.w	ip, r2, #3
   19048:	ebc4 020c 	rsb	r2, r4, ip
   1904c:	2a0f      	cmp	r2, #15
   1904e:	f300 8194 	bgt.w	1937a <_malloc_r+0x41e>
   19052:	2a00      	cmp	r2, #0
   19054:	60c9      	str	r1, [r1, #12]
   19056:	6089      	str	r1, [r1, #8]
   19058:	f280 8099 	bge.w	1918e <_malloc_r+0x232>
   1905c:	f5bc 7f00 	cmp.w	ip, #512	; 0x200
   19060:	f080 8165 	bcs.w	1932e <_malloc_r+0x3d2>
   19064:	ea4f 0cdc 	mov.w	ip, ip, lsr #3
   19068:	f04f 0a01 	mov.w	sl, #1
   1906c:	687a      	ldr	r2, [r7, #4]
   1906e:	eb07 00cc 	add.w	r0, r7, ip, lsl #3
   19072:	ea4f 0cac 	mov.w	ip, ip, asr #2
   19076:	fa0a fc0c 	lsl.w	ip, sl, ip
   1907a:	60d8      	str	r0, [r3, #12]
   1907c:	f8d0 8008 	ldr.w	r8, [r0, #8]
   19080:	ea4c 0202 	orr.w	r2, ip, r2
   19084:	607a      	str	r2, [r7, #4]
   19086:	f8c3 8008 	str.w	r8, [r3, #8]
   1908a:	f8c8 300c 	str.w	r3, [r8, #12]
   1908e:	6083      	str	r3, [r0, #8]
   19090:	f04f 0c01 	mov.w	ip, #1
   19094:	ea4f 03ae 	mov.w	r3, lr, asr #2
   19098:	fa0c fc03 	lsl.w	ip, ip, r3
   1909c:	4594      	cmp	ip, r2
   1909e:	f200 8082 	bhi.w	191a6 <_malloc_r+0x24a>
   190a2:	ea12 0f0c 	tst.w	r2, ip
   190a6:	d108      	bne.n	190ba <_malloc_r+0x15e>
   190a8:	f02e 0e03 	bic.w	lr, lr, #3
   190ac:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
   190b0:	f10e 0e04 	add.w	lr, lr, #4
   190b4:	ea12 0f0c 	tst.w	r2, ip
   190b8:	d0f8      	beq.n	190ac <_malloc_r+0x150>
   190ba:	eb07 09ce 	add.w	r9, r7, lr, lsl #3
   190be:	46f2      	mov	sl, lr
   190c0:	46c8      	mov	r8, r9
   190c2:	f8d8 300c 	ldr.w	r3, [r8, #12]
   190c6:	4598      	cmp	r8, r3
   190c8:	d107      	bne.n	190da <_malloc_r+0x17e>
   190ca:	e168      	b.n	1939e <_malloc_r+0x442>
   190cc:	2a00      	cmp	r2, #0
   190ce:	f280 8178 	bge.w	193c2 <_malloc_r+0x466>
   190d2:	68db      	ldr	r3, [r3, #12]
   190d4:	4598      	cmp	r8, r3
   190d6:	f000 8162 	beq.w	1939e <_malloc_r+0x442>
   190da:	6858      	ldr	r0, [r3, #4]
   190dc:	f020 0003 	bic.w	r0, r0, #3
   190e0:	1b02      	subs	r2, r0, r4
   190e2:	2a0f      	cmp	r2, #15
   190e4:	ddf2      	ble.n	190cc <_malloc_r+0x170>
   190e6:	461d      	mov	r5, r3
   190e8:	191f      	adds	r7, r3, r4
   190ea:	f8d3 c00c 	ldr.w	ip, [r3, #12]
   190ee:	f044 0e01 	orr.w	lr, r4, #1
   190f2:	f855 4f08 	ldr.w	r4, [r5, #8]!
   190f6:	4630      	mov	r0, r6
   190f8:	50ba      	str	r2, [r7, r2]
   190fa:	f042 0201 	orr.w	r2, r2, #1
   190fe:	f8c3 e004 	str.w	lr, [r3, #4]
   19102:	f8cc 4008 	str.w	r4, [ip, #8]
   19106:	f8c4 c00c 	str.w	ip, [r4, #12]
   1910a:	608f      	str	r7, [r1, #8]
   1910c:	60cf      	str	r7, [r1, #12]
   1910e:	607a      	str	r2, [r7, #4]
   19110:	60b9      	str	r1, [r7, #8]
   19112:	60f9      	str	r1, [r7, #12]
   19114:	f000 fabe 	bl	19694 <__malloc_unlock>
   19118:	e754      	b.n	18fc4 <_malloc_r+0x68>
   1911a:	f1be 0f04 	cmp.w	lr, #4
   1911e:	bf9e      	ittt	ls
   19120:	ea4f 1e94 	movls.w	lr, r4, lsr #6
   19124:	f10e 0e38 	addls.w	lr, lr, #56	; 0x38
   19128:	ea4f 00ce 	movls.w	r0, lr, lsl #3
   1912c:	f67f af65 	bls.w	18ffa <_malloc_r+0x9e>
   19130:	f1be 0f14 	cmp.w	lr, #20
   19134:	bf9c      	itt	ls
   19136:	f10e 0e5b 	addls.w	lr, lr, #91	; 0x5b
   1913a:	ea4f 00ce 	movls.w	r0, lr, lsl #3
   1913e:	f67f af5c 	bls.w	18ffa <_malloc_r+0x9e>
   19142:	f1be 0f54 	cmp.w	lr, #84	; 0x54
   19146:	bf9e      	ittt	ls
   19148:	ea4f 3e14 	movls.w	lr, r4, lsr #12
   1914c:	f10e 0e6e 	addls.w	lr, lr, #110	; 0x6e
   19150:	ea4f 00ce 	movls.w	r0, lr, lsl #3
   19154:	f67f af51 	bls.w	18ffa <_malloc_r+0x9e>
   19158:	f5be 7faa 	cmp.w	lr, #340	; 0x154
   1915c:	bf9e      	ittt	ls
   1915e:	ea4f 3ed4 	movls.w	lr, r4, lsr #15
   19162:	f10e 0e77 	addls.w	lr, lr, #119	; 0x77
   19166:	ea4f 00ce 	movls.w	r0, lr, lsl #3
   1916a:	f67f af46 	bls.w	18ffa <_malloc_r+0x9e>
   1916e:	f240 5354 	movw	r3, #1364	; 0x554
   19172:	459e      	cmp	lr, r3
   19174:	bf95      	itete	ls
   19176:	ea4f 4e94 	movls.w	lr, r4, lsr #18
   1917a:	f44f 707c 	movhi.w	r0, #1008	; 0x3f0
   1917e:	f10e 0e7c 	addls.w	lr, lr, #124	; 0x7c
   19182:	f04f 0e7e 	movhi.w	lr, #126	; 0x7e
   19186:	bf98      	it	ls
   19188:	ea4f 00ce 	movls.w	r0, lr, lsl #3
   1918c:	e735      	b.n	18ffa <_malloc_r+0x9e>
   1918e:	eb03 020c 	add.w	r2, r3, ip
   19192:	f103 0508 	add.w	r5, r3, #8
   19196:	4630      	mov	r0, r6
   19198:	6853      	ldr	r3, [r2, #4]
   1919a:	f043 0301 	orr.w	r3, r3, #1
   1919e:	6053      	str	r3, [r2, #4]
   191a0:	f000 fa78 	bl	19694 <__malloc_unlock>
   191a4:	e70e      	b.n	18fc4 <_malloc_r+0x68>
   191a6:	f8d7 8008 	ldr.w	r8, [r7, #8]
   191aa:	f8d8 3004 	ldr.w	r3, [r8, #4]
   191ae:	f023 0903 	bic.w	r9, r3, #3
   191b2:	ebc4 0209 	rsb	r2, r4, r9
   191b6:	454c      	cmp	r4, r9
   191b8:	bf94      	ite	ls
   191ba:	2300      	movls	r3, #0
   191bc:	2301      	movhi	r3, #1
   191be:	2a0f      	cmp	r2, #15
   191c0:	bfd8      	it	le
   191c2:	f043 0301 	orrle.w	r3, r3, #1
   191c6:	2b00      	cmp	r3, #0
   191c8:	f000 80a1 	beq.w	1930e <_malloc_r+0x3b2>
   191cc:	f64a 1b64 	movw	fp, #43364	; 0xa964
   191d0:	f8d5 2408 	ldr.w	r2, [r5, #1032]	; 0x408
   191d4:	f2c2 0b00 	movt	fp, #8192	; 0x2000
   191d8:	f8db 3000 	ldr.w	r3, [fp]
   191dc:	3310      	adds	r3, #16
   191de:	191b      	adds	r3, r3, r4
   191e0:	f1b2 3fff 	cmp.w	r2, #4294967295
   191e4:	d006      	beq.n	191f4 <_malloc_r+0x298>
   191e6:	f503 637e 	add.w	r3, r3, #4064	; 0xfe0
   191ea:	331f      	adds	r3, #31
   191ec:	f423 637e 	bic.w	r3, r3, #4064	; 0xfe0
   191f0:	f023 031f 	bic.w	r3, r3, #31
   191f4:	4619      	mov	r1, r3
   191f6:	4630      	mov	r0, r6
   191f8:	9301      	str	r3, [sp, #4]
   191fa:	f001 f8f3 	bl	1a3e4 <_sbrk_r>
   191fe:	9b01      	ldr	r3, [sp, #4]
   19200:	f1b0 3fff 	cmp.w	r0, #4294967295
   19204:	4682      	mov	sl, r0
   19206:	f000 80f4 	beq.w	193f2 <_malloc_r+0x496>
   1920a:	eb08 0109 	add.w	r1, r8, r9
   1920e:	4281      	cmp	r1, r0
   19210:	f200 80ec 	bhi.w	193ec <_malloc_r+0x490>
   19214:	f8db 2004 	ldr.w	r2, [fp, #4]
   19218:	189a      	adds	r2, r3, r2
   1921a:	4551      	cmp	r1, sl
   1921c:	f8cb 2004 	str.w	r2, [fp, #4]
   19220:	f000 8145 	beq.w	194ae <_malloc_r+0x552>
   19224:	f8d5 5408 	ldr.w	r5, [r5, #1032]	; 0x408
   19228:	f240 2010 	movw	r0, #528	; 0x210
   1922c:	f2c2 0000 	movt	r0, #8192	; 0x2000
   19230:	f1b5 3fff 	cmp.w	r5, #4294967295
   19234:	bf08      	it	eq
   19236:	f8c0 a408 	streq.w	sl, [r0, #1032]	; 0x408
   1923a:	d003      	beq.n	19244 <_malloc_r+0x2e8>
   1923c:	4452      	add	r2, sl
   1923e:	1a51      	subs	r1, r2, r1
   19240:	f8cb 1004 	str.w	r1, [fp, #4]
   19244:	f01a 0507 	ands.w	r5, sl, #7
   19248:	4630      	mov	r0, r6
   1924a:	bf17      	itett	ne
   1924c:	f1c5 0508 	rsbne	r5, r5, #8
   19250:	f44f 5580 	moveq.w	r5, #4096	; 0x1000
   19254:	44aa      	addne	sl, r5
   19256:	f505 5580 	addne.w	r5, r5, #4096	; 0x1000
   1925a:	4453      	add	r3, sl
   1925c:	051b      	lsls	r3, r3, #20
   1925e:	0d1b      	lsrs	r3, r3, #20
   19260:	1aed      	subs	r5, r5, r3
   19262:	4629      	mov	r1, r5
   19264:	f001 f8be 	bl	1a3e4 <_sbrk_r>
   19268:	f1b0 3fff 	cmp.w	r0, #4294967295
   1926c:	f000 812c 	beq.w	194c8 <_malloc_r+0x56c>
   19270:	ebca 0100 	rsb	r1, sl, r0
   19274:	1949      	adds	r1, r1, r5
   19276:	f041 0101 	orr.w	r1, r1, #1
   1927a:	f8db 2004 	ldr.w	r2, [fp, #4]
   1927e:	f64a 1364 	movw	r3, #43364	; 0xa964
   19282:	f8c7 a008 	str.w	sl, [r7, #8]
   19286:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1928a:	18aa      	adds	r2, r5, r2
   1928c:	45b8      	cmp	r8, r7
   1928e:	f8cb 2004 	str.w	r2, [fp, #4]
   19292:	f8ca 1004 	str.w	r1, [sl, #4]
   19296:	d017      	beq.n	192c8 <_malloc_r+0x36c>
   19298:	f1b9 0f0f 	cmp.w	r9, #15
   1929c:	f240 80df 	bls.w	1945e <_malloc_r+0x502>
   192a0:	f1a9 010c 	sub.w	r1, r9, #12
   192a4:	2505      	movs	r5, #5
   192a6:	f021 0107 	bic.w	r1, r1, #7
   192aa:	eb08 0001 	add.w	r0, r8, r1
   192ae:	290f      	cmp	r1, #15
   192b0:	6085      	str	r5, [r0, #8]
   192b2:	6045      	str	r5, [r0, #4]
   192b4:	f8d8 0004 	ldr.w	r0, [r8, #4]
   192b8:	f000 0001 	and.w	r0, r0, #1
   192bc:	ea41 0000 	orr.w	r0, r1, r0
   192c0:	f8c8 0004 	str.w	r0, [r8, #4]
   192c4:	f200 80ac 	bhi.w	19420 <_malloc_r+0x4c4>
   192c8:	46d0      	mov	r8, sl
   192ca:	f64a 1364 	movw	r3, #43364	; 0xa964
   192ce:	f8db 102c 	ldr.w	r1, [fp, #44]	; 0x2c
   192d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
   192d6:	428a      	cmp	r2, r1
   192d8:	f8db 1030 	ldr.w	r1, [fp, #48]	; 0x30
   192dc:	bf88      	it	hi
   192de:	62da      	strhi	r2, [r3, #44]	; 0x2c
   192e0:	f64a 1364 	movw	r3, #43364	; 0xa964
   192e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
   192e8:	428a      	cmp	r2, r1
   192ea:	bf88      	it	hi
   192ec:	631a      	strhi	r2, [r3, #48]	; 0x30
   192ee:	e082      	b.n	193f6 <_malloc_r+0x49a>
   192f0:	185c      	adds	r4, r3, r1
   192f2:	689a      	ldr	r2, [r3, #8]
   192f4:	68d9      	ldr	r1, [r3, #12]
   192f6:	4630      	mov	r0, r6
   192f8:	6866      	ldr	r6, [r4, #4]
   192fa:	f103 0508 	add.w	r5, r3, #8
   192fe:	608a      	str	r2, [r1, #8]
   19300:	f046 0301 	orr.w	r3, r6, #1
   19304:	60d1      	str	r1, [r2, #12]
   19306:	6063      	str	r3, [r4, #4]
   19308:	f000 f9c4 	bl	19694 <__malloc_unlock>
   1930c:	e65a      	b.n	18fc4 <_malloc_r+0x68>
   1930e:	eb08 0304 	add.w	r3, r8, r4
   19312:	f042 0201 	orr.w	r2, r2, #1
   19316:	f044 0401 	orr.w	r4, r4, #1
   1931a:	4630      	mov	r0, r6
   1931c:	f8c8 4004 	str.w	r4, [r8, #4]
   19320:	f108 0508 	add.w	r5, r8, #8
   19324:	605a      	str	r2, [r3, #4]
   19326:	60bb      	str	r3, [r7, #8]
   19328:	f000 f9b4 	bl	19694 <__malloc_unlock>
   1932c:	e64a      	b.n	18fc4 <_malloc_r+0x68>
   1932e:	ea4f 225c 	mov.w	r2, ip, lsr #9
   19332:	2a04      	cmp	r2, #4
   19334:	d954      	bls.n	193e0 <_malloc_r+0x484>
   19336:	2a14      	cmp	r2, #20
   19338:	f200 8089 	bhi.w	1944e <_malloc_r+0x4f2>
   1933c:	325b      	adds	r2, #91	; 0x5b
   1933e:	ea4f 08c2 	mov.w	r8, r2, lsl #3
   19342:	44a8      	add	r8, r5
   19344:	f240 2710 	movw	r7, #528	; 0x210
   19348:	f2c2 0700 	movt	r7, #8192	; 0x2000
   1934c:	f8d8 0008 	ldr.w	r0, [r8, #8]
   19350:	4540      	cmp	r0, r8
   19352:	d103      	bne.n	1935c <_malloc_r+0x400>
   19354:	e06f      	b.n	19436 <_malloc_r+0x4da>
   19356:	6880      	ldr	r0, [r0, #8]
   19358:	4580      	cmp	r8, r0
   1935a:	d004      	beq.n	19366 <_malloc_r+0x40a>
   1935c:	6842      	ldr	r2, [r0, #4]
   1935e:	f022 0203 	bic.w	r2, r2, #3
   19362:	4594      	cmp	ip, r2
   19364:	d3f7      	bcc.n	19356 <_malloc_r+0x3fa>
   19366:	f8d0 c00c 	ldr.w	ip, [r0, #12]
   1936a:	f8c3 c00c 	str.w	ip, [r3, #12]
   1936e:	6098      	str	r0, [r3, #8]
   19370:	687a      	ldr	r2, [r7, #4]
   19372:	60c3      	str	r3, [r0, #12]
   19374:	f8cc 3008 	str.w	r3, [ip, #8]
   19378:	e68a      	b.n	19090 <_malloc_r+0x134>
   1937a:	191f      	adds	r7, r3, r4
   1937c:	4630      	mov	r0, r6
   1937e:	f044 0401 	orr.w	r4, r4, #1
   19382:	60cf      	str	r7, [r1, #12]
   19384:	605c      	str	r4, [r3, #4]
   19386:	f103 0508 	add.w	r5, r3, #8
   1938a:	50ba      	str	r2, [r7, r2]
   1938c:	f042 0201 	orr.w	r2, r2, #1
   19390:	608f      	str	r7, [r1, #8]
   19392:	607a      	str	r2, [r7, #4]
   19394:	60b9      	str	r1, [r7, #8]
   19396:	60f9      	str	r1, [r7, #12]
   19398:	f000 f97c 	bl	19694 <__malloc_unlock>
   1939c:	e612      	b.n	18fc4 <_malloc_r+0x68>
   1939e:	f10a 0a01 	add.w	sl, sl, #1
   193a2:	f01a 0f03 	tst.w	sl, #3
   193a6:	d05f      	beq.n	19468 <_malloc_r+0x50c>
   193a8:	f103 0808 	add.w	r8, r3, #8
   193ac:	e689      	b.n	190c2 <_malloc_r+0x166>
   193ae:	f103 0208 	add.w	r2, r3, #8
   193b2:	68d3      	ldr	r3, [r2, #12]
   193b4:	429a      	cmp	r2, r3
   193b6:	bf08      	it	eq
   193b8:	f10e 0e02 	addeq.w	lr, lr, #2
   193bc:	f43f ae36 	beq.w	1902c <_malloc_r+0xd0>
   193c0:	e5ef      	b.n	18fa2 <_malloc_r+0x46>
   193c2:	461d      	mov	r5, r3
   193c4:	1819      	adds	r1, r3, r0
   193c6:	68da      	ldr	r2, [r3, #12]
   193c8:	4630      	mov	r0, r6
   193ca:	f855 3f08 	ldr.w	r3, [r5, #8]!
   193ce:	684c      	ldr	r4, [r1, #4]
   193d0:	6093      	str	r3, [r2, #8]
   193d2:	f044 0401 	orr.w	r4, r4, #1
   193d6:	60da      	str	r2, [r3, #12]
   193d8:	604c      	str	r4, [r1, #4]
   193da:	f000 f95b 	bl	19694 <__malloc_unlock>
   193de:	e5f1      	b.n	18fc4 <_malloc_r+0x68>
   193e0:	ea4f 129c 	mov.w	r2, ip, lsr #6
   193e4:	3238      	adds	r2, #56	; 0x38
   193e6:	ea4f 08c2 	mov.w	r8, r2, lsl #3
   193ea:	e7aa      	b.n	19342 <_malloc_r+0x3e6>
   193ec:	45b8      	cmp	r8, r7
   193ee:	f43f af11 	beq.w	19214 <_malloc_r+0x2b8>
   193f2:	f8d7 8008 	ldr.w	r8, [r7, #8]
   193f6:	f8d8 2004 	ldr.w	r2, [r8, #4]
   193fa:	f022 0203 	bic.w	r2, r2, #3
   193fe:	4294      	cmp	r4, r2
   19400:	bf94      	ite	ls
   19402:	2300      	movls	r3, #0
   19404:	2301      	movhi	r3, #1
   19406:	1b12      	subs	r2, r2, r4
   19408:	2a0f      	cmp	r2, #15
   1940a:	bfd8      	it	le
   1940c:	f043 0301 	orrle.w	r3, r3, #1
   19410:	2b00      	cmp	r3, #0
   19412:	f43f af7c 	beq.w	1930e <_malloc_r+0x3b2>
   19416:	4630      	mov	r0, r6
   19418:	2500      	movs	r5, #0
   1941a:	f000 f93b 	bl	19694 <__malloc_unlock>
   1941e:	e5d1      	b.n	18fc4 <_malloc_r+0x68>
   19420:	f108 0108 	add.w	r1, r8, #8
   19424:	4630      	mov	r0, r6
   19426:	9301      	str	r3, [sp, #4]
   19428:	f7ff fc6e 	bl	18d08 <_free_r>
   1942c:	9b01      	ldr	r3, [sp, #4]
   1942e:	f8d7 8008 	ldr.w	r8, [r7, #8]
   19432:	685a      	ldr	r2, [r3, #4]
   19434:	e749      	b.n	192ca <_malloc_r+0x36e>
   19436:	f04f 0a01 	mov.w	sl, #1
   1943a:	f8d7 8004 	ldr.w	r8, [r7, #4]
   1943e:	1092      	asrs	r2, r2, #2
   19440:	4684      	mov	ip, r0
   19442:	fa0a f202 	lsl.w	r2, sl, r2
   19446:	ea48 0202 	orr.w	r2, r8, r2
   1944a:	607a      	str	r2, [r7, #4]
   1944c:	e78d      	b.n	1936a <_malloc_r+0x40e>
   1944e:	2a54      	cmp	r2, #84	; 0x54
   19450:	d824      	bhi.n	1949c <_malloc_r+0x540>
   19452:	ea4f 321c 	mov.w	r2, ip, lsr #12
   19456:	326e      	adds	r2, #110	; 0x6e
   19458:	ea4f 08c2 	mov.w	r8, r2, lsl #3
   1945c:	e771      	b.n	19342 <_malloc_r+0x3e6>
   1945e:	2301      	movs	r3, #1
   19460:	46d0      	mov	r8, sl
   19462:	f8ca 3004 	str.w	r3, [sl, #4]
   19466:	e7c6      	b.n	193f6 <_malloc_r+0x49a>
   19468:	464a      	mov	r2, r9
   1946a:	f01e 0f03 	tst.w	lr, #3
   1946e:	4613      	mov	r3, r2
   19470:	f10e 3eff 	add.w	lr, lr, #4294967295
   19474:	d033      	beq.n	194de <_malloc_r+0x582>
   19476:	f853 2908 	ldr.w	r2, [r3], #-8
   1947a:	429a      	cmp	r2, r3
   1947c:	d0f5      	beq.n	1946a <_malloc_r+0x50e>
   1947e:	687b      	ldr	r3, [r7, #4]
   19480:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
   19484:	459c      	cmp	ip, r3
   19486:	f63f ae8e 	bhi.w	191a6 <_malloc_r+0x24a>
   1948a:	f1bc 0f00 	cmp.w	ip, #0
   1948e:	f43f ae8a 	beq.w	191a6 <_malloc_r+0x24a>
   19492:	ea1c 0f03 	tst.w	ip, r3
   19496:	d027      	beq.n	194e8 <_malloc_r+0x58c>
   19498:	46d6      	mov	lr, sl
   1949a:	e60e      	b.n	190ba <_malloc_r+0x15e>
   1949c:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
   194a0:	d815      	bhi.n	194ce <_malloc_r+0x572>
   194a2:	ea4f 32dc 	mov.w	r2, ip, lsr #15
   194a6:	3277      	adds	r2, #119	; 0x77
   194a8:	ea4f 08c2 	mov.w	r8, r2, lsl #3
   194ac:	e749      	b.n	19342 <_malloc_r+0x3e6>
   194ae:	0508      	lsls	r0, r1, #20
   194b0:	0d00      	lsrs	r0, r0, #20
   194b2:	2800      	cmp	r0, #0
   194b4:	f47f aeb6 	bne.w	19224 <_malloc_r+0x2c8>
   194b8:	f8d7 8008 	ldr.w	r8, [r7, #8]
   194bc:	444b      	add	r3, r9
   194be:	f043 0301 	orr.w	r3, r3, #1
   194c2:	f8c8 3004 	str.w	r3, [r8, #4]
   194c6:	e700      	b.n	192ca <_malloc_r+0x36e>
   194c8:	2101      	movs	r1, #1
   194ca:	2500      	movs	r5, #0
   194cc:	e6d5      	b.n	1927a <_malloc_r+0x31e>
   194ce:	f240 5054 	movw	r0, #1364	; 0x554
   194d2:	4282      	cmp	r2, r0
   194d4:	d90d      	bls.n	194f2 <_malloc_r+0x596>
   194d6:	f44f 787c 	mov.w	r8, #1008	; 0x3f0
   194da:	227e      	movs	r2, #126	; 0x7e
   194dc:	e731      	b.n	19342 <_malloc_r+0x3e6>
   194de:	687b      	ldr	r3, [r7, #4]
   194e0:	ea23 030c 	bic.w	r3, r3, ip
   194e4:	607b      	str	r3, [r7, #4]
   194e6:	e7cb      	b.n	19480 <_malloc_r+0x524>
   194e8:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
   194ec:	f10a 0a04 	add.w	sl, sl, #4
   194f0:	e7cf      	b.n	19492 <_malloc_r+0x536>
   194f2:	ea4f 429c 	mov.w	r2, ip, lsr #18
   194f6:	327c      	adds	r2, #124	; 0x7c
   194f8:	ea4f 08c2 	mov.w	r8, r2, lsl #3
   194fc:	e721      	b.n	19342 <_malloc_r+0x3e6>
   194fe:	bf00      	nop

00019500 <memchr>:
   19500:	f010 0f03 	tst.w	r0, #3
   19504:	b2c9      	uxtb	r1, r1
   19506:	b410      	push	{r4}
   19508:	d010      	beq.n	1952c <memchr+0x2c>
   1950a:	2a00      	cmp	r2, #0
   1950c:	d02f      	beq.n	1956e <memchr+0x6e>
   1950e:	7803      	ldrb	r3, [r0, #0]
   19510:	428b      	cmp	r3, r1
   19512:	d02a      	beq.n	1956a <memchr+0x6a>
   19514:	3a01      	subs	r2, #1
   19516:	e005      	b.n	19524 <memchr+0x24>
   19518:	2a00      	cmp	r2, #0
   1951a:	d028      	beq.n	1956e <memchr+0x6e>
   1951c:	7803      	ldrb	r3, [r0, #0]
   1951e:	3a01      	subs	r2, #1
   19520:	428b      	cmp	r3, r1
   19522:	d022      	beq.n	1956a <memchr+0x6a>
   19524:	3001      	adds	r0, #1
   19526:	f010 0f03 	tst.w	r0, #3
   1952a:	d1f5      	bne.n	19518 <memchr+0x18>
   1952c:	2a03      	cmp	r2, #3
   1952e:	d911      	bls.n	19554 <memchr+0x54>
   19530:	ea41 2401 	orr.w	r4, r1, r1, lsl #8
   19534:	ea44 4404 	orr.w	r4, r4, r4, lsl #16
   19538:	6803      	ldr	r3, [r0, #0]
   1953a:	ea84 0303 	eor.w	r3, r4, r3
   1953e:	f1a3 3c01 	sub.w	ip, r3, #16843009	; 0x1010101
   19542:	ea2c 0303 	bic.w	r3, ip, r3
   19546:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   1954a:	d103      	bne.n	19554 <memchr+0x54>
   1954c:	3a04      	subs	r2, #4
   1954e:	3004      	adds	r0, #4
   19550:	2a03      	cmp	r2, #3
   19552:	d8f1      	bhi.n	19538 <memchr+0x38>
   19554:	b15a      	cbz	r2, 1956e <memchr+0x6e>
   19556:	7803      	ldrb	r3, [r0, #0]
   19558:	428b      	cmp	r3, r1
   1955a:	d006      	beq.n	1956a <memchr+0x6a>
   1955c:	3a01      	subs	r2, #1
   1955e:	b132      	cbz	r2, 1956e <memchr+0x6e>
   19560:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   19564:	3a01      	subs	r2, #1
   19566:	428b      	cmp	r3, r1
   19568:	d1f9      	bne.n	1955e <memchr+0x5e>
   1956a:	bc10      	pop	{r4}
   1956c:	4770      	bx	lr
   1956e:	2000      	movs	r0, #0
   19570:	e7fb      	b.n	1956a <memchr+0x6a>
   19572:	bf00      	nop

00019574 <memcmp>:
   19574:	2a03      	cmp	r2, #3
   19576:	b430      	push	{r4, r5}
   19578:	4605      	mov	r5, r0
   1957a:	460c      	mov	r4, r1
   1957c:	d925      	bls.n	195ca <memcmp+0x56>
   1957e:	ea41 0300 	orr.w	r3, r1, r0
   19582:	f013 0f03 	tst.w	r3, #3
   19586:	d015      	beq.n	195b4 <memcmp+0x40>
   19588:	7828      	ldrb	r0, [r5, #0]
   1958a:	f894 c000 	ldrb.w	ip, [r4]
   1958e:	4560      	cmp	r0, ip
   19590:	d11e      	bne.n	195d0 <memcmp+0x5c>
   19592:	3a01      	subs	r2, #1
   19594:	2300      	movs	r3, #0
   19596:	e006      	b.n	195a6 <memcmp+0x32>
   19598:	7840      	ldrb	r0, [r0, #1]
   1959a:	3301      	adds	r3, #1
   1959c:	f891 c001 	ldrb.w	ip, [r1, #1]
   195a0:	3a01      	subs	r2, #1
   195a2:	4560      	cmp	r0, ip
   195a4:	d114      	bne.n	195d0 <memcmp+0x5c>
   195a6:	18e8      	adds	r0, r5, r3
   195a8:	18e1      	adds	r1, r4, r3
   195aa:	2a00      	cmp	r2, #0
   195ac:	d1f4      	bne.n	19598 <memcmp+0x24>
   195ae:	2000      	movs	r0, #0
   195b0:	bc30      	pop	{r4, r5}
   195b2:	4770      	bx	lr
   195b4:	6804      	ldr	r4, [r0, #0]
   195b6:	680b      	ldr	r3, [r1, #0]
   195b8:	429c      	cmp	r4, r3
   195ba:	d104      	bne.n	195c6 <memcmp+0x52>
   195bc:	3a04      	subs	r2, #4
   195be:	3004      	adds	r0, #4
   195c0:	3104      	adds	r1, #4
   195c2:	2a03      	cmp	r2, #3
   195c4:	d8f6      	bhi.n	195b4 <memcmp+0x40>
   195c6:	4605      	mov	r5, r0
   195c8:	460c      	mov	r4, r1
   195ca:	2a00      	cmp	r2, #0
   195cc:	d1dc      	bne.n	19588 <memcmp+0x14>
   195ce:	e7ee      	b.n	195ae <memcmp+0x3a>
   195d0:	ebcc 0000 	rsb	r0, ip, r0
   195d4:	e7ec      	b.n	195b0 <memcmp+0x3c>
   195d6:	bf00      	nop

000195d8 <memmove>:
   195d8:	4288      	cmp	r0, r1
   195da:	468c      	mov	ip, r1
   195dc:	b470      	push	{r4, r5, r6}
   195de:	4605      	mov	r5, r0
   195e0:	4614      	mov	r4, r2
   195e2:	d90e      	bls.n	19602 <memmove+0x2a>
   195e4:	188b      	adds	r3, r1, r2
   195e6:	4298      	cmp	r0, r3
   195e8:	d20b      	bcs.n	19602 <memmove+0x2a>
   195ea:	b142      	cbz	r2, 195fe <memmove+0x26>
   195ec:	ebc2 0c03 	rsb	ip, r2, r3
   195f0:	4601      	mov	r1, r0
   195f2:	1e53      	subs	r3, r2, #1
   195f4:	f81c 2003 	ldrb.w	r2, [ip, r3]
   195f8:	54ca      	strb	r2, [r1, r3]
   195fa:	3b01      	subs	r3, #1
   195fc:	d2fa      	bcs.n	195f4 <memmove+0x1c>
   195fe:	bc70      	pop	{r4, r5, r6}
   19600:	4770      	bx	lr
   19602:	2a0f      	cmp	r2, #15
   19604:	d809      	bhi.n	1961a <memmove+0x42>
   19606:	2c00      	cmp	r4, #0
   19608:	d0f9      	beq.n	195fe <memmove+0x26>
   1960a:	2300      	movs	r3, #0
   1960c:	f81c 2003 	ldrb.w	r2, [ip, r3]
   19610:	54ea      	strb	r2, [r5, r3]
   19612:	3301      	adds	r3, #1
   19614:	42a3      	cmp	r3, r4
   19616:	d1f9      	bne.n	1960c <memmove+0x34>
   19618:	e7f1      	b.n	195fe <memmove+0x26>
   1961a:	ea41 0300 	orr.w	r3, r1, r0
   1961e:	f013 0f03 	tst.w	r3, #3
   19622:	d1f0      	bne.n	19606 <memmove+0x2e>
   19624:	4694      	mov	ip, r2
   19626:	460c      	mov	r4, r1
   19628:	4603      	mov	r3, r0
   1962a:	6825      	ldr	r5, [r4, #0]
   1962c:	f1ac 0c10 	sub.w	ip, ip, #16
   19630:	601d      	str	r5, [r3, #0]
   19632:	6865      	ldr	r5, [r4, #4]
   19634:	605d      	str	r5, [r3, #4]
   19636:	68a5      	ldr	r5, [r4, #8]
   19638:	609d      	str	r5, [r3, #8]
   1963a:	68e5      	ldr	r5, [r4, #12]
   1963c:	3410      	adds	r4, #16
   1963e:	60dd      	str	r5, [r3, #12]
   19640:	3310      	adds	r3, #16
   19642:	f1bc 0f0f 	cmp.w	ip, #15
   19646:	d8f0      	bhi.n	1962a <memmove+0x52>
   19648:	3a10      	subs	r2, #16
   1964a:	ea4f 1c12 	mov.w	ip, r2, lsr #4
   1964e:	f10c 0501 	add.w	r5, ip, #1
   19652:	ebcc 7c0c 	rsb	ip, ip, ip, lsl #28
   19656:	012d      	lsls	r5, r5, #4
   19658:	eb02 160c 	add.w	r6, r2, ip, lsl #4
   1965c:	eb01 0c05 	add.w	ip, r1, r5
   19660:	1945      	adds	r5, r0, r5
   19662:	2e03      	cmp	r6, #3
   19664:	4634      	mov	r4, r6
   19666:	d9ce      	bls.n	19606 <memmove+0x2e>
   19668:	2300      	movs	r3, #0
   1966a:	f85c 2003 	ldr.w	r2, [ip, r3]
   1966e:	50ea      	str	r2, [r5, r3]
   19670:	3304      	adds	r3, #4
   19672:	1af2      	subs	r2, r6, r3
   19674:	2a03      	cmp	r2, #3
   19676:	d8f8      	bhi.n	1966a <memmove+0x92>
   19678:	3e04      	subs	r6, #4
   1967a:	08b3      	lsrs	r3, r6, #2
   1967c:	1c5a      	adds	r2, r3, #1
   1967e:	ebc3 7383 	rsb	r3, r3, r3, lsl #30
   19682:	0092      	lsls	r2, r2, #2
   19684:	4494      	add	ip, r2
   19686:	eb06 0483 	add.w	r4, r6, r3, lsl #2
   1968a:	18ad      	adds	r5, r5, r2
   1968c:	e7bb      	b.n	19606 <memmove+0x2e>
   1968e:	bf00      	nop

00019690 <__malloc_lock>:
   19690:	4770      	bx	lr
   19692:	bf00      	nop

00019694 <__malloc_unlock>:
   19694:	4770      	bx	lr
   19696:	bf00      	nop

00019698 <__hi0bits>:
   19698:	0c02      	lsrs	r2, r0, #16
   1969a:	4603      	mov	r3, r0
   1969c:	0412      	lsls	r2, r2, #16
   1969e:	b1b2      	cbz	r2, 196ce <__hi0bits+0x36>
   196a0:	2000      	movs	r0, #0
   196a2:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
   196a6:	d101      	bne.n	196ac <__hi0bits+0x14>
   196a8:	3008      	adds	r0, #8
   196aa:	021b      	lsls	r3, r3, #8
   196ac:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
   196b0:	d101      	bne.n	196b6 <__hi0bits+0x1e>
   196b2:	3004      	adds	r0, #4
   196b4:	011b      	lsls	r3, r3, #4
   196b6:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
   196ba:	d101      	bne.n	196c0 <__hi0bits+0x28>
   196bc:	3002      	adds	r0, #2
   196be:	009b      	lsls	r3, r3, #2
   196c0:	2b00      	cmp	r3, #0
   196c2:	db03      	blt.n	196cc <__hi0bits+0x34>
   196c4:	f013 4f80 	tst.w	r3, #1073741824	; 0x40000000
   196c8:	d004      	beq.n	196d4 <__hi0bits+0x3c>
   196ca:	3001      	adds	r0, #1
   196cc:	4770      	bx	lr
   196ce:	0403      	lsls	r3, r0, #16
   196d0:	2010      	movs	r0, #16
   196d2:	e7e6      	b.n	196a2 <__hi0bits+0xa>
   196d4:	2020      	movs	r0, #32
   196d6:	4770      	bx	lr

000196d8 <__lo0bits>:
   196d8:	6803      	ldr	r3, [r0, #0]
   196da:	4602      	mov	r2, r0
   196dc:	f013 0007 	ands.w	r0, r3, #7
   196e0:	d009      	beq.n	196f6 <__lo0bits+0x1e>
   196e2:	f013 0f01 	tst.w	r3, #1
   196e6:	d121      	bne.n	1972c <__lo0bits+0x54>
   196e8:	f013 0f02 	tst.w	r3, #2
   196ec:	d122      	bne.n	19734 <__lo0bits+0x5c>
   196ee:	089b      	lsrs	r3, r3, #2
   196f0:	2002      	movs	r0, #2
   196f2:	6013      	str	r3, [r2, #0]
   196f4:	4770      	bx	lr
   196f6:	b299      	uxth	r1, r3
   196f8:	b909      	cbnz	r1, 196fe <__lo0bits+0x26>
   196fa:	0c1b      	lsrs	r3, r3, #16
   196fc:	2010      	movs	r0, #16
   196fe:	f013 0fff 	tst.w	r3, #255	; 0xff
   19702:	d101      	bne.n	19708 <__lo0bits+0x30>
   19704:	3008      	adds	r0, #8
   19706:	0a1b      	lsrs	r3, r3, #8
   19708:	f013 0f0f 	tst.w	r3, #15
   1970c:	d101      	bne.n	19712 <__lo0bits+0x3a>
   1970e:	3004      	adds	r0, #4
   19710:	091b      	lsrs	r3, r3, #4
   19712:	f013 0f03 	tst.w	r3, #3
   19716:	d101      	bne.n	1971c <__lo0bits+0x44>
   19718:	3002      	adds	r0, #2
   1971a:	089b      	lsrs	r3, r3, #2
   1971c:	f013 0f01 	tst.w	r3, #1
   19720:	d102      	bne.n	19728 <__lo0bits+0x50>
   19722:	085b      	lsrs	r3, r3, #1
   19724:	d004      	beq.n	19730 <__lo0bits+0x58>
   19726:	3001      	adds	r0, #1
   19728:	6013      	str	r3, [r2, #0]
   1972a:	4770      	bx	lr
   1972c:	2000      	movs	r0, #0
   1972e:	4770      	bx	lr
   19730:	2020      	movs	r0, #32
   19732:	4770      	bx	lr
   19734:	085b      	lsrs	r3, r3, #1
   19736:	2001      	movs	r0, #1
   19738:	6013      	str	r3, [r2, #0]
   1973a:	4770      	bx	lr

0001973c <__mcmp>:
   1973c:	4603      	mov	r3, r0
   1973e:	690a      	ldr	r2, [r1, #16]
   19740:	6900      	ldr	r0, [r0, #16]
   19742:	b410      	push	{r4}
   19744:	1a80      	subs	r0, r0, r2
   19746:	d111      	bne.n	1976c <__mcmp+0x30>
   19748:	3204      	adds	r2, #4
   1974a:	f103 0c14 	add.w	ip, r3, #20
   1974e:	0092      	lsls	r2, r2, #2
   19750:	189b      	adds	r3, r3, r2
   19752:	1889      	adds	r1, r1, r2
   19754:	3104      	adds	r1, #4
   19756:	3304      	adds	r3, #4
   19758:	f853 4c04 	ldr.w	r4, [r3, #-4]
   1975c:	3b04      	subs	r3, #4
   1975e:	f851 2c04 	ldr.w	r2, [r1, #-4]
   19762:	3904      	subs	r1, #4
   19764:	4294      	cmp	r4, r2
   19766:	d103      	bne.n	19770 <__mcmp+0x34>
   19768:	459c      	cmp	ip, r3
   1976a:	d3f5      	bcc.n	19758 <__mcmp+0x1c>
   1976c:	bc10      	pop	{r4}
   1976e:	4770      	bx	lr
   19770:	bf38      	it	cc
   19772:	f04f 30ff 	movcc.w	r0, #4294967295
   19776:	d3f9      	bcc.n	1976c <__mcmp+0x30>
   19778:	2001      	movs	r0, #1
   1977a:	e7f7      	b.n	1976c <__mcmp+0x30>

0001977c <__ulp>:
   1977c:	f240 0300 	movw	r3, #0
   19780:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
   19784:	ea01 0303 	and.w	r3, r1, r3
   19788:	f1a3 7350 	sub.w	r3, r3, #54525952	; 0x3400000
   1978c:	2b00      	cmp	r3, #0
   1978e:	dd02      	ble.n	19796 <__ulp+0x1a>
   19790:	4619      	mov	r1, r3
   19792:	2000      	movs	r0, #0
   19794:	4770      	bx	lr
   19796:	425b      	negs	r3, r3
   19798:	151b      	asrs	r3, r3, #20
   1979a:	2b13      	cmp	r3, #19
   1979c:	dd0e      	ble.n	197bc <__ulp+0x40>
   1979e:	3b14      	subs	r3, #20
   197a0:	2b1e      	cmp	r3, #30
   197a2:	dd03      	ble.n	197ac <__ulp+0x30>
   197a4:	2301      	movs	r3, #1
   197a6:	2100      	movs	r1, #0
   197a8:	4618      	mov	r0, r3
   197aa:	4770      	bx	lr
   197ac:	2201      	movs	r2, #1
   197ae:	f1c3 031f 	rsb	r3, r3, #31
   197b2:	2100      	movs	r1, #0
   197b4:	fa12 f303 	lsls.w	r3, r2, r3
   197b8:	4618      	mov	r0, r3
   197ba:	4770      	bx	lr
   197bc:	f44f 2200 	mov.w	r2, #524288	; 0x80000
   197c0:	2000      	movs	r0, #0
   197c2:	fa52 f103 	asrs.w	r1, r2, r3
   197c6:	4770      	bx	lr

000197c8 <__b2d>:
   197c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   197cc:	6904      	ldr	r4, [r0, #16]
   197ce:	f100 0614 	add.w	r6, r0, #20
   197d2:	460f      	mov	r7, r1
   197d4:	3404      	adds	r4, #4
   197d6:	f850 5024 	ldr.w	r5, [r0, r4, lsl #2]
   197da:	eb00 0484 	add.w	r4, r0, r4, lsl #2
   197de:	46a0      	mov	r8, r4
   197e0:	4628      	mov	r0, r5
   197e2:	f7ff ff59 	bl	19698 <__hi0bits>
   197e6:	280a      	cmp	r0, #10
   197e8:	f1c0 0320 	rsb	r3, r0, #32
   197ec:	603b      	str	r3, [r7, #0]
   197ee:	dc14      	bgt.n	1981a <__b2d+0x52>
   197f0:	42a6      	cmp	r6, r4
   197f2:	f1c0 030b 	rsb	r3, r0, #11
   197f6:	d237      	bcs.n	19868 <__b2d+0xa0>
   197f8:	f854 1c04 	ldr.w	r1, [r4, #-4]
   197fc:	40d9      	lsrs	r1, r3
   197fe:	fa25 fc03 	lsr.w	ip, r5, r3
   19802:	3015      	adds	r0, #21
   19804:	f04c 537e 	orr.w	r3, ip, #1065353216	; 0x3f800000
   19808:	4085      	lsls	r5, r0
   1980a:	f443 03e0 	orr.w	r3, r3, #7340032	; 0x700000
   1980e:	ea41 0205 	orr.w	r2, r1, r5
   19812:	4610      	mov	r0, r2
   19814:	4619      	mov	r1, r3
   19816:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1981a:	42a6      	cmp	r6, r4
   1981c:	d320      	bcc.n	19860 <__b2d+0x98>
   1981e:	2100      	movs	r1, #0
   19820:	380b      	subs	r0, #11
   19822:	bf02      	ittt	eq
   19824:	f045 537e 	orreq.w	r3, r5, #1065353216	; 0x3f800000
   19828:	460a      	moveq	r2, r1
   1982a:	f443 03e0 	orreq.w	r3, r3, #7340032	; 0x700000
   1982e:	d0f0      	beq.n	19812 <__b2d+0x4a>
   19830:	42b4      	cmp	r4, r6
   19832:	f1c0 0320 	rsb	r3, r0, #32
   19836:	d919      	bls.n	1986c <__b2d+0xa4>
   19838:	f854 4c04 	ldr.w	r4, [r4, #-4]
   1983c:	40dc      	lsrs	r4, r3
   1983e:	4085      	lsls	r5, r0
   19840:	fa21 fc03 	lsr.w	ip, r1, r3
   19844:	f045 557e 	orr.w	r5, r5, #1065353216	; 0x3f800000
   19848:	fa11 f000 	lsls.w	r0, r1, r0
   1984c:	f445 05e0 	orr.w	r5, r5, #7340032	; 0x700000
   19850:	ea44 0200 	orr.w	r2, r4, r0
   19854:	ea45 030c 	orr.w	r3, r5, ip
   19858:	4610      	mov	r0, r2
   1985a:	4619      	mov	r1, r3
   1985c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   19860:	f854 1c04 	ldr.w	r1, [r4, #-4]
   19864:	3c04      	subs	r4, #4
   19866:	e7db      	b.n	19820 <__b2d+0x58>
   19868:	2100      	movs	r1, #0
   1986a:	e7c8      	b.n	197fe <__b2d+0x36>
   1986c:	2400      	movs	r4, #0
   1986e:	e7e6      	b.n	1983e <__b2d+0x76>

00019870 <__ratio>:
   19870:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   19874:	b083      	sub	sp, #12
   19876:	460e      	mov	r6, r1
   19878:	a901      	add	r1, sp, #4
   1987a:	4607      	mov	r7, r0
   1987c:	f7ff ffa4 	bl	197c8 <__b2d>
   19880:	460d      	mov	r5, r1
   19882:	4604      	mov	r4, r0
   19884:	4669      	mov	r1, sp
   19886:	4630      	mov	r0, r6
   19888:	f7ff ff9e 	bl	197c8 <__b2d>
   1988c:	f8dd c004 	ldr.w	ip, [sp, #4]
   19890:	46a9      	mov	r9, r5
   19892:	46a0      	mov	r8, r4
   19894:	460b      	mov	r3, r1
   19896:	4602      	mov	r2, r0
   19898:	6931      	ldr	r1, [r6, #16]
   1989a:	4616      	mov	r6, r2
   1989c:	6938      	ldr	r0, [r7, #16]
   1989e:	461f      	mov	r7, r3
   198a0:	1a40      	subs	r0, r0, r1
   198a2:	9900      	ldr	r1, [sp, #0]
   198a4:	ebc1 010c 	rsb	r1, r1, ip
   198a8:	eb01 1140 	add.w	r1, r1, r0, lsl #5
   198ac:	2900      	cmp	r1, #0
   198ae:	bfc9      	itett	gt
   198b0:	eb05 5901 	addgt.w	r9, r5, r1, lsl #20
   198b4:	eba3 5701 	suble.w	r7, r3, r1, lsl #20
   198b8:	4624      	movgt	r4, r4
   198ba:	464d      	movgt	r5, r9
   198bc:	bfdc      	itt	le
   198be:	4612      	movle	r2, r2
   198c0:	463b      	movle	r3, r7
   198c2:	4620      	mov	r0, r4
   198c4:	4629      	mov	r1, r5
   198c6:	f7fb f98f 	bl	14be8 <__aeabi_ddiv>
   198ca:	b003      	add	sp, #12
   198cc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

000198d0 <_mprec_log10>:
   198d0:	2817      	cmp	r0, #23
   198d2:	b510      	push	{r4, lr}
   198d4:	4604      	mov	r4, r0
   198d6:	dd0e      	ble.n	198f6 <_mprec_log10+0x26>
   198d8:	f240 0100 	movw	r1, #0
   198dc:	2000      	movs	r0, #0
   198de:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
   198e2:	f240 0300 	movw	r3, #0
   198e6:	2200      	movs	r2, #0
   198e8:	f2c4 0324 	movt	r3, #16420	; 0x4024
   198ec:	f7fb f852 	bl	14994 <__aeabi_dmul>
   198f0:	3c01      	subs	r4, #1
   198f2:	d1f6      	bne.n	198e2 <_mprec_log10+0x12>
   198f4:	bd10      	pop	{r4, pc}
   198f6:	f64f 2308 	movw	r3, #64008	; 0xfa08
   198fa:	f2c0 0302 	movt	r3, #2
   198fe:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
   19902:	e9d3 0100 	ldrd	r0, r1, [r3]
   19906:	bd10      	pop	{r4, pc}

00019908 <__copybits>:
   19908:	6913      	ldr	r3, [r2, #16]
   1990a:	3901      	subs	r1, #1
   1990c:	f102 0c14 	add.w	ip, r2, #20
   19910:	b410      	push	{r4}
   19912:	eb02 0283 	add.w	r2, r2, r3, lsl #2
   19916:	114c      	asrs	r4, r1, #5
   19918:	3214      	adds	r2, #20
   1991a:	3401      	adds	r4, #1
   1991c:	4594      	cmp	ip, r2
   1991e:	eb00 0484 	add.w	r4, r0, r4, lsl #2
   19922:	d20f      	bcs.n	19944 <__copybits+0x3c>
   19924:	2300      	movs	r3, #0
   19926:	f85c 1003 	ldr.w	r1, [ip, r3]
   1992a:	50c1      	str	r1, [r0, r3]
   1992c:	3304      	adds	r3, #4
   1992e:	eb03 010c 	add.w	r1, r3, ip
   19932:	428a      	cmp	r2, r1
   19934:	d8f7      	bhi.n	19926 <__copybits+0x1e>
   19936:	ea6f 0c0c 	mvn.w	ip, ip
   1993a:	4462      	add	r2, ip
   1993c:	f022 0203 	bic.w	r2, r2, #3
   19940:	3204      	adds	r2, #4
   19942:	1880      	adds	r0, r0, r2
   19944:	4284      	cmp	r4, r0
   19946:	d904      	bls.n	19952 <__copybits+0x4a>
   19948:	2300      	movs	r3, #0
   1994a:	f840 3b04 	str.w	r3, [r0], #4
   1994e:	4284      	cmp	r4, r0
   19950:	d8fb      	bhi.n	1994a <__copybits+0x42>
   19952:	bc10      	pop	{r4}
   19954:	4770      	bx	lr
   19956:	bf00      	nop

00019958 <__any_on>:
   19958:	6902      	ldr	r2, [r0, #16]
   1995a:	114b      	asrs	r3, r1, #5
   1995c:	429a      	cmp	r2, r3
   1995e:	db10      	blt.n	19982 <__any_on+0x2a>
   19960:	dd0e      	ble.n	19980 <__any_on+0x28>
   19962:	f011 011f 	ands.w	r1, r1, #31
   19966:	d00b      	beq.n	19980 <__any_on+0x28>
   19968:	461a      	mov	r2, r3
   1996a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
   1996e:	695b      	ldr	r3, [r3, #20]
   19970:	fa23 fc01 	lsr.w	ip, r3, r1
   19974:	fa0c f101 	lsl.w	r1, ip, r1
   19978:	4299      	cmp	r1, r3
   1997a:	d002      	beq.n	19982 <__any_on+0x2a>
   1997c:	2001      	movs	r0, #1
   1997e:	4770      	bx	lr
   19980:	461a      	mov	r2, r3
   19982:	3204      	adds	r2, #4
   19984:	f100 0114 	add.w	r1, r0, #20
   19988:	eb00 0382 	add.w	r3, r0, r2, lsl #2
   1998c:	f103 0c04 	add.w	ip, r3, #4
   19990:	4561      	cmp	r1, ip
   19992:	d20b      	bcs.n	199ac <__any_on+0x54>
   19994:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
   19998:	2a00      	cmp	r2, #0
   1999a:	d1ef      	bne.n	1997c <__any_on+0x24>
   1999c:	4299      	cmp	r1, r3
   1999e:	d205      	bcs.n	199ac <__any_on+0x54>
   199a0:	f853 2d04 	ldr.w	r2, [r3, #-4]!
   199a4:	2a00      	cmp	r2, #0
   199a6:	d1e9      	bne.n	1997c <__any_on+0x24>
   199a8:	4299      	cmp	r1, r3
   199aa:	d3f9      	bcc.n	199a0 <__any_on+0x48>
   199ac:	2000      	movs	r0, #0
   199ae:	4770      	bx	lr

000199b0 <_Bfree>:
   199b0:	b530      	push	{r4, r5, lr}
   199b2:	6a45      	ldr	r5, [r0, #36]	; 0x24
   199b4:	b083      	sub	sp, #12
   199b6:	4604      	mov	r4, r0
   199b8:	b155      	cbz	r5, 199d0 <_Bfree+0x20>
   199ba:	b139      	cbz	r1, 199cc <_Bfree+0x1c>
   199bc:	6a63      	ldr	r3, [r4, #36]	; 0x24
   199be:	684a      	ldr	r2, [r1, #4]
   199c0:	68db      	ldr	r3, [r3, #12]
   199c2:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
   199c6:	6008      	str	r0, [r1, #0]
   199c8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
   199cc:	b003      	add	sp, #12
   199ce:	bd30      	pop	{r4, r5, pc}
   199d0:	2010      	movs	r0, #16
   199d2:	9101      	str	r1, [sp, #4]
   199d4:	f7ff faba 	bl	18f4c <malloc>
   199d8:	9901      	ldr	r1, [sp, #4]
   199da:	6260      	str	r0, [r4, #36]	; 0x24
   199dc:	60c5      	str	r5, [r0, #12]
   199de:	6045      	str	r5, [r0, #4]
   199e0:	6085      	str	r5, [r0, #8]
   199e2:	6005      	str	r5, [r0, #0]
   199e4:	e7e9      	b.n	199ba <_Bfree+0xa>
   199e6:	bf00      	nop

000199e8 <_Balloc>:
   199e8:	b570      	push	{r4, r5, r6, lr}
   199ea:	6a44      	ldr	r4, [r0, #36]	; 0x24
   199ec:	4606      	mov	r6, r0
   199ee:	460d      	mov	r5, r1
   199f0:	b164      	cbz	r4, 19a0c <_Balloc+0x24>
   199f2:	68e2      	ldr	r2, [r4, #12]
   199f4:	b1a2      	cbz	r2, 19a20 <_Balloc+0x38>
   199f6:	f852 3025 	ldr.w	r3, [r2, r5, lsl #2]
   199fa:	b1eb      	cbz	r3, 19a38 <_Balloc+0x50>
   199fc:	6819      	ldr	r1, [r3, #0]
   199fe:	f842 1025 	str.w	r1, [r2, r5, lsl #2]
   19a02:	2200      	movs	r2, #0
   19a04:	60da      	str	r2, [r3, #12]
   19a06:	611a      	str	r2, [r3, #16]
   19a08:	4618      	mov	r0, r3
   19a0a:	bd70      	pop	{r4, r5, r6, pc}
   19a0c:	2010      	movs	r0, #16
   19a0e:	f7ff fa9d 	bl	18f4c <malloc>
   19a12:	2300      	movs	r3, #0
   19a14:	4604      	mov	r4, r0
   19a16:	6270      	str	r0, [r6, #36]	; 0x24
   19a18:	60c3      	str	r3, [r0, #12]
   19a1a:	6043      	str	r3, [r0, #4]
   19a1c:	6083      	str	r3, [r0, #8]
   19a1e:	6003      	str	r3, [r0, #0]
   19a20:	2210      	movs	r2, #16
   19a22:	4630      	mov	r0, r6
   19a24:	2104      	movs	r1, #4
   19a26:	f000 fddf 	bl	1a5e8 <_calloc_r>
   19a2a:	6a73      	ldr	r3, [r6, #36]	; 0x24
   19a2c:	60e0      	str	r0, [r4, #12]
   19a2e:	68da      	ldr	r2, [r3, #12]
   19a30:	2a00      	cmp	r2, #0
   19a32:	d1e0      	bne.n	199f6 <_Balloc+0xe>
   19a34:	4613      	mov	r3, r2
   19a36:	e7e7      	b.n	19a08 <_Balloc+0x20>
   19a38:	2401      	movs	r4, #1
   19a3a:	4630      	mov	r0, r6
   19a3c:	4621      	mov	r1, r4
   19a3e:	40ac      	lsls	r4, r5
   19a40:	1d62      	adds	r2, r4, #5
   19a42:	0092      	lsls	r2, r2, #2
   19a44:	f000 fdd0 	bl	1a5e8 <_calloc_r>
   19a48:	4603      	mov	r3, r0
   19a4a:	2800      	cmp	r0, #0
   19a4c:	d0dc      	beq.n	19a08 <_Balloc+0x20>
   19a4e:	6045      	str	r5, [r0, #4]
   19a50:	6084      	str	r4, [r0, #8]
   19a52:	e7d6      	b.n	19a02 <_Balloc+0x1a>

00019a54 <__d2b>:
   19a54:	e92d 45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
   19a58:	b083      	sub	sp, #12
   19a5a:	2101      	movs	r1, #1
   19a5c:	461d      	mov	r5, r3
   19a5e:	4614      	mov	r4, r2
   19a60:	9f0a      	ldr	r7, [sp, #40]	; 0x28
   19a62:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
   19a64:	f7ff ffc0 	bl	199e8 <_Balloc>
   19a68:	f025 4200 	bic.w	r2, r5, #2147483648	; 0x80000000
   19a6c:	f025 437f 	bic.w	r3, r5, #4278190080	; 0xff000000
   19a70:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
   19a74:	4615      	mov	r5, r2
   19a76:	ea5f 5a12 	movs.w	sl, r2, lsr #20
   19a7a:	9300      	str	r3, [sp, #0]
   19a7c:	bf1c      	itt	ne
   19a7e:	f443 1380 	orrne.w	r3, r3, #1048576	; 0x100000
   19a82:	9300      	strne	r3, [sp, #0]
   19a84:	4680      	mov	r8, r0
   19a86:	2c00      	cmp	r4, #0
   19a88:	d023      	beq.n	19ad2 <__d2b+0x7e>
   19a8a:	a802      	add	r0, sp, #8
   19a8c:	f840 4d04 	str.w	r4, [r0, #-4]!
   19a90:	f7ff fe22 	bl	196d8 <__lo0bits>
   19a94:	4603      	mov	r3, r0
   19a96:	2800      	cmp	r0, #0
   19a98:	d137      	bne.n	19b0a <__d2b+0xb6>
   19a9a:	9901      	ldr	r1, [sp, #4]
   19a9c:	9a00      	ldr	r2, [sp, #0]
   19a9e:	f8c8 1014 	str.w	r1, [r8, #20]
   19aa2:	2a00      	cmp	r2, #0
   19aa4:	bf14      	ite	ne
   19aa6:	2402      	movne	r4, #2
   19aa8:	2401      	moveq	r4, #1
   19aaa:	f8c8 2018 	str.w	r2, [r8, #24]
   19aae:	f8c8 4010 	str.w	r4, [r8, #16]
   19ab2:	f1ba 0f00 	cmp.w	sl, #0
   19ab6:	d01b      	beq.n	19af0 <__d2b+0x9c>
   19ab8:	f5aa 6a86 	sub.w	sl, sl, #1072	; 0x430
   19abc:	f1c3 0235 	rsb	r2, r3, #53	; 0x35
   19ac0:	f1aa 0a03 	sub.w	sl, sl, #3
   19ac4:	4453      	add	r3, sl
   19ac6:	603b      	str	r3, [r7, #0]
   19ac8:	6032      	str	r2, [r6, #0]
   19aca:	4640      	mov	r0, r8
   19acc:	b003      	add	sp, #12
   19ace:	e8bd 85f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, pc}
   19ad2:	4668      	mov	r0, sp
   19ad4:	f7ff fe00 	bl	196d8 <__lo0bits>
   19ad8:	2301      	movs	r3, #1
   19ada:	461c      	mov	r4, r3
   19adc:	f8c8 3010 	str.w	r3, [r8, #16]
   19ae0:	9b00      	ldr	r3, [sp, #0]
   19ae2:	f8c8 3014 	str.w	r3, [r8, #20]
   19ae6:	f100 0320 	add.w	r3, r0, #32
   19aea:	f1ba 0f00 	cmp.w	sl, #0
   19aee:	d1e3      	bne.n	19ab8 <__d2b+0x64>
   19af0:	eb08 0284 	add.w	r2, r8, r4, lsl #2
   19af4:	f5a3 6386 	sub.w	r3, r3, #1072	; 0x430
   19af8:	3b02      	subs	r3, #2
   19afa:	603b      	str	r3, [r7, #0]
   19afc:	6910      	ldr	r0, [r2, #16]
   19afe:	f7ff fdcb 	bl	19698 <__hi0bits>
   19b02:	ebc0 1044 	rsb	r0, r0, r4, lsl #5
   19b06:	6030      	str	r0, [r6, #0]
   19b08:	e7df      	b.n	19aca <__d2b+0x76>
   19b0a:	9a00      	ldr	r2, [sp, #0]
   19b0c:	f1c0 0120 	rsb	r1, r0, #32
   19b10:	fa12 f101 	lsls.w	r1, r2, r1
   19b14:	40c2      	lsrs	r2, r0
   19b16:	9801      	ldr	r0, [sp, #4]
   19b18:	4301      	orrs	r1, r0
   19b1a:	f8c8 1014 	str.w	r1, [r8, #20]
   19b1e:	9200      	str	r2, [sp, #0]
   19b20:	e7bf      	b.n	19aa2 <__d2b+0x4e>
   19b22:	bf00      	nop

00019b24 <__mdiff>:
   19b24:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   19b28:	6913      	ldr	r3, [r2, #16]
   19b2a:	690f      	ldr	r7, [r1, #16]
   19b2c:	460c      	mov	r4, r1
   19b2e:	4615      	mov	r5, r2
   19b30:	1aff      	subs	r7, r7, r3
   19b32:	2f00      	cmp	r7, #0
   19b34:	d04f      	beq.n	19bd6 <__mdiff+0xb2>
   19b36:	db6a      	blt.n	19c0e <__mdiff+0xea>
   19b38:	2700      	movs	r7, #0
   19b3a:	f101 0614 	add.w	r6, r1, #20
   19b3e:	6861      	ldr	r1, [r4, #4]
   19b40:	f7ff ff52 	bl	199e8 <_Balloc>
   19b44:	f8d5 8010 	ldr.w	r8, [r5, #16]
   19b48:	f8d4 c010 	ldr.w	ip, [r4, #16]
   19b4c:	f105 0114 	add.w	r1, r5, #20
   19b50:	2200      	movs	r2, #0
   19b52:	eb05 0588 	add.w	r5, r5, r8, lsl #2
   19b56:	eb04 048c 	add.w	r4, r4, ip, lsl #2
   19b5a:	f105 0814 	add.w	r8, r5, #20
   19b5e:	3414      	adds	r4, #20
   19b60:	f100 0314 	add.w	r3, r0, #20
   19b64:	60c7      	str	r7, [r0, #12]
   19b66:	f851 7b04 	ldr.w	r7, [r1], #4
   19b6a:	f856 5b04 	ldr.w	r5, [r6], #4
   19b6e:	46bb      	mov	fp, r7
   19b70:	fa1f fa87 	uxth.w	sl, r7
   19b74:	0c3f      	lsrs	r7, r7, #16
   19b76:	fa1f f985 	uxth.w	r9, r5
   19b7a:	ebc7 4715 	rsb	r7, r7, r5, lsr #16
   19b7e:	ebca 0a09 	rsb	sl, sl, r9
   19b82:	4452      	add	r2, sl
   19b84:	eb07 4722 	add.w	r7, r7, r2, asr #16
   19b88:	b292      	uxth	r2, r2
   19b8a:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
   19b8e:	f843 2b04 	str.w	r2, [r3], #4
   19b92:	143a      	asrs	r2, r7, #16
   19b94:	4588      	cmp	r8, r1
   19b96:	d8e6      	bhi.n	19b66 <__mdiff+0x42>
   19b98:	42a6      	cmp	r6, r4
   19b9a:	d20e      	bcs.n	19bba <__mdiff+0x96>
   19b9c:	f856 1b04 	ldr.w	r1, [r6], #4
   19ba0:	b28d      	uxth	r5, r1
   19ba2:	0c09      	lsrs	r1, r1, #16
   19ba4:	1952      	adds	r2, r2, r5
   19ba6:	eb01 4122 	add.w	r1, r1, r2, asr #16
   19baa:	b292      	uxth	r2, r2
   19bac:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
   19bb0:	f843 2b04 	str.w	r2, [r3], #4
   19bb4:	140a      	asrs	r2, r1, #16
   19bb6:	42b4      	cmp	r4, r6
   19bb8:	d8f0      	bhi.n	19b9c <__mdiff+0x78>
   19bba:	f853 2c04 	ldr.w	r2, [r3, #-4]
   19bbe:	b932      	cbnz	r2, 19bce <__mdiff+0xaa>
   19bc0:	f853 2c08 	ldr.w	r2, [r3, #-8]
   19bc4:	f10c 3cff 	add.w	ip, ip, #4294967295
   19bc8:	3b04      	subs	r3, #4
   19bca:	2a00      	cmp	r2, #0
   19bcc:	d0f8      	beq.n	19bc0 <__mdiff+0x9c>
   19bce:	f8c0 c010 	str.w	ip, [r0, #16]
   19bd2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   19bd6:	3304      	adds	r3, #4
   19bd8:	f101 0614 	add.w	r6, r1, #20
   19bdc:	009b      	lsls	r3, r3, #2
   19bde:	18d2      	adds	r2, r2, r3
   19be0:	18cb      	adds	r3, r1, r3
   19be2:	3304      	adds	r3, #4
   19be4:	3204      	adds	r2, #4
   19be6:	f853 cc04 	ldr.w	ip, [r3, #-4]
   19bea:	3b04      	subs	r3, #4
   19bec:	f852 1c04 	ldr.w	r1, [r2, #-4]
   19bf0:	3a04      	subs	r2, #4
   19bf2:	458c      	cmp	ip, r1
   19bf4:	d10a      	bne.n	19c0c <__mdiff+0xe8>
   19bf6:	429e      	cmp	r6, r3
   19bf8:	d3f5      	bcc.n	19be6 <__mdiff+0xc2>
   19bfa:	2100      	movs	r1, #0
   19bfc:	f7ff fef4 	bl	199e8 <_Balloc>
   19c00:	2301      	movs	r3, #1
   19c02:	6103      	str	r3, [r0, #16]
   19c04:	2300      	movs	r3, #0
   19c06:	6143      	str	r3, [r0, #20]
   19c08:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   19c0c:	d297      	bcs.n	19b3e <__mdiff+0x1a>
   19c0e:	4623      	mov	r3, r4
   19c10:	462c      	mov	r4, r5
   19c12:	2701      	movs	r7, #1
   19c14:	461d      	mov	r5, r3
   19c16:	f104 0614 	add.w	r6, r4, #20
   19c1a:	e790      	b.n	19b3e <__mdiff+0x1a>

00019c1c <__lshift>:
   19c1c:	e92d 45f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, sl, lr}
   19c20:	690d      	ldr	r5, [r1, #16]
   19c22:	688b      	ldr	r3, [r1, #8]
   19c24:	1156      	asrs	r6, r2, #5
   19c26:	3501      	adds	r5, #1
   19c28:	460c      	mov	r4, r1
   19c2a:	19ad      	adds	r5, r5, r6
   19c2c:	4690      	mov	r8, r2
   19c2e:	429d      	cmp	r5, r3
   19c30:	4682      	mov	sl, r0
   19c32:	6849      	ldr	r1, [r1, #4]
   19c34:	dd03      	ble.n	19c3e <__lshift+0x22>
   19c36:	005b      	lsls	r3, r3, #1
   19c38:	3101      	adds	r1, #1
   19c3a:	429d      	cmp	r5, r3
   19c3c:	dcfb      	bgt.n	19c36 <__lshift+0x1a>
   19c3e:	4650      	mov	r0, sl
   19c40:	f7ff fed2 	bl	199e8 <_Balloc>
   19c44:	2e00      	cmp	r6, #0
   19c46:	4607      	mov	r7, r0
   19c48:	f100 0214 	add.w	r2, r0, #20
   19c4c:	dd0a      	ble.n	19c64 <__lshift+0x48>
   19c4e:	2300      	movs	r3, #0
   19c50:	4619      	mov	r1, r3
   19c52:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
   19c56:	3301      	adds	r3, #1
   19c58:	42b3      	cmp	r3, r6
   19c5a:	d1fa      	bne.n	19c52 <__lshift+0x36>
   19c5c:	eb07 0383 	add.w	r3, r7, r3, lsl #2
   19c60:	f103 0214 	add.w	r2, r3, #20
   19c64:	6920      	ldr	r0, [r4, #16]
   19c66:	f104 0314 	add.w	r3, r4, #20
   19c6a:	eb04 0080 	add.w	r0, r4, r0, lsl #2
   19c6e:	3014      	adds	r0, #20
   19c70:	f018 081f 	ands.w	r8, r8, #31
   19c74:	d01b      	beq.n	19cae <__lshift+0x92>
   19c76:	f1c8 0e20 	rsb	lr, r8, #32
   19c7a:	2100      	movs	r1, #0
   19c7c:	681e      	ldr	r6, [r3, #0]
   19c7e:	fa06 fc08 	lsl.w	ip, r6, r8
   19c82:	ea41 010c 	orr.w	r1, r1, ip
   19c86:	f842 1b04 	str.w	r1, [r2], #4
   19c8a:	f853 1b04 	ldr.w	r1, [r3], #4
   19c8e:	4298      	cmp	r0, r3
   19c90:	fa21 f10e 	lsr.w	r1, r1, lr
   19c94:	d8f2      	bhi.n	19c7c <__lshift+0x60>
   19c96:	6011      	str	r1, [r2, #0]
   19c98:	b101      	cbz	r1, 19c9c <__lshift+0x80>
   19c9a:	3501      	adds	r5, #1
   19c9c:	4650      	mov	r0, sl
   19c9e:	3d01      	subs	r5, #1
   19ca0:	4621      	mov	r1, r4
   19ca2:	613d      	str	r5, [r7, #16]
   19ca4:	f7ff fe84 	bl	199b0 <_Bfree>
   19ca8:	4638      	mov	r0, r7
   19caa:	e8bd 85f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, sl, pc}
   19cae:	f853 1008 	ldr.w	r1, [r3, r8]
   19cb2:	f842 1008 	str.w	r1, [r2, r8]
   19cb6:	f108 0804 	add.w	r8, r8, #4
   19cba:	eb08 0103 	add.w	r1, r8, r3
   19cbe:	4288      	cmp	r0, r1
   19cc0:	d9ec      	bls.n	19c9c <__lshift+0x80>
   19cc2:	f853 1008 	ldr.w	r1, [r3, r8]
   19cc6:	f842 1008 	str.w	r1, [r2, r8]
   19cca:	f108 0804 	add.w	r8, r8, #4
   19cce:	eb08 0103 	add.w	r1, r8, r3
   19cd2:	4288      	cmp	r0, r1
   19cd4:	d8eb      	bhi.n	19cae <__lshift+0x92>
   19cd6:	e7e1      	b.n	19c9c <__lshift+0x80>

00019cd8 <__multiply>:
   19cd8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   19cdc:	f8d1 8010 	ldr.w	r8, [r1, #16]
   19ce0:	6917      	ldr	r7, [r2, #16]
   19ce2:	460d      	mov	r5, r1
   19ce4:	4616      	mov	r6, r2
   19ce6:	b087      	sub	sp, #28
   19ce8:	45b8      	cmp	r8, r7
   19cea:	bfb5      	itete	lt
   19cec:	4615      	movlt	r5, r2
   19cee:	463b      	movge	r3, r7
   19cf0:	460b      	movlt	r3, r1
   19cf2:	4647      	movge	r7, r8
   19cf4:	bfb4      	ite	lt
   19cf6:	461e      	movlt	r6, r3
   19cf8:	4698      	movge	r8, r3
   19cfa:	68ab      	ldr	r3, [r5, #8]
   19cfc:	eb08 0407 	add.w	r4, r8, r7
   19d00:	6869      	ldr	r1, [r5, #4]
   19d02:	429c      	cmp	r4, r3
   19d04:	bfc8      	it	gt
   19d06:	3101      	addgt	r1, #1
   19d08:	f7ff fe6e 	bl	199e8 <_Balloc>
   19d0c:	eb00 0384 	add.w	r3, r0, r4, lsl #2
   19d10:	f100 0b14 	add.w	fp, r0, #20
   19d14:	3314      	adds	r3, #20
   19d16:	9003      	str	r0, [sp, #12]
   19d18:	459b      	cmp	fp, r3
   19d1a:	9304      	str	r3, [sp, #16]
   19d1c:	d206      	bcs.n	19d2c <__multiply+0x54>
   19d1e:	9904      	ldr	r1, [sp, #16]
   19d20:	465b      	mov	r3, fp
   19d22:	2200      	movs	r2, #0
   19d24:	f843 2b04 	str.w	r2, [r3], #4
   19d28:	4299      	cmp	r1, r3
   19d2a:	d8fb      	bhi.n	19d24 <__multiply+0x4c>
   19d2c:	eb06 0888 	add.w	r8, r6, r8, lsl #2
   19d30:	f106 0914 	add.w	r9, r6, #20
   19d34:	f108 0814 	add.w	r8, r8, #20
   19d38:	eb05 0c87 	add.w	ip, r5, r7, lsl #2
   19d3c:	3514      	adds	r5, #20
   19d3e:	45c1      	cmp	r9, r8
   19d40:	f8cd 8004 	str.w	r8, [sp, #4]
   19d44:	f10c 0c14 	add.w	ip, ip, #20
   19d48:	9502      	str	r5, [sp, #8]
   19d4a:	d24b      	bcs.n	19de4 <__multiply+0x10c>
   19d4c:	f04f 0a00 	mov.w	sl, #0
   19d50:	9405      	str	r4, [sp, #20]
   19d52:	f859 400a 	ldr.w	r4, [r9, sl]
   19d56:	eb0a 080b 	add.w	r8, sl, fp
   19d5a:	b2a0      	uxth	r0, r4
   19d5c:	b1d8      	cbz	r0, 19d96 <__multiply+0xbe>
   19d5e:	9a02      	ldr	r2, [sp, #8]
   19d60:	4643      	mov	r3, r8
   19d62:	2400      	movs	r4, #0
   19d64:	f852 5b04 	ldr.w	r5, [r2], #4
   19d68:	6819      	ldr	r1, [r3, #0]
   19d6a:	b2af      	uxth	r7, r5
   19d6c:	0c2d      	lsrs	r5, r5, #16
   19d6e:	b28e      	uxth	r6, r1
   19d70:	0c09      	lsrs	r1, r1, #16
   19d72:	fb00 6607 	mla	r6, r0, r7, r6
   19d76:	fb00 1105 	mla	r1, r0, r5, r1
   19d7a:	1936      	adds	r6, r6, r4
   19d7c:	eb01 4116 	add.w	r1, r1, r6, lsr #16
   19d80:	b2b6      	uxth	r6, r6
   19d82:	0c0c      	lsrs	r4, r1, #16
   19d84:	4594      	cmp	ip, r2
   19d86:	ea46 4601 	orr.w	r6, r6, r1, lsl #16
   19d8a:	f843 6b04 	str.w	r6, [r3], #4
   19d8e:	d8e9      	bhi.n	19d64 <__multiply+0x8c>
   19d90:	601c      	str	r4, [r3, #0]
   19d92:	f859 400a 	ldr.w	r4, [r9, sl]
   19d96:	0c24      	lsrs	r4, r4, #16
   19d98:	d01c      	beq.n	19dd4 <__multiply+0xfc>
   19d9a:	f85b 200a 	ldr.w	r2, [fp, sl]
   19d9e:	4641      	mov	r1, r8
   19da0:	9b02      	ldr	r3, [sp, #8]
   19da2:	2500      	movs	r5, #0
   19da4:	4610      	mov	r0, r2
   19da6:	881e      	ldrh	r6, [r3, #0]
   19da8:	b297      	uxth	r7, r2
   19daa:	fb06 5504 	mla	r5, r6, r4, r5
   19dae:	eb05 4510 	add.w	r5, r5, r0, lsr #16
   19db2:	ea47 4705 	orr.w	r7, r7, r5, lsl #16
   19db6:	600f      	str	r7, [r1, #0]
   19db8:	f851 0f04 	ldr.w	r0, [r1, #4]!
   19dbc:	f853 2b04 	ldr.w	r2, [r3], #4
   19dc0:	b286      	uxth	r6, r0
   19dc2:	0c12      	lsrs	r2, r2, #16
   19dc4:	fb02 6204 	mla	r2, r2, r4, r6
   19dc8:	eb02 4215 	add.w	r2, r2, r5, lsr #16
   19dcc:	0c15      	lsrs	r5, r2, #16
   19dce:	459c      	cmp	ip, r3
   19dd0:	d8e9      	bhi.n	19da6 <__multiply+0xce>
   19dd2:	600a      	str	r2, [r1, #0]
   19dd4:	f10a 0a04 	add.w	sl, sl, #4
   19dd8:	9a01      	ldr	r2, [sp, #4]
   19dda:	eb0a 0309 	add.w	r3, sl, r9
   19dde:	429a      	cmp	r2, r3
   19de0:	d8b7      	bhi.n	19d52 <__multiply+0x7a>
   19de2:	9c05      	ldr	r4, [sp, #20]
   19de4:	2c00      	cmp	r4, #0
   19de6:	dd0b      	ble.n	19e00 <__multiply+0x128>
   19de8:	9a04      	ldr	r2, [sp, #16]
   19dea:	f852 3c04 	ldr.w	r3, [r2, #-4]
   19dee:	b93b      	cbnz	r3, 19e00 <__multiply+0x128>
   19df0:	4613      	mov	r3, r2
   19df2:	e003      	b.n	19dfc <__multiply+0x124>
   19df4:	f853 2c08 	ldr.w	r2, [r3, #-8]
   19df8:	3b04      	subs	r3, #4
   19dfa:	b90a      	cbnz	r2, 19e00 <__multiply+0x128>
   19dfc:	3c01      	subs	r4, #1
   19dfe:	d1f9      	bne.n	19df4 <__multiply+0x11c>
   19e00:	9b03      	ldr	r3, [sp, #12]
   19e02:	4618      	mov	r0, r3
   19e04:	611c      	str	r4, [r3, #16]
   19e06:	b007      	add	sp, #28
   19e08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00019e0c <__i2b>:
   19e0c:	b510      	push	{r4, lr}
   19e0e:	460c      	mov	r4, r1
   19e10:	2101      	movs	r1, #1
   19e12:	f7ff fde9 	bl	199e8 <_Balloc>
   19e16:	2201      	movs	r2, #1
   19e18:	6144      	str	r4, [r0, #20]
   19e1a:	6102      	str	r2, [r0, #16]
   19e1c:	bd10      	pop	{r4, pc}
   19e1e:	bf00      	nop

00019e20 <__multadd>:
   19e20:	e92d 45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
   19e24:	460d      	mov	r5, r1
   19e26:	2100      	movs	r1, #0
   19e28:	4606      	mov	r6, r0
   19e2a:	692c      	ldr	r4, [r5, #16]
   19e2c:	b083      	sub	sp, #12
   19e2e:	f105 0814 	add.w	r8, r5, #20
   19e32:	4608      	mov	r0, r1
   19e34:	f858 7001 	ldr.w	r7, [r8, r1]
   19e38:	3001      	adds	r0, #1
   19e3a:	fa1f fa87 	uxth.w	sl, r7
   19e3e:	ea4f 4c17 	mov.w	ip, r7, lsr #16
   19e42:	fb0a 3302 	mla	r3, sl, r2, r3
   19e46:	fb0c fc02 	mul.w	ip, ip, r2
   19e4a:	eb0c 4c13 	add.w	ip, ip, r3, lsr #16
   19e4e:	b29b      	uxth	r3, r3
   19e50:	eb03 430c 	add.w	r3, r3, ip, lsl #16
   19e54:	f848 3001 	str.w	r3, [r8, r1]
   19e58:	3104      	adds	r1, #4
   19e5a:	4284      	cmp	r4, r0
   19e5c:	ea4f 431c 	mov.w	r3, ip, lsr #16
   19e60:	dce8      	bgt.n	19e34 <__multadd+0x14>
   19e62:	b13b      	cbz	r3, 19e74 <__multadd+0x54>
   19e64:	68aa      	ldr	r2, [r5, #8]
   19e66:	4294      	cmp	r4, r2
   19e68:	da08      	bge.n	19e7c <__multadd+0x5c>
   19e6a:	eb05 0284 	add.w	r2, r5, r4, lsl #2
   19e6e:	3401      	adds	r4, #1
   19e70:	612c      	str	r4, [r5, #16]
   19e72:	6153      	str	r3, [r2, #20]
   19e74:	4628      	mov	r0, r5
   19e76:	b003      	add	sp, #12
   19e78:	e8bd 85f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, pc}
   19e7c:	6869      	ldr	r1, [r5, #4]
   19e7e:	4630      	mov	r0, r6
   19e80:	9301      	str	r3, [sp, #4]
   19e82:	3101      	adds	r1, #1
   19e84:	f7ff fdb0 	bl	199e8 <_Balloc>
   19e88:	692a      	ldr	r2, [r5, #16]
   19e8a:	f105 010c 	add.w	r1, r5, #12
   19e8e:	3202      	adds	r2, #2
   19e90:	0092      	lsls	r2, r2, #2
   19e92:	4607      	mov	r7, r0
   19e94:	300c      	adds	r0, #12
   19e96:	f7fb facd 	bl	15434 <memcpy>
   19e9a:	4629      	mov	r1, r5
   19e9c:	4630      	mov	r0, r6
   19e9e:	463d      	mov	r5, r7
   19ea0:	f7ff fd86 	bl	199b0 <_Bfree>
   19ea4:	9b01      	ldr	r3, [sp, #4]
   19ea6:	e7e0      	b.n	19e6a <__multadd+0x4a>

00019ea8 <__pow5mult>:
   19ea8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   19eac:	4615      	mov	r5, r2
   19eae:	f012 0203 	ands.w	r2, r2, #3
   19eb2:	4604      	mov	r4, r0
   19eb4:	4688      	mov	r8, r1
   19eb6:	d12c      	bne.n	19f12 <__pow5mult+0x6a>
   19eb8:	10ad      	asrs	r5, r5, #2
   19eba:	d01e      	beq.n	19efa <__pow5mult+0x52>
   19ebc:	6a66      	ldr	r6, [r4, #36]	; 0x24
   19ebe:	2e00      	cmp	r6, #0
   19ec0:	d034      	beq.n	19f2c <__pow5mult+0x84>
   19ec2:	68b7      	ldr	r7, [r6, #8]
   19ec4:	2f00      	cmp	r7, #0
   19ec6:	d03b      	beq.n	19f40 <__pow5mult+0x98>
   19ec8:	f015 0f01 	tst.w	r5, #1
   19ecc:	d108      	bne.n	19ee0 <__pow5mult+0x38>
   19ece:	106d      	asrs	r5, r5, #1
   19ed0:	d013      	beq.n	19efa <__pow5mult+0x52>
   19ed2:	683e      	ldr	r6, [r7, #0]
   19ed4:	b1a6      	cbz	r6, 19f00 <__pow5mult+0x58>
   19ed6:	4630      	mov	r0, r6
   19ed8:	4607      	mov	r7, r0
   19eda:	f015 0f01 	tst.w	r5, #1
   19ede:	d0f6      	beq.n	19ece <__pow5mult+0x26>
   19ee0:	4641      	mov	r1, r8
   19ee2:	463a      	mov	r2, r7
   19ee4:	4620      	mov	r0, r4
   19ee6:	f7ff fef7 	bl	19cd8 <__multiply>
   19eea:	4641      	mov	r1, r8
   19eec:	4606      	mov	r6, r0
   19eee:	4620      	mov	r0, r4
   19ef0:	f7ff fd5e 	bl	199b0 <_Bfree>
   19ef4:	106d      	asrs	r5, r5, #1
   19ef6:	46b0      	mov	r8, r6
   19ef8:	d1eb      	bne.n	19ed2 <__pow5mult+0x2a>
   19efa:	4640      	mov	r0, r8
   19efc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   19f00:	4639      	mov	r1, r7
   19f02:	463a      	mov	r2, r7
   19f04:	4620      	mov	r0, r4
   19f06:	f7ff fee7 	bl	19cd8 <__multiply>
   19f0a:	6038      	str	r0, [r7, #0]
   19f0c:	4607      	mov	r7, r0
   19f0e:	6006      	str	r6, [r0, #0]
   19f10:	e7e3      	b.n	19eda <__pow5mult+0x32>
   19f12:	f64f 2c08 	movw	ip, #64008	; 0xfa08
   19f16:	2300      	movs	r3, #0
   19f18:	f2c0 0c02 	movt	ip, #2
   19f1c:	eb0c 0282 	add.w	r2, ip, r2, lsl #2
   19f20:	f8d2 20c4 	ldr.w	r2, [r2, #196]	; 0xc4
   19f24:	f7ff ff7c 	bl	19e20 <__multadd>
   19f28:	4680      	mov	r8, r0
   19f2a:	e7c5      	b.n	19eb8 <__pow5mult+0x10>
   19f2c:	2010      	movs	r0, #16
   19f2e:	f7ff f80d 	bl	18f4c <malloc>
   19f32:	2300      	movs	r3, #0
   19f34:	4606      	mov	r6, r0
   19f36:	6260      	str	r0, [r4, #36]	; 0x24
   19f38:	60c3      	str	r3, [r0, #12]
   19f3a:	6043      	str	r3, [r0, #4]
   19f3c:	6083      	str	r3, [r0, #8]
   19f3e:	6003      	str	r3, [r0, #0]
   19f40:	4620      	mov	r0, r4
   19f42:	f240 2171 	movw	r1, #625	; 0x271
   19f46:	f7ff ff61 	bl	19e0c <__i2b>
   19f4a:	2300      	movs	r3, #0
   19f4c:	60b0      	str	r0, [r6, #8]
   19f4e:	4607      	mov	r7, r0
   19f50:	6003      	str	r3, [r0, #0]
   19f52:	e7b9      	b.n	19ec8 <__pow5mult+0x20>

00019f54 <__s2b>:
   19f54:	e92d 45f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, sl, lr}
   19f58:	461e      	mov	r6, r3
   19f5a:	f648 6339 	movw	r3, #36409	; 0x8e39
   19f5e:	f106 0c08 	add.w	ip, r6, #8
   19f62:	f6c3 03e3 	movt	r3, #14563	; 0x38e3
   19f66:	4688      	mov	r8, r1
   19f68:	4605      	mov	r5, r0
   19f6a:	4617      	mov	r7, r2
   19f6c:	fb83 130c 	smull	r1, r3, r3, ip
   19f70:	ea4f 7cec 	mov.w	ip, ip, asr #31
   19f74:	ebcc 0c63 	rsb	ip, ip, r3, asr #1
   19f78:	f1bc 0f01 	cmp.w	ip, #1
   19f7c:	dd35      	ble.n	19fea <__s2b+0x96>
   19f7e:	2100      	movs	r1, #0
   19f80:	2201      	movs	r2, #1
   19f82:	0052      	lsls	r2, r2, #1
   19f84:	3101      	adds	r1, #1
   19f86:	4594      	cmp	ip, r2
   19f88:	dcfb      	bgt.n	19f82 <__s2b+0x2e>
   19f8a:	4628      	mov	r0, r5
   19f8c:	f7ff fd2c 	bl	199e8 <_Balloc>
   19f90:	9b08      	ldr	r3, [sp, #32]
   19f92:	6143      	str	r3, [r0, #20]
   19f94:	2301      	movs	r3, #1
   19f96:	2f09      	cmp	r7, #9
   19f98:	6103      	str	r3, [r0, #16]
   19f9a:	dd22      	ble.n	19fe2 <__s2b+0x8e>
   19f9c:	f108 0a09 	add.w	sl, r8, #9
   19fa0:	2409      	movs	r4, #9
   19fa2:	f818 3004 	ldrb.w	r3, [r8, r4]
   19fa6:	4601      	mov	r1, r0
   19fa8:	220a      	movs	r2, #10
   19faa:	3401      	adds	r4, #1
   19fac:	3b30      	subs	r3, #48	; 0x30
   19fae:	4628      	mov	r0, r5
   19fb0:	f7ff ff36 	bl	19e20 <__multadd>
   19fb4:	42a7      	cmp	r7, r4
   19fb6:	dcf4      	bgt.n	19fa2 <__s2b+0x4e>
   19fb8:	eb0a 0807 	add.w	r8, sl, r7
   19fbc:	f1a8 0808 	sub.w	r8, r8, #8
   19fc0:	42be      	cmp	r6, r7
   19fc2:	dd0c      	ble.n	19fde <__s2b+0x8a>
   19fc4:	2400      	movs	r4, #0
   19fc6:	f818 3004 	ldrb.w	r3, [r8, r4]
   19fca:	4601      	mov	r1, r0
   19fcc:	3401      	adds	r4, #1
   19fce:	220a      	movs	r2, #10
   19fd0:	3b30      	subs	r3, #48	; 0x30
   19fd2:	4628      	mov	r0, r5
   19fd4:	f7ff ff24 	bl	19e20 <__multadd>
   19fd8:	19e3      	adds	r3, r4, r7
   19fda:	429e      	cmp	r6, r3
   19fdc:	dcf3      	bgt.n	19fc6 <__s2b+0x72>
   19fde:	e8bd 85f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, sl, pc}
   19fe2:	f108 080a 	add.w	r8, r8, #10
   19fe6:	2709      	movs	r7, #9
   19fe8:	e7ea      	b.n	19fc0 <__s2b+0x6c>
   19fea:	2100      	movs	r1, #0
   19fec:	e7cd      	b.n	19f8a <__s2b+0x36>
   19fee:	bf00      	nop

00019ff0 <_realloc_r>:
   19ff0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   19ff4:	4691      	mov	r9, r2
   19ff6:	b083      	sub	sp, #12
   19ff8:	4607      	mov	r7, r0
   19ffa:	460e      	mov	r6, r1
   19ffc:	2900      	cmp	r1, #0
   19ffe:	f000 813a 	beq.w	1a276 <_realloc_r+0x286>
   1a002:	f1a1 0808 	sub.w	r8, r1, #8
   1a006:	f109 040b 	add.w	r4, r9, #11
   1a00a:	f7ff fb41 	bl	19690 <__malloc_lock>
   1a00e:	2c16      	cmp	r4, #22
   1a010:	f8d8 1004 	ldr.w	r1, [r8, #4]
   1a014:	460b      	mov	r3, r1
   1a016:	f200 80a0 	bhi.w	1a15a <_realloc_r+0x16a>
   1a01a:	2210      	movs	r2, #16
   1a01c:	2500      	movs	r5, #0
   1a01e:	4614      	mov	r4, r2
   1a020:	454c      	cmp	r4, r9
   1a022:	bf38      	it	cc
   1a024:	f045 0501 	orrcc.w	r5, r5, #1
   1a028:	2d00      	cmp	r5, #0
   1a02a:	f040 812a 	bne.w	1a282 <_realloc_r+0x292>
   1a02e:	f021 0a03 	bic.w	sl, r1, #3
   1a032:	4592      	cmp	sl, r2
   1a034:	bfa2      	ittt	ge
   1a036:	4640      	movge	r0, r8
   1a038:	4655      	movge	r5, sl
   1a03a:	f108 0808 	addge.w	r8, r8, #8
   1a03e:	da75      	bge.n	1a12c <_realloc_r+0x13c>
   1a040:	f240 2310 	movw	r3, #528	; 0x210
   1a044:	eb08 000a 	add.w	r0, r8, sl
   1a048:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1a04c:	f8d3 e008 	ldr.w	lr, [r3, #8]
   1a050:	4586      	cmp	lr, r0
   1a052:	f000 811a 	beq.w	1a28a <_realloc_r+0x29a>
   1a056:	f8d0 c004 	ldr.w	ip, [r0, #4]
   1a05a:	f02c 0b01 	bic.w	fp, ip, #1
   1a05e:	4483      	add	fp, r0
   1a060:	f8db b004 	ldr.w	fp, [fp, #4]
   1a064:	f01b 0f01 	tst.w	fp, #1
   1a068:	d07c      	beq.n	1a164 <_realloc_r+0x174>
   1a06a:	46ac      	mov	ip, r5
   1a06c:	4628      	mov	r0, r5
   1a06e:	f011 0f01 	tst.w	r1, #1
   1a072:	f040 809b 	bne.w	1a1ac <_realloc_r+0x1bc>
   1a076:	f856 1c08 	ldr.w	r1, [r6, #-8]
   1a07a:	ebc1 0b08 	rsb	fp, r1, r8
   1a07e:	f8db 5004 	ldr.w	r5, [fp, #4]
   1a082:	f025 0503 	bic.w	r5, r5, #3
   1a086:	2800      	cmp	r0, #0
   1a088:	f000 80dd 	beq.w	1a246 <_realloc_r+0x256>
   1a08c:	4570      	cmp	r0, lr
   1a08e:	f000 811f 	beq.w	1a2d0 <_realloc_r+0x2e0>
   1a092:	eb05 030a 	add.w	r3, r5, sl
   1a096:	eb0c 0503 	add.w	r5, ip, r3
   1a09a:	4295      	cmp	r5, r2
   1a09c:	bfb8      	it	lt
   1a09e:	461d      	movlt	r5, r3
   1a0a0:	f2c0 80d2 	blt.w	1a248 <_realloc_r+0x258>
   1a0a4:	6881      	ldr	r1, [r0, #8]
   1a0a6:	465b      	mov	r3, fp
   1a0a8:	68c0      	ldr	r0, [r0, #12]
   1a0aa:	f1aa 0204 	sub.w	r2, sl, #4
   1a0ae:	2a24      	cmp	r2, #36	; 0x24
   1a0b0:	6081      	str	r1, [r0, #8]
   1a0b2:	60c8      	str	r0, [r1, #12]
   1a0b4:	f853 1f08 	ldr.w	r1, [r3, #8]!
   1a0b8:	f8db 000c 	ldr.w	r0, [fp, #12]
   1a0bc:	6081      	str	r1, [r0, #8]
   1a0be:	60c8      	str	r0, [r1, #12]
   1a0c0:	f200 80d0 	bhi.w	1a264 <_realloc_r+0x274>
   1a0c4:	2a13      	cmp	r2, #19
   1a0c6:	469c      	mov	ip, r3
   1a0c8:	d921      	bls.n	1a10e <_realloc_r+0x11e>
   1a0ca:	4631      	mov	r1, r6
   1a0cc:	f10b 0c10 	add.w	ip, fp, #16
   1a0d0:	f851 0b04 	ldr.w	r0, [r1], #4
   1a0d4:	f8cb 0008 	str.w	r0, [fp, #8]
   1a0d8:	6870      	ldr	r0, [r6, #4]
   1a0da:	1d0e      	adds	r6, r1, #4
   1a0dc:	2a1b      	cmp	r2, #27
   1a0de:	f8cb 000c 	str.w	r0, [fp, #12]
   1a0e2:	d914      	bls.n	1a10e <_realloc_r+0x11e>
   1a0e4:	6848      	ldr	r0, [r1, #4]
   1a0e6:	1d31      	adds	r1, r6, #4
   1a0e8:	f10b 0c18 	add.w	ip, fp, #24
   1a0ec:	f8cb 0010 	str.w	r0, [fp, #16]
   1a0f0:	6870      	ldr	r0, [r6, #4]
   1a0f2:	1d0e      	adds	r6, r1, #4
   1a0f4:	2a24      	cmp	r2, #36	; 0x24
   1a0f6:	f8cb 0014 	str.w	r0, [fp, #20]
   1a0fa:	d108      	bne.n	1a10e <_realloc_r+0x11e>
   1a0fc:	684a      	ldr	r2, [r1, #4]
   1a0fe:	f10b 0c20 	add.w	ip, fp, #32
   1a102:	f8cb 2018 	str.w	r2, [fp, #24]
   1a106:	6872      	ldr	r2, [r6, #4]
   1a108:	3608      	adds	r6, #8
   1a10a:	f8cb 201c 	str.w	r2, [fp, #28]
   1a10e:	4631      	mov	r1, r6
   1a110:	4698      	mov	r8, r3
   1a112:	4662      	mov	r2, ip
   1a114:	4658      	mov	r0, fp
   1a116:	f851 3b04 	ldr.w	r3, [r1], #4
   1a11a:	f842 3b04 	str.w	r3, [r2], #4
   1a11e:	6873      	ldr	r3, [r6, #4]
   1a120:	f8cc 3004 	str.w	r3, [ip, #4]
   1a124:	684b      	ldr	r3, [r1, #4]
   1a126:	6053      	str	r3, [r2, #4]
   1a128:	f8db 3004 	ldr.w	r3, [fp, #4]
   1a12c:	ebc4 0c05 	rsb	ip, r4, r5
   1a130:	f1bc 0f0f 	cmp.w	ip, #15
   1a134:	d826      	bhi.n	1a184 <_realloc_r+0x194>
   1a136:	1942      	adds	r2, r0, r5
   1a138:	f003 0301 	and.w	r3, r3, #1
   1a13c:	ea43 0505 	orr.w	r5, r3, r5
   1a140:	6045      	str	r5, [r0, #4]
   1a142:	6853      	ldr	r3, [r2, #4]
   1a144:	f043 0301 	orr.w	r3, r3, #1
   1a148:	6053      	str	r3, [r2, #4]
   1a14a:	4638      	mov	r0, r7
   1a14c:	4645      	mov	r5, r8
   1a14e:	f7ff faa1 	bl	19694 <__malloc_unlock>
   1a152:	4628      	mov	r0, r5
   1a154:	b003      	add	sp, #12
   1a156:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1a15a:	f024 0407 	bic.w	r4, r4, #7
   1a15e:	4622      	mov	r2, r4
   1a160:	0fe5      	lsrs	r5, r4, #31
   1a162:	e75d      	b.n	1a020 <_realloc_r+0x30>
   1a164:	f02c 0c03 	bic.w	ip, ip, #3
   1a168:	eb0c 050a 	add.w	r5, ip, sl
   1a16c:	4295      	cmp	r5, r2
   1a16e:	f6ff af7e 	blt.w	1a06e <_realloc_r+0x7e>
   1a172:	6882      	ldr	r2, [r0, #8]
   1a174:	460b      	mov	r3, r1
   1a176:	68c1      	ldr	r1, [r0, #12]
   1a178:	4640      	mov	r0, r8
   1a17a:	f108 0808 	add.w	r8, r8, #8
   1a17e:	608a      	str	r2, [r1, #8]
   1a180:	60d1      	str	r1, [r2, #12]
   1a182:	e7d3      	b.n	1a12c <_realloc_r+0x13c>
   1a184:	1901      	adds	r1, r0, r4
   1a186:	f003 0301 	and.w	r3, r3, #1
   1a18a:	eb01 020c 	add.w	r2, r1, ip
   1a18e:	ea43 0404 	orr.w	r4, r3, r4
   1a192:	f04c 0301 	orr.w	r3, ip, #1
   1a196:	6044      	str	r4, [r0, #4]
   1a198:	604b      	str	r3, [r1, #4]
   1a19a:	4638      	mov	r0, r7
   1a19c:	6853      	ldr	r3, [r2, #4]
   1a19e:	3108      	adds	r1, #8
   1a1a0:	f043 0301 	orr.w	r3, r3, #1
   1a1a4:	6053      	str	r3, [r2, #4]
   1a1a6:	f7fe fdaf 	bl	18d08 <_free_r>
   1a1aa:	e7ce      	b.n	1a14a <_realloc_r+0x15a>
   1a1ac:	4649      	mov	r1, r9
   1a1ae:	4638      	mov	r0, r7
   1a1b0:	f7fe fed4 	bl	18f5c <_malloc_r>
   1a1b4:	4605      	mov	r5, r0
   1a1b6:	2800      	cmp	r0, #0
   1a1b8:	d041      	beq.n	1a23e <_realloc_r+0x24e>
   1a1ba:	f8d8 3004 	ldr.w	r3, [r8, #4]
   1a1be:	f1a0 0208 	sub.w	r2, r0, #8
   1a1c2:	f023 0101 	bic.w	r1, r3, #1
   1a1c6:	4441      	add	r1, r8
   1a1c8:	428a      	cmp	r2, r1
   1a1ca:	f000 80d7 	beq.w	1a37c <_realloc_r+0x38c>
   1a1ce:	f1aa 0204 	sub.w	r2, sl, #4
   1a1d2:	4631      	mov	r1, r6
   1a1d4:	2a24      	cmp	r2, #36	; 0x24
   1a1d6:	d878      	bhi.n	1a2ca <_realloc_r+0x2da>
   1a1d8:	2a13      	cmp	r2, #19
   1a1da:	4603      	mov	r3, r0
   1a1dc:	d921      	bls.n	1a222 <_realloc_r+0x232>
   1a1de:	4634      	mov	r4, r6
   1a1e0:	f854 3b04 	ldr.w	r3, [r4], #4
   1a1e4:	1d21      	adds	r1, r4, #4
   1a1e6:	f840 3b04 	str.w	r3, [r0], #4
   1a1ea:	1d03      	adds	r3, r0, #4
   1a1ec:	f8d6 c004 	ldr.w	ip, [r6, #4]
   1a1f0:	2a1b      	cmp	r2, #27
   1a1f2:	f8c5 c004 	str.w	ip, [r5, #4]
   1a1f6:	d914      	bls.n	1a222 <_realloc_r+0x232>
   1a1f8:	f8d4 e004 	ldr.w	lr, [r4, #4]
   1a1fc:	1d1c      	adds	r4, r3, #4
   1a1fe:	f101 0c04 	add.w	ip, r1, #4
   1a202:	f8c0 e004 	str.w	lr, [r0, #4]
   1a206:	6848      	ldr	r0, [r1, #4]
   1a208:	f10c 0104 	add.w	r1, ip, #4
   1a20c:	6058      	str	r0, [r3, #4]
   1a20e:	1d23      	adds	r3, r4, #4
   1a210:	2a24      	cmp	r2, #36	; 0x24
   1a212:	d106      	bne.n	1a222 <_realloc_r+0x232>
   1a214:	f8dc 2004 	ldr.w	r2, [ip, #4]
   1a218:	6062      	str	r2, [r4, #4]
   1a21a:	684a      	ldr	r2, [r1, #4]
   1a21c:	3108      	adds	r1, #8
   1a21e:	605a      	str	r2, [r3, #4]
   1a220:	3308      	adds	r3, #8
   1a222:	4608      	mov	r0, r1
   1a224:	461a      	mov	r2, r3
   1a226:	f850 4b04 	ldr.w	r4, [r0], #4
   1a22a:	f842 4b04 	str.w	r4, [r2], #4
   1a22e:	6849      	ldr	r1, [r1, #4]
   1a230:	6059      	str	r1, [r3, #4]
   1a232:	6843      	ldr	r3, [r0, #4]
   1a234:	6053      	str	r3, [r2, #4]
   1a236:	4631      	mov	r1, r6
   1a238:	4638      	mov	r0, r7
   1a23a:	f7fe fd65 	bl	18d08 <_free_r>
   1a23e:	4638      	mov	r0, r7
   1a240:	f7ff fa28 	bl	19694 <__malloc_unlock>
   1a244:	e785      	b.n	1a152 <_realloc_r+0x162>
   1a246:	4455      	add	r5, sl
   1a248:	4295      	cmp	r5, r2
   1a24a:	dbaf      	blt.n	1a1ac <_realloc_r+0x1bc>
   1a24c:	465b      	mov	r3, fp
   1a24e:	f8db 000c 	ldr.w	r0, [fp, #12]
   1a252:	f1aa 0204 	sub.w	r2, sl, #4
   1a256:	f853 1f08 	ldr.w	r1, [r3, #8]!
   1a25a:	2a24      	cmp	r2, #36	; 0x24
   1a25c:	6081      	str	r1, [r0, #8]
   1a25e:	60c8      	str	r0, [r1, #12]
   1a260:	f67f af30 	bls.w	1a0c4 <_realloc_r+0xd4>
   1a264:	4618      	mov	r0, r3
   1a266:	4631      	mov	r1, r6
   1a268:	4698      	mov	r8, r3
   1a26a:	f7ff f9b5 	bl	195d8 <memmove>
   1a26e:	4658      	mov	r0, fp
   1a270:	f8db 3004 	ldr.w	r3, [fp, #4]
   1a274:	e75a      	b.n	1a12c <_realloc_r+0x13c>
   1a276:	4611      	mov	r1, r2
   1a278:	b003      	add	sp, #12
   1a27a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1a27e:	f7fe be6d 	b.w	18f5c <_malloc_r>
   1a282:	230c      	movs	r3, #12
   1a284:	2500      	movs	r5, #0
   1a286:	603b      	str	r3, [r7, #0]
   1a288:	e763      	b.n	1a152 <_realloc_r+0x162>
   1a28a:	f8de 5004 	ldr.w	r5, [lr, #4]
   1a28e:	f104 0b10 	add.w	fp, r4, #16
   1a292:	f025 0c03 	bic.w	ip, r5, #3
   1a296:	eb0c 000a 	add.w	r0, ip, sl
   1a29a:	4558      	cmp	r0, fp
   1a29c:	bfb8      	it	lt
   1a29e:	4670      	movlt	r0, lr
   1a2a0:	f6ff aee5 	blt.w	1a06e <_realloc_r+0x7e>
   1a2a4:	eb08 0204 	add.w	r2, r8, r4
   1a2a8:	1b01      	subs	r1, r0, r4
   1a2aa:	f041 0101 	orr.w	r1, r1, #1
   1a2ae:	609a      	str	r2, [r3, #8]
   1a2b0:	6051      	str	r1, [r2, #4]
   1a2b2:	4638      	mov	r0, r7
   1a2b4:	f8d8 1004 	ldr.w	r1, [r8, #4]
   1a2b8:	4635      	mov	r5, r6
   1a2ba:	f001 0301 	and.w	r3, r1, #1
   1a2be:	431c      	orrs	r4, r3
   1a2c0:	f8c8 4004 	str.w	r4, [r8, #4]
   1a2c4:	f7ff f9e6 	bl	19694 <__malloc_unlock>
   1a2c8:	e743      	b.n	1a152 <_realloc_r+0x162>
   1a2ca:	f7ff f985 	bl	195d8 <memmove>
   1a2ce:	e7b2      	b.n	1a236 <_realloc_r+0x246>
   1a2d0:	4455      	add	r5, sl
   1a2d2:	f104 0110 	add.w	r1, r4, #16
   1a2d6:	44ac      	add	ip, r5
   1a2d8:	458c      	cmp	ip, r1
   1a2da:	dbb5      	blt.n	1a248 <_realloc_r+0x258>
   1a2dc:	465d      	mov	r5, fp
   1a2de:	f8db 000c 	ldr.w	r0, [fp, #12]
   1a2e2:	f1aa 0204 	sub.w	r2, sl, #4
   1a2e6:	f855 1f08 	ldr.w	r1, [r5, #8]!
   1a2ea:	2a24      	cmp	r2, #36	; 0x24
   1a2ec:	6081      	str	r1, [r0, #8]
   1a2ee:	60c8      	str	r0, [r1, #12]
   1a2f0:	d84c      	bhi.n	1a38c <_realloc_r+0x39c>
   1a2f2:	2a13      	cmp	r2, #19
   1a2f4:	4628      	mov	r0, r5
   1a2f6:	d924      	bls.n	1a342 <_realloc_r+0x352>
   1a2f8:	4631      	mov	r1, r6
   1a2fa:	f10b 0010 	add.w	r0, fp, #16
   1a2fe:	f851 eb04 	ldr.w	lr, [r1], #4
   1a302:	f8cb e008 	str.w	lr, [fp, #8]
   1a306:	f8d6 e004 	ldr.w	lr, [r6, #4]
   1a30a:	1d0e      	adds	r6, r1, #4
   1a30c:	2a1b      	cmp	r2, #27
   1a30e:	f8cb e00c 	str.w	lr, [fp, #12]
   1a312:	d916      	bls.n	1a342 <_realloc_r+0x352>
   1a314:	f8d1 e004 	ldr.w	lr, [r1, #4]
   1a318:	1d31      	adds	r1, r6, #4
   1a31a:	f10b 0018 	add.w	r0, fp, #24
   1a31e:	f8cb e010 	str.w	lr, [fp, #16]
   1a322:	f8d6 e004 	ldr.w	lr, [r6, #4]
   1a326:	1d0e      	adds	r6, r1, #4
   1a328:	2a24      	cmp	r2, #36	; 0x24
   1a32a:	f8cb e014 	str.w	lr, [fp, #20]
   1a32e:	d108      	bne.n	1a342 <_realloc_r+0x352>
   1a330:	684a      	ldr	r2, [r1, #4]
   1a332:	f10b 0020 	add.w	r0, fp, #32
   1a336:	f8cb 2018 	str.w	r2, [fp, #24]
   1a33a:	6872      	ldr	r2, [r6, #4]
   1a33c:	3608      	adds	r6, #8
   1a33e:	f8cb 201c 	str.w	r2, [fp, #28]
   1a342:	4631      	mov	r1, r6
   1a344:	4602      	mov	r2, r0
   1a346:	f851 eb04 	ldr.w	lr, [r1], #4
   1a34a:	f842 eb04 	str.w	lr, [r2], #4
   1a34e:	6876      	ldr	r6, [r6, #4]
   1a350:	6046      	str	r6, [r0, #4]
   1a352:	6849      	ldr	r1, [r1, #4]
   1a354:	6051      	str	r1, [r2, #4]
   1a356:	eb0b 0204 	add.w	r2, fp, r4
   1a35a:	ebc4 010c 	rsb	r1, r4, ip
   1a35e:	f041 0101 	orr.w	r1, r1, #1
   1a362:	609a      	str	r2, [r3, #8]
   1a364:	6051      	str	r1, [r2, #4]
   1a366:	4638      	mov	r0, r7
   1a368:	f8db 1004 	ldr.w	r1, [fp, #4]
   1a36c:	f001 0301 	and.w	r3, r1, #1
   1a370:	431c      	orrs	r4, r3
   1a372:	f8cb 4004 	str.w	r4, [fp, #4]
   1a376:	f7ff f98d 	bl	19694 <__malloc_unlock>
   1a37a:	e6ea      	b.n	1a152 <_realloc_r+0x162>
   1a37c:	6855      	ldr	r5, [r2, #4]
   1a37e:	4640      	mov	r0, r8
   1a380:	f108 0808 	add.w	r8, r8, #8
   1a384:	f025 0503 	bic.w	r5, r5, #3
   1a388:	4455      	add	r5, sl
   1a38a:	e6cf      	b.n	1a12c <_realloc_r+0x13c>
   1a38c:	4631      	mov	r1, r6
   1a38e:	4628      	mov	r0, r5
   1a390:	9300      	str	r3, [sp, #0]
   1a392:	f8cd c004 	str.w	ip, [sp, #4]
   1a396:	f7ff f91f 	bl	195d8 <memmove>
   1a39a:	f8dd c004 	ldr.w	ip, [sp, #4]
   1a39e:	9b00      	ldr	r3, [sp, #0]
   1a3a0:	e7d9      	b.n	1a356 <_realloc_r+0x366>
   1a3a2:	bf00      	nop

0001a3a4 <__isinfd>:
   1a3a4:	4602      	mov	r2, r0
   1a3a6:	4240      	negs	r0, r0
   1a3a8:	ea40 0302 	orr.w	r3, r0, r2
   1a3ac:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   1a3b0:	ea41 73d3 	orr.w	r3, r1, r3, lsr #31
   1a3b4:	f1c3 43fe 	rsb	r3, r3, #2130706432	; 0x7f000000
   1a3b8:	f503 0370 	add.w	r3, r3, #15728640	; 0xf00000
   1a3bc:	4258      	negs	r0, r3
   1a3be:	ea40 0303 	orr.w	r3, r0, r3
   1a3c2:	17d8      	asrs	r0, r3, #31
   1a3c4:	3001      	adds	r0, #1
   1a3c6:	4770      	bx	lr

0001a3c8 <__isnand>:
   1a3c8:	4602      	mov	r2, r0
   1a3ca:	4240      	negs	r0, r0
   1a3cc:	4310      	orrs	r0, r2
   1a3ce:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   1a3d2:	ea41 70d0 	orr.w	r0, r1, r0, lsr #31
   1a3d6:	f1c0 40fe 	rsb	r0, r0, #2130706432	; 0x7f000000
   1a3da:	f500 0070 	add.w	r0, r0, #15728640	; 0xf00000
   1a3de:	0fc0      	lsrs	r0, r0, #31
   1a3e0:	4770      	bx	lr
   1a3e2:	bf00      	nop

0001a3e4 <_sbrk_r>:
   1a3e4:	b538      	push	{r3, r4, r5, lr}
   1a3e6:	f64c 44a4 	movw	r4, #52388	; 0xcca4
   1a3ea:	f2c2 0400 	movt	r4, #8192	; 0x2000
   1a3ee:	4605      	mov	r5, r0
   1a3f0:	4608      	mov	r0, r1
   1a3f2:	2300      	movs	r3, #0
   1a3f4:	6023      	str	r3, [r4, #0]
   1a3f6:	f7f0 f98d 	bl	a714 <_sbrk>
   1a3fa:	f1b0 3fff 	cmp.w	r0, #4294967295
   1a3fe:	d000      	beq.n	1a402 <_sbrk_r+0x1e>
   1a400:	bd38      	pop	{r3, r4, r5, pc}
   1a402:	6823      	ldr	r3, [r4, #0]
   1a404:	2b00      	cmp	r3, #0
   1a406:	d0fb      	beq.n	1a400 <_sbrk_r+0x1c>
   1a408:	602b      	str	r3, [r5, #0]
   1a40a:	bd38      	pop	{r3, r4, r5, pc}

0001a40c <strcmp>:
   1a40c:	ea80 0201 	eor.w	r2, r0, r1
   1a410:	f012 0f03 	tst.w	r2, #3
   1a414:	d13a      	bne.n	1a48c <strcmp_unaligned>
   1a416:	f010 0203 	ands.w	r2, r0, #3
   1a41a:	f020 0003 	bic.w	r0, r0, #3
   1a41e:	f021 0103 	bic.w	r1, r1, #3
   1a422:	f850 cb04 	ldr.w	ip, [r0], #4
   1a426:	bf08      	it	eq
   1a428:	f851 3b04 	ldreq.w	r3, [r1], #4
   1a42c:	d00d      	beq.n	1a44a <strcmp+0x3e>
   1a42e:	f082 0203 	eor.w	r2, r2, #3
   1a432:	ea4f 02c2 	mov.w	r2, r2, lsl #3
   1a436:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
   1a43a:	fa23 f202 	lsr.w	r2, r3, r2
   1a43e:	f851 3b04 	ldr.w	r3, [r1], #4
   1a442:	ea4c 0c02 	orr.w	ip, ip, r2
   1a446:	ea43 0302 	orr.w	r3, r3, r2
   1a44a:	bf00      	nop
   1a44c:	f1ac 3201 	sub.w	r2, ip, #16843009	; 0x1010101
   1a450:	459c      	cmp	ip, r3
   1a452:	bf01      	itttt	eq
   1a454:	ea22 020c 	biceq.w	r2, r2, ip
   1a458:	f012 3f80 	tsteq.w	r2, #2155905152	; 0x80808080
   1a45c:	f850 cb04 	ldreq.w	ip, [r0], #4
   1a460:	f851 3b04 	ldreq.w	r3, [r1], #4
   1a464:	d0f2      	beq.n	1a44c <strcmp+0x40>
   1a466:	ea4f 600c 	mov.w	r0, ip, lsl #24
   1a46a:	ea4f 2c1c 	mov.w	ip, ip, lsr #8
   1a46e:	2801      	cmp	r0, #1
   1a470:	bf28      	it	cs
   1a472:	ebb0 6f03 	cmpcs.w	r0, r3, lsl #24
   1a476:	bf08      	it	eq
   1a478:	0a1b      	lsreq	r3, r3, #8
   1a47a:	d0f4      	beq.n	1a466 <strcmp+0x5a>
   1a47c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
   1a480:	ea4f 6010 	mov.w	r0, r0, lsr #24
   1a484:	eba0 0003 	sub.w	r0, r0, r3
   1a488:	4770      	bx	lr
   1a48a:	bf00      	nop

0001a48c <strcmp_unaligned>:
   1a48c:	f010 0f03 	tst.w	r0, #3
   1a490:	d00a      	beq.n	1a4a8 <strcmp_unaligned+0x1c>
   1a492:	f810 2b01 	ldrb.w	r2, [r0], #1
   1a496:	f811 3b01 	ldrb.w	r3, [r1], #1
   1a49a:	2a01      	cmp	r2, #1
   1a49c:	bf28      	it	cs
   1a49e:	429a      	cmpcs	r2, r3
   1a4a0:	d0f4      	beq.n	1a48c <strcmp_unaligned>
   1a4a2:	eba2 0003 	sub.w	r0, r2, r3
   1a4a6:	4770      	bx	lr
   1a4a8:	f84d 5d04 	str.w	r5, [sp, #-4]!
   1a4ac:	f84d 4d04 	str.w	r4, [sp, #-4]!
   1a4b0:	f04f 0201 	mov.w	r2, #1
   1a4b4:	ea42 2202 	orr.w	r2, r2, r2, lsl #8
   1a4b8:	ea42 4202 	orr.w	r2, r2, r2, lsl #16
   1a4bc:	f001 0c03 	and.w	ip, r1, #3
   1a4c0:	f021 0103 	bic.w	r1, r1, #3
   1a4c4:	f850 4b04 	ldr.w	r4, [r0], #4
   1a4c8:	f851 5b04 	ldr.w	r5, [r1], #4
   1a4cc:	f1bc 0f02 	cmp.w	ip, #2
   1a4d0:	d026      	beq.n	1a520 <strcmp_unaligned+0x94>
   1a4d2:	d84b      	bhi.n	1a56c <strcmp_unaligned+0xe0>
   1a4d4:	f024 4c7f 	bic.w	ip, r4, #4278190080	; 0xff000000
   1a4d8:	ebbc 2f15 	cmp.w	ip, r5, lsr #8
   1a4dc:	eba4 0302 	sub.w	r3, r4, r2
   1a4e0:	ea23 0304 	bic.w	r3, r3, r4
   1a4e4:	d10d      	bne.n	1a502 <strcmp_unaligned+0x76>
   1a4e6:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
   1a4ea:	bf08      	it	eq
   1a4ec:	f851 5b04 	ldreq.w	r5, [r1], #4
   1a4f0:	d10a      	bne.n	1a508 <strcmp_unaligned+0x7c>
   1a4f2:	ea8c 0c04 	eor.w	ip, ip, r4
   1a4f6:	ebbc 6f05 	cmp.w	ip, r5, lsl #24
   1a4fa:	d10c      	bne.n	1a516 <strcmp_unaligned+0x8a>
   1a4fc:	f850 4b04 	ldr.w	r4, [r0], #4
   1a500:	e7e8      	b.n	1a4d4 <strcmp_unaligned+0x48>
   1a502:	ea4f 2515 	mov.w	r5, r5, lsr #8
   1a506:	e05c      	b.n	1a5c2 <strcmp_unaligned+0x136>
   1a508:	f033 437f 	bics.w	r3, r3, #4278190080	; 0xff000000
   1a50c:	d152      	bne.n	1a5b4 <strcmp_unaligned+0x128>
   1a50e:	780d      	ldrb	r5, [r1, #0]
   1a510:	ea4f 6c14 	mov.w	ip, r4, lsr #24
   1a514:	e055      	b.n	1a5c2 <strcmp_unaligned+0x136>
   1a516:	ea4f 6c14 	mov.w	ip, r4, lsr #24
   1a51a:	f005 05ff 	and.w	r5, r5, #255	; 0xff
   1a51e:	e050      	b.n	1a5c2 <strcmp_unaligned+0x136>
   1a520:	ea4f 4c04 	mov.w	ip, r4, lsl #16
   1a524:	eba4 0302 	sub.w	r3, r4, r2
   1a528:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
   1a52c:	ea23 0304 	bic.w	r3, r3, r4
   1a530:	ebbc 4f15 	cmp.w	ip, r5, lsr #16
   1a534:	d117      	bne.n	1a566 <strcmp_unaligned+0xda>
   1a536:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
   1a53a:	bf08      	it	eq
   1a53c:	f851 5b04 	ldreq.w	r5, [r1], #4
   1a540:	d107      	bne.n	1a552 <strcmp_unaligned+0xc6>
   1a542:	ea8c 0c04 	eor.w	ip, ip, r4
   1a546:	ebbc 4f05 	cmp.w	ip, r5, lsl #16
   1a54a:	d108      	bne.n	1a55e <strcmp_unaligned+0xd2>
   1a54c:	f850 4b04 	ldr.w	r4, [r0], #4
   1a550:	e7e6      	b.n	1a520 <strcmp_unaligned+0x94>
   1a552:	041b      	lsls	r3, r3, #16
   1a554:	d12e      	bne.n	1a5b4 <strcmp_unaligned+0x128>
   1a556:	880d      	ldrh	r5, [r1, #0]
   1a558:	ea4f 4c14 	mov.w	ip, r4, lsr #16
   1a55c:	e031      	b.n	1a5c2 <strcmp_unaligned+0x136>
   1a55e:	ea4f 4505 	mov.w	r5, r5, lsl #16
   1a562:	ea4f 4c14 	mov.w	ip, r4, lsr #16
   1a566:	ea4f 4515 	mov.w	r5, r5, lsr #16
   1a56a:	e02a      	b.n	1a5c2 <strcmp_unaligned+0x136>
   1a56c:	f004 0cff 	and.w	ip, r4, #255	; 0xff
   1a570:	ebbc 6f15 	cmp.w	ip, r5, lsr #24
   1a574:	eba4 0302 	sub.w	r3, r4, r2
   1a578:	ea23 0304 	bic.w	r3, r3, r4
   1a57c:	d10d      	bne.n	1a59a <strcmp_unaligned+0x10e>
   1a57e:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
   1a582:	bf08      	it	eq
   1a584:	f851 5b04 	ldreq.w	r5, [r1], #4
   1a588:	d10a      	bne.n	1a5a0 <strcmp_unaligned+0x114>
   1a58a:	ea8c 0c04 	eor.w	ip, ip, r4
   1a58e:	ebbc 2f05 	cmp.w	ip, r5, lsl #8
   1a592:	d10a      	bne.n	1a5aa <strcmp_unaligned+0x11e>
   1a594:	f850 4b04 	ldr.w	r4, [r0], #4
   1a598:	e7e8      	b.n	1a56c <strcmp_unaligned+0xe0>
   1a59a:	ea4f 6515 	mov.w	r5, r5, lsr #24
   1a59e:	e010      	b.n	1a5c2 <strcmp_unaligned+0x136>
   1a5a0:	f014 0fff 	tst.w	r4, #255	; 0xff
   1a5a4:	d006      	beq.n	1a5b4 <strcmp_unaligned+0x128>
   1a5a6:	f851 5b04 	ldr.w	r5, [r1], #4
   1a5aa:	ea4f 2c14 	mov.w	ip, r4, lsr #8
   1a5ae:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
   1a5b2:	e006      	b.n	1a5c2 <strcmp_unaligned+0x136>
   1a5b4:	f04f 0000 	mov.w	r0, #0
   1a5b8:	f85d 4b04 	ldr.w	r4, [sp], #4
   1a5bc:	f85d 5b04 	ldr.w	r5, [sp], #4
   1a5c0:	4770      	bx	lr
   1a5c2:	f00c 02ff 	and.w	r2, ip, #255	; 0xff
   1a5c6:	f005 00ff 	and.w	r0, r5, #255	; 0xff
   1a5ca:	2801      	cmp	r0, #1
   1a5cc:	bf28      	it	cs
   1a5ce:	4290      	cmpcs	r0, r2
   1a5d0:	bf04      	itt	eq
   1a5d2:	ea4f 2c1c 	moveq.w	ip, ip, lsr #8
   1a5d6:	0a2d      	lsreq	r5, r5, #8
   1a5d8:	d0f3      	beq.n	1a5c2 <strcmp_unaligned+0x136>
   1a5da:	eba2 0000 	sub.w	r0, r2, r0
   1a5de:	f85d 4b04 	ldr.w	r4, [sp], #4
   1a5e2:	f85d 5b04 	ldr.w	r5, [sp], #4
   1a5e6:	4770      	bx	lr

0001a5e8 <_calloc_r>:
   1a5e8:	b538      	push	{r3, r4, r5, lr}
   1a5ea:	fb01 f102 	mul.w	r1, r1, r2
   1a5ee:	f7fe fcb5 	bl	18f5c <_malloc_r>
   1a5f2:	4604      	mov	r4, r0
   1a5f4:	b1f8      	cbz	r0, 1a636 <_calloc_r+0x4e>
   1a5f6:	f850 2c04 	ldr.w	r2, [r0, #-4]
   1a5fa:	f022 0203 	bic.w	r2, r2, #3
   1a5fe:	3a04      	subs	r2, #4
   1a600:	2a24      	cmp	r2, #36	; 0x24
   1a602:	d81a      	bhi.n	1a63a <_calloc_r+0x52>
   1a604:	2a13      	cmp	r2, #19
   1a606:	4603      	mov	r3, r0
   1a608:	d90f      	bls.n	1a62a <_calloc_r+0x42>
   1a60a:	2100      	movs	r1, #0
   1a60c:	f840 1b04 	str.w	r1, [r0], #4
   1a610:	1d03      	adds	r3, r0, #4
   1a612:	2a1b      	cmp	r2, #27
   1a614:	6061      	str	r1, [r4, #4]
   1a616:	d908      	bls.n	1a62a <_calloc_r+0x42>
   1a618:	1d1d      	adds	r5, r3, #4
   1a61a:	6041      	str	r1, [r0, #4]
   1a61c:	6059      	str	r1, [r3, #4]
   1a61e:	1d2b      	adds	r3, r5, #4
   1a620:	2a24      	cmp	r2, #36	; 0x24
   1a622:	bf02      	ittt	eq
   1a624:	6069      	streq	r1, [r5, #4]
   1a626:	6059      	streq	r1, [r3, #4]
   1a628:	3308      	addeq	r3, #8
   1a62a:	461a      	mov	r2, r3
   1a62c:	2100      	movs	r1, #0
   1a62e:	f842 1b04 	str.w	r1, [r2], #4
   1a632:	6059      	str	r1, [r3, #4]
   1a634:	6051      	str	r1, [r2, #4]
   1a636:	4620      	mov	r0, r4
   1a638:	bd38      	pop	{r3, r4, r5, pc}
   1a63a:	2100      	movs	r1, #0
   1a63c:	f7fa ffc2 	bl	155c4 <memset>
   1a640:	4620      	mov	r0, r4
   1a642:	bd38      	pop	{r3, r4, r5, pc}

0001a644 <_wrapup_reent>:
   1a644:	b570      	push	{r4, r5, r6, lr}
   1a646:	4604      	mov	r4, r0
   1a648:	b188      	cbz	r0, 1a66e <_wrapup_reent+0x2a>
   1a64a:	f104 0248 	add.w	r2, r4, #72	; 0x48
   1a64e:	6853      	ldr	r3, [r2, #4]
   1a650:	1e5d      	subs	r5, r3, #1
   1a652:	d407      	bmi.n	1a664 <_wrapup_reent+0x20>
   1a654:	3302      	adds	r3, #2
   1a656:	eb02 0683 	add.w	r6, r2, r3, lsl #2
   1a65a:	f856 3d04 	ldr.w	r3, [r6, #-4]!
   1a65e:	4798      	blx	r3
   1a660:	3d01      	subs	r5, #1
   1a662:	d5fa      	bpl.n	1a65a <_wrapup_reent+0x16>
   1a664:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1a666:	b10b      	cbz	r3, 1a66c <_wrapup_reent+0x28>
   1a668:	4620      	mov	r0, r4
   1a66a:	4798      	blx	r3
   1a66c:	bd70      	pop	{r4, r5, r6, pc}
   1a66e:	f240 130c 	movw	r3, #268	; 0x10c
   1a672:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1a676:	681c      	ldr	r4, [r3, #0]
   1a678:	e7e7      	b.n	1a64a <_wrapup_reent+0x6>
   1a67a:	bf00      	nop

0001a67c <cleanup_glue>:
   1a67c:	b570      	push	{r4, r5, r6, lr}
   1a67e:	460c      	mov	r4, r1
   1a680:	6809      	ldr	r1, [r1, #0]
   1a682:	4605      	mov	r5, r0
   1a684:	b109      	cbz	r1, 1a68a <cleanup_glue+0xe>
   1a686:	f7ff fff9 	bl	1a67c <cleanup_glue>
   1a68a:	4628      	mov	r0, r5
   1a68c:	4621      	mov	r1, r4
   1a68e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   1a692:	f7fe bb39 	b.w	18d08 <_free_r>
   1a696:	bf00      	nop

0001a698 <_reclaim_reent>:
   1a698:	f240 130c 	movw	r3, #268	; 0x10c
   1a69c:	f2c2 0300 	movt	r3, #8192	; 0x2000
   1a6a0:	b570      	push	{r4, r5, r6, lr}
   1a6a2:	681b      	ldr	r3, [r3, #0]
   1a6a4:	4605      	mov	r5, r0
   1a6a6:	4298      	cmp	r0, r3
   1a6a8:	d046      	beq.n	1a738 <_reclaim_reent+0xa0>
   1a6aa:	6a43      	ldr	r3, [r0, #36]	; 0x24
   1a6ac:	4619      	mov	r1, r3
   1a6ae:	b1bb      	cbz	r3, 1a6e0 <_reclaim_reent+0x48>
   1a6b0:	68da      	ldr	r2, [r3, #12]
   1a6b2:	b1aa      	cbz	r2, 1a6e0 <_reclaim_reent+0x48>
   1a6b4:	2600      	movs	r6, #0
   1a6b6:	5991      	ldr	r1, [r2, r6]
   1a6b8:	b141      	cbz	r1, 1a6cc <_reclaim_reent+0x34>
   1a6ba:	680c      	ldr	r4, [r1, #0]
   1a6bc:	4628      	mov	r0, r5
   1a6be:	f7fe fb23 	bl	18d08 <_free_r>
   1a6c2:	4621      	mov	r1, r4
   1a6c4:	2c00      	cmp	r4, #0
   1a6c6:	d1f8      	bne.n	1a6ba <_reclaim_reent+0x22>
   1a6c8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   1a6ca:	68da      	ldr	r2, [r3, #12]
   1a6cc:	3604      	adds	r6, #4
   1a6ce:	2e3c      	cmp	r6, #60	; 0x3c
   1a6d0:	d001      	beq.n	1a6d6 <_reclaim_reent+0x3e>
   1a6d2:	68da      	ldr	r2, [r3, #12]
   1a6d4:	e7ef      	b.n	1a6b6 <_reclaim_reent+0x1e>
   1a6d6:	4611      	mov	r1, r2
   1a6d8:	4628      	mov	r0, r5
   1a6da:	f7fe fb15 	bl	18d08 <_free_r>
   1a6de:	6a69      	ldr	r1, [r5, #36]	; 0x24
   1a6e0:	6809      	ldr	r1, [r1, #0]
   1a6e2:	b111      	cbz	r1, 1a6ea <_reclaim_reent+0x52>
   1a6e4:	4628      	mov	r0, r5
   1a6e6:	f7fe fb0f 	bl	18d08 <_free_r>
   1a6ea:	6969      	ldr	r1, [r5, #20]
   1a6ec:	b111      	cbz	r1, 1a6f4 <_reclaim_reent+0x5c>
   1a6ee:	4628      	mov	r0, r5
   1a6f0:	f7fe fb0a 	bl	18d08 <_free_r>
   1a6f4:	6a69      	ldr	r1, [r5, #36]	; 0x24
   1a6f6:	b111      	cbz	r1, 1a6fe <_reclaim_reent+0x66>
   1a6f8:	4628      	mov	r0, r5
   1a6fa:	f7fe fb05 	bl	18d08 <_free_r>
   1a6fe:	6ba9      	ldr	r1, [r5, #56]	; 0x38
   1a700:	b111      	cbz	r1, 1a708 <_reclaim_reent+0x70>
   1a702:	4628      	mov	r0, r5
   1a704:	f7fe fb00 	bl	18d08 <_free_r>
   1a708:	6be9      	ldr	r1, [r5, #60]	; 0x3c
   1a70a:	b111      	cbz	r1, 1a712 <_reclaim_reent+0x7a>
   1a70c:	4628      	mov	r0, r5
   1a70e:	f7fe fafb 	bl	18d08 <_free_r>
   1a712:	6c29      	ldr	r1, [r5, #64]	; 0x40
   1a714:	b111      	cbz	r1, 1a71c <_reclaim_reent+0x84>
   1a716:	4628      	mov	r0, r5
   1a718:	f7fe faf6 	bl	18d08 <_free_r>
   1a71c:	6cab      	ldr	r3, [r5, #72]	; 0x48
   1a71e:	f8d3 1088 	ldr.w	r1, [r3, #136]	; 0x88
   1a722:	b111      	cbz	r1, 1a72a <_reclaim_reent+0x92>
   1a724:	4628      	mov	r0, r5
   1a726:	f7fe faef 	bl	18d08 <_free_r>
   1a72a:	6b69      	ldr	r1, [r5, #52]	; 0x34
   1a72c:	b111      	cbz	r1, 1a734 <_reclaim_reent+0x9c>
   1a72e:	4628      	mov	r0, r5
   1a730:	f7fe faea 	bl	18d08 <_free_r>
   1a734:	69ab      	ldr	r3, [r5, #24]
   1a736:	b903      	cbnz	r3, 1a73a <_reclaim_reent+0xa2>
   1a738:	bd70      	pop	{r4, r5, r6, pc}
   1a73a:	6aab      	ldr	r3, [r5, #40]	; 0x28
   1a73c:	4628      	mov	r0, r5
   1a73e:	4798      	blx	r3
   1a740:	f8d5 10d8 	ldr.w	r1, [r5, #216]	; 0xd8
   1a744:	2900      	cmp	r1, #0
   1a746:	d0f7      	beq.n	1a738 <_reclaim_reent+0xa0>
   1a748:	4628      	mov	r0, r5
   1a74a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   1a74e:	e795      	b.n	1a67c <cleanup_glue>

0001a750 <__aeabi_uidiv>:
   1a750:	1e4a      	subs	r2, r1, #1
   1a752:	bf08      	it	eq
   1a754:	4770      	bxeq	lr
   1a756:	f0c0 8124 	bcc.w	1a9a2 <__aeabi_uidiv+0x252>
   1a75a:	4288      	cmp	r0, r1
   1a75c:	f240 8116 	bls.w	1a98c <__aeabi_uidiv+0x23c>
   1a760:	4211      	tst	r1, r2
   1a762:	f000 8117 	beq.w	1a994 <__aeabi_uidiv+0x244>
   1a766:	fab0 f380 	clz	r3, r0
   1a76a:	fab1 f281 	clz	r2, r1
   1a76e:	eba2 0303 	sub.w	r3, r2, r3
   1a772:	f1c3 031f 	rsb	r3, r3, #31
   1a776:	a204      	add	r2, pc, #16	; (adr r2, 1a788 <__aeabi_uidiv+0x38>)
   1a778:	eb02 1303 	add.w	r3, r2, r3, lsl #4
   1a77c:	f04f 0200 	mov.w	r2, #0
   1a780:	469f      	mov	pc, r3
   1a782:	bf00      	nop
   1a784:	f3af 8000 	nop.w
   1a788:	ebb0 7fc1 	cmp.w	r0, r1, lsl #31
   1a78c:	bf00      	nop
   1a78e:	eb42 0202 	adc.w	r2, r2, r2
   1a792:	bf28      	it	cs
   1a794:	eba0 70c1 	subcs.w	r0, r0, r1, lsl #31
   1a798:	ebb0 7f81 	cmp.w	r0, r1, lsl #30
   1a79c:	bf00      	nop
   1a79e:	eb42 0202 	adc.w	r2, r2, r2
   1a7a2:	bf28      	it	cs
   1a7a4:	eba0 7081 	subcs.w	r0, r0, r1, lsl #30
   1a7a8:	ebb0 7f41 	cmp.w	r0, r1, lsl #29
   1a7ac:	bf00      	nop
   1a7ae:	eb42 0202 	adc.w	r2, r2, r2
   1a7b2:	bf28      	it	cs
   1a7b4:	eba0 7041 	subcs.w	r0, r0, r1, lsl #29
   1a7b8:	ebb0 7f01 	cmp.w	r0, r1, lsl #28
   1a7bc:	bf00      	nop
   1a7be:	eb42 0202 	adc.w	r2, r2, r2
   1a7c2:	bf28      	it	cs
   1a7c4:	eba0 7001 	subcs.w	r0, r0, r1, lsl #28
   1a7c8:	ebb0 6fc1 	cmp.w	r0, r1, lsl #27
   1a7cc:	bf00      	nop
   1a7ce:	eb42 0202 	adc.w	r2, r2, r2
   1a7d2:	bf28      	it	cs
   1a7d4:	eba0 60c1 	subcs.w	r0, r0, r1, lsl #27
   1a7d8:	ebb0 6f81 	cmp.w	r0, r1, lsl #26
   1a7dc:	bf00      	nop
   1a7de:	eb42 0202 	adc.w	r2, r2, r2
   1a7e2:	bf28      	it	cs
   1a7e4:	eba0 6081 	subcs.w	r0, r0, r1, lsl #26
   1a7e8:	ebb0 6f41 	cmp.w	r0, r1, lsl #25
   1a7ec:	bf00      	nop
   1a7ee:	eb42 0202 	adc.w	r2, r2, r2
   1a7f2:	bf28      	it	cs
   1a7f4:	eba0 6041 	subcs.w	r0, r0, r1, lsl #25
   1a7f8:	ebb0 6f01 	cmp.w	r0, r1, lsl #24
   1a7fc:	bf00      	nop
   1a7fe:	eb42 0202 	adc.w	r2, r2, r2
   1a802:	bf28      	it	cs
   1a804:	eba0 6001 	subcs.w	r0, r0, r1, lsl #24
   1a808:	ebb0 5fc1 	cmp.w	r0, r1, lsl #23
   1a80c:	bf00      	nop
   1a80e:	eb42 0202 	adc.w	r2, r2, r2
   1a812:	bf28      	it	cs
   1a814:	eba0 50c1 	subcs.w	r0, r0, r1, lsl #23
   1a818:	ebb0 5f81 	cmp.w	r0, r1, lsl #22
   1a81c:	bf00      	nop
   1a81e:	eb42 0202 	adc.w	r2, r2, r2
   1a822:	bf28      	it	cs
   1a824:	eba0 5081 	subcs.w	r0, r0, r1, lsl #22
   1a828:	ebb0 5f41 	cmp.w	r0, r1, lsl #21
   1a82c:	bf00      	nop
   1a82e:	eb42 0202 	adc.w	r2, r2, r2
   1a832:	bf28      	it	cs
   1a834:	eba0 5041 	subcs.w	r0, r0, r1, lsl #21
   1a838:	ebb0 5f01 	cmp.w	r0, r1, lsl #20
   1a83c:	bf00      	nop
   1a83e:	eb42 0202 	adc.w	r2, r2, r2
   1a842:	bf28      	it	cs
   1a844:	eba0 5001 	subcs.w	r0, r0, r1, lsl #20
   1a848:	ebb0 4fc1 	cmp.w	r0, r1, lsl #19
   1a84c:	bf00      	nop
   1a84e:	eb42 0202 	adc.w	r2, r2, r2
   1a852:	bf28      	it	cs
   1a854:	eba0 40c1 	subcs.w	r0, r0, r1, lsl #19
   1a858:	ebb0 4f81 	cmp.w	r0, r1, lsl #18
   1a85c:	bf00      	nop
   1a85e:	eb42 0202 	adc.w	r2, r2, r2
   1a862:	bf28      	it	cs
   1a864:	eba0 4081 	subcs.w	r0, r0, r1, lsl #18
   1a868:	ebb0 4f41 	cmp.w	r0, r1, lsl #17
   1a86c:	bf00      	nop
   1a86e:	eb42 0202 	adc.w	r2, r2, r2
   1a872:	bf28      	it	cs
   1a874:	eba0 4041 	subcs.w	r0, r0, r1, lsl #17
   1a878:	ebb0 4f01 	cmp.w	r0, r1, lsl #16
   1a87c:	bf00      	nop
   1a87e:	eb42 0202 	adc.w	r2, r2, r2
   1a882:	bf28      	it	cs
   1a884:	eba0 4001 	subcs.w	r0, r0, r1, lsl #16
   1a888:	ebb0 3fc1 	cmp.w	r0, r1, lsl #15
   1a88c:	bf00      	nop
   1a88e:	eb42 0202 	adc.w	r2, r2, r2
   1a892:	bf28      	it	cs
   1a894:	eba0 30c1 	subcs.w	r0, r0, r1, lsl #15
   1a898:	ebb0 3f81 	cmp.w	r0, r1, lsl #14
   1a89c:	bf00      	nop
   1a89e:	eb42 0202 	adc.w	r2, r2, r2
   1a8a2:	bf28      	it	cs
   1a8a4:	eba0 3081 	subcs.w	r0, r0, r1, lsl #14
   1a8a8:	ebb0 3f41 	cmp.w	r0, r1, lsl #13
   1a8ac:	bf00      	nop
   1a8ae:	eb42 0202 	adc.w	r2, r2, r2
   1a8b2:	bf28      	it	cs
   1a8b4:	eba0 3041 	subcs.w	r0, r0, r1, lsl #13
   1a8b8:	ebb0 3f01 	cmp.w	r0, r1, lsl #12
   1a8bc:	bf00      	nop
   1a8be:	eb42 0202 	adc.w	r2, r2, r2
   1a8c2:	bf28      	it	cs
   1a8c4:	eba0 3001 	subcs.w	r0, r0, r1, lsl #12
   1a8c8:	ebb0 2fc1 	cmp.w	r0, r1, lsl #11
   1a8cc:	bf00      	nop
   1a8ce:	eb42 0202 	adc.w	r2, r2, r2
   1a8d2:	bf28      	it	cs
   1a8d4:	eba0 20c1 	subcs.w	r0, r0, r1, lsl #11
   1a8d8:	ebb0 2f81 	cmp.w	r0, r1, lsl #10
   1a8dc:	bf00      	nop
   1a8de:	eb42 0202 	adc.w	r2, r2, r2
   1a8e2:	bf28      	it	cs
   1a8e4:	eba0 2081 	subcs.w	r0, r0, r1, lsl #10
   1a8e8:	ebb0 2f41 	cmp.w	r0, r1, lsl #9
   1a8ec:	bf00      	nop
   1a8ee:	eb42 0202 	adc.w	r2, r2, r2
   1a8f2:	bf28      	it	cs
   1a8f4:	eba0 2041 	subcs.w	r0, r0, r1, lsl #9
   1a8f8:	ebb0 2f01 	cmp.w	r0, r1, lsl #8
   1a8fc:	bf00      	nop
   1a8fe:	eb42 0202 	adc.w	r2, r2, r2
   1a902:	bf28      	it	cs
   1a904:	eba0 2001 	subcs.w	r0, r0, r1, lsl #8
   1a908:	ebb0 1fc1 	cmp.w	r0, r1, lsl #7
   1a90c:	bf00      	nop
   1a90e:	eb42 0202 	adc.w	r2, r2, r2
   1a912:	bf28      	it	cs
   1a914:	eba0 10c1 	subcs.w	r0, r0, r1, lsl #7
   1a918:	ebb0 1f81 	cmp.w	r0, r1, lsl #6
   1a91c:	bf00      	nop
   1a91e:	eb42 0202 	adc.w	r2, r2, r2
   1a922:	bf28      	it	cs
   1a924:	eba0 1081 	subcs.w	r0, r0, r1, lsl #6
   1a928:	ebb0 1f41 	cmp.w	r0, r1, lsl #5
   1a92c:	bf00      	nop
   1a92e:	eb42 0202 	adc.w	r2, r2, r2
   1a932:	bf28      	it	cs
   1a934:	eba0 1041 	subcs.w	r0, r0, r1, lsl #5
   1a938:	ebb0 1f01 	cmp.w	r0, r1, lsl #4
   1a93c:	bf00      	nop
   1a93e:	eb42 0202 	adc.w	r2, r2, r2
   1a942:	bf28      	it	cs
   1a944:	eba0 1001 	subcs.w	r0, r0, r1, lsl #4
   1a948:	ebb0 0fc1 	cmp.w	r0, r1, lsl #3
   1a94c:	bf00      	nop
   1a94e:	eb42 0202 	adc.w	r2, r2, r2
   1a952:	bf28      	it	cs
   1a954:	eba0 00c1 	subcs.w	r0, r0, r1, lsl #3
   1a958:	ebb0 0f81 	cmp.w	r0, r1, lsl #2
   1a95c:	bf00      	nop
   1a95e:	eb42 0202 	adc.w	r2, r2, r2
   1a962:	bf28      	it	cs
   1a964:	eba0 0081 	subcs.w	r0, r0, r1, lsl #2
   1a968:	ebb0 0f41 	cmp.w	r0, r1, lsl #1
   1a96c:	bf00      	nop
   1a96e:	eb42 0202 	adc.w	r2, r2, r2
   1a972:	bf28      	it	cs
   1a974:	eba0 0041 	subcs.w	r0, r0, r1, lsl #1
   1a978:	ebb0 0f01 	cmp.w	r0, r1
   1a97c:	bf00      	nop
   1a97e:	eb42 0202 	adc.w	r2, r2, r2
   1a982:	bf28      	it	cs
   1a984:	eba0 0001 	subcs.w	r0, r0, r1
   1a988:	4610      	mov	r0, r2
   1a98a:	4770      	bx	lr
   1a98c:	bf0c      	ite	eq
   1a98e:	2001      	moveq	r0, #1
   1a990:	2000      	movne	r0, #0
   1a992:	4770      	bx	lr
   1a994:	fab1 f281 	clz	r2, r1
   1a998:	f1c2 021f 	rsb	r2, r2, #31
   1a99c:	fa20 f002 	lsr.w	r0, r0, r2
   1a9a0:	4770      	bx	lr
   1a9a2:	b108      	cbz	r0, 1a9a8 <__aeabi_uidiv+0x258>
   1a9a4:	f04f 30ff 	mov.w	r0, #4294967295
   1a9a8:	f000 b80e 	b.w	1a9c8 <__aeabi_idiv0>

0001a9ac <__aeabi_uidivmod>:
   1a9ac:	2900      	cmp	r1, #0
   1a9ae:	d0f8      	beq.n	1a9a2 <__aeabi_uidiv+0x252>
   1a9b0:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
   1a9b4:	f7ff fecc 	bl	1a750 <__aeabi_uidiv>
   1a9b8:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
   1a9bc:	fb02 f300 	mul.w	r3, r2, r0
   1a9c0:	eba1 0103 	sub.w	r1, r1, r3
   1a9c4:	4770      	bx	lr
   1a9c6:	bf00      	nop

0001a9c8 <__aeabi_idiv0>:
   1a9c8:	4770      	bx	lr
   1a9ca:	bf00      	nop

0001a9cc <__gedf2>:
   1a9cc:	f04f 3cff 	mov.w	ip, #4294967295
   1a9d0:	e006      	b.n	1a9e0 <__cmpdf2+0x4>
   1a9d2:	bf00      	nop

0001a9d4 <__ledf2>:
   1a9d4:	f04f 0c01 	mov.w	ip, #1
   1a9d8:	e002      	b.n	1a9e0 <__cmpdf2+0x4>
   1a9da:	bf00      	nop

0001a9dc <__cmpdf2>:
   1a9dc:	f04f 0c01 	mov.w	ip, #1
   1a9e0:	f84d cd04 	str.w	ip, [sp, #-4]!
   1a9e4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   1a9e8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   1a9ec:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   1a9f0:	bf18      	it	ne
   1a9f2:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
   1a9f6:	d01b      	beq.n	1aa30 <__cmpdf2+0x54>
   1a9f8:	b001      	add	sp, #4
   1a9fa:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
   1a9fe:	bf0c      	ite	eq
   1aa00:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
   1aa04:	ea91 0f03 	teqne	r1, r3
   1aa08:	bf02      	ittt	eq
   1aa0a:	ea90 0f02 	teqeq	r0, r2
   1aa0e:	2000      	moveq	r0, #0
   1aa10:	4770      	bxeq	lr
   1aa12:	f110 0f00 	cmn.w	r0, #0
   1aa16:	ea91 0f03 	teq	r1, r3
   1aa1a:	bf58      	it	pl
   1aa1c:	4299      	cmppl	r1, r3
   1aa1e:	bf08      	it	eq
   1aa20:	4290      	cmpeq	r0, r2
   1aa22:	bf2c      	ite	cs
   1aa24:	17d8      	asrcs	r0, r3, #31
   1aa26:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
   1aa2a:	f040 0001 	orr.w	r0, r0, #1
   1aa2e:	4770      	bx	lr
   1aa30:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   1aa34:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   1aa38:	d102      	bne.n	1aa40 <__cmpdf2+0x64>
   1aa3a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
   1aa3e:	d107      	bne.n	1aa50 <__cmpdf2+0x74>
   1aa40:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   1aa44:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   1aa48:	d1d6      	bne.n	1a9f8 <__cmpdf2+0x1c>
   1aa4a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
   1aa4e:	d0d3      	beq.n	1a9f8 <__cmpdf2+0x1c>
   1aa50:	f85d 0b04 	ldr.w	r0, [sp], #4
   1aa54:	4770      	bx	lr
   1aa56:	bf00      	nop

0001aa58 <__aeabi_cdrcmple>:
   1aa58:	4684      	mov	ip, r0
   1aa5a:	4610      	mov	r0, r2
   1aa5c:	4662      	mov	r2, ip
   1aa5e:	468c      	mov	ip, r1
   1aa60:	4619      	mov	r1, r3
   1aa62:	4663      	mov	r3, ip
   1aa64:	e000      	b.n	1aa68 <__aeabi_cdcmpeq>
   1aa66:	bf00      	nop

0001aa68 <__aeabi_cdcmpeq>:
   1aa68:	b501      	push	{r0, lr}
   1aa6a:	f7ff ffb7 	bl	1a9dc <__cmpdf2>
   1aa6e:	2800      	cmp	r0, #0
   1aa70:	bf48      	it	mi
   1aa72:	f110 0f00 	cmnmi.w	r0, #0
   1aa76:	bd01      	pop	{r0, pc}

0001aa78 <__aeabi_dcmpeq>:
   1aa78:	f84d ed08 	str.w	lr, [sp, #-8]!
   1aa7c:	f7ff fff4 	bl	1aa68 <__aeabi_cdcmpeq>
   1aa80:	bf0c      	ite	eq
   1aa82:	2001      	moveq	r0, #1
   1aa84:	2000      	movne	r0, #0
   1aa86:	f85d fb08 	ldr.w	pc, [sp], #8
   1aa8a:	bf00      	nop

0001aa8c <__aeabi_dcmplt>:
   1aa8c:	f84d ed08 	str.w	lr, [sp, #-8]!
   1aa90:	f7ff ffea 	bl	1aa68 <__aeabi_cdcmpeq>
   1aa94:	bf34      	ite	cc
   1aa96:	2001      	movcc	r0, #1
   1aa98:	2000      	movcs	r0, #0
   1aa9a:	f85d fb08 	ldr.w	pc, [sp], #8
   1aa9e:	bf00      	nop

0001aaa0 <__aeabi_dcmple>:
   1aaa0:	f84d ed08 	str.w	lr, [sp, #-8]!
   1aaa4:	f7ff ffe0 	bl	1aa68 <__aeabi_cdcmpeq>
   1aaa8:	bf94      	ite	ls
   1aaaa:	2001      	movls	r0, #1
   1aaac:	2000      	movhi	r0, #0
   1aaae:	f85d fb08 	ldr.w	pc, [sp], #8
   1aab2:	bf00      	nop

0001aab4 <__aeabi_dcmpge>:
   1aab4:	f84d ed08 	str.w	lr, [sp, #-8]!
   1aab8:	f7ff ffce 	bl	1aa58 <__aeabi_cdrcmple>
   1aabc:	bf94      	ite	ls
   1aabe:	2001      	movls	r0, #1
   1aac0:	2000      	movhi	r0, #0
   1aac2:	f85d fb08 	ldr.w	pc, [sp], #8
   1aac6:	bf00      	nop

0001aac8 <__aeabi_dcmpgt>:
   1aac8:	f84d ed08 	str.w	lr, [sp, #-8]!
   1aacc:	f7ff ffc4 	bl	1aa58 <__aeabi_cdrcmple>
   1aad0:	bf34      	ite	cc
   1aad2:	2001      	movcc	r0, #1
   1aad4:	2000      	movcs	r0, #0
   1aad6:	f85d fb08 	ldr.w	pc, [sp], #8
   1aada:	bf00      	nop

0001aadc <__aeabi_d2iz>:
   1aadc:	ea4f 0241 	mov.w	r2, r1, lsl #1
   1aae0:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   1aae4:	d215      	bcs.n	1ab12 <__aeabi_d2iz+0x36>
   1aae6:	d511      	bpl.n	1ab0c <__aeabi_d2iz+0x30>
   1aae8:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   1aaec:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   1aaf0:	d912      	bls.n	1ab18 <__aeabi_d2iz+0x3c>
   1aaf2:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   1aaf6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   1aafa:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   1aafe:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   1ab02:	fa23 f002 	lsr.w	r0, r3, r2
   1ab06:	bf18      	it	ne
   1ab08:	4240      	negne	r0, r0
   1ab0a:	4770      	bx	lr
   1ab0c:	f04f 0000 	mov.w	r0, #0
   1ab10:	4770      	bx	lr
   1ab12:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   1ab16:	d105      	bne.n	1ab24 <__aeabi_d2iz+0x48>
   1ab18:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
   1ab1c:	bf08      	it	eq
   1ab1e:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
   1ab22:	4770      	bx	lr
   1ab24:	f04f 0000 	mov.w	r0, #0
   1ab28:	4770      	bx	lr
   1ab2a:	bf00      	nop

0001ab2c <__aeabi_uldivmod>:
   1ab2c:	b94b      	cbnz	r3, 1ab42 <__aeabi_uldivmod+0x16>
   1ab2e:	b942      	cbnz	r2, 1ab42 <__aeabi_uldivmod+0x16>
   1ab30:	2900      	cmp	r1, #0
   1ab32:	bf08      	it	eq
   1ab34:	2800      	cmpeq	r0, #0
   1ab36:	d002      	beq.n	1ab3e <__aeabi_uldivmod+0x12>
   1ab38:	f04f 31ff 	mov.w	r1, #4294967295
   1ab3c:	4608      	mov	r0, r1
   1ab3e:	f7ff bf43 	b.w	1a9c8 <__aeabi_idiv0>
   1ab42:	b082      	sub	sp, #8
   1ab44:	46ec      	mov	ip, sp
   1ab46:	e92d 5000 	stmdb	sp!, {ip, lr}
   1ab4a:	f000 f805 	bl	1ab58 <__gnu_uldivmod_helper>
   1ab4e:	f8dd e004 	ldr.w	lr, [sp, #4]
   1ab52:	b002      	add	sp, #8
   1ab54:	bc0c      	pop	{r2, r3}
   1ab56:	4770      	bx	lr

0001ab58 <__gnu_uldivmod_helper>:
   1ab58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1ab5a:	4614      	mov	r4, r2
   1ab5c:	461d      	mov	r5, r3
   1ab5e:	4606      	mov	r6, r0
   1ab60:	460f      	mov	r7, r1
   1ab62:	f000 f9d7 	bl	1af14 <__udivdi3>
   1ab66:	fb00 f505 	mul.w	r5, r0, r5
   1ab6a:	fba0 2304 	umull	r2, r3, r0, r4
   1ab6e:	fb04 5401 	mla	r4, r4, r1, r5
   1ab72:	18e3      	adds	r3, r4, r3
   1ab74:	1ab6      	subs	r6, r6, r2
   1ab76:	eb67 0703 	sbc.w	r7, r7, r3
   1ab7a:	9b06      	ldr	r3, [sp, #24]
   1ab7c:	e9c3 6700 	strd	r6, r7, [r3]
   1ab80:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1ab82:	bf00      	nop

0001ab84 <__gnu_ldivmod_helper>:
   1ab84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1ab86:	4614      	mov	r4, r2
   1ab88:	461d      	mov	r5, r3
   1ab8a:	4606      	mov	r6, r0
   1ab8c:	460f      	mov	r7, r1
   1ab8e:	f000 f80f 	bl	1abb0 <__divdi3>
   1ab92:	fb00 f505 	mul.w	r5, r0, r5
   1ab96:	fba0 2304 	umull	r2, r3, r0, r4
   1ab9a:	fb04 5401 	mla	r4, r4, r1, r5
   1ab9e:	18e3      	adds	r3, r4, r3
   1aba0:	1ab6      	subs	r6, r6, r2
   1aba2:	eb67 0703 	sbc.w	r7, r7, r3
   1aba6:	9b06      	ldr	r3, [sp, #24]
   1aba8:	e9c3 6700 	strd	r6, r7, [r3]
   1abac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1abae:	bf00      	nop

0001abb0 <__divdi3>:
   1abb0:	2900      	cmp	r1, #0
   1abb2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1abb6:	b085      	sub	sp, #20
   1abb8:	f2c0 80c8 	blt.w	1ad4c <__divdi3+0x19c>
   1abbc:	2600      	movs	r6, #0
   1abbe:	2b00      	cmp	r3, #0
   1abc0:	f2c0 80bf 	blt.w	1ad42 <__divdi3+0x192>
   1abc4:	4689      	mov	r9, r1
   1abc6:	4614      	mov	r4, r2
   1abc8:	4605      	mov	r5, r0
   1abca:	469b      	mov	fp, r3
   1abcc:	2b00      	cmp	r3, #0
   1abce:	d14a      	bne.n	1ac66 <__divdi3+0xb6>
   1abd0:	428a      	cmp	r2, r1
   1abd2:	d957      	bls.n	1ac84 <__divdi3+0xd4>
   1abd4:	fab2 f382 	clz	r3, r2
   1abd8:	b153      	cbz	r3, 1abf0 <__divdi3+0x40>
   1abda:	f1c3 0020 	rsb	r0, r3, #32
   1abde:	fa01 f903 	lsl.w	r9, r1, r3
   1abe2:	fa25 f800 	lsr.w	r8, r5, r0
   1abe6:	fa12 f403 	lsls.w	r4, r2, r3
   1abea:	409d      	lsls	r5, r3
   1abec:	ea48 0909 	orr.w	r9, r8, r9
   1abf0:	0c27      	lsrs	r7, r4, #16
   1abf2:	4648      	mov	r0, r9
   1abf4:	4639      	mov	r1, r7
   1abf6:	fa1f fb84 	uxth.w	fp, r4
   1abfa:	f7ff fda9 	bl	1a750 <__aeabi_uidiv>
   1abfe:	4639      	mov	r1, r7
   1ac00:	4682      	mov	sl, r0
   1ac02:	4648      	mov	r0, r9
   1ac04:	f7ff fed2 	bl	1a9ac <__aeabi_uidivmod>
   1ac08:	0c2a      	lsrs	r2, r5, #16
   1ac0a:	fb0b f30a 	mul.w	r3, fp, sl
   1ac0e:	ea42 4901 	orr.w	r9, r2, r1, lsl #16
   1ac12:	454b      	cmp	r3, r9
   1ac14:	d909      	bls.n	1ac2a <__divdi3+0x7a>
   1ac16:	eb19 0904 	adds.w	r9, r9, r4
   1ac1a:	f10a 3aff 	add.w	sl, sl, #4294967295
   1ac1e:	d204      	bcs.n	1ac2a <__divdi3+0x7a>
   1ac20:	454b      	cmp	r3, r9
   1ac22:	bf84      	itt	hi
   1ac24:	f10a 3aff 	addhi.w	sl, sl, #4294967295
   1ac28:	44a1      	addhi	r9, r4
   1ac2a:	ebc3 0909 	rsb	r9, r3, r9
   1ac2e:	4639      	mov	r1, r7
   1ac30:	4648      	mov	r0, r9
   1ac32:	b2ad      	uxth	r5, r5
   1ac34:	f7ff fd8c 	bl	1a750 <__aeabi_uidiv>
   1ac38:	4639      	mov	r1, r7
   1ac3a:	4680      	mov	r8, r0
   1ac3c:	4648      	mov	r0, r9
   1ac3e:	f7ff feb5 	bl	1a9ac <__aeabi_uidivmod>
   1ac42:	fb0b fb08 	mul.w	fp, fp, r8
   1ac46:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
   1ac4a:	45ab      	cmp	fp, r5
   1ac4c:	d907      	bls.n	1ac5e <__divdi3+0xae>
   1ac4e:	192d      	adds	r5, r5, r4
   1ac50:	f108 38ff 	add.w	r8, r8, #4294967295
   1ac54:	d203      	bcs.n	1ac5e <__divdi3+0xae>
   1ac56:	45ab      	cmp	fp, r5
   1ac58:	bf88      	it	hi
   1ac5a:	f108 38ff 	addhi.w	r8, r8, #4294967295
   1ac5e:	ea48 480a 	orr.w	r8, r8, sl, lsl #16
   1ac62:	2700      	movs	r7, #0
   1ac64:	e003      	b.n	1ac6e <__divdi3+0xbe>
   1ac66:	428b      	cmp	r3, r1
   1ac68:	d957      	bls.n	1ad1a <__divdi3+0x16a>
   1ac6a:	2700      	movs	r7, #0
   1ac6c:	46b8      	mov	r8, r7
   1ac6e:	4642      	mov	r2, r8
   1ac70:	463b      	mov	r3, r7
   1ac72:	b116      	cbz	r6, 1ac7a <__divdi3+0xca>
   1ac74:	4252      	negs	r2, r2
   1ac76:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   1ac7a:	4619      	mov	r1, r3
   1ac7c:	4610      	mov	r0, r2
   1ac7e:	b005      	add	sp, #20
   1ac80:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ac84:	b922      	cbnz	r2, 1ac90 <__divdi3+0xe0>
   1ac86:	4611      	mov	r1, r2
   1ac88:	2001      	movs	r0, #1
   1ac8a:	f7ff fd61 	bl	1a750 <__aeabi_uidiv>
   1ac8e:	4604      	mov	r4, r0
   1ac90:	fab4 f884 	clz	r8, r4
   1ac94:	f1b8 0f00 	cmp.w	r8, #0
   1ac98:	d15e      	bne.n	1ad58 <__divdi3+0x1a8>
   1ac9a:	ebc4 0809 	rsb	r8, r4, r9
   1ac9e:	0c27      	lsrs	r7, r4, #16
   1aca0:	fa1f f984 	uxth.w	r9, r4
   1aca4:	2101      	movs	r1, #1
   1aca6:	9102      	str	r1, [sp, #8]
   1aca8:	4639      	mov	r1, r7
   1acaa:	4640      	mov	r0, r8
   1acac:	f7ff fd50 	bl	1a750 <__aeabi_uidiv>
   1acb0:	4639      	mov	r1, r7
   1acb2:	4682      	mov	sl, r0
   1acb4:	4640      	mov	r0, r8
   1acb6:	f7ff fe79 	bl	1a9ac <__aeabi_uidivmod>
   1acba:	ea4f 4815 	mov.w	r8, r5, lsr #16
   1acbe:	fb09 f30a 	mul.w	r3, r9, sl
   1acc2:	ea48 4b01 	orr.w	fp, r8, r1, lsl #16
   1acc6:	455b      	cmp	r3, fp
   1acc8:	d909      	bls.n	1acde <__divdi3+0x12e>
   1acca:	eb1b 0b04 	adds.w	fp, fp, r4
   1acce:	f10a 3aff 	add.w	sl, sl, #4294967295
   1acd2:	d204      	bcs.n	1acde <__divdi3+0x12e>
   1acd4:	455b      	cmp	r3, fp
   1acd6:	bf84      	itt	hi
   1acd8:	f10a 3aff 	addhi.w	sl, sl, #4294967295
   1acdc:	44a3      	addhi	fp, r4
   1acde:	ebc3 0b0b 	rsb	fp, r3, fp
   1ace2:	4639      	mov	r1, r7
   1ace4:	4658      	mov	r0, fp
   1ace6:	b2ad      	uxth	r5, r5
   1ace8:	f7ff fd32 	bl	1a750 <__aeabi_uidiv>
   1acec:	4639      	mov	r1, r7
   1acee:	4680      	mov	r8, r0
   1acf0:	4658      	mov	r0, fp
   1acf2:	f7ff fe5b 	bl	1a9ac <__aeabi_uidivmod>
   1acf6:	fb09 f908 	mul.w	r9, r9, r8
   1acfa:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
   1acfe:	45a9      	cmp	r9, r5
   1ad00:	d907      	bls.n	1ad12 <__divdi3+0x162>
   1ad02:	192d      	adds	r5, r5, r4
   1ad04:	f108 38ff 	add.w	r8, r8, #4294967295
   1ad08:	d203      	bcs.n	1ad12 <__divdi3+0x162>
   1ad0a:	45a9      	cmp	r9, r5
   1ad0c:	bf88      	it	hi
   1ad0e:	f108 38ff 	addhi.w	r8, r8, #4294967295
   1ad12:	ea48 480a 	orr.w	r8, r8, sl, lsl #16
   1ad16:	9f02      	ldr	r7, [sp, #8]
   1ad18:	e7a9      	b.n	1ac6e <__divdi3+0xbe>
   1ad1a:	fab3 f783 	clz	r7, r3
   1ad1e:	2f00      	cmp	r7, #0
   1ad20:	d168      	bne.n	1adf4 <__divdi3+0x244>
   1ad22:	428b      	cmp	r3, r1
   1ad24:	bf2c      	ite	cs
   1ad26:	f04f 0900 	movcs.w	r9, #0
   1ad2a:	f04f 0901 	movcc.w	r9, #1
   1ad2e:	4282      	cmp	r2, r0
   1ad30:	bf8c      	ite	hi
   1ad32:	464c      	movhi	r4, r9
   1ad34:	f049 0401 	orrls.w	r4, r9, #1
   1ad38:	2c00      	cmp	r4, #0
   1ad3a:	d096      	beq.n	1ac6a <__divdi3+0xba>
   1ad3c:	f04f 0801 	mov.w	r8, #1
   1ad40:	e795      	b.n	1ac6e <__divdi3+0xbe>
   1ad42:	4252      	negs	r2, r2
   1ad44:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   1ad48:	43f6      	mvns	r6, r6
   1ad4a:	e73b      	b.n	1abc4 <__divdi3+0x14>
   1ad4c:	4240      	negs	r0, r0
   1ad4e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   1ad52:	f04f 36ff 	mov.w	r6, #4294967295
   1ad56:	e732      	b.n	1abbe <__divdi3+0xe>
   1ad58:	fa04 f408 	lsl.w	r4, r4, r8
   1ad5c:	f1c8 0720 	rsb	r7, r8, #32
   1ad60:	fa35 f307 	lsrs.w	r3, r5, r7
   1ad64:	fa29 fa07 	lsr.w	sl, r9, r7
   1ad68:	0c27      	lsrs	r7, r4, #16
   1ad6a:	fa09 fb08 	lsl.w	fp, r9, r8
   1ad6e:	4639      	mov	r1, r7
   1ad70:	4650      	mov	r0, sl
   1ad72:	ea43 020b 	orr.w	r2, r3, fp
   1ad76:	9202      	str	r2, [sp, #8]
   1ad78:	f7ff fcea 	bl	1a750 <__aeabi_uidiv>
   1ad7c:	4639      	mov	r1, r7
   1ad7e:	fa1f f984 	uxth.w	r9, r4
   1ad82:	4683      	mov	fp, r0
   1ad84:	4650      	mov	r0, sl
   1ad86:	f7ff fe11 	bl	1a9ac <__aeabi_uidivmod>
   1ad8a:	9802      	ldr	r0, [sp, #8]
   1ad8c:	fb09 f20b 	mul.w	r2, r9, fp
   1ad90:	0c03      	lsrs	r3, r0, #16
   1ad92:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   1ad96:	429a      	cmp	r2, r3
   1ad98:	d904      	bls.n	1ada4 <__divdi3+0x1f4>
   1ad9a:	191b      	adds	r3, r3, r4
   1ad9c:	f10b 3bff 	add.w	fp, fp, #4294967295
   1ada0:	f0c0 80b1 	bcc.w	1af06 <__divdi3+0x356>
   1ada4:	1a9b      	subs	r3, r3, r2
   1ada6:	4639      	mov	r1, r7
   1ada8:	4618      	mov	r0, r3
   1adaa:	9301      	str	r3, [sp, #4]
   1adac:	f7ff fcd0 	bl	1a750 <__aeabi_uidiv>
   1adb0:	9901      	ldr	r1, [sp, #4]
   1adb2:	4682      	mov	sl, r0
   1adb4:	4608      	mov	r0, r1
   1adb6:	4639      	mov	r1, r7
   1adb8:	f7ff fdf8 	bl	1a9ac <__aeabi_uidivmod>
   1adbc:	f8dd c008 	ldr.w	ip, [sp, #8]
   1adc0:	fb09 f30a 	mul.w	r3, r9, sl
   1adc4:	fa1f f08c 	uxth.w	r0, ip
   1adc8:	ea40 4201 	orr.w	r2, r0, r1, lsl #16
   1adcc:	4293      	cmp	r3, r2
   1adce:	d908      	bls.n	1ade2 <__divdi3+0x232>
   1add0:	1912      	adds	r2, r2, r4
   1add2:	f10a 3aff 	add.w	sl, sl, #4294967295
   1add6:	d204      	bcs.n	1ade2 <__divdi3+0x232>
   1add8:	4293      	cmp	r3, r2
   1adda:	bf84      	itt	hi
   1addc:	f10a 3aff 	addhi.w	sl, sl, #4294967295
   1ade0:	1912      	addhi	r2, r2, r4
   1ade2:	fa05 f508 	lsl.w	r5, r5, r8
   1ade6:	ea4a 4e0b 	orr.w	lr, sl, fp, lsl #16
   1adea:	ebc3 0802 	rsb	r8, r3, r2
   1adee:	f8cd e008 	str.w	lr, [sp, #8]
   1adf2:	e759      	b.n	1aca8 <__divdi3+0xf8>
   1adf4:	f1c7 0020 	rsb	r0, r7, #32
   1adf8:	fa03 fa07 	lsl.w	sl, r3, r7
   1adfc:	40c2      	lsrs	r2, r0
   1adfe:	fa35 f300 	lsrs.w	r3, r5, r0
   1ae02:	ea42 0b0a 	orr.w	fp, r2, sl
   1ae06:	fa21 f800 	lsr.w	r8, r1, r0
   1ae0a:	fa01 f907 	lsl.w	r9, r1, r7
   1ae0e:	4640      	mov	r0, r8
   1ae10:	ea4f 4a1b 	mov.w	sl, fp, lsr #16
   1ae14:	ea43 0109 	orr.w	r1, r3, r9
   1ae18:	9102      	str	r1, [sp, #8]
   1ae1a:	4651      	mov	r1, sl
   1ae1c:	fa1f f28b 	uxth.w	r2, fp
   1ae20:	9203      	str	r2, [sp, #12]
   1ae22:	f7ff fc95 	bl	1a750 <__aeabi_uidiv>
   1ae26:	4651      	mov	r1, sl
   1ae28:	4681      	mov	r9, r0
   1ae2a:	4640      	mov	r0, r8
   1ae2c:	f7ff fdbe 	bl	1a9ac <__aeabi_uidivmod>
   1ae30:	9b03      	ldr	r3, [sp, #12]
   1ae32:	f8dd c008 	ldr.w	ip, [sp, #8]
   1ae36:	fb03 f209 	mul.w	r2, r3, r9
   1ae3a:	ea4f 401c 	mov.w	r0, ip, lsr #16
   1ae3e:	fa14 f307 	lsls.w	r3, r4, r7
   1ae42:	ea40 4401 	orr.w	r4, r0, r1, lsl #16
   1ae46:	42a2      	cmp	r2, r4
   1ae48:	d904      	bls.n	1ae54 <__divdi3+0x2a4>
   1ae4a:	eb14 040b 	adds.w	r4, r4, fp
   1ae4e:	f109 39ff 	add.w	r9, r9, #4294967295
   1ae52:	d352      	bcc.n	1aefa <__divdi3+0x34a>
   1ae54:	1aa4      	subs	r4, r4, r2
   1ae56:	4651      	mov	r1, sl
   1ae58:	4620      	mov	r0, r4
   1ae5a:	9301      	str	r3, [sp, #4]
   1ae5c:	f7ff fc78 	bl	1a750 <__aeabi_uidiv>
   1ae60:	4651      	mov	r1, sl
   1ae62:	4680      	mov	r8, r0
   1ae64:	4620      	mov	r0, r4
   1ae66:	f7ff fda1 	bl	1a9ac <__aeabi_uidivmod>
   1ae6a:	9803      	ldr	r0, [sp, #12]
   1ae6c:	f8dd c008 	ldr.w	ip, [sp, #8]
   1ae70:	fb00 f208 	mul.w	r2, r0, r8
   1ae74:	fa1f f38c 	uxth.w	r3, ip
   1ae78:	ea43 4001 	orr.w	r0, r3, r1, lsl #16
   1ae7c:	9b01      	ldr	r3, [sp, #4]
   1ae7e:	4282      	cmp	r2, r0
   1ae80:	d904      	bls.n	1ae8c <__divdi3+0x2dc>
   1ae82:	eb10 000b 	adds.w	r0, r0, fp
   1ae86:	f108 38ff 	add.w	r8, r8, #4294967295
   1ae8a:	d330      	bcc.n	1aeee <__divdi3+0x33e>
   1ae8c:	ea48 4809 	orr.w	r8, r8, r9, lsl #16
   1ae90:	fa1f fc83 	uxth.w	ip, r3
   1ae94:	0c1b      	lsrs	r3, r3, #16
   1ae96:	1a80      	subs	r0, r0, r2
   1ae98:	fa1f fe88 	uxth.w	lr, r8
   1ae9c:	ea4f 4a18 	mov.w	sl, r8, lsr #16
   1aea0:	fb0c f90e 	mul.w	r9, ip, lr
   1aea4:	fb0c fc0a 	mul.w	ip, ip, sl
   1aea8:	fb03 c10e 	mla	r1, r3, lr, ip
   1aeac:	fb03 f20a 	mul.w	r2, r3, sl
   1aeb0:	eb01 4119 	add.w	r1, r1, r9, lsr #16
   1aeb4:	458c      	cmp	ip, r1
   1aeb6:	bf88      	it	hi
   1aeb8:	f502 3280 	addhi.w	r2, r2, #65536	; 0x10000
   1aebc:	eb02 4e11 	add.w	lr, r2, r1, lsr #16
   1aec0:	4570      	cmp	r0, lr
   1aec2:	d310      	bcc.n	1aee6 <__divdi3+0x336>
   1aec4:	fa1f f989 	uxth.w	r9, r9
   1aec8:	fa05 f707 	lsl.w	r7, r5, r7
   1aecc:	eb09 4001 	add.w	r0, r9, r1, lsl #16
   1aed0:	bf14      	ite	ne
   1aed2:	2200      	movne	r2, #0
   1aed4:	2201      	moveq	r2, #1
   1aed6:	4287      	cmp	r7, r0
   1aed8:	bf2c      	ite	cs
   1aeda:	2700      	movcs	r7, #0
   1aedc:	f002 0701 	andcc.w	r7, r2, #1
   1aee0:	2f00      	cmp	r7, #0
   1aee2:	f43f aec4 	beq.w	1ac6e <__divdi3+0xbe>
   1aee6:	f108 38ff 	add.w	r8, r8, #4294967295
   1aeea:	2700      	movs	r7, #0
   1aeec:	e6bf      	b.n	1ac6e <__divdi3+0xbe>
   1aeee:	4282      	cmp	r2, r0
   1aef0:	bf84      	itt	hi
   1aef2:	4458      	addhi	r0, fp
   1aef4:	f108 38ff 	addhi.w	r8, r8, #4294967295
   1aef8:	e7c8      	b.n	1ae8c <__divdi3+0x2dc>
   1aefa:	42a2      	cmp	r2, r4
   1aefc:	bf84      	itt	hi
   1aefe:	f109 39ff 	addhi.w	r9, r9, #4294967295
   1af02:	445c      	addhi	r4, fp
   1af04:	e7a6      	b.n	1ae54 <__divdi3+0x2a4>
   1af06:	429a      	cmp	r2, r3
   1af08:	bf84      	itt	hi
   1af0a:	f10b 3bff 	addhi.w	fp, fp, #4294967295
   1af0e:	191b      	addhi	r3, r3, r4
   1af10:	e748      	b.n	1ada4 <__divdi3+0x1f4>
   1af12:	bf00      	nop

0001af14 <__udivdi3>:
   1af14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1af18:	460c      	mov	r4, r1
   1af1a:	b083      	sub	sp, #12
   1af1c:	4680      	mov	r8, r0
   1af1e:	4616      	mov	r6, r2
   1af20:	4689      	mov	r9, r1
   1af22:	461f      	mov	r7, r3
   1af24:	4615      	mov	r5, r2
   1af26:	468a      	mov	sl, r1
   1af28:	2b00      	cmp	r3, #0
   1af2a:	d14b      	bne.n	1afc4 <__udivdi3+0xb0>
   1af2c:	428a      	cmp	r2, r1
   1af2e:	d95c      	bls.n	1afea <__udivdi3+0xd6>
   1af30:	fab2 f382 	clz	r3, r2
   1af34:	b15b      	cbz	r3, 1af4e <__udivdi3+0x3a>
   1af36:	f1c3 0020 	rsb	r0, r3, #32
   1af3a:	fa01 fa03 	lsl.w	sl, r1, r3
   1af3e:	fa28 f200 	lsr.w	r2, r8, r0
   1af42:	fa16 f503 	lsls.w	r5, r6, r3
   1af46:	fa08 f803 	lsl.w	r8, r8, r3
   1af4a:	ea42 0a0a 	orr.w	sl, r2, sl
   1af4e:	0c2e      	lsrs	r6, r5, #16
   1af50:	4650      	mov	r0, sl
   1af52:	4631      	mov	r1, r6
   1af54:	b2af      	uxth	r7, r5
   1af56:	f7ff fbfb 	bl	1a750 <__aeabi_uidiv>
   1af5a:	4631      	mov	r1, r6
   1af5c:	ea4f 4418 	mov.w	r4, r8, lsr #16
   1af60:	4681      	mov	r9, r0
   1af62:	4650      	mov	r0, sl
   1af64:	f7ff fd22 	bl	1a9ac <__aeabi_uidivmod>
   1af68:	fb07 f309 	mul.w	r3, r7, r9
   1af6c:	ea44 4a01 	orr.w	sl, r4, r1, lsl #16
   1af70:	4553      	cmp	r3, sl
   1af72:	d909      	bls.n	1af88 <__udivdi3+0x74>
   1af74:	eb1a 0a05 	adds.w	sl, sl, r5
   1af78:	f109 39ff 	add.w	r9, r9, #4294967295
   1af7c:	d204      	bcs.n	1af88 <__udivdi3+0x74>
   1af7e:	4553      	cmp	r3, sl
   1af80:	bf84      	itt	hi
   1af82:	f109 39ff 	addhi.w	r9, r9, #4294967295
   1af86:	44aa      	addhi	sl, r5
   1af88:	ebc3 0a0a 	rsb	sl, r3, sl
   1af8c:	4631      	mov	r1, r6
   1af8e:	4650      	mov	r0, sl
   1af90:	fa1f f888 	uxth.w	r8, r8
   1af94:	f7ff fbdc 	bl	1a750 <__aeabi_uidiv>
   1af98:	4631      	mov	r1, r6
   1af9a:	4604      	mov	r4, r0
   1af9c:	4650      	mov	r0, sl
   1af9e:	f7ff fd05 	bl	1a9ac <__aeabi_uidivmod>
   1afa2:	fb07 f704 	mul.w	r7, r7, r4
   1afa6:	ea48 4801 	orr.w	r8, r8, r1, lsl #16
   1afaa:	4547      	cmp	r7, r8
   1afac:	d906      	bls.n	1afbc <__udivdi3+0xa8>
   1afae:	3c01      	subs	r4, #1
   1afb0:	eb18 0805 	adds.w	r8, r8, r5
   1afb4:	d202      	bcs.n	1afbc <__udivdi3+0xa8>
   1afb6:	4547      	cmp	r7, r8
   1afb8:	bf88      	it	hi
   1afba:	3c01      	subhi	r4, #1
   1afbc:	ea44 4409 	orr.w	r4, r4, r9, lsl #16
   1afc0:	2600      	movs	r6, #0
   1afc2:	e05c      	b.n	1b07e <__udivdi3+0x16a>
   1afc4:	428b      	cmp	r3, r1
   1afc6:	d858      	bhi.n	1b07a <__udivdi3+0x166>
   1afc8:	fab3 f683 	clz	r6, r3
   1afcc:	2e00      	cmp	r6, #0
   1afce:	d15b      	bne.n	1b088 <__udivdi3+0x174>
   1afd0:	428b      	cmp	r3, r1
   1afd2:	bf2c      	ite	cs
   1afd4:	2200      	movcs	r2, #0
   1afd6:	2201      	movcc	r2, #1
   1afd8:	4285      	cmp	r5, r0
   1afda:	bf8c      	ite	hi
   1afdc:	4615      	movhi	r5, r2
   1afde:	f042 0501 	orrls.w	r5, r2, #1
   1afe2:	2d00      	cmp	r5, #0
   1afe4:	d049      	beq.n	1b07a <__udivdi3+0x166>
   1afe6:	2401      	movs	r4, #1
   1afe8:	e049      	b.n	1b07e <__udivdi3+0x16a>
   1afea:	b922      	cbnz	r2, 1aff6 <__udivdi3+0xe2>
   1afec:	4611      	mov	r1, r2
   1afee:	2001      	movs	r0, #1
   1aff0:	f7ff fbae 	bl	1a750 <__aeabi_uidiv>
   1aff4:	4605      	mov	r5, r0
   1aff6:	fab5 f685 	clz	r6, r5
   1affa:	2e00      	cmp	r6, #0
   1affc:	f040 80ba 	bne.w	1b174 <__udivdi3+0x260>
   1b000:	1b64      	subs	r4, r4, r5
   1b002:	0c2f      	lsrs	r7, r5, #16
   1b004:	fa1f fa85 	uxth.w	sl, r5
   1b008:	2601      	movs	r6, #1
   1b00a:	4639      	mov	r1, r7
   1b00c:	4620      	mov	r0, r4
   1b00e:	f7ff fb9f 	bl	1a750 <__aeabi_uidiv>
   1b012:	4639      	mov	r1, r7
   1b014:	ea4f 4b18 	mov.w	fp, r8, lsr #16
   1b018:	4681      	mov	r9, r0
   1b01a:	4620      	mov	r0, r4
   1b01c:	f7ff fcc6 	bl	1a9ac <__aeabi_uidivmod>
   1b020:	fb0a f309 	mul.w	r3, sl, r9
   1b024:	ea4b 4b01 	orr.w	fp, fp, r1, lsl #16
   1b028:	455b      	cmp	r3, fp
   1b02a:	d909      	bls.n	1b040 <__udivdi3+0x12c>
   1b02c:	eb1b 0b05 	adds.w	fp, fp, r5
   1b030:	f109 39ff 	add.w	r9, r9, #4294967295
   1b034:	d204      	bcs.n	1b040 <__udivdi3+0x12c>
   1b036:	455b      	cmp	r3, fp
   1b038:	bf84      	itt	hi
   1b03a:	f109 39ff 	addhi.w	r9, r9, #4294967295
   1b03e:	44ab      	addhi	fp, r5
   1b040:	ebc3 0b0b 	rsb	fp, r3, fp
   1b044:	4639      	mov	r1, r7
   1b046:	4658      	mov	r0, fp
   1b048:	fa1f f888 	uxth.w	r8, r8
   1b04c:	f7ff fb80 	bl	1a750 <__aeabi_uidiv>
   1b050:	4639      	mov	r1, r7
   1b052:	4604      	mov	r4, r0
   1b054:	4658      	mov	r0, fp
   1b056:	f7ff fca9 	bl	1a9ac <__aeabi_uidivmod>
   1b05a:	fb0a fa04 	mul.w	sl, sl, r4
   1b05e:	ea48 4801 	orr.w	r8, r8, r1, lsl #16
   1b062:	45c2      	cmp	sl, r8
   1b064:	d906      	bls.n	1b074 <__udivdi3+0x160>
   1b066:	3c01      	subs	r4, #1
   1b068:	eb18 0805 	adds.w	r8, r8, r5
   1b06c:	d202      	bcs.n	1b074 <__udivdi3+0x160>
   1b06e:	45c2      	cmp	sl, r8
   1b070:	bf88      	it	hi
   1b072:	3c01      	subhi	r4, #1
   1b074:	ea44 4409 	orr.w	r4, r4, r9, lsl #16
   1b078:	e001      	b.n	1b07e <__udivdi3+0x16a>
   1b07a:	2600      	movs	r6, #0
   1b07c:	4634      	mov	r4, r6
   1b07e:	4631      	mov	r1, r6
   1b080:	4620      	mov	r0, r4
   1b082:	b003      	add	sp, #12
   1b084:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1b088:	f1c6 0020 	rsb	r0, r6, #32
   1b08c:	40b3      	lsls	r3, r6
   1b08e:	fa32 f700 	lsrs.w	r7, r2, r0
   1b092:	fa21 fb00 	lsr.w	fp, r1, r0
   1b096:	431f      	orrs	r7, r3
   1b098:	fa14 f206 	lsls.w	r2, r4, r6
   1b09c:	fa28 f100 	lsr.w	r1, r8, r0
   1b0a0:	4658      	mov	r0, fp
   1b0a2:	ea4f 4a17 	mov.w	sl, r7, lsr #16
   1b0a6:	4311      	orrs	r1, r2
   1b0a8:	9100      	str	r1, [sp, #0]
   1b0aa:	4651      	mov	r1, sl
   1b0ac:	b2bb      	uxth	r3, r7
   1b0ae:	9301      	str	r3, [sp, #4]
   1b0b0:	f7ff fb4e 	bl	1a750 <__aeabi_uidiv>
   1b0b4:	4651      	mov	r1, sl
   1b0b6:	40b5      	lsls	r5, r6
   1b0b8:	4681      	mov	r9, r0
   1b0ba:	4658      	mov	r0, fp
   1b0bc:	f7ff fc76 	bl	1a9ac <__aeabi_uidivmod>
   1b0c0:	9c01      	ldr	r4, [sp, #4]
   1b0c2:	9800      	ldr	r0, [sp, #0]
   1b0c4:	fb04 f309 	mul.w	r3, r4, r9
   1b0c8:	ea4f 4c10 	mov.w	ip, r0, lsr #16
   1b0cc:	ea4c 4b01 	orr.w	fp, ip, r1, lsl #16
   1b0d0:	455b      	cmp	r3, fp
   1b0d2:	d905      	bls.n	1b0e0 <__udivdi3+0x1cc>
   1b0d4:	eb1b 0b07 	adds.w	fp, fp, r7
   1b0d8:	f109 39ff 	add.w	r9, r9, #4294967295
   1b0dc:	f0c0 808e 	bcc.w	1b1fc <__udivdi3+0x2e8>
   1b0e0:	ebc3 0b0b 	rsb	fp, r3, fp
   1b0e4:	4651      	mov	r1, sl
   1b0e6:	4658      	mov	r0, fp
   1b0e8:	f7ff fb32 	bl	1a750 <__aeabi_uidiv>
   1b0ec:	4651      	mov	r1, sl
   1b0ee:	4604      	mov	r4, r0
   1b0f0:	4658      	mov	r0, fp
   1b0f2:	f7ff fc5b 	bl	1a9ac <__aeabi_uidivmod>
   1b0f6:	9801      	ldr	r0, [sp, #4]
   1b0f8:	9a00      	ldr	r2, [sp, #0]
   1b0fa:	fb00 f304 	mul.w	r3, r0, r4
   1b0fe:	fa1f fc82 	uxth.w	ip, r2
   1b102:	ea4c 4201 	orr.w	r2, ip, r1, lsl #16
   1b106:	4293      	cmp	r3, r2
   1b108:	d906      	bls.n	1b118 <__udivdi3+0x204>
   1b10a:	3c01      	subs	r4, #1
   1b10c:	19d2      	adds	r2, r2, r7
   1b10e:	d203      	bcs.n	1b118 <__udivdi3+0x204>
   1b110:	4293      	cmp	r3, r2
   1b112:	d901      	bls.n	1b118 <__udivdi3+0x204>
   1b114:	19d2      	adds	r2, r2, r7
   1b116:	3c01      	subs	r4, #1
   1b118:	ea44 4409 	orr.w	r4, r4, r9, lsl #16
   1b11c:	b2a8      	uxth	r0, r5
   1b11e:	1ad2      	subs	r2, r2, r3
   1b120:	0c2d      	lsrs	r5, r5, #16
   1b122:	fa1f fc84 	uxth.w	ip, r4
   1b126:	0c23      	lsrs	r3, r4, #16
   1b128:	fb00 f70c 	mul.w	r7, r0, ip
   1b12c:	fb00 fe03 	mul.w	lr, r0, r3
   1b130:	fb05 e10c 	mla	r1, r5, ip, lr
   1b134:	fb05 f503 	mul.w	r5, r5, r3
   1b138:	eb01 4117 	add.w	r1, r1, r7, lsr #16
   1b13c:	458e      	cmp	lr, r1
   1b13e:	bf88      	it	hi
   1b140:	f505 3580 	addhi.w	r5, r5, #65536	; 0x10000
   1b144:	eb05 4511 	add.w	r5, r5, r1, lsr #16
   1b148:	42aa      	cmp	r2, r5
   1b14a:	d310      	bcc.n	1b16e <__udivdi3+0x25a>
   1b14c:	b2bf      	uxth	r7, r7
   1b14e:	fa08 f606 	lsl.w	r6, r8, r6
   1b152:	eb07 4201 	add.w	r2, r7, r1, lsl #16
   1b156:	bf14      	ite	ne
   1b158:	f04f 0e00 	movne.w	lr, #0
   1b15c:	f04f 0e01 	moveq.w	lr, #1
   1b160:	4296      	cmp	r6, r2
   1b162:	bf2c      	ite	cs
   1b164:	2600      	movcs	r6, #0
   1b166:	f00e 0601 	andcc.w	r6, lr, #1
   1b16a:	2e00      	cmp	r6, #0
   1b16c:	d087      	beq.n	1b07e <__udivdi3+0x16a>
   1b16e:	3c01      	subs	r4, #1
   1b170:	2600      	movs	r6, #0
   1b172:	e784      	b.n	1b07e <__udivdi3+0x16a>
   1b174:	40b5      	lsls	r5, r6
   1b176:	f1c6 0120 	rsb	r1, r6, #32
   1b17a:	fa24 f901 	lsr.w	r9, r4, r1
   1b17e:	fa28 f201 	lsr.w	r2, r8, r1
   1b182:	0c2f      	lsrs	r7, r5, #16
   1b184:	40b4      	lsls	r4, r6
   1b186:	4639      	mov	r1, r7
   1b188:	4648      	mov	r0, r9
   1b18a:	4322      	orrs	r2, r4
   1b18c:	9200      	str	r2, [sp, #0]
   1b18e:	f7ff fadf 	bl	1a750 <__aeabi_uidiv>
   1b192:	4639      	mov	r1, r7
   1b194:	fa1f fa85 	uxth.w	sl, r5
   1b198:	4683      	mov	fp, r0
   1b19a:	4648      	mov	r0, r9
   1b19c:	f7ff fc06 	bl	1a9ac <__aeabi_uidivmod>
   1b1a0:	9b00      	ldr	r3, [sp, #0]
   1b1a2:	0c1a      	lsrs	r2, r3, #16
   1b1a4:	fb0a f30b 	mul.w	r3, sl, fp
   1b1a8:	ea42 4401 	orr.w	r4, r2, r1, lsl #16
   1b1ac:	42a3      	cmp	r3, r4
   1b1ae:	d903      	bls.n	1b1b8 <__udivdi3+0x2a4>
   1b1b0:	1964      	adds	r4, r4, r5
   1b1b2:	f10b 3bff 	add.w	fp, fp, #4294967295
   1b1b6:	d327      	bcc.n	1b208 <__udivdi3+0x2f4>
   1b1b8:	1ae4      	subs	r4, r4, r3
   1b1ba:	4639      	mov	r1, r7
   1b1bc:	4620      	mov	r0, r4
   1b1be:	f7ff fac7 	bl	1a750 <__aeabi_uidiv>
   1b1c2:	4639      	mov	r1, r7
   1b1c4:	4681      	mov	r9, r0
   1b1c6:	4620      	mov	r0, r4
   1b1c8:	f7ff fbf0 	bl	1a9ac <__aeabi_uidivmod>
   1b1cc:	9800      	ldr	r0, [sp, #0]
   1b1ce:	fb0a f309 	mul.w	r3, sl, r9
   1b1d2:	fa1f fc80 	uxth.w	ip, r0
   1b1d6:	ea4c 4401 	orr.w	r4, ip, r1, lsl #16
   1b1da:	42a3      	cmp	r3, r4
   1b1dc:	d908      	bls.n	1b1f0 <__udivdi3+0x2dc>
   1b1de:	1964      	adds	r4, r4, r5
   1b1e0:	f109 39ff 	add.w	r9, r9, #4294967295
   1b1e4:	d204      	bcs.n	1b1f0 <__udivdi3+0x2dc>
   1b1e6:	42a3      	cmp	r3, r4
   1b1e8:	bf84      	itt	hi
   1b1ea:	f109 39ff 	addhi.w	r9, r9, #4294967295
   1b1ee:	1964      	addhi	r4, r4, r5
   1b1f0:	fa08 f806 	lsl.w	r8, r8, r6
   1b1f4:	1ae4      	subs	r4, r4, r3
   1b1f6:	ea49 460b 	orr.w	r6, r9, fp, lsl #16
   1b1fa:	e706      	b.n	1b00a <__udivdi3+0xf6>
   1b1fc:	455b      	cmp	r3, fp
   1b1fe:	bf84      	itt	hi
   1b200:	f109 39ff 	addhi.w	r9, r9, #4294967295
   1b204:	44bb      	addhi	fp, r7
   1b206:	e76b      	b.n	1b0e0 <__udivdi3+0x1cc>
   1b208:	42a3      	cmp	r3, r4
   1b20a:	bf84      	itt	hi
   1b20c:	f10b 3bff 	addhi.w	fp, fp, #4294967295
   1b210:	1964      	addhi	r4, r4, r5
   1b212:	e7d1      	b.n	1b1b8 <__udivdi3+0x2a4>

0001b214 <pow>:
   1b214:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1b218:	b08d      	sub	sp, #52	; 0x34
   1b21a:	4699      	mov	r9, r3
   1b21c:	4682      	mov	sl, r0
   1b21e:	468b      	mov	fp, r1
   1b220:	4690      	mov	r8, r2
   1b222:	f000 f9a5 	bl	1b570 <__ieee754_pow>
   1b226:	f240 6420 	movw	r4, #1568	; 0x620
   1b22a:	f2c2 0400 	movt	r4, #8192	; 0x2000
   1b22e:	f994 3000 	ldrsb.w	r3, [r4]
   1b232:	f1b3 3fff 	cmp.w	r3, #4294967295
   1b236:	4606      	mov	r6, r0
   1b238:	460f      	mov	r7, r1
   1b23a:	d005      	beq.n	1b248 <pow+0x34>
   1b23c:	4640      	mov	r0, r8
   1b23e:	4649      	mov	r1, r9
   1b240:	f7ff f8c2 	bl	1a3c8 <__isnand>
   1b244:	4605      	mov	r5, r0
   1b246:	b120      	cbz	r0, 1b252 <pow+0x3e>
   1b248:	4630      	mov	r0, r6
   1b24a:	4639      	mov	r1, r7
   1b24c:	b00d      	add	sp, #52	; 0x34
   1b24e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1b252:	4650      	mov	r0, sl
   1b254:	4659      	mov	r1, fp
   1b256:	f7ff f8b7 	bl	1a3c8 <__isnand>
   1b25a:	9001      	str	r0, [sp, #4]
   1b25c:	2800      	cmp	r0, #0
   1b25e:	d02b      	beq.n	1b2b8 <pow+0xa4>
   1b260:	4640      	mov	r0, r8
   1b262:	4649      	mov	r1, r9
   1b264:	2200      	movs	r2, #0
   1b266:	2300      	movs	r3, #0
   1b268:	f7ff fc06 	bl	1aa78 <__aeabi_dcmpeq>
   1b26c:	2800      	cmp	r0, #0
   1b26e:	d0eb      	beq.n	1b248 <pow+0x34>
   1b270:	f994 2000 	ldrsb.w	r2, [r4]
   1b274:	f64f 3330 	movw	r3, #64304	; 0xfb30
   1b278:	f2c0 0302 	movt	r3, #2
   1b27c:	2000      	movs	r0, #0
   1b27e:	f1b2 3fff 	cmp.w	r2, #4294967295
   1b282:	bf14      	ite	ne
   1b284:	2100      	movne	r1, #0
   1b286:	2101      	moveq	r1, #1
   1b288:	9303      	str	r3, [sp, #12]
   1b28a:	2a02      	cmp	r2, #2
   1b28c:	bf14      	ite	ne
   1b28e:	460a      	movne	r2, r1
   1b290:	f041 0201 	orreq.w	r2, r1, #1
   1b294:	f240 0100 	movw	r1, #0
   1b298:	2301      	movs	r3, #1
   1b29a:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
   1b29e:	950a      	str	r5, [sp, #40]	; 0x28
   1b2a0:	e9cd ab04 	strd	sl, fp, [sp, #16]
   1b2a4:	e9cd 8906 	strd	r8, r9, [sp, #24]
   1b2a8:	9302      	str	r3, [sp, #8]
   1b2aa:	e9cd 0108 	strd	r0, r1, [sp, #32]
   1b2ae:	2a00      	cmp	r2, #0
   1b2b0:	d02e      	beq.n	1b310 <pow+0xfc>
   1b2b2:	e9dd 6708 	ldrd	r6, r7, [sp, #32]
   1b2b6:	e7c7      	b.n	1b248 <pow+0x34>
   1b2b8:	4650      	mov	r0, sl
   1b2ba:	4659      	mov	r1, fp
   1b2bc:	2200      	movs	r2, #0
   1b2be:	2300      	movs	r3, #0
   1b2c0:	f7ff fbda 	bl	1aa78 <__aeabi_dcmpeq>
   1b2c4:	2800      	cmp	r0, #0
   1b2c6:	d030      	beq.n	1b32a <pow+0x116>
   1b2c8:	4640      	mov	r0, r8
   1b2ca:	4649      	mov	r1, r9
   1b2cc:	2200      	movs	r2, #0
   1b2ce:	2300      	movs	r3, #0
   1b2d0:	f7ff fbd2 	bl	1aa78 <__aeabi_dcmpeq>
   1b2d4:	2800      	cmp	r0, #0
   1b2d6:	d064      	beq.n	1b3a2 <pow+0x18e>
   1b2d8:	9801      	ldr	r0, [sp, #4]
   1b2da:	f64f 3330 	movw	r3, #64304	; 0xfb30
   1b2de:	f994 2000 	ldrsb.w	r2, [r4]
   1b2e2:	f2c0 0302 	movt	r3, #2
   1b2e6:	2100      	movs	r1, #0
   1b2e8:	9303      	str	r3, [sp, #12]
   1b2ea:	900a      	str	r0, [sp, #40]	; 0x28
   1b2ec:	2301      	movs	r3, #1
   1b2ee:	2000      	movs	r0, #0
   1b2f0:	e9cd ab04 	strd	sl, fp, [sp, #16]
   1b2f4:	9302      	str	r3, [sp, #8]
   1b2f6:	e9cd 8906 	strd	r8, r9, [sp, #24]
   1b2fa:	e9cd 0108 	strd	r0, r1, [sp, #32]
   1b2fe:	b13a      	cbz	r2, 1b310 <pow+0xfc>
   1b300:	f240 0300 	movw	r3, #0
   1b304:	2200      	movs	r2, #0
   1b306:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
   1b30a:	e9cd 2308 	strd	r2, r3, [sp, #32]
   1b30e:	e7d0      	b.n	1b2b2 <pow+0x9e>
   1b310:	a802      	add	r0, sp, #8
   1b312:	f000 ffd7 	bl	1c2c4 <matherr>
   1b316:	2800      	cmp	r0, #0
   1b318:	d071      	beq.n	1b3fe <pow+0x1ea>
   1b31a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1b31c:	2b00      	cmp	r3, #0
   1b31e:	d0c8      	beq.n	1b2b2 <pow+0x9e>
   1b320:	f7fa f85a 	bl	153d8 <__errno>
   1b324:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1b326:	6003      	str	r3, [r0, #0]
   1b328:	e7c3      	b.n	1b2b2 <pow+0x9e>
   1b32a:	4630      	mov	r0, r6
   1b32c:	4639      	mov	r1, r7
   1b32e:	f000 ffc1 	bl	1c2b4 <finite>
   1b332:	4605      	mov	r5, r0
   1b334:	2800      	cmp	r0, #0
   1b336:	d067      	beq.n	1b408 <pow+0x1f4>
   1b338:	4630      	mov	r0, r6
   1b33a:	4639      	mov	r1, r7
   1b33c:	2200      	movs	r2, #0
   1b33e:	2300      	movs	r3, #0
   1b340:	f7ff fb9a 	bl	1aa78 <__aeabi_dcmpeq>
   1b344:	2800      	cmp	r0, #0
   1b346:	f43f af7f 	beq.w	1b248 <pow+0x34>
   1b34a:	4650      	mov	r0, sl
   1b34c:	4659      	mov	r1, fp
   1b34e:	f000 ffb1 	bl	1c2b4 <finite>
   1b352:	2800      	cmp	r0, #0
   1b354:	f43f af78 	beq.w	1b248 <pow+0x34>
   1b358:	4640      	mov	r0, r8
   1b35a:	4649      	mov	r1, r9
   1b35c:	f000 ffaa 	bl	1c2b4 <finite>
   1b360:	2800      	cmp	r0, #0
   1b362:	f43f af71 	beq.w	1b248 <pow+0x34>
   1b366:	f994 2000 	ldrsb.w	r2, [r4]
   1b36a:	f64f 3330 	movw	r3, #64304	; 0xfb30
   1b36e:	f2c0 0302 	movt	r3, #2
   1b372:	2000      	movs	r0, #0
   1b374:	2100      	movs	r1, #0
   1b376:	9303      	str	r3, [sp, #12]
   1b378:	2304      	movs	r3, #4
   1b37a:	9302      	str	r3, [sp, #8]
   1b37c:	2300      	movs	r3, #0
   1b37e:	2a02      	cmp	r2, #2
   1b380:	e9cd ab04 	strd	sl, fp, [sp, #16]
   1b384:	e9cd 8906 	strd	r8, r9, [sp, #24]
   1b388:	930a      	str	r3, [sp, #40]	; 0x28
   1b38a:	e9cd 0108 	strd	r0, r1, [sp, #32]
   1b38e:	d06a      	beq.n	1b466 <pow+0x252>
   1b390:	a802      	add	r0, sp, #8
   1b392:	f000 ff97 	bl	1c2c4 <matherr>
   1b396:	2800      	cmp	r0, #0
   1b398:	d065      	beq.n	1b466 <pow+0x252>
   1b39a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1b39c:	2b00      	cmp	r3, #0
   1b39e:	d088      	beq.n	1b2b2 <pow+0x9e>
   1b3a0:	e7be      	b.n	1b320 <pow+0x10c>
   1b3a2:	4640      	mov	r0, r8
   1b3a4:	4649      	mov	r1, r9
   1b3a6:	f000 ff85 	bl	1c2b4 <finite>
   1b3aa:	2800      	cmp	r0, #0
   1b3ac:	f43f af4c 	beq.w	1b248 <pow+0x34>
   1b3b0:	4640      	mov	r0, r8
   1b3b2:	4649      	mov	r1, r9
   1b3b4:	2200      	movs	r2, #0
   1b3b6:	2300      	movs	r3, #0
   1b3b8:	f7ff fb68 	bl	1aa8c <__aeabi_dcmplt>
   1b3bc:	2800      	cmp	r0, #0
   1b3be:	f43f af43 	beq.w	1b248 <pow+0x34>
   1b3c2:	9901      	ldr	r1, [sp, #4]
   1b3c4:	f64f 3330 	movw	r3, #64304	; 0xfb30
   1b3c8:	7822      	ldrb	r2, [r4, #0]
   1b3ca:	f2c0 0302 	movt	r3, #2
   1b3ce:	e9cd ab04 	strd	sl, fp, [sp, #16]
   1b3d2:	9303      	str	r3, [sp, #12]
   1b3d4:	2301      	movs	r3, #1
   1b3d6:	910a      	str	r1, [sp, #40]	; 0x28
   1b3d8:	9302      	str	r3, [sp, #8]
   1b3da:	e9cd 8906 	strd	r8, r9, [sp, #24]
   1b3de:	2a00      	cmp	r2, #0
   1b3e0:	d137      	bne.n	1b452 <pow+0x23e>
   1b3e2:	2200      	movs	r2, #0
   1b3e4:	2300      	movs	r3, #0
   1b3e6:	e9cd 2308 	strd	r2, r3, [sp, #32]
   1b3ea:	a802      	add	r0, sp, #8
   1b3ec:	f000 ff6a 	bl	1c2c4 <matherr>
   1b3f0:	2800      	cmp	r0, #0
   1b3f2:	d1d2      	bne.n	1b39a <pow+0x186>
   1b3f4:	f7f9 fff0 	bl	153d8 <__errno>
   1b3f8:	2321      	movs	r3, #33	; 0x21
   1b3fa:	6003      	str	r3, [r0, #0]
   1b3fc:	e7cd      	b.n	1b39a <pow+0x186>
   1b3fe:	f7f9 ffeb 	bl	153d8 <__errno>
   1b402:	2321      	movs	r3, #33	; 0x21
   1b404:	6003      	str	r3, [r0, #0]
   1b406:	e788      	b.n	1b31a <pow+0x106>
   1b408:	4650      	mov	r0, sl
   1b40a:	4659      	mov	r1, fp
   1b40c:	f000 ff52 	bl	1c2b4 <finite>
   1b410:	2800      	cmp	r0, #0
   1b412:	d091      	beq.n	1b338 <pow+0x124>
   1b414:	4640      	mov	r0, r8
   1b416:	4649      	mov	r1, r9
   1b418:	f000 ff4c 	bl	1c2b4 <finite>
   1b41c:	2800      	cmp	r0, #0
   1b41e:	d08b      	beq.n	1b338 <pow+0x124>
   1b420:	4630      	mov	r0, r6
   1b422:	4639      	mov	r1, r7
   1b424:	f7fe ffd0 	bl	1a3c8 <__isnand>
   1b428:	b310      	cbz	r0, 1b470 <pow+0x25c>
   1b42a:	7824      	ldrb	r4, [r4, #0]
   1b42c:	f64f 3330 	movw	r3, #64304	; 0xfb30
   1b430:	f2c0 0302 	movt	r3, #2
   1b434:	950a      	str	r5, [sp, #40]	; 0x28
   1b436:	9303      	str	r3, [sp, #12]
   1b438:	2301      	movs	r3, #1
   1b43a:	e9cd ab04 	strd	sl, fp, [sp, #16]
   1b43e:	9302      	str	r3, [sp, #8]
   1b440:	e9cd 8906 	strd	r8, r9, [sp, #24]
   1b444:	2c00      	cmp	r4, #0
   1b446:	d13b      	bne.n	1b4c0 <pow+0x2ac>
   1b448:	2000      	movs	r0, #0
   1b44a:	2100      	movs	r1, #0
   1b44c:	e9cd 0108 	strd	r0, r1, [sp, #32]
   1b450:	e7cb      	b.n	1b3ea <pow+0x1d6>
   1b452:	2000      	movs	r0, #0
   1b454:	2a02      	cmp	r2, #2
   1b456:	f240 0100 	movw	r1, #0
   1b45a:	f6cf 71f0 	movt	r1, #65520	; 0xfff0
   1b45e:	e9cd 0108 	strd	r0, r1, [sp, #32]
   1b462:	d0c7      	beq.n	1b3f4 <pow+0x1e0>
   1b464:	e7c1      	b.n	1b3ea <pow+0x1d6>
   1b466:	f7f9 ffb7 	bl	153d8 <__errno>
   1b46a:	2322      	movs	r3, #34	; 0x22
   1b46c:	6003      	str	r3, [r0, #0]
   1b46e:	e794      	b.n	1b39a <pow+0x186>
   1b470:	7825      	ldrb	r5, [r4, #0]
   1b472:	f64f 3230 	movw	r2, #64304	; 0xfb30
   1b476:	f2c0 0202 	movt	r2, #2
   1b47a:	2303      	movs	r3, #3
   1b47c:	900a      	str	r0, [sp, #40]	; 0x28
   1b47e:	9203      	str	r2, [sp, #12]
   1b480:	9302      	str	r3, [sp, #8]
   1b482:	e9cd ab04 	strd	sl, fp, [sp, #16]
   1b486:	e9cd 8906 	strd	r8, r9, [sp, #24]
   1b48a:	bb25      	cbnz	r5, 1b4d6 <pow+0x2c2>
   1b48c:	f64f 77ff 	movw	r7, #65535	; 0xffff
   1b490:	4650      	mov	r0, sl
   1b492:	4659      	mov	r1, fp
   1b494:	2200      	movs	r2, #0
   1b496:	2300      	movs	r3, #0
   1b498:	f04f 4660 	mov.w	r6, #3758096384	; 0xe0000000
   1b49c:	f2c4 77ef 	movt	r7, #18415	; 0x47ef
   1b4a0:	e9cd 6708 	strd	r6, r7, [sp, #32]
   1b4a4:	f7ff faf2 	bl	1aa8c <__aeabi_dcmplt>
   1b4a8:	bb30      	cbnz	r0, 1b4f8 <pow+0x2e4>
   1b4aa:	a802      	add	r0, sp, #8
   1b4ac:	f000 ff0a 	bl	1c2c4 <matherr>
   1b4b0:	2800      	cmp	r0, #0
   1b4b2:	f47f af32 	bne.w	1b31a <pow+0x106>
   1b4b6:	f7f9 ff8f 	bl	153d8 <__errno>
   1b4ba:	2322      	movs	r3, #34	; 0x22
   1b4bc:	6003      	str	r3, [r0, #0]
   1b4be:	e72c      	b.n	1b31a <pow+0x106>
   1b4c0:	2000      	movs	r0, #0
   1b4c2:	2100      	movs	r1, #0
   1b4c4:	4602      	mov	r2, r0
   1b4c6:	460b      	mov	r3, r1
   1b4c8:	f7f9 fb8e 	bl	14be8 <__aeabi_ddiv>
   1b4cc:	2c02      	cmp	r4, #2
   1b4ce:	e9cd 0108 	strd	r0, r1, [sp, #32]
   1b4d2:	d08f      	beq.n	1b3f4 <pow+0x1e0>
   1b4d4:	e789      	b.n	1b3ea <pow+0x1d6>
   1b4d6:	f240 0700 	movw	r7, #0
   1b4da:	4650      	mov	r0, sl
   1b4dc:	4659      	mov	r1, fp
   1b4de:	2200      	movs	r2, #0
   1b4e0:	2300      	movs	r3, #0
   1b4e2:	2600      	movs	r6, #0
   1b4e4:	f6c7 77f0 	movt	r7, #32752	; 0x7ff0
   1b4e8:	e9cd 6708 	strd	r6, r7, [sp, #32]
   1b4ec:	f7ff face 	bl	1aa8c <__aeabi_dcmplt>
   1b4f0:	bb00      	cbnz	r0, 1b534 <pow+0x320>
   1b4f2:	2d02      	cmp	r5, #2
   1b4f4:	d1d9      	bne.n	1b4aa <pow+0x296>
   1b4f6:	e7de      	b.n	1b4b6 <pow+0x2a2>
   1b4f8:	f240 0300 	movw	r3, #0
   1b4fc:	2200      	movs	r2, #0
   1b4fe:	f6c3 73e0 	movt	r3, #16352	; 0x3fe0
   1b502:	4640      	mov	r0, r8
   1b504:	4649      	mov	r1, r9
   1b506:	f7f9 fa45 	bl	14994 <__aeabi_dmul>
   1b50a:	4606      	mov	r6, r0
   1b50c:	460f      	mov	r7, r1
   1b50e:	f000 fee1 	bl	1c2d4 <rint>
   1b512:	4632      	mov	r2, r6
   1b514:	463b      	mov	r3, r7
   1b516:	f7ff faaf 	bl	1aa78 <__aeabi_dcmpeq>
   1b51a:	b948      	cbnz	r0, 1b530 <pow+0x31c>
   1b51c:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1b520:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
   1b524:	f2cc 73ef 	movt	r3, #51183	; 0xc7ef
   1b528:	7825      	ldrb	r5, [r4, #0]
   1b52a:	e9cd 2308 	strd	r2, r3, [sp, #32]
   1b52e:	e7e0      	b.n	1b4f2 <pow+0x2de>
   1b530:	7825      	ldrb	r5, [r4, #0]
   1b532:	e7de      	b.n	1b4f2 <pow+0x2de>
   1b534:	f240 0300 	movw	r3, #0
   1b538:	2200      	movs	r2, #0
   1b53a:	f6c3 73e0 	movt	r3, #16352	; 0x3fe0
   1b53e:	4640      	mov	r0, r8
   1b540:	4649      	mov	r1, r9
   1b542:	f7f9 fa27 	bl	14994 <__aeabi_dmul>
   1b546:	4606      	mov	r6, r0
   1b548:	460f      	mov	r7, r1
   1b54a:	f000 fec3 	bl	1c2d4 <rint>
   1b54e:	4632      	mov	r2, r6
   1b550:	463b      	mov	r3, r7
   1b552:	f7ff fa91 	bl	1aa78 <__aeabi_dcmpeq>
   1b556:	2800      	cmp	r0, #0
   1b558:	d1ea      	bne.n	1b530 <pow+0x31c>
   1b55a:	f240 0300 	movw	r3, #0
   1b55e:	2200      	movs	r2, #0
   1b560:	f6cf 73f0 	movt	r3, #65520	; 0xfff0
   1b564:	7825      	ldrb	r5, [r4, #0]
   1b566:	e9cd 2308 	strd	r2, r3, [sp, #32]
   1b56a:	e7c2      	b.n	1b4f2 <pow+0x2de>
   1b56c:	0000      	lsls	r0, r0, #0
	...

0001b570 <__ieee754_pow>:
   1b570:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1b574:	468a      	mov	sl, r1
   1b576:	4619      	mov	r1, r3
   1b578:	4680      	mov	r8, r0
   1b57a:	f021 4600 	bic.w	r6, r1, #2147483648	; 0x80000000
   1b57e:	4610      	mov	r0, r2
   1b580:	460f      	mov	r7, r1
   1b582:	ea56 0100 	orrs.w	r1, r6, r0
   1b586:	b091      	sub	sp, #68	; 0x44
   1b588:	4615      	mov	r5, r2
   1b58a:	461c      	mov	r4, r3
   1b58c:	46d3      	mov	fp, sl
   1b58e:	46c1      	mov	r9, r8
   1b590:	d011      	beq.n	1b5b6 <__ieee754_pow+0x46>
   1b592:	f240 0100 	movw	r1, #0
   1b596:	f02a 4c00 	bic.w	ip, sl, #2147483648	; 0x80000000
   1b59a:	f6c7 71f0 	movt	r1, #32752	; 0x7ff0
   1b59e:	f8cd a008 	str.w	sl, [sp, #8]
   1b5a2:	458c      	cmp	ip, r1
   1b5a4:	dd11      	ble.n	1b5ca <__ieee754_pow+0x5a>
   1b5a6:	f10c 4c40 	add.w	ip, ip, #3221225472	; 0xc0000000
   1b5aa:	f50c 1c80 	add.w	ip, ip, #1048576	; 0x100000
   1b5ae:	ea5c 0c09 	orrs.w	ip, ip, r9
   1b5b2:	f040 8084 	bne.w	1b6be <__ieee754_pow+0x14e>
   1b5b6:	f240 0400 	movw	r4, #0
   1b5ba:	2500      	movs	r5, #0
   1b5bc:	f6c3 74f0 	movt	r4, #16368	; 0x3ff0
   1b5c0:	4628      	mov	r0, r5
   1b5c2:	4621      	mov	r1, r4
   1b5c4:	b011      	add	sp, #68	; 0x44
   1b5c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1b5ca:	bf14      	ite	ne
   1b5cc:	2200      	movne	r2, #0
   1b5ce:	2201      	moveq	r2, #1
   1b5d0:	f1b8 0f00 	cmp.w	r8, #0
   1b5d4:	bf0c      	ite	eq
   1b5d6:	2300      	moveq	r3, #0
   1b5d8:	f002 0301 	andne.w	r3, r2, #1
   1b5dc:	2b00      	cmp	r3, #0
   1b5de:	d1e2      	bne.n	1b5a6 <__ieee754_pow+0x36>
   1b5e0:	428e      	cmp	r6, r1
   1b5e2:	dce0      	bgt.n	1b5a6 <__ieee754_pow+0x36>
   1b5e4:	bf14      	ite	ne
   1b5e6:	2300      	movne	r3, #0
   1b5e8:	2301      	moveq	r3, #1
   1b5ea:	9308      	str	r3, [sp, #32]
   1b5ec:	2800      	cmp	r0, #0
   1b5ee:	bf0c      	ite	eq
   1b5f0:	2300      	moveq	r3, #0
   1b5f2:	f003 0301 	andne.w	r3, r3, #1
   1b5f6:	2b00      	cmp	r3, #0
   1b5f8:	d1d5      	bne.n	1b5a6 <__ieee754_pow+0x36>
   1b5fa:	f1ba 0f00 	cmp.w	sl, #0
   1b5fe:	db67      	blt.n	1b6d0 <__ieee754_pow+0x160>
   1b600:	2300      	movs	r3, #0
   1b602:	9306      	str	r3, [sp, #24]
   1b604:	b9b0      	cbnz	r0, 1b634 <__ieee754_pow+0xc4>
   1b606:	9908      	ldr	r1, [sp, #32]
   1b608:	2900      	cmp	r1, #0
   1b60a:	d16a      	bne.n	1b6e2 <__ieee754_pow+0x172>
   1b60c:	f240 0300 	movw	r3, #0
   1b610:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
   1b614:	429e      	cmp	r6, r3
   1b616:	f000 809d 	beq.w	1b754 <__ieee754_pow+0x1e4>
   1b61a:	f1b7 4f80 	cmp.w	r7, #1073741824	; 0x40000000
   1b61e:	bf04      	itt	eq
   1b620:	4640      	moveq	r0, r8
   1b622:	4651      	moveq	r1, sl
   1b624:	d044      	beq.n	1b6b0 <__ieee754_pow+0x140>
   1b626:	f240 0300 	movw	r3, #0
   1b62a:	f6c3 73e0 	movt	r3, #16352	; 0x3fe0
   1b62e:	429f      	cmp	r7, r3
   1b630:	f000 83b3 	beq.w	1bd9a <__ieee754_pow+0x82a>
   1b634:	4640      	mov	r0, r8
   1b636:	4651      	mov	r1, sl
   1b638:	9201      	str	r2, [sp, #4]
   1b63a:	f8cd c000 	str.w	ip, [sp]
   1b63e:	f000 fe35 	bl	1c2ac <fabs>
   1b642:	9a01      	ldr	r2, [sp, #4]
   1b644:	f8dd c000 	ldr.w	ip, [sp]
   1b648:	9104      	str	r1, [sp, #16]
   1b64a:	f1b9 0f00 	cmp.w	r9, #0
   1b64e:	d10c      	bne.n	1b66a <__ieee754_pow+0xfa>
   1b650:	f1bc 0f00 	cmp.w	ip, #0
   1b654:	bf08      	it	eq
   1b656:	f042 0201 	orreq.w	r2, r2, #1
   1b65a:	2a00      	cmp	r2, #0
   1b65c:	d156      	bne.n	1b70c <__ieee754_pow+0x19c>
   1b65e:	f240 0300 	movw	r3, #0
   1b662:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
   1b666:	459c      	cmp	ip, r3
   1b668:	d050      	beq.n	1b70c <__ieee754_pow+0x19c>
   1b66a:	ea4f 79db 	mov.w	r9, fp, lsr #31
   1b66e:	9906      	ldr	r1, [sp, #24]
   1b670:	f109 39ff 	add.w	r9, r9, #4294967295
   1b674:	ea51 0109 	orrs.w	r1, r1, r9
   1b678:	d067      	beq.n	1b74a <__ieee754_pow+0x1da>
   1b67a:	f240 0300 	movw	r3, #0
   1b67e:	f2c4 13e0 	movt	r3, #16864	; 0x41e0
   1b682:	429e      	cmp	r6, r3
   1b684:	f340 8099 	ble.w	1b7ba <__ieee754_pow+0x24a>
   1b688:	f240 0300 	movw	r3, #0
   1b68c:	f2c4 33f0 	movt	r3, #17392	; 0x43f0
   1b690:	429e      	cmp	r6, r3
   1b692:	f340 83f2 	ble.w	1be7a <__ieee754_pow+0x90a>
   1b696:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1b69a:	f6c3 73ef 	movt	r3, #16367	; 0x3fef
   1b69e:	459c      	cmp	ip, r3
   1b6a0:	f340 8386 	ble.w	1bdb0 <__ieee754_pow+0x840>
   1b6a4:	2f00      	cmp	r7, #0
   1b6a6:	dd2e      	ble.n	1b706 <__ieee754_pow+0x196>
   1b6a8:	f60f 1164 	addw	r1, pc, #2404	; 0x964
   1b6ac:	e9d1 0100 	ldrd	r0, r1, [r1]
   1b6b0:	4602      	mov	r2, r0
   1b6b2:	460b      	mov	r3, r1
   1b6b4:	f7f9 f96e 	bl	14994 <__aeabi_dmul>
   1b6b8:	4605      	mov	r5, r0
   1b6ba:	460c      	mov	r4, r1
   1b6bc:	e780      	b.n	1b5c0 <__ieee754_pow+0x50>
   1b6be:	f64f 1080 	movw	r0, #63872	; 0xf980
   1b6c2:	f2c0 0002 	movt	r0, #2
   1b6c6:	b011      	add	sp, #68	; 0x44
   1b6c8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1b6cc:	f000 bdfc 	b.w	1c2c8 <nan>
   1b6d0:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1b6d4:	f2c4 333f 	movt	r3, #17215	; 0x433f
   1b6d8:	429e      	cmp	r6, r3
   1b6da:	dd4d      	ble.n	1b778 <__ieee754_pow+0x208>
   1b6dc:	2102      	movs	r1, #2
   1b6de:	9106      	str	r1, [sp, #24]
   1b6e0:	e790      	b.n	1b604 <__ieee754_pow+0x94>
   1b6e2:	f10c 4340 	add.w	r3, ip, #3221225472	; 0xc0000000
   1b6e6:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
   1b6ea:	ea53 0309 	orrs.w	r3, r3, r9
   1b6ee:	f43f af62 	beq.w	1b5b6 <__ieee754_pow+0x46>
   1b6f2:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1b6f6:	f6c3 73ef 	movt	r3, #16367	; 0x3fef
   1b6fa:	459c      	cmp	ip, r3
   1b6fc:	f340 83b6 	ble.w	1be6c <__ieee754_pow+0x8fc>
   1b700:	2f00      	cmp	r7, #0
   1b702:	f6bf af5d 	bge.w	1b5c0 <__ieee754_pow+0x50>
   1b706:	2500      	movs	r5, #0
   1b708:	462c      	mov	r4, r5
   1b70a:	e759      	b.n	1b5c0 <__ieee754_pow+0x50>
   1b70c:	2f00      	cmp	r7, #0
   1b70e:	f2c0 8428 	blt.w	1bf62 <__ieee754_pow+0x9f2>
   1b712:	9c04      	ldr	r4, [sp, #16]
   1b714:	4605      	mov	r5, r0
   1b716:	9902      	ldr	r1, [sp, #8]
   1b718:	2900      	cmp	r1, #0
   1b71a:	f6bf af51 	bge.w	1b5c0 <__ieee754_pow+0x50>
   1b71e:	f10c 4c40 	add.w	ip, ip, #3221225472	; 0xc0000000
   1b722:	9a06      	ldr	r2, [sp, #24]
   1b724:	f50c 1c80 	add.w	ip, ip, #1048576	; 0x100000
   1b728:	ea52 020c 	orrs.w	r2, r2, ip
   1b72c:	f040 8447 	bne.w	1bfbe <__ieee754_pow+0xa4e>
   1b730:	462a      	mov	r2, r5
   1b732:	4628      	mov	r0, r5
   1b734:	4623      	mov	r3, r4
   1b736:	4621      	mov	r1, r4
   1b738:	f7f8 ff78 	bl	1462c <__aeabi_dsub>
   1b73c:	4602      	mov	r2, r0
   1b73e:	460b      	mov	r3, r1
   1b740:	f7f9 fa52 	bl	14be8 <__aeabi_ddiv>
   1b744:	4605      	mov	r5, r0
   1b746:	460c      	mov	r4, r1
   1b748:	e73a      	b.n	1b5c0 <__ieee754_pow+0x50>
   1b74a:	4640      	mov	r0, r8
   1b74c:	4651      	mov	r1, sl
   1b74e:	4642      	mov	r2, r8
   1b750:	4653      	mov	r3, sl
   1b752:	e7f1      	b.n	1b738 <__ieee754_pow+0x1c8>
   1b754:	2f00      	cmp	r7, #0
   1b756:	bfa4      	itt	ge
   1b758:	4645      	movge	r5, r8
   1b75a:	4654      	movge	r4, sl
   1b75c:	f6bf af30 	bge.w	1b5c0 <__ieee754_pow+0x50>
   1b760:	f240 0100 	movw	r1, #0
   1b764:	4642      	mov	r2, r8
   1b766:	2000      	movs	r0, #0
   1b768:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
   1b76c:	4653      	mov	r3, sl
   1b76e:	f7f9 fa3b 	bl	14be8 <__aeabi_ddiv>
   1b772:	4605      	mov	r5, r0
   1b774:	460c      	mov	r4, r1
   1b776:	e723      	b.n	1b5c0 <__ieee754_pow+0x50>
   1b778:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1b77c:	f6c3 73ef 	movt	r3, #16367	; 0x3fef
   1b780:	429e      	cmp	r6, r3
   1b782:	f77f af3d 	ble.w	1b600 <__ieee754_pow+0x90>
   1b786:	1533      	asrs	r3, r6, #20
   1b788:	f5a3 737e 	sub.w	r3, r3, #1016	; 0x3f8
   1b78c:	3b07      	subs	r3, #7
   1b78e:	2b14      	cmp	r3, #20
   1b790:	f340 8408 	ble.w	1bfa4 <__ieee754_pow+0xa34>
   1b794:	f1c3 0334 	rsb	r3, r3, #52	; 0x34
   1b798:	9304      	str	r3, [sp, #16]
   1b79a:	9904      	ldr	r1, [sp, #16]
   1b79c:	fa30 f303 	lsrs.w	r3, r0, r3
   1b7a0:	9306      	str	r3, [sp, #24]
   1b7a2:	fa13 f101 	lsls.w	r1, r3, r1
   1b7a6:	9104      	str	r1, [sp, #16]
   1b7a8:	4281      	cmp	r1, r0
   1b7aa:	f47f af29 	bne.w	1b600 <__ieee754_pow+0x90>
   1b7ae:	f003 0101 	and.w	r1, r3, #1
   1b7b2:	f1c1 0102 	rsb	r1, r1, #2
   1b7b6:	9106      	str	r1, [sp, #24]
   1b7b8:	e724      	b.n	1b604 <__ieee754_pow+0x94>
   1b7ba:	f5bc 1f80 	cmp.w	ip, #1048576	; 0x100000
   1b7be:	bfa4      	itt	ge
   1b7c0:	f64f 4101 	movwge	r1, #64513	; 0xfc01
   1b7c4:	f6cf 71ff 	movtge	r1, #65535	; 0xffff
   1b7c8:	da0f      	bge.n	1b7ea <__ieee754_pow+0x27a>
   1b7ca:	9f04      	ldr	r7, [sp, #16]
   1b7cc:	f240 0300 	movw	r3, #0
   1b7d0:	f2c4 3340 	movt	r3, #17216	; 0x4340
   1b7d4:	2200      	movs	r2, #0
   1b7d6:	4639      	mov	r1, r7
   1b7d8:	f7f9 f8dc 	bl	14994 <__aeabi_dmul>
   1b7dc:	460b      	mov	r3, r1
   1b7de:	9104      	str	r1, [sp, #16]
   1b7e0:	f64f 31cc 	movw	r1, #64460	; 0xfbcc
   1b7e4:	469c      	mov	ip, r3
   1b7e6:	f6cf 71ff 	movt	r1, #65535	; 0xffff
   1b7ea:	f02c 437f 	bic.w	r3, ip, #4278190080	; 0xff000000
   1b7ee:	f649 028e 	movw	r2, #39054	; 0x988e
   1b7f2:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
   1b7f6:	f2c0 0203 	movt	r2, #3
   1b7fa:	4293      	cmp	r3, r2
   1b7fc:	f043 577e 	orr.w	r7, r3, #1065353216	; 0x3f800000
   1b800:	eb01 5c2c 	add.w	ip, r1, ip, asr #20
   1b804:	f447 07e0 	orr.w	r7, r7, #7340032	; 0x700000
   1b808:	f340 82c3 	ble.w	1bd92 <__ieee754_pow+0x822>
   1b80c:	f24b 6279 	movw	r2, #46713	; 0xb679
   1b810:	f2c0 020b 	movt	r2, #11
   1b814:	4293      	cmp	r3, r2
   1b816:	bfc4      	itt	gt
   1b818:	f10c 0c01 	addgt.w	ip, ip, #1
   1b81c:	f5a7 1780 	subgt.w	r7, r7, #1048576	; 0x100000
   1b820:	f300 82b7 	bgt.w	1bd92 <__ieee754_pow+0x822>
   1b824:	f44f 2840 	mov.w	r8, #786432	; 0xc0000
   1b828:	2601      	movs	r6, #1
   1b82a:	f64f 3338 	movw	r3, #64312	; 0xfb38
   1b82e:	4639      	mov	r1, r7
   1b830:	f2c0 0302 	movt	r3, #2
   1b834:	f8cd c000 	str.w	ip, [sp]
   1b838:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
   1b83c:	4682      	mov	sl, r0
   1b83e:	e9d6 2300 	ldrd	r2, r3, [r6]
   1b842:	f7f8 fef3 	bl	1462c <__aeabi_dsub>
   1b846:	e9d6 2300 	ldrd	r2, r3, [r6]
   1b84a:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
   1b84e:	4650      	mov	r0, sl
   1b850:	4639      	mov	r1, r7
   1b852:	f7f8 feed 	bl	14630 <__adddf3>
   1b856:	460b      	mov	r3, r1
   1b858:	f240 0100 	movw	r1, #0
   1b85c:	4602      	mov	r2, r0
   1b85e:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
   1b862:	2000      	movs	r0, #0
   1b864:	f7f9 f9c0 	bl	14be8 <__aeabi_ddiv>
   1b868:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
   1b86c:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
   1b870:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
   1b874:	f7f9 f88e 	bl	14994 <__aeabi_dmul>
   1b878:	f04f 0e00 	mov.w	lr, #0
   1b87c:	e9cd 0108 	strd	r0, r1, [sp, #32]
   1b880:	1079      	asrs	r1, r7, #1
   1b882:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
   1b886:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
   1b88a:	e9cd 2304 	strd	r2, r3, [sp, #16]
   1b88e:	2200      	movs	r2, #0
   1b890:	f8cd e010 	str.w	lr, [sp, #16]
   1b894:	eb01 0308 	add.w	r3, r1, r8
   1b898:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
   1b89c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   1b8a0:	4610      	mov	r0, r2
   1b8a2:	4619      	mov	r1, r3
   1b8a4:	e9cd 2302 	strd	r2, r3, [sp, #8]
   1b8a8:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
   1b8ac:	f7f9 f872 	bl	14994 <__aeabi_dmul>
   1b8b0:	4602      	mov	r2, r0
   1b8b2:	460b      	mov	r3, r1
   1b8b4:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
   1b8b8:	f7f8 feb8 	bl	1462c <__aeabi_dsub>
   1b8bc:	e9d6 2300 	ldrd	r2, r3, [r6]
   1b8c0:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
   1b8c4:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   1b8c8:	f7f8 feb0 	bl	1462c <__aeabi_dsub>
   1b8cc:	4602      	mov	r2, r0
   1b8ce:	460b      	mov	r3, r1
   1b8d0:	4650      	mov	r0, sl
   1b8d2:	4639      	mov	r1, r7
   1b8d4:	f7f8 feaa 	bl	1462c <__aeabi_dsub>
   1b8d8:	4602      	mov	r2, r0
   1b8da:	460b      	mov	r3, r1
   1b8dc:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   1b8e0:	f7f9 f858 	bl	14994 <__aeabi_dmul>
   1b8e4:	4602      	mov	r2, r0
   1b8e6:	460b      	mov	r3, r1
   1b8e8:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
   1b8ec:	f7f8 fe9e 	bl	1462c <__aeabi_dsub>
   1b8f0:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
   1b8f4:	f7f9 f84e 	bl	14994 <__aeabi_dmul>
   1b8f8:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   1b8fc:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   1b900:	4602      	mov	r2, r0
   1b902:	460b      	mov	r3, r1
   1b904:	f7f9 f846 	bl	14994 <__aeabi_dmul>
   1b908:	4602      	mov	r2, r0
   1b90a:	460b      	mov	r3, r1
   1b90c:	4682      	mov	sl, r0
   1b90e:	468b      	mov	fp, r1
   1b910:	f7f9 f840 	bl	14994 <__aeabi_dmul>
   1b914:	f20f 7300 	addw	r3, pc, #1792	; 0x700
   1b918:	e9d3 2300 	ldrd	r2, r3, [r3]
   1b91c:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
   1b920:	4650      	mov	r0, sl
   1b922:	4659      	mov	r1, fp
   1b924:	f7f9 f836 	bl	14994 <__aeabi_dmul>
   1b928:	f20f 63f4 	addw	r3, pc, #1780	; 0x6f4
   1b92c:	e9d3 2300 	ldrd	r2, r3, [r3]
   1b930:	f7f8 fe7e 	bl	14630 <__adddf3>
   1b934:	4652      	mov	r2, sl
   1b936:	465b      	mov	r3, fp
   1b938:	f7f9 f82c 	bl	14994 <__aeabi_dmul>
   1b93c:	f20f 63e8 	addw	r3, pc, #1768	; 0x6e8
   1b940:	e9d3 2300 	ldrd	r2, r3, [r3]
   1b944:	f7f8 fe74 	bl	14630 <__adddf3>
   1b948:	4652      	mov	r2, sl
   1b94a:	465b      	mov	r3, fp
   1b94c:	f7f9 f822 	bl	14994 <__aeabi_dmul>
   1b950:	f20f 63dc 	addw	r3, pc, #1756	; 0x6dc
   1b954:	e9d3 2300 	ldrd	r2, r3, [r3]
   1b958:	f7f8 fe6a 	bl	14630 <__adddf3>
   1b95c:	4652      	mov	r2, sl
   1b95e:	465b      	mov	r3, fp
   1b960:	f7f9 f818 	bl	14994 <__aeabi_dmul>
   1b964:	f20f 63d0 	addw	r3, pc, #1744	; 0x6d0
   1b968:	e9d3 2300 	ldrd	r2, r3, [r3]
   1b96c:	f7f8 fe60 	bl	14630 <__adddf3>
   1b970:	4652      	mov	r2, sl
   1b972:	465b      	mov	r3, fp
   1b974:	f7f9 f80e 	bl	14994 <__aeabi_dmul>
   1b978:	f20f 63c4 	addw	r3, pc, #1732	; 0x6c4
   1b97c:	e9d3 2300 	ldrd	r2, r3, [r3]
   1b980:	f7f8 fe56 	bl	14630 <__adddf3>
   1b984:	4602      	mov	r2, r0
   1b986:	460b      	mov	r3, r1
   1b988:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
   1b98c:	f7f9 f802 	bl	14994 <__aeabi_dmul>
   1b990:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
   1b994:	4682      	mov	sl, r0
   1b996:	468b      	mov	fp, r1
   1b998:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   1b99c:	f7f8 fe48 	bl	14630 <__adddf3>
   1b9a0:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
   1b9a4:	f7f8 fff6 	bl	14994 <__aeabi_dmul>
   1b9a8:	4652      	mov	r2, sl
   1b9aa:	465b      	mov	r3, fp
   1b9ac:	f7f8 fe40 	bl	14630 <__adddf3>
   1b9b0:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
   1b9b4:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   1b9b8:	4602      	mov	r2, r0
   1b9ba:	460b      	mov	r3, r1
   1b9bc:	f7f8 ffea 	bl	14994 <__aeabi_dmul>
   1b9c0:	f240 0300 	movw	r3, #0
   1b9c4:	2200      	movs	r2, #0
   1b9c6:	f2c4 0308 	movt	r3, #16392	; 0x4008
   1b9ca:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
   1b9ce:	f7f8 fe2f 	bl	14630 <__adddf3>
   1b9d2:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
   1b9d6:	f7f8 fe2b 	bl	14630 <__adddf3>
   1b9da:	9b04      	ldr	r3, [sp, #16]
   1b9dc:	469a      	mov	sl, r3
   1b9de:	461a      	mov	r2, r3
   1b9e0:	468b      	mov	fp, r1
   1b9e2:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   1b9e6:	465b      	mov	r3, fp
   1b9e8:	f7f8 ffd4 	bl	14994 <__aeabi_dmul>
   1b9ec:	4652      	mov	r2, sl
   1b9ee:	465b      	mov	r3, fp
   1b9f0:	e9cd 0102 	strd	r0, r1, [sp, #8]
   1b9f4:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   1b9f8:	f7f8 ffcc 	bl	14994 <__aeabi_dmul>
   1b9fc:	f240 0300 	movw	r3, #0
   1ba00:	2200      	movs	r2, #0
   1ba02:	f2c4 0308 	movt	r3, #16392	; 0x4008
   1ba06:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   1ba0a:	4650      	mov	r0, sl
   1ba0c:	4659      	mov	r1, fp
   1ba0e:	f7f8 fe0d 	bl	1462c <__aeabi_dsub>
   1ba12:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
   1ba16:	f7f8 fe09 	bl	1462c <__aeabi_dsub>
   1ba1a:	4602      	mov	r2, r0
   1ba1c:	460b      	mov	r3, r1
   1ba1e:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
   1ba22:	f7f8 fe03 	bl	1462c <__aeabi_dsub>
   1ba26:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
   1ba2a:	f7f8 ffb3 	bl	14994 <__aeabi_dmul>
   1ba2e:	4602      	mov	r2, r0
   1ba30:	460b      	mov	r3, r1
   1ba32:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   1ba36:	f7f8 fdfb 	bl	14630 <__adddf3>
   1ba3a:	e9cd 0108 	strd	r0, r1, [sp, #32]
   1ba3e:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
   1ba42:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   1ba46:	f7f8 fdf3 	bl	14630 <__adddf3>
   1ba4a:	f8dd e010 	ldr.w	lr, [sp, #16]
   1ba4e:	f20f 53f8 	addw	r3, pc, #1528	; 0x5f8
   1ba52:	e9d3 2300 	ldrd	r2, r3, [r3]
   1ba56:	4670      	mov	r0, lr
   1ba58:	46f2      	mov	sl, lr
   1ba5a:	468b      	mov	fp, r1
   1ba5c:	f7f8 ff9a 	bl	14994 <__aeabi_dmul>
   1ba60:	f20f 53ec 	addw	r3, pc, #1516	; 0x5ec
   1ba64:	e9d3 2300 	ldrd	r2, r3, [r3]
   1ba68:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   1ba6c:	4650      	mov	r0, sl
   1ba6e:	4659      	mov	r1, fp
   1ba70:	f7f8 ff90 	bl	14994 <__aeabi_dmul>
   1ba74:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   1ba78:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
   1ba7c:	4650      	mov	r0, sl
   1ba7e:	4659      	mov	r1, fp
   1ba80:	f7f8 fdd4 	bl	1462c <__aeabi_dsub>
   1ba84:	4602      	mov	r2, r0
   1ba86:	460b      	mov	r3, r1
   1ba88:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   1ba8c:	f7f8 fdce 	bl	1462c <__aeabi_dsub>
   1ba90:	f20f 53c4 	addw	r3, pc, #1476	; 0x5c4
   1ba94:	e9d3 2300 	ldrd	r2, r3, [r3]
   1ba98:	f7f8 ff7c 	bl	14994 <__aeabi_dmul>
   1ba9c:	4602      	mov	r2, r0
   1ba9e:	460b      	mov	r3, r1
   1baa0:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
   1baa4:	f7f8 fdc4 	bl	14630 <__adddf3>
   1baa8:	e9d6 2304 	ldrd	r2, r3, [r6, #16]
   1baac:	f7f8 fdc0 	bl	14630 <__adddf3>
   1bab0:	e9cd 0108 	strd	r0, r1, [sp, #32]
   1bab4:	f8dd c000 	ldr.w	ip, [sp]
   1bab8:	4660      	mov	r0, ip
   1baba:	f7f8 ff05 	bl	148c8 <__aeabi_i2d>
   1babe:	e9d6 2308 	ldrd	r2, r3, [r6, #32]
   1bac2:	e9cd 2302 	strd	r2, r3, [sp, #8]
   1bac6:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
   1baca:	4682      	mov	sl, r0
   1bacc:	468b      	mov	fp, r1
   1bace:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   1bad2:	f7f8 fdad 	bl	14630 <__adddf3>
   1bad6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   1bada:	f7f8 fda9 	bl	14630 <__adddf3>
   1bade:	4652      	mov	r2, sl
   1bae0:	465b      	mov	r3, fp
   1bae2:	f7f8 fda5 	bl	14630 <__adddf3>
   1bae6:	9b04      	ldr	r3, [sp, #16]
   1bae8:	4652      	mov	r2, sl
   1baea:	461e      	mov	r6, r3
   1baec:	465b      	mov	r3, fp
   1baee:	4630      	mov	r0, r6
   1baf0:	460f      	mov	r7, r1
   1baf2:	f7f8 fd9b 	bl	1462c <__aeabi_dsub>
   1baf6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   1bafa:	f7f8 fd97 	bl	1462c <__aeabi_dsub>
   1bafe:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
   1bb02:	f7f8 fd93 	bl	1462c <__aeabi_dsub>
   1bb06:	4602      	mov	r2, r0
   1bb08:	460b      	mov	r3, r1
   1bb0a:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   1bb0e:	f7f8 fd8d 	bl	1462c <__aeabi_dsub>
   1bb12:	e9cd 0104 	strd	r0, r1, [sp, #16]
   1bb16:	f8dd e018 	ldr.w	lr, [sp, #24]
   1bb1a:	f10e 33ff 	add.w	r3, lr, #4294967295
   1bb1e:	ea53 0309 	orrs.w	r3, r3, r9
   1bb22:	f000 819b 	beq.w	1be5c <__ieee754_pow+0x8ec>
   1bb26:	f240 0300 	movw	r3, #0
   1bb2a:	2200      	movs	r2, #0
   1bb2c:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
   1bb30:	e9cd 2302 	strd	r2, r3, [sp, #8]
   1bb34:	f04f 0800 	mov.w	r8, #0
   1bb38:	4623      	mov	r3, r4
   1bb3a:	4642      	mov	r2, r8
   1bb3c:	4628      	mov	r0, r5
   1bb3e:	4621      	mov	r1, r4
   1bb40:	f7f8 fd74 	bl	1462c <__aeabi_dsub>
   1bb44:	4632      	mov	r2, r6
   1bb46:	463b      	mov	r3, r7
   1bb48:	f7f8 ff24 	bl	14994 <__aeabi_dmul>
   1bb4c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   1bb50:	4682      	mov	sl, r0
   1bb52:	468b      	mov	fp, r1
   1bb54:	4628      	mov	r0, r5
   1bb56:	4621      	mov	r1, r4
   1bb58:	f7f8 ff1c 	bl	14994 <__aeabi_dmul>
   1bb5c:	4602      	mov	r2, r0
   1bb5e:	460b      	mov	r3, r1
   1bb60:	4650      	mov	r0, sl
   1bb62:	4659      	mov	r1, fp
   1bb64:	f7f8 fd64 	bl	14630 <__adddf3>
   1bb68:	4632      	mov	r2, r6
   1bb6a:	463b      	mov	r3, r7
   1bb6c:	4682      	mov	sl, r0
   1bb6e:	468b      	mov	fp, r1
   1bb70:	4640      	mov	r0, r8
   1bb72:	4621      	mov	r1, r4
   1bb74:	f7f8 ff0e 	bl	14994 <__aeabi_dmul>
   1bb78:	4604      	mov	r4, r0
   1bb7a:	460d      	mov	r5, r1
   1bb7c:	462b      	mov	r3, r5
   1bb7e:	4650      	mov	r0, sl
   1bb80:	4659      	mov	r1, fp
   1bb82:	4622      	mov	r2, r4
   1bb84:	f7f8 fd54 	bl	14630 <__adddf3>
   1bb88:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1bb8c:	f2c4 038f 	movt	r3, #16527	; 0x408f
   1bb90:	4299      	cmp	r1, r3
   1bb92:	4680      	mov	r8, r0
   1bb94:	4689      	mov	r9, r1
   1bb96:	460f      	mov	r7, r1
   1bb98:	460e      	mov	r6, r1
   1bb9a:	f340 810d 	ble.w	1bdb8 <__ieee754_pow+0x848>
   1bb9e:	f101 423f 	add.w	r2, r1, #3204448256	; 0xbf000000
   1bba2:	f502 02e0 	add.w	r2, r2, #7340032	; 0x700000
   1bba6:	4302      	orrs	r2, r0
   1bba8:	f040 81ec 	bne.w	1bf84 <__ieee754_pow+0xa14>
   1bbac:	f20f 43b0 	addw	r3, pc, #1200	; 0x4b0
   1bbb0:	e9d3 2300 	ldrd	r2, r3, [r3]
   1bbb4:	4650      	mov	r0, sl
   1bbb6:	4659      	mov	r1, fp
   1bbb8:	f7f8 fd3a 	bl	14630 <__adddf3>
   1bbbc:	4622      	mov	r2, r4
   1bbbe:	462b      	mov	r3, r5
   1bbc0:	e9cd 0106 	strd	r0, r1, [sp, #24]
   1bbc4:	4640      	mov	r0, r8
   1bbc6:	4649      	mov	r1, r9
   1bbc8:	f7f8 fd30 	bl	1462c <__aeabi_dsub>
   1bbcc:	4602      	mov	r2, r0
   1bbce:	460b      	mov	r3, r1
   1bbd0:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
   1bbd4:	f7fe ff78 	bl	1aac8 <__aeabi_dcmpgt>
   1bbd8:	2800      	cmp	r0, #0
   1bbda:	f040 81d3 	bne.w	1bf84 <__ieee754_pow+0xa14>
   1bbde:	f029 4700 	bic.w	r7, r9, #2147483648	; 0x80000000
   1bbe2:	f240 0300 	movw	r3, #0
   1bbe6:	f6c3 73e0 	movt	r3, #16352	; 0x3fe0
   1bbea:	429f      	cmp	r7, r3
   1bbec:	f300 8100 	bgt.w	1bdf0 <__ieee754_pow+0x880>
   1bbf0:	2300      	movs	r3, #0
   1bbf2:	9306      	str	r3, [sp, #24]
   1bbf4:	469c      	mov	ip, r3
   1bbf6:	4622      	mov	r2, r4
   1bbf8:	462b      	mov	r3, r5
   1bbfa:	4650      	mov	r0, sl
   1bbfc:	4659      	mov	r1, fp
   1bbfe:	f8cd c000 	str.w	ip, [sp]
   1bc02:	f7f8 fd15 	bl	14630 <__adddf3>
   1bc06:	2600      	movs	r6, #0
   1bc08:	f20f 435c 	addw	r3, pc, #1116	; 0x45c
   1bc0c:	e9d3 2300 	ldrd	r2, r3, [r3]
   1bc10:	4630      	mov	r0, r6
   1bc12:	460f      	mov	r7, r1
   1bc14:	f7f8 febe 	bl	14994 <__aeabi_dmul>
   1bc18:	4622      	mov	r2, r4
   1bc1a:	462b      	mov	r3, r5
   1bc1c:	4680      	mov	r8, r0
   1bc1e:	4689      	mov	r9, r1
   1bc20:	4630      	mov	r0, r6
   1bc22:	4639      	mov	r1, r7
   1bc24:	f7f8 fd02 	bl	1462c <__aeabi_dsub>
   1bc28:	4602      	mov	r2, r0
   1bc2a:	460b      	mov	r3, r1
   1bc2c:	4650      	mov	r0, sl
   1bc2e:	4659      	mov	r1, fp
   1bc30:	f7f8 fcfc 	bl	1462c <__aeabi_dsub>
   1bc34:	f20f 4338 	addw	r3, pc, #1080	; 0x438
   1bc38:	e9d3 2300 	ldrd	r2, r3, [r3]
   1bc3c:	f7f8 feaa 	bl	14994 <__aeabi_dmul>
   1bc40:	f20f 4334 	addw	r3, pc, #1076	; 0x434
   1bc44:	e9d3 2300 	ldrd	r2, r3, [r3]
   1bc48:	4604      	mov	r4, r0
   1bc4a:	460d      	mov	r5, r1
   1bc4c:	4630      	mov	r0, r6
   1bc4e:	4639      	mov	r1, r7
   1bc50:	f7f8 fea0 	bl	14994 <__aeabi_dmul>
   1bc54:	4602      	mov	r2, r0
   1bc56:	460b      	mov	r3, r1
   1bc58:	4620      	mov	r0, r4
   1bc5a:	4629      	mov	r1, r5
   1bc5c:	f7f8 fce8 	bl	14630 <__adddf3>
   1bc60:	4606      	mov	r6, r0
   1bc62:	460f      	mov	r7, r1
   1bc64:	4632      	mov	r2, r6
   1bc66:	463b      	mov	r3, r7
   1bc68:	4640      	mov	r0, r8
   1bc6a:	4649      	mov	r1, r9
   1bc6c:	f7f8 fce0 	bl	14630 <__adddf3>
   1bc70:	4642      	mov	r2, r8
   1bc72:	464b      	mov	r3, r9
   1bc74:	460d      	mov	r5, r1
   1bc76:	4604      	mov	r4, r0
   1bc78:	f7f8 fcd8 	bl	1462c <__aeabi_dsub>
   1bc7c:	4602      	mov	r2, r0
   1bc7e:	460b      	mov	r3, r1
   1bc80:	4630      	mov	r0, r6
   1bc82:	4639      	mov	r1, r7
   1bc84:	f7f8 fcd2 	bl	1462c <__aeabi_dsub>
   1bc88:	462b      	mov	r3, r5
   1bc8a:	4622      	mov	r2, r4
   1bc8c:	4680      	mov	r8, r0
   1bc8e:	4689      	mov	r9, r1
   1bc90:	4620      	mov	r0, r4
   1bc92:	4629      	mov	r1, r5
   1bc94:	f7f8 fe7e 	bl	14994 <__aeabi_dmul>
   1bc98:	a3f9      	add	r3, pc, #996	; (adr r3, 1c080 <__ieee754_pow+0xb10>)
   1bc9a:	e9d3 2300 	ldrd	r2, r3, [r3]
   1bc9e:	4606      	mov	r6, r0
   1bca0:	460f      	mov	r7, r1
   1bca2:	f7f8 fe77 	bl	14994 <__aeabi_dmul>
   1bca6:	a3f8      	add	r3, pc, #992	; (adr r3, 1c088 <__ieee754_pow+0xb18>)
   1bca8:	e9d3 2300 	ldrd	r2, r3, [r3]
   1bcac:	f7f8 fcbe 	bl	1462c <__aeabi_dsub>
   1bcb0:	4632      	mov	r2, r6
   1bcb2:	463b      	mov	r3, r7
   1bcb4:	f7f8 fe6e 	bl	14994 <__aeabi_dmul>
   1bcb8:	a3f5      	add	r3, pc, #980	; (adr r3, 1c090 <__ieee754_pow+0xb20>)
   1bcba:	e9d3 2300 	ldrd	r2, r3, [r3]
   1bcbe:	f7f8 fcb7 	bl	14630 <__adddf3>
   1bcc2:	4632      	mov	r2, r6
   1bcc4:	463b      	mov	r3, r7
   1bcc6:	f7f8 fe65 	bl	14994 <__aeabi_dmul>
   1bcca:	a3f3      	add	r3, pc, #972	; (adr r3, 1c098 <__ieee754_pow+0xb28>)
   1bccc:	e9d3 2300 	ldrd	r2, r3, [r3]
   1bcd0:	f7f8 fcac 	bl	1462c <__aeabi_dsub>
   1bcd4:	4632      	mov	r2, r6
   1bcd6:	463b      	mov	r3, r7
   1bcd8:	f7f8 fe5c 	bl	14994 <__aeabi_dmul>
   1bcdc:	a3f0      	add	r3, pc, #960	; (adr r3, 1c0a0 <__ieee754_pow+0xb30>)
   1bcde:	e9d3 2300 	ldrd	r2, r3, [r3]
   1bce2:	f7f8 fca5 	bl	14630 <__adddf3>
   1bce6:	4632      	mov	r2, r6
   1bce8:	463b      	mov	r3, r7
   1bcea:	f7f8 fe53 	bl	14994 <__aeabi_dmul>
   1bcee:	4602      	mov	r2, r0
   1bcf0:	460b      	mov	r3, r1
   1bcf2:	4620      	mov	r0, r4
   1bcf4:	4629      	mov	r1, r5
   1bcf6:	f7f8 fc99 	bl	1462c <__aeabi_dsub>
   1bcfa:	4606      	mov	r6, r0
   1bcfc:	460f      	mov	r7, r1
   1bcfe:	4632      	mov	r2, r6
   1bd00:	463b      	mov	r3, r7
   1bd02:	4629      	mov	r1, r5
   1bd04:	4620      	mov	r0, r4
   1bd06:	f7f8 fe45 	bl	14994 <__aeabi_dmul>
   1bd0a:	2200      	movs	r2, #0
   1bd0c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   1bd10:	4682      	mov	sl, r0
   1bd12:	468b      	mov	fp, r1
   1bd14:	4630      	mov	r0, r6
   1bd16:	4639      	mov	r1, r7
   1bd18:	f7f8 fc88 	bl	1462c <__aeabi_dsub>
   1bd1c:	4602      	mov	r2, r0
   1bd1e:	460b      	mov	r3, r1
   1bd20:	4650      	mov	r0, sl
   1bd22:	4659      	mov	r1, fp
   1bd24:	f7f8 ff60 	bl	14be8 <__aeabi_ddiv>
   1bd28:	4642      	mov	r2, r8
   1bd2a:	464b      	mov	r3, r9
   1bd2c:	4606      	mov	r6, r0
   1bd2e:	460f      	mov	r7, r1
   1bd30:	4620      	mov	r0, r4
   1bd32:	4629      	mov	r1, r5
   1bd34:	f7f8 fe2e 	bl	14994 <__aeabi_dmul>
   1bd38:	4642      	mov	r2, r8
   1bd3a:	464b      	mov	r3, r9
   1bd3c:	f7f8 fc78 	bl	14630 <__adddf3>
   1bd40:	4602      	mov	r2, r0
   1bd42:	460b      	mov	r3, r1
   1bd44:	4630      	mov	r0, r6
   1bd46:	4639      	mov	r1, r7
   1bd48:	f7f8 fc70 	bl	1462c <__aeabi_dsub>
   1bd4c:	462b      	mov	r3, r5
   1bd4e:	4622      	mov	r2, r4
   1bd50:	f7f8 fc6c 	bl	1462c <__aeabi_dsub>
   1bd54:	460b      	mov	r3, r1
   1bd56:	f240 0100 	movw	r1, #0
   1bd5a:	4602      	mov	r2, r0
   1bd5c:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
   1bd60:	2000      	movs	r0, #0
   1bd62:	f7f8 fc63 	bl	1462c <__aeabi_dsub>
   1bd66:	f8dd e018 	ldr.w	lr, [sp, #24]
   1bd6a:	f8dd c000 	ldr.w	ip, [sp]
   1bd6e:	eb0e 0301 	add.w	r3, lr, r1
   1bd72:	460d      	mov	r5, r1
   1bd74:	151a      	asrs	r2, r3, #20
   1bd76:	2a00      	cmp	r2, #0
   1bd78:	bfc2      	ittt	gt
   1bd7a:	461d      	movgt	r5, r3
   1bd7c:	4602      	movgt	r2, r0
   1bd7e:	462b      	movgt	r3, r5
   1bd80:	f340 8138 	ble.w	1bff4 <__ieee754_pow+0xa84>
   1bd84:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   1bd88:	f7f8 fe04 	bl	14994 <__aeabi_dmul>
   1bd8c:	4605      	mov	r5, r0
   1bd8e:	460c      	mov	r4, r1
   1bd90:	e416      	b.n	1b5c0 <__ieee754_pow+0x50>
   1bd92:	f44f 2800 	mov.w	r8, #524288	; 0x80000
   1bd96:	2600      	movs	r6, #0
   1bd98:	e547      	b.n	1b82a <__ieee754_pow+0x2ba>
   1bd9a:	9b02      	ldr	r3, [sp, #8]
   1bd9c:	2b00      	cmp	r3, #0
   1bd9e:	f6ff ac49 	blt.w	1b634 <__ieee754_pow+0xc4>
   1bda2:	4640      	mov	r0, r8
   1bda4:	4651      	mov	r1, sl
   1bda6:	b011      	add	sp, #68	; 0x44
   1bda8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1bdac:	f000 b990 	b.w	1c0d0 <__ieee754_sqrt>
   1bdb0:	2f00      	cmp	r7, #0
   1bdb2:	f6bf aca8 	bge.w	1b706 <__ieee754_pow+0x196>
   1bdb6:	e477      	b.n	1b6a8 <__ieee754_pow+0x138>
   1bdb8:	f64c 33ff 	movw	r3, #52223	; 0xcbff
   1bdbc:	f021 4700 	bic.w	r7, r1, #2147483648	; 0x80000000
   1bdc0:	f2c4 0390 	movt	r3, #16528	; 0x4090
   1bdc4:	429f      	cmp	r7, r3
   1bdc6:	f77f af0c 	ble.w	1bbe2 <__ieee754_pow+0x672>
   1bdca:	f243 4300 	movw	r3, #13312	; 0x3400
   1bdce:	f6c3 736f 	movt	r3, #16239	; 0x3f6f
   1bdd2:	18cb      	adds	r3, r1, r3
   1bdd4:	4303      	orrs	r3, r0
   1bdd6:	f040 80f7 	bne.w	1bfc8 <__ieee754_pow+0xa58>
   1bdda:	4622      	mov	r2, r4
   1bddc:	462b      	mov	r3, r5
   1bdde:	f7f8 fc25 	bl	1462c <__aeabi_dsub>
   1bde2:	4652      	mov	r2, sl
   1bde4:	465b      	mov	r3, fp
   1bde6:	f7fe fe65 	bl	1aab4 <__aeabi_dcmpge>
   1bdea:	2800      	cmp	r0, #0
   1bdec:	f040 80ec 	bne.w	1bfc8 <__ieee754_pow+0xa58>
   1bdf0:	153b      	asrs	r3, r7, #20
   1bdf2:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
   1bdf6:	f5a3 737e 	sub.w	r3, r3, #1016	; 0x3f8
   1bdfa:	f64f 70ff 	movw	r0, #65535	; 0xffff
   1bdfe:	3b06      	subs	r3, #6
   1be00:	f2c0 000f 	movt	r0, #15
   1be04:	fa52 f303 	asrs.w	r3, r2, r3
   1be08:	f04f 0800 	mov.w	r8, #0
   1be0c:	1999      	adds	r1, r3, r6
   1be0e:	f3c1 530a 	ubfx	r3, r1, #20, #11
   1be12:	f021 4c7f 	bic.w	ip, r1, #4278190080	; 0xff000000
   1be16:	f5a3 737e 	sub.w	r3, r3, #1016	; 0x3f8
   1be1a:	f42c 0c70 	bic.w	ip, ip, #15728640	; 0xf00000
   1be1e:	3b07      	subs	r3, #7
   1be20:	ea4c 0c02 	orr.w	ip, ip, r2
   1be24:	4118      	asrs	r0, r3
   1be26:	f1c3 0314 	rsb	r3, r3, #20
   1be2a:	fa4c fc03 	asr.w	ip, ip, r3
   1be2e:	2e00      	cmp	r6, #0
   1be30:	bfb8      	it	lt
   1be32:	f1cc 0c00 	rsblt	ip, ip, #0
   1be36:	ea21 0900 	bic.w	r9, r1, r0
   1be3a:	4642      	mov	r2, r8
   1be3c:	4620      	mov	r0, r4
   1be3e:	4629      	mov	r1, r5
   1be40:	464b      	mov	r3, r9
   1be42:	ea4f 5e0c 	mov.w	lr, ip, lsl #20
   1be46:	f8cd c000 	str.w	ip, [sp]
   1be4a:	f8cd e018 	str.w	lr, [sp, #24]
   1be4e:	f7f8 fbed 	bl	1462c <__aeabi_dsub>
   1be52:	f8dd c000 	ldr.w	ip, [sp]
   1be56:	4604      	mov	r4, r0
   1be58:	460d      	mov	r5, r1
   1be5a:	e6cc      	b.n	1bbf6 <__ieee754_pow+0x686>
   1be5c:	f240 0300 	movw	r3, #0
   1be60:	2200      	movs	r2, #0
   1be62:	f6cb 73f0 	movt	r3, #49136	; 0xbff0
   1be66:	e9cd 2302 	strd	r2, r3, [sp, #8]
   1be6a:	e663      	b.n	1bb34 <__ieee754_pow+0x5c4>
   1be6c:	2f00      	cmp	r7, #0
   1be6e:	f6bf ac4a 	bge.w	1b706 <__ieee754_pow+0x196>
   1be72:	f104 4400 	add.w	r4, r4, #2147483648	; 0x80000000
   1be76:	f7ff bba3 	b.w	1b5c0 <__ieee754_pow+0x50>
   1be7a:	f64f 73fe 	movw	r3, #65534	; 0xfffe
   1be7e:	f6c3 73ef 	movt	r3, #16367	; 0x3fef
   1be82:	459c      	cmp	ip, r3
   1be84:	dd94      	ble.n	1bdb0 <__ieee754_pow+0x840>
   1be86:	f240 0300 	movw	r3, #0
   1be8a:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
   1be8e:	459c      	cmp	ip, r3
   1be90:	f73f ac08 	bgt.w	1b6a4 <__ieee754_pow+0x134>
   1be94:	9f04      	ldr	r7, [sp, #16]
   1be96:	f240 0300 	movw	r3, #0
   1be9a:	2200      	movs	r2, #0
   1be9c:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
   1bea0:	4639      	mov	r1, r7
   1bea2:	f7f8 fbc3 	bl	1462c <__aeabi_dsub>
   1bea6:	a380      	add	r3, pc, #512	; (adr r3, 1c0a8 <__ieee754_pow+0xb38>)
   1bea8:	e9d3 2300 	ldrd	r2, r3, [r3]
   1beac:	4606      	mov	r6, r0
   1beae:	460f      	mov	r7, r1
   1beb0:	f7f8 fd70 	bl	14994 <__aeabi_dmul>
   1beb4:	a37e      	add	r3, pc, #504	; (adr r3, 1c0b0 <__ieee754_pow+0xb40>)
   1beb6:	e9d3 2300 	ldrd	r2, r3, [r3]
   1beba:	4682      	mov	sl, r0
   1bebc:	468b      	mov	fp, r1
   1bebe:	4630      	mov	r0, r6
   1bec0:	4639      	mov	r1, r7
   1bec2:	f7f8 fd67 	bl	14994 <__aeabi_dmul>
   1bec6:	4632      	mov	r2, r6
   1bec8:	463b      	mov	r3, r7
   1beca:	e9cd 0102 	strd	r0, r1, [sp, #8]
   1bece:	4630      	mov	r0, r6
   1bed0:	4639      	mov	r1, r7
   1bed2:	f7f8 fd5f 	bl	14994 <__aeabi_dmul>
   1bed6:	f240 0300 	movw	r3, #0
   1beda:	2200      	movs	r2, #0
   1bedc:	f6cb 73d0 	movt	r3, #49104	; 0xbfd0
   1bee0:	e9cd 0104 	strd	r0, r1, [sp, #16]
   1bee4:	4630      	mov	r0, r6
   1bee6:	4639      	mov	r1, r7
   1bee8:	f7f8 fd54 	bl	14994 <__aeabi_dmul>
   1beec:	a372      	add	r3, pc, #456	; (adr r3, 1c0b8 <__ieee754_pow+0xb48>)
   1beee:	e9d3 2300 	ldrd	r2, r3, [r3]
   1bef2:	f7f8 fb9d 	bl	14630 <__adddf3>
   1bef6:	4632      	mov	r2, r6
   1bef8:	463b      	mov	r3, r7
   1befa:	2600      	movs	r6, #0
   1befc:	f7f8 fd4a 	bl	14994 <__aeabi_dmul>
   1bf00:	460b      	mov	r3, r1
   1bf02:	f240 0100 	movw	r1, #0
   1bf06:	4602      	mov	r2, r0
   1bf08:	f6c3 71e0 	movt	r1, #16352	; 0x3fe0
   1bf0c:	2000      	movs	r0, #0
   1bf0e:	f7f8 fb8d 	bl	1462c <__aeabi_dsub>
   1bf12:	4602      	mov	r2, r0
   1bf14:	460b      	mov	r3, r1
   1bf16:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   1bf1a:	f7f8 fd3b 	bl	14994 <__aeabi_dmul>
   1bf1e:	a368      	add	r3, pc, #416	; (adr r3, 1c0c0 <__ieee754_pow+0xb50>)
   1bf20:	e9d3 2300 	ldrd	r2, r3, [r3]
   1bf24:	f7f8 fd36 	bl	14994 <__aeabi_dmul>
   1bf28:	4602      	mov	r2, r0
   1bf2a:	460b      	mov	r3, r1
   1bf2c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   1bf30:	f7f8 fb7e 	bl	14630 <__adddf3>
   1bf34:	e9cd 0102 	strd	r0, r1, [sp, #8]
   1bf38:	4650      	mov	r0, sl
   1bf3a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   1bf3e:	4659      	mov	r1, fp
   1bf40:	f7f8 fb76 	bl	14630 <__adddf3>
   1bf44:	4652      	mov	r2, sl
   1bf46:	465b      	mov	r3, fp
   1bf48:	4630      	mov	r0, r6
   1bf4a:	460f      	mov	r7, r1
   1bf4c:	f7f8 fb6e 	bl	1462c <__aeabi_dsub>
   1bf50:	4602      	mov	r2, r0
   1bf52:	460b      	mov	r3, r1
   1bf54:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   1bf58:	f7f8 fb68 	bl	1462c <__aeabi_dsub>
   1bf5c:	e9cd 0104 	strd	r0, r1, [sp, #16]
   1bf60:	e5d9      	b.n	1bb16 <__ieee754_pow+0x5a6>
   1bf62:	f240 0100 	movw	r1, #0
   1bf66:	4602      	mov	r2, r0
   1bf68:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
   1bf6c:	2000      	movs	r0, #0
   1bf6e:	9b04      	ldr	r3, [sp, #16]
   1bf70:	f8cd c000 	str.w	ip, [sp]
   1bf74:	f7f8 fe38 	bl	14be8 <__aeabi_ddiv>
   1bf78:	f8dd c000 	ldr.w	ip, [sp]
   1bf7c:	4605      	mov	r5, r0
   1bf7e:	460c      	mov	r4, r1
   1bf80:	f7ff bbc9 	b.w	1b716 <__ieee754_pow+0x1a6>
   1bf84:	a322      	add	r3, pc, #136	; (adr r3, 1c010 <__ieee754_pow+0xaa0>)
   1bf86:	e9d3 2300 	ldrd	r2, r3, [r3]
   1bf8a:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   1bf8e:	f7f8 fd01 	bl	14994 <__aeabi_dmul>
   1bf92:	a31f      	add	r3, pc, #124	; (adr r3, 1c010 <__ieee754_pow+0xaa0>)
   1bf94:	e9d3 2300 	ldrd	r2, r3, [r3]
   1bf98:	f7f8 fcfc 	bl	14994 <__aeabi_dmul>
   1bf9c:	4605      	mov	r5, r0
   1bf9e:	460c      	mov	r4, r1
   1bfa0:	f7ff bb0e 	b.w	1b5c0 <__ieee754_pow+0x50>
   1bfa4:	bb00      	cbnz	r0, 1bfe8 <__ieee754_pow+0xa78>
   1bfa6:	f1c3 0314 	rsb	r3, r3, #20
   1bfaa:	fa56 f003 	asrs.w	r0, r6, r3
   1bfae:	fa10 f303 	lsls.w	r3, r0, r3
   1bfb2:	42b3      	cmp	r3, r6
   1bfb4:	d024      	beq.n	1c000 <__ieee754_pow+0xa90>
   1bfb6:	2100      	movs	r1, #0
   1bfb8:	9106      	str	r1, [sp, #24]
   1bfba:	f7ff bb24 	b.w	1b606 <__ieee754_pow+0x96>
   1bfbe:	9b06      	ldr	r3, [sp, #24]
   1bfc0:	2b01      	cmp	r3, #1
   1bfc2:	f47f aafd 	bne.w	1b5c0 <__ieee754_pow+0x50>
   1bfc6:	e754      	b.n	1be72 <__ieee754_pow+0x902>
   1bfc8:	a33f      	add	r3, pc, #252	; (adr r3, 1c0c8 <__ieee754_pow+0xb58>)
   1bfca:	e9d3 2300 	ldrd	r2, r3, [r3]
   1bfce:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   1bfd2:	f7f8 fcdf 	bl	14994 <__aeabi_dmul>
   1bfd6:	a33c      	add	r3, pc, #240	; (adr r3, 1c0c8 <__ieee754_pow+0xb58>)
   1bfd8:	e9d3 2300 	ldrd	r2, r3, [r3]
   1bfdc:	f7f8 fcda 	bl	14994 <__aeabi_dmul>
   1bfe0:	4605      	mov	r5, r0
   1bfe2:	460c      	mov	r4, r1
   1bfe4:	f7ff baec 	b.w	1b5c0 <__ieee754_pow+0x50>
   1bfe8:	f04f 0e00 	mov.w	lr, #0
   1bfec:	f8cd e018 	str.w	lr, [sp, #24]
   1bff0:	f7ff bb20 	b.w	1b634 <__ieee754_pow+0xc4>
   1bff4:	4662      	mov	r2, ip
   1bff6:	f000 fa07 	bl	1c408 <scalbn>
   1bffa:	4602      	mov	r2, r0
   1bffc:	460b      	mov	r3, r1
   1bffe:	e6c1      	b.n	1bd84 <__ieee754_pow+0x814>
   1c000:	f000 0301 	and.w	r3, r0, #1
   1c004:	f1c3 0302 	rsb	r3, r3, #2
   1c008:	9306      	str	r3, [sp, #24]
   1c00a:	f7ff bafc 	b.w	1b606 <__ieee754_pow+0x96>
   1c00e:	bf00      	nop
   1c010:	8800759c 	.word	0x8800759c
   1c014:	7e37e43c 	.word	0x7e37e43c
   1c018:	4a454eef 	.word	0x4a454eef
   1c01c:	3fca7e28 	.word	0x3fca7e28
   1c020:	93c9db65 	.word	0x93c9db65
   1c024:	3fcd864a 	.word	0x3fcd864a
   1c028:	a91d4101 	.word	0xa91d4101
   1c02c:	3fd17460 	.word	0x3fd17460
   1c030:	518f264d 	.word	0x518f264d
   1c034:	3fd55555 	.word	0x3fd55555
   1c038:	db6fabff 	.word	0xdb6fabff
   1c03c:	3fdb6db6 	.word	0x3fdb6db6
   1c040:	33333303 	.word	0x33333303
   1c044:	3fe33333 	.word	0x3fe33333
   1c048:	e0000000 	.word	0xe0000000
   1c04c:	3feec709 	.word	0x3feec709
   1c050:	145b01f5 	.word	0x145b01f5
   1c054:	be3e2fe0 	.word	0xbe3e2fe0
   1c058:	dc3a03fd 	.word	0xdc3a03fd
   1c05c:	3feec709 	.word	0x3feec709
   1c060:	652b82fe 	.word	0x652b82fe
   1c064:	3c971547 	.word	0x3c971547
   1c068:	00000000 	.word	0x00000000
   1c06c:	3fe62e43 	.word	0x3fe62e43
   1c070:	fefa39ef 	.word	0xfefa39ef
   1c074:	3fe62e42 	.word	0x3fe62e42
   1c078:	0ca86c39 	.word	0x0ca86c39
   1c07c:	be205c61 	.word	0xbe205c61
   1c080:	72bea4d0 	.word	0x72bea4d0
   1c084:	3e663769 	.word	0x3e663769
   1c088:	c5d26bf1 	.word	0xc5d26bf1
   1c08c:	3ebbbd41 	.word	0x3ebbbd41
   1c090:	af25de2c 	.word	0xaf25de2c
   1c094:	3f11566a 	.word	0x3f11566a
   1c098:	16bebd93 	.word	0x16bebd93
   1c09c:	3f66c16c 	.word	0x3f66c16c
   1c0a0:	5555553e 	.word	0x5555553e
   1c0a4:	3fc55555 	.word	0x3fc55555
   1c0a8:	60000000 	.word	0x60000000
   1c0ac:	3ff71547 	.word	0x3ff71547
   1c0b0:	f85ddf44 	.word	0xf85ddf44
   1c0b4:	3e54ae0b 	.word	0x3e54ae0b
   1c0b8:	55555555 	.word	0x55555555
   1c0bc:	3fd55555 	.word	0x3fd55555
   1c0c0:	652b82fe 	.word	0x652b82fe
   1c0c4:	bff71547 	.word	0xbff71547
   1c0c8:	c2f8f359 	.word	0xc2f8f359
   1c0cc:	01a56e1f 	.word	0x01a56e1f

0001c0d0 <__ieee754_sqrt>:
   1c0d0:	f240 0c00 	movw	ip, #0
   1c0d4:	460b      	mov	r3, r1
   1c0d6:	f6c7 7cf0 	movt	ip, #32752	; 0x7ff0
   1c0da:	4602      	mov	r2, r0
   1c0dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1c0e0:	4666      	mov	r6, ip
   1c0e2:	ea01 0c0c 	and.w	ip, r1, ip
   1c0e6:	4604      	mov	r4, r0
   1c0e8:	45b4      	cmp	ip, r6
   1c0ea:	460d      	mov	r5, r1
   1c0ec:	4680      	mov	r8, r0
   1c0ee:	4689      	mov	r9, r1
   1c0f0:	f000 80be 	beq.w	1c270 <__ieee754_sqrt+0x1a0>
   1c0f4:	2900      	cmp	r1, #0
   1c0f6:	f340 808c 	ble.w	1c212 <__ieee754_sqrt+0x142>
   1c0fa:	ea5f 5821 	movs.w	r8, r1, asr #20
   1c0fe:	f000 8096 	beq.w	1c22e <__ieee754_sqrt+0x15e>
   1c102:	f5a8 787e 	sub.w	r8, r8, #1016	; 0x3f8
   1c106:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
   1c10a:	f1a8 0807 	sub.w	r8, r8, #7
   1c10e:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
   1c112:	f018 0f01 	tst.w	r8, #1
   1c116:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   1c11a:	d16a      	bne.n	1c1f2 <__ieee754_sqrt+0x122>
   1c11c:	0fd1      	lsrs	r1, r2, #31
   1c11e:	f04f 0c00 	mov.w	ip, #0
   1c122:	eb01 0343 	add.w	r3, r1, r3, lsl #1
   1c126:	0052      	lsls	r2, r2, #1
   1c128:	4665      	mov	r5, ip
   1c12a:	4660      	mov	r0, ip
   1c12c:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
   1c130:	1844      	adds	r4, r0, r1
   1c132:	0fd6      	lsrs	r6, r2, #31
   1c134:	0052      	lsls	r2, r2, #1
   1c136:	429c      	cmp	r4, r3
   1c138:	f10c 0c01 	add.w	ip, ip, #1
   1c13c:	dc02      	bgt.n	1c144 <__ieee754_sqrt+0x74>
   1c13e:	1b1b      	subs	r3, r3, r4
   1c140:	186d      	adds	r5, r5, r1
   1c142:	1860      	adds	r0, r4, r1
   1c144:	0849      	lsrs	r1, r1, #1
   1c146:	f1bc 0f16 	cmp.w	ip, #22
   1c14a:	eb06 0343 	add.w	r3, r6, r3, lsl #1
   1c14e:	d1ef      	bne.n	1c130 <__ieee754_sqrt+0x60>
   1c150:	2400      	movs	r4, #0
   1c152:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
   1c156:	46a2      	mov	sl, r4
   1c158:	4626      	mov	r6, r4
   1c15a:	e013      	b.n	1c184 <__ieee754_sqrt+0xb4>
   1c15c:	4283      	cmp	r3, r0
   1c15e:	bf14      	ite	ne
   1c160:	2700      	movne	r7, #0
   1c162:	2701      	moveq	r7, #1
   1c164:	4594      	cmp	ip, r2
   1c166:	bf8c      	ite	hi
   1c168:	2700      	movhi	r7, #0
   1c16a:	f007 0701 	andls.w	r7, r7, #1
   1c16e:	b96f      	cbnz	r7, 1c18c <__ieee754_sqrt+0xbc>
   1c170:	3401      	adds	r4, #1
   1c172:	4607      	mov	r7, r0
   1c174:	0849      	lsrs	r1, r1, #1
   1c176:	0fd0      	lsrs	r0, r2, #31
   1c178:	0052      	lsls	r2, r2, #1
   1c17a:	2c20      	cmp	r4, #32
   1c17c:	eb00 0343 	add.w	r3, r0, r3, lsl #1
   1c180:	d01b      	beq.n	1c1ba <__ieee754_sqrt+0xea>
   1c182:	4638      	mov	r0, r7
   1c184:	4298      	cmp	r0, r3
   1c186:	eb01 0c06 	add.w	ip, r1, r6
   1c18a:	dae7      	bge.n	1c15c <__ieee754_sqrt+0x8c>
   1c18c:	f00c 4700 	and.w	r7, ip, #2147483648	; 0x80000000
   1c190:	eb0c 0601 	add.w	r6, ip, r1
   1c194:	f1b7 4f00 	cmp.w	r7, #2147483648	; 0x80000000
   1c198:	d027      	beq.n	1c1ea <__ieee754_sqrt+0x11a>
   1c19a:	4607      	mov	r7, r0
   1c19c:	1a1b      	subs	r3, r3, r0
   1c19e:	4594      	cmp	ip, r2
   1c1a0:	ebcc 0202 	rsb	r2, ip, r2
   1c1a4:	bf88      	it	hi
   1c1a6:	3b01      	subhi	r3, #1
   1c1a8:	3401      	adds	r4, #1
   1c1aa:	448a      	add	sl, r1
   1c1ac:	0fd0      	lsrs	r0, r2, #31
   1c1ae:	0849      	lsrs	r1, r1, #1
   1c1b0:	0052      	lsls	r2, r2, #1
   1c1b2:	2c20      	cmp	r4, #32
   1c1b4:	eb00 0343 	add.w	r3, r0, r3, lsl #1
   1c1b8:	d1e3      	bne.n	1c182 <__ieee754_sqrt+0xb2>
   1c1ba:	4313      	orrs	r3, r2
   1c1bc:	d11e      	bne.n	1c1fc <__ieee754_sqrt+0x12c>
   1c1be:	ea4f 0a5a 	mov.w	sl, sl, lsr #1
   1c1c2:	ea4f 0168 	mov.w	r1, r8, asr #1
   1c1c6:	f015 0f01 	tst.w	r5, #1
   1c1ca:	bf18      	it	ne
   1c1cc:	f04a 4a00 	orrne.w	sl, sl, #2147483648	; 0x80000000
   1c1d0:	0509      	lsls	r1, r1, #20
   1c1d2:	4654      	mov	r4, sl
   1c1d4:	f101 517e 	add.w	r1, r1, #1065353216	; 0x3f800000
   1c1d8:	f501 01c0 	add.w	r1, r1, #6291456	; 0x600000
   1c1dc:	eb01 0365 	add.w	r3, r1, r5, asr #1
   1c1e0:	461d      	mov	r5, r3
   1c1e2:	4620      	mov	r0, r4
   1c1e4:	4629      	mov	r1, r5
   1c1e6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1c1ea:	2e00      	cmp	r6, #0
   1c1ec:	dbd5      	blt.n	1c19a <__ieee754_sqrt+0xca>
   1c1ee:	1c47      	adds	r7, r0, #1
   1c1f0:	e7d4      	b.n	1c19c <__ieee754_sqrt+0xcc>
   1c1f2:	0fd1      	lsrs	r1, r2, #31
   1c1f4:	0052      	lsls	r2, r2, #1
   1c1f6:	eb01 0343 	add.w	r3, r1, r3, lsl #1
   1c1fa:	e78f      	b.n	1c11c <__ieee754_sqrt+0x4c>
   1c1fc:	f1ba 3fff 	cmp.w	sl, #4294967295
   1c200:	bf1c      	itt	ne
   1c202:	f00a 0301 	andne.w	r3, sl, #1
   1c206:	449a      	addne	sl, r3
   1c208:	d1d9      	bne.n	1c1be <__ieee754_sqrt+0xee>
   1c20a:	3501      	adds	r5, #1
   1c20c:	f04f 0a00 	mov.w	sl, #0
   1c210:	e7d7      	b.n	1c1c2 <__ieee754_sqrt+0xf2>
   1c212:	f021 4c00 	bic.w	ip, r1, #2147483648	; 0x80000000
   1c216:	ea5c 0c00 	orrs.w	ip, ip, r0
   1c21a:	d0e2      	beq.n	1c1e2 <__ieee754_sqrt+0x112>
   1c21c:	2900      	cmp	r1, #0
   1c21e:	d13a      	bne.n	1c296 <__ieee754_sqrt+0x1c6>
   1c220:	4688      	mov	r8, r1
   1c222:	0ad3      	lsrs	r3, r2, #11
   1c224:	f1a8 0815 	sub.w	r8, r8, #21
   1c228:	0552      	lsls	r2, r2, #21
   1c22a:	2b00      	cmp	r3, #0
   1c22c:	d0f9      	beq.n	1c222 <__ieee754_sqrt+0x152>
   1c22e:	f413 1180 	ands.w	r1, r3, #1048576	; 0x100000
   1c232:	d12d      	bne.n	1c290 <__ieee754_sqrt+0x1c0>
   1c234:	005b      	lsls	r3, r3, #1
   1c236:	3101      	adds	r1, #1
   1c238:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
   1c23c:	d0fa      	beq.n	1c234 <__ieee754_sqrt+0x164>
   1c23e:	f1c1 0020 	rsb	r0, r1, #32
   1c242:	f108 0801 	add.w	r8, r8, #1
   1c246:	fa32 f000 	lsrs.w	r0, r2, r0
   1c24a:	ebc1 0808 	rsb	r8, r1, r8
   1c24e:	4303      	orrs	r3, r0
   1c250:	f5a8 787e 	sub.w	r8, r8, #1016	; 0x3f8
   1c254:	408a      	lsls	r2, r1
   1c256:	f1a8 0807 	sub.w	r8, r8, #7
   1c25a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
   1c25e:	f018 0f01 	tst.w	r8, #1
   1c262:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
   1c266:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   1c26a:	f43f af57 	beq.w	1c11c <__ieee754_sqrt+0x4c>
   1c26e:	e7c0      	b.n	1c1f2 <__ieee754_sqrt+0x122>
   1c270:	4602      	mov	r2, r0
   1c272:	460b      	mov	r3, r1
   1c274:	f7f8 fb8e 	bl	14994 <__aeabi_dmul>
   1c278:	4602      	mov	r2, r0
   1c27a:	460b      	mov	r3, r1
   1c27c:	4620      	mov	r0, r4
   1c27e:	4629      	mov	r1, r5
   1c280:	f7f8 f9d6 	bl	14630 <__adddf3>
   1c284:	4604      	mov	r4, r0
   1c286:	460d      	mov	r5, r1
   1c288:	4620      	mov	r0, r4
   1c28a:	4629      	mov	r1, r5
   1c28c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1c290:	2020      	movs	r0, #32
   1c292:	2100      	movs	r1, #0
   1c294:	e7d5      	b.n	1c242 <__ieee754_sqrt+0x172>
   1c296:	4602      	mov	r2, r0
   1c298:	460b      	mov	r3, r1
   1c29a:	f7f8 f9c7 	bl	1462c <__aeabi_dsub>
   1c29e:	4602      	mov	r2, r0
   1c2a0:	460b      	mov	r3, r1
   1c2a2:	f7f8 fca1 	bl	14be8 <__aeabi_ddiv>
   1c2a6:	4604      	mov	r4, r0
   1c2a8:	460d      	mov	r5, r1
   1c2aa:	e79a      	b.n	1c1e2 <__ieee754_sqrt+0x112>

0001c2ac <fabs>:
   1c2ac:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   1c2b0:	4619      	mov	r1, r3
   1c2b2:	4770      	bx	lr

0001c2b4 <finite>:
   1c2b4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   1c2b8:	f101 4000 	add.w	r0, r1, #2147483648	; 0x80000000
   1c2bc:	f500 1080 	add.w	r0, r0, #1048576	; 0x100000
   1c2c0:	0fc0      	lsrs	r0, r0, #31
   1c2c2:	4770      	bx	lr

0001c2c4 <matherr>:
   1c2c4:	2000      	movs	r0, #0
   1c2c6:	4770      	bx	lr

0001c2c8 <nan>:
   1c2c8:	f240 0100 	movw	r1, #0
   1c2cc:	2000      	movs	r0, #0
   1c2ce:	f6c7 71f8 	movt	r1, #32760	; 0x7ff8
   1c2d2:	4770      	bx	lr

0001c2d4 <rint>:
   1c2d4:	f3c1 530a 	ubfx	r3, r1, #20, #11
   1c2d8:	4684      	mov	ip, r0
   1c2da:	f5a3 737e 	sub.w	r3, r3, #1016	; 0x3f8
   1c2de:	3b07      	subs	r3, #7
   1c2e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1c2e4:	0fcc      	lsrs	r4, r1, #31
   1c2e6:	2b13      	cmp	r3, #19
   1c2e8:	b083      	sub	sp, #12
   1c2ea:	4606      	mov	r6, r0
   1c2ec:	460f      	mov	r7, r1
   1c2ee:	460d      	mov	r5, r1
   1c2f0:	dc39      	bgt.n	1c366 <rint+0x92>
   1c2f2:	2b00      	cmp	r3, #0
   1c2f4:	db55      	blt.n	1c3a2 <rint+0xce>
   1c2f6:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1c2fa:	f2c0 020f 	movt	r2, #15
   1c2fe:	411a      	asrs	r2, r3
   1c300:	ea02 0101 	and.w	r1, r2, r1
   1c304:	4301      	orrs	r1, r0
   1c306:	d029      	beq.n	1c35c <rint+0x88>
   1c308:	0852      	lsrs	r2, r2, #1
   1c30a:	ea02 0107 	and.w	r1, r2, r7
   1c30e:	4301      	orrs	r1, r0
   1c310:	bf08      	it	eq
   1c312:	468c      	moveq	ip, r1
   1c314:	d00b      	beq.n	1c32e <rint+0x5a>
   1c316:	2b13      	cmp	r3, #19
   1c318:	bf08      	it	eq
   1c31a:	f04f 4c80 	moveq.w	ip, #1073741824	; 0x40000000
   1c31e:	d006      	beq.n	1c32e <rint+0x5a>
   1c320:	ea27 0502 	bic.w	r5, r7, r2
   1c324:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   1c328:	fa52 f303 	asrs.w	r3, r2, r3
   1c32c:	431d      	orrs	r5, r3
   1c32e:	f64f 3168 	movw	r1, #64360	; 0xfb68
   1c332:	462b      	mov	r3, r5
   1c334:	f2c0 0102 	movt	r1, #2
   1c338:	4662      	mov	r2, ip
   1c33a:	eb01 04c4 	add.w	r4, r1, r4, lsl #3
   1c33e:	cc30      	ldmia	r4!, {r4, r5}
   1c340:	4620      	mov	r0, r4
   1c342:	4629      	mov	r1, r5
   1c344:	f7f8 f974 	bl	14630 <__adddf3>
   1c348:	4622      	mov	r2, r4
   1c34a:	462b      	mov	r3, r5
   1c34c:	e9cd 0100 	strd	r0, r1, [sp]
   1c350:	e9dd 0100 	ldrd	r0, r1, [sp]
   1c354:	f7f8 f96a 	bl	1462c <__aeabi_dsub>
   1c358:	4606      	mov	r6, r0
   1c35a:	460f      	mov	r7, r1
   1c35c:	4630      	mov	r0, r6
   1c35e:	4639      	mov	r1, r7
   1c360:	b003      	add	sp, #12
   1c362:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1c366:	2b33      	cmp	r3, #51	; 0x33
   1c368:	dd09      	ble.n	1c37e <rint+0xaa>
   1c36a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
   1c36e:	d1f5      	bne.n	1c35c <rint+0x88>
   1c370:	4602      	mov	r2, r0
   1c372:	460b      	mov	r3, r1
   1c374:	f7f8 f95c 	bl	14630 <__adddf3>
   1c378:	4606      	mov	r6, r0
   1c37a:	460f      	mov	r7, r1
   1c37c:	e7ee      	b.n	1c35c <rint+0x88>
   1c37e:	f04f 32ff 	mov.w	r2, #4294967295
   1c382:	3b14      	subs	r3, #20
   1c384:	40da      	lsrs	r2, r3
   1c386:	4202      	tst	r2, r0
   1c388:	d0e8      	beq.n	1c35c <rint+0x88>
   1c38a:	0852      	lsrs	r2, r2, #1
   1c38c:	4202      	tst	r2, r0
   1c38e:	d0ce      	beq.n	1c32e <rint+0x5a>
   1c390:	ea20 0c02 	bic.w	ip, r0, r2
   1c394:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   1c398:	fa52 f303 	asrs.w	r3, r2, r3
   1c39c:	ea4c 0c03 	orr.w	ip, ip, r3
   1c3a0:	e7c5      	b.n	1c32e <rint+0x5a>
   1c3a2:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   1c3a6:	4303      	orrs	r3, r0
   1c3a8:	d0d8      	beq.n	1c35c <rint+0x88>
   1c3aa:	f021 437f 	bic.w	r3, r1, #4278190080	; 0xff000000
   1c3ae:	f64f 3168 	movw	r1, #64360	; 0xfb68
   1c3b2:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
   1c3b6:	f2c0 0102 	movt	r1, #2
   1c3ba:	ea43 0c00 	orr.w	ip, r3, r0
   1c3be:	eb01 01c4 	add.w	r1, r1, r4, lsl #3
   1c3c2:	f1cc 0200 	rsb	r2, ip, #0
   1c3c6:	0c7b      	lsrs	r3, r7, #17
   1c3c8:	ea42 0c0c 	orr.w	ip, r2, ip
   1c3cc:	e9d1 6700 	ldrd	r6, r7, [r1]
   1c3d0:	045b      	lsls	r3, r3, #17
   1c3d2:	4680      	mov	r8, r0
   1c3d4:	ea4f 321c 	mov.w	r2, ip, lsr #12
   1c3d8:	4630      	mov	r0, r6
   1c3da:	f402 2200 	and.w	r2, r2, #524288	; 0x80000
   1c3de:	4639      	mov	r1, r7
   1c3e0:	ea42 0903 	orr.w	r9, r2, r3
   1c3e4:	4642      	mov	r2, r8
   1c3e6:	464b      	mov	r3, r9
   1c3e8:	f7f8 f922 	bl	14630 <__adddf3>
   1c3ec:	463b      	mov	r3, r7
   1c3ee:	4632      	mov	r2, r6
   1c3f0:	e9cd 0100 	strd	r0, r1, [sp]
   1c3f4:	e9dd 0100 	ldrd	r0, r1, [sp]
   1c3f8:	f7f8 f918 	bl	1462c <__aeabi_dsub>
   1c3fc:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   1c400:	4606      	mov	r6, r0
   1c402:	ea43 77c4 	orr.w	r7, r3, r4, lsl #31
   1c406:	e7a9      	b.n	1c35c <rint+0x88>

0001c408 <scalbn>:
   1c408:	f3c1 530a 	ubfx	r3, r1, #20, #11
   1c40c:	e92d 43d0 	stmdb	sp!, {r4, r6, r7, r8, r9, lr}
   1c410:	4614      	mov	r4, r2
   1c412:	4606      	mov	r6, r0
   1c414:	460f      	mov	r7, r1
   1c416:	4680      	mov	r8, r0
   1c418:	4689      	mov	r9, r1
   1c41a:	460a      	mov	r2, r1
   1c41c:	2b00      	cmp	r3, #0
   1c41e:	d12f      	bne.n	1c480 <scalbn+0x78>
   1c420:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
   1c424:	4302      	orrs	r2, r0
   1c426:	d027      	beq.n	1c478 <scalbn+0x70>
   1c428:	f240 0300 	movw	r3, #0
   1c42c:	2200      	movs	r2, #0
   1c42e:	f2c4 3350 	movt	r3, #17232	; 0x4350
   1c432:	f7f8 faaf 	bl	14994 <__aeabi_dmul>
   1c436:	f643 43b0 	movw	r3, #15536	; 0x3cb0
   1c43a:	f6cf 73ff 	movt	r3, #65535	; 0xffff
   1c43e:	429c      	cmp	r4, r3
   1c440:	4606      	mov	r6, r0
   1c442:	460f      	mov	r7, r1
   1c444:	4680      	mov	r8, r0
   1c446:	4689      	mov	r9, r1
   1c448:	db3a      	blt.n	1c4c0 <scalbn+0xb8>
   1c44a:	f3c1 530a 	ubfx	r3, r1, #20, #11
   1c44e:	460a      	mov	r2, r1
   1c450:	3b36      	subs	r3, #54	; 0x36
   1c452:	f240 71fe 	movw	r1, #2046	; 0x7fe
   1c456:	191b      	adds	r3, r3, r4
   1c458:	428b      	cmp	r3, r1
   1c45a:	dd1a      	ble.n	1c492 <scalbn+0x8a>
   1c45c:	4632      	mov	r2, r6
   1c45e:	463b      	mov	r3, r7
   1c460:	a12b      	add	r1, pc, #172	; (adr r1, 1c510 <scalbn+0x108>)
   1c462:	e9d1 0100 	ldrd	r0, r1, [r1]
   1c466:	f000 f85b 	bl	1c520 <copysign>
   1c46a:	a329      	add	r3, pc, #164	; (adr r3, 1c510 <scalbn+0x108>)
   1c46c:	e9d3 2300 	ldrd	r2, r3, [r3]
   1c470:	f7f8 fa90 	bl	14994 <__aeabi_dmul>
   1c474:	4606      	mov	r6, r0
   1c476:	460f      	mov	r7, r1
   1c478:	4630      	mov	r0, r6
   1c47a:	4639      	mov	r1, r7
   1c47c:	e8bd 83d0 	ldmia.w	sp!, {r4, r6, r7, r8, r9, pc}
   1c480:	f240 7cff 	movw	ip, #2047	; 0x7ff
   1c484:	4563      	cmp	r3, ip
   1c486:	d026      	beq.n	1c4d6 <scalbn+0xce>
   1c488:	191b      	adds	r3, r3, r4
   1c48a:	f240 71fe 	movw	r1, #2046	; 0x7fe
   1c48e:	428b      	cmp	r3, r1
   1c490:	dce4      	bgt.n	1c45c <scalbn+0x54>
   1c492:	2b00      	cmp	r3, #0
   1c494:	bfc2      	ittt	gt
   1c496:	f022 42fe 	bicgt.w	r2, r2, #2130706432	; 0x7f000000
   1c49a:	f422 0270 	bicgt.w	r2, r2, #15728640	; 0xf00000
   1c49e:	ea42 5703 	orrgt.w	r7, r2, r3, lsl #20
   1c4a2:	dce9      	bgt.n	1c478 <scalbn+0x70>
   1c4a4:	f113 0f35 	cmn.w	r3, #53	; 0x35
   1c4a8:	da1f      	bge.n	1c4ea <scalbn+0xe2>
   1c4aa:	f24c 3350 	movw	r3, #50000	; 0xc350
   1c4ae:	429c      	cmp	r4, r3
   1c4b0:	dcd4      	bgt.n	1c45c <scalbn+0x54>
   1c4b2:	4632      	mov	r2, r6
   1c4b4:	463b      	mov	r3, r7
   1c4b6:	a118      	add	r1, pc, #96	; (adr r1, 1c518 <scalbn+0x110>)
   1c4b8:	e9d1 0100 	ldrd	r0, r1, [r1]
   1c4bc:	f000 f830 	bl	1c520 <copysign>
   1c4c0:	a315      	add	r3, pc, #84	; (adr r3, 1c518 <scalbn+0x110>)
   1c4c2:	e9d3 2300 	ldrd	r2, r3, [r3]
   1c4c6:	f7f8 fa65 	bl	14994 <__aeabi_dmul>
   1c4ca:	4606      	mov	r6, r0
   1c4cc:	460f      	mov	r7, r1
   1c4ce:	4630      	mov	r0, r6
   1c4d0:	4639      	mov	r1, r7
   1c4d2:	e8bd 83d0 	ldmia.w	sp!, {r4, r6, r7, r8, r9, pc}
   1c4d6:	4602      	mov	r2, r0
   1c4d8:	460b      	mov	r3, r1
   1c4da:	f7f8 f8a9 	bl	14630 <__adddf3>
   1c4de:	4606      	mov	r6, r0
   1c4e0:	460f      	mov	r7, r1
   1c4e2:	4630      	mov	r0, r6
   1c4e4:	4639      	mov	r1, r7
   1c4e6:	e8bd 83d0 	ldmia.w	sp!, {r4, r6, r7, r8, r9, pc}
   1c4ea:	3336      	adds	r3, #54	; 0x36
   1c4ec:	f022 42fe 	bic.w	r2, r2, #2130706432	; 0x7f000000
   1c4f0:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
   1c4f4:	4630      	mov	r0, r6
   1c4f6:	ea42 5703 	orr.w	r7, r2, r3, lsl #20
   1c4fa:	f240 0300 	movw	r3, #0
   1c4fe:	4639      	mov	r1, r7
   1c500:	2200      	movs	r2, #0
   1c502:	f6c3 4390 	movt	r3, #15504	; 0x3c90
   1c506:	f7f8 fa45 	bl	14994 <__aeabi_dmul>
   1c50a:	4606      	mov	r6, r0
   1c50c:	460f      	mov	r7, r1
   1c50e:	e7b3      	b.n	1c478 <scalbn+0x70>
   1c510:	8800759c 	.word	0x8800759c
   1c514:	7e37e43c 	.word	0x7e37e43c
   1c518:	c2f8f359 	.word	0xc2f8f359
   1c51c:	01a56e1f 	.word	0x01a56e1f

0001c520 <copysign>:
   1c520:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
   1c524:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
   1c528:	b430      	push	{r4, r5}
   1c52a:	460d      	mov	r5, r1
   1c52c:	4604      	mov	r4, r0
   1c52e:	ea43 0102 	orr.w	r1, r3, r2
   1c532:	bc30      	pop	{r4, r5}
   1c534:	4770      	bx	lr
   1c536:	bf00      	nop
   1c538:	00007852 	.word	0x00007852
   1c53c:	00005854 	.word	0x00005854
   1c540:	63656843 	.word	0x63656843
   1c544:	6d69546b 	.word	0x6d69546b
   1c548:	00007265 	.word	0x00007265
   1c54c:	00504975 	.word	0x00504975
   1c550:	74726175 	.word	0x74726175
   1c554:	7361745f 	.word	0x7361745f
   1c558:	0000006b 	.word	0x0000006b
   1c55c:	206c6c41 	.word	0x206c6c41
   1c560:	6b736174 	.word	0x6b736174
   1c564:	75722073 	.word	0x75722073
   1c568:	6e696e6e 	.word	0x6e696e6e
   1c56c:	69772067 	.word	0x69772067
   1c570:	756f6874 	.word	0x756f6874
   1c574:	72652074 	.word	0x72652074
   1c578:	00726f72 	.word	0x00726f72
   1c57c:	2a2a2a0a 	.word	0x2a2a2a0a
   1c580:	2a2a2a2a 	.word	0x2a2a2a2a
   1c584:	57202a2a 	.word	0x57202a2a
   1c588:	6f636c65 	.word	0x6f636c65
   1c58c:	7420656d 	.word	0x7420656d
   1c590:	6874206f 	.word	0x6874206f
   1c594:	654d2065 	.word	0x654d2065
   1c598:	72757361 	.word	0x72757361
   1c59c:	6e656d65 	.word	0x6e656d65
   1c5a0:	79532074 	.word	0x79532074
   1c5a4:	6d657473 	.word	0x6d657473
   1c5a8:	2a2a2020 	.word	0x2a2a2020
   1c5ac:	2a2a2a2a 	.word	0x2a2a2a2a
   1c5b0:	0a2a2a2a 	.word	0x0a2a2a2a
   1c5b4:	0000000d 	.word	0x0000000d
   1c5b8:	00000d0a 	.word	0x00000d0a
   1c5bc:	2a2a2a2a 	.word	0x2a2a2a2a
   1c5c0:	2a2a2a2a 	.word	0x2a2a2a2a
   1c5c4:	6d53202a 	.word	0x6d53202a
   1c5c8:	46747261 	.word	0x46747261
   1c5cc:	6f697375 	.word	0x6f697375
   1c5d0:	6c50206e 	.word	0x6c50206e
   1c5d4:	4d207961 	.word	0x4d207961
   1c5d8:	20756e65 	.word	0x20756e65
   1c5dc:	2a2a2a2a 	.word	0x2a2a2a2a
   1c5e0:	2a2a2a2a 	.word	0x2a2a2a2a
   1c5e4:	2a2a2a2a 	.word	0x2a2a2a2a
   1c5e8:	0d0a2a2a 	.word	0x0d0a2a2a
   1c5ec:	00000000 	.word	0x00000000
   1c5f0:	2a2a2a2a 	.word	0x2a2a2a2a
   1c5f4:	2a2a2a2a 	.word	0x2a2a2a2a
   1c5f8:	2e30202a 	.word	0x2e30202a
   1c5fc:	754d2020 	.word	0x754d2020
   1c600:	6d69746c 	.word	0x6d69746c
   1c604:	72657465 	.word	0x72657465
   1c608:	2a2a2a20 	.word	0x2a2a2a20
   1c60c:	2a2a2a2a 	.word	0x2a2a2a2a
   1c610:	2a2a2a2a 	.word	0x2a2a2a2a
   1c614:	2a2a2a2a 	.word	0x2a2a2a2a
   1c618:	2a2a2a2a 	.word	0x2a2a2a2a
   1c61c:	0d0a2a2a 	.word	0x0d0a2a2a
   1c620:	00000000 	.word	0x00000000
   1c624:	0000000a 	.word	0x0000000a
   1c628:	61766e49 	.word	0x61766e49
   1c62c:	2064696c 	.word	0x2064696c
   1c630:	2079654b 	.word	0x2079654b
   1c634:	00000d0a 	.word	0x00000d0a
   1c638:	2a2a2a2a 	.word	0x2a2a2a2a
   1c63c:	656c5020 	.word	0x656c5020
   1c640:	20657361 	.word	0x20657361
   1c644:	65746e45 	.word	0x65746e45
   1c648:	6f592072 	.word	0x6f592072
   1c64c:	43207275 	.word	0x43207275
   1c650:	63696f68 	.word	0x63696f68
   1c654:	20202065 	.word	0x20202065
   1c658:	2a202020 	.word	0x2a202020
   1c65c:	2a2a2a2a 	.word	0x2a2a2a2a
   1c660:	0d0a202a 	.word	0x0d0a202a
   1c664:	00000000 	.word	0x00000000
   1c668:	54505241 	.word	0x54505241
   1c66c:	72656d69 	.word	0x72656d69
   1c670:	00000000 	.word	0x00000000
   1c674:	69726550 	.word	0x69726550
   1c678:	6369646f 	.word	0x6369646f
   1c67c:	656d6954 	.word	0x656d6954
   1c680:	00000072 	.word	0x00000072
   1c684:	746e6f63 	.word	0x746e6f63
   1c688:	2e6c6f72 	.word	0x2e6c6f72
   1c68c:	6d746873 	.word	0x6d746873
   1c690:	0000006c 	.word	0x0000006c
   1c694:	3044454c 	.word	0x3044454c
   1c698:	0000313d 	.word	0x0000313d

0001c69c <ulARPTimerExpired.4126>:
   1c69c:	00000004                                ....

0001c6a0 <ulPeriodicTimerExpired.4127>:
   1c6a0:	00000008 2d706374 6e6e6f63 69746365     ....tcp-connecti
   1c6b0:	00736e6f 2d74656e 74617473 00000073     ons.net-stats...
   1c6c0:	2d64656c 00006f69 736e6573 722d726f     led-io..sensor-r
   1c6d0:	69646165 0073676e 3e72743c 3e64743c     eadings.<tr><td>
   1c6e0:	2f3c6425 3c3e6474 253e6474 75252e75     %d</td><td>%u.%u
   1c6f0:	2e75252e 253a7525 742f3c75 743c3e64     .%u.%u:%u</td><t
   1c700:	73253e64 64742f3c 64743c3e 3c75253e     d>%s</td><td>%u<
   1c710:	3e64742f 3e64743c 2f3c7525 3c3e6474     /td><td>%u</td><
   1c720:	253e6474 63252063 64742f3c 742f3c3e     td>%c %c</td></t
   1c730:	0a0d3e72 00000000 0a753525 00000000     r>......%5u.....
   1c740:	63656863 0064656b 00000000 706e693c     checked.....<inp
   1c750:	74207475 3d657079 65686322 6f626b63     ut type="checkbo
   1c760:	6e202278 3d656d61 44454c22 76202230     x" name="LED0" v
   1c770:	65756c61 2231223d 3e732520 3c44454c     alue="1" %s>LED<
   1c780:	00003e70 66342e25 342e252c 2e252c66     p>..%.4f,%.4f,%.
   1c790:	252c6634 0066342e                       4f,%.4f.

0001c798 <tcp>:
   1c798:	0001c6a4 00001961                       ....a...

0001c7a0 <net>:
   1c7a0:	0001c6b4 00001a61                       ....a...

0001c7a8 <io>:
   1c7a8:	0001c6c0 00001b6d                       ....m...

0001c7b0 <output>:
   1c7b0:	0001c6c8 00001bd5                       ........

0001c7b8 <closed>:
   1c7b8:	534f4c43 00004445                       CLOSED..

0001c7c0 <syn_rcvd>:
   1c7c0:	2d4e5953 44564352 00000000              SYN-RCVD....

0001c7cc <syn_sent>:
   1c7cc:	2d4e5953 544e4553 00000000              SYN-SENT....

0001c7d8 <established>:
   1c7d8:	41545345 53494c42 00444548              ESTABLISHED.

0001c7e4 <fin_wait_1>:
   1c7e4:	2d4e4946 54494157 0000312d              FIN-WAIT-1..

0001c7f0 <fin_wait_2>:
   1c7f0:	2d4e4946 54494157 0000322d              FIN-WAIT-2..

0001c7fc <closing>:
   1c7fc:	534f4c43 00474e49                       CLOSING.

0001c804 <time_wait>:
   1c804:	454d4954 4941572d 00000054              TIME-WAIT...

0001c810 <last_ack>:
   1c810:	5453414c 4b43412d 00000000              LAST-ACK....

0001c81c <g_ace_current_resistors>:
   1c81c:	000186a0 00010001                       ........

0001c824 <g_ace_external_varef_used>:
   1c824:	00000000                                ....

0001c828 <g_ace_channel_0_name>:
   1c828:	72727543 4d746e65 74696e6f 305f726f     CurrentMonitor_0
   1c838:	00000000                                ....

0001c83c <g_ace_channel_1_name>:
   1c83c:	746c6f56 4d656761 74696e6f 305f726f     VoltageMonitor_0
   1c84c:	00000000                                ....

0001c850 <g_ace_channel_2_name>:
   1c850:	41747845 6f6c616e 6d655467 00000070     ExtAnalogTemp...

0001c860 <g_ace_channel_3_name>:
   1c860:	41747845 6f6c616e 6d754867 00006469     ExtAnalogHumid..

0001c870 <g_ace_channel_4_name>:
   1c870:	706d6554 74617265 4d657275 74696e6f     TemperatureMonit
   1c880:	305f726f 00000000                       or_0....

0001c888 <g_ace_channel_5_name>:
   1c888:	41747845 6f6c616e 00565567              ExtAnalogUV.

0001c894 <g_ace_channel_6_name>:
   1c894:	41747845 6f6c616e 67694c67 00007468     ExtAnalogLight..

0001c8a4 <g_ace_ppe_transforms_desc_table>:
   1c8a4:	00130012 00004000 001c001b 00004000     .....@.......@..
   1c8b4:	00250024 ffffc000 002e002d ffffc000     $.%.....-.......
   1c8c4:	00370036 00004000 0040003f ffffc000     6.7..@..?.@.....
   1c8d4:	00490048 ffffc000                       H.I.....

0001c8dc <g_ace_sse_proc_0_name>:
   1c8dc:	30434441 49414d5f 0000004e              ADC0_MAIN...

0001c8e8 <g_ace_sse_proc_0_sequence>:
   1c8e8:	16011705 8a0c152d 00001309 000014c3     ....-...........
   1c8f8:	155c8a04 000014c4 14c5155c 152d0000     ..\.....\.....-.
   1c908:	132f970c 14c80000 97040000 14c6155c     ../.........\...
   1c918:	10020000                                ....

0001c91c <g_ace_sse_proc_1_name>:
   1c91c:	31434441 49414d5f 0000004e              ADC1_MAIN...

0001c928 <g_ace_sse_proc_1_sequence>:
   1c928:	26012705 24c5255c 255c0000 000024c6     .'.&\%.$..\%.$..
   1c938:	0000201c                                . ..

0001c93c <g_config_reg_lut>:
   1c93c:	40013000 40013004 40013008 4001300c     .0.@.0.@.0.@.0.@
   1c94c:	40013010 40013014 40013018 4001301c     .0.@.0.@.0.@.0.@
   1c95c:	40013020 40013024 40013028 4001302c      0.@$0.@(0.@,0.@
   1c96c:	40013030 40013034 40013038 4001303c     00.@40.@80.@<0.@
   1c97c:	40013040 40013044 40013048 4001304c     @0.@D0.@H0.@L0.@
   1c98c:	40013050 40013054 40013058 4001305c     P0.@T0.@X0.@\0.@
   1c99c:	40013060 40013064 40013068 4001306c     `0.@d0.@h0.@l0.@
   1c9ac:	40013070 40013074 40013078 4001307c     p0.@t0.@x0.@|0.@

0001c9bc <g_gpio_irqn_lut>:
   1c9bc:	00210020 00230022 00250024 00270026      .!.".#.$.%.&.'.
   1c9cc:	00290028 002b002a 002d002c 002f002e     (.).*.+.,.-.../.
   1c9dc:	00310030 00330032 00350034 00370036     0.1.2.3.4.5.6.7.
   1c9ec:	00390038 003b003a 003d003c 003f003e     8.9.:.;.<.=.>.?.

0001c9fc <crc32_table>:
   1c9fc:	00000000 77073096 ee0e612c 990951ba     .....0.w,a...Q..
   1ca0c:	076dc419 706af48f e963a535 9e6495a3     ..m...jp5.c...d.
   1ca1c:	0edb8832 79dcb8a4 e0d5e91e 97d2d988     2......y........
   1ca2c:	09b64c2b 7eb17cbd e7b82d07 90bf1d91     +L...|.~.-......
   1ca3c:	1db71064 6ab020f2 f3b97148 84be41de     d.... .jHq...A..
   1ca4c:	1adad47d 6ddde4eb f4d4b551 83d385c7     }......mQ.......
   1ca5c:	136c9856 646ba8c0 fd62f97a 8a65c9ec     V.l...kdz.b...e.
   1ca6c:	14015c4f 63066cd9 fa0f3d63 8d080df5     O\...l.cc=......
   1ca7c:	3b6e20c8 4c69105e d56041e4 a2677172     . n;^.iL.A`.rqg.
   1ca8c:	3c03e4d1 4b04d447 d20d85fd a50ab56b     ...<G..K....k...
   1ca9c:	35b5a8fa 42b2986c dbbbc9d6 acbcf940     ...5l..B....@...
   1caac:	32d86ce3 45df5c75 dcd60dcf abd13d59     .l.2u\.E....Y=..
   1cabc:	26d930ac 51de003a c8d75180 bfd06116     .0.&:..Q.Q...a..
   1cacc:	21b4f4b5 56b3c423 cfba9599 b8bda50f     ...!#..V........
   1cadc:	2802b89e 5f058808 c60cd9b2 b10be924     ...(..._....$...
   1caec:	2f6f7c87 58684c11 c1611dab b6662d3d     .|o/.LhX..a.=-f.
   1cafc:	76dc4190 01db7106 98d220bc efd5102a     .A.v.q... ..*...
   1cb0c:	71b18589 06b6b51f 9fbfe4a5 e8b8d433     ...q........3...
   1cb1c:	7807c9a2 0f00f934 9609a88e e10e9818     ...x4...........
   1cb2c:	7f6a0dbb 086d3d2d 91646c97 e6635c01     ..j.-=m..ld..\c.
   1cb3c:	6b6b51f4 1c6c6162 856530d8 f262004e     .Qkkbal..0e.N.b.
   1cb4c:	6c0695ed 1b01a57b 8208f4c1 f50fc457     ...l{.......W...
   1cb5c:	65b0d9c6 12b7e950 8bbeb8ea fcb9887c     ...eP.......|...
   1cb6c:	62dd1ddf 15da2d49 8cd37cf3 fbd44c65     ...bI-...|..eL..
   1cb7c:	4db26158 3ab551ce a3bc0074 d4bb30e2     Xa.M.Q.:t....0..
   1cb8c:	4adfa541 3dd895d7 a4d1c46d d3d6f4fb     A..J...=m.......
   1cb9c:	4369e96a 346ed9fc ad678846 da60b8d0     j.iC..n4F.g...`.
   1cbac:	44042d73 33031de5 aa0a4c5f dd0d7cc9     s-.D...3_L...|..
   1cbbc:	5005713c 270241aa be0b1010 c90c2086     <q.P.A.'..... ..
   1cbcc:	5768b525 206f85b3 b966d409 ce61e49f     %.hW..o ..f...a.
   1cbdc:	5edef90e 29d9c998 b0d09822 c7d7a8b4     ...^...)".......
   1cbec:	59b33d17 2eb40d81 b7bd5c3b c0ba6cad     .=.Y....;\...l..
   1cbfc:	edb88320 9abfb3b6 03b6e20c 74b1d29a      ..............t
   1cc0c:	ead54739 9dd277af 04db2615 73dc1683     9G...w...&.....s
   1cc1c:	e3630b12 94643b84 0d6d6a3e 7a6a5aa8     ..c..;d.>jm..Zjz
   1cc2c:	e40ecf0b 9309ff9d 0a00ae27 7d079eb1     ........'......}
   1cc3c:	f00f9344 8708a3d2 1e01f268 6906c2fe     D.......h......i
   1cc4c:	f762575d 806567cb 196c3671 6e6b06e7     ]Wb..ge.q6l...kn
   1cc5c:	fed41b76 89d32be0 10da7a5a 67dd4acc     v....+..Zz...J.g
   1cc6c:	f9b9df6f 8ebeeff9 17b7be43 60b08ed5     o.......C......`
   1cc7c:	d6d6a3e8 a1d1937e 38d8c2c4 4fdff252     ....~......8R..O
   1cc8c:	d1bb67f1 a6bc5767 3fb506dd 48b2364b     .g..gW.....?K6.H
   1cc9c:	d80d2bda af0a1b4c 36034af6 41047a60     .+..L....J.6`z.A
   1ccac:	df60efc3 a867df55 316e8eef 4669be79     ..`.U.g...n1y.iF
   1ccbc:	cb61b38c bc66831a 256fd2a0 5268e236     ..a...f...o%6.hR
   1cccc:	cc0c7795 bb0b4703 220216b9 5505262f     .w...G....."/&.U
   1ccdc:	c5ba3bbe b2bd0b28 2bb45a92 5cb36a04     .;..(....Z.+.j.\
   1ccec:	c2d7ffa7 b5d0cf31 2cd99e8b 5bdeae1d     ....1......,...[
   1ccfc:	9b64c2b0 ec63f226 756aa39c 026d930a     ..d.&.c...ju..m.
   1cd0c:	9c0906a9 eb0e363f 72076785 05005713     ....?6...g.r.W..
   1cd1c:	95bf4a82 e2b87a14 7bb12bae 0cb61b38     .J...z...+.{8...
   1cd2c:	92d28e9b e5d5be0d 7cdcefb7 0bdbdf21     ...........|!...
   1cd3c:	86d3d2d4 f1d4e242 68ddb3f8 1fda836e     ....B......hn...
   1cd4c:	81be16cd f6b9265b 6fb077e1 18b74777     ....[&...w.owG..
   1cd5c:	88085ae6 ff0f6a70 66063bca 11010b5c     .Z..pj...;.f\...
   1cd6c:	8f659eff f862ae69 616bffd3 166ccf45     ..e.i.b...kaE.l.
   1cd7c:	a00ae278 d70dd2ee 4e048354 3903b3c2     x.......T..N...9
   1cd8c:	a7672661 d06016f7 4969474d 3e6e77db     a&g...`.MGiI.wn>
   1cd9c:	aed16a4a d9d65adc 40df0b66 37d83bf0     Jj...Z..f..@.;.7
   1cdac:	a9bcae53 debb9ec5 47b2cf7f 30b5ffe9     S..........G...0
   1cdbc:	bdbdf21c cabac28a 53b39330 24b4a3a6     ........0..S...$
   1cdcc:	bad03605 cdd70693 54de5729 23d967bf     .6......)W.T.g.#
   1cddc:	b3667a2e c4614ab8 5d681b02 2a6f2b94     .zf..Ja...h].+o*
   1cdec:	b40bbe37 c30c8ea1 5a05df1b 2d02ef8d     7..........Z...-

0001cdfc <unknown_error>:
   1cdfc:	6e6b6e55 206e776f 6f727265 00000072     Unknown error...

0001ce0c <ErrorMessages>:
   1ce0c:	65206f4e 726f7272 63636f20 64657275     No error occured
	...
   1ce34:	6874654d 6620646f 656c6961 00000064     Method failed...
	...
   1ce5c:	6e6f7257 61702067 656d6172 20726574     Wrong parameter 
   1ce6c:	65736170 6f742064 6e756620 6f697463     pased to functio
   1ce7c:	0000006e 00000000 6d617246 73692065     n.......Frame is
   1ce8c:	6f6f7420 6e6f6c20 00000067 00000000      too long.......
	...
   1ceac:	20746f4e 756f6e65 73206867 65636170     Not enough space
   1cebc:	206e6920 66667562 00007265 00000000      in buffer......
	...
   1ced4:	20746f4e 756f6e65 73206867 65636170     Not enough space
   1cee4:	206e6920 66667562 00007265 00000000      in buffer......
	...
   1cefc:	656d6954 756f2064 00000074 00000000     Timed out.......
	...
   1cf24:	6d617246 73692065 6f6f7420 616d7320     Frame is too sma
   1cf34:	00006c6c 00000000 00000000 00000000     ll..............
	...

0001cf4c <C.18.3199>:
   1cf4c:	10131200 00001115                       ........

0001cf54 <channel_type_lut>:
   1cf54:	01000000 01000002 00000002 00ffff00     ................
   1cf64:	01000000 01000002 00000002 00ffff00     ................
   1cf74:	01000000 ffffff02 000000ff 00ffff00     ................

0001cf84 <channel_quad_lut>:
   1cf84:	000000ff 01010100 ffffff01 ffffffff     ................
   1cf94:	020202ff 03030302 ffffff03 ffffffff     ................
   1cfa4:	040404ff ffffff04 ffffffff ffffffff     ................

0001cfb4 <abps_channel_lut>:
   1cfb4:	ff0000ff ff0101ff ffffffff ffffffff     ................
   1cfc4:	ff0202ff ff0303ff ffffffff ffffffff     ................
   1cfd4:	ff0404ff ffffffff ffffffff ffffffff     ................

0001cfe4 <abps_idx_lut>:
   1cfe4:	ff0100ff ff0302ff ffffffff ffffffff     ................
   1cff4:	ff0504ff ff0706ff ffffffff ffffffff     ................
   1d004:	ff0908ff ffffffff ffffffff ffffffff     ................

0001d014 <apbs_gain_lut>:
   1d014:	0204080c                                ....

0001d018 <apbs_range>:
   1d018:	28003c00 0a001400                       .<.(....

0001d020 <sse_pc_ctrl_lut>:
   1d020:	40020048 40020088 400200c8              H..@...@...@

0001d02c <sse_pc_lo_lut>:
   1d02c:	40020040 40020080 400200c0              @..@...@...@

0001d038 <sse_pc_hi_lut>:
   1d038:	40020044 40020084 400200c4              D..@...@...@

0001d044 <p_mtd_data>:
   1d044:	60080010                                ...`

0001d048 <C.24.3281>:
   1d048:	02010006 02010003 04040403 05060604     ................

0001d058 <C.36.3345>:
	...
   1d080:	00000001 00000002 00000003 00000000     ................
	...

0001d098 <C.18.3191>:
   1d098:	40004000 00000000                       .@.@....

0001d0a0 <adc_status_reg_lut>:
   1d0a0:	40021000 40021004 40021008              ...@...@...@

0001d0ac <dac_ctrl_reg_lut>:
   1d0ac:	40020060 400200a0 400200e0              `..@...@...@

0001d0b8 <dac_enable_masks_lut>:
   1d0b8:	00000010 00000020 00000040              .... ...@...

0001d0c4 <dac_byte01_reg_lut>:
   1d0c4:	40020500 40020504 40020508              ...@...@...@

0001d0d0 <dac_byte2_reg_lut>:
   1d0d0:	4002006c 400200ac 400200ec              l..@...@...@

0001d0dc <p_mtd_data>:
   1d0dc:	60080010                                ...`

0001d0e0 <comp_id_2_scb_lut>:
   1d0e0:	01010000 03030202 00000404              ............

0001d0ec <C.18.3516>:
   1d0ec:	00040200                                ....

0001d0f0 <C.18.2576>:
   1d0f0:	00000001 00000002 00000004 00000001     ................
   1d100:	70616548 646e6120 61747320 63206b63     Heap and stack c
   1d110:	696c6c6f 6e6f6973 0000000a              ollision....

0001d11c <uart_instance>:
   1d11c:	2000a9d0                                ... 

0001d120 <uip_broadcast_addr>:
   1d120:	ffffffff                                ....

0001d124 <uip_all_zeroes_addr>:
   1d124:	00000000                                ....

0001d128 <broadcast_ethaddr>:
   1d128:	ffffffff 0000ffff                       ........

0001d130 <http_http>:
   1d130:	70747468 002f2f3a                       http://.

0001d138 <http_200>:
   1d138:	20303032 00000000                       200 ....

0001d140 <http_301>:
   1d140:	20313033 00000000                       301 ....

0001d148 <http_302>:
   1d148:	20323033 00000000                       302 ....

0001d150 <http_get>:
   1d150:	20544547 00000000                       GET ....

0001d158 <http_10>:
   1d158:	50545448 302e312f 00000000              HTTP/1.0....

0001d164 <http_11>:
   1d164:	50545448 312e312f 00000000              HTTP/1.1....

0001d170 <http_content_type>:
   1d170:	746e6f63 2d746e65 65707974 0000203a     content-type: ..

0001d180 <http_texthtml>:
   1d180:	74786574 6d74682f 0000006c              text/html...

0001d18c <http_location>:
   1d18c:	61636f6c 6e6f6974 0000203a              location: ..

0001d198 <http_host>:
   1d198:	74736f68 0000203a                       host: ..

0001d1a0 <http_crnl>:
   1d1a0:	00000a0d                                ....

0001d1a4 <http_index_html>:
   1d1a4:	646e692f 682e7865 006c6d74              /index.html.

0001d1b0 <http_404_html>:
   1d1b0:	3430342f 6d74682e 0000006c              /404.html...

0001d1bc <http_referer>:
   1d1bc:	65666552 3a726572 00000000              Referer:....

0001d1c8 <http_header_200>:
   1d1c8:	50545448 302e312f 30303220 0d4b4f20     HTTP/1.0 200 OK.
   1d1d8:	7265530a 3a726576 50497520 302e312f     .Server: uIP/1.0
   1d1e8:	74746820 2f2f3a70 2e777777 73636973      http://www.sics
   1d1f8:	2f65732e 6164617e 69752f6d 0a0d2f70     .se/~adam/uip/..
   1d208:	6e6e6f43 69746365 203a6e6f 736f6c63     Connection: clos
   1d218:	000a0d65                                e...

0001d21c <http_header_404>:
   1d21c:	50545448 302e312f 34303420 746f4e20     HTTP/1.0 404 Not
   1d22c:	756f6620 0a0d646e 76726553 203a7265      found..Server: 
   1d23c:	2f504975 20302e31 70747468 772f2f3a     uIP/1.0 http://w
   1d24c:	732e7777 2e736369 7e2f6573 6d616461     ww.sics.se/~adam
   1d25c:	7069752f 430a0d2f 656e6e6f 6f697463     /uip/..Connectio
   1d26c:	63203a6e 65736f6c 00000a0d              n: close....

0001d278 <http_content_type_plain>:
   1d278:	746e6f43 2d746e65 65707974 6574203a     Content-type: te
   1d288:	702f7478 6e69616c 0a0d0a0d 00000000     xt/plain........

0001d298 <http_content_type_html>:
   1d298:	746e6f43 2d746e65 65707974 6574203a     Content-type: te
   1d2a8:	682f7478 0d6c6d74 000a0d0a              xt/html.....

0001d2b4 <http_content_type_css>:
   1d2b4:	746e6f43 2d746e65 65707974 6574203a     Content-type: te
   1d2c4:	632f7478 0a0d7373 00000a0d              xt/css......

0001d2d0 <http_content_type_text>:
   1d2d0:	746e6f43 2d746e65 65707974 6574203a     Content-type: te
   1d2e0:	742f7478 0d747865 000a0d0a              xt/text.....

0001d2ec <http_content_type_png>:
   1d2ec:	746e6f43 2d746e65 65707974 6d69203a     Content-type: im
   1d2fc:	2f656761 0d676e70 000a0d0a              age/png.....

0001d308 <http_content_type_gif>:
   1d308:	746e6f43 2d746e65 65707974 6d69203a     Content-type: im
   1d318:	2f656761 0d666967 000a0d0a              age/gif.....

0001d324 <http_content_type_jpg>:
   1d324:	746e6f43 2d746e65 65707974 6d69203a     Content-type: im
   1d334:	2f656761 6765706a 0a0d0a0d 00000000     age/jpeg........

0001d344 <http_content_type_binary>:
   1d344:	746e6f43 2d746e65 65707974 7061203a     Content-type: ap
   1d354:	63696c70 6f697461 636f2f6e 2d746574     plication/octet-
   1d364:	65727473 0a0d6d61 00000a0d              stream......

0001d370 <http_html>:
   1d370:	6d74682e 0000006c                       .html...

0001d378 <http_shtml>:
   1d378:	7468732e 00006c6d                       .shtml..

0001d380 <http_htm>:
   1d380:	6d74682e 00000000                       .htm....

0001d388 <http_css>:
   1d388:	7373632e 00000000                       .css....

0001d390 <http_png>:
   1d390:	676e702e 00000000                       .png....

0001d398 <http_gif>:
   1d398:	6669672e 00000000                       .gif....

0001d3a0 <http_jpg>:
   1d3a0:	67706a2e 00000000                       .jpg....

0001d3a8 <http_text>:
   1d3a8:	7478742e 00000000                       .txt....

0001d3b0 <http_txt>:
   1d3b0:	7478742e 00000000                       .txt....

0001d3b8 <data_404_html>:
   1d3b8:	3430342f 6d74682e 683c006c 3e6c6d74     /404.html.<html>
   1d3c8:	0a0d0a0d 646f623c 67622079 6f6c6f63     ....<body bgcolo
   1d3d8:	77223d72 65746968 0a0d3e22 20202020     r="white">..    
   1d3e8:	6e65633c 3e726574 20200a0d 20202020     <center>..      
   1d3f8:	683c2020 30343e31 202d2034 656c6966       <h1>404 - file
   1d408:	746f6e20 756f6620 2f3c646e 0d3e3168      not found</h1>.
   1d418:	2020200a 20202020 33683c20 206f473e     .        <h3>Go 
   1d428:	3c206f74 72682061 223d6665 683e222f     to <a href="/">h
   1d438:	3c656d6f 203e612f 65676170 682f3c2e     ome</a> page.</h
   1d448:	0a0d3e33 20202020 65632f3c 7265746e     3>..    </center
   1d458:	3c0a0d3e 646f622f 0a0d3e79 2f3c0a0d     >..</body>....</
   1d468:	6c6d7468 0000003e                       html>...

0001d470 <data_control_shtml>:
   1d470:	6e6f632f 6c6f7274 7468732e 3c006c6d     /control.shtml.<
   1d480:	434f4421 45505954 4d544820 0a0d3e4c     !DOCTYPE HTML>..
   1d490:	6d74683c 0a0d3e6c 683c0a0d 3e646165     <html>....<head>
   1d4a0:	20200a0d 743c2020 656c7469 6b614a3e     ..    <title>Jak
   1d4b0:	20732765 74616577 20726568 74617473     e's weather stat
   1d4c0:	206e6f69 6e696874 2f3c7967 6c746974     ion thingy</titl
   1d4d0:	0a0d3e65 20202020 74656d3c 74682061     e>..    <meta ht
   1d4e0:	652d7074 76697571 6f63223d 6e65746e     tp-equiv="conten
   1d4f0:	79742d74 20226570 746e6f63 3d746e65     t-type" content=
   1d500:	78657422 74682f74 203b6c6d 72616863     "text/html; char
   1d510:	3d746573 2d6f7369 39353838 2022312d     set=iso-8859-1" 
   1d520:	0a0d3e2f 20202020 7974733c 6d20656c     />..    <style m
   1d530:	61696465 6c61223d 7420226c 3d657079     edia="all" type=
   1d540:	78657422 73632f74 0d3e2273 2020200a     "text/css">..   
   1d550:	20202020 6d694020 74726f70 73632220          @import "cs
   1d560:	74732f73 73656c79 7373632e 0a0d3b22     s/styles.css";..
   1d570:	20202020 74732f3c 3e656c79 2f3c0a0d         </style>..</
   1d580:	64616568 0d0a0d3e 6f623c0a 0d3e7964     head>....<body>.
   1d590:	2020200a 69643c20 64692076 616d223d     .    <div id="ma
   1d5a0:	3e226e69 20200a0d 20202020 643c2020     in">..        <d
   1d5b0:	69207669 68223d64 65646165 0d3e2272     iv id="header">.
   1d5c0:	2020200a 20202020 20202020 20613c20     .            <a 
   1d5d0:	66657268 6e69223d 2e786564 6c6d7468     href="index.html
   1d5e0:	6c632022 3d737361 676f6c22 3c3e226f     " class="logo"><
   1d5f0:	20676d69 3d637273 676d6922 6f6c632f     img src="img/clo
   1d600:	6f4c6475 702e6f67 2022676e 74646977     udLogo.png" widt
   1d610:	31223d68 20223030 67696568 223d7468     h="100" height="
   1d620:	20223038 3d746c61 2f202222 612f3c3e     80" alt="" /></a
   1d630:	0d0a0d3e 2020200a 20202020 20202020     >....           
   1d640:	6c753c20 3d646920 706f7422 76616e2d      <ul id="top-nav
   1d650:	74616769 226e6f69 200a0d3e 20202020     igation">..     
   1d660:	20202020 20202020 3c202020 3c3e696c                <li><
   1d670:	6e617073 70733c3e 3c3e6e61 72682061     span><span><a hr
   1d680:	223d6665 65646e69 74682e78 3e226c6d     ef="index.html">
   1d690:	656d6f48 3e612f3c 70732f3c 3c3e6e61     Home</a></span><
   1d6a0:	6170732f 0a0d3e6e 20202020 20202020     /span>..        
   1d6b0:	20202020 20202020 696c2f3c 200a0d3e             </li>.. 
   1d6c0:	20202020 20202020 20202020 3c202020                    <
   1d6d0:	3c3e696c 6e617073 70733c3e 3c3e6e61     li><span><span><
   1d6e0:	72682061 223d6665 68736164 72616f62     a href="dashboar
   1d6f0:	68732e64 226c6d74 7361443e 616f6268     d.shtml">Dashboa
   1d700:	2f3c6472 2f3c3e61 6e617073 732f3c3e     rd</a></span></s
   1d710:	3e6e6170 20200a0d 20202020 20202020     pan>..          
   1d720:	20202020 2f3c2020 0d3e696c 2020200a           </li>..   
   1d730:	20202020 20202020 20202020 696c3c20                  <li
   1d740:	616c6320 223d7373 69746361 3e226576      class="active">
   1d750:	6170733c 733c3e6e 3e6e6170 6820613c     <span><span><a h
   1d760:	3d666572 6e6f6322 6c6f7274 7468732e     ref="control.sht
   1d770:	3e226c6d 746e6f43 3c6c6f72 3c3e612f     ml">Control</a><
   1d780:	6170732f 2f3c3e6e 6e617073 200a0d3e     /span></span>.. 
   1d790:	20202020 20202020 20202020 3c202020                    <
   1d7a0:	3e696c2f 20200a0d 20202020 20202020     /li>..          
   1d7b0:	20202020 6c3c2020 733c3e69 3e6e6170           <li><span>
   1d7c0:	6170733c 613c3e6e 65726820 73223d66     <span><a href="s
   1d7d0:	73746174 7468732e 3e226c6d 20504354     tats.shtml">TCP 
   1d7e0:	74617453 612f3c73 732f3c3e 3e6e6170     Stats</a></span>
   1d7f0:	70732f3c 0d3e6e61 2020200a 20202020     </span>..       
   1d800:	20202020 20202020 6c2f3c20 0a0d3e69              </li>..
   1d810:	20202020 20202020 20202020 20202020                     
   1d820:	3e696c3c 6170733c 733c3e6e 3e6e6170     <li><span><span>
   1d830:	6820613c 3d666572 70637422 7468732e     <a href="tcp.sht
   1d840:	3e226c6d 6e6e6f43 69746365 3c736e6f     ml">Connections<
   1d850:	3c3e612f 6170732f 2f3c3e6e 6e617073     /a></span></span
   1d860:	200a0d3e 20202020 20202020 20202020     >..             
   1d870:	3c202020 3e696c2f 20200a0d 20202020        </li>..      
   1d880:	20202020 2f3c2020 0d3e6c75 2020200a           </ul>..   
   1d890:	20202020 642f3c20 0d3e7669 200a0d0a          </div>.... 
   1d8a0:	20202020 3c202020 20766964 223d6469            <div id="
   1d8b0:	6464696d 3e22656c 20200a0d 20202020     middle">..      
   1d8c0:	20202020 683c2020 65573e32 6d6f636c           <h2>Welcom
   1d8d0:	6f742065 65687420 204f4920 746e6f63     e to the IO cont
   1d8e0:	206c6f72 656e6170 3c20216c 3e32682f     rol panel! </h2>
   1d8f0:	0a0d0a0d 20202020 20202020 20202020     ....            
   1d900:	3e72683c 20200a0d 20202020 20202020     <hr>..          
   1d910:	623c2020 6e6f433e 6c6f7274 65687420       <b>Control the
   1d920:	44454c20 622f3c73 72623c3e 200a0d3e      LEDs</b><br>.. 
   1d930:	20202020 20202020 3c202020 0a0d3e70                <p>..
   1d940:	20200a0d 20202020 20202020 20202020     ..              
   1d950:	703c2020 6573553e 65687420 65686320       <p>Use the che
   1d960:	62206b63 7420786f 7574206f 6f206e72     ck box to turn o
   1d970:	726f206e 66666f20 44454c20 202c3420     n or off LED 4, 
   1d980:	6e656874 696c6320 22206b63 61647055     then click "Upda
   1d990:	49206574 3c2e224f 0d3e702f 2020200a     te IO".</p>..   
   1d9a0:	20202020 20202020 20202020 3e703c20                  <p>
   1d9b0:	20200a0d 20202020 20202020 20202020     ..              
   1d9c0:	20202020 663c2020 206d726f 656d616e           <form name
   1d9d0:	4661223d 226d726f 74636120 3d6e6f69     ="aForm" action=
   1d9e0:	6f632f22 6f72746e 68732e6c 226c6d74     "/control.shtml"
   1d9f0:	74656d20 3d646f68 74656722 0a0d3e22      method="get">..
   1da00:	20202020 20202020 20202020 20202020                     
   1da10:	20202020 20202020 6c202125 692d6465             %! led-i
   1da20:	200a0d6f 20202020 20202020 20202020     o..             
   1da30:	20202020 20202020 3c202020 0a0d3e70                <p>..
   1da40:	20202020 20202020 20202020 20202020                     
   1da50:	20202020 20202020 20202020 706e693c                 <inp
   1da60:	74207475 3d657079 62757322 2274696d     ut type="submit"
   1da70:	6c617620 223d6575 61647055 49206574      value="Update I
   1da80:	0d3e224f 2020200a 20202020 20202020     O">..           
   1da90:	20202020 20202020 662f3c20 3e6d726f              </form>
   1daa0:	20200a0d 20202020 2f3c2020 3e766964     ..        </div>
   1dab0:	0a0d0a0d 20200a0d 20202020 643c2020     ......        <d
   1dac0:	69207669 66223d64 65746f6f 3c3e2272     iv id="footer"><
   1dad0:	7669642f 200a0d3e 3c202020 7669642f     /div>..    </div
   1dae0:	0d0a0d3e 622f3c0a 3e79646f 0a0d0a0d     >....</body>....
   1daf0:	74682f3c 003e6c6d                       </html>.

0001daf8 <data_dashboard_shtml>:
   1daf8:	7361642f 616f6268 732e6472 6c6d7468     /dashboard.shtml
   1db08:	44213c00 5954434f 48204550 3e4c4d54     .<!DOCTYPE HTML>
   1db18:	683c0a0d 3e6c6d74 0a0d0a0d 6165683c     ..<html>....<hea
   1db28:	0a0d3e64 20202020 7469743c 4a3e656c     d>..    <title>J
   1db38:	27656b61 65772073 65687461 74732072     ake's weather st
   1db48:	6f697461 6874206e 79676e69 69742f3c     ation thingy</ti
   1db58:	3e656c74 20200a0d 6d3c2020 20617465     tle>..    <meta 
   1db68:	70747468 7571652d 223d7669 746e6f63     http-equiv="cont
   1db78:	2d746e65 65707974 6f632022 6e65746e     ent-type" conten
   1db88:	74223d74 2f747865 6c6d7468 6863203b     t="text/html; ch
   1db98:	65737261 73693d74 38382d6f 312d3935     arset=iso-8859-1
   1dba8:	3e2f2022 20200a0d 733c2020 656c7974     " />..    <style
   1dbb8:	64656d20 223d6169 226c6c61 70797420      media="all" typ
   1dbc8:	74223d65 2f747865 22737363 200a0d3e     e="text/css">.. 
   1dbd8:	20202020 40202020 6f706d69 22207472            @import "
   1dbe8:	2f737363 6c797473 632e7365 3b227373     css/styles.css";
   1dbf8:	20200a0d 2f3c2020 6c797473 0a0d3e65     ..    </style>..
   1dc08:	65682f3c 0d3e6461 0d0a0d0a 6f623c0a     </head>......<bo
   1dc18:	0d3e7964 2020200a 69643c20 64692076     dy>..    <div id
   1dc28:	616d223d 3e226e69 20200a0d 20202020     ="main">..      
   1dc38:	643c2020 69207669 68223d64 65646165       <div id="heade
   1dc48:	0d3e2272 2020200a 20202020 20202020     r">..           
   1dc58:	20613c20 66657268 6e69223d 2e786564      <a href="index.
   1dc68:	6c6d7468 6c632022 3d737361 676f6c22     html" class="log
   1dc78:	3c3e226f 20676d69 3d637273 676d6922     o"><img src="img
   1dc88:	6f6c632f 6f4c6475 702e6f67 2022676e     /cloudLogo.png" 
   1dc98:	74646977 31223d68 20223030 67696568     width="100" heig
   1dca8:	223d7468 20223038 3d746c61 2f202222     ht="80" alt="" /
   1dcb8:	612f3c3e 0d0a0d3e 2020200a 20202020     ></a>....       
   1dcc8:	20202020 6c753c20 3d646920 706f7422          <ul id="top
   1dcd8:	76616e2d 74616769 226e6f69 200a0d3e     -navigation">.. 
   1dce8:	20202020 20202020 20202020 3c202020                    <
   1dcf8:	3c3e696c 6e617073 70733c3e 3c3e6e61     li><span><span><
   1dd08:	72682061 223d6665 65646e69 74682e78     a href="index.ht
   1dd18:	3e226c6d 656d6f48 3e612f3c 70732f3c     ml">Home</a></sp
   1dd28:	3c3e6e61 6170732f 0a0d3e6e 20202020     an></span>..    
   1dd38:	20202020 20202020 20202020 696c2f3c                 </li
   1dd48:	200a0d3e 20202020 20202020 20202020     >..             
   1dd58:	3c202020 6320696c 7373616c 6361223d        <li class="ac
   1dd68:	65766974 733c3e22 3e6e6170 6170733c     tive"><span><spa
   1dd78:	613c3e6e 65726820 64223d66 62687361     n><a href="dashb
   1dd88:	6472616f 7468732e 3e226c6d 68736144     oard.shtml">Dash
   1dd98:	72616f62 612f3c64 732f3c3e 3e6e6170     board</a></span>
   1dda8:	70732f3c 0d3e6e61 2020200a 20202020     </span>..       
   1ddb8:	20202020 20202020 6c2f3c20 0a0d3e69              </li>..
   1ddc8:	20202020 20202020 20202020 20202020                     
   1ddd8:	3e696c3c 6170733c 733c3e6e 3e6e6170     <li><span><span>
   1dde8:	6820613c 3d666572 6e6f6322 6c6f7274     <a href="control
   1ddf8:	7468732e 3e226c6d 746e6f43 3c6c6f72     .shtml">Control<
   1de08:	3c3e612f 6170732f 2f3c3e6e 6e617073     /a></span></span
   1de18:	200a0d3e 20202020 20202020 20202020     >..             
   1de28:	3c202020 3e696c2f 20200a0d 20202020        </li>..      
   1de38:	20202020 20202020 6c3c2020 733c3e69               <li><s
   1de48:	3e6e6170 6170733c 613c3e6e 65726820     pan><span><a hre
   1de58:	73223d66 73746174 7468732e 3e226c6d     f="stats.shtml">
   1de68:	20504354 74617453 612f3c73 732f3c3e     TCP Stats</a></s
   1de78:	3e6e6170 70732f3c 0d3e6e61 2020200a     pan></span>..   
   1de88:	20202020 20202020 20202020 6c2f3c20                  </l
   1de98:	0a0d3e69 20202020 20202020 20202020     i>..            
   1dea8:	20202020 3e696c3c 6170733c 733c3e6e         <li><span><s
   1deb8:	3e6e6170 6820613c 3d666572 70637422     pan><a href="tcp
   1dec8:	7468732e 3e226c6d 6e6e6f43 69746365     .shtml">Connecti
   1ded8:	3c736e6f 3c3e612f 6170732f 2f3c3e6e     ons</a></span></
   1dee8:	6e617073 200a0d3e 20202020 20202020     span>..         
   1def8:	20202020 3c202020 3e696c2f 20200a0d            </li>..  
   1df08:	20202020 20202020 2f3c2020 0d3e6c75               </ul>.
   1df18:	2020200a 20202020 642f3c20 0d3e7669     .        </div>.
   1df28:	200a0d0a 20202020 3c202020 20766964     ...        <div 
   1df38:	223d6469 6464696d 3e22656c 20200a0d     id="middle">..  
   1df48:	20202020 20202020 683c2020 65573e32               <h2>We
   1df58:	6d6f636c 6f742065 65687420 61655720     lcome to the Wea
   1df68:	72656874 73614420 616f6268 20216472     ther Dashboard! 
   1df78:	32682f3c 0d0a0d3e 2020200a 20202020     </h2>....       
   1df88:	20202020 33683c20 6d65543e 61726570          <h3>Tempera
   1df98:	65727574 29432820 682f3c20 0a0d3e33     ture (C) </h3>..
   1dfa8:	20200a0d 20202020 20202020 643c2020     ..            <d
   1dfb8:	69207669 63223d64 74726168 0a0d3e22     iv id="chart">..
   1dfc8:	20202020 20202020 20202020 20202020                     
   1dfd8:	6e61633c 20736176 223d6469 706d6574     <canvas id="temp
   1dfe8:	6172675f 20226870 74646977 35223d68     _graph" width="5
   1dff8:	20223231 67696568 223d7468 22303031     12" height="100"
   1e008:	632f3c3e 61766e61 0a0d3e73 20202020     ></canvas>..    
   1e018:	20202020 20202020 69642f3c 0a0d3e76             </div>..
   1e028:	20200a0d 20202020 20202020 683c2020     ..            <h
   1e038:	75483e33 6964696d 28207974 2f3c2925     3>Humidity (%)</
   1e048:	0d3e3368 200a0d0a 20202020 20202020     h3>....         
   1e058:	3c202020 20766964 223d6469 72616863        <div id="char
   1e068:	0d3e2274 2020200a 20202020 20202020     t">..           
   1e078:	20202020 61633c20 7361766e 3d646920          <canvas id=
   1e088:	6d756822 675f6469 68706172 69772022     "humid_graph" wi
   1e098:	3d687464 32313522 65682022 74686769     dth="512" height
   1e0a8:	3031223d 3c3e2230 6e61632f 3e736176     ="100"></canvas>
   1e0b8:	20200a0d 20202020 20202020 2f3c2020     ..            </
   1e0c8:	3e766964 0a0d0a0d 20202020 20202020     div>....        
   1e0d8:	20202020 3e33683c 6867694c 6e492074         <h3>Light In
   1e0e8:	736e6574 20797469 78754c28 682f3c29     tensity (Lux)</h
   1e0f8:	0a0d3e33 20200a0d 20202020 20202020     3>....          
   1e108:	643c2020 69207669 63223d64 74726168       <div id="chart
   1e118:	0a0d3e22 20202020 20202020 20202020     ">..            
   1e128:	20202020 6e61633c 20736176 223d6469         <canvas id="
   1e138:	5f78756c 70617267 77202268 68746469     lux_graph" width
   1e148:	3135223d 68202232 68676965 31223d74     ="512" height="1
   1e158:	3e223030 61632f3c 7361766e 200a0d3e     00"></canvas>.. 
   1e168:	20202020 20202020 3c202020 7669642f                </div
   1e178:	0d0a0d3e 2020200a 20202020 20202020     >....           
   1e188:	33683c20 2056553e 65646e49 682f3c78      <h3>UV Index</h
   1e198:	0a0d3e33 20200a0d 20202020 20202020     3>....          
   1e1a8:	643c2020 69207669 63223d64 74726168       <div id="chart
   1e1b8:	0a0d3e22 20202020 20202020 20202020     ">..            
   1e1c8:	20202020 6e61633c 20736176 223d6469         <canvas id="
   1e1d8:	675f7675 68706172 69772022 3d687464     uv_graph" width=
   1e1e8:	32313522 65682022 74686769 3031223d     "512" height="10
   1e1f8:	3c3e2230 6e61632f 3e736176 20200a0d     0"></canvas>..  
   1e208:	20202020 20202020 2f3c2020 3e766964               </div>
   1e218:	20200a0d 20202020 2f3c2020 3e766964     ..        </div>
   1e228:	0a0d0a0d 20202020 20202020 7669643c     ....        <div
   1e238:	3d646920 6d656422 0d3e226f 200a0d0a      id="demo">.... 
   1e248:	20202020 3c202020 7669642f 0d0a0d3e            </div>...
   1e258:	200a0d0a 20202020 3c202020 20766964     ...        <div 
   1e268:	223d6469 746f6f66 3e227265 69642f3c     id="footer"></di
   1e278:	0a0d3e76 20202020 69642f3c 0a0d3e76     v>..    </div>..
   1e288:	20200a0d 733c2020 70697263 0a0d3e74     ..    <script>..
   1e298:	20202020 20202020 6f632f2f 66206564             //code f
   1e2a8:	6320726f 74726168 6f726620 7468206d     or chart from ht
   1e2b8:	2f3a7074 6f6d732f 6968746f 61686365     tp://smoothiecha
   1e2c8:	2e737472 2f67726f 0a0d0a0d 20202020     rts.org/....    
   1e2d8:	20202020 75662021 6974636e 65286e6f         ! function(e
   1e2e8:	0d7b2029 2020200a 20202020 20202020     ) {..           
   1e2f8:	72617620 3d207420 0a0d7b20 20202020      var t = {..    
   1e308:	20202020 20202020 20202020 65747865                 exte
   1e318:	203a646e 636e7566 6e6f6974 7b202928     nd: function() {
   1e328:	20200a0d 20202020 20202020 20202020     ..              
   1e338:	20202020 72612020 656d7567 5b73746e           arguments[
   1e348:	3d205d30 67726120 6e656d75 305b7374     0] = arguments[0
   1e358:	7c7c205d 3b7d7b20 20200a0d 20202020     ] || {};..      
   1e368:	20202020 20202020 20202020 6f662020                   fo
   1e378:	76282072 65207261 31203d20 2065203b     r (var e = 1; e 
   1e388:	7261203c 656d7567 2e73746e 676e656c     < arguments.leng
   1e398:	203b6874 3d2b2065 0d293120 2020200a     th; e += 1)..   
   1e3a8:	20202020 20202020 20202020 20202020                     
   1e3b8:	20202020 726f6620 61762820 20692072          for (var i 
   1e3c8:	61206e69 6d756772 73746e65 295d655b     in arguments[e])
   1e3d8:	67726120 6e656d75 655b7374 61682e5d      arguments[e].ha
   1e3e8:	6e774f73 706f7250 79747265 20296928     sOwnProperty(i) 
   1e3f8:	28202626 6a626f22 22746365 203d3d20     && ("object" == 
   1e408:	65707974 6120666f 6d756772 73746e65     typeof arguments
   1e418:	5b5d655b 3f205d69 67726120 6e656d75     [e][i] ? argumen
   1e428:	655b7374 5d695b5d 736e6920 636e6174     ts[e][i] instanc
   1e438:	20666f65 61727241 203f2079 75677261     eof Array ? argu
   1e448:	746e656d 5d305b73 205d695b 7261203d     ments[0][i] = ar
   1e458:	656d7567 5b73746e 695b5d65 203a205d     guments[e][i] : 
   1e468:	75677261 746e656d 5d305b73 205d695b     arguments[0][i] 
   1e478:	2e74203d 65747865 6128646e 6d756772     = t.extend(argum
   1e488:	73746e65 5b5d305b 202c5d69 75677261     ents[0][i], argu
   1e498:	746e656d 5d655b73 295d695b 61203a20     ments[e][i]) : a
   1e4a8:	6d756772 73746e65 5b5d305b 3d205d69     rguments[0][i] =
   1e4b8:	67726120 6e656d75 655b7374 5d695b5d      arguments[e][i]
   1e4c8:	0a0d3b29 20202020 20202020 20202020     );..            
   1e4d8:	20202020 20202020 75746572 61206e72             return a
   1e4e8:	6d756772 73746e65 0d5d305b 2020200a     rguments[0]..   
   1e4f8:	20202020 20202020 20202020 0a0d7d20                  }..
   1e508:	20202020 20202020 20202020 0a0d3b7d                 };..
   1e518:	20200a0d 20202020 20202020 75662020     ..            fu
   1e528:	6974636e 69206e6f 20296528 200a0d7b     nction i(e) {.. 
   1e538:	20202020 20202020 20202020 74202020                    t
   1e548:	2e736968 6974706f 20736e6f 2e74203d     his.options = t.
   1e558:	65747865 7b28646e 69202c7d 6665642e     extend({}, i.def
   1e568:	746c7561 6974704f 2c736e6f 2c296520     aultOptions, e),
   1e578:	69687420 6c632e73 28726165 200a0d29      this.clear().. 
   1e588:	20202020 20202020 7d202020 0a0d0a0d                }....
   1e598:	20202020 20202020 20202020 636e7566                 func
   1e5a8:	6e6f6974 65286120 0d7b2029 2020200a     tion a(e) {..   
   1e5b8:	20202020 20202020 20202020 69687420                  thi
   1e5c8:	706f2e73 6e6f6974 203d2073 78652e74     s.options = t.ex
   1e5d8:	646e6574 2c7d7b28 642e6120 75616665     tend({}, a.defau
   1e5e8:	6843746c 4f747261 6f697470 202c736e     ltChartOptions, 
   1e5f8:	202c2965 73696874 7265732e 53736569     e), this.seriesS
   1e608:	3d207465 2c5d5b20 69687420 75632e73     et = [], this.cu
   1e618:	6e657272 6c615674 61526575 2065676e     rrentValueRange 
   1e628:	2c31203d 69687420 75632e73 6e657272     = 1, this.curren
   1e638:	73695674 566e694d 65756c61 30203d20     tVisMinValue = 0
   1e648:	6874202c 6c2e7369 52747361 65646e65     , this.lastRende
   1e658:	6d695472 6c694d65 2073696c 0d30203d     rTimeMillis = 0.
   1e668:	2020200a 20202020 20202020 0a0d7d20     .            }..
   1e678:	20202020 20202020 20202020 65642e69                 i.de
   1e688:	6c756166 74704f74 736e6f69 7b203d20     faultOptions = {
   1e698:	20200a0d 20202020 20202020 20202020     ..              
   1e6a8:	65722020 42746573 646e756f 746e4973       resetBoundsInt
   1e6b8:	61767265 33203a6c 0d2c3365 2020200a     erval: 3e3,..   
   1e6c8:	20202020 20202020 20202020 73657220                  res
   1e6d8:	6f427465 73646e75 3021203a 20200a0d     etBounds: !0..  
   1e6e8:	20202020 20202020 2c7d2020 702e6920               }, i.p
   1e6f8:	6f746f72 65707974 656c632e 3d207261     rototype.clear =
   1e708:	6e756620 6f697463 2029286e 200a0d7b      function() {.. 
   1e718:	20202020 20202020 20202020 74202020                    t
   1e728:	2e736968 61746164 5b203d20 74202c5d     his.data = [], t
   1e738:	2e736968 5678616d 65756c61 4e203d20     his.maxValue = N
   1e748:	65626d75 614e2e72 74202c4e 2e736968     umber.NaN, this.
   1e758:	566e696d 65756c61 4e203d20 65626d75     minValue = Numbe
   1e768:	614e2e72 200a0d4e 20202020 20202020     r.NaN..         
   1e778:	7d202020 2e69202c 746f7270 7079746f        }, i.prototyp
   1e788:	65722e65 42746573 646e756f 203d2073     e.resetBounds = 
   1e798:	636e7566 6e6f6974 7b202928 20200a0d     function() {..  
   1e7a8:	20202020 20202020 20202020 66692020                   if
   1e7b8:	68742820 642e7369 2e617461 676e656c      (this.data.leng
   1e7c8:	20296874 200a0d7b 20202020 20202020     th) {..         
   1e7d8:	20202020 20202020 74202020 2e736968                this.
   1e7e8:	5678616d 65756c61 74203d20 2e736968     maxValue = this.
   1e7f8:	61746164 5b5d305b 202c5d31 73696874     data[0][1], this
   1e808:	6e696d2e 756c6156 203d2065 73696874     .minValue = this
   1e818:	7461642e 5d305b61 3b5d315b 20200a0d     .data[0][1];..  
   1e828:	20202020 20202020 20202020 20202020                     
   1e838:	6f662020 76282072 65207261 31203d20       for (var e = 1
   1e848:	2065203b 6874203c 642e7369 2e617461     ; e < this.data.
   1e858:	676e656c 203b6874 3d2b2065 20293120     length; e += 1) 
   1e868:	200a0d7b 20202020 20202020 20202020     {..             
   1e878:	20202020 20202020 76202020 74207261                var t
   1e888:	74203d20 2e736968 61746164 5b5d655b      = this.data[e][
   1e898:	0d3b5d31 2020200a 20202020 20202020     1];..           
   1e8a8:	20202020 20202020 20202020 3e207420                  t >
   1e8b8:	69687420 616d2e73 6c615678 26206575      this.maxValue &
   1e8c8:	74282026 2e736968 5678616d 65756c61     & (this.maxValue
   1e8d8:	74203d20 74202c29 74203c20 2e736968      = t), t < this.
   1e8e8:	566e696d 65756c61 20262620 69687428     minValue && (thi
   1e8f8:	696d2e73 6c61566e 3d206575 0d297420     s.minValue = t).
   1e908:	2020200a 20202020 20202020 20202020     .               
   1e918:	20202020 0a0d7d20 20202020 20202020          }..        
   1e928:	20202020 20202020 6c65207d 74206573             } else t
   1e938:	2e736968 5678616d 65756c61 4e203d20     his.maxValue = N
   1e948:	65626d75 614e2e72 74202c4e 2e736968     umber.NaN, this.
   1e958:	566e696d 65756c61 4e203d20 65626d75     minValue = Numbe
   1e968:	614e2e72 200a0d4e 20202020 20202020     r.NaN..         
   1e978:	7d202020 2e69202c 746f7270 7079746f        }, i.prototyp
   1e988:	70612e65 646e6570 66203d20 74636e75     e.append = funct
   1e998:	286e6f69 74202c65 2969202c 0a0d7b20     ion(e, t, i) {..
   1e9a8:	20202020 20202020 20202020 20202020                     
   1e9b8:	20726f66 72617628 3d206120 69687420     for (var a = thi
   1e9c8:	61642e73 6c2e6174 74676e65 202d2068     s.data.length - 
   1e9d8:	61203b31 203d3e20 26262030 69687420     1; a >= 0 && thi
   1e9e8:	61642e73 615b6174 5d305b5d 65203e20     s.data[a][0] > e
   1e9f8:	6120293b 203d2d20 2d203b31 3d203120     ;) a -= 1; - 1 =
   1ea08:	61203d3d 74203f20 2e736968 61746164     == a ? this.data
   1ea18:	6c70732e 28656369 30202c30 655b202c     .splice(0, 0, [e
   1ea28:	5d74202c 203a2029 73696874 7461642e     , t]) : this.dat
   1ea38:	656c2e61 6874676e 30203e20 20262620     a.length > 0 && 
   1ea48:	73696874 7461642e 5d615b61 205d305b     this.data[a][0] 
   1ea58:	203d3d3d 203f2065 203f2069 69687428     === e ? i ? (thi
   1ea68:	61642e73 615b6174 5d315b5d 203d2b20     s.data[a][1] += 
   1ea78:	74202c74 74203d20 2e736968 61746164     t, t = this.data
   1ea88:	5b5d615b 20295d31 6874203a 642e7369     [a][1]) : this.d
   1ea98:	5b617461 315b5d61 203d205d 203a2074     ata[a][1] = t : 
   1eaa8:	203c2061 73696874 7461642e 656c2e61     a < this.data.le
   1eab8:	6874676e 31202d20 74203f20 2e736968     ngth - 1 ? this.
   1eac8:	61746164 6c70732e 28656369 202b2061     data.splice(a + 
   1ead8:	30202c31 655b202c 5d74202c 203a2029     1, 0, [e, t]) : 
   1eae8:	73696874 7461642e 75702e61 5b286873     this.data.push([
   1eaf8:	74202c65 202c295d 73696874 78616d2e     e, t]), this.max
   1eb08:	756c6156 203d2065 614e7369 6874284e     Value = isNaN(th
   1eb18:	6d2e7369 61567861 2965756c 74203f20     is.maxValue) ? t
   1eb28:	4d203a20 2e687461 2878616d 73696874      : Math.max(this
   1eb38:	78616d2e 756c6156 74202c65 74202c29     .maxValue, t), t
   1eb48:	2e736968 566e696d 65756c61 69203d20     his.minValue = i
   1eb58:	4e614e73 69687428 696d2e73 6c61566e     sNaN(this.minVal
   1eb68:	20296575 2074203f 614d203a 6d2e6874     ue) ? t : Math.m
   1eb78:	74286e69 2e736968 566e696d 65756c61     in(this.minValue
   1eb88:	2974202c 20200a0d 20202020 20202020     , t)..          
   1eb98:	2c7d2020 702e6920 6f746f72 65707974       }, i.prototype
   1eba8:	6f72642e 646c4f70 61746144 66203d20     .dropOldData = f
   1ebb8:	74636e75 286e6f69 74202c65 0d7b2029     unction(e, t) {.
   1ebc8:	2020200a 20202020 20202020 20202020     .               
   1ebd8:	726f6620 61762820 20692072 3b30203d      for (var i = 0;
   1ebe8:	69687420 61642e73 6c2e6174 74676e65      this.data.lengt
   1ebf8:	202d2068 3d3e2069 26207420 68742026     h - i >= t && th
   1ec08:	642e7369 5b617461 202b2069 305b5d31     is.data[i + 1][0
   1ec18:	203c205d 20293b65 3d2b2069 0d3b3120     ] < e;) i += 1;.
   1ec28:	2020200a 20202020 20202020 20202020     .               
   1ec38:	21203020 69203d3d 20262620 73696874      0 !== i && this
   1ec48:	7461642e 70732e61 6563696c 202c3028     .data.splice(0, 
   1ec58:	0a0d2969 20202020 20202020 20202020     i)..            
   1ec68:	61202c7d 6665642e 746c7561 72616843     }, a.defaultChar
   1ec78:	74704f74 736e6f69 7b203d20 20200a0d     tOptions = {..  
   1ec88:	20202020 20202020 20202020 696d2020                   mi
   1ec98:	73696c6c 50726550 6c657869 3032203a     llisPerPixel: 20
   1eca8:	200a0d2c 20202020 20202020 20202020     ,..             
   1ecb8:	65202020 6c62616e 69704465 6c616353        enableDpiScal
   1ecc8:	3a676e69 2c302120 20200a0d 20202020     ing: !0,..      
   1ecd8:	20202020 20202020 4d792020 6f466e69               yMinFo
   1ece8:	74616d72 3a726574 6e756620 6f697463     rmatter: functio
   1ecf8:	2c65286e 20297420 200a0d7b 20202020     n(e, t) {..     
   1ed08:	20202020 20202020 20202020 72202020                    r
   1ed18:	72757465 6170206e 46657372 74616f6c     eturn parseFloat
   1ed28:	2e296528 69466f74 28646578 0a0d2974     (e).toFixed(t)..
   1ed38:	20202020 20202020 20202020 20202020                     
   1ed48:	0a0d2c7d 20202020 20202020 20202020     },..            
   1ed58:	20202020 78614d79 6d726f46 65747461         yMaxFormatte
   1ed68:	66203a72 74636e75 286e6f69 74202c65     r: function(e, t
   1ed78:	0d7b2029 2020200a 20202020 20202020     ) {..           
   1ed88:	20202020 20202020 74657220 206e7275              return 
   1ed98:	73726170 6f6c4665 65287461 6f742e29     parseFloat(e).to
   1eda8:	65786946 29742864 20200a0d 20202020     Fixed(t)..      
   1edb8:	20202020 20202020 2c7d2020 20200a0d               },..  
   1edc8:	20202020 20202020 20202020 616d2020                   ma
   1edd8:	6c615678 63536575 3a656c61 0d2c3120     xValueScale: 1,.
   1ede8:	2020200a 20202020 20202020 20202020     .               
   1edf8:	6e696d20 756c6156 61635365 203a656c      minValueScale: 
   1ee08:	0a0d2c31 20202020 20202020 20202020     1,..            
   1ee18:	20202020 65746e69 6c6f7072 6f697461         interpolatio
   1ee28:	22203a6e 697a6562 2c227265 20200a0d     n: "bezier",..  
   1ee38:	20202020 20202020 20202020 63732020                   sc
   1ee48:	53656c61 746f6f6d 676e6968 312e203a     aleSmoothing: .1
   1ee58:	0d2c3532 2020200a 20202020 20202020     25,..           
   1ee68:	20202020 78616d20 61746144 4c746553          maxDataSetL
   1ee78:	74676e65 32203a68 200a0d2c 20202020     ength: 2,..     
   1ee88:	20202020 20202020 73202020 6c6f7263                scrol
   1ee98:	6361426c 7261776b 203a7364 0d2c3121     lBackwards: !1,.
   1eea8:	2020200a 20202020 20202020 20202020     .               
   1eeb8:	69726720 7b203a64 20200a0d 20202020      grid: {..      
   1eec8:	20202020 20202020 20202020 69662020                   fi
   1eed8:	74536c6c 3a656c79 30232220 30303030     llStyle: "#00000
   1eee8:	0d2c2230 2020200a 20202020 20202020     0",..           
   1eef8:	20202020 20202020 72747320 53656b6f              strokeS
   1ef08:	656c7974 2322203a 37373737 2c223737     tyle: "#777777",
   1ef18:	20200a0d 20202020 20202020 20202020     ..              
   1ef28:	20202020 696c2020 6957656e 3a687464           lineWidth:
   1ef38:	0d2c3120 2020200a 20202020 20202020      1,..           
   1ef48:	20202020 20202020 61687320 694c7072              sharpLi
   1ef58:	3a73656e 2c312120 20200a0d 20202020     nes: !1,..      
   1ef68:	20202020 20202020 20202020 696d2020                   mi
   1ef78:	73696c6c 4c726550 3a656e69 33653120     llisPerLine: 1e3
   1ef88:	200a0d2c 20202020 20202020 20202020     ,..             
   1ef98:	20202020 76202020 69747265 536c6163            verticalS
   1efa8:	69746365 3a736e6f 0d2c3220 2020200a     ections: 2,..   
   1efb8:	20202020 20202020 20202020 20202020                     
   1efc8:	726f6220 56726564 62697369 203a656c      borderVisible: 
   1efd8:	0a0d3021 20202020 20202020 20202020     !0..            
   1efe8:	20202020 0a0d2c7d 20202020 20202020         },..        
   1eff8:	20202020 20202020 6562616c 203a736c             labels: 
   1f008:	200a0d7b 20202020 20202020 20202020     {..             
   1f018:	20202020 66202020 536c6c69 656c7974            fillStyle
   1f028:	2322203a 66666666 2c226666 20200a0d     : "#ffffff",..  
   1f038:	20202020 20202020 20202020 20202020                     
   1f048:	69642020 6c626173 203a6465 0d2c3121       disabled: !1,.
   1f058:	2020200a 20202020 20202020 20202020     .               
   1f068:	20202020 6e6f6620 7a695374 31203a65          fontSize: 1
   1f078:	0a0d2c30 20202020 20202020 20202020     0,..            
   1f088:	20202020 20202020 746e6f66 696d6146             fontFami
   1f098:	203a796c 6e6f6d22 6170736f 2c226563     ly: "monospace",
   1f0a8:	20200a0d 20202020 20202020 20202020     ..              
   1f0b8:	20202020 72702020 73696365 3a6e6f69           precision:
   1f0c8:	0a0d3220 20202020 20202020 20202020      2..            
   1f0d8:	20202020 0a0d2c7d 20202020 20202020         },..        
   1f0e8:	20202020 20202020 69726f68 746e6f7a             horizont
   1f0f8:	694c6c61 3a73656e 0d5d5b20 2020200a     alLines: []..   
   1f108:	20202020 20202020 202c7d20 6e412e61              }, a.An
   1f118:	74616d69 6d6f4365 69746170 696c6962     imateCompatibili
   1f128:	3d207974 0a0d7b20 20202020 20202020     ty = {..        
   1f138:	20202020 20202020 75716572 41747365             requestA
   1f148:	616d696e 6e6f6974 6d617246 66203a65     nimationFrame: f
   1f158:	74636e75 286e6f69 74202c65 0d7b2029     unction(e, t) {.
   1f168:	2020200a 20202020 20202020 20202020     .               
   1f178:	20202020 74657220 206e7275 6e697728          return (win
   1f188:	2e776f64 75716572 41747365 616d696e     dow.requestAnima
   1f198:	6e6f6974 6d617246 7c7c2065 6e697720     tionFrame || win
   1f1a8:	2e776f64 6b626577 65527469 73657571     dow.webkitReques
   1f1b8:	696e4174 6974616d 72466e6f 20656d61     tAnimationFrame 
   1f1c8:	77207c7c 6f646e69 6f6d2e77 7165527a     || window.mozReq
   1f1d8:	74736575 6d696e41 6f697461 6172466e     uestAnimationFra
   1f1e8:	7c20656d 6977207c 776f646e 65526f2e     me || window.oRe
   1f1f8:	73657571 696e4174 6974616d 72466e6f     questAnimationFr
   1f208:	20656d61 77207c7c 6f646e69 736d2e77     ame || window.ms
   1f218:	75716552 41747365 616d696e 6e6f6974     RequestAnimation
   1f228:	6d617246 7c7c2065 6e756620 6f697463     Frame || functio
   1f238:	2965286e 0a0d7b20 20202020 20202020     n(e) {..        
   1f248:	20202020 20202020 20202020 20202020                     
   1f258:	75746572 77206e72 6f646e69 65732e77     return window.se
   1f268:	6d695474 74756f65 6e756628 6f697463     tTimeout(functio
   1f278:	2029286e 200a0d7b 20202020 20202020     n() {..         
   1f288:	20202020 20202020 20202020 20202020                     
   1f298:	65202020 656e2828 61442077 2e296574        e((new Date).
   1f2a8:	54746567 28656d69 0a0d2929 20202020     getTime())..    
   1f2b8:	20202020 20202020 20202020 20202020                     
   1f2c8:	20202020 31202c7d 0a0d2936 20202020         }, 16)..    
   1f2d8:	20202020 20202020 20202020 20202020                     
   1f2e8:	632e297d 286c6c61 646e6977 202c776f     }).call(window, 
   1f2f8:	74202c65 200a0d29 20202020 20202020     e, t)..         
   1f308:	20202020 7d202020 200a0d2c 20202020            },..     
   1f318:	20202020 20202020 63202020 65636e61                cance
   1f328:	696e416c 6974616d 72466e6f 3a656d61     lAnimationFrame:
   1f338:	6e756620 6f697463 2965286e 0a0d7b20      function(e) {..
   1f348:	20202020 20202020 20202020 20202020                     
   1f358:	20202020 75746572 28206e72 646e6977         return (wind
   1f368:	632e776f 65636e61 696e416c 6974616d     ow.cancelAnimati
   1f378:	72466e6f 20656d61 66207c7c 74636e75     onFrame || funct
   1f388:	286e6f69 7b202965 20200a0d 20202020     ion(e) {..      
   1f398:	20202020 20202020 20202020 20202020                     
   1f3a8:	6c632020 54726165 6f656d69 65287475       clearTimeout(e
   1f3b8:	200a0d29 20202020 20202020 20202020     )..             
   1f3c8:	20202020 7d202020 61632e29 77286c6c            }).call(w
   1f3d8:	6f646e69 65202c77 200a0d29 20202020     indow, e)..     
   1f3e8:	20202020 20202020 7d202020 20200a0d                }..  
   1f3f8:	20202020 20202020 2c7d2020 642e6120               }, a.d
   1f408:	75616665 6553746c 73656972 73657250     efaultSeriesPres
   1f418:	61746e65 6e6f6974 6974704f 20736e6f     entationOptions 
   1f428:	0d7b203d 2020200a 20202020 20202020     = {..           
   1f438:	20202020 6e696c20 64695765 203a6874          lineWidth: 
   1f448:	0a0d2c31 20202020 20202020 20202020     1,..            
   1f458:	20202020 6f727473 7453656b 3a656c79         strokeStyle:
   1f468:	66232220 66666666 0a0d2266 20202020      "#ffffff"..    
   1f478:	20202020 20202020 61202c7d 6f72702e             }, a.pro
   1f488:	79746f74 612e6570 69546464 6553656d     totype.addTimeSe
   1f498:	73656972 66203d20 74636e75 286e6f69     ries = function(
   1f4a8:	69202c65 0d7b2029 2020200a 20202020     e, i) {..       
   1f4b8:	20202020 20202020 69687420 65732e73              this.se
   1f4c8:	73656972 2e746553 68737570 0a0d7b28     riesSet.push({..
   1f4d8:	20202020 20202020 20202020 20202020                     
   1f4e8:	20202020 656d6974 69726553 203a7365         timeSeries: 
   1f4f8:	0a0d2c65 20202020 20202020 20202020     e,..            
   1f508:	20202020 20202020 6974706f 3a736e6f             options:
   1f518:	652e7420 6e657478 7d7b2864 2e61202c      t.extend({}, a.
   1f528:	61666564 53746c75 65697265 65725073     defaultSeriesPre
   1f538:	746e6573 6f697461 74704f6e 736e6f69     sentationOptions
   1f548:	2969202c 20200a0d 20202020 20202020     , i)..          
   1f558:	20202020 297d2020 2e65202c 6974706f           }), e.opti
   1f568:	2e736e6f 65736572 756f4274 2073646e     ons.resetBounds 
   1f578:	65202626 74706f2e 736e6f69 7365722e     && e.options.res
   1f588:	6f427465 73646e75 65746e49 6c617672     etBoundsInterval
   1f598:	30203e20 20262620 722e6528 74657365      > 0 && (e.reset
   1f5a8:	6e756f42 69547364 4972656d 203d2064     BoundsTimerId = 
   1f5b8:	49746573 7265746e 286c6176 636e7566     setInterval(func
   1f5c8:	6e6f6974 7b202928 20200a0d 20202020     tion() {..      
   1f5d8:	20202020 20202020 20202020 2e652020                   e.
   1f5e8:	65736572 756f4274 2873646e 200a0d29     resetBounds().. 
   1f5f8:	20202020 20202020 20202020 7d202020                    }
   1f608:	2e65202c 6974706f 2e736e6f 65736572     , e.options.rese
   1f618:	756f4274 4973646e 7265746e 296c6176     tBoundsInterval)
   1f628:	200a0d29 20202020 20202020 7d202020     )..            }
   1f638:	2e61202c 746f7270 7079746f 65722e65     , a.prototype.re
   1f648:	65766f6d 656d6954 69726553 3d207365     moveTimeSeries =
   1f658:	6e756620 6f697463 2965286e 0a0d7b20      function(e) {..
   1f668:	20202020 20202020 20202020 20202020                     
   1f678:	20726f66 72617628 3d207420 69687420     for (var t = thi
   1f688:	65732e73 73656972 2e746553 676e656c     s.seriesSet.leng
   1f698:	202c6874 203d2069 69203b30 74203c20     th, i = 0; i < t
   1f6a8:	2069203b 31203d2b 200a0d29 20202020     ; i += 1)..     
   1f6b8:	20202020 20202020 20202020 69202020                    i
   1f6c8:	74282066 2e736968 69726573 65537365     f (this.seriesSe
   1f6d8:	5d695b74 6d69742e 72655365 20736569     t[i].timeSeries 
   1f6e8:	203d3d3d 7b202965 20200a0d 20202020     === e) {..      
   1f6f8:	20202020 20202020 20202020 20202020                     
   1f708:	68742020 732e7369 65697265 74655373       this.seriesSet
   1f718:	6c70732e 28656369 31202c69 0a0d3b29     .splice(i, 1);..
   1f728:	20202020 20202020 20202020 20202020                     
   1f738:	20202020 20202020 61657262 200a0d6b             break.. 
   1f748:	20202020 20202020 20202020 20202020                     
   1f758:	7d202020 20200a0d 20202020 20202020        }..          
   1f768:	20202020 2e652020 65736572 756f4274           e.resetBou
   1f778:	5473646e 72656d69 26206449 6c632026     ndsTimerId && cl
   1f788:	49726165 7265746e 286c6176 65722e65     earInterval(e.re
   1f798:	42746573 646e756f 6d695473 64497265     setBoundsTimerId
   1f7a8:	200a0d29 20202020 20202020 7d202020     )..            }
   1f7b8:	2e61202c 746f7270 7079746f 65672e65     , a.prototype.ge
   1f7c8:	6d695474 72655365 4f736569 6f697470     tTimeSeriesOptio
   1f7d8:	3d20736e 6e756620 6f697463 2965286e     ns = function(e)
   1f7e8:	0a0d7b20 20202020 20202020 20202020      {..            
   1f7f8:	20202020 20726f66 72617628 3d207420         for (var t =
   1f808:	69687420 65732e73 73656972 2e746553      this.seriesSet.
   1f818:	676e656c 202c6874 203d2069 69203b30     length, i = 0; i
   1f828:	74203c20 2069203b 31203d2b 200a0d29      < t; i += 1).. 
   1f838:	20202020 20202020 20202020 20202020                     
   1f848:	69202020 74282066 2e736968 69726573        if (this.seri
   1f858:	65537365 5d695b74 6d69742e 72655365     esSet[i].timeSer
   1f868:	20736569 203d3d3d 72202965 72757465     ies === e) retur
   1f878:	6874206e 732e7369 65697265 74655373     n this.seriesSet
   1f888:	2e5d695b 6974706f 0d736e6f 2020200a     [i].options..   
   1f898:	20202020 20202020 202c7d20 72702e61              }, a.pr
   1f8a8:	746f746f 2e657079 6e697262 466f5467     ototype.bringToF
   1f8b8:	746e6f72 66203d20 74636e75 286e6f69     ront = function(
   1f8c8:	7b202965 20200a0d 20202020 20202020     e) {..          
   1f8d8:	20202020 6f662020 76282072 74207261           for (var t
   1f8e8:	74203d20 2e736968 69726573 65537365      = this.seriesSe
   1f8f8:	656c2e74 6874676e 2069202c 3b30203d     t.length, i = 0;
   1f908:	3c206920 203b7420 3d2b2069 0d293120      i < t; i += 1).
   1f918:	2020200a 20202020 20202020 20202020     .               
   1f928:	20202020 20666920 69687428 65732e73          if (this.se
   1f938:	73656972 5b746553 742e5d69 53656d69     riesSet[i].timeS
   1f948:	65697265 3d3d2073 2965203d 0a0d7b20     eries === e) {..
   1f958:	20202020 20202020 20202020 20202020                     
   1f968:	20202020 20202020 20726176 203d2061             var a = 
   1f978:	73696874 7265732e 53736569 732e7465     this.seriesSet.s
   1f988:	63696c70 2c692865 3b293120 20200a0d     plice(i, 1);..  
   1f998:	20202020 20202020 20202020 20202020                     
   1f9a8:	20202020 68742020 732e7369 65697265           this.serie
   1f9b8:	74655373 7375702e 5b612868 3b295d30     sSet.push(a[0]);
   1f9c8:	20200a0d 20202020 20202020 20202020     ..              
   1f9d8:	20202020 20202020 72622020 0d6b6165               break.
   1f9e8:	2020200a 20202020 20202020 20202020     .               
   1f9f8:	20202020 0a0d7d20 20202020 20202020          }..        
   1fa08:	20202020 61202c7d 6f72702e 79746f74         }, a.prototy
   1fa18:	732e6570 61657274 206f546d 7566203d     pe.streamTo = fu
   1fa28:	6974636e 65286e6f 2974202c 0a0d7b20     nction(e, t) {..
   1fa38:	20202020 20202020 20202020 20202020                     
   1fa48:	73696874 6e61632e 20736176 2c65203d     this.canvas = e,
   1fa58:	69687420 65642e73 2079616c 2c74203d      this.delay = t,
   1fa68:	69687420 74732e73 28747261 200a0d29      this.start().. 
   1fa78:	20202020 20202020 7d202020 2e61202c                }, a.
   1fa88:	746f7270 7079746f 65722e65 657a6973     prototype.resize
   1fa98:	66203d20 74636e75 286e6f69 0d7b2029      = function() {.
   1faa8:	2020200a 20202020 20202020 20202020     .               
   1fab8:	20666920 69687428 706f2e73 6e6f6974      if (this.option
   1fac8:	6e652e73 656c6261 53697044 696c6163     s.enableDpiScali
   1fad8:	2620676e 69772026 776f646e 20262620     ng && window && 
   1fae8:	3d212031 6977203d 776f646e 7665642e     1 !== window.dev
   1faf8:	50656369 6c657869 69746152 7b20296f     icePixelRatio) {
   1fb08:	20200a0d 20202020 20202020 20202020     ..              
   1fb18:	20202020 61762020 20652072 6977203d           var e = wi
   1fb28:	776f646e 7665642e 50656369 6c657869     ndow.devicePixel
   1fb38:	69746152 0a0d2c6f 20202020 20202020     Ratio,..        
   1fb48:	20202020 20202020 20202020 20202020                     
   1fb58:	203d2074 73726170 746e4965 69687428     t = parseInt(thi
   1fb68:	61632e73 7361766e 7465672e 72747441     s.canvas.getAttr
   1fb78:	74756269 77222865 68746469 2c292922     ibute("width")),
   1fb88:	20200a0d 20202020 20202020 20202020     ..              
   1fb98:	20202020 20202020 20692020 6170203d               i = pa
   1fba8:	49657372 7428746e 2e736968 766e6163     rseInt(this.canv
   1fbb8:	672e7361 74417465 62697274 28657475     as.getAttribute(
   1fbc8:	69656822 22746867 0d3b2929 2020200a     "height"));..   
   1fbd8:	20202020 20202020 20202020 20202020                     
   1fbe8:	69687420 726f2e73 6e696769 69576c61      this.originalWi
   1fbf8:	20687464 4d202626 2e687461 6f6f6c66     dth && Math.floo
   1fc08:	68742872 6f2e7369 69676972 576c616e     r(this.originalW
   1fc18:	68746469 65202a20 3d3d2029 2074203d     idth * e) === t 
   1fc28:	28207c7c 73696874 69726f2e 616e6967     || (this.origina
   1fc38:	6469576c 3d206874 202c7420 73696874     lWidth = t, this
   1fc48:	6e61632e 2e736176 41746573 69727474     .canvas.setAttri
   1fc58:	65747562 69772228 22687464 614d202c     bute("width", Ma
   1fc68:	662e6874 726f6f6c 2a207428 2e296520     th.floor(t * e).
   1fc78:	74536f74 676e6972 2c292928 69687420     toString()), thi
   1fc88:	61632e73 7361766e 7974732e 772e656c     s.canvas.style.w
   1fc98:	68746469 74203d20 22202b20 2c227870     idth = t + "px",
   1fca8:	69687420 61632e73 7361766e 7465672e      this.canvas.get
   1fcb8:	746e6f43 28747865 22643222 63732e29     Context("2d").sc
   1fcc8:	28656c61 65202c65 202c2929 73696874     ale(e, e)), this
   1fcd8:	69726f2e 616e6967 6965486c 20746867     .originalHeight 
   1fce8:	4d202626 2e687461 6f6f6c66 68742872     && Math.floor(th
   1fcf8:	6f2e7369 69676972 486c616e 68676965     is.originalHeigh
   1fd08:	202a2074 3d202965 69203d3d 207c7c20     t * e) === i || 
   1fd18:	69687428 726f2e73 6e696769 65486c61     (this.originalHe
   1fd28:	74686769 69203d20 6874202c 632e7369     ight = i, this.c
   1fd38:	61766e61 65732e73 74744174 75626972     anvas.setAttribu
   1fd48:	22286574 67696568 2c227468 74614d20     te("height", Mat
   1fd58:	6c662e68 28726f6f 202a2069 742e2965     h.floor(i * e).t
   1fd68:	7274536f 28676e69 202c2929 73696874     oString()), this
   1fd78:	6e61632e 2e736176 6c797473 65682e65     .canvas.style.he
   1fd88:	74686769 69203d20 22202b20 2c227870     ight = i + "px",
   1fd98:	69687420 61632e73 7361766e 7465672e      this.canvas.get
   1fda8:	746e6f43 28747865 22643222 63732e29     Context("2d").sc
   1fdb8:	28656c61 65202c65 0a0d2929 20202020     ale(e, e))..    
   1fdc8:	20202020 20202020 20202020 200a0d7d                 }.. 
   1fdd8:	20202020 20202020 7d202020 2e61202c                }, a.
   1fde8:	746f7270 7079746f 74732e65 20747261     prototype.start 
   1fdf8:	7566203d 6974636e 29286e6f 0a0d7b20     = function() {..
   1fe08:	20202020 20202020 20202020 20202020                     
   1fe18:	28206669 69687421 72662e73 29656d61     if (!this.frame)
   1fe28:	0a0d7b20 20202020 20202020 20202020      {..            
   1fe38:	20202020 20202020 20726176 203d2065             var e = 
   1fe48:	636e7566 6e6f6974 7b202928 20200a0d     function() {..  
   1fe58:	20202020 20202020 20202020 20202020                     
   1fe68:	20202020 68742020 662e7369 656d6172           this.frame
   1fe78:	61203d20 696e412e 6574616d 706d6f43      = a.AnimateComp
   1fe88:	62697461 74696c69 65722e79 73657571     atibility.reques
   1fe98:	696e4174 6974616d 72466e6f 28656d61     tAnimationFrame(
   1fea8:	636e7566 6e6f6974 7b202928 20200a0d     function() {..  
   1feb8:	20202020 20202020 20202020 20202020                     
   1fec8:	20202020 20202020 68742020 722e7369               this.r
   1fed8:	65646e65 2c292872 29286520 20200a0d     ender(), e()..  
   1fee8:	20202020 20202020 20202020 20202020                     
   1fef8:	20202020 2e7d2020 646e6962 69687428           }.bind(thi
   1ff08:	0d292973 2020200a 20202020 20202020     s))..           
   1ff18:	20202020 20202020 622e7d20 28646e69              }.bind(
   1ff28:	73696874 0a0d3b29 20202020 20202020     this);..        
   1ff38:	20202020 20202020 20202020 0d292865                 e().
   1ff48:	2020200a 20202020 20202020 20202020     .               
   1ff58:	0a0d7d20 20202020 20202020 20202020      }..            
   1ff68:	61202c7d 6f72702e 79746f74 732e6570     }, a.prototype.s
   1ff78:	20706f74 7566203d 6974636e 29286e6f     top = function()
   1ff88:	0a0d7b20 20202020 20202020 20202020      {..            
   1ff98:	20202020 73696874 6172662e 2620656d         this.frame &
   1ffa8:	61282026 696e412e 6574616d 706d6f43     & (a.AnimateComp
   1ffb8:	62697461 74696c69 61632e79 6c65636e     atibility.cancel
   1ffc8:	6d696e41 6f697461 6172466e 7428656d     AnimationFrame(t
   1ffd8:	2e736968 6d617266 202c2965 656c6564     his.frame), dele
   1ffe8:	74206574 2e736968 6d617266 0a0d2965     te this.frame)..
   1fff8:	20202020 20202020 20202020 61202c7d                 }, a
   20008:	6f72702e 79746f74 752e6570 74616470     .prototype.updat
   20018:	6c615665 61526575 2065676e 7566203d     eValueRange = fu
   20028:	6974636e 29286e6f 0a0d7b20 20202020     nction() {..    
   20038:	20202020 20202020 20202020 20726f66                 for 
   20048:	72617628 3d206520 69687420 706f2e73     (var e = this.op
   20058:	6e6f6974 74202c73 4e203d20 65626d75     tions, t = Numbe
   20068:	614e2e72 69202c4e 4e203d20 65626d75     r.NaN, i = Numbe
   20078:	614e2e72 61202c4e 30203d20 2061203b     r.NaN, a = 0; a 
   20088:	6874203c 732e7369 65697265 74655373     < this.seriesSet
   20098:	6e656c2e 3b687467 2b206120 2931203d     .length; a += 1)
   200a8:	0a0d7b20 20202020 20202020 20202020      {..            
   200b8:	20202020 20202020 20726176 203d2073             var s = 
   200c8:	73696874 7265732e 53736569 615b7465     this.seriesSet[a
   200d8:	69742e5d 6553656d 73656972 200a0d3b     ].timeSeries;.. 
   200e8:	20202020 20202020 20202020 20202020                     
   200f8:	69202020 4e614e73 6d2e7328 61567861        isNaN(s.maxVa
   20108:	2965756c 207c7c20 3d207428 4e736920     lue) || (t = isN
   20118:	74284e61 203f2029 616d2e73 6c615678     aN(t) ? s.maxVal
   20128:	3a206575 74614d20 616d2e68 2c742878     ue : Math.max(t,
   20138:	6d2e7320 61567861 2965756c 69202c29      s.maxValue)), i
   20148:	4e614e73 6d2e7328 61566e69 2965756c     sNaN(s.minValue)
   20158:	207c7c20 3d206928 4e736920 69284e61      || (i = isNaN(i
   20168:	203f2029 696d2e73 6c61566e 3a206575     ) ? s.minValue :
   20178:	74614d20 696d2e68 2c69286e 6d2e7320      Math.min(i, s.m
   20188:	61566e69 2965756c 200a0d29 20202020     inValue))..     
   20198:	20202020 20202020 7d202020 20200a0d                }..  
   201a8:	20202020 20202020 20202020 66692020                   if
   201b8:	756e2820 21206c6c 2e65203d 5678616d      (null != e.maxV
   201c8:	65756c61 74203f20 65203d20 78616d2e     alue ? t = e.max
   201d8:	756c6156 203a2065 3d2a2074 6d2e6520     Value : t *= e.m
   201e8:	61567861 5365756c 656c6163 756e202c     axValueScale, nu
   201f8:	21206c6c 2e65203d 566e696d 65756c61     ll != e.minValue
   20208:	69203f20 65203d20 6e696d2e 756c6156      ? i = e.minValu
   20218:	203a2065 3d2d2069 74614d20 62612e68     e : i -= Math.ab
   20228:	20692873 2e65202a 566e696d 65756c61     s(i * e.minValue
   20238:	6c616353 202d2065 202c2969 73696874     Scale - i), this
   20248:	74706f2e 736e6f69 6152792e 4665676e     .options.yRangeF
   20258:	74636e75 296e6f69 0a0d7b20 20202020     unction) {..    
   20268:	20202020 20202020 20202020 20202020                     
   20278:	20726176 203d206e 73696874 74706f2e     var n = this.opt
   20288:	736e6f69 6152792e 4665676e 74636e75     ions.yRangeFunct
   20298:	286e6f69 200a0d7b 20202020 20202020     ion({..         
   202a8:	20202020 20202020 20202020 6d202020                    m
   202b8:	203a6e69 0a0d2c69 20202020 20202020     in: i,..        
   202c8:	20202020 20202020 20202020 20202020                     
   202d8:	3a78616d 0a0d7420 20202020 20202020     max: t..        
   202e8:	20202020 20202020 20202020 0d3b297d                 });.
   202f8:	2020200a 20202020 20202020 20202020     .               
   20308:	20202020 3d206920 6d2e6e20 202c6e69          i = n.min, 
   20318:	203d2074 616d2e6e 200a0d78 20202020     t = n.max..     
   20328:	20202020 20202020 7d202020 20200a0d                }..  
   20338:	20202020 20202020 20202020 66692020                   if
   20348:	69212820 4e614e73 20297428 21202626      (!isNaN(t) && !
   20358:	614e7369 2969284e 0d7b2029 2020200a     isNaN(i)) {..   
   20368:	20202020 20202020 20202020 20202020                     
   20378:	72617620 3d207220 2d207420 2d206920      var r = t - i -
   20388:	69687420 75632e73 6e657272 6c615674      this.currentVal
   20398:	61526575 2c65676e 20200a0d 20202020     ueRange,..      
   203a8:	20202020 20202020 20202020 20202020                     
   203b8:	206c2020 2069203d 6874202d 632e7369       l = i - this.c
   203c8:	65727275 6956746e 6e694d73 756c6156     urrentVisMinValu
   203d8:	0a0d3b65 20202020 20202020 20202020     e;..            
   203e8:	20202020 20202020 73696874 4173692e             this.isA
   203f8:	616d696e 676e6974 6c616353 203d2065     nimatingScale = 
   20408:	6874614d 7362612e 20297228 312e203e     Math.abs(r) > .1
   20418:	207c7c20 6874614d 7362612e 20296c28      || Math.abs(l) 
   20428:	312e203e 6874202c 632e7369 65727275     > .1, this.curre
   20438:	6156746e 5265756c 65676e61 203d2b20     ntValueRange += 
   20448:	63732e65 53656c61 746f6f6d 676e6968     e.scaleSmoothing
   20458:	72202a20 6874202c 632e7369 65727275      * r, this.curre
   20468:	6956746e 6e694d73 756c6156 3d2b2065     ntVisMinValue +=
   20478:	732e6520 656c6163 6f6f6d53 6e696874      e.scaleSmoothin
   20488:	202a2067 200a0d6c 20202020 20202020     g * l..         
   20498:	20202020 7d202020 20200a0d 20202020            }..      
   204a8:	20202020 20202020 68742020 762e7369               this.v
   204b8:	65756c61 676e6152 203d2065 200a0d7b     alueRange = {.. 
   204c8:	20202020 20202020 20202020 20202020                     
   204d8:	6d202020 203a6e69 0a0d2c69 20202020        min: i,..    
   204e8:	20202020 20202020 20202020 20202020                     
   204f8:	3a78616d 0a0d7420 20202020 20202020     max: t..        
   20508:	20202020 20202020 200a0d7d 20202020             }..     
   20518:	20202020 7d202020 2e61202c 746f7270            }, a.prot
   20528:	7079746f 65722e65 7265646e 66203d20     otype.render = f
   20538:	74636e75 286e6f69 74202c65 0d7b2029     unction(e, t) {.
   20548:	2020200a 20202020 20202020 20202020     .               
   20558:	72617620 3d206920 656e2820 61442077      var i = (new Da
   20568:	2e296574 54746567 28656d69 0a0d3b29     te).getTime();..
   20578:	20202020 20202020 20202020 20202020                     
   20588:	28206669 69687421 73692e73 6d696e41     if (!this.isAnim
   20598:	6e697461 61635367 2029656c 200a0d7b     atingScale) {.. 
   205a8:	20202020 20202020 20202020 20202020                     
   205b8:	76202020 61207261 4d203d20 2e687461        var a = Math.
   205c8:	286e696d 20336531 2c36202f 69687420     min(1e3 / 6, thi
   205d8:	706f2e73 6e6f6974 696d2e73 73696c6c     s.options.millis
   205e8:	50726550 6c657869 0a0d3b29 20202020     PerPixel);..    
   205f8:	20202020 20202020 20202020 20202020                     
   20608:	28206669 202d2069 73696874 73616c2e     if (i - this.las
   20618:	6e655274 54726564 4d656d69 696c6c69     tRenderTimeMilli
   20628:	203c2073 72202961 72757465 200a0d6e     s < a) return.. 
   20638:	20202020 20202020 20202020 7d202020                    }
   20648:	20200a0d 20202020 20202020 20202020     ..              
   20658:	68742020 722e7369 7a697365 2c292865       this.resize(),
   20668:	69687420 616c2e73 65527473 7265646e      this.lastRender
   20678:	656d6954 6c6c694d 3d207369 202c6920     TimeMillis = i, 
   20688:	203d2065 7c7c2065 69687420 61632e73     e = e || this.ca
   20698:	7361766e 2074202c 2074203d 69207c7c     nvas, t = t || i
   206a8:	28202d20 73696874 6c65642e 7c207961      - (this.delay |
   206b8:	2930207c 2074202c 74203d2d 74202520     | 0), t -= t % t
   206c8:	2e736968 6974706f 2e736e6f 6c6c696d     his.options.mill
   206d8:	65507369 78695072 0d3b6c65 2020200a     isPerPixel;..   
   206e8:	20202020 20202020 20202020 72617620                  var
   206f8:	3d207320 672e6520 6f437465 7865746e      s = e.getContex
   20708:	32222874 2c292264 20200a0d 20202020     t("2d"),..      
   20718:	20202020 20202020 20202020 206e2020                   n 
   20728:	6874203d 6f2e7369 6f697470 0d2c736e     = this.options,.
   20738:	2020200a 20202020 20202020 20202020     .               
   20748:	20202020 3d207220 0a0d7b20 20202020          r = {..    
   20758:	20202020 20202020 20202020 20202020                     
   20768:	20202020 3a706f74 0d2c3020 2020200a         top: 0,..   
   20778:	20202020 20202020 20202020 20202020                     
   20788:	20202020 66656c20 30203a74 200a0d2c          left: 0,.. 
   20798:	20202020 20202020 20202020 20202020                     
   207a8:	20202020 77202020 68746469 2e65203a            width: e.
   207b8:	65696c63 6957746e 2c687464 20200a0d     clientWidth,..  
   207c8:	20202020 20202020 20202020 20202020                     
   207d8:	20202020 65682020 74686769 2e65203a           height: e.
   207e8:	65696c63 6548746e 74686769 20200a0d     clientHeight..  
   207f8:	20202020 20202020 20202020 20202020                     
   20808:	2c7d2020 20200a0d 20202020 20202020       },..          
   20818:	20202020 20202020 206c2020 2074203d               l = t 
   20828:	2e72202d 74646977 202a2068 696d2e6e     - r.width * n.mi
   20838:	73696c6c 50726550 6c657869 200a0d2c     llisPerPixel,.. 
   20848:	20202020 20202020 20202020 20202020                     
   20858:	6f202020 66203d20 74636e75 286e6f69        o = function(
   20868:	7b202965 20200a0d 20202020 20202020     e) {..          
   20878:	20202020 20202020 20202020 61762020                   va
   20888:	20742072 2065203d 6874202d 632e7369     r t = e - this.c
   20898:	65727275 6956746e 6e694d73 756c6156     urrentVisMinValu
   208a8:	0a0d3b65 20202020 20202020 20202020     e;..            
   208b8:	20202020 20202020 20202020 75746572                 retu
   208c8:	30206e72 3d3d3d20 69687420 75632e73     rn 0 === this.cu
   208d8:	6e657272 6c615674 61526575 2065676e     rrentValueRange 
   208e8:	2e72203f 67696568 3a207468 682e7220     ? r.height : r.h
   208f8:	68676965 202d2074 6874614d 756f722e     eight - Math.rou
   20908:	7428646e 74202f20 2e736968 72727563     nd(t / this.curr
   20918:	56746e65 65756c61 676e6152 202a2065     entValueRange * 
   20928:	65682e72 74686769 200a0d29 20202020     r.height)..     
   20938:	20202020 20202020 20202020 7d202020                    }
   20948:	6e69622e 68742864 2c297369 20200a0d     .bind(this),..  
   20958:	20202020 20202020 20202020 20202020                     
   20968:	20682020 7566203d 6974636e 65286e6f       h = function(e
   20978:	0d7b2029 2020200a 20202020 20202020     ) {..           
   20988:	20202020 20202020 20202020 74657220                  ret
   20998:	206e7275 63732e6e 6c6c6f72 6b636142     urn n.scrollBack
   209a8:	64726177 203f2073 6874614d 756f722e     wards ? Math.rou
   209b8:	2828646e 202d2074 2f202965 6d2e6e20     nd((t - e) / n.m
   209c8:	696c6c69 72655073 65786950 3a20296c     illisPerPixel) :
   209d8:	74614d20 6f722e68 28646e75 69772e72      Math.round(r.wi
   209e8:	20687464 7428202d 65202d20 202f2029     dth - (t - e) / 
   209f8:	696d2e6e 73696c6c 50726550 6c657869     n.millisPerPixel
   20a08:	200a0d29 20202020 20202020 20202020     )..             
   20a18:	20202020 7d202020 200a0d3b 20202020            };..     
   20a28:	20202020 20202020 69202020 74282066                if (t
   20a38:	2e736968 61647075 61566574 5265756c     his.updateValueR
   20a48:	65676e61 202c2928 6f662e73 3d20746e     ange(), s.font =
   20a58:	6c2e6e20 6c656261 6f662e73 6953746e      n.labels.fontSi
   20a68:	2b20657a 78702220 2b202220 6c2e6e20     ze + "px " + n.l
   20a78:	6c656261 6f662e73 6146746e 796c696d     abels.fontFamily
   20a88:	2e73202c 65766173 202c2928 72742e73     , s.save(), s.tr
   20a98:	6c736e61 28657461 656c2e72 202c7466     anslate(r.left, 
   20aa8:	6f742e72 202c2970 65622e73 506e6967     r.top), s.beginP
   20ab8:	28687461 73202c29 6365722e 2c302874     ath(), s.rect(0,
   20ac8:	202c3020 69772e72 2c687464 682e7220      0, r.width, r.h
   20ad8:	68676965 202c2974 6c632e73 29287069     eight), s.clip()
   20ae8:	2e73202c 65766173 202c2928 69662e73     , s.save(), s.fi
   20af8:	74536c6c 20656c79 2e6e203d 64697267     llStyle = n.grid
   20b08:	6c69662e 7974536c 202c656c 6c632e73     .fillStyle, s.cl
   20b18:	52726165 28746365 30202c30 2e72202c     earRect(0, 0, r.
   20b28:	74646977 72202c68 6965682e 29746867     width, r.height)
   20b38:	2e73202c 6c6c6966 74636552 202c3028     , s.fillRect(0, 
   20b48:	72202c30 6469772e 202c6874 65682e72     0, r.width, r.he
   20b58:	74686769 73202c29 7365722e 65726f74     ight), s.restore
   20b68:	202c2928 61732e73 29286576 2e73202c     (), s.save(), s.
   20b78:	656e696c 74646957 203d2068 72672e6e     lineWidth = n.gr
   20b88:	6c2e6469 57656e69 68746469 2e73202c     id.lineWidth, s.
   20b98:	6f727473 7453656b 20656c79 2e6e203d     strokeStyle = n.
   20ba8:	64697267 7274732e 53656b6f 656c7974     grid.strokeStyle
   20bb8:	2e6e202c 64697267 6c696d2e 5073696c     , n.grid.millisP
   20bc8:	694c7265 3e20656e 20293020 200a0d7b     erLine > 0) {.. 
   20bd8:	20202020 20202020 20202020 20202020                     
   20be8:	73202020 6765622e 61506e69 29286874        s.beginPath()
   20bf8:	200a0d3b 20202020 20202020 20202020     ;..             
   20c08:	20202020 66202020 2820726f 20726176            for (var 
   20c18:	203d2064 202d2074 20252074 72672e6e     d = t - t % n.gr
   20c28:	6d2e6469 696c6c69 72655073 656e694c     id.millisPerLine
   20c38:	2064203b 6c203d3e 2064203b 6e203d2d     ; d >= l; d -= n
   20c48:	6972672e 696d2e64 73696c6c 4c726550     .grid.millisPerL
   20c58:	29656e69 0a0d7b20 20202020 20202020     ine) {..        
   20c68:	20202020 20202020 20202020 20202020                     
   20c78:	20726176 203d2075 29642868 200a0d3b     var u = h(d);.. 
   20c88:	20202020 20202020 20202020 20202020                     
   20c98:	20202020 6e202020 6972672e 68732e64            n.grid.sh
   20ca8:	4c707261 73656e69 20262620 2d207528     arpLines && (u -
   20cb8:	352e203d 73202c29 766f6d2e 286f5465     = .5), s.moveTo(
   20cc8:	30202c75 73202c29 6e696c2e 286f5465     u, 0), s.lineTo(
   20cd8:	72202c75 6965682e 29746867 20200a0d     u, r.height)..  
   20ce8:	20202020 20202020 20202020 20202020                     
   20cf8:	0d7d2020 2020200a 20202020 20202020       }..           
   20d08:	20202020 20202020 732e7320 6b6f7274              s.strok
   20d18:	2c292865 632e7320 65736f6c 68746150     e(), s.closePath
   20d28:	0a0d2928 20202020 20202020 20202020     ()..            
   20d38:	20202020 200a0d7d 20202020 20202020         }..         
   20d48:	20202020 66202020 2820726f 20726176            for (var 
   20d58:	203d206d 6d203b31 6e203c20 6972672e     m = 1; m < n.gri
   20d68:	65762e64 63697472 65536c61 6f697463     d.verticalSectio
   20d78:	203b736e 3d2b206d 20293120 200a0d7b     ns; m += 1) {.. 
   20d88:	20202020 20202020 20202020 20202020                     
   20d98:	76202020 63207261 4d203d20 2e687461        var c = Math.
   20da8:	6e756f72 206d2864 2e72202a 67696568     round(m * r.heig
   20db8:	2f207468 672e6e20 2e646972 74726576     ht / n.grid.vert
   20dc8:	6c616369 74636553 736e6f69 0a0d3b29     icalSections);..
   20dd8:	20202020 20202020 20202020 20202020                     
   20de8:	20202020 72672e6e 732e6469 70726168         n.grid.sharp
   20df8:	656e694c 26262073 20632820 2e203d2d     Lines && (c -= .
   20e08:	202c2935 65622e73 506e6967 28687461     5), s.beginPath(
   20e18:	73202c29 766f6d2e 286f5465 63202c30     ), s.moveTo(0, c
   20e28:	73202c29 6e696c2e 286f5465 69772e72     ), s.lineTo(r.wi
   20e38:	2c687464 2c296320 732e7320 6b6f7274     dth, c), s.strok
   20e48:	2c292865 632e7320 65736f6c 68746150     e(), s.closePath
   20e58:	0a0d2928 20202020 20202020 20202020     ()..            
   20e68:	20202020 200a0d7d 20202020 20202020         }..         
   20e78:	20202020 69202020 6e282066 6972672e            if (n.gri
   20e88:	6f622e64 72656472 69736956 20656c62     d.borderVisible 
   20e98:	28202626 65622e73 506e6967 28687461     && (s.beginPath(
   20ea8:	73202c29 7274732e 52656b6f 28746365     ), s.strokeRect(
   20eb8:	30202c30 2e72202c 74646977 72202c68     0, 0, r.width, r
   20ec8:	6965682e 29746867 2e73202c 736f6c63     .height), s.clos
   20ed8:	74615065 29292868 2e73202c 74736572     ePath()), s.rest
   20ee8:	2865726f 6e202c29 726f682e 6e6f7a69     ore(), n.horizon
   20ef8:	4c6c6174 73656e69 20262620 6f682e6e     talLines && n.ho
   20f08:	6f7a6972 6c61746e 656e694c 656c2e73     rizontalLines.le
   20f18:	6874676e 200a0d29 20202020 20202020     ngth)..         
   20f28:	20202020 20202020 66202020 2820726f                for (
   20f38:	20726176 203d2066 66203b30 6e203c20     var f = 0; f < n
   20f48:	726f682e 6e6f7a69 4c6c6174 73656e69     .horizontalLines
   20f58:	6e656c2e 3b687467 2b206620 2931203d     .length; f += 1)
   20f68:	0a0d7b20 20202020 20202020 20202020      {..            
   20f78:	20202020 20202020 20202020 20726176                 var 
   20f88:	203d2067 6f682e6e 6f7a6972 6c61746e     g = n.horizontal
   20f98:	656e694c 5d665b73 200a0d2c 20202020     Lines[f],..     
   20fa8:	20202020 20202020 20202020 20202020                     
   20fb8:	20202020 70202020 4d203d20 2e687461            p = Math.
   20fc8:	6e756f72 286f2864 61762e67 2965756c     round(o(g.value)
   20fd8:	202d2029 0d3b352e 2020200a 20202020     ) - .5;..       
   20fe8:	20202020 20202020 20202020 20202020                     
   20ff8:	732e7320 6b6f7274 79745365 3d20656c      s.strokeStyle =
   21008:	632e6720 726f6c6f 207c7c20 66662322      g.color || "#ff
   21018:	66666666 73202c22 6e696c2e 64695765     ffff", s.lineWid
   21028:	3d206874 6c2e6720 57656e69 68746469     th = g.lineWidth
   21038:	207c7c20 73202c31 6765622e 61506e69      || 1, s.beginPa
   21048:	29286874 2e73202c 65766f6d 30286f54     th(), s.moveTo(0
   21058:	2970202c 2e73202c 656e696c 72286f54     , p), s.lineTo(r
   21068:	6469772e 202c6874 202c2970 74732e73     .width, p), s.st
   21078:	656b6f72 202c2928 6c632e73 5065736f     roke(), s.closeP
   21088:	28687461 200a0d29 20202020 20202020     ath()..         
   21098:	20202020 20202020 7d202020 20200a0d                }..  
   210a8:	20202020 20202020 20202020 6f662020                   fo
   210b8:	76282072 53207261 30203d20 2053203b     r (var S = 0; S 
   210c8:	6874203c 732e7369 65697265 74655373     < this.seriesSet
   210d8:	6e656c2e 3b687467 2b205320 2931203d     .length; S += 1)
   210e8:	0a0d7b20 20202020 20202020 20202020      {..            
   210f8:	20202020 20202020 61732e73 29286576             s.save()
   21108:	200a0d3b 20202020 20202020 20202020     ;..             
   21118:	20202020 76202020 76207261 74203d20            var v = t
   21128:	2e736968 69726573 65537365 5d535b74     his.seriesSet[S]
   21138:	6d69742e 72655365 2c736569 20200a0d     .timeSeries,..  
   21148:	20202020 20202020 20202020 20202020                     
   21158:	20202020 20772020 2e76203d 61746164           w = v.data
   21168:	200a0d2c 20202020 20202020 20202020     ,..             
   21178:	20202020 20202020 78202020 74203d20                x = t
   21188:	2e736968 69726573 65537365 5d535b74     his.seriesSet[S]
   21198:	74706f2e 736e6f69 200a0d3b 20202020     .options;..     
   211a8:	20202020 20202020 20202020 76202020                    v
   211b8:	6f72642e 646c4f70 61746144 202c6c28     .dropOldData(l, 
   211c8:	616d2e6e 74614478 74655361 676e654c     n.maxDataSetLeng
   211d8:	2c296874 6c2e7320 57656e69 68746469     th), s.lineWidth
   211e8:	78203d20 6e696c2e 64695765 202c6874      = x.lineWidth, 
   211f8:	74732e73 656b6f72 6c797453 203d2065     s.strokeStyle = 
   21208:	74732e78 656b6f72 6c797453 73202c65     x.strokeStyle, s
   21218:	6765622e 61506e69 29286874 200a0d3b     .beginPath();.. 
   21228:	20202020 20202020 20202020 20202020                     
   21238:	66202020 2820726f 20726176 203d2079        for (var y = 
   21248:	62202c30 30203d20 2056202c 2c30203d     0, b = 0, V = 0,
   21258:	3d205420 203b3020 203c2054 656c2e77      T = 0; T < w.le
   21268:	6874676e 20262620 3d212031 2e77203d     ngth && 1 !== w.
   21278:	676e656c 203b6874 3d2b2054 20293120     length; T += 1) 
   21288:	200a0d7b 20202020 20202020 20202020     {..             
   21298:	20202020 20202020 76202020 4e207261                var N
   212a8:	68203d20 545b7728 5d305b5d 0a0d2c29      = h(w[T][0]),..
   212b8:	20202020 20202020 20202020 20202020                     
   212c8:	20202020 20202020 20202020 203d2050                 P = 
   212d8:	5b77286f 315b5d54 0d3b295d 2020200a     o(w[T][1]);..   
   212e8:	20202020 20202020 20202020 20202020                     
   212f8:	20202020 20666920 3d203028 54203d3d          if (0 === T
   21308:	20792029 2c4e203d 6d2e7320 5465766f     ) y = N, s.moveT
   21318:	2c4e286f 3b295020 20200a0d 20202020     o(N, P);..      
   21328:	20202020 20202020 20202020 20202020                     
   21338:	6c652020 73206573 63746977 6e282068       else switch (n
   21348:	746e692e 6f707265 6974616c 20296e6f     .interpolation) 
   21358:	200a0d7b 20202020 20202020 20202020     {..             
   21368:	20202020 20202020 20202020 63202020                    c
   21378:	20657361 6e696c22 22726165 200a0d3a     ase "linear":.. 
   21388:	20202020 20202020 20202020 20202020                     
   21398:	20202020 20202020 63202020 20657361                case 
   213a8:	6e696c22 0d3a2265 2020200a 20202020     "line":..       
   213b8:	20202020 20202020 20202020 20202020                     
   213c8:	20202020 20202020 6c2e7320 54656e69              s.lineT
   213d8:	2c4e286f 3b295020 20200a0d 20202020     o(N, P);..      
   213e8:	20202020 20202020 20202020 20202020                     
   213f8:	20202020 20202020 72622020 3b6b6165               break;
   21408:	20200a0d 20202020 20202020 20202020     ..              
   21418:	20202020 20202020 20202020 61632020                   ca
   21428:	22206573 697a6562 3a227265 20200a0d     se "bezier":..  
   21438:	20202020 20202020 20202020 20202020                     
   21448:	20202020 20202020 65642020 6c756166               defaul
   21458:	0a0d3a74 20202020 20202020 20202020     t:..            
   21468:	20202020 20202020 20202020 20202020                     
   21478:	20202020 65622e73 7265697a 76727543         s.bezierCurv
   21488:	286f5465 6874614d 756f722e 2828646e     eTo(Math.round((
   21498:	202b2062 2f20294e 2c293220 202c5620     b + N) / 2), V, 
   214a8:	6874614d 756f722e 6228646e 4e202b20     Math.round(b + N
   214b8:	202f2029 50202c32 2c4e202c 3b295020     ) / 2, P, N, P);
   214c8:	20200a0d 20202020 20202020 20202020     ..              
   214d8:	20202020 20202020 20202020 20202020                     
   214e8:	72622020 3b6b6165 20200a0d 20202020       break;..      
   214f8:	20202020 20202020 20202020 20202020                     
   21508:	20202020 61632020 22206573 70657473           case "step
   21518:	0a0d3a22 20202020 20202020 20202020     ":..            
   21528:	20202020 20202020 20202020 20202020                     
   21538:	20202020 696c2e73 6f54656e 202c4e28         s.lineTo(N, 
   21548:	202c2956 696c2e73 6f54656e 202c4e28     V), s.lineTo(N, 
   21558:	0a0d2950 20202020 20202020 20202020     P)..            
   21568:	20202020 20202020 20202020 200a0d7d                 }.. 
   21578:	20202020 20202020 20202020 20202020                     
   21588:	20202020 62202020 4e203d20 2056202c            b = N, V 
   21598:	0d50203d 2020200a 20202020 20202020     = P..           
   215a8:	20202020 20202020 0a0d7d20 20202020              }..    
   215b8:	20202020 20202020 20202020 20202020                     
   215c8:	656c2e77 6874676e 31203e20 20262620     w.length > 1 && 
   215d8:	662e7828 536c6c69 656c7974 20262620     (x.fillStyle && 
   215e8:	6c2e7328 54656e69 2e72286f 74646977     (s.lineTo(r.widt
   215f8:	202b2068 696c2e78 6957656e 20687464     h + x.lineWidth 
   21608:	2c31202b 2c295620 6c2e7320 54656e69     + 1, V), s.lineT
   21618:	2e72286f 74646977 202b2068 696c2e78     o(r.width + x.li
   21628:	6957656e 20687464 2c31202b 682e7220     neWidth + 1, r.h
   21638:	68676965 202b2074 696c2e78 6957656e     eight + x.lineWi
   21648:	20687464 2931202b 2e73202c 656e696c     dth + 1), s.line
   21658:	79286f54 2e72202c 67696568 2b207468     To(y, r.height +
   21668:	6c2e7820 57656e69 68746469 73202c29      x.lineWidth), s
   21678:	6c69662e 7974536c 3d20656c 662e7820     .fillStyle = x.f
   21688:	536c6c69 656c7974 2e73202c 6c6c6966     illStyle, s.fill
   21698:	2c292928 732e7820 6b6f7274 79745365     ()), x.strokeSty
   216a8:	2620656c 6e222026 22656e6f 3d3d2120     le && "none" !==
   216b8:	732e7820 6b6f7274 79745365 2620656c      x.strokeStyle &
   216c8:	2e732026 6f727473 2928656b 2e73202c     & s.stroke(), s.
   216d8:	736f6c63 74615065 29292868 2e73202c     closePath()), s.
   216e8:	74736572 2865726f 200a0d29 20202020     restore()..     
   216f8:	20202020 20202020 7d202020 20200a0d                }..  
   21708:	20202020 20202020 20202020 66692020                   if
   21718:	6e212820 62616c2e 2e736c65 61736964      (!n.labels.disa
   21728:	64656c62 20262620 4e736921 74284e61     bled && !isNaN(t
   21738:	2e736968 756c6176 6e615265 6d2e6567     his.valueRange.m
   21748:	20296e69 21202626 614e7369 6874284e     in) && !isNaN(th
   21758:	762e7369 65756c61 676e6152 616d2e65     is.valueRange.ma
   21768:	20292978 200a0d7b 20202020 20202020     x)) {..         
   21778:	20202020 20202020 76202020 4d207261                var M
   21788:	6e203d20 614d792e 726f4678 7474616d      = n.yMaxFormatt
   21798:	74287265 2e736968 756c6176 6e615265     er(this.valueRan
   217a8:	6d2e6567 202c7861 616c2e6e 736c6562     ge.max, n.labels
   217b8:	6572702e 69736963 2c296e6f 20200a0d     .precision),..  
   217c8:	20202020 20202020 20202020 20202020                     
   217d8:	20202020 206b2020 2e6e203d 6e694d79           k = n.yMin
   217e8:	6d726f46 65747461 68742872 762e7369     Formatter(this.v
   217f8:	65756c61 676e6152 696d2e65 6e202c6e     alueRange.min, n
   21808:	62616c2e 2e736c65 63657270 6f697369     .labels.precisio
   21818:	0d2c296e 2020200a 20202020 20202020     n),..           
   21828:	20202020 20202020 20202020 3d204620                  F =
   21838:	732e6e20 6c6f7263 6361426c 7261776b      n.scrollBackwar
   21848:	3f207364 3a203020 772e7220 68746469     ds ? 0 : r.width
   21858:	73202d20 61656d2e 65727573 74786554      - s.measureText
   21868:	2e294d28 74646977 202d2068 0a0d2c32     (M).width - 2,..
   21878:	20202020 20202020 20202020 20202020                     
   21888:	20202020 20202020 203d2052 63732e6e             R = n.sc
   21898:	6c6c6f72 6b636142 64726177 203f2073     rollBackwards ? 
   218a8:	203a2030 69772e72 20687464 2e73202d     0 : r.width - s.
   218b8:	7361656d 54657275 28747865 772e296b     measureText(k).w
   218c8:	68746469 32202d20 200a0d3b 20202020     idth - 2;..     
   218d8:	20202020 20202020 20202020 73202020                    s
   218e8:	6c69662e 7974536c 3d20656c 6c2e6e20     .fillStyle = n.l
   218f8:	6c656261 69662e73 74536c6c 2c656c79     abels.fillStyle,
   21908:	662e7320 546c6c69 28747865 46202c4d      s.fillText(M, F
   21918:	2e6e202c 6562616c 662e736c 53746e6f     , n.labels.fontS
   21928:	29657a69 2e73202c 6c6c6966 74786554     ize), s.fillText
   21938:	202c6b28 72202c52 6965682e 20746867     (k, R, r.height 
   21948:	2932202d 20200a0d 20202020 20202020     - 2)..          
   21958:	20202020 0d7d2020 2020200a 20202020           }..       
   21968:	20202020 20202020 20666920 742e6e28              if (n.t
   21978:	73656d69 706d6174 6d726f46 65747461     imestampFormatte
   21988:	26262072 672e6e20 2e646972 6c6c696d     r && n.grid.mill
   21998:	65507369 6e694c72 203e2065 7b202930     isPerLine > 0) {
   219a8:	20200a0d 20202020 20202020 20202020     ..              
   219b8:	20202020 61762020 20412072 2e6e203d           var A = n.
   219c8:	6f726373 61426c6c 61776b63 20736472     scrollBackwards 
   219d8:	2e73203f 7361656d 54657275 28747865     ? s.measureText(
   219e8:	772e296b 68746469 72203a20 6469772e     k).width : r.wid
   219f8:	2d206874 6d2e7320 75736165 65546572     th - s.measureTe
   21a08:	6b287478 69772e29 20687464 3b34202b     xt(k).width + 4;
   21a18:	20200a0d 20202020 20202020 20202020     ..              
   21a28:	20202020 6f662020 64282072 74203d20           for (d = t
   21a38:	74202d20 6e202520 6972672e 696d2e64      - t % n.grid.mi
   21a48:	73696c6c 4c726550 3b656e69 3e206420     llisPerLine; d >
   21a58:	3b6c203d 2d206420 2e6e203d 64697267     = l; d -= n.grid
   21a68:	6c696d2e 5073696c 694c7265 2029656e     .millisPerLine) 
   21a78:	200a0d7b 20202020 20202020 20202020     {..             
   21a88:	20202020 20202020 75202020 68203d20                u = h
   21a98:	3b296428 20200a0d 20202020 20202020     (d);..          
   21aa8:	20202020 20202020 20202020 66692020                   if
   21ab8:	6e212820 7263732e 426c6c6f 776b6361      (!n.scrollBackw
   21ac8:	73647261 20262620 203c2075 7c7c2041     ards && u < A ||
   21ad8:	732e6e20 6c6f7263 6361426c 7261776b      n.scrollBackwar
   21ae8:	26207364 20752026 2941203e 0a0d7b20     ds && u > A) {..
   21af8:	20202020 20202020 20202020 20202020                     
   21b08:	20202020 20202020 20202020 20726176                 var 
   21b18:	203d2042 2077656e 65746144 2c296428     B = new Date(d),
   21b28:	20200a0d 20202020 20202020 20202020     ..              
   21b38:	20202020 20202020 20202020 20202020                     
   21b48:	204c2020 2e6e203d 656d6974 6d617473       L = n.timestam
   21b58:	726f4670 7474616d 42287265 0a0d2c29     pFormatter(B),..
   21b68:	20202020 20202020 20202020 20202020                     
   21b78:	20202020 20202020 20202020 20202020                     
   21b88:	203d2057 656d2e73 72757361 78655465     W = s.measureTex
   21b98:	294c2874 6469772e 0d3b6874 2020200a     t(L).width;..   
   21ba8:	20202020 20202020 20202020 20202020                     
   21bb8:	20202020 20202020 3d204120 732e6e20              A = n.s
   21bc8:	6c6f7263 6361426c 7261776b 3f207364     crollBackwards ?
   21bd8:	2b207520 2b205720 3a203220 2d207520      u + W + 2 : u -
   21be8:	2d205720 202c3220 69662e73 74536c6c      W - 2, s.fillSt
   21bf8:	20656c79 2e6e203d 6562616c 662e736c     yle = n.labels.f
   21c08:	536c6c69 656c7974 2e6e202c 6f726373     illStyle, n.scro
   21c18:	61426c6c 61776b63 20736472 2e73203f     llBackwards ? s.
   21c28:	6c6c6966 74786554 202c4c28 72202c75     fillText(L, u, r
   21c38:	6965682e 20746867 2932202d 73203a20     .height - 2) : s
   21c48:	6c69662e 7865546c 2c4c2874 2d207520     .fillText(L, u -
   21c58:	202c5720 65682e72 74686769 32202d20      W, r.height - 2
   21c68:	200a0d29 20202020 20202020 20202020     )..             
   21c78:	20202020 20202020 7d202020 20200a0d                }..  
   21c88:	20202020 20202020 20202020 20202020                     
   21c98:	0d7d2020 2020200a 20202020 20202020       }..           
   21ca8:	20202020 0a0d7d20 20202020 20202020          }..        
   21cb8:	20202020 20202020 65722e73 726f7473             s.restor
   21cc8:	0d292865 2020200a 20202020 20202020     e()..           
   21cd8:	202c7d20 69742e61 6f46656d 74616d72      }, a.timeFormat
   21ce8:	20726574 7566203d 6974636e 65286e6f     ter = function(e
   21cf8:	0d7b2029 2020200a 20202020 20202020     ) {..           
   21d08:	20202020 6e756620 6f697463 2874206e          function t(
   21d18:	7b202965 20200a0d 20202020 20202020     e) {..          
   21d28:	20202020 20202020 65722020 6e727574               return
   21d38:	20652820 3031203c 22203f20 3a202230      (e < 10 ? "0" :
   21d48:	29222220 65202b20 20200a0d 20202020      "") + e..      
   21d58:	20202020 20202020 0d7d2020 2020200a               }..   
   21d68:	20202020 20202020 20202020 74657220                  ret
   21d78:	206e7275 2e652874 48746567 7372756f     urn t(e.getHours
   21d88:	20292928 3a22202b 202b2022 2e652874     ()) + ":" + t(e.
   21d98:	4d746567 74756e69 29287365 202b2029     getMinutes()) + 
   21da8:	20223a22 2874202b 65672e65 63655374     ":" + t(e.getSec
   21db8:	73646e6f 0d292928 2020200a 20202020     onds())..       
   21dc8:	20202020 202c7d20 69542e65 6553656d          }, e.TimeSe
   21dd8:	73656972 69203d20 2e65202c 6f6f6d53     ries = i, e.Smoo
   21de8:	65696874 72616843 203d2074 200a0d61     thieChart = a.. 
   21df8:	20202020 7d202020 6e752228 69666564            }("undefi
   21e08:	2264656e 203d3d20 65707974 6520666f     ned" == typeof e
   21e18:	726f7078 3f207374 69687420 203a2073     xports ? this : 
   21e28:	6f707865 29737472 0d0a0d3b 0d0a0d0a     exports);.......
   21e38:	200a0d0a 20202020 66202020 74636e75     ...        funct
   21e48:	206e6f69 64616f6c 61746144 7b202928     ion loadData() {
   21e58:	20200a0d 20202020 20202020 61762020     ..            va
   21e68:	3b722072 20200a0d 20202020 20202020     r r;..          
   21e78:	72742020 0d7b2079 2020200a 20202020       try {..       
   21e88:	20202020 20202020 3d207220 77656e20              r = new
   21e98:	4c4d5820 70747448 75716552 28747365      XMLHttpRequest(
   21ea8:	200a0d29 20202020 20202020 7d202020     )..            }
   21eb8:	74616320 28206863 7b202965 20200a0d      catch (e) {..  
   21ec8:	20202020 20202020 20202020 72742020                   tr
   21ed8:	0d7b2079 2020200a 20202020 20202020     y {..           
   21ee8:	20202020 20202020 3d207220 77656e20              r = new
   21ef8:	74634120 58657669 656a624f 22287463      ActiveXObject("
   21f08:	6d78734d 582e326c 54484c4d 29225054     Msxml2.XMLHTTP")
   21f18:	20200a0d 20202020 20202020 20202020     ..              
   21f28:	207d2020 63746163 65282068 0d7b2029       } catch (e) {.
   21f38:	2020200a 20202020 20202020 20202020     .               
   21f48:	20202020 79727420 0a0d7b20 20202020          try {..    
   21f58:	20202020 20202020 20202020 20202020                     
   21f68:	20202020 203d2072 2077656e 69746341         r = new Acti
   21f78:	4f586576 63656a62 4d222874 6f726369     veXObject("Micro
   21f88:	74666f73 4c4d582e 50545448 0a0d2922     soft.XMLHTTP")..
   21f98:	20202020 20202020 20202020 20202020                     
   21fa8:	20202020 6163207d 20686374 20296528         } catch (e) 
   21fb8:	200a0d7b 20202020 20202020 20202020     {..             
   21fc8:	20202020 20202020 61202020 7472656c                alert
   21fd8:	6f592228 62207275 73776f72 64207265     ("Your browser d
   21fe8:	2073656f 20746f6e 70707573 2074726f     oes not support 
   21ff8:	58414a41 3b292221 20200a0d 20202020     AJAX!");..      
   22008:	20202020 20202020 20202020 20202020                     
   22018:	65722020 6e727574 6c616620 0a0d6573       return false..
   22028:	20202020 20202020 20202020 20202020                     
   22038:	20202020 200a0d7d 20202020 20202020         }..         
   22048:	20202020 7d202020 20200a0d 20202020            }..      
   22058:	20202020 0d7d2020 2020200a 20202020           }..       
   22068:	20202020 6f2e7220 6165726e 74737964          r.onreadyst
   22078:	63657461 676e6168 203d2065 636e7566     atechange = func
   22088:	6e6f6974 7b202928 20200a0d 20202020     tion() {..      
   22098:	20202020 20202020 66692020 2e722820               if (r.
   220a8:	64616572 61745379 3d206574 2934203d     readyState == 4)
   220b8:	0a0d7b20 20202020 20202020 20202020      {..            
   220c8:	20202020 20202020 72202f2f 3d207365             // res =
   220d8:	6f742720 27206b6f 28202b20 77656e28      'took ' + ((new
   220e8:	74614420 29292865 7465672e 656d6954      Date()).getTime
   220f8:	2d202928 61747320 672e7472 69547465     () - start.getTi
   22108:	2928656d 202f2029 30303031 27202b20     me()) / 1000 + '
   22118:	63657320 73646e6f 0a0d3b27 20202020      seconds';..    
   22128:	20202020 20202020 20202020 20202020                     
   22138:	20736572 2e72203d 70736572 65736e6f     res = r.response
   22148:	74786554 6c70732e 22287469 3b29222c     Text.split(",");
   22158:	20200a0d 20202020 20202020 20202020     ..              
   22168:	20202020 6f642020 656d7563 672e746e           document.g
   22178:	6c457465 6e656d65 49794274 64222864     etElementById("d
   22188:	226f6d65 6e692e29 4872656e 204c4d54     emo").innerHTML 
   22198:	6572203d 0a0d3b73 20202020 20202020     = res;..        
   221a8:	20202020 20202020 20202020 706d6574                 temp
   221b8:	6e696c5f 70612e65 646e6570 77656e28     _line.append(new
   221c8:	74614420 2e292865 54746567 28656d69      Date().getTime(
   221d8:	72202c29 305b7365 0d3b295d 2020200a     ), res[0]);..   
   221e8:	20202020 20202020 20202020 20202020                     
   221f8:	6d756820 6c5f6469 2e656e69 65707061      humid_line.appe
   22208:	6e28646e 44207765 28657461 65672e29     nd(new Date().ge
   22218:	6d695474 2c292865 73657220 295d315b     tTime(), res[1])
   22228:	200a0d3b 20202020 20202020 20202020     ;..             
   22238:	20202020 75202020 696c5f76 612e656e            uv_line.a
   22248:	6e657070 656e2864 61442077 29286574     ppend(new Date()
   22258:	7465672e 656d6954 202c2928 5b736572     .getTime(), res[
   22268:	3b295d32 20200a0d 20202020 20202020     2]);..          
   22278:	20202020 20202020 756c2020 696c5f78               lux_li
   22288:	612e656e 6e657070 656e2864 61442077     ne.append(new Da
   22298:	29286574 7465672e 656d6954 202c2928     te().getTime(), 
   222a8:	5b736572 3b295d33 0a0d0a0d 20200a0d     res[3]);......  
   222b8:	20202020 20202020 20202020 0d7d2020                   }.
   222c8:	2020200a 20202020 20202020 0d3b7d20     .            };.
   222d8:	2020200a 20202020 20202020 61747320     .            sta
   222e8:	3d207472 77656e20 74614420 3b292865     rt = new Date();
   222f8:	20200a0d 20202020 20202020 2e722020     ..            r.
   22308:	6e65706f 45472228 202c2254 65732f22     open("GET", "/se
   22318:	726f736e 61746164 7468732e 2c226c6d     nsordata.shtml",
   22328:	75727420 0d3b2965 2020200a 20202020      true);..       
   22338:	20202020 732e7220 28646e65 6c6c756e          r.send(null
   22348:	200a0d29 20202020 7d202020 0a0d0a0d     )..        }....
   22358:	20200a0d 20202020 61762020 65742072     ..        var te
   22368:	635f706d 74726168 6e203d20 53207765     mp_chart = new S
   22378:	746f6f6d 43656968 74726168 0a0d7b28     moothieChart({..
   22388:	20202020 20202020 20202020 6c6c696d                 mill
   22398:	65507369 78695072 203a6c65 0d2c3034     isPerPixel: 40,.
   223a8:	2020200a 20202020 20202020 78616d20     .            max
   223b8:	756c6156 61635365 203a656c 30322e31     ValueScale: 1.20
   223c8:	200a0d2c 20202020 20202020 6d202020     ,..            m
   223d8:	61566e69 5365756c 656c6163 2e31203a     inValueScale: 1.
   223e8:	0a0d3032 20202020 20202020 0d3b297d     20..        });.
   223f8:	2020200a 20202020 6d657420 68635f70     .        temp_ch
   22408:	2e747261 65727473 6f546d61 636f6428     art.streamTo(doc
   22418:	6e656d75 65672e74 656c4574 746e656d     ument.getElement
   22428:	64497942 65742228 675f706d 68706172     ById("temp_graph
   22438:	3b292922 20200a0d 20202020 61762020     "));..        va
   22448:	65742072 6c5f706d 20656e69 656e203d     r temp_line = ne
   22458:	69542077 6553656d 73656972 0d3b2928     w TimeSeries();.
   22468:	200a0d0a 20202020 76202020 68207261     ...        var h
   22478:	64696d75 6168635f 3d207472 77656e20     umid_chart = new
   22488:	6f6d5320 6968746f 61684365 7b287472      SmoothieChart({
   22498:	20200a0d 20202020 20202020 696d2020     ..            mi
   224a8:	73696c6c 50726550 6c657869 3034203a     llisPerPixel: 40
   224b8:	200a0d2c 20202020 20202020 6d202020     ,..            m
   224c8:	61567861 5365756c 656c6163 2e31203a     axValueScale: 1.
   224d8:	0d2c3032 2020200a 20202020 20202020     20,..           
   224e8:	6e696d20 756c6156 61635365 203a656c      minValueScale: 
   224f8:	30322e31 20200a0d 20202020 297d2020     1.20..        })
   22508:	200a0d3b 20202020 68202020 64696d75     ;..        humid
   22518:	6168635f 732e7472 61657274 286f546d     _chart.streamTo(
   22528:	75636f64 746e656d 7465672e 6d656c45     document.getElem
   22538:	42746e65 28644979 6d756822 675f6469     entById("humid_g
   22548:	68706172 3b292922 20200a0d 20202020     raph"));..      
   22558:	61762020 75682072 5f64696d 656e696c       var humid_line
   22568:	6e203d20 54207765 53656d69 65697265      = new TimeSerie
   22578:	3b292873 0a0d0a0d 20202020 20202020     s();....        
   22588:	20726176 635f7675 74726168 6e203d20     var uv_chart = n
   22598:	53207765 746f6f6d 43656968 74726168     ew SmoothieChart
   225a8:	0a0d7b28 20202020 20202020 20202020     ({..            
   225b8:	6c6c696d 65507369 78695072 203a6c65     millisPerPixel: 
   225c8:	0d2c3034 2020200a 20202020 20202020     40,..           
   225d8:	78616d20 756c6156 61635365 203a656c      maxValueScale: 
   225e8:	30322e31 200a0d2c 20202020 20202020     1.20,..         
   225f8:	6d202020 61566e69 5365756c 656c6163        minValueScale
   22608:	2e31203a 0a0d3032 20202020 20202020     : 1.20..        
   22618:	0d3b297d 2020200a 20202020 5f767520     });..        uv_
   22628:	72616863 74732e74 6d616572 64286f54     chart.streamTo(d
   22638:	6d75636f 2e746e65 45746567 656d656c     ocument.getEleme
   22648:	7942746e 22286449 675f7675 68706172     ntById("uv_graph
   22658:	3b292922 20200a0d 20202020 61762020     "));..        va
   22668:	76752072 6e696c5f 203d2065 2077656e     r uv_line = new 
   22678:	656d6954 69726553 29287365 0d0a0d3b     TimeSeries();...
   22688:	2020200a 20202020 72617620 78756c20     .        var lux
   22698:	6168635f 3d207472 77656e20 6f6d5320     _chart = new Smo
   226a8:	6968746f 61684365 7b287472 20200a0d     othieChart({..  
   226b8:	20202020 20202020 696d2020 73696c6c               millis
   226c8:	50726550 6c657869 3034203a 200a0d2c     PerPixel: 40,.. 
   226d8:	20202020 20202020 6d202020 61567861                maxVa
   226e8:	5365756c 656c6163 2e31203a 0d2c3032     lueScale: 1.20,.
   226f8:	2020200a 20202020 20202020 6e696d20     .            min
   22708:	756c6156 61635365 203a656c 30322e31     ValueScale: 1.20
   22718:	20200a0d 20202020 297d2020 200a0d3b     ..        });.. 
   22728:	20202020 6c202020 635f7875 74726168            lux_chart
   22738:	7274732e 546d6165 6f64286f 656d7563     .streamTo(docume
   22748:	672e746e 6c457465 6e656d65 49794274     nt.getElementByI
   22758:	6c222864 675f7875 68706172 3b292922     d("lux_graph"));
   22768:	20200a0d 20202020 61762020 756c2072     ..        var lu
   22778:	696c5f78 3d20656e 77656e20 6d695420     x_line = new Tim
   22788:	72655365 28736569 0a0d3b29 0a0d0a0d     eSeries();......
   22798:	20202020 20202020 49746573 7265746e             setInter
   227a8:	286c6176 636e7566 6e6f6974 7b202928     val(function() {
   227b8:	20200a0d 20202020 20202020 6f6c2020     ..            lo
   227c8:	61446461 29286174 200a0d3b 20202020     adData();..     
   227d8:	7d202020 3035202c 0d3b2930 200a0d0a        }, 500);.... 
   227e8:	20202020 74202020 5f706d65 72616863            temp_char
   227f8:	64612e74 6d695464 72655365 28736569     t.addTimeSeries(
   22808:	706d6574 6e696c5f 7b202c65 20200a0d     temp_line, {..  
   22818:	20202020 20202020 74732020 656b6f72               stroke
   22828:	6c797453 27203a65 28626772 32202c30     Style: 'rgb(0, 2
   22838:	202c3535 2c272930 20200a0d 20202020     55, 0)',..      
   22848:	20202020 69662020 74536c6c 3a656c79           fillStyle:
   22858:	67722720 30286162 3032202c 30202c35      'rgba(0, 205, 0
   22868:	2e30202c 2c272934 20200a0d 20202020     , 0.4)',..      
   22878:	20202020 696c2020 6957656e 3a687464           lineWidth:
   22888:	0a0d3320 20202020 20202020 0d3b297d      3..        });.
   22898:	2020200a 20202020 6d756820 635f6469     .        humid_c
   228a8:	74726168 6464612e 656d6954 69726553     hart.addTimeSeri
   228b8:	68287365 64696d75 6e696c5f 7b202c65     es(humid_line, {
   228c8:	20200a0d 20202020 20202020 74732020     ..            st
   228d8:	656b6f72 6c797453 27203a65 28626772     rokeStyle: 'rgb(
   228e8:	32202c30 202c3535 2c272930 20200a0d     0, 255, 0)',..  
   228f8:	20202020 20202020 69662020 74536c6c               fillSt
   22908:	3a656c79 67722720 30286162 3032202c     yle: 'rgba(0, 20
   22918:	30202c35 2e30202c 2c272934 20200a0d     5, 0, 0.4)',..  
   22928:	20202020 20202020 696c2020 6957656e               lineWi
   22938:	3a687464 0a0d3320 20202020 20202020     dth: 3..        
   22948:	0d3b297d 200a0d0a 20202020 6c202020     });....        l
   22958:	635f7875 74726168 6464612e 656d6954     ux_chart.addTime
   22968:	69726553 6c287365 6c5f7875 2c656e69     Series(lux_line,
   22978:	0a0d7b20 20202020 20202020 20202020      {..            
   22988:	6f727473 7453656b 3a656c79 67722720     strokeStyle: 'rg
   22998:	2c302862 35353220 2930202c 0a0d2c27     b(0, 255, 0)',..
   229a8:	20202020 20202020 20202020 6c6c6966                 fill
   229b8:	6c797453 27203a65 61626772 202c3028     Style: 'rgba(0, 
   229c8:	2c353032 202c3020 29342e30 0a0d2c27     205, 0, 0.4)',..
   229d8:	20202020 20202020 20202020 656e696c                 line
   229e8:	74646957 33203a68 20200a0d 20202020     Width: 3..      
   229f8:	297d2020 0d0a0d3b 2020200a 20202020       });....       
   22a08:	5f767520 72616863 64612e74 6d695464      uv_chart.addTim
   22a18:	72655365 28736569 6c5f7675 2c656e69     eSeries(uv_line,
   22a28:	0a0d7b20 20202020 20202020 20202020      {..            
   22a38:	6f727473 7453656b 3a656c79 67722720     strokeStyle: 'rg
   22a48:	2c302862 35353220 2930202c 0a0d2c27     b(0, 255, 0)',..
   22a58:	20202020 20202020 20202020 6c6c6966                 fill
   22a68:	6c797453 27203a65 61626772 202c3028     Style: 'rgba(0, 
   22a78:	2c353032 202c3020 29342e30 0a0d2c27     205, 0, 0.4)',..
   22a88:	20202020 20202020 20202020 656e696c                 line
   22a98:	74646957 33203a68 20200a0d 20202020     Width: 3..      
   22aa8:	297d2020 200a0d3b 3c202020 7263732f       });..    </scr
   22ab8:	3e747069 0a0d0a0d 0a0d0a0d 6f622f3c     ipt>........</bo
   22ac8:	0d3e7964 3c0a0d0a 6d74682f 00003e6c     dy>....</html>..

00022ad8 <data_index_html>:
   22ad8:	646e692f 682e7865 006c6d74 4f44213c     /index.html.<!DO
   22ae8:	50595443 74682045 0d3e6c6d 74683c0a     CTYPE html>..<ht
   22af8:	0d3e6c6d 3c0a0d0a 64616568 200a0d3e     ml>....<head>.. 
   22b08:	3c202020 6c746974 614a3e65 7327656b        <title>Jake's
   22b18:	61657720 72656874 61747320 6e6f6974      weather station
   22b28:	69687420 3c79676e 7469742f 0d3e656c      thingy</title>.
   22b38:	2020200a 656d3c20 68206174 2d707474     .    <meta http-
   22b48:	69757165 63223d76 65746e6f 742d746e     equiv="content-t
   22b58:	22657079 6e6f6320 746e6574 6574223d     ype" content="te
   22b68:	682f7478 3b6c6d74 61686320 74657372     xt/html; charset
   22b78:	6f73693d 3538382d 22312d39 0d3e2f20     =iso-8859-1" />.
   22b88:	2020200a 74733c20 20656c79 6964656d     .    <style medi
   22b98:	61223d61 20226c6c 65707974 6574223d     a="all" type="te
   22ba8:	632f7478 3e227373 20200a0d 20202020     xt/css">..      
   22bb8:	69402020 726f706d 63222074 732f7373       @import "css/s
   22bc8:	656c7974 73632e73 0d3b2273 2020200a     tyles.css";..   
   22bd8:	732f3c20 656c7974 3c0a0d3e 6165682f      </style>..</hea
   22be8:	0a0d3e64 623c0a0d 3e79646f 20200a0d     d>....<body>..  
   22bf8:	643c2020 69207669 6d223d64 226e6961       <div id="main"
   22c08:	200a0d3e 20202020 3c202020 20766964     >..        <div 
   22c18:	223d6469 64616568 3e227265 20200a0d     id="header">..  
   22c28:	20202020 20202020 613c2020 65726820               <a hre
   22c38:	69223d66 7865646e 6d74682e 6320226c     f="index.html" c
   22c48:	7373616c 6f6c223d 3e226f67 676d693c     lass="logo"><img
   22c58:	63727320 6d69223d 6c632f67 4c64756f      src="img/cloudL
   22c68:	2e6f676f 22676e70 64697720 223d6874     ogo.png" width="
   22c78:	22303031 69656820 3d746867 22303822     100" height="80"
   22c88:	746c6120 2022223d 2f3c3e2f 0a0d3e61      alt="" /></a>..
   22c98:	20200a0d 20202020 20202020 753c2020     ..            <u
   22ca8:	6469206c 6f74223d 616e2d70 61676976     l id="top-naviga
   22cb8:	6e6f6974 0a0d3e22 20202020 20202020     tion">..        
   22cc8:	20202020 20202020 20696c3c 73616c63             <li clas
   22cd8:	61223d73 76697463 3c3e2265 6e617073     s="active"><span
   22ce8:	70733c3e 3c3e6e61 72682061 223d6665     ><span><a href="
   22cf8:	65646e69 74682e78 3e226c6d 656d6f48     index.html">Home
   22d08:	3e612f3c 70732f3c 3c3e6e61 6170732f     </a></span></spa
   22d18:	0a0d3e6e 20202020 20202020 20202020     n>..            
   22d28:	20202020 696c2f3c 200a0d3e 20202020         </li>..     
   22d38:	20202020 20202020 3c202020 3c3e696c                <li><
   22d48:	6e617073 70733c3e 3c3e6e61 72682061     span><span><a hr
   22d58:	223d6665 68736164 72616f62 68732e64     ef="dashboard.sh
   22d68:	226c6d74 7361443e 616f6268 2f3c6472     tml">Dashboard</
   22d78:	2f3c3e61 6e617073 732f3c3e 3e6e6170     a></span></span>
   22d88:	20200a0d 20202020 20202020 20202020     ..              
   22d98:	2f3c2020 0d3e696c 2020200a 20202020       </li>..       
   22da8:	20202020 20202020 696c3c20 70733c3e              <li><sp
   22db8:	3c3e6e61 6e617073 20613c3e 66657268     an><span><a href
   22dc8:	6f63223d 6f72746e 68732e6c 226c6d74     ="control.shtml"
   22dd8:	6e6f433e 6c6f7274 3e612f3c 70732f3c     >Control</a></sp
   22de8:	3c3e6e61 6170732f 0a0d3e6e 20202020     an></span>..    
   22df8:	20202020 20202020 20202020 696c2f3c                 </li
   22e08:	200a0d3e 20202020 20202020 20202020     >..             
   22e18:	3c202020 3c3e696c 6e617073 70733c3e        <li><span><sp
   22e28:	3c3e6e61 72682061 223d6665 74617473     an><a href="stat
   22e38:	68732e73 226c6d74 5043543e 61745320     s.shtml">TCP Sta
   22e48:	2f3c7374 2f3c3e61 6e617073 732f3c3e     ts</a></span></s
   22e58:	3e6e6170 20200a0d 20202020 20202020     pan>..          
   22e68:	20202020 2f3c2020 0d3e696c 2020200a           </li>..   
   22e78:	20202020 20202020 20202020 696c3c20                  <li
   22e88:	70733c3e 3c3e6e61 6e617073 20613c3e     ><span><span><a 
   22e98:	66657268 6374223d 68732e70 226c6d74     href="tcp.shtml"
   22ea8:	6e6f433e 7463656e 736e6f69 3e612f3c     >Connections</a>
   22eb8:	70732f3c 3c3e6e61 6170732f 0a0d3e6e     </span></span>..
   22ec8:	20202020 20202020 20202020 20202020                     
   22ed8:	696c2f3c 200a0d3e 20202020 20202020     </li>..         
   22ee8:	3c202020 3e6c752f 20200a0d 20202020        </ul>..      
   22ef8:	2f3c2020 3e766964 0a0d0a0d 20202020       </div>....    
   22f08:	20202020 7669643c 3d646920 64696d22         <div id="mid
   22f18:	22656c64 200a0d3e 20202020 20202020     dle">..         
   22f28:	3c202020 573e3268 6f636c65 7420656d        <h2>Welcome t
   22f38:	6f79206f 70207275 6f737265 206c616e     o your personal 
   22f48:	6f6d6572 72206574 206c6165 656d6974     remote real time
   22f58:	61657720 72656874 61747320 6e6f6974      weather station
   22f68:	682f3c20 0a0d3e32 20200a0d 20202020      </h2>....      
   22f78:	20202020 643c2020 69207669 77223d64           <div id="w
   22f88:	65676469 65732d74 6f697463 0d3e226e     idget-section">.
   22f98:	2020200a 20202020 20202020 20202020     .               
   22fa8:	69643c20 64692076 6874223d 6f6d7265      <div id="thermo
   22fb8:	6361622d 6f72676b 22646e75 200a0d3e     -background">.. 
   22fc8:	20202020 20202020 20202020 20202020                     
   22fd8:	3c202020 20766964 223d6469 72656874        <div id="ther
   22fe8:	702d6f6d 72676f72 22737365 200a0d3e     mo-progress">.. 
   22ff8:	20202020 20202020 20202020 20202020                     
   23008:	20202020 3c202020 20766964 223d6469            <div id="
   23018:	72656874 622d6f6d 3e227261 69642f3c     thermo-bar"></di
   23028:	0a0d3e76 20202020 20202020 20202020     v>..            
   23038:	20202020 20202020 69642f3c 0a0d3e76             </div>..
   23048:	20202020 20202020 20202020 20202020                     
   23058:	20202020 7669643c 3d646920 6d657422         <div id="tem
   23068:	61655270 676e6964 0a0d3e22 20202020     pReading">..    
   23078:	20202020 20202020 20202020 20202020                     
   23088:	20202020 6170733c 6469206e 6574223d         <span id="te
   23098:	6552706d 6e696461 6c615667 2f3c3e22     mpReadingVal"></
   230a8:	6e617073 3123263e 0d433637 2020200a     span>&#176C..   
   230b8:	20202020 20202020 20202020 20202020                     
   230c8:	642f3c20 0d3e7669 2020200a 20202020      </div>..       
   230d8:	20202020 20202020 642f3c20 0d3e7669              </div>.
   230e8:	2020200a 20202020 20202020 642f3c20     .            </d
   230f8:	0d3e7669 200a0d0a 20202020 20202020     iv>....         
   23108:	3c202020 20766964 223d6469 67646977        <div id="widg
   23118:	732d7465 69746365 3e226e6f 20200a0d     et-section">..  
   23128:	20202020 20202020 20202020 643c2020                   <d
   23138:	69207669 72223d64 2d6e6961 6b636162     iv id="rain-back
   23148:	756f7267 3e22646e 20200a0d 20202020     ground">..      
   23158:	20202020 20202020 20202020 643c2020                   <d
   23168:	69207669 72223d64 2d6e6961 676f7270     iv id="rain-prog
   23178:	73736572 0a0d3e22 20202020 20202020     ress">..        
   23188:	20202020 20202020 20202020 20202020                     
   23198:	7669643c 3d646920 69617222 61622d6e     <div id="rain-ba
   231a8:	3c3e2272 7669642f 200a0d3e 20202020     r"></div>..     
   231b8:	20202020 20202020 20202020 3c202020                    <
   231c8:	7669642f 200a0d3e 20202020 20202020     /div>..         
   231d8:	20202020 20202020 3c202020 20766964                <div 
   231e8:	223d6469 6e696172 64616552 22676e69     id="rainReading"
   231f8:	200a0d3e 20202020 20202020 20202020     >..             
   23208:	20202020 20202020 3c202020 6e617073                <span
   23218:	3d646920 69617222 6165526e 676e6964      id="rainReading
   23228:	226c6156 732f3c3e 3e6e6170 200a0d25     Val"></span>%.. 
   23238:	20202020 20202020 20202020 20202020                     
   23248:	3c202020 7669642f 200a0d3e 20202020        </div>..     
   23258:	20202020 20202020 3c202020 7669642f                </div
   23268:	200a0d3e 20202020 20202020 3c202020     >..            <
   23278:	7669642f 0d0a0d3e 2020200a 20202020     /div>....       
   23288:	20202020 69643c20 64692076 6977223d          <div id="wi
   23298:	74656764 6365732d 6e6f6974 0a0d3e22     dget-section">..
   232a8:	20202020 20202020 20202020 20202020                     
   232b8:	7669643c 3d646920 6e757322 6361622d     <div id="sun-bac
   232c8:	6f72676b 22646e75 200a0d3e 20202020     kground">..     
   232d8:	20202020 20202020 20202020 3c202020                    <
   232e8:	20766964 223d6469 2d6e7573 676f7270     div id="sun-prog
   232f8:	73736572 0a0d3e22 20202020 20202020     ress">..        
   23308:	20202020 20202020 20202020 20202020                     
   23318:	7669643c 3d646920 6e757322 7261622d     <div id="sun-bar
   23328:	2f3c3e22 3e766964 20200a0d 20202020     "></div>..      
   23338:	20202020 20202020 20202020 2f3c2020                   </
   23348:	3e766964 20200a0d 20202020 20202020     div>..          
   23358:	20202020 20202020 643c2020 69207669               <div i
   23368:	73223d64 65526e75 6e696461 0d3e2267     d="sunReading">.
   23378:	2020200a 20202020 20202020 20202020     .               
   23388:	20202020 20202020 70733c20 69206e61              <span i
   23398:	73223d64 65526e75 6e696461 6c615667     d="sunReadingVal
   233a8:	2f3c3e22 6e617073 754c203e 200a0d78     "></span> Lux.. 
   233b8:	20202020 20202020 20202020 20202020                     
   233c8:	3c202020 7669642f 200a0d3e 20202020        </div>..     
   233d8:	20202020 20202020 3c202020 7669642f                </div
   233e8:	200a0d3e 20202020 20202020 3c202020     >..            <
   233f8:	7669642f 0d0a0d3e 2020200a 20202020     /div>....       
   23408:	20202020 69643c20 64692076 6977223d          <div id="wi
   23418:	74656764 6365732d 6e6f6974 0a0d3e22     dget-section">..
   23428:	20202020 20202020 20202020 20202020                     
   23438:	7669643c 3d646920 2d767522 6b636162     <div id="uv-back
   23448:	756f7267 3e22646e 20200a0d 20202020     ground">..      
   23458:	20202020 20202020 20202020 643c2020                   <d
   23468:	69207669 75223d64 72702d76 6572676f     iv id="uv-progre
   23478:	3e227373 20200a0d 20202020 20202020     ss">..          
   23488:	20202020 20202020 20202020 643c2020                   <d
   23498:	69207669 75223d64 61622d76 3c3e2272     iv id="uv-bar"><
   234a8:	7669642f 200a0d3e 20202020 20202020     /div>..         
   234b8:	20202020 20202020 3c202020 7669642f                </div
   234c8:	200a0d3e 20202020 20202020 20202020     >..             
   234d8:	20202020 3c202020 20766964 223d6469            <div id="
   234e8:	65527675 6e696461 0d3e2267 2020200a     uvReading">..   
   234f8:	20202020 20202020 20202020 20202020                     
   23508:	20202020 70733c20 69206e61 75223d64          <span id="u
   23518:	61655276 676e6964 226c6156 732f3c3e     vReadingVal"></s
   23528:	3e6e6170 20200a0d 20202020 20202020     pan>..          
   23538:	20202020 20202020 2f3c2020 3e766964               </div>
   23548:	20200a0d 20202020 20202020 20202020     ..              
   23558:	2f3c2020 3e766964 20200a0d 20202020       </div>..      
   23568:	20202020 2f3c2020 3e766964 0a0d0a0d           </div>....
   23578:	20202020 20202020 20202020 3e72623c                 <br>
   23588:	0a0d0a0d 20202020 20202020 69642f3c     ....        </di
   23598:	0a0d3e76 0a0d0a0d 20202020 20202020     v>......        
   235a8:	7669643c 3d646920 6f6f6622 22726574     <div id="footer"
   235b8:	642f3c3e 0d3e7669 2020200a 642f3c20     ></div>..    </d
   235c8:	0d3e7669 200a0d0a 3c202020 69726373     iv>....    <scri
   235d8:	0d3e7470 2020200a 20202020 6e756620     pt>..        fun
   235e8:	6f697463 6f6d206e 745f6576 6d726568     ction move_therm
   235f8:	6f70286f 7b202973 20200a0d 20202020     o(pos) {..      
   23608:	20202020 61762020 6c652072 3d206d65           var elem =
   23618:	636f6420 6e656d75 65672e74 656c4574      document.getEle
   23628:	746e656d 64497942 68742228 6f6d7265     mentById("thermo
   23638:	7261622d 0d3b2922 2020200a 20202020     -bar");..       
   23648:	20202020 656c6520 74732e6d 2e656c79          elem.style.
   23658:	67696568 3d207468 736f7020 27202b20     height = pos + '
   23668:	0d3b2725 2020200a 20202020 0a0d7d20     %';..        }..
   23678:	20200a0d 20202020 75662020 6974636e     ..        functi
   23688:	6d206e6f 5f65766f 6e696172 736f7028     on move_rain(pos
   23698:	0d7b2029 2020200a 20202020 20202020     ) {..           
   236a8:	72617620 656c6520 203d206d 75636f64      var elem = docu
   236b8:	746e656d 7465672e 6d656c45 42746e65     ment.getElementB
   236c8:	28644979 69617222 61622d6e 3b292272     yId("rain-bar");
   236d8:	20200a0d 20202020 20202020 6c652020     ..            el
   236e8:	732e6d65 656c7974 6965682e 20746867     em.style.height 
   236f8:	6f70203d 202b2073 3b272527 20200a0d     = pos + '%';..  
   23708:	20202020 0d7d2020 200a0d0a 20202020           }....     
   23718:	66202020 74636e75 206e6f69 65766f6d        function move
   23728:	6e75735f 736f7028 0d7b2029 2020200a     _sun(pos) {..   
   23738:	20202020 20202020 72617620 656c6520              var ele
   23748:	203d206d 75636f64 746e656d 7465672e     m = document.get
   23758:	6d656c45 42746e65 28644979 6e757322     ElementById("sun
   23768:	7261622d 0d3b2922 2020200a 20202020     -bar");..       
   23778:	20202020 20666920 736f7028 203d3c20          if (pos <= 
   23788:	20303031 70202626 3e20736f 20293020     100 && pos > 0) 
   23798:	200a0d7b 20202020 20202020 20202020     {..             
   237a8:	65202020 2e6d656c 6c797473 65682e65        elem.style.he
   237b8:	74686769 70203d20 2b20736f 27252720     ight = pos + '%'
   237c8:	200a0d3b 20202020 20202020 7d202020     ;..            }
   237d8:	736c6520 66692065 6f702820 3d3c2073      else if (pos <=
   237e8:	20293020 200a0d7b 20202020 20202020      0) {..         
   237f8:	20202020 65202020 2e6d656c 6c797473            elem.styl
   23808:	65682e65 74686769 30203d20 27202b20     e.height = 0 + '
   23818:	0d3b2725 2020200a 20202020 20202020     %';..           
   23828:	65207d20 2065736c 200a0d7b 20202020      } else {..     
   23838:	20202020 20202020 65202020 2e6d656c                elem.
   23848:	6c797473 65682e65 74686769 31203d20     style.height = 1
   23858:	2b203030 27252720 200a0d3b 20202020     00 + '%';..     
   23868:	20202020 7d202020 0a0d0a0d 20202020            }....    
   23878:	20202020 0d0a0d7d 2020200a 20202020         }....       
   23888:	6e756620 6f697463 6f6d206e 755f6576      function move_u
   23898:	6f702876 7b202973 20200a0d 20202020     v(pos) {..      
   238a8:	20202020 61762020 6c652072 3d206d65           var elem =
   238b8:	636f6420 6e656d75 65672e74 656c4574      document.getEle
   238c8:	746e656d 64497942 76752228 7261622d     mentById("uv-bar
   238d8:	0d3b2922 2020200a 20202020 20202020     ");..           
   238e8:	20666920 736f7028 203d3c20 20303031      if (pos <= 100 
   238f8:	70202626 3e20736f 20293020 200a0d7b     && pos > 0) {.. 
   23908:	20202020 20202020 20202020 65202020                    e
   23918:	2e6d656c 6c797473 65682e65 74686769     lem.style.height
   23928:	70203d20 2b20736f 27252720 200a0d3b      = pos + '%';.. 
   23938:	20202020 20202020 7d202020 736c6520                } els
   23948:	66692065 6f702820 3d3c2073 20293020     e if (pos <= 0) 
   23958:	200a0d7b 20202020 20202020 20202020     {..             
   23968:	65202020 2e6d656c 6c797473 65682e65        elem.style.he
   23978:	74686769 30203d20 27202b20 0d3b2725     ight = 0 + '%';.
   23988:	2020200a 20202020 20202020 65207d20     .            } e
   23998:	2065736c 200a0d7b 20202020 20202020     lse {..         
   239a8:	20202020 65202020 2e6d656c 6c797473            elem.styl
   239b8:	65682e65 74686769 31203d20 2b203030     e.height = 100 +
   239c8:	27252720 200a0d3b 20202020 20202020      '%';..         
   239d8:	7d202020 20200a0d 20202020 0d7d2020        }..        }.
   239e8:	0d0a0d0a 2020200a 20202020 6e756620     .....        fun
   239f8:	6f697463 6f6c206e 61446461 29286174     ction loadData()
   23a08:	0a0d7b20 20202020 20202020 20202020      {..            
   23a18:	20726176 0a0d3b72 20202020 20202020     var r;..        
   23a28:	20202020 20797274 200a0d7b 20202020         try {..     
   23a38:	20202020 20202020 72202020 6e203d20                r = n
   23a48:	58207765 74484c4d 65527074 73657571     ew XMLHttpReques
   23a58:	0d292874 2020200a 20202020 20202020     t()..           
   23a68:	63207d20 68637461 29652820 0a0d7b20      } catch (e) {..
   23a78:	20202020 20202020 20202020 20202020                     
   23a88:	20797274 200a0d7b 20202020 20202020     try {..         
   23a98:	20202020 20202020 72202020 6e203d20                r = n
   23aa8:	41207765 76697463 624f5865 7463656a     ew ActiveXObject
   23ab8:	734d2228 326c6d78 4c4d582e 50545448     ("Msxml2.XMLHTTP
   23ac8:	0a0d2922 20202020 20202020 20202020     ")..            
   23ad8:	20202020 6163207d 20686374 20296528         } catch (e) 
   23ae8:	200a0d7b 20202020 20202020 20202020     {..             
   23af8:	20202020 74202020 7b207972 20200a0d            try {..  
   23b08:	20202020 20202020 20202020 20202020                     
   23b18:	20202020 20722020 656e203d 63412077           r = new Ac
   23b28:	65766974 6a624f58 28746365 63694d22     tiveXObject("Mic
   23b38:	6f736f72 582e7466 54484c4d 29225054     rosoft.XMLHTTP")
   23b48:	20200a0d 20202020 20202020 20202020     ..              
   23b58:	20202020 207d2020 63746163 65282068           } catch (e
   23b68:	0d7b2029 2020200a 20202020 20202020     ) {..           
   23b78:	20202020 20202020 20202020 656c6120                  ale
   23b88:	22287472 72756f59 6f726220 72657377     rt("Your browser
   23b98:	656f6420 6f6e2073 75732074 726f7070      does not suppor
   23ba8:	4a412074 22215841 0a0d3b29 20202020     t AJAX!");..    
   23bb8:	20202020 20202020 20202020 20202020                     
   23bc8:	20202020 75746572 66206e72 65736c61         return false
   23bd8:	20200a0d 20202020 20202020 20202020     ..              
   23be8:	20202020 0d7d2020 2020200a 20202020           }..       
   23bf8:	20202020 20202020 0a0d7d20 20202020              }..    
   23c08:	20202020 20202020 200a0d7d 20202020             }..     
   23c18:	20202020 72202020 726e6f2e 79646165            r.onready
   23c28:	74617473 61686365 2065676e 7566203d     statechange = fu
   23c38:	6974636e 29286e6f 0a0d7b20 20202020     nction() {..    
   23c48:	20202020 20202020 20202020 28206669                 if (
   23c58:	65722e72 53796461 65746174 203d3d20     r.readyState == 
   23c68:	7b202934 20200a0d 20202020 20202020     4) {..          
   23c78:	20202020 20202020 2f2f2020 73657220               // res
   23c88:	27203d20 6b6f6f74 2b202720 6e282820      = 'took ' + ((n
   23c98:	44207765 28657461 672e2929 69547465     ew Date()).getTi
   23ca8:	2928656d 73202d20 74726174 7465672e     me() - start.get
   23cb8:	656d6954 20292928 3031202f 2b203030     Time()) / 1000 +
   23cc8:	73202720 6e6f6365 3b277364 20200a0d      ' seconds';..  
   23cd8:	20202020 20202020 20202020 20202020                     
   23ce8:	65722020 203d2073 65722e72 6e6f7073       res = r.respon
   23cf8:	65546573 732e7478 74696c70 222c2228     seText.split(","
   23d08:	0a0d3b29 20202020 20202020 20202020     );..            
   23d18:	20202020 20202020 20726176 706d6574             var temp
   23d28:	206c6156 614d203d 722e6874 646e756f     Val = Math.round
   23d38:	73657228 295d305b 200a0d3b 20202020     (res[0]);..     
   23d48:	20202020 20202020 20202020 76202020                    v
   23d58:	68207261 64696d75 206c6156 614d203d     ar humidVal = Ma
   23d68:	722e6874 646e756f 73657228 295d315b     th.round(res[1])
   23d78:	20200a0d 20202020 20202020 20202020     ..              
   23d88:	20202020 61762020 754c2072 6c615678           var LuxVal
   23d98:	4d203d20 2e687461 6e756f72 65722864      = Math.round(re
   23da8:	5d325b73 200a0d29 20202020 20202020     s[2])..         
   23db8:	20202020 20202020 76202020 55207261                var U
   23dc8:	6c615656 4d203d20 2e687461 6e756f72     VVal = Math.roun
   23dd8:	65722864 5d335b73 200a0d29 20202020     d(res[3])..     
   23de8:	20202020 20202020 20202020 6d202020                    m
   23df8:	5f65766f 72656874 31286f6d 2d203030     ove_thermo(100 -
   23e08:	6d657420 6c615670 0a0d3b29 20202020      tempVal);..    
   23e18:	20202020 20202020 20202020 20202020                     
   23e28:	65766f6d 6961725f 3031286e 202d2030     move_rain(100 - 
   23e38:	696d7568 6c615664 0a0d3b29 20202020     humidVal);..    
   23e48:	20202020 20202020 20202020 20202020                     
   23e58:	65766f6d 6e75735f 30303128 28202d20     move_sun(100 - (
   23e68:	5678754c 2f206c61 29303320 0a0d3b29     LuxVal / 30));..
   23e78:	20202020 20202020 20202020 20202020                     
   23e88:	20202020 65766f6d 2876755f 20303031         move_uv(100 
   23e98:	5528202d 6c615656 36202a20 2936362e     - (UVVal * 6.66)
   23ea8:	0a0d3b29 20202020 20202020 20202020     );..            
   23eb8:	20202020 20202020 75636f64 746e656d             document
   23ec8:	7465672e 6d656c45 42746e65 28644979     .getElementById(
   23ed8:	6d657422 61655270 676e6964 226c6156     "tempReadingVal"
   23ee8:	6e692e29 4872656e 204c4d54 6574203d     ).innerHTML = te
   23ef8:	6156706d 0a0d3b6c 20202020 20202020     mpVal;..        
   23f08:	20202020 20202020 20202020 75636f64                 docu
   23f18:	746e656d 7465672e 6d656c45 42746e65     ment.getElementB
   23f28:	28644979 69617222 6165526e 676e6964     yId("rainReading
   23f38:	226c6156 6e692e29 4872656e 204c4d54     Val").innerHTML 
   23f48:	7568203d 5664696d 0d3b6c61 2020200a     = humidVal;..   
   23f58:	20202020 20202020 20202020 20202020                     
   23f68:	636f6420 6e656d75 65672e74 656c4574      document.getEle
   23f78:	746e656d 64497942 75732228 6165526e     mentById("sunRea
   23f88:	676e6964 226c6156 6e692e29 4872656e     dingVal").innerH
   23f98:	204c4d54 754c203d 6c615678 200a0d3b     TML = LuxVal;.. 
   23fa8:	20202020 20202020 20202020 20202020                     
   23fb8:	64202020 6d75636f 2e746e65 45746567        document.getE
   23fc8:	656d656c 7942746e 22286449 65527675     lementById("uvRe
   23fd8:	6e696461 6c615667 692e2922 72656e6e     adingVal").inner
   23fe8:	4c4d5448 55203d20 6c615656 200a0d3b     HTML = UVVal;.. 
   23ff8:	20202020 20202020 20202020 20202020                     
   24008:	2f202020 6f64202f 656d7563 672e746e        // document.g
   24018:	6c457465 6e656d65 49794274 64222864     etElementById("d
   24028:	226f6d65 6e692e29 4872656e 204c4d54     emo").innerHTML 
   24038:	6572203d 0a0d3b73 20202020 20202020     = res;..        
   24048:	20202020 20202020 20202020 74202f2f                 // t
   24058:	5f706d65 656e696c 7070612e 28646e65     emp_line.append(
   24068:	2077656e 65746144 672e2928 69547465     new Date().getTi
   24078:	2928656d 6572202c 5d305b73 0a0d3b29     me(), res[0]);..
   24088:	20202020 20202020 20202020 20202020                     
   24098:	20202020 68202f2f 64696d75 6e696c5f         // humid_lin
   240a8:	70612e65 646e6570 77656e28 74614420     e.append(new Dat
   240b8:	2e292865 54746567 28656d69 72202c29     e().getTime(), r
   240c8:	315b7365 0d3b295d 2020200a 20202020     es[1]);..       
   240d8:	20202020 20202020 20202020 202f2f20                  // 
   240e8:	6c5f7675 2e656e69 65707061 6e28646e     uv_line.append(n
   240f8:	44207765 28657461 65672e29 6d695474     ew Date().getTim
   24108:	2c292865 73657220 295d325b 200a0d3b     e(), res[2]);.. 
   24118:	20202020 20202020 20202020 7d202020                    }
   24128:	20200a0d 20202020 20202020 3b7d2020     ..            };
   24138:	20200a0d 20202020 20202020 74732020     ..            st
   24148:	20747261 656e203d 61442077 29286574     art = new Date()
   24158:	200a0d3b 20202020 20202020 72202020     ;..            r
   24168:	65706f2e 4722286e 2c225445 732f2220     .open("GET", "/s
   24178:	6f736e65 74616472 68732e61 226c6d74     ensordata.shtml"
   24188:	7274202c 3b296575 20200a0d 20202020     , true);..      
   24198:	20202020 2e722020 646e6573 6c756e28           r.send(nul
   241a8:	0a0d296c 20202020 20202020 0d0a0d7d     l)..        }...
   241b8:	2020200a 20202020 74657320 65746e49     .        setInte
   241c8:	6c617672 6e756628 6f697463 2029286e     rval(function() 
   241d8:	200a0d7b 20202020 20202020 6c202020     {..            l
   241e8:	4464616f 28617461 0a0d3b29 20202020     oadData();..    
   241f8:	20202020 32202c7d 29303035 200a0d3b         }, 2500);.. 
   24208:	3c202020 7263732f 3e747069 0a0d0a0d        </script>....
   24218:	6f622f3c 0d3e7964 3c0a0d0a 6d74682f     </body>....</htm
   24228:	00003e6c                                l>..

0002422c <data_sensordata_shtml>:
   2422c:	6e65732f 64726f73 2e617461 6d746873     /sensordata.shtm
   2423c:	2125006c 6e657320 2d726f73 64616572     l.%! sensor-read
   2424c:	73676e69 00000000                       ings....

00024254 <data_smoothie_min_js>:
   24254:	6f6d732f 6968746f 696d5f65 736a2e6e     /smoothie_min.js
   24264:	66202100 74636e75 286e6f69 7b202965     .! function(e) {
   24274:	72617620 3d207420 65207b20 6e657478      var t = { exten
   24284:	66203a64 74636e75 286e6f69 207b2029     d: function() { 
   24294:	75677261 746e656d 5d305b73 61203d20     arguments[0] = a
   242a4:	6d756772 73746e65 205d305b 7b207c7c     rguments[0] || {
   242b4:	66203b7d 2820726f 20726176 203d2065     }; for (var e = 
   242c4:	65203b31 61203c20 6d756772 73746e65     1; e < arguments
   242d4:	6e656c2e 3b687467 2b206520 2931203d     .length; e += 1)
   242e4:	20200a0d 20202020 20202020 20202020     ..              
   242f4:	6f662020 76282072 69207261 206e6920       for (var i in 
   24304:	75677261 746e656d 5d655b73 72612029     arguments[e]) ar
   24314:	656d7567 5b73746e 682e5d65 774f7361     guments[e].hasOw
   24324:	6f72506e 74726570 29692879 20262620     nProperty(i) && 
   24334:	626f2228 7463656a 3d3d2022 70797420     ("object" == typ
   24344:	20666f65 75677261 746e656d 5d655b73     eof arguments[e]
   24354:	205d695b 7261203f 656d7567 5b73746e     [i] ? arguments[
   24364:	695b5d65 6e69205d 6e617473 666f6563     e][i] instanceof
   24374:	72724120 3f207961 67726120 6e656d75      Array ? argumen
   24384:	305b7374 5d695b5d 61203d20 6d756772     ts[0][i] = argum
   24394:	73746e65 5b5d655b 3a205d69 67726120     ents[e][i] : arg
   243a4:	6e656d75 305b7374 5d695b5d 74203d20     uments[0][i] = t
   243b4:	7478652e 28646e65 75677261 746e656d     .extend(argument
   243c4:	5d305b73 2c5d695b 67726120 6e656d75     s[0][i], argumen
   243d4:	655b7374 5d695b5d 203a2029 75677261     ts[e][i]) : argu
   243e4:	746e656d 5d305b73 205d695b 7261203d     ments[0][i] = ar
   243f4:	656d7567 5b73746e 695b5d65 203b295d     guments[e][i]); 
   24404:	75746572 61206e72 6d756772 73746e65     return arguments
   24414:	205d305b 3b7d207d 0a0d0a0d 20202020     [0] } };....    
   24424:	636e7566 6e6f6974 65286920 207b2029     function i(e) { 
   24434:	73696874 74706f2e 736e6f69 74203d20     this.options = t
   24444:	7478652e 28646e65 202c7d7b 65642e69     .extend({}, i.de
   24454:	6c756166 74704f74 736e6f69 2965202c     faultOptions, e)
   24464:	6874202c 632e7369 7261656c 7d202928     , this.clear() }
   24474:	0a0d0a0d 20202020 636e7566 6e6f6974     ....    function
   24484:	65286120 207b2029 73696874 74706f2e      a(e) { this.opt
   24494:	736e6f69 74203d20 7478652e 28646e65     ions = t.extend(
   244a4:	202c7d7b 65642e61 6c756166 61684374     {}, a.defaultCha
   244b4:	704f7472 6e6f6974 65202c73 74202c29     rtOptions, e), t
   244c4:	2e736968 69726573 65537365 203d2074     his.seriesSet = 
   244d4:	202c5d5b 73696874 7275632e 746e6572     [], this.current
   244e4:	756c6156 6e615265 3d206567 202c3120     ValueRange = 1, 
   244f4:	73696874 7275632e 746e6572 4d736956     this.currentVisM
   24504:	61566e69 2065756c 2c30203d 69687420     inValue = 0, thi
   24514:	616c2e73 65527473 7265646e 656d6954     s.lastRenderTime
   24524:	6c6c694d 3d207369 7d203020 20200a0d     Millis = 0 }..  
   24534:	2e692020 61666564 4f746c75 6f697470       i.defaultOptio
   24544:	3d20736e 72207b20 74657365 6e756f42     ns = { resetBoun
   24554:	6e497364 76726574 203a6c61 2c336533     dsInterval: 3e3,
   24564:	73657220 6f427465 73646e75 3021203a      resetBounds: !0
   24574:	202c7d20 72702e69 746f746f 2e657079      }, i.prototype.
   24584:	61656c63 203d2072 636e7566 6e6f6974     clear = function
   24594:	7b202928 69687420 61642e73 3d206174     () { this.data =
   245a4:	2c5d5b20 69687420 616d2e73 6c615678      [], this.maxVal
   245b4:	3d206575 6d754e20 2e726562 2c4e614e     ue = Number.NaN,
   245c4:	69687420 696d2e73 6c61566e 3d206575      this.minValue =
   245d4:	6d754e20 2e726562 204e614e 69202c7d      Number.NaN }, i
   245e4:	6f72702e 79746f74 722e6570 74657365     .prototype.reset
   245f4:	6e756f42 3d207364 6e756620 6f697463     Bounds = functio
   24604:	2029286e 6669207b 68742820 642e7369     n() { if (this.d
   24614:	2e617461 676e656c 20296874 6874207b     ata.length) { th
   24624:	6d2e7369 61567861 2065756c 6874203d     is.maxValue = th
   24634:	642e7369 5b617461 315b5d30 74202c5d     is.data[0][1], t
   24644:	2e736968 566e696d 65756c61 74203d20     his.minValue = t
   24654:	2e736968 61746164 5b5d305b 203b5d31     his.data[0][1]; 
   24664:	20726f66 72617628 3d206520 203b3120     for (var e = 1; 
   24674:	203c2065 73696874 7461642e 656c2e61     e < this.data.le
   24684:	6874676e 2065203b 31203d2b 207b2029     ngth; e += 1) { 
   24694:	20726176 203d2074 73696874 7461642e     var t = this.dat
   246a4:	5d655b61 3b5d315b 20200a0d 20202020     a[e][1];..      
   246b4:	20202020 20202020 20742020 6874203e               t > th
   246c4:	6d2e7369 61567861 2065756c 28202626     is.maxValue && (
   246d4:	73696874 78616d2e 756c6156 203d2065     this.maxValue = 
   246e4:	202c2974 203c2074 73696874 6e696d2e     t), t < this.min
   246f4:	756c6156 26262065 68742820 6d2e7369     Value && (this.m
   24704:	61566e69 2065756c 2974203d 7d207d20     inValue = t) } }
   24714:	736c6520 68742065 6d2e7369 61567861      else this.maxVa
   24724:	2065756c 754e203d 7265626d 4e614e2e     lue = Number.NaN
   24734:	6874202c 6d2e7369 61566e69 2065756c     , this.minValue 
   24744:	754e203d 7265626d 4e614e2e 202c7d20     = Number.NaN }, 
   24754:	72702e69 746f746f 2e657079 65707061     i.prototype.appe
   24764:	3d20646e 6e756620 6f697463 2c65286e     nd = function(e,
   24774:	202c7420 7b202969 726f6620 61762820      t, i) { for (va
   24784:	20612072 6874203d 642e7369 2e617461     r a = this.data.
   24794:	676e656c 2d206874 203b3120 3d3e2061     length - 1; a >=
   247a4:	26203020 68742026 642e7369 5b617461      0 && this.data[
   247b4:	305b5d61 203e205d 20293b65 3d2d2061     a][0] > e;) a -=
   247c4:	203b3120 2031202d 203d3d3d 203f2061      1; - 1 === a ? 
   247d4:	73696874 7461642e 70732e61 6563696c     this.data.splice
   247e4:	202c3028 5b202c30 74202c65 3a20295d     (0, 0, [e, t]) :
   247f4:	69687420 61642e73 6c2e6174 74676e65      this.data.lengt
   24804:	203e2068 26262030 69687420 61642e73     h > 0 && this.da
   24814:	615b6174 5d305b5d 3d3d3d20 3f206520     ta[a][0] === e ?
   24824:	3f206920 68742820 642e7369 5b617461      i ? (this.data[
   24834:	315b5d61 3d2b205d 202c7420 203d2074     a][1] += t, t = 
   24844:	73696874 7461642e 5d615b61 295d315b     this.data[a][1])
   24854:	74203a20 2e736968 61746164 5b5d615b      : this.data[a][
   24864:	3d205d31 3a207420 3c206120 69687420     1] = t : a < thi
   24874:	61642e73 6c2e6174 74676e65 202d2068     s.data.length - 
   24884:	203f2031 73696874 7461642e 70732e61     1 ? this.data.sp
   24894:	6563696c 2b206128 202c3120 5b202c30     lice(a + 1, 0, [
   248a4:	74202c65 3a20295d 69687420 61642e73     e, t]) : this.da
   248b4:	702e6174 28687375 202c655b 2c295d74     ta.push([e, t]),
   248c4:	69687420 616d2e73 6c615678 3d206575      this.maxValue =
   248d4:	4e736920 74284e61 2e736968 5678616d      isNaN(this.maxV
   248e4:	65756c61 203f2029 203a2074 6874614d     alue) ? t : Math
   248f4:	78616d2e 69687428 616d2e73 6c615678     .max(this.maxVal
   24904:	202c6575 202c2974 73696874 6e696d2e     ue, t), this.min
   24914:	756c6156 203d2065 614e7369 6874284e     Value = isNaN(th
   24924:	6d2e7369 61566e69 2965756c 74203f20     is.minValue) ? t
   24934:	4d203a20 2e687461 286e696d 73696874      : Math.min(this
   24944:	6e696d2e 756c6156 74202c65 2c7d2029     .minValue, t) },
   24954:	702e6920 6f746f72 65707974 6f72642e      i.prototype.dro
   24964:	646c4f70 61746144 66203d20 74636e75     pOldData = funct
   24974:	286e6f69 74202c65 207b2029 20726f66     ion(e, t) { for 
   24984:	72617628 3d206920 203b3020 73696874     (var i = 0; this
   24994:	7461642e 656c2e61 6874676e 69202d20     .data.length - i
   249a4:	203d3e20 26262074 69687420 61642e73      >= t && this.da
   249b4:	695b6174 31202b20 5d305b5d 65203c20     ta[i + 1][0] < e
   249c4:	6920293b 203d2b20 0a0d3b31 20202020     ;) i += 1;..    
   249d4:	20202020 3d212030 2069203d 74202626         0 !== i && t
   249e4:	2e736968 61746164 6c70732e 28656369     his.data.splice(
   249f4:	69202c30 2c7d2029 642e6120 75616665     0, i) }, a.defau
   24a04:	6843746c 4f747261 6f697470 3d20736e     ltChartOptions =
   24a14:	6d207b20 696c6c69 72655073 65786950      { millisPerPixe
   24a24:	32203a6c 65202c30 6c62616e 69704465     l: 20, enableDpi
   24a34:	6c616353 3a676e69 2c302120 694d7920     Scaling: !0, yMi
   24a44:	726f466e 7474616d 203a7265 636e7566     nFormatter: func
   24a54:	6e6f6974 202c6528 7b202974 74657220     tion(e, t) { ret
   24a64:	206e7275 73726170 6f6c4665 65287461     urn parseFloat(e
   24a74:	6f742e29 65786946 29742864 202c7d20     ).toFixed(t) }, 
   24a84:	78614d79 6d726f46 65747461 66203a72     yMaxFormatter: f
   24a94:	74636e75 286e6f69 74202c65 207b2029     unction(e, t) { 
   24aa4:	75746572 70206e72 65737261 616f6c46     return parseFloa
   24ab4:	29652874 466f742e 64657869 20297428     t(e).toFixed(t) 
   24ac4:	6d202c7d 61567861 5365756c 656c6163     }, maxValueScale
   24ad4:	2c31203a 6e696d20 756c6156 61635365     : 1, minValueSca
   24ae4:	203a656c 69202c31 7265746e 616c6f70     le: 1, interpola
   24af4:	6e6f6974 6222203a 65697a65 202c2272     tion: "bezier", 
   24b04:	6c616373 6f6d5365 6968746f 203a676e     scaleSmoothing: 
   24b14:	3532312e 616d202c 74614478 74655361     .125, maxDataSet
   24b24:	676e654c 203a6874 73202c32 6c6f7263     Length: 2, scrol
   24b34:	6361426c 7261776b 203a7364 202c3121     lBackwards: !1, 
   24b44:	64697267 207b203a 6c6c6966 6c797453     grid: { fillStyl
   24b54:	22203a65 30303023 22303030 7473202c     e: "#000000", st
   24b64:	656b6f72 6c797453 22203a65 37373723     rokeStyle: "#777
   24b74:	22373737 696c202c 6957656e 3a687464     777", lineWidth:
   24b84:	202c3120 72616873 6e694c70 203a7365      1, sharpLines: 
   24b94:	202c3121 6c6c696d 65507369 6e694c72     !1, millisPerLin
   24ba4:	31203a65 202c3365 74726576 6c616369     e: 1e3, vertical
   24bb4:	74636553 736e6f69 2c32203a 726f6220     Sections: 2, bor
   24bc4:	56726564 62697369 203a656c 7d203021     derVisible: !0 }
   24bd4:	616c202c 736c6562 207b203a 6c6c6966     , labels: { fill
   24be4:	6c797453 22203a65 66666623 22666666     Style: "#ffffff"
   24bf4:	6964202c 6c626173 203a6465 202c3121     , disabled: !1, 
   24c04:	746e6f66 657a6953 3031203a 6f66202c     fontSize: 10, fo
   24c14:	6146746e 796c696d 6d22203a 736f6e6f     ntFamily: "monos
   24c24:	65636170 70202c22 69636572 6e6f6973     pace", precision
   24c34:	2032203a 68202c7d 7a69726f 61746e6f     : 2 }, horizonta
   24c44:	6e694c6c 203a7365 7d205d5b 2e61202c     lLines: [] }, a.
   24c54:	6d696e41 43657461 61706d6f 69626974     AnimateCompatibi
   24c64:	7974696c 7b203d20 71657220 74736575     lity = { request
   24c74:	6d696e41 6f697461 6172466e 203a656d     AnimationFrame: 
   24c84:	636e7566 6e6f6974 202c6528 7b202974     function(e, t) {
   24c94:	74657220 206e7275 6e697728 2e776f64      return (window.
   24ca4:	75716572 41747365 616d696e 6e6f6974     requestAnimation
   24cb4:	6d617246 7c7c2065 6e697720 2e776f64     Frame || window.
   24cc4:	6b626577 65527469 73657571 696e4174     webkitRequestAni
   24cd4:	6974616d 72466e6f 20656d61 77207c7c     mationFrame || w
   24ce4:	6f646e69 6f6d2e77 7165527a 74736575     indow.mozRequest
   24cf4:	6d696e41 6f697461 6172466e 7c20656d     AnimationFrame |
   24d04:	6977207c 776f646e 65526f2e 73657571     | window.oReques
   24d14:	696e4174 6974616d 72466e6f 20656d61     tAnimationFrame 
   24d24:	77207c7c 6f646e69 736d2e77 75716552     || window.msRequ
   24d34:	41747365 616d696e 6e6f6974 6d617246     estAnimationFram
   24d44:	7c7c2065 6e756620 6f697463 2965286e     e || function(e)
   24d54:	72207b20 72757465 6977206e 776f646e      { return window
   24d64:	7465732e 656d6954 2874756f 636e7566     .setTimeout(func
   24d74:	6e6f6974 7b202928 28286520 2077656e     tion() { e((new 
   24d84:	65746144 65672e29 6d695474 29292865     Date).getTime())
   24d94:	202c7d20 20293631 632e297d 286c6c61      }, 16) }).call(
   24da4:	646e6977 202c776f 74202c65 2c7d2029     window, e, t) },
   24db4:	6e616320 416c6563 616d696e 6e6f6974      cancelAnimation
   24dc4:	6d617246 66203a65 74636e75 286e6f69     Frame: function(
   24dd4:	7b202965 74657220 206e7275 6e697728     e) { return (win
   24de4:	2e776f64 636e6163 6e416c65 74616d69     dow.cancelAnimat
   24df4:	466e6f69 656d6172 207c7c20 636e7566     ionFrame || func
   24e04:	6e6f6974 20296528 6c63207b 54726165     tion(e) { clearT
   24e14:	6f656d69 65287475 297d2029 6c61632e     imeout(e) }).cal
   24e24:	6977286c 776f646e 2965202c 7d207d20     l(window, e) } }
   24e34:	2e61202c 61666564 53746c75 65697265     , a.defaultSerie
   24e44:	65725073 746e6573 6f697461 74704f6e     sPresentationOpt
   24e54:	736e6f69 7b203d20 6e696c20 64695765     ions = { lineWid
   24e64:	203a6874 73202c31 6b6f7274 79745365     th: 1, strokeSty
   24e74:	203a656c 66662322 66666666 2c7d2022     le: "#ffffff" },
   24e84:	702e6120 6f746f72 65707974 6464612e      a.prototype.add
   24e94:	656d6954 69726553 3d207365 6e756620     TimeSeries = fun
   24ea4:	6f697463 2c65286e 20296920 6874207b     ction(e, i) { th
   24eb4:	732e7369 65697265 74655373 7375702e     is.seriesSet.pus
   24ec4:	207b2868 656d6974 69726553 203a7365     h({ timeSeries: 
   24ed4:	6f202c65 6f697470 203a736e 78652e74     e, options: t.ex
   24ee4:	646e6574 2c7d7b28 642e6120 75616665     tend({}, a.defau
   24ef4:	6553746c 73656972 73657250 61746e65     ltSeriesPresenta
   24f04:	6e6f6974 6974704f 2c736e6f 20296920     tionOptions, i) 
   24f14:	202c297d 706f2e65 6e6f6974 65722e73     }), e.options.re
   24f24:	42746573 646e756f 26262073 6f2e6520     setBounds && e.o
   24f34:	6f697470 722e736e 74657365 6e756f42     ptions.resetBoun
   24f44:	6e497364 76726574 3e206c61 26203020     dsInterval > 0 &
   24f54:	65282026 7365722e 6f427465 73646e75     & (e.resetBounds
   24f64:	656d6954 20644972 6573203d 746e4974     TimerId = setInt
   24f74:	61767265 7566286c 6974636e 29286e6f     erval(function()
   24f84:	65207b20 7365722e 6f427465 73646e75      { e.resetBounds
   24f94:	7d202928 2e65202c 6974706f 2e736e6f     () }, e.options.
   24fa4:	65736572 756f4274 4973646e 7265746e     resetBoundsInter
   24fb4:	296c6176 2c7d2029 702e6120 6f746f72     val)) }, a.proto
   24fc4:	65707974 6d65722e 5465766f 53656d69     type.removeTimeS
   24fd4:	65697265 203d2073 636e7566 6e6f6974     eries = function
   24fe4:	20296528 6f66207b 76282072 74207261     (e) { for (var t
   24ff4:	74203d20 2e736968 69726573 65537365      = this.seriesSe
   25004:	656c2e74 6874676e 2069202c 3b30203d     t.length, i = 0;
   25014:	3c206920 203b7420 3d2b2069 0d293120      i < t; i += 1).
   25024:	2020200a 20202020 20202020 20666920     .            if 
   25034:	69687428 65732e73 73656972 5b746553     (this.seriesSet[
   25044:	742e5d69 53656d69 65697265 3d3d2073     i].timeSeries ==
   25054:	2965203d 74207b20 2e736968 69726573     = e) { this.seri
   25064:	65537365 70732e74 6563696c 202c6928     esSet.splice(i, 
   25074:	203b2931 61657262 0d7d206b 2020200a     1); break }..   
   25084:	20202020 722e6520 74657365 6e756f42          e.resetBoun
   25094:	69547364 4972656d 26262064 656c6320     dsTimerId && cle
   250a4:	6e497261 76726574 65286c61 7365722e     arInterval(e.res
   250b4:	6f427465 73646e75 656d6954 29644972     etBoundsTimerId)
   250c4:	202c7d20 72702e61 746f746f 2e657079      }, a.prototype.
   250d4:	54746567 53656d69 65697265 74704f73     getTimeSeriesOpt
   250e4:	736e6f69 66203d20 74636e75 286e6f69     ions = function(
   250f4:	7b202965 726f6620 61762820 20742072     e) { for (var t 
   25104:	6874203d 732e7369 65697265 74655373     = this.seriesSet
   25114:	6e656c2e 2c687467 3d206920 203b3020     .length, i = 0; 
   25124:	203c2069 69203b74 203d2b20 0a0d2931     i < t; i += 1)..
   25134:	20202020 20202020 20202020 28206669                 if (
   25144:	73696874 7265732e 53736569 695b7465     this.seriesSet[i
   25154:	69742e5d 6553656d 73656972 3d3d3d20     ].timeSeries ===
   25164:	20296520 75746572 74206e72 2e736968      e) return this.
   25174:	69726573 65537365 5d695b74 74706f2e     seriesSet[i].opt
   25184:	736e6f69 202c7d20 72702e61 746f746f     ions }, a.protot
   25194:	2e657079 6e697262 466f5467 746e6f72     ype.bringToFront
   251a4:	66203d20 74636e75 286e6f69 7b202965      = function(e) {
   251b4:	726f6620 61762820 20742072 6874203d      for (var t = th
   251c4:	732e7369 65697265 74655373 6e656c2e     is.seriesSet.len
   251d4:	2c687467 3d206920 203b3020 203c2069     gth, i = 0; i < 
   251e4:	69203b74 203d2b20 0a0d2931 20202020     t; i += 1)..    
   251f4:	20202020 20202020 28206669 73696874             if (this
   25204:	7265732e 53736569 695b7465 69742e5d     .seriesSet[i].ti
   25214:	6553656d 73656972 3d3d3d20 20296520     meSeries === e) 
   25224:	6176207b 20612072 6874203d 732e7369     { var a = this.s
   25234:	65697265 74655373 6c70732e 28656369     eriesSet.splice(
   25244:	31202c69 0a0d3b29 20202020 20202020     i, 1);..        
   25254:	20202020 20202020 73696874 7265732e             this.ser
   25264:	53736569 702e7465 28687375 5d305b61     iesSet.push(a[0]
   25274:	62203b29 6b616572 7d207d20 2e61202c     ); break } }, a.
   25284:	746f7270 7079746f 74732e65 6d616572     prototype.stream
   25294:	3d206f54 6e756620 6f697463 2c65286e     To = function(e,
   252a4:	20297420 6874207b 632e7369 61766e61      t) { this.canva
   252b4:	203d2073 74202c65 2e736968 616c6564     s = e, this.dela
   252c4:	203d2079 74202c74 2e736968 72617473     y = t, this.star
   252d4:	20292874 61202c7d 6f72702e 79746f74     t() }, a.prototy
   252e4:	722e6570 7a697365 203d2065 636e7566     pe.resize = func
   252f4:	6e6f6974 7b202928 20666920 69687428     tion() { if (thi
   25304:	706f2e73 6e6f6974 6e652e73 656c6261     s.options.enable
   25314:	53697044 696c6163 2620676e 69772026     DpiScaling && wi
   25324:	776f646e 20262620 3d212031 6977203d     ndow && 1 !== wi
   25334:	776f646e 7665642e 50656369 6c657869     ndow.devicePixel
   25344:	69746152 7b20296f 72617620 3d206520     Ratio) { var e =
   25354:	6e697720 2e776f64 69766564 69506563      window.devicePi
   25364:	526c6578 6f697461 200a0d2c 20202020     xelRatio,..     
   25374:	20202020 20202020 74202020 70203d20                t = p
   25384:	65737261 28746e49 73696874 6e61632e     arseInt(this.can
   25394:	2e736176 41746567 69727474 65747562     vas.getAttribute
   253a4:	69772228 22687464 0d2c2929 2020200a     ("width")),..   
   253b4:	20202020 20202020 20202020 3d206920                  i =
   253c4:	72617020 6e496573 68742874 632e7369      parseInt(this.c
   253d4:	61766e61 65672e73 74744174 75626972     anvas.getAttribu
   253e4:	22286574 67696568 29227468 0a0d3b29     te("height"));..
   253f4:	20202020 20202020 20202020 73696874                 this
   25404:	69726f2e 616e6967 6469576c 26206874     .originalWidth &
   25414:	614d2026 662e6874 726f6f6c 69687428     & Math.floor(thi
   25424:	726f2e73 6e696769 69576c61 20687464     s.originalWidth 
   25434:	2965202a 3d3d3d20 7c207420 7428207c     * e) === t || (t
   25444:	2e736968 6769726f 6c616e69 74646957     his.originalWidt
   25454:	203d2068 74202c74 2e736968 766e6163     h = t, this.canv
   25464:	732e7361 74417465 62697274 28657475     as.setAttribute(
   25474:	64697722 2c226874 74614d20 6c662e68     "width", Math.fl
   25484:	28726f6f 202a2074 742e2965 7274536f     oor(t * e).toStr
   25494:	28676e69 202c2929 73696874 6e61632e     ing()), this.can
   254a4:	2e736176 6c797473 69772e65 20687464     vas.style.width 
   254b4:	2074203d 7022202b 202c2278 73696874     = t + "px", this
   254c4:	6e61632e 2e736176 43746567 65746e6f     .canvas.getConte
   254d4:	22287478 29226432 6163732e 6528656c     xt("2d").scale(e
   254e4:	2965202c 74202c29 2e736968 6769726f     , e)), this.orig
   254f4:	6c616e69 67696548 26207468 614d2026     inalHeight && Ma
   25504:	662e6874 726f6f6c 69687428 726f2e73     th.floor(this.or
   25514:	6e696769 65486c61 74686769 65202a20     iginalHeight * e
   25524:	3d3d2029 2069203d 28207c7c 73696874     ) === i || (this
   25534:	69726f2e 616e6967 6965486c 20746867     .originalHeight 
   25544:	2c69203d 69687420 61632e73 7361766e     = i, this.canvas
   25554:	7465732e 72747441 74756269 68222865     .setAttribute("h
   25564:	68676965 202c2274 6874614d 6f6c662e     eight", Math.flo
   25574:	6928726f 65202a20 6f742e29 69727453     or(i * e).toStri
   25584:	2928676e 74202c29 2e736968 766e6163     ng()), this.canv
   25594:	732e7361 656c7974 6965682e 20746867     as.style.height 
   255a4:	2069203d 7022202b 202c2278 73696874     = i + "px", this
   255b4:	6e61632e 2e736176 43746567 65746e6f     .canvas.getConte
   255c4:	22287478 29226432 6163732e 6528656c     xt("2d").scale(e
   255d4:	2965202c 207d2029 61202c7d 6f72702e     , e)) } }, a.pro
   255e4:	79746f74 732e6570 74726174 66203d20     totype.start = f
   255f4:	74636e75 286e6f69 207b2029 28206669     unction() { if (
   25604:	69687421 72662e73 29656d61 76207b20     !this.frame) { v
   25614:	65207261 66203d20 74636e75 286e6f69     ar e = function(
   25624:	207b2029 73696874 6172662e 3d20656d     ) { this.frame =
   25634:	412e6120 616d696e 6f436574 7461706d      a.AnimateCompat
   25644:	6c696269 2e797469 75716572 41747365     ibility.requestA
   25654:	616d696e 6e6f6974 6d617246 75662865     nimationFrame(fu
   25664:	6974636e 29286e6f 74207b20 2e736968     nction() { this.
   25674:	646e6572 29287265 2865202c 2e7d2029     render(), e() }.
   25684:	646e6962 69687428 20292973 69622e7d     bind(this)) }.bi
   25694:	7428646e 29736968 200a0d3b 20202020     nd(this);..     
   256a4:	20202020 65202020 7d202928 202c7d20            e() } }, 
   256b4:	72702e61 746f746f 2e657079 706f7473     a.prototype.stop
   256c4:	66203d20 74636e75 286e6f69 207b2029      = function() { 
   256d4:	73696874 6172662e 2620656d 61282026     this.frame && (a
   256e4:	696e412e 6574616d 706d6f43 62697461     .AnimateCompatib
   256f4:	74696c69 61632e79 6c65636e 6d696e41     ility.cancelAnim
   25704:	6f697461 6172466e 7428656d 2e736968     ationFrame(this.
   25714:	6d617266 202c2965 656c6564 74206574     frame), delete t
   25724:	2e736968 6d617266 7d202965 2e61202c     his.frame) }, a.
   25734:	746f7270 7079746f 70752e65 65746164     prototype.update
   25744:	756c6156 6e615265 3d206567 6e756620     ValueRange = fun
   25754:	6f697463 2029286e 6f66207b 76282072     ction() { for (v
   25764:	65207261 74203d20 2e736968 6974706f     ar e = this.opti
   25774:	2c736e6f 3d207420 6d754e20 2e726562     ons, t = Number.
   25784:	2c4e614e 3d206920 6d754e20 2e726562     NaN, i = Number.
   25794:	2c4e614e 3d206120 203b3020 203c2061     NaN, a = 0; a < 
   257a4:	73696874 7265732e 53736569 6c2e7465     this.seriesSet.l
   257b4:	74676e65 61203b68 203d2b20 7b202931     ength; a += 1) {
   257c4:	72617620 3d207320 69687420 65732e73      var s = this.se
   257d4:	73656972 5b746553 742e5d61 53656d69     riesSet[a].timeS
   257e4:	65697265 0a0d3b73 20202020 20202020     eries;..        
   257f4:	20202020 614e7369 2e73284e 5678616d         isNaN(s.maxV
   25804:	65756c61 7c7c2029 20742820 7369203d     alue) || (t = is
   25814:	284e614e 3f202974 6d2e7320 61567861     NaN(t) ? s.maxVa
   25824:	2065756c 614d203a 6d2e6874 74287861     lue : Math.max(t
   25834:	2e73202c 5678616d 65756c61 202c2929     , s.maxValue)), 
   25844:	614e7369 2e73284e 566e696d 65756c61     isNaN(s.minValue
   25854:	7c7c2029 20692820 7369203d 284e614e     ) || (i = isNaN(
   25864:	3f202969 6d2e7320 61566e69 2065756c     i) ? s.minValue 
   25874:	614d203a 6d2e6874 69286e69 2e73202c     : Math.min(i, s.
   25884:	566e696d 65756c61 7d202929 20666920     minValue)) } if 
   25894:	6c756e28 3d21206c 6d2e6520 61567861     (null != e.maxVa
   258a4:	2065756c 2074203f 2e65203d 5678616d     lue ? t = e.maxV
   258b4:	65756c61 74203a20 203d2a20 616d2e65     alue : t *= e.ma
   258c4:	6c615678 63536575 2c656c61 6c756e20     xValueScale, nul
   258d4:	3d21206c 6d2e6520 61566e69 2065756c     l != e.minValue 
   258e4:	2069203f 2e65203d 566e696d 65756c61     ? i = e.minValue
   258f4:	69203a20 203d2d20 6874614d 7362612e      : i -= Math.abs
   25904:	2a206928 6d2e6520 61566e69 5365756c     (i * e.minValueS
   25914:	656c6163 69202d20 74202c29 2e736968     cale - i), this.
   25924:	6974706f 2e736e6f 6e615279 75466567     options.yRangeFu
   25934:	6974636e 20296e6f 6176207b 206e2072     nction) { var n 
   25944:	6874203d 6f2e7369 6f697470 792e736e     = this.options.y
   25954:	676e6152 6e754665 6f697463 207b286e     RangeFunction({ 
   25964:	3a6e696d 202c6920 3a78616d 7d207420     min: i, max: t }
   25974:	0a0d3b29 20202020 20202020 20202020     );..            
   25984:	203d2069 696d2e6e 74202c6e 6e203d20     i = n.min, t = n
   25994:	78616d2e 69207d20 21282066 614e7369     .max } if (!isNa
   259a4:	2974284e 20262620 4e736921 69284e61     N(t) && !isNaN(i
   259b4:	7b202929 72617620 3d207220 2d207420     )) { var r = t -
   259c4:	2d206920 69687420 75632e73 6e657272      i - this.curren
   259d4:	6c615674 61526575 2c65676e 20200a0d     tValueRange,..  
   259e4:	20202020 20202020 20202020 206c2020                   l 
   259f4:	2069203d 6874202d 632e7369 65727275     = i - this.curre
   25a04:	6956746e 6e694d73 756c6156 0a0d3b65     ntVisMinValue;..
   25a14:	20202020 20202020 20202020 73696874                 this
   25a24:	4173692e 616d696e 676e6974 6c616353     .isAnimatingScal
   25a34:	203d2065 6874614d 7362612e 20297228     e = Math.abs(r) 
   25a44:	312e203e 207c7c20 6874614d 7362612e     > .1 || Math.abs
   25a54:	20296c28 312e203e 6874202c 632e7369     (l) > .1, this.c
   25a64:	65727275 6156746e 5265756c 65676e61     urrentValueRange
   25a74:	203d2b20 63732e65 53656c61 746f6f6d      += e.scaleSmoot
   25a84:	676e6968 72202a20 6874202c 632e7369     hing * r, this.c
   25a94:	65727275 6956746e 6e694d73 756c6156     urrentVisMinValu
   25aa4:	3d2b2065 732e6520 656c6163 6f6f6d53     e += e.scaleSmoo
   25ab4:	6e696874 202a2067 0d7d206c 2020200a     thing * l }..   
   25ac4:	20202020 69687420 61762e73 5265756c          this.valueR
   25ad4:	65676e61 7b203d20 6e696d20 2c69203a     ange = { min: i,
   25ae4:	78616d20 2074203a 2c7d207d 702e6120      max: t } }, a.p
   25af4:	6f746f72 65707974 6e65722e 20726564     rototype.render 
   25b04:	7566203d 6974636e 65286e6f 2974202c     = function(e, t)
   25b14:	76207b20 69207261 28203d20 2077656e      { var i = (new 
   25b24:	65746144 65672e29 6d695474 3b292865     Date).getTime();
   25b34:	20666920 68742128 692e7369 696e4173      if (!this.isAni
   25b44:	6974616d 6353676e 29656c61 76207b20     matingScale) { v
   25b54:	61207261 4d203d20 2e687461 286e696d     ar a = Math.min(
   25b64:	20336531 2c36202f 69687420 706f2e73     1e3 / 6, this.op
   25b74:	6e6f6974 696d2e73 73696c6c 50726550     tions.millisPerP
   25b84:	6c657869 69203b29 69282066 74202d20     ixel); if (i - t
   25b94:	2e736968 7473616c 646e6552 69547265     his.lastRenderTi
   25ba4:	694d656d 73696c6c 61203c20 65722029     meMillis < a) re
   25bb4:	6e727574 0a0d7d20 20202020 20202020     turn }..        
   25bc4:	73696874 7365722e 28657a69 74202c29     this.resize(), t
   25bd4:	2e736968 7473616c 646e6552 69547265     his.lastRenderTi
   25be4:	694d656d 73696c6c 69203d20 2065202c     meMillis = i, e 
   25bf4:	2065203d 74207c7c 2e736968 766e6163     = e || this.canv
   25c04:	202c7361 203d2074 7c7c2074 2d206920     as, t = t || i -
   25c14:	68742820 642e7369 79616c65 207c7c20      (this.delay || 
   25c24:	202c2930 3d2d2074 25207420 69687420     0), t -= t % thi
   25c34:	706f2e73 6e6f6974 696d2e73 73696c6c     s.options.millis
   25c44:	50726550 6c657869 6176203b 20732072     PerPixel; var s 
   25c54:	2e65203d 43746567 65746e6f 22287478     = e.getContext("
   25c64:	29226432 200a0d2c 20202020 20202020     2d"),..         
   25c74:	6e202020 74203d20 2e736968 6974706f        n = this.opti
   25c84:	2c736e6f 20200a0d 20202020 20202020     ons,..          
   25c94:	20722020 207b203d 3a706f74 202c3020       r = { top: 0, 
   25ca4:	7466656c 2c30203a 64697720 203a6874     left: 0, width: 
   25cb4:	6c632e65 746e6569 74646957 68202c68     e.clientWidth, h
   25cc4:	68676965 65203a74 696c632e 48746e65     eight: e.clientH
   25cd4:	68676965 2c7d2074 20200a0d 20202020     eight },..      
   25ce4:	20202020 206c2020 2074203d 2e72202d           l = t - r.
   25cf4:	74646977 202a2068 696d2e6e 73696c6c     width * n.millis
   25d04:	50726550 6c657869 200a0d2c 20202020     PerPixel,..     
   25d14:	20202020 6f202020 66203d20 74636e75            o = funct
   25d24:	286e6f69 7b202965 72617620 3d207420     ion(e) { var t =
   25d34:	2d206520 69687420 75632e73 6e657272      e - this.curren
   25d44:	73695674 566e694d 65756c61 6572203b     tVisMinValue; re
   25d54:	6e727574 3d203020 74203d3d 2e736968     turn 0 === this.
   25d64:	72727563 56746e65 65756c61 676e6152     currentValueRang
   25d74:	203f2065 65682e72 74686769 72203a20     e ? r.height : r
   25d84:	6965682e 20746867 614d202d 722e6874     .height - Math.r
   25d94:	646e756f 2f207428 69687420 75632e73     ound(t / this.cu
   25da4:	6e657272 6c615674 61526575 2065676e     rrentValueRange 
   25db4:	2e72202a 67696568 20297468 69622e7d     * r.height) }.bi
   25dc4:	7428646e 29736968 200a0d2c 20202020     nd(this),..     
   25dd4:	20202020 68202020 66203d20 74636e75            h = funct
   25de4:	286e6f69 7b202965 74657220 206e7275     ion(e) { return 
   25df4:	63732e6e 6c6c6f72 6b636142 64726177     n.scrollBackward
   25e04:	203f2073 6874614d 756f722e 2828646e     s ? Math.round((
   25e14:	202d2074 2f202965 6d2e6e20 696c6c69     t - e) / n.milli
   25e24:	72655073 65786950 3a20296c 74614d20     sPerPixel) : Mat
   25e34:	6f722e68 28646e75 69772e72 20687464     h.round(r.width 
   25e44:	7428202d 65202d20 202f2029 696d2e6e     - (t - e) / n.mi
   25e54:	73696c6c 50726550 6c657869 3b7d2029     llisPerPixel) };
   25e64:	20666920 69687428 70752e73 65746164      if (this.update
   25e74:	756c6156 6e615265 29286567 2e73202c     ValueRange(), s.
   25e84:	746e6f66 6e203d20 62616c2e 2e736c65     font = n.labels.
   25e94:	746e6f66 657a6953 22202b20 22207870     fontSize + "px "
   25ea4:	6e202b20 62616c2e 2e736c65 746e6f66      + n.labels.font
   25eb4:	696d6146 202c796c 61732e73 29286576     Family, s.save()
   25ec4:	2e73202c 6e617274 74616c73 2e722865     , s.translate(r.
   25ed4:	7466656c 2e72202c 29706f74 2e73202c     left, r.top), s.
   25ee4:	69676562 7461506e 2c292868 722e7320     beginPath(), s.r
   25ef4:	28746365 30202c30 2e72202c 74646977     ect(0, 0, r.widt
   25f04:	72202c68 6965682e 29746867 2e73202c     h, r.height), s.
   25f14:	70696c63 202c2928 61732e73 29286576     clip(), s.save()
   25f24:	2e73202c 6c6c6966 6c797453 203d2065     , s.fillStyle = 
   25f34:	72672e6e 662e6469 536c6c69 656c7974     n.grid.fillStyle
   25f44:	2e73202c 61656c63 63655272 2c302874     , s.clearRect(0,
   25f54:	202c3020 69772e72 2c687464 682e7220      0, r.width, r.h
   25f64:	68676965 202c2974 69662e73 65526c6c     eight), s.fillRe
   25f74:	30287463 2c30202c 772e7220 68746469     ct(0, 0, r.width
   25f84:	2e72202c 67696568 2c297468 722e7320     , r.height), s.r
   25f94:	6f747365 29286572 2e73202c 65766173     estore(), s.save
   25fa4:	202c2928 696c2e73 6957656e 20687464     (), s.lineWidth 
   25fb4:	2e6e203d 64697267 6e696c2e 64695765     = n.grid.lineWid
   25fc4:	202c6874 74732e73 656b6f72 6c797453     th, s.strokeStyl
   25fd4:	203d2065 72672e6e 732e6469 6b6f7274     e = n.grid.strok
   25fe4:	79745365 202c656c 72672e6e 6d2e6469     eStyle, n.grid.m
   25ff4:	696c6c69 72655073 656e694c 30203e20     illisPerLine > 0
   26004:	207b2029 65622e73 506e6967 28687461     ) { s.beginPath(
   26014:	66203b29 2820726f 20726176 203d2064     ); for (var d = 
   26024:	202d2074 20252074 72672e6e 6d2e6469     t - t % n.grid.m
   26034:	696c6c69 72655073 656e694c 2064203b     illisPerLine; d 
   26044:	6c203d3e 2064203b 6e203d2d 6972672e     >= l; d -= n.gri
   26054:	696d2e64 73696c6c 4c726550 29656e69     d.millisPerLine)
   26064:	76207b20 75207261 68203d20 3b296428      { var u = h(d);
   26074:	20200a0d 20202020 20202020 20202020     ..              
   26084:	2e6e2020 64697267 6168732e 694c7072       n.grid.sharpLi
   26094:	2073656e 28202626 3d2d2075 29352e20     nes && (u -= .5)
   260a4:	2e73202c 65766f6d 75286f54 2930202c     , s.moveTo(u, 0)
   260b4:	2e73202c 656e696c 75286f54 2e72202c     , s.lineTo(u, r.
   260c4:	67696568 20297468 200a0d7d 20202020     height) }..     
   260d4:	20202020 73202020 7274732e 28656b6f            s.stroke(
   260e4:	73202c29 6f6c632e 61506573 29286874     ), s.closePath()
   260f4:	66207d20 2820726f 20726176 203d206d      } for (var m = 
   26104:	6d203b31 6e203c20 6972672e 65762e64     1; m < n.grid.ve
   26114:	63697472 65536c61 6f697463 203b736e     rticalSections; 
   26124:	3d2b206d 20293120 6176207b 20632072     m += 1) { var c 
   26134:	614d203d 722e6874 646e756f 2a206d28     = Math.round(m *
   26144:	682e7220 68676965 202f2074 72672e6e      r.height / n.gr
   26154:	762e6469 69747265 536c6163 69746365     id.verticalSecti
   26164:	29736e6f 200a0d3b 20202020 20202020     ons);..         
   26174:	6e202020 6972672e 68732e64 4c707261        n.grid.sharpL
   26184:	73656e69 20262620 2d206328 352e203d     ines && (c -= .5
   26194:	73202c29 6765622e 61506e69 29286874     ), s.beginPath()
   261a4:	2e73202c 65766f6d 30286f54 2963202c     , s.moveTo(0, c)
   261b4:	2e73202c 656e696c 72286f54 6469772e     , s.lineTo(r.wid
   261c4:	202c6874 202c2963 74732e73 656b6f72     th, c), s.stroke
   261d4:	202c2928 6c632e73 5065736f 28687461     (), s.closePath(
   261e4:	207d2029 28206669 72672e6e 622e6469     ) } if (n.grid.b
   261f4:	6564726f 73695672 656c6269 20262620     orderVisible && 
   26204:	622e7328 6e696765 68746150 202c2928     (s.beginPath(), 
   26214:	74732e73 656b6f72 74636552 202c3028     s.strokeRect(0, 
   26224:	72202c30 6469772e 202c6874 65682e72     0, r.width, r.he
   26234:	74686769 73202c29 6f6c632e 61506573     ight), s.closePa
   26244:	29286874 73202c29 7365722e 65726f74     th()), s.restore
   26254:	202c2928 6f682e6e 6f7a6972 6c61746e     (), n.horizontal
   26264:	656e694c 26262073 682e6e20 7a69726f     Lines && n.horiz
   26274:	61746e6f 6e694c6c 6c2e7365 74676e65     ontalLines.lengt
   26284:	0a0d2968 20202020 20202020 20202020     h)..            
   26294:	20726f66 72617628 3d206620 203b3020     for (var f = 0; 
   262a4:	203c2066 6f682e6e 6f7a6972 6c61746e     f < n.horizontal
   262b4:	656e694c 656c2e73 6874676e 2066203b     Lines.length; f 
   262c4:	31203d2b 207b2029 20726176 203d2067     += 1) { var g = 
   262d4:	6f682e6e 6f7a6972 6c61746e 656e694c     n.horizontalLine
   262e4:	5d665b73 200a0d2c 20202020 20202020     s[f],..         
   262f4:	20202020 20202020 70202020 4d203d20                p = M
   26304:	2e687461 6e756f72 286f2864 61762e67     ath.round(o(g.va
   26314:	2965756c 202d2029 0d3b352e 2020200a     lue)) - .5;..   
   26324:	20202020 20202020 20202020 732e7320                  s.s
   26334:	6b6f7274 79745365 3d20656c 632e6720     trokeStyle = g.c
   26344:	726f6c6f 207c7c20 66662322 66666666     olor || "#ffffff
   26354:	73202c22 6e696c2e 64695765 3d206874     ", s.lineWidth =
   26364:	6c2e6720 57656e69 68746469 207c7c20      g.lineWidth || 
   26374:	73202c31 6765622e 61506e69 29286874     1, s.beginPath()
   26384:	2e73202c 65766f6d 30286f54 2970202c     , s.moveTo(0, p)
   26394:	2e73202c 656e696c 72286f54 6469772e     , s.lineTo(r.wid
   263a4:	202c6874 202c2970 74732e73 656b6f72     th, p), s.stroke
   263b4:	202c2928 6c632e73 5065736f 28687461     (), s.closePath(
   263c4:	0d7d2029 2020200a 20202020 726f6620     ) }..        for
   263d4:	61762820 20532072 3b30203d 3c205320      (var S = 0; S <
   263e4:	69687420 65732e73 73656972 2e746553      this.seriesSet.
   263f4:	676e656c 203b6874 3d2b2053 20293120     length; S += 1) 
   26404:	2e73207b 65766173 203b2928 20726176     { s.save(); var 
   26414:	203d2076 73696874 7265732e 53736569     v = this.seriesS
   26424:	535b7465 69742e5d 6553656d 73656972     et[S].timeSeries
   26434:	200a0d2c 20202020 20202020 20202020     ,..             
   26444:	77202020 76203d20 7461642e 0a0d2c61        w = v.data,..
   26454:	20202020 20202020 20202020 20202020                     
   26464:	203d2078 73696874 7265732e 53736569     x = this.seriesS
   26474:	535b7465 706f2e5d 6e6f6974 0a0d3b73     et[S].options;..
   26484:	20202020 20202020 20202020 72642e76                 v.dr
   26494:	6c4f706f 74614464 2c6c2861 6d2e6e20     opOldData(l, n.m
   264a4:	61447861 65536174 6e654c74 29687467     axDataSetLength)
   264b4:	2e73202c 656e696c 74646957 203d2068     , s.lineWidth = 
   264c4:	696c2e78 6957656e 2c687464 732e7320     x.lineWidth, s.s
   264d4:	6b6f7274 79745365 3d20656c 732e7820     trokeStyle = x.s
   264e4:	6b6f7274 79745365 202c656c 65622e73     trokeStyle, s.be
   264f4:	506e6967 28687461 66203b29 2820726f     ginPath(); for (
   26504:	20726176 203d2079 62202c30 30203d20     var y = 0, b = 0
   26514:	2056202c 2c30203d 3d205420 203b3020     , V = 0, T = 0; 
   26524:	203c2054 656c2e77 6874676e 20262620     T < w.length && 
   26534:	3d212031 2e77203d 676e656c 203b6874     1 !== w.length; 
   26544:	3d2b2054 20293120 6176207b 204e2072     T += 1) { var N 
   26554:	2868203d 5d545b77 295d305b 200a0d2c     = h(w[T][0]),.. 
   26564:	20202020 20202020 20202020 20202020                     
   26574:	50202020 6f203d20 545b7728 5d315b5d        P = o(w[T][1]
   26584:	69203b29 30282066 3d3d3d20 20295420     ); if (0 === T) 
   26594:	203d2079 73202c4e 766f6d2e 286f5465     y = N, s.moveTo(
   265a4:	50202c4e 0a0d3b29 20202020 20202020     N, P);..        
   265b4:	20202020 20202020 65736c65 69777320             else swi
   265c4:	20686374 692e6e28 7265746e 616c6f70     tch (n.interpola
   265d4:	6e6f6974 0d7b2029 2020200a 20202020     tion) {..       
   265e4:	20202020 20202020 20202020 73616320                  cas
   265f4:	6c222065 61656e69 0d3a2272 2020200a     e "linear":..   
   26604:	20202020 20202020 20202020 20202020                     
   26614:	73616320 6c222065 22656e69 200a0d3a      case "line":.. 
   26624:	20202020 20202020 20202020 20202020                     
   26634:	20202020 73202020 6e696c2e 286f5465            s.lineTo(
   26644:	50202c4e 62203b29 6b616572 200a0d3b     N, P); break;.. 
   26654:	20202020 20202020 20202020 20202020                     
   26664:	63202020 20657361 7a656222 22726569        case "bezier"
   26674:	200a0d3a 20202020 20202020 20202020     :..             
   26684:	20202020 64202020 75616665 0d3a746c            default:.
   26694:	2020200a 20202020 20202020 20202020     .               
   266a4:	20202020 20202020 622e7320 65697a65              s.bezie
   266b4:	72754372 6f546576 74614d28 6f722e68     rCurveTo(Math.ro
   266c4:	28646e75 2b206228 20294e20 2932202f     und((b + N) / 2)
   266d4:	2c56202c 74614d20 6f722e68 28646e75     , V, Math.round(
   266e4:	202b2062 2f20294e 202c3220 4e202c50     b + N) / 2, P, N
   266f4:	2950202c 7262203b 3b6b6165 20200a0d     , P); break;..  
   26704:	20202020 20202020 20202020 20202020                     
   26714:	61632020 22206573 70657473 0a0d3a22       case "step":..
   26724:	20202020 20202020 20202020 20202020                     
   26734:	20202020 20202020 696c2e73 6f54656e             s.lineTo
   26744:	202c4e28 202c2956 696c2e73 6f54656e     (N, V), s.lineTo
   26754:	202c4e28 7d202950 20200a0d 20202020     (N, P) }..      
   26764:	20202020 20202020 20622020 2c4e203d               b = N,
   26774:	3d205620 7d205020 20200a0d 20202020      V = P }..      
   26784:	20202020 2e772020 676e656c 3e206874           w.length >
   26794:	26203120 78282026 6c69662e 7974536c      1 && (x.fillSty
   267a4:	2620656c 73282026 6e696c2e 286f5465     le && (s.lineTo(
   267b4:	69772e72 20687464 2e78202b 656e696c     r.width + x.line
   267c4:	74646957 202b2068 56202c31 73202c29     Width + 1, V), s
   267d4:	6e696c2e 286f5465 69772e72 20687464     .lineTo(r.width 
   267e4:	2e78202b 656e696c 74646957 202b2068     + x.lineWidth + 
   267f4:	72202c31 6965682e 20746867 2e78202b     1, r.height + x.
   26804:	656e696c 74646957 202b2068 202c2931     lineWidth + 1), 
   26814:	696c2e73 6f54656e 202c7928 65682e72     s.lineTo(y, r.he
   26824:	74686769 78202b20 6e696c2e 64695765     ight + x.lineWid
   26834:	2c296874 662e7320 536c6c69 656c7974     th), s.fillStyle
   26844:	78203d20 6c69662e 7974536c 202c656c      = x.fillStyle, 
   26854:	69662e73 29286c6c 78202c29 7274732e     s.fill()), x.str
   26864:	53656b6f 656c7974 20262620 6e6f6e22     okeStyle && "non
   26874:	21202265 78203d3d 7274732e 53656b6f     e" !== x.strokeS
   26884:	656c7974 20262620 74732e73 656b6f72     tyle && s.stroke
   26894:	202c2928 6c632e73 5065736f 28687461     (), s.closePath(
   268a4:	202c2929 65722e73 726f7473 20292865     )), s.restore() 
   268b4:	6669207d 6e212820 62616c2e 2e736c65     } if (!n.labels.
   268c4:	61736964 64656c62 20262620 4e736921     disabled && !isN
   268d4:	74284e61 2e736968 756c6176 6e615265     aN(this.valueRan
   268e4:	6d2e6567 20296e69 21202626 614e7369     ge.min) && !isNa
   268f4:	6874284e 762e7369 65756c61 676e6152     N(this.valueRang
   26904:	616d2e65 20292978 6176207b 204d2072     e.max)) { var M 
   26914:	2e6e203d 78614d79 6d726f46 65747461     = n.yMaxFormatte
   26924:	68742872 762e7369 65756c61 676e6152     r(this.valueRang
   26934:	616d2e65 6e202c78 62616c2e 2e736c65     e.max, n.labels.
   26944:	63657270 6f697369 0d2c296e 2020200a     precision),..   
   26954:	20202020 20202020 20202020 3d206b20                  k =
   26964:	792e6e20 466e694d 616d726f 72657474      n.yMinFormatter
   26974:	69687428 61762e73 5265756c 65676e61     (this.valueRange
   26984:	6e696d2e 2e6e202c 6562616c 702e736c     .min, n.labels.p
   26994:	69636572 6e6f6973 0a0d2c29 20202020     recision),..    
   269a4:	20202020 20202020 20202020 203d2046                 F = 
   269b4:	63732e6e 6c6c6f72 6b636142 64726177     n.scrollBackward
   269c4:	203f2073 203a2030 69772e72 20687464     s ? 0 : r.width 
   269d4:	2e73202d 7361656d 54657275 28747865     - s.measureText(
   269e4:	772e294d 68746469 32202d20 200a0d2c     M).width - 2,.. 
   269f4:	20202020 20202020 20202020 52202020                    R
   26a04:	6e203d20 7263732e 426c6c6f 776b6361      = n.scrollBackw
   26a14:	73647261 30203f20 72203a20 6469772e     ards ? 0 : r.wid
   26a24:	2d206874 6d2e7320 75736165 65546572     th - s.measureTe
   26a34:	6b287478 69772e29 20687464 3b32202d     xt(k).width - 2;
   26a44:	20200a0d 20202020 20202020 2e732020     ..            s.
   26a54:	6c6c6966 6c797453 203d2065 616c2e6e     fillStyle = n.la
   26a64:	736c6562 6c69662e 7974536c 202c656c     bels.fillStyle, 
   26a74:	69662e73 65546c6c 4d287478 2c46202c     s.fillText(M, F,
   26a84:	6c2e6e20 6c656261 6f662e73 6953746e      n.labels.fontSi
   26a94:	2c29657a 662e7320 546c6c69 28747865     ze), s.fillText(
   26aa4:	52202c6b 2e72202c 67696568 2d207468     k, R, r.height -
   26ab4:	20293220 6669207d 2e6e2820 656d6974      2) } if (n.time
   26ac4:	6d617473 726f4670 7474616d 26207265     stampFormatter &
   26ad4:	2e6e2026 64697267 6c696d2e 5073696c     & n.grid.millisP
   26ae4:	694c7265 3e20656e 20293020 6176207b     erLine > 0) { va
   26af4:	20412072 2e6e203d 6f726373 61426c6c     r A = n.scrollBa
   26b04:	61776b63 20736472 2e73203f 7361656d     ckwards ? s.meas
   26b14:	54657275 28747865 772e296b 68746469     ureText(k).width
   26b24:	72203a20 6469772e 2d206874 6d2e7320      : r.width - s.m
   26b34:	75736165 65546572 6b287478 69772e29     easureText(k).wi
   26b44:	20687464 3b34202b 726f6620 20642820     dth + 4; for (d 
   26b54:	2074203d 2074202d 2e6e2025 64697267     = t - t % n.grid
   26b64:	6c696d2e 5073696c 694c7265 203b656e     .millisPerLine; 
   26b74:	3d3e2064 203b6c20 3d2d2064 672e6e20     d >= l; d -= n.g
   26b84:	2e646972 6c6c696d 65507369 6e694c72     rid.millisPerLin
   26b94:	7b202965 3d207520 64286820 69203b29     e) { u = h(d); i
   26ba4:	21282066 63732e6e 6c6c6f72 6b636142     f (!n.scrollBack
   26bb4:	64726177 26262073 3c207520 7c204120     wards && u < A |
   26bc4:	2e6e207c 6f726373 61426c6c 61776b63     | n.scrollBackwa
   26bd4:	20736472 75202626 41203e20 207b2029     rds && u > A) { 
   26be4:	20726176 203d2042 2077656e 65746144     var B = new Date
   26bf4:	2c296428 20200a0d 20202020 20202020     (d),..          
   26c04:	20202020 20202020 20202020 204c2020                   L 
   26c14:	2e6e203d 656d6974 6d617473 726f4670     = n.timestampFor
   26c24:	7474616d 42287265 0a0d2c29 20202020     matter(B),..    
   26c34:	20202020 20202020 20202020 20202020                     
   26c44:	20202020 203d2057 656d2e73 72757361         W = s.measur
   26c54:	78655465 294c2874 6469772e 0d3b6874     eText(L).width;.
   26c64:	2020200a 20202020 20202020 20202020     .               
   26c74:	20202020 3d204120 732e6e20 6c6f7263          A = n.scrol
   26c84:	6361426c 7261776b 3f207364 2b207520     lBackwards ? u +
   26c94:	2b205720 3a203220 2d207520 2d205720      W + 2 : u - W -
   26ca4:	202c3220 69662e73 74536c6c 20656c79      2, s.fillStyle 
   26cb4:	2e6e203d 6562616c 662e736c 536c6c69     = n.labels.fillS
   26cc4:	656c7974 2e6e202c 6f726373 61426c6c     tyle, n.scrollBa
   26cd4:	61776b63 20736472 2e73203f 6c6c6966     ckwards ? s.fill
   26ce4:	74786554 202c4c28 72202c75 6965682e     Text(L, u, r.hei
   26cf4:	20746867 2932202d 73203a20 6c69662e     ght - 2) : s.fil
   26d04:	7865546c 2c4c2874 2d207520 202c5720     lText(L, u - W, 
   26d14:	65682e72 74686769 32202d20 207d2029     r.height - 2) } 
   26d24:	0d7d207d 2020200a 20202020 722e7320     } }..        s.r
   26d34:	6f747365 29286572 202c7d20 69742e61     estore() }, a.ti
   26d44:	6f46656d 74616d72 20726574 7566203d     meFormatter = fu
   26d54:	6974636e 65286e6f 0d7b2029 2020200a     nction(e) {..   
   26d64:	20202020 6e756620 6f697463 2874206e          function t(
   26d74:	7b202965 74657220 206e7275 3c206528     e) { return (e <
   26d84:	20303120 3022203f 203a2022 20292222      10 ? "0" : "") 
   26d94:	2065202b 6572207d 6e727574 65287420     + e } return t(e
   26da4:	7465672e 72756f48 29292873 22202b20     .getHours()) + "
   26db4:	2b20223a 65287420 7465672e 756e694d     :" + t(e.getMinu
   26dc4:	28736574 2b202929 223a2220 74202b20     tes()) + ":" + t
   26dd4:	672e6528 65537465 646e6f63 29292873     (e.getSeconds())
   26de4:	202c7d20 69542e65 6553656d 73656972      }, e.TimeSeries
   26df4:	69203d20 2e65202c 6f6f6d53 65696874      = i, e.Smoothie
   26e04:	72616843 203d2074 287d2061 646e7522     Chart = a }("und
   26e14:	6e696665 20226465 74203d3d 6f657079     efined" == typeo
   26e24:	78652066 74726f70 203f2073 73696874     f exports ? this
   26e34:	65203a20 726f7078 3b297374 00000000      : exports);....

00026e44 <data_stats_shtml>:
   26e44:	6174732f 732e7374 6c6d7468 44213c00     /stats.shtml.<!D
   26e54:	5954434f 48204550 3e4c4d54 683c0a0d     OCTYPE HTML>..<h
   26e64:	3e6c6d74 0a0d0a0d 6165683c 0a0d3e64     tml>....<head>..
   26e74:	20202020 7469743c 4a3e656c 27656b61         <title>Jake'
   26e84:	65772073 65687461 74732072 6f697461     s weather statio
   26e94:	6874206e 79676e69 69742f3c 3e656c74     n thingy</title>
   26ea4:	20200a0d 6d3c2020 20617465 70747468     ..    <meta http
   26eb4:	7571652d 223d7669 746e6f63 2d746e65     -equiv="content-
   26ec4:	65707974 6f632022 6e65746e 74223d74     type" content="t
   26ed4:	2f747865 6c6d7468 6863203b 65737261     ext/html; charse
   26ee4:	73693d74 38382d6f 312d3935 3e2f2022     t=iso-8859-1" />
   26ef4:	20200a0d 733c2020 656c7974 64656d20     ..    <style med
   26f04:	223d6169 226c6c61 70797420 74223d65     ia="all" type="t
   26f14:	2f747865 22737363 200a0d3e 20202020     ext/css">..     
   26f24:	40202020 6f706d69 22207472 2f737363        @import "css/
   26f34:	6c797473 632e7365 3b227373 20200a0d     styles.css";..  
   26f44:	2f3c2020 6c797473 0a0d3e65 65682f3c       </style>..</he
   26f54:	0d3e6461 3c0a0d0a 79646f62 200a0d3e     ad>....<body>.. 
   26f64:	3c202020 20766964 223d6469 6e69616d        <div id="main
   26f74:	0a0d3e22 20202020 20202020 7669643c     ">..        <div
   26f84:	3d646920 61656822 22726564 200a0d3e      id="header">.. 
   26f94:	20202020 20202020 3c202020 72682061                <a hr
   26fa4:	223d6665 65646e69 74682e78 20226c6d     ef="index.html" 
   26fb4:	73616c63 6c223d73 226f676f 6d693c3e     class="logo"><im
   26fc4:	72732067 69223d63 632f676d 64756f6c     g src="img/cloud
   26fd4:	6f676f4c 676e702e 69772022 3d687464     Logo.png" width=
   26fe4:	30303122 65682022 74686769 3038223d     "100" height="80
   26ff4:	6c612022 22223d74 3c3e2f20 0d3e612f     " alt="" /></a>.
   27004:	200a0d0a 20202020 20202020 3c202020     ...            <
   27014:	69206c75 74223d64 6e2d706f 67697661     ul id="top-navig
   27024:	6f697461 0d3e226e 2020200a 20202020     ation">..       
   27034:	20202020 20202020 696c3c20 70733c3e              <li><sp
   27044:	3c3e6e61 6e617073 20613c3e 66657268     an><span><a href
   27054:	6e69223d 2e786564 6c6d7468 6f483e22     ="index.html">Ho
   27064:	2f3c656d 2f3c3e61 6e617073 732f3c3e     me</a></span></s
   27074:	3e6e6170 20200a0d 20202020 20202020     pan>..          
   27084:	20202020 2f3c2020 0d3e696c 2020200a           </li>..   
   27094:	20202020 20202020 20202020 696c3c20                  <li
   270a4:	70733c3e 3c3e6e61 6e617073 20613c3e     ><span><span><a 
   270b4:	66657268 6164223d 6f626873 2e647261     href="dashboard.
   270c4:	6d746873 443e226c 62687361 6472616f     shtml">Dashboard
   270d4:	3e612f3c 70732f3c 3c3e6e61 6170732f     </a></span></spa
   270e4:	0a0d3e6e 20202020 20202020 20202020     n>..            
   270f4:	20202020 696c2f3c 200a0d3e 20202020         </li>..     
   27104:	20202020 20202020 3c202020 3c3e696c                <li><
   27114:	6e617073 70733c3e 3c3e6e61 72682061     span><span><a hr
   27124:	223d6665 746e6f63 2e6c6f72 6d746873     ef="control.shtm
   27134:	433e226c 72746e6f 2f3c6c6f 2f3c3e61     l">Control</a></
   27144:	6e617073 732f3c3e 3e6e6170 20200a0d     span></span>..  
   27154:	20202020 20202020 20202020 2f3c2020                   </
   27164:	0d3e696c 2020200a 20202020 20202020     li>..           
   27174:	20202020 696c3c20 616c6320 223d7373          <li class="
   27184:	69746361 3e226576 6170733c 733c3e6e     active"><span><s
   27194:	3e6e6170 6820613c 3d666572 61747322     pan><a href="sta
   271a4:	732e7374 6c6d7468 43543e22 74532050     ts.shtml">TCP St
   271b4:	3c737461 3c3e612f 6170732f 2f3c3e6e     ats</a></span></
   271c4:	6e617073 200a0d3e 20202020 20202020     span>..         
   271d4:	20202020 3c202020 3e696c2f 20200a0d            </li>..  
   271e4:	20202020 20202020 20202020 6c3c2020                   <l
   271f4:	733c3e69 3e6e6170 6170733c 613c3e6e     i><span><span><a
   27204:	65726820 74223d66 732e7063 6c6d7468      href="tcp.shtml
   27214:	6f433e22 63656e6e 6e6f6974 612f3c73     ">Connections</a
   27224:	732f3c3e 3e6e6170 70732f3c 0d3e6e61     ></span></span>.
   27234:	2020200a 20202020 20202020 20202020     .               
   27244:	6c2f3c20 0a0d3e69 20202020 20202020      </li>..        
   27254:	20202020 6c752f3c 200a0d3e 20202020         </ul>..     
   27264:	3c202020 7669642f 0d0a0d3e 2020200a        </div>....   
   27274:	20202020 69643c20 64692076 696d223d          <div id="mi
   27284:	656c6464 0a0d3e22 20202020 20202020     ddle">..        
   27294:	20202020 3e32683c 7774654e 206b726f         <h2>Network 
   272a4:	74617473 69747369 2f3c7363 0d3e3268     statistics</h2>.
   272b4:	2020200a 20202020 20202020 61743c20     .            <ta
   272c4:	20656c62 74646977 33223d68 20223030     ble width="300" 
   272d4:	64726f62 223d7265 0d3e2230 2020200a     border="0">..   
   272e4:	20202020 20202020 20202020 72743c20                  <tr
   272f4:	200a0d3e 20202020 20202020 20202020     >..             
   27304:	20202020 3c202020 61206474 6e67696c            <td align
   27314:	656c223d 3e227466 20200a0d 20202020     ="left">..      
   27324:	20202020 20202020 20202020 20202020                     
   27334:	663c2020 20746e6f 65636166 6f63223d       <font face="co
   27344:	65697275 3c3e2272 3e657270 50490a0d     urier"><pre>..IP
   27354:	20202020 20202020 50202020 656b6361                Packe
   27364:	72207374 69656365 0d646576 2020200a     ts received..   
   27374:	20202020 20202020 61502020 74656b63               Packet
   27384:	65732073 0a0d746e 20202020 20202020     s sent..        
   27394:	20202020 726f4620 65646177 200a0d64          Forwaded.. 
   273a4:	20202020 20202020 20202020 706f7244                 Drop
   273b4:	0d646570 2050490a 6f727265 20207372     ped..IP errors  
   273c4:	50492020 72657620 6e6f6973 6165682f       IP version/hea
   273d4:	20726564 676e656c 0a0d6874 20202020     der length..    
   273e4:	20202020 20202020 20504920 676e656c              IP leng
   273f4:	202c6874 68676968 74796220 200a0d65     th, high byte.. 
   27404:	20202020 20202020 20202020 6c205049                 IP l
   27414:	74676e65 6c202c68 6220776f 0d657479     ength, low byte.
   27424:	2020200a 20202020 20202020 50492020     .             IP
   27434:	61726620 6e656d67 0a0d7374 20202020      fragments..    
   27444:	20202020 20202020 61654820 20726564              Header 
   27454:	63656863 6d75736b 20200a0d 20202020     checksum..      
   27464:	20202020 57202020 676e6f72 6f727020            Wrong pro
   27474:	6f636f74 490a0d6c 09504d43 20202020     tocol..ICMP.    
   27484:	63615020 7374656b 63657220 65766965      Packets receive
   27494:	200a0d64 20202020 20202020 20202020     d..             
   274a4:	6b636150 20737465 746e6573 20200a0d     Packets sent..  
   274b4:	20202020 20202020 50202020 656b6361                Packe
   274c4:	64207374 70706f72 0a0d6465 20202020     ts dropped..    
   274d4:	20202020 20202020 70795420 72652065              Type er
   274e4:	73726f72 20200a0d 20202020 20202020     rors..          
   274f4:	43202020 6b636568 206d7573 6f727265        Checksum erro
   27504:	0a0d7372 20504354 20202020 20202020     rs..TCP         
   27514:	63615020 7374656b 63657220 65766965      Packets receive
   27524:	200a0d64 20202020 20202020 20202020     d..             
   27534:	6b636150 20737465 746e6573 20200a0d     Packets sent..  
   27544:	20202020 20202020 50202020 656b6361                Packe
   27554:	64207374 70706f72 0a0d6465 20202020     ts dropped..    
   27564:	20202020 20202020 65684320 75736b63              Checksu
   27574:	7265206d 73726f72 20200a0d 20202020     m errors..      
   27584:	20202020 44202020 20617461 6b636170            Data pack
   27594:	20737465 68746977 2074756f 734b4341     ets without ACKs
   275a4:	20200a0d 20202020 20202020 52202020     ..             R
   275b4:	74657365 200a0d73 20202020 20202020     esets..         
   275c4:	20202020 72746552 6d736e61 69737369         Retransmissi
   275d4:	61736e6f 20200a0d 20202020 20202020     onsa..          
   275e4:	53202020 74206e79 6c63206f 6465736f        Syn to closed
   275f4:	726f7020 550a0d74 20205044 20202020      port..UDP      
   27604:	20202020 6b636150 20737465 706f7264         Packets drop
   27614:	0d646570 2020200a 20202020 20202020     ped..           
   27624:	61502020 74656b63 65722073 76696563       Packets receiv
   27634:	0a0d6465 20202020 20202020 20202020     ed..            
   27644:	63615020 7374656b 6e657320 200a0d74      Packets sent.. 
   27654:	20202020 20202020 20202020 6b636150                 Pack
   27664:	20737465 656b6863 0a0d7272 20202009     ets chkerr...   
   27674:	6f4e2020 6e6f6320 7463656e 206e6f69       No connection 
   27684:	6c617661 6c626169 3c0a0d65 6572702f     avaliable..</pre
   27694:	662f3c3e 3e746e6f 20200a0d 20202020     ></font>..      
   276a4:	20202020 20202020 20202020 2f3c2020                   </
   276b4:	0d3e6474 2020200a 20202020 20202020     td>..           
   276c4:	20202020 20202020 64743c20 200a0d3e              <td>.. 
   276d4:	20202020 20202020 20202020 20202020                     
   276e4:	20202020 3c202020 746e6f66 63616620            <font fac
   276f4:	63223d65 6972756f 3e227265 6572703c     e="courier"><pre
   27704:	2021253e 2d74656e 74617473 3c0a0d73     >%! net-stats..<
   27714:	6572702f 662f3c3e 3e746e6f 20200a0d     /pre></font>..  
   27724:	20202020 20202020 20202020 20202020                     
   27734:	2f3c2020 0d3e6474 2020200a 20202020       </td>..       
   27744:	20202020 742f3c20 656c6261 200a0d3e          </table>.. 
   27754:	20202020 3c202020 7669642f 0d0a0d3e            </div>...
   27764:	200a0d0a 20202020 3c202020 20766964     ...        <div 
   27774:	223d6469 746f6f66 3e227265 69642f3c     id="footer"></di
   27784:	0a0d3e76 20202020 69642f3c 0a0d3e76     v>..    </div>..
   27794:	2f3c0a0d 79646f62 0d0a0d3e 682f3c0a     ..</body>....</h
   277a4:	3e6c6d74 00000000                       tml>....

000277ac <data_tcp_shtml>:
   277ac:	7063742f 7468732e 3c006c6d 434f4421     /tcp.shtml.<!DOC
   277bc:	45505954 4d544820 0a0d3e4c 6d74683c     TYPE HTML>..<htm
   277cc:	0a0d3e6c 683c0a0d 3e646165 20200a0d     l>....<head>..  
   277dc:	743c2020 656c7469 6b614a3e 20732765       <title>Jake's 
   277ec:	74616577 20726568 74617473 206e6f69     weather station 
   277fc:	6e696874 2f3c7967 6c746974 0a0d3e65     thingy</title>..
   2780c:	20202020 74656d3c 74682061 652d7074         <meta http-e
   2781c:	76697571 6f63223d 6e65746e 79742d74     quiv="content-ty
   2782c:	20226570 746e6f63 3d746e65 78657422     pe" content="tex
   2783c:	74682f74 203b6c6d 72616863 3d746573     t/html; charset=
   2784c:	2d6f7369 39353838 2022312d 0a0d3e2f     iso-8859-1" />..
   2785c:	20202020 7974733c 6d20656c 61696465         <style media
   2786c:	6c61223d 7420226c 3d657079 78657422     ="all" type="tex
   2787c:	73632f74 0d3e2273 2020200a 20202020     t/css">..       
   2788c:	6d694020 74726f70 73632220 74732f73      @import "css/st
   2789c:	73656c79 7373632e 0a0d3b22 20202020     yles.css";..    
   278ac:	74732f3c 3e656c79 2f3c0a0d 64616568     </style>..</head
   278bc:	0d0a0d3e 6f623c0a 0d3e7964 2020200a     >....<body>..   
   278cc:	69643c20 64692076 616d223d 3e226e69      <div id="main">
   278dc:	20200a0d 20202020 643c2020 69207669     ..        <div i
   278ec:	68223d64 65646165 0d3e2272 2020200a     d="header">..   
   278fc:	20202020 20202020 20613c20 66657268              <a href
   2790c:	6e69223d 2e786564 6c6d7468 6c632022     ="index.html" cl
   2791c:	3d737361 676f6c22 3c3e226f 20676d69     ass="logo"><img 
   2792c:	3d637273 676d6922 6f6c632f 6f4c6475     src="img/cloudLo
   2793c:	702e6f67 2022676e 74646977 31223d68     go.png" width="1
   2794c:	20223030 67696568 223d7468 20223038     00" height="80" 
   2795c:	3d746c61 2f202222 612f3c3e 0d0a0d3e     alt="" /></a>...
   2796c:	2020200a 20202020 20202020 6c753c20     .            <ul
   2797c:	3d646920 706f7422 76616e2d 74616769      id="top-navigat
   2798c:	226e6f69 200a0d3e 20202020 20202020     ion">..         
   2799c:	20202020 3c202020 3c3e696c 6e617073            <li><span
   279ac:	70733c3e 3c3e6e61 72682061 223d6665     ><span><a href="
   279bc:	65646e69 74682e78 3e226c6d 656d6f48     index.html">Home
   279cc:	3e612f3c 70732f3c 3c3e6e61 6170732f     </a></span></spa
   279dc:	0a0d3e6e 20202020 20202020 20202020     n>..            
   279ec:	20202020 696c2f3c 200a0d3e 20202020         </li>..     
   279fc:	20202020 20202020 3c202020 3c3e696c                <li><
   27a0c:	6e617073 70733c3e 3c3e6e61 72682061     span><span><a hr
   27a1c:	223d6665 68736164 72616f62 68732e64     ef="dashboard.sh
   27a2c:	226c6d74 7361443e 616f6268 2f3c6472     tml">Dashboard</
   27a3c:	2f3c3e61 6e617073 732f3c3e 3e6e6170     a></span></span>
   27a4c:	20200a0d 20202020 20202020 20202020     ..              
   27a5c:	2f3c2020 0d3e696c 2020200a 20202020       </li>..       
   27a6c:	20202020 20202020 696c3c20 70733c3e              <li><sp
   27a7c:	3c3e6e61 6e617073 20613c3e 66657268     an><span><a href
   27a8c:	6f63223d 6f72746e 68732e6c 226c6d74     ="control.shtml"
   27a9c:	6e6f433e 6c6f7274 3e612f3c 70732f3c     >Control</a></sp
   27aac:	3c3e6e61 6170732f 0a0d3e6e 20202020     an></span>..    
   27abc:	20202020 20202020 20202020 696c2f3c                 </li
   27acc:	200a0d3e 20202020 20202020 20202020     >..             
   27adc:	3c202020 3c3e696c 6e617073 70733c3e        <li><span><sp
   27aec:	3c3e6e61 72682061 223d6665 74617473     an><a href="stat
   27afc:	68732e73 226c6d74 5043543e 61745320     s.shtml">TCP Sta
   27b0c:	2f3c7374 2f3c3e61 6e617073 732f3c3e     ts</a></span></s
   27b1c:	3e6e6170 20200a0d 20202020 20202020     pan>..          
   27b2c:	20202020 2f3c2020 0d3e696c 2020200a           </li>..   
   27b3c:	20202020 20202020 20202020 696c3c20                  <li
   27b4c:	616c6320 223d7373 69746361 3e226576      class="active">
   27b5c:	6170733c 733c3e6e 3e6e6170 6820613c     <span><span><a h
   27b6c:	3d666572 70637422 7468732e 3e226c6d     ref="tcp.shtml">
   27b7c:	6e6e6f43 69746365 3c736e6f 3c3e612f     Connections</a><
   27b8c:	6170732f 2f3c3e6e 6e617073 200a0d3e     /span></span>.. 
   27b9c:	20202020 20202020 20202020 3c202020                    <
   27bac:	3e696c2f 20200a0d 20202020 20202020     /li>..          
   27bbc:	2f3c2020 0d3e6c75 2020200a 20202020       </ul>..       
   27bcc:	642f3c20 0d3e7669 200a0d0a 20202020      </div>....     
   27bdc:	3c202020 20766964 223d6469 6464696d        <div id="midd
   27bec:	3e22656c 20200a0d 20202020 20202020     le">..          
   27bfc:	683c2020 654e3e32 726f7774 6f63206b       <h2>Network co
   27c0c:	63656e6e 6e6f6974 682f3c73 0a0d3e32     nnections</h2>..
   27c1c:	20202020 20202020 20202020 0d3e703c                 <p>.
   27c2c:	2020200a 20202020 20202020 20202020     .               
   27c3c:	61743c20 3e656c62 20200a0d 20202020      <table>..      
   27c4c:	20202020 20202020 20202020 743c2020                   <t
   27c5c:	0a0d3e72 20202020 20202020 20202020     r>..            
   27c6c:	20202020 20202020 20202020 3e68743c                 <th>
   27c7c:	61636f4c 742f3c6c 0a0d3e68 20202020     Local</th>..    
   27c8c:	20202020 20202020 20202020 20202020                     
   27c9c:	20202020 3e68743c 6f6d6552 2f3c6574         <th>Remote</
   27cac:	0d3e6874 2020200a 20202020 20202020     th>..           
   27cbc:	20202020 20202020 20202020 68743c20                  <th
   27ccc:	6174533e 2f3c6574 0d3e6874 2020200a     >State</th>..   
   27cdc:	20202020 20202020 20202020 20202020                     
   27cec:	20202020 68743c20 7465523e 736e6172          <th>Retrans
   27cfc:	7373696d 736e6f69 68742f3c 200a0d3e     missions</th>.. 
   27d0c:	20202020 20202020 20202020 20202020                     
   27d1c:	20202020 3c202020 543e6874 72656d69            <th>Timer
   27d2c:	68742f3c 200a0d3e 20202020 20202020     </th>..         
   27d3c:	20202020 20202020 20202020 3c202020                    <
   27d4c:	463e6874 7367616c 68742f3c 200a0d3e     th>Flags</th>.. 
   27d5c:	20202020 20202020 20202020 20202020                     
   27d6c:	3c202020 3e72742f 20200a0d 20202020        </tr>..      
   27d7c:	20202020 20202020 20202020 21252020                   %!
   27d8c:	70637420 6e6f632d 7463656e 736e6f69      tcp-connections
   27d9c:	20200a0d 20202020 20202020 20202020     ..              
   27dac:	2f3c2020 6c626174 0a0d3e65 20202020       </table>..    
   27dbc:	20202020 69642f3c 0a0d3e76 0a0d0a0d         </div>......
   27dcc:	20202020 20202020 7669643c 3d646920             <div id=
   27ddc:	6f6f6622 22726574 642f3c3e 0d3e7669     "footer"></div>.
   27dec:	2020200a 642f3c20 0d3e7669 3c0a0d0a     .    </div>....<
   27dfc:	646f622f 0a0d3e79 2f3c0a0d 6c6d7468     /body>....</html
   27e0c:	0000003e                                >...

00027e10 <data_css_styles_css>:
   27e10:	7373632f 7974732f 2e73656c 00737363     /css/styles.css.
   27e20:	6d202a2f 206e6961 6c797473 2a207365     /* main styles *
   27e30:	0d0a0d2f 646f620a 0d7b2079 2020200a     /....body {..   
   27e40:	72616d20 3a6e6967 0d3b3020 2020200a      margin: 0;..   
   27e50:	64617020 676e6964 3b30203a 20200a0d      padding: 0;..  
   27e60:	61622020 72676b63 646e756f 4223203a       background: #B
   27e70:	45394442 0a0d3b45 20202020 6f6c6f63     BD9EE;..    colo
   27e80:	23203a72 3b303030 20200a0d 6f662020     r: #000;..    fo
   27e90:	662d746e 6c696d61 74203a79 6d6f6861     nt-family: tahom
   27ea0:	61202c61 6c616972 6173202c 732d736e     a, arial, sans-s
   27eb0:	66697265 200a0d3b 66202020 2d746e6f     erif;..    font-
   27ec0:	657a6973 3131203a 0d3b7870 0a0d7d0a     size: 11px;..}..
   27ed0:	6f660a0d 7b206d72 20200a0d 616d2020     ..form {..    ma
   27ee0:	6e696772 3b30203a 20200a0d 61702020     rgin: 0;..    pa
   27ef0:	6e696464 30203a67 0d7d0a0d 690a0d0a     dding: 0..}....i
   27f00:	7b20676d 20200a0d 6f622020 72656472     mg {..    border
   27f10:	6f6e203a 0d3b656e 0a0d7d0a 20610a0d     : none;..}....a 
   27f20:	200a0d7b 63202020 726f6c6f 3023203a     {..    color: #0
   27f30:	30363036 0a0d3b36 20202020 74786574     60606;..    text
   27f40:	6365642d 7461726f 3a6e6f69 6e6f6e20     -decoration: non
   27f50:	7d0a0d65 0a0d0a0d 6f683a61 20726576     e..}....a:hover 
   27f60:	200a0d7b 74202020 2d747865 6f636564     {..    text-deco
   27f70:	69746172 203a6e6f 65646e75 6e696c72     ration: underlin
   27f80:	7d0a0d65 0a0d0a0d 75706e69 0d7b2074     e..}....input {.
   27f90:	2020200a 72657620 61636974 6c612d6c     .    vertical-al
   27fa0:	3a6e6769 64696d20 0d656c64 0a0d7d0a     ign: middle..}..
   27fb0:	662e0a0d 74616f6c 7466656c 0a0d7b20     ...floatleft {..
   27fc0:	20202020 616f6c66 6c203a74 20746665         float: left 
   27fd0:	706d6921 6174726f 0a0d746e 0d0a0d7d     !important..}...
   27fe0:	6c662e0a 7274616f 74686769 0a0d7b20     ..floatright {..
   27ff0:	20202020 616f6c66 72203a74 74686769         float: right
   28000:	6d692120 74726f70 0d746e61 0a0d7d0a      !important..}..
   28010:	632e0a0d 7261656c 0a0d7b20 20202020     ...clear {..    
   28020:	61656c63 62203a72 2068746f 706d6921     clear: both !imp
   28030:	6174726f 0a0d746e 0d0a0d7d 6f622e0a     ortant..}.....bo
   28040:	7b20646c 20200a0d 6f662020 772d746e     ld {..    font-w
   28050:	68676965 62203a74 20646c6f 706d6921     eight: bold !imp
   28060:	6174726f 0a0d746e 0d0a0d7d 6f6e2e0a     ortant..}.....no
   28070:	6c616d72 0a0d7b20 20202020 746e6f66     rmal {..    font
   28080:	6965772d 3a746867 726f6e20 206c616d     -weight: normal 
   28090:	706d6921 6174726f 0a0d746e 0d0a0d7d     !important..}...
   280a0:	6c622e0a 206b636f 200a0d7b 64202020     ..block {..    d
   280b0:	6c707369 203a7961 636f6c62 6921206b     isplay: block !i
   280c0:	726f706d 746e6174 0d7d0a0d 690a0d0a     mportant..}....i
   280d0:	7475706e 7865742e 0a0d2c74 656c6573     nput.text,..sele
   280e0:	0d2c7463 7865740a 65726174 0d7b2061     ct,..textarea {.
   280f0:	2020200a 6e6f6620 61662d74 796c696d     .    font-family
   28100:	7261203a 2c6c6169 6e617320 65732d73     : arial, sans-se
   28110:	3b666972 20200a0d 6f632020 3a726f6c     rif;..    color:
   28120:	33332320 0a0d3b33 20202020 746e6f66      #333;..    font
   28130:	7a69732d 31203a65 3b787032 20200a0d     -size: 12px;..  
   28140:	65762020 63697472 612d6c61 6e67696c       vertical-align
   28150:	696d203a 656c6464 7d0a0d3b 0a0d0a0d     : middle;..}....
   28160:	75706e69 65742e74 7b207478 20200a0d     input.text {..  
   28170:	61702020 6e696464 31203a67 30207870       padding: 1px 0
   28180:	34203020 0d3b7870 2020200a 69656820      0 4px;..    hei
   28190:	3a746867 70343120 0a0d3b78 20202020     ght: 14px;..    
   281a0:	746e6f66 6965772d 3a746867 726f6e20     font-weight: nor
   281b0:	3b6c616d 0d7d0a0d 0d0a0d0a 202a2f0a     mal;..}....../* 
   281c0:	6e69616d 6e6f6320 6e696174 2a207265     main container *
   281d0:	0d0a0d2f 616d230a 7b206e69 20200a0d     /....#main {..  
   281e0:	69772020 3a687464 32393920 0d3b7870       width: 992px;.
   281f0:	2020200a 72616d20 3a6e6967 61203020     .    margin: 0 a
   28200:	3b6f7475 0d7d0a0d 0d0a0d0a 202a2f0a     uto;..}....../* 
   28210:	64616568 2a207265 0d0a0d2f 6568230a     header */....#he
   28220:	72656461 0a0d7b20 20202020 69736f70     ader {..    posi
   28230:	6e6f6974 6572203a 6974616c 0d3b6576     tion: relative;.
   28240:	2020200a 64697720 203a6874 70323939     .    width: 992p
   28250:	0a0d3b78 20202020 67696568 203a7468     x;..    height: 
   28260:	70363031 0a0d3b78 20202020 6b636162     106px;..    back
   28270:	756f7267 203a646e 286c7275 692f2e2e     ground: url(../i
   28280:	622f676d 61654867 2e726564 29666967     mg/bgHeader.gif)
   28290:	2d6f6e20 65706572 6c207461 20746665      no-repeat left 
   282a0:	74746f62 0d3b6d6f 0a0d7d0a 0a0d0a0d     bottom;..}......
   282b0:	73202a2f 20657469 6f676f6c 0d2f2a20     /* site logo */.
   282c0:	610a0d0a 676f6c2e 0d7b206f 2020200a     ...a.logo {..   
   282d0:	736f7020 6f697469 61203a6e 6c6f7362      position: absol
   282e0:	3b657475 20200a0d 6f742020 30203a70     ute;..    top: 0
   282f0:	0d3b7870 2020200a 66656c20 30203a74     px;..    left: 0
   28300:	0d3b7870 0a0d7d0a 0a0d0a0d 68202a2f     px;..}....../* h
   28310:	65646165 61742072 2a207362 0d0a0d2f     eader tabs */...
   28320:	6f74230a 616e2d70 61676976 6e6f6974     .#top-navigation
   28330:	0a0d7b20 20202020 69736f70 6e6f6974      {..    position
   28340:	6261203a 756c6f73 0d3b6574 2020200a     : absolute;..   
   28350:	706f7420 3036203a 0d3b7870 2020200a      top: 60px;..   
   28360:	66656c20 32203a74 3b787030 20200a0d      left: 20px;..  
   28370:	616d2020 6e696772 3b30203a 20200a0d       margin: 0;..  
   28380:	61702020 6e696464 30203a67 200a0d3b       padding: 0;.. 
   28390:	6c202020 2d747369 6c797473 6e203a65        list-style: n
   283a0:	3b656e6f 0d7d0a0d 230a0d0a 2d706f74     one;..}....#top-
   283b0:	6976616e 69746167 6c206e6f 0d7b2069     navigation li {.
   283c0:	2020200a 6f6c6620 203a7461 7466656c     .    float: left
   283d0:	200a0d3b 6d202020 69677261 30203a6e     ;..    margin: 0
   283e0:	78703320 30203020 200a0d3b 68202020      3px 0 0;..    h
   283f0:	68676965 33203a74 3b787034 20200a0d     eight: 34px;..  
   28400:	61622020 72676b63 646e756f 7275203a       background: ur
   28410:	2e2e286c 676d692f 6261742f 6669672e     l(../img/tab.gif
   28420:	65722029 74616570 7420782d 0d3b706f     ) repeat-x top;.
   28430:	0a0d7d0a 74230a0d 6e2d706f 67697661     .}....#top-navig
   28440:	6f697461 696c206e 7b206120 20200a0d     ation li a {..  
   28450:	6c662020 3a74616f 66656c20 0a0d3b74       float: left;..
   28460:	20202020 70736964 3a79616c 6f6c6220         display: blo
   28470:	0d3b6b63 2020200a 69656820 3a746867     ck;..    height:
   28480:	70303220 0a0d3b78 20202020 656e696c      20px;..    line
   28490:	6965682d 3a746867 70393120 0a0d3b78     -height: 19px;..
   284a0:	20202020 6f6c6f63 23203a72 30363036         color: #6060
   284b0:	0d3b3036 2020200a 64617020 676e6964     60;..    padding
   284c0:	7034203a 20302078 3b302030 0d7d0a0d     : 4px 0 0 0;..}.
   284d0:	230a0d0a 2d706f74 6976616e 69746167     ...#top-navigati
   284e0:	6c206e6f 70732069 7b206e61 20200a0d     on li span {..  
   284f0:	6c662020 3a74616f 66656c20 0a0d3b74       float: left;..
   28500:	20202020 6b636162 756f7267 203a646e         background: 
   28510:	286c7275 692f2e2e 742f676d 654c6261     url(../img/tabLe
   28520:	672e7466 20296669 722d6f6e 61657065     ft.gif) no-repea
   28530:	656c2074 74207466 0d3b706f 0a0d7d0a     t left top;..}..
   28540:	74230a0d 6e2d706f 67697661 6f697461     ..#top-navigatio
   28550:	696c206e 61707320 7073206e 7b206e61     n li span span {
   28560:	20200a0d 61622020 72676b63 646e756f     ..    background
   28570:	7275203a 2e2e286c 676d692f 6261742f     : url(../img/tab
   28580:	68676952 69672e74 6e202966 65722d6f     Right.gif) no-re
   28590:	74616570 67697220 74207468 0d3b706f     peat right top;.
   285a0:	2020200a 64617020 676e6964 7037203a     .    padding: 7p
   285b0:	30312078 30207870 70303120 0a0d3b78     x 10px 0 10px;..
   285c0:	0d0a0d7d 6f74230a 616e2d70 61676976     }....#top-naviga
   285d0:	6e6f6974 2e696c20 69746361 7b206576     tion li.active {
   285e0:	20200a0d 61702020 6e696464 30203a67     ..    padding: 0
   285f0:	200a0d3b 68202020 68676965 33203a74     ;..    height: 3
   28600:	3b787034 20200a0d 61622020 72676b63     4px;..    backgr
   28610:	646e756f 7275203a 2e2e286c 676d692f     ound: url(../img
   28620:	6261742f 69746341 672e6576 20296669     /tabActive.gif) 
   28630:	65706572 782d7461 706f7420 200a0d3b     repeat-x top;.. 
   28640:	6d202020 69677261 69722d6e 3a746867        margin-right:
   28650:	78703220 7d0a0d3b 0a0d0a0d 706f7423      2px;..}....#top
   28660:	76616e2d 74616769 206e6f69 612e696c     -navigation li.a
   28670:	76697463 70732065 7b206e61 20200a0d     ctive span {..  
   28680:	61622020 72676b63 646e756f 7275203a       background: ur
   28690:	2e2e286c 676d692f 6261742f 4c746341     l(../img/tabActL
   286a0:	2e746665 29666967 2d6f6e20 65706572     eft.gif) no-repe
   286b0:	6c207461 20746665 3b706f74 20200a0d     at left top;..  
   286c0:	65682020 74686769 3433203a 0d3b7870       height: 34px;.
   286d0:	0a0d7d0a 74230a0d 6e2d706f 67697661     .}....#top-navig
   286e0:	6f697461 696c206e 7463612e 20657669     ation li.active 
   286f0:	6e617073 61707320 0d7b206e 2020200a     span span {..   
   28700:	63616220 6f72676b 3a646e75 6c727520      background: url
   28710:	2f2e2e28 2f676d69 41626174 69527463     (../img/tabActRi
   28720:	2e746867 29666967 2d6f6e20 65706572     ght.gif) no-repe
   28730:	72207461 74686769 706f7420 200a0d3b     at right top;.. 
   28740:	68202020 68676965 33203a74 3b787034        height: 34px;
   28750:	20200a0d 61702020 6e696464 37203a67     ..    padding: 7
   28760:	31207870 20787030 30312030 0d3b7870     px 10px 0 10px;.
   28770:	2020200a 6e696c20 65682d65 74686769     .    line-height
   28780:	3931203a 0d3b7870 2020200a 6c6f6320     : 19px;..    col
   28790:	203a726f 36303623 3b303630 0d7d0a0d     or: #606060;..}.
   287a0:	0d0a0d0a 202a2f0a 6464696d 2a20656c     ...../* middle *
   287b0:	0d0a0d2f 696d230a 656c6464 0a0d7b20     /....#middle {..
   287c0:	20202020 616f6c66 6c203a74 3b746665         float: left;
   287d0:	20200a0d 69772020 3a687464 37363920     ..    width: 967
   287e0:	0d3b7870 2020200a 63616220 6f72676b     px;..    backgro
   287f0:	3a646e75 6c727520 2f2e2e28 2f676d69     und: url(../img/
   28800:	694d6762 656c6464 6669672e 65722029     bgMiddle.gif) re
   28810:	74616570 6c20792d 3b746665 20200a0d     peat-y left;..  
   28820:	61702020 6e696464 30203a67 70333120       padding: 0 13p
   28830:	20302078 78703532 7d0a0d3b 0a0d0a0d     x 0 25px;..}....
   28840:	2a2f0a0d 6f6f6620 20726574 0a0d2f2a     ../* footer */..
   28850:	66230a0d 65746f6f 0d7b2072 2020200a     ..#footer {..   
   28860:	6f6c6620 203a7461 7466656c 200a0d3b      float: left;.. 
   28870:	77202020 68746469 3031203a 0d3b2530        width: 100%;.
   28880:	2020200a 63616220 6f72676b 3a646e75     .    background:
   28890:	6c727520 2f2e2e28 2f676d69 6f466762      url(../img/bgFo
   288a0:	7265746f 6669672e 6f6e2029 7065722d     oter.gif) no-rep
   288b0:	3b746165 20200a0d 65682020 74686769     eat;..    height
   288c0:	3531203a 0d3b7870 0a0d7d0a 63230a0d     : 15px;..}....#c
   288d0:	74726168 0a0d7b20 20202020 74646977     hart {..    widt
   288e0:	36203a68 78703030 200a0d3b 68202020     h: 600px;..    h
   288f0:	68676965 31203a74 78703032 7d0a0d3b     eight: 120px;..}
   28900:	0a0d0a0d 64697723 2d746567 74636573     ....#widget-sect
   28910:	206e6f69 200a0d7b 77202020 68746469     ion {..    width
   28920:	3131203a 3b787030 20200a0d 65682020     : 110px;..    he
   28930:	74686769 3832203a 3b787030 20200a0d     ight: 280px;..  
   28940:	6c662020 3a74616f 66656c20 0a0d3b74       float: left;..
   28950:	20202020 6772616d 722d6e69 74686769         margin-right
   28960:	3032203a 0d3b7870 0a0d7d0a 74230a0d     : 20px;..}....#t
   28970:	6d726568 61622d6f 72676b63 646e756f     hermo-background
   28980:	0a0d7b20 20202020 6b636162 756f7267      {..    backgrou
   28990:	203a646e 286c7275 74616422 6d693a61     nd: url("data:im
   289a0:	2f656761 2b677673 3b6c6d78 65736162     age/svg+xml;base
   289b0:	502c3436 62343944 64677757 6379566d     64,PD94bWwgdmVyc
   289c0:	62766c32 4d69306a 49773453 647a4269     2lvbj0iMS4wIiBzd
   289d0:	5a754647 62734647 506c3532 62754a53     GFuZGFsb25lPSJub
   289e0:	502f4979 4c68776a 52673053 5a755632     yI/PjwhLS0gR2VuZ
   289f0:	64684a58 4f793947 63484269 6132466d     XJhdG9yOiBHcmF2a
   28a00:	61755158 4c673857 502b3053 5a324e48     XQuaW8gLS0+PHN2Z
   28a10:	62344279 63757857 6169307a 63305248     yB4bWxucz0iaHR0c
   28a20:	4c766f44 64336433 4d333579 63763579     DovL3d3dy53My5vc
   28a30:	4d76636d 4d77416a 647a3943 4969636d     mcvMjAwMC9zdmciI
   28a40:	62746848 4f7a3547 6173686e 50723557     HhtbG5zOnhsaW5rP
   28a50:	646f4a53 4f775248 64763869 4c336433     SJodHRwOi8vd3d3L
   28a60:	4c7a636e 5a79396d 4f783879 4c356b54     nczLm9yZy8xOTk5L
   28a70:	61736833 49723557 647a4269 5a736c48     3hsaW5rIiBzdHlsZ
   28a80:	61693054 62764e58 61304647 4f753957     T0iaXNvbGF0aW9uO
   28a90:	627a6c6d 64687832 49695547 5a705a48     mlzb2xhdGUiIHZpZ
   28aa0:	62436458 49396733 4d67416a 4e784143     XdCb3g9IjAgMCAxN
   28ab0:	4f755554 49324154 4e314d44 4d7a3443     TUuOTA2IDM1NC4zM
   28ac0:	4969457a 5a706448 506f5248 4d784953     zEiIHdpZHRoPSIxM
   28ad0:	4f754d44 4d7a4d54 61674979 5a705647     DMuOTMzMyIgaGVpZ
   28ae0:	50306832 4d794953 4d75597a 4e77496a     2h0PSIyMzYuMjIwN
   28af0:	502b4969 5a6c5247 502b4d6e 61734e47     iI+PGRlZnM+PGNsa
   28b00:	59514258 496f5258 506b6c47 59664a53     XBQYXRoIGlkPSJfY
   28b10:	63707832 64684246 55666847 657a3430     2xpcFBhdGhfU04ze
   28b20:	65686458 54707047 626c566d 644f7033     XdheGppTmVlb3pOd
   28b30:	5a784958 51775a6e 5377557a 64785554     XIxZnZwQzUwSTUxd
   28b40:	5a535a54 50696f6d 5a79786a 49304e57     TZSZmoiPjxyZWN0I
   28b50:	5a706448 506f5248 4e784953 4f755554     HdpZHRoPSIxNTUuO
   28b60:	49324154 5a6f4269 616e6c57 49395148     TA2IiBoZWlnaHQ9I
   28b70:	4e314d6a 4d7a3443 4c69457a 4c38347a     jM1NC4zMzEiLz48L
   28b80:	61734e32 59514258 506f5258 5a76776a     2NsaXBQYXRoPjwvZ
   28b90:	636d5647 5a38347a 626a4279 4c776c47     GVmcz48ZyBjbGlwL
   28ba0:	64684258 49396747 6279566e 586a6743     XBhdGg9InVybCgjX
   28bb0:	61734e32 59514258 586f5258 4d4f4e31     2NsaXBQYXRoX1NOM
   28bc0:	59336c33 61716858 5a6c3555 54363957     3l3YXhqaU5lZW96T
   28bd0:	4d79566e 63325a57 4d314d45 4d316b45     nVyMWZ2cEM1MEk1M
   28be0:	55325558 4b715a6d 502b4953 502b6347     XU2UmZqKSI+PGc+P
   28bf0:	5a6c5247 502b4d6e 62705a47 636c5248     GRlZnM+PGZpbHRlc
   28c00:	5a704269 53693044 526e566a 57454656     iBpZD0iSjVnRVFEW
   28c10:	5232706d 556a4e6b 63327757 4d47426c     mp2RkNjUWw2clBGM
   28c20:	4d576c6c 6244356d 546d646a 54696454     llWMm5DbjdmTTdiT
   28c30:	49694932 49396748 4d793069 496c4144     2IiIHg9Ii0yMDAlI
   28c40:	50354269 4d744953 4a77416a 64674953     iB5PSItMjAwJSIgd
   28c50:	646b6c32 49396747 4d77516a 49695543     2lkdGg9IjQwMCUiI
   28c60:	616c6847 646f6457 4e693044 4a774144     GhlaWdodD0iNDAwJ
   28c70:	5a674953 64736c6d 56795647 64703557     SIgZmlsdGVyVW5pd
   28c80:	49394d48 6169396d 646a566d 64764a45     HM9Im9iamVjdEJvd
   28c90:	616b3557 516e3557 4934396d 626a4269     W5kaW5nQm94IiBjb
   28ca0:	63767832 62703169 636c526e 6276426e     2xvci1pbnRlcnBvb
   28cb0:	61304647 4c753957 62705a57 636c5248     GF0aW9uLWZpbHRlc
   28cc0:	49394d6e 52534e6e 50694930 5a6d786a     nM9InNSR0IiPjxmZ
   28cd0:	64686455 617a4e58 51754657 6331786d     UdhdXNzaWFuQmx1c
   28ce0:	62344269 63757857 6169307a 63305248     iB4bWxucz0iaHR0c
   28cf0:	4c766f44 64336433 4d333579 63763579     DovL3d3dy53My5vc
   28d00:	4d76636d 4d77416a 647a3943 4969636d     mcvMjAwMC9zdmciI
   28d10:	50756c47 62544a53 59795633 63485632     GluPSJTb3VyY2VHc
   28d20:	6177466d 496a6c47 647a4269 5a455247     mFwaGljIiBzdGREZ
   28d30:	59705a58 62705258 49393432 4d75516a     XZpYXRpb249IjQuM
   28d40:	4e7a6b6a 4d35416a 4f795944 4d354d44     jkzNjA5MDYyODM5M
   28d50:	49344944 502b3869 546c5a47 636d5a32     DI4Ii8+PGZlT2Zmc
   28d60:	49305632 62746848 507a3547 646f4a53     2V0IHhtbG5zPSJod
   28d70:	4f775248 64763869 4c336433 4c7a636e     HRwOi8vd3d3LnczL
   28d80:	5a79396d 4d793879 4c774144 5a324e33     m9yZy8yMDAwL3N2Z
   28d90:	5a674979 49396748 4969496a 50355247     yIgZHg9IjIiIGR5P
   28da0:	49794953 5a794269 62314e58 49395148     SIyIiByZXN1bHQ9I
   28db0:	586d426e 4d77457a 5a763946 5a7a5a6d     nBmXzEwMF9vZmZzZ
   28dc0:	62435258 49795648 502b3869 526c5a47     XRCbHVyIi8+PGZlR
   28dd0:	6276786d 65675132 62733147 49394d6e     mxvb2QgeG1sbnM9I
   28de0:	6430686d 4c364148 64333979 64756333     mh0dHA6Ly93d3cud
   28df0:	62754d7a 4c6e4a33 4d77497a 63764144     zMub3JnLzIwMDAvc
   28e00:	496e5a33 626d4269 5a763947 626a3143     3ZnIiBmbG9vZC1jb
   28e10:	63767832 4969306a 4d77417a 4d774144     2xvcj0iIzAwMDAwM
   28e20:	5a674943 6276786d 62745132 59684233     CIgZmxvb2Qtb3BhY
   28e30:	65306c32 4d693054 4e323443 50764953     2l0eT0iMC42NSIvP
   28e40:	5a6d786a 62764e55 63764258 5a306c32     jxmZUNvbXBvc2l0Z
   28e50:	62344253 63757857 6169307a 63305248     SB4bWxucz0iaHR0c
   28e60:	4c766f44 64336433 4d333579 63763579     DovL3d3dy53My5vc
   28e70:	4d76636d 4d77416a 647a3943 4969636d     mcvMjAwMC9zdmciI
   28e80:	4d756c47 6369306a 4d665a47 58774154     GluMj0icGZfMTAwX
   28e90:	5a6d3932 646c4e6e 64734a45 49694958     29mZnNldEJsdXIiI
   28ea0:	5a773947 64684a58 50793947 62704a53     G9wZXJhdG9yPSJpb
   28eb0:	63674969 647a566d 50307857 5a774a53     iIgcmVzdWx0PSJwZ
   28ec0:	4d78386c 5a664244 63764a48 596f4e46     l8xMDBfZHJvcFNoY
   28ed0:	64765257 50764979 5a6d786a 5a734a55     WRvdyIvPjxmZUJsZ
   28ee0:	496b3557 62746848 507a3547 646f4a53     W5kIHhtbG5zPSJod
   28ef0:	4f775248 64763869 4c336433 4c7a636e     HRwOi8vd3d3LnczL
   28f00:	5a79396d 4d793879 4c774144 5a324e33     m9yZy8yMDAwL3N2Z
   28f10:	61674979 49393457 64764e6c 5a6a4a58     yIgaW49IlNvdXJjZ
   28f20:	59796455 616f4258 49694d57 4d756c47     UdyYXBoaWMiIGluM
   28f30:	6369306a 4d665a47 58774154 62795232     j0icGZfMTAwX2Ryb
   28f40:	61544233 626b4647 49696333 5a763147     3BTaGFkb3ciIG1vZ
   28f50:	49395547 6376356d 6268316d 63674943     GU9Im5vcm1hbCIgc
   28f60:	647a566d 50307857 62664a53 58305633     mVzdWx0PSJfb3V0X
   28f70:	4e7a457a 52723530 4d336447 64596c6b     zEzN05rRGd3MklYd
   28f80:	56573157 5a345946 57304258 55334e48     W1WVFY4ZXB0WHN3U
   28f90:	62734a6d 4d797330 49576c7a 502b3869     mJsb0syMzlWIi8+P
   28fa0:	546c5a47 636d5a32 49305632 62746848     GZlT2Zmc2V0IHhtb
   28fb0:	507a3547 646f4a53 4f775248 64763869     G5zPSJodHRwOi8vd
   28fc0:	4c336433 4c7a636e 5a79396d 4d793879     3d3LnczLm9yZy8yM
   28fd0:	4c774144 5a324e33 61674979 49393457     DAwL3N2ZyIgaW49I
   28fe0:	6476396c 4d665258 54334d54 5a45746d     l9vdXRfMTM3TmtEZ
   28ff0:	53796333 62316856 56555a56 636c686a     3cySVh1bVZUVjhlc
   29000:	63595248 59536433 5376786d 4f7a497a     HRYc3dSYmxvSzIzO
   29010:	49695956 50345247 49304953 656b4269     VYiIGR4PSI0IiBke
   29020:	4d693054 50764969 5a6d786a 64686455     T0iMiIvPjxmZUdhd
   29030:	617a4e58 51754657 6331786d 62344269     XNzaWFuQmx1ciB4b
   29040:	63757857 6169307a 63305248 4c766f44     Wxucz0iaHR0cDovL
   29050:	64336433 4d333579 63763579 4d76636d     3d3dy53My5vcmcvM
   29060:	4d77416a 647a3943 4969636d 5a304e48     jAwMC9zdmciIHN0Z
   29070:	646c5245 64686c6d 62766c47 4e69306a     ERldmlhdGlvbj0iN
   29080:	4f793443 4d324d54 4e776b44 4d34496a     C4yOTM2MDkwNjI4M
   29090:	4d776b7a 4969676a 636c4a48 64735633     zkwMjgiIHJlc3Vsd
   290a0:	63693044 4d665a47 58784154 5a6d3932     D0icGZfMTAxX29mZ
   290b0:	646c4e6e 64734a45 4c694958 5a38347a     nNldEJsdXIiLz48Z
   290c0:	6244566d 62773132 64704e33 65675547     mVDb21wb3NpdGUge
   290d0:	62733147 49394d6e 6430686d 4c364148     G1sbnM9Imh0dHA6L
   290e0:	64333979 64756333 62754d7a 4c6e4a33     y93d3cudzMub3JnL
   290f0:	4d77497a 63764144 496e5a33 62704269     zIwMDAvc3ZnIiBpb
   29100:	5869306a 64313932 4d783846 614f647a     j0iX291dF8xMzdOa
   29110:	646e5230 574a4a7a 56745648 4f57526c     0RndzJJWHVtVlRWO
   29120:	64775647 647a6846 62694a31 4d4c3947     GVwdFhzd1JibG9LM
   29130:	56354d6a 61674969 50793457 5a774a53     jM5ViIgaW4yPSJwZ
   29140:	4d78386c 62664644 636d5a32 51305632     l8xMDFfb2Zmc2V0Q
   29150:	6331786d 63674969 647a566d 50307857     mx1ciIgcmVzdWx0P
   29160:	5a774a53 4d78386c 61664644 5a323557     SJwZl8xMDFfaW52Z
   29170:	5a7a4a58 62674953 636c4233 6230466d     XJzZSIgb3BlcmF0b
   29180:	49394933 6431396d 50764943 5a6d786a     3I9Im91dCIvPjxmZ
   29190:	62735a55 496b3932 62746848 507a3547     UZsb29kIHhtbG5zP
   291a0:	646f4a53 4f775248 64763869 4c336433     SJodHRwOi8vd3d3L
   291b0:	4c7a636e 5a79396d 4d793879 4c774144     nczLm9yZy8yMDAwL
   291c0:	5a324e33 5a674979 6276786d 59745132     3N2ZyIgZmxvb2QtY
   291d0:	62733932 49394933 4d774d69 4d774144     29sb3I9IiMwMDAwM
   291e0:	49694144 62735a47 4c6b3932 59773957     DAiIGZsb29kLW9wY
   291f0:	64704e57 49396b48 4e75416a 63674953     WNpdHk9IjAuNSIgc
   29200:	647a566d 50307857 5a774a53 4d78386c     mVzdWx0PSJwZl8xM
   29210:	59664644 62733932 4c694933 5a38347a     DFfY29sb3IiLz48Z
   29220:	6244566d 62773132 64704e33 65675547     mVDb21wb3NpdGUge
   29230:	62733147 49394d6e 6430686d 4c364148     G1sbnM9Imh0dHA6L
   29240:	64333979 64756333 62754d7a 4c6e4a33     y93d3cudzMub3JnL
   29250:	4d77497a 63764144 496e5a33 62704269     zIwMDAvc3ZnIiBpb
   29260:	6369306a 4d665a47 58784154 62764e32     j0icGZfMTAxX2Nvb
   29270:	49793947 62704269 4939496a 586d426e     G9yIiBpbjI9InBmX
   29280:	4d77457a 62703956 636c5a6e 496c4e6e     zEwMV9pbnZlcnNlI
   29290:	63764269 59795647 63765258 6169306a     iBvcGVyYXRvcj0ia
   292a0:	49693457 636c4a48 64735633 63693044     W4iIHJlc3VsdD0ic
   292b0:	4d665a47 58784154 596f4e33 64765257     GZfMTAxX3NoYWRvd
   292c0:	50764979 5a6d786a 62764e55 63764258     yIvPjxmZUNvbXBvc
   292d0:	5a306c32 62344253 63757857 6169307a     2l0ZSB4bWxucz0ia
   292e0:	63305248 4c766f44 64336433 4d333579     HR0cDovL3d3dy53M
   292f0:	63763579 4d76636d 4d77416a 647a3943     y5vcmcvMjAwMC9zd
   29300:	4969636d 50756c47 5a774a53 4d78386c     mciIGluPSJwZl8xM
   29310:	63664644 5a686832 49333947 62704269     DFfc2hhZG93IiBpb
   29320:	4939496a 6476396c 4d665258 54334d54     jI9Il9vdXRfMTM3T
   29330:	5a45746d 53796333 62316856 56555a56     mtEZ3cySVh1bVZUV
   29340:	636c686a 63595248 59536433 5376786d     jhlcHRYc3dSYmxvS
   29350:	4f7a497a 49695956 5a773947 64684a58     zIzOVYiIG9wZXJhd
   29360:	50793947 64764a53 4979566d 5a794269     G9yPSJvdmVyIiByZ
   29370:	62314e58 49395148 6476396c 65665258     XN1bHQ9Il9vdXRfe
   29380:	64483957 65334554 55315258 61615648     W9HdTE3eXR1UHVaa
   29390:	644b6c32 61355554 64596c31 57685a30     2lKdTU5a1lYd0ZhW
   293a0:	5a355245 536f4e47 4c69496b 5a38347a     ER5ZGNoSkIiLz48Z
   293b0:	5a4e566d 5a6e4a58 5a383454 5a4e566d     mVNZXJnZT48ZmVNZ
   293c0:	5a6e4a58 5a763555 61675547 49393457     XJnZU5vZGUgaW49I
   293d0:	6476396c 65665258 64483957 65334554     l9vdXRfeW9HdTE3e
   293e0:	55315258 61615648 644b6c32 61355554     XR1UHVaa2lKdTU5a
   293f0:	64596c31 57685a30 5a355245 536f4e47     1lYd0ZhWER5ZGNoS
   29400:	4c69496b 4c38347a 546c5a32 5a795657     kIiLz48L2ZlTWVyZ
   29410:	502b5532 526c5a47 63314632 59704e33     2U+PGZlR2F1c3NpY
   29420:	62433557 49795648 62746848 507a3547     W5CbHVyIHhtbG5zP
   29430:	646f4a53 4f775248 64763869 4c336433     SJodHRwOi8vd3d3L
   29440:	4c7a636e 5a79396d 4d793879 4c774144     nczLm9yZy8yMDAwL
   29450:	5a324e33 63674979 526b5233 61325647     3N2ZyIgc3RkRGV2a
   29460:	61304657 50753957 4c774953 4f79516a     WF0aW9uPSIwLjQyO
   29470:	4d324d54 4e776b44 4d34496a 4d776b7a     TM2MDkwNjI4MzkwM
   29480:	497a676a 502b3869 616d3943 5a307857     jgzIi8+PC9maWx0Z
   29490:	502b4958 5a6b3943 507a5a57 496e786a     XI+PC9kZWZzPjxnI
   294a0:	62705a47 636c5248 6469306a 4b734a58     GZpbHRlcj0idXJsK
   294b0:	4e4b4e43 55466457 61615255 51475a6e     CNKNWdFUURaanZGQ
   294c0:	62524e32 55795a44 57795945 62795956     2NRbDZyUEYyWVYyb
   294d0:	4e754e6b 4e4e5a32 59504a32 50696b69     kNuN2ZNN2JPYikiP
   294e0:	5977786a 496f5258 49395147 494e4269     jxwYXRoIGQ9IiBNI
   294f0:	4d774544 4d313479 4e794169 4d756b54     DEwMy41MiAyNTkuM
   29500:	4935416a 4d677745 4c7a4154 4979556a     jA5IEwgMTAzLjUyI
   29510:	4c305144 4e796b6a 49444253 4d774544     DQ0LjkyNSBDIDEwM
   29520:	4d313479 4d7a4169 4d303453 4f675954     y41MiAzMS40MTYgO
   29530:	4d754d54 4930456a 4c774944 4f30516a     TMuMjE0IDIwLjQ0O
   29540:	4d344153 4d313443 4d794169 4e303443     SA4MC41MiAyMC40N
   29550:	54676b44 4d344143 4d313443 4d794169     DkgTCA4MC41MiAyM
   29560:	4e303443 51676b44 4e324179 4d343479     C40NDkgQyA2Ny44M
   29570:	4d67596a 4e75416a 49355144 4c335544     jYgMjAuNDQ5IDU3L
   29580:	4979556a 4c784d44 4e78516a 4e314169     jUyIDMxLjQxNiA1N
   29590:	4d313479 4e304169 4d353443 5467556a     y41MiA0NC45MjUgT
   295a0:	4e314143 4d313479 4e794169 4d756b54     CA1Ny41MiAyNTkuM
   295b0:	4935416a 4e674d45 4e755544 4d67677a     jA5IEMgNDUuNzggM
   295c0:	4c32596a 4934636a 49344d44 4f334944     jY2Ljc4IDM4IDI3O
   295d0:	4e353453 4d674d7a 4d67677a 4c306b6a     S45NzMgMzggMjk0L
   295e0:	4f326b6a 49444253 49344d44 4f784d44     jk2OSBDIDM4IDMxO
   295f0:	4d303443 4e67597a 4d756354 49795544     C40MzYgNTcuMDUyI
   29600:	4e7a4d44 4f303479 4f676744 4e754144     DMzNy40ODggODAuN
   29610:	4d674954 4c334d7a 4f34516a 49444243     TIgMzM3LjQ4OCBDI
   29620:	4d774544 4f353479 4d676344 4c334d7a     DEwMy45ODcgMzM3L
   29630:	4f34516a 4d784143 4d754d6a 49354d44     jQ4OCAxMjMuMDM5I
   29640:	4f784d44 4d303443 4d67597a 4c7a4954     DMxOC40MzYgMTIzL
   29650:	4f7a416a 4f794153 4f755154 49355954     jAzOSAyOTQuOTY5I
   29660:	4d674d45 4c7a4954 4f7a416a 4e794153     EMgMTIzLjAzOSAyN
   29670:	4f756b7a 497a6354 4e784544 4e793453     zkuOTczIDExNS4yN
   29680:	4e794169 4e75596a 4d67677a 4c7a4154     iAyNjYuNzggMTAzL
   29690:	4979556a 4f314944 4d793453 57676b44     jUyIDI1OS4yMDkgW
   296a0:	49694169 62705a47 63747747 5a73566e     iAiIGZpbGwtcnVsZ
   296b0:	5a693054 626c5a58 5a6b396d 5a674943     T0iZXZlbm9kZCIgZ
   296c0:	62736c6d 63693044 4b69646d 4e7a4944     mlsbD0icmdiKDIzN
   296d0:	4d797753 4d73557a 4b314d6a 64674953     SwyMzUsMjM1KSIgd
   296e0:	646a566d 4c793947 5a6d5657 646a566d     mVjdG9yLWVmZmVjd
   296f0:	62693044 4c75396d 596a4e58 62707857     D0ibm9uLXNjYWxpb
   29700:	6374636d 62795233 496c7432 647a4269     mctc3Ryb2tlIiBzd
   29710:	61764a48 64745532 646b6c32 49396747     HJva2Utd2lkdGg9I
   29720:	49694d6a 63304e48 5a72396d 63693054     jMiIHN0cm9rZT0ic
   29730:	4b69646d 4d734144 4b777743 63674953     mdiKDAsMCwwKSIgc
   29740:	62795233 4c6c7432 62707857 6271566d     3Ryb2tlLWxpbmVqb
   29750:	50756c32 61744a53 636c5258 63674969     2luPSJtaXRlciIgc
   29760:	62795233 4c6c7432 62707857 596a566d     3Ryb2tlLWxpbmVjY
   29770:	49394158 64784e6e 5a794657 63674953     XA9InNxdWFyZSIgc
   29780:	62795233 4c6c7432 64703157 62795647     3Ryb2tlLW1pdGVyb
   29790:	61746c47 49395158 4c694d6a 4c38347a     GltaXQ9IjMiLz48L
   297a0:	502b6332 5a6c5247 502b4d6e 62705a47     2c+PGRlZnM+PGZpb
   297b0:	636c5248 5a704269 51693044 596c5655     HRlciBpZD0iQUVlY
   297c0:	4e346758 524b3547 63303445 634c5a44     Xg4NG5KRE40cDZLc
   297d0:	4e466844 514f6830 564a4a6e 65685a55     DhFN0hOQnJJVUZhe
   297e0:	56364e46 49694957 49396748 4d793069     FN6VWIiIHg9Ii0yM
   297f0:	496c4144 50354269 4d744953 4a77416a     DAlIiB5PSItMjAwJ
   29800:	64674953 646b6c32 49396747 4d77516a     SIgd2lkdGg9IjQwM
   29810:	49695543 616c6847 646f6457 4e693044     CUiIGhlaWdodD0iN
   29820:	4a774144 5a674953 64736c6d 56795647     DAwJSIgZmlsdGVyV
   29830:	64703557 49394d48 6169396d 646a566d     W5pdHM9Im9iamVjd
   29840:	64764a45 616b3557 516e3557 4934396d     EJvdW5kaW5nQm94I
   29850:	626a4269 63767832 62703169 636c526e     iBjb2xvci1pbnRlc
   29860:	6276426e 61304647 4c753957 62705a57     nBvbGF0aW9uLWZpb
   29870:	636c5248 49394d6e 52534e6e 50694930     HRlcnM9InNSR0IiP
   29880:	5a6d786a 64686455 617a4e58 51754657     jxmZUdhdXNzaWFuQ
   29890:	6331786d 62344269 63757857 6169307a     mx1ciB4bWxucz0ia
   298a0:	63305248 4c766f44 64336433 4d333579     HR0cDovL3d3dy53M
   298b0:	63763579 4d76636d 4d77416a 647a3943     y5vcmcvMjAwMC9zd
   298c0:	4969636d 5a304e48 646c5245 64686c6d     mciIHN0ZERldmlhd
   298d0:	62766c47 4d69306a 4e773479 4e306744     Glvbj0iMy4wNDg0N
   298e0:	4d30496a 4d32517a 4d335554 50764953     jI0MzQ2MTU3MSIvP
   298f0:	5a76776a 64736c6d 50795647 5a76776a     jwvZmlsdGVyPjwvZ
   29900:	636d5647 5a38347a 616d4279 5a307857     GVmcz48ZyBmaWx0Z
   29910:	49394958 6279566e 516a6743 596c5655     XI9InVybCgjQUVlY
   29920:	4e346758 524b3547 63303445 634c5a44     Xg4NG5KRE40cDZLc
   29930:	4e466844 514f6830 564a4a6e 65685a55     DhFN0hOQnJJVUZhe
   29940:	56364e46 49704957 5938346a 59796c32     FN6VWIpIj48Y2lyY
   29950:	496c7832 596c5a48 63765233 5a6c3169     2xlIHZlY3Rvci1lZ
   29960:	596c5a6d 49395133 6276356d 597a3169     mZlY3Q9Im5vbi1zY
   29970:	61734632 4c6e3557 63304e58 5a72396d     2FsaW5nLXN0cm9rZ
   29980:	59674953 49396733 4c77676a 4f78556a     SIgY3g9IjgwLjUxO
   29990:	4e345954 4f7a4154 4f324d54 49326754     TY4NTAzOTM2OTg2I
   299a0:	656a4269 4d693054 4c316b6a 4d77676a     iBjeT0iMjk1LjgwM
   299b0:	4f30457a 4e775954 4f35496a 49326744     zE0OTYwNjI5ODg2I
   299c0:	50794269 4f7a4953 4f323453 4d775544     iByPSIzOS42ODUwM
   299d0:	4e7a6b7a 4e77417a 4e33677a 5a674943     zkzNzAwNzg3NCIgZ
   299e0:	62736c6d 63693044 4b69646d 4d7a4944     mlsbD0icmdiKDIzM
   299f0:	4e787743 4e787743 49696b43 63304e48     CwxNCwxNCkiIHN0c
   29a00:	5a72396d 61333153 61305257 4d693044     m9rZS13aWR0aD0iM
   29a10:	63674953 62795233 506c7432 5a794a53     SIgc3Ryb2tlPSJyZ
   29a20:	4d6f4932 4c777743 49704144 647a4269     2IoMCwwLDApIiBzd
   29a30:	61764a48 62745532 5a756c47 61767057     HJva2UtbGluZWpva
   29a40:	49393457 6470316d 49795647 647a4269     W49Im1pdGVyIiBzd
   29a50:	61764a48 62745532 5a756c47 63684e57     HJva2UtbGluZWNhc
   29a60:	63693044 59314633 496c4a58 647a4269     D0ic3F1YXJlIiBzd
   29a70:	61764a48 62745532 5a306c57 61734a58     HJva2UtbWl0ZXJsa
   29a80:	64703157 4d693044 50764979 5a76776a     W1pdD0iMyIvPjwvZ
   29a90:	6338347a 646a566d 50344243 4d324953     z48cmVjdCB4PSI2M
   29aa0:	4e323453 4969637a 49396b48 4e30496a     S42NzciIHk9IjI0N
   29ab0:	4e303469 49696b44 5a706448 506f5248     i40NDkiIHdpZHRoP
   29ac0:	4f7a4953 4e793443 4969676a 616c6847     SIzOC4yNjgiIGhla
   29ad0:	646f6457 4d693044 4969556a 59795248     WdodD0iMjUiIHRyY
   29ae0:	5a7a3557 6279396d 62693054 63304657     W5zZm9ybT0ibWF0c
   29af0:	4b346c6d 4d734544 4c777743 4d734544     ml4KDEsMCwwLDEsM
   29b00:	4b777743 5a674953 62736c6d 63693044     CwwKSIgZmlsbD0ic
   29b10:	4b69646d 4d7a4944 4e787743 4e787743     mdiKDIzMCwxNCwxN
   29b20:	4c696b43 6238347a 5a756c47 4d344253     CkiLz48bGluZSB4M
   29b30:	4e693054 4e756354 497a6754 4d354269     T0iNTcuNTgzIiB5M
   29b40:	4d693054 4c33516a 4979496a 4d344269     T0iMjQ3LjIyIiB4M
   29b50:	4d69306a 4d75497a 49784d7a 4d354269     j0iMzIuMzMxIiB5M
   29b60:	4d69306a 4c33516a 4979496a 5a324269     j0iMjQ3LjIyIiB2Z
   29b70:	62304e57 5a744933 5a6d5a57 50304e57     WN0b3ItZWZmZWN0P
   29b80:	62754a53 63743432 62684e32 5a756c47     SJub24tc2NhbGluZ
   29b90:	647a3179 61764a48 49695532 63304e48     y1zdHJva2UiIHN0c
   29ba0:	5a72396d 61333153 61305257 4d693044     m9rZS13aWR0aD0iM
   29bb0:	63674979 62795233 506c7432 5a794a53     yIgc3Ryb2tlPSJyZ
   29bc0:	4d6f4932 4c777743 49704144 647a4269     2IoMCwwLDApIiBzd
   29bd0:	61764a48 62745532 5a756c47 61767057     HJva2UtbGluZWpva
   29be0:	49393457 6470316d 49795647 647a4269     W49Im1pdGVyIiBzd
   29bf0:	61764a48 62745532 5a756c47 63684e57     HJva2UtbGluZWNhc
   29c00:	63693044 59314633 496c4a58 647a4269     D0ic3F1YXJlIiBzd
   29c10:	61764a48 62745532 5a306c57 61734a58     HJva2UtbWl0ZXJsa
   29c20:	64703157 4d693044 50764979 6173786a     W1pdD0iMyIvPjxsa
   29c30:	496c3557 50786748 4e314953 4f313479     W5lIHgxPSI1Ny41O
   29c40:	49694d44 50786b48 4f354953 4d303443     DMiIHkxPSI5OC40M
   29c50:	49694944 50796748 4d7a4953 4d7a3469     DIiIHgyPSIzMi4zM
   29c60:	4969457a 50796b48 4f354953 4d303443     zEiIHkyPSI5OC40M
   29c70:	49694944 596c5a48 63765233 5a6c3169     DIiIHZlY3Rvci1lZ
   29c80:	596c5a6d 49395133 6276356d 597a3169     mZlY3Q9Im5vbi1zY
   29c90:	61734632 4c6e3557 63304e58 5a72396d     2FsaW5nLXN0cm9rZ
   29ca0:	63674953 62795233 4c6c7432 5a706458     SIgc3Ryb2tlLXdpZ
   29cb0:	506f5248 497a4953 647a4269 61764a48     HRoPSIzIiBzdHJva
   29cc0:	49395532 596e4a6e 4c776769 4d734144     2U9InJnYigwLDAsM
   29cd0:	49696b43 63304e48 5a72396d 61733153     CkiIHN0cm9rZS1sa
   29ce0:	616c3557 6270396d 6269306a 5a306c57     W5lam9pbj0ibWl0Z
   29cf0:	49694958 63304e48 5a72396d 61733153     XIiIHN0cm9rZS1sa
   29d00:	596c3557 50774632 637a4a53 63685658     W5lY2FwPSJzcXVhc
   29d10:	4969556d 63304e48 5a72396d 61743153     mUiIHN0cm9rZS1ta
   29d20:	636c5258 6270786d 50306c57 497a4953     XRlcmxpbWl0PSIzI
   29d30:	502b3869 62707847 6567556d 49394544     i8+PGxpbmUgeDE9I
   29d40:	4c33556a 4d34556a 65674979 49394554     jU3LjU4MyIgeTE9I
   29d50:	4f30456a 4d773443 49696744 50796748     jE0OC4wMDgiIHgyP
   29d60:	4d7a4953 4d7a3469 4969457a 50796b48     SIzMi4zMzEiIHkyP
   29d70:	4e784953 4d756744 49344144 5a324269     SIxNDguMDA4IiB2Z
   29d80:	62304e57 5a744933 5a6d5a57 50304e57     WN0b3ItZWZmZWN0P
   29d90:	62754a53 63743432 62684e32 5a756c47     SJub24tc2NhbGluZ
   29da0:	647a3179 61764a48 49695532 63304e48     y1zdHJva2UiIHN0c
   29db0:	5a72396d 61333153 61305257 4d693044     m9rZS13aWR0aD0iM
   29dc0:	63674979 62795233 506c7432 5a794a53     yIgc3Ryb2tlPSJyZ
   29dd0:	4d6f4932 4c777743 49704144 647a4269     2IoMCwwLDApIiBzd
   29de0:	61764a48 62745532 5a756c47 61767057     HJva2UtbGluZWpva
   29df0:	49393457 6470316d 49795647 647a4269     W49Im1pdGVyIiBzd
   29e00:	61764a48 62745532 5a756c47 63684e57     HJva2UtbGluZWNhc
   29e10:	63693044 59314633 496c4a58 647a4269     D0ic3F1YXJlIiBzd
   29e20:	61764a48 62745532 5a306c57 61734a58     HJva2UtbWl0ZXJsa
   29e30:	64703157 4d693044 50764979 6173786a     W1pdD0iMyIvPjxsa
   29e40:	496c3557 50786748 4e314953 4f313479     W5lIHgxPSI1Ny41O
   29e50:	49694d44 50786b48 4f784953 4e756354     DMiIHkxPSIxOTcuN
   29e60:	4930456a 4d344269 4d69306a 4d75497a     jE0IiB4Mj0iMzIuM
   29e70:	49784d7a 4d354269 4d69306a 4c336b54     zMxIiB5Mj0iMTk3L
   29e80:	4e78596a 64674943 646a566d 4c793947     jYxNCIgdmVjdG9yL
   29e90:	5a6d5657 646a566d 62693044 4c75396d     WVmZmVjdD0ibm9uL
   29ea0:	596a4e58 62707857 6374636d 62795233     XNjYWxpbmctc3Ryb
   29eb0:	496c7432 647a4269 61764a48 64745532     2tlIiBzdHJva2Utd
   29ec0:	646b6c32 49396747 49694d6a 63304e48     2lkdGg9IjMiIHN0c
   29ed0:	5a72396d 63693054 4b69646d 4d734144     m9rZT0icmdiKDAsM
   29ee0:	4b777743 63674953 62795233 4c6c7432     CwwKSIgc3Ryb2tlL
   29ef0:	62707857 6271566d 50756c32 61744a53     WxpbmVqb2luPSJta
   29f00:	636c5258 63674969 62795233 4c6c7432     XRlciIgc3Ryb2tlL
   29f10:	62707857 596a566d 49394158 64784e6e     WxpbmVjYXA9InNxd
   29f20:	5a794657 63674953 62795233 4c6c7432     WFyZSIgc3Ryb2tlL
   29f30:	64703157 62795647 61746c47 49395158     W1pdGVybGltaXQ9I
   29f40:	4c694d6a 6238347a 5a756c47 4d344253     jMiLz48bGluZSB4M
   29f50:	4e693054 4e756354 497a6754 4d354269     T0iNTcuNTgzIiB5M
   29f60:	4e693054 4e756344 49316b7a 4d344269     T0iNDcuNzk1IiB4M
   29f70:	4d69306a 4d75497a 49784d7a 4d354269     j0iMzIuMzMxIiB5M
   29f80:	4e69306a 4e756344 49316b7a 5a324269     j0iNDcuNzk1IiB2Z
   29f90:	62304e57 5a744933 5a6d5a57 50304e57     WN0b3ItZWZmZWN0P
   29fa0:	62754a53 63743432 62684e32 5a756c47     SJub24tc2NhbGluZ
   29fb0:	647a3179 61764a48 49695532 63304e48     y1zdHJva2UiIHN0c
   29fc0:	5a72396d 61333153 61305257 4d693044     m9rZS13aWR0aD0iM
   29fd0:	63674979 62795233 506c7432 5a794a53     yIgc3Ryb2tlPSJyZ
   29fe0:	4d6f4932 4c777743 49704144 647a4269     2IoMCwwLDApIiBzd
   29ff0:	61764a48 62745532 5a756c47 61767057     HJva2UtbGluZWpva
   2a000:	49393457 6470316d 49795647 647a4269     W49Im1pdGVyIiBzd
   2a010:	61764a48 62745532 5a756c47 63684e57     HJva2UtbGluZWNhc
   2a020:	63693044 59314633 496c4a58 647a4269     D0ic3F1YXJlIiBzd
   2a030:	61764a48 62745532 5a306c57 61734a58     HJva2UtbWl0ZXJsa
   2a040:	64703157 4d693044 50764979 496e786a     W1pdD0iMyIvPjxnI
   2a050:	59795248 5a7a3557 6279396d 62693054     HRyYW5zZm9ybT0ib
   2a060:	63304657 4b346c6d 4d734544 4c777743     WF0cml4KDEsMCwwL
   2a070:	4d734544 4e735954 50696b69 5a30786a     DEsMTYsNikiPjx0Z
   2a080:	49306858 59795248 5a7a3557 6279396d     Xh0IHRyYW5zZm9yb
   2a090:	62693054 63304657 4b346c6d 4d734544     T0ibWF0cml4KDEsM
   2a0a0:	4c777743 4d734544 4e343443 4d734544     CwwLDEsMC44NDEsM
   2a0b0:	4e75496a 4b325144 63674953 62355233     jIuNDQ2KSIgc3R5b
   2a0c0:	49395547 62765a6d 5a74516e 6174466d     GU9ImZvbnQtZmFta
   2a0d0:	4f357857 63506469 49755647 62684e46     Wx5OidPcGVuIFNhb
   2a0e0:	4f6e4d6e 62765a32 6474516e 5a705632     nMnO2ZvbnQtd2VpZ
   2a0f0:	4f306832 4d77636a 626d7444 4c303532     2h0OjcwMDtmb250L
   2a100:	65704e58 4d36556d 6577466a 626d7444     XNpemU6MjFweDtmb
   2a110:	4c303532 65304e58 4f6c7857 59306c6d     250LXN0eWxlOml0Y
   2a120:	59707857 616d747a 4f737857 4d774d69     WxpYztmaWxsOiMwM
   2a130:	4d774144 63374144 62795233 4f6c7432     DAwMDA7c3Ryb2tlO
   2a140:	6276356d 4937556d 7343376a 4c384d45     m5vbmU7Ij7CsEM8L
   2a150:	656c5233 502b5148 506e3943 496e786a     3RleHQ+PC9nPjxnI
   2a160:	59795248 5a7a3557 6279396d 62693054     HRyYW5zZm9ybT0ib
   2a170:	63304657 4b346c6d 4d734544 4c777743     WF0cml4KDEsMCwwL
   2a180:	4e734544 4e7a7779 4d333469 4970636a     DEsNywzNi43MjcpI
   2a190:	6438346a 64345647 63304243 6375466d     j48dGV4dCB0cmFuc
   2a1a0:	63765a32 4939306d 6468316d 65704a48     2Zvcm09Im1hdHJpe
   2a1b0:	4c786743 4d734144 4c787743 4d734144     CgxLDAsMCwxLDAsM
   2a1c0:	4f754954 4b324944 63674953 62355233     TIuODI2KSIgc3R5b
   2a1d0:	49395547 62765a6d 5a74516e 6174466d     GU9ImZvbnQtZmFta
   2a1e0:	4f357857 63506469 49755647 62684e46     Wx5OidPcGVuIFNhb
   2a1f0:	4f6e4d6e 62765a32 6474516e 5a705632     nMnO2ZvbnQtd2VpZ
   2a200:	4f306832 4d77596a 626d7444 4c303532     2h0OjYwMDtmb250L
   2a210:	65704e58 4d36556d 65774a54 626d7444     XNpemU6MTJweDtmb
   2a220:	4c303532 65304e58 4f6c7857 59306c6d     250LXN0eWxlOml0Y
   2a230:	59707857 616d747a 4f737857 4d774d69     WxpYztmaWxsOiMwM
   2a240:	4d774144 63374144 62795233 4f6c7432     DAwMDA7c3Ryb2tlO
   2a250:	6276356d 4937556d 4d78346a 4c384144     m5vbmU7Ij4xMDA8L
   2a260:	656c5233 502b5148 506e3943 496e786a     3RleHQ+PC9nPjxnI
   2a270:	59795248 5a7a3557 6279396d 62693054     HRyYW5zZm9ybT0ib
   2a280:	63304657 4b346c6d 4d734544 4c777743     WF0cml4KDEsMCwwL
   2a290:	4d734544 4f734154 4d754154 4b784d6a     DEsMTAsOTAuMjMxK
   2a2a0:	502b4953 656c5248 64675148 62684a48     SI+PHRleHQgdHJhb
   2a2b0:	626d4e6e 50744a33 59744a53 61795258     nNmb3JtPSJtYXRya
   2a2c0:	4d6f6758 4c777753 4d734144 4c777753     XgoMSwwLDAsMSwwL
   2a2d0:	4c794544 4e79676a 49696b69 65304e48     DEyLjgyNikiIHN0e
   2a2e0:	506c7857 626d4a53 4c303532 62685a57     WxlPSJmb250LWZhb
   2a2f0:	65736c57 546e6f54 626c4233 59544269     WlseTonT3BlbiBTY
   2a300:	4a7a3557 626d747a 4c303532 616c6458     W5zJztmb250LXdla
   2a310:	646f6457 4d326f44 5a374144 6475396d     WdodDo2MDA7Zm9ud
   2a320:	617a3143 4f6c7058 6379456a 5a376748     C1zaXplOjEycHg7Z
   2a330:	6475396d 647a3143 5a736c48 64707054     m9udC1zdHlsZTppd
   2a340:	61734647 5a374d57 62736c6d 4d6a6f44     GFsaWM7ZmlsbDojM
   2a350:	4d774144 4f774144 63304e33 5a72396d     DAwMDAwO3N0cm9rZ
   2a360:	62757054 4f6c3532 4e2b4979 4c38557a     Tpub25lOyI+NzU8L
   2a370:	656c5233 502b5148 506e3943 496e786a     3RleHQ+PC9nPjxnI
   2a380:	59795248 5a7a3557 6279396d 62693054     HRyYW5zZm9ybT0ib
   2a390:	63304657 4b346c6d 4d734544 4c777743     WF0cml4KDEsMCwwL
   2a3a0:	4d734544 4d734154 4c354d54 4e7a676a     DEsMTAsMTM5LjgzN
   2a3b0:	50696b79 5a30786a 49306858 59795248     ykiPjx0ZXh0IHRyY
   2a3c0:	5a7a3557 6279396d 62693054 63304657     W5zZm9ybT0ibWF0c
   2a3d0:	4b346c6d 4d734544 4c777743 4d734544     ml4KDEsMCwwLDEsM
   2a3e0:	4d787743 4d343469 4970596a 647a4269     CwxMi44MjYpIiBzd
   2a3f0:	5a736c48 5a693054 6475396d 596d3143     HlsZT0iZm9udC1mY
   2a400:	62703157 4a366b48 5a773930 55673457     W1pbHk6J09wZW4gU
   2a410:	63754632 5a376379 6475396d 5a333143     2Fucyc7Zm9udC13Z
   2a420:	616e6c57 4e365148 4f77416a 62765a32     WlnaHQ6NjAwO2Zvb
   2a430:	6374516e 5a366c32 4d786f54 4f34426e     nQtc2l6ZToxMnB4O
   2a440:	62765a32 6374516e 62355233 61365547     2ZvbnQtc3R5bGU6a
   2a450:	62685258 4f6a6c47 62705a32 49367747     XRhbGljO2ZpbGw6I
   2a460:	4d77417a 4d774144 647a7444 61764a48     zAwMDAwMDtzdHJva
   2a470:	62365532 5a75396d 50697354 5077556a     2U6bm9uZTsiPjUwP
   2a480:	5a303943 50306858 5a76776a 5a38347a     C90ZXh0PjwvZz48Z
   2a490:	63304279 6375466d 63765a32 4939306d     yB0cmFuc2Zvcm09I
   2a4a0:	6468316d 65704a48 4c786743 4d734144     m1hdHJpeCgxLDAsM
   2a4b0:	4c787743 4c774544 4f344544 4e303453     CwxLDEwLDE4OS40N
   2a4c0:	49704d44 6438346a 64345647 63304243     DMpIj48dGV4dCB0c
   2a4d0:	6375466d 63765a32 4939306d 6468316d     mFuc2Zvcm09Im1hd
   2a4e0:	65704a48 4c786743 4d734144 4c787743     HJpeCgxLDAsMCwxL
   2a4f0:	4d754144 4c314154 4c794544 4e79676a     DAuMTA1LDEyLjgyN
   2a500:	49696b69 65304e48 506c7857 626d4a53     ikiIHN0eWxlPSJmb
   2a510:	4c303532 62685a57 65736c57 546e6f54     250LWZhbWlseTonT
   2a520:	626c4233 59544269 4a7a3557 626d747a     3BlbiBTYW5zJztmb
   2a530:	4c303532 616c6458 646f6457 4d326f44     250LXdlaWdodDo2M
   2a540:	5a374144 6475396d 617a3143 4f6c7058     DA7Zm9udC1zaXplO
   2a550:	6379456a 5a376748 6475396d 647a3143     jEycHg7Zm9udC1zd
   2a560:	5a736c48 64707054 61734647 5a374d57     HlsZTppdGFsaWM7Z
   2a570:	62736c6d 4d6a6f44 4d774144 4f774144     mlsbDojMDAwMDAwO
   2a580:	63304e33 5a72396d 62757054 4f6c3532     3N0cm9rZTpub25lO
   2a590:	4d2b4979 4c38556a 656c5233 502b5148     yI+MjU8L3RleHQ+P
   2a5a0:	506e3943 496e786a 59795248 5a7a3557     C9nPjxnIHRyYW5zZ
   2a5b0:	6279396d 62693054 63304657 4b346c6d     m9ybT0ibWF0cml4K
   2a5c0:	4d734544 4c777743 4d734544 4d734154     DEsMCwwLDEsMTAsM
   2a5d0:	4c344d6a 4d30516a 50696b79 5a30786a     jM4LjQ0MykiPjx0Z
   2a5e0:	49306858 59795248 5a7a3557 6279396d     Xh0IHRyYW5zZm9yb
   2a5f0:	62693054 63304657 4b346c6d 4d734544     T0ibWF0cml4KDEsM
   2a600:	4c777743 4d734544 4d787743 4d343469     CwwLDEsMCwxMi44M
   2a610:	4970596a 647a4269 5a736c48 5a693054     jYpIiBzdHlsZT0iZ
   2a620:	6475396d 596d3143 62703157 4a366b48     m9udC1mYW1pbHk6J
   2a630:	5a773930 55673457 63754632 5a376379     09wZW4gU2Fucyc7Z
   2a640:	6475396d 5a333143 616e6c57 4e365148     m9udC13ZWlnaHQ6N
   2a650:	4f77416a 62765a32 6374516e 5a366c32     jAwO2ZvbnQtc2l6Z
   2a660:	4d786f54 4f34426e 62765a32 6374516e     ToxMnB4O2ZvbnQtc
   2a670:	62355233 61365547 62685258 4f6a6c47     3R5bGU6aXRhbGljO
   2a680:	62705a32 49367747 4d77417a 4d774144     2ZpbGw6IzAwMDAwM
   2a690:	647a7444 61764a48 62365532 5a75396d     DtzdHJva2U6bm9uZ
   2a6a0:	50697354 4c38416a 656c5233 502b5148     TsiPjA8L3RleHQ+P
   2a6b0:	506e3943 5a76776a 4c38347a 502b6332     C9nPjwvZz48L2c+P
   2a6c0:	647a3943 222b636d 6f6e2029 7065722d     C9zdmc+") no-rep
   2a6d0:	3b746165 20200a0d 65682020 74686769     eat;..    height
   2a6e0:	3432203a 3b787030 20200a0d 69772020     : 240px;..    wi
   2a6f0:	3a687464 35303120 0d3b7870 2020200a     dth: 105px;..   
   2a700:	64617020 676e6964 706f742d 3033203a      padding-top: 30
   2a710:	7870352e 7d0a0d3b 0a0d0a0d 65687423     .5px;..}....#the
   2a720:	2d6f6d72 676f7270 73736572 0a0d7b20     rmo-progress {..
   2a730:	20202020 67696568 203a7468 70343331         height: 134p
   2a740:	0a0d3b78 20202020 6b636162 756f7267     x;..    backgrou
   2a750:	632d646e 726f6c6f 4523203a 30453036     nd-color: #E60E0
   2a760:	0a0d3b45 20202020 6772616d 6c2d6e69     E;..    margin-l
   2a770:	3a746665 70313420 0a0d3b78 20202020     eft: 41px;..    
   2a780:	74646977 32203a68 70352e35 0a0d3b78     width: 25.5px;..
   2a790:	20202020 64726f62 722d7265 75696461         border-radiu
   2a7a0:	32203a73 20787035 78703532 30203020     s: 25px 25px 0 0
   2a7b0:	7d0a0d3b 0a0d0a0d 65687423 2d6f6d72     ;..}....#thermo-
   2a7c0:	20726162 200a0d7b 77202020 68746469     bar {..    width
   2a7d0:	3532203a 7870352e 200a0d3b 68202020     : 25.5px;..    h
   2a7e0:	68676965 31203a74 3b253030 20200a0d     eight: 100%;..  
   2a7f0:	61622020 72676b63 646e756f 6c6f632d       background-col
   2a800:	203a726f 65366523 3b366536 0d7d0a0d     or: #e6e6e6;..}.
   2a810:	230a0d0a 706d6574 64616552 20676e69     ...#tempReading 
   2a820:	200a0d7b 70202020 69646461 6c2d676e     {..    padding-l
   2a830:	3a746665 70333420 0a0d3b78 20202020     eft: 43px;..    
   2a840:	64646170 2d676e69 3a706f74 70343220     padding-top: 24p
   2a850:	0a0d3b78 20202020 6f6c6f63 77203a72     x;..    color: w
   2a860:	65746968 7d0a0d3b 0a0d0a0d 69617223     hite;..}....#rai
   2a870:	61622d6e 72676b63 646e756f 0a0d7b20     n-background {..
   2a880:	20202020 6772616d 742d6e69 203a706f         margin-top: 
   2a890:	78703033 200a0d3b 70202020 7469736f     30px;..    posit
   2a8a0:	3a6e6f69 6c657220 76697461 0a0d3b65     ion: relative;..
   2a8b0:	20202020 67696568 203a7468 70303731         height: 170p
   2a8c0:	0a0d3b78 20202020 74646977 31203a68     x;..    width: 1
   2a8d0:	78703530 200a0d3b 62202020 676b6361     05px;..    backg
   2a8e0:	6e756f72 75203a64 22286c72 61746164     round: url("data
   2a8f0:	616d693a 732f6567 782b6776 623b6c6d     :image/svg+xml;b
   2a900:	36657361 44502c34 57623439 6d646777     ase64,PD94bWwgdm
   2a910:	32637956 6a62766c 534d6930 69497734     Vyc2lvbj0iMS4wIi
   2a920:	47647a42 475a7546 32627346 53506c35     BzdGFuZGFsb25lPS
   2a930:	7962754a 6a502f49 534c6877 32526730     JubyI/PjwhLS0gR2
   2a940:	585a7556 4764684a 694f7939 6d634842     VuZXJhdG9yOiBHcm
   2a950:	58613246 57617551 534c6738 48502b30     F2aXQuaW8gLS0+PH
   2a960:	795a324e 57623442 7a637578 48616930     N2ZyB4bWxucz0iaH
   2a970:	44633052 334c766f 79643364 794d3335     R0cDovL3d3dy53My
   2a980:	6d637635 6a4d7663 434d7741 6d647a39     5vcmcvMjAwMC9zdm
   2a990:	48496963 47627468 6e4f7a35 57617368     ciIHhtbG5zOnhsaW
   2a9a0:	53507235 48646f4a 694f7752 33647638     5rPSJodHRwOi8vd3
   2a9b0:	6e4c3364 6d4c7a63 795a7939 544f7838     d3LnczLm9yZy8xOT
   2a9c0:	334c356b 57617368 69497235 48647a42     k5L3hsaW5rIiBzdH
   2a9d0:	545a736c 58616930 4762764e 57613046     lsZT0iaXNvbGF0aW
   2a9e0:	6d4f7539 32627a6c 47646878 48496955     9uOmlzb2xhdGUiIH
   2a9f0:	585a705a 33624364 6a493967 434d6741     ZpZXdCb3g9IjAgMC
   2aa00:	544e7941 7a4d6741 69497741 57613342     AyNTAgMzAwIiB3aW
   2aa10:	44613052 544d6930 69497741 575a6f42     R0aD0iMTAwIiBoZW
   2aa20:	48616e6c 6a493951 434d7945 47502b49     lnaHQ9IjEyMCI+PG
   2aa30:	6e5a6c52 47502b4d 5861734e 58595142     RlZnM+PGNsaXBQYX
   2aa40:	47496f52 53506b6c 3259664a 46637078     RoIGlkPSJfY2xpcF
   2aa50:	47646842 47616668 30535a56 6b4e6e68     BhdGhfaGVZS0hnNk
   2aa60:	6b4d4839 6e556d31 6a656c4e 57597564     9HMk1mUnNlejduYW
   2aa70:	6c4e4d74 55515752 545a796f 6b53364a     tMNlRWQUoyZTJ6Sk
   2aa80:	6a50694d 575a7978 4849304e 485a7064     MiPjxyZWN0IHdpZH
   2aa90:	53506f52 544e7949 47496941 57616c68     RoPSIyNTAiIGhlaW
   2aaa0:	44646f64 7a4d6930 69497741 43502b38     dodD0iMzAwIi8+PC
   2aab0:	47626a39 4755776c 44613046 324c3834     9jbGlwUGF0aD48L2
   2aac0:	6e5a6c52 47502b4d 32596763 43637078     RlZnM+PGcgY2xpcC
   2aad0:	58597731 53506f52 6d63314a 31496f77     1wYXRoPSJ1cmwoI1
   2aae0:	47626a39 4755776c 46613046 565a6f39     9jbGlwUGF0aF9oZV
   2aaf0:	47534c6c 30543263 57547963 3263535a     lLSGc2T0cyTWZSc2
   2ab00:	324e3656 30616835 46563277 6a53425a     V6N25ha0w2VFZBSj
   2ab10:	6e4d6c4a 79514b70 6a50696b 58597778     JlMnpKQykiPjxwYX
   2ab20:	47496f52 69493951 44494e42 6a4c7951     RoIGQ9IiBNIDQyLj
   2ab30:	694d7745 7a4e7841 544f7555 45497949     EwMiAxNzUuOTIyIE
   2ab40:	444e674d 6a4e754d 44493467 534e3245     MgNDMuNjg4IDE2NS
   2ab50:	434e3134 794e3041 444e7934 544d6751     41NCA0Ny4yNDQgMT
   2ab60:	6a4c3155 534e7a4d 694d3141 444e3434     U1LjMzNSA1Mi44ND
   2ab70:	544d674d 6a4c3151 794d3367 44494d42     MgMTQ1Ljg3MyBMID
   2ab80:	534e7945 444f7734 6a4d674d 7a4e754d     EyNS4wODMgMjMuNz
   2ab90:	4549326b 544d6777 6a4c336b 794d794d     k2IEwgMTk3LjMyMy
   2aba0:	444e7841 444f7555 45497a63 6a4d674d     AxNDUuODczIEMgMj
   2abb0:	6a4c3245 794d3067 7a4e7841 444f7567     E2Ljg0MyAxNzguOD
   2abc0:	44493455 534d7849 434e3134 6a4d7941     U4IDIxMS41NCAyMj
   2abd0:	444f7541 44493263 434e3445 7a4d3034     AuODc2IDE4NC40Mz
   2abe0:	6a4d6767 6a4c3351 434f336b 44494d42     ggMjQ3Ljk3OCBMID
   2abf0:	434e3445 7a4d3034 6a4d6767 6a4c3351     E4NC40MzggMjQ3Lj
   2ac00:	434f336b 44494442 534d3145 544e3234     k3OCBDIDE1MS42NT
   2ac10:	6a4d6767 6a4c7767 534f3163 434f3541     ggMjgwLjc1OSA5OC
   2ac20:	534d3134 444f7941 7a4e7541 44493555     41MSAyODAuNzU5ID
   2ac30:	6a4c3159 434f7963 444e7941 544f7563     Y1LjcyOCAyNDcuOT
   2ac40:	45493463 6a4e6777 7a4e7555 44493449     c4IEwgNjUuNzI4ID
   2ac50:	794e3049 7a4e3534 79516767 694e3041     I0Ny45NzggQyA0Ni
   2ac60:	44493034 434f7949 534e3234 434f7a41     40IDIyOC42NSAzOC
   2ac70:	694e7834 444d7941 7a4e7545 4449324d     4xNiAyMDEuNzM2ID
   2ac80:	6a4c7951 694d7745 7a4e7841 544f7555     QyLjEwMiAxNzUuOT
   2ac90:	69497949 57616d42 53507378 325a794a     IyIiBmaWxsPSJyZ2
   2aca0:	444e6f49 544d734d 444c3159 794e3049     IoNDMsMTY1LDI0Ny
   2acb0:	7a4c696b 47633834 43613046 53506b42     kiLz48cGF0aCBkPS
   2acc0:	53546749 444d7941 544f7555 44497845     IgTSAyMDUuOTExID
   2acd0:	694d3045 444f3134 43546751 7a4d7841     E0Mi41ODQgTCAxMz
   2ace0:	6a4e754d 6a4d6763 544e7541 45493341     MuNjcgMjAuNTA3IE
   2acf0:	544d674d 6a4c784d 694e3167 794e7841     MgMTMxLjg1NiAxNy
   2ad00:	444e3034 544d674d 6a4c3449 534d3255     40NDMgMTI4LjU2MS
   2ad10:	534e7841 6a4e3134 544d6751 44493149     AxNS41NjQgMTI1ID
   2ad20:	6a4c3145 434e3255 44494442 534d7945     E1LjU2NCBDIDEyMS
   2ad30:	7a4d3034 544d676b 544e7555 44493059     40MzkgMTUuNTY0ID
   2ad40:	434f7845 444e7834 544d6755 444e7563     ExOC4xNDUgMTcuND
   2ad50:	44497a51 694e7845 794d7a34 434d7941     QzIDExNi4zMyAyMC
   2ad60:	444d3134 43546767 434e3041 534f7734     41MDggTCA0NC4wOS
   2ad70:	444e7841 544e7549 45493167 6a4d674d     AxNDIuNTg1IEMgMj
   2ad80:	6a4d7549 44493345 534f3345 444e3134     IuMjE3IDE3OS41ND
   2ad90:	6a4d6767 544d7567 44497855 694e7949     ggMjguMTUxIDIyNi
   2ada0:	7a4e3134 544e6751 544e7567 44497949     41NzQgNTguNTIyID
   2adb0:	694e3149 444e3534 7951674d 694e3341     I1Ni45NDMgQyA3Ni
   2adc0:	534e3434 7a4e7941 6a4d7555 44497863     44NSAyNzUuMjcxID
   2add0:	434d7745 6a4d3534 6a4d6759 6a4c3067     EwMC45MjYgMjg0Lj
   2ade0:	694e7a51 6a4d7841 6a4d6755 6a4c3067     QzNiAxMjUgMjg0Lj
   2adf0:	694e7a51 44494442 534f3045 7a4e7734     QzNiBDIDE0OS4wNz
   2ae00:	6a4d6759 6a4c3067 694e7a51 7a4e7841     YgMjg0LjQzNiAxNz
   2ae10:	544d754d 44497855 534e3349 7a4e7934     MuMTUxIDI3NS4yNz
   2ae20:	544d6749 6a4c786b 44493451 694e3149     IgMTkxLjQ4IDI1Ni
   2ae30:	444e3534 7951674d 6a4d7941 444f7545     45NDMgQyAyMjEuOD
   2ae40:	44493451 694e7949 7a4e3134 6a4d674d     Q4IDIyNi41NzMgMj
   2ae50:	6a4c3349 694d3463 7a4e7841 544e756b     I3Ljc4MiAxNzkuNT
   2ae60:	44493351 534e7749 544d3534 544d6745     Q3IDIwNS45MTEgMT
   2ae70:	6a4c7951 434e3455 43496142 44494e42     QyLjU4NCBaICBNID
   2ae80:	794e3345 7a4d7934 6a4d674d 6a4c7951     E3Ny4yMzMgMjQyLj
   2ae90:	694e3559 44494442 794d3245 444f7934     Y5NiBDIDE2My4yOD
   2aea0:	6a4d6745 6a4c3255 434f3059 444e7841     EgMjU2LjY0OCAxND
   2aeb0:	7a4e7551 4449794d 434e3249 7a4d7a34     QuNzMyIDI2NC4zMz
   2aec0:	544d6745 44493149 434e3249 7a4d7a34     EgMTI1IDI2NC4zMz
   2aed0:	79516745 444d7841 6a4d7555 44493559     EgQyAxMDUuMjY5ID
   2aee0:	434e3249 7a4d7a34 444f6745 7a4e7559     I2NC4zMzEgODYuNz
   2aef0:	44493545 694e3149 444e3234 7a4e6763     E5IDI1Ni42NDcgNz
   2af00:	7a4e7549 44493359 694d3049 544f3234     IuNzY3IDI0Mi42OT
   2af10:	79516759 434f3041 444d3534 6a4d6755     YgQyA0OC45MDUgMj
   2af20:	6a4c3445 434e7a67 434e3041 444e7934     E4LjgzNCA0NC4yND
   2af30:	544d674d 6a4c7867 694e3467 534d3241     MgMTgxLjg4NiA2MS
   2af40:	6a4d3034 544d6767 6a4c7955 434e3067     40MjggMTUyLjg0NC
   2af50:	44494d42 534e7945 534e3041 544d3034     BMIDEyNSA0NS40MT
   2af60:	43546763 444f7841 544e7567 44497963     cgTCAxODguNTcyID
   2af70:	694d3145 444e3434 79516751 444d7941     E1Mi44NDQgQyAyMD
   2af80:	7a4e7555 44493455 534d3445 444f3434     UuNzU4IDE4MS44OD
   2af90:	6a4d6763 6a4c7841 434e3541 544d7941     cgMjAxLjA5NCAyMT
   2afa0:	444f7567 4449314d 794e3345 7a4d7934     guODM1IDE3Ny4yMz
   2afb0:	6a4d674d 6a4c7951 694e3559 43496142     MgMjQyLjY5NiBaIC
   2afc0:	6d5a6749 4362736c 57647931 53506c78     IgZmlsbC1ydWxlPS
   2afd0:	6d646c4a 32627556 69496b52 57616d42     JldmVub2RkIiBmaW
   2afe0:	53507378 325a794a 544e6f49 544e7345     xsPSJyZ2IoNTEsNT
   2aff0:	544e7345 69497045 43502b38 6a506e39     EsNTEpIi8+PC9nPj
   2b000:	33637677 67506e5a 29223d3d 2d6f6e20     wvc3ZnPg==") no-
   2b010:	65706572 0d3b7461 0a0d7d0a 72230a0d     repeat;..}....#r
   2b020:	2d6e6961 676f7270 73736572 0a0d7b20     ain-progress {..
   2b030:	20202020 67696568 203a7468 70303231         height: 120p
   2b040:	0a0d3b78 20202020 74646977 31203a68     x;..    width: 1
   2b050:	78703030 7d0a0d3b 0a0d0a0d 69617223     00px;..}....#rai
   2b060:	61622d6e 0d7b2072 2020200a 69656820     n-bar {..    hei
   2b070:	3a746867 30303120 0a0d3b25 20202020     ght: 100%;..    
   2b080:	6b636162 756f7267 692d646e 6567616d     background-image
   2b090:	7275203a 6422286c 3a617461 67616d69     : url("data:imag
   2b0a0:	76732f65 6d782b67 61623b6c 34366573     e/svg+xml;base64
   2b0b0:	3944502c 77576234 566d6467 6c326379     ,PD94bWwgdmVyc2l
   2b0c0:	306a6276 34534d69 42694977 4647647a     vbj0iMS4wIiBzdGF
   2b0d0:	46475a75 35326273 4a53506c 49796275     uZGFsb25lPSJubyI
   2b0e0:	776a502f 30534c68 56325267 4a585a75     /PjwhLS0gR2VuZXJ
   2b0f0:	39476468 42694f79 466d6348 51586132     hdG9yOiBHcmF2aXQ
   2b100:	38576175 30534c67 4e48502b 42795a32     uaW8gLS0+PHN2ZyB
   2b110:	78576234 307a6375 52486169 6f446330     4bWxucz0iaHR0cDo
   2b120:	64334c76 35796433 35794d33 636d6376     vL3d3dy53My5vcmc
   2b130:	416a4d76 39434d77 636d647a 68484969     vMjAwMC9zdmciIHh
   2b140:	35476274 686e4f7a 35576173 4a535072     tbG5zOnhsaW5rPSJ
   2b150:	5248646f 38694f77 64336476 636e4c33     odHRwOi8vd3d3Lnc
   2b160:	396d4c7a 38795a79 6b544f78 68334c35     zLm9yZy8xOTk5L3h
   2b170:	35576173 42694972 6c48647a 30545a73     saW5rIiBzdHlsZT0
   2b180:	4e586169 46476276 39576130 6c6d4f75     iaXNvbGF0aW9uOml
   2b190:	7832627a 55476468 5a484969 64585a70     zb2xhdGUiIHZpZXd
   2b1a0:	67336243 416a4939 41434d67 41544e79     Cb3g9IjAgMCAyNTA
   2b1b0:	417a4d67 42694977 52576133 30446130     gMzAwIiB3aWR0aD0
   2b1c0:	41544d69 42694977 6c575a6f 5148616e     iMTAwIiBoZWlnaHQ
   2b1d0:	456a4939 49434d79 5247502b 4d6e5a6c     9IjEyMCI+PGRlZnM
   2b1e0:	4e47502b 42586173 52585951 6c47496f     +PGNsaXBQYXRoIGl
   2b1f0:	4a53506b 78325966 42466370 68476468     kPSJfY2xpcFBhdGh
   2b200:	4a546366 5a484d53 526c597a 5a574e55     fcTJSMHZzYlRUNWZ
   2b210:	73555950 46476478 68584e34 70574d6b     PYUsxdGF4NXhkMWp
   2b220:	64566436 42566254 30555170 786a5069     6dVdTbVBpQU0iPjx
   2b230:	4e575a79 64484930 52485a70 4953506f     yZWN0IHdpZHRoPSI
   2b240:	41544e79 68474969 6457616c 3044646f     yNTAiIGhlaWdodD0
   2b250:	417a4d69 38694977 3943502b 6c47626a     iMzAwIi8+PC9jbGl
   2b260:	46475577 34446130 52324c38 4d6e5a6c     wUGF0aD48L2RlZnM
   2b270:	6347502b 78325967 31436370 52585977     +PGcgY2xpcC1wYXR
   2b280:	4a53506f 776d6331 3931496f 6c47626a     oPSJ1cmwoI19jbGl
   2b290:	46475577 39466130 496c4d78 4e6e6477     wUGF0aF9xMlIwdnN
   2b2a0:	51465669 396b5a31 467a5368 67585930     iVFQ1Zk9hSzF0YXg
   2b2b0:	51476531 706e6178 4e315631 6c475574     1eGQxanp1V1NtUGl
   2b2c0:	6b535442 786a5069 52585977 5147496f     BTSkiPjxwYXRoIGQ
   2b2d0:	42694939 4944494e 34534e77 45544d35     9IiBNIDIwNS45MTE
   2b2e0:	51544d67 556a4c79 42434e34 4544494d     gMTQyLjU4NCBMIDE
   2b2f0:	34794d7a 41794e32 34434d79 63444d31     zMy42NyAyMC41MDc
   2b300:	41795167 457a4d78 55444f75 45444932     gQyAxMzEuODU2IDE
   2b310:	516a4c33 41794d30 676a4d78 59544e75     3LjQ0MyAxMjguNTY
   2b320:	45444978 556a4c31 41434e32 556a4d78     xIDE1LjU2NCAxMjU
   2b330:	55544d67 59544e75 4d454930 49544d67     gMTUuNTY0IEMgMTI
   2b340:	516a4c78 41534f7a 34534e78 516a4e31     xLjQzOSAxNS41NjQ
   2b350:	45544d67 456a4c34 41534e30 34794e78     gMTE4LjE0NSAxNy4
   2b360:	4d444e30 45544d67 4d6a4c32 4944497a     0NDMgMTE2LjMzIDI
   2b370:	556a4c77 42434f77 5144494d 416a4c30     wLjUwOCBMIDQ0LjA
   2b380:	45444935 34694d30 55444f31 41795167     5IDE0Mi41ODUgQyA
   2b390:	34694d79 63544d79 63544d67 556a4c35     yMi4yMTcgMTc5LjU
   2b3a0:	41434f30 34434f79 45544e78 496a4d67     0OCAyOC4xNTEgMjI
   2b3b0:	556a4c32 41434e33 34434f31 496a4d31     2LjU3NCA1OC41MjI
   2b3c0:	556a4d67 6b6a4c32 42794d30 63444944     gMjU2Ljk0MyBDIDc
   2b3d0:	676a4c32 49444931 34534e33 457a4e79     2Ljg1IDI3NS4yNzE
   2b3e0:	41544d67 6b6a4c77 41694e79 51444f79     gMTAwLjkyNiAyODQ
   2b3f0:	4d444e75 45444932 41534e79 51444f79     uNDM2IDEyNSAyODQ
   2b400:	4d444e75 4d454932 51544d67 416a4c35     uNDM2IEMgMTQ5LjA
   2b410:	41694e33 51444f79 4d444e75 45444932     3NiAyODQuNDM2IDE
   2b420:	34794d33 45544e78 636a4d67 496a4c31     3My4xNTEgMjc1LjI
   2b430:	41694d33 45544f78 67444e75 556a4d67     3MiAxOTEuNDggMjU
   2b440:	6b6a4c32 42794d30 49444944 34534d79     2Ljk0MyBDIDIyMS4
   2b450:	67444e34 496a4d67 556a4c32 41794d33     4NDggMjI2LjU3MyA
   2b460:	636a4d79 677a4e75 45444979 34534f33     yMjcuNzgyIDE3OS4
   2b470:	63444e31 416a4d67 6b6a4c31 41534d78     1NDcgMjA1LjkxMSA
   2b480:	49444e78 67544e75 6f464930 30454967     xNDIuNTg0IFogIE0
   2b490:	63544d67 496a4c33 41794d7a 49444e79     gMTc3LjIzMyAyNDI
   2b4a0:	6b6a4e75 4d454932 59544d67 496a4c7a     uNjk2IEMgMTYzLjI
   2b4b0:	41534d34 59544e79 516a4e75 45444934     4MSAyNTYuNjQ4IDE
   2b4c0:	34434e30 497a4d33 596a4d67 4d6a4c30     0NC43MzIgMjY0LjM
   2b4d0:	41534d7a 556a4d78 596a4d67 4d6a4c30     zMSAxMjUgMjY0LjM
   2b4e0:	42534d7a 45444944 34534e77 6b6a4e79     zMSBDIDEwNS4yNjk
   2b4f0:	596a4d67 4d6a4c30 41534d7a 34694e34     gMjY0LjMzMSA4Ni4
   2b500:	6b544d33 556a4d67 596a4c32 41794e30     3MTkgMjU2LjY0NyA
   2b510:	34694d33 636a4e33 516a4d67 596a4c79     3Mi43NjcgMjQyLjY
   2b520:	42694e35 51444944 6b6a4c34 41534e77     5NiBDIDQ4LjkwNSA
   2b530:	67544d79 4d444f75 51444930 496a4c30     yMTguODM0IDQ0LjI
   2b540:	41794d30 45444f78 67444f75 59444932     0MyAxODEuODg2IDY
   2b550:	516a4c78 41434f79 49544e78 51444f75     xLjQyOCAxNTIuODQ
   2b560:	77454930 49544d67 51444931 516a4c31     0IEwgMTI1IDQ1LjQ
   2b570:	42794e78 4544494d 34434f34 497a4e31     xNyBMIDE4OC41NzI
   2b580:	55544d67 676a4c79 42434e30 49444944     gMTUyLjg0NCBDIDI
   2b590:	34534e77 67544e33 67544d67 676a4c78     wNS43NTggMTgxLjg
   2b5a0:	41794e34 45444d79 6b444d75 49444930     4NyAyMDEuMDk0IDI
   2b5b0:	34434f78 557a4d34 63544d67 496a4c33     xOC44MzUgMTc3LjI
   2b5c0:	41794d7a 49444e79 6b6a4e75 6f464932     zMyAyNDIuNjk2IFo
   2b5d0:	42694967 7857616d 4a584c73 55476231     gIiBmaWxsLXJ1bGU
   2b5e0:	566d4939 35575a32 51475a76 5a474969     9ImV2ZW5vZGQiIGZ
   2b5f0:	77476270 4a6e4939 6769596e 77534d31     pbGw9InJnYig1MSw
   2b600:	77534d31 6b534d31 347a4c69 63324c38     1MSw1MSkiLz48L2c
   2b610:	3943502b 636d647a 3b29222b 20200a0d     +PC9zdmc+");..  
   2b620:	61622020 72676b63 646e756f 6c6f632d       background-col
   2b630:	203a726f 74696877 0a0d3b65 0d0a0d7d     or: white;..}...
   2b640:	6172230a 65526e69 6e696461 0d7b2067     .#rainReading {.
   2b650:	2020200a 64617020 676e6964 66656c2d     .    padding-lef
   2b660:	33203a74 3b787033 20200a0d 61702020     t: 33px;..    pa
   2b670:	6e696464 6f742d67 31203a70 3b787035     dding-top: 15px;
   2b680:	20200a0d 6f632020 3a726f6c 62322320     ..    color: #2b
   2b690:	66663437 200a0d3b 66202020 2d746e6f     74ff;..    font-
   2b6a0:	657a6973 3032203a 0d3b7870 2020200a     size: 20px;..   
   2b6b0:	6e6f6620 74732d74 3a656c79 61746920      font-style: ita
   2b6c0:	3b63696c 0d7d0a0d 230a0d0a 2d6e7573     lic;..}....#sun-
   2b6d0:	6b636162 756f7267 7b20646e 20200a0d     background {..  
   2b6e0:	616d2020 6e696772 706f742d 3034203a       margin-top: 40
   2b6f0:	0d3b7870 2020200a 736f7020 6f697469     px;..    positio
   2b700:	72203a6e 74616c65 3b657669 20200a0d     n: relative;..  
   2b710:	65682020 74686769 3131203a 3b787030       height: 110px;
   2b720:	20200a0d 69772020 3a687464 30313120     ..    width: 110
   2b730:	0d3b7870 2020200a 63616220 6f72676b     px;..    backgro
   2b740:	3a646e75 6c727520 61642228 693a6174     und: url("data:i
   2b750:	6567616d 6776732f 6c6d782b 7361623b     mage/svg+xml;bas
   2b760:	2c343665 34394450 67775762 79566d64     e64,PD94bWwgdmVy
   2b770:	766c3263 69306a62 7734534d 7a426949     c2lvbj0iMS4wIiBz
   2b780:	75464764 7346475a 6c353262 754a5350     dGFuZGFsb25lPSJu
   2b790:	2f497962 68776a50 6730534c 75563252     byI/PjwhLS0gR2Vu
   2b7a0:	684a585a 79394764 4842694f 32466d63     ZXJhdG9yOiBHcmF2
   2b7b0:	75515861 67385761 2b30534c 324e4850     aXQuaW8gLS0+PHN2
   2b7c0:	3442795a 75785762 69307a63 30524861     ZyB4bWxucz0iaHR0
   2b7d0:	766f4463 3364334c 33357964 7635794d     cDovL3d3dy53My5v
   2b7e0:	76636d63 77416a4d 7a39434d 69636d64     cmcvMjAwMC9zdmci
   2b7f0:	74684849 7a354762 73686e4f 72355761     IHhtbG5zOnhsaW5r
   2b800:	6f4a5350 77524864 7638694f 33643364     PSJodHRwOi8vd3d3
   2b810:	7a636e4c 79396d4c 7838795a 356b544f     LnczLm9yZy8xOTk5
   2b820:	7368334c 72355761 7a426949 736c4864     L3hsaW5rIiBzdHls
   2b830:	6930545a 764e5861 30464762 75395761     ZT0iaXNvbGF0aW9u
   2b840:	7a6c6d4f 68783262 69554764 705a4849     Omlzb2xhdGUiIHZp
   2b850:	4364585a 39673362 67416a49 7841434d     ZXdCb3g9IjAgMCAx
   2b860:	6741544d 7745544d 33426949 30525761     MTAgMTEwIiB3aWR0
   2b870:	69304461 7745544d 6f426949 6e6c575a     aD0iMTEwIiBoZWln
   2b880:	39514861 78456a49 2b49434d 6c524750     aHQ9IjExMCI+PGRl
   2b890:	2b4d6e5a 734e4750 51425861 6f525859     ZnM+PGNsaXBQYXRo
   2b8a0:	6b6c4749 664a5350 70783259 68424663     IGlkPSJfY2xpcFBh
   2b8b0:	66684764 7646565a 6e5a324d 4c426a64     dGhfZVFvM2ZndjBL
   2b8c0:	364e3061 4d686e56 784d6a54 544a554e     a0N6VnhMTjMxNUJT
   2b8d0:	6b4a4552 72684753 3146555a 69305552     REJkSGhrZUF1RU0i
   2b8e0:	79786a50 304e575a 70644849 6f52485a     PjxyZWN0IHdpZHRo
   2b8f0:	78495350 6941544d 6c684749 6f645761     PSIxMTAiIGhlaWdo
   2b900:	69304464 7745544d 2b386949 6a394350     dD0iMTEwIi8+PC9j
   2b910:	776c4762 30464755 38344461 6c52324c     bGlwUGF0aD48L2Rl
   2b920:	2b4d6e5a 67634750 70783259 77314363     ZnM+PGcgY2xpcC1w
   2b930:	6f525859 314a5350 6f776d63 6a393149     YXRoPSJ1cmwoI19j
   2b940:	776c4762 30464755 6c394661 7a385755     bGlwUGF0aF9lUW8z
   2b950:	32646d5a 7274454d 57703351 4f784565     Zmd2MEtrQ3pWeExO
   2b960:	31457a4d 454e6c51 49526d51 6c744761     MzE1QlNEQmRIaGtl
   2b970:	46565851 696b5354 6e786a50 6c786a50     QXVFTSkiPjxnPjxl
   2b980:	70784762 6c4e4863 6c5a4849 76523359     bGxpcHNlIHZlY3Rv
   2b990:	6c316963 6c5a6d5a 39513359 76356d49     ci1lZmZlY3Q9Im5v
   2b9a0:	7a316962 73463259 6e355761 304e584c     bi1zY2FsaW5nLXN0
   2b9b0:	72396d63 6749535a 39673359 30556a49     cm9rZSIgY3g9IjU0
   2b9c0:	776b6a4c 3567444f 3051444f 7763444d     LjkwODg5ODQ0MDcw
   2b9d0:	784d6a4e 6a426949 69305465 7551544e     NjMxIiBjeT0iNTQu
   2b9e0:	356b544f 356b544f 356b544f 356b544f     OTk5OTk5OTk5OTk5
   2b9f0:	6963544f 344a4849 79495350 7734534e     OTciIHJ4PSIyNS4w
   2ba00:	3159544e 354d7a4e 79457a4d 7a45444e     NTY1NzM5MzEyNDEz
   2ba10:	69676a4d 354a4849 79495350 3234534e     MjgiIHJ5PSIyNS42
   2ba20:	3167444e 3159444e 35417a4e 35556a4d     NDg1NDY1NzA5MjU5
   2ba30:	6749794d 736c6d5a 69304462 69646d63     MyIgZmlsbD0icmdi
   2ba40:	3149444b 7977534e 7355544e 696b434d     KDI1NSwyNTUsMCki
   2ba50:	304e4849 72396d63 3331535a 30525761     IHN0cm9rZS13aWR0
   2ba60:	69304461 6749794d 79523363 6c743262     aD0iMyIgc3Ryb2tl
   2ba70:	794a5350 6f49325a 7777434d 7041444c     PSJyZ2IoMCwwLDAp
   2ba80:	7a426949 764a4864 74553261 756c4762     IiBzdHJva2UtbGlu
   2ba90:	7670575a 39345761 70316d49 79564764     ZWpvaW49Im1pdGVy
   2baa0:	7a426949 764a4864 74553261 756c4762     IiBzdHJva2UtbGlu
   2bab0:	684e575a 69304463 31463363 6c4a5859     ZWNhcD0ic3F1YXJl
   2bac0:	7a426949 764a4864 74553261 306c5762     IiBzdHJva2UtbWl0
   2bad0:	734a585a 70315761 69304464 7649794d     ZXJsaW1pdD0iMyIv
   2bae0:	77786a50 35783262 7539325a 76424849     Pjxwb2x5Z29uIHBv
   2baf0:	30355761 69307a63 75496a4e 3349544f     aW50cz0iNjIuOTI3
   2bb00:	7a49444c 32516a4c 3077794e 3434694e     LDIzLjQ2Nyw0Ni44
   2bb10:	7345544f 754d6a4d 344d6a4d 3155444c     OTEsMjMuMjM4LDU1
   2bb20:	31416a4c 3177534f 6d426949 73785761     LjA1OSw1IiBmaWxs
   2bb30:	794a5350 6f49325a 31556a4d 3545444c     PSJyZ2IoMjU1LDE5
   2bb40:	7a77534f 696b434d 6c5a4849 76523359     OSwzMCkiIHZlY3Rv
   2bb50:	6c316963 6c5a6d5a 39513359 76356d49     ci1lZmZlY3Q9Im5v
   2bb60:	7a316962 73463259 6e355761 304e584c     bi1zY2FsaW5nLXN0
   2bb70:	72396d63 6749535a 79523363 6c743262     cm9rZSIgc3Ryb2tl
   2bb80:	7064584c 6f52485a 7a495350 7a426949     LXdpZHRoPSIzIiBz
   2bb90:	764a4864 39553261 6e4a6e49 77676959     dHJva2U9InJnYigw
   2bba0:	7341444c 696b434d 304e4849 72396d63     LDAsMCkiIHN0cm9r
   2bbb0:	7331535a 6c355761 70396d61 69306a62     ZS1saW5lam9pbj0i
   2bbc0:	306c5762 6949585a 304e4849 72396d63     bWl0ZXIiIHN0cm9r
   2bbd0:	7331535a 6c355761 77463259 7a4a5350     ZS1saW5lY2FwPSJz
   2bbe0:	68565863 69556d63 304e4849 72396d63     cXVhcmUiIHN0cm9r
   2bbf0:	7431535a 6c525861 70786d63 306c5762     ZS1taXRlcmxpbWl0
   2bc00:	7a495350 2b386949 76424850 6e6c4862     PSIzIi8+PHBvbHln
   2bc10:	67343262 70394763 7a526e62 34495350     b24gcG9pbnRzPSI4
   2bc20:	3534694e 736b544e 754d6a4e 34416a4d     Ni45NTksNjMuMjA4
   2bc30:	3367444c 34456a4c 3077794d 3334694e     LDg3LjE4Myw0Ni43
   2bc40:	7349544f 3141544d 3155444c 31456a4c     OTIsMTA1LDU1LjE1
   2bc50:	6749794d 736c6d5a 69304462 69646d63     MyIgZmlsbD0icmdi
   2bc60:	3149444b 7877534e 736b544f 70417a4d     KDI1NSwxOTksMzAp
   2bc70:	32426949 304e575a 74493362 6d5a575a     IiB2ZWN0b3ItZWZm
   2bc80:	304e575a 754a5350 74343262 684e3263     ZWN0PSJub24tc2Nh
   2bc90:	756c4762 7a31795a 764a4864 69553261     bGluZy1zdHJva2Ui
   2bca0:	304e4849 72396d63 3331535a 30525761     IHN0cm9rZS13aWR0
   2bcb0:	69304461 6749794d 79523363 6c743262     aD0iMyIgc3Ryb2tl
   2bcc0:	794a5350 6f49325a 7777434d 7041444c     PSJyZ2IoMCwwLDAp
   2bcd0:	7a426949 764a4864 74553261 756c4762     IiBzdHJva2UtbGlu
   2bce0:	7670575a 39345761 70316d49 79564764     ZWpvaW49Im1pdGVy
   2bcf0:	7a426949 764a4864 74553261 756c4762     IiBzdHJva2UtbGlu
   2bd00:	684e575a 69304463 31463363 6c4a5859     ZWNhcD0ic3F1YXJl
   2bd10:	7a426949 764a4864 74553261 306c5762     IiBzdHJva2UtbWl0
   2bd20:	734a585a 70315761 69304464 7649794d     ZXJsaW1pdD0iMyIv
   2bd30:	77786a50 35783262 7539325a 76424849     Pjxwb2x5Z29uIHBv
   2bd40:	30355761 69307a63 754d444f 7a597a4d     aW50cz0iODMuMzYz
   2bd50:	344d444c 79636a4c 3377434f 7834694d     LDM4LjcyOCw3Mi4x
   2bd60:	7345444f 75596a4d 3555544f 776b444c     ODEsMjYuOTU5LDkw
   2bd70:	31556a4c 7877694e 3534534f 69557a4e     LjU1NiwxOS45NzUi
   2bd80:	705a4749 39774762 6e4a6e49 79676959     IGZpbGw9InJnYigy
   2bd90:	7355544e 356b544d 774d444c 6749534b     NTUsMTk5LDMwKSIg
   2bda0:	6a566d64 79394764 6d56574c 6a566d5a     dmVjdG9yLWVmZmVj
   2bdb0:	69304464 75396d62 6a4e584c 70785759     dD0ibm9uLXNjYWxp
   2bdc0:	74636d62 79523363 6c743262 7a426949     bmctc3Ryb2tlIiBz
   2bdd0:	764a4864 74553261 6b6c3264 39674764     dHJva2Utd2lkdGg9
   2bde0:	694d6a49 304e4849 72396d63 6930545a     IjMiIHN0cm9rZT0i
   2bdf0:	69646d63 7341444b 7777434d 6749534b     cmdiKDAsMCwwKSIg
   2be00:	79523363 6c743262 7078574c 71566d62     c3Ryb2tlLWxpbmVq
   2be10:	756c3262 744a5350 6c525861 67496963     b2luPSJtaXRlciIg
   2be20:	79523363 6c743262 7078574c 6a566d62     c3Ryb2tlLWxpbmVj
   2be30:	39415859 784e6e49 79465764 6749535a     YXA9InNxdWFyZSIg
   2be40:	79523363 6c743262 7031574c 79564764     c3Ryb2tlLW1pdGVy
   2be50:	746c4762 39515861 694d6a49 38347a4c     bGltaXQ9IjMiLz48
   2be60:	73394763 76645765 77426962 756c3262     cG9seWdvbiBwb2lu
   2be70:	394d4864 334d6a49 78416a4c 7977434f     dHM9IjM3LjAxOCwy
   2be80:	7a34794e 73677a4d 75556a4d 7849544e     Ny4zMzgsMjUuNTIx
   2be90:	344d444c 34636a4c 7877794d 3234434f     LDM4Ljc4MywxOC42
   2bea0:	7367544f 756b544d 3163544f 6d426949     OTgsMTkuOTc1IiBm
   2beb0:	73785761 794a5350 6f49325a 31556a4d     aWxsPSJyZ2IoMjU1
   2bec0:	3545444c 7a77534f 696b434d 6c5a4849     LDE5OSwzMCkiIHZl
   2bed0:	76523359 6c316963 6c5a6d5a 39513359     Y3Rvci1lZmZlY3Q9
   2bee0:	76356d49 7a316962 73463259 6e355761     Im5vbi1zY2FsaW5n
   2bef0:	304e584c 72396d63 6749535a 79523363     LXN0cm9rZSIgc3Ry
   2bf00:	6c743262 7064584c 6f52485a 7a495350     b2tlLXdpZHRoPSIz
   2bf10:	7a426949 764a4864 39553261 6e4a6e49     IiBzdHJva2U9InJn
   2bf20:	77676959 7341444c 696b434d 304e4849     YigwLDAsMCkiIHN0
   2bf30:	72396d63 7331535a 6c355761 70396d61     cm9rZS1saW5lam9p
   2bf40:	69306a62 306c5762 6949585a 304e4849     bj0ibWl0ZXIiIHN0
   2bf50:	72396d63 7331535a 6c355761 77463259     cm9rZS1saW5lY2Fw
   2bf60:	7a4a5350 68565863 69556d63 304e4849     PSJzcXVhcmUiIHN0
   2bf70:	72396d63 7431535a 6c525861 70786d63     cm9rZS1taXRlcmxp
   2bf80:	306c5762 7a495350 2b386949 76424850     bWl0PSIzIi8+PHBv
   2bf90:	6e6c4862 67343262 70394763 7a526e62     bHlnb24gcG9pbnRz
   2bfa0:	33495350 3434434d 7355444d 7551444f     PSI3MC44MDUsODQu
   2bfb0:	3249544d 7967444c 774d6a4c 3377794d     MTI2LDgyLjMwMyw3
   2bfc0:	3234694d 7345444f 756b444f 3249544d     Mi42ODEsODkuMTI2
   2bfd0:	786b444c 34516a4c 6749534f 736c6d5a     LDkxLjQ4OSIgZmls
   2bfe0:	69304462 69646d63 3149444b 7877534e     bD0icmdiKDI1NSwx
   2bff0:	736b544f 70417a4d 32426949 304e575a     OTksMzApIiB2ZWN0
   2c000:	74493362 6d5a575a 304e575a 754a5350     b3ItZWZmZWN0PSJu
   2c010:	74343262 684e3263 756c4762 7a31795a     b24tc2NhbGluZy1z
   2c020:	764a4864 69553261 304e4849 72396d63     dHJva2UiIHN0cm9r
   2c030:	3331535a 30525761 69304461 6749794d     ZS13aWR0aD0iMyIg
   2c040:	79523363 6c743262 794a5350 6f49325a     c3Ryb2tlPSJyZ2Io
   2c050:	7777434d 7041444c 7a426949 764a4864     MCwwLDApIiBzdHJv
   2c060:	74553261 756c4762 7670575a 39345761     a2UtbGluZWpvaW49
   2c070:	70316d49 79564764 7a426949 764a4864     Im1pdGVyIiBzdHJv
   2c080:	74553261 756c4762 684e575a 69304463     a2UtbGluZWNhcD0i
   2c090:	31463363 6c4a5859 7a426949 764a4864     c3F1YXJlIiBzdHJv
   2c0a0:	74553261 306c5762 734a585a 70315761     a2UtbWl0ZXJsaW1p
   2c0b0:	69304464 7649794d 77786a50 35783262     dD0iMyIvPjxwb2x5
   2c0c0:	7539325a 76424849 30355761 69307a63     Z29uIHBvaW50cz0i
   2c0d0:	75636a4d 3455444f 7863444c 33496a4c     MjcuODU4LDcxLjI3
   2c0e0:	7a77694d 7734534f 3477434e 7734794d     MiwzOS4wNCw4My4w
   2c0f0:	7345444e 75416a4d 31596a4e 776b444c     NDEsMjAuNjY1LDkw
   2c100:	79416a4c 6749534e 736c6d5a 69304462     LjAyNSIgZmlsbD0i
   2c110:	69646d63 3149444b 7877534e 736b544f     cmdiKDI1NSwxOTks
   2c120:	70417a4d 32426949 304e575a 74493362     MzApIiB2ZWN0b3It
   2c130:	6d5a575a 304e575a 754a5350 74343262     ZWZmZWN0PSJub24t
   2c140:	684e3263 756c4762 7a31795a 764a4864     c2NhbGluZy1zdHJv
   2c150:	69553261 304e4849 72396d63 3331535a     a2UiIHN0cm9rZS13
   2c160:	30525761 69304461 6749794d 79523363     aWR0aD0iMyIgc3Ry
   2c170:	6c743262 794a5350 6f49325a 7777434d     b2tlPSJyZ2IoMCww
   2c180:	7041444c 7a426949 764a4864 74553261     LDApIiBzdHJva2Ut
   2c190:	756c4762 7670575a 39345761 70316d49     bGluZWpvaW49Im1p
   2c1a0:	79564764 7a426949 764a4864 74553261     dGVyIiBzdHJva2Ut
   2c1b0:	756c4762 684e575a 69304463 31463363     bGluZWNhcD0ic3F1
   2c1c0:	6c4a5859 7a426949 764a4864 74553261     YXJlIiBzdHJva2Ut
   2c1d0:	306c5762 734a585a 70315761 69304464     bWl0ZXJsaW1pdD0i
   2c1e0:	7649794d 77786a50 35783262 7539325a     MyIvPjxwb2x5Z29u
   2c1f0:	76424849 30355761 69307a63 754d6a4d     IHBvaW50cz0iMjMu
   2c200:	7851444d 3251444c 35636a4c 7977694d     MDQxLDQ2Ljc5Miwy
   2c210:	3434694d 7363544d 754d6a4e 34416a4d     Mi44MTcsNjMuMjA4
   2c220:	7355444c 7551544e 3351444f 6d426949     LDUsNTQuODQ3IiBm
   2c230:	73785761 794a5350 6f49325a 31556a4d     aWxsPSJyZ2IoMjU1
   2c240:	3545444c 7a77534f 696b434d 6c5a4849     LDE5OSwzMCkiIHZl
   2c250:	76523359 6c316963 6c5a6d5a 39513359     Y3Rvci1lZmZlY3Q9
   2c260:	76356d49 7a316962 73463259 6e355761     Im5vbi1zY2FsaW5n
   2c270:	304e584c 72396d63 6749535a 79523363     LXN0cm9rZSIgc3Ry
   2c280:	6c743262 7064584c 6f52485a 7a495350     b2tlLXdpZHRoPSIz
   2c290:	7a426949 764a4864 39553261 6e4a6e49     IiBzdHJva2U9InJn
   2c2a0:	77676959 7341444c 696b434d 304e4849     YigwLDAsMCkiIHN0
   2c2b0:	72396d63 7331535a 6c355761 70396d61     cm9rZS1saW5lam9p
   2c2c0:	69306a62 306c5762 6949585a 304e4849     bj0ibWl0ZXIiIHN0
   2c2d0:	72396d63 7331535a 6c355761 77463259     cm9rZS1saW5lY2Fw
   2c2e0:	7a4a5350 68565863 69556d63 304e4849     PSJzcXVhcmUiIHN0
   2c2f0:	72396d63 7431535a 6c525861 70786d63     cm9rZS1taXRlcmxp
   2c300:	306c5762 7a495350 2b386949 76424850     bWl0PSIzIi8+PHBv
   2c310:	6e6c4862 67343262 70394763 7a526e62     bHlnb24gcG9pbnRz
   2c320:	30495350 3434694e 7345544f 7559444f     PSI0Ni44OTEsODYu
   2c330:	7a4d544e 7959444c 796b6a4c 3477794e     NTMzLDYyLjkyNyw4
   2c340:	3334694e 73496a4e 7551544e 35557a4e     Ni43NjIsNTQuNzU5
   2c350:	7745444c 6749534e 736c6d5a 69304462     LDEwNSIgZmlsbD0i
   2c360:	69646d63 3149444b 7877534e 736b544f     cmdiKDI1NSwxOTks
   2c370:	70417a4d 32426949 304e575a 74493362     MzApIiB2ZWN0b3It
   2c380:	6d5a575a 304e575a 754a5350 74343262     ZWZmZWN0PSJub24t
   2c390:	684e3263 756c4762 7a31795a 764a4864     c2NhbGluZy1zdHJv
   2c3a0:	69553261 304e4849 72396d63 3331535a     a2UiIHN0cm9rZS13
   2c3b0:	30525761 69304461 6749794d 79523363     aWR0aD0iMyIgc3Ry
   2c3c0:	6c743262 794a5350 6f49325a 7777434d     b2tlPSJyZ2IoMCww
   2c3d0:	7041444c 7a426949 764a4864 74553261     LDApIiBzdHJva2Ut
   2c3e0:	756c4762 7670575a 39345761 70316d49     bGluZWpvaW49Im1p
   2c3f0:	79564764 7a426949 764a4864 74553261     dGVyIiBzdHJva2Ut
   2c400:	756c4762 684e575a 69304463 31463363     bGluZWNhcD0ic3F1
   2c410:	6c4a5859 7a426949 764a4864 74553261     YXJlIiBzdHJva2Ut
   2c420:	306c5762 734a585a 70315761 69304464     bWl0ZXJsaW1pdD0i
   2c430:	7649794d 76776a50 38347a5a 2b63324c     MyIvPjwvZz48L2c+
   2c440:	7a394350 2b636d64 6e202922 65722d6f     PC9zdmc+") no-re
   2c450:	74616570 7d0a0d3b 0a0d0a0d 6e757323     peat;..}....#sun
   2c460:	6f72702d 73657267 0d7b2073 2020200a     -progress {..   
   2c470:	69656820 3a746867 30313120 0d3b7870      height: 110px;.
   2c480:	2020200a 64697720 203a6874 70303131     .    width: 110p
   2c490:	0a0d3b78 0d0a0d7d 7573230a 61622d6e     x;..}....#sun-ba
   2c4a0:	0d7b2072 2020200a 69656820 3a746867     r {..    height:
   2c4b0:	30303120 0a0d3b25 20202020 6b636162      100%;..    back
   2c4c0:	756f7267 692d646e 6567616d 7275203a     ground-image: ur
   2c4d0:	6422286c 3a617461 67616d69 76732f65     l("data:image/sv
   2c4e0:	6d782b67 61623b6c 34366573 3944502c     g+xml;base64,PD9
   2c4f0:	77576234 566d6467 6c326379 306a6276     4bWwgdmVyc2lvbj0
   2c500:	34534d69 42694977 4647647a 46475a75     iMS4wIiBzdGFuZGF
   2c510:	35326273 4a53506c 49796275 776a502f     sb25lPSJubyI/Pjw
   2c520:	30534c68 56325267 4a585a75 39476468     hLS0gR2VuZXJhdG9
   2c530:	42694f79 466d6348 51586132 38576175     yOiBHcmF2aXQuaW8
   2c540:	30534c67 4e48502b 42795a32 78576234     gLS0+PHN2ZyB4bWx
   2c550:	307a6375 52486169 6f446330 64334c76     ucz0iaHR0cDovL3d
   2c560:	35796433 35794d33 636d6376 416a4d76     3dy53My5vcmcvMjA
   2c570:	39434d77 636d647a 68484969 35476274     wMC9zdmciIHhtbG5
   2c580:	686e4f7a 35576173 4a535072 5248646f     zOnhsaW5rPSJodHR
   2c590:	38694f77 64336476 636e4c33 396d4c7a     wOi8vd3d3LnczLm9
   2c5a0:	38795a79 6b544f78 68334c35 35576173     yZy8xOTk5L3hsaW5
   2c5b0:	42694972 6c48647a 30545a73 4e586169     rIiBzdHlsZT0iaXN
   2c5c0:	46476276 39576130 6c6d4f75 7832627a     vbGF0aW9uOmlzb2x
   2c5d0:	55476468 5a484969 64585a70 67336243     hdGUiIHZpZXdCb3g
   2c5e0:	416a4939 41434d67 41544d78 45544d67     9IjAgMCAxMTAgMTE
   2c5f0:	42694977 52576133 30446130 45544d69     wIiB3aWR0aD0iMTE
   2c600:	42694977 6c575a6f 5148616e 456a4939     wIiBoZWlnaHQ9IjE
   2c610:	49434d78 5247502b 4d6e5a6c 4e47502b     xMCI+PGRlZnM+PGN
   2c620:	42586173 52585951 6c47496f 4a53506b     saXBQYXRoIGlkPSJ
   2c630:	78325966 42466370 68476468 70565266     fY2xpcFBhdGhfRVp
   2c640:	776b5969 68336377 6c326274 68314e72     iYkwwc3htb2lrN1h
   2c650:	39306133 35455536 496a5253 59474e77     3a096UE5SRjIwNGY
   2c660:	566a4e7a 416e4e4f 786a5069 4e575a79     zNjVONnAiPjxyZWN
   2c670:	64484930 52485a70 4953506f 41544d78     0IHdpZHRoPSIxMTA
   2c680:	68474969 6457616c 3044646f 45544d69     iIGhlaWdodD0iMTE
   2c690:	38694977 3943502b 6c47626a 46475577     wIi8+PC9jbGlwUGF
   2c6a0:	34446130 52324c38 4d6e5a6c 6347502b     0aD48L2RlZnM+PGc
   2c6b0:	78325967 31436370 52585977 4a53506f     gY2xpcC1wYXRoPSJ
   2c6c0:	776d6331 3931496f 6c47626a 46475577     1cmwoI19jbGlwUGF
   2c6d0:	39466130 4a6d5746 42445469 3147657a     0aF9FWmJiTDBzeG1
   2c6e0:	73576176 64485733 70335472 4a6c5451     vaWs3WHdrT3pQTlJ
   2c6f0:	416a4d47 4d6a5a30 34554e32 6b436332     GMjA0ZjM2NU42cCk
   2c700:	786a5069 786a506e 7847626c 4e486370     iPjxnPjxlbGxpcHN
   2c710:	5a48496c 5233596c 31696376 5a6d5a6c     lIHZlY3Rvci1lZmZ
   2c720:	5133596c 356d4939 31696276 4632597a     lY3Q9Im5vbi1zY2F
   2c730:	35576173 4e584c6e 396d6330 49535a72     saW5nLXN0cm9rZSI
   2c740:	67335967 556a4939 6b6a4c30 67444f77     gY3g9IjU0LjkwODg
   2c750:	51444f35 63444d30 4d6a4e77 42694978     5ODQ0MDcwNjMxIiB
   2c760:	3054656a 51544e69 6b544f75 6b544f35     jeT0iNTQuOTk5OTk
   2c770:	6b544f35 6b544f35 63544f35 4a484969     5OTk5OTk5OTciIHJ
   2c780:	49535034 34534e79 59544e77 4d7a4e31     4PSIyNS4wNTY1NzM
   2c790:	457a4d35 45444e79 676a4d7a 4a484969     5MzEyNDEzMjgiIHJ
   2c7a0:	49535035 34534e79 67444e32 59444e31     5PSIyNS42NDg1NDY
   2c7b0:	417a4e31 556a4d35 49794d35 6c6d5a67     1NzA5MjU5MyIgZml
   2c7c0:	30446273 396d6269 49535a75 52336367     sbD0ibm9uZSIgc3R
   2c7d0:	74326279 64584c6c 52485a70 4953506f     yb2tlLXdpZHRoPSI
   2c7e0:	4269497a 4a48647a 55326176 4a6e4939     zIiBzdHJva2U9InJ
   2c7f0:	6769596e 41444c77 6b434d73 4e484969     nYigwLDAsMCkiIHN
   2c800:	396d6330 31535a72 35576173 396d616c     0cm9rZS1saW5lam9
   2c810:	306a6270 6c576269 49585a30 4e484969     pbj0ibWl0ZXIiIHN
   2c820:	396d6330 31535a72 35576173 4632596c     0cm9rZS1saW5lY2F
   2c830:	4a535077 5658637a 556d6368 4e484969     wPSJzcXVhcmUiIHN
   2c840:	396d6330 31535a72 52586174 786d636c     0cm9rZS1taXRlcmx
   2c850:	6c576270 49535030 3869497a 4248502b     pbWl0PSIzIi8+PHB
   2c860:	6c486276 3432626e 39476367 526e6270     vbHlnb24gcG9pbnR
   2c870:	4953507a 34694d32 636a4d35 4d6a4d73     zPSI2Mi45MjcsMjM
   2c880:	59444e75 51444c33 676a4c32 77534d35     uNDY3LDQ2Ljg5MSw
   2c890:	34794d79 677a4d79 55544e73 55444d75     yMy4yMzgsNTUuMDU
   2c8a0:	55444c35 5a474969 77476270 356d4939     5LDUiIGZpbGw9Im5
   2c8b0:	556d6276 5a484969 5233596c 31696376     vbmUiIHZlY3Rvci1
   2c8c0:	5a6d5a6c 5133596c 356d4939 31696276     lZmZlY3Q9Im5vbi1
   2c8d0:	4632597a 35576173 4e584c6e 396d6330     zY2FsaW5nLXN0cm9
   2c8e0:	49535a72 52336367 74326279 64584c6c     rZSIgc3Ryb2tlLXd
   2c8f0:	52485a70 4953506f 4269497a 4a48647a     pZHRoPSIzIiBzdHJ
   2c900:	55326176 4a6e4939 6769596e 41444c77     va2U9InJnYigwLDA
   2c910:	6b434d73 4e484969 396d6330 31535a72     sMCkiIHN0cm9rZS1
   2c920:	35576173 396d616c 306a6270 6c576269     saW5lam9pbj0ibWl
   2c930:	49585a30 4e484969 396d6330 31535a72     0ZXIiIHN0cm9rZS1
   2c940:	35576173 4632596c 4a535077 5658637a     saW5lY2FwPSJzcXV
   2c950:	556d6368 4e484969 396d6330 31535a72     hcmUiIHN0cm9rZS1
   2c960:	52586174 786d636c 6c576270 49535030     taXRlcmxpbWl0PSI
   2c970:	3869497a 4248502b 6c486276 3432626e     zIi8+PHBvbHlnb24
   2c980:	39476367 526e6270 4953507a 34694e34     gcG9pbnRzPSI4Ni4
   2c990:	6b544e35 4d6a4e73 416a4d75 67444c34     5NTksNjMuMjA4LDg
   2c9a0:	456a4c33 77794d34 34694e30 49544f33     3LjE4Myw0Ni43OTI
   2c9b0:	41544d73 55444c31 456a4c31 49794d31     sMTA1LDU1LjE1MyI
   2c9c0:	6c6d5a67 30446273 396d6269 49535a75     gZmlsbD0ibm9uZSI
   2c9d0:	566d6467 3947646a 56574c79 566d5a6d     gdmVjdG9yLWVmZmV
   2c9e0:	3044646a 396d6269 4e584c75 7857596a     jdD0ibm9uLXNjYWx
   2c9f0:	636d6270 52336374 74326279 4269496c     pbmctc3Ryb2tlIiB
   2ca00:	4a48647a 55326176 6c326474 6747646b     zdHJva2Utd2lkdGg
   2ca10:	4d6a4939 4e484969 396d6330 30545a72     9IjMiIHN0cm9rZT0
   2ca20:	646d6369 41444b69 77434d73 49534b77     icmdiKDAsMCwwKSI
   2ca30:	52336367 74326279 78574c6c 566d6270     gc3Ryb2tlLWxpbmV
   2ca40:	6c326271 4a535075 52586174 4969636c     qb2luPSJtaXRlciI
   2ca50:	52336367 74326279 78574c6c 566d6270     gc3Ryb2tlLWxpbmV
   2ca60:	4158596a 4e6e4939 46576478 49535a79     jYXA9InNxdWFyZSI
   2ca70:	52336367 74326279 31574c6c 56476470     gc3Ryb2tlLW1pdGV
   2ca80:	6c476279 51586174 4d6a4939 347a4c69     ybGltaXQ9IjMiLz4
   2ca90:	39476338 64576573 42696276 6c326277     8cG9seWdvbiBwb2l
   2caa0:	4d486475 676a4939 4d6a4c7a 77794d32     udHM9IjgzLjM2Myw
   2cab0:	34434f7a 676a4d33 497a4e73 67544d75     zOC43MjgsNzIuMTg
   2cac0:	49444c78 6b6a4c32 77534f31 34434d35     xLDI2Ljk1OSw5MC4
   2cad0:	59544e31 6b544d73 63544f75 42694931     1NTYsMTkuOTc1IiB
   2cae0:	7857616d 4a535073 35326275 4269496c     maWxsPSJub25lIiB
   2caf0:	4e575a32 49336230 5a575a74 4e575a6d     2ZWN0b3ItZWZmZWN
   2cb00:	4a535030 34326275 4e326374 6c476268     0PSJub24tc2NhbGl
   2cb10:	31795a75 4a48647a 55326176 4e484969     uZy1zdHJva2UiIHN
   2cb20:	396d6330 31535a72 52576133 30446130     0cm9rZS13aWR0aD0
   2cb30:	49794d69 52336367 74326279 4a53506c     iMyIgc3Ryb2tlPSJ
   2cb40:	49325a79 77434d6f 41444c77 42694970     yZ2IoMCwwLDApIiB
   2cb50:	4a48647a 55326176 6c476274 70575a75     zdHJva2UtbGluZWp
   2cb60:	34576176 316d4939 56476470 42694979     vaW49Im1pdGVyIiB
   2cb70:	4a48647a 55326176 6c476274 4e575a75     zdHJva2UtbGluZWN
   2cb80:	30446368 46336369 4a585931 4269496c     hcD0ic3F1YXJlIiB
   2cb90:	4a48647a 55326176 6c576274 4a585a30     zdHJva2UtbWl0ZXJ
   2cba0:	31576173 30446470 49794d69 786a5076     saW1pdD0iMyIvPjx
   2cbb0:	78326277 39325a35 42484975 35576176     wb2x5Z29uIHBvaW5
   2cbc0:	307a6330 637a4d69 45444d75 49444c34     0cz0iMzcuMDE4LDI
   2cbd0:	4d6a4c33 77434f7a 34534e79 456a4d31     3LjMzOCwyNS41MjE
   2cbe0:	677a4d73 677a4e75 45444c7a 596a4c34     sMzguNzgzLDE4LjY
   2cbf0:	77434f35 34534f78 557a4e35 5a474969     5OCwxOS45NzUiIGZ
   2cc00:	77476270 356d4939 556d6276 5a484969     pbGw9Im5vbmUiIHZ
   2cc10:	5233596c 31696376 5a6d5a6c 5133596c     lY3Rvci1lZmZlY3Q
   2cc20:	356d4939 31696276 4632597a 35576173     9Im5vbi1zY2FsaW5
   2cc30:	4e584c6e 396d6330 49535a72 52336367     nLXN0cm9rZSIgc3R
   2cc40:	74326279 64584c6c 52485a70 4953506f     yb2tlLXdpZHRoPSI
   2cc50:	4269497a 4a48647a 55326176 4a6e4939     zIiBzdHJva2U9InJ
   2cc60:	6769596e 41444c77 6b434d73 4e484969     nYigwLDAsMCkiIHN
   2cc70:	396d6330 31535a72 35576173 396d616c     0cm9rZS1saW5lam9
   2cc80:	306a6270 6c576269 49585a30 4e484969     pbj0ibWl0ZXIiIHN
   2cc90:	396d6330 31535a72 35576173 4632596c     0cm9rZS1saW5lY2F
   2cca0:	4a535077 5658637a 556d6368 4e484969     wPSJzcXVhcmUiIHN
   2ccb0:	396d6330 31535a72 52586174 786d636c     0cm9rZS1taXRlcmx
   2ccc0:	6c576270 49535030 3869497a 4248502b     pbWl0PSIzIi8+PHB
   2ccd0:	6c486276 3432626e 39476367 526e6270     vbHlnb24gcG9pbnR
   2cce0:	4953507a 34434d33 55444d34 51444f73     zPSI3MC44MDUsODQ
   2ccf0:	49544d75 67444c32 4d6a4c79 77794d77     uMTI2LDgyLjMwMyw
   2cd00:	34694d33 45444f32 6b444f73 49544d75     3Mi42ODEsODkuMTI
   2cd10:	6b444c32 516a4c78 49534f34 6c6d5a67     2LDkxLjQ4OSIgZml
   2cd20:	30446273 396d6269 49535a75 566d6467     sbD0ibm9uZSIgdmV
   2cd30:	3947646a 56574c79 566d5a6d 3044646a     jdG9yLWVmZmVjdD0
   2cd40:	396d6269 4e584c75 7857596a 636d6270     ibm9uLXNjYWxpbmc
   2cd50:	52336374 74326279 4269496c 4a48647a     tc3Ryb2tlIiBzdHJ
   2cd60:	55326176 6c326474 6747646b 4d6a4939     va2Utd2lkdGg9IjM
   2cd70:	4e484969 396d6330 30545a72 646d6369     iIHN0cm9rZT0icmd
   2cd80:	41444b69 77434d73 49534b77 52336367     iKDAsMCwwKSIgc3R
   2cd90:	74326279 78574c6c 566d6270 6c326271     yb2tlLWxpbmVqb2l
   2cda0:	4a535075 52586174 4969636c 52336367     uPSJtaXRlciIgc3R
   2cdb0:	74326279 78574c6c 566d6270 4158596a     yb2tlLWxpbmVjYXA
   2cdc0:	4e6e4939 46576478 49535a79 52336367     9InNxdWFyZSIgc3R
   2cdd0:	74326279 31574c6c 56476470 6c476279     yb2tlLW1pdGVybGl
   2cde0:	51586174 4d6a4939 347a4c69 39476338     taXQ9IjMiLz48cG9
   2cdf0:	64576573 42696276 6c326277 4d486475     seWdvbiBwb2ludHM
   2ce00:	496a4939 676a4c33 77434f31 34534d33     9IjI3Ljg1OCw3MS4
   2ce10:	497a4e79 6b7a4d73 51444d75 4d444f73     yNzIsMzkuMDQsODM
   2ce20:	51444d75 49444c78 596a4c77 77534e32     uMDQxLDIwLjY2NSw
   2ce30:	34434d35 556a4d77 5a474969 77476270     5MC4wMjUiIGZpbGw
   2ce40:	356d4939 556d6276 5a484969 5233596c     9Im5vbmUiIHZlY3R
   2ce50:	31696376 5a6d5a6c 5133596c 356d4939     vci1lZmZlY3Q9Im5
   2ce60:	31696276 4632597a 35576173 4e584c6e     vbi1zY2FsaW5nLXN
   2ce70:	396d6330 49535a72 52336367 74326279     0cm9rZSIgc3Ryb2t
   2ce80:	64584c6c 52485a70 4953506f 4269497a     lLXdpZHRoPSIzIiB
   2ce90:	4a48647a 55326176 4a6e4939 6769596e     zdHJva2U9InJnYig
   2cea0:	41444c77 6b434d73 4e484969 396d6330     wLDAsMCkiIHN0cm9
   2ceb0:	31535a72 35576173 396d616c 306a6270     rZS1saW5lam9pbj0
   2cec0:	6c576269 49585a30 4e484969 396d6330     ibWl0ZXIiIHN0cm9
   2ced0:	31535a72 35576173 4632596c 4a535077     rZS1saW5lY2FwPSJ
   2cee0:	5658637a 556d6368 4e484969 396d6330     zcXVhcmUiIHN0cm9
   2cef0:	31535a72 52586174 786d636c 6c576270     rZS1taXRlcmxpbWl
   2cf00:	49535030 3869497a 4248502b 6c486276     0PSIzIi8+PHBvbHl
   2cf10:	3432626e 39476367 526e6270 4953507a     nb24gcG9pbnRzPSI
   2cf20:	34794d79 45444e77 59444e73 6b7a4e75     yMy4wNDEsNDYuNzk
   2cf30:	49444c79 676a4c79 77794e78 34794d32     yLDIyLjgxNyw2My4
   2cf40:	67444d79 77534e73 34434e31 63444e34     yMDgsNSw1NC44NDc
   2cf50:	5a474969 77476270 356d4939 556d6276     iIGZpbGw9Im5vbmU
   2cf60:	5a484969 5233596c 31696376 5a6d5a6c     iIHZlY3Rvci1lZmZ
   2cf70:	5133596c 356d4939 31696276 4632597a     lY3Q9Im5vbi1zY2F
   2cf80:	35576173 4e584c6e 396d6330 49535a72     saW5nLXN0cm9rZSI
   2cf90:	52336367 74326279 64584c6c 52485a70     gc3Ryb2tlLXdpZHR
   2cfa0:	4953506f 4269497a 4a48647a 55326176     oPSIzIiBzdHJva2U
   2cfb0:	4a6e4939 6769596e 41444c77 6b434d73     9InJnYigwLDAsMCk
   2cfc0:	4e484969 396d6330 31535a72 35576173     iIHN0cm9rZS1saW5
   2cfd0:	396d616c 306a6270 6c576269 49585a30     lam9pbj0ibWl0ZXI
   2cfe0:	4e484969 396d6330 31535a72 35576173     iIHN0cm9rZS1saW5
   2cff0:	4632596c 4a535077 5658637a 556d6368     lY2FwPSJzcXVhcmU
   2d000:	4e484969 396d6330 31535a72 52586174     iIHN0cm9rZS1taXR
   2d010:	786d636c 6c576270 49535030 3869497a     lcmxpbWl0PSIzIi8
   2d020:	4248502b 6c486276 3432626e 39476367     +PHBvbHlnb24gcG9
   2d030:	526e6270 4953507a 34694e30 45544f34     pbnRzPSI0Ni44OTE
   2d040:	59444f73 4d544e75 59444c7a 6b6a4c79     sODYuNTMzLDYyLjk
   2d050:	77794e79 34694e34 496a4e33 51544e73     yNyw4Ni43NjIsNTQ
   2d060:	557a4e75 45444c35 49534e77 6c6d5a67     uNzU5LDEwNSIgZml
   2d070:	30446273 396d6269 49535a75 566d6467     sbD0ibm9uZSIgdmV
   2d080:	3947646a 56574c79 566d5a6d 3044646a     jdG9yLWVmZmVjdD0
   2d090:	396d6269 4e584c75 7857596a 636d6270     ibm9uLXNjYWxpbmc
   2d0a0:	52336374 74326279 4269496c 4a48647a     tc3Ryb2tlIiBzdHJ
   2d0b0:	55326176 6c326474 6747646b 4d6a4939     va2Utd2lkdGg9IjM
   2d0c0:	4e484969 396d6330 30545a72 646d6369     iIHN0cm9rZT0icmd
   2d0d0:	41444b69 77434d73 49534b77 52336367     iKDAsMCwwKSIgc3R
   2d0e0:	74326279 78574c6c 566d6270 6c326271     yb2tlLWxpbmVqb2l
   2d0f0:	4a535075 52586174 4969636c 52336367     uPSJtaXRlciIgc3R
   2d100:	74326279 78574c6c 566d6270 4158596a     yb2tlLWxpbmVjYXA
   2d110:	4e6e4939 46576478 49535a79 52336367     9InNxdWFyZSIgc3R
   2d120:	74326279 31574c6c 56476470 6c476279     yb2tlLW1pdGVybGl
   2d130:	51586174 4d6a4939 347a4c69 63324c38     taXQ9IjMiLz48L2c
   2d140:	3943502b 776a506e 5a336376 3d67506e     +PC9nPjwvc3ZnPg=
   2d150:	3b29223d 20200a0d 61622020 72676b63     =");..    backgr
   2d160:	646e756f 6c6f632d 203a726f 74696877     ound-color: whit
   2d170:	0a0d3b65 0d0a0d7d 7573230a 6165526e     e;..}....#sunRea
   2d180:	676e6964 0a0d7b20 20202020 64646170     ding {..    padd
   2d190:	2d676e69 7466656c 3832203a 0d3b7870     ing-left: 28px;.
   2d1a0:	2020200a 64617020 676e6964 706f742d     .    padding-top
   2d1b0:	3531203a 0d3b7870 2020200a 6c6f6320     : 15px;..    col
   2d1c0:	203a726f 37366523 3b613163 20200a0d     or: #e67c1a;..  
   2d1d0:	6f662020 732d746e 3a657a69 70303220       font-size: 20p
   2d1e0:	0a0d3b78 20202020 746e6f66 7974732d     x;..    font-sty
   2d1f0:	203a656c 6c617469 0d3b6369 0a0d7d0a     le: italic;..}..
   2d200:	75230a0d 61622d76 72676b63 646e756f     ..#uv-background
   2d210:	0a0d7b20 20202020 6772616d 742d6e69      {..    margin-t
   2d220:	203a706f 78703034 200a0d3b 70202020     op: 40px;..    p
   2d230:	7469736f 3a6e6f69 6c657220 76697461     osition: relativ
   2d240:	0a0d3b65 20202020 67696568 203a7468     e;..    height: 
   2d250:	70303131 0a0d3b78 20202020 74646977     110px;..    widt
   2d260:	31203a68 78703031 200a0d3b 62202020     h: 110px;..    b
   2d270:	676b6361 6e756f72 75203a64 22286c72     ackground: url("
   2d280:	61746164 616d693a 732f6567 782b6776     data:image/svg+x
   2d290:	623b6c6d 36657361 44502c34 57623439     ml;base64,PD94bW
   2d2a0:	6d646777 32637956 6a62766c 534d6930     wgdmVyc2lvbj0iMS
   2d2b0:	69497734 47647a42 475a7546 32627346     4wIiBzdGFuZGFsb2
   2d2c0:	53506c35 7962754a 6a502f49 534c6877     5lPSJubyI/PjwhLS
   2d2d0:	32526730 585a7556 4764684a 694f7939     0gR2VuZXJhdG9yOi
   2d2e0:	6d634842 58613246 57617551 534c6738     BHcmF2aXQuaW8gLS
   2d2f0:	48502b30 795a324e 57623442 7a637578     0+PHN2ZyB4bWxucz
   2d300:	48616930 44633052 334c766f 79643364     0iaHR0cDovL3d3dy
   2d310:	794d3335 6d637635 6a4d7663 434d7741     53My5vcmcvMjAwMC
   2d320:	6d647a39 48496963 47627468 6e4f7a35     9zdmciIHhtbG5zOn
   2d330:	57617368 53507235 48646f4a 694f7752     hsaW5rPSJodHRwOi
   2d340:	33647638 6e4c3364 6d4c7a63 795a7939     8vd3d3LnczLm9yZy
   2d350:	544f7838 334c356b 57617368 69497235     8xOTk5L3hsaW5rIi
   2d360:	48647a42 545a736c 58616930 4762764e     BzdHlsZT0iaXNvbG
   2d370:	57613046 6d4f7539 32627a6c 47646878     F0aW9uOmlzb2xhdG
   2d380:	48496955 585a705a 33624364 6a493967     UiIHZpZXdCb3g9Ij
   2d390:	434d6741 544d7841 544d6741 69497745     AgMCAxMTAgMTEwIi
   2d3a0:	57613342 44613052 544d6930 69497745     B3aWR0aD0iMTEwIi
   2d3b0:	575a6f42 48616e6c 6a493951 434d7845     BoZWlnaHQ9IjExMC
   2d3c0:	47502b49 6e5a6c52 47502b4d 5861734e     I+PGRlZnM+PGNsaX
   2d3d0:	58595142 47496f52 53506b6c 3259664a     BQYXRoIGlkPSJfY2
   2d3e0:	46637078 47646842 46566668 57557370     xpcFBhdGhfVFpsUW
   2d3f0:	5454524e 5761314e 56564b68 47633567     NRTTN1aWhKVVg5cG
   2d400:	7a564f70 54653063 56627552 47615746     pOVzc0eTRubVFWaG
   2d410:	32596a70 6a506963 575a7978 4849304e     pjY2ciPjxyZWN0IH
   2d420:	485a7064 53506f52 544d7849 47496941     dpZHRoPSIxMTAiIG
   2d430:	57616c68 44646f64 544d6930 69497745     hlaWdodD0iMTEwIi
   2d440:	43502b38 47626a39 4755776c 44613046     8+PC9jbGlwUGF0aD
   2d450:	324c3834 6e5a6c52 47502b4d 32596763     48L2RlZnM+PGcgY2
   2d460:	43637078 58597731 53506f52 6d63314a     xpcC1wYXRoPSJ1cm
   2d470:	31496f77 47626a39 4755776c 46613046     woI19jbGlwUGF0aF
   2d480:	6d575539 31595278 334d4e46 45617056     9UWmxRY1FNM3VpaE
   2d490:	44575670 6b61776c 7a4e5835 474e3552     pVWDlwak5XNzR5NG
   2d4a0:	56557435 6d616f5a 795a6a4e 6a50696b     5tUVZoamNjZykiPj
   2d4b0:	58597778 47496f52 69493951 44494e42     xwYXRoIGQ9IiBNID
   2d4c0:	6a4c3059 694d7a45 794d7941 7a4d3034     Y0LjEzMiAyMy40Mz
   2d4d0:	43546749 534f3341 444f3234 544e6749     IgTCA3OS42ODIgNT
   2d4e0:	7a4d7541 45493159 544f6777 6a4d7555     AuMzY1IEwgOTUuMj
   2d4f0:	4449784d 6a4c3363 794e3549 44494442     MxIDc3LjI5NyBDID
   2d500:	434d7745 7a4e7934 444f6745 444d7559     EwMC4yNzEgODYuMD
   2d510:	44493349 6a4c326b 534f3345 794d3541     I3IDk2LjE3OSA5My
   2d520:	544d7834 444f6755 444d7559 4449356b     4xMTUgODYuMDk5ID
   2d530:	6a4c7a6b 534e7845 44494d42 44493155     kzLjExNSBMIDU1ID
   2d540:	6a4c7a6b 534e7845 44494d42 6a4c7a49     kzLjExNSBMIDIzLj
   2d550:	534d776b 794d3541 544d7834 79516755     kwMSA5My4xMTUgQy
   2d560:	794d7841 6a4d3434 544f6745 544d754d     AxMy44MjEgOTMuMT
   2d570:	44493145 7a4e756b 44493549 6a4c3267     E1IDkuNzI5IDg2Lj
   2d580:	794e7941 434e7841 6a4e3334 7a4e676b     AyNyAxNC43NjkgNz
   2d590:	6a4d7563 4549336b 7a4d6777 7a4d7541     cuMjk3IEwgMzAuMz
   2d5a0:	44493445 6a4c7755 534e324d 44494d42     E4IDUwLjM2NSBMID
   2d5b0:	6a4c3151 434f3267 794d7941 7a4d3034     Q1Ljg2OCAyMy40Mz
   2d5c0:	79516749 434d3141 444d3534 544d6767     IgQyA1MC45MDggMT
   2d5d0:	7a4e7551 44497a41 6a4c3555 694d3541     QuNzAzIDU5LjA5Mi
   2d5e0:	434e7841 444d3334 6a4e674d 544d7551     AxNC43MDMgNjQuMT
   2d5f0:	4449794d 6a4c7a49 694d7a51 43496142     MyIDIzLjQzMiBaIC
   2d600:	6d5a6749 4462736c 6d636930 444b6964     IgZmlsbD0icmdiKD
   2d610:	434f3145 434f3577 544e7977 69497055     E1OCw5OCwyNTUpIi
   2d620:	575a3242 3362304e 575a7449 575a6d5a     B2ZWN0b3ItZWZmZW
   2d630:	5350304e 3262754a 32637434 4762684e     N0PSJub24tc2NhbG
   2d640:	795a756c 48647a31 3261764a 48496955     luZy1zdHJva2UiIH
   2d650:	6d63304e 535a7239 57613331 44613052     N0cm9rZS13aWR0aD
   2d660:	434e6930 33636749 32627952 53506c74     0iNCIgc3Ryb2tlPS
   2d670:	325a794a 434d6f49 444c7777 69497041     JyZ2IoMCwwLDApIi
   2d680:	48647a42 3261764a 47627455 575a756c     BzdHJva2UtbGluZW
   2d690:	57617670 6d493934 47647031 69497956     pvaW49Im1pdGVyIi
   2d6a0:	48647a42 3261764a 47627455 575a756c     BzdHJva2UtbGluZW
   2d6b0:	4463684e 33636930 58593146 69496c4a     NhcD0ic3F1YXJlIi
   2d6c0:	48647a42 3261764a 57627455 585a306c     BzdHJva2UtbWl0ZX
   2d6d0:	5761734a 44647031 794d6930 6a507649     JsaW1pdD0iMyIvPj
   2d6e0:	48496e78 57597952 6d5a7a35 54627939     xnIHRyYW5zZm9ybT
   2d6f0:	57626930 6d633046 444b346c 434d7345     0ibWF0cml4KDEsMC
   2d700:	444c7777 7a4d7345 534e756b 534e3277     wwLDEsMzkuNSw2NS
   2d710:	434f7934 6a50696b 585a3078 48493068     4yOCkiPjx0ZXh0IH
   2d720:	57597952 6d5a7a35 54627939 57626930     RyYW5zZm9ybT0ibW
   2d730:	6d633046 444b346c 434d7345 444c7777     F0cml4KDEsMCwwLD
   2d740:	434d7345 434e7834 434d7977 694d7934     EsMC4xNCwyMC4yMi
   2d750:	4849696b 5765304e 53506c78 32626d4a     kiIHN0eWxlPSJmb2
   2d760:	574c3035 5762685a 5465736c 6e546e6f     50LWZhbWlseTonTn
   2d770:	58617556 7a4a7652 32626d74 584c3035     VuaXRvJztmb250LX
   2d780:	57616c64 44646f64 444d336f 6d5a3741     dlaWdodDo3MDA7Zm
   2d790:	43647539 58617a31 6a4f6c70 48637749     9udC1zaXplOjIwcH
   2d7a0:	6d5a3767 43647539 48647a31 545a736c     g7Zm9udC1zdHlsZT
   2d7b0:	33627570 5759744a 6d5a3777 4462736c     pub3JtYWw7ZmlsbD
   2d7c0:	444d6a6f 444d7741 334f7741 6d63304e     ojMDAwMDAwO3N0cm
   2d7d0:	545a7239 32627570 794f6c35 56562b49     9rZTpub25lOyI+VV
   2d7e0:	43506759 585a3039 6a503068 7a5a7677     YgPC90ZXh0PjwvZz
   2d7f0:	795a3834 6d633042 32637546 6d63765a     48ZyB0cmFuc2Zvcm
   2d800:	6d493930 48646831 4365704a 444c7867     09Im1hdHJpeCgxLD
   2d810:	434d7341 444c7877 6a4c7755 6a4d7355     AsMCwxLDUwLjUsMj
   2d820:	6a4d7559 6a497067 47643834 43643456     YuMjgpIj48dGV4dC
   2d830:	6d633042 32637546 6d63765a 6d493930     B0cmFuc2Zvcm09Im
   2d840:	48646831 4365704a 444c7867 434d7341     1hdHJpeCgxLDAsMC
   2d850:	444c7877 7a4d7341 7a4d7559 534b326b     wxLDAsMzYuMzk2KS
   2d860:	33636749 47623552 6d493955 6e62765a     Igc3R5bGU9ImZvbn
   2d870:	6d5a7451 57617446 694f3578 57644f64     QtZmFtaWx5OidOdW
   2d880:	47647035 324f6e38 6e62765a 32647451     5pdG8nO2ZvbnQtd2
   2d890:	325a7056 6a4f3068 444d7751 32626d74     VpZ2h0OjQwMDtmb2
   2d8a0:	584c3035 6d65704e 7a4d3655 4465775a     50LXNpemU6MzZweD
   2d8b0:	32626d74 584c3035 5765304e 6d4f6c78     tmb250LXN0eWxlOm
   2d8c0:	6d637635 44626831 57616d74 694f7378     5vcm1hbDtmaWxsOi
   2d8d0:	444d774d 444d7741 33633741 32627952     MwMDAwMDA7c3Ryb2
   2d8e0:	6d4f6c74 6d627635 6a493755 43506834     tlOm5vbmU7Ij4hPC
   2d8f0:	585a3039 6a503068 7a5a7677 324c3834     90ZXh0PjwvZz48L2
   2d900:	43502b63 6d647a39 29222b63 2d6f6e20     c+PC9zdmc+") no-
   2d910:	65706572 0d3b7461 0a0d7d0a 75230a0d     repeat;..}....#u
   2d920:	72702d76 6572676f 7b207373 20200a0d     v-progress {..  
   2d930:	65682020 74686769 3131203a 3b787030       height: 110px;
   2d940:	20200a0d 69772020 3a687464 30313120     ..    width: 110
   2d950:	0d3b7870 0a0d7d0a 75230a0d 61622d76     px;..}....#uv-ba
   2d960:	0d7b2072 2020200a 69656820 3a746867     r {..    height:
   2d970:	30303120 0a0d3b25 20202020 6b636162      100%;..    back
   2d980:	756f7267 692d646e 6567616d 7275203a     ground-image: ur
   2d990:	6422286c 3a617461 67616d69 76732f65     l("data:image/sv
   2d9a0:	6d782b67 61623b6c 34366573 3944502c     g+xml;base64,PD9
   2d9b0:	77576234 566d6467 6c326379 306a6276     4bWwgdmVyc2lvbj0
   2d9c0:	34534d69 42694977 4647647a 46475a75     iMS4wIiBzdGFuZGF
   2d9d0:	35326273 4a53506c 49796275 776a502f     sb25lPSJubyI/Pjw
   2d9e0:	30534c68 56325267 4a585a75 39476468     hLS0gR2VuZXJhdG9
   2d9f0:	42694f79 466d6348 51586132 38576175     yOiBHcmF2aXQuaW8
   2da00:	30534c67 4e48502b 42795a32 78576234     gLS0+PHN2ZyB4bWx
   2da10:	307a6375 52486169 6f446330 64334c76     ucz0iaHR0cDovL3d
   2da20:	35796433 35794d33 636d6376 416a4d76     3dy53My5vcmcvMjA
   2da30:	39434d77 636d647a 68484969 35476274     wMC9zdmciIHhtbG5
   2da40:	686e4f7a 35576173 4a535072 5248646f     zOnhsaW5rPSJodHR
   2da50:	38694f77 64336476 636e4c33 396d4c7a     wOi8vd3d3LnczLm9
   2da60:	38795a79 6b544f78 68334c35 35576173     yZy8xOTk5L3hsaW5
   2da70:	42694972 6c48647a 30545a73 4e586169     rIiBzdHlsZT0iaXN
   2da80:	46476276 39576130 6c6d4f75 7832627a     vbGF0aW9uOmlzb2x
   2da90:	55476468 5a484969 64585a70 67336243     hdGUiIHZpZXdCb3g
   2daa0:	416a4939 41434d67 41544d78 45544d67     9IjAgMCAxMTAgMTE
   2dab0:	42694977 52576133 30446130 45544d69     wIiB3aWR0aD0iMTE
   2dac0:	42694977 6c575a6f 5148616e 456a4939     wIiBoZWlnaHQ9IjE
   2dad0:	49434d78 5247502b 4d6e5a6c 4e47502b     xMCI+PGRlZnM+PGN
   2dae0:	42586173 52585951 6c47496f 4a53506b     saXBQYXRoIGlkPSJ
   2daf0:	78325966 42466370 68476468 566c6266     fY2xpcFBhdGhfblV
   2db00:	6f6d5568 567a4d35 567a5934 4e555275     hUmo5MzV4YzVuRUN
   2db10:	63475670 316b5431 52555134 526d5233     pVGc1Tk14QUR3RmR
   2db20:	30476253 3445627a 786a5069 4e575a79     SbG0zbE4iPjxyZWN
   2db30:	64484930 52485a70 4953506f 41544d78     0IHdpZHRoPSIxMTA
   2db40:	68474969 6457616c 3044646f 45544d69     iIGhlaWdodD0iMTE
   2db50:	38694977 3943502b 6c47626a 46475577     wIi8+PC9jbGlwUGF
   2db60:	34446130 52324c38 4d6e5a6c 6347502b     0aD48L2RlZnM+PGc
   2db70:	78325967 31436370 52585977 4a53506f     gY2xpcC1wYXRoPSJ
   2db80:	776d6331 3931496f 6c47626a 46475577     1cmwoI19jbGlwUGF
   2db90:	39466130 46575675 6b6a6153 68584e7a     0aF9uVWFSajkzNXh
   2dba0:	35574e6a 6c325146 567a5a55 6858544f     jNW5FQ2lUZzVOTXh
   2dbb0:	64485242 4a465a47 4e546273 6b695473     BRHdGZFJsbTNsTik
   2dbc0:	786a5069 52585977 5147496f 42694939     iPjxwYXRoIGQ9IiB
   2dbd0:	5944494e 456a4c30 41694d7a 34794d79     NIDY0LjEzMiAyMy4
   2dbe0:	497a4d30 41435467 34534f33 49444f32     0MzIgTCA3OS42ODI
   2dbf0:	41544e67 597a4d75 77454931 55544f67     gNTAuMzY1IEwgOTU
   2dc00:	4d6a4d75 63444978 496a4c33 42794e35     uMjMxIDc3LjI5NyB
   2dc10:	45444944 34434d77 457a4e79 59444f67     DIDEwMC4yNzEgODY
   2dc20:	49444d75 6b444933 456a4c32 41534f33     uMDI3IDk2LjE3OSA
   2dc30:	34794d35 55544d78 59444f67 6b444d75     5My4xMTUgODYuMDk
   2dc40:	6b444935 456a4c7a 42534e78 5544494d     5IDkzLjExNSBMIDU
   2dc50:	6b444931 456a4c7a 42534e78 4944494d     1IDkzLjExNSBMIDI
   2dc60:	6b6a4c7a 41534d77 34794d35 55544d78     zLjkwMSA5My4xMTU
   2dc70:	41795167 34794d78 456a4d34 4d544f67     gQyAxMy44MjEgOTM
   2dc80:	45544d75 6b444931 497a4e75 67444935     uMTE1IDkuNzI5IDg
   2dc90:	416a4c32 41794e79 34434e78 6b6a4e33     2LjAyNyAxNC43Njk
   2dca0:	637a4e67 6b6a4d75 77454933 417a4d67     gNzcuMjk3IEwgMzA
   2dcb0:	457a4d75 55444934 4d6a4c77 42534e32     uMzE4IDUwLjM2NSB
   2dcc0:	5144494d 676a4c31 41434f32 34794d79     MIDQ1Ljg2OCAyMy4
   2dcd0:	497a4d30 41795167 34434d31 67444d35     0MzIgQyA1MC45MDg
   2dce0:	51544d67 417a4e75 5544497a 416a4c35     gMTQuNzAzIDU5LjA
   2dcf0:	41694d35 34434e78 4d444d33 516a4e67     5MiAxNC43MDMgNjQ
   2dd00:	4d544d75 49444979 516a4c7a 42694d7a     uMTMyIDIzLjQzMiB
   2dd10:	49434961 6c6d5a67 30446273 396d6269     aICIgZmlsbD0ibm9
   2dd20:	49535a75 566d6467 3947646a 56574c79     uZSIgdmVjdG9yLWV
   2dd30:	566d5a6d 3044646a 396d6269 4e584c75     mZmVjdD0ibm9uLXN
   2dd40:	7857596a 636d6270 52336374 74326279     jYWxpbmctc3Ryb2t
   2dd50:	4269496c 4a48647a 55326176 6c326474     lIiBzdHJva2Utd2l
   2dd60:	6747646b 516a4939 4e484969 396d6330     kdGg9IjQiIHN0cm9
   2dd70:	30545a72 646d6369 41444b69 77434d73     rZT0icmdiKDAsMCw
   2dd80:	49534b77 52336367 74326279 78574c6c     wKSIgc3Ryb2tlLWx
   2dd90:	566d6270 6c326271 4a535075 52586174     pbmVqb2luPSJtaXR
   2dda0:	4969636c 52336367 74326279 78574c6c     lciIgc3Ryb2tlLWx
   2ddb0:	566d6270 4158596a 4e6e4939 46576478     pbmVjYXA9InNxdWF
   2ddc0:	49535a79 52336367 74326279 31574c6c     yZSIgc3Ryb2tlLW1
   2ddd0:	56476470 6c476279 51586174 4d6a4939     pdGVybGltaXQ9IjM
   2dde0:	347a4c69 42795a38 466d6330 5a326375     iLz48ZyB0cmFuc2Z
   2ddf0:	306d6376 316d4939 4a486468 67436570     vcm09Im1hdHJpeCg
   2de00:	41444c78 77434d73 4d444c78 556a4c35     xLDAsMCwxLDM5LjU
   2de10:	556a4e73 676a4d75 346a4970 56476438     sNjUuMjgpIj48dGV
   2de20:	42436434 466d6330 5a326375 306d6376     4dCB0cmFuc2Zvcm0
   2de30:	316d4939 4a486468 67436570 41444c78     9Im1hdHJpeCgxLDA
   2de40:	77434d73 41444c78 51544d75 416a4d73     sMCwxLDAuMTQsMjA
   2de50:	496a4d75 42694970 6c48647a 30545a73     uMjIpIiBzdHlsZT0
   2de60:	396d5a69 31436475 3157596d 6b486270     iZm9udC1mYW1pbHk
   2de70:	35304a36 6c6d6231 63796230 396d5a37     6J051bml0byc7Zm9
   2de80:	31436475 6c575a33 5148616e 417a4e36     udC13ZWlnaHQ6NzA
   2de90:	5a324f77 516e6276 6c326374 6f545a36     wO2ZvbnQtc2l6ZTo
   2dea0:	42484d79 5a324f34 516e6276 52336374     yMHB4O2ZvbnQtc3R
   2deb0:	55476235 396d6236 46576279 5a324f73     5bGU6bm9ybWFsO2Z
   2dec0:	77476270 417a4936 41444d77 74444d77     pbGw6IzAwMDAwMDt
   2ded0:	4a48647a 55326176 396d6236 73545a75     zdHJva2U6bm9uZTs
   2dee0:	566c5069 77444957 56476476 34446434     iPlVWIDwvdGV4dD4
   2def0:	63324c38 6347502b 4a486467 4e6e6268     8L2c+PGcgdHJhbnN
   2df00:	4a33626d 4a535074 52585974 67586179     mb3JtPSJtYXRyaXg
   2df10:	77534d6f 41444c77 77534d73 34434d31     oMSwwLDAsMSw1MC4
   2df20:	49444c31 496a4c32 49534b34 5248502b     1LDI2LjI4KSI+PHR
   2df30:	5148656c 4a486467 4e6e6268 4a33626d     leHQgdHJhbnNmb3J
   2df40:	4a535074 52585974 67586179 77534d6f     tPSJtYXRyaXgoMSw
   2df50:	41444c77 77534d73 4d444c77 4d6a4c32     wLDAsMSwwLDM2LjM
   2df60:	6b694e35 4e484969 78576530 4a53506c     5NikiIHN0eWxlPSJ
   2df70:	3532626d 5a574c30 6c576268 6f546573     mb250LWZhbWlseTo
   2df80:	566e546e 52586175 747a4a76 3532626d     nTnVuaXRvJztmb25
   2df90:	64584c30 6457616c 6f44646f 41444d30     0LXdlaWdodDo0MDA
   2dfa0:	396d5a37 31436475 7058617a 4d6a4f6c     7Zm9udC1zaXplOjM
   2dfb0:	67486332 396d5a37 31436475 6c48647a     2cHg7Zm9udC1zdHl
   2dfc0:	70545a73 4a336275 77575974 6c6d5a37     sZTpub3JtYWw7Zml
   2dfd0:	6f446273 41444d6a 41444d77 4e334f77     sbDojMDAwMDAwO3N
   2dfe0:	396d6330 70545a72 35326275 49794f6c     0cm9rZTpub25lOyI
   2dff0:	7754492b 56476476 34446434 63324c38     +ITwvdGV4dD48L2c
   2e000:	3943502b 776a506e 5a336376 3d67506e     +PC9nPjwvc3ZnPg=
   2e010:	3b29223d 20200a0d 61622020 72676b63     =");..    backgr
   2e020:	646e756f 6c6f632d 203a726f 74696877     ound-color: whit
   2e030:	0a0d3b65 0d0a0d7d 7675230a 64616552     e;..}....#uvRead
   2e040:	20676e69 200a0d7b 70202020 69646461     ing {..    paddi
   2e050:	6c2d676e 3a746665 70383320 0a0d3b78     ng-left: 38px;..
   2e060:	20202020 64646170 2d676e69 3a706f74         padding-top:
   2e070:	70353120 0a0d3b78 20202020 6f6c6f63      15px;..    colo
   2e080:	23203a72 63373665 0d3b6131 2020200a     r: #e67c1a;..   
   2e090:	6e6f6620 69732d74 203a657a 78703032      font-size: 20px
   2e0a0:	200a0d3b 66202020 2d746e6f 6c797473     ;..    font-styl
   2e0b0:	69203a65 696c6174 0a0d3b63 0000007d     e: italic;..}...

0002e0c0 <data_img_bgFooter_gif>:
   2e0c0:	676d692f 4667622f 65746f6f 69672e72     /img/bgFooter.gi
   2e0d0:	49470066 61393846 000f03e0 ba0000c4     f.GIF89a........
   2e0e0:	d4b7ecd7 e6d1b4e8 a9e9d5b7 ccb0d8c5     ................
   2e0f0:	d9c6abe0 aee5d0b4 d6b8ddca e1cdb1ea     ................
   2e100:	af69aaff c3a8dfcb dbc8acd6 add9c5aa     ..i.............
   2e110:	c1a6dcc9 e3cfb2d4 afd7c4a9 c2a7decb     ................
   2e120:	dac7acd5 b3e7d3b6 6fffe4d0 ebd6b900     ...........o....
   2e130:	ffedd8ba d9bbffff 000000ee 21000000     ...............!
   2e140:	000004f9 2c000000 00000000 000f03e0     .......,........
   2e150:	60ff0500 96e48e27 aeaa5c2d 70beeb6c     ...`'...-\..l..p
   2e160:	6d74cf2c efae78df c0ffef7c 2c4870a0     ,.tm.x..|....pH,
   2e170:	a4c88f1a 3a6cc972 54a8d09f 2c4cc8b7     ....r.l:...T..L,
   2e180:	b345cc14 1bbf7921 2e4a664d b4e8cf9b     ..E.!y..MfJ.....
   2e190:	bb6ecd7a 7cb8f0df 2a65df4e fb96ac04     z.n....|N.e*....
   2e1a0:	19c28bed 84837527 88878685 8c8b8a89     ....'u..........
   2e1b0:	298f8e8d 0c797755 7e7c0118 07011a60     ...)Uwy...|~`...
   2e1c0:	a09f9e81 a4a3a2a1 a8a7a6a5 acabaaa9     ................
   2e1d0:	b0afaead b4b3b2b1 b8b7b6b5 bcbbbab9     ................
   2e1e0:	c0bfbebd c4c3c2c1 11adc6c5 0e0f0d11     ................
   2e1f0:	5d970705 001b5e99 080a0203 150d0406     ...].^..........
   2e200:	e0dfdedd e4e3e2e1 e8e7e6e5 ecebeae9     ................
   2e210:	f0efeeed f4f3f2f1 f8f7f6f5 fcfbfaf9     ................
   2e220:	00fffefd 481c0a03 7441a0b0 4018080d     .......H..At...@
   2e230:	00c040a0 91a4d100 02e09000 0c100286     .@..............
   2e240:	6040203c 208fc782 491c8a43 93c9a4b2     < @`... C..I....
   2e250:	aaff5328 a5b2c95c 633097cb b3499cca     (S..\.....0c..I.
   2e260:	389bcda6 c9dcea73 9fcfa7b3 1d0a8340     ...8s.......@...
   2e270:	d1a8b44a 3e3925a3 80a10030 24000496     J....%9>0......$
   2e280:	a126b26a 16070200 cadd6ab2 afd7abb5     j.&......j......
   2e290:	1d8ac360 d9acb64b aad368b3 adb6cb5d     `...K....h..]...
   2e2a0:	e370b7db b74b9dca 78bbddae cbddeaf3     ..p...K....x....
   2e2b0:	bfdfafb7 260b0380 014100eb 49310e09     .......&..A...1I
   2e2c0:	936d411d 0a0a0c00 b940a030 98cbe5b2     .Am.....0.@.....
   2e2d0:	ccde6b33 cfe7b3b9 1e8b43a0 e9b4ba4d     3k.......C..M...
   2e2e0:	ab53a8d3 b5bacd5e 63b0d7eb bb4d9ecb     ..S.^......c..M.
   2e2f0:	b8dbedb6 cddeeb73 066777bb 10601405     ....s....wg...`.
   2e300:	e2e20970 0c340069 00e020b8 a3d0e786     p...i.4.. ......
   2e310:	bd4e9f4b d8ebf5ba cedf6bb3 eff7bbbd     K.N......k......
   2e320:	1f8bc3e0 f9bcbe4f abd3e8f3 bdbecf5f     ....O......._...
   2e330:	e3f0f7fb bf4f9fcb f8fbfdbe 70101fb5     ......O........p
   2e340:	e3068061 41a721c7 10040302 260805c0     a....!.A.......&
   2e350:	82ffe0a8 e0e8360c 28461083 561484e1     .....6....F(...V
   2e360:	1885e168 86e1a866 e1e8761c 28862087     h...f....v... .(
   2e370:	962488e2 2889e268 8ae2a8a6 e2e8b62c     ..$.h..(....,...
   2e380:	18c6308b 240381a1 01445ff0 724d4096     .0.....$._D..@Mr
   2e390:	e3e8f41a 2906408f 164490e4 4891e469     .....@.)..D.i..H
   2e3a0:	92e4a926 e4e9364c 29465093 565494e5     &...L6...PF)..TV
   2e3b0:	5895e569 96e5a966 e5e9765c 29866097     i..Xf...\v...`.)
   2e3c0:	966498e6 00926669 8e638440 e6e06c60     ..d.if..@.c.`l..
   2e3d0:	29c6709b d6749ce7 789de769 9ee7a9e6     .p.)..t.i..x....
   2e3e0:	e7e9f67c 2a06809f 1684a0e8 88a1e86a     |......*....j...
   2e3f0:	a2e8aa26 e8ea368c 2a4690a3 5694a4e9     &....6....F*...V
   2e400:	7ca5e96a a6e9a9b2 e9ea769c 2a86a0a7     j..|.....v.....*
   2e410:	96a4a8ea a8a9ea6a aaeaaaa6 eaeab6ac     ....j...........
   2e420:	2ac6b0ab d6b4aceb b8adeb6a aeebaae6     ...*....j.......
   2e430:	ebeaf6bc 2b06c0af 16c4b0ec c8b1ec6b     .......+....k...
   2e440:	b2ecab26 eceb36cc 2b46d0b3 56d4b4ed     &....6....F+...V
   2e450:	ac03ed6b 3b000021 00000000              k...!..;....

0002e45c <data_img_bgHeader_gif>:
   2e45c:	676d692f 4867622f 65646165 69672e72     /img/bgHeader.gi
   2e46c:	49470066 61393846 006a03e0 ff0000c4     f.GIF89a..j.....
   2e47c:	d8ba006f ebd6b9ed b3ecd7ba d3b6e4d0     o...............
   2e48c:	e9d5b7e7 ffdac7ac d4b769aa e0ccb0e8     .........i......
   2e49c:	b4decbaf d6b8e6d1 d8c5a9ea afd7c4a9     ................
   2e4ac:	cfb2dfcb e5d0b4e3 aee1cdb1 c6abddca     ................
   2e4bc:	d9c5aad9 addbc8ac ffffdcc9 eed9bbff     ................
	...
   2e4d8:	21000000 000004f9 2c000000 00000000     ...!.......,....
   2e4e8:	006a03e0 a0ff0500 69648e26 aeaa689e     ..j.....&.di.h..
   2e4f8:	70beeb6c 6d74cf2c efae78df c0ffef7c     l..p,.tm.x..|...
   2e508:	2c4870a0 a4c88f1a 3a6cc972 74a8d09f     .pH,....r.l:...t
   2e518:	af5aad4a cb76acd8 e0bf7aed 2e4c78b0     J.Z...v..z...xL.
   2e528:	b4e8cf9b bb6ecd7a 7cb8f0df efdbaf4e     ....z.n....|N...
   2e538:	cf7ebcf8 80fffbef 84838281 88878685     ..~.............
   2e548:	8c8b8a89 908f8e8d 94939291 98979695     ................
   2e558:	9c9b9a99 a09f9e9d a4a3a2a1 a8a7a6a5     ................
   2e568:	acabaaa9 b0afaead b4b3b2b1 b8b7b6b5     ................
   2e578:	bcbbbab9 c0bfbebd c4c3c2c1 c8c7c6c5     ................
   2e588:	cccbcac9 d0cfcecd d4d3d2d1 d8d7d6d5     ................
   2e598:	dcdbdad9 e0dfdedd e4e3e2e1 e8e7e6e5     ................
   2e5a8:	ecebeae9 f0efeeed f4f3f2f1 f8f7f6f5     ................
   2e5b8:	fcfbfaf9 00fffefd 481c0a03 83c1a0b0     ...........H....
   2e5c8:	5c2a1308 c3a1b0c8 4a231087 a2b1489c     ..*\......#J.H..
   2e5d8:	33188bc5 b1c8dc6a 208fc7a3 491c8a43     ...3j...... C..I
   2e5e8:	93c9a4b2 aaff5328 a5b2c95c 633097cb     ....(S..\.....0c
   2e5f8:	b3499cca 389bcda6 c9dcea73 9fcfa7b3     ..I....8s.......
   2e608:	1d0a8340 d1a8b44a 2a9348a3 a9b4ca5d     @...J....H.*]...
   2e618:	a350a7d3 b54a9d4a 58abd5aa cadd6ab3     ..P.J.J....X.j..
   2e628:	afd7abb5 1d8ac360 d9acb64b aad368b3     ....`...K....h..
   2e638:	adb6cb5d e370b7db b74b9dca 78bbddae     ].....p...K....x
   2e648:	cbddeaf3 bfdfafb7 1e0b0380 e1b0b84c     ............L...
   2e658:	2b1388c3 b1b8cc5e 2390c7e3 b94c9e4b     ...+^......#K.L.
   2e668:	98cbe5b2 ccde6b33 cfe7b3b9 1e8b43a0     ....3k.......C..
   2e678:	e9b4ba4d ab53a8d3 b5bacd5e 63b0d7eb     M.....S.^......c
   2e688:	bb4d9ecb b8dbedb6 cddeeb73 dfefb7bb     ..M.....s.......
   2e698:	1f0b83c0 f1b8bc4e 2b93c8e3 f9bcce5f     ....N......+_...
   2e6a8:	a3d00010 bd4e9f4b d8ebf5ba cedf6bb3     ....K.N......k..
   2e6b8:	eff7bbbd 1f8bc3e0 f9bcbe4f abd3e8f3     ........O.......
   2e6c8:	bdbecf5f e3f0f7fb bf4f9fcb f8fbfdbe     _.........O.....
   2e6d8:	c00f7ff3 0474071f e0280419 68160480     ......t...(....h
   2e6e8:	260881e0 82ffe0a8 e0e8360c 28461083     ...&.....6....F(
   2e6f8:	561484e1 1885e168 86e1a866 e1e8761c     ...Vh...f....v..
   2e708:	28862087 962488e2 2889e268 83a2a8a6     . .(..$.h..(....
   2e718:	c0374008 00d1fd00 d6348ac0 388de368     .@7.......4.h..8
   2e728:	8ee3a8e6 e3e8f63c 2906408f 4e4490e4     ....<....@.)..DN
   2e738:	0d018008 0ce30008 e4580000 29465093     ..........X..PF)
   2e748:	565494e5 5895e569 96e5a966 8058b604     ..TVi..Xf.....X.
   2e758:	20064a01 965c8cc3 6899e669 9ae6a9a6     .J. ..\.i..h....
   2e768:	e6e9b66c c0100096 c6610240 789be640     l.......@.a.@..x
   2e778:	9ee7a9e6 e7e9f67c 08e6809f 30110280     ....|..........0
   2e788:	3098a600 a2e819dc e8ea368c 2a4690a3     ...0.....6....F*
   2e798:	60008fa9 050100a0 0c003034 e93a2801     ...`....40...(:.
   2e7a8:	2a86a0a7 96a4a8ea 150026fa a1813050     ...*.....&..P0..
   2e7b8:	a9d0ba4b 2ac6b0a9 d6b4aceb 0086ab6a     K......*....j...
   2e7c8:	02817058 6889d012 2adeaf0b 16c4b0ec     Xp.....h...*....
   2e7d8:	7bb1ec6b 01c0e002 ebe01010 2b22c10b     k..{.........."+
   2e7e8:	56d4b4ed b52eed6b c07b2a28 f00a9802     ...Vk...(*{.....
   2e7f8:	62d10b2b e4b8ee2b b56e6b96 6db03c00     +..b+....kn..<.m
   2e808:	10aedfb7 c6f0b9ee f4bcef2b baee9a02     ........+.......
   2e818:	425b7805 003b0008                       .x[B..;.

0002e820 <data_img_bgMiddle_gif>:
   2e820:	676d692f 4d67622f 6c646469 69672e65     /img/bgMiddle.gi
   2e830:	49470066 61393846 000103e0 bb0000e6     f.GIF89a........
   2e840:	f9f9eed9 006ffff9 e5edd8ba c4a9e5e5     ......o.........
   2e850:	dac7acd7 b6e4d0b3 d6b9e7d3 decbafeb     ................
   2e860:	fbfafafa fcfcfbfb fdfdfdfc fffefefe     ................
   2e870:	0000ffff 00000000 00000000 00000000     ................
	...
   2e9bc:	21000000 000004f9 2c000000 00000000     ...!.......,....
   2e9cc:	000103e0 803e0700 84838200 88100203     ......>.........
   2e9dc:	8c8b8a89 908f8e8d 94939291 98979695     ................
   2e9ec:	9c9b9a99 a09f9e9d a4a3a2a1 a8a7a6a5     ................
   2e9fc:	acabaaa9 b0afaead 05029bb1 08070a06     ................
   2ea0c:	00840309 003b0081                       ......;.

0002ea14 <data_img_cloudLogo_png>:
   2ea14:	676d692f 6f6c632f 6f4c6475 702e6f67     /img/cloudLogo.p
   2ea24:	8900676e 0d474e50 000a1a0a 490d0000     ng..PNG........I
   2ea34:	00524448 00800000 08800000 00000006     HDR.............
   2ea44:	cb613ec3 06000000 44474b62 ff00ff00     .>a.....bKGD....
   2ea54:	bda0ff00 000093a7 4449270b da785441     .........'IDATx.
   2ea64:	6c7f9ded c715575b 96b6576f 6c295d76     ...l[W..oW..v])l
   2ea74:	87ec06dd a31f8c06 31b07594 60306c7e     .........u.1~l0`
   2ea84:	b6843608 1543ad31 6a8240ea a0636d08     .6..1.C..@.j.mc.
   2ea94:	651b426d 6915b18c 61428bfd 26849b2b     mB.e...i..Ba+..&
   2eaa4:	e38ad816 6aac2824 8cd35d60 7bf6c486     ....$(.j`].....{
   2eab4:	24e271cf 49c76276 ddb1389c cb8ff7e6     .q.$vb.I.8......
   2eac4:	ae024e39 73f3ef73 9efcf7ed 91d23e7d     9N..s..s....}>..
   2ead4:	cfcfc3fb eef3df7e bdce738f 2082318f     ....~....s...1. 
   2eae4:	08208208 82082082 20820820 08208208     .. .. .. .. .. .
   2eaf4:	82082082 20820820 b5e1cb08 89ac0b8c     . .. .. ........
   2eb04:	00390cae 38400e41 db174847 39677604     ..9.A.@8GH...vg9
   2eb14:	d9bb801c dbee7085 08728548 06dec4df     .....p..H.r.....
   2eb24:	1001ff17 c8b6012d b06ec6ff d96a01dc     ....-.....n...j.
   2eb34:	dce399f3 46ec05ac bbbac552 f0b836fe     .......FR....6..
   2eb44:	4ef11c81 58d6ce70 f82000e5 85fef0f5     ...Np..X.. .....
   2eb54:	e11763ac 2ec06adf 14cc8527 005d81bf     .c...j..'.....].
   2eb64:	285c7b17 b4ed8ba0 d96a01cc f19f253f     .{\(......j.?%..
   2eb74:	fcc9523b 250fdc01 1d107f17 80076cc4     ;R.....%.....l..
   2eb84:	c25bfcbb c92cdde3 495b635f 7ffa2b21     ..[...,._c[I!+..
   2eb94:	4449f337 0e99a5fc f9d86bc0 e4a8bef0     7.ID.....k......
   2eba4:	3a931ff8 9b813956 c222517d 07dffc0c     ...:V9..}Q".....
   2ebb4:	5a80734c d8e494f6 79c73800 5db58ca4     Ls.Z.....8.y...]
   2ebc4:	8c448341 b63de73f ebc55d8e baf025d9     A.D.?.=..]...%..
   2ebd4:	8b8dba05 a357cfe0 cbba71e5 2427b3e1     ......W..q....'$
   2ebe4:	a41dffcd 700ed588 2e0fbd98 9044b4fe     .......p......D.
   2ebf4:	7d984d5b b87126bc 7ca35206 817ec0ad     [M.}.&q..R.|..~.
   2ec04:	d620f520 0f3d25b5 a9c1314c 1d9f047e      . ..%=.L1..~...
   2ec14:	1cd739cf 91b620c4 056be512 ca2591de     .9... ....k...%.
   2ec24:	afd26809 387cf533 bdb17408 d2c6b199     .h..3.|8.t......
   2ec34:	2a437f39 78407f94 41c08e1f 9d96b59c     9.C*..@x...A....
   2ec44:	147d8eb3 d308d9ce 029177be 7763eba5     ..}......w....cw
   2ec54:	94fd45c2 3ac7d3a9 987039f6 7dae703d     .E.....:.9p.=p.}
   2ec64:	9943ae70 bd8b9de8 07f7fcb4 8de66ec1     p.C..........n..
   2ec74:	bf55a36c f3b4d359 ad769a3d 92ffe7cf     l.U.Y...=.v.....
   2ec84:	f1ee5147 a1efb4f9 ffd9fd2d f7cf9f35     GQ......-...5...
   2ec94:	b83060a1 bfc41aae 2a7e2e18 b1755213     .`0.......~*.Ru.
   2eca4:	fcc8c13f bd1325bd 338edd96 e7cfe583     ?....%.....3....
   2ecb4:	ec1e6c06 df3e99df ca5ddec5 7af5e9df     .l....>...]....z
   2ecc4:	f5557a37 1da2af5e 07aa28f0 8abde75e     7zU.^....(..^...
   2ecd4:	22d8f3ca a7c7bb58 710e0b3e 9cfce733     ..."X...>..q3...
   2ece4:	fdcc1c4a 9c044721 22013d6e cfab386c     J...!G..n=."l8..
   2ecf4:	81cecbdb 058377e3 772e8a0d 7ac87406     .....w.....w.t.z
   2ed04:	bf314576 9be6ee0f 043eaee0 080da642     vE1.......>.B...
   2ed14:	753e6fae 7b7f6c00 9595c77b c8ef87d2     .o>u.l.{{.......
   2ed24:	5b64ac49 05bdd83f 3e967a25 c29164ef     I.d[?...%z.>.d..
   2ed34:	2674dae7 4a2d0408 5dadbf21 53ee3ed3     ..t&..-J!..].>.S
   2ed44:	45a2a6d4 382cdb17 8f1e8bc2 15ce3de7     ...E..,8.....=..
   2ed54:	2e57a71f 015e46f6 bc38ecdc 67c0d27e     ..W..F^...8.~..g
   2ed64:	42359c3d 34dec337 df413dd2 e7104efe     =.5B7..4.=A..N..
   2ed74:	f89b06f7 2c1c0ca2 fdcadd05 71ac35d0     .......,.....5.q
   2ed84:	c8c0039e 261a233d c7348c52 3f1d6892     ....=#.&R.4..h.?
   2ed94:	0ccdcec8 3e13cce6 aec086db 6826fd91     .......>......&h
   2eda4:	61056fea 7e16cd86 602729b5 3395708c     .o.a...~.)'`.p.3
   2edb4:	c70c025b cb83b2d6 2b593003 d03a4070     [........0Y+p@:.
   2edc4:	cee94793 0a60a3b4 14582f58 08360e2c     .G....`.X/X.,.6.
   2edd4:	00160fd6 306b016b 387104e4 0d56c7e7     ....k.k0..q8..V.
   2ede4:	27e514f2 a19cc620 78d5573b 8f0f7757     ...' ...;W.xWw..
   2edf4:	7c780744 278f8464 4c993c93 13475e65     D.x|d..'.<.Le^G.
   2ee04:	34383e09 fbfafbc4 59d03fb9 71681380     .>84.....?.Y..hq
   2ee14:	ed3e5145 76c0f1e4 2e08ca4c ea965478     EQ>....vL...xT..
   2ee24:	73200c15 93f3871d 6960c360 eb049603     .. s....`.`i....
   2ee34:	d7923b04 67b30609 7ff17009 eea4446d     .;.....g.p..mD..
   2ee44:	3e3e5e9e 0b0be49e 3328dc0b 387c3333     .^>>......(333|8
   2ee54:	9d1de71e 611c465d 5f92a602 e0acfa75     ....]F.a..._u...
   2ee64:	2c9eb02e a648f711 4574bb8f f080563a     ...,..H...tE:V..
   2ee74:	530296b9 9d74eac1 80b319a0 f953fe20     ...S..t..... .S.
   2ee84:	8509e984 a7d3a9f8 2e2c3179 f1b1f22e     ........y1,.....
   2ee94:	308e2371 5bb4d5ed 4d04ed9c ff083d6c     q#.0...[...Ml=..
   2eea4:	45645c28 bbc56a94 d0ec774f ba622cb6     (\dE.j..Ow...,b.
   2eeb4:	35818b48 d2209dca 3d11e4fc 077f3431     H..5.. ....=14..
   2eec4:	bc52a64f 6023a094 88dd808b 8310e0de     O.R...#`........
   2eed4:	269fce4c e0bc424a 8a917f00 f84094af     L..&JB........@.
   2eee4:	c2b1c36c e79f563f 7075e374 1152bda1     l...?V..t.up..R.
   2eef4:	3e3ee142 cdc73737 12727262 319d035a     B.>>77..brr.Z..1
   2ef04:	6086aa82 12a5b860 323bffe3 f8914351     ...``.....;2QC..
   2ef14:	fc58956f b3381b15 dbab983b a39efdc2     o.X...8.;.......
   2ef24:	1fdf8bd2 54ee6689 eb0741b3 bf4b760a     .....f.T.A...vK.
   2ef34:	0e4acc07 f0e46257 aff8a115 d2e20f2f     ..J.Wb....../...
   2ef44:	ffc75926 d96e15cf 1a3f172f 3f3256e5     &Y....n./.?..V2?
   2ef54:	bb3bcf3f 704e7a82 fddd2567 0acd8217     ?.;..zNpg%......
   2ef64:	44d7a01d 860657f1 689c9530 d8bd2edc     ...D.W..0..h....
   2ef74:	2f30e1bd b3b3b307 c808eb5c b9b857be     ..0/....\....W..
   2ef84:	95edf9b9 2d5dfe94 e2c9937e e30f58af     ......]-~....X..
   2ef94:	092faddd 041fb42f cfcfb330 4a7d3a47     .././...0...G:}J
   2efa4:	a9f4283e f34a550f 01d0b2ff 7b17a502     >(...UJ........{
   2efb4:	4f2b6c76 13c4df0f 78f26fb1 a87cbbe4     vl+O.....o.x..|.
   2efc4:	f48f0f7f 917a5cfe c53a9d4f 96060dcb     .....\z.O.:.....
   2efd4:	50a44964 12beb428 7424201c 88d29180     dI.P(.... $t....
   2efe4:	9db2313e e31f840f 058d1d1d c4716285     >1...........bq.
   2eff4:	3c70076f 53d4c2a0 55d81632 22b1017e     o.p<...S2..U~.."
   2f004:	933d96b7 ebecdcd7 837fe682 b4787330     ..=.........0sx.
   2f014:	5317d138 e06278eb f9d9de6e e2c759ea     8..S.xb.n....Y..
   2f024:	b8a6a727 8118c05d c4785a64 e7f87d0e     '...]...dZx..}..
   2f034:	ddedc50d f38169ec def8587c f1dc45e3     .....i..|X...E..
   2f044:	2078dba3 112a2ee0 730a1bd3 80ad813b     ..x ..*....s;...
   2f054:	cda44838 5db5b5b7 a8070ce4 8e088f65     8H.....]....e...
   2f064:	def85ebd 5f85c2d6 91e7ad48 8b30cff0     .^....._H.....0.
   2f074:	0e267456 a376fb63 6b223faf c53a7605     Vt&.c.v..?"k.v:.
   2f084:	44141e01 7c233eff e2a17b6f c13de46f     ...D.>#|o{..o.=.
   2f094:	c54b2543 2fe47396 92529d03 33adfc31     C%K..s./..R.1..3
   2f0a4:	1ec5c01c d42c755f 7bdf0be0 f3f8b8d2     ...._u,....{....
   2f0b4:	d83ccdc9 6121b2f9 94b75a71 5ffd1dae     ..<...!aqZ....._
   2f0c4:	319316ba 81f7f023 42778c58 29082e04     ...1#...X.wB...)
   2f0d4:	71823b5d 34038901 f601c53b 32e01c09     ];.q...4;......2
   2f0e4:	34df7be1 e06fe77a cd7f9d5d d147a79b     .{.4z.o.].....G.
   2f0f4:	6ece2027 57633134 84a18124 44c84bb3     ' .n41cW$....K.D
   2f104:	c60dbdd5 67afa01c 0e60fe9f d35378a2     .......g..`..xS.
   2f114:	e852bcd3 fe15edee f06096ce 013ae702     ..R.......`...:.
   2f124:	6a22c96e e2fa6205 75bba3c7 6244faef     n."j.b.....u..Db
   2f134:	b21a578c 0d542081 0764e65d 81d0b678     .W... T.].d.x...
   2f144:	25d8ece0 c47ff220 f3f34317 78220db4     ...% ....C...."x
   2f154:	db054656 4e23ed34 851b8076 c0dd800e     VF..4.#Nv.......
   2f164:	2201d898 9a8ebda1 4c0a95c2 82230b49     ...".......LI.#.
   2f174:	d6d1ed3e 9d73d6d6 8b4b00e9 4e857a3e     >.....s...K.>z.N
   2f184:	fe2d5be0 7015d8f4 368b8bf7 bc438362     .[-....p...6b.C.
   2f194:	f5f50992 ba798de9 05faaa3d 1e03e6a7     ......y.=.......
   2f1a4:	0e801692 d100e99c 0bc213f0 76757580     .............uuv
   2f1b4:	0297c11e 5be6a29c d553e676 b96e395f     .......[v.S._9n.
   2f1c4:	6d899419 5fd5ac16 4de6ac32 92fb4f2c     ...m..._2..M,O..
   2f1d4:	b5aab8eb bfd35d54 8c6f8e02 6ab03bc4     ....T]....o..;.j
   2f1e4:	425d96c8 6488e166 7d883fcd fffd6ebf     ..]Bf..d.?.}.n..
   2f1f4:	f8e9e328 383f8567 9533d500 3003e60e     (...g.?8..3....0
   2f204:	2453a943 ae221b92 904b55b1 62edaa59     C.S$.."..UK.Y..b
   2f214:	c69af0ed 73a1202a 892d52e0 7d1d4c13     ....* .s.R-..L.}
   2f224:	bc0eef3f 83b1fc28 9abcc343 e8d1e2c0     ?...(...C.......
   2f234:	8b6f2c40 cb902b80 7661fc2f f7e2a0a5     @,o..+../.av....
   2f244:	737be919 ad9c8e36 f5ea18bf 0802839e     ..{s6...........
   2f254:	6b753c9f 6957ca30 66cccccc 637a9732     .<uk0.Wi...f2.zc
   2f264:	6e0ee802 b0f08f2f ff080331 4a71100b     ...n/...1.....qJ
   2f274:	c24f4770 d2507dff b2b2dc52 74d13420     pGO..}P.R... 4.t
   2f284:	6fbc5707 16397ae9 383b544b 4f59d1fb     .W.o.z9.KT;8..YO
   2f294:	c0f18310 5f84eb06 4bbbd55a ecc60367     ......._Z..Kg...
   2f2a4:	256b3855 867b81b1 c160fd8e d7675f48     U8k%..{...`.H_g.
   2f2b4:	60d58de4 d0b3a837 c46b01f4 f9d85a5f     ...`7.....k._Z..
   2f2c4:	9102c186 7655fce3 e073e8a9 70d4ff0b     ......Uv..s....p
   2f2d4:	4c3846f1 09c4afea 8138b2c2 6b6cb516     .F8L......8...lk
   2f2e4:	79fde59a 16ef84f4 00ad8795 01bf210b     ...y.........!..
   2f2f4:	eef75a5f 5c799ac7 dca98b6d 6e951b29     _Z....y\m...)..n
   2f304:	20a661d9 59841fab 72adb7c1 70204d80     .a. ...Y...r.M p
   2f314:	2a7e204c 58004cf3 163b2ffb 7acdaafa     L ~*.L.X./;....z
   2f324:	f851f16b 97f38d4a 5961a18a 5bd4a057     k.Q.J.....aYW..[
   2f334:	9ddbe539 41d349b3 0d9f7359 d39e5b4c     9....I.AYs..L[..
   2f344:	642dd2ab 32b57609 541fad27 0e0b2c27     ..-d.v.2'..T',..
   2f354:	4ff9e72d ba331d80 1b6663d9 949b4516     -..O..3..cf..E..
   2f364:	7a566915 ba8ad798 bfd7af01 0056bac3     .iVz..........V.
   2f374:	44866f37 7bf7d18f 5961ed14 6df61719     7o.D...{..aY...m
   2f384:	00ddf144 db6857ee 51f4007c e97d12ff     D....Wh.|..Q..}.
   2f394:	ec2c0ad1 d8c49b30 9396b398 9e7ff341     ..,.0.......A...
   2f3a4:	50c7f9a8 85fbf527 65a74a93 6dc7e1a1     ...P'....J.e...m
   2f3b4:	e9b000e9 2f3b36c1 581a72cf 01692cf1     .....6;/.r.X.,i.
   2f3c4:	f367b11e 54dffb0f 59878163 a4bbd960     ..g....Tc..Y`...
   2f3d4:	f6fbe872 bd550074 7185f44b 70a235bb     r...t.U.K..q.5.p
   2f3e4:	490b4370 6d97e8f1 b19800e9 e96f34a2     pC.I...m.....4o.
   2f3f4:	b40cd590 da97fdfa 41b80bb5 22fb85f4     ...........A..."
   2f404:	40b35211 493aeb70 db60203e 0872e029     .R.@p.:I> `.).r.
   2f414:	96d57178 14c9e06c 10512a00 b4be3608     xq..l....*Q..6..
   2f424:	7c205d75 8be89f41 308694e3 285fee06     u] |A......0.._(
   2f434:	b4d10c2d 00ee6c6b 04c2d3ca a4d82c10     -...kl.......,..
   2f444:	d33f2056 954e04b0 d4f98895 32bedbbf     V ?...N........2
   2f454:	b8e9e3d8 3b1db65a c1f5074d b67587bd     ....Z..;M.....u.
   2f464:	31c05d9b c3ca2396 82f68a7d 8f181b2c     .].1.#..}...,...
   2f474:	c45094d3 7e84c4c4 e73c30a5 03eb31c0     ..P....~.0<..1..
   2f484:	981969f0 98fd94b6 8eb76c30 d809e4eb     .i......0l......
   2f494:	b136002f 7a82b5c0 7c430bfb 081033a5     /.6....z..C|.3..
   2f4a4:	22d4726c 96ca7c11 e610355e 81d03007     lr.".|..^5...0..
   2f4b4:	dc762185 302cc3c9 dd4b8a23 430a0ab1     .!v...,0#.K....C
   2f4c4:	2fc2bae4 07ed98d9 82333a7e a13fd603     .../....~:3...?.
   2f4d4:	770c72a3 83f47716 c572b026 90af28a7     .r.w.w..&.r..(..
   2f4e4:	7e256798 04ffc40c ead03a73 8e8581ad     .g%~....s:......
   2f4f4:	44028a4f 85ab5264 656e1967 792c0495     O..DdR..g.ne..,y
   2f504:	08c40afe d7571214 74ec60ba 6a54ab37     ......W..`.t7.Tj
   2f514:	42d66a6a f03be8c2 f9e3ce74 c8abc64a     jj.B..;.t...J...
   2f524:	e78a6066 f1e3adc2 016ab0fa 6bc8389b     f`........j..8.k
   2f534:	450387df a11aefe8 3abd7875 6b43754c     ...E....ux.:LuCk
   2f544:	ddf847f8 8873e18f 8cb5b1f1 20820820     .G....s..... .. 
   2f554:	08208208 82082082 20820820 08208208     .. .. .. .. .. .
   2f564:	82082082 20820820 08208208 82082082     . .. .. .. .. ..
   2f574:	20820820 08208208 82082082 e62a8820      .. .. .. .. .*.
   2f584:	895abebf 41b31893 000000f5 4e454900     ..Z....A.....IEN
   2f594:	6042ae44 00000082                       D.B`....

0002f59c <data_img_tab_gif>:
   2f59c:	676d692f 6261742f 6669672e 46494700     /img/tab.gif.GIF
   2f5ac:	01613938 91002200 6fff0000 eed9bb00     89a..".....o....
   2f5bc:	00f8f1e7 f9210000 00000004 002c0000     ......!.......,.
   2f5cc:	01000000 00002200 1f8c0802 6bedcba2     .....".........k
   2f5dc:	3b000140 00000000                       @..;....

0002f5e4 <data_img_tabActive_gif>:
   2f5e4:	676d692f 6261742f 69746341 672e6576     /img/tabActive.g
   2f5f4:	47006669 39384649 22000161 00008000     if.GIF89a.."....
   2f604:	ff006fff f921ffff 00000004 002c0000     .o....!.......,.
   2f614:	01000000 00002200 8e440502 005acba9     ....."....D...Z.
   2f624:	0000003b                                ;...

0002f628 <data_img_tabActLeft_gif>:
   2f628:	676d692f 6261742f 4c746341 2e746665     /img/tabActLeft.
   2f638:	00666967 38464947 00046139 00910022     gif.GIF89a.."...
   2f648:	629be300 ffeed9bb ffff006f 04f921ff     ...b....o....!..
   2f658:	00000000 00002c00 00040000 02000022     .....,......"...
   2f668:	20118c1a 9ea33212 5b4c6f93 7a9cceaf     ... .2...oL[...z
   2f678:	07616dfc 9e49a296 0000556a 0000003b     .ma...I.jU..;...

0002f688 <data_img_tabActRight_gif>:
   2f688:	676d692f 6261742f 52746341 74686769     /img/tabActRight
   2f698:	6669672e 46494700 04613938 91002200     .gif.GIF89a.."..
   2f6a8:	9be30000 eed9bb62 ff006fff f921ffff     ....b....o....!.
   2f6b8:	00000004 002c0000 04000000 00002200     ......,......"..
   2f6c8:	2e441802 ac123362 5a829358 bade2778     ..D.b3..X..Zx'..
   2f6d8:	5979fe57 78268e48 3b00057a 00000000     W.yYH.&xz..;....

0002f6e8 <data_img_tabLeft_gif>:
   2f6e8:	676d692f 6261742f 7466654c 6669672e     /img/tabLeft.gif
   2f6f8:	46494700 03613938 91002200 6fff0000     .GIF89a..".....o
   2f708:	eed9bb00 00f8f1e7 f9210000 00000004     ..........!.....
   2f718:	002c0000 03000000 00002200 8f8c0e02     ..,......"......
   2f728:	0d1228a9 dab49ca3 05d8158b 00003b00     .(...........;..

0002f738 <data_img_tabRight_gif>:
   2f738:	676d692f 6261742f 68676952 69672e74     /img/tabRight.gi
   2f748:	49470066 61393846 00220003 ff000091     f.GIF89a..".....
   2f758:	d9bb006f f8f1e7ee 21000000 000004f9     o..........!....
   2f768:	2c000000 00000000 00220003 8c0f0200     ...,......".....
   2f778:	1227a98f b49c9afd 55f38bda 3b0017a0     ..'........U...;
   2f788:	00000000                                ....

0002f78c <file_404_html>:
   2f78c:	00000000 0001d3b8 0001d3c2 000000ac     ................
   2f79c:	00000000                                ....

0002f7a0 <file_control_shtml>:
   2f7a0:	0002f78c 0001d470 0001d47f 00000679     ....p.......y...
   2f7b0:	00000000                                ....

0002f7b4 <file_dashboard_shtml>:
   2f7b4:	0002f7a0 0001daf8 0001db09 00004fce     .............O..
   2f7c4:	00000000                                ....

0002f7c8 <file_index_html>:
   2f7c8:	0002f7b4 00022ad8 00022ae4 00001747     .....*...*..G...
   2f7d8:	00000000                                ....

0002f7dc <file_sensordata_shtml>:
   2f7dc:	0002f7c8 0002422c 0002423e 00000013     ....,B..>B......
   2f7ec:	00000000                                ....

0002f7f0 <file_smoothie_min_js>:
   2f7f0:	0002f7dc 00024254 00024265 00002bdc     ....TB..eB...+..
   2f800:	00000000                                ....

0002f804 <file_stats_shtml>:
   2f804:	0002f7f0 00026e44 00026e51 00000958     ....Dn..Qn..X...
   2f814:	00000000                                ....

0002f818 <file_tcp_shtml>:
   2f818:	0002f804 000277ac 000277b7 00000657     .....w...w..W...
   2f828:	00000000                                ....

0002f82c <file_css_styles_css>:
   2f82c:	0002f818 00027e10 00027e20 0000629e     .....~.. ~...b..
   2f83c:	00000000                                ....

0002f840 <file_img_bgFooter_gif>:
   2f840:	0002f82c 0002e0c0 0002e0d2 00000387     ,...............
   2f850:	00000000                                ....

0002f854 <file_img_bgHeader_gif>:
   2f854:	0002f840 0002e45c 0002e46e 000003b2     @...\...n.......
   2f864:	00000000                                ....

0002f868 <file_img_bgMiddle_gif>:
   2f868:	0002f854 0002e820 0002e832 000001e2     T... ...2.......
   2f878:	00000000                                ....

0002f87c <file_img_cloudLogo_png>:
   2f87c:	0002f868 0002ea14 0002ea27 00000b73     h.......'...s...
   2f88c:	00000000                                ....

0002f890 <file_img_tab_gif>:
   2f890:	0002f87c 0002f59c 0002f5a9 00000038     |...........8...
   2f8a0:	00000000                                ....

0002f8a4 <file_img_tabActive_gif>:
   2f8a4:	0002f890 0002f5e4 0002f5f7 0000002f     ............/...
   2f8b4:	00000000                                ....

0002f8b8 <file_img_tabActLeft_gif>:
   2f8b8:	0002f8a4 0002f628 0002f63c 0000004a     ....(...<...J...
   2f8c8:	00000000                                ....

0002f8cc <file_img_tabActRight_gif>:
   2f8cc:	0002f8b8 0002f688 0002f69d 00000048     ............H...
   2f8dc:	00000000                                ....

0002f8e0 <file_img_tabLeft_gif>:
   2f8e0:	0002f8cc 0002f6e8 0002f6f9 0000003e     ............>...
   2f8f0:	00000000                                ....

0002f8f4 <file_img_tabRight_gif>:
   2f8f4:	0002f8e0 0002f738 0002f74a 0000003f     ....8...J...?...
   2f904:	00000000 454c4449 00000000 09632509     ....IDLE.....%c.
   2f914:	25097525 75250975 00000a0d 09752509     %u.%u.%u.....%u.
   2f924:	25752509 000a0d25 09752509 25313c09     .%u%%....%u..<1%
   2f934:	000a0d25 20726d54 00637653              %...Tmr Svc.

0002f940 <heapSTRUCT_SIZE>:
   2f940:	00000008                                ....

0002f944 <pcInterruptPriorityRegisters>:
   2f944:	e000e3f0                                ....

0002f948 <_global_impure_ptr>:
   2f948:	20000110 00000043                       ... C...

0002f950 <blanks.3595>:
   2f950:	20202020 20202020 20202020 20202020                     

0002f960 <zeroes.3596>:
   2f960:	30303030 30303030 30303030 30303030     0000000000000000
   2f970:	33323130 37363534 42413938 46454443     0123456789ABCDEF
   2f980:	00000000 00464e49 00666e69 004e414e     ....INF.inf.NAN.
   2f990:	006e616e 33323130 37363534 62613938     nan.0123456789ab
   2f9a0:	66656463 00000000 6c756e28 0000296c     cdef....(null)..
   2f9b0:	00000030 69666e49 7974696e 00000000     0...Infinity....
   2f9c0:	004e614e                                NaN.

0002f9c4 <charset>:
   2f9c4:	0002f9fc                                ....

0002f9c8 <lconv>:
   2f9c8:	0002f9f8 0002f980 0002f980 0002f980     ................
   2f9d8:	0002f980 0002f980 0002f980 0002f980     ................
   2f9e8:	0002f980 0002f980 ffffffff ffffffff     ................
   2f9f8:	0000002e 2d4f5349 39353838 0000312d     ....ISO-8859-1..

0002fa08 <__mprec_tens>:
   2fa08:	00000000 3ff00000 00000000 40240000     .......?......$@
   2fa18:	00000000 40590000 00000000 408f4000     ......Y@.....@.@
   2fa28:	00000000 40c38800 00000000 40f86a00     .......@.....j.@
   2fa38:	00000000 412e8480 00000000 416312d0     .......A......cA
   2fa48:	00000000 4197d784 00000000 41cdcd65     .......A....e..A
   2fa58:	20000000 4202a05f e8000000 42374876     ... _..B....vH7B
   2fa68:	a2000000 426d1a94 e5400000 42a2309c     ......mB..@..0.B
   2fa78:	1e900000 42d6bcc4 26340000 430c6bf5     .......B..4&.k.C
   2fa88:	37e08000 4341c379 85d8a000 43763457     ...7y.AC....W4vC
   2fa98:	674ec800 43abc16d 60913d00 43e158e4     ..Ngm..C.=.`.X.C
   2faa8:	78b58c40 4415af1d d6e2ef50 444b1ae4     @..x...DP.....KD
   2fab8:	064dd592 4480f0cf c7e14af6 44b52d02     ..M....D.J...-.D
   2fac8:	79d99db4 44ea7843                       ...yCx.D

0002fad0 <p05.2463>:
   2fad0:	00000005 00000019 0000007d 00000000     ........}.......

0002fae0 <__mprec_bigtens>:
   2fae0:	37e08000 4341c379 b5056e17 4693b8b5     ...7y.AC.n.....F
   2faf0:	e93ff9f5 4d384f03 f9301d32 5a827748     ..?..O8M2.0.Hw.Z
   2fb00:	7f73bf3c 75154fdd                       <.s..O.u

0002fb08 <__mprec_tinytens>:
   2fb08:	97d889bc 3c9cd2b2 d5a8a733 3949f623     .......<3...#.I9
   2fb18:	44f4a73d 32a50ffd cf8c979d 255bba08     =..D...2......[%
   2fb28:	64ac6f43 0ac80628 00776f70 00000000     Co.d(...pow.....

0002fb38 <bp>:
   2fb38:	00000000 3ff00000 00000000 3ff80000     .......?.......?

0002fb48 <dp_l>:
	...
   2fb50:	43cfd006 3e4cfdeb                       ...C..L>

0002fb58 <dp_h>:
	...
   2fb60:	40000000 3fe2b803                       ...@...?

0002fb68 <TWO52>:
   2fb68:	00000000 43300000 00000000 c3300000     ......0C......0.

0002fb78 <_init>:
   2fb78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2fb7a:	bf00      	nop
   2fb7c:	bcf8      	pop	{r3, r4, r5, r6, r7}
   2fb7e:	bc08      	pop	{r3}
   2fb80:	469e      	mov	lr, r3
   2fb82:	4770      	bx	lr

0002fb84 <_fini>:
   2fb84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2fb86:	bf00      	nop
   2fb88:	bcf8      	pop	{r3, r4, r5, r6, r7}
   2fb8a:	bc08      	pop	{r3}
   2fb8c:	469e      	mov	lr, r3
   2fb8e:	4770      	bx	lr

0002fb90 <__frame_dummy_init_array_entry>:
   2fb90:	0485 0000                                   ....

0002fb94 <__do_global_dtors_aux_fini_array_entry>:
   2fb94:	0471 0000                                   q...
